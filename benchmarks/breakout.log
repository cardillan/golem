   147 instructions before optimizations.
     8 instructions eliminated by Temp Variables Elimination (6 iterations).
    20 instructions eliminated by Dead Code Elimination (7 iterations).
     2 instructions eliminated by Jump Normalization (6 iterations).
     6 instructions eliminated by Condition Optimization (2 passes, 8 iterations).
     8 instructions eliminated by Single Step Elimination (7 iterations).
     2 instructions eliminated by Expression Optimization (3 iterations).
    38 instructions eliminated by Data Flow Optimization (4 passes, 14 iterations).
     3 instructions eliminated by Loop Rotation (3 iterations).
       3 loop conditions were fully rotated.
   126 instructions added by Loop Unrolling (6 iterations).
     3 loops unrolled by Loop Unrolling.
     1 instructions eliminated by Jump Straightening (7 iterations).
     2 instructions updated by Jump Threading.
     2 instructions eliminated by Unreachable Code Elimination (2 passes, 3 iterations).
   183 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 903):
    Unroll loop at line 40:5                                     size    +2, benefit     7500.0, efficiency   3750.000
    Unroll loop at line 81:9                                     size   +25, benefit    62500.0, efficiency   2500.000
  * Unroll loop at line 82:13                                    size   +47, benefit  2343750.0, efficiency  49867.021 (+38 instructions)

Pass 1: speed optimization selection (cost limit 865):
  * Unroll loop at line 40:5                                     size    +2, benefit     7500.0, efficiency   3750.000 (+2 instructions)
    Unroll loop at line 81:9                                     size   +63, benefit    62500.0, efficiency    992.063

Pass 1: speed optimization selection (cost limit 863):
  * Unroll loop at line 81:9                                     size   +63, benefit    62500.0, efficiency    992.063 (+50 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-12 instructions):
 
    41 label *label11
    42 set *tmp12 null
    43 label *label12
-    * set *tmp9 *tmp12
    44 jump *label10 always
    45 label *label9
    46 op greaterThan *tmp13 :paddleX 0
 
    51 label *label13
    52 set *tmp14 null
    53 label *label14
-    * set *tmp9 *tmp14
    54 label *label10
    55 op add :ballX :ballX :ballVX
    56 op add :ballY :ballY :ballVY
 
    63 op lor *tmp19 *tmp17 *tmp18
    64 jump *label15 equal *tmp19 false
    65 op mul :ballVX :ballVX -1
-    * set *tmp20 :ballVX
    66 jump *label16 always
    67 label *label15
-    * set *tmp20 null
    68 label *label16
    69 op greaterThan *tmp21 :ballYEnd 176
    70 jump *label17 equal *tmp21 false
    71 op mul :ballVY :ballVY -1
-    * set *tmp22 :ballVY
    72 jump *label18 always
    73 label *label17
-    * set *tmp22 null
    74 label *label18
    75 op greaterThan *tmp23 :ballXEnd :paddleX
    76 op add *tmp24 :paddleX :paddleWidth
 
    89 op div *tmp36 *tmp35 10
    90 op add :ballVX :ballVX *tmp36
    91 op sub :paddleWidth :paddleWidth 1
-    * set *tmp31 :paddleWidth
    92 jump *label20 always
    93 label *label19
-    * set *tmp31 null
    94 label *label20
    95 set :brickPtr 0
    96 set :y 126
 
   137 label *label29
   138 set *tmp51 null
   139 label *label30
-    * set *tmp41 *tmp51
   140 jump *label28 always
   141 label *label27
-    * set *tmp41 null
   142 label *label28
   143 op add :brickPtr :brickPtr 1
   144 label *label25
 
   154 op lor *tmp62 *tmp60 *tmp61
   155 jump *label33 equal *tmp62 false
   156 jump *label8 always
-    * set *tmp63 null
   157 jump *label34 always
   158 label *label33
-    * set *tmp63 null
   159 label *label34
   160 drawflush DISPLAY
   161 label *label7

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-6 instructions):
 
    36 op lessThan *tmp11 :paddleX *tmp10
    37 jump *label11 equal *tmp11 false
    38 op add :paddleX :paddleX 3
-    * set *tmp12 :paddleX
    39 jump *label12 always
    40 label *label11
-    * set *tmp12 null
    41 label *label12
    42 jump *label10 always
    43 label *label9
    44 op greaterThan *tmp13 :paddleX 0
    45 jump *label13 equal *tmp13 false
    46 op sub :paddleX :paddleX 3
-    * set *tmp14 :paddleX
    47 jump *label14 always
    48 label *label13
-    * set *tmp14 null
    49 label *label14
    50 label *label10
    51 op add :ballX :ballX :ballVX
 
   128 op mul :ballVX :ballVX -1
   129 set *tmp59 :ballVX
   130 label *label32
-    * set *tmp51 *tmp59
   131 jump *label30 always
   132 label *label29
-    * set *tmp51 null
   133 label *label30
   134 jump *label28 always
   135 label *label27

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
   122 op land *tmp58 *tmp55 *tmp57
   123 jump *label31 equal *tmp58 false
   124 op mul :ballVY :ballVY -1
-    * set *tmp59 :ballVY
   125 jump *label32 always
   126 label *label31
   127 op mul :ballVX :ballVX -1
-    * set *tmp59 :ballVX
   128 label *label32
   129 jump *label30 always
   130 label *label29

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-8 instructions):
 
     5 jump *label2 equal true false
     6 set :paddleWidth 40
     7 op div *tmp0 :paddleWidth 2
-    * op sub *tmp1 88 *tmp0
-    * set :paddleX *tmp1
+    8 op sub :paddleX 88 *tmp0
     9 set :ballX 88
    10 set :ballY 88
    11 op rand *tmp2 10
-    * op sub *tmp3 *tmp2 5
-    * set :ballVX *tmp3
+   12 op sub :ballVX *tmp2 5
    13 op rand *tmp4 10
-    * op sub *tmp5 *tmp4 5
-    * set :ballVY *tmp5
+   14 op sub :ballVY *tmp4 5
    15 set :brickCount 6
    16 set :i 0
    17 label *label3
    18 jump *label5 greaterThanEq :i 6
-    * set *tmp6 :i
-    * write 1 BRICKS *tmp6
+   19 write 1 BRICKS :i
    20 label *label4
    21 op add :i :i 1
    22 jump *label3 always
 
    46 label *label10
    47 op add :ballX :ballX :ballVX
    48 op add :ballY :ballY :ballVY
-    * op add *tmp15 :ballX 5
-    * set :ballXEnd *tmp15
-    * op add *tmp16 :ballY 5
-    * set :ballYEnd *tmp16
+   49 op add :ballXEnd :ballX 5
+   50 op add :ballYEnd :ballY 5
    51 op lessThan *tmp17 :ballX 0
    52 op greaterThan *tmp18 :ballXEnd 176
    53 op lor *tmp19 *tmp17 *tmp18
 
    91 label *label24
    92 op lessThan *tmp38 :x 176
    93 jump *label26 equal *tmp38 false
-    * set *tmp39 :brickPtr
-    * read *tmp40 BRICKS *tmp39
+   94 read *tmp40 BRICKS :brickPtr
    95 jump *label27 equal *tmp40 false
    96 draw rect :x :y 57.666666666666664 9
    97 op greaterThan *tmp42 :ballXEnd :x
 
   104 op lessThan *tmp49 :ballY *tmp48
   105 op land *tmp50 *tmp47 *tmp49
   106 jump *label29 equal *tmp50 false
-    * set *tmp52 :brickPtr
-    * write 0 BRICKS *tmp52
+  107 write 0 BRICKS :brickPtr
   108 op sub :brickCount :brickCount 1
   109 set :brickWidthPlusBallSizeMinus1 62.666666666666664
   110 op sub *tmp54 :x 4

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
     2 set PADDLECONTROLLER switch1
     3 draw color 255 255 255 255
     4 label *label0
-    * jump *label2 equal true false
     5 set :paddleWidth 40
     6 op div *tmp0 :paddleWidth 2
     7 op sub :paddleX 88 *tmp0
 
    21 jump *label3 always
    22 label *label5
    23 label *label6
-    * jump *label8 equal true false
    24 draw clear 0 0 0
    25 draw rect :paddleX 10 :paddleWidth 5
    26 draw rect :ballX :ballY 5 5

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-5 instructions):
 
    27 sensor *tmp8 PADDLECONTROLLER @enabled
    28 jump *label9 equal *tmp8 false
    29 op sub *tmp10 176 :paddleWidth
-    * op lessThan *tmp11 :paddleX *tmp10
-    * jump *label11 equal *tmp11 false
+   30 jump *label11 greaterThanEq :paddleX *tmp10
    31 op add :paddleX :paddleX 3
    32 jump *label12 always
    33 label *label11
    34 label *label12
    35 jump *label10 always
    36 label *label9
-    * op greaterThan *tmp13 :paddleX 0
-    * jump *label13 equal *tmp13 false
+   37 jump *label13 lessThanEq :paddleX 0
    38 op sub :paddleX :paddleX 3
    39 jump *label14 always
    40 label *label13
 
    52 jump *label16 always
    53 label *label15
    54 label *label16
-    * op greaterThan *tmp21 :ballYEnd 176
-    * jump *label17 equal *tmp21 false
+   55 jump *label17 lessThanEq :ballYEnd 176
    56 op mul :ballVY :ballVY -1
    57 jump *label18 always
    58 label *label17
 
    80 set :brickPtr 0
    81 set :y 126
    82 label *label21
-    * op greaterThan *tmp37 :y 106
-    * jump *label23 equal *tmp37 false
+   83 jump *label23 lessThanEq :y 106
    84 set :x 1
    85 label *label24
-    * op lessThan *tmp38 :x 176
-    * jump *label26 equal *tmp38 false
+   86 jump *label26 greaterThanEq :x 176
    87 read *tmp40 BRICKS :brickPtr
    88 jump *label27 equal *tmp40 false
    89 draw rect :x :y 57.666666666666664 9

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-8 instructions):
 
    29 op sub *tmp10 176 :paddleWidth
    30 jump *label11 greaterThanEq :paddleX *tmp10
    31 op add :paddleX :paddleX 3
-    * jump *label12 always
    32 label *label11
    33 label *label12
    34 jump *label10 always
    35 label *label9
    36 jump *label13 lessThanEq :paddleX 0
    37 op sub :paddleX :paddleX 3
-    * jump *label14 always
    38 label *label13
    39 label *label14
    40 label *label10
 
    47 op lor *tmp19 *tmp17 *tmp18
    48 jump *label15 equal *tmp19 false
    49 op mul :ballVX :ballVX -1
-    * jump *label16 always
    50 label *label15
    51 label *label16
    52 jump *label17 lessThanEq :ballYEnd 176
    53 op mul :ballVY :ballVY -1
-    * jump *label18 always
    54 label *label17
    55 label *label18
    56 op greaterThan *tmp23 :ballXEnd :paddleX
 
    70 op div *tmp36 *tmp35 10
    71 op add :ballVX :ballVX *tmp36
    72 op sub :paddleWidth :paddleWidth 1
-    * jump *label20 always
    73 label *label19
    74 label *label20
    75 set :brickPtr 0
 
   106 label *label31
   107 op mul :ballVX :ballVX -1
   108 label *label32
-    * jump *label30 always
   109 label *label29
   110 label *label30
-    * jump *label28 always
   111 label *label27
   112 label *label28
   113 op add :brickPtr :brickPtr 1
 
   124 op lor *tmp62 *tmp60 *tmp61
   125 jump *label33 equal *tmp62 false
   126 jump *label8 always
-    * jump *label34 always
   127 label *label33
   128 label *label34
   129 drawflush DISPLAY

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    44 op add :ballYEnd :ballY 5
    45 op lessThan *tmp17 :ballX 0
    46 op greaterThan *tmp18 :ballXEnd 176
-    * op lor *tmp19 *tmp17 *tmp18
+   47 op or *tmp19 *tmp17 *tmp18
    48 jump *label15 equal *tmp19 false
    49 op mul :ballVX :ballVX -1
    50 label *label15
 
   121 label *label23
   122 op lessThan *tmp60 :ballY 0
   123 op equal *tmp61 :brickCount 0
-    * op lor *tmp62 *tmp60 *tmp61
+  124 op or *tmp62 *tmp60 *tmp61
   125 jump *label33 equal *tmp62 false
   126 jump *label8 always
   127 label *label33

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 draw color 255 255 255 255
     4 label *label0
     5 set :paddleWidth 40
-    * op div *tmp0 :paddleWidth 2
-    * op sub :paddleX 88 *tmp0
+    6 op div *tmp0 40 2
+    7 op sub :paddleX 88 20
     8 set :ballX 88
     9 set :ballY 88
    10 op rand *tmp2 10
 
    97 set :brickWidthPlusBallSizeMinus1 62.666666666666664
    98 op sub *tmp54 :x 4
    99 op greaterThan *tmp55 :ballX *tmp54
-    * op add *tmp56 :x :brickWidthPlusBallSizeMinus1
+  100 op add *tmp56 :x 62.666666666666664
   101 op lessThan *tmp57 :ballX *tmp56
   102 op land *tmp58 *tmp55 *tmp57
   103 jump *label31 equal *tmp58 false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
     3 draw color 255 255 255 255
     4 label *label0
     5 set :paddleWidth 40
-    * op div *tmp0 40 2
     6 op sub :paddleX 88 20
     7 set :ballX 88
     8 set :ballY 88
 
    93 jump *label29 equal *tmp50 false
    94 write 0 BRICKS :brickPtr
    95 op sub :brickCount :brickCount 1
-    * set :brickWidthPlusBallSizeMinus1 62.666666666666664
    96 op sub *tmp54 :x 4
    97 op greaterThan *tmp55 :ballX *tmp54
    98 op add *tmp56 :x 62.666666666666664

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1 (-3 instructions):
 
    13 set :brickCount 6
    14 set :i 0
    15 label *label3
-    * jump *label5 greaterThanEq :i 6
+   16 label *label35
    17 write 1 BRICKS :i
    18 label *label4
    19 op add :i :i 1
-    * jump *label3 always
+   20 jump *label35 lessThan :i 6
    21 label *label5
    22 label *label6
    23 draw clear 0 0 0
 
    74 set :brickPtr 0
    75 set :y 126
    76 label *label21
-    * jump *label23 lessThanEq :y 106
+   77 label *label36
    78 set :x 1
    79 label *label24
-    * jump *label26 greaterThanEq :x 176
+   80 label *label37
    81 read *tmp40 BRICKS :brickPtr
    82 jump *label27 equal *tmp40 false
    83 draw rect :x :y 57.666666666666664 9
 
   111 op add :brickPtr :brickPtr 1
   112 label *label25
   113 op add :x :x 58.666666666666664
-    * jump *label24 always
+  114 jump *label37 lessThan :x 176
   115 label *label26
   116 label *label22
   117 op sub :y :y 10
-    * jump *label21 always
+  118 jump *label36 greaterThan :y 106
   119 label *label23
   120 op lessThan *tmp60 :ballY 0
   121 op equal *tmp61 :brickCount 0

Modifications by Unroll loop at line 82:13 (+51 instructions):
 
    75 set :y 126
    76 label *label21
    77 label *label36
-    * set :x 1
-    * label *label24
-    * label *label37
-    * read *tmp40 BRICKS :brickPtr
-    * jump *label27 equal *tmp40 false
-    * draw rect :x :y 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd :x
-    * op add *tmp43 :x 58.666666666666664
-    * op lessThan *tmp44 :ballX *tmp43
-    * op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
-    * op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
-    * op land *tmp50 *tmp47 *tmp49
-    * jump *label29 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
-    * op sub :brickCount :brickCount 1
-    * op sub *tmp54 :x 4
-    * op greaterThan *tmp55 :ballX *tmp54
-    * op add *tmp56 :x 62.666666666666664
-    * op lessThan *tmp57 :ballX *tmp56
-    * op land *tmp58 *tmp55 *tmp57
-    * jump *label31 equal *tmp58 false
-    * op mul :ballVY :ballVY -1
-    * jump *label32 always
-    * label *label31
-    * op mul :ballVX :ballVX -1
-    * label *label32
-    * label *label29
-    * label *label30
-    * label *label27
-    * label *label28
-    * op add :brickPtr :brickPtr 1
-    * label *label25
-    * op add :x :x 58.666666666666664
-    * jump *label37 lessThan :x 176
-    * label *label26
+   78 set :x 1
+   79 label *label38
+   80 label *label39
+   81 read *tmp40 BRICKS :brickPtr
+   82 jump *label44 equal *tmp40 false
+   83 draw rect :x :y 57.666666666666664 9
+   84 op greaterThan *tmp42 :ballXEnd :x
+   85 op add *tmp43 :x 58.666666666666664
+   86 op lessThan *tmp44 :ballX *tmp43
+   87 op land *tmp45 *tmp42 *tmp44
+   88 op greaterThan *tmp46 :ballYEnd :y
+   89 op land *tmp47 *tmp45 *tmp46
+   90 op add *tmp48 :y 10
+   91 op lessThan *tmp49 :ballY *tmp48
+   92 op land *tmp50 *tmp47 *tmp49
+   93 jump *label42 equal *tmp50 false
+   94 write 0 BRICKS :brickPtr
+   95 op sub :brickCount :brickCount 1
+   96 op sub *tmp54 :x 4
+   97 op greaterThan *tmp55 :ballX *tmp54
+   98 op add *tmp56 :x 62.666666666666664
+   99 op lessThan *tmp57 :ballX *tmp56
+  100 op land *tmp58 *tmp55 *tmp57
+  101 jump *label40 equal *tmp58 false
+  102 op mul :ballVY :ballVY -1
+  103 jump *label41 always
+  104 label *label40
+  105 op mul :ballVX :ballVX -1
+  106 label *label41
+  107 label *label42
+  108 label *label43
+  109 label *label44
+  110 label *label45
+  111 op add :brickPtr :brickPtr 1
+  112 label *label46
+  113 op add :x :x 58.666666666666664
+  114 read *tmp40 BRICKS :brickPtr
+  115 jump *label51 equal *tmp40 false
+  116 draw rect :x :y 57.666666666666664 9
+  117 op greaterThan *tmp42 :ballXEnd :x
+  118 op add *tmp43 :x 58.666666666666664
+  119 op lessThan *tmp44 :ballX *tmp43
+  120 op land *tmp45 *tmp42 *tmp44
+  121 op greaterThan *tmp46 :ballYEnd :y
+  122 op land *tmp47 *tmp45 *tmp46
+  123 op add *tmp48 :y 10
+  124 op lessThan *tmp49 :ballY *tmp48
+  125 op land *tmp50 *tmp47 *tmp49
+  126 jump *label49 equal *tmp50 false
+  127 write 0 BRICKS :brickPtr
+  128 op sub :brickCount :brickCount 1
+  129 op sub *tmp54 :x 4
+  130 op greaterThan *tmp55 :ballX *tmp54
+  131 op add *tmp56 :x 62.666666666666664
+  132 op lessThan *tmp57 :ballX *tmp56
+  133 op land *tmp58 *tmp55 *tmp57
+  134 jump *label47 equal *tmp58 false
+  135 op mul :ballVY :ballVY -1
+  136 jump *label48 always
+  137 label *label47
+  138 op mul :ballVX :ballVX -1
+  139 label *label48
+  140 label *label49
+  141 label *label50
+  142 label *label51
+  143 label *label52
+  144 op add :brickPtr :brickPtr 1
+  145 label *label53
+  146 op add :x :x 58.666666666666664
+  147 read *tmp40 BRICKS :brickPtr
+  148 jump *label58 equal *tmp40 false
+  149 draw rect :x :y 57.666666666666664 9
+  150 op greaterThan *tmp42 :ballXEnd :x
+  151 op add *tmp43 :x 58.666666666666664
+  152 op lessThan *tmp44 :ballX *tmp43
+  153 op land *tmp45 *tmp42 *tmp44
+  154 op greaterThan *tmp46 :ballYEnd :y
+  155 op land *tmp47 *tmp45 *tmp46
+  156 op add *tmp48 :y 10
+  157 op lessThan *tmp49 :ballY *tmp48
+  158 op land *tmp50 *tmp47 *tmp49
+  159 jump *label56 equal *tmp50 false
+  160 write 0 BRICKS :brickPtr
+  161 op sub :brickCount :brickCount 1
+  162 op sub *tmp54 :x 4
+  163 op greaterThan *tmp55 :ballX *tmp54
+  164 op add *tmp56 :x 62.666666666666664
+  165 op lessThan *tmp57 :ballX *tmp56
+  166 op land *tmp58 *tmp55 *tmp57
+  167 jump *label54 equal *tmp58 false
+  168 op mul :ballVY :ballVY -1
+  169 jump *label55 always
+  170 label *label54
+  171 op mul :ballVX :ballVX -1
+  172 label *label55
+  173 label *label56
+  174 label *label57
+  175 label *label58
+  176 label *label59
+  177 op add :brickPtr :brickPtr 1
+  178 label *label60
+  179 op add :x :x 58.666666666666664
+  180 label *label26
   181 label *label22
   182 op sub :y :y 10
   183 jump *label36 greaterThan :y 106

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    80 label *label39
    81 read *tmp40 BRICKS :brickPtr
    82 jump *label44 equal *tmp40 false
-    * draw rect :x :y 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd :x
-    * op add *tmp43 :x 58.666666666666664
-    * op lessThan *tmp44 :ballX *tmp43
+   83 draw rect 1 :y 57.666666666666664 9
+   84 op greaterThan *tmp42 :ballXEnd 1
+   85 op add *tmp43 1 58.666666666666664
+   86 op lessThan *tmp44 :ballX 59.666666666666664
    87 op land *tmp45 *tmp42 *tmp44
    88 op greaterThan *tmp46 :ballYEnd :y
    89 op land *tmp47 *tmp45 *tmp46
 
    93 jump *label42 equal *tmp50 false
    94 write 0 BRICKS :brickPtr
    95 op sub :brickCount :brickCount 1
-    * op sub *tmp54 :x 4
-    * op greaterThan *tmp55 :ballX *tmp54
-    * op add *tmp56 :x 62.666666666666664
-    * op lessThan *tmp57 :ballX *tmp56
+   96 op sub *tmp54 1 4
+   97 op greaterThan *tmp55 :ballX -3
+   98 op add *tmp56 1 62.666666666666664
+   99 op lessThan *tmp57 :ballX 63.666666666666664
   100 op land *tmp58 *tmp55 *tmp57
   101 jump *label40 equal *tmp58 false
   102 op mul :ballVY :ballVY -1
 
   110 label *label45
   111 op add :brickPtr :brickPtr 1
   112 label *label46
-    * op add :x :x 58.666666666666664
+  113 op add :x 1 58.666666666666664
   114 read *tmp40 BRICKS :brickPtr
   115 jump *label51 equal *tmp40 false
-    * draw rect :x :y 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd :x
-    * op add *tmp43 :x 58.666666666666664
-    * op lessThan *tmp44 :ballX *tmp43
+  116 draw rect 59.666666666666664 :y 57.666666666666664 9
+  117 op greaterThan *tmp42 :ballXEnd 59.666666666666664
+  118 op add *tmp43 59.666666666666664 58.666666666666664
+  119 op lessThan *tmp44 :ballX 118.33333333333333
   120 op land *tmp45 *tmp42 *tmp44
   121 op greaterThan *tmp46 :ballYEnd :y
   122 op land *tmp47 *tmp45 *tmp46
 
   126 jump *label49 equal *tmp50 false
   127 write 0 BRICKS :brickPtr
   128 op sub :brickCount :brickCount 1
-    * op sub *tmp54 :x 4
-    * op greaterThan *tmp55 :ballX *tmp54
-    * op add *tmp56 :x 62.666666666666664
-    * op lessThan *tmp57 :ballX *tmp56
+  129 op sub *tmp54 59.666666666666664 4
+  130 op greaterThan *tmp55 :ballX 55.666666666666664
+  131 op add *tmp56 59.666666666666664 62.666666666666664
+  132 op lessThan *tmp57 :ballX 122.33333333333333
   133 op land *tmp58 *tmp55 *tmp57
   134 jump *label47 equal *tmp58 false
   135 op mul :ballVY :ballVY -1
 
   143 label *label52
   144 op add :brickPtr :brickPtr 1
   145 label *label53
-    * op add :x :x 58.666666666666664
+  146 op add :x 59.666666666666664 58.666666666666664
   147 read *tmp40 BRICKS :brickPtr
   148 jump *label58 equal *tmp40 false
-    * draw rect :x :y 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd :x
-    * op add *tmp43 :x 58.666666666666664
-    * op lessThan *tmp44 :ballX *tmp43
+  149 draw rect 118.33333333333333 :y 57.666666666666664 9
+  150 op greaterThan *tmp42 :ballXEnd 118.33333333333333
+  151 op add *tmp43 118.33333333333333 58.666666666666664
+  152 op lessThan *tmp44 :ballX 177
   153 op land *tmp45 *tmp42 *tmp44
   154 op greaterThan *tmp46 :ballYEnd :y
   155 op land *tmp47 *tmp45 *tmp46
 
   159 jump *label56 equal *tmp50 false
   160 write 0 BRICKS :brickPtr
   161 op sub :brickCount :brickCount 1
-    * op sub *tmp54 :x 4
-    * op greaterThan *tmp55 :ballX *tmp54
-    * op add *tmp56 :x 62.666666666666664
-    * op lessThan *tmp57 :ballX *tmp56
+  162 op sub *tmp54 118.33333333333333 4
+  163 op greaterThan *tmp55 :ballX 114.33333333333333
+  164 op add *tmp56 118.33333333333333 62.666666666666664
+  165 op lessThan *tmp57 :ballX 181
   166 op land *tmp58 *tmp55 *tmp57
   167 jump *label54 equal *tmp58 false
   168 op mul :ballVY :ballVY -1
 
   176 label *label59
   177 op add :brickPtr :brickPtr 1
   178 label *label60
-    * op add :x :x 58.666666666666664
+  179 op add :x 118.33333333333333 58.666666666666664
   180 label *label26
   181 label *label22
   182 op sub :y :y 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-13 instructions):
 
    75 set :y 126
    76 label *label21
    77 label *label36
-    * set :x 1
    78 label *label38
    79 label *label39
    80 read *tmp40 BRICKS :brickPtr
    81 jump *label44 equal *tmp40 false
    82 draw rect 1 :y 57.666666666666664 9
    83 op greaterThan *tmp42 :ballXEnd 1
-    * op add *tmp43 1 58.666666666666664
    84 op lessThan *tmp44 :ballX 59.666666666666664
    85 op land *tmp45 *tmp42 *tmp44
    86 op greaterThan *tmp46 :ballYEnd :y
 
    91 jump *label42 equal *tmp50 false
    92 write 0 BRICKS :brickPtr
    93 op sub :brickCount :brickCount 1
-    * op sub *tmp54 1 4
    94 op greaterThan *tmp55 :ballX -3
-    * op add *tmp56 1 62.666666666666664
    95 op lessThan *tmp57 :ballX 63.666666666666664
    96 op land *tmp58 *tmp55 *tmp57
    97 jump *label40 equal *tmp58 false
 
   106 label *label45
   107 op add :brickPtr :brickPtr 1
   108 label *label46
-    * op add :x 1 58.666666666666664
   109 read *tmp40 BRICKS :brickPtr
   110 jump *label51 equal *tmp40 false
   111 draw rect 59.666666666666664 :y 57.666666666666664 9
   112 op greaterThan *tmp42 :ballXEnd 59.666666666666664
-    * op add *tmp43 59.666666666666664 58.666666666666664
   113 op lessThan *tmp44 :ballX 118.33333333333333
   114 op land *tmp45 *tmp42 *tmp44
   115 op greaterThan *tmp46 :ballYEnd :y
 
   120 jump *label49 equal *tmp50 false
   121 write 0 BRICKS :brickPtr
   122 op sub :brickCount :brickCount 1
-    * op sub *tmp54 59.666666666666664 4
   123 op greaterThan *tmp55 :ballX 55.666666666666664
-    * op add *tmp56 59.666666666666664 62.666666666666664
   124 op lessThan *tmp57 :ballX 122.33333333333333
   125 op land *tmp58 *tmp55 *tmp57
   126 jump *label47 equal *tmp58 false
 
   135 label *label52
   136 op add :brickPtr :brickPtr 1
   137 label *label53
-    * op add :x 59.666666666666664 58.666666666666664
   138 read *tmp40 BRICKS :brickPtr
   139 jump *label58 equal *tmp40 false
   140 draw rect 118.33333333333333 :y 57.666666666666664 9
   141 op greaterThan *tmp42 :ballXEnd 118.33333333333333
-    * op add *tmp43 118.33333333333333 58.666666666666664
   142 op lessThan *tmp44 :ballX 177
   143 op land *tmp45 *tmp42 *tmp44
   144 op greaterThan *tmp46 :ballYEnd :y
 
   149 jump *label56 equal *tmp50 false
   150 write 0 BRICKS :brickPtr
   151 op sub :brickCount :brickCount 1
-    * op sub *tmp54 118.33333333333333 4
   152 op greaterThan *tmp55 :ballX 114.33333333333333
-    * op add *tmp56 118.33333333333333 62.666666666666664
   153 op lessThan *tmp57 :ballX 181
   154 op land *tmp58 *tmp55 *tmp57
   155 jump *label54 equal *tmp58 false
 
   164 label *label59
   165 op add :brickPtr :brickPtr 1
   166 label *label60
-    * op add :x 118.33333333333333 58.666666666666664
   167 label *label26
   168 label *label22
   169 op sub :y :y 10

Modifications by Unroll loop at line 40:5 (+9 instructions):
 
    11 op rand *tmp4 10
    12 op sub :ballVY *tmp4 5
    13 set :brickCount 6
-    * set :i 0
-    * label *label3
-    * label *label35
-    * write 1 BRICKS :i
-    * label *label4
-    * op add :i :i 1
-    * jump *label35 lessThan :i 6
-    * label *label5
+   14 set :i 0
+   15 label *label61
+   16 label *label62
+   17 write 1 BRICKS :i
+   18 label *label63
+   19 op add :i :i 1
+   20 write 1 BRICKS :i
+   21 label *label64
+   22 op add :i :i 1
+   23 write 1 BRICKS :i
+   24 label *label65
+   25 op add :i :i 1
+   26 write 1 BRICKS :i
+   27 label *label66
+   28 op add :i :i 1
+   29 write 1 BRICKS :i
+   30 label *label67
+   31 op add :i :i 1
+   32 write 1 BRICKS :i
+   33 label *label68
+   34 op add :i :i 1
+   35 label *label5
    36 label *label6
    37 draw clear 0 0 0
    38 draw rect :paddleX 10 :paddleWidth 5

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    14 set :i 0
    15 label *label61
    16 label *label62
-    * write 1 BRICKS :i
+   17 write 1 BRICKS 0
    18 label *label63
-    * op add :i :i 1
-    * write 1 BRICKS :i
+   19 op add :i 0 1
+   20 write 1 BRICKS 1
    21 label *label64
-    * op add :i :i 1
-    * write 1 BRICKS :i
+   22 op add :i 1 1
+   23 write 1 BRICKS 2
    24 label *label65
-    * op add :i :i 1
-    * write 1 BRICKS :i
+   25 op add :i 2 1
+   26 write 1 BRICKS 3
    27 label *label66
-    * op add :i :i 1
-    * write 1 BRICKS :i
+   28 op add :i 3 1
+   29 write 1 BRICKS 4
    30 label *label67
-    * op add :i :i 1
-    * write 1 BRICKS :i
+   31 op add :i 4 1
+   32 write 1 BRICKS 5
    33 label *label68
-    * op add :i :i 1
+   34 op add :i 5 1
    35 label *label5
    36 label *label6
    37 draw clear 0 0 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
    11 op rand *tmp4 10
    12 op sub :ballVY *tmp4 5
    13 set :brickCount 6
-    * set :i 0
    14 label *label61
    15 label *label62
    16 write 1 BRICKS 0
    17 label *label63
-    * op add :i 0 1
    18 write 1 BRICKS 1
    19 label *label64
-    * op add :i 1 1
    20 write 1 BRICKS 2
    21 label *label65
-    * op add :i 2 1
    22 write 1 BRICKS 3
    23 label *label66
-    * op add :i 3 1
    24 write 1 BRICKS 4
    25 label *label67
-    * op add :i 4 1
    26 write 1 BRICKS 5
    27 label *label68
-    * op add :i 5 1
    28 label *label5
    29 label *label6
    30 draw clear 0 0 0

Modifications by Unroll loop at line 81:9 (+66 instructions):
 
    79 label *label19
    80 label *label20
    81 set :brickPtr 0
-    * set :y 126
-    * label *label21
-    * label *label36
-    * label *label38
-    * label *label39
-    * read *tmp40 BRICKS :brickPtr
-    * jump *label44 equal *tmp40 false
-    * draw rect 1 :y 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd 1
-    * op lessThan *tmp44 :ballX 59.666666666666664
-    * op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
-    * op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
-    * op land *tmp50 *tmp47 *tmp49
-    * jump *label42 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
-    * op sub :brickCount :brickCount 1
-    * op greaterThan *tmp55 :ballX -3
-    * op lessThan *tmp57 :ballX 63.666666666666664
-    * op land *tmp58 *tmp55 *tmp57
-    * jump *label40 equal *tmp58 false
-    * op mul :ballVY :ballVY -1
-    * jump *label41 always
-    * label *label40
-    * op mul :ballVX :ballVX -1
-    * label *label41
-    * label *label42
-    * label *label43
-    * label *label44
-    * label *label45
-    * op add :brickPtr :brickPtr 1
-    * label *label46
-    * read *tmp40 BRICKS :brickPtr
-    * jump *label51 equal *tmp40 false
-    * draw rect 59.666666666666664 :y 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd 59.666666666666664
-    * op lessThan *tmp44 :ballX 118.33333333333333
-    * op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
-    * op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
-    * op land *tmp50 *tmp47 *tmp49
-    * jump *label49 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
-    * op sub :brickCount :brickCount 1
-    * op greaterThan *tmp55 :ballX 55.666666666666664
-    * op lessThan *tmp57 :ballX 122.33333333333333
-    * op land *tmp58 *tmp55 *tmp57
-    * jump *label47 equal *tmp58 false
-    * op mul :ballVY :ballVY -1
-    * jump *label48 always
-    * label *label47
-    * op mul :ballVX :ballVX -1
-    * label *label48
-    * label *label49
-    * label *label50
-    * label *label51
-    * label *label52
-    * op add :brickPtr :brickPtr 1
-    * label *label53
-    * read *tmp40 BRICKS :brickPtr
-    * jump *label58 equal *tmp40 false
-    * draw rect 118.33333333333333 :y 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd 118.33333333333333
-    * op lessThan *tmp44 :ballX 177
-    * op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
-    * op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
-    * op land *tmp50 *tmp47 *tmp49
-    * jump *label56 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
-    * op sub :brickCount :brickCount 1
-    * op greaterThan *tmp55 :ballX 114.33333333333333
-    * op lessThan *tmp57 :ballX 181
-    * op land *tmp58 *tmp55 *tmp57
-    * jump *label54 equal *tmp58 false
-    * op mul :ballVY :ballVY -1
-    * jump *label55 always
-    * label *label54
-    * op mul :ballVX :ballVX -1
-    * label *label55
-    * label *label56
-    * label *label57
-    * label *label58
-    * label *label59
-    * op add :brickPtr :brickPtr 1
-    * label *label60
-    * label *label26
-    * label *label22
-    * op sub :y :y 10
-    * jump *label36 greaterThan :y 106
-    * label *label23
+   82 set :y 126
+   83 label *label69
+   84 label *label70
+   85 label *label71
+   86 label *label72
+   87 read *tmp40 BRICKS :brickPtr
+   88 jump *label77 equal *tmp40 false
+   89 draw rect 1 :y 57.666666666666664 9
+   90 op greaterThan *tmp42 :ballXEnd 1
+   91 op lessThan *tmp44 :ballX 59.666666666666664
+   92 op land *tmp45 *tmp42 *tmp44
+   93 op greaterThan *tmp46 :ballYEnd :y
+   94 op land *tmp47 *tmp45 *tmp46
+   95 op add *tmp48 :y 10
+   96 op lessThan *tmp49 :ballY *tmp48
+   97 op land *tmp50 *tmp47 *tmp49
+   98 jump *label75 equal *tmp50 false
+   99 write 0 BRICKS :brickPtr
+  100 op sub :brickCount :brickCount 1
+  101 op greaterThan *tmp55 :ballX -3
+  102 op lessThan *tmp57 :ballX 63.666666666666664
+  103 op land *tmp58 *tmp55 *tmp57
+  104 jump *label73 equal *tmp58 false
+  105 op mul :ballVY :ballVY -1
+  106 jump *label74 always
+  107 label *label73
+  108 op mul :ballVX :ballVX -1
+  109 label *label74
+  110 label *label75
+  111 label *label76
+  112 label *label77
+  113 label *label78
+  114 op add :brickPtr :brickPtr 1
+  115 label *label79
+  116 read *tmp40 BRICKS :brickPtr
+  117 jump *label84 equal *tmp40 false
+  118 draw rect 59.666666666666664 :y 57.666666666666664 9
+  119 op greaterThan *tmp42 :ballXEnd 59.666666666666664
+  120 op lessThan *tmp44 :ballX 118.33333333333333
+  121 op land *tmp45 *tmp42 *tmp44
+  122 op greaterThan *tmp46 :ballYEnd :y
+  123 op land *tmp47 *tmp45 *tmp46
+  124 op add *tmp48 :y 10
+  125 op lessThan *tmp49 :ballY *tmp48
+  126 op land *tmp50 *tmp47 *tmp49
+  127 jump *label82 equal *tmp50 false
+  128 write 0 BRICKS :brickPtr
+  129 op sub :brickCount :brickCount 1
+  130 op greaterThan *tmp55 :ballX 55.666666666666664
+  131 op lessThan *tmp57 :ballX 122.33333333333333
+  132 op land *tmp58 *tmp55 *tmp57
+  133 jump *label80 equal *tmp58 false
+  134 op mul :ballVY :ballVY -1
+  135 jump *label81 always
+  136 label *label80
+  137 op mul :ballVX :ballVX -1
+  138 label *label81
+  139 label *label82
+  140 label *label83
+  141 label *label84
+  142 label *label85
+  143 op add :brickPtr :brickPtr 1
+  144 label *label86
+  145 read *tmp40 BRICKS :brickPtr
+  146 jump *label91 equal *tmp40 false
+  147 draw rect 118.33333333333333 :y 57.666666666666664 9
+  148 op greaterThan *tmp42 :ballXEnd 118.33333333333333
+  149 op lessThan *tmp44 :ballX 177
+  150 op land *tmp45 *tmp42 *tmp44
+  151 op greaterThan *tmp46 :ballYEnd :y
+  152 op land *tmp47 *tmp45 *tmp46
+  153 op add *tmp48 :y 10
+  154 op lessThan *tmp49 :ballY *tmp48
+  155 op land *tmp50 *tmp47 *tmp49
+  156 jump *label89 equal *tmp50 false
+  157 write 0 BRICKS :brickPtr
+  158 op sub :brickCount :brickCount 1
+  159 op greaterThan *tmp55 :ballX 114.33333333333333
+  160 op lessThan *tmp57 :ballX 181
+  161 op land *tmp58 *tmp55 *tmp57
+  162 jump *label87 equal *tmp58 false
+  163 op mul :ballVY :ballVY -1
+  164 jump *label88 always
+  165 label *label87
+  166 op mul :ballVX :ballVX -1
+  167 label *label88
+  168 label *label89
+  169 label *label90
+  170 label *label91
+  171 label *label92
+  172 op add :brickPtr :brickPtr 1
+  173 label *label93
+  174 label *label94
+  175 label *label95
+  176 op sub :y :y 10
+  177 label *label96
+  178 label *label97
+  179 read *tmp40 BRICKS :brickPtr
+  180 jump *label102 equal *tmp40 false
+  181 draw rect 1 :y 57.666666666666664 9
+  182 op greaterThan *tmp42 :ballXEnd 1
+  183 op lessThan *tmp44 :ballX 59.666666666666664
+  184 op land *tmp45 *tmp42 *tmp44
+  185 op greaterThan *tmp46 :ballYEnd :y
+  186 op land *tmp47 *tmp45 *tmp46
+  187 op add *tmp48 :y 10
+  188 op lessThan *tmp49 :ballY *tmp48
+  189 op land *tmp50 *tmp47 *tmp49
+  190 jump *label100 equal *tmp50 false
+  191 write 0 BRICKS :brickPtr
+  192 op sub :brickCount :brickCount 1
+  193 op greaterThan *tmp55 :ballX -3
+  194 op lessThan *tmp57 :ballX 63.666666666666664
+  195 op land *tmp58 *tmp55 *tmp57
+  196 jump *label98 equal *tmp58 false
+  197 op mul :ballVY :ballVY -1
+  198 jump *label99 always
+  199 label *label98
+  200 op mul :ballVX :ballVX -1
+  201 label *label99
+  202 label *label100
+  203 label *label101
+  204 label *label102
+  205 label *label103
+  206 op add :brickPtr :brickPtr 1
+  207 label *label104
+  208 read *tmp40 BRICKS :brickPtr
+  209 jump *label109 equal *tmp40 false
+  210 draw rect 59.666666666666664 :y 57.666666666666664 9
+  211 op greaterThan *tmp42 :ballXEnd 59.666666666666664
+  212 op lessThan *tmp44 :ballX 118.33333333333333
+  213 op land *tmp45 *tmp42 *tmp44
+  214 op greaterThan *tmp46 :ballYEnd :y
+  215 op land *tmp47 *tmp45 *tmp46
+  216 op add *tmp48 :y 10
+  217 op lessThan *tmp49 :ballY *tmp48
+  218 op land *tmp50 *tmp47 *tmp49
+  219 jump *label107 equal *tmp50 false
+  220 write 0 BRICKS :brickPtr
+  221 op sub :brickCount :brickCount 1
+  222 op greaterThan *tmp55 :ballX 55.666666666666664
+  223 op lessThan *tmp57 :ballX 122.33333333333333
+  224 op land *tmp58 *tmp55 *tmp57
+  225 jump *label105 equal *tmp58 false
+  226 op mul :ballVY :ballVY -1
+  227 jump *label106 always
+  228 label *label105
+  229 op mul :ballVX :ballVX -1
+  230 label *label106
+  231 label *label107
+  232 label *label108
+  233 label *label109
+  234 label *label110
+  235 op add :brickPtr :brickPtr 1
+  236 label *label111
+  237 read *tmp40 BRICKS :brickPtr
+  238 jump *label116 equal *tmp40 false
+  239 draw rect 118.33333333333333 :y 57.666666666666664 9
+  240 op greaterThan *tmp42 :ballXEnd 118.33333333333333
+  241 op lessThan *tmp44 :ballX 177
+  242 op land *tmp45 *tmp42 *tmp44
+  243 op greaterThan *tmp46 :ballYEnd :y
+  244 op land *tmp47 *tmp45 *tmp46
+  245 op add *tmp48 :y 10
+  246 op lessThan *tmp49 :ballY *tmp48
+  247 op land *tmp50 *tmp47 *tmp49
+  248 jump *label114 equal *tmp50 false
+  249 write 0 BRICKS :brickPtr
+  250 op sub :brickCount :brickCount 1
+  251 op greaterThan *tmp55 :ballX 114.33333333333333
+  252 op lessThan *tmp57 :ballX 181
+  253 op land *tmp58 *tmp55 *tmp57
+  254 jump *label112 equal *tmp58 false
+  255 op mul :ballVY :ballVY -1
+  256 jump *label113 always
+  257 label *label112
+  258 op mul :ballVX :ballVX -1
+  259 label *label113
+  260 label *label114
+  261 label *label115
+  262 label *label116
+  263 label *label117
+  264 op add :brickPtr :brickPtr 1
+  265 label *label118
+  266 label *label119
+  267 label *label120
+  268 op sub :y :y 10
+  269 label *label23
   270 op lessThan *tmp60 :ballY 0
   271 op equal *tmp61 :brickCount 0
   272 op or *tmp62 *tmp60 *tmp61

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    84 label *label70
    85 label *label71
    86 label *label72
-    * read *tmp40 BRICKS :brickPtr
+   87 read *tmp40 BRICKS 0
    88 jump *label77 equal *tmp40 false
-    * draw rect 1 :y 57.666666666666664 9
+   89 draw rect 1 126 57.666666666666664 9
    90 op greaterThan *tmp42 :ballXEnd 1
    91 op lessThan *tmp44 :ballX 59.666666666666664
    92 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
+   93 op greaterThan *tmp46 :ballYEnd 126
    94 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
+   95 op add *tmp48 126 10
+   96 op lessThan *tmp49 :ballY 136
    97 op land *tmp50 *tmp47 *tmp49
    98 jump *label75 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
+   99 write 0 BRICKS 0
   100 op sub :brickCount :brickCount 1
   101 op greaterThan *tmp55 :ballX -3
   102 op lessThan *tmp57 :ballX 63.666666666666664
 
   111 label *label76
   112 label *label77
   113 label *label78
-    * op add :brickPtr :brickPtr 1
+  114 op add :brickPtr 0 1
   115 label *label79
-    * read *tmp40 BRICKS :brickPtr
+  116 read *tmp40 BRICKS 1
   117 jump *label84 equal *tmp40 false
-    * draw rect 59.666666666666664 :y 57.666666666666664 9
+  118 draw rect 59.666666666666664 126 57.666666666666664 9
   119 op greaterThan *tmp42 :ballXEnd 59.666666666666664
   120 op lessThan *tmp44 :ballX 118.33333333333333
   121 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
+  122 op greaterThan *tmp46 :ballYEnd 126
   123 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
+  124 op add *tmp48 126 10
+  125 op lessThan *tmp49 :ballY 136
   126 op land *tmp50 *tmp47 *tmp49
   127 jump *label82 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
+  128 write 0 BRICKS 1
   129 op sub :brickCount :brickCount 1
   130 op greaterThan *tmp55 :ballX 55.666666666666664
   131 op lessThan *tmp57 :ballX 122.33333333333333
 
   140 label *label83
   141 label *label84
   142 label *label85
-    * op add :brickPtr :brickPtr 1
+  143 op add :brickPtr 1 1
   144 label *label86
-    * read *tmp40 BRICKS :brickPtr
+  145 read *tmp40 BRICKS 2
   146 jump *label91 equal *tmp40 false
-    * draw rect 118.33333333333333 :y 57.666666666666664 9
+  147 draw rect 118.33333333333333 126 57.666666666666664 9
   148 op greaterThan *tmp42 :ballXEnd 118.33333333333333
   149 op lessThan *tmp44 :ballX 177
   150 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
+  151 op greaterThan *tmp46 :ballYEnd 126
   152 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
+  153 op add *tmp48 126 10
+  154 op lessThan *tmp49 :ballY 136
   155 op land *tmp50 *tmp47 *tmp49
   156 jump *label89 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
+  157 write 0 BRICKS 2
   158 op sub :brickCount :brickCount 1
   159 op greaterThan *tmp55 :ballX 114.33333333333333
   160 op lessThan *tmp57 :ballX 181
 
   169 label *label90
   170 label *label91
   171 label *label92
-    * op add :brickPtr :brickPtr 1
+  172 op add :brickPtr 2 1
   173 label *label93
   174 label *label94
   175 label *label95
-    * op sub :y :y 10
+  176 op sub :y 126 10
   177 label *label96
   178 label *label97
-    * read *tmp40 BRICKS :brickPtr
+  179 read *tmp40 BRICKS 3
   180 jump *label102 equal *tmp40 false
-    * draw rect 1 :y 57.666666666666664 9
+  181 draw rect 1 116 57.666666666666664 9
   182 op greaterThan *tmp42 :ballXEnd 1
   183 op lessThan *tmp44 :ballX 59.666666666666664
   184 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
+  185 op greaterThan *tmp46 :ballYEnd 116
   186 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
+  187 op add *tmp48 116 10
+  188 op lessThan *tmp49 :ballY 126
   189 op land *tmp50 *tmp47 *tmp49
   190 jump *label100 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
+  191 write 0 BRICKS 3
   192 op sub :brickCount :brickCount 1
   193 op greaterThan *tmp55 :ballX -3
   194 op lessThan *tmp57 :ballX 63.666666666666664
 
   203 label *label101
   204 label *label102
   205 label *label103
-    * op add :brickPtr :brickPtr 1
+  206 op add :brickPtr 3 1
   207 label *label104
-    * read *tmp40 BRICKS :brickPtr
+  208 read *tmp40 BRICKS 4
   209 jump *label109 equal *tmp40 false
-    * draw rect 59.666666666666664 :y 57.666666666666664 9
+  210 draw rect 59.666666666666664 116 57.666666666666664 9
   211 op greaterThan *tmp42 :ballXEnd 59.666666666666664
   212 op lessThan *tmp44 :ballX 118.33333333333333
   213 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
+  214 op greaterThan *tmp46 :ballYEnd 116
   215 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
+  216 op add *tmp48 116 10
+  217 op lessThan *tmp49 :ballY 126
   218 op land *tmp50 *tmp47 *tmp49
   219 jump *label107 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
+  220 write 0 BRICKS 4
   221 op sub :brickCount :brickCount 1
   222 op greaterThan *tmp55 :ballX 55.666666666666664
   223 op lessThan *tmp57 :ballX 122.33333333333333
 
   232 label *label108
   233 label *label109
   234 label *label110
-    * op add :brickPtr :brickPtr 1
+  235 op add :brickPtr 4 1
   236 label *label111
-    * read *tmp40 BRICKS :brickPtr
+  237 read *tmp40 BRICKS 5
   238 jump *label116 equal *tmp40 false
-    * draw rect 118.33333333333333 :y 57.666666666666664 9
+  239 draw rect 118.33333333333333 116 57.666666666666664 9
   240 op greaterThan *tmp42 :ballXEnd 118.33333333333333
   241 op lessThan *tmp44 :ballX 177
   242 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd :y
+  243 op greaterThan *tmp46 :ballYEnd 116
   244 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 :y 10
-    * op lessThan *tmp49 :ballY *tmp48
+  245 op add *tmp48 116 10
+  246 op lessThan *tmp49 :ballY 126
   247 op land *tmp50 *tmp47 *tmp49
   248 jump *label114 equal *tmp50 false
-    * write 0 BRICKS :brickPtr
+  249 write 0 BRICKS 5
   250 op sub :brickCount :brickCount 1
   251 op greaterThan *tmp55 :ballX 114.33333333333333
   252 op lessThan *tmp57 :ballX 181
 
   261 label *label115
   262 label *label116
   263 label *label117
-    * op add :brickPtr :brickPtr 1
+  264 op add :brickPtr 5 1
   265 label *label118
   266 label *label119
   267 label *label120
-    * op sub :y :y 10
+  268 op sub :y 116 10
   269 label *label23
   270 op lessThan *tmp60 :ballY 0
   271 op equal *tmp61 :brickCount 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-16 instructions):
 
    78 op sub :paddleWidth :paddleWidth 1
    79 label *label19
    80 label *label20
-    * set :brickPtr 0
-    * set :y 126
    81 label *label69
    82 label *label70
    83 label *label71
 
    90 op land *tmp45 *tmp42 *tmp44
    91 op greaterThan *tmp46 :ballYEnd 126
    92 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 126 10
    93 op lessThan *tmp49 :ballY 136
    94 op land *tmp50 *tmp47 *tmp49
    95 jump *label75 equal *tmp50 false
 
   108 label *label76
   109 label *label77
   110 label *label78
-    * op add :brickPtr 0 1
   111 label *label79
   112 read *tmp40 BRICKS 1
   113 jump *label84 equal *tmp40 false
 
   117 op land *tmp45 *tmp42 *tmp44
   118 op greaterThan *tmp46 :ballYEnd 126
   119 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 126 10
   120 op lessThan *tmp49 :ballY 136
   121 op land *tmp50 *tmp47 *tmp49
   122 jump *label82 equal *tmp50 false
 
   135 label *label83
   136 label *label84
   137 label *label85
-    * op add :brickPtr 1 1
   138 label *label86
   139 read *tmp40 BRICKS 2
   140 jump *label91 equal *tmp40 false
 
   144 op land *tmp45 *tmp42 *tmp44
   145 op greaterThan *tmp46 :ballYEnd 126
   146 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 126 10
   147 op lessThan *tmp49 :ballY 136
   148 op land *tmp50 *tmp47 *tmp49
   149 jump *label89 equal *tmp50 false
 
   162 label *label90
   163 label *label91
   164 label *label92
-    * op add :brickPtr 2 1
   165 label *label93
   166 label *label94
   167 label *label95
-    * op sub :y 126 10
   168 label *label96
   169 label *label97
   170 read *tmp40 BRICKS 3
 
   175 op land *tmp45 *tmp42 *tmp44
   176 op greaterThan *tmp46 :ballYEnd 116
   177 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 116 10
   178 op lessThan *tmp49 :ballY 126
   179 op land *tmp50 *tmp47 *tmp49
   180 jump *label100 equal *tmp50 false
 
   193 label *label101
   194 label *label102
   195 label *label103
-    * op add :brickPtr 3 1
   196 label *label104
   197 read *tmp40 BRICKS 4
   198 jump *label109 equal *tmp40 false
 
   202 op land *tmp45 *tmp42 *tmp44
   203 op greaterThan *tmp46 :ballYEnd 116
   204 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 116 10
   205 op lessThan *tmp49 :ballY 126
   206 op land *tmp50 *tmp47 *tmp49
   207 jump *label107 equal *tmp50 false
 
   220 label *label108
   221 label *label109
   222 label *label110
-    * op add :brickPtr 4 1
   223 label *label111
   224 read *tmp40 BRICKS 5
   225 jump *label116 equal *tmp40 false
 
   229 op land *tmp45 *tmp42 *tmp44
   230 op greaterThan *tmp46 :ballYEnd 116
   231 op land *tmp47 *tmp45 *tmp46
-    * op add *tmp48 116 10
   232 op lessThan *tmp49 :ballY 126
   233 op land *tmp50 *tmp47 *tmp49
   234 jump *label114 equal *tmp50 false
 
   247 label *label115
   248 label *label116
   249 label *label117
-    * op add :brickPtr 5 1
   250 label *label118
   251 label *label119
   252 label *label120
-    * op sub :y 116 10
   253 label *label23
   254 op lessThan *tmp60 :ballY 0
   255 op equal *tmp61 :brickCount 0

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-1 instructions):
 
    47 op add :ballX :ballX :ballVX
    48 op add :ballY :ballY :ballVY
    49 op add :ballXEnd :ballX 5
-    * op add :ballYEnd :ballY 5
    50 op lessThan *tmp17 :ballX 0
-    * op greaterThan *tmp18 :ballXEnd 176
+   51 op greaterThan *tmp18 :ballX 171
    52 op or *tmp19 *tmp17 *tmp18
    53 jump *label15 equal *tmp19 false
    54 op mul :ballVX :ballVX -1
    55 label *label15
    56 label *label16
-    * jump *label17 lessThanEq :ballYEnd 176
+   57 jump *label17 lessThanEq :ballY 171
    58 op mul :ballVY :ballVY -1
    59 label *label17
    60 label *label18
 
    62 op add *tmp24 :paddleX :paddleWidth
    63 op lessThan *tmp25 :ballX *tmp24
    64 op land *tmp26 *tmp23 *tmp25
-    * op greaterThan *tmp27 :ballYEnd 10
+   65 op greaterThan *tmp27 :ballY 5
    66 op land *tmp28 *tmp26 *tmp27
    67 op lessThan *tmp29 :ballY 15
    68 op land *tmp30 *tmp28 *tmp29
 
    84 read *tmp40 BRICKS 0
    85 jump *label77 equal *tmp40 false
    86 draw rect 1 126 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd 1
+   87 op greaterThan *tmp42 :ballX -4
    88 op lessThan *tmp44 :ballX 59.666666666666664
    89 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd 126
+   90 op greaterThan *tmp46 :ballY 121
    91 op land *tmp47 *tmp45 *tmp46
    92 op lessThan *tmp49 :ballY 136
    93 op land *tmp50 *tmp47 *tmp49
 
   111 read *tmp40 BRICKS 1
   112 jump *label84 equal *tmp40 false
   113 draw rect 59.666666666666664 126 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd 59.666666666666664
+  114 op greaterThan *tmp42 :ballX 54.666666666666664
   115 op lessThan *tmp44 :ballX 118.33333333333333
   116 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd 126
+  117 op greaterThan *tmp46 :ballY 121
   118 op land *tmp47 *tmp45 *tmp46
   119 op lessThan *tmp49 :ballY 136
   120 op land *tmp50 *tmp47 *tmp49
 
   138 read *tmp40 BRICKS 2
   139 jump *label91 equal *tmp40 false
   140 draw rect 118.33333333333333 126 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd 118.33333333333333
+  141 op greaterThan *tmp42 :ballX 113.33333333333333
   142 op lessThan *tmp44 :ballX 177
   143 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd 126
+  144 op greaterThan *tmp46 :ballY 121
   145 op land *tmp47 *tmp45 *tmp46
   146 op lessThan *tmp49 :ballY 136
   147 op land *tmp50 *tmp47 *tmp49
 
   169 read *tmp40 BRICKS 3
   170 jump *label102 equal *tmp40 false
   171 draw rect 1 116 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd 1
+  172 op greaterThan *tmp42 :ballX -4
   173 op lessThan *tmp44 :ballX 59.666666666666664
   174 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd 116
+  175 op greaterThan *tmp46 :ballY 111
   176 op land *tmp47 *tmp45 *tmp46
   177 op lessThan *tmp49 :ballY 126
   178 op land *tmp50 *tmp47 *tmp49
 
   196 read *tmp40 BRICKS 4
   197 jump *label109 equal *tmp40 false
   198 draw rect 59.666666666666664 116 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd 59.666666666666664
+  199 op greaterThan *tmp42 :ballX 54.666666666666664
   200 op lessThan *tmp44 :ballX 118.33333333333333
   201 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd 116
+  202 op greaterThan *tmp46 :ballY 111
   203 op land *tmp47 *tmp45 *tmp46
   204 op lessThan *tmp49 :ballY 126
   205 op land *tmp50 *tmp47 *tmp49
 
   223 read *tmp40 BRICKS 5
   224 jump *label116 equal *tmp40 false
   225 draw rect 118.33333333333333 116 57.666666666666664 9
-    * op greaterThan *tmp42 :ballXEnd 118.33333333333333
+  226 op greaterThan *tmp42 :ballX 113.33333333333333
   227 op lessThan *tmp44 :ballX 177
   228 op land *tmp45 *tmp42 *tmp44
-    * op greaterThan *tmp46 :ballYEnd 116
+  229 op greaterThan *tmp46 :ballY 111
   230 op land *tmp47 *tmp45 *tmp46
   231 op lessThan *tmp49 :ballY 126
   232 op land *tmp50 *tmp47 *tmp49

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-1 instructions):
 
    11 op rand *tmp4 10
    12 op sub :ballVY *tmp4 5
    13 set :brickCount 6
-    * label *label61
-    * label *label62
    14 write 1 BRICKS 0
-    * label *label63
    15 write 1 BRICKS 1
-    * label *label64
    16 write 1 BRICKS 2
-    * label *label65
    17 write 1 BRICKS 3
-    * label *label66
    18 write 1 BRICKS 4
-    * label *label67
    19 write 1 BRICKS 5
-    * label *label68
-    * label *label5
    20 label *label6
    21 draw clear 0 0 0
    22 draw rect :paddleX 10 :paddleWidth 5
 
    27 jump *label11 greaterThanEq :paddleX *tmp10
    28 op add :paddleX :paddleX 3
    29 label *label11
-    * label *label12
    30 jump *label10 always
    31 label *label9
    32 jump *label13 lessThanEq :paddleX 0
    33 op sub :paddleX :paddleX 3
    34 label *label13
-    * label *label14
    35 label *label10
    36 op add :ballX :ballX :ballVX
    37 op add :ballY :ballY :ballVY
 
    42 jump *label15 equal *tmp19 false
    43 op mul :ballVX :ballVX -1
    44 label *label15
-    * label *label16
    45 jump *label17 lessThanEq :ballY 171
    46 op mul :ballVY :ballVY -1
    47 label *label17
-    * label *label18
    48 op greaterThan *tmp23 :ballXEnd :paddleX
    49 op add *tmp24 :paddleX :paddleWidth
    50 op lessThan *tmp25 :ballX *tmp24
 
    63 op add :ballVX :ballVX *tmp36
    64 op sub :paddleWidth :paddleWidth 1
    65 label *label19
-    * label *label20
-    * label *label69
-    * label *label70
-    * label *label71
-    * label *label72
    66 read *tmp40 BRICKS 0
    67 jump *label77 equal *tmp40 false
    68 draw rect 1 126 57.666666666666664 9
 
    86 op mul :ballVX :ballVX -1
    87 label *label74
    88 label *label75
-    * label *label76
    89 label *label77
-    * label *label78
-    * label *label79
    90 read *tmp40 BRICKS 1
    91 jump *label84 equal *tmp40 false
    92 draw rect 59.666666666666664 126 57.666666666666664 9
 
   110 op mul :ballVX :ballVX -1
   111 label *label81
   112 label *label82
-    * label *label83
   113 label *label84
-    * label *label85
-    * label *label86
   114 read *tmp40 BRICKS 2
   115 jump *label91 equal *tmp40 false
   116 draw rect 118.33333333333333 126 57.666666666666664 9
 
   134 op mul :ballVX :ballVX -1
   135 label *label88
   136 label *label89
-    * label *label90
   137 label *label91
-    * label *label92
-    * label *label93
-    * label *label94
-    * label *label95
-    * label *label96
-    * label *label97
   138 read *tmp40 BRICKS 3
   139 jump *label102 equal *tmp40 false
   140 draw rect 1 116 57.666666666666664 9
 
   158 op mul :ballVX :ballVX -1
   159 label *label99
   160 label *label100
-    * label *label101
   161 label *label102
-    * label *label103
-    * label *label104
   162 read *tmp40 BRICKS 4
   163 jump *label109 equal *tmp40 false
   164 draw rect 59.666666666666664 116 57.666666666666664 9
 
   182 op mul :ballVX :ballVX -1
   183 label *label106
   184 label *label107
-    * label *label108
   185 label *label109
-    * label *label110
-    * label *label111
   186 read *tmp40 BRICKS 5
   187 jump *label116 equal *tmp40 false
   188 draw rect 118.33333333333333 116 57.666666666666664 9
 
   206 op mul :ballVX :ballVX -1
   207 label *label113
   208 label *label114
-    * label *label115
   209 label *label116
-    * label *label117
-    * label *label118
-    * label *label119
-    * label *label120
-    * label *label23
   210 op lessThan *tmp60 :ballY 0
   211 op equal *tmp61 :brickCount 0
   212 op or *tmp62 *tmp60 *tmp61
   213 jump *label33 equal *tmp62 false
   214 jump *label8 always
   215 label *label33
-    * label *label34
   216 drawflush DISPLAY
-    * label *label7
   217 jump *label6 always
   218 label *label8
-    * label *label1
   219 jump *label0 always
-    * label *label2
-    * end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
   210 op lessThan *tmp60 :ballY 0
   211 op equal *tmp61 :brickCount 0
   212 op or *tmp62 *tmp60 *tmp61
-    * jump *label33 equal *tmp62 false
-    * jump *label8 always
+  213 jump *label8 notEqual *tmp62 false
   214 label *label33
   215 drawflush DISPLAY
   216 jump *label6 always

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    24 sensor *tmp8 PADDLECONTROLLER @enabled
    25 jump *label9 equal *tmp8 false
    26 op sub *tmp10 176 :paddleWidth
-    * jump *label11 greaterThanEq :paddleX *tmp10
+   27 jump *label10 greaterThanEq :paddleX *tmp10
    28 op add :paddleX :paddleX 3
    29 label *label11
    30 jump *label10 always
 
   210 op lessThan *tmp60 :ballY 0
   211 op equal *tmp61 :brickCount 0
   212 op or *tmp62 *tmp60 *tmp61
-    * jump *label8 notEqual *tmp62 false
+  213 jump *label0 notEqual *tmp62 false
   214 drawflush DISPLAY
   215 jump *label6 always
   216 label *label8

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-1 instructions):
 
   212 jump *label0 notEqual *tmp62 false
   213 drawflush DISPLAY
   214 jump *label6 always
-    * jump *label0 always

Final code before resolving virtual instructions:

    0:  set BRICKS bank1                                             param BRICKS = bank1;
    1:  set DISPLAY display1                                         param DISPLAY = display1;
    2:  set PADDLECONTROLLER switch1                                 param PADDLECONTROLLER = switch1;
    3:  draw color 255 255 255 255 0 0                               color(255, 255, 255, 255);
        label *label0                                                while true do
    4:  set :paddleWidth 40                                          paddleWidth = 40;
    5:  op sub :paddleX 88 20                                        paddleX = size / 2 - paddleWidth / 2;
    6:  set :ballX 88                                                ballX = size / 2;
    7:  set :ballY 88                                                ballY = size / 2;
    8:  op rand *tmp2 10 0                                           ballVX = rand(ballMaxStartSpeed * 2) - ballMaxStartSpeed;
    9:  op sub :ballVX *tmp2 5                                       ...
   10:  op rand *tmp4 10 0                                           ballVY = rand(ballMaxStartSpeed * 2) - ballMaxStartSpeed;
   11:  op sub :ballVY *tmp4 5                                       ...
   12:  set :brickCount 6                                            brickCount = brickTotal;
   13:  write 1 BRICKS 0                                             BRICKS[i] = 1;
   14:  write 1 BRICKS 1                                             ...
   15:  write 1 BRICKS 2                                             ...
   16:  write 1 BRICKS 3                                             ...
   17:  write 1 BRICKS 4                                             ...
   18:  write 1 BRICKS 5                                             ...
        label *label6                                                while true do
   19:  draw clear 0 0 0 0 0 0                                       clear(0, 0, 0);
   20:  draw rect :paddleX 10 :paddleWidth 5 0 0                     rect(paddleX, paddleY, paddleWidth, paddleHeight);
   21:  draw rect :ballX :ballY 5 5 0 0                              rect(ballX, ballY, ballSize, ballSize);
   22:  sensor *tmp8 PADDLECONTROLLER @enabled                       if PADDLECONTROLLER.@enabled then
   23:  jump *label9 equal *tmp8 false                               ...
   24:  op sub *tmp10 176 :paddleWidth                               if paddleX < size - paddleWidth then
   25:  jump *label10 greaterThanEq :paddleX *tmp10                  ...
   26:  op add :paddleX :paddleX 3                                   paddleX += paddleSpeed;
   27:  jump *label10 always 0 0                                     if PADDLECONTROLLER.@enabled then
        label *label9                                                ...
   28:  jump *label13 lessThanEq :paddleX 0                          elsif paddleX > 0 then
   29:  op sub :paddleX :paddleX 3                                   paddleX -= paddleSpeed;
        label *label13                                               elsif paddleX > 0 then
        label *label10                                               if PADDLECONTROLLER.@enabled then
   30:  op add :ballX :ballX :ballVX                                 ballX += ballVX;
   31:  op add :ballY :ballY :ballVY                                 ballY += ballVY;
   32:  op add :ballXEnd :ballX 5                                    ballXEnd = ballX + ballSize;
   33:  op lessThan *tmp17 :ballX 0                                  if ballX < 0 || ballXEnd > size then
   34:  op greaterThan *tmp18 :ballX 171                             ...
   35:  op or *tmp19 *tmp17 *tmp18                                   ...
   36:  jump *label15 equal *tmp19 false                             ...
   37:  op mul :ballVX :ballVX -1                                    ballVX *= -1;
        label *label15                                               if ballX < 0 || ballXEnd > size then
   38:  jump *label17 lessThanEq :ballY 171                          if ballYEnd > size then
   39:  op mul :ballVY :ballVY -1                                    ballVY *= -1;
        label *label17                                               if ballYEnd > size then
   40:  op greaterThan *tmp23 :ballXEnd :paddleX                     if ballXEnd > paddleX && ballX < paddleX + paddleWidth && ballYEnd > paddleY && ballY < paddleY + paddleHeight then
   41:  op add *tmp24 :paddleX :paddleWidth                          ...
   42:  op lessThan *tmp25 :ballX *tmp24                             ...
   43:  op land *tmp26 *tmp23 *tmp25                                 ...
   44:  op greaterThan *tmp27 :ballY 5                               ...
   45:  op land *tmp28 *tmp26 *tmp27                                 ...
   46:  op lessThan *tmp29 :ballY 15                                 ...
   47:  op land *tmp30 *tmp28 *tmp29                                 ...
   48:  jump *label19 equal *tmp30 false                             ...
   49:  op mul :ballVY :ballVY -1.1                                  ballVY *= -1.1;
   50:  op add *tmp32 :ballX 2.5                                     ballVX += (ballX + ballSize / 2 - paddleX + paddleWidth / 2) / 10;
   51:  op sub *tmp33 *tmp32 :paddleX                                ...
   52:  op div *tmp34 :paddleWidth 2                                 ...
   53:  op add *tmp35 *tmp33 *tmp34                                  ...
   54:  op div *tmp36 *tmp35 10                                      ...
   55:  op add :ballVX :ballVX *tmp36                                ...
   56:  op sub :paddleWidth :paddleWidth 1                           paddleWidth -= 1;
        label *label19                                               if ballXEnd > paddleX && ballX < paddleX + paddleWidth && ballYEnd > paddleY && ballY < paddleY + paddleHeight then
   57:  read *tmp40 BRICKS 0                                         if BRICKS[brickPtr] then
   58:  jump *label77 equal *tmp40 false                             ...
   59:  draw rect 1 126 57.666666666666664 9 0 0                     rect(x, y, brickWidth - 1, brickHeight - 1);
   60:  op greaterThan *tmp42 :ballX -4                              ballXEnd > x &&
   61:  op lessThan *tmp44 :ballX 59.666666666666664                 ballX < x + brickWidth &&
   62:  op land *tmp45 *tmp42 *tmp44                                 ballXEnd > x &&
   63:  op greaterThan *tmp46 :ballY 121                             ballYEnd > y &&
   64:  op land *tmp47 *tmp45 *tmp46                                 ballX < x + brickWidth &&
   65:  op lessThan *tmp49 :ballY 136                                ballY < y + brickHeight
   66:  op land *tmp50 *tmp47 *tmp49                                 ballYEnd > y &&
   67:  jump *label75 equal *tmp50 false                             if
   68:  write 0 BRICKS 0                                             BRICKS[brickPtr] = 0;
   69:  op sub :brickCount :brickCount 1                             brickCount -= 1;
   70:  op greaterThan *tmp55 :ballX -3                              ballX > x - ballSizeMinus1 &&
   71:  op lessThan *tmp57 :ballX 63.666666666666664                 ballX < x + brickWidthPlusBallSizeMinus1
   72:  op land *tmp58 *tmp55 *tmp57                                 ballX > x - ballSizeMinus1 &&
   73:  jump *label73 equal *tmp58 false                             if
   74:  op mul :ballVY :ballVY -1                                    ballVY *= -1;
   75:  jump *label74 always 0 0                                     if
        label *label73                                               ...
   76:  op mul :ballVX :ballVX -1                                    ballVX *= -1;
        label *label74                                               if
        label *label75                                               if
        label *label77                                               if BRICKS[brickPtr] then
   77:  read *tmp40 BRICKS 1                                         ...
   78:  jump *label84 equal *tmp40 false                             ...
   79:  draw rect 59.666666666666664 126 57.666666666666664 9 0 0    rect(x, y, brickWidth - 1, brickHeight - 1);
   80:  op greaterThan *tmp42 :ballX 54.666666666666664              ballXEnd > x &&
   81:  op lessThan *tmp44 :ballX 118.33333333333333                 ballX < x + brickWidth &&
   82:  op land *tmp45 *tmp42 *tmp44                                 ballXEnd > x &&
   83:  op greaterThan *tmp46 :ballY 121                             ballYEnd > y &&
   84:  op land *tmp47 *tmp45 *tmp46                                 ballX < x + brickWidth &&
   85:  op lessThan *tmp49 :ballY 136                                ballY < y + brickHeight
   86:  op land *tmp50 *tmp47 *tmp49                                 ballYEnd > y &&
   87:  jump *label82 equal *tmp50 false                             if
   88:  write 0 BRICKS 1                                             BRICKS[brickPtr] = 0;
   89:  op sub :brickCount :brickCount 1                             brickCount -= 1;
   90:  op greaterThan *tmp55 :ballX 55.666666666666664              ballX > x - ballSizeMinus1 &&
   91:  op lessThan *tmp57 :ballX 122.33333333333333                 ballX < x + brickWidthPlusBallSizeMinus1
   92:  op land *tmp58 *tmp55 *tmp57                                 ballX > x - ballSizeMinus1 &&
   93:  jump *label80 equal *tmp58 false                             if
   94:  op mul :ballVY :ballVY -1                                    ballVY *= -1;
   95:  jump *label81 always 0 0                                     if
        label *label80                                               ...
   96:  op mul :ballVX :ballVX -1                                    ballVX *= -1;
        label *label81                                               if
        label *label82                                               if
        label *label84                                               if BRICKS[brickPtr] then
   97:  read *tmp40 BRICKS 2                                         ...
   98:  jump *label91 equal *tmp40 false                             ...
   99:  draw rect 118.33333333333333 126 57.666666666666664 9 0 0    rect(x, y, brickWidth - 1, brickHeight - 1);
  100:  op greaterThan *tmp42 :ballX 113.33333333333333              ballXEnd > x &&
  101:  op lessThan *tmp44 :ballX 177                                ballX < x + brickWidth &&
  102:  op land *tmp45 *tmp42 *tmp44                                 ballXEnd > x &&
  103:  op greaterThan *tmp46 :ballY 121                             ballYEnd > y &&
  104:  op land *tmp47 *tmp45 *tmp46                                 ballX < x + brickWidth &&
  105:  op lessThan *tmp49 :ballY 136                                ballY < y + brickHeight
  106:  op land *tmp50 *tmp47 *tmp49                                 ballYEnd > y &&
  107:  jump *label89 equal *tmp50 false                             if
  108:  write 0 BRICKS 2                                             BRICKS[brickPtr] = 0;
  109:  op sub :brickCount :brickCount 1                             brickCount -= 1;
  110:  op greaterThan *tmp55 :ballX 114.33333333333333              ballX > x - ballSizeMinus1 &&
  111:  op lessThan *tmp57 :ballX 181                                ballX < x + brickWidthPlusBallSizeMinus1
  112:  op land *tmp58 *tmp55 *tmp57                                 ballX > x - ballSizeMinus1 &&
  113:  jump *label87 equal *tmp58 false                             if
  114:  op mul :ballVY :ballVY -1                                    ballVY *= -1;
  115:  jump *label88 always 0 0                                     if
        label *label87                                               ...
  116:  op mul :ballVX :ballVX -1                                    ballVX *= -1;
        label *label88                                               if
        label *label89                                               if
        label *label91                                               if BRICKS[brickPtr] then
  117:  read *tmp40 BRICKS 3                                         ...
  118:  jump *label102 equal *tmp40 false                            ...
  119:  draw rect 1 116 57.666666666666664 9 0 0                     rect(x, y, brickWidth - 1, brickHeight - 1);
  120:  op greaterThan *tmp42 :ballX -4                              ballXEnd > x &&
  121:  op lessThan *tmp44 :ballX 59.666666666666664                 ballX < x + brickWidth &&
  122:  op land *tmp45 *tmp42 *tmp44                                 ballXEnd > x &&
  123:  op greaterThan *tmp46 :ballY 111                             ballYEnd > y &&
  124:  op land *tmp47 *tmp45 *tmp46                                 ballX < x + brickWidth &&
  125:  op lessThan *tmp49 :ballY 126                                ballY < y + brickHeight
  126:  op land *tmp50 *tmp47 *tmp49                                 ballYEnd > y &&
  127:  jump *label100 equal *tmp50 false                            if
  128:  write 0 BRICKS 3                                             BRICKS[brickPtr] = 0;
  129:  op sub :brickCount :brickCount 1                             brickCount -= 1;
  130:  op greaterThan *tmp55 :ballX -3                              ballX > x - ballSizeMinus1 &&
  131:  op lessThan *tmp57 :ballX 63.666666666666664                 ballX < x + brickWidthPlusBallSizeMinus1
  132:  op land *tmp58 *tmp55 *tmp57                                 ballX > x - ballSizeMinus1 &&
  133:  jump *label98 equal *tmp58 false                             if
  134:  op mul :ballVY :ballVY -1                                    ballVY *= -1;
  135:  jump *label99 always 0 0                                     if
        label *label98                                               ...
  136:  op mul :ballVX :ballVX -1                                    ballVX *= -1;
        label *label99                                               if
        label *label100                                              if
        label *label102                                              if BRICKS[brickPtr] then
  137:  read *tmp40 BRICKS 4                                         ...
  138:  jump *label109 equal *tmp40 false                            ...
  139:  draw rect 59.666666666666664 116 57.666666666666664 9 0 0    rect(x, y, brickWidth - 1, brickHeight - 1);
  140:  op greaterThan *tmp42 :ballX 54.666666666666664              ballXEnd > x &&
  141:  op lessThan *tmp44 :ballX 118.33333333333333                 ballX < x + brickWidth &&
  142:  op land *tmp45 *tmp42 *tmp44                                 ballXEnd > x &&
  143:  op greaterThan *tmp46 :ballY 111                             ballYEnd > y &&
  144:  op land *tmp47 *tmp45 *tmp46                                 ballX < x + brickWidth &&
  145:  op lessThan *tmp49 :ballY 126                                ballY < y + brickHeight
  146:  op land *tmp50 *tmp47 *tmp49                                 ballYEnd > y &&
  147:  jump *label107 equal *tmp50 false                            if
  148:  write 0 BRICKS 4                                             BRICKS[brickPtr] = 0;
  149:  op sub :brickCount :brickCount 1                             brickCount -= 1;
  150:  op greaterThan *tmp55 :ballX 55.666666666666664              ballX > x - ballSizeMinus1 &&
  151:  op lessThan *tmp57 :ballX 122.33333333333333                 ballX < x + brickWidthPlusBallSizeMinus1
  152:  op land *tmp58 *tmp55 *tmp57                                 ballX > x - ballSizeMinus1 &&
  153:  jump *label105 equal *tmp58 false                            if
  154:  op mul :ballVY :ballVY -1                                    ballVY *= -1;
  155:  jump *label106 always 0 0                                    if
        label *label105                                              ...
  156:  op mul :ballVX :ballVX -1                                    ballVX *= -1;
        label *label106                                              if
        label *label107                                              if
        label *label109                                              if BRICKS[brickPtr] then
  157:  read *tmp40 BRICKS 5                                         ...
  158:  jump *label116 equal *tmp40 false                            ...
  159:  draw rect 118.33333333333333 116 57.666666666666664 9 0 0    rect(x, y, brickWidth - 1, brickHeight - 1);
  160:  op greaterThan *tmp42 :ballX 113.33333333333333              ballXEnd > x &&
  161:  op lessThan *tmp44 :ballX 177                                ballX < x + brickWidth &&
  162:  op land *tmp45 *tmp42 *tmp44                                 ballXEnd > x &&
  163:  op greaterThan *tmp46 :ballY 111                             ballYEnd > y &&
  164:  op land *tmp47 *tmp45 *tmp46                                 ballX < x + brickWidth &&
  165:  op lessThan *tmp49 :ballY 126                                ballY < y + brickHeight
  166:  op land *tmp50 *tmp47 *tmp49                                 ballYEnd > y &&
  167:  jump *label114 equal *tmp50 false                            if
  168:  write 0 BRICKS 5                                             BRICKS[brickPtr] = 0;
  169:  op sub :brickCount :brickCount 1                             brickCount -= 1;
  170:  op greaterThan *tmp55 :ballX 114.33333333333333              ballX > x - ballSizeMinus1 &&
  171:  op lessThan *tmp57 :ballX 181                                ballX < x + brickWidthPlusBallSizeMinus1
  172:  op land *tmp58 *tmp55 *tmp57                                 ballX > x - ballSizeMinus1 &&
  173:  jump *label112 equal *tmp58 false                            if
  174:  op mul :ballVY :ballVY -1                                    ballVY *= -1;
  175:  jump *label113 always 0 0                                    if
        label *label112                                              ...
  176:  op mul :ballVX :ballVX -1                                    ballVX *= -1;
        label *label113                                              if
        label *label114                                              if
        label *label116                                              if BRICKS[brickPtr] then
  177:  op lessThan *tmp60 :ballY 0                                  if ballY < 0 || brickCount == 0 then
  178:  op equal *tmp61 :brickCount 0                                ...
  179:  op or *tmp62 *tmp60 *tmp61                                   ...
  180:  jump *label0 notEqual *tmp62 false                           ...
  181:  drawflush DISPLAY                                            drawflush(DISPLAY);
  182:  jump *label6 always 0 0                                      while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   184     1x    184,0  <no function>

Performance: parsed in 199 ms, compiled in 295 ms, optimized in 425 ms, run in 12 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (23 steps):
The program didn't generate any output.
Execution exception at instruction 22: sensor *tmp8 PADDLECONTROLLER @enabled:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
