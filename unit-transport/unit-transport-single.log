   593 instructions before optimizations.
    38 instructions eliminated by Temp Variables Elimination (2 passes, 6 iterations).
    78 instructions eliminated by Dead Code Elimination (8 iterations).
C:\Home\golem\unit-transport\unit-transport-single.mnd:186:1 Variable 'iter' is not used.
     6 instructions eliminated by Jump Normalization (2 passes, 6 iterations).
    53 instructions eliminated by Condition Optimization (7 iterations).
    33 instructions eliminated by Single Step Elimination (4 passes, 10 iterations).
     2 instructions eliminated by If Expression Optimization (3 iterations).
     2 instructions eliminated by Data Flow Optimization (3 passes, 13 iterations).
     5 instructions added by Loop Rotation (3 iterations).
       9 loop conditions were partially rotated.
     7 instructions eliminated by Jump Straightening (2 passes, 8 iterations).
     9 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (3 iterations).
    34 instructions eliminated by Print Merging.
   342 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 612):
  * Partial loop rotation at line 44:1                           size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Partial loop rotation at line 52:1                           size    +1, benefit       25.0, efficiency     25.000
    Partial loop rotation at line 112:9                          size    +1, benefit        6.3, efficiency      6.250
    Partial loop rotation at line 306:1                          size    +1, benefit       25.0, efficiency     25.000
    Partial loop rotation at line 316:5                          size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 611):
  * Partial loop rotation at line 52:1                           size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Partial loop rotation at line 112:9                          size    +1, benefit        6.3, efficiency      6.250
    Partial loop rotation at line 306:1                          size    +1, benefit       25.0, efficiency     25.000
    Partial loop rotation at line 316:5                          size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 610):
    Partial loop rotation at line 112:9                          size    +1, benefit        6.3, efficiency      6.250
  * Partial loop rotation at line 306:1                          size    +1, benefit       25.0, efficiency     25.000 (+0 instructions)
    Partial loop rotation at line 316:5                          size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 610):
    Partial loop rotation at line 112:9                          size    +1, benefit        6.3, efficiency      6.250
  * Partial loop rotation at line 316:5                          size    +1, benefit       12.5, efficiency     12.500 (+1 instructions)

Pass 1: speed optimization selection (cost limit 609):
  * Partial loop rotation at line 112:9                          size    +1, benefit        6.3, efficiency      6.250 (+1 instructions)
C:\Home\golem\unit-transport\unit-transport-single.mnd:96:49 Variable 'CORE_X' is not initialized.
C:\Home\golem\unit-transport\unit-transport-single.mnd:96:61 Variable 'CORE_Y' is not initialized.
C:\Home\golem\unit-transport\unit-transport-single.mnd:229:13 Variable 'MSG' is not initialized.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-50 instructions):
 
    34 set *tmp8 @unit
    35 set :rebindUnit:first_unit *tmp8
    36 jump *label9 always
-    * set *tmp7 null
    37 jump *label11 always
    38 label *label10
-    * set *tmp7 null
    39 label *label11
    40 print "[salmon]No unit of type "
    41 print UNIT
 
    50 op equal *tmp10 *tmp9 @this
    51 jump *label15 equal *tmp10 false
    52 jump *label6 always
-    * set *tmp11 null
    53 jump *label16 always
    54 label *label15
-    * set *tmp11 null
    55 label *label16
    56 ubind UNIT
    57 print "[gold]Looking for old unit..."
 
    74 print UNIT
    75 print " "
    76 print "found."
-    * set *tmp16 null
    77 jump *label23 always
    78 label *label22
    79 sensor *tmp17 @unit @controlled
 
    89 jump *label18 always
    90 set *tmp19 null
    91 label *label25
-    * set *tmp16 *tmp19
    92 label *label23
    93 printflush message1
    94 label *label20
 
   123 jump *label32 equal *tmp28 false
   124 set .DROP_TARGET .CONTAINER
   125 set .CONTAINER :block
-    * set *tmp29 .CONTAINER
   126 jump *label33 always
   127 label *label32
-    * set *tmp29 null
   128 label *label33
   129 label *label30
   130 jump *label29 always
 
   133 jump *label34 equal *tmp30 false
   134 print "[salmon]No destination."
   135 print "\n"
-    * set *tmp31 "[salmon]No destination."
   136 jump *label35 always
   137 label *label34
   138 op notEqual *tmp32 .DROP_TARGET null
 
   158 jump *label28 always
   159 set *tmp35 null
   160 label *label37
-    * set *tmp31 *tmp35
   161 label *label35
   162 printflush message1
   163 label *label27
 
   170 printflush message1
   171 ulocate building core false @copper .CORE_X .CORE_Y *tmp39 *tmp38
   172 set .CORE *tmp38
-    * set *tmp37 .CORE
   173 jump *label41 always
   174 label *label40
   175 print "[gold]Locating vault #"
 
   233 label *label47
   234 set *tmp46 null
   235 label *label48
-    * set *tmp37 *tmp46
   236 label *label41
   237 op equal *tmp58 .CORE null
   238 jump *label56 equal *tmp58 false
   239 end
-    * set *tmp59 null
   240 jump *label57 always
   241 label *label56
-    * set *tmp59 null
   242 label *label57
   243 set .SORTER sorter1
   244 sensor *tmp60 .SORTER @type
 
   257 jump *label63 equal *tmp63 false
   258 print "Block found: "
   259 print .SORTER
-    * set *tmp64 .SORTER
   260 jump *label64 always
   261 label *label63
-    * set *tmp64 null
   262 label *label64
   263 printflush message1
   264 set .SORTER sorter1
 
   293 set *tmp76 "[] from vault #"
   294 label *label68
   295 set .DIRECTION *tmp76
-    * set *tmp67 .DIRECTION
   296 jump *label66 always
   297 label *label65
   298 op greaterThan *tmp77 LINK_ID 0
 
   323 set *tmp89 "[] to vault #"
   324 label *label70
   325 set .DIRECTION *tmp89
-    * set *tmp67 .DIRECTION
   326 label *label66
   327 op equal *tmp90 LINK_ID 0
   328 jump *label71 equal *tmp90 false
 
   345 set .DROP_TARGET .CORE
   346 set .DROP_X .CORE_X
   347 set .DROP_Y .CORE_Y
-    * set *tmp97 .DROP_Y
   348 jump *label74 always
   349 label *label73
   350 sensor *tmp98 .DROP_TARGET @x
   351 set .DROP_X *tmp98
   352 sensor *tmp99 .DROP_TARGET @y
   353 set .DROP_Y *tmp99
-    * set *tmp97 .DROP_Y
   354 label *label74
   355 set .LAST_ITEM @mono
-    * set :iter 0
   356 set :loop_time 0
   357 set :state 1
   358 ucontrol stop
 
   375 print UNIT
   376 print " "
   377 print "found."
-    * set *tmp108 null
   378 jump *label85 always
   379 label *label84
   380 sensor *tmp109 @unit @controlled
 
   390 jump *label80 always
   391 set *tmp111 null
   392 label *label87
-    * set *tmp108 *tmp111
   393 label *label85
   394 printflush message1
   395 label *label82
 
   398 label *label80
   399 ucontrol flag 1
   400 set :state 1
-    * set *tmp106 :state
   401 jump *label79 always
   402 label *label78
-    * set *tmp106 null
   403 label *label79
   404 sensor *tmp112 .SORTER @config
   405 set .ITEM *tmp112
 
   417 label *label92
   418 set .LAST_ITEM .ITEM
   419 set :state 1
-    * set *tmp114 :state
   420 jump *label89 always
   421 label *label88
-    * set *tmp114 null
   422 label *label89
   423 set :show_state 0
   424 op equal *tmp117 :state 1
 
   451 label *label98
   452 set *tmp121 *tmp124
   453 label *label96
-    * set *tmp118 *tmp121
   454 jump *label94 always
   455 label *label93
-    * set *tmp118 null
   456 label *label94
   457 op equal *tmp127 :state 2
   458 jump *label101 equal *tmp127 false
 
   481 set :show_state 2
   482 set *tmp130 :show_state
   483 label *label104
-    * set *tmp128 *tmp130
   484 jump *label102 always
   485 label *label101
-    * set *tmp128 null
   486 label *label102
   487 op equal *tmp137 :state 3
   488 jump *label107 equal *tmp137 false
 
   512 set :show_state 3
   513 set *tmp140 :show_state
   514 label *label110
-    * set *tmp138 *tmp140
   515 jump *label108 always
   516 label *label107
-    * set *tmp138 null
   517 label *label108
-    * set :iter 0
   518 print "Moving [green]"
   519 print .ITEM
   520 print .DIRECTION
 
   532 print .LOCAL_MARGIN
   533 print "["
   534 print "])"
-    * set *tmp149 null
   535 jump *label114 always
   536 label *label113
-    * set *tmp149 null
   537 label *label114
   538 jump *label115 equal .SHOW_REMOTE_LEVEL false
   539 sensor *tmp151 .CORE .ITEM
 
   553 label *label117
   554 set *tmp153 null
   555 label *label118
-    * set *tmp150 *tmp153
   556 jump *label116 always
   557 label *label115
-    * set *tmp150 null
   558 label *label116
   559 sensor *tmp154 @unit @totalItems
   560 print .MSG
 
   575 print " "
   576 print "sec[]"
   577 print "\n"
-    * set *tmp156 null
   578 jump *label120 always
   579 label *label119
   580 op equal *tmp164 :show_state 3
 
   596 label *label121
   597 set *tmp165 null
   598 label *label122
-    * set *tmp156 *tmp165
   599 label *label120
   600 op floor *tmp173 :loop_time
   601 print "[lightgray]Loop time: "
 
   607 op equal *tmp175 *tmp174 0
   608 jump *label123 equal *tmp175 false
   609 jump *label77 always
-    * set *tmp176 null
   610 jump *label124 always
   611 label *label123
-    * set *tmp176 null
   612 label *label124
   613 sensor *tmp177 .SRC @dead
   614 op notEqual *tmp178 *tmp177 0
   615 jump *label125 equal *tmp178 false
   616 jump *label77 always
-    * set *tmp179 null
   617 jump *label126 always
   618 label *label125
-    * set *tmp179 null
   619 label *label126
   620 sensor *tmp180 .DST @dead
   621 op notEqual *tmp181 *tmp180 0
   622 jump *label127 equal *tmp181 false
   623 jump *label77 always
-    * set *tmp182 null
   624 jump *label128 always
   625 label *label127
-    * set *tmp182 null
   626 label *label128
   627 sensor *tmp183 .SORTER @dead
   628 op notEqual *tmp184 *tmp183 0
   629 jump *label129 equal *tmp184 false
   630 jump *label77 always
-    * set *tmp185 null
   631 jump *label130 always
   632 label *label129
-    * set *tmp185 null
   633 label *label130
   634 op sub *tmp186 @time :start
   635 set :loop_time *tmp186
 
   673 label *label139
   674 jump *label138 always
   675 label *label140
-    * set *tmp193 null
   676 jump *label135 always
   677 label *label134
-    * set *tmp193 null
   678 label *label135
   679 end

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-18 instructions):
 
    83 print UNIT
    84 print "."
    85 print ".."
-    * set *tmp19 null
    86 jump *label25 always
    87 label *label24
    88 jump *label18 always
-    * set *tmp19 null
    89 label *label25
    90 label *label23
    91 printflush message1
 
   150 print "\"
   151 print "n"
   152 print "[salmon]Item dump must be a container or a vault!"
-    * set *tmp35 null
   153 jump *label37 always
   154 label *label36
   155 jump *label28 always
-    * set *tmp35 null
   156 label *label37
   157 label *label35
   158 printflush message1
 
   224 label *label54
   225 set *tmp57 null
   226 label *label55
-    * set *tmp46 *tmp57
   227 jump *label48 always
   228 label *label47
-    * set *tmp46 null
   229 label *label48
   230 label *label41
   231 op equal *tmp58 .CORE null
 
   378 print UNIT
   379 print "."
   380 print ".."
-    * set *tmp111 null
   381 jump *label87 always
   382 label *label86
   383 jump *label80 always
-    * set *tmp111 null
   384 label *label87
   385 label *label85
   386 printflush message1
 
   419 op equal *tmp120 *tmp119 .ITEM
   420 jump *label95 equal *tmp120 false
   421 set :state 3
-    * set *tmp121 :state
   422 jump *label96 always
   423 label *label95
   424 sensor *tmp122 @unit @totalItems
 
   440 label *label100
   441 set *tmp124 *tmp126
   442 label *label98
-    * set *tmp121 *tmp124
   443 label *label96
   444 jump *label94 always
   445 label *label93
 
   463 set .MSG "\nLoading items: [green]"
   464 set *tmp136 .MSG
   465 label *label106
-    * set *tmp130 *tmp136
   466 jump *label104 always
   467 label *label103
   468 ucontrol approach .SRC_X .SRC_Y 6
   469 set .MSG "\nGoing to source: [green]"
   470 set :show_state 2
-    * set *tmp130 :show_state
   471 label *label104
   472 jump *label102 always
   473 label *label101
 
   492 set .MSG "\nDropping items: [green]"
   493 set *tmp146 .MSG
   494 label *label112
-    * set *tmp140 *tmp146
   495 jump *label110 always
   496 label *label109
   497 ucontrol approach .DST_X .DST_Y 6
   498 set .MSG "\nGoing to destination: [green]"
   499 set :show_state 3
-    * set *tmp140 :show_state
   500 label *label110
   501 jump *label108 always
   502 label *label107
 
   534 print .REMOTE_MARGIN
   535 print "["
   536 print "])"
-    * set *tmp153 null
   537 jump *label118 always
   538 label *label117
-    * set *tmp153 null
   539 label *label118
   540 jump *label116 always
   541 label *label115
 
   575 print " "
   576 print "sec[]"
   577 print "\n"
-    * set *tmp165 null
   578 jump *label122 always
   579 label *label121
-    * set *tmp165 null
   580 label *label122
   581 label *label120
   582 op floor *tmp173 :loop_time

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-8 instructions):
 
   219 op notEqual *tmp56 :b_type @vault
   220 jump *label54 equal *tmp56 false
   221 set .CORE null
-    * set *tmp57 .CORE
   222 jump *label55 always
   223 label *label54
-    * set *tmp57 null
   224 label *label55
   225 jump *label48 always
   226 label *label47
 
   423 op equal *tmp123 *tmp122 0
   424 jump *label97 equal *tmp123 false
   425 set :state 2
-    * set *tmp124 :state
   426 jump *label98 always
   427 label *label97
   428 set .MSG "\nUnloading previous items: [green]"
 
   435 label *label99
   436 set *tmp126 null
   437 label *label100
-    * set *tmp124 *tmp126
   438 label *label98
   439 label *label96
   440 jump *label94 always
 
   453 op greaterThanEq *tmp135 *tmp134 .UNIT_CAPACITY
   454 jump *label105 equal *tmp135 false
   455 set :state 3
-    * set *tmp136 :state
   456 jump *label106 always
   457 label *label105
   458 set .MSG "\nLoading items: [green]"
-    * set *tmp136 .MSG
   459 label *label106
   460 jump *label104 always
   461 label *label103
 
   480 jump *label111 equal *tmp145 false
   481 set :state 2
   482 ucontrol approach .SRC_X .SRC_Y 6
-    * set *tmp146 null
   483 jump *label112 always
   484 label *label111
   485 set .MSG "\nDropping items: [green]"
-    * set *tmp146 .MSG
   486 label *label112
   487 jump *label110 always
   488 label *label109

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   430 ucontrol within .DROP_X .DROP_Y 8 *tmp125
   431 jump *label99 equal *tmp125 false
   432 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * set *tmp126 null
   433 jump *label100 always
   434 label *label99
-    * set *tmp126 null
   435 label *label100
   436 label *label98
   437 label *label96

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-38 instructions):
 
     5 set LOCAL_LIMIT 100
     6 remark "How much of remote container capacity to use, in percents (20-100)."
     7 set REMOTE_LIMIT 100
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+    8 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+    9 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    10 label *label0
    11 sensor *tmp2 switch1 @enabled
    12 op equal *tmp3 *tmp2 false
 
    29 ubind UNIT
    30 op notEqual *tmp6 @unit null
    31 jump *label10 equal *tmp6 false
-    * set *tmp8 @unit
-    * set :rebindUnit:first_unit *tmp8
+   32 set :rebindUnit:first_unit @unit
    33 jump *label9 always
    34 jump *label11 always
    35 label *label10
 
    94 label *label4
    95 jump *label3 always
    96 label *label5
-    * sensor *tmp20 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp20
+   97 sensor .UNIT_CAPACITY @unit @itemCapacity
    98 sensor *tmp21 @unit @speed
-    * op div *tmp22 *tmp21 10
-    * set .SPEED_SEC *tmp22
+   99 op div .SPEED_SEC *tmp21 10
   100 ucontrol flag 1
   101 label *label26
   102 jump *label28 equal true false
   103 set .CONTAINER null
   104 set .DROP_TARGET null
-    * set *tmp23 @links
-    * set :n *tmp23
+  105 set :n @links
   106 label *label29
   107 op greaterThan *tmp24 :n 0
   108 jump *label31 equal *tmp24 false
-    * op sub *tmp25 :n 1
-    * set :n *tmp25
-    * getlink *tmp26 :n
-    * set :block *tmp26
+  109 op sub :n :n 1
+  110 getlink :block :n
   111 sensor *tmp27 :block @itemCapacity
   112 op greaterThan *tmp28 *tmp27 0
   113 jump *label32 equal *tmp28 false
 
   156 jump *label40 equal *tmp36 false
   157 print "[gold]Locating core..."
   158 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp39 *tmp38
-    * set .CORE *tmp38
+  159 ulocate building core false @copper .CORE_X .CORE_Y *tmp39 .CORE
   160 jump *label41 always
   161 label *label40
   162 print "[gold]Locating vault #"
 
   164 print "."
   165 print ".."
   166 printflush message1
-    * op add *tmp40 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp40
+  167 op add .QUERY_FLAG 99999900 LINK_ID
   168 set :flag .QUERY_FLAG
   169 ucontrol flag :flag
   170 label *label42
 
   177 jump *label45 always
   178 label *label45
   179 ucontrol stop
-    * sensor *tmp44 @unit @flag
-    * set :flag *tmp44
+  180 sensor :flag @unit @flag
   181 label *label43
   182 jump *label42 always
   183 label *label44
   184 op notEqual *tmp45 :flag .QUERY_FLAG
   185 jump *label47 equal *tmp45 false
-    * op idiv *tmp47 :flag 100
-    * set :position *tmp47
-    * op mod *tmp48 :position @mapw
-    * set .CORE_X *tmp48
-    * op idiv *tmp49 :position @mapw
-    * set .CORE_Y *tmp49
+  186 op idiv :position :flag 100
+  187 op mod .CORE_X :position @mapw
+  188 op idiv .CORE_Y :position @mapw
   189 label *label49
   190 ucontrol within .CORE_X .CORE_Y 8 *tmp50
   191 op equal *tmp51 *tmp50 false
 
   200 label *label50
   201 jump *label49 always
   202 label *label51
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp54 *tmp55
-    * set .CORE *tmp54
+  203 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp55
   204 op notEqual *tmp56 :b_type @vault
   205 jump *label54 equal *tmp56 false
   206 set .CORE null
 
   218 label *label56
   219 label *label57
   220 set .SORTER sorter1
-    * sensor *tmp60 .SORTER @type
-    * set :sorter_type *tmp60
+  221 sensor :sorter_type .SORTER @type
   222 label *label58
   223 op notEqual *tmp61 :sorter_type @sorter
   224 jump *label60 equal *tmp61 false
 
   238 label *label64
   239 printflush message1
   240 set .SORTER sorter1
-    * sensor *tmp65 .SORTER @type
-    * set :sorter_type *tmp65
+  241 sensor :sorter_type .SORTER @type
   242 label *label59
   243 jump *label58 always
   244 label *label60
 
   247 set .SHOW_REMOTE_LEVEL true
   248 set .SRC .CORE
   249 set .DST .CONTAINER
-    * sensor *tmp68 .SRC @itemCapacity
-    * set :src_capacity *tmp68
-    * sensor *tmp69 .DST @itemCapacity
-    * set :dst_capacity *tmp69
+  250 sensor :src_capacity .SRC @itemCapacity
+  251 sensor :dst_capacity .DST @itemCapacity
   252 op sub *tmp70 100 .EFF_REMOTE_LIMIT
   253 op mul *tmp71 :src_capacity *tmp70
-    * op idiv *tmp72 *tmp71 100
-    * set .LOAD_LEVEL *tmp72
+  254 op idiv .LOAD_LEVEL *tmp71 100
   255 op mul *tmp73 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp74 *tmp73 100
-    * set .DROP_LEVEL *tmp74
+  256 op idiv .DROP_LEVEL *tmp73 100
   257 set .LOCAL_MARGIN .DROP_LEVEL
   258 set .REMOTE_MARGIN .LOAD_LEVEL
   259 op equal *tmp75 LINK_ID 0
 
   266 set .DIRECTION *tmp76
   267 jump *label66 always
   268 label *label65
-    * op greaterThan *tmp77 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp77
+  269 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   270 set .SRC .CONTAINER
   271 set .DST .CORE
-    * sensor *tmp78 .SRC @itemCapacity
-    * set :src_capacity *tmp78
-    * sensor *tmp79 .DST @itemCapacity
-    * set :dst_capacity *tmp79
+  272 sensor :src_capacity .SRC @itemCapacity
+  273 sensor :dst_capacity .DST @itemCapacity
   274 op sub *tmp80 100 .EFF_LOCAL_LIMIT
   275 op mul *tmp81 :src_capacity *tmp80
-    * op idiv *tmp82 *tmp81 100
-    * set .LOAD_LEVEL *tmp82
+  276 op idiv .LOAD_LEVEL *tmp81 100
   277 op mul *tmp83 :dst_capacity .EFF_REMOTE_LIMIT
   278 op idiv *tmp84 *tmp83 100
   279 op equal *tmp85 LINK_ID 0
   280 op mul *tmp86 *tmp85 .UNIT_CAPACITY
-    * op add *tmp87 *tmp84 *tmp86
-    * set .DROP_LEVEL *tmp87
+  281 op add .DROP_LEVEL *tmp84 *tmp86
   282 set .LOCAL_MARGIN .LOAD_LEVEL
   283 set .REMOTE_MARGIN .DROP_LEVEL
   284 op equal *tmp88 LINK_ID 0
 
   298 set *tmp91 LINK_ID
   299 label *label72
   300 set .LINK_TXT *tmp91
-    * sensor *tmp92 .SRC @x
-    * set .SRC_X *tmp92
-    * sensor *tmp93 .SRC @y
-    * set .SRC_Y *tmp93
-    * sensor *tmp94 .DST @x
-    * set .DST_X *tmp94
-    * sensor *tmp95 .DST @y
-    * set .DST_Y *tmp95
+  301 sensor .SRC_X .SRC @x
+  302 sensor .SRC_Y .SRC @y
+  303 sensor .DST_X .DST @x
+  304 sensor .DST_Y .DST @y
   305 op equal *tmp96 .DROP_TARGET null
   306 jump *label73 equal *tmp96 false
   307 set .DROP_TARGET .CORE
 
   309 set .DROP_Y .CORE_Y
   310 jump *label74 always
   311 label *label73
-    * sensor *tmp98 .DROP_TARGET @x
-    * set .DROP_X *tmp98
-    * sensor *tmp99 .DROP_TARGET @y
-    * set .DROP_Y *tmp99
+  312 sensor .DROP_X .DROP_TARGET @x
+  313 sensor .DROP_Y .DROP_TARGET @y
   314 label *label74
   315 set .LAST_ITEM @mono
   316 set :loop_time 0
 
   318 ucontrol stop
   319 label *label75
   320 jump *label77 equal true false
-    * set *tmp100 @time
-    * set :start *tmp100
+  321 set :start @time
   322 sensor *tmp101 @unit @dead
   323 op equal *tmp102 *tmp101 0
   324 sensor *tmp103 @unit @controller
 
   358 jump *label79 always
   359 label *label78
   360 label *label79
-    * sensor *tmp112 .SORTER @config
-    * set .ITEM *tmp112
+  361 sensor .ITEM .SORTER @config
   362 op notEqual *tmp113 .ITEM .LAST_ITEM
   363 jump *label88 equal *tmp113 false
   364 label *label90
 
   366 jump *label92 equal *tmp115 false
   367 print "[salmon]No item type selected for transport."
   368 printflush message1
-    * sensor *tmp116 .SORTER @config
-    * set .ITEM *tmp116
+  369 sensor .ITEM .SORTER @config
   370 label *label91
   371 jump *label90 always
   372 label *label92
 
   409 jump *label103 equal *tmp129 false
   410 sensor *tmp131 .SRC .ITEM
   411 op sub *tmp132 *tmp131 .LOAD_LEVEL
-    * op max *tmp133 *tmp132 0
-    * set :max_load *tmp133
+  412 op max :max_load *tmp132 0
   413 ucontrol itemTake .SRC .ITEM :max_load
   414 sensor *tmp134 @unit @totalItems
   415 op greaterThanEq *tmp135 *tmp134 .UNIT_CAPACITY
 
   434 jump *label109 equal *tmp139 false
   435 sensor *tmp141 .DST .ITEM
   436 op sub *tmp142 .DROP_LEVEL *tmp141
-    * op max *tmp143 *tmp142 0
-    * set :max_drop *tmp143
+  437 op max :max_drop *tmp142 0
   438 ucontrol itemDrop .DST :max_drop
   439 sensor *tmp144 @unit @totalItems
   440 op lessThanEq *tmp145 *tmp144 0
 
   566 jump *label130 always
   567 label *label129
   568 label *label130
-    * op sub *tmp186 @time :start
-    * set :loop_time *tmp186
+  569 op sub :loop_time @time :start
   570 label *label76
   571 jump *label75 always
   572 label *label77

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-5 instructions):
 
    25 jump *label5 equal *tmp5 false
    26 set :rebindUnit:first_unit null
    27 label *label7
-    * jump *label9 equal true false
    28 ubind UNIT
    29 op notEqual *tmp6 @unit null
    30 jump *label10 equal *tmp6 false
 
    62 jump *label12 always
    63 label *label14
    64 label *label19
-    * jump *label21 equal true false
    65 ubind UNIT
    66 op equal *tmp15 @unit null
    67 jump *label22 equal *tmp15 false
 
    97 op div .SPEED_SEC *tmp21 10
    98 ucontrol flag 1
    99 label *label26
-    * jump *label28 equal true false
   100 set .CONTAINER null
   101 set .DROP_TARGET null
   102 set :n @links
 
   314 set :state 1
   315 ucontrol stop
   316 label *label75
-    * jump *label77 equal true false
   317 set :start @time
   318 sensor *tmp101 @unit @dead
   319 op equal *tmp102 *tmp101 0
 
   322 op lessThanEq *tmp105 *tmp102 *tmp104
   323 jump *label78 equal *tmp105 false
   324 label *label81
-    * jump *label83 equal true false
   325 ubind UNIT
   326 op equal *tmp107 @unit null
   327 jump *label84 equal *tmp107 false

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-2 instructions):
 
    58 label *label17
    59 sensor *tmp13 :rebindUnit:first_unit @dead
    60 op equal *tmp14 *tmp13 0
-    * jump *label14 equal *tmp14 false
-    * jump *label12 always
+   61 jump *label12 notEqual *tmp14 false
    62 label *label14
    63 label *label19
    64 ubind UNIT
 
   584 label *label137
   585 sensor *tmp191 .DST @dead
   586 op notEqual *tmp192 *tmp191 0
-    * jump *label136 notEqual *tmp192 false
-    * jump *label134 always
+  587 jump *label134 equal *tmp192 false
   588 label *label136
   589 control enabled switch1 false
   590 label *label138

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-53 instructions):
 
     9 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    10 label *label0
    11 sensor *tmp2 switch1 @enabled
-    * op equal *tmp3 *tmp2 false
-    * jump *label2 equal *tmp3 false
+   12 jump *label2 notEqual *tmp2 false
    13 print "Unit Transport - Single"
    14 print "\n"
    15 print "Activate switch to start."
 
    20 label *label2
    21 label *label3
    22 sensor *tmp4 @unit @dead
-    * op notEqual *tmp5 *tmp4 0
-    * jump *label5 equal *tmp5 false
+   23 jump *label5 equal *tmp4 0
    24 set :rebindUnit:first_unit null
    25 label *label7
    26 ubind UNIT
-    * op notEqual *tmp6 @unit null
-    * jump *label10 equal *tmp6 false
+   27 jump *label10 equal @unit null
    28 set :rebindUnit:first_unit @unit
    29 jump *label9 always
    30 jump *label11 always
 
    40 label *label9
    41 label *label12
    42 sensor *tmp9 @unit @controller
-    * op equal *tmp10 *tmp9 @this
-    * jump *label15 equal *tmp10 false
+   43 jump *label15 notEqual *tmp9 @this
    44 jump *label6 always
    45 jump *label16 always
    46 label *label15
 
    49 print "[gold]Looking for old unit..."
    50 printflush message1
    51 label *label13
-    * op notEqual *tmp12 @unit :rebindUnit:first_unit
-    * jump *label14 equal *tmp12 false
+   52 jump *label14 equal @unit :rebindUnit:first_unit
    53 label *label17
    54 sensor *tmp13 :rebindUnit:first_unit @dead
-    * op equal *tmp14 *tmp13 0
-    * jump *label12 notEqual *tmp14 false
+   55 jump *label12 equal *tmp13 0
    56 label *label14
    57 label *label19
    58 ubind UNIT
-    * op equal *tmp15 @unit null
-    * jump *label22 equal *tmp15 false
+   59 jump *label22 notEqual @unit null
    60 print "[salmon]No unit of type "
    61 print UNIT
    62 print " "
 
    64 jump *label23 always
    65 label *label22
    66 sensor *tmp17 @unit @controlled
-    * op notEqual *tmp18 *tmp17 0
-    * jump *label24 equal *tmp18 false
+   67 jump *label24 equal *tmp17 0
    68 print "[salmon]Looking for a free "
    69 print UNIT
    70 print "."
 
    92 set .DROP_TARGET null
    93 set :n @links
    94 label *label29
-    * op greaterThan *tmp24 :n 0
-    * jump *label31 equal *tmp24 false
+   95 jump *label31 lessThanEq :n 0
    96 op sub :n :n 1
    97 getlink :block :n
    98 sensor *tmp27 :block @itemCapacity
-    * op greaterThan *tmp28 *tmp27 0
-    * jump *label32 equal *tmp28 false
+   99 jump *label32 lessThanEq *tmp27 0
   100 set .DROP_TARGET .CONTAINER
   101 set .CONTAINER :block
   102 jump *label33 always
 
   105 label *label30
   106 jump *label29 always
   107 label *label31
-    * op equal *tmp30 .CONTAINER null
-    * jump *label34 equal *tmp30 false
+  108 jump *label34 notEqual .CONTAINER null
   109 print "[salmon]No destination."
   110 print "\n"
   111 jump *label35 always
   112 label *label34
-    * op notEqual *tmp32 .DROP_TARGET null
-    * jump *label36 equal *tmp32 false
+  113 jump *label36 equal .DROP_TARGET null
   114 label *label39
   115 sensor *tmp33 .DROP_TARGET @itemCapacity
-    * op lessThan *tmp34 *tmp33 300
-    * jump *label36 equal *tmp34 false
+  116 jump *label36 greaterThanEq *tmp33 300
   117 jump *label38 always
   118 label *label38
   119 print "Destination: "
 
   135 jump *label26 always
   136 label *label28
   137 set .CORE null
-    * op equal *tmp36 LINK_ID 0
-    * jump *label40 equal *tmp36 false
+  138 jump *label40 notEqual LINK_ID 0
   139 print "[gold]Locating core..."
   140 printflush message1
   141 ulocate building core false @copper .CORE_X .CORE_Y *tmp39 .CORE
 
   150 set :flag .QUERY_FLAG
   151 ucontrol flag :flag
   152 label *label42
-    * op equal *tmp41 :flag .QUERY_FLAG
-    * jump *label44 equal *tmp41 false
+  153 jump *label44 notEqual :flag .QUERY_FLAG
   154 label *label46
   155 sensor *tmp42 @unit @dead
-    * op equal *tmp43 *tmp42 0
-    * jump *label44 equal *tmp43 false
+  156 jump *label44 notEqual *tmp42 0
   157 jump *label45 always
   158 label *label45
   159 ucontrol stop
 
   161 label *label43
   162 jump *label42 always
   163 label *label44
-    * op notEqual *tmp45 :flag .QUERY_FLAG
-    * jump *label47 equal *tmp45 false
+  164 jump *label47 equal :flag .QUERY_FLAG
   165 op idiv :position :flag 100
   166 op mod .CORE_X :position @mapw
   167 op idiv .CORE_Y :position @mapw
   168 label *label49
   169 ucontrol within .CORE_X .CORE_Y 8 *tmp50
-    * op equal *tmp51 *tmp50 false
-    * jump *label51 equal *tmp51 false
+  170 jump *label51 notEqual *tmp50 false
   171 label *label53
   172 sensor *tmp52 @unit @dead
-    * op equal *tmp53 *tmp52 0
-    * jump *label51 equal *tmp53 false
+  173 jump *label51 notEqual *tmp52 0
   174 jump *label52 always
   175 label *label52
   176 ucontrol approach .CORE_X .CORE_Y 6
 
   178 jump *label49 always
   179 label *label51
   180 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp55
-    * op notEqual *tmp56 :b_type @vault
-    * jump *label54 equal *tmp56 false
+  181 jump *label54 equal :b_type @vault
   182 set .CORE null
   183 jump *label55 always
   184 label *label54
 
   187 label *label47
   188 label *label48
   189 label *label41
-    * op equal *tmp58 .CORE null
-    * jump *label56 equal *tmp58 false
+  190 jump *label56 notEqual .CORE null
   191 end
   192 jump *label57 always
   193 label *label56
 
   195 set .SORTER sorter1
   196 sensor :sorter_type .SORTER @type
   197 label *label58
-    * op notEqual *tmp61 :sorter_type @sorter
-    * jump *label60 equal *tmp61 false
+  198 jump *label60 equal :sorter_type @sorter
   199 label *label62
-    * op notEqual *tmp62 :sorter_type @inverted-sorter
-    * jump *label60 equal *tmp62 false
+  200 jump *label60 equal :sorter_type @inverted-sorter
   201 jump *label61 always
   202 label *label61
   203 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   204 print "\n"
-    * op notEqual *tmp63 .SORTER null
-    * jump *label63 equal *tmp63 false
+  205 jump *label63 equal .SORTER null
   206 print "Block found: "
   207 print .SORTER
   208 jump *label64 always
 
   214 label *label59
   215 jump *label58 always
   216 label *label60
-    * op equal *tmp66 :sorter_type @sorter
-    * jump *label65 equal *tmp66 false
+  217 jump *label65 notEqual :sorter_type @sorter
   218 set .SHOW_REMOTE_LEVEL true
   219 set .SRC .CORE
   220 set .DST .CONTAINER
 
   227 op idiv .DROP_LEVEL *tmp73 100
   228 set .LOCAL_MARGIN .DROP_LEVEL
   229 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op equal *tmp75 LINK_ID 0
-    * jump *label67 equal *tmp75 false
+  230 jump *label67 notEqual LINK_ID 0
   231 set *tmp76 "[] from core"
   232 jump *label68 always
   233 label *label67
 
   251 op add .DROP_LEVEL *tmp84 *tmp86
   252 set .LOCAL_MARGIN .LOAD_LEVEL
   253 set .REMOTE_MARGIN .DROP_LEVEL
-    * op equal *tmp88 LINK_ID 0
-    * jump *label69 equal *tmp88 false
+  254 jump *label69 notEqual LINK_ID 0
   255 set *tmp89 "[] to core"
   256 jump *label70 always
   257 label *label69
 
   259 label *label70
   260 set .DIRECTION *tmp89
   261 label *label66
-    * op equal *tmp90 LINK_ID 0
-    * jump *label71 equal *tmp90 false
+  262 jump *label71 notEqual LINK_ID 0
   263 set *tmp91 ""
   264 jump *label72 always
   265 label *label71
 
   270 sensor .SRC_Y .SRC @y
   271 sensor .DST_X .DST @x
   272 sensor .DST_Y .DST @y
-    * op equal *tmp96 .DROP_TARGET null
-    * jump *label73 equal *tmp96 false
+  273 jump *label73 notEqual .DROP_TARGET null
   274 set .DROP_TARGET .CORE
   275 set .DROP_X .CORE_X
   276 set .DROP_Y .CORE_Y
 
   289 op equal *tmp102 *tmp101 0
   290 sensor *tmp103 @unit @controller
   291 op notEqual *tmp104 *tmp103 @this
-    * op lessThanEq *tmp105 *tmp102 *tmp104
-    * jump *label78 equal *tmp105 false
+  292 jump *label78 greaterThan *tmp102 *tmp104
   293 label *label81
   294 ubind UNIT
-    * op equal *tmp107 @unit null
-    * jump *label84 equal *tmp107 false
+  295 jump *label84 notEqual @unit null
   296 print "[salmon]No unit of type "
   297 print UNIT
   298 print " "
 
   300 jump *label85 always
   301 label *label84
   302 sensor *tmp109 @unit @controlled
-    * op notEqual *tmp110 *tmp109 0
-    * jump *label86 equal *tmp110 false
+  303 jump *label86 equal *tmp109 0
   304 print "[salmon]Looking for a free "
   305 print UNIT
   306 print "."
 
   321 label *label78
   322 label *label79
   323 sensor .ITEM .SORTER @config
-    * op notEqual *tmp113 .ITEM .LAST_ITEM
-    * jump *label88 equal *tmp113 false
+  324 jump *label88 equal .ITEM .LAST_ITEM
   325 label *label90
-    * op equal *tmp115 .ITEM null
-    * jump *label92 equal *tmp115 false
+  326 jump *label92 notEqual .ITEM null
   327 print "[salmon]No item type selected for transport."
   328 printflush message1
   329 sensor .ITEM .SORTER @config
 
   336 label *label88
   337 label *label89
   338 set :show_state 0
-    * op equal *tmp117 :state 1
-    * jump *label93 equal *tmp117 false
+  339 jump *label93 notEqual :state 1
   340 sensor *tmp119 @unit @firstItem
-    * op equal *tmp120 *tmp119 .ITEM
-    * jump *label95 equal *tmp120 false
+  341 jump *label95 notEqual *tmp119 .ITEM
   342 set :state 3
   343 jump *label96 always
   344 label *label95
   345 sensor *tmp122 @unit @totalItems
-    * op equal *tmp123 *tmp122 0
-    * jump *label97 equal *tmp123 false
+  346 jump *label97 notEqual *tmp122 0
   347 set :state 2
   348 jump *label98 always
   349 label *label97
 
   360 jump *label94 always
   361 label *label93
   362 label *label94
-    * op equal *tmp127 :state 2
-    * jump *label101 equal *tmp127 false
+  363 jump *label101 notEqual :state 2
   364 ucontrol within .SRC_X .SRC_Y 8 *tmp129
   365 jump *label103 equal *tmp129 false
   366 sensor *tmp131 .SRC .ITEM
 
   368 op max :max_load *tmp132 0
   369 ucontrol itemTake .SRC .ITEM :max_load
   370 sensor *tmp134 @unit @totalItems
-    * op greaterThanEq *tmp135 *tmp134 .UNIT_CAPACITY
-    * jump *label105 equal *tmp135 false
+  371 jump *label105 lessThan *tmp134 .UNIT_CAPACITY
   372 set :state 3
   373 jump *label106 always
   374 label *label105
 
   383 jump *label102 always
   384 label *label101
   385 label *label102
-    * op equal *tmp137 :state 3
-    * jump *label107 equal *tmp137 false
+  386 jump *label107 notEqual :state 3
   387 ucontrol within .DST_X .DST_Y 8 *tmp139
   388 jump *label109 equal *tmp139 false
   389 sensor *tmp141 .DST .ITEM
 
   391 op max :max_drop *tmp142 0
   392 ucontrol itemDrop .DST :max_drop
   393 sensor *tmp144 @unit @totalItems
-    * op lessThanEq *tmp145 *tmp144 0
-    * jump *label111 equal *tmp145 false
+  394 jump *label111 greaterThan *tmp144 0
   395 set :state 2
   396 ucontrol approach .SRC_X .SRC_Y 6
   397 jump *label112 always
 
   418 print *tmp147
   419 print "["
   420 print "]"
-    * op lessThan *tmp148 .EFF_LOCAL_LIMIT 100
-    * jump *label113 equal *tmp148 false
+  421 jump *label113 greaterThanEq .EFF_LOCAL_LIMIT 100
   422 print " (limit [orange]"
   423 print .LOCAL_MARGIN
   424 print "["
 
   433 print *tmp151
   434 print "["
   435 print "]"
-    * op lessThan *tmp152 .EFF_REMOTE_LIMIT 100
-    * jump *label117 equal *tmp152 false
+  436 jump *label117 greaterThanEq .EFF_REMOTE_LIMIT 100
   437 print " (limit [orange]"
   438 print .REMOTE_MARGIN
   439 print "["
 
   449 print *tmp154
   450 print "[]"
   451 print "\n"
-    * op equal *tmp155 :show_state 2
-    * jump *label119 equal *tmp155 false
+  452 jump *label119 notEqual :show_state 2
   453 sensor *tmp157 @unit @x
   454 op sub *tmp158 .SRC_X *tmp157
   455 sensor *tmp159 @unit @y
 
   464 print "\n"
   465 jump *label120 always
   466 label *label119
-    * op equal *tmp164 :show_state 3
-    * jump *label121 equal *tmp164 false
+  467 jump *label121 notEqual :show_state 3
   468 sensor *tmp166 @unit @x
   469 op sub *tmp167 .DST_X *tmp166
   470 sensor *tmp168 @unit @y
 
   488 print "\n"
   489 printflush message1
   490 sensor *tmp174 switch1 @enabled
-    * op equal *tmp175 *tmp174 0
-    * jump *label123 equal *tmp175 false
+  491 jump *label123 notEqual *tmp174 0
   492 jump *label77 always
   493 jump *label124 always
   494 label *label123
   495 label *label124
   496 sensor *tmp177 .SRC @dead
-    * op notEqual *tmp178 *tmp177 0
-    * jump *label125 equal *tmp178 false
+  497 jump *label125 equal *tmp177 0
   498 jump *label77 always
   499 jump *label126 always
   500 label *label125
   501 label *label126
   502 sensor *tmp180 .DST @dead
-    * op notEqual *tmp181 *tmp180 0
-    * jump *label127 equal *tmp181 false
+  503 jump *label127 equal *tmp180 0
   504 jump *label77 always
   505 jump *label128 always
   506 label *label127
   507 label *label128
   508 sensor *tmp183 .SORTER @dead
-    * op notEqual *tmp184 *tmp183 0
-    * jump *label129 equal *tmp184 false
+  509 jump *label129 equal *tmp183 0
   510 jump *label77 always
   511 jump *label130 always
   512 label *label129
 
   517 label *label77
   518 label *label131
   519 sensor *tmp187 .SORTER @dead
-    * op equal *tmp188 *tmp187 0
-    * jump *label133 equal *tmp188 false
+  520 jump *label133 notEqual *tmp187 0
   521 print "[salmon]sorter1 is missing!"
   522 print "\n"
   523 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   529 jump *label131 always
   530 label *label133
   531 sensor *tmp189 .SRC @dead
-    * op notEqual *tmp190 *tmp189 0
-    * jump *label136 notEqual *tmp190 false
+  532 jump *label136 notEqual *tmp189 0
   533 label *label137
   534 sensor *tmp191 .DST @dead
-    * op notEqual *tmp192 *tmp191 0
-    * jump *label134 equal *tmp192 false
+  535 jump *label134 equal *tmp191 0
   536 label *label136
   537 control enabled switch1 false
   538 label *label138
   539 sensor *tmp195 switch1 @enabled
-    * op equal *tmp196 *tmp195 false
-    * jump *label140 equal *tmp196 false
+  540 jump *label140 notEqual *tmp195 false
   541 print "[salmon]Local or remote container became invalid."
   542 print "\n"
   543 print "[gold]Please fix and press button to reinitialize."

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-26 instructions):
 
    27 jump *label10 equal @unit null
    28 set :rebindUnit:first_unit @unit
    29 jump *label9 always
-    * jump *label11 always
    30 label *label10
    31 label *label11
    32 print "[salmon]No unit of type "
 
    41 sensor *tmp9 @unit @controller
    42 jump *label15 notEqual *tmp9 @this
    43 jump *label6 always
-    * jump *label16 always
    44 label *label15
    45 label *label16
    46 ubind UNIT
 
    97 jump *label32 lessThanEq *tmp27 0
    98 set .DROP_TARGET .CONTAINER
    99 set .CONTAINER :block
-    * jump *label33 always
   100 label *label32
   101 label *label33
   102 label *label30
 
   111 label *label39
   112 sensor *tmp33 .DROP_TARGET @itemCapacity
   113 jump *label36 greaterThanEq *tmp33 300
-    * jump *label38 always
   114 label *label38
   115 print "Destination: "
   116 print .CONTAINER
 
   150 label *label46
   151 sensor *tmp42 @unit @dead
   152 jump *label44 notEqual *tmp42 0
-    * jump *label45 always
   153 label *label45
   154 ucontrol stop
   155 sensor :flag @unit @flag
 
   166 label *label53
   167 sensor *tmp52 @unit @dead
   168 jump *label51 notEqual *tmp52 0
-    * jump *label52 always
   169 label *label52
   170 ucontrol approach .CORE_X .CORE_Y 6
   171 label *label50
 
   174 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp55
   175 jump *label54 equal :b_type @vault
   176 set .CORE null
-    * jump *label55 always
   177 label *label54
   178 label *label55
-    * jump *label48 always
   179 label *label47
   180 label *label48
   181 label *label41
   182 jump *label56 notEqual .CORE null
   183 end
-    * jump *label57 always
   184 label *label56
   185 label *label57
   186 set .SORTER sorter1
 
   189 jump *label60 equal :sorter_type @sorter
   190 label *label62
   191 jump *label60 equal :sorter_type @inverted-sorter
-    * jump *label61 always
   192 label *label61
   193 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   194 print "\n"
   195 jump *label63 equal .SORTER null
   196 print "Block found: "
   197 print .SORTER
-    * jump *label64 always
   198 label *label63
   199 label *label64
   200 printflush message1
 
   306 label *label80
   307 ucontrol flag 1
   308 set :state 1
-    * jump *label79 always
   309 label *label78
   310 label *label79
   311 sensor .ITEM .SORTER @config
 
   320 label *label92
   321 set .LAST_ITEM .ITEM
   322 set :state 1
-    * jump *label89 always
   323 label *label88
   324 label *label89
   325 set :show_state 0
 
   339 ucontrol within .DROP_X .DROP_Y 8 *tmp125
   340 jump *label99 equal *tmp125 false
   341 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * jump *label100 always
   342 label *label99
   343 label *label100
   344 label *label98
   345 label *label96
-    * jump *label94 always
   346 label *label93
   347 label *label94
   348 jump *label101 notEqual :state 2
 
   365 set .MSG "\nGoing to source: [green]"
   366 set :show_state 2
   367 label *label104
-    * jump *label102 always
   368 label *label101
   369 label *label102
   370 jump *label107 notEqual :state 3
 
   388 set .MSG "\nGoing to destination: [green]"
   389 set :show_state 3
   390 label *label110
-    * jump *label108 always
   391 label *label107
   392 label *label108
   393 print "Moving [green]"
 
   406 print .LOCAL_MARGIN
   407 print "["
   408 print "])"
-    * jump *label114 always
   409 label *label113
   410 label *label114
   411 jump *label115 equal .SHOW_REMOTE_LEVEL false
 
   420 print .REMOTE_MARGIN
   421 print "["
   422 print "])"
-    * jump *label118 always
   423 label *label117
   424 label *label118
-    * jump *label116 always
   425 label *label115
   426 label *label116
   427 sensor *tmp154 @unit @totalItems
 
   457 print " "
   458 print "sec[]"
   459 print "\n"
-    * jump *label122 always
   460 label *label121
   461 label *label122
   462 label *label120
 
   469 sensor *tmp174 switch1 @enabled
   470 jump *label123 notEqual *tmp174 0
   471 jump *label77 always
-    * jump *label124 always
   472 label *label123
   473 label *label124
   474 sensor *tmp177 .SRC @dead
   475 jump *label125 equal *tmp177 0
   476 jump *label77 always
-    * jump *label126 always
   477 label *label125
   478 label *label126
   479 sensor *tmp180 .DST @dead
   480 jump *label127 equal *tmp180 0
   481 jump *label77 always
-    * jump *label128 always
   482 label *label127
   483 label *label128
   484 sensor *tmp183 .SORTER @dead
   485 jump *label129 equal *tmp183 0
   486 jump *label77 always
-    * jump *label130 always
   487 label *label129
   488 label *label130
   489 op sub :loop_time @time :start
 
   522 label *label139
   523 jump *label138 always
   524 label *label140
-    * jump *label135 always
   525 label *label134
   526 label *label135
   527 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   144 printflush message1
   145 op add .QUERY_FLAG 99999900 LINK_ID
   146 set :flag .QUERY_FLAG
-    * ucontrol flag :flag
+  147 ucontrol flag .QUERY_FLAG
   148 label *label42
   149 jump *label44 notEqual :flag .QUERY_FLAG
   150 label *label46
 
   184 label *label56
   185 label *label57
   186 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  187 sensor :sorter_type sorter1 @type
   188 label *label58
   189 jump *label60 equal :sorter_type @sorter
   190 label *label62
 
   199 label *label64
   200 printflush message1
   201 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  202 sensor :sorter_type sorter1 @type
   203 label *label59
   204 jump *label58 always
   205 label *label60
 
   207 set .SHOW_REMOTE_LEVEL true
   208 set .SRC .CORE
   209 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  210 sensor :src_capacity .CORE @itemCapacity
+  211 sensor :dst_capacity .CONTAINER @itemCapacity
   212 op sub *tmp70 100 .EFF_REMOTE_LIMIT
   213 op mul *tmp71 :src_capacity *tmp70
   214 op idiv .LOAD_LEVEL *tmp71 100
 
   228 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   229 set .SRC .CONTAINER
   230 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  231 sensor :src_capacity .CONTAINER @itemCapacity
+  232 sensor :dst_capacity .CORE @itemCapacity
   233 op sub *tmp80 100 .EFF_LOCAL_LIMIT
   234 op mul *tmp81 :src_capacity *tmp80
   235 op idiv .LOAD_LEVEL *tmp81 100
 
   393 print "Moving [green]"
   394 print .ITEM
   395 print .DIRECTION
-    * print .LINK_TXT
+  396 print *tmp91
   397 print "\"
   398 print "n"
   399 sensor *tmp147 .CONTAINER .ITEM

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   254 label *label71
   255 set *tmp91 LINK_ID
   256 label *label72
-    * set .LINK_TXT *tmp91
   257 sensor .SRC_X .SRC @x
   258 sensor .SRC_Y .SRC @y
   259 sensor .DST_X .DST @x

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
    48 printflush message1
    49 label *label13
    50 jump *label14 equal @unit :rebindUnit:first_unit
-    * label *label17
    51 sensor *tmp13 :rebindUnit:first_unit @dead
    52 jump *label12 equal *tmp13 0
    53 label *label14
 
    90 set :n @links
    91 label *label29
    92 jump *label31 lessThanEq :n 0
+   93 label *label141
    94 op sub :n :n 1
    95 getlink :block :n
    96 sensor *tmp27 :block @itemCapacity
 
   100 label *label32
   101 label *label33
   102 label *label30
-    * jump *label29 always
+  103 jump *label141 greaterThan :n 0
   104 label *label31
   105 jump *label34 notEqual .CONTAINER null
   106 print "[salmon]No destination."
 
   147 ucontrol flag .QUERY_FLAG
   148 label *label42
   149 jump *label44 notEqual :flag .QUERY_FLAG
-    * label *label46
+  150 label *label142
   151 sensor *tmp42 @unit @dead
   152 jump *label44 notEqual *tmp42 0
-    * label *label45
   153 ucontrol stop
   154 sensor :flag @unit @flag
   155 label *label43
-    * jump *label42 always
+  156 jump *label142 equal :flag .QUERY_FLAG
   157 label *label44
   158 jump *label47 equal :flag .QUERY_FLAG
   159 op idiv :position :flag 100
 
   162 label *label49
   163 ucontrol within .CORE_X .CORE_Y 8 *tmp50
   164 jump *label51 notEqual *tmp50 false
-    * label *label53
   165 sensor *tmp52 @unit @dead
   166 jump *label51 notEqual *tmp52 0
-    * label *label52
   167 ucontrol approach .CORE_X .CORE_Y 6
   168 label *label50
   169 jump *label49 always
 
   184 sensor :sorter_type sorter1 @type
   185 label *label58
   186 jump *label60 equal :sorter_type @sorter
-    * label *label62
+  187 label *label143
   188 jump *label60 equal :sorter_type @inverted-sorter
-    * label *label61
   189 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   190 print "\n"
   191 jump *label63 equal .SORTER null
 
   197 set .SORTER sorter1
   198 sensor :sorter_type sorter1 @type
   199 label *label59
-    * jump *label58 always
+  200 jump *label143 notEqual :sorter_type @sorter
   201 label *label60
   202 jump *label65 notEqual :sorter_type @sorter
   203 set .SHOW_REMOTE_LEVEL true
 
   307 jump *label88 equal .ITEM .LAST_ITEM
   308 label *label90
   309 jump *label92 notEqual .ITEM null
+  310 label *label144
   311 print "[salmon]No item type selected for transport."
   312 printflush message1
   313 sensor .ITEM .SORTER @config
   314 label *label91
-    * jump *label90 always
+  315 jump *label144 equal .ITEM null
   316 label *label92
   317 set .LAST_ITEM .ITEM
   318 set :state 1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
   210 op idiv .DROP_LEVEL *tmp73 100
   211 set .LOCAL_MARGIN .DROP_LEVEL
   212 set .REMOTE_MARGIN .LOAD_LEVEL
-    * jump *label67 notEqual LINK_ID 0
-    * set *tmp76 "[] from core"
+  213 set .DIRECTION "[] from vault #"
+  214 jump *label68 notEqual LINK_ID 0
+  215 set .DIRECTION "[] from core"
   216 jump *label68 always
-    * label *label67
-    * set *tmp76 "[] from vault #"
   217 label *label68
-    * set .DIRECTION *tmp76
   218 jump *label66 always
   219 label *label65
   220 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   232 op add .DROP_LEVEL *tmp84 *tmp86
   233 set .LOCAL_MARGIN .LOAD_LEVEL
   234 set .REMOTE_MARGIN .DROP_LEVEL
-    * jump *label69 notEqual LINK_ID 0
-    * set *tmp89 "[] to core"
+  235 set .DIRECTION "[] to vault #"
+  236 jump *label70 notEqual LINK_ID 0
+  237 set .DIRECTION "[] to core"
   238 jump *label70 always
-    * label *label69
-    * set *tmp89 "[] to vault #"
   239 label *label70
-    * set .DIRECTION *tmp89
   240 label *label66
-    * jump *label71 notEqual LINK_ID 0
+  241 set *tmp91 LINK_ID
+  242 jump *label72 notEqual LINK_ID 0
   243 set *tmp91 ""
   244 jump *label72 always
-    * label *label71
-    * set *tmp91 LINK_ID
   245 label *label72
   246 sensor .SRC_X .SRC @x
   247 sensor .SRC_Y .SRC @y

Modifications by Partial loop rotation at line 44:1 (+1 instructions):
 
    10 label *label0
    11 sensor *tmp2 switch1 @enabled
    12 jump *label2 notEqual *tmp2 false
+   13 label *label145
    14 print "Unit Transport - Single"
    15 print "\n"
    16 print "Activate switch to start."
    17 print "\n"
    18 printflush message1
    19 label *label1
-    * jump *label0 always
+   20 sensor *tmp2 switch1 @enabled
+   21 jump *label145 equal *tmp2 false
    22 label *label2
    23 label *label3
    24 sensor *tmp4 @unit @dead

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   146 set :flag .QUERY_FLAG
   147 ucontrol flag .QUERY_FLAG
   148 label *label42
-    * jump *label44 notEqual :flag .QUERY_FLAG
+  149 jump *label44 notEqual .QUERY_FLAG .QUERY_FLAG
   150 label *label142
   151 sensor *tmp42 @unit @dead
   152 jump *label44 notEqual *tmp42 0

Modifications by Partial loop rotation at line 52:1 (+1 instructions):
 
    23 label *label3
    24 sensor *tmp4 @unit @dead
    25 jump *label5 equal *tmp4 0
+   26 label *label146
    27 set :rebindUnit:first_unit null
    28 label *label7
    29 ubind UNIT
 
    81 label *label18
    82 label *label6
    83 label *label4
-    * jump *label3 always
+   84 sensor *tmp4 @unit @dead
+   85 jump *label146 notEqual *tmp4 0
    86 label *label5
    87 sensor .UNIT_CAPACITY @unit @itemCapacity
    88 sensor *tmp21 @unit @speed

Modifications by Partial loop rotation at line 306:1 (+1 instructions):
 
   486 label *label131
   487 sensor *tmp187 .SORTER @dead
   488 jump *label133 notEqual *tmp187 0
+  489 label *label147
   490 print "[salmon]sorter1 is missing!"
   491 print "\n"
   492 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   495 printflush message2
   496 set .SORTER sorter1
   497 label *label132
-    * jump *label131 always
+  498 sensor *tmp187 .SORTER @dead
+  499 jump *label147 equal *tmp187 0
   500 label *label133
   501 sensor *tmp189 .SRC @dead
   502 jump *label136 notEqual *tmp189 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   495 printflush message2
   496 set .SORTER sorter1
   497 label *label132
-    * sensor *tmp187 .SORTER @dead
+  498 sensor *tmp187 sorter1 @dead
   499 jump *label147 equal *tmp187 0
   500 label *label133
   501 sensor *tmp189 .SRC @dead

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   493 print "\n"
   494 printflush message1
   495 printflush message2
-    * set .SORTER sorter1
   496 label *label132
   497 sensor *tmp187 sorter1 @dead
   498 jump *label147 equal *tmp187 0

Modifications by Partial loop rotation at line 316:5 (+1 instructions):
 
   506 label *label138
   507 sensor *tmp195 switch1 @enabled
   508 jump *label140 notEqual *tmp195 false
+  509 label *label148
   510 print "[salmon]Local or remote container became invalid."
   511 print "\n"
   512 print "[gold]Please fix and press button to reinitialize."
 
   514 printflush message1
   515 printflush message2
   516 label *label139
-    * jump *label138 always
+  517 sensor *tmp195 switch1 @enabled
+  518 jump *label148 equal *tmp195 false
   519 label *label140
   520 label *label134
   521 label *label135

Modifications by Partial loop rotation at line 112:9 (+1 instructions):
 
   164 label *label49
   165 ucontrol within .CORE_X .CORE_Y 8 *tmp50
   166 jump *label51 notEqual *tmp50 false
+  167 label *label149
   168 sensor *tmp52 @unit @dead
   169 jump *label51 notEqual *tmp52 0
   170 ucontrol approach .CORE_X .CORE_Y 6
   171 label *label50
-    * jump *label49 always
+  172 ucontrol within .CORE_X .CORE_Y 8 *tmp50
+  173 jump *label149 equal *tmp50 false
   174 label *label51
   175 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp55
   176 jump *label54 equal :b_type @vault

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   148 set :flag .QUERY_FLAG
   149 ucontrol flag .QUERY_FLAG
   150 label *label42
-    * jump *label44 notEqual .QUERY_FLAG .QUERY_FLAG
   151 label *label142
   152 sensor *tmp42 @unit @dead
   153 jump *label44 notEqual *tmp42 0

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
   218 set .DIRECTION "[] from vault #"
   219 jump *label68 notEqual LINK_ID 0
   220 set .DIRECTION "[] from core"
-    * jump *label68 always
   221 label *label68
   222 jump *label66 always
   223 label *label65
 
   239 set .DIRECTION "[] to vault #"
   240 jump *label70 notEqual LINK_ID 0
   241 set .DIRECTION "[] to core"
-    * jump *label70 always
   242 label *label70
   243 label *label66
   244 set *tmp91 LINK_ID
   245 jump *label72 notEqual LINK_ID 0
   246 set *tmp91 ""
-    * jump *label72 always
   247 label *label72
   248 sensor .SRC_X .SRC @x
   249 sensor .SRC_Y .SRC @y

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-5 instructions):
 
    37 label *label9
    38 label *label12
    39 sensor *tmp9 @unit @controller
-    * jump *label15 notEqual *tmp9 @this
-    * jump *label6 always
+   40 jump *label6 equal *tmp9 @this
    41 label *label15
    42 ubind UNIT
    43 print "[gold]Looking for old unit..."
 
   419 print "\n"
   420 printflush message1
   421 sensor *tmp174 switch1 @enabled
-    * jump *label123 notEqual *tmp174 0
-    * jump *label77 always
+  422 jump *label77 equal *tmp174 0
   423 label *label123
   424 sensor *tmp177 .SRC @dead
-    * jump *label125 equal *tmp177 0
-    * jump *label77 always
+  425 jump *label77 notEqual *tmp177 0
   426 label *label125
   427 sensor *tmp180 .DST @dead
-    * jump *label127 equal *tmp180 0
-    * jump *label77 always
+  428 jump *label77 notEqual *tmp180 0
   429 label *label127
   430 sensor *tmp183 .SORTER @dead
-    * jump *label129 equal *tmp183 0
-    * jump *label77 always
+  431 jump *label77 notEqual *tmp183 0
   432 label *label129
   433 op sub :loop_time @time :start
   434 jump *label75 always

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 remark "Which unit type to use"
     2 set UNIT @mega
     3 remark "Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core"
 
    56 jump *label23 always
    57 label *label22
    58 sensor *tmp17 @unit @controlled
-    * jump *label24 equal *tmp17 0
+   59 jump *label18 equal *tmp17 0
    60 print "[salmon]Looking for a free "
    61 print UNIT
    62 print "."
 
    97 print "\n"
    98 jump *label35 always
    99 label *label34
-    * jump *label36 equal .DROP_TARGET null
+  100 jump *label28 equal .DROP_TARGET null
   101 sensor *tmp33 .DROP_TARGET @itemCapacity
-    * jump *label36 greaterThanEq *tmp33 300
+  102 jump *label28 greaterThanEq *tmp33 300
   103 print "Destination: "
   104 print .CONTAINER
   105 print "\"
 
   191 set .LOCAL_MARGIN .DROP_LEVEL
   192 set .REMOTE_MARGIN .LOAD_LEVEL
   193 set .DIRECTION "[] from vault #"
-    * jump *label68 notEqual LINK_ID 0
+  194 jump *label66 notEqual LINK_ID 0
   195 set .DIRECTION "[] from core"
   196 label *label68
   197 jump *label66 always
 
   254 jump *label85 always
   255 label *label84
   256 sensor *tmp109 @unit @controlled
-    * jump *label86 equal *tmp109 0
+  257 jump *label80 equal *tmp109 0
   258 print "[salmon]Looking for a free "
   259 print UNIT
   260 print "."
 
   313 sensor *tmp134 @unit @totalItems
   314 jump *label105 lessThan *tmp134 .UNIT_CAPACITY
   315 set :state 3
-    * jump *label106 always
+  316 jump *label104 always
   317 label *label105
   318 set .MSG "\nLoading items: [green]"
   319 label *label106
 
   335 jump *label111 greaterThan *tmp144 0
   336 set :state 2
   337 ucontrol approach .SRC_X .SRC_Y 6
-    * jump *label112 always
+  338 jump *label110 always
   339 label *label111
   340 set .MSG "\nDropping items: [green]"
   341 label *label112
 
   444 sensor *tmp189 .SRC @dead
   445 jump *label136 notEqual *tmp189 0
   446 sensor *tmp191 .DST @dead
-    * jump *label134 equal *tmp191 0
+  447 jump __start__ equal *tmp191 0
   448 label *label136
   449 control enabled switch1 false
   450 sensor *tmp195 switch1 @enabled
-    * jump *label140 notEqual *tmp195 false
+  451 jump __start__ notEqual *tmp195 false
   452 label *label148
   453 print "[salmon]Local or remote container became invalid."
   454 print "\n"

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   452 printflush message2
   453 sensor *tmp195 switch1 @enabled
   454 jump *label148 equal *tmp195 false
-    * end

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-3 instructions):
 
    62 print "."
    63 print ".."
    64 jump *label25 always
-    * jump *label18 always
    65 label *label25
    66 label *label23
    67 printflush message1
 
   108 print "n"
   109 print "[salmon]Item dump must be a container or a vault!"
   110 jump *label37 always
-    * jump *label28 always
   111 label *label37
   112 label *label35
   113 printflush message1
 
   255 print "."
   256 print ".."
   257 jump *label87 always
-    * jump *label80 always
   258 label *label87
   259 label *label85
   260 printflush message1

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-3 instructions):
 
    61 print UNIT
    62 print "."
    63 print ".."
-    * jump *label25 always
    64 label *label25
    65 label *label23
    66 printflush message1
 
   106 print "\"
   107 print "n"
   108 print "[salmon]Item dump must be a container or a vault!"
-    * jump *label37 always
   109 label *label37
   110 label *label35
   111 printflush message1
 
   252 print UNIT
   253 print "."
   254 print ".."
-    * jump *label87 always
   255 label *label87
   256 label *label85
   257 printflush message1

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
   113 jump *label40 notEqual LINK_ID 0
   114 print "[gold]Locating core..."
   115 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp39 .CORE
+  116 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   117 jump *label41 always
   118 label *label40
   119 print "[gold]Locating vault #"
 
   144 ucontrol within .CORE_X .CORE_Y 8 *tmp50
   145 jump *label149 equal *tmp50 false
   146 label *label51
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp55
+  147 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   148 jump *label54 equal :b_type @vault
   149 set .CORE null
   150 label *label54

Modifications by Final phase, Print Merging, iteration 1 (-34 instructions):
 
    11 sensor *tmp2 switch1 @enabled
    12 jump *label2 notEqual *tmp2 false
    13 label *label145
-    * print "Unit Transport - Single"
-    * print "\n"
-    * print "Activate switch to start."
-    * print "\n"
+   14 print "Unit Transport - Single\nActivate switch to start.\n"
    15 printflush message1
    16 sensor *tmp2 switch1 @enabled
    17 jump *label145 equal *tmp2 false
 
    28 label *label10
    29 print "[salmon]No unit of type "
    30 print UNIT
-    * print " "
-    * print "found. 1"
+   31 print " found. 1"
    32 printflush message1
    33 jump *label7 always
    34 label *label9
 
    47 jump *label22 notEqual @unit null
    48 print "[salmon]No unit of type "
    49 print UNIT
-    * print " "
-    * print "found."
+   50 print " found."
    51 jump *label23 always
    52 label *label22
    53 sensor *tmp17 @unit @controlled
    54 jump *label18 equal *tmp17 0
    55 print "[salmon]Looking for a free "
    56 print UNIT
-    * print "."
-    * print ".."
+   57 print "..."
    58 label *label23
    59 printflush message1
    60 jump *label19 always
 
    83 jump *label141 greaterThan :n 0
    84 label *label31
    85 jump *label34 notEqual .CONTAINER null
-    * print "[salmon]No destination."
-    * print "\n"
+   86 print "[salmon]No destination.\n"
    87 jump *label35 always
    88 label *label34
    89 jump *label28 equal .DROP_TARGET null
 
    91 jump *label28 greaterThanEq *tmp33 300
    92 print "Destination: "
    93 print .CONTAINER
-    * print "\"
-    * print "n"
-    * print "Item dump: "
+   94 print "\nItem dump: "
    95 print .DROP_TARGET
-    * print "\"
-    * print "n"
-    * print "[salmon]Item dump must be a container or a vault!"
+   96 print "\n[salmon]Item dump must be a container or a vault!"
    97 label *label35
    98 printflush message1
    99 jump *label26 always
 
   107 label *label40
   108 print "[gold]Locating vault #"
   109 print LINK_ID
-    * print "."
-    * print ".."
+  110 print "..."
   111 printflush message1
   112 op add .QUERY_FLAG 99999900 LINK_ID
   113 set :flag .QUERY_FLAG
 
   146 jump *label60 equal :sorter_type @sorter
   147 label *label143
   148 jump *label60 equal :sorter_type @inverted-sorter
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  149 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   150 jump *label63 equal .SORTER null
   151 print "Block found: "
   152 print .SORTER
 
   227 jump *label84 notEqual @unit null
   228 print "[salmon]No unit of type "
   229 print UNIT
-    * print " "
-    * print "found."
+  230 print " found."
   231 jump *label85 always
   232 label *label84
   233 sensor *tmp109 @unit @controlled
   234 jump *label80 equal *tmp109 0
   235 print "[salmon]Looking for a free "
   236 print UNIT
-    * print "."
-    * print ".."
+  237 print "..."
   238 label *label85
   239 printflush message1
   240 jump *label81 always
 
   320 print .ITEM
   321 print .DIRECTION
   322 print *tmp91
-    * print "\"
-    * print "n"
   323 sensor *tmp147 .CONTAINER .ITEM
-    * print "Local items: [gold]"
+  324 print "\nLocal items: [gold]"
   325 print *tmp147
-    * print "["
-    * print "]"
+  326 print "[]"
   327 jump *label113 greaterThanEq .EFF_LOCAL_LIMIT 100
   328 print " (limit [orange]"
   329 print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  330 print "[])"
   331 label *label113
   332 jump *label115 equal .SHOW_REMOTE_LEVEL false
   333 sensor *tmp151 .CORE .ITEM
-    * print "\n"
-    * print "Remote items: [gold]"
+  334 print "\nRemote items: [gold]"
   335 print *tmp151
-    * print "["
-    * print "]"
+  336 print "[]"
   337 jump *label117 greaterThanEq .EFF_REMOTE_LIMIT 100
   338 print " (limit [orange]"
   339 print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  340 print "[])"
   341 label *label117
   342 label *label115
   343 sensor *tmp154 @unit @totalItems
   344 print .MSG
   345 print *tmp154
-    * print "[]"
-    * print "\n"
+  346 print "[]\n"
   347 jump *label119 notEqual :show_state 2
   348 sensor *tmp157 @unit @x
   349 op sub *tmp158 .SRC_X *tmp157
 
   354 op div *tmp163 *tmp162 10
   355 print "[]  arriving in [gold]"
   356 print *tmp163
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  357 print " sec[]\n"
   358 jump *label120 always
   359 label *label119
   360 jump *label121 notEqual :show_state 3
 
   367 op div *tmp172 *tmp171 10
   368 print "[]  arriving in [gold]"
   369 print *tmp172
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  370 print " sec[]\n"
   371 label *label121
   372 label *label120
   373 op floor *tmp173 :loop_time
   374 print "[lightgray]Loop time: "
   375 print *tmp173
-    * print " ms[]"
-    * print "\n"
+  376 print " ms[]\n"
   377 printflush message1
   378 sensor *tmp174 switch1 @enabled
   379 jump *label77 equal *tmp174 0
 
   389 sensor *tmp187 .SORTER @dead
   390 jump *label133 notEqual *tmp187 0
   391 label *label147
-    * print "[salmon]sorter1 is missing!"
-    * print "\n"
-    * print "[gold]Please place and link sorter or inverted sorter to the processor."
-    * print "\n"
+  392 print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
   393 printflush message1
   394 printflush message2
   395 sensor *tmp187 sorter1 @dead
 
   404 sensor *tmp195 switch1 @enabled
   405 jump __start__ notEqual *tmp195 false
   406 label *label148
-    * print "[salmon]Local or remote container became invalid."
-    * print "\n"
-    * print "[gold]Please fix and press button to reinitialize."
-    * print "\n"
+  407 print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
   408 printflush message1
   409 printflush message2
   410 sensor *tmp195 switch1 @enabled

Final code before resolving virtual instructions:

        label __start__
    0:  remark "Which unit type to use"                              param UNIT              = @mega;        /// Which unit type to use
    2:  set UNIT @mega                                               ...
    3:  remark "Remote vault ID (1-99); if nonzero, items are moved  param LINK_ID           = 0;            /// Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core
    5:  set LINK_ID 0                                                ...
    6:  remark "How much of local container capacity to use, in perc param LOCAL_LIMIT       = 100;          /// How much of local container capacity to use, in percents (20-100).
    8:  set LOCAL_LIMIT 100                                          ...
    9:  remark "How much of remote container capacity to use, in per param REMOTE_LIMIT      = 100;          /// How much of remote container capacity to use, in percents (20-100).
   11:  set REMOTE_LIMIT 100                                         ...
   12:  op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20                       var EFF_LOCAL_LIMIT = max(LOCAL_LIMIT, 20);
   13:  op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20                     var EFF_REMOTE_LIMIT = max(REMOTE_LIMIT, 20);
   14:  sensor *tmp2 switch1 @enabled                                while !switch1.@enabled do
   15:  jump *label2 notEqual *tmp2 false                            ...
        label *label145                                              ...
   16:  print "Unit Transport - Single\nActivate switch to start.\n" println("Activate switch to start.");
   17:  printflush message1                                          printflush(message1);
   18:  sensor *tmp2 switch1 @enabled                                while !switch1.@enabled do
   19:  jump *label145 equal *tmp2 false                             ...
        label *label2                                                ...
   20:  sensor *tmp4 @unit @dead                                     while @unit.@dead != 0 do
   21:  jump *label5 equal *tmp4 0                                   ...
        label *label146                                              ...
   22:  set :rebindUnit:first_unit null                              first_unit = null;
        label *label7                                                while true do
   23:  ubind UNIT                                                   ubind(UNIT);
   24:  jump *label10 equal @unit null                               if @unit != null then
   25:  set :rebindUnit:first_unit @unit                             first_unit = @unit;
   26:  jump *label9 always 0 0                                      break;
        label *label10                                               if @unit != null then
   27:  print "[salmon]No unit of type "                             print($"[salmon]No unit of type $UNIT found. 1");
   28:  print UNIT                                                   ...
   29:  print " found. 1"                                            ...
   30:  printflush message1                                          printflush(message1);
   31:  jump *label7 always 0 0                                      while true do
        label *label9                                                ...
        label *label12                                               do
   32:  sensor *tmp9 @unit @controller                               if @unit.@controller == @this then
   33:  jump *label6 equal *tmp9 @this                               ...
   34:  ubind UNIT                                                   ubind(UNIT);
   35:  print "[gold]Looking for old unit..."                        print($"[gold]Looking for old unit...");
   36:  printflush message1                                          printflush(message1);
   37:  jump *label14 equal @unit :rebindUnit:first_unit             while @unit != first_unit and first_unit.@dead == 0;
   38:  sensor *tmp13 :rebindUnit:first_unit @dead                   ...
   39:  jump *label12 equal *tmp13 0                                 ...
        label *label14                                               do
        label *label19                                               while true do
   40:  ubind UNIT                                                   ubind(UNIT);
   41:  jump *label22 notEqual @unit null                            if @unit == null then
   42:  print "[salmon]No unit of type "                             print($"[salmon]No unit of type $UNIT found.");
   43:  print UNIT                                                   ...
   44:  print " found."                                              ...
   45:  jump *label23 always 0 0                                     if @unit == null then
        label *label22                                               ...
   46:  sensor *tmp17 @unit @controlled                              elsif @unit.@controlled != 0 then
   47:  jump *label18 equal *tmp17 0                                 ...
   48:  print "[salmon]Looking for a free "                          print($"[salmon]Looking for a free $UNIT...");
   49:  print UNIT                                                   ...
   50:  print "..."                                                  ...
        label *label23                                               if @unit == null then
   51:  printflush message1                                          printflush(message1);
   52:  jump *label19 always 0 0                                     while true do
        label *label18                                               findUnit();
        label *label6                                                rebindUnit();
   53:  sensor *tmp4 @unit @dead                                     while @unit.@dead != 0 do
   54:  jump *label146 notEqual *tmp4 0                              ...
        label *label5                                                ...
   55:  sensor .UNIT_CAPACITY @unit @itemCapacity                    UNIT_CAPACITY = @unit.@itemCapacity;
   56:  sensor *tmp21 @unit @speed                                   SPEED_SEC = @unit.@speed / 10;
   57:  op div .SPEED_SEC *tmp21 10                                  ...
   58:  ucontrol flag 1 0 0 0 0                                      flag(1);
        label *label26                                               while true do
   59:  set .CONTAINER null                                          CONTAINER = null;
   60:  set .DROP_TARGET null                                        DROP_TARGET = null;
   61:  set :n @links                                                n = @links;
   62:  jump *label31 lessThanEq :n 0                                while n > 0 do
        label *label141                                              ...
   63:  op sub :n :n 1                                               n = n - 1;
   64:  getlink :block :n                                            block = getlink(n);
   65:  sensor *tmp27 :block @itemCapacity                           if block.@itemCapacity > 0 then
   66:  jump *label32 lessThanEq *tmp27 0                            ...
   67:  set .DROP_TARGET .CONTAINER                                  DROP_TARGET = CONTAINER;
   68:  set .CONTAINER :block                                        CONTAINER = block;
        label *label32                                               if block.@itemCapacity > 0 then
   69:  jump *label141 greaterThan :n 0                              while n > 0 do
        label *label31                                               ...
   70:  jump *label34 notEqual .CONTAINER null                       if CONTAINER == null then
   71:  print "[salmon]No destination.\n"                            println("[salmon]No destination.");
   72:  jump *label35 always 0 0                                     if CONTAINER == null then
        label *label34                                               ...
   73:  jump *label28 equal .DROP_TARGET null                        elsif (DROP_TARGET != null) and (DROP_TARGET.@itemCapacity < 300) then
   74:  sensor *tmp33 .DROP_TARGET @itemCapacity                     ...
   75:  jump *label28 greaterThanEq *tmp33 300                       ...
   76:  print "Destination: "                                        print($"Destination: $CONTAINER\n");
   77:  print .CONTAINER                                             ...
   78:  print "\nItem dump: "                                        print($"Item dump: $DROP_TARGET\n");
   79:  print .DROP_TARGET                                           ...
   80:  print "\n[salmon]Item dump must be a container or a vault!"  print($"[salmon]Item dump must be a container or a vault!");
        label *label35                                               if CONTAINER == null then
   81:  printflush message1                                          printflush(message1);
   82:  jump *label26 always 0 0                                     while true do
        label *label28                                               ...
   83:  set .CORE null                                               CORE = null;
   84:  jump *label40 notEqual LINK_ID 0                             if LINK_ID == 0 then
   85:  print "[gold]Locating core..."                               print("[gold]Locating core...");
   86:  printflush message1                                          printflush(message1);
   87:  ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE  CORE = ulocate(:building, :core, false, out CORE_X, out CORE_Y);
   88:  jump *label41 always 0 0                                     if LINK_ID == 0 then
        label *label40                                               ...
   89:  print "[gold]Locating vault #"                               print($"[gold]Locating vault #$LINK_ID...");
   90:  print LINK_ID                                                ...
   91:  print "..."                                                  ...
   92:  printflush message1                                          printflush(message1);
   93:  op add .QUERY_FLAG 99999900 LINK_ID                          QUERY_FLAG = 99999900 + LINK_ID;
   94:  set :flag .QUERY_FLAG                                        flag = QUERY_FLAG;
   95:  ucontrol flag .QUERY_FLAG 0 0 0 0                            flag(flag);
        label *label142                                              while (flag == QUERY_FLAG) and (@unit.@dead == 0) do
   96:  sensor *tmp42 @unit @dead                                    ...
   97:  jump *label44 notEqual *tmp42 0                              ...
   98:  ucontrol stop 0 0 0 0 0                                      stop();                       // Keep controlling the unit
   99:  sensor :flag @unit @flag                                     flag = @unit.@flag;
  100:  jump *label142 equal :flag .QUERY_FLAG                       while (flag == QUERY_FLAG) and (@unit.@dead == 0) do
        label *label44                                               ...
  101:  jump *label47 equal :flag .QUERY_FLAG                        if (flag != QUERY_FLAG) then
  102:  op idiv :position :flag 100                                  position = flag \ 100;
  103:  op mod .CORE_X :position @mapw                               CORE_X = position % @mapw;
  104:  op idiv .CORE_Y :position @mapw                              CORE_Y = position \ @mapw;
  105:  ucontrol within .CORE_X .CORE_Y 8 *tmp50 0                   while (within(CORE_X, CORE_Y, RADIUS_WITHIN) == false) and (@unit.@dead == 0) do
  106:  jump *label51 notEqual *tmp50 false                          ...
        label *label149                                              ...
  107:  sensor *tmp52 @unit @dead                                    ...
  108:  jump *label51 notEqual *tmp52 0                              ...
  109:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  110:  ucontrol within .CORE_X .CORE_Y 8 *tmp50 0                   while (within(CORE_X, CORE_Y, RADIUS_WITHIN) == false) and (@unit.@dead == 0) do
  111:  jump *label149 equal *tmp50 false                            ...
        label *label51                                               ...
  112:  ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0            CORE = getBlock(CORE_X, CORE_Y, out b_type);
  113:  jump *label54 equal :b_type @vault                           if b_type != @vault then
  114:  set .CORE null                                               CORE = null;
        label *label54                                               if b_type != @vault then
        label *label47                                               if (flag != QUERY_FLAG) then
        label *label41                                               if LINK_ID == 0 then
  115:  jump *label56 notEqual .CORE null                            if CORE == null then
  116:  end                                                          end();
        label *label56                                               if CORE == null then
  117:  set .SORTER sorter1                                          SORTER = sorter1;
  118:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  119:  jump *label60 equal :sorter_type @sorter                     while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
        label *label143                                              ...
  120:  jump *label60 equal :sorter_type @inverted-sorter            ...
  121:  print "[salmon]Block sorter1 is neither a sorter, nor an inv println("[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.");
  122:  jump *label63 equal .SORTER null                             if SORTER != null then
  123:  print "Block found: "                                        print("Block found: ", SORTER);
  124:  print .SORTER                                                ...
        label *label63                                               if SORTER != null then
  125:  printflush message1                                          printflush(message1);
  126:  set .SORTER sorter1                                          SORTER = sorter1;
  127:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  128:  jump *label143 notEqual :sorter_type @sorter                 while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
        label *label60                                               ...
  129:  jump *label65 notEqual :sorter_type @sorter                  if (sorter_type == @sorter) then
  130:  set .SHOW_REMOTE_LEVEL true                                  SHOW_REMOTE_LEVEL = true;
  131:  set .SRC .CORE                                               SRC = CORE;
  132:  set .DST .CONTAINER                                          DST = CONTAINER;
  133:  sensor :src_capacity .CORE @itemCapacity                     src_capacity = SRC.@itemCapacity;
  134:  sensor :dst_capacity .CONTAINER @itemCapacity                dst_capacity = DST.@itemCapacity;
  135:  op sub *tmp70 100 .EFF_REMOTE_LIMIT                          LOAD_LEVEL = (src_capacity * (100 - EFF_REMOTE_LIMIT)) \ 100;
  136:  op mul *tmp71 :src_capacity *tmp70                           ...
  137:  op idiv .LOAD_LEVEL *tmp71 100                               ...
  138:  op mul *tmp73 :dst_capacity .EFF_LOCAL_LIMIT                 DROP_LEVEL = (dst_capacity * EFF_LOCAL_LIMIT) \ 100;
  139:  op idiv .DROP_LEVEL *tmp73 100                               ...
  140:  set .LOCAL_MARGIN .DROP_LEVEL                                LOCAL_MARGIN = DROP_LEVEL;
  141:  set .REMOTE_MARGIN .LOAD_LEVEL                               REMOTE_MARGIN = LOAD_LEVEL;
  142:  set .DIRECTION "[] from vault #"                             DIRECTION = (LINK_ID == 0) ? "[] from core"  : "[] from vault #";
  143:  jump *label66 notEqual LINK_ID 0                             ...
  144:  set .DIRECTION "[] from core"                                ...
  145:  jump *label66 always 0 0                                     if (sorter_type == @sorter) then
        label *label65                                               ...
  146:  op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0                  SHOW_REMOTE_LEVEL = LINK_ID > 0;
  147:  set .SRC .CONTAINER                                          SRC = CONTAINER;
  148:  set .DST .CORE                                               DST = CORE;
  149:  sensor :src_capacity .CONTAINER @itemCapacity                src_capacity = SRC.@itemCapacity;
  150:  sensor :dst_capacity .CORE @itemCapacity                     dst_capacity = DST.@itemCapacity;
  151:  op sub *tmp80 100 .EFF_LOCAL_LIMIT                           LOAD_LEVEL = (src_capacity * (100 - EFF_LOCAL_LIMIT)) \ 100;
  152:  op mul *tmp81 :src_capacity *tmp80                           ...
  153:  op idiv .LOAD_LEVEL *tmp81 100                               ...
  154:  op mul *tmp83 :dst_capacity .EFF_REMOTE_LIMIT                DROP_LEVEL = (dst_capacity * EFF_REMOTE_LIMIT) \ 100 + ((LINK_ID == 0) * UNIT_CAPACITY);
  155:  op idiv *tmp84 *tmp83 100                                    ...
  156:  op equal *tmp85 LINK_ID 0                                    ...
  157:  op mul *tmp86 *tmp85 .UNIT_CAPACITY                          ...
  158:  op add .DROP_LEVEL *tmp84 *tmp86                             ...
  159:  set .LOCAL_MARGIN .LOAD_LEVEL                                LOCAL_MARGIN = LOAD_LEVEL;
  160:  set .REMOTE_MARGIN .DROP_LEVEL                               REMOTE_MARGIN = DROP_LEVEL;
  161:  set .DIRECTION "[] to vault #"                               DIRECTION = (LINK_ID == 0) ? "[] to core" : "[] to vault #";
  162:  jump *label70 notEqual LINK_ID 0                             ...
  163:  set .DIRECTION "[] to core"                                  ...
        label *label70                                               ...
        label *label66                                               if (sorter_type == @sorter) then
  164:  set *tmp91 LINK_ID                                           LINK_TXT = (LINK_ID == 0) ? ""  : LINK_ID;
  165:  jump *label72 notEqual LINK_ID 0                             ...
  166:  set *tmp91 ""                                                ...
        label *label72                                               ...
  167:  sensor .SRC_X .SRC @x                                        SRC_X = SRC.@x;
  168:  sensor .SRC_Y .SRC @y                                        SRC_Y = SRC.@y;
  169:  sensor .DST_X .DST @x                                        DST_X = DST.@x;
  170:  sensor .DST_Y .DST @y                                        DST_Y = DST.@y;
  171:  jump *label73 notEqual .DROP_TARGET null                     if DROP_TARGET == null then
  172:  set .DROP_TARGET .CORE                                       DROP_TARGET = CORE;
  173:  set .DROP_X .CORE_X                                          DROP_X = CORE_X;
  174:  set .DROP_Y .CORE_Y                                          DROP_Y = CORE_Y;
  175:  jump *label74 always 0 0                                     if DROP_TARGET == null then
        label *label73                                               ...
  176:  sensor .DROP_X .DROP_TARGET @x                               DROP_X = DROP_TARGET.@x;
  177:  sensor .DROP_Y .DROP_TARGET @y                               DROP_Y = DROP_TARGET.@y;
        label *label74                                               if DROP_TARGET == null then
  178:  set .LAST_ITEM @mono                                         LAST_ITEM = @mono;      // Must not be null
  179:  set :loop_time 0                                             loop_time = 0;
  180:  set :state 1                                                 state = S_UNLOAD;
  181:  ucontrol stop 0 0 0 0 0                                      stop();
        label *label75                                               while true do
  182:  set :start @time                                             start = @time;
  183:  sensor *tmp101 @unit @dead                                   if (@unit.@dead == 0) <= (@unit.@controller != @this) then
  184:  op equal *tmp102 *tmp101 0                                   ...
  185:  sensor *tmp103 @unit @controller                             ...
  186:  op notEqual *tmp104 *tmp103 @this                            ...
  187:  jump *label78 greaterThan *tmp102 *tmp104                    ...
        label *label81                                               while true do
  188:  ubind UNIT                                                   ubind(UNIT);
  189:  jump *label84 notEqual @unit null                            if @unit == null then
  190:  print "[salmon]No unit of type "                             print($"[salmon]No unit of type $UNIT found.");
  191:  print UNIT                                                   ...
  192:  print " found."                                              ...
  193:  jump *label85 always 0 0                                     if @unit == null then
        label *label84                                               ...
  194:  sensor *tmp109 @unit @controlled                             elsif @unit.@controlled != 0 then
  195:  jump *label80 equal *tmp109 0                                ...
  196:  print "[salmon]Looking for a free "                          print($"[salmon]Looking for a free $UNIT...");
  197:  print UNIT                                                   ...
  198:  print "..."                                                  ...
        label *label85                                               if @unit == null then
  199:  printflush message1                                          printflush(message1);
  200:  jump *label81 always 0 0                                     while true do
        label *label80                                               findUnit();
  201:  ucontrol flag 1 0 0 0 0                                      flag(1);            // Mark unit as active
  202:  set :state 1                                                 state = S_UNLOAD;   // We'll unload our unit first
        label *label78                                               if (@unit.@dead == 0) <= (@unit.@controller != @this) then
  203:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  204:  jump *label88 equal .ITEM .LAST_ITEM                         if ITEM != LAST_ITEM then
  205:  jump *label92 notEqual .ITEM null                            while ITEM == null do
        label *label144                                              ...
  206:  print "[salmon]No item type selected for transport."         print("[salmon]No item type selected for transport.");
  207:  printflush message1                                          printflush(message1);
  208:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  209:  jump *label144 equal .ITEM null                              while ITEM == null do
        label *label92                                               ...
  210:  set .LAST_ITEM .ITEM                                         LAST_ITEM = ITEM;
  211:  set :state 1                                                 state = S_UNLOAD;
        label *label88                                               if ITEM != LAST_ITEM then
  212:  set :show_state 0                                            show_state = S_UNUSED;
  213:  jump *label93 notEqual :state 1                              if state == S_UNLOAD then
  214:  sensor *tmp119 @unit @firstItem                              if @unit.@firstItem == ITEM then
  215:  jump *label95 notEqual *tmp119 .ITEM                         ...
  216:  set :state 3                                                 state = S_APPROACH_DST;
  217:  jump *label96 always 0 0                                     if @unit.@firstItem == ITEM then
        label *label95                                               ...
  218:  sensor *tmp122 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  219:  jump *label97 notEqual *tmp122 0                             ...
  220:  set :state 2                                                 state = S_APPROACH_SRC;
  221:  jump *label98 always 0 0                                     elsif @unit.@totalItems == 0 then
        label *label97                                               ...
  222:  set .MSG "\nUnloading previous items: [green]"               MSG = "\nUnloading previous items: [green]";
  223:  ucontrol approach .DROP_X .DROP_Y 6 0 0                      approach(DROP_X, DROP_Y, RADIUS_APPROACH);
  224:  ucontrol within .DROP_X .DROP_Y 8 *tmp125 0                  if within(DROP_X, DROP_Y, RADIUS_WITHIN) then
  225:  jump *label99 equal *tmp125 false                            ...
  226:  ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY 0 0 0          itemDrop(DROP_TARGET, UNIT_CAPACITY);
        label *label99                                               if within(DROP_X, DROP_Y, RADIUS_WITHIN) then
        label *label98                                               elsif @unit.@totalItems == 0 then
        label *label96                                               if @unit.@firstItem == ITEM then
        label *label93                                               if state == S_UNLOAD then
  227:  jump *label101 notEqual :state 2                             if state == S_APPROACH_SRC then
  228:  ucontrol within .SRC_X .SRC_Y 8 *tmp129 0                    if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
  229:  jump *label103 equal *tmp129 false                           ...
  230:  sensor *tmp131 .SRC .ITEM                                    max_load = max(SRC.sensor(ITEM) - LOAD_LEVEL, 0);
  231:  op sub *tmp132 *tmp131 .LOAD_LEVEL                           ...
  232:  op max :max_load *tmp132 0                                   ...
  233:  ucontrol itemTake .SRC .ITEM :max_load 0 0                   itemTake(SRC, ITEM, max_load);
  234:  sensor *tmp134 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  235:  jump *label105 lessThan *tmp134 .UNIT_CAPACITY               ...
  236:  set :state 3                                                 state = S_APPROACH_DST;
  237:  jump *label104 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label105                                              ...
  238:  set .MSG "\nLoading items: [green]"                          MSG = "\nLoading items: [green]";
  239:  jump *label104 always 0 0                                    if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label103                                              ...
  240:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  241:  set .MSG "\nGoing to source: [green]"                        MSG = "\nGoing to source: [green]";
  242:  set :show_state 2                                            show_state = S_APPROACH_SRC;
        label *label104                                              if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label101                                              if state == S_APPROACH_SRC then
  243:  jump *label107 notEqual :state 3                             if state == S_APPROACH_DST then
  244:  ucontrol within .DST_X .DST_Y 8 *tmp139 0                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
  245:  jump *label109 equal *tmp139 false                           ...
  246:  sensor *tmp141 .DST .ITEM                                    max_drop = max(DROP_LEVEL - DST.sensor(ITEM), 0);
  247:  op sub *tmp142 .DROP_LEVEL *tmp141                           ...
  248:  op max :max_drop *tmp142 0                                   ...
  249:  ucontrol itemDrop .DST :max_drop 0 0 0                       itemDrop(DST, max_drop);
  250:  sensor *tmp144 @unit @totalItems                             if @unit.@totalItems <= 0 then
  251:  jump *label111 greaterThan *tmp144 0                         ...
  252:  set :state 2                                                 state = S_APPROACH_SRC;
  253:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  254:  jump *label110 always 0 0                                    if @unit.@totalItems <= 0 then
        label *label111                                              ...
  255:  set .MSG "\nDropping items: [green]"                         MSG = "\nDropping items: [green]";
  256:  jump *label110 always 0 0                                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label109                                              ...
  257:  ucontrol approach .DST_X .DST_Y 6 0 0                        approach(DST_X, DST_Y, RADIUS_APPROACH);
  258:  set .MSG "\nGoing to destination: [green]"                   MSG = "\nGoing to destination: [green]";
  259:  set :show_state 3                                            show_state = S_APPROACH_DST;
        label *label110                                              if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label107                                              if state == S_APPROACH_DST then
  260:  print "Moving [green]"                                       print($"Moving [green]$ITEM$DIRECTION$LINK_TXT\n");
  261:  print .ITEM                                                  ...
  262:  print .DIRECTION                                             ...
  263:  print *tmp91                                                 ...
  264:  sensor *tmp147 .CONTAINER .ITEM                              print($"Local items: [gold]$[]", CONTAINER.sensor(ITEM));
  265:  print "\nLocal items: [gold]"                                ...
  266:  print *tmp147                                                ...
  267:  print "[]"                                                   ...
  268:  jump *label113 greaterThanEq .EFF_LOCAL_LIMIT 100            if EFF_LOCAL_LIMIT < 100 then
  269:  print " (limit [orange]"                                     print($" (limit [orange]$LOCAL_MARGIN[])");
  270:  print .LOCAL_MARGIN                                          ...
  271:  print "[])"                                                  ...
        label *label113                                              if EFF_LOCAL_LIMIT < 100 then
  272:  jump *label115 equal .SHOW_REMOTE_LEVEL false                if SHOW_REMOTE_LEVEL then
  273:  sensor *tmp151 .CORE .ITEM                                   print($"\nRemote items: [gold]$[]", CORE.sensor(ITEM));
  274:  print "\nRemote items: [gold]"                               ...
  275:  print *tmp151                                                ...
  276:  print "[]"                                                   ...
  277:  jump *label117 greaterThanEq .EFF_REMOTE_LIMIT 100           if EFF_REMOTE_LIMIT < 100 then
  278:  print " (limit [orange]"                                     print($" (limit [orange]$REMOTE_MARGIN[])");
  279:  print .REMOTE_MARGIN                                         ...
  280:  print "[])"                                                  ...
        label *label117                                              if EFF_REMOTE_LIMIT < 100 then
        label *label115                                              if SHOW_REMOTE_LEVEL then
  281:  sensor *tmp154 @unit @totalItems                             println(MSG, @unit.@totalItems, "[]");
  282:  print .MSG                                                   ...
  283:  print *tmp154                                                ...
  284:  print "[]\n"                                                 ...
  285:  jump *label119 notEqual :show_state 2                        if show_state == S_APPROACH_SRC then
  286:  sensor *tmp157 @unit @x                                      print($"[]  arriving in [gold]$ sec[]\n", len(SRC_X - @unit.@x, SRC_Y - @unit.@y) \ SPEED_SEC / 10);
  287:  op sub *tmp158 .SRC_X *tmp157                                ...
  288:  sensor *tmp159 @unit @y                                      ...
  289:  op sub *tmp160 .SRC_Y *tmp159                                ...
  290:  op len *tmp161 *tmp158 *tmp160                               ...
  291:  op idiv *tmp162 *tmp161 .SPEED_SEC                           ...
  292:  op div *tmp163 *tmp162 10                                    ...
  293:  print "[]  arriving in [gold]"                               ...
  294:  print *tmp163                                                ...
  295:  print " sec[]\n"                                             ...
  296:  jump *label120 always 0 0                                    if show_state == S_APPROACH_SRC then
        label *label119                                              ...
  297:  jump *label121 notEqual :show_state 3                        elsif show_state == S_APPROACH_DST then
  298:  sensor *tmp166 @unit @x                                      print($"[]  arriving in [gold]$ sec[]\n", len(DST_X - @unit.@x, DST_Y - @unit.@y) \ SPEED_SEC / 10);
  299:  op sub *tmp167 .DST_X *tmp166                                ...
  300:  sensor *tmp168 @unit @y                                      ...
  301:  op sub *tmp169 .DST_Y *tmp168                                ...
  302:  op len *tmp170 *tmp167 *tmp169                               ...
  303:  op idiv *tmp171 *tmp170 .SPEED_SEC                           ...
  304:  op div *tmp172 *tmp171 10                                    ...
  305:  print "[]  arriving in [gold]"                               ...
  306:  print *tmp172                                                ...
  307:  print " sec[]\n"                                             ...
        label *label121                                              elsif show_state == S_APPROACH_DST then
        label *label120                                              if show_state == S_APPROACH_SRC then
  308:  op floor *tmp173 :loop_time 0                                println("[lightgray]Loop time: ", floor(loop_time), " ms[]");
  309:  print "[lightgray]Loop time: "                               ...
  310:  print *tmp173                                                ...
  311:  print " ms[]\n"                                              ...
  312:  printflush message1                                          printflush(message1);
  313:  sensor *tmp174 switch1 @enabled                              if switch1.@enabled == 0 then break; end;
  314:  jump *label77 equal *tmp174 0                                ...
  315:  sensor *tmp177 .SRC @dead                                    if SRC.@dead != 0 then break; end;
  316:  jump *label77 notEqual *tmp177 0                             ...
  317:  sensor *tmp180 .DST @dead                                    if DST.@dead != 0 then break; end;
  318:  jump *label77 notEqual *tmp180 0                             ...
  319:  sensor *tmp183 .SORTER @dead                                 if SORTER.@dead != 0 then break; end;
  320:  jump *label77 notEqual *tmp183 0                             ...
  321:  op sub :loop_time @time :start                               loop_time = @time - start;
  322:  jump *label75 always 0 0                                     while true do
        label *label77                                               ...
  323:  sensor *tmp187 .SORTER @dead                                 while SORTER.@dead == 0 do
  324:  jump *label133 notEqual *tmp187 0                            ...
        label *label147                                              ...
  325:  print "[salmon]sorter1 is missing!\n[gold]Please place and l println("[gold]Please place and link sorter or inverted sorter to the processor.");
  326:  printflush message1                                          printflush(message1);
  327:  printflush message2                                          printflush(message2);
  328:  sensor *tmp187 sorter1 @dead                                 while SORTER.@dead == 0 do
  329:  jump *label147 equal *tmp187 0                               ...
        label *label133                                              ...
  330:  sensor *tmp189 .SRC @dead                                    if SRC.@dead != 0 or DST.@dead != 0 then
  331:  jump *label136 notEqual *tmp189 0                            ...
  332:  sensor *tmp191 .DST @dead                                    ...
  333:  jump __start__ equal *tmp191 0                               ...
        label *label136                                              ...
  334:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  335:  sensor *tmp195 switch1 @enabled                              while !switch1.@enabled do
  336:  jump __start__ notEqual *tmp195 false                        ...
        label *label148                                              ...
  337:  print "[salmon]Local or remote container became invalid.\n[g println("[gold]Please fix and press button to reinitialize.");
  338:  printflush message1                                          printflush(message1);
  339:  printflush message2                                          printflush(message2);
  340:  sensor *tmp195 switch1 @enabled                              while !switch1.@enabled do
  341:  jump *label148 equal *tmp195 false                           ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   298     1x    298,0  <no function>
    26     2x     13,0  inline void findUnit()
    18     1x     18,0  inline void rebindUnit()

Performance: parsed in 358 ms, compiled in 282 ms, optimized in 586 ms, run in 14 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (11 steps):
The program didn't generate any output.
Execution exception at instruction 14: sensor *tmp2 switch1 @enabled:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
