   596 instructions before optimizations.
    38 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
    80 instructions eliminated by Dead Code Elimination (7 iterations).
     7 instructions eliminated by Jump Normalization (6 iterations).
    41 instructions eliminated by Jump Optimization (6 iterations).
    31 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
     2 instructions modified by Expression Optimization (2 passes, 4 iterations).
     2 instructions eliminated by If Expression Optimization (4 iterations).
     7 instructions eliminated by Data Flow Optimization (5 passes, 19 iterations).
    16 instructions added by Loop Optimization (4 iterations).
     9 loops improved by Loop Optimization.
     5 instructions eliminated by Jump Straightening (6 iterations).
     8 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    34 instructions eliminated by Print Merging.
   364 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 599):
  * Replicate loop condition at line 44:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 52:1                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 103:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 112:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 131:1                       size    +3, benefit       25.0, efficiency      8.333
    Replicate loop condition at line 306:1                       size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 316:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 598):
  * Replicate loop condition at line 52:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 103:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 112:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 131:1                       size    +3, benefit       25.0, efficiency      8.333
    Replicate loop condition at line 306:1                       size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 316:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 597):
    Replicate loop condition at line 103:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 112:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 131:1                       size    +3, benefit       25.0, efficiency      8.333
  * Replicate loop condition at line 306:1                       size    +1, benefit       25.0, efficiency     25.000 (+0 instructions)
    Replicate loop condition at line 316:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 597):
    Replicate loop condition at line 103:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 112:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 131:1                       size    +3, benefit       25.0, efficiency      8.333
  * Replicate loop condition at line 316:5                       size    +1, benefit       12.5, efficiency     12.500 (+1 instructions)

Pass 1: speed optimization selection (cost limit 596):
    Replicate loop condition at line 103:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 112:9                       size    +5, benefit        6.3, efficiency      1.250
  * Replicate loop condition at line 131:1                       size    +3, benefit       25.0, efficiency      8.333 (+3 instructions)

Pass 1: speed optimization selection (cost limit 593):
  * Replicate loop condition at line 103:5                       size    +4, benefit       12.5, efficiency      3.125 (+4 instructions)
    Replicate loop condition at line 112:9                       size    +5, benefit        6.3, efficiency      1.250

Pass 1: speed optimization selection (cost limit 589):
  * Replicate loop condition at line 112:9                       size    +5, benefit        6.3, efficiency      1.250 (+5 instructions)
C:\Home\golem\unit-transport\unit-transport-single.mnd:96:49 Variable 'CORE_X' is not initialized.
C:\Home\golem\unit-transport\unit-transport-single.mnd:96:61 Variable 'CORE_Y' is not initialized.
C:\Home\golem\unit-transport\unit-transport-single.mnd:229:13 Variable 'MSG' is not initialized.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-48 instructions):
 
    34 set *tmp8 @unit
    35 set :rebindUnit:first_unit *tmp8
    36 jump *label9 always
-    * set *tmp7 null
    37 jump *label11 always
    38 label *label10
-    * set *tmp7 null
    39 label *label11
    40 print "[salmon]No unit of type "
    41 print UNIT
 
    50 op equal *tmp10 *tmp9 @this
    51 jump *label15 equal *tmp10 false
    52 jump *label6 always
-    * set *tmp11 null
    53 jump *label16 always
    54 label *label15
-    * set *tmp11 null
    55 label *label16
    56 ubind UNIT
    57 print "[gold]Looking for old unit..."
 
    72 print UNIT
    73 print " "
    74 print "found."
-    * set *tmp17 null
    75 jump *label22 always
    76 label *label21
    77 sensor *tmp18 @unit @controlled
 
    87 jump *label17 always
    88 set *tmp20 null
    89 label *label24
-    * set *tmp17 *tmp20
    90 label *label22
    91 printflush message1
    92 label *label19
 
   121 jump *label31 equal *tmp29 false
   122 set .DROP_TARGET .CONTAINER
   123 set .CONTAINER :block
-    * set *tmp30 .CONTAINER
   124 jump *label32 always
   125 label *label31
-    * set *tmp30 null
   126 label *label32
   127 label *label29
   128 jump *label28 always
 
   131 jump *label33 equal *tmp31 false
   132 print "[salmon]No destination."
   133 print "\n"
-    * set *tmp32 "[salmon]No destination."
   134 jump *label34 always
   135 label *label33
   136 op notEqual *tmp33 .DROP_TARGET null
 
   153 jump *label27 always
   154 set *tmp37 null
   155 label *label36
-    * set *tmp32 *tmp37
   156 label *label34
   157 printflush message1
   158 label *label26
 
   165 printflush message1
   166 ulocate building core false @copper .CORE_X .CORE_Y *tmp41 *tmp40
   167 set .CORE *tmp40
-    * set *tmp39 .CORE
   168 jump *label38 always
   169 label *label37
   170 print "[gold]Locating vault #"
 
   222 label *label42
   223 set *tmp49 null
   224 label *label43
-    * set *tmp39 *tmp49
   225 label *label38
   226 op equal *tmp62 .CORE null
   227 jump *label49 equal *tmp62 false
   228 end
-    * set *tmp63 null
   229 jump *label50 always
   230 label *label49
-    * set *tmp63 null
   231 label *label50
   232 set .SORTER sorter1
   233 sensor *tmp64 .SORTER @type
 
   243 jump *label54 equal *tmp68 false
   244 print "Block found: "
   245 print .SORTER
-    * set *tmp69 .SORTER
   246 jump *label55 always
   247 label *label54
-    * set *tmp69 null
   248 label *label55
   249 printflush message1
   250 set .SORTER sorter1
 
   279 set *tmp81 "[] from vault #"
   280 label *label59
   281 set .DIRECTION *tmp81
-    * set *tmp72 .DIRECTION
   282 jump *label57 always
   283 label *label56
   284 op greaterThan *tmp82 LINK_ID 0
 
   309 set *tmp94 "[] to vault #"
   310 label *label61
   311 set .DIRECTION *tmp94
-    * set *tmp72 .DIRECTION
   312 label *label57
   313 op equal *tmp95 LINK_ID 0
   314 jump *label62 equal *tmp95 false
 
   331 set .DROP_TARGET .CORE
   332 set .DROP_X .CORE_X
   333 set .DROP_Y .CORE_Y
-    * set *tmp102 .DROP_Y
   334 jump *label65 always
   335 label *label64
   336 sensor *tmp103 .DROP_TARGET @x
   337 set .DROP_X *tmp103
   338 sensor *tmp104 .DROP_TARGET @y
   339 set .DROP_Y *tmp104
-    * set *tmp102 .DROP_Y
   340 label *label65
   341 set .LAST_ITEM @mono
   342 set :iter 0
 
   362 print UNIT
   363 print " "
   364 print "found."
-    * set *tmp113 null
   365 jump *label76 always
   366 label *label75
   367 sensor *tmp114 @unit @controlled
 
   377 jump *label71 always
   378 set *tmp116 null
   379 label *label78
-    * set *tmp113 *tmp116
   380 label *label76
   381 printflush message1
   382 label *label73
 
   385 label *label71
   386 ucontrol flag 1
   387 set :state 1
-    * set *tmp111 :state
   388 jump *label70 always
   389 label *label69
-    * set *tmp111 null
   390 label *label70
   391 sensor *tmp117 .SORTER @config
   392 set .ITEM *tmp117
 
   404 label *label83
   405 set .LAST_ITEM .ITEM
   406 set :state 1
-    * set *tmp119 :state
   407 jump *label80 always
   408 label *label79
-    * set *tmp119 null
   409 label *label80
   410 set :show_state 0
   411 op equal *tmp122 :state 1
 
   438 label *label89
   439 set *tmp126 *tmp129
   440 label *label87
-    * set *tmp123 *tmp126
   441 jump *label85 always
   442 label *label84
-    * set *tmp123 null
   443 label *label85
   444 op equal *tmp132 :state 2
   445 jump *label92 equal *tmp132 false
 
   468 set :show_state 2
   469 set *tmp135 :show_state
   470 label *label95
-    * set *tmp133 *tmp135
   471 jump *label93 always
   472 label *label92
-    * set *tmp133 null
   473 label *label93
   474 op equal *tmp142 :state 3
   475 jump *label98 equal *tmp142 false
 
   499 set :show_state 3
   500 set *tmp145 :show_state
   501 label *label101
-    * set *tmp143 *tmp145
   502 jump *label99 always
   503 label *label98
-    * set *tmp143 null
   504 label *label99
   505 jump *label104 equal true false
   506 set :iter 0
 
   521 print .LOCAL_MARGIN
   522 print "["
   523 print "])"
-    * set *tmp155 null
   524 jump *label107 always
   525 label *label106
-    * set *tmp155 null
   526 label *label107
   527 jump *label108 equal .SHOW_REMOTE_LEVEL false
   528 sensor *tmp157 .CORE .ITEM
 
   542 label *label110
   543 set *tmp159 null
   544 label *label111
-    * set *tmp156 *tmp159
   545 jump *label109 always
   546 label *label108
-    * set *tmp156 null
   547 label *label109
   548 sensor *tmp160 @unit @totalItems
   549 print .MSG
 
   589 label *label117
   590 set *tmp163 *tmp172
   591 label *label115
-    * set *tmp161 *tmp163
   592 jump *label113 always
   593 label *label112
-    * set *tmp161 null
   594 label *label113
   595 op floor *tmp180 :loop_time
   596 print "[lightgray]Loop time: "
 
   602 op equal *tmp182 *tmp181 0
   603 jump *label118 equal *tmp182 false
   604 jump *label68 always
-    * set *tmp183 null
   605 jump *label119 always
   606 label *label118
-    * set *tmp183 null
   607 label *label119
   608 sensor *tmp184 .SRC @dead
   609 op notEqual *tmp185 *tmp184 0
   610 jump *label120 equal *tmp185 false
   611 jump *label68 always
-    * set *tmp186 null
   612 jump *label121 always
   613 label *label120
-    * set *tmp186 null
   614 label *label121
   615 sensor *tmp187 .DST @dead
   616 op notEqual *tmp188 *tmp187 0
   617 jump *label122 equal *tmp188 false
   618 jump *label68 always
-    * set *tmp189 null
   619 jump *label123 always
   620 label *label122
-    * set *tmp189 null
   621 label *label123
   622 sensor *tmp190 .SORTER @dead
   623 op notEqual *tmp191 *tmp190 0
 
   628 label *label124
   629 set *tmp192 null
   630 label *label125
-    * set *tmp152 *tmp192
   631 jump *label105 always
   632 label *label104
   633 op add :iter :iter 1
-    * set *tmp152 :iter
   634 label *label105
   635 op sub *tmp193 @time :start
   636 set :loop_time *tmp193
 
   671 label *label132
   672 jump *label131 always
   673 label *label133
-    * set *tmp201 null
   674 jump *label130 always
   675 label *label129
-    * set *tmp201 null
   676 label *label130
   677 end

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-20 instructions):
 
    81 print UNIT
    82 print "."
    83 print ".."
-    * set *tmp20 null
    84 jump *label24 always
    85 label *label23
    86 jump *label17 always
-    * set *tmp20 null
    87 label *label24
    88 label *label22
    89 printflush message1
 
   145 print "\"
   146 print "n"
   147 print "[salmon]Item dump must be a container or a vault!"
-    * set *tmp37 null
   148 jump *label36 always
   149 label *label35
   150 jump *label27 always
-    * set *tmp37 null
   151 label *label36
   152 label *label34
   153 printflush message1
 
   213 label *label47
   214 set *tmp61 null
   215 label *label48
-    * set *tmp49 *tmp61
   216 jump *label43 always
   217 label *label42
-    * set *tmp49 null
   218 label *label43
   219 label *label38
   220 op equal *tmp62 .CORE null
 
   365 print UNIT
   366 print "."
   367 print ".."
-    * set *tmp116 null
   368 jump *label78 always
   369 label *label77
   370 jump *label71 always
-    * set *tmp116 null
   371 label *label78
   372 label *label76
   373 printflush message1
 
   406 op equal *tmp125 *tmp124 .ITEM
   407 jump *label86 equal *tmp125 false
   408 set :state 3
-    * set *tmp126 :state
   409 jump *label87 always
   410 label *label86
   411 sensor *tmp127 @unit @totalItems
 
   427 label *label91
   428 set *tmp129 *tmp131
   429 label *label89
-    * set *tmp126 *tmp129
   430 label *label87
   431 jump *label85 always
   432 label *label84
 
   450 set .MSG "\nLoading items: [green]"
   451 set *tmp141 .MSG
   452 label *label97
-    * set *tmp135 *tmp141
   453 jump *label95 always
   454 label *label94
   455 ucontrol approach .SRC_X .SRC_Y 6
   456 set .MSG "\nGoing to source: [green]"
   457 set :show_state 2
-    * set *tmp135 :show_state
   458 label *label95
   459 jump *label93 always
   460 label *label92
 
   479 set .MSG "\nDropping items: [green]"
   480 set *tmp151 .MSG
   481 label *label103
-    * set *tmp145 *tmp151
   482 jump *label101 always
   483 label *label100
   484 ucontrol approach .DST_X .DST_Y 6
   485 set .MSG "\nGoing to destination: [green]"
   486 set :show_state 3
-    * set *tmp145 :show_state
   487 label *label101
   488 jump *label99 always
   489 label *label98
 
   523 print .REMOTE_MARGIN
   524 print "["
   525 print "])"
-    * set *tmp159 null
   526 jump *label111 always
   527 label *label110
-    * set *tmp159 null
   528 label *label111
   529 jump *label109 always
   530 label *label108
 
   549 print " "
   550 print "sec[]"
   551 print "\n"
-    * set *tmp163 null
   552 jump *label115 always
   553 label *label114
   554 op equal *tmp171 :show_state 3
 
   570 label *label116
   571 set *tmp172 null
   572 label *label117
-    * set *tmp163 *tmp172
   573 label *label115
   574 jump *label113 always
   575 label *label112
 
   605 op notEqual *tmp191 *tmp190 0
   606 jump *label124 equal *tmp191 false
   607 jump *label68 always
-    * set *tmp192 null
   608 jump *label125 always
   609 label *label124
-    * set *tmp192 null
   610 label *label125
   611 jump *label105 always
   612 label *label104

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   208 op notEqual *tmp60 :b_type @vault
   209 jump *label47 equal *tmp60 false
   210 set .CORE null
-    * set *tmp61 .CORE
   211 jump *label48 always
   212 label *label47
-    * set *tmp61 null
   213 label *label48
   214 jump *label43 always
   215 label *label42
 
   410 op equal *tmp128 *tmp127 0
   411 jump *label88 equal *tmp128 false
   412 set :state 2
-    * set *tmp129 :state
   413 jump *label89 always
   414 label *label88
   415 set .MSG "\nUnloading previous items: [green]"
 
   422 label *label90
   423 set *tmp131 null
   424 label *label91
-    * set *tmp129 *tmp131
   425 label *label89
   426 label *label87
   427 jump *label85 always
 
   440 op greaterThanEq *tmp140 *tmp139 .UNIT_CAPACITY
   441 jump *label96 equal *tmp140 false
   442 set :state 3
-    * set *tmp141 :state
   443 jump *label97 always
   444 label *label96
   445 set .MSG "\nLoading items: [green]"
-    * set *tmp141 .MSG
   446 label *label97
   447 jump *label95 always
   448 label *label94
 
   467 jump *label102 equal *tmp150 false
   468 set :state 2
   469 ucontrol approach .SRC_X .SRC_Y 6
-    * set *tmp151 null
   470 jump *label103 always
   471 label *label102
   472 set .MSG "\nDropping items: [green]"
-    * set *tmp151 .MSG
   473 label *label103
   474 jump *label101 always
   475 label *label100
 
   557 print " "
   558 print "sec[]"
   559 print "\n"
-    * set *tmp172 null
   560 jump *label117 always
   561 label *label116
-    * set *tmp172 null
   562 label *label117
   563 label *label115
   564 jump *label113 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   417 ucontrol within .DROP_X .DROP_Y 8 *tmp130
   418 jump *label90 equal *tmp130 false
   419 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * set *tmp131 null
   420 jump *label91 always
   421 label *label90
-    * set *tmp131 null
   422 label *label91
   423 label *label89
   424 label *label87

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-38 instructions):
 
     5 set LOCAL_LIMIT 100
     6 remark "How much of remote container capacity to use, in percents (20-100)."
     7 set REMOTE_LIMIT 100
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+    8 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+    9 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    10 label *label0
    11 sensor *tmp2 switch1 @enabled
    12 op equal *tmp3 *tmp2 false
 
    29 ubind UNIT
    30 op notEqual *tmp6 @unit null
    31 jump *label10 equal *tmp6 false
-    * set *tmp8 @unit
-    * set :rebindUnit:first_unit *tmp8
+   32 set :rebindUnit:first_unit @unit
    33 jump *label9 always
    34 jump *label11 always
    35 label *label10
 
    92 label *label4
    93 jump *label3 always
    94 label *label5
-    * sensor *tmp21 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp21
+   95 sensor .UNIT_CAPACITY @unit @itemCapacity
    96 sensor *tmp22 @unit @speed
-    * op div *tmp23 *tmp22 10
-    * set .SPEED_SEC *tmp23
+   97 op div .SPEED_SEC *tmp22 10
    98 ucontrol flag 1
    99 label *label25
   100 jump *label27 equal true false
   101 set .CONTAINER null
   102 set .DROP_TARGET null
-    * set *tmp24 @links
-    * set :n *tmp24
+  103 set :n @links
   104 label *label28
   105 op greaterThan *tmp25 :n 0
   106 jump *label30 equal *tmp25 false
-    * op sub *tmp26 :n 1
-    * set :n *tmp26
-    * getlink *tmp27 :n
-    * set :block *tmp27
+  107 op sub :n :n 1
+  108 getlink :block :n
   109 sensor *tmp28 :block @itemCapacity
   110 op greaterThan *tmp29 *tmp28 0
   111 jump *label31 equal *tmp29 false
 
   151 jump *label37 equal *tmp38 false
   152 print "[gold]Locating core..."
   153 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp41 *tmp40
-    * set .CORE *tmp40
+  154 ulocate building core false @copper .CORE_X .CORE_Y *tmp41 .CORE
   155 jump *label38 always
   156 label *label37
   157 print "[gold]Locating vault #"
 
   159 print "."
   160 print ".."
   161 printflush message1
-    * op add *tmp42 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp42
+  162 op add .QUERY_FLAG 99999900 LINK_ID
   163 set :flag .QUERY_FLAG
   164 ucontrol flag :flag
   165 label *label39
 
   169 op land *tmp46 *tmp43 *tmp45
   170 jump *label41 equal *tmp46 false
   171 ucontrol stop
-    * sensor *tmp47 @unit @flag
-    * set :flag *tmp47
+  172 sensor :flag @unit @flag
   173 label *label40
   174 jump *label39 always
   175 label *label41
   176 op notEqual *tmp48 :flag .QUERY_FLAG
   177 jump *label42 equal *tmp48 false
-    * op idiv *tmp50 :flag 100
-    * set :position *tmp50
-    * op mod *tmp51 :position @mapw
-    * set .CORE_X *tmp51
-    * op idiv *tmp52 :position @mapw
-    * set .CORE_Y *tmp52
+  178 op idiv :position :flag 100
+  179 op mod .CORE_X :position @mapw
+  180 op idiv .CORE_Y :position @mapw
   181 label *label44
   182 ucontrol within .CORE_X .CORE_Y 8 *tmp53
   183 op equal *tmp54 *tmp53 false
 
   189 label *label45
   190 jump *label44 always
   191 label *label46
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp58 *tmp59
-    * set .CORE *tmp58
+  192 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp59
   193 op notEqual *tmp60 :b_type @vault
   194 jump *label47 equal *tmp60 false
   195 set .CORE null
 
   207 label *label49
   208 label *label50
   209 set .SORTER sorter1
-    * sensor *tmp64 .SORTER @type
-    * set :sorter_type *tmp64
+  210 sensor :sorter_type .SORTER @type
   211 label *label51
   212 op notEqual *tmp65 :sorter_type @sorter
   213 op notEqual *tmp66 :sorter_type @inverted-sorter
 
   224 label *label55
   225 printflush message1
   226 set .SORTER sorter1
-    * sensor *tmp70 .SORTER @type
-    * set :sorter_type *tmp70
+  227 sensor :sorter_type .SORTER @type
   228 label *label52
   229 jump *label51 always
   230 label *label53
 
   233 set .SHOW_REMOTE_LEVEL true
   234 set .SRC .CORE
   235 set .DST .CONTAINER
-    * sensor *tmp73 .SRC @itemCapacity
-    * set :src_capacity *tmp73
-    * sensor *tmp74 .DST @itemCapacity
-    * set :dst_capacity *tmp74
+  236 sensor :src_capacity .SRC @itemCapacity
+  237 sensor :dst_capacity .DST @itemCapacity
   238 op sub *tmp75 100 .EFF_REMOTE_LIMIT
   239 op mul *tmp76 :src_capacity *tmp75
-    * op idiv *tmp77 *tmp76 100
-    * set .LOAD_LEVEL *tmp77
+  240 op idiv .LOAD_LEVEL *tmp76 100
   241 op mul *tmp78 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp79 *tmp78 100
-    * set .DROP_LEVEL *tmp79
+  242 op idiv .DROP_LEVEL *tmp78 100
   243 set .LOCAL_MARGIN .DROP_LEVEL
   244 set .REMOTE_MARGIN .LOAD_LEVEL
   245 op equal *tmp80 LINK_ID 0
 
   252 set .DIRECTION *tmp81
   253 jump *label57 always
   254 label *label56
-    * op greaterThan *tmp82 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp82
+  255 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   256 set .SRC .CONTAINER
   257 set .DST .CORE
-    * sensor *tmp83 .SRC @itemCapacity
-    * set :src_capacity *tmp83
-    * sensor *tmp84 .DST @itemCapacity
-    * set :dst_capacity *tmp84
+  258 sensor :src_capacity .SRC @itemCapacity
+  259 sensor :dst_capacity .DST @itemCapacity
   260 op sub *tmp85 100 .EFF_LOCAL_LIMIT
   261 op mul *tmp86 :src_capacity *tmp85
-    * op idiv *tmp87 *tmp86 100
-    * set .LOAD_LEVEL *tmp87
+  262 op idiv .LOAD_LEVEL *tmp86 100
   263 op mul *tmp88 :dst_capacity .EFF_REMOTE_LIMIT
   264 op idiv *tmp89 *tmp88 100
   265 op equal *tmp90 LINK_ID 0
   266 op mul *tmp91 *tmp90 .UNIT_CAPACITY
-    * op add *tmp92 *tmp89 *tmp91
-    * set .DROP_LEVEL *tmp92
+  267 op add .DROP_LEVEL *tmp89 *tmp91
   268 set .LOCAL_MARGIN .LOAD_LEVEL
   269 set .REMOTE_MARGIN .DROP_LEVEL
   270 op equal *tmp93 LINK_ID 0
 
   284 set *tmp96 LINK_ID
   285 label *label63
   286 set .LINK_TXT *tmp96
-    * sensor *tmp97 .SRC @x
-    * set .SRC_X *tmp97
-    * sensor *tmp98 .SRC @y
-    * set .SRC_Y *tmp98
-    * sensor *tmp99 .DST @x
-    * set .DST_X *tmp99
-    * sensor *tmp100 .DST @y
-    * set .DST_Y *tmp100
+  287 sensor .SRC_X .SRC @x
+  288 sensor .SRC_Y .SRC @y
+  289 sensor .DST_X .DST @x
+  290 sensor .DST_Y .DST @y
   291 op equal *tmp101 .DROP_TARGET null
   292 jump *label64 equal *tmp101 false
   293 set .DROP_TARGET .CORE
 
   295 set .DROP_Y .CORE_Y
   296 jump *label65 always
   297 label *label64
-    * sensor *tmp103 .DROP_TARGET @x
-    * set .DROP_X *tmp103
-    * sensor *tmp104 .DROP_TARGET @y
-    * set .DROP_Y *tmp104
+  298 sensor .DROP_X .DROP_TARGET @x
+  299 sensor .DROP_Y .DROP_TARGET @y
   300 label *label65
   301 set .LAST_ITEM @mono
   302 set :iter 0
 
   305 ucontrol stop
   306 label *label66
   307 jump *label68 equal true false
-    * set *tmp105 @time
-    * set :start *tmp105
+  308 set :start @time
   309 sensor *tmp106 @unit @dead
   310 op equal *tmp107 *tmp106 0
   311 sensor *tmp108 @unit @controller
 
   345 jump *label70 always
   346 label *label69
   347 label *label70
-    * sensor *tmp117 .SORTER @config
-    * set .ITEM *tmp117
+  348 sensor .ITEM .SORTER @config
   349 op notEqual *tmp118 .ITEM .LAST_ITEM
   350 jump *label79 equal *tmp118 false
   351 label *label81
 
   353 jump *label83 equal *tmp120 false
   354 print "[salmon]No item type selected for transport."
   355 printflush message1
-    * sensor *tmp121 .SORTER @config
-    * set .ITEM *tmp121
+  356 sensor .ITEM .SORTER @config
   357 label *label82
   358 jump *label81 always
   359 label *label83
 
   396 jump *label94 equal *tmp134 false
   397 sensor *tmp136 .SRC .ITEM
   398 op sub *tmp137 *tmp136 .LOAD_LEVEL
-    * op max *tmp138 *tmp137 0
-    * set :max_load *tmp138
+  399 op max :max_load *tmp137 0
   400 ucontrol itemTake .SRC .ITEM :max_load
   401 sensor *tmp139 @unit @totalItems
   402 op greaterThanEq *tmp140 *tmp139 .UNIT_CAPACITY
 
   421 jump *label100 equal *tmp144 false
   422 sensor *tmp146 .DST .ITEM
   423 op sub *tmp147 .DROP_LEVEL *tmp146
-    * op max *tmp148 *tmp147 0
-    * set :max_drop *tmp148
+  424 op max :max_drop *tmp147 0
   425 ucontrol itemDrop .DST :max_drop
   426 sensor *tmp149 @unit @totalItems
   427 op lessThanEq *tmp150 *tmp149 0
 
   563 label *label104
   564 op add :iter :iter 1
   565 label *label105
-    * op sub *tmp193 @time :start
-    * set :loop_time *tmp193
+  566 op sub :loop_time @time :start
   567 label *label67
   568 jump *label66 always
   569 label *label68

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-7 instructions):
 
    25 jump *label5 equal *tmp5 false
    26 set :rebindUnit:first_unit null
    27 label *label7
-    * jump *label9 equal true false
    28 ubind UNIT
    29 op notEqual *tmp6 @unit null
    30 jump *label10 equal *tmp6 false
 
    60 jump *label12 notEqual *tmp15 false
    61 label *label14
    62 label *label18
-    * jump *label20 equal true false
    63 ubind UNIT
    64 op equal *tmp16 @unit null
    65 jump *label21 equal *tmp16 false
 
    95 op div .SPEED_SEC *tmp22 10
    96 ucontrol flag 1
    97 label *label25
-    * jump *label27 equal true false
    98 set .CONTAINER null
    99 set .DROP_TARGET null
   100 set :n @links
 
   301 set :state 1
   302 ucontrol stop
   303 label *label66
-    * jump *label68 equal true false
   304 set :start @time
   305 sensor *tmp106 @unit @dead
   306 op equal *tmp107 *tmp106 0
 
   309 op lessThanEq *tmp110 *tmp107 *tmp109
   310 jump *label69 equal *tmp110 false
   311 label *label72
-    * jump *label74 equal true false
   312 ubind UNIT
   313 op equal *tmp112 @unit null
   314 jump *label75 equal *tmp112 false
 
   436 jump *label99 always
   437 label *label98
   438 label *label99
-    * jump *label104 equal true false
   439 set :iter 0
   440 print "Moving [green]"
   441 print .ITEM
 
   481 print *tmp160
   482 print "[]"
   483 print "\n"
-    * jump *label112 equal true false
   484 op equal *tmp162 :show_state 2
   485 jump *label114 equal *tmp162 false
   486 sensor *tmp164 @unit @x

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-41 instructions):
 
     9 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    10 label *label0
    11 sensor *tmp2 switch1 @enabled
-    * op equal *tmp3 *tmp2 false
-    * jump *label2 equal *tmp3 false
+   12 jump *label2 notEqual *tmp2 false
    13 print "Unit Transport - Single"
    14 print "\n"
    15 print "Activate switch to start."
 
    20 label *label2
    21 label *label3
    22 sensor *tmp4 @unit @dead
-    * op notEqual *tmp5 *tmp4 0
-    * jump *label5 equal *tmp5 false
+   23 jump *label5 equal *tmp4 0
    24 set :rebindUnit:first_unit null
    25 label *label7
    26 ubind UNIT
-    * op notEqual *tmp6 @unit null
-    * jump *label10 equal *tmp6 false
+   27 jump *label10 equal @unit null
    28 set :rebindUnit:first_unit @unit
    29 jump *label9 always
    30 jump *label11 always
 
    40 label *label9
    41 label *label12
    42 sensor *tmp9 @unit @controller
-    * op equal *tmp10 *tmp9 @this
-    * jump *label15 equal *tmp10 false
+   43 jump *label15 notEqual *tmp9 @this
    44 jump *label6 always
    45 jump *label16 always
    46 label *label15
 
    57 label *label14
    58 label *label18
    59 ubind UNIT
-    * op equal *tmp16 @unit null
-    * jump *label21 equal *tmp16 false
+   60 jump *label21 notEqual @unit null
    61 print "[salmon]No unit of type "
    62 print UNIT
    63 print " "
 
    65 jump *label22 always
    66 label *label21
    67 sensor *tmp18 @unit @controlled
-    * op notEqual *tmp19 *tmp18 0
-    * jump *label23 equal *tmp19 false
+   68 jump *label23 equal *tmp18 0
    69 print "[salmon]Looking for a free "
    70 print UNIT
    71 print "."
 
    93 set .DROP_TARGET null
    94 set :n @links
    95 label *label28
-    * op greaterThan *tmp25 :n 0
-    * jump *label30 equal *tmp25 false
+   96 jump *label30 lessThanEq :n 0
    97 op sub :n :n 1
    98 getlink :block :n
    99 sensor *tmp28 :block @itemCapacity
-    * op greaterThan *tmp29 *tmp28 0
-    * jump *label31 equal *tmp29 false
+  100 jump *label31 lessThanEq *tmp28 0
   101 set .DROP_TARGET .CONTAINER
   102 set .CONTAINER :block
   103 jump *label32 always
 
   106 label *label29
   107 jump *label28 always
   108 label *label30
-    * op equal *tmp31 .CONTAINER null
-    * jump *label33 equal *tmp31 false
+  109 jump *label33 notEqual .CONTAINER null
   110 print "[salmon]No destination."
   111 print "\n"
   112 jump *label34 always
 
   135 jump *label25 always
   136 label *label27
   137 set .CORE null
-    * op equal *tmp38 LINK_ID 0
-    * jump *label37 equal *tmp38 false
+  138 jump *label37 notEqual LINK_ID 0
   139 print "[gold]Locating core..."
   140 printflush message1
   141 ulocate building core false @copper .CORE_X .CORE_Y *tmp41 .CORE
 
   160 label *label40
   161 jump *label39 always
   162 label *label41
-    * op notEqual *tmp48 :flag .QUERY_FLAG
-    * jump *label42 equal *tmp48 false
+  163 jump *label42 equal :flag .QUERY_FLAG
   164 op idiv :position :flag 100
   165 op mod .CORE_X :position @mapw
   166 op idiv .CORE_Y :position @mapw
 
   176 jump *label44 always
   177 label *label46
   178 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp59
-    * op notEqual *tmp60 :b_type @vault
-    * jump *label47 equal *tmp60 false
+  179 jump *label47 equal :b_type @vault
   180 set .CORE null
   181 jump *label48 always
   182 label *label47
 
   185 label *label42
   186 label *label43
   187 label *label38
-    * op equal *tmp62 .CORE null
-    * jump *label49 equal *tmp62 false
+  188 jump *label49 notEqual .CORE null
   189 end
   190 jump *label50 always
   191 label *label49
 
   199 jump *label53 equal *tmp67 false
   200 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   201 print "\n"
-    * op notEqual *tmp68 .SORTER null
-    * jump *label54 equal *tmp68 false
+  202 jump *label54 equal .SORTER null
   203 print "Block found: "
   204 print .SORTER
   205 jump *label55 always
 
   211 label *label52
   212 jump *label51 always
   213 label *label53
-    * op equal *tmp71 :sorter_type @sorter
-    * jump *label56 equal *tmp71 false
+  214 jump *label56 notEqual :sorter_type @sorter
   215 set .SHOW_REMOTE_LEVEL true
   216 set .SRC .CORE
   217 set .DST .CONTAINER
 
   224 op idiv .DROP_LEVEL *tmp78 100
   225 set .LOCAL_MARGIN .DROP_LEVEL
   226 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op equal *tmp80 LINK_ID 0
-    * jump *label58 equal *tmp80 false
+  227 jump *label58 notEqual LINK_ID 0
   228 set *tmp81 "[] from core"
   229 jump *label59 always
   230 label *label58
 
   248 op add .DROP_LEVEL *tmp89 *tmp91
   249 set .LOCAL_MARGIN .LOAD_LEVEL
   250 set .REMOTE_MARGIN .DROP_LEVEL
-    * op equal *tmp93 LINK_ID 0
-    * jump *label60 equal *tmp93 false
+  251 jump *label60 notEqual LINK_ID 0
   252 set *tmp94 "[] to core"
   253 jump *label61 always
   254 label *label60
 
   256 label *label61
   257 set .DIRECTION *tmp94
   258 label *label57
-    * op equal *tmp95 LINK_ID 0
-    * jump *label62 equal *tmp95 false
+  259 jump *label62 notEqual LINK_ID 0
   260 set *tmp96 ""
   261 jump *label63 always
   262 label *label62
 
   267 sensor .SRC_Y .SRC @y
   268 sensor .DST_X .DST @x
   269 sensor .DST_Y .DST @y
-    * op equal *tmp101 .DROP_TARGET null
-    * jump *label64 equal *tmp101 false
+  270 jump *label64 notEqual .DROP_TARGET null
   271 set .DROP_TARGET .CORE
   272 set .DROP_X .CORE_X
   273 set .DROP_Y .CORE_Y
 
   287 op equal *tmp107 *tmp106 0
   288 sensor *tmp108 @unit @controller
   289 op notEqual *tmp109 *tmp108 @this
-    * op lessThanEq *tmp110 *tmp107 *tmp109
-    * jump *label69 equal *tmp110 false
+  290 jump *label69 greaterThan *tmp107 *tmp109
   291 label *label72
   292 ubind UNIT
-    * op equal *tmp112 @unit null
-    * jump *label75 equal *tmp112 false
+  293 jump *label75 notEqual @unit null
   294 print "[salmon]No unit of type "
   295 print UNIT
   296 print " "
 
   298 jump *label76 always
   299 label *label75
   300 sensor *tmp114 @unit @controlled
-    * op notEqual *tmp115 *tmp114 0
-    * jump *label77 equal *tmp115 false
+  301 jump *label77 equal *tmp114 0
   302 print "[salmon]Looking for a free "
   303 print UNIT
   304 print "."
 
   319 label *label69
   320 label *label70
   321 sensor .ITEM .SORTER @config
-    * op notEqual *tmp118 .ITEM .LAST_ITEM
-    * jump *label79 equal *tmp118 false
+  322 jump *label79 equal .ITEM .LAST_ITEM
   323 label *label81
-    * op equal *tmp120 .ITEM null
-    * jump *label83 equal *tmp120 false
+  324 jump *label83 notEqual .ITEM null
   325 print "[salmon]No item type selected for transport."
   326 printflush message1
   327 sensor .ITEM .SORTER @config
 
   334 label *label79
   335 label *label80
   336 set :show_state 0
-    * op equal *tmp122 :state 1
-    * jump *label84 equal *tmp122 false
+  337 jump *label84 notEqual :state 1
   338 sensor *tmp124 @unit @firstItem
-    * op equal *tmp125 *tmp124 .ITEM
-    * jump *label86 equal *tmp125 false
+  339 jump *label86 notEqual *tmp124 .ITEM
   340 set :state 3
   341 jump *label87 always
   342 label *label86
   343 sensor *tmp127 @unit @totalItems
-    * op equal *tmp128 *tmp127 0
-    * jump *label88 equal *tmp128 false
+  344 jump *label88 notEqual *tmp127 0
   345 set :state 2
   346 jump *label89 always
   347 label *label88
 
   358 jump *label85 always
   359 label *label84
   360 label *label85
-    * op equal *tmp132 :state 2
-    * jump *label92 equal *tmp132 false
+  361 jump *label92 notEqual :state 2
   362 ucontrol within .SRC_X .SRC_Y 8 *tmp134
   363 jump *label94 equal *tmp134 false
   364 sensor *tmp136 .SRC .ITEM
 
   366 op max :max_load *tmp137 0
   367 ucontrol itemTake .SRC .ITEM :max_load
   368 sensor *tmp139 @unit @totalItems
-    * op greaterThanEq *tmp140 *tmp139 .UNIT_CAPACITY
-    * jump *label96 equal *tmp140 false
+  369 jump *label96 lessThan *tmp139 .UNIT_CAPACITY
   370 set :state 3
   371 jump *label97 always
   372 label *label96
 
   381 jump *label93 always
   382 label *label92
   383 label *label93
-    * op equal *tmp142 :state 3
-    * jump *label98 equal *tmp142 false
+  384 jump *label98 notEqual :state 3
   385 ucontrol within .DST_X .DST_Y 8 *tmp144
   386 jump *label100 equal *tmp144 false
   387 sensor *tmp146 .DST .ITEM
 
   389 op max :max_drop *tmp147 0
   390 ucontrol itemDrop .DST :max_drop
   391 sensor *tmp149 @unit @totalItems
-    * op lessThanEq *tmp150 *tmp149 0
-    * jump *label102 equal *tmp150 false
+  392 jump *label102 greaterThan *tmp149 0
   393 set :state 2
   394 ucontrol approach .SRC_X .SRC_Y 6
   395 jump *label103 always
 
   417 print *tmp153
   418 print "["
   419 print "]"
-    * op lessThan *tmp154 .EFF_LOCAL_LIMIT 100
-    * jump *label106 equal *tmp154 false
+  420 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
   421 print " (limit [orange]"
   422 print .LOCAL_MARGIN
   423 print "["
 
   432 print *tmp157
   433 print "["
   434 print "]"
-    * op lessThan *tmp158 .EFF_REMOTE_LIMIT 100
-    * jump *label110 equal *tmp158 false
+  435 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
   436 print " (limit [orange]"
   437 print .REMOTE_MARGIN
   438 print "["
 
   448 print *tmp160
   449 print "[]"
   450 print "\n"
-    * op equal *tmp162 :show_state 2
-    * jump *label114 equal *tmp162 false
+  451 jump *label114 notEqual :show_state 2
   452 sensor *tmp164 @unit @x
   453 op sub *tmp165 .SRC_X *tmp164
   454 sensor *tmp166 @unit @y
 
   463 print "\n"
   464 jump *label115 always
   465 label *label114
-    * op equal *tmp171 :show_state 3
-    * jump *label116 equal *tmp171 false
+  466 jump *label116 notEqual :show_state 3
   467 sensor *tmp173 @unit @x
   468 op sub *tmp174 .DST_X *tmp173
   469 sensor *tmp175 @unit @y
 
   490 print "\n"
   491 printflush message1
   492 sensor *tmp181 switch1 @enabled
-    * op equal *tmp182 *tmp181 0
-    * jump *label118 equal *tmp182 false
+  493 jump *label118 notEqual *tmp181 0
   494 jump *label68 always
   495 jump *label119 always
   496 label *label118
   497 label *label119
   498 sensor *tmp184 .SRC @dead
-    * op notEqual *tmp185 *tmp184 0
-    * jump *label120 equal *tmp185 false
+  499 jump *label120 equal *tmp184 0
   500 jump *label68 always
   501 jump *label121 always
   502 label *label120
   503 label *label121
   504 sensor *tmp187 .DST @dead
-    * op notEqual *tmp188 *tmp187 0
-    * jump *label122 equal *tmp188 false
+  505 jump *label122 equal *tmp187 0
   506 jump *label68 always
   507 jump *label123 always
   508 label *label122
   509 label *label123
   510 sensor *tmp190 .SORTER @dead
-    * op notEqual *tmp191 *tmp190 0
-    * jump *label124 equal *tmp191 false
+  511 jump *label124 equal *tmp190 0
   512 jump *label68 always
   513 jump *label125 always
   514 label *label124
 
   523 label *label68
   524 label *label126
   525 sensor *tmp194 .SORTER @dead
-    * op equal *tmp195 *tmp194 0
-    * jump *label128 equal *tmp195 false
+  526 jump *label128 notEqual *tmp194 0
   527 print "[salmon]sorter1 is missing!"
   528 print "\n"
   529 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   543 control enabled switch1 false
   544 label *label131
   545 sensor *tmp203 switch1 @enabled
-    * op equal *tmp204 *tmp203 false
-    * jump *label133 equal *tmp204 false
+  546 jump *label133 notEqual *tmp203 false
   547 print "[salmon]Local or remote container became invalid."
   548 print "\n"
   549 print "[gold]Please fix and press button to reinitialize."

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-23 instructions):
 
    27 jump *label10 equal @unit null
    28 set :rebindUnit:first_unit @unit
    29 jump *label9 always
-    * jump *label11 always
    30 label *label10
    31 label *label11
    32 print "[salmon]No unit of type "
 
    41 sensor *tmp9 @unit @controller
    42 jump *label15 notEqual *tmp9 @this
    43 jump *label6 always
-    * jump *label16 always
    44 label *label15
    45 label *label16
    46 ubind UNIT
 
    98 jump *label31 lessThanEq *tmp28 0
    99 set .DROP_TARGET .CONTAINER
   100 set .CONTAINER :block
-    * jump *label32 always
   101 label *label31
   102 label *label32
   103 label *label29
 
   175 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp59
   176 jump *label47 equal :b_type @vault
   177 set .CORE null
-    * jump *label48 always
   178 label *label47
   179 label *label48
-    * jump *label43 always
   180 label *label42
   181 label *label43
   182 label *label38
   183 jump *label49 notEqual .CORE null
   184 end
-    * jump *label50 always
   185 label *label49
   186 label *label50
   187 set .SORTER sorter1
 
   196 jump *label54 equal .SORTER null
   197 print "Block found: "
   198 print .SORTER
-    * jump *label55 always
   199 label *label54
   200 label *label55
   201 printflush message1
 
   308 label *label71
   309 ucontrol flag 1
   310 set :state 1
-    * jump *label70 always
   311 label *label69
   312 label *label70
   313 sensor .ITEM .SORTER @config
 
   322 label *label83
   323 set .LAST_ITEM .ITEM
   324 set :state 1
-    * jump *label80 always
   325 label *label79
   326 label *label80
   327 set :show_state 0
 
   341 ucontrol within .DROP_X .DROP_Y 8 *tmp130
   342 jump *label90 equal *tmp130 false
   343 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * jump *label91 always
   344 label *label90
   345 label *label91
   346 label *label89
   347 label *label87
-    * jump *label85 always
   348 label *label84
   349 label *label85
   350 jump *label92 notEqual :state 2
 
   367 set .MSG "\nGoing to source: [green]"
   368 set :show_state 2
   369 label *label95
-    * jump *label93 always
   370 label *label92
   371 label *label93
   372 jump *label98 notEqual :state 3
 
   390 set .MSG "\nGoing to destination: [green]"
   391 set :show_state 3
   392 label *label101
-    * jump *label99 always
   393 label *label98
   394 label *label99
   395 set :iter 0
 
   409 print .LOCAL_MARGIN
   410 print "["
   411 print "])"
-    * jump *label107 always
   412 label *label106
   413 label *label107
   414 jump *label108 equal .SHOW_REMOTE_LEVEL false
 
   423 print .REMOTE_MARGIN
   424 print "["
   425 print "])"
-    * jump *label111 always
   426 label *label110
   427 label *label111
-    * jump *label109 always
   428 label *label108
   429 label *label109
   430 sensor *tmp160 @unit @totalItems
 
   460 print " "
   461 print "sec[]"
   462 print "\n"
-    * jump *label117 always
   463 label *label116
   464 label *label117
   465 label *label115
-    * jump *label113 always
   466 label *label112
   467 label *label113
   468 op floor *tmp180 :loop_time
 
   474 sensor *tmp181 switch1 @enabled
   475 jump *label118 notEqual *tmp181 0
   476 jump *label68 always
-    * jump *label119 always
   477 label *label118
   478 label *label119
   479 sensor *tmp184 .SRC @dead
   480 jump *label120 equal *tmp184 0
   481 jump *label68 always
-    * jump *label121 always
   482 label *label120
   483 label *label121
   484 sensor *tmp187 .DST @dead
   485 jump *label122 equal *tmp187 0
   486 jump *label68 always
-    * jump *label123 always
   487 label *label122
   488 label *label123
   489 sensor *tmp190 .SORTER @dead
   490 jump *label124 equal *tmp190 0
   491 jump *label68 always
-    * jump *label125 always
   492 label *label124
   493 label *label125
   494 jump *label105 always
 
   531 label *label132
   532 jump *label131 always
   533 label *label133
-    * jump *label130 always
   534 label *label129
   535 label *label130
   536 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
   145 printflush message1
   146 op add .QUERY_FLAG 99999900 LINK_ID
   147 set :flag .QUERY_FLAG
-    * ucontrol flag :flag
+  148 ucontrol flag .QUERY_FLAG
   149 label *label39
   150 op equal *tmp43 :flag .QUERY_FLAG
   151 sensor *tmp44 @unit @dead
 
   185 label *label49
   186 label *label50
   187 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  188 sensor :sorter_type sorter1 @type
   189 label *label51
   190 op notEqual *tmp65 :sorter_type @sorter
   191 op notEqual *tmp66 :sorter_type @inverted-sorter
 
   200 label *label55
   201 printflush message1
   202 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  203 sensor :sorter_type sorter1 @type
   204 label *label52
   205 jump *label51 always
   206 label *label53
 
   208 set .SHOW_REMOTE_LEVEL true
   209 set .SRC .CORE
   210 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  211 sensor :src_capacity .CORE @itemCapacity
+  212 sensor :dst_capacity .CONTAINER @itemCapacity
   213 op sub *tmp75 100 .EFF_REMOTE_LIMIT
   214 op mul *tmp76 :src_capacity *tmp75
   215 op idiv .LOAD_LEVEL *tmp76 100
 
   229 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   230 set .SRC .CONTAINER
   231 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  232 sensor :src_capacity .CONTAINER @itemCapacity
+  233 sensor :dst_capacity .CORE @itemCapacity
   234 op sub *tmp85 100 .EFF_LOCAL_LIMIT
   235 op mul *tmp86 :src_capacity *tmp85
   236 op idiv .LOAD_LEVEL *tmp86 100
 
   270 sensor .DROP_Y .DROP_TARGET @y
   271 label *label65
   272 set .LAST_ITEM @mono
-    * set :iter 0
   273 set :loop_time 0
   274 set :state 1
   275 ucontrol stop
 
   391 label *label101
   392 label *label98
   393 label *label99
-    * set :iter 0
   394 print "Moving [green]"
   395 print .ITEM
   396 print .DIRECTION
-    * print .LINK_TXT
+  397 print *tmp96
   398 print "\"
   399 print "n"
   400 sensor *tmp153 .CONTAINER .ITEM
 
   491 label *label125
   492 jump *label105 always
   493 label *label104
-    * op add :iter :iter 1
+  494 op add :iter 0 1
   495 label *label105
   496 op sub :loop_time @time :start
   497 label *label67

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
   255 label *label62
   256 set *tmp96 LINK_ID
   257 label *label63
-    * set .LINK_TXT *tmp96
   258 sensor .SRC_X .SRC @x
   259 sensor .SRC_Y .SRC @y
   260 sensor .DST_X .DST @x
 
   490 label *label125
   491 jump *label105 always
   492 label *label104
-    * op add :iter 0 1
   493 label *label105
   494 op sub :loop_time @time :start
   495 label *label67

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    92 set :n @links
    93 label *label28
    94 jump *label30 lessThanEq :n 0
+   95 label *label134
    96 op sub :n :n 1
    97 getlink :block :n
    98 sensor *tmp28 :block @itemCapacity
 
   102 label *label31
   103 label *label32
   104 label *label29
-    * jump *label28 always
+  105 jump *label134 greaterThan :n 0
   106 label *label30
   107 jump *label33 notEqual .CONTAINER null
   108 print "[salmon]No destination."
 
   313 jump *label79 equal .ITEM .LAST_ITEM
   314 label *label81
   315 jump *label83 notEqual .ITEM null
+  316 label *label135
   317 print "[salmon]No item type selected for transport."
   318 printflush message1
   319 sensor .ITEM .SORTER @config
   320 label *label82
-    * jump *label81 always
+  321 jump *label135 equal .ITEM null
   322 label *label83
   323 set .LAST_ITEM .ITEM
   324 set :state 1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
   218 op idiv .DROP_LEVEL *tmp78 100
   219 set .LOCAL_MARGIN .DROP_LEVEL
   220 set .REMOTE_MARGIN .LOAD_LEVEL
-    * jump *label58 notEqual LINK_ID 0
-    * set *tmp81 "[] from core"
+  221 set .DIRECTION "[] from vault #"
+  222 jump *label59 notEqual LINK_ID 0
+  223 set .DIRECTION "[] from core"
   224 jump *label59 always
-    * label *label58
-    * set *tmp81 "[] from vault #"
   225 label *label59
-    * set .DIRECTION *tmp81
   226 jump *label57 always
   227 label *label56
   228 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   240 op add .DROP_LEVEL *tmp89 *tmp91
   241 set .LOCAL_MARGIN .LOAD_LEVEL
   242 set .REMOTE_MARGIN .DROP_LEVEL
-    * jump *label60 notEqual LINK_ID 0
-    * set *tmp94 "[] to core"
+  243 set .DIRECTION "[] to vault #"
+  244 jump *label61 notEqual LINK_ID 0
+  245 set .DIRECTION "[] to core"
   246 jump *label61 always
-    * label *label60
-    * set *tmp94 "[] to vault #"
   247 label *label61
-    * set .DIRECTION *tmp94
   248 label *label57
-    * jump *label62 notEqual LINK_ID 0
+  249 set *tmp96 LINK_ID
+  250 jump *label63 notEqual LINK_ID 0
   251 set *tmp96 ""
   252 jump *label63 always
-    * label *label62
-    * set *tmp96 LINK_ID
   253 label *label63
   254 sensor .SRC_X .SRC @x
   255 sensor .SRC_Y .SRC @y

Modifications by Replicate loop condition at line 44:1 (+1 instructions):
 
    10 label *label0
    11 sensor *tmp2 switch1 @enabled
    12 jump *label2 notEqual *tmp2 false
+   13 label *label136
    14 print "Unit Transport - Single"
    15 print "\n"
    16 print "Activate switch to start."
    17 print "\n"
    18 printflush message1
    19 label *label1
-    * jump *label0 always
+   20 sensor *tmp2 switch1 @enabled
+   21 jump *label136 equal *tmp2 false
    22 label *label2
    23 label *label3
    24 sensor *tmp4 @unit @dead

Modifications by Replicate loop condition at line 52:1 (+1 instructions):
 
    23 label *label3
    24 sensor *tmp4 @unit @dead
    25 jump *label5 equal *tmp4 0
+   26 label *label137
    27 set :rebindUnit:first_unit null
    28 label *label7
    29 ubind UNIT
 
    83 label *label17
    84 label *label6
    85 label *label4
-    * jump *label3 always
+   86 sensor *tmp4 @unit @dead
+   87 jump *label137 notEqual *tmp4 0
    88 label *label5
    89 sensor .UNIT_CAPACITY @unit @itemCapacity
    90 sensor *tmp22 @unit @speed

Modifications by Replicate loop condition at line 306:1 (+1 instructions):
 
   499 label *label126
   500 sensor *tmp194 .SORTER @dead
   501 jump *label128 notEqual *tmp194 0
+  502 label *label138
   503 print "[salmon]sorter1 is missing!"
   504 print "\n"
   505 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   508 printflush message2
   509 set .SORTER sorter1
   510 label *label127
-    * jump *label126 always
+  511 sensor *tmp194 .SORTER @dead
+  512 jump *label138 equal *tmp194 0
   513 label *label128
   514 sensor *tmp196 .SRC @dead
   515 op notEqual *tmp197 *tmp196 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   508 printflush message2
   509 set .SORTER sorter1
   510 label *label127
-    * sensor *tmp194 .SORTER @dead
+  511 sensor *tmp194 sorter1 @dead
   512 jump *label138 equal *tmp194 0
   513 label *label128
   514 sensor *tmp196 .SRC @dead

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   506 print "\n"
   507 printflush message1
   508 printflush message2
-    * set .SORTER sorter1
   509 label *label127
   510 sensor *tmp194 sorter1 @dead
   511 jump *label138 equal *tmp194 0

Modifications by Replicate loop condition at line 316:5 (+1 instructions):
 
   520 label *label131
   521 sensor *tmp203 switch1 @enabled
   522 jump *label133 notEqual *tmp203 false
+  523 label *label139
   524 print "[salmon]Local or remote container became invalid."
   525 print "\n"
   526 print "[gold]Please fix and press button to reinitialize."
 
   528 printflush message1
   529 printflush message2
   530 label *label132
-    * jump *label131 always
+  531 sensor *tmp203 switch1 @enabled
+  532 jump *label139 equal *tmp203 false
   533 label *label133
   534 label *label129
   535 label *label130

Modifications by Replicate loop condition at line 131:1 (+3 instructions):
 
   196 op notEqual *tmp66 :sorter_type @inverted-sorter
   197 op land *tmp67 *tmp65 *tmp66
   198 jump *label53 equal *tmp67 false
+  199 label *label140
   200 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   201 print "\n"
   202 jump *label54 equal .SORTER null
 
   208 set .SORTER sorter1
   209 sensor :sorter_type sorter1 @type
   210 label *label52
-    * jump *label51 always
+  211 op notEqual *tmp65 :sorter_type @sorter
+  212 op notEqual *tmp66 :sorter_type @inverted-sorter
+  213 op land *tmp67 *tmp65 *tmp66
+  214 jump *label140 notEqual *tmp67 false
   215 label *label53
   216 jump *label56 notEqual :sorter_type @sorter
   217 set .SHOW_REMOTE_LEVEL true

Modifications by Replicate loop condition at line 103:5 (+4 instructions):
 
   157 op equal *tmp45 *tmp44 0
   158 op land *tmp46 *tmp43 *tmp45
   159 jump *label41 equal *tmp46 false
+  160 label *label141
   161 ucontrol stop
   162 sensor :flag @unit @flag
   163 label *label40
-    * jump *label39 always
+  164 op equal *tmp43 :flag .QUERY_FLAG
+  165 sensor *tmp44 @unit @dead
+  166 op equal *tmp45 *tmp44 0
+  167 op land *tmp46 *tmp43 *tmp45
+  168 jump *label141 notEqual *tmp46 false
   169 label *label41
   170 jump *label42 equal :flag .QUERY_FLAG
   171 op idiv :position :flag 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   152 set :flag .QUERY_FLAG
   153 ucontrol flag .QUERY_FLAG
   154 label *label39
-    * op equal *tmp43 :flag .QUERY_FLAG
+  155 op equal *tmp43 .QUERY_FLAG .QUERY_FLAG
   156 sensor *tmp44 @unit @dead
   157 op equal *tmp45 *tmp44 0
   158 op land *tmp46 *tmp43 *tmp45

Modifications by Replicate loop condition at line 112:9 (+5 instructions):
 
   178 op equal *tmp56 *tmp55 0
   179 op land *tmp57 *tmp54 *tmp56
   180 jump *label46 equal *tmp57 false
+  181 label *label142
   182 ucontrol approach .CORE_X .CORE_Y 6
   183 label *label45
-    * jump *label44 always
+  184 ucontrol within .CORE_X .CORE_Y 8 *tmp53
+  185 op equal *tmp54 *tmp53 false
+  186 sensor *tmp55 @unit @dead
+  187 op equal *tmp56 *tmp55 0
+  188 op land *tmp57 *tmp54 *tmp56
+  189 jump *label142 notEqual *tmp57 false
   190 label *label46
   191 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp59
   192 jump *label47 equal :b_type @vault

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-4 instructions):
 
   240 set .DIRECTION "[] from vault #"
   241 jump *label59 notEqual LINK_ID 0
   242 set .DIRECTION "[] from core"
-    * jump *label59 always
   243 label *label59
   244 jump *label57 always
   245 label *label56
 
   261 set .DIRECTION "[] to vault #"
   262 jump *label61 notEqual LINK_ID 0
   263 set .DIRECTION "[] to core"
-    * jump *label61 always
   264 label *label61
   265 label *label57
   266 set *tmp96 LINK_ID
   267 jump *label63 notEqual LINK_ID 0
   268 set *tmp96 ""
-    * jump *label63 always
   269 label *label63
   270 sensor .SRC_X .SRC @x
   271 sensor .SRC_Y .SRC @y
 
   501 jump *label68 always
   502 label *label124
   503 label *label125
-    * jump *label105 always
   504 label *label104
   505 label *label105
   506 op sub :loop_time @time :start

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   152 set :flag .QUERY_FLAG
   153 ucontrol flag .QUERY_FLAG
   154 label *label39
-    * op equal *tmp43 .QUERY_FLAG .QUERY_FLAG
+  155 set *tmp43 true
   156 sensor *tmp44 @unit @dead
   157 op equal *tmp45 *tmp44 0
   158 op land *tmp46 *tmp43 *tmp45

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   155 set *tmp43 true
   156 sensor *tmp44 @unit @dead
   157 op equal *tmp45 *tmp44 0
-    * op land *tmp46 *tmp43 *tmp45
+  158 op land *tmp46 true *tmp45
   159 jump *label41 equal *tmp46 false
   160 label *label141
   161 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
   152 set :flag .QUERY_FLAG
   153 ucontrol flag .QUERY_FLAG
   154 label *label39
-    * set *tmp43 true
   155 sensor *tmp44 @unit @dead
   156 op equal *tmp45 *tmp44 0
   157 op land *tmp46 true *tmp45

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1:
 
   154 label *label39
   155 sensor *tmp44 @unit @dead
   156 op equal *tmp45 *tmp44 0
-    * op land *tmp46 true *tmp45
+  157 set *tmp46 *tmp45
   158 jump *label41 equal *tmp46 false
   159 label *label141
   160 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1 (-1 instructions):
 
   153 ucontrol flag .QUERY_FLAG
   154 label *label39
   155 sensor *tmp44 @unit @dead
-    * op equal *tmp45 *tmp44 0
-    * set *tmp46 *tmp45
+  156 op equal *tmp46 *tmp44 0
   157 jump *label41 equal *tmp46 false
   158 label *label141
   159 ucontrol stop

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
     7 set REMOTE_LIMIT 100
     8 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
     9 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
-    * label *label0
    10 sensor *tmp2 switch1 @enabled
    11 jump *label2 notEqual *tmp2 false
    12 label *label136
 
    15 print "Activate switch to start."
    16 print "\n"
    17 printflush message1
-    * label *label1
    18 sensor *tmp2 switch1 @enabled
    19 jump *label136 equal *tmp2 false
    20 label *label2
-    * label *label3
    21 sensor *tmp4 @unit @dead
    22 jump *label5 equal *tmp4 0
    23 label *label137
 
    28 set :rebindUnit:first_unit @unit
    29 jump *label9 always
    30 label *label10
-    * label *label11
    31 print "[salmon]No unit of type "
    32 print UNIT
    33 print " "
    34 print "found. 1"
    35 printflush message1
-    * label *label8
    36 jump *label7 always
    37 label *label9
    38 label *label12
 
    40 jump *label15 notEqual *tmp9 @this
    41 jump *label6 always
    42 label *label15
-    * label *label16
    43 ubind UNIT
    44 print "[gold]Looking for old unit..."
    45 printflush message1
-    * label *label13
    46 op notEqual *tmp12 @unit :rebindUnit:first_unit
    47 sensor *tmp13 :rebindUnit:first_unit @dead
    48 op equal *tmp14 *tmp13 0
    49 op land *tmp15 *tmp12 *tmp14
    50 jump *label12 notEqual *tmp15 false
-    * label *label14
    51 label *label18
    52 ubind UNIT
    53 jump *label21 notEqual @unit null
 
    69 label *label24
    70 label *label22
    71 printflush message1
-    * label *label19
    72 jump *label18 always
-    * label *label20
    73 label *label17
    74 label *label6
-    * label *label4
    75 sensor *tmp4 @unit @dead
    76 jump *label137 notEqual *tmp4 0
    77 label *label5
 
    83 set .CONTAINER null
    84 set .DROP_TARGET null
    85 set :n @links
-    * label *label28
    86 jump *label30 lessThanEq :n 0
    87 label *label134
    88 op sub :n :n 1
 
    92 set .DROP_TARGET .CONTAINER
    93 set .CONTAINER :block
    94 label *label31
-    * label *label32
-    * label *label29
    95 jump *label134 greaterThan :n 0
    96 label *label30
    97 jump *label33 notEqual .CONTAINER null
 
   119 label *label36
   120 label *label34
   121 printflush message1
-    * label *label26
   122 jump *label25 always
   123 label *label27
   124 set .CORE null
 
   136 op add .QUERY_FLAG 99999900 LINK_ID
   137 set :flag .QUERY_FLAG
   138 ucontrol flag .QUERY_FLAG
-    * label *label39
   139 sensor *tmp44 @unit @dead
   140 op equal *tmp46 *tmp44 0
   141 jump *label41 equal *tmp46 false
   142 label *label141
   143 ucontrol stop
   144 sensor :flag @unit @flag
-    * label *label40
   145 op equal *tmp43 :flag .QUERY_FLAG
   146 sensor *tmp44 @unit @dead
   147 op equal *tmp45 *tmp44 0
 
   152 op idiv :position :flag 100
   153 op mod .CORE_X :position @mapw
   154 op idiv .CORE_Y :position @mapw
-    * label *label44
   155 ucontrol within .CORE_X .CORE_Y 8 *tmp53
   156 op equal *tmp54 *tmp53 false
   157 sensor *tmp55 @unit @dead
 
   160 jump *label46 equal *tmp57 false
   161 label *label142
   162 ucontrol approach .CORE_X .CORE_Y 6
-    * label *label45
   163 ucontrol within .CORE_X .CORE_Y 8 *tmp53
   164 op equal *tmp54 *tmp53 false
   165 sensor *tmp55 @unit @dead
 
   171 jump *label47 equal :b_type @vault
   172 set .CORE null
   173 label *label47
-    * label *label48
   174 label *label42
-    * label *label43
   175 label *label38
   176 jump *label49 notEqual .CORE null
   177 end
   178 label *label49
-    * label *label50
   179 set .SORTER sorter1
   180 sensor :sorter_type sorter1 @type
-    * label *label51
   181 op notEqual *tmp65 :sorter_type @sorter
   182 op notEqual *tmp66 :sorter_type @inverted-sorter
   183 op land *tmp67 *tmp65 *tmp66
 
   189 print "Block found: "
   190 print .SORTER
   191 label *label54
-    * label *label55
   192 printflush message1
   193 set .SORTER sorter1
   194 sensor :sorter_type sorter1 @type
-    * label *label52
   195 op notEqual *tmp65 :sorter_type @sorter
   196 op notEqual *tmp66 :sorter_type @inverted-sorter
   197 op land *tmp67 *tmp65 *tmp66
 
   285 label *label78
   286 label *label76
   287 printflush message1
-    * label *label73
   288 jump *label72 always
-    * label *label74
   289 label *label71
   290 ucontrol flag 1
   291 set :state 1
   292 label *label69
-    * label *label70
   293 sensor .ITEM .SORTER @config
   294 jump *label79 equal .ITEM .LAST_ITEM
-    * label *label81
   295 jump *label83 notEqual .ITEM null
   296 label *label135
   297 print "[salmon]No item type selected for transport."
   298 printflush message1
   299 sensor .ITEM .SORTER @config
-    * label *label82
   300 jump *label135 equal .ITEM null
   301 label *label83
   302 set .LAST_ITEM .ITEM
   303 set :state 1
   304 label *label79
-    * label *label80
   305 set :show_state 0
   306 jump *label84 notEqual :state 1
   307 sensor *tmp124 @unit @firstItem
 
   320 jump *label90 equal *tmp130 false
   321 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
   322 label *label90
-    * label *label91
   323 label *label89
   324 label *label87
   325 label *label84
-    * label *label85
   326 jump *label92 notEqual :state 2
   327 ucontrol within .SRC_X .SRC_Y 8 *tmp134
   328 jump *label94 equal *tmp134 false
 
   344 set :show_state 2
   345 label *label95
   346 label *label92
-    * label *label93
   347 jump *label98 notEqual :state 3
   348 ucontrol within .DST_X .DST_Y 8 *tmp144
   349 jump *label100 equal *tmp144 false
 
   366 set :show_state 3
   367 label *label101
   368 label *label98
-    * label *label99
   369 print "Moving [green]"
   370 print .ITEM
   371 print .DIRECTION
 
   383 print "["
   384 print "])"
   385 label *label106
-    * label *label107
   386 jump *label108 equal .SHOW_REMOTE_LEVEL false
   387 sensor *tmp157 .CORE .ITEM
   388 print "\n"
 
   396 print "["
   397 print "])"
   398 label *label110
-    * label *label111
   399 label *label108
-    * label *label109
   400 sensor *tmp160 @unit @totalItems
   401 print .MSG
   402 print *tmp160
 
   431 print "sec[]"
   432 print "\n"
   433 label *label116
-    * label *label117
   434 label *label115
-    * label *label112
-    * label *label113
   435 op floor *tmp180 :loop_time
   436 print "[lightgray]Loop time: "
   437 print *tmp180
 
   442 jump *label118 notEqual *tmp181 0
   443 jump *label68 always
   444 label *label118
-    * label *label119
   445 sensor *tmp184 .SRC @dead
   446 jump *label120 equal *tmp184 0
   447 jump *label68 always
   448 label *label120
-    * label *label121
   449 sensor *tmp187 .DST @dead
   450 jump *label122 equal *tmp187 0
   451 jump *label68 always
   452 label *label122
-    * label *label123
   453 sensor *tmp190 .SORTER @dead
   454 jump *label124 equal *tmp190 0
   455 jump *label68 always
   456 label *label124
-    * label *label125
-    * label *label104
-    * label *label105
   457 op sub :loop_time @time :start
-    * label *label67
   458 jump *label66 always
   459 label *label68
-    * label *label126
   460 sensor *tmp194 .SORTER @dead
   461 jump *label128 notEqual *tmp194 0
   462 label *label138
 
   466 print "\n"
   467 printflush message1
   468 printflush message2
-    * label *label127
   469 sensor *tmp194 sorter1 @dead
   470 jump *label138 equal *tmp194 0
   471 label *label128
 
   476 op or *tmp200 *tmp197 *tmp199
   477 jump *label129 equal *tmp200 false
   478 control enabled switch1 false
-    * label *label131
   479 sensor *tmp203 switch1 @enabled
   480 jump *label133 notEqual *tmp203 false
   481 label *label139
 
   485 print "\n"
   486 printflush message1
   487 printflush message2
-    * label *label132
   488 sensor *tmp203 switch1 @enabled
   489 jump *label139 equal *tmp203 false
   490 label *label133
   491 label *label129
-    * label *label130
   492 end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-5 instructions):
 
    37 label *label9
    38 label *label12
    39 sensor *tmp9 @unit @controller
-    * jump *label15 notEqual *tmp9 @this
-    * jump *label6 always
+   40 jump *label6 equal *tmp9 @this
    41 label *label15
    42 ubind UNIT
    43 print "[gold]Looking for old unit..."
 
   438 print "\n"
   439 printflush message1
   440 sensor *tmp181 switch1 @enabled
-    * jump *label118 notEqual *tmp181 0
-    * jump *label68 always
+  441 jump *label68 equal *tmp181 0
   442 label *label118
   443 sensor *tmp184 .SRC @dead
-    * jump *label120 equal *tmp184 0
-    * jump *label68 always
+  444 jump *label68 notEqual *tmp184 0
   445 label *label120
   446 sensor *tmp187 .DST @dead
-    * jump *label122 equal *tmp187 0
-    * jump *label68 always
+  447 jump *label68 notEqual *tmp187 0
   448 label *label122
   449 sensor *tmp190 .SORTER @dead
-    * jump *label124 equal *tmp190 0
-    * jump *label68 always
+  450 jump *label68 notEqual *tmp190 0
   451 label *label124
   452 op sub :loop_time @time :start
   453 jump *label66 always

Modifications by Jumps phase, Jump Optimization, pass 5, iteration 1:
 
    38 label *label12
    39 sensor *tmp9 @unit @controller
    40 jump *label6 equal *tmp9 @this
-    * label *label15
    41 ubind UNIT
    42 print "[gold]Looking for old unit..."
    43 printflush message1
 
   438 printflush message1
   439 sensor *tmp181 switch1 @enabled
   440 jump *label68 equal *tmp181 0
-    * label *label118
   441 sensor *tmp184 .SRC @dead
   442 jump *label68 notEqual *tmp184 0
-    * label *label120
   443 sensor *tmp187 .DST @dead
   444 jump *label68 notEqual *tmp187 0
-    * label *label122
   445 sensor *tmp190 .SORTER @dead
   446 jump *label68 notEqual *tmp190 0
-    * label *label124
   447 op sub :loop_time @time :start
   448 jump *label66 always
   449 label *label68

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
+    0 label __start__
     1 remark "Which unit type to use"
     2 set UNIT @mega
     3 remark "Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core"
 
    57 jump *label22 always
    58 label *label21
    59 sensor *tmp18 @unit @controlled
-    * jump *label23 equal *tmp18 0
+   60 jump *label17 equal *tmp18 0
    61 print "[salmon]Looking for a free "
    62 print UNIT
    63 print "."
 
   102 sensor *tmp34 .DROP_TARGET @itemCapacity
   103 op lessThan *tmp35 *tmp34 300
   104 op land *tmp36 *tmp33 *tmp35
-    * jump *label35 equal *tmp36 false
+  105 jump *label27 equal *tmp36 false
   106 print "Destination: "
   107 print .CONTAINER
   108 print "\"
 
   210 set .LOCAL_MARGIN .DROP_LEVEL
   211 set .REMOTE_MARGIN .LOAD_LEVEL
   212 set .DIRECTION "[] from vault #"
-    * jump *label59 notEqual LINK_ID 0
+  213 jump *label57 notEqual LINK_ID 0
   214 set .DIRECTION "[] from core"
   215 label *label59
   216 jump *label57 always
 
   273 jump *label76 always
   274 label *label75
   275 sensor *tmp114 @unit @controlled
-    * jump *label77 equal *tmp114 0
+  276 jump *label71 equal *tmp114 0
   277 print "[salmon]Looking for a free "
   278 print UNIT
   279 print "."
 
   332 sensor *tmp139 @unit @totalItems
   333 jump *label96 lessThan *tmp139 .UNIT_CAPACITY
   334 set :state 3
-    * jump *label97 always
+  335 jump *label95 always
   336 label *label96
   337 set .MSG "\nLoading items: [green]"
   338 label *label97
 
   354 jump *label102 greaterThan *tmp149 0
   355 set :state 2
   356 ucontrol approach .SRC_X .SRC_Y 6
-    * jump *label103 always
+  357 jump *label101 always
   358 label *label102
   359 set .MSG "\nDropping items: [green]"
   360 label *label103
 
   465 sensor *tmp198 .DST @dead
   466 op notEqual *tmp199 *tmp198 0
   467 op or *tmp200 *tmp197 *tmp199
-    * jump *label129 equal *tmp200 false
+  468 jump __start__ equal *tmp200 false
   469 control enabled switch1 false
   470 sensor *tmp203 switch1 @enabled
-    * jump *label133 notEqual *tmp203 false
+  471 jump __start__ notEqual *tmp203 false
   472 label *label139
   473 print "[salmon]Local or remote container became invalid."
   474 print "\n"

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-3 instructions):
 
    63 print "."
    64 print ".."
    65 jump *label24 always
-    * label *label23
-    * jump *label17 always
    66 label *label24
    67 label *label22
    68 printflush message1
 
   111 print "n"
   112 print "[salmon]Item dump must be a container or a vault!"
   113 jump *label36 always
-    * label *label35
-    * jump *label27 always
   114 label *label36
   115 label *label34
   116 printflush message1
 
   208 set .DIRECTION "[] from vault #"
   209 jump *label57 notEqual LINK_ID 0
   210 set .DIRECTION "[] from core"
-    * label *label59
   211 jump *label57 always
   212 label *label56
   213 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   274 print "."
   275 print ".."
   276 jump *label78 always
-    * label *label77
-    * jump *label71 always
   277 label *label78
   278 label *label76
   279 printflush message1
 
   328 jump *label95 always
   329 label *label96
   330 set .MSG "\nLoading items: [green]"
-    * label *label97
   331 jump *label95 always
   332 label *label94
   333 ucontrol approach .SRC_X .SRC_Y 6
 
   349 jump *label101 always
   350 label *label102
   351 set .MSG "\nDropping items: [green]"
-    * label *label103
   352 jump *label101 always
   353 label *label100
   354 ucontrol approach .DST_X .DST_Y 6
 
   469 printflush message2
   470 sensor *tmp203 switch1 @enabled
   471 jump *label139 equal *tmp203 false
-    * label *label133
-    * label *label129
   472 end

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-4 instructions):
 
    62 print UNIT
    63 print "."
    64 print ".."
-    * jump *label24 always
    65 label *label24
    66 label *label22
    67 printflush message1
 
   109 print "\"
   110 print "n"
   111 print "[salmon]Item dump must be a container or a vault!"
-    * jump *label36 always
   112 label *label36
   113 label *label34
   114 printflush message1
 
   271 print UNIT
   272 print "."
   273 print ".."
-    * jump *label78 always
   274 label *label78
   275 label *label76
   276 printflush message1
 
   466 printflush message2
   467 sensor *tmp203 switch1 @enabled
   468 jump *label139 equal *tmp203 false
-    * end

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
    62 print UNIT
    63 print "."
    64 print ".."
-    * label *label24
    65 label *label22
    66 printflush message1
    67 jump *label18 always
 
   108 print "\"
   109 print "n"
   110 print "[salmon]Item dump must be a container or a vault!"
-    * label *label36
   111 label *label34
   112 printflush message1
   113 jump *label25 always
 
   269 print UNIT
   270 print "."
   271 print ".."
-    * label *label78
   272 label *label76
   273 printflush message1
   274 jump *label72 always

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
   116 jump *label37 notEqual LINK_ID 0
   117 print "[gold]Locating core..."
   118 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp41 .CORE
+  119 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   120 jump *label38 always
   121 label *label37
   122 print "[gold]Locating vault #"
 
   158 op land *tmp57 *tmp54 *tmp56
   159 jump *label142 notEqual *tmp57 false
   160 label *label46
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp59
+  161 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   162 jump *label47 equal :b_type @vault
   163 set .CORE null
   164 label *label47

Modifications by Final phase, Print Merging, iteration 1 (-34 instructions):
 
    11 sensor *tmp2 switch1 @enabled
    12 jump *label2 notEqual *tmp2 false
    13 label *label136
-    * print "Unit Transport - Single"
-    * print "\n"
-    * print "Activate switch to start."
-    * print "\n"
+   14 print "Unit Transport - Single\nActivate switch to start.\n"
    15 printflush message1
    16 sensor *tmp2 switch1 @enabled
    17 jump *label136 equal *tmp2 false
 
    28 label *label10
    29 print "[salmon]No unit of type "
    30 print UNIT
-    * print " "
-    * print "found. 1"
+   31 print " found. 1"
    32 printflush message1
    33 jump *label7 always
    34 label *label9
 
    48 jump *label21 notEqual @unit null
    49 print "[salmon]No unit of type "
    50 print UNIT
-    * print " "
-    * print "found."
+   51 print " found."
    52 jump *label22 always
    53 label *label21
    54 sensor *tmp18 @unit @controlled
    55 jump *label17 equal *tmp18 0
    56 print "[salmon]Looking for a free "
    57 print UNIT
-    * print "."
-    * print ".."
+   58 print "..."
    59 label *label22
    60 printflush message1
    61 jump *label18 always
 
    84 jump *label134 greaterThan :n 0
    85 label *label30
    86 jump *label33 notEqual .CONTAINER null
-    * print "[salmon]No destination."
-    * print "\n"
+   87 print "[salmon]No destination.\n"
    88 jump *label34 always
    89 label *label33
    90 op notEqual *tmp33 .DROP_TARGET null
 
    94 jump *label27 equal *tmp36 false
    95 print "Destination: "
    96 print .CONTAINER
-    * print "\"
-    * print "n"
-    * print "Item dump: "
+   97 print "\nItem dump: "
    98 print .DROP_TARGET
-    * print "\"
-    * print "n"
-    * print "[salmon]Item dump must be a container or a vault!"
+   99 print "\n[salmon]Item dump must be a container or a vault!"
   100 label *label34
   101 printflush message1
   102 jump *label25 always
 
   110 label *label37
   111 print "[gold]Locating vault #"
   112 print LINK_ID
-    * print "."
-    * print ".."
+  113 print "..."
   114 printflush message1
   115 op add .QUERY_FLAG 99999900 LINK_ID
   116 set :flag .QUERY_FLAG
 
   162 op land *tmp67 *tmp65 *tmp66
   163 jump *label53 equal *tmp67 false
   164 label *label140
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  165 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   166 jump *label54 equal .SORTER null
   167 print "Block found: "
   168 print .SORTER
 
   246 jump *label75 notEqual @unit null
   247 print "[salmon]No unit of type "
   248 print UNIT
-    * print " "
-    * print "found."
+  249 print " found."
   250 jump *label76 always
   251 label *label75
   252 sensor *tmp114 @unit @controlled
   253 jump *label71 equal *tmp114 0
   254 print "[salmon]Looking for a free "
   255 print UNIT
-    * print "."
-    * print ".."
+  256 print "..."
   257 label *label76
   258 printflush message1
   259 jump *label72 always
 
   339 print .ITEM
   340 print .DIRECTION
   341 print *tmp96
-    * print "\"
-    * print "n"
   342 sensor *tmp153 .CONTAINER .ITEM
-    * print "Local items: [gold]"
+  343 print "\nLocal items: [gold]"
   344 print *tmp153
-    * print "["
-    * print "]"
+  345 print "[]"
   346 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
   347 print " (limit [orange]"
   348 print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  349 print "[])"
   350 label *label106
   351 jump *label108 equal .SHOW_REMOTE_LEVEL false
   352 sensor *tmp157 .CORE .ITEM
-    * print "\n"
-    * print "Remote items: [gold]"
+  353 print "\nRemote items: [gold]"
   354 print *tmp157
-    * print "["
-    * print "]"
+  355 print "[]"
   356 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
   357 print " (limit [orange]"
   358 print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  359 print "[])"
   360 label *label110
   361 label *label108
   362 sensor *tmp160 @unit @totalItems
   363 print .MSG
   364 print *tmp160
-    * print "[]"
-    * print "\n"
+  365 print "[]\n"
   366 jump *label114 notEqual :show_state 2
   367 sensor *tmp164 @unit @x
   368 op sub *tmp165 .SRC_X *tmp164
 
   373 op div *tmp170 *tmp169 10
   374 print "[]  arriving in [gold]"
   375 print *tmp170
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  376 print " sec[]\n"
   377 jump *label115 always
   378 label *label114
   379 jump *label116 notEqual :show_state 3
 
   386 op div *tmp179 *tmp178 10
   387 print "[]  arriving in [gold]"
   388 print *tmp179
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  389 print " sec[]\n"
   390 label *label116
   391 label *label115
   392 op floor *tmp180 :loop_time
   393 print "[lightgray]Loop time: "
   394 print *tmp180
-    * print " ms[]"
-    * print "\n"
+  395 print " ms[]\n"
   396 printflush message1
   397 sensor *tmp181 switch1 @enabled
   398 jump *label68 equal *tmp181 0
 
   408 sensor *tmp194 .SORTER @dead
   409 jump *label128 notEqual *tmp194 0
   410 label *label138
-    * print "[salmon]sorter1 is missing!"
-    * print "\n"
-    * print "[gold]Please place and link sorter or inverted sorter to the processor."
-    * print "\n"
+  411 print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
   412 printflush message1
   413 printflush message2
   414 sensor *tmp194 sorter1 @dead
 
   424 sensor *tmp203 switch1 @enabled
   425 jump __start__ notEqual *tmp203 false
   426 label *label139
-    * print "[salmon]Local or remote container became invalid."
-    * print "\n"
-    * print "[gold]Please fix and press button to reinitialize."
-    * print "\n"
+  427 print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
   428 printflush message1
   429 printflush message2
   430 sensor *tmp203 switch1 @enabled

Final code before resolving virtual instructions:

        label __start__                                              param UNIT              = @mega;        /// Which unit type to use
    0:  remark "Which unit type to use"                              ...
    2:  set UNIT @mega                                               ...
    3:  remark "Remote vault ID (1-99); if nonzero, items are moved  param LINK_ID           = 0;            /// Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core
    5:  set LINK_ID 0                                                ...
    6:  remark "How much of local container capacity to use, in perc param LOCAL_LIMIT       = 100;          /// How much of local container capacity to use, in percents (20-100).
    8:  set LOCAL_LIMIT 100                                          ...
    9:  remark "How much of remote container capacity to use, in per param REMOTE_LIMIT      = 100;          /// How much of remote container capacity to use, in percents (20-100).
   11:  set REMOTE_LIMIT 100                                         ...
   12:  op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20                       var EFF_LOCAL_LIMIT = max(LOCAL_LIMIT, 20);
   13:  op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20                     var EFF_REMOTE_LIMIT = max(REMOTE_LIMIT, 20);
   14:  sensor *tmp2 switch1 @enabled                                while !switch1.@enabled do
   15:  jump *label2 notEqual *tmp2 false                            ...
        label *label136                                              ...
   16:  print "Unit Transport - Single\nActivate switch to start.\n" println("Activate switch to start.");
   17:  printflush message1                                          printflush(message1);
   18:  sensor *tmp2 switch1 @enabled                                while !switch1.@enabled do
   19:  jump *label136 equal *tmp2 false                             ...
        label *label2                                                ...
   20:  sensor *tmp4 @unit @dead                                     while @unit.@dead != 0 do
   21:  jump *label5 equal *tmp4 0                                   ...
        label *label137                                              ...
   22:  set :rebindUnit:first_unit null                              first_unit = null;
        label *label7                                                while true do
   23:  ubind UNIT                                                   ubind(UNIT);
   24:  jump *label10 equal @unit null                               if @unit != null then
   25:  set :rebindUnit:first_unit @unit                             first_unit = @unit;
   26:  jump *label9 always 0 0                                      break;
        label *label10                                               if @unit != null then
   27:  print "[salmon]No unit of type "                             print($"[salmon]No unit of type $UNIT found. 1");
   28:  print UNIT                                                   ...
   29:  print " found. 1"                                            ...
   30:  printflush message1                                          printflush(message1);
   31:  jump *label7 always 0 0                                      while true do
        label *label9                                                ...
        label *label12                                               do
   32:  sensor *tmp9 @unit @controller                               if @unit.@controller == @this then
   33:  jump *label6 equal *tmp9 @this                               ...
   34:  ubind UNIT                                                   ubind(UNIT);
   35:  print "[gold]Looking for old unit..."                        print($"[gold]Looking for old unit...");
   36:  printflush message1                                          printflush(message1);
   37:  op notEqual *tmp12 @unit :rebindUnit:first_unit              while @unit != first_unit and first_unit.@dead == 0;
   38:  sensor *tmp13 :rebindUnit:first_unit @dead                   ...
   39:  op equal *tmp14 *tmp13 0                                     ...
   40:  op land *tmp15 *tmp12 *tmp14                                 ...
   41:  jump *label12 notEqual *tmp15 false                          do
        label *label18                                               while true do
   42:  ubind UNIT                                                   ubind(UNIT);
   43:  jump *label21 notEqual @unit null                            if @unit == null then
   44:  print "[salmon]No unit of type "                             print($"[salmon]No unit of type $UNIT found.");
   45:  print UNIT                                                   ...
   46:  print " found."                                              ...
   47:  jump *label22 always 0 0                                     if @unit == null then
        label *label21                                               ...
   48:  sensor *tmp18 @unit @controlled                              elsif @unit.@controlled != 0 then
   49:  jump *label17 equal *tmp18 0                                 ...
   50:  print "[salmon]Looking for a free "                          print($"[salmon]Looking for a free $UNIT...");
   51:  print UNIT                                                   ...
   52:  print "..."                                                  ...
        label *label22                                               if @unit == null then
   53:  printflush message1                                          printflush(message1);
   54:  jump *label18 always 0 0                                     while true do
        label *label17                                               findUnit();
        label *label6                                                rebindUnit();
   55:  sensor *tmp4 @unit @dead                                     while @unit.@dead != 0 do
   56:  jump *label137 notEqual *tmp4 0                              ...
        label *label5                                                ...
   57:  sensor .UNIT_CAPACITY @unit @itemCapacity                    UNIT_CAPACITY = @unit.@itemCapacity;
   58:  sensor *tmp22 @unit @speed                                   SPEED_SEC = @unit.@speed / 10;
   59:  op div .SPEED_SEC *tmp22 10                                  ...
   60:  ucontrol flag 1 0 0 0 0                                      flag(1);
        label *label25                                               while true do
   61:  set .CONTAINER null                                          CONTAINER = null;
   62:  set .DROP_TARGET null                                        DROP_TARGET = null;
   63:  set :n @links                                                n = @links;
   64:  jump *label30 lessThanEq :n 0                                while n > 0 do
        label *label134                                              ...
   65:  op sub :n :n 1                                               n = n - 1;
   66:  getlink :block :n                                            block = getlink(n);
   67:  sensor *tmp28 :block @itemCapacity                           if block.@itemCapacity > 0 then
   68:  jump *label31 lessThanEq *tmp28 0                            ...
   69:  set .DROP_TARGET .CONTAINER                                  DROP_TARGET = CONTAINER;
   70:  set .CONTAINER :block                                        CONTAINER = block;
        label *label31                                               if block.@itemCapacity > 0 then
   71:  jump *label134 greaterThan :n 0                              while n > 0 do
        label *label30                                               ...
   72:  jump *label33 notEqual .CONTAINER null                       if CONTAINER == null then
   73:  print "[salmon]No destination.\n"                            println("[salmon]No destination.");
   74:  jump *label34 always 0 0                                     if CONTAINER == null then
        label *label33                                               ...
   75:  op notEqual *tmp33 .DROP_TARGET null                         elsif (DROP_TARGET != null) and (DROP_TARGET.@itemCapacity < 300) then
   76:  sensor *tmp34 .DROP_TARGET @itemCapacity                     ...
   77:  op lessThan *tmp35 *tmp34 300                                ...
   78:  op land *tmp36 *tmp33 *tmp35                                 ...
   79:  jump *label27 equal *tmp36 false                             ...
   80:  print "Destination: "                                        print($"Destination: $CONTAINER\n");
   81:  print .CONTAINER                                             ...
   82:  print "\nItem dump: "                                        print($"Item dump: $DROP_TARGET\n");
   83:  print .DROP_TARGET                                           ...
   84:  print "\n[salmon]Item dump must be a container or a vault!"  print($"[salmon]Item dump must be a container or a vault!");
        label *label34                                               if CONTAINER == null then
   85:  printflush message1                                          printflush(message1);
   86:  jump *label25 always 0 0                                     while true do
        label *label27                                               ...
   87:  set .CORE null                                               CORE = null;
   88:  jump *label37 notEqual LINK_ID 0                             if LINK_ID == 0 then
   89:  print "[gold]Locating core..."                               print("[gold]Locating core...");
   90:  printflush message1                                          printflush(message1);
   91:  ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE  CORE = ulocate(:building, :core, false, out CORE_X, out CORE_Y);
   92:  jump *label38 always 0 0                                     if LINK_ID == 0 then
        label *label37                                               ...
   93:  print "[gold]Locating vault #"                               print($"[gold]Locating vault #$LINK_ID...");
   94:  print LINK_ID                                                ...
   95:  print "..."                                                  ...
   96:  printflush message1                                          printflush(message1);
   97:  op add .QUERY_FLAG 99999900 LINK_ID                          QUERY_FLAG = 99999900 + LINK_ID;
   98:  set :flag .QUERY_FLAG                                        flag = QUERY_FLAG;
   99:  ucontrol flag .QUERY_FLAG 0 0 0 0                            flag(flag);
  100:  sensor *tmp44 @unit @dead                                    while (flag == QUERY_FLAG) and (@unit.@dead == 0) do
  101:  op equal *tmp46 *tmp44 0                                     ...
  102:  jump *label41 equal *tmp46 false                             ...
        label *label141                                              ...
  103:  ucontrol stop 0 0 0 0 0                                      stop();                       // Keep controlling the unit
  104:  sensor :flag @unit @flag                                     flag = @unit.@flag;
  105:  op equal *tmp43 :flag .QUERY_FLAG                            while (flag == QUERY_FLAG) and (@unit.@dead == 0) do
  106:  sensor *tmp44 @unit @dead                                    ...
  107:  op equal *tmp45 *tmp44 0                                     ...
  108:  op land *tmp46 *tmp43 *tmp45                                 ...
  109:  jump *label141 notEqual *tmp46 false                         ...
        label *label41                                               ...
  110:  jump *label42 equal :flag .QUERY_FLAG                        if (flag != QUERY_FLAG) then
  111:  op idiv :position :flag 100                                  position = flag \ 100;
  112:  op mod .CORE_X :position @mapw                               CORE_X = position % @mapw;
  113:  op idiv .CORE_Y :position @mapw                              CORE_Y = position \ @mapw;
  114:  ucontrol within .CORE_X .CORE_Y 8 *tmp53 0                   while (within(CORE_X, CORE_Y, RADIUS_WITHIN) == false) and (@unit.@dead == 0) do
  115:  op equal *tmp54 *tmp53 false                                 ...
  116:  sensor *tmp55 @unit @dead                                    ...
  117:  op equal *tmp56 *tmp55 0                                     ...
  118:  op land *tmp57 *tmp54 *tmp56                                 ...
  119:  jump *label46 equal *tmp57 false                             ...
        label *label142                                              ...
  120:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  121:  ucontrol within .CORE_X .CORE_Y 8 *tmp53 0                   while (within(CORE_X, CORE_Y, RADIUS_WITHIN) == false) and (@unit.@dead == 0) do
  122:  op equal *tmp54 *tmp53 false                                 ...
  123:  sensor *tmp55 @unit @dead                                    ...
  124:  op equal *tmp56 *tmp55 0                                     ...
  125:  op land *tmp57 *tmp54 *tmp56                                 ...
  126:  jump *label142 notEqual *tmp57 false                         ...
        label *label46                                               ...
  127:  ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0            CORE = getBlock(CORE_X, CORE_Y, out b_type);
  128:  jump *label47 equal :b_type @vault                           if b_type != @vault then
  129:  set .CORE null                                               CORE = null;
        label *label47                                               if b_type != @vault then
        label *label42                                               if (flag != QUERY_FLAG) then
        label *label38                                               if LINK_ID == 0 then
  130:  jump *label49 notEqual .CORE null                            if CORE == null then
  131:  end                                                          end();
        label *label49                                               if CORE == null then
  132:  set .SORTER sorter1                                          SORTER = sorter1;
  133:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  134:  op notEqual *tmp65 :sorter_type @sorter                      while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
  135:  op notEqual *tmp66 :sorter_type @inverted-sorter             ...
  136:  op land *tmp67 *tmp65 *tmp66                                 ...
  137:  jump *label53 equal *tmp67 false                             ...
        label *label140                                              ...
  138:  print "[salmon]Block sorter1 is neither a sorter, nor an inv println("[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.");
  139:  jump *label54 equal .SORTER null                             if SORTER != null then
  140:  print "Block found: "                                        print("Block found: ", SORTER);
  141:  print .SORTER                                                ...
        label *label54                                               if SORTER != null then
  142:  printflush message1                                          printflush(message1);
  143:  set .SORTER sorter1                                          SORTER = sorter1;
  144:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  145:  op notEqual *tmp65 :sorter_type @sorter                      while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
  146:  op notEqual *tmp66 :sorter_type @inverted-sorter             ...
  147:  op land *tmp67 *tmp65 *tmp66                                 ...
  148:  jump *label140 notEqual *tmp67 false                         ...
        label *label53                                               ...
  149:  jump *label56 notEqual :sorter_type @sorter                  if (sorter_type == @sorter) then
  150:  set .SHOW_REMOTE_LEVEL true                                  SHOW_REMOTE_LEVEL = true;
  151:  set .SRC .CORE                                               SRC = CORE;
  152:  set .DST .CONTAINER                                          DST = CONTAINER;
  153:  sensor :src_capacity .CORE @itemCapacity                     src_capacity = SRC.@itemCapacity;
  154:  sensor :dst_capacity .CONTAINER @itemCapacity                dst_capacity = DST.@itemCapacity;
  155:  op sub *tmp75 100 .EFF_REMOTE_LIMIT                          LOAD_LEVEL = (src_capacity * (100 - EFF_REMOTE_LIMIT)) \ 100;
  156:  op mul *tmp76 :src_capacity *tmp75                           ...
  157:  op idiv .LOAD_LEVEL *tmp76 100                               ...
  158:  op mul *tmp78 :dst_capacity .EFF_LOCAL_LIMIT                 DROP_LEVEL = (dst_capacity * EFF_LOCAL_LIMIT) \ 100;
  159:  op idiv .DROP_LEVEL *tmp78 100                               ...
  160:  set .LOCAL_MARGIN .DROP_LEVEL                                LOCAL_MARGIN = DROP_LEVEL;
  161:  set .REMOTE_MARGIN .LOAD_LEVEL                               REMOTE_MARGIN = LOAD_LEVEL;
  162:  set .DIRECTION "[] from vault #"                             DIRECTION = (LINK_ID == 0) ? "[] from core"  : "[] from vault #";
  163:  jump *label57 notEqual LINK_ID 0                             ...
  164:  set .DIRECTION "[] from core"                                ...
  165:  jump *label57 always 0 0                                     if (sorter_type == @sorter) then
        label *label56                                               ...
  166:  op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0                  SHOW_REMOTE_LEVEL = LINK_ID > 0;
  167:  set .SRC .CONTAINER                                          SRC = CONTAINER;
  168:  set .DST .CORE                                               DST = CORE;
  169:  sensor :src_capacity .CONTAINER @itemCapacity                src_capacity = SRC.@itemCapacity;
  170:  sensor :dst_capacity .CORE @itemCapacity                     dst_capacity = DST.@itemCapacity;
  171:  op sub *tmp85 100 .EFF_LOCAL_LIMIT                           LOAD_LEVEL = (src_capacity * (100 - EFF_LOCAL_LIMIT)) \ 100;
  172:  op mul *tmp86 :src_capacity *tmp85                           ...
  173:  op idiv .LOAD_LEVEL *tmp86 100                               ...
  174:  op mul *tmp88 :dst_capacity .EFF_REMOTE_LIMIT                DROP_LEVEL = (dst_capacity * EFF_REMOTE_LIMIT) \ 100 + ((LINK_ID == 0) * UNIT_CAPACITY);
  175:  op idiv *tmp89 *tmp88 100                                    ...
  176:  op equal *tmp90 LINK_ID 0                                    ...
  177:  op mul *tmp91 *tmp90 .UNIT_CAPACITY                          ...
  178:  op add .DROP_LEVEL *tmp89 *tmp91                             ...
  179:  set .LOCAL_MARGIN .LOAD_LEVEL                                LOCAL_MARGIN = LOAD_LEVEL;
  180:  set .REMOTE_MARGIN .DROP_LEVEL                               REMOTE_MARGIN = DROP_LEVEL;
  181:  set .DIRECTION "[] to vault #"                               DIRECTION = (LINK_ID == 0) ? "[] to core" : "[] to vault #";
  182:  jump *label61 notEqual LINK_ID 0                             ...
  183:  set .DIRECTION "[] to core"                                  ...
        label *label61                                               ...
        label *label57                                               if (sorter_type == @sorter) then
  184:  set *tmp96 LINK_ID                                           LINK_TXT = (LINK_ID == 0) ? ""  : LINK_ID;
  185:  jump *label63 notEqual LINK_ID 0                             ...
  186:  set *tmp96 ""                                                ...
        label *label63                                               ...
  187:  sensor .SRC_X .SRC @x                                        SRC_X = SRC.@x;
  188:  sensor .SRC_Y .SRC @y                                        SRC_Y = SRC.@y;
  189:  sensor .DST_X .DST @x                                        DST_X = DST.@x;
  190:  sensor .DST_Y .DST @y                                        DST_Y = DST.@y;
  191:  jump *label64 notEqual .DROP_TARGET null                     if DROP_TARGET == null then
  192:  set .DROP_TARGET .CORE                                       DROP_TARGET = CORE;
  193:  set .DROP_X .CORE_X                                          DROP_X = CORE_X;
  194:  set .DROP_Y .CORE_Y                                          DROP_Y = CORE_Y;
  195:  jump *label65 always 0 0                                     if DROP_TARGET == null then
        label *label64                                               ...
  196:  sensor .DROP_X .DROP_TARGET @x                               DROP_X = DROP_TARGET.@x;
  197:  sensor .DROP_Y .DROP_TARGET @y                               DROP_Y = DROP_TARGET.@y;
        label *label65                                               if DROP_TARGET == null then
  198:  set .LAST_ITEM @mono                                         LAST_ITEM = @mono;      // Must not be null
  199:  set :loop_time 0                                             loop_time = 0;
  200:  set :state 1                                                 state = S_UNLOAD;
  201:  ucontrol stop 0 0 0 0 0                                      stop();
        label *label66                                               while true do
  202:  set :start @time                                             start = @time;
  203:  sensor *tmp106 @unit @dead                                   if (@unit.@dead == 0) <= (@unit.@controller != @this) then
  204:  op equal *tmp107 *tmp106 0                                   ...
  205:  sensor *tmp108 @unit @controller                             ...
  206:  op notEqual *tmp109 *tmp108 @this                            ...
  207:  jump *label69 greaterThan *tmp107 *tmp109                    ...
        label *label72                                               while true do
  208:  ubind UNIT                                                   ubind(UNIT);
  209:  jump *label75 notEqual @unit null                            if @unit == null then
  210:  print "[salmon]No unit of type "                             print($"[salmon]No unit of type $UNIT found.");
  211:  print UNIT                                                   ...
  212:  print " found."                                              ...
  213:  jump *label76 always 0 0                                     if @unit == null then
        label *label75                                               ...
  214:  sensor *tmp114 @unit @controlled                             elsif @unit.@controlled != 0 then
  215:  jump *label71 equal *tmp114 0                                ...
  216:  print "[salmon]Looking for a free "                          print($"[salmon]Looking for a free $UNIT...");
  217:  print UNIT                                                   ...
  218:  print "..."                                                  ...
        label *label76                                               if @unit == null then
  219:  printflush message1                                          printflush(message1);
  220:  jump *label72 always 0 0                                     while true do
        label *label71                                               findUnit();
  221:  ucontrol flag 1 0 0 0 0                                      flag(1);            // Mark unit as active
  222:  set :state 1                                                 state = S_UNLOAD;   // We'll unload our unit first
        label *label69                                               if (@unit.@dead == 0) <= (@unit.@controller != @this) then
  223:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  224:  jump *label79 equal .ITEM .LAST_ITEM                         if ITEM != LAST_ITEM then
  225:  jump *label83 notEqual .ITEM null                            while ITEM == null do
        label *label135                                              ...
  226:  print "[salmon]No item type selected for transport."         print("[salmon]No item type selected for transport.");
  227:  printflush message1                                          printflush(message1);
  228:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  229:  jump *label135 equal .ITEM null                              while ITEM == null do
        label *label83                                               ...
  230:  set .LAST_ITEM .ITEM                                         LAST_ITEM = ITEM;
  231:  set :state 1                                                 state = S_UNLOAD;
        label *label79                                               if ITEM != LAST_ITEM then
  232:  set :show_state 0                                            show_state = S_UNUSED;
  233:  jump *label84 notEqual :state 1                              if state == S_UNLOAD then
  234:  sensor *tmp124 @unit @firstItem                              if @unit.@firstItem == ITEM then
  235:  jump *label86 notEqual *tmp124 .ITEM                         ...
  236:  set :state 3                                                 state = S_APPROACH_DST;
  237:  jump *label87 always 0 0                                     if @unit.@firstItem == ITEM then
        label *label86                                               ...
  238:  sensor *tmp127 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  239:  jump *label88 notEqual *tmp127 0                             ...
  240:  set :state 2                                                 state = S_APPROACH_SRC;
  241:  jump *label89 always 0 0                                     elsif @unit.@totalItems == 0 then
        label *label88                                               ...
  242:  set .MSG "\nUnloading previous items: [green]"               MSG = "\nUnloading previous items: [green]";
  243:  ucontrol approach .DROP_X .DROP_Y 6 0 0                      approach(DROP_X, DROP_Y, RADIUS_APPROACH);
  244:  ucontrol within .DROP_X .DROP_Y 8 *tmp130 0                  if within(DROP_X, DROP_Y, RADIUS_WITHIN) then
  245:  jump *label90 equal *tmp130 false                            ...
  246:  ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY 0 0 0          itemDrop(DROP_TARGET, UNIT_CAPACITY);
        label *label90                                               if within(DROP_X, DROP_Y, RADIUS_WITHIN) then
        label *label89                                               elsif @unit.@totalItems == 0 then
        label *label87                                               if @unit.@firstItem == ITEM then
        label *label84                                               if state == S_UNLOAD then
  247:  jump *label92 notEqual :state 2                              if state == S_APPROACH_SRC then
  248:  ucontrol within .SRC_X .SRC_Y 8 *tmp134 0                    if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
  249:  jump *label94 equal *tmp134 false                            ...
  250:  sensor *tmp136 .SRC .ITEM                                    max_load = max(SRC.sensor(ITEM) - LOAD_LEVEL, 0);
  251:  op sub *tmp137 *tmp136 .LOAD_LEVEL                           ...
  252:  op max :max_load *tmp137 0                                   ...
  253:  ucontrol itemTake .SRC .ITEM :max_load 0 0                   itemTake(SRC, ITEM, max_load);
  254:  sensor *tmp139 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  255:  jump *label96 lessThan *tmp139 .UNIT_CAPACITY                ...
  256:  set :state 3                                                 state = S_APPROACH_DST;
  257:  jump *label95 always 0 0                                     if @unit.@totalItems >= UNIT_CAPACITY then
        label *label96                                               ...
  258:  set .MSG "\nLoading items: [green]"                          MSG = "\nLoading items: [green]";
  259:  jump *label95 always 0 0                                     if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label94                                               ...
  260:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  261:  set .MSG "\nGoing to source: [green]"                        MSG = "\nGoing to source: [green]";
  262:  set :show_state 2                                            show_state = S_APPROACH_SRC;
        label *label95                                               if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label92                                               if state == S_APPROACH_SRC then
  263:  jump *label98 notEqual :state 3                              if state == S_APPROACH_DST then
  264:  ucontrol within .DST_X .DST_Y 8 *tmp144 0                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
  265:  jump *label100 equal *tmp144 false                           ...
  266:  sensor *tmp146 .DST .ITEM                                    max_drop = max(DROP_LEVEL - DST.sensor(ITEM), 0);
  267:  op sub *tmp147 .DROP_LEVEL *tmp146                           ...
  268:  op max :max_drop *tmp147 0                                   ...
  269:  ucontrol itemDrop .DST :max_drop 0 0 0                       itemDrop(DST, max_drop);
  270:  sensor *tmp149 @unit @totalItems                             if @unit.@totalItems <= 0 then
  271:  jump *label102 greaterThan *tmp149 0                         ...
  272:  set :state 2                                                 state = S_APPROACH_SRC;
  273:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  274:  jump *label101 always 0 0                                    if @unit.@totalItems <= 0 then
        label *label102                                              ...
  275:  set .MSG "\nDropping items: [green]"                         MSG = "\nDropping items: [green]";
  276:  jump *label101 always 0 0                                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label100                                              ...
  277:  ucontrol approach .DST_X .DST_Y 6 0 0                        approach(DST_X, DST_Y, RADIUS_APPROACH);
  278:  set .MSG "\nGoing to destination: [green]"                   MSG = "\nGoing to destination: [green]";
  279:  set :show_state 3                                            show_state = S_APPROACH_DST;
        label *label101                                              if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label98                                               if state == S_APPROACH_DST then
  280:  print "Moving [green]"                                       print($"Moving [green]$ITEM$DIRECTION$LINK_TXT\n");
  281:  print .ITEM                                                  ...
  282:  print .DIRECTION                                             ...
  283:  print *tmp96                                                 ...
  284:  sensor *tmp153 .CONTAINER .ITEM                              print($"Local items: [gold]$[]", CONTAINER.sensor(ITEM));
  285:  print "\nLocal items: [gold]"                                ...
  286:  print *tmp153                                                ...
  287:  print "[]"                                                   ...
  288:  jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100            if EFF_LOCAL_LIMIT < 100 then
  289:  print " (limit [orange]"                                     print($" (limit [orange]$LOCAL_MARGIN[])");
  290:  print .LOCAL_MARGIN                                          ...
  291:  print "[])"                                                  ...
        label *label106                                              if EFF_LOCAL_LIMIT < 100 then
  292:  jump *label108 equal .SHOW_REMOTE_LEVEL false                if SHOW_REMOTE_LEVEL then
  293:  sensor *tmp157 .CORE .ITEM                                   print($"\nRemote items: [gold]$[]", CORE.sensor(ITEM));
  294:  print "\nRemote items: [gold]"                               ...
  295:  print *tmp157                                                ...
  296:  print "[]"                                                   ...
  297:  jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100           if EFF_REMOTE_LIMIT < 100 then
  298:  print " (limit [orange]"                                     print($" (limit [orange]$REMOTE_MARGIN[])");
  299:  print .REMOTE_MARGIN                                         ...
  300:  print "[])"                                                  ...
        label *label110                                              if EFF_REMOTE_LIMIT < 100 then
        label *label108                                              if SHOW_REMOTE_LEVEL then
  301:  sensor *tmp160 @unit @totalItems                             println(MSG, @unit.@totalItems, "[]");
  302:  print .MSG                                                   ...
  303:  print *tmp160                                                ...
  304:  print "[]\n"                                                 ...
  305:  jump *label114 notEqual :show_state 2                        if show_state == S_APPROACH_SRC then
  306:  sensor *tmp164 @unit @x                                      print($"[]  arriving in [gold]$ sec[]\n", len(SRC_X - @unit.@x, SRC_Y - @unit.@y) \ SPEED_SEC / 10);
  307:  op sub *tmp165 .SRC_X *tmp164                                ...
  308:  sensor *tmp166 @unit @y                                      ...
  309:  op sub *tmp167 .SRC_Y *tmp166                                ...
  310:  op len *tmp168 *tmp165 *tmp167                               ...
  311:  op idiv *tmp169 *tmp168 .SPEED_SEC                           ...
  312:  op div *tmp170 *tmp169 10                                    ...
  313:  print "[]  arriving in [gold]"                               ...
  314:  print *tmp170                                                ...
  315:  print " sec[]\n"                                             ...
  316:  jump *label115 always 0 0                                    if show_state == S_APPROACH_SRC then
        label *label114                                              ...
  317:  jump *label116 notEqual :show_state 3                        elsif show_state == S_APPROACH_DST then
  318:  sensor *tmp173 @unit @x                                      print($"[]  arriving in [gold]$ sec[]\n", len(DST_X - @unit.@x, DST_Y - @unit.@y) \ SPEED_SEC / 10);
  319:  op sub *tmp174 .DST_X *tmp173                                ...
  320:  sensor *tmp175 @unit @y                                      ...
  321:  op sub *tmp176 .DST_Y *tmp175                                ...
  322:  op len *tmp177 *tmp174 *tmp176                               ...
  323:  op idiv *tmp178 *tmp177 .SPEED_SEC                           ...
  324:  op div *tmp179 *tmp178 10                                    ...
  325:  print "[]  arriving in [gold]"                               ...
  326:  print *tmp179                                                ...
  327:  print " sec[]\n"                                             ...
        label *label116                                              elsif show_state == S_APPROACH_DST then
        label *label115                                              if show_state == S_APPROACH_SRC then
  328:  op floor *tmp180 :loop_time 0                                println("[lightgray]Loop time: ", floor(loop_time), " ms[]");
  329:  print "[lightgray]Loop time: "                               ...
  330:  print *tmp180                                                ...
  331:  print " ms[]\n"                                              ...
  332:  printflush message1                                          printflush(message1);
  333:  sensor *tmp181 switch1 @enabled                              if switch1.@enabled == 0 then break; end;
  334:  jump *label68 equal *tmp181 0                                ...
  335:  sensor *tmp184 .SRC @dead                                    if SRC.@dead != 0 then break; end;
  336:  jump *label68 notEqual *tmp184 0                             ...
  337:  sensor *tmp187 .DST @dead                                    if DST.@dead != 0 then break; end;
  338:  jump *label68 notEqual *tmp187 0                             ...
  339:  sensor *tmp190 .SORTER @dead                                 if SORTER.@dead != 0 then break; end;
  340:  jump *label68 notEqual *tmp190 0                             ...
  341:  op sub :loop_time @time :start                               loop_time = @time - start;
  342:  jump *label66 always 0 0                                     while true do
        label *label68                                               ...
  343:  sensor *tmp194 .SORTER @dead                                 while SORTER.@dead == 0 do
  344:  jump *label128 notEqual *tmp194 0                            ...
        label *label138                                              ...
  345:  print "[salmon]sorter1 is missing!\n[gold]Please place and l println("[gold]Please place and link sorter or inverted sorter to the processor.");
  346:  printflush message1                                          printflush(message1);
  347:  printflush message2                                          printflush(message2);
  348:  sensor *tmp194 sorter1 @dead                                 while SORTER.@dead == 0 do
  349:  jump *label138 equal *tmp194 0                               ...
        label *label128                                              ...
  350:  sensor *tmp196 .SRC @dead                                    if SRC.@dead != 0 or DST.@dead != 0 then
  351:  op notEqual *tmp197 *tmp196 0                                ...
  352:  sensor *tmp198 .DST @dead                                    ...
  353:  op notEqual *tmp199 *tmp198 0                                ...
  354:  op or *tmp200 *tmp197 *tmp199                                ...
  355:  jump __start__ equal *tmp200 false                           ...
  356:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  357:  sensor *tmp203 switch1 @enabled                              while !switch1.@enabled do
  358:  jump __start__ notEqual *tmp203 false                        ...
        label *label139                                              ...
  359:  print "[salmon]Local or remote container became invalid.\n[g println("[gold]Please fix and press button to reinitialize.");
  360:  printflush message1                                          printflush(message1);
  361:  printflush message2                                          printflush(message2);
  362:  sensor *tmp203 switch1 @enabled                              while !switch1.@enabled do
  363:  jump *label139 equal *tmp203 false                           ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   318     1x    318,0  <no function>
    26     2x     13,0  inline void findUnit()
    20     1x     20,0  inline void rebindUnit()

Performance: parsed in 351 ms, compiled in 246 ms, optimized in 610 ms, run in 14 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (11 steps):
The program didn't generate any output.
Execution exception at instruction 14: sensor *tmp2 switch1 @enabled:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
