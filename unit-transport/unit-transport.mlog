print "Configurable options:"
print "Which unit type to use:"
set UNIT @mega
print "Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core:"
set LINK_ID 0
print "Start in auto allocation mode?"
set AUTO_ALLOCATION true
print "Max units to use, in both manual and auto allocation modes:"
set MAX_UNITS 24
print "Leave discarded units with nonzero flag for housekeeping (flag-clearing) processor to pick them up:"
set HOUSEKEEPING true
print "Drop superfluous items to air, even when there's a core:"
set DROP_TO_AIR true
print "How much of local container capacity to use, in percents (20-100):"
set LOCAL_LIMIT 100
print "How much of remote container capacity to use, in percents (20-100)"
set REMOTE_LIMIT 100
print "Allocate at least this much more units than needed:"
set OVERALLOCATION_LOW 0.25
print "Allocate at most this much more units than needed:"
set OVERALLOCATION_HIGH 0.75
print "Use average of last three flow rate values for better unit auto allocation stability:"
set STABILIZATION false
print "End of configurable options"
printflush null
set .MESSAGE ""
op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION
op mul .S_UNUSED -1 HOUSEKEEPING
set .STATE_LIMIT null
set .ITEM_ICON null
set .ITEM null
set .CORE_Y null
set .CORE_X null
set .CONTAINER_INDEX null
op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
ubind UNIT
jump 45 notEqual @unit null
print "[salmon]No unit of type "
print UNIT
print " found."
printflush message1
ubind UNIT
jump 39 equal @unit null
set :first_unit @unit
sensor *tmp8 @unit @speed
op div .SPEED_SEC *tmp8 10
sensor *tmp10 @unit @speed
op div .SPEED *tmp10 1000
set .TARGET 0
sensor *tmp12 @unit @controller
jump 58 notEqual *tmp12 @this
sensor :state @unit @flag
op greaterThanEq *tmp16 :state 1
op lessThan *tmp17 :state 6
op land *tmp18 *tmp16 *tmp17
op add .TARGET .TARGET *tmp18
ubind UNIT
jump 62 equal @unit :first_unit
sensor *tmp20 :first_unit @dead
jump 51 equal *tmp20 0
set .CHANGE 0
set :active .TARGET
set .DEC_LIMIT 0
set .INC_LIMIT 0
sensor .UNIT_CAPACITY @unit @itemCapacity
set :first_unit null
set .CONTAINER null
set .CONTAINERS 0
set :n @links
jump 81 lessThanEq :n 0
op sub :n :n 1
getlink :block :n
sensor *tmp28 :block @type
jump 77 equal *tmp28 @vault
jump 80 notEqual *tmp28 @container
set .CONTAINER :block
op add .CONTAINERS .CONTAINERS 1
set .CONTAINER_INDEX :n
jump 72 greaterThan :n 0
jump 85 notEqual .CONTAINER null
print "[salmon]No vault or container."
printflush message1
jump 68 always 0 0
set .CORE null
jump 98 notEqual LINK_ID 0
print "[green]Locating core..."
printflush message1
ubind UNIT
sensor *tmp35 @unit @controlled
jump 94 notEqual *tmp35 0
ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
ucontrol flag .S_UNUSED 0 0 0 0
jump 87 equal .CORE null
set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
op equal .DROP_TO_CORE DROP_TO_AIR false
jump 143 always 0 0
printflush message2
print "[green]Locating vault #"
print LINK_ID
print "..."
printflush message1
op add .QUERY_FLAG 99999900 LINK_ID
set :flag .QUERY_FLAG
ubind UNIT
sensor *tmp43 @unit @controlled
jump 111 equal *tmp43 0
ubind UNIT
sensor *tmp43 @unit @controlled
jump 108 notEqual *tmp43 0
ucontrol flag .QUERY_FLAG 0 0 0 0
sensor *tmp46 @unit @dead
jump 117 notEqual *tmp46 0
ucontrol stop 0 0 0 0 0
sensor :flag @unit @flag
jump 112 equal :flag .QUERY_FLAG
jump 137 equal :flag .QUERY_FLAG
op idiv :position :flag 100
op mod .CORE_X :position @mapw
op idiv .CORE_Y :position @mapw
sensor *tmp54 @unit @dead
jump 128 notEqual *tmp54 0
ucontrol within .CORE_X .CORE_Y 8 *tmp56 0
jump 128 notEqual *tmp56 false
ucontrol approach .CORE_X .CORE_Y 6 0 0
sensor *tmp54 @unit @dead
jump 123 equal *tmp54 0
ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
jump 137 equal :b_type @vault
print "[salmon]Building at "
print .CORE_X
print ", "
print .CORE_Y
print " is not a vault!"
printflush message2
set .CORE null
ucontrol flag .S_UNUSED 0 0 0 0
jump 104 equal .CORE null
set .DISCARD_UNIT_MAX_ITEMS 0
jump 142 equal DROP_TO_AIR false
set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
set .DROP_TO_CORE false
set .SORTER sorter1
sensor :sorter_type sorter1 @type
jump 155 equal :sorter_type @sorter
jump 155 equal :sorter_type @inverted-sorter
print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
jump 151 equal .SORTER null
print "Block found: "
print .SORTER
printflush message1
set .SORTER sorter1
sensor :sorter_type sorter1 @type
jump 146 notEqual :sorter_type @sorter
jump 177 notEqual :sorter_type @sorter
set .SHOW_REMOTE_LEVEL true
set .SRC .CORE
set .DST .CONTAINER
sensor :src_capacity .CORE @itemCapacity
sensor :dst_capacity .CONTAINER @itemCapacity
op sub *tmp73 100 .EFF_REMOTE_LIMIT
op mul *tmp74 :src_capacity *tmp73
op idiv .LOAD_LEVEL *tmp74 100
op mul *tmp76 :dst_capacity .EFF_LOCAL_LIMIT
op idiv .DROP_LEVEL *tmp76 100
set .LOCAL_MARGIN .DROP_LEVEL
set .REMOTE_MARGIN .LOAD_LEVEL
op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998
set .HIGH_LEVEL_TRIGGER :dst_capacity
set .FLOW_CORR_SIGN 1
set .SRC_REMOTE_WAIT 1
set .DST_REMOTE_WAIT 0
set .DIRECTION " from vault #"
jump 200 notEqual LINK_ID 0
set .DIRECTION " from core"
jump 200 always 0 0
op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
set .SRC .CONTAINER
set .DST .CORE
sensor :src_capacity .CONTAINER @itemCapacity
sensor :dst_capacity .CORE @itemCapacity
op sub *tmp85 100 .EFF_LOCAL_LIMIT
op mul *tmp86 :src_capacity *tmp85
op idiv .LOAD_LEVEL *tmp86 100
op mul *tmp88 :dst_capacity .EFF_REMOTE_LIMIT
op idiv *tmp89 *tmp88 100
op equal *tmp90 LINK_ID 0
op mul *tmp91 *tmp90 .UNIT_CAPACITY
op add .DROP_LEVEL *tmp89 *tmp91
set .LOCAL_MARGIN .LOAD_LEVEL
set .REMOTE_MARGIN .DROP_LEVEL
op mul .HIGH_LEVEL_TRIGGER :src_capacity 0.9
set .LOW_LEVEL_TRIGGER 0
set .FLOW_CORR_SIGN -1
set .SRC_REMOTE_WAIT 0
set .DST_REMOTE_WAIT 1
set .DIRECTION " to vault #"
jump 200 notEqual LINK_ID 0
set .DIRECTION " to core"
set *tmp97 LINK_ID
jump 203 notEqual LINK_ID 0
set *tmp97 ""
op sub *tmp98 :src_capacity .LOAD_LEVEL
op min .LOAD_PACK .UNIT_CAPACITY *tmp98
op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL
sensor .SRC_X .SRC @x
sensor .SRC_Y .SRC @y
sensor .DST_X .DST @x
sensor .DST_Y .DST @y
op sub *tmp105 .DST_X .SRC_X
op sub *tmp106 .DST_Y .SRC_Y
op len *tmp107 *tmp105 *tmp106
op sub .DISTANCE *tmp107 14
op max *tmp110 .DISTANCE 10
op mul *tmp111 2 *tmp110
op div .TRAVEL_TIME *tmp111 .SPEED
op add .PARK_X .CORE_X -15
sensor *tmp113 .CONTAINER @x
jump 221 greaterThanEq *tmp113 .CORE_X
op add .PARK_X .CORE_X 15
op add .PARK_Y .CORE_Y -15
sensor *tmp117 .CONTAINER @y
jump 225 greaterThanEq *tmp117 .CORE_Y
op add .PARK_Y .CORE_Y 15
op equal *tmp121 LINK_ID 0
op mul .PARK_ITEM_LIMIT *tmp121 .UNIT_CAPACITY
set .TRANSFER_START @tick
op sub .LOOP_START @tick 60
set .LAST_ITEM @mono
op add .MESSAGE_TIMEOUT @tick 600
set .WAIT_LIMIT 30000
set :items_in_transit 0
set :items_per_min_unit "--"
set :items_per_min "-- "
set :turnaround_str "--"
set :elapsed_str "--"
set :wait_time_str 0
set :wait_time 0
set :transfers 0
set :transferred 0
set :total_flow_2 0
set :total_flow_1 0
set :remote_wait_time 0
set :min_level 0
set :max_level 0
set :loop_time_ms 0
set :last_level 0
jump 254 equal AUTO_ALLOCATION false
set .CORR_SIGN "[]([green]+"
set :corr_per_min 0
set .SPEED_UNIT_TXT "[])/min"
set .AUTO_ALLOCATION_TXT "\n=== [gold]Gathering statistics[] ==="
jump 258 always 0 0
set .CORR_SIGN "[]"
set :corr_per_min ""
set .SPEED_UNIT_TXT "/min"
set .AUTO_ALLOCATION_TXT ""
ubind UNIT
jump 266 notEqual @unit null
print "No unit of type "
print UNIT
print " found."
printflush message1
ubind UNIT
jump 260 equal @unit null
sensor *tmp128 switch1 @enabled
jump 277 equal *tmp128 false
control enabled switch1 false 0 0 0
set .EFF_AUTO_ALLOCATION false
set .AUTO_ALLOCATION_TXT ""
op add *tmp131 .TARGET 1
op min .TARGET *tmp131 MAX_UNITS
set .CORR_SIGN "[]"
set :corr_per_min ""
set .SPEED_UNIT_TXT "/min"
set .WAIT_LIMIT 30000
sensor *tmp133 switch2 @enabled
jump 299 equal *tmp133 false
control enabled switch2 false 0 0 0
jump 289 greaterThanEq .TARGET 1
set .EFF_AUTO_ALLOCATION true
set .TARGET 1
set .DEC_LIMIT 0
set .INC_LIMIT 0
set .CORR_SIGN "[]([green]+"
set :corr_per_min 0
set .SPEED_UNIT_TXT "[])/min"
jump 298 always 0 0
set .EFF_AUTO_ALLOCATION false
op sub *tmp138 .TARGET 1
op max .TARGET *tmp138 0
set .CORR_SIGN "[]"
set :corr_per_min ""
set .SPEED_UNIT_TXT "/min"
set .AUTO_ALLOCATION_TXT ""
jump 298 notEqual .TARGET 0
set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivated[] ==="
set .WAIT_LIMIT 30000
sensor *tmp142 :first_unit @dead
op equal :alive *tmp142 0
op equal *tmp144 @unit :first_unit
jump 581 greaterThan :alive *tmp144
jump 305 notEqual :active 0
print "\n[salmon]No active units.[]"
printflush message2
set .STATE_LIMIT 6
sensor .ITEM .SORTER @config
jump 372 equal .ITEM .LAST_ITEM
jump 314 notEqual .ITEM null
print "[salmon]No item type selected for transport.[]"
printflush message1
sensor .ITEM .SORTER @config
jump 310 equal .ITEM null
set .LAST_ITEM .ITEM
sensor *tmp156 .ITEM @id
jump 324 greaterThanEq *tmp156 3
jump 321 greaterThanEq *tmp156 1
jump 366 lessThan *tmp156 0
set *tmp155 "[]"
jump 367 always 0 0
jump 346 greaterThanEq *tmp156 2
set *tmp155 "[]"
jump 367 always 0 0
jump 366 greaterThanEq *tmp156 16
op add @counter *tmp156 323
jump 344 always 0 0
jump 352 always 0 0
jump 342 always 0 0
jump 364 always 0 0
jump 362 always 0 0
jump 354 always 0 0
jump 356 always 0 0
jump 350 always 0 0
jump 348 always 0 0
jump 360 always 0 0
jump 358 always 0 0
jump 340 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 "[]"
jump 367 always 0 0
set *tmp155 null
set .ITEM_ICON *tmp155
set .STATE_LIMIT 1
sensor :last_level .CONTAINER .ITEM
set :min_level 999999
set :max_level 0
sensor :container_items .CONTAINER .ITEM
op min :min_level :min_level :container_items
op max :max_level :max_level :container_items
op sub :loop_time @tick .LOOP_START
set .LOOP_START @tick
op mul *tmp164 :loop_time 100
op idiv :loop_time_ms *tmp164 6
jump 381 greaterThanEq :transfers :active
jump 501 lessThanEq :wait_time .WAIT_LIMIT
op div *tmp169 :wait_time 100
op ceil *tmp170 *tmp169 0
op div :wait_time_str *tmp170 10
op sub :elapsed_ticks @tick .TRANSFER_START
set .TRANSFER_START @tick
op div :elapsed_ms :elapsed_ticks 0.06
op idiv *tmp175 :elapsed_ms 100
op div :elapsed_str *tmp175 10
op div :items_per_ms :transferred :elapsed_ms
op idiv :items_per_min :items_per_ms 0.000016666666666666667
set :transferred 0
set :transfers 0
jump 454 equal .EFF_AUTO_ALLOCATION false
set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] ==="
op mul *tmp180 16.666666666666668 :loop_time
op add :turnaround_ms .TRAVEL_TIME *tmp180
op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION
op idiv *tmp183 :turnaround_ms 100
op div :turnaround_str *tmp183 10
op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms
op idiv :items_per_min_unit :items_per_ms_unit 0.000016666666666666667
op add *tmp188 :min_level :max_level
op div :this_level *tmp188 2
op sub *tmp190 :last_level :this_level
op mul :corr *tmp190 .FLOW_CORR_SIGN
op div :corr_per_ms :corr :elapsed_ms
set :last_level :this_level
op add :total_flow_per_ms :items_per_ms :corr_per_ms
op idiv :corr_per_min :corr_per_ms 0.000016666666666666667
set .CORR_SIGN "[]([green]"
jump 413 lessThan :corr_per_min 0
set .CORR_SIGN "[]([green]+"
set .SPEED_UNIT_TXT "[])/min"
jump 450 notEqual *tmp142 0
jump 418 greaterThanEq :min_level .LOW_LEVEL_TRIGGER
set *tmp201 true
jump 419 always 0 0
op greaterThan *tmp201 :max_level .HIGH_LEVEL_TRIGGER
jump 421 equal :wait_time 0
jump 441 lessThanEq *tmp201 :remote_wait_time
jump 428 equal STABILIZATION false
set :total_flow_3 :total_flow_2
set :total_flow_2 :total_flow_1
set :total_flow_1 :total_flow_per_ms
op add *tmp206 :total_flow_3 :total_flow_2
op add *tmp207 *tmp206 :total_flow_per_ms
op div :total_flow_per_ms *tmp207 3
op div *tmp209 :total_flow_per_ms :items_per_ms_unit
op add *tmp210 *tmp209 OVERALLOCATION_LOW
op ceil :new_target *tmp210 0
op mul :level_boost 2 *tmp201
op add *tmp213 :new_target :level_boost
op min :new_target *tmp213 MAX_UNITS
op sub *tmp215 :new_target :active
op max *tmp216 *tmp215 0
op min :new_change *tmp216 .INC_LIMIT
set .INC_LIMIT 6
op lessThanEq *tmp218 :new_change 0
op mul .DEC_LIMIT *tmp218 -1
jump 447 always 0 0
op idiv *tmp220 :wait_time .WAIT_LIMIT
op mul *tmp221 -1 *tmp220
op max :new_change *tmp221 .DEC_LIMIT
op greaterThanEq *tmp223 :new_change 0
op mul .INC_LIMIT *tmp223 6
set .DEC_LIMIT -1
op add *tmp225 :active :new_change
op max .TARGET *tmp225 1
jump 452 always 0 0
set .INC_LIMIT 0
set .DEC_LIMIT 0
set :min_level 999999
set :max_level 0
jump 497 lessThanEq .CONTAINERS 1
jump 497 notEqual .SRC .CORE
sensor *tmp230 .DST .ITEM
op sub :max_drop .DROP_LEVEL *tmp230
jump 497 greaterThanEq :max_drop .DROP_PACK
set :findAnotherContainer:min_level 999999
set .CONTAINERS 0
set :findAnotherContainer:n @links
jump 475 lessThanEq :findAnotherContainer:n 0
op sub :findAnotherContainer:n :findAnotherContainer:n 1
getlink :findAnotherContainer:block :findAnotherContainer:n
sensor *tmp240 :findAnotherContainer:block @type
jump 468 equal *tmp240 @vault
jump 474 notEqual *tmp240 @container
op add .CONTAINERS .CONTAINERS 1
sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM
jump 474 greaterThanEq :findAnotherContainer:level :findAnotherContainer:min_level
set :findAnotherContainer:min_level :findAnotherContainer:level
set .CONTAINER :findAnotherContainer:block
set .CONTAINER_INDEX :findAnotherContainer:n
jump 463 greaterThan :findAnotherContainer:n 0
jump 478 notEqual .CONTAINERS 0
set .CONTAINER @this
jump 496 always 0 0
set .DST .CONTAINER
sensor :findAnotherContainer:dst_capacity .CONTAINER @itemCapacity
op mul *tmp248 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
op idiv .DROP_LEVEL *tmp248 100
set .LOCAL_MARGIN .DROP_LEVEL
op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity 0.09999999999999998
set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
sensor .DST_X .CONTAINER @x
sensor .DST_Y .CONTAINER @y
op sub *tmp254 .DST_X .SRC_X
op sub *tmp255 .DST_Y .SRC_Y
op len *tmp256 *tmp254 *tmp255
op sub .DISTANCE *tmp256 14
op max *tmp259 .DISTANCE 10
op mul *tmp260 2 *tmp259
op div .TRAVEL_TIME *tmp260 .SPEED
set .MESSAGE "[salmon]Container filled up, switching...[]\n"
op add .MESSAGE_TIMEOUT @tick 600
set :last_level :findAnotherContainer:min_level
set :wait_time 0
set :remote_wait_time 0
jump 501 lessThan @tick .MESSAGE_TIMEOUT
set .MESSAGE ""
print .MESSAGE
print "Moving [green]"
print .ITEM
print "[]"
print .DIRECTION
print *tmp97
print .AUTO_ALLOCATION_TXT
jump 529 lessThanEq .TARGET 0
jump 519 lessThan :active .TARGET
print "\nUsing [green]"
print :active
print "/"
print .TARGET
print "[] units ("
print UNIT
print ") [gold]+"
print :items_in_transit
jump 527 always 0 0
print "\nUsing [salmon]"
print :active
print "/"
print .TARGET
print "[] units ("
print UNIT
print ") [gold]+"
print :items_in_transit
jump 529 lessThanEq .CHANGE 0
print "\n[][salmon]Cannot acquire additional units![]"
print "\n[]Local items: [gold]"
print :container_items
jump 535 greaterThanEq .EFF_LOCAL_LIMIT 100
print "[] (limit [orange]"
print .LOCAL_MARGIN
print "[])"
jump 543 equal .SHOW_REMOTE_LEVEL false
sensor :remote_level .CORE .ITEM
print "\n[]Remote items: [gold]"
print :remote_level
jump 543 greaterThanEq .EFF_REMOTE_LIMIT 100
print "[] (limit [orange]"
print .REMOTE_MARGIN
print "[])"
jump 564 lessThanEq .TARGET 0
print "\n[]Speed: [green]"
print :items_per_min
print .CORR_SIGN
print :corr_per_min
print .SPEED_UNIT_TXT
jump 558 equal .EFF_AUTO_ALLOCATION false
print "\nUnit throughput: [green]"
print :items_per_min_unit
print "[]/min\nMin/last round: [green]"
print :turnaround_str
print "[]/[green]"
print :elapsed_str
print "[] s"
jump 561 always 0 0
print "\nLast round: [green]"
print :elapsed_str
print "[] s"
print "\nTotal wait time: [green]"
print :wait_time_str
print "[] s"
print "\n[lightgray]Loop: "
print :loop_time_ms
print " ms"
printflush message1
op sub .CHANGE .TARGET :active
set :active 0
set :first_unit @unit
set :items_in_transit 0
print "Unit status:"
sensor *tmp282 .SRC @dead
jump 711 notEqual *tmp282 0
sensor *tmp285 .DST @dead
jump 711 notEqual *tmp285 0
sensor *tmp288 .SORTER @dead
jump 711 notEqual *tmp288 0
getlink *tmp291 .CONTAINER_INDEX
jump 711 notEqual .CONTAINER *tmp291
jump 586 lessThanEq .CHANGE 0
sensor *tmp296 @unit @controlled
jump 586 notEqual *tmp296 0
op sub .CHANGE .CHANGE 1
ucontrol flag 1 0 0 0 0
sensor *tmp299 @unit @controller
jump 258 notEqual *tmp299 @this
sensor :state @unit @flag
jump 258 equal :state .S_UNUSED
op max *tmp305 :state 1
op min :state *tmp305 .STATE_LIMIT
jump 598 greaterThanEq .CHANGE 0
jump 598 equal :state 6
sensor *tmp311 @unit @totalItems
jump 598 greaterThan *tmp311 .DISCARD_UNIT_MAX_ITEMS
op add .CHANGE .CHANGE 1
set :state 6
jump 614 notEqual :state 1
set :state 2
sensor *tmp316 @unit @totalItems
jump 614 equal *tmp316 0
set :state 4
sensor *tmp319 @unit @firstItem
jump 614 equal *tmp319 .ITEM
jump 612 equal .DROP_TO_CORE false
ucontrol approach .CORE_X .CORE_Y 6 0 0
ucontrol within .CORE_X .CORE_Y 8 *tmp323 0
jump 610 equal *tmp323 false
ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0
print "[]\nUnloading previous items: [green]"
jump 614 always 0 0
ucontrol itemDrop @air .UNIT_CAPACITY 0 0 0
set :state 2
jump 630 notEqual :state 2
ucontrol approach .SRC_X .SRC_Y 6 0 0
ucontrol within .SRC_X .SRC_Y 8 *tmp327 0
jump 620 equal *tmp327 false
set :state 3
jump 630 always 0 0
sensor *tmp330 @unit @x
op sub *tmp331 .SRC_X *tmp330
sensor *tmp332 @unit @y
op sub *tmp333 .SRC_Y *tmp332
op len *tmp334 *tmp331 *tmp333
op idiv *tmp335 *tmp334 .SPEED_SEC
op div *tmp336 *tmp335 10
print "[]\n[gold]"
print *tmp336
print " sec[] to source: [green]"
jump 644 notEqual :state 3
sensor *tmp339 .SRC .ITEM
op sub :max_load *tmp339 .LOAD_LEVEL
jump 635 lessThan :max_load .LOAD_PACK
ucontrol itemTake .SRC .ITEM :max_load 0 0
sensor *tmp343 @unit @totalItems
jump 639 lessThan *tmp343 .UNIT_CAPACITY
set :state 4
jump 644 always 0 0
print "[]\nWaiting at source: [green]"
ucontrol approach .SRC_X .SRC_Y 6 0 0
op add :wait_time :wait_time :loop_time_ms
op mul *tmp346 :loop_time_ms .SRC_REMOTE_WAIT
op add :remote_wait_time :remote_wait_time *tmp346
jump 663 notEqual :state 4
ucontrol approach .DST_X .DST_Y 6 0 0
ucontrol within .DST_X .DST_Y 8 *tmp349 0
jump 653 equal *tmp349 false
sensor *tmp351 @unit @totalItems
op add :transferred :transferred *tmp351
op add :transfers :transfers 1
set :state 5
jump 663 always 0 0
sensor *tmp353 @unit @x
op sub *tmp354 .DST_X *tmp353
sensor *tmp355 @unit @y
op sub *tmp356 .DST_Y *tmp355
op len *tmp357 *tmp354 *tmp356
op idiv *tmp358 *tmp357 .SPEED_SEC
op div *tmp359 *tmp358 10
print "[]\n[gold]"
print *tmp359
print " sec[] to destination: [green]"
jump 688 notEqual :state 5
sensor *tmp362 .DST .ITEM
op sub :max_drop .DROP_LEVEL *tmp362
jump 668 lessThan :max_drop .DROP_PACK
ucontrol itemDrop .DST :max_drop 0 0 0
sensor *tmp366 @unit @totalItems
jump 683 greaterThan *tmp366 0
set :state 2
ucontrol approach .SRC_X .SRC_Y 6 0 0
sensor *tmp370 @unit @x
op sub *tmp371 .SRC_X *tmp370
sensor *tmp372 @unit @y
op sub *tmp373 .SRC_Y *tmp372
op len *tmp374 *tmp371 *tmp373
op idiv *tmp375 *tmp374 .SPEED_SEC
op div *tmp376 *tmp375 10
print "[]\n[gold]"
print *tmp376
print " sec[] to source: [green]"
jump 688 always 0 0
print "[]\nWaiting at destination: [green]"
ucontrol approach .DST_X .DST_Y 6 0 0
op add :wait_time :wait_time :loop_time_ms
op mul *tmp377 :loop_time_ms .DST_REMOTE_WAIT
op add :remote_wait_time :remote_wait_time *tmp377
sensor :items @unit @totalItems
op add :items_in_transit :items_in_transit :items
jump 706 notEqual :state 6
print "[]\nParking: [green]"
jump 702 lessThanEq :items 0
jump 700 equal .DROP_TO_CORE false
ucontrol approach .CORE_X .CORE_Y 6 0 0
ucontrol within .CORE_X .CORE_Y 8 *tmp384 0
jump 702 equal *tmp384 false
ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0
sensor :items @unit @totalItems
jump 702 always 0 0
ucontrol itemDrop @air .UNIT_CAPACITY 0 0 0
sensor :items @unit @totalItems
jump 707 greaterThan :items .PARK_ITEM_LIMIT
ucontrol move .PARK_X .PARK_Y 0 0 0
set :state .S_UNUSED
jump 707 always 0 0
op add :active :active 1
print :items
print .ITEM_ICON
ucontrol flag :state 0 0 0 0
jump 258 always 0 0
control enabled switch1 false 0 0 0
control enabled switch2 false 0 0 0

