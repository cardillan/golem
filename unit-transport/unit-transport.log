  1242 instructions before optimizations.
   110 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
     3 instructions eliminated by Case Expression Optimization.
   141 instructions eliminated by Dead Code Elimination (7 iterations).
     5 instructions eliminated by Jump Normalization (6 iterations).
    62 instructions eliminated by Jump Optimization (6 iterations).
    59 instructions eliminated by Single Step Elimination (4 passes, 10 iterations).
     2 instructions eliminated by Expression Optimization (3 passes, 4 iterations).
     9 instructions eliminated by If Expression Optimization (2 passes, 4 iterations).
    29 instructions eliminated by Data Flow Optimization (4 passes, 17 iterations).
     1 loops improved by Loop Hoisting.
    11 instructions added by Loop Optimization (4 iterations).
    11 loops improved by Loop Optimization.
     2 instructions added by Case Switching (9 iterations).
     1 case expressions converted to switched jumps Case Switching.
    22 instructions eliminated by Jump Straightening (2 passes, 6 iterations).
     8 instructions updated by Jump Threading.
    21 instructions eliminated by Unreachable Code Elimination (2 iterations).
    56 instructions eliminated by Print Merging.
   736 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 184):
  * Replicate loop condition at line 156:9                       size    +1, benefit      312.5, efficiency    312.500 (+1 instructions)
    Replicate loop condition at line 160:9                       size    +4, benefit      312.5, efficiency     78.125
    Replicate loop condition at line 169:13                      size    +5, benefit      156.3, efficiency     31.250
    Replicate loop condition at line 189:1                       size    +3, benefit       25.0, efficiency      8.333
    Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
    Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 183):
  * Replicate loop condition at line 160:9                       size    +4, benefit      312.5, efficiency     78.125 (+4 instructions)
    Replicate loop condition at line 169:13                      size    +5, benefit      156.3, efficiency     31.250
    Replicate loop condition at line 189:1                       size    +3, benefit       25.0, efficiency      8.333
    Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
    Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 179):
  * Replicate loop condition at line 169:13                      size    +5, benefit      156.3, efficiency     31.250 (+5 instructions)
    Replicate loop condition at line 189:1                       size    +3, benefit       25.0, efficiency      8.333
    Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
    Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 174):
  * Replicate loop condition at line 189:1                       size    +3, benefit       25.0, efficiency      8.333 (+3 instructions)
  o Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
  o Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 171):
  o Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
  * Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844 (+2 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-3 instructions):
 
   114 getlink *tmp27 :n
   115 set :block *tmp27
   116 sensor *tmp29 :block @type
-    * set *tmp30 *tmp29
-    * jump *label30 equal *tmp30 @vault
-    * jump *label30 equal *tmp30 @container
+  117 jump *label30 equal *tmp29 @vault
+  118 jump *label30 equal *tmp29 @container
   119 jump *label29 always
   120 label *label30
   121 set .CONTAINER :block
 
   554 set .LAST_ITEM .ITEM
   555 set :itemTypeToIcon:itemType .ITEM
   556 sensor *tmp160 :itemTypeToIcon:itemType @id
-    * set *tmp161 *tmp160
-    * jump *label103 equal *tmp161 14
+  557 jump *label103 equal *tmp160 14
   558 jump *label102 always
   559 label *label103
   560 set *tmp159 "[]"
   561 jump *label101 always
   562 label *label102
-    * jump *label105 equal *tmp161 5
+  563 jump *label105 equal *tmp160 5
   564 jump *label104 always
   565 label *label105
   566 set *tmp159 "[]"
   567 jump *label101 always
   568 label *label104
-    * jump *label107 equal *tmp161 0
+  569 jump *label107 equal *tmp160 0
   570 jump *label106 always
   571 label *label107
   572 set *tmp159 "[]"
   573 jump *label101 always
   574 label *label106
-    * jump *label109 equal *tmp161 3
+  575 jump *label109 equal *tmp160 3
   576 jump *label108 always
   577 label *label109
   578 set *tmp159 "[]"
   579 jump *label101 always
   580 label *label108
-    * jump *label111 equal *tmp161 1
+  581 jump *label111 equal *tmp160 1
   582 jump *label110 always
   583 label *label111
   584 set *tmp159 "[]"
   585 jump *label101 always
   586 label *label110
-    * jump *label113 equal *tmp161 2
+  587 jump *label113 equal *tmp160 2
   588 jump *label112 always
   589 label *label113
   590 set *tmp159 "[]"
   591 jump *label101 always
   592 label *label112
-    * jump *label115 equal *tmp161 11
+  593 jump *label115 equal *tmp160 11
   594 jump *label114 always
   595 label *label115
   596 set *tmp159 "[]"
   597 jump *label101 always
   598 label *label114
-    * jump *label117 equal *tmp161 10
+  599 jump *label117 equal *tmp160 10
   600 jump *label116 always
   601 label *label117
   602 set *tmp159 "[]"
   603 jump *label101 always
   604 label *label116
-    * jump *label119 equal *tmp161 15
+  605 jump *label119 equal *tmp160 15
   606 jump *label118 always
   607 label *label119
   608 set *tmp159 "[]"
   609 jump *label101 always
   610 label *label118
-    * jump *label121 equal *tmp161 4
+  611 jump *label121 equal *tmp160 4
   612 jump *label120 always
   613 label *label121
   614 set *tmp159 "[]"
   615 jump *label101 always
   616 label *label120
-    * jump *label123 equal *tmp161 8
+  617 jump *label123 equal *tmp160 8
   618 jump *label122 always
   619 label *label123
   620 set *tmp159 "[]"
   621 jump *label101 always
   622 label *label122
-    * jump *label125 equal *tmp161 9
+  623 jump *label125 equal *tmp160 9
   624 jump *label124 always
   625 label *label125
   626 set *tmp159 "[]"
   627 jump *label101 always
   628 label *label124
-    * jump *label127 equal *tmp161 13
+  629 jump *label127 equal *tmp160 13
   630 jump *label126 always
   631 label *label127
   632 set *tmp159 "[]"
   633 jump *label101 always
   634 label *label126
-    * jump *label129 equal *tmp161 12
+  635 jump *label129 equal *tmp160 12
   636 jump *label128 always
   637 label *label129
   638 set *tmp159 "[]"
   639 jump *label101 always
   640 label *label128
-    * jump *label131 equal *tmp161 7
+  641 jump *label131 equal *tmp160 7
   642 jump *label130 always
   643 label *label131
   644 set *tmp159 "[]"
   645 jump *label101 always
   646 label *label130
-    * jump *label133 equal *tmp161 6
+  647 jump *label133 equal *tmp160 6
   648 jump *label132 always
   649 label *label133
   650 set *tmp159 "[]"
 
   829 getlink *tmp245 :findAnotherContainer:n
   830 set :findAnotherContainer:block *tmp245
   831 sensor *tmp247 :findAnotherContainer:block @type
-    * set *tmp248 *tmp247
-    * jump *label156 equal *tmp248 @vault
-    * jump *label156 equal *tmp248 @container
+  832 jump *label156 equal *tmp247 @vault
+  833 jump *label156 equal *tmp247 @container
   834 jump *label155 always
   835 label *label156
   836 op add .CONTAINERS .CONTAINERS 1

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-90 instructions):
 
    80 op lessThan *tmp17 :state 6
    81 op land *tmp18 *tmp16 *tmp17
    82 op add .TARGET .TARGET *tmp18
-    * set *tmp14 .TARGET
    83 jump *label21 always
    84 label *label20
-    * set *tmp14 null
    85 label *label21
    86 ubind UNIT
    87 label *label18
 
   119 set .CONTAINER :block
   120 op add .CONTAINERS .CONTAINERS 1
   121 set .CONTAINER_INDEX :n
-    * set *tmp28 .CONTAINER_INDEX
   122 jump *label28 always
   123 label *label29
-    * set *tmp28 null
   124 label *label28
   125 label *label26
   126 jump *label25 always
 
   129 jump *label31 equal *tmp31 false
   130 print "[salmon]No vault or container."
   131 printflush message1
-    * set *tmp32 null
   132 jump *label32 always
   133 label *label31
   134 jump *label24 always
-    * set *tmp32 null
   135 label *label32
   136 label *label23
   137 jump *label22 always
 
   151 ulocate building core false @copper .CORE_X .CORE_Y *tmp40 *tmp39
   152 set .CORE *tmp39
   153 ucontrol flag .S_UNUSED
-    * set *tmp38 null
   154 jump *label39 always
   155 label *label38
-    * set *tmp38 null
   156 label *label39
   157 label *label36
   158 jump *label35 always
 
   160 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   161 op equal *tmp41 DROP_TO_AIR false
   162 set .DROP_TO_CORE *tmp41
-    * set *tmp34 .DROP_TO_CORE
   163 jump *label34 always
   164 label *label33
   165 printflush message2
 
   233 label *label54
   234 set *tmp64 null
   235 label *label55
-    * set *tmp52 *tmp64
   236 jump *label50 always
   237 label *label49
-    * set *tmp52 null
   238 label *label50
   239 ucontrol flag .S_UNUSED
   240 label *label41
 
   248 label *label57
   249 set .DISCARD_UNIT_MAX_ITEMS *tmp65
   250 set .DROP_TO_CORE false
-    * set *tmp34 .DROP_TO_CORE
   251 label *label34
   252 set .SORTER sorter1
   253 sensor *tmp66 .SORTER @type
 
   263 jump *label61 equal *tmp70 false
   264 print "Block found: "
   265 print .SORTER
-    * set *tmp71 .SORTER
   266 jump *label62 always
   267 label *label61
-    * set *tmp71 null
   268 label *label62
   269 printflush message1
   270 set .SORTER sorter1
 
   306 set *tmp85 " from vault #"
   307 label *label66
   308 set .DIRECTION *tmp85
-    * set *tmp74 .DIRECTION
   309 jump *label64 always
   310 label *label63
   311 op greaterThan *tmp86 LINK_ID 0
 
   342 set *tmp99 " to vault #"
   343 label *label68
   344 set .DIRECTION *tmp99
-    * set *tmp74 .DIRECTION
   345 label *label64
   346 op equal *tmp100 LINK_ID 0
   347 jump *label69 equal *tmp100 false
 
   426 set :corr_per_min 0
   427 set .SPEED_UNIT_TXT "[])/min"
   428 set .AUTO_ALLOCATION_TXT "\n=== [gold]Gathering statistics[] ==="
-    * set *tmp130 .AUTO_ALLOCATION_TXT
   429 jump *label76 always
   430 label *label75
   431 set .CORR_SIGN "[]"
   432 set :corr_per_min ""
   433 set .SPEED_UNIT_TXT "/min"
   434 set .AUTO_ALLOCATION_TXT ""
-    * set *tmp130 .AUTO_ALLOCATION_TXT
   435 label *label76
   436 label *label77
   437 jump *label79 equal true false
 
   460 set :corr_per_min ""
   461 set .SPEED_UNIT_TXT "/min"
   462 set .WAIT_LIMIT 30000
-    * set *tmp133 .WAIT_LIMIT
   463 jump *label84 always
   464 label *label83
-    * set *tmp133 null
   465 label *label84
   466 sensor *tmp137 switch2 @enabled
   467 jump *label85 equal *tmp137 false
 
   475 set .CORR_SIGN "[]([green]+"
   476 set :corr_per_min 0
   477 set .SPEED_UNIT_TXT "[])/min"
-    * set *tmp141 .SPEED_UNIT_TXT
   478 jump *label88 always
   479 label *label87
   480 set .EFF_AUTO_ALLOCATION false
 
   492 set *tmp145 ""
   493 label *label90
   494 set .AUTO_ALLOCATION_TXT *tmp145
-    * set *tmp141 .AUTO_ALLOCATION_TXT
   495 label *label88
   496 set .WAIT_LIMIT 30000
-    * set *tmp138 .WAIT_LIMIT
   497 jump *label86 always
   498 label *label85
-    * set *tmp138 null
   499 label *label86
   500 sensor *tmp146 :first_unit @dead
   501 op equal *tmp147 *tmp146 0
 
   506 op equal *tmp151 :active 0
   507 jump *label93 equal *tmp151 false
   508 print "\n[salmon]No active units.[]"
-    * set *tmp152 "\n[salmon]No active units.[]"
   509 jump *label94 always
   510 label *label93
-    * set *tmp152 null
   511 label *label94
   512 printflush message2
   513 set .STATE_LIMIT 6
 
   634 set :last_level *tmp162
   635 set :min_level 999999
   636 set :max_level 0
-    * set *tmp155 :max_level
   637 jump *label96 always
   638 label *label95
-    * set *tmp155 null
   639 label *label96
   640 sensor *tmp163 .CONTAINER .ITEM
   641 set :container_items *tmp163
 
   728 op add *tmp213 *tmp212 :total_flow_1
   729 op div *tmp214 *tmp213 3
   730 set :total_flow_per_ms *tmp214
-    * set *tmp211 :total_flow_per_ms
   731 jump *label145 always
   732 label *label144
-    * set *tmp211 null
   733 label *label145
   734 op div *tmp215 :total_flow_per_ms :items_per_ms_unit
   735 op add *tmp216 *tmp215 .INC_OVERALLOCATION
 
   748 op lessThanEq *tmp224 :new_change 0
   749 op mul *tmp225 *tmp224 .DEC_MAX
   750 set .DEC_LIMIT *tmp225
-    * set *tmp210 .DEC_LIMIT
   751 jump *label143 always
   752 label *label142
   753 op idiv *tmp226 :wait_time .WAIT_LIMIT
 
   758 op mul *tmp230 *tmp229 .INC_MAX
   759 set .INC_LIMIT *tmp230
   760 set .DEC_LIMIT .DEC_MAX
-    * set *tmp210 .DEC_LIMIT
   761 label *label143
   762 op add *tmp231 :active :new_change
   763 op max *tmp232 *tmp231 1
   764 set .TARGET *tmp232
-    * set *tmp203 .TARGET
   765 jump *label141 always
   766 label *label140
   767 set .INC_LIMIT 0
   768 set .DEC_LIMIT 0
-    * set *tmp203 .DEC_LIMIT
   769 label *label141
   770 set :min_level 999999
   771 set :max_level 0
-    * set *tmp184 :max_level
   772 jump *label137 always
   773 label *label136
-    * set *tmp184 null
   774 label *label137
   775 op greaterThan *tmp233 .CONTAINERS 1
   776 op equal *tmp234 .SRC .CORE
 
   810 label *label157
   811 set *tmp251 null
   812 label *label158
-    * set *tmp246 *tmp251
   813 jump *label154 always
   814 label *label155
-    * set *tmp246 null
   815 label *label154
   816 label *label152
   817 jump *label151 always
 
   819 op equal *tmp252 .CONTAINERS 0
   820 jump *label159 equal *tmp252 false
   821 set .CONTAINER @this
-    * set *tmp253 .CONTAINER
   822 jump *label160 always
   823 label *label159
   824 set .DST .CONTAINER
 
   849 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   850 op add *tmp269 @tick 600
   851 set .MESSAGE_TIMEOUT *tmp269
-    * set *tmp253 .MESSAGE_TIMEOUT
   852 label *label160
   853 set *tmp241 :findAnotherContainer:min_level
   854 jump *label150 always
 
   861 label *label148
   862 set *tmp240 null
   863 label *label149
-    * set *tmp236 *tmp240
   864 jump *label147 always
   865 label *label146
-    * set *tmp236 null
   866 label *label147
   867 set :wait_time 0
   868 set :remote_wait_time 0
 
   874 label *label161
   875 set *tmp271 null
   876 label *label162
-    * set *tmp173 *tmp271
   877 jump *label135 always
   878 label *label134
-    * set *tmp173 null
   879 label *label135
   880 print .MESSAGE
   881 print "Moving [green]"
 
   900 print ")"
   901 print " [gold]+"
   902 print :items_in_transit
-    * set *tmp275 null
   903 jump *label166 always
   904 label *label165
   905 print "\n"
 
   913 print ")"
   914 print " [gold]+"
   915 print :items_in_transit
-    * set *tmp275 null
   916 label *label166
   917 op greaterThan *tmp276 .CHANGE 0
   918 jump *label167 equal *tmp276 false
 
   922 label *label167
   923 set *tmp277 null
   924 label *label168
-    * set *tmp273 *tmp277
   925 jump *label164 always
   926 label *label163
-    * set *tmp273 null
   927 label *label164
   928 print "\n"
   929 print "[]Local items: [gold]"
 
   934 print .LOCAL_MARGIN
   935 print "["
   936 print "])"
-    * set *tmp279 null
   937 jump *label170 always
   938 label *label169
-    * set *tmp279 null
   939 label *label170
   940 jump *label171 equal .SHOW_REMOTE_LEVEL false
   941 sensor *tmp281 .CORE .ITEM
 
   954 label *label173
   955 set *tmp283 null
   956 label *label174
-    * set *tmp280 *tmp283
   957 jump *label172 always
   958 label *label171
-    * set *tmp280 null
   959 label *label172
   960 op greaterThan *tmp284 .TARGET 0
   961 jump *label175 equal *tmp284 false
 
   979 print :elapsed_str
   980 print "["
   981 print "] s"
-    * set *tmp286 null
   982 jump *label178 always
   983 label *label177
   984 print "\n"
 
   986 print :elapsed_str
   987 print "["
   988 print "] s"
-    * set *tmp286 null
   989 label *label178
   990 print "\n"
   991 print "Total wait time: [green]"
   992 print :wait_time_str
   993 print "["
   994 print "] s"
-    * set *tmp285 null
   995 jump *label176 always
   996 label *label175
-    * set *tmp285 null
   997 label *label176
   998 print "\n"
   999 print "[lightgray]Loop: "
 
  1012 op notEqual *tmp290 *tmp289 0
  1013 jump *label179 equal *tmp290 false
  1014 jump *label79 always
-    * set *tmp291 null
  1015 jump *label180 always
  1016 label *label179
-    * set *tmp291 null
  1017 label *label180
  1018 sensor *tmp292 .DST @dead
  1019 op notEqual *tmp293 *tmp292 0
  1020 jump *label181 equal *tmp293 false
  1021 jump *label79 always
-    * set *tmp294 null
  1022 jump *label182 always
  1023 label *label181
-    * set *tmp294 null
  1024 label *label182
  1025 sensor *tmp295 .SORTER @dead
  1026 op notEqual *tmp296 *tmp295 0
  1027 jump *label183 equal *tmp296 false
  1028 jump *label79 always
-    * set *tmp297 null
  1029 jump *label184 always
  1030 label *label183
-    * set *tmp297 null
  1031 label *label184
  1032 getlink *tmp298 .CONTAINER_INDEX
  1033 op notEqual *tmp299 .CONTAINER *tmp298
 
  1038 label *label185
  1039 set *tmp300 null
  1040 label *label186
-    * set *tmp150 *tmp300
  1041 jump *label92 always
  1042 label *label91
-    * set *tmp150 null
  1043 label *label92
  1044 op greaterThan *tmp301 .CHANGE 0
  1045 jump *label187 equal *tmp301 false
 
  1053 label *label189
  1054 set *tmp305 null
  1055 label *label190
-    * set *tmp302 *tmp305
  1056 jump *label188 always
  1057 label *label187
-    * set *tmp302 null
  1058 label *label188
  1059 sensor *tmp306 @unit @controller
  1060 op equal *tmp307 *tmp306 @this
 
  1085 label *label197
  1086 set *tmp317 null
  1087 label *label198
-    * set *tmp315 *tmp317
  1088 jump *label196 always
  1089 label *label195
-    * set *tmp315 null
  1090 label *label196
  1091 op equal *tmp321 :state 1
  1092 jump *label201 equal *tmp321 false
 
  1109 ucontrol within .CORE_X .CORE_Y 8 *tmp330
  1110 jump *label209 equal *tmp330 false
  1111 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp331 null
  1112 jump *label210 always
  1113 label *label209
-    * set *tmp331 null
  1114 label *label210
  1115 print "[]"
  1116 print "\n"
 
  1126 label *label206
  1127 set *tmp325 *tmp328
  1128 label *label204
-    * set *tmp322 *tmp325
  1129 jump *label202 always
  1130 label *label201
-    * set *tmp322 null
  1131 label *label202
  1132 op equal *tmp332 :state 2
  1133 jump *label211 equal *tmp332 false
 
  1173 label *label215
  1174 set *tmp335 *tmp336
  1175 label *label214
-    * set *tmp333 *tmp335
  1176 jump *label212 always
  1177 label *label211
-    * set *tmp333 null
  1178 label *label212
  1179 op equal *tmp345 :state 3
  1180 jump *label218 equal *tmp345 false
 
  1184 op greaterThanEq *tmp349 :max_load .LOAD_PACK
  1185 jump *label220 equal *tmp349 false
  1186 ucontrol itemTake .SRC .ITEM :max_load
-    * set *tmp350 null
  1187 jump *label221 always
  1188 label *label220
-    * set *tmp350 null
  1189 label *label221
  1190 sensor *tmp351 @unit @totalItems
  1191 op greaterThanEq *tmp352 *tmp351 .UNIT_CAPACITY
 
  1203 op add :remote_wait_time :remote_wait_time *tmp354
  1204 set *tmp353 :remote_wait_time
  1205 label *label223
-    * set *tmp346 *tmp353
  1206 jump *label219 always
  1207 label *label218
-    * set *tmp346 null
  1208 label *label219
  1209 op equal *tmp355 :state 4
  1210 jump *label224 equal *tmp355 false
 
  1253 label *label228
  1254 set *tmp358 *tmp360
  1255 label *label227
-    * set *tmp356 *tmp358
  1256 jump *label225 always
  1257 label *label224
-    * set *tmp356 null
  1258 label *label225
  1259 op equal *tmp369 :state 5
  1260 jump *label231 equal *tmp369 false
 
  1264 op greaterThanEq *tmp373 :max_drop .DROP_PACK
  1265 jump *label233 equal *tmp373 false
  1266 ucontrol itemDrop .DST :max_drop
-    * set *tmp374 null
  1267 jump *label234 always
  1268 label *label233
-    * set *tmp374 null
  1269 label *label234
  1270 sensor *tmp375 @unit @totalItems
  1271 op lessThanEq *tmp376 *tmp375 0
 
  1317 op add :remote_wait_time :remote_wait_time *tmp387
  1318 set *tmp377 :remote_wait_time
  1319 label *label236
-    * set *tmp370 *tmp377
  1320 jump *label232 always
  1321 label *label231
-    * set *tmp370 null
  1322 label *label232
  1323 sensor *tmp388 @unit @totalItems
  1324 set :items *tmp388
 
  1350 set :items *tmp397
  1351 set *tmp393 :items
  1352 label *label245
-    * set *tmp392 *tmp393
  1353 jump *label243 always
  1354 label *label242
-    * set *tmp392 null
  1355 label *label243
  1356 op lessThanEq *tmp398 :items .PARK_ITEM_LIMIT
  1357 jump *label248 equal *tmp398 false
 
  1362 label *label248
  1363 set *tmp399 null
  1364 label *label249
-    * set *tmp390 *tmp399
  1365 jump *label241 always
  1366 label *label240
  1367 op add :active :active 1
-    * set *tmp390 :active
  1368 label *label241
  1369 print :items
  1370 print .ITEM_ICON
 
  1374 label *label193
  1375 set *tmp311 null
  1376 label *label194
-    * set *tmp308 *tmp311
  1377 jump *label192 always
  1378 label *label191
-    * set *tmp308 null
  1379 label *label192
  1380 label *label78
  1381 jump *label77 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-34 instructions):
 
   228 print "is not a vault!"
   229 printflush message2
   230 set .CORE null
-    * set *tmp64 .CORE
   231 jump *label55 always
   232 label *label54
-    * set *tmp64 null
   233 label *label55
   234 jump *label50 always
   235 label *label49
 
   803 set :findAnotherContainer:min_level :findAnotherContainer:level
   804 set .CONTAINER :findAnotherContainer:block
   805 set .CONTAINER_INDEX :findAnotherContainer:n
-    * set *tmp251 .CONTAINER_INDEX
   806 jump *label158 always
   807 label *label157
-    * set *tmp251 null
   808 label *label158
   809 jump *label154 always
   810 label *label155
 
   852 label *label150
   853 set :this_level *tmp241
   854 set :last_level :this_level
-    * set *tmp240 :last_level
   855 jump *label149 always
   856 label *label148
-    * set *tmp240 null
   857 label *label149
   858 jump *label147 always
   859 label *label146
 
   863 op greaterThanEq *tmp270 @tick .MESSAGE_TIMEOUT
   864 jump *label161 equal *tmp270 false
   865 set .MESSAGE ""
-    * set *tmp271 .MESSAGE
   866 jump *label162 always
   867 label *label161
-    * set *tmp271 null
   868 label *label162
   869 jump *label135 always
   870 label *label134
 
   909 op greaterThan *tmp276 .CHANGE 0
   910 jump *label167 equal *tmp276 false
   911 print "\n[][salmon]Cannot acquire additional units![]"
-    * set *tmp277 "\n[][salmon]Cannot acquire additional units![]"
   912 jump *label168 always
   913 label *label167
-    * set *tmp277 null
   914 label *label168
   915 jump *label164 always
   916 label *label163
 
   939 print .REMOTE_MARGIN
   940 print "["
   941 print "])"
-    * set *tmp283 null
   942 jump *label174 always
   943 label *label173
-    * set *tmp283 null
   944 label *label174
   945 jump *label172 always
   946 label *label171
 
  1021 op notEqual *tmp299 .CONTAINER *tmp298
  1022 jump *label185 equal *tmp299 false
  1023 jump *label79 always
-    * set *tmp300 null
  1024 jump *label186 always
  1025 label *label185
-    * set *tmp300 null
  1026 label *label186
  1027 jump *label92 always
  1028 label *label91
 
  1034 jump *label189 equal *tmp304 false
  1035 op sub .CHANGE .CHANGE 1
  1036 ucontrol flag 1
-    * set *tmp305 null
  1037 jump *label190 always
  1038 label *label189
-    * set *tmp305 null
  1039 label *label190
  1040 jump *label188 always
  1041 label *label187
 
  1064 label *label199
  1065 set *tmp320 null
  1066 label *label200
-    * set *tmp317 *tmp320
  1067 jump *label198 always
  1068 label *label197
-    * set *tmp317 null
  1069 label *label198
  1070 jump *label196 always
  1071 label *label195
 
  1076 op equal *tmp324 *tmp323 0
  1077 jump *label203 equal *tmp324 false
  1078 set :state 2
-    * set *tmp325 :state
  1079 jump *label204 always
  1080 label *label203
  1081 sensor *tmp326 @unit @firstItem
 
  1105 label *label208
  1106 set *tmp328 *tmp329
  1107 label *label206
-    * set *tmp325 *tmp328
  1108 label *label204
  1109 jump *label202 always
  1110 label *label201
 
  1115 ucontrol within .SRC_X .SRC_Y 8 *tmp334
  1116 jump *label213 equal *tmp334 false
  1117 set :state 3
-    * set *tmp335 :state
  1118 jump *label214 always
  1119 label *label213
  1120 set :printUnitInfo:name "source"
 
  1150 label *label217
  1151 set *tmp336 *tmp337
  1152 label *label215
-    * set *tmp335 *tmp336
  1153 label *label214
  1154 jump *label212 always
  1155 label *label211
 
  1169 op greaterThanEq *tmp352 *tmp351 .UNIT_CAPACITY
  1170 jump *label222 equal *tmp352 false
  1171 set :state 4
-    * set *tmp353 :state
  1172 jump *label223 always
  1173 label *label222
  1174 print "[]"
 
  1178 op add :wait_time :wait_time :loop_time_ms
  1179 op mul *tmp354 :loop_time_ms .SRC_REMOTE_WAIT
  1180 op add :remote_wait_time :remote_wait_time *tmp354
-    * set *tmp353 :remote_wait_time
  1181 label *label223
  1182 jump *label219 always
  1183 label *label218
 
  1191 op add :transferred :transferred *tmp359
  1192 op add :transfers :transfers 1
  1193 set :state 5
-    * set *tmp358 :state
  1194 jump *label227 always
  1195 label *label226
  1196 set :printUnitInfo.1:name "destination"
 
  1226 label *label230
  1227 set *tmp360 *tmp361
  1228 label *label228
-    * set *tmp358 *tmp360
  1229 label *label227
  1230 jump *label225 always
  1231 label *label224
 
  1279 label *label239
  1280 set *tmp378 *tmp379
  1281 label *label237
-    * set *tmp377 *tmp378
  1282 jump *label236 always
  1283 label *label235
  1284 print "[]"
 
  1288 op add :wait_time :wait_time :loop_time_ms
  1289 op mul *tmp387 :loop_time_ms .DST_REMOTE_WAIT
  1290 op add :remote_wait_time :remote_wait_time *tmp387
-    * set *tmp377 :remote_wait_time
  1291 label *label236
  1292 jump *label232 always
  1293 label *label231
 
  1314 label *label246
  1315 set *tmp395 null
  1316 label *label247
-    * set *tmp393 *tmp395
  1317 jump *label245 always
  1318 label *label244
  1319 ucontrol itemDrop @air .UNIT_CAPACITY
  1320 sensor *tmp397 @unit @totalItems
  1321 set :items *tmp397
-    * set *tmp393 :items
  1322 label *label245
  1323 jump *label243 always
  1324 label *label242
 
  1327 jump *label248 equal *tmp398 false
  1328 ucontrol move .PARK_X .PARK_Y
  1329 set :state .S_UNUSED
-    * set *tmp399 :state
  1330 jump *label249 always
  1331 label *label248
-    * set *tmp399 null
  1332 label *label249
  1333 jump *label241 always
  1334 label *label240
 
  1337 print :items
  1338 print .ITEM_ICON
  1339 ucontrol flag :state
-    * set *tmp311 null
  1340 jump *label194 always
  1341 label *label193
-    * set *tmp311 null
  1342 label *label194
  1343 jump *label192 always
  1344 label *label191

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-9 instructions):
 
  1059 jump *label199 equal *tmp319 false
  1060 op add .CHANGE .CHANGE 1
  1061 set :state 6
-    * set *tmp320 :state
  1062 jump *label200 always
  1063 label *label199
-    * set *tmp320 null
  1064 label *label200
  1065 jump *label198 always
  1066 label *label197
 
  1080 op equal *tmp327 *tmp326 .ITEM
  1081 jump *label205 equal *tmp327 false
  1082 set :state 4
-    * set *tmp328 :state
  1083 jump *label206 always
  1084 label *label205
  1085 jump *label207 equal .DROP_TO_CORE false
 
  1100 set :state 2
  1101 set *tmp329 :state
  1102 label *label208
-    * set *tmp328 *tmp329
  1103 label *label206
  1104 label *label204
  1105 jump *label202 always
 
  1144 print " [green]"
  1145 set *tmp337 null
  1146 label *label217
-    * set *tmp336 *tmp337
  1147 label *label215
  1148 label *label214
  1149 jump *label212 always
 
  1219 print " [green]"
  1220 set *tmp361 null
  1221 label *label230
-    * set *tmp360 *tmp361
  1222 label *label228
  1223 label *label227
  1224 jump *label225 always
 
  1271 print " [green]"
  1272 set *tmp379 null
  1273 label *label239
-    * set *tmp378 *tmp379
  1274 label *label237
  1275 jump *label236 always
  1276 label *label235
 
  1302 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1303 sensor *tmp396 @unit @totalItems
  1304 set :items *tmp396
-    * set *tmp395 :items
  1305 jump *label247 always
  1306 label *label246
-    * set *tmp395 null
  1307 label *label247
  1308 jump *label245 always
  1309 label *label244

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
  1093 print "[]"
  1094 print "\n"
  1095 print "Unloading previous items: [green]"
-    * set *tmp329 null
  1096 jump *label208 always
  1097 label *label207
  1098 ucontrol itemDrop @air .UNIT_CAPACITY
  1099 set :state 2
-    * set *tmp329 :state
  1100 label *label208
  1101 label *label206
  1102 label *label204
 
  1131 print :printUnitInfo:name
  1132 print ":"
  1133 print " [green]"
-    * set *tmp337 null
  1134 jump *label217 always
  1135 label *label216
  1136 print "[]"
 
  1139 print :printUnitInfo:name
  1140 print ":"
  1141 print " [green]"
-    * set *tmp337 null
  1142 label *label217
  1143 label *label215
  1144 label *label214
 
  1204 print :printUnitInfo.1:name
  1205 print ":"
  1206 print " [green]"
-    * set *tmp361 null
  1207 jump *label230 always
  1208 label *label229
  1209 print "[]"
 
  1212 print :printUnitInfo.1:name
  1213 print ":"
  1214 print " [green]"
-    * set *tmp361 null
  1215 label *label230
  1216 label *label228
  1217 label *label227
 
  1254 print :printUnitInfo.2:name
  1255 print ":"
  1256 print " [green]"
-    * set *tmp379 null
  1257 jump *label239 always
  1258 label *label238
  1259 print "[]"
 
  1262 print :printUnitInfo.2:name
  1263 print ":"
  1264 print " [green]"
-    * set *tmp379 null
  1265 label *label239
  1266 label *label237
  1267 jump *label236 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-110 instructions):
 
    24 printflush null
    25 label *label13
    26 set .MESSAGE ""
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+   27 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+   28 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    29 set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION
    30 set .TRIGGER_LEVEL 0.9
-    * op mul *tmp2 -1 HOUSEKEEPING
-    * set .S_UNUSED *tmp2
+   31 op mul .S_UNUSED -1 HOUSEKEEPING
    32 set .STATE_LIMIT null
    33 set .ITEM_ICON .STATE_LIMIT
    34 set .ITEM .ITEM_ICON
 
    37 set .CONTAINER_INDEX .CORE_X
    38 set .LOOPS 1
    39 op mul *tmp3 .LOOPS 1000
-    * op div *tmp4 *tmp3 60
-    * set .LOOPS_TICKS_TO_MS *tmp4
+   40 op div .LOOPS_TICKS_TO_MS *tmp3 60
    41 set .INC_OVERALLOCATION OVERALLOCATION_LOW
-    * op add *tmp5 1 OVERALLOCATION_HIGH
-    * set .DEC_OVERALLOCATION *tmp5
+   42 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    43 set .TRIGGER_BOOST 2
    44 set .INC_MAX 6
    45 set .DEC_MAX -1
 
    56 label *label15
    57 jump *label14 always
    58 label *label16
-    * set *tmp7 @unit
-    * set :first_unit *tmp7
+   59 set :first_unit @unit
    60 sensor *tmp8 @unit @speed
-    * op div *tmp9 *tmp8 10
-    * set .SPEED_SEC *tmp9
+   61 op div .SPEED_SEC *tmp8 10
    62 sensor *tmp10 @unit @speed
-    * op div *tmp11 *tmp10 1000
-    * set .SPEED *tmp11
+   63 op div .SPEED *tmp10 1000
    64 set .TARGET 0
    65 label *label17
    66 sensor *tmp12 @unit @controller
    67 op equal *tmp13 *tmp12 @this
    68 jump *label20 equal *tmp13 false
-    * sensor *tmp15 @unit @flag
-    * set :state *tmp15
+   69 sensor :state @unit @flag
    70 op greaterThanEq *tmp16 :state 1
    71 op lessThan *tmp17 :state 6
    72 op land *tmp18 *tmp16 *tmp17
 
    86 set :active .TARGET
    87 set .DEC_LIMIT 0
    88 set .INC_LIMIT 0
-    * sensor *tmp23 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp23
+   89 sensor .UNIT_CAPACITY @unit @itemCapacity
    90 set :first_unit null
    91 label *label22
    92 jump *label24 equal true false
    93 set .CONTAINER null
    94 set .CONTAINERS 0
-    * set *tmp24 @links
-    * set :n *tmp24
+   95 set :n @links
    96 label *label25
    97 op greaterThan *tmp25 :n 0
    98 jump *label27 equal *tmp25 false
-    * op sub *tmp26 :n 1
-    * set :n *tmp26
-    * getlink *tmp27 :n
-    * set :block *tmp27
+   99 op sub :n :n 1
+  100 getlink :block :n
   101 sensor *tmp29 :block @type
   102 jump *label30 equal *tmp29 @vault
   103 jump *label30 equal *tmp29 @container
 
   135 sensor *tmp36 @unit @controlled
   136 op equal *tmp37 *tmp36 0
   137 jump *label38 equal *tmp37 false
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp40 *tmp39
-    * set .CORE *tmp39
+  138 ulocate building core false @copper .CORE_X .CORE_Y *tmp40 .CORE
   139 ucontrol flag .S_UNUSED
   140 jump *label39 always
   141 label *label38
 
   144 jump *label35 always
   145 label *label37
   146 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
-    * op equal *tmp41 DROP_TO_AIR false
-    * set .DROP_TO_CORE *tmp41
+  147 op equal .DROP_TO_CORE DROP_TO_AIR false
   148 jump *label34 always
   149 label *label33
   150 printflush message2
 
   156 label *label40
   157 op equal *tmp42 .CORE null
   158 jump *label42 equal *tmp42 false
-    * op add *tmp43 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp43
+  159 op add .QUERY_FLAG 99999900 LINK_ID
   160 set :flag .QUERY_FLAG
   161 ubind UNIT
   162 label *label43
 
   175 op land *tmp49 *tmp46 *tmp48
   176 jump *label48 equal *tmp49 false
   177 ucontrol stop
-    * sensor *tmp50 @unit @flag
-    * set :flag *tmp50
+  178 sensor :flag @unit @flag
   179 label *label47
   180 jump *label46 always
   181 label *label48
   182 op notEqual *tmp51 :flag .QUERY_FLAG
   183 jump *label49 equal *tmp51 false
-    * op idiv *tmp53 :flag 100
-    * set :position *tmp53
-    * op mod *tmp54 :position @mapw
-    * set .CORE_X *tmp54
-    * op idiv *tmp55 :position @mapw
-    * set .CORE_Y *tmp55
+  184 op idiv :position :flag 100
+  185 op mod .CORE_X :position @mapw
+  186 op idiv .CORE_Y :position @mapw
   187 label *label51
   188 sensor *tmp56 @unit @dead
   189 op equal *tmp57 *tmp56 0
 
   195 label *label52
   196 jump *label51 always
   197 label *label53
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp61 *tmp62
-    * set .CORE *tmp61
+  198 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp62
   199 op notEqual *tmp63 :b_type @vault
   200 jump *label54 equal *tmp63 false
   201 print "[salmon]Building at "
 
   227 set .DROP_TO_CORE false
   228 label *label34
   229 set .SORTER sorter1
-    * sensor *tmp66 .SORTER @type
-    * set :sorter_type *tmp66
+  230 sensor :sorter_type .SORTER @type
   231 label *label58
   232 op notEqual *tmp67 :sorter_type @sorter
   233 op notEqual *tmp68 :sorter_type @inverted-sorter
 
   244 label *label62
   245 printflush message1
   246 set .SORTER sorter1
-    * sensor *tmp72 .SORTER @type
-    * set :sorter_type *tmp72
+  247 sensor :sorter_type .SORTER @type
   248 label *label59
   249 jump *label58 always
   250 label *label60
 
   253 set .SHOW_REMOTE_LEVEL true
   254 set .SRC .CORE
   255 set .DST .CONTAINER
-    * sensor *tmp75 .SRC @itemCapacity
-    * set :src_capacity *tmp75
-    * sensor *tmp76 .DST @itemCapacity
-    * set :dst_capacity *tmp76
+  256 sensor :src_capacity .SRC @itemCapacity
+  257 sensor :dst_capacity .DST @itemCapacity
   258 op sub *tmp77 100 .EFF_REMOTE_LIMIT
   259 op mul *tmp78 :src_capacity *tmp77
-    * op idiv *tmp79 *tmp78 100
-    * set .LOAD_LEVEL *tmp79
+  260 op idiv .LOAD_LEVEL *tmp78 100
   261 op mul *tmp80 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp81 *tmp80 100
-    * set .DROP_LEVEL *tmp81
+  262 op idiv .DROP_LEVEL *tmp80 100
   263 set .LOCAL_MARGIN .DROP_LEVEL
   264 set .REMOTE_MARGIN .LOAD_LEVEL
   265 op sub *tmp82 1 .TRIGGER_LEVEL
-    * op mul *tmp83 :dst_capacity *tmp82
-    * set .LOW_LEVEL_TRIGGER *tmp83
+  266 op mul .LOW_LEVEL_TRIGGER :dst_capacity *tmp82
   267 set .HIGH_LEVEL_TRIGGER :dst_capacity
   268 set .FLOW_CORR_SIGN 1
   269 set .SRC_REMOTE_WAIT 1
 
   278 set .DIRECTION *tmp85
   279 jump *label64 always
   280 label *label63
-    * op greaterThan *tmp86 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp86
+  281 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   282 set .SRC .CONTAINER
   283 set .DST .CORE
-    * sensor *tmp87 .SRC @itemCapacity
-    * set :src_capacity *tmp87
-    * sensor *tmp88 .DST @itemCapacity
-    * set :dst_capacity *tmp88
+  284 sensor :src_capacity .SRC @itemCapacity
+  285 sensor :dst_capacity .DST @itemCapacity
   286 op sub *tmp89 100 .EFF_LOCAL_LIMIT
   287 op mul *tmp90 :src_capacity *tmp89
-    * op idiv *tmp91 *tmp90 100
-    * set .LOAD_LEVEL *tmp91
+  288 op idiv .LOAD_LEVEL *tmp90 100
   289 op mul *tmp92 :dst_capacity .EFF_REMOTE_LIMIT
   290 op idiv *tmp93 *tmp92 100
   291 op equal *tmp94 LINK_ID 0
   292 op mul *tmp95 *tmp94 .UNIT_CAPACITY
-    * op add *tmp96 *tmp93 *tmp95
-    * set .DROP_LEVEL *tmp96
+  293 op add .DROP_LEVEL *tmp93 *tmp95
   294 set .LOCAL_MARGIN .LOAD_LEVEL
   295 set .REMOTE_MARGIN .DROP_LEVEL
-    * op mul *tmp97 :src_capacity .TRIGGER_LEVEL
-    * set .HIGH_LEVEL_TRIGGER *tmp97
+  296 op mul .HIGH_LEVEL_TRIGGER :src_capacity .TRIGGER_LEVEL
   297 set .LOW_LEVEL_TRIGGER 0
   298 set .FLOW_CORR_SIGN -1
   299 set .SRC_REMOTE_WAIT 0
 
   316 label *label70
   317 set .LINK_TXT *tmp101
   318 op sub *tmp102 :src_capacity .LOAD_LEVEL
-    * op min *tmp103 .UNIT_CAPACITY *tmp102
-    * set .LOAD_PACK *tmp103
-    * op min *tmp104 .UNIT_CAPACITY .DROP_LEVEL
-    * set .DROP_PACK *tmp104
-    * sensor *tmp105 .SRC @x
-    * set .SRC_X *tmp105
-    * sensor *tmp106 .SRC @y
-    * set .SRC_Y *tmp106
-    * sensor *tmp107 .DST @x
-    * set .DST_X *tmp107
-    * sensor *tmp108 .DST @y
-    * set .DST_Y *tmp108
+  319 op min .LOAD_PACK .UNIT_CAPACITY *tmp102
+  320 op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL
+  321 sensor .SRC_X .SRC @x
+  322 sensor .SRC_Y .SRC @y
+  323 sensor .DST_X .DST @x
+  324 sensor .DST_Y .DST @y
   325 op sub *tmp109 .DST_X .SRC_X
   326 op sub *tmp110 .DST_Y .SRC_Y
   327 op len *tmp111 *tmp109 *tmp110
   328 op sub *tmp112 *tmp111 6
-    * op sub *tmp113 *tmp112 8
-    * set .DISTANCE *tmp113
+  329 op sub .DISTANCE *tmp112 8
   330 op max *tmp114 .DISTANCE 10
   331 op mul *tmp115 2 *tmp114
-    * op div *tmp116 *tmp115 .SPEED
-    * set .TRAVEL_TIME *tmp116
+  332 op div .TRAVEL_TIME *tmp115 .SPEED
   333 sensor *tmp117 .CONTAINER @x
   334 op lessThan *tmp118 *tmp117 .CORE_X
   335 jump *label71 equal *tmp118 false
 
   338 label *label71
   339 set *tmp119 -15
   340 label *label72
-    * op add *tmp120 .CORE_X *tmp119
-    * set .PARK_X *tmp120
+  341 op add .PARK_X .CORE_X *tmp119
   342 sensor *tmp121 .CONTAINER @y
   343 op lessThan *tmp122 *tmp121 .CORE_Y
   344 jump *label73 equal *tmp122 false
 
   347 label *label73
   348 set *tmp123 -15
   349 label *label74
-    * op add *tmp124 .CORE_Y *tmp123
-    * set .PARK_Y *tmp124
+  350 op add .PARK_Y .CORE_Y *tmp123
   351 op equal *tmp125 LINK_ID 0
-    * op mul *tmp126 *tmp125 .UNIT_CAPACITY
-    * set .PARK_ITEM_LIMIT *tmp126
-    * set *tmp127 @tick
-    * set .TRANSFER_START *tmp127
-    * op sub *tmp128 @tick 60
-    * set .LOOP_START *tmp128
+  352 op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY
+  353 set .TRANSFER_START @tick
+  354 op sub .LOOP_START @tick 60
   355 set .LAST_ITEM @mono
-    * op add *tmp129 @tick 600
-    * set .MESSAGE_TIMEOUT *tmp129
+  356 op add .MESSAGE_TIMEOUT @tick 600
   357 set .WAIT_LIMIT 30000
   358 set :items_in_transit 0
   359 set :items_per_min_unit "--"
 
   404 set .EFF_AUTO_ALLOCATION false
   405 set .AUTO_ALLOCATION_TXT ""
   406 op add *tmp135 .TARGET 1
-    * op min *tmp136 *tmp135 MAX_UNITS
-    * set .TARGET *tmp136
+  407 op min .TARGET *tmp135 MAX_UNITS
   408 set .CORR_SIGN "[]"
   409 set :corr_per_min ""
   410 set .SPEED_UNIT_TXT "/min"
 
   428 label *label87
   429 set .EFF_AUTO_ALLOCATION false
   430 op sub *tmp142 .TARGET 1
-    * op max *tmp143 *tmp142 0
-    * set .TARGET *tmp143
+  431 op max .TARGET *tmp142 0
   432 set .CORR_SIGN "[]"
   433 set :corr_per_min ""
   434 set .SPEED_UNIT_TXT "/min"
 
   446 label *label85
   447 label *label86
   448 sensor *tmp146 :first_unit @dead
-    * op equal *tmp147 *tmp146 0
-    * set :alive *tmp147
+  449 op equal :alive *tmp146 0
   450 op equal *tmp148 @unit :first_unit
   451 op lessThanEq *tmp149 :alive *tmp148
   452 jump *label91 equal *tmp149 false
 
   458 label *label94
   459 printflush message2
   460 set .STATE_LIMIT 6
-    * sensor *tmp153 .SORTER @config
-    * set .ITEM *tmp153
+  461 sensor .ITEM .SORTER @config
   462 op notEqual *tmp154 .ITEM .LAST_ITEM
   463 jump *label95 equal *tmp154 false
   464 label *label97
 
   466 jump *label99 equal *tmp156 false
   467 print "[salmon]No item type selected for transport.[]"
   468 printflush message1
-    * sensor *tmp157 .SORTER @config
-    * set .ITEM *tmp157
+  469 sensor .ITEM .SORTER @config
   470 label *label98
   471 jump *label97 always
   472 label *label99
 
   575 label *label100
   576 set .ITEM_ICON *tmp158
   577 set .STATE_LIMIT 1
-    * sensor *tmp162 .CONTAINER .ITEM
-    * set :last_level *tmp162
+  578 sensor :last_level .CONTAINER .ITEM
   579 set :min_level 999999
   580 set :max_level 0
   581 jump *label96 always
   582 label *label95
   583 label *label96
-    * sensor *tmp163 .CONTAINER .ITEM
-    * set :container_items *tmp163
-    * op min *tmp164 :min_level :container_items
-    * set :min_level *tmp164
-    * op max *tmp165 :max_level :container_items
-    * set :max_level *tmp165
-    * op sub *tmp166 @tick .LOOP_START
-    * set :loop_time *tmp166
-    * set *tmp167 @tick
-    * set .LOOP_START *tmp167
+  584 sensor :container_items .CONTAINER .ITEM
+  585 op min :min_level :min_level :container_items
+  586 op max :max_level :max_level :container_items
+  587 op sub :loop_time @tick .LOOP_START
+  588 set .LOOP_START @tick
   589 op mul *tmp168 :loop_time 100
-    * op idiv *tmp169 *tmp168 6
-    * set :loop_time_ms *tmp169
+  590 op idiv :loop_time_ms *tmp168 6
   591 op greaterThanEq *tmp170 :transfers :active
   592 op greaterThan *tmp171 :wait_time .WAIT_LIMIT
   593 op or *tmp172 *tmp170 *tmp171
   594 jump *label134 equal *tmp172 false
   595 op div *tmp174 :wait_time 100
   596 op ceil *tmp175 *tmp174
-    * op div *tmp176 *tmp175 10
-    * set :wait_time_str *tmp176
-    * op sub *tmp177 @tick .TRANSFER_START
-    * set :elapsed_ticks *tmp177
-    * set *tmp178 @tick
-    * set .TRANSFER_START *tmp178
-    * op div *tmp179 :elapsed_ticks 0.06
-    * set :elapsed_ms *tmp179
+  597 op div :wait_time_str *tmp175 10
+  598 op sub :elapsed_ticks @tick .TRANSFER_START
+  599 set .TRANSFER_START @tick
+  600 op div :elapsed_ms :elapsed_ticks 0.06
   601 op idiv *tmp180 :elapsed_ms 100
-    * op div *tmp181 *tmp180 10
-    * set :elapsed_str *tmp181
-    * op div *tmp182 :transferred :elapsed_ms
-    * set :items_per_ms *tmp182
-    * op idiv *tmp183 :items_per_ms 0.000016666666666666667
-    * set :items_per_min *tmp183
+  602 op div :elapsed_str *tmp180 10
+  603 op div :items_per_ms :transferred :elapsed_ms
+  604 op idiv :items_per_min :items_per_ms 0.000016666666666666667
   605 set :transferred 0
   606 set :transfers 0
   607 jump *label136 equal .EFF_AUTO_ALLOCATION false
   608 set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] ==="
   609 op mul *tmp185 .LOOPS_TICKS_TO_MS :loop_time
-    * op add *tmp186 .TRAVEL_TIME *tmp185
-    * set :turnaround_ms *tmp186
-    * op mul *tmp187 :turnaround_ms .DEC_OVERALLOCATION
-    * set .WAIT_LIMIT *tmp187
+  610 op add :turnaround_ms .TRAVEL_TIME *tmp185
+  611 op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION
   612 op idiv *tmp188 :turnaround_ms 100
-    * op div *tmp189 *tmp188 10
-    * set :turnaround_str *tmp189
-    * op div *tmp190 .UNIT_CAPACITY :turnaround_ms
-    * set :items_per_ms_unit *tmp190
+  613 op div :turnaround_str *tmp188 10
+  614 op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms
   615 op mul *tmp191 :items_per_ms_unit 60000
-    * op floor *tmp192 *tmp191
-    * set :items_per_min_unit *tmp192
+  616 op floor :items_per_min_unit *tmp191
   617 op add *tmp193 :min_level :max_level
-    * op div *tmp194 *tmp193 2
-    * set :this_level *tmp194
+  618 op div :this_level *tmp193 2
   619 op sub *tmp195 :last_level :this_level
-    * op mul *tmp196 *tmp195 .FLOW_CORR_SIGN
-    * set :corr *tmp196
-    * op div *tmp197 :corr :elapsed_ms
-    * set :corr_per_ms *tmp197
+  620 op mul :corr *tmp195 .FLOW_CORR_SIGN
+  621 op div :corr_per_ms :corr :elapsed_ms
   622 set :last_level :this_level
-    * op add *tmp198 :items_per_ms :corr_per_ms
-    * set :total_flow_per_ms *tmp198
+  623 op add :total_flow_per_ms :items_per_ms :corr_per_ms
   624 op mul *tmp199 60000 :corr_per_ms
-    * op floor *tmp200 *tmp199
-    * set :corr_per_min *tmp200
+  625 op floor :corr_per_min *tmp199
   626 op greaterThanEq *tmp201 :corr_per_min 0
   627 jump *label138 equal *tmp201 false
   628 set *tmp202 "[]([green]+"
 
   635 jump *label140 equal :alive false
   636 op lessThan *tmp204 :min_level .LOW_LEVEL_TRIGGER
   637 op greaterThan *tmp205 :max_level .HIGH_LEVEL_TRIGGER
-    * op or *tmp206 *tmp204 *tmp205
-    * set :trigger *tmp206
+  638 op or :trigger *tmp204 *tmp205
   639 op equal *tmp207 :wait_time 0
   640 op greaterThan *tmp208 :trigger :remote_wait_time
   641 op or *tmp209 *tmp207 *tmp208
 
   646 set :total_flow_1 :total_flow_per_ms
   647 op add *tmp212 :total_flow_3 :total_flow_2
   648 op add *tmp213 *tmp212 :total_flow_1
-    * op div *tmp214 *tmp213 3
-    * set :total_flow_per_ms *tmp214
+  649 op div :total_flow_per_ms *tmp213 3
   650 jump *label145 always
   651 label *label144
   652 label *label145
   653 op div *tmp215 :total_flow_per_ms :items_per_ms_unit
   654 op add *tmp216 *tmp215 .INC_OVERALLOCATION
-    * op ceil *tmp217 *tmp216
-    * set :new_target *tmp217
-    * op mul *tmp218 .TRIGGER_BOOST :trigger
-    * set :level_boost *tmp218
+  655 op ceil :new_target *tmp216
+  656 op mul :level_boost .TRIGGER_BOOST :trigger
   657 op add *tmp219 :new_target :level_boost
-    * op min *tmp220 *tmp219 MAX_UNITS
-    * set :new_target *tmp220
+  658 op min :new_target *tmp219 MAX_UNITS
   659 op sub *tmp221 :new_target :active
   660 op max *tmp222 *tmp221 0
-    * op min *tmp223 *tmp222 .INC_LIMIT
-    * set :new_change *tmp223
+  661 op min :new_change *tmp222 .INC_LIMIT
   662 set .INC_LIMIT .INC_MAX
   663 op lessThanEq *tmp224 :new_change 0
-    * op mul *tmp225 *tmp224 .DEC_MAX
-    * set .DEC_LIMIT *tmp225
+  664 op mul .DEC_LIMIT *tmp224 .DEC_MAX
   665 jump *label143 always
   666 label *label142
   667 op idiv *tmp226 :wait_time .WAIT_LIMIT
   668 op mul *tmp227 -1 *tmp226
-    * op max *tmp228 *tmp227 .DEC_LIMIT
-    * set :new_change *tmp228
+  669 op max :new_change *tmp227 .DEC_LIMIT
   670 op greaterThanEq *tmp229 :new_change 0
-    * op mul *tmp230 *tmp229 .INC_MAX
-    * set .INC_LIMIT *tmp230
+  671 op mul .INC_LIMIT *tmp229 .INC_MAX
   672 set .DEC_LIMIT .DEC_MAX
   673 label *label143
   674 op add *tmp231 :active :new_change
-    * op max *tmp232 *tmp231 1
-    * set .TARGET *tmp232
+  675 op max .TARGET *tmp231 1
   676 jump *label141 always
   677 label *label140
   678 set .INC_LIMIT 0
 
   688 op land *tmp235 *tmp233 *tmp234
   689 jump *label146 equal *tmp235 false
   690 sensor *tmp237 .DST .ITEM
-    * op sub *tmp238 .DROP_LEVEL *tmp237
-    * set :max_drop *tmp238
+  691 op sub :max_drop .DROP_LEVEL *tmp237
   692 op lessThan *tmp239 :max_drop .DROP_PACK
   693 jump *label148 equal *tmp239 false
   694 set :findAnotherContainer:min_level 999999
   695 set .CONTAINERS 0
-    * set *tmp242 @links
-    * set :findAnotherContainer:n *tmp242
+  696 set :findAnotherContainer:n @links
   697 label *label151
   698 op greaterThan *tmp243 :findAnotherContainer:n 0
   699 jump *label153 equal *tmp243 false
-    * op sub *tmp244 :findAnotherContainer:n 1
-    * set :findAnotherContainer:n *tmp244
-    * getlink *tmp245 :findAnotherContainer:n
-    * set :findAnotherContainer:block *tmp245
+  700 op sub :findAnotherContainer:n :findAnotherContainer:n 1
+  701 getlink :findAnotherContainer:block :findAnotherContainer:n
   702 sensor *tmp247 :findAnotherContainer:block @type
   703 jump *label156 equal *tmp247 @vault
   704 jump *label156 equal *tmp247 @container
   705 jump *label155 always
   706 label *label156
   707 op add .CONTAINERS .CONTAINERS 1
-    * sensor *tmp249 :findAnotherContainer:block .ITEM
-    * set :findAnotherContainer:level *tmp249
+  708 sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM
   709 op lessThan *tmp250 :findAnotherContainer:level :findAnotherContainer:min_level
   710 jump *label157 equal *tmp250 false
   711 set :findAnotherContainer:min_level :findAnotherContainer:level
 
   726 jump *label160 always
   727 label *label159
   728 set .DST .CONTAINER
-    * sensor *tmp254 .DST @itemCapacity
-    * set :findAnotherContainer:dst_capacity *tmp254
+  729 sensor :findAnotherContainer:dst_capacity .DST @itemCapacity
   730 op mul *tmp255 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp256 *tmp255 100
-    * set .DROP_LEVEL *tmp256
+  731 op idiv .DROP_LEVEL *tmp255 100
   732 set .LOCAL_MARGIN .DROP_LEVEL
   733 op sub *tmp257 1 .TRIGGER_LEVEL
-    * op mul *tmp258 :findAnotherContainer:dst_capacity *tmp257
-    * set .LOW_LEVEL_TRIGGER *tmp258
+  734 op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity *tmp257
   735 set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
-    * sensor *tmp259 .DST @x
-    * set .DST_X *tmp259
-    * sensor *tmp260 .DST @y
-    * set .DST_Y *tmp260
+  736 sensor .DST_X .DST @x
+  737 sensor .DST_Y .DST @y
   738 op sub *tmp261 .DST_X .SRC_X
   739 op sub *tmp262 .DST_Y .SRC_Y
   740 op len *tmp263 *tmp261 *tmp262
   741 op sub *tmp264 *tmp263 6
-    * op sub *tmp265 *tmp264 8
-    * set .DISTANCE *tmp265
+  742 op sub .DISTANCE *tmp264 8
   743 op max *tmp266 .DISTANCE 10
   744 op mul *tmp267 2 *tmp266
-    * op div *tmp268 *tmp267 .SPEED
-    * set .TRAVEL_TIME *tmp268
+  745 op div .TRAVEL_TIME *tmp267 .SPEED
   746 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
-    * op add *tmp269 @tick 600
-    * set .MESSAGE_TIMEOUT *tmp269
+  747 op add .MESSAGE_TIMEOUT @tick 600
   748 label *label160
   749 set *tmp241 :findAnotherContainer:min_level
   750 jump *label150 always
 
   828 label *label169
   829 label *label170
   830 jump *label171 equal .SHOW_REMOTE_LEVEL false
-    * sensor *tmp281 .CORE .ITEM
-    * set :remote_level *tmp281
+  831 sensor :remote_level .CORE .ITEM
   832 print "\n"
   833 print "[]Remote items: [gold]"
   834 print :remote_level
 
   888 print " "
   889 print "ms"
   890 printflush message1
-    * op sub *tmp287 .TARGET :active
-    * set .CHANGE *tmp287
+  891 op sub .CHANGE .TARGET :active
   892 set :active 0
-    * set *tmp288 @unit
-    * set :first_unit *tmp288
+  893 set :first_unit @unit
   894 set :items_in_transit 0
   895 print "Unit status:"
   896 sensor *tmp289 .SRC @dead
 
   940 sensor *tmp306 @unit @controller
   941 op equal *tmp307 *tmp306 @this
   942 jump *label191 equal *tmp307 false
-    * sensor *tmp309 @unit @flag
-    * set :state *tmp309
+  943 sensor :state @unit @flag
   944 op notEqual *tmp310 :state .S_UNUSED
   945 jump *label193 equal *tmp310 false
   946 op max *tmp312 :state 1
-    * op min *tmp313 *tmp312 .STATE_LIMIT
-    * set :state *tmp313
+  947 op min :state *tmp312 .STATE_LIMIT
   948 op lessThan *tmp314 .CHANGE 0
   949 jump *label195 equal *tmp314 false
   950 op notEqual *tmp316 :state 6
 
  1043 op equal *tmp345 :state 3
  1044 jump *label218 equal *tmp345 false
  1045 sensor *tmp347 .SRC .ITEM
-    * op sub *tmp348 *tmp347 .LOAD_LEVEL
-    * set :max_load *tmp348
+ 1046 op sub :max_load *tmp347 .LOAD_LEVEL
  1047 op greaterThanEq *tmp349 :max_load .LOAD_PACK
  1048 jump *label220 equal *tmp349 false
  1049 ucontrol itemTake .SRC .ITEM :max_load
 
  1115 op equal *tmp369 :state 5
  1116 jump *label231 equal *tmp369 false
  1117 sensor *tmp371 .DST .ITEM
-    * op sub *tmp372 .DROP_LEVEL *tmp371
-    * set :max_drop *tmp372
+ 1118 op sub :max_drop .DROP_LEVEL *tmp371
  1119 op greaterThanEq *tmp373 :max_drop .DROP_PACK
  1120 jump *label233 equal *tmp373 false
  1121 ucontrol itemDrop .DST :max_drop
 
  1170 jump *label232 always
  1171 label *label231
  1172 label *label232
-    * sensor *tmp388 @unit @totalItems
-    * set :items *tmp388
+ 1173 sensor :items @unit @totalItems
  1174 op add :items_in_transit :items_in_transit :items
  1175 op equal *tmp389 :state 6
  1176 jump *label240 equal *tmp389 false
 
  1184 ucontrol within .CORE_X .CORE_Y 8 *tmp394
  1185 jump *label246 equal *tmp394 false
  1186 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * sensor *tmp396 @unit @totalItems
-    * set :items *tmp396
+ 1187 sensor :items @unit @totalItems
  1188 jump *label247 always
  1189 label *label246
  1190 label *label247
  1191 jump *label245 always
  1192 label *label244
  1193 ucontrol itemDrop @air .UNIT_CAPACITY
-    * sensor *tmp397 @unit @totalItems
-    * set :items *tmp397
+ 1194 sensor :items @unit @totalItems
  1195 label *label245
  1196 jump *label243 always
  1197 label *label242

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-5 instructions):
 
    89 sensor .UNIT_CAPACITY @unit @itemCapacity
    90 set :first_unit null
    91 label *label22
-    * jump *label24 equal true false
    92 set .CONTAINER null
    93 set .CONTAINERS 0
    94 set :n @links
 
   383 set .AUTO_ALLOCATION_TXT ""
   384 label *label76
   385 label *label77
-    * jump *label79 equal true false
   386 ubind UNIT
   387 label *label80
   388 op equal *tmp131 @unit null
 
  1007 set :printUnitInfo:name "source"
  1008 set :printUnitInfo:x .SRC_X
  1009 set :printUnitInfo:y .SRC_Y
-    * jump *label216 equal true false
  1010 sensor *tmp338 @unit @x
  1011 op sub *tmp339 :printUnitInfo:x *tmp338
  1012 sensor *tmp340 @unit @y
 
  1078 set :printUnitInfo.1:name "destination"
  1079 set :printUnitInfo.1:x .DST_X
  1080 set :printUnitInfo.1:y .DST_Y
-    * jump *label229 equal true false
  1081 sensor *tmp362 @unit @x
  1082 op sub *tmp363 :printUnitInfo.1:x *tmp362
  1083 sensor *tmp364 @unit @y
 
  1126 set :printUnitInfo.2:name "source"
  1127 set :printUnitInfo.2:x .SRC_X
  1128 set :printUnitInfo.2:y .SRC_Y
-    * jump *label238 equal true false
  1129 sensor *tmp380 @unit @x
  1130 op sub *tmp381 :printUnitInfo.2:x *tmp380
  1131 sensor *tmp382 @unit @y

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-18 instructions):
 
    99 getlink :block :n
   100 sensor *tmp29 :block @type
   101 jump *label30 equal *tmp29 @vault
-    * jump *label30 equal *tmp29 @container
-    * jump *label29 always
+  102 jump *label29 notEqual *tmp29 @container
   103 label *label30
   104 set .CONTAINER :block
   105 op add .CONTAINERS .CONTAINERS 1
 
   470 set .LAST_ITEM .ITEM
   471 set :itemTypeToIcon:itemType .ITEM
   472 sensor *tmp160 :itemTypeToIcon:itemType @id
-    * jump *label103 equal *tmp160 14
-    * jump *label102 always
+  473 jump *label102 notEqual *tmp160 14
   474 label *label103
   475 set *tmp159 "[]"
   476 jump *label101 always
   477 label *label102
-    * jump *label105 equal *tmp160 5
-    * jump *label104 always
+  478 jump *label104 notEqual *tmp160 5
   479 label *label105
   480 set *tmp159 "[]"
   481 jump *label101 always
   482 label *label104
-    * jump *label107 equal *tmp160 0
-    * jump *label106 always
+  483 jump *label106 notEqual *tmp160 0
   484 label *label107
   485 set *tmp159 "[]"
   486 jump *label101 always
   487 label *label106
-    * jump *label109 equal *tmp160 3
-    * jump *label108 always
+  488 jump *label108 notEqual *tmp160 3
   489 label *label109
   490 set *tmp159 "[]"
   491 jump *label101 always
   492 label *label108
-    * jump *label111 equal *tmp160 1
-    * jump *label110 always
+  493 jump *label110 notEqual *tmp160 1
   494 label *label111
   495 set *tmp159 "[]"
   496 jump *label101 always
   497 label *label110
-    * jump *label113 equal *tmp160 2
-    * jump *label112 always
+  498 jump *label112 notEqual *tmp160 2
   499 label *label113
   500 set *tmp159 "[]"
   501 jump *label101 always
   502 label *label112
-    * jump *label115 equal *tmp160 11
-    * jump *label114 always
+  503 jump *label114 notEqual *tmp160 11
   504 label *label115
   505 set *tmp159 "[]"
   506 jump *label101 always
   507 label *label114
-    * jump *label117 equal *tmp160 10
-    * jump *label116 always
+  508 jump *label116 notEqual *tmp160 10
   509 label *label117
   510 set *tmp159 "[]"
   511 jump *label101 always
   512 label *label116
-    * jump *label119 equal *tmp160 15
-    * jump *label118 always
+  513 jump *label118 notEqual *tmp160 15
   514 label *label119
   515 set *tmp159 "[]"
   516 jump *label101 always
   517 label *label118
-    * jump *label121 equal *tmp160 4
-    * jump *label120 always
+  518 jump *label120 notEqual *tmp160 4
   519 label *label121
   520 set *tmp159 "[]"
   521 jump *label101 always
   522 label *label120
-    * jump *label123 equal *tmp160 8
-    * jump *label122 always
+  523 jump *label122 notEqual *tmp160 8
   524 label *label123
   525 set *tmp159 "[]"
   526 jump *label101 always
   527 label *label122
-    * jump *label125 equal *tmp160 9
-    * jump *label124 always
+  528 jump *label124 notEqual *tmp160 9
   529 label *label125
   530 set *tmp159 "[]"
   531 jump *label101 always
   532 label *label124
-    * jump *label127 equal *tmp160 13
-    * jump *label126 always
+  533 jump *label126 notEqual *tmp160 13
   534 label *label127
   535 set *tmp159 "[]"
   536 jump *label101 always
   537 label *label126
-    * jump *label129 equal *tmp160 12
-    * jump *label128 always
+  538 jump *label128 notEqual *tmp160 12
   539 label *label129
   540 set *tmp159 "[]"
   541 jump *label101 always
   542 label *label128
-    * jump *label131 equal *tmp160 7
-    * jump *label130 always
+  543 jump *label130 notEqual *tmp160 7
   544 label *label131
   545 set *tmp159 "[]"
   546 jump *label101 always
   547 label *label130
-    * jump *label133 equal *tmp160 6
-    * jump *label132 always
+  548 jump *label132 notEqual *tmp160 6
   549 label *label133
   550 set *tmp159 "[]"
   551 jump *label101 always
 
   682 getlink :findAnotherContainer:block :findAnotherContainer:n
   683 sensor *tmp247 :findAnotherContainer:block @type
   684 jump *label156 equal *tmp247 @vault
-    * jump *label156 equal *tmp247 @container
-    * jump *label155 always
+  685 jump *label155 notEqual *tmp247 @container
   686 label *label156
   687 op add .CONTAINERS .CONTAINERS 1
   688 sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-62 instructions):
 
    45 set .DEC_MAX -1
    46 ubind UNIT
    47 label *label14
-    * op equal *tmp6 @unit null
-    * jump *label16 equal *tmp6 false
+   48 jump *label16 notEqual @unit null
    49 print "[salmon]No unit of type "
    50 print UNIT
    51 print " "
 
    63 set .TARGET 0
    64 label *label17
    65 sensor *tmp12 @unit @controller
-    * op equal *tmp13 *tmp12 @this
-    * jump *label20 equal *tmp13 false
+   66 jump *label20 notEqual *tmp12 @this
    67 sensor :state @unit @flag
    68 op greaterThanEq *tmp16 :state 1
    69 op lessThan *tmp17 :state 6
 
    91 set .CONTAINERS 0
    92 set :n @links
    93 label *label25
-    * op greaterThan *tmp25 :n 0
-    * jump *label27 equal *tmp25 false
+   94 jump *label27 lessThanEq :n 0
    95 op sub :n :n 1
    96 getlink :block :n
    97 sensor *tmp29 :block @type
 
   107 label *label26
   108 jump *label25 always
   109 label *label27
-    * op equal *tmp31 .CONTAINER null
-    * jump *label31 equal *tmp31 false
+  110 jump *label31 notEqual .CONTAINER null
   111 print "[salmon]No vault or container."
   112 printflush message1
   113 jump *label32 always
 
   118 jump *label22 always
   119 label *label24
   120 set .CORE null
-    * op equal *tmp33 LINK_ID 0
-    * jump *label33 equal *tmp33 false
+  121 jump *label33 notEqual LINK_ID 0
   122 label *label35
-    * op equal *tmp35 .CORE null
-    * jump *label37 equal *tmp35 false
+  123 jump *label37 notEqual .CORE null
   124 print "[green]Locating core..."
   125 printflush message1
   126 ubind UNIT
   127 sensor *tmp36 @unit @controlled
-    * op equal *tmp37 *tmp36 0
-    * jump *label38 equal *tmp37 false
+  128 jump *label38 notEqual *tmp36 0
   129 ulocate building core false @copper .CORE_X .CORE_Y *tmp40 .CORE
   130 ucontrol flag .S_UNUSED
   131 jump *label39 always
 
   145 print ".."
   146 printflush message1
   147 label *label40
-    * op equal *tmp42 .CORE null
-    * jump *label42 equal *tmp42 false
+  148 jump *label42 notEqual .CORE null
   149 op add .QUERY_FLAG 99999900 LINK_ID
   150 set :flag .QUERY_FLAG
   151 ubind UNIT
   152 label *label43
   153 sensor *tmp44 @unit @controlled
-    * op notEqual *tmp45 *tmp44 0
-    * jump *label45 equal *tmp45 false
+  154 jump *label45 equal *tmp44 0
   155 ubind UNIT
   156 label *label44
   157 jump *label43 always
 
   168 label *label47
   169 jump *label46 always
   170 label *label48
-    * op notEqual *tmp51 :flag .QUERY_FLAG
-    * jump *label49 equal *tmp51 false
+  171 jump *label49 equal :flag .QUERY_FLAG
   172 op idiv :position :flag 100
   173 op mod .CORE_X :position @mapw
   174 op idiv .CORE_Y :position @mapw
 
   184 jump *label51 always
   185 label *label53
   186 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp62
-    * op notEqual *tmp63 :b_type @vault
-    * jump *label54 equal *tmp63 false
+  187 jump *label54 equal :b_type @vault
   188 print "[salmon]Building at "
   189 print .CORE_X
   190 print ","
 
   222 jump *label60 equal *tmp69 false
   223 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   224 print "\n"
-    * op notEqual *tmp70 .SORTER null
-    * jump *label61 equal *tmp70 false
+  225 jump *label61 equal .SORTER null
   226 print "Block found: "
   227 print .SORTER
   228 jump *label62 always
 
   234 label *label59
   235 jump *label58 always
   236 label *label60
-    * op equal *tmp73 :sorter_type @sorter
-    * jump *label63 equal *tmp73 false
+  237 jump *label63 notEqual :sorter_type @sorter
   238 set .SHOW_REMOTE_LEVEL true
   239 set .SRC .CORE
   240 set .DST .CONTAINER
 
   253 set .FLOW_CORR_SIGN 1
   254 set .SRC_REMOTE_WAIT 1
   255 set .DST_REMOTE_WAIT 0
-    * op equal *tmp84 LINK_ID 0
-    * jump *label65 equal *tmp84 false
+  256 jump *label65 notEqual LINK_ID 0
   257 set *tmp85 " from core"
   258 jump *label66 always
   259 label *label65
 
   282 set .FLOW_CORR_SIGN -1
   283 set .SRC_REMOTE_WAIT 0
   284 set .DST_REMOTE_WAIT 1
-    * op equal *tmp98 LINK_ID 0
-    * jump *label67 equal *tmp98 false
+  285 jump *label67 notEqual LINK_ID 0
   286 set *tmp99 " to core"
   287 jump *label68 always
   288 label *label67
 
   290 label *label68
   291 set .DIRECTION *tmp99
   292 label *label64
-    * op equal *tmp100 LINK_ID 0
-    * jump *label69 equal *tmp100 false
+  293 jump *label69 notEqual LINK_ID 0
   294 set *tmp101 ""
   295 jump *label70 always
   296 label *label69
 
   313 op mul *tmp115 2 *tmp114
   314 op div .TRAVEL_TIME *tmp115 .SPEED
   315 sensor *tmp117 .CONTAINER @x
-    * op lessThan *tmp118 *tmp117 .CORE_X
-    * jump *label71 equal *tmp118 false
+  316 jump *label71 greaterThanEq *tmp117 .CORE_X
   317 set *tmp119 15
   318 jump *label72 always
   319 label *label71
 
   321 label *label72
   322 op add .PARK_X .CORE_X *tmp119
   323 sensor *tmp121 .CONTAINER @y
-    * op lessThan *tmp122 *tmp121 .CORE_Y
-    * jump *label73 equal *tmp122 false
+  324 jump *label73 greaterThanEq *tmp121 .CORE_Y
   325 set *tmp123 15
   326 jump *label74 always
   327 label *label73
 
   366 label *label77
   367 ubind UNIT
   368 label *label80
-    * op equal *tmp131 @unit null
-    * jump *label82 equal *tmp131 false
+  369 jump *label82 notEqual @unit null
   370 print "No unit of type "
   371 print UNIT
   372 print " "
 
   393 sensor *tmp137 switch2 @enabled
   394 jump *label85 equal *tmp137 false
   395 control enabled switch2 false
-    * op lessThan *tmp140 .TARGET 1
-    * jump *label87 equal *tmp140 false
+  396 jump *label87 greaterThanEq .TARGET 1
   397 set .EFF_AUTO_ALLOCATION true
   398 set .TARGET 1
   399 set .DEC_LIMIT 0
 
   409 set .CORR_SIGN "[]"
   410 set :corr_per_min ""
   411 set .SPEED_UNIT_TXT "/min"
-    * op equal *tmp144 .TARGET 0
-    * jump *label89 equal *tmp144 false
+  412 jump *label89 notEqual .TARGET 0
   413 set *tmp145 "\n=== [salmon]Transport deactivated[] ==="
   414 jump *label90 always
   415 label *label89
 
   424 sensor *tmp146 :first_unit @dead
   425 op equal :alive *tmp146 0
   426 op equal *tmp148 @unit :first_unit
-    * op lessThanEq *tmp149 :alive *tmp148
-    * jump *label91 equal *tmp149 false
-    * op equal *tmp151 :active 0
-    * jump *label93 equal *tmp151 false
+  427 jump *label91 greaterThan :alive *tmp148
+  428 jump *label93 notEqual :active 0
   429 print "\n[salmon]No active units.[]"
   430 jump *label94 always
   431 label *label93
 
   433 printflush message2
   434 set .STATE_LIMIT 6
   435 sensor .ITEM .SORTER @config
-    * op notEqual *tmp154 .ITEM .LAST_ITEM
-    * jump *label95 equal *tmp154 false
+  436 jump *label95 equal .ITEM .LAST_ITEM
   437 label *label97
-    * op equal *tmp156 .ITEM null
-    * jump *label99 equal *tmp156 false
+  438 jump *label99 notEqual .ITEM null
   439 print "[salmon]No item type selected for transport.[]"
   440 printflush message1
   441 sensor .ITEM .SORTER @config
 
   579 op add :total_flow_per_ms :items_per_ms :corr_per_ms
   580 op mul *tmp199 60000 :corr_per_ms
   581 op floor :corr_per_min *tmp199
-    * op greaterThanEq *tmp201 :corr_per_min 0
-    * jump *label138 equal *tmp201 false
+  582 jump *label138 lessThan :corr_per_min 0
   583 set *tmp202 "[]([green]+"
   584 jump *label139 always
   585 label *label138
 
   644 jump *label146 equal *tmp235 false
   645 sensor *tmp237 .DST .ITEM
   646 op sub :max_drop .DROP_LEVEL *tmp237
-    * op lessThan *tmp239 :max_drop .DROP_PACK
-    * jump *label148 equal *tmp239 false
+  647 jump *label148 greaterThanEq :max_drop .DROP_PACK
   648 set :findAnotherContainer:min_level 999999
   649 set .CONTAINERS 0
   650 set :findAnotherContainer:n @links
   651 label *label151
-    * op greaterThan *tmp243 :findAnotherContainer:n 0
-    * jump *label153 equal *tmp243 false
+  652 jump *label153 lessThanEq :findAnotherContainer:n 0
   653 op sub :findAnotherContainer:n :findAnotherContainer:n 1
   654 getlink :findAnotherContainer:block :findAnotherContainer:n
   655 sensor *tmp247 :findAnotherContainer:block @type
 
   658 label *label156
   659 op add .CONTAINERS .CONTAINERS 1
   660 sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM
-    * op lessThan *tmp250 :findAnotherContainer:level :findAnotherContainer:min_level
-    * jump *label157 equal *tmp250 false
+  661 jump *label157 greaterThanEq :findAnotherContainer:level :findAnotherContainer:min_level
   662 set :findAnotherContainer:min_level :findAnotherContainer:level
   663 set .CONTAINER :findAnotherContainer:block
   664 set .CONTAINER_INDEX :findAnotherContainer:n
 
   671 label *label152
   672 jump *label151 always
   673 label *label153
-    * op equal *tmp252 .CONTAINERS 0
-    * jump *label159 equal *tmp252 false
+  674 jump *label159 notEqual .CONTAINERS 0
   675 set .CONTAINER @this
   676 jump *label160 always
   677 label *label159
 
   710 label *label147
   711 set :wait_time 0
   712 set :remote_wait_time 0
-    * op greaterThanEq *tmp270 @tick .MESSAGE_TIMEOUT
-    * jump *label161 equal *tmp270 false
+  713 jump *label161 lessThan @tick .MESSAGE_TIMEOUT
   714 set .MESSAGE ""
   715 jump *label162 always
   716 label *label161
 
   726 print .DIRECTION
   727 print .LINK_TXT
   728 print .AUTO_ALLOCATION_TXT
-    * op greaterThan *tmp272 .TARGET 0
-    * jump *label163 equal *tmp272 false
-    * op greaterThanEq *tmp274 :active .TARGET
-    * jump *label165 equal *tmp274 false
+  729 jump *label163 lessThanEq .TARGET 0
+  730 jump *label165 lessThan :active .TARGET
   731 print "\n"
   732 print "Using [green]"
   733 print :active
 
   753 print " [gold]+"
   754 print :items_in_transit
   755 label *label166
-    * op greaterThan *tmp276 .CHANGE 0
-    * jump *label167 equal *tmp276 false
+  756 jump *label167 lessThanEq .CHANGE 0
   757 print "\n[][salmon]Cannot acquire additional units![]"
   758 jump *label168 always
   759 label *label167
 
   764 print "\n"
   765 print "[]Local items: [gold]"
   766 print :container_items
-    * op lessThan *tmp278 .EFF_LOCAL_LIMIT 100
-    * jump *label169 equal *tmp278 false
+  767 jump *label169 greaterThanEq .EFF_LOCAL_LIMIT 100
   768 print "[] (limit [orange]"
   769 print .LOCAL_MARGIN
   770 print "["
 
   777 print "\n"
   778 print "[]Remote items: [gold]"
   779 print :remote_level
-    * op lessThan *tmp282 .EFF_REMOTE_LIMIT 100
-    * jump *label173 equal *tmp282 false
+  780 jump *label173 greaterThanEq .EFF_REMOTE_LIMIT 100
   781 print "[] (limit [orange]"
   782 print .REMOTE_MARGIN
   783 print "["
 
   788 jump *label172 always
   789 label *label171
   790 label *label172
-    * op greaterThan *tmp284 .TARGET 0
-    * jump *label175 equal *tmp284 false
+  791 jump *label175 lessThanEq .TARGET 0
   792 print "\n"
   793 print "[]Speed: [green]"
   794 print :items_per_min
 
   837 set :items_in_transit 0
   838 print "Unit status:"
   839 sensor *tmp289 .SRC @dead
-    * op notEqual *tmp290 *tmp289 0
-    * jump *label179 equal *tmp290 false
+  840 jump *label179 equal *tmp289 0
   841 jump *label79 always
   842 jump *label180 always
   843 label *label179
   844 label *label180
   845 sensor *tmp292 .DST @dead
-    * op notEqual *tmp293 *tmp292 0
-    * jump *label181 equal *tmp293 false
+  846 jump *label181 equal *tmp292 0
   847 jump *label79 always
   848 jump *label182 always
   849 label *label181
   850 label *label182
   851 sensor *tmp295 .SORTER @dead
-    * op notEqual *tmp296 *tmp295 0
-    * jump *label183 equal *tmp296 false
+  852 jump *label183 equal *tmp295 0
   853 jump *label79 always
   854 jump *label184 always
   855 label *label183
   856 label *label184
   857 getlink *tmp298 .CONTAINER_INDEX
-    * op notEqual *tmp299 .CONTAINER *tmp298
-    * jump *label185 equal *tmp299 false
+  858 jump *label185 equal .CONTAINER *tmp298
   859 jump *label79 always
   860 jump *label186 always
   861 label *label185
 
   863 jump *label92 always
   864 label *label91
   865 label *label92
-    * op greaterThan *tmp301 .CHANGE 0
-    * jump *label187 equal *tmp301 false
+  866 jump *label187 lessThanEq .CHANGE 0
   867 sensor *tmp303 @unit @controlled
-    * op equal *tmp304 *tmp303 0
-    * jump *label189 equal *tmp304 false
+  868 jump *label189 notEqual *tmp303 0
   869 op sub .CHANGE .CHANGE 1
   870 ucontrol flag 1
   871 jump *label190 always
 
   875 label *label187
   876 label *label188
   877 sensor *tmp306 @unit @controller
-    * op equal *tmp307 *tmp306 @this
-    * jump *label191 equal *tmp307 false
+  878 jump *label191 notEqual *tmp306 @this
   879 sensor :state @unit @flag
-    * op notEqual *tmp310 :state .S_UNUSED
-    * jump *label193 equal *tmp310 false
+  880 jump *label193 equal :state .S_UNUSED
   881 op max *tmp312 :state 1
   882 op min :state *tmp312 .STATE_LIMIT
-    * op lessThan *tmp314 .CHANGE 0
-    * jump *label195 equal *tmp314 false
-    * op notEqual *tmp316 :state 6
-    * jump *label197 equal *tmp316 false
+  883 jump *label195 greaterThanEq .CHANGE 0
+  884 jump *label197 equal :state 6
   885 sensor *tmp318 @unit @totalItems
-    * op lessThanEq *tmp319 *tmp318 .DISCARD_UNIT_MAX_ITEMS
-    * jump *label199 equal *tmp319 false
+  886 jump *label199 greaterThan *tmp318 .DISCARD_UNIT_MAX_ITEMS
   887 op add .CHANGE .CHANGE 1
   888 set :state 6
   889 jump *label200 always
 
   895 jump *label196 always
   896 label *label195
   897 label *label196
-    * op equal *tmp321 :state 1
-    * jump *label201 equal *tmp321 false
+  898 jump *label201 notEqual :state 1
   899 sensor *tmp323 @unit @totalItems
-    * op equal *tmp324 *tmp323 0
-    * jump *label203 equal *tmp324 false
+  900 jump *label203 notEqual *tmp323 0
   901 set :state 2
   902 jump *label204 always
   903 label *label203
   904 sensor *tmp326 @unit @firstItem
-    * op equal *tmp327 *tmp326 .ITEM
-    * jump *label205 equal *tmp327 false
+  905 jump *label205 notEqual *tmp326 .ITEM
   906 set :state 4
   907 jump *label206 always
   908 label *label205
 
   927 jump *label202 always
   928 label *label201
   929 label *label202
-    * op equal *tmp332 :state 2
-    * jump *label211 equal *tmp332 false
+  930 jump *label211 notEqual :state 2
   931 ucontrol approach .SRC_X .SRC_Y 6
   932 ucontrol within .SRC_X .SRC_Y 8 *tmp334
   933 jump *label213 equal *tmp334 false
 
   967 jump *label212 always
   968 label *label211
   969 label *label212
-    * op equal *tmp345 :state 3
-    * jump *label218 equal *tmp345 false
+  970 jump *label218 notEqual :state 3
   971 sensor *tmp347 .SRC .ITEM
   972 op sub :max_load *tmp347 .LOAD_LEVEL
-    * op greaterThanEq *tmp349 :max_load .LOAD_PACK
-    * jump *label220 equal *tmp349 false
+  973 jump *label220 lessThan :max_load .LOAD_PACK
   974 ucontrol itemTake .SRC .ITEM :max_load
   975 jump *label221 always
   976 label *label220
   977 label *label221
   978 sensor *tmp351 @unit @totalItems
-    * op greaterThanEq *tmp352 *tmp351 .UNIT_CAPACITY
-    * jump *label222 equal *tmp352 false
+  979 jump *label222 lessThan *tmp351 .UNIT_CAPACITY
   980 set :state 4
   981 jump *label223 always
   982 label *label222
 
   991 jump *label219 always
   992 label *label218
   993 label *label219
-    * op equal *tmp355 :state 4
-    * jump *label224 equal *tmp355 false
+  994 jump *label224 notEqual :state 4
   995 ucontrol approach .DST_X .DST_Y 6
   996 ucontrol within .DST_X .DST_Y 8 *tmp357
   997 jump *label226 equal *tmp357 false
 
  1034 jump *label225 always
  1035 label *label224
  1036 label *label225
-    * op equal *tmp369 :state 5
-    * jump *label231 equal *tmp369 false
+ 1037 jump *label231 notEqual :state 5
  1038 sensor *tmp371 .DST .ITEM
  1039 op sub :max_drop .DROP_LEVEL *tmp371
-    * op greaterThanEq *tmp373 :max_drop .DROP_PACK
-    * jump *label233 equal *tmp373 false
+ 1040 jump *label233 lessThan :max_drop .DROP_PACK
  1041 ucontrol itemDrop .DST :max_drop
  1042 jump *label234 always
  1043 label *label233
  1044 label *label234
  1045 sensor *tmp375 @unit @totalItems
-    * op lessThanEq *tmp376 *tmp375 0
-    * jump *label235 equal *tmp376 false
+ 1046 jump *label235 greaterThan *tmp375 0
  1047 set :state 2
  1048 ucontrol approach .SRC_X .SRC_Y 6
  1049 set :printUnitInfo.2:name "source"
 
  1090 label *label232
  1091 sensor :items @unit @totalItems
  1092 op add :items_in_transit :items_in_transit :items
-    * op equal *tmp389 :state 6
-    * jump *label240 equal *tmp389 false
+ 1093 jump *label240 notEqual :state 6
  1094 print "[]"
  1095 print "\n"
  1096 print "Parking: [green]"
-    * op greaterThan *tmp391 :items 0
-    * jump *label242 equal *tmp391 false
+ 1097 jump *label242 lessThanEq :items 0
  1098 jump *label244 equal .DROP_TO_CORE false
  1099 ucontrol approach .CORE_X .CORE_Y 6
  1100 ucontrol within .CORE_X .CORE_Y 8 *tmp394
 
  1112 jump *label243 always
  1113 label *label242
  1114 label *label243
-    * op lessThanEq *tmp398 :items .PARK_ITEM_LIMIT
-    * jump *label248 equal *tmp398 false
+ 1115 jump *label248 greaterThan :items .PARK_ITEM_LIMIT
  1116 ucontrol move .PARK_X .PARK_Y
  1117 set :state .S_UNUSED
  1118 jump *label249 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-47 instructions):
 
    69 op lessThan *tmp17 :state 6
    70 op land *tmp18 *tmp16 *tmp17
    71 op add .TARGET .TARGET *tmp18
-    * jump *label21 always
    72 label *label20
    73 label *label21
    74 ubind UNIT
 
   100 set .CONTAINER :block
   101 op add .CONTAINERS .CONTAINERS 1
   102 set .CONTAINER_INDEX :n
-    * jump *label28 always
   103 label *label29
   104 label *label28
   105 label *label26
 
   126 jump *label38 notEqual *tmp36 0
   127 ulocate building core false @copper .CORE_X .CORE_Y *tmp40 .CORE
   128 ucontrol flag .S_UNUSED
-    * jump *label39 always
   129 label *label38
   130 label *label39
   131 label *label36
 
   191 print "is not a vault!"
   192 printflush message2
   193 set .CORE null
-    * jump *label55 always
   194 label *label54
   195 label *label55
-    * jump *label50 always
   196 label *label49
   197 label *label50
   198 ucontrol flag .S_UNUSED
 
   220 jump *label61 equal .SORTER null
   221 print "Block found: "
   222 print .SORTER
-    * jump *label62 always
   223 label *label61
   224 label *label62
   225 printflush message1
 
   381 set :corr_per_min ""
   382 set .SPEED_UNIT_TXT "/min"
   383 set .WAIT_LIMIT 30000
-    * jump *label84 always
   384 label *label83
   385 label *label84
   386 sensor *tmp137 switch2 @enabled
 
   411 set .AUTO_ALLOCATION_TXT *tmp145
   412 label *label88
   413 set .WAIT_LIMIT 30000
-    * jump *label86 always
   414 label *label85
   415 label *label86
   416 sensor *tmp146 :first_unit @dead
 
   419 jump *label91 greaterThan :alive *tmp148
   420 jump *label93 notEqual :active 0
   421 print "\n[salmon]No active units.[]"
-    * jump *label94 always
   422 label *label93
   423 label *label94
   424 printflush message2
 
   525 sensor :last_level .CONTAINER .ITEM
   526 set :min_level 999999
   527 set :max_level 0
-    * jump *label96 always
   528 label *label95
   529 label *label96
   530 sensor :container_items .CONTAINER .ITEM
 
   592 op add *tmp212 :total_flow_3 :total_flow_2
   593 op add *tmp213 *tmp212 :total_flow_1
   594 op div :total_flow_per_ms *tmp213 3
-    * jump *label145 always
   595 label *label144
   596 label *label145
   597 op div *tmp215 :total_flow_per_ms :items_per_ms_unit
 
   624 label *label141
   625 set :min_level 999999
   626 set :max_level 0
-    * jump *label137 always
   627 label *label136
   628 label *label137
   629 op greaterThan *tmp233 .CONTAINERS 1
 
   650 set :findAnotherContainer:min_level :findAnotherContainer:level
   651 set .CONTAINER :findAnotherContainer:block
   652 set .CONTAINER_INDEX :findAnotherContainer:n
-    * jump *label158 always
   653 label *label157
   654 label *label158
-    * jump *label154 always
   655 label *label155
   656 label *label154
   657 label *label152
 
   688 label *label150
   689 set :this_level *tmp241
   690 set :last_level :this_level
-    * jump *label149 always
   691 label *label148
   692 label *label149
-    * jump *label147 always
   693 label *label146
   694 label *label147
   695 set :wait_time 0
   696 set :remote_wait_time 0
   697 jump *label161 lessThan @tick .MESSAGE_TIMEOUT
   698 set .MESSAGE ""
-    * jump *label162 always
   699 label *label161
   700 label *label162
-    * jump *label135 always
   701 label *label134
   702 label *label135
   703 print .MESSAGE
 
   737 label *label166
   738 jump *label167 lessThanEq .CHANGE 0
   739 print "\n[][salmon]Cannot acquire additional units![]"
-    * jump *label168 always
   740 label *label167
   741 label *label168
-    * jump *label164 always
   742 label *label163
   743 label *label164
   744 print "\n"
 
   749 print .LOCAL_MARGIN
   750 print "["
   751 print "])"
-    * jump *label170 always
   752 label *label169
   753 label *label170
   754 jump *label171 equal .SHOW_REMOTE_LEVEL false
 
   761 print .REMOTE_MARGIN
   762 print "["
   763 print "])"
-    * jump *label174 always
   764 label *label173
   765 label *label174
-    * jump *label172 always
   766 label *label171
   767 label *label172
   768 jump *label175 lessThanEq .TARGET 0
 
   799 print :wait_time_str
   800 print "["
   801 print "] s"
-    * jump *label176 always
   802 label *label175
   803 label *label176
   804 print "\n"
 
   815 sensor *tmp289 .SRC @dead
   816 jump *label179 equal *tmp289 0
   817 jump *label79 always
-    * jump *label180 always
   818 label *label179
   819 label *label180
   820 sensor *tmp292 .DST @dead
   821 jump *label181 equal *tmp292 0
   822 jump *label79 always
-    * jump *label182 always
   823 label *label181
   824 label *label182
   825 sensor *tmp295 .SORTER @dead
   826 jump *label183 equal *tmp295 0
   827 jump *label79 always
-    * jump *label184 always
   828 label *label183
   829 label *label184
   830 getlink *tmp298 .CONTAINER_INDEX
   831 jump *label185 equal .CONTAINER *tmp298
   832 jump *label79 always
-    * jump *label186 always
   833 label *label185
   834 label *label186
-    * jump *label92 always
   835 label *label91
   836 label *label92
   837 jump *label187 lessThanEq .CHANGE 0
 
   839 jump *label189 notEqual *tmp303 0
   840 op sub .CHANGE .CHANGE 1
   841 ucontrol flag 1
-    * jump *label190 always
   842 label *label189
   843 label *label190
-    * jump *label188 always
   844 label *label187
   845 label *label188
   846 sensor *tmp306 @unit @controller
 
   855 jump *label199 greaterThan *tmp318 .DISCARD_UNIT_MAX_ITEMS
   856 op add .CHANGE .CHANGE 1
   857 set :state 6
-    * jump *label200 always
   858 label *label199
   859 label *label200
-    * jump *label198 always
   860 label *label197
   861 label *label198
-    * jump *label196 always
   862 label *label195
   863 label *label196
   864 jump *label201 notEqual :state 1
 
   877 ucontrol within .CORE_X .CORE_Y 8 *tmp330
   878 jump *label209 equal *tmp330 false
   879 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label210 always
   880 label *label209
   881 label *label210
   882 print "[]"
 
   889 label *label208
   890 label *label206
   891 label *label204
-    * jump *label202 always
   892 label *label201
   893 label *label202
   894 jump *label211 notEqual :state 2
 
   928 label *label217
   929 label *label215
   930 label *label214
-    * jump *label212 always
   931 label *label211
   932 label *label212
   933 jump *label218 notEqual :state 3
 
   935 op sub :max_load *tmp347 .LOAD_LEVEL
   936 jump *label220 lessThan :max_load .LOAD_PACK
   937 ucontrol itemTake .SRC .ITEM :max_load
-    * jump *label221 always
   938 label *label220
   939 label *label221
   940 sensor *tmp351 @unit @totalItems
 
   950 op mul *tmp354 :loop_time_ms .SRC_REMOTE_WAIT
   951 op add :remote_wait_time :remote_wait_time *tmp354
   952 label *label223
-    * jump *label219 always
   953 label *label218
   954 label *label219
   955 jump *label224 notEqual :state 4
 
   992 label *label230
   993 label *label228
   994 label *label227
-    * jump *label225 always
   995 label *label224
   996 label *label225
   997 jump *label231 notEqual :state 5
 
   999 op sub :max_drop .DROP_LEVEL *tmp371
  1000 jump *label233 lessThan :max_drop .DROP_PACK
  1001 ucontrol itemDrop .DST :max_drop
-    * jump *label234 always
  1002 label *label233
  1003 label *label234
  1004 sensor *tmp375 @unit @totalItems
 
  1044 op mul *tmp387 :loop_time_ms .DST_REMOTE_WAIT
  1045 op add :remote_wait_time :remote_wait_time *tmp387
  1046 label *label236
-    * jump *label232 always
  1047 label *label231
  1048 label *label232
  1049 sensor :items @unit @totalItems
 
  1059 jump *label246 equal *tmp394 false
  1060 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1061 sensor :items @unit @totalItems
-    * jump *label247 always
  1062 label *label246
  1063 label *label247
  1064 jump *label245 always
 
  1066 ucontrol itemDrop @air .UNIT_CAPACITY
  1067 sensor :items @unit @totalItems
  1068 label *label245
-    * jump *label243 always
  1069 label *label242
  1070 label *label243
  1071 jump *label248 greaterThan :items .PARK_ITEM_LIMIT
  1072 ucontrol move .PARK_X .PARK_Y
  1073 set :state .S_UNUSED
-    * jump *label249 always
  1074 label *label248
  1075 label *label249
  1076 jump *label241 always
 
  1080 print :items
  1081 print .ITEM_ICON
  1082 ucontrol flag :state
-    * jump *label194 always
  1083 label *label193
  1084 label *label194
-    * jump *label192 always
  1085 label *label191
  1086 label *label192
  1087 label *label78

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
   558 op idiv *tmp188 :turnaround_ms 100
   559 op div :turnaround_str *tmp188 10
   560 op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms
-    * op mul *tmp191 :items_per_ms_unit 60000
-    * op floor :items_per_min_unit *tmp191
+  561 op idiv :items_per_min_unit :items_per_ms_unit 0.000016666666666666667
   562 op add *tmp193 :min_level :max_level
   563 op div :this_level *tmp193 2
   564 op sub *tmp195 :last_level :this_level
 
   566 op div :corr_per_ms :corr :elapsed_ms
   567 set :last_level :this_level
   568 op add :total_flow_per_ms :items_per_ms :corr_per_ms
-    * op mul *tmp199 60000 :corr_per_ms
-    * op floor :corr_per_min *tmp199
+  569 op idiv :corr_per_min :corr_per_ms 0.000016666666666666667
   570 jump *label138 lessThan :corr_per_min 0
   571 set *tmp202 "[]([green]+"
   572 jump *label139 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    30 set .TRIGGER_LEVEL 0.9
    31 op mul .S_UNUSED -1 HOUSEKEEPING
    32 set .STATE_LIMIT null
-    * set .ITEM_ICON .STATE_LIMIT
-    * set .ITEM .ITEM_ICON
-    * set .CORE_Y .ITEM
-    * set .CORE_X .CORE_Y
-    * set .CONTAINER_INDEX .CORE_X
+   33 set .ITEM_ICON null
+   34 set .ITEM .STATE_LIMIT
+   35 set .CORE_Y .ITEM_ICON
+   36 set .CORE_X .ITEM
+   37 set .CONTAINER_INDEX .CORE_Y
    38 set .LOOPS 1
-    * op mul *tmp3 .LOOPS 1000
-    * op div .LOOPS_TICKS_TO_MS *tmp3 60
+   39 op mul *tmp3 1 1000
+   40 op div .LOOPS_TICKS_TO_MS 1000 60
    41 set .INC_OVERALLOCATION OVERALLOCATION_LOW
    42 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    43 set .TRIGGER_BOOST 2
 
   153 label *label44
   154 jump *label43 always
   155 label *label45
-    * ucontrol flag :flag
+  156 ucontrol flag .QUERY_FLAG
   157 label *label46
   158 op equal *tmp46 :flag .QUERY_FLAG
   159 sensor *tmp47 @unit @dead
 
   209 set .DROP_TO_CORE false
   210 label *label34
   211 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  212 sensor :sorter_type sorter1 @type
   213 label *label58
   214 op notEqual *tmp67 :sorter_type @sorter
   215 op notEqual *tmp68 :sorter_type @inverted-sorter
 
   224 label *label62
   225 printflush message1
   226 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  227 sensor :sorter_type sorter1 @type
   228 label *label59
   229 jump *label58 always
   230 label *label60
 
   232 set .SHOW_REMOTE_LEVEL true
   233 set .SRC .CORE
   234 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  235 sensor :src_capacity .CORE @itemCapacity
+  236 sensor :dst_capacity .CONTAINER @itemCapacity
   237 op sub *tmp77 100 .EFF_REMOTE_LIMIT
   238 op mul *tmp78 :src_capacity *tmp77
   239 op idiv .LOAD_LEVEL *tmp78 100
 
   241 op idiv .DROP_LEVEL *tmp80 100
   242 set .LOCAL_MARGIN .DROP_LEVEL
   243 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op sub *tmp82 1 .TRIGGER_LEVEL
-    * op mul .LOW_LEVEL_TRIGGER :dst_capacity *tmp82
+  244 op sub *tmp82 1 0.9
+  245 op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998
   246 set .HIGH_LEVEL_TRIGGER :dst_capacity
   247 set .FLOW_CORR_SIGN 1
   248 set .SRC_REMOTE_WAIT 1
 
   259 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   260 set .SRC .CONTAINER
   261 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  262 sensor :src_capacity .CONTAINER @itemCapacity
+  263 sensor :dst_capacity .CORE @itemCapacity
   264 op sub *tmp89 100 .EFF_LOCAL_LIMIT
   265 op mul *tmp90 :src_capacity *tmp89
   266 op idiv .LOAD_LEVEL *tmp90 100
 
   271 op add .DROP_LEVEL *tmp93 *tmp95
   272 set .LOCAL_MARGIN .LOAD_LEVEL
   273 set .REMOTE_MARGIN .DROP_LEVEL
-    * op mul .HIGH_LEVEL_TRIGGER :src_capacity .TRIGGER_LEVEL
+  274 op mul .HIGH_LEVEL_TRIGGER :src_capacity 0.9
   275 set .LOW_LEVEL_TRIGGER 0
   276 set .FLOW_CORR_SIGN -1
   277 set .SRC_REMOTE_WAIT 0
 
   302 op sub *tmp110 .DST_Y .SRC_Y
   303 op len *tmp111 *tmp109 *tmp110
   304 op sub *tmp112 *tmp111 6
-    * op sub .DISTANCE *tmp112 8
+  305 op sub .DISTANCE *tmp111 14
   306 op max *tmp114 .DISTANCE 10
   307 op mul *tmp115 2 *tmp114
   308 op div .TRAVEL_TIME *tmp115 .SPEED
 
   336 set :elapsed_str "--"
   337 set :wait_time_str 0
   338 set :wait_time 0
-    * set :transfers :wait_time
-    * set :transferred :transfers
-    * set :total_flow_2 :transferred
-    * set :total_flow_1 :total_flow_2
-    * set :remote_wait_time :total_flow_1
-    * set :min_level :remote_wait_time
-    * set :max_level :min_level
-    * set :loop_time_ms :max_level
-    * set :last_level :loop_time_ms
-    * jump *label75 equal .EFF_AUTO_ALLOCATION false
+  339 set :transfers 0
+  340 set :transferred :wait_time
+  341 set :total_flow_2 :transfers
+  342 set :total_flow_1 :transferred
+  343 set :remote_wait_time :total_flow_2
+  344 set :min_level :total_flow_1
+  345 set :max_level :remote_wait_time
+  346 set :loop_time_ms :min_level
+  347 set :last_level :max_level
+  348 jump *label75 equal AUTO_ALLOCATION false
   349 set .CORR_SIGN "[]([green]+"
   350 set :corr_per_min 0
   351 set .SPEED_UNIT_TXT "[])/min"
 
   435 label *label99
   436 set .LAST_ITEM .ITEM
   437 set :itemTypeToIcon:itemType .ITEM
-    * sensor *tmp160 :itemTypeToIcon:itemType @id
+  438 sensor *tmp160 .ITEM @id
   439 jump *label102 notEqual *tmp160 14
   440 label *label103
   441 set *tmp159 "[]"
 
   520 label *label101
   521 set *tmp158 *tmp159
   522 label *label100
-    * set .ITEM_ICON *tmp158
+  523 set .ITEM_ICON *tmp159
   524 set .STATE_LIMIT 1
   525 sensor :last_level .CONTAINER .ITEM
   526 set :min_level 999999
 
   552 set :transfers 0
   553 jump *label136 equal .EFF_AUTO_ALLOCATION false
   554 set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] ==="
-    * op mul *tmp185 .LOOPS_TICKS_TO_MS :loop_time
+  555 op mul *tmp185 16.666666666666668 :loop_time
   556 op add :turnaround_ms .TRAVEL_TIME *tmp185
   557 op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION
   558 op idiv *tmp188 :turnaround_ms 100
 
   588 set :total_flow_2 :total_flow_1
   589 set :total_flow_1 :total_flow_per_ms
   590 op add *tmp212 :total_flow_3 :total_flow_2
-    * op add *tmp213 *tmp212 :total_flow_1
+  591 op add *tmp213 *tmp212 :total_flow_per_ms
   592 op div :total_flow_per_ms *tmp213 3
   593 label *label144
   594 label *label145
   595 op div *tmp215 :total_flow_per_ms :items_per_ms_unit
-    * op add *tmp216 *tmp215 .INC_OVERALLOCATION
+  596 op add *tmp216 *tmp215 OVERALLOCATION_LOW
   597 op ceil :new_target *tmp216
-    * op mul :level_boost .TRIGGER_BOOST :trigger
+  598 op mul :level_boost 2 :trigger
   599 op add *tmp219 :new_target :level_boost
   600 op min :new_target *tmp219 MAX_UNITS
   601 op sub *tmp221 :new_target :active
   602 op max *tmp222 *tmp221 0
   603 op min :new_change *tmp222 .INC_LIMIT
-    * set .INC_LIMIT .INC_MAX
+  604 set .INC_LIMIT 6
   605 op lessThanEq *tmp224 :new_change 0
-    * op mul .DEC_LIMIT *tmp224 .DEC_MAX
+  606 op mul .DEC_LIMIT *tmp224 -1
   607 jump *label143 always
   608 label *label142
   609 op idiv *tmp226 :wait_time .WAIT_LIMIT
   610 op mul *tmp227 -1 *tmp226
   611 op max :new_change *tmp227 .DEC_LIMIT
   612 op greaterThanEq *tmp229 :new_change 0
-    * op mul .INC_LIMIT *tmp229 .INC_MAX
-    * set .DEC_LIMIT .DEC_MAX
+  613 op mul .INC_LIMIT *tmp229 6
+  614 set .DEC_LIMIT -1
   615 label *label143
   616 op add *tmp231 :active :new_change
   617 op max .TARGET *tmp231 1
 
   660 jump *label160 always
   661 label *label159
   662 set .DST .CONTAINER
-    * sensor :findAnotherContainer:dst_capacity .DST @itemCapacity
+  663 sensor :findAnotherContainer:dst_capacity .CONTAINER @itemCapacity
   664 op mul *tmp255 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
   665 op idiv .DROP_LEVEL *tmp255 100
   666 set .LOCAL_MARGIN .DROP_LEVEL
-    * op sub *tmp257 1 .TRIGGER_LEVEL
-    * op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity *tmp257
+  667 op sub *tmp257 1 0.9
+  668 op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity 0.09999999999999998
   669 set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
-    * sensor .DST_X .DST @x
-    * sensor .DST_Y .DST @y
+  670 sensor .DST_X .CONTAINER @x
+  671 sensor .DST_Y .CONTAINER @y
   672 op sub *tmp261 .DST_X .SRC_X
   673 op sub *tmp262 .DST_Y .SRC_Y
   674 op len *tmp263 *tmp261 *tmp262
   675 op sub *tmp264 *tmp263 6
-    * op sub .DISTANCE *tmp264 8
+  676 op sub .DISTANCE *tmp263 14
   677 op max *tmp266 .DISTANCE 10
   678 op mul *tmp267 2 *tmp266
   679 op div .TRAVEL_TIME *tmp267 .SPEED
 
   682 label *label160
   683 set *tmp241 :findAnotherContainer:min_level
   684 jump *label150 always
-    * set *tmp241 null
   685 label *label150
-    * set :this_level *tmp241
-    * set :last_level :this_level
+  686 set :this_level :findAnotherContainer:min_level
+  687 set :last_level *tmp241
   688 label *label148
   689 label *label149
   690 label *label146
 
   703 print "["
   704 print "]"
   705 print .DIRECTION
-    * print .LINK_TXT
+  706 print *tmp101
   707 print .AUTO_ALLOCATION_TXT
   708 jump *label163 lessThanEq .TARGET 0
   709 jump *label165 lessThan :active .TARGET
 
   899 set :printUnitInfo:x .SRC_X
   900 set :printUnitInfo:y .SRC_Y
   901 sensor *tmp338 @unit @x
-    * op sub *tmp339 :printUnitInfo:x *tmp338
+  902 op sub *tmp339 .SRC_X *tmp338
   903 sensor *tmp340 @unit @y
-    * op sub *tmp341 :printUnitInfo:y *tmp340
+  904 op sub *tmp341 .SRC_Y *tmp340
   905 op len *tmp342 *tmp339 *tmp341
   906 op idiv *tmp343 *tmp342 .SPEED_SEC
   907 op div *tmp344 *tmp343 10
 
   911 print *tmp344
   912 print " "
   913 print "sec[] to "
-    * print :printUnitInfo:name
+  914 print "source"
   915 print ":"
   916 print " [green]"
   917 jump *label217 always
 
   919 print "[]"
   920 print "\n"
   921 print "Going to "
-    * print :printUnitInfo:name
+  922 print "source"
   923 print ":"
   924 print " [green]"
   925 label *label217
 
   963 set :printUnitInfo.1:x .DST_X
   964 set :printUnitInfo.1:y .DST_Y
   965 sensor *tmp362 @unit @x
-    * op sub *tmp363 :printUnitInfo.1:x *tmp362
+  966 op sub *tmp363 .DST_X *tmp362
   967 sensor *tmp364 @unit @y
-    * op sub *tmp365 :printUnitInfo.1:y *tmp364
+  968 op sub *tmp365 .DST_Y *tmp364
   969 op len *tmp366 *tmp363 *tmp365
   970 op idiv *tmp367 *tmp366 .SPEED_SEC
   971 op div *tmp368 *tmp367 10
 
   975 print *tmp368
   976 print " "
   977 print "sec[] to "
-    * print :printUnitInfo.1:name
+  978 print "destination"
   979 print ":"
   980 print " [green]"
   981 jump *label230 always
 
   983 print "[]"
   984 print "\n"
   985 print "Going to "
-    * print :printUnitInfo.1:name
+  986 print "destination"
   987 print ":"
   988 print " [green]"
   989 label *label230
 
  1006 set :printUnitInfo.2:x .SRC_X
  1007 set :printUnitInfo.2:y .SRC_Y
  1008 sensor *tmp380 @unit @x
-    * op sub *tmp381 :printUnitInfo.2:x *tmp380
+ 1009 op sub *tmp381 .SRC_X *tmp380
  1010 sensor *tmp382 @unit @y
-    * op sub *tmp383 :printUnitInfo.2:y *tmp382
+ 1011 op sub *tmp383 .SRC_Y *tmp382
  1012 op len *tmp384 *tmp381 *tmp383
  1013 op idiv *tmp385 *tmp384 .SPEED_SEC
  1014 op div *tmp386 *tmp385 10
 
  1018 print *tmp386
  1019 print " "
  1020 print "sec[] to "
-    * print :printUnitInfo.2:name
+ 1021 print "source"
  1022 print ":"
  1023 print " [green]"
  1024 jump *label239 always
 
  1026 print "[]"
  1027 print "\n"
  1028 print "Going to "
-    * print :printUnitInfo.2:name
+ 1029 print "source"
  1030 print ":"
  1031 print " [green]"
  1032 label *label239

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-25 instructions):
 
    27 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
    28 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    29 set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION
-    * set .TRIGGER_LEVEL 0.9
    30 op mul .S_UNUSED -1 HOUSEKEEPING
    31 set .STATE_LIMIT null
    32 set .ITEM_ICON null
-    * set .ITEM .STATE_LIMIT
-    * set .CORE_Y .ITEM_ICON
-    * set .CORE_X .ITEM
-    * set .CONTAINER_INDEX .CORE_Y
-    * set .LOOPS 1
-    * op mul *tmp3 1 1000
-    * op div .LOOPS_TICKS_TO_MS 1000 60
-    * set .INC_OVERALLOCATION OVERALLOCATION_LOW
+   33 set .ITEM null
+   34 set .CORE_Y null
+   35 set .CORE_X .STATE_LIMIT
+   36 set .CONTAINER_INDEX .ITEM_ICON
    37 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
-    * set .TRIGGER_BOOST 2
-    * set .INC_MAX 6
-    * set .DEC_MAX -1
    38 ubind UNIT
    39 label *label14
    40 jump *label16 notEqual @unit null
 
   233 op idiv .DROP_LEVEL *tmp80 100
   234 set .LOCAL_MARGIN .DROP_LEVEL
   235 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op sub *tmp82 1 0.9
   236 op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998
   237 set .HIGH_LEVEL_TRIGGER :dst_capacity
   238 set .FLOW_CORR_SIGN 1
 
   281 label *label69
   282 set *tmp101 LINK_ID
   283 label *label70
-    * set .LINK_TXT *tmp101
   284 op sub *tmp102 :src_capacity .LOAD_LEVEL
   285 op min .LOAD_PACK .UNIT_CAPACITY *tmp102
   286 op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL
 
   291 op sub *tmp109 .DST_X .SRC_X
   292 op sub *tmp110 .DST_Y .SRC_Y
   293 op len *tmp111 *tmp109 *tmp110
-    * op sub *tmp112 *tmp111 6
   294 op sub .DISTANCE *tmp111 14
   295 op max *tmp114 .DISTANCE 10
   296 op mul *tmp115 2 *tmp114
 
   326 set :wait_time_str 0
   327 set :wait_time 0
   328 set :transfers 0
-    * set :transferred :wait_time
-    * set :total_flow_2 :transfers
-    * set :total_flow_1 :transferred
-    * set :remote_wait_time :total_flow_2
-    * set :min_level :total_flow_1
-    * set :max_level :remote_wait_time
-    * set :loop_time_ms :min_level
-    * set :last_level :max_level
+  329 set :transferred 0
+  330 set :total_flow_2 0
+  331 set :total_flow_1 :wait_time
+  332 set :remote_wait_time :transfers
+  333 set :min_level :transferred
+  334 set :max_level :total_flow_2
+  335 set :loop_time_ms :total_flow_1
+  336 set :last_level :remote_wait_time
   337 jump *label75 equal AUTO_ALLOCATION false
   338 set .CORR_SIGN "[]([green]+"
   339 set :corr_per_min 0
 
   423 jump *label97 always
   424 label *label99
   425 set .LAST_ITEM .ITEM
-    * set :itemTypeToIcon:itemType .ITEM
   426 sensor *tmp160 .ITEM @id
   427 jump *label102 notEqual *tmp160 14
   428 label *label103
 
   506 label *label132
   507 set *tmp159 null
   508 label *label101
-    * set *tmp158 *tmp159
   509 label *label100
   510 set .ITEM_ICON *tmp159
   511 set .STATE_LIMIT 1
 
   651 op mul *tmp255 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
   652 op idiv .DROP_LEVEL *tmp255 100
   653 set .LOCAL_MARGIN .DROP_LEVEL
-    * op sub *tmp257 1 0.9
   654 op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity 0.09999999999999998
   655 set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
   656 sensor .DST_X .CONTAINER @x
 
   658 op sub *tmp261 .DST_X .SRC_X
   659 op sub *tmp262 .DST_Y .SRC_Y
   660 op len *tmp263 *tmp261 *tmp262
-    * op sub *tmp264 *tmp263 6
   661 op sub .DISTANCE *tmp263 14
   662 op max *tmp266 .DISTANCE 10
   663 op mul *tmp267 2 *tmp266
 
   668 set *tmp241 :findAnotherContainer:min_level
   669 jump *label150 always
   670 label *label150
-    * set :this_level :findAnotherContainer:min_level
-    * set :last_level *tmp241
+  671 set :last_level :findAnotherContainer:min_level
   672 label *label148
   673 label *label149
   674 label *label146
 
   879 set :state 3
   880 jump *label214 always
   881 label *label213
-    * set :printUnitInfo:name "source"
-    * set :printUnitInfo:x .SRC_X
-    * set :printUnitInfo:y .SRC_Y
   882 sensor *tmp338 @unit @x
   883 op sub *tmp339 .SRC_X *tmp338
   884 sensor *tmp340 @unit @y
 
   940 set :state 5
   941 jump *label227 always
   942 label *label226
-    * set :printUnitInfo.1:name "destination"
-    * set :printUnitInfo.1:x .DST_X
-    * set :printUnitInfo.1:y .DST_Y
   943 sensor *tmp362 @unit @x
   944 op sub *tmp363 .DST_X *tmp362
   945 sensor *tmp364 @unit @y
 
   980 jump *label235 greaterThan *tmp375 0
   981 set :state 2
   982 ucontrol approach .SRC_X .SRC_Y 6
-    * set :printUnitInfo.2:name "source"
-    * set :printUnitInfo.2:x .SRC_X
-    * set :printUnitInfo.2:y .SRC_Y
   983 sensor *tmp380 @unit @x
   984 op sub *tmp381 .SRC_X *tmp380
   985 sensor *tmp382 @unit @y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
    32 set .ITEM_ICON null
    33 set .ITEM null
    34 set .CORE_Y null
-    * set .CORE_X .STATE_LIMIT
-    * set .CONTAINER_INDEX .ITEM_ICON
+   35 set .CORE_X null
+   36 set .CONTAINER_INDEX null
    37 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    38 ubind UNIT
    39 label *label14
 
   328 set :transfers 0
   329 set :transferred 0
   330 set :total_flow_2 0
-    * set :total_flow_1 :wait_time
-    * set :remote_wait_time :transfers
-    * set :min_level :transferred
-    * set :max_level :total_flow_2
-    * set :loop_time_ms :total_flow_1
-    * set :last_level :remote_wait_time
+  331 set :total_flow_1 0
+  332 set :remote_wait_time 0
+  333 set :min_level 0
+  334 set :max_level 0
+  335 set :loop_time_ms :wait_time
+  336 set :last_level :transfers
   337 jump *label75 equal AUTO_ALLOCATION false
   338 set .CORR_SIGN "[]([green]+"
   339 set :corr_per_min 0
 
   665 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   666 op add .MESSAGE_TIMEOUT @tick 600
   667 label *label160
-    * set *tmp241 :findAnotherContainer:min_level
   668 jump *label150 always
   669 label *label150
   670 set :last_level :findAnotherContainer:min_level

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4:
 
   332 set :remote_wait_time 0
   333 set :min_level 0
   334 set :max_level 0
-    * set :loop_time_ms :wait_time
-    * set :last_level :transfers
+  335 set :loop_time_ms 0
+  336 set :last_level 0
   337 jump *label75 equal AUTO_ALLOCATION false
   338 set .CORR_SIGN "[]([green]+"
   339 set :corr_per_min 0

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
   133 print "."
   134 print ".."
   135 printflush message1
+  136 op add .QUERY_FLAG 99999900 LINK_ID
   137 label *label40
   138 jump *label42 notEqual .CORE null
-    * op add .QUERY_FLAG 99999900 LINK_ID
   139 set :flag .QUERY_FLAG
   140 ubind UNIT
   141 label *label43

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-2 instructions):
 
    38 ubind UNIT
    39 label *label14
    40 jump *label16 notEqual @unit null
+   41 label *label250
    42 print "[salmon]No unit of type "
    43 print UNIT
    44 print " "
 
    46 printflush message1
    47 ubind UNIT
    48 label *label15
-    * jump *label14 always
+   49 jump *label250 equal @unit null
    50 label *label16
    51 set :first_unit @unit
    52 sensor *tmp8 @unit @speed
 
    84 set :n @links
    85 label *label25
    86 jump *label27 lessThanEq :n 0
+   87 label *label251
    88 op sub :n :n 1
    89 getlink :block :n
    90 sensor *tmp29 :block @type
 
    97 label *label29
    98 label *label28
    99 label *label26
-    * jump *label25 always
+  100 jump *label251 greaterThan :n 0
   101 label *label27
   102 jump *label31 notEqual .CONTAINER null
   103 print "[salmon]No vault or container."
 
   112 set .CORE null
   113 jump *label33 notEqual LINK_ID 0
   114 label *label35
-    * jump *label37 notEqual .CORE null
+  115 label *label252
   116 print "[green]Locating core..."
   117 printflush message1
   118 ubind UNIT
 
   123 label *label38
   124 label *label39
   125 label *label36
-    * jump *label35 always
+  126 jump *label252 equal .CORE null
   127 label *label37
   128 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   129 op equal .DROP_TO_CORE DROP_TO_AIR false
 
   137 printflush message1
   138 op add .QUERY_FLAG 99999900 LINK_ID
   139 label *label40
-    * jump *label42 notEqual .CORE null
+  140 label *label253
   141 set :flag .QUERY_FLAG
   142 ubind UNIT
   143 label *label43
 
   191 label *label50
   192 ucontrol flag .S_UNUSED
   193 label *label41
-    * jump *label40 always
+  194 jump *label253 equal .CORE null
   195 label *label42
   196 jump *label56 equal DROP_TO_AIR false
   197 set *tmp65 .UNIT_CAPACITY
 
   352 ubind UNIT
   353 label *label80
   354 jump *label82 notEqual @unit null
+  355 label *label254
   356 print "No unit of type "
   357 print UNIT
   358 print " "
 
   360 printflush message1
   361 ubind UNIT
   362 label *label81
-    * jump *label80 always
+  363 jump *label254 equal @unit null
   364 label *label82
   365 sensor *tmp132 switch1 @enabled
   366 jump *label83 equal *tmp132 false
 
   419 jump *label95 equal .ITEM .LAST_ITEM
   420 label *label97
   421 jump *label99 notEqual .ITEM null
+  422 label *label255
   423 print "[salmon]No item type selected for transport.[]"
   424 printflush message1
   425 sensor .ITEM .SORTER @config
   426 label *label98
-    * jump *label97 always
+  427 jump *label255 equal .ITEM null
   428 label *label99
   429 set .LAST_ITEM .ITEM
   430 sensor *tmp160 .ITEM @id
 
   627 set :findAnotherContainer:n @links
   628 label *label151
   629 jump *label153 lessThanEq :findAnotherContainer:n 0
+  630 label *label256
   631 op sub :findAnotherContainer:n :findAnotherContainer:n 1
   632 getlink :findAnotherContainer:block :findAnotherContainer:n
   633 sensor *tmp247 :findAnotherContainer:block @type
 
   645 label *label155
   646 label *label154
   647 label *label152
-    * jump *label151 always
+  648 jump *label256 greaterThan :findAnotherContainer:n 0
   649 label *label153
   650 jump *label159 notEqual .CONTAINERS 0
   651 set .CONTAINER @this

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-9 instructions):
 
   193 label *label41
   194 jump *label253 equal .CORE null
   195 label *label42
-    * jump *label56 equal DROP_TO_AIR false
-    * set *tmp65 .UNIT_CAPACITY
+  196 set .DISCARD_UNIT_MAX_ITEMS 0
+  197 jump *label57 equal DROP_TO_AIR false
+  198 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   199 jump *label57 always
-    * label *label56
-    * set *tmp65 0
   200 label *label57
-    * set .DISCARD_UNIT_MAX_ITEMS *tmp65
   201 set .DROP_TO_CORE false
   202 label *label34
   203 set .SORTER sorter1
 
   238 set .FLOW_CORR_SIGN 1
   239 set .SRC_REMOTE_WAIT 1
   240 set .DST_REMOTE_WAIT 0
-    * jump *label65 notEqual LINK_ID 0
-    * set *tmp85 " from core"
+  241 set .DIRECTION " from vault #"
+  242 jump *label66 notEqual LINK_ID 0
+  243 set .DIRECTION " from core"
   244 jump *label66 always
-    * label *label65
-    * set *tmp85 " from vault #"
   245 label *label66
-    * set .DIRECTION *tmp85
   246 jump *label64 always
   247 label *label63
   248 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   265 set .FLOW_CORR_SIGN -1
   266 set .SRC_REMOTE_WAIT 0
   267 set .DST_REMOTE_WAIT 1
-    * jump *label67 notEqual LINK_ID 0
-    * set *tmp99 " to core"
+  268 set .DIRECTION " to vault #"
+  269 jump *label68 notEqual LINK_ID 0
+  270 set .DIRECTION " to core"
   271 jump *label68 always
-    * label *label67
-    * set *tmp99 " to vault #"
   272 label *label68
-    * set .DIRECTION *tmp99
   273 label *label64
-    * jump *label69 notEqual LINK_ID 0
+  274 set *tmp101 LINK_ID
+  275 jump *label70 notEqual LINK_ID 0
   276 set *tmp101 ""
   277 jump *label70 always
-    * label *label69
-    * set *tmp101 LINK_ID
   278 label *label70
   279 op sub *tmp102 :src_capacity .LOAD_LEVEL
   280 op min .LOAD_PACK .UNIT_CAPACITY *tmp102
 
   292 op div .TRAVEL_TIME *tmp115 .SPEED
   293 sensor *tmp117 .CONTAINER @x
   294 jump *label71 greaterThanEq *tmp117 .CORE_X
-    * set *tmp119 15
+  295 op add .PARK_X .CORE_X 15
   296 jump *label72 always
   297 label *label71
-    * set *tmp119 -15
+  298 op add .PARK_X .CORE_X -15
   299 label *label72
-    * op add .PARK_X .CORE_X *tmp119
   300 sensor *tmp121 .CONTAINER @y
   301 jump *label73 greaterThanEq *tmp121 .CORE_Y
-    * set *tmp123 15
+  302 op add .PARK_Y .CORE_Y 15
   303 jump *label74 always
   304 label *label73
-    * set *tmp123 -15
+  305 op add .PARK_Y .CORE_Y -15
   306 label *label74
-    * op add .PARK_Y .CORE_Y *tmp123
   307 op equal *tmp125 LINK_ID 0
   308 op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY
   309 set .TRANSFER_START @tick
 
   385 set .CORR_SIGN "[]"
   386 set :corr_per_min ""
   387 set .SPEED_UNIT_TXT "/min"
-    * jump *label89 notEqual .TARGET 0
-    * set *tmp145 "\n=== [salmon]Transport deactivated[] ==="
+  388 set .AUTO_ALLOCATION_TXT ""
+  389 jump *label90 notEqual .TARGET 0
+  390 set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivated[] ==="
   391 jump *label90 always
-    * label *label89
-    * set *tmp145 ""
   392 label *label90
-    * set .AUTO_ALLOCATION_TXT *tmp145
   393 label *label88
   394 set .WAIT_LIMIT 30000
   395 label *label85
 
   547 set :last_level :this_level
   548 op add :total_flow_per_ms :items_per_ms :corr_per_ms
   549 op idiv :corr_per_min :corr_per_ms 0.000016666666666666667
-    * jump *label138 lessThan :corr_per_min 0
-    * set *tmp202 "[]([green]+"
+  550 set .CORR_SIGN "[]([green]"
+  551 jump *label139 lessThan :corr_per_min 0
+  552 set .CORR_SIGN "[]([green]+"
   553 jump *label139 always
-    * label *label138
-    * set *tmp202 "[]([green]"
   554 label *label139
-    * set .CORR_SIGN *tmp202
   555 set .SPEED_UNIT_TXT "[])/min"
   556 jump *label140 equal :alive false
   557 op lessThan *tmp204 :min_level .LOW_LEVEL_TRIGGER
 
   834 label *label195
   835 label *label196
   836 jump *label201 notEqual :state 1
+  837 set :state 2
   838 sensor *tmp323 @unit @totalItems
-    * jump *label203 notEqual *tmp323 0
-    * set :state 2
-    * jump *label204 always
+  839 jump *label204 equal *tmp323 0
   840 label *label203
+  841 set :state 4
   842 sensor *tmp326 @unit @firstItem
-    * jump *label205 notEqual *tmp326 .ITEM
-    * set :state 4
-    * jump *label206 always
+  843 jump *label206 equal *tmp326 .ITEM
   844 label *label205
   845 jump *label207 equal .DROP_TO_CORE false
   846 ucontrol approach .CORE_X .CORE_Y 6

Modifications by Replicate loop condition at line 156:9 (+1 instructions):
 
   143 label *label43
   144 sensor *tmp44 @unit @controlled
   145 jump *label45 equal *tmp44 0
+  146 label *label257
   147 ubind UNIT
   148 label *label44
-    * jump *label43 always
+  149 sensor *tmp44 @unit @controlled
+  150 jump *label257 notEqual *tmp44 0
   151 label *label45
   152 ucontrol flag .QUERY_FLAG
   153 label *label46

Modifications by Replicate loop condition at line 160:9 (+4 instructions):
 
   156 op equal *tmp48 *tmp47 0
   157 op land *tmp49 *tmp46 *tmp48
   158 jump *label48 equal *tmp49 false
+  159 label *label258
   160 ucontrol stop
   161 sensor :flag @unit @flag
   162 label *label47
-    * jump *label46 always
+  163 op equal *tmp46 :flag .QUERY_FLAG
+  164 sensor *tmp47 @unit @dead
+  165 op equal *tmp48 *tmp47 0
+  166 op land *tmp49 *tmp46 *tmp48
+  167 jump *label258 notEqual *tmp49 false
   168 label *label48
   169 jump *label49 equal :flag .QUERY_FLAG
   170 op idiv :position :flag 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   151 label *label45
   152 ucontrol flag .QUERY_FLAG
   153 label *label46
-    * op equal *tmp46 :flag .QUERY_FLAG
+  154 op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
   155 sensor *tmp47 @unit @dead
   156 op equal *tmp48 *tmp47 0
   157 op land *tmp49 *tmp46 *tmp48

Modifications by Replicate loop condition at line 169:13 (+5 instructions):
 
   177 op equal *tmp59 *tmp58 false
   178 op land *tmp60 *tmp57 *tmp59
   179 jump *label53 equal *tmp60 false
+  180 label *label259
   181 ucontrol approach .CORE_X .CORE_Y 6
   182 label *label52
-    * jump *label51 always
+  183 sensor *tmp56 @unit @dead
+  184 op equal *tmp57 *tmp56 0
+  185 ucontrol within .CORE_X .CORE_Y 8 *tmp58
+  186 op equal *tmp59 *tmp58 false
+  187 op land *tmp60 *tmp57 *tmp59
+  188 jump *label259 notEqual *tmp60 false
   189 label *label53
   190 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp62
   191 jump *label54 equal :b_type @vault

Modifications by Replicate loop condition at line 189:1 (+3 instructions):
 
   220 op notEqual *tmp68 :sorter_type @inverted-sorter
   221 op land *tmp69 *tmp67 *tmp68
   222 jump *label60 equal *tmp69 false
+  223 label *label260
   224 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   225 print "\n"
   226 jump *label61 equal .SORTER null
 
   232 set .SORTER sorter1
   233 sensor :sorter_type sorter1 @type
   234 label *label59
-    * jump *label58 always
+  235 op notEqual *tmp67 :sorter_type @sorter
+  236 op notEqual *tmp68 :sorter_type @inverted-sorter
+  237 op land *tmp69 *tmp67 *tmp68
+  238 jump *label260 notEqual *tmp69 false
   239 label *label60
   240 jump *label63 notEqual :sorter_type @sorter
   241 set .SHOW_REMOTE_LEVEL true

Modifications by Convert case at line 704:5 (segments: 4) (+2 instructions):
 
   434 label *label99
   435 set .LAST_ITEM .ITEM
   436 sensor *tmp160 .ITEM @id
-    * jump *label102 notEqual *tmp160 14
+  437 jump *label262 greaterThanEq *tmp160 3
+  438 jump *label263 greaterThanEq *tmp160 1
+  439 jump *label261 lessThan *tmp160 0
+  440 label *label107
+  441 set *tmp159 "[]"
+  442 jump *label101 always
+  443 label *label263
+  444 jump *label113 greaterThanEq *tmp160 2
+  445 label *label111
+  446 set *tmp159 "[]"
+  447 jump *label101 always
+  448 label *label262
+  449 jump *label261 greaterThanEq *tmp160 16
+  450 multijump *label265 *tmp160 3 (m:*label264)
+  451 multilabel *label265 (m:*label264)
+  452 jump *label109 always
+  453 multilabel *label266 (m:*label264)
+  454 jump *label121 always
+  455 multilabel *label267 (m:*label264)
+  456 jump *label105 always
+  457 multilabel *label268 (m:*label264)
+  458 jump *label133 always
+  459 multilabel *label269 (m:*label264)
+  460 jump *label131 always
+  461 multilabel *label270 (m:*label264)
+  462 jump *label123 always
+  463 multilabel *label271 (m:*label264)
+  464 jump *label125 always
+  465 multilabel *label272 (m:*label264)
+  466 jump *label117 always
+  467 multilabel *label273 (m:*label264)
+  468 jump *label115 always
+  469 multilabel *label274 (m:*label264)
+  470 jump *label129 always
+  471 multilabel *label275 (m:*label264)
+  472 jump *label127 always
+  473 multilabel *label276 (m:*label264)
+  474 jump *label103 always
+  475 multilabel *label277 (m:*label264)
+  476 label *label119
+  477 set *tmp159 "[]"
+  478 jump *label101 always
   479 label *label103
   480 set *tmp159 "[]"
   481 jump *label101 always
   482 label *label102
-    * jump *label104 notEqual *tmp160 5
   483 label *label105
   484 set *tmp159 "[]"
   485 jump *label101 always
   486 label *label104
-    * jump *label106 notEqual *tmp160 0
-    * label *label107
-    * set *tmp159 "[]"
-    * jump *label101 always
   487 label *label106
-    * jump *label108 notEqual *tmp160 3
   488 label *label109
   489 set *tmp159 "[]"
   490 jump *label101 always
   491 label *label108
-    * jump *label110 notEqual *tmp160 1
-    * label *label111
-    * set *tmp159 "[]"
-    * jump *label101 always
   492 label *label110
-    * jump *label112 notEqual *tmp160 2
   493 label *label113
   494 set *tmp159 "[]"
   495 jump *label101 always
   496 label *label112
-    * jump *label114 notEqual *tmp160 11
   497 label *label115
   498 set *tmp159 "[]"
   499 jump *label101 always
   500 label *label114
-    * jump *label116 notEqual *tmp160 10
   501 label *label117
   502 set *tmp159 "[]"
   503 jump *label101 always
   504 label *label116
-    * jump *label118 notEqual *tmp160 15
-    * label *label119
-    * set *tmp159 "[]"
-    * jump *label101 always
   505 label *label118
-    * jump *label120 notEqual *tmp160 4
   506 label *label121
   507 set *tmp159 "[]"
   508 jump *label101 always
   509 label *label120
-    * jump *label122 notEqual *tmp160 8
   510 label *label123
   511 set *tmp159 "[]"
   512 jump *label101 always
   513 label *label122
-    * jump *label124 notEqual *tmp160 9
   514 label *label125
   515 set *tmp159 "[]"
   516 jump *label101 always
   517 label *label124
-    * jump *label126 notEqual *tmp160 13
   518 label *label127
   519 set *tmp159 "[]"
   520 jump *label101 always
   521 label *label126
-    * jump *label128 notEqual *tmp160 12
   522 label *label129
   523 set *tmp159 "[]"
   524 jump *label101 always
   525 label *label128
-    * jump *label130 notEqual *tmp160 7
   526 label *label131
   527 set *tmp159 "[]"
   528 jump *label101 always
   529 label *label130
-    * jump *label132 notEqual *tmp160 6
   530 label *label133
   531 set *tmp159 "[]"
   532 jump *label101 always
   533 label *label132
+  534 label *label261
   535 set *tmp159 null
   536 label *label101
   537 label *label100

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-7 instructions):
 
   209 set .DISCARD_UNIT_MAX_ITEMS 0
   210 jump *label57 equal DROP_TO_AIR false
   211 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
-    * jump *label57 always
   212 label *label57
   213 set .DROP_TO_CORE false
   214 label *label34
 
   257 set .DIRECTION " from vault #"
   258 jump *label66 notEqual LINK_ID 0
   259 set .DIRECTION " from core"
-    * jump *label66 always
   260 label *label66
   261 jump *label64 always
   262 label *label63
 
   283 set .DIRECTION " to vault #"
   284 jump *label68 notEqual LINK_ID 0
   285 set .DIRECTION " to core"
-    * jump *label68 always
   286 label *label68
   287 label *label64
   288 set *tmp101 LINK_ID
   289 jump *label70 notEqual LINK_ID 0
   290 set *tmp101 ""
-    * jump *label70 always
   291 label *label70
   292 op sub *tmp102 :src_capacity .LOAD_LEVEL
   293 op min .LOAD_PACK .UNIT_CAPACITY *tmp102
 
   401 set .AUTO_ALLOCATION_TXT ""
   402 jump *label90 notEqual .TARGET 0
   403 set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivated[] ==="
-    * jump *label90 always
   404 label *label90
   405 label *label88
   406 set .WAIT_LIMIT 30000
 
   580 set .CORR_SIGN "[]([green]"
   581 jump *label139 lessThan :corr_per_min 0
   582 set .CORR_SIGN "[]([green]+"
-    * jump *label139 always
   583 label *label139
   584 set .SPEED_UNIT_TXT "[])/min"
   585 jump *label140 equal :alive false
 
   686 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   687 op add .MESSAGE_TIMEOUT @tick 600
   688 label *label160
-    * jump *label150 always
   689 label *label150
   690 set :last_level :findAnotherContainer:min_level
   691 label *label148

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   151 label *label45
   152 ucontrol flag .QUERY_FLAG
   153 label *label46
-    * op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
+  154 set *tmp46 true
   155 sensor *tmp47 @unit @dead
   156 op equal *tmp48 *tmp47 0
   157 op land *tmp49 *tmp46 *tmp48

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   154 set *tmp46 true
   155 sensor *tmp47 @unit @dead
   156 op equal *tmp48 *tmp47 0
-    * op land *tmp49 *tmp46 *tmp48
+  157 op land *tmp49 true *tmp48
   158 jump *label48 equal *tmp49 false
   159 label *label258
   160 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
   151 label *label45
   152 ucontrol flag .QUERY_FLAG
   153 label *label46
-    * set *tmp46 true
   154 sensor *tmp47 @unit @dead
   155 op equal *tmp48 *tmp47 0
   156 op land *tmp49 true *tmp48

Modifications by Iterated phase, If Expression Optimization, pass 2, iteration 1:
 
   302 op max *tmp114 .DISTANCE 10
   303 op mul *tmp115 2 *tmp114
   304 op div .TRAVEL_TIME *tmp115 .SPEED
+  305 op add .PARK_X .CORE_X -15
   306 sensor *tmp117 .CONTAINER @x
-    * jump *label71 greaterThanEq *tmp117 .CORE_X
+  307 jump *label72 greaterThanEq *tmp117 .CORE_X
   308 op add .PARK_X .CORE_X 15
   309 jump *label72 always
-    * label *label71
-    * op add .PARK_X .CORE_X -15
   310 label *label72
+  311 op add .PARK_Y .CORE_Y -15
   312 sensor *tmp121 .CONTAINER @y
-    * jump *label73 greaterThanEq *tmp121 .CORE_Y
+  313 jump *label74 greaterThanEq *tmp121 .CORE_Y
   314 op add .PARK_Y .CORE_Y 15
   315 jump *label74 always
-    * label *label73
-    * op add .PARK_Y .CORE_Y -15
   316 label *label74
   317 op equal *tmp125 LINK_ID 0
   318 op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-2 instructions):
 
   306 sensor *tmp117 .CONTAINER @x
   307 jump *label72 greaterThanEq *tmp117 .CORE_X
   308 op add .PARK_X .CORE_X 15
-    * jump *label72 always
   309 label *label72
   310 op add .PARK_Y .CORE_Y -15
   311 sensor *tmp121 .CONTAINER @y
   312 jump *label74 greaterThanEq *tmp121 .CORE_Y
   313 op add .PARK_Y .CORE_Y 15
-    * jump *label74 always
   314 label *label74
   315 op equal *tmp125 LINK_ID 0
   316 op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1:
 
   153 label *label46
   154 sensor *tmp47 @unit @dead
   155 op equal *tmp48 *tmp47 0
-    * op land *tmp49 true *tmp48
+  156 set *tmp49 *tmp48
   157 jump *label48 equal *tmp49 false
   158 label *label258
   159 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1 (-1 instructions):
 
   152 ucontrol flag .QUERY_FLAG
   153 label *label46
   154 sensor *tmp47 @unit @dead
-    * op equal *tmp48 *tmp47 0
-    * set *tmp49 *tmp48
+  155 op equal *tmp49 *tmp47 0
   156 jump *label48 equal *tmp49 false
   157 label *label258
   158 ucontrol stop

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
    22 set STABILIZATION false
    23 remark "End of configurable options"
    24 printflush null
-    * label *label13
    25 set .MESSAGE ""
    26 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
    27 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
 
    35 set .CONTAINER_INDEX null
    36 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    37 ubind UNIT
-    * label *label14
    38 jump *label16 notEqual @unit null
    39 label *label250
    40 print "[salmon]No unit of type "
 
    43 print "found."
    44 printflush message1
    45 ubind UNIT
-    * label *label15
    46 jump *label250 equal @unit null
    47 label *label16
    48 set :first_unit @unit
 
    60 op land *tmp18 *tmp16 *tmp17
    61 op add .TARGET .TARGET *tmp18
    62 label *label20
-    * label *label21
    63 ubind UNIT
-    * label *label18
    64 op notEqual *tmp19 @unit :first_unit
    65 sensor *tmp20 :first_unit @dead
    66 op equal *tmp21 *tmp20 0
    67 op land *tmp22 *tmp19 *tmp21
    68 jump *label17 notEqual *tmp22 false
-    * label *label19
    69 set .CHANGE 0
    70 set :active .TARGET
    71 set .DEC_LIMIT 0
 
    76 set .CONTAINER null
    77 set .CONTAINERS 0
    78 set :n @links
-    * label *label25
    79 jump *label27 lessThanEq :n 0
    80 label *label251
    81 op sub :n :n 1
 
    88 op add .CONTAINERS .CONTAINERS 1
    89 set .CONTAINER_INDEX :n
    90 label *label29
-    * label *label28
-    * label *label26
    91 jump *label251 greaterThan :n 0
    92 label *label27
    93 jump *label31 notEqual .CONTAINER null
 
    97 label *label31
    98 jump *label24 always
    99 label *label32
-    * label *label23
   100 jump *label22 always
   101 label *label24
   102 set .CORE null
   103 jump *label33 notEqual LINK_ID 0
-    * label *label35
   104 label *label252
   105 print "[green]Locating core..."
   106 printflush message1
 
   110 ulocate building core false @copper .CORE_X .CORE_Y *tmp40 .CORE
   111 ucontrol flag .S_UNUSED
   112 label *label38
-    * label *label39
-    * label *label36
   113 jump *label252 equal .CORE null
-    * label *label37
   114 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   115 op equal .DROP_TO_CORE DROP_TO_AIR false
   116 jump *label34 always
 
   122 print ".."
   123 printflush message1
   124 op add .QUERY_FLAG 99999900 LINK_ID
-    * label *label40
   125 label *label253
   126 set :flag .QUERY_FLAG
   127 ubind UNIT
-    * label *label43
   128 sensor *tmp44 @unit @controlled
   129 jump *label45 equal *tmp44 0
   130 label *label257
   131 ubind UNIT
-    * label *label44
   132 sensor *tmp44 @unit @controlled
   133 jump *label257 notEqual *tmp44 0
   134 label *label45
   135 ucontrol flag .QUERY_FLAG
-    * label *label46
   136 sensor *tmp47 @unit @dead
   137 op equal *tmp49 *tmp47 0
   138 jump *label48 equal *tmp49 false
   139 label *label258
   140 ucontrol stop
   141 sensor :flag @unit @flag
-    * label *label47
   142 op equal *tmp46 :flag .QUERY_FLAG
   143 sensor *tmp47 @unit @dead
   144 op equal *tmp48 *tmp47 0
 
   149 op idiv :position :flag 100
   150 op mod .CORE_X :position @mapw
   151 op idiv .CORE_Y :position @mapw
-    * label *label51
   152 sensor *tmp56 @unit @dead
   153 op equal *tmp57 *tmp56 0
   154 ucontrol within .CORE_X .CORE_Y 8 *tmp58
 
   157 jump *label53 equal *tmp60 false
   158 label *label259
   159 ucontrol approach .CORE_X .CORE_Y 6
-    * label *label52
   160 sensor *tmp56 @unit @dead
   161 op equal *tmp57 *tmp56 0
   162 ucontrol within .CORE_X .CORE_Y 8 *tmp58
 
   176 printflush message2
   177 set .CORE null
   178 label *label54
-    * label *label55
   179 label *label49
-    * label *label50
   180 ucontrol flag .S_UNUSED
-    * label *label41
   181 jump *label253 equal .CORE null
-    * label *label42
   182 set .DISCARD_UNIT_MAX_ITEMS 0
   183 jump *label57 equal DROP_TO_AIR false
   184 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
 
   187 label *label34
   188 set .SORTER sorter1
   189 sensor :sorter_type sorter1 @type
-    * label *label58
   190 op notEqual *tmp67 :sorter_type @sorter
   191 op notEqual *tmp68 :sorter_type @inverted-sorter
   192 op land *tmp69 *tmp67 *tmp68
 
   198 print "Block found: "
   199 print .SORTER
   200 label *label61
-    * label *label62
   201 printflush message1
   202 set .SORTER sorter1
   203 sensor :sorter_type sorter1 @type
-    * label *label59
   204 op notEqual *tmp67 :sorter_type @sorter
   205 op notEqual *tmp68 :sorter_type @inverted-sorter
   206 op land *tmp69 *tmp67 *tmp68
 
   320 label *label76
   321 label *label77
   322 ubind UNIT
-    * label *label80
   323 jump *label82 notEqual @unit null
   324 label *label254
   325 print "No unit of type "
 
   328 print "found."
   329 printflush message1
   330 ubind UNIT
-    * label *label81
   331 jump *label254 equal @unit null
   332 label *label82
   333 sensor *tmp132 switch1 @enabled
 
   342 set .SPEED_UNIT_TXT "/min"
   343 set .WAIT_LIMIT 30000
   344 label *label83
-    * label *label84
   345 sensor *tmp137 switch2 @enabled
   346 jump *label85 equal *tmp137 false
   347 control enabled switch2 false
 
   368 label *label88
   369 set .WAIT_LIMIT 30000
   370 label *label85
-    * label *label86
   371 sensor *tmp146 :first_unit @dead
   372 op equal :alive *tmp146 0
   373 op equal *tmp148 @unit :first_unit
 
   375 jump *label93 notEqual :active 0
   376 print "\n[salmon]No active units.[]"
   377 label *label93
-    * label *label94
   378 printflush message2
   379 set .STATE_LIMIT 6
   380 sensor .ITEM .SORTER @config
   381 jump *label95 equal .ITEM .LAST_ITEM
-    * label *label97
   382 jump *label99 notEqual .ITEM null
   383 label *label255
   384 print "[salmon]No item type selected for transport.[]"
   385 printflush message1
   386 sensor .ITEM .SORTER @config
-    * label *label98
   387 jump *label255 equal .ITEM null
   388 label *label99
   389 set .LAST_ITEM .ITEM
 
   391 jump *label262 greaterThanEq *tmp160 3
   392 jump *label263 greaterThanEq *tmp160 1
   393 jump *label261 lessThan *tmp160 0
-    * label *label107
   394 set *tmp159 "[]"
   395 jump *label101 always
   396 label *label263
   397 jump *label113 greaterThanEq *tmp160 2
-    * label *label111
   398 set *tmp159 "[]"
   399 jump *label101 always
   400 label *label262
 
   425 multilabel *label276 (m:*label264)
   426 jump *label103 always
   427 multilabel *label277 (m:*label264)
-    * label *label119
   428 set *tmp159 "[]"
   429 jump *label101 always
   430 label *label103
   431 set *tmp159 "[]"
   432 jump *label101 always
-    * label *label102
   433 label *label105
   434 set *tmp159 "[]"
   435 jump *label101 always
-    * label *label104
-    * label *label106
   436 label *label109
   437 set *tmp159 "[]"
   438 jump *label101 always
-    * label *label108
-    * label *label110
   439 label *label113
   440 set *tmp159 "[]"
   441 jump *label101 always
-    * label *label112
   442 label *label115
   443 set *tmp159 "[]"
   444 jump *label101 always
-    * label *label114
   445 label *label117
   446 set *tmp159 "[]"
   447 jump *label101 always
-    * label *label116
-    * label *label118
   448 label *label121
   449 set *tmp159 "[]"
   450 jump *label101 always
-    * label *label120
   451 label *label123
   452 set *tmp159 "[]"
   453 jump *label101 always
-    * label *label122
   454 label *label125
   455 set *tmp159 "[]"
   456 jump *label101 always
-    * label *label124
   457 label *label127
   458 set *tmp159 "[]"
   459 jump *label101 always
-    * label *label126
   460 label *label129
   461 set *tmp159 "[]"
   462 jump *label101 always
-    * label *label128
   463 label *label131
   464 set *tmp159 "[]"
   465 jump *label101 always
-    * label *label130
   466 label *label133
   467 set *tmp159 "[]"
   468 jump *label101 always
-    * label *label132
   469 label *label261
   470 set *tmp159 null
   471 label *label101
-    * label *label100
   472 set .ITEM_ICON *tmp159
   473 set .STATE_LIMIT 1
   474 sensor :last_level .CONTAINER .ITEM
   475 set :min_level 999999
   476 set :max_level 0
   477 label *label95
-    * label *label96
   478 sensor :container_items .CONTAINER .ITEM
   479 op min :min_level :min_level :container_items
   480 op max :max_level :max_level :container_items
 
   536 op add *tmp213 *tmp212 :total_flow_per_ms
   537 op div :total_flow_per_ms *tmp213 3
   538 label *label144
-    * label *label145
   539 op div *tmp215 :total_flow_per_ms :items_per_ms_unit
   540 op add *tmp216 *tmp215 OVERALLOCATION_LOW
   541 op ceil :new_target *tmp216
 
   567 set :min_level 999999
   568 set :max_level 0
   569 label *label136
-    * label *label137
   570 op greaterThan *tmp233 .CONTAINERS 1
   571 op equal *tmp234 .SRC .CORE
   572 op land *tmp235 *tmp233 *tmp234
 
   577 set :findAnotherContainer:min_level 999999
   578 set .CONTAINERS 0
   579 set :findAnotherContainer:n @links
-    * label *label151
   580 jump *label153 lessThanEq :findAnotherContainer:n 0
   581 label *label256
   582 op sub :findAnotherContainer:n :findAnotherContainer:n 1
 
   592 set .CONTAINER :findAnotherContainer:block
   593 set .CONTAINER_INDEX :findAnotherContainer:n
   594 label *label157
-    * label *label158
   595 label *label155
-    * label *label154
-    * label *label152
   596 jump *label256 greaterThan :findAnotherContainer:n 0
   597 label *label153
   598 jump *label159 notEqual .CONTAINERS 0
 
   618 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   619 op add .MESSAGE_TIMEOUT @tick 600
   620 label *label160
-    * label *label150
   621 set :last_level :findAnotherContainer:min_level
   622 label *label148
-    * label *label149
   623 label *label146
-    * label *label147
   624 set :wait_time 0
   625 set :remote_wait_time 0
   626 jump *label161 lessThan @tick .MESSAGE_TIMEOUT
   627 set .MESSAGE ""
   628 label *label161
-    * label *label162
   629 label *label134
-    * label *label135
   630 print .MESSAGE
   631 print "Moving [green]"
   632 print .ITEM
 
   665 jump *label167 lessThanEq .CHANGE 0
   666 print "\n[][salmon]Cannot acquire additional units![]"
   667 label *label167
-    * label *label168
   668 label *label163
-    * label *label164
   669 print "\n"
   670 print "[]Local items: [gold]"
   671 print :container_items
 
   675 print "["
   676 print "])"
   677 label *label169
-    * label *label170
   678 jump *label171 equal .SHOW_REMOTE_LEVEL false
   679 sensor :remote_level .CORE .ITEM
   680 print "\n"
 
   686 print "["
   687 print "])"
   688 label *label173
-    * label *label174
   689 label *label171
-    * label *label172
   690 jump *label175 lessThanEq .TARGET 0
   691 print "\n"
   692 print "[]Speed: [green]"
 
   722 print "["
   723 print "] s"
   724 label *label175
-    * label *label176
   725 print "\n"
   726 print "[lightgray]Loop: "
   727 print :loop_time_ms
 
   737 jump *label179 equal *tmp289 0
   738 jump *label79 always
   739 label *label179
-    * label *label180
   740 sensor *tmp292 .DST @dead
   741 jump *label181 equal *tmp292 0
   742 jump *label79 always
   743 label *label181
-    * label *label182
   744 sensor *tmp295 .SORTER @dead
   745 jump *label183 equal *tmp295 0
   746 jump *label79 always
   747 label *label183
-    * label *label184
   748 getlink *tmp298 .CONTAINER_INDEX
   749 jump *label185 equal .CONTAINER *tmp298
   750 jump *label79 always
   751 label *label185
-    * label *label186
   752 label *label91
-    * label *label92
   753 jump *label187 lessThanEq .CHANGE 0
   754 sensor *tmp303 @unit @controlled
   755 jump *label189 notEqual *tmp303 0
   756 op sub .CHANGE .CHANGE 1
   757 ucontrol flag 1
   758 label *label189
-    * label *label190
   759 label *label187
-    * label *label188
   760 sensor *tmp306 @unit @controller
   761 jump *label191 notEqual *tmp306 @this
   762 sensor :state @unit @flag
 
   770 op add .CHANGE .CHANGE 1
   771 set :state 6
   772 label *label199
-    * label *label200
   773 label *label197
-    * label *label198
   774 label *label195
-    * label *label196
   775 jump *label201 notEqual :state 1
   776 set :state 2
   777 sensor *tmp323 @unit @totalItems
   778 jump *label204 equal *tmp323 0
-    * label *label203
   779 set :state 4
   780 sensor *tmp326 @unit @firstItem
   781 jump *label206 equal *tmp326 .ITEM
-    * label *label205
   782 jump *label207 equal .DROP_TO_CORE false
   783 ucontrol approach .CORE_X .CORE_Y 6
   784 ucontrol within .CORE_X .CORE_Y 8 *tmp330
   785 jump *label209 equal *tmp330 false
   786 ucontrol itemDrop .CORE .UNIT_CAPACITY
   787 label *label209
-    * label *label210
   788 print "[]"
   789 print "\n"
   790 print "Unloading previous items: [green]"
 
   796 label *label206
   797 label *label204
   798 label *label201
-    * label *label202
   799 jump *label211 notEqual :state 2
   800 ucontrol approach .SRC_X .SRC_Y 6
   801 ucontrol within .SRC_X .SRC_Y 8 *tmp334
 
   820 print ":"
   821 print " [green]"
   822 jump *label217 always
-    * label *label216
   823 print "[]"
   824 print "\n"
   825 print "Going to "
 
   827 print ":"
   828 print " [green]"
   829 label *label217
-    * label *label215
   830 label *label214
   831 label *label211
-    * label *label212
   832 jump *label218 notEqual :state 3
   833 sensor *tmp347 .SRC .ITEM
   834 op sub :max_load *tmp347 .LOAD_LEVEL
   835 jump *label220 lessThan :max_load .LOAD_PACK
   836 ucontrol itemTake .SRC .ITEM :max_load
   837 label *label220
-    * label *label221
   838 sensor *tmp351 @unit @totalItems
   839 jump *label222 lessThan *tmp351 .UNIT_CAPACITY
   840 set :state 4
 
   849 op add :remote_wait_time :remote_wait_time *tmp354
   850 label *label223
   851 label *label218
-    * label *label219
   852 jump *label224 notEqual :state 4
   853 ucontrol approach .DST_X .DST_Y 6
   854 ucontrol within .DST_X .DST_Y 8 *tmp357
 
   876 print ":"
   877 print " [green]"
   878 jump *label230 always
-    * label *label229
   879 print "[]"
   880 print "\n"
   881 print "Going to "
 
   883 print ":"
   884 print " [green]"
   885 label *label230
-    * label *label228
   886 label *label227
   887 label *label224
-    * label *label225
   888 jump *label231 notEqual :state 5
   889 sensor *tmp371 .DST .ITEM
   890 op sub :max_drop .DROP_LEVEL *tmp371
   891 jump *label233 lessThan :max_drop .DROP_PACK
   892 ucontrol itemDrop .DST :max_drop
   893 label *label233
-    * label *label234
   894 sensor *tmp375 @unit @totalItems
   895 jump *label235 greaterThan *tmp375 0
   896 set :state 2
 
   912 print ":"
   913 print " [green]"
   914 jump *label239 always
-    * label *label238
   915 print "[]"
   916 print "\n"
   917 print "Going to "
 
   919 print ":"
   920 print " [green]"
   921 label *label239
-    * label *label237
   922 jump *label236 always
   923 label *label235
   924 print "[]"
 
   930 op add :remote_wait_time :remote_wait_time *tmp387
   931 label *label236
   932 label *label231
-    * label *label232
   933 sensor :items @unit @totalItems
   934 op add :items_in_transit :items_in_transit :items
   935 jump *label240 notEqual :state 6
 
   944 ucontrol itemDrop .CORE .UNIT_CAPACITY
   945 sensor :items @unit @totalItems
   946 label *label246
-    * label *label247
   947 jump *label245 always
   948 label *label244
   949 ucontrol itemDrop @air .UNIT_CAPACITY
   950 sensor :items @unit @totalItems
   951 label *label245
   952 label *label242
-    * label *label243
   953 jump *label248 greaterThan :items .PARK_ITEM_LIMIT
   954 ucontrol move .PARK_X .PARK_Y
   955 set :state .S_UNUSED
   956 label *label248
-    * label *label249
   957 jump *label241 always
   958 label *label240
   959 op add :active :active 1
 
   962 print .ITEM_ICON
   963 ucontrol flag :state
   964 label *label193
-    * label *label194
   965 label *label191
-    * label *label192
-    * label *label78
   966 jump *label77 always
   967 label *label79
   968 control enabled switch1 false

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-4 instructions):
 
   734 set :items_in_transit 0
   735 print "Unit status:"
   736 sensor *tmp289 .SRC @dead
-    * jump *label179 equal *tmp289 0
-    * jump *label79 always
+  737 jump *label79 notEqual *tmp289 0
   738 label *label179
   739 sensor *tmp292 .DST @dead
-    * jump *label181 equal *tmp292 0
-    * jump *label79 always
+  740 jump *label79 notEqual *tmp292 0
   741 label *label181
   742 sensor *tmp295 .SORTER @dead
-    * jump *label183 equal *tmp295 0
-    * jump *label79 always
+  743 jump *label79 notEqual *tmp295 0
   744 label *label183
   745 getlink *tmp298 .CONTAINER_INDEX
-    * jump *label185 equal .CONTAINER *tmp298
-    * jump *label79 always
+  746 jump *label79 notEqual .CONTAINER *tmp298
   747 label *label185
   748 label *label91
   749 jump *label187 lessThanEq .CHANGE 0

Modifications by Jumps phase, Jump Optimization, pass 5, iteration 1:
 
   735 print "Unit status:"
   736 sensor *tmp289 .SRC @dead
   737 jump *label79 notEqual *tmp289 0
-    * label *label179
   738 sensor *tmp292 .DST @dead
   739 jump *label79 notEqual *tmp292 0
-    * label *label181
   740 sensor *tmp295 .SORTER @dead
   741 jump *label79 notEqual *tmp295 0
-    * label *label183
   742 getlink *tmp298 .CONTAINER_INDEX
   743 jump *label79 notEqual .CONTAINER *tmp298
-    * label *label185
   744 label *label91
   745 jump *label187 lessThanEq .CHANGE 0
   746 sensor *tmp303 @unit @controlled

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
 
    90 label *label29
    91 jump *label251 greaterThan :n 0
    92 label *label27
-    * jump *label31 notEqual .CONTAINER null
+   93 jump *label24 notEqual .CONTAINER null
    94 print "[salmon]No vault or container."
    95 printflush message1
-    * jump *label32 always
+   96 jump *label22 always
    97 label *label31
    98 jump *label24 always
    99 label *label32
 
   225 set .SRC_REMOTE_WAIT 1
   226 set .DST_REMOTE_WAIT 0
   227 set .DIRECTION " from vault #"
-    * jump *label66 notEqual LINK_ID 0
+  228 jump *label64 notEqual LINK_ID 0
   229 set .DIRECTION " from core"
   230 label *label66
   231 jump *label64 always
 
   750 label *label189
   751 label *label187
   752 sensor *tmp306 @unit @controller
-    * jump *label191 notEqual *tmp306 @this
+  753 jump *label77 notEqual *tmp306 @this
   754 sensor :state @unit @flag
-    * jump *label193 equal :state .S_UNUSED
+  755 jump *label77 equal :state .S_UNUSED
   756 op max *tmp312 :state 1
   757 op min :state *tmp312 .STATE_LIMIT
   758 jump *label195 greaterThanEq .CHANGE 0
 
   903 print "source"
   904 print ":"
   905 print " [green]"
-    * jump *label239 always
+  906 jump *label236 always
   907 print "[]"
   908 print "\n"
   909 print "Going to "
 
   932 jump *label244 equal .DROP_TO_CORE false
   933 ucontrol approach .CORE_X .CORE_Y 6
   934 ucontrol within .CORE_X .CORE_Y 8 *tmp394
-    * jump *label246 equal *tmp394 false
+  935 jump *label245 equal *tmp394 false
   936 ucontrol itemDrop .CORE .UNIT_CAPACITY
   937 sensor :items @unit @totalItems
   938 label *label246
 
   942 sensor :items @unit @totalItems
   943 label *label245
   944 label *label242
-    * jump *label248 greaterThan :items .PARK_ITEM_LIMIT
+  945 jump *label241 greaterThan :items .PARK_ITEM_LIMIT
   946 ucontrol move .PARK_X .PARK_Y
   947 set :state .S_UNUSED
   948 label *label248

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-21 instructions):
 
    94 print "[salmon]No vault or container."
    95 printflush message1
    96 jump *label22 always
-    * label *label31
-    * jump *label24 always
-    * label *label32
-    * jump *label22 always
    97 label *label24
    98 set .CORE null
    99 jump *label33 notEqual LINK_ID 0
 
   223 set .DIRECTION " from vault #"
   224 jump *label64 notEqual LINK_ID 0
   225 set .DIRECTION " from core"
-    * label *label66
   226 jump *label64 always
   227 label *label63
   228 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   807 print ":"
   808 print " [green]"
   809 jump *label217 always
-    * print "[]"
-    * print "\n"
-    * print "Going to "
-    * print "source"
-    * print ":"
-    * print " [green]"
   810 label *label217
   811 label *label214
   812 label *label211
 
   857 print ":"
   858 print " [green]"
   859 jump *label230 always
-    * print "[]"
-    * print "\n"
-    * print "Going to "
-    * print "destination"
-    * print ":"
-    * print " [green]"
   860 label *label230
   861 label *label227
   862 label *label224
 
   887 print ":"
   888 print " [green]"
   889 jump *label236 always
-    * print "[]"
-    * print "\n"
-    * print "Going to "
-    * print "source"
-    * print ":"
-    * print " [green]"
-    * label *label239
-    * jump *label236 always
   890 label *label235
   891 print "[]"
   892 print "\n"
 
   910 jump *label245 equal *tmp394 false
   911 ucontrol itemDrop .CORE .UNIT_CAPACITY
   912 sensor :items @unit @totalItems
-    * label *label246
   913 jump *label245 always
   914 label *label244
   915 ucontrol itemDrop @air .UNIT_CAPACITY
 
   919 jump *label241 greaterThan :items .PARK_ITEM_LIMIT
   920 ucontrol move .PARK_X .PARK_Y
   921 set :state .S_UNUSED
-    * label *label248
   922 jump *label241 always
   923 label *label240
   924 op add :active :active 1
 
   926 print :items
   927 print .ITEM_ICON
   928 ucontrol flag :state
-    * label *label193
-    * label *label191
   929 jump *label77 always
   930 label *label79
   931 control enabled switch1 false

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-3 instructions):
 
   806 print "source"
   807 print ":"
   808 print " [green]"
-    * jump *label217 always
   809 label *label217
   810 label *label214
   811 label *label211
 
   855 print "destination"
   856 print ":"
   857 print " [green]"
-    * jump *label230 always
   858 label *label230
   859 label *label227
   860 label *label224
 
   928 label *label79
   929 control enabled switch1 false
   930 control enabled switch2 false
-    * end

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
   806 print "source"
   807 print ":"
   808 print " [green]"
-    * label *label217
   809 label *label214
   810 label *label211
   811 jump *label218 notEqual :state 3
 
   854 print "destination"
   855 print ":"
   856 print " [green]"
-    * label *label230
   857 label *label227
   858 label *label224
   859 jump *label231 notEqual :state 5

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
   103 ubind UNIT
   104 sensor *tmp36 @unit @controlled
   105 jump *label38 notEqual *tmp36 0
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp40 .CORE
+  106 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   107 ucontrol flag .S_UNUSED
   108 label *label38
   109 jump *label252 equal .CORE null
 
   160 op land *tmp60 *tmp57 *tmp59
   161 jump *label259 notEqual *tmp60 false
   162 label *label53
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp62
+  163 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   164 jump *label54 equal :b_type @vault
   165 print "[salmon]Building at "
   166 print .CORE_X

Modifications by Final phase, Print Merging, iteration 1 (-56 instructions):
 
    39 label *label250
    40 print "[salmon]No unit of type "
    41 print UNIT
-    * print " "
-    * print "found."
+   42 print " found."
    43 printflush message1
    44 ubind UNIT
    45 jump *label250 equal @unit null
 
   113 printflush message2
   114 print "[green]Locating vault #"
   115 print LINK_ID
-    * print "."
-    * print ".."
+  116 print "..."
   117 printflush message1
   118 op add .QUERY_FLAG 99999900 LINK_ID
   119 label *label253
 
   162 jump *label54 equal :b_type @vault
   163 print "[salmon]Building at "
   164 print .CORE_X
-    * print ","
-    * print " "
+  165 print ", "
   166 print .CORE_Y
-    * print " "
-    * print "is not a vault!"
+  167 print " is not a vault!"
   168 printflush message2
   169 set .CORE null
   170 label *label54
 
   184 op land *tmp69 *tmp67 *tmp68
   185 jump *label60 equal *tmp69 false
   186 label *label260
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  187 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   188 jump *label61 equal .SORTER null
   189 print "Block found: "
   190 print .SORTER
 
   314 label *label254
   315 print "No unit of type "
   316 print UNIT
-    * print " "
-    * print "found."
+  317 print " found."
   318 printflush message1
   319 ubind UNIT
   320 jump *label254 equal @unit null
 
   619 print .MESSAGE
   620 print "Moving [green]"
   621 print .ITEM
-    * print "["
-    * print "]"
+  622 print "[]"
   623 print .DIRECTION
   624 print *tmp101
   625 print .AUTO_ALLOCATION_TXT
   626 jump *label163 lessThanEq .TARGET 0
   627 jump *label165 lessThan :active .TARGET
-    * print "\n"
-    * print "Using [green]"
+  628 print "\nUsing [green]"
   629 print :active
   630 print "/"
   631 print .TARGET
-    * print "["
-    * print "] units ("
+  632 print "[] units ("
   633 print UNIT
-    * print ")"
-    * print " [gold]+"
+  634 print ") [gold]+"
   635 print :items_in_transit
   636 jump *label166 always
   637 label *label165
-    * print "\n"
-    * print "Using [salmon]"
+  638 print "\nUsing [salmon]"
   639 print :active
   640 print "/"
   641 print .TARGET
-    * print "["
-    * print "] units ("
+  642 print "[] units ("
   643 print UNIT
-    * print ")"
-    * print " [gold]+"
+  644 print ") [gold]+"
   645 print :items_in_transit
   646 label *label166
   647 jump *label167 lessThanEq .CHANGE 0
   648 print "\n[][salmon]Cannot acquire additional units![]"
   649 label *label167
   650 label *label163
-    * print "\n"
-    * print "[]Local items: [gold]"
+  651 print "\n[]Local items: [gold]"
   652 print :container_items
   653 jump *label169 greaterThanEq .EFF_LOCAL_LIMIT 100
   654 print "[] (limit [orange]"
   655 print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  656 print "[])"
   657 label *label169
   658 jump *label171 equal .SHOW_REMOTE_LEVEL false
   659 sensor :remote_level .CORE .ITEM
-    * print "\n"
-    * print "[]Remote items: [gold]"
+  660 print "\n[]Remote items: [gold]"
   661 print :remote_level
   662 jump *label173 greaterThanEq .EFF_REMOTE_LIMIT 100
   663 print "[] (limit [orange]"
   664 print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  665 print "[])"
   666 label *label173
   667 label *label171
   668 jump *label175 lessThanEq .TARGET 0
-    * print "\n"
-    * print "[]Speed: [green]"
+  669 print "\n[]Speed: [green]"
   670 print :items_per_min
   671 print .CORR_SIGN
   672 print :corr_per_min
   673 print .SPEED_UNIT_TXT
   674 jump *label177 equal .EFF_AUTO_ALLOCATION false
-    * print "\n"
-    * print "Unit throughput: [green]"
+  675 print "\nUnit throughput: [green]"
   676 print :items_per_min_unit
-    * print "["
-    * print "]/min"
-    * print "\n"
-    * print "Min/last round: [green]"
+  677 print "[]/min\nMin/last round: [green]"
   678 print :turnaround_str
-    * print "["
-    * print "]/[green]"
+  679 print "[]/[green]"
   680 print :elapsed_str
-    * print "["
-    * print "] s"
+  681 print "[] s"
   682 jump *label178 always
   683 label *label177
-    * print "\n"
-    * print "Last round: [green]"
+  684 print "\nLast round: [green]"
   685 print :elapsed_str
-    * print "["
-    * print "] s"
+  686 print "[] s"
   687 label *label178
-    * print "\n"
-    * print "Total wait time: [green]"
+  688 print "\nTotal wait time: [green]"
   689 print :wait_time_str
-    * print "["
-    * print "] s"
+  690 print "[] s"
   691 label *label175
-    * print "\n"
-    * print "[lightgray]Loop: "
+  692 print "\n[lightgray]Loop: "
   693 print :loop_time_ms
-    * print " "
-    * print "ms"
+  694 print " ms"
   695 printflush message1
   696 op sub .CHANGE .TARGET :active
   697 set :active 0
 
   742 jump *label209 equal *tmp330 false
   743 ucontrol itemDrop .CORE .UNIT_CAPACITY
   744 label *label209
-    * print "[]"
-    * print "\n"
-    * print "Unloading previous items: [green]"
+  745 print "[]\nUnloading previous items: [green]"
   746 jump *label208 always
   747 label *label207
   748 ucontrol itemDrop @air .UNIT_CAPACITY
 
   765 op len *tmp342 *tmp339 *tmp341
   766 op idiv *tmp343 *tmp342 .SPEED_SEC
   767 op div *tmp344 *tmp343 10
-    * print "[]"
-    * print "\n"
-    * print "[gold]"
+  768 print "[]\n[gold]"
   769 print *tmp344
-    * print " "
-    * print "sec[] to "
-    * print "source"
-    * print ":"
-    * print " [green]"
+  770 print " sec[] to source: [green]"
   771 label *label214
   772 label *label211
   773 jump *label218 notEqual :state 3
 
   781 set :state 4
   782 jump *label223 always
   783 label *label222
-    * print "[]"
-    * print "\n"
-    * print "Waiting at source: [green]"
+  784 print "[]\nWaiting at source: [green]"
   785 ucontrol approach .SRC_X .SRC_Y 6
   786 op add :wait_time :wait_time :loop_time_ms
   787 op mul *tmp354 :loop_time_ms .SRC_REMOTE_WAIT
 
   805 op len *tmp366 *tmp363 *tmp365
   806 op idiv *tmp367 *tmp366 .SPEED_SEC
   807 op div *tmp368 *tmp367 10
-    * print "[]"
-    * print "\n"
-    * print "[gold]"
+  808 print "[]\n[gold]"
   809 print *tmp368
-    * print " "
-    * print "sec[] to "
-    * print "destination"
-    * print ":"
-    * print " [green]"
+  810 print " sec[] to destination: [green]"
   811 label *label227
   812 label *label224
   813 jump *label231 notEqual :state 5
 
   827 op len *tmp384 *tmp381 *tmp383
   828 op idiv *tmp385 *tmp384 .SPEED_SEC
   829 op div *tmp386 *tmp385 10
-    * print "[]"
-    * print "\n"
-    * print "[gold]"
+  830 print "[]\n[gold]"
   831 print *tmp386
-    * print " "
-    * print "sec[] to "
-    * print "source"
-    * print ":"
-    * print " [green]"
+  832 print " sec[] to source: [green]"
   833 jump *label236 always
   834 label *label235
-    * print "[]"
-    * print "\n"
-    * print "Waiting at destination: [green]"
+  835 print "[]\nWaiting at destination: [green]"
   836 ucontrol approach .DST_X .DST_Y 6
   837 op add :wait_time :wait_time :loop_time_ms
   838 op mul *tmp387 :loop_time_ms .DST_REMOTE_WAIT
 
   842 sensor :items @unit @totalItems
   843 op add :items_in_transit :items_in_transit :items
   844 jump *label240 notEqual :state 6
-    * print "[]"
-    * print "\n"
-    * print "Parking: [green]"
+  845 print "[]\nParking: [green]"
   846 jump *label242 lessThanEq :items 0
   847 jump *label244 equal .DROP_TO_CORE false
   848 ucontrol approach .CORE_X .CORE_Y 6

Final code before resolving virtual instructions:

    0:  remark "Configurable options:"                               /// Configurable options:
    1:  remark "Which unit type to use:"                             param UNIT                    = @mega;  /// Which unit type to use:
    2:  set UNIT @mega                                               ...
    3:  remark "Remote vault ID (1-99); if nonzero, items are moved  param LINK_ID                 = 0;      /// Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core:
    4:  set LINK_ID 0                                                ...
    5:  remark "Start in auto allocation mode?"                      param AUTO_ALLOCATION         = true;   /// Start in auto allocation mode?
    6:  set AUTO_ALLOCATION true                                     ...
    7:  remark "Max units to use, in both manual and auto allocation param MAX_UNITS               = 24;     /// Max units to use, in both manual and auto allocation modes:
    8:  set MAX_UNITS 24                                             ...
    9:  remark "Leave discarded units with nonzero flag for housekee param HOUSEKEEPING            = true;   /// Leave discarded units with nonzero flag for housekeeping (flag-clearing) processor to pick them up:
   10:  set HOUSEKEEPING true                                        ...
   11:  remark "Drop superfluous items to air, even when there's a c param DROP_TO_AIR             = true;   /// Drop superfluous items to air, even when there's a core:
   12:  set DROP_TO_AIR true                                         ...
   13:  remark "How much of local container capacity to use, in perc param LOCAL_LIMIT             = 100;    /// How much of local container capacity to use, in percents (20-100):
   14:  set LOCAL_LIMIT 100                                          ...
   15:  remark "How much of remote container capacity to use, in per param REMOTE_LIMIT            = 100;    /// How much of remote container capacity to use, in percents (20-100)
   16:  set REMOTE_LIMIT 100                                         ...
   17:  remark "Allocate at least this much more units than needed:" param OVERALLOCATION_LOW      = 0.25;   /// Allocate at least this much more units than needed:
   18:  set OVERALLOCATION_LOW 0.25                                  ...
   19:  remark "Allocate at most this much more units than needed:"  param OVERALLOCATION_HIGH     = 0.75;   /// Allocate at most this much more units than needed:
   20:  set OVERALLOCATION_HIGH 0.75                                 ...
   21:  remark "Use average of last three flow rate values for bette param STABILIZATION           = false;  /// Use average of last three flow rate values for better unit auto allocation stability:
   22:  set STABILIZATION false                                      ...
   23:  remark "End of configurable options"                         /// End of configurable options
   24:  printflush null                                              *printing: printflush(null);
   25:  set .MESSAGE ""                                              MESSAGE = "";
   26:  op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20                       EFF_LOCAL_LIMIT = max(LOCAL_LIMIT, 20);
   27:  op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20                     EFF_REMOTE_LIMIT = max(REMOTE_LIMIT, 20);
   28:  set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION                     EFF_AUTO_ALLOCATION = AUTO_ALLOCATION;
   29:  op mul .S_UNUSED -1 HOUSEKEEPING                             S_UNUSED = -1 * HOUSEKEEPING;           // Unit is not used. Regarded as a free unit even if controlled by this processor.
   30:  set .STATE_LIMIT null                                        CONTAINER_INDEX = CORE_X = CORE_Y = ITEM = ITEM_ICON = STATE_LIMIT = null;
   31:  set .ITEM_ICON null                                          ...
   32:  set .ITEM null                                               ...
   33:  set .CORE_Y null                                             ...
   34:  set .CORE_X null                                             ...
   35:  set .CONTAINER_INDEX null                                    ...
   36:  op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH             DEC_OVERALLOCATION      = 1 + OVERALLOCATION_HIGH;  // Deallocate on this much overcapacity (convert to multiplicational factor)
   37:  ubind UNIT                                                   ubind(UNIT);
   38:  jump *label16 notEqual @unit null                            while @unit == null do
        label *label250                                              ...
   39:  print "[salmon]No unit of type "                             print($"[salmon]No unit of type $UNIT found.");
   40:  print UNIT                                                   ...
   41:  print " found."                                              ...
   42:  printflush message1                                          printflush(message1);
   43:  ubind UNIT                                                   ubind(UNIT);
   44:  jump *label250 equal @unit null                              while @unit == null do
        label *label16                                               ...
   45:  set :first_unit @unit                                        first_unit = @unit;
   46:  sensor *tmp8 @unit @speed                                    SPEED_SEC = @unit.@speed / 10;
   47:  op div .SPEED_SEC *tmp8 10                                   ...
   48:  sensor *tmp10 @unit @speed                                   SPEED = @unit.@speed / 1000;                         // Unit speed in tiles/ms
   49:  op div .SPEED *tmp10 1000                                    ...
   50:  set .TARGET 0                                                TARGET = 0;
        label *label17                                               do
   51:  sensor *tmp12 @unit @controller                              if @unit.@controller == @this then
   52:  jump *label20 notEqual *tmp12 @this                          ...
   53:  sensor :state @unit @flag                                    state = @unit.@flag;
   54:  op greaterThanEq *tmp16 :state 1                             TARGET += (state >= S_FIRST) && (state < S_LAST);
   55:  op lessThan *tmp17 :state 6                                  ...
   56:  op land *tmp18 *tmp16 *tmp17                                 ...
   57:  op add .TARGET .TARGET *tmp18                                ...
        label *label20                                               if @unit.@controller == @this then
   58:  ubind UNIT                                                   ubind(UNIT);
   59:  op notEqual *tmp19 @unit :first_unit                         while (@unit != first_unit) and (first_unit.@dead == 0);    // Don't get stuck if the first unit is killed
   60:  sensor *tmp20 :first_unit @dead                              ...
   61:  op equal *tmp21 *tmp20 0                                     ...
   62:  op land *tmp22 *tmp19 *tmp21                                 ...
   63:  jump *label17 notEqual *tmp22 false                          do
   64:  set .CHANGE 0                                                CHANGE = 0;
   65:  set :active .TARGET                                          active = TARGET;
   66:  set .DEC_LIMIT 0                                             DEC_LIMIT = 0;
   67:  set .INC_LIMIT 0                                             INC_LIMIT = 0;
   68:  sensor .UNIT_CAPACITY @unit @itemCapacity                    UNIT_CAPACITY = @unit.@itemCapacity;
   69:  set :first_unit null                                         first_unit = null;
        label *label22                                               while true do
   70:  set .CONTAINER null                                          CONTAINER = null;
   71:  set .CONTAINERS 0                                            CONTAINERS = 0;
   72:  set :n @links                                                n = @links;
   73:  jump *label27 lessThanEq :n 0                                while n > 0 do
        label *label251                                              ...
   74:  op sub :n :n 1                                               n = n - 1;
   75:  getlink :block :n                                            block = getlink(n);
   76:  sensor *tmp29 :block @type                                   case block.@type
   77:  jump *label30 equal *tmp29 @vault                            ...
   78:  jump *label29 notEqual *tmp29 @container                     ...
        label *label30                                               ...
   79:  set .CONTAINER :block                                        CONTAINER = block;
   80:  op add .CONTAINERS .CONTAINERS 1                             CONTAINERS += 1;
   81:  set .CONTAINER_INDEX :n                                      CONTAINER_INDEX = n;
        label *label29                                               case block.@type
   82:  jump *label251 greaterThan :n 0                              while n > 0 do
        label *label27                                               ...
   83:  jump *label24 notEqual .CONTAINER null                       if CONTAINER == null then
   84:  print "[salmon]No vault or container."                       print("[salmon]No vault or container.");
   85:  printflush message1                                          printflush(message1);
   86:  jump *label22 always 0 0                                     if CONTAINER == null then
        label *label24                                               while true do
   87:  set .CORE null                                               CORE = null;
   88:  jump *label33 notEqual LINK_ID 0                             if LINK_ID == 0 then
        label *label252                                              while CORE == null do
   89:  print "[green]Locating core..."                              print("[green]Locating core...");
   90:  printflush message1                                          printflush(message1);
   91:  ubind UNIT                                                   ubind(UNIT);
   92:  sensor *tmp36 @unit @controlled                              if @unit.@controlled == 0 then
   93:  jump *label38 notEqual *tmp36 0                              ...
   94:  ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE  CORE = ulocate(:building, :core, false, out CORE_X, out CORE_Y);
   95:  ucontrol flag .S_UNUSED 0 0 0 0                              flag(S_UNUSED);
        label *label38                                               if @unit.@controlled == 0 then
   96:  jump *label252 equal .CORE null                              while CORE == null do
   97:  set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY                   DISCARD_UNIT_MAX_ITEMS = UNIT_CAPACITY;       // Can discard anything to the core
   98:  op equal .DROP_TO_CORE DROP_TO_AIR false                     DROP_TO_CORE = not DROP_TO_AIR;
   99:  jump *label34 always 0 0                                     if LINK_ID == 0 then
        label *label33                                               ...
  100:  printflush message2                                          printflush(message2);
  101:  print "[green]Locating vault #"                              print($"[green]Locating vault #$LINK_ID...");
  102:  print LINK_ID                                                ...
  103:  print "..."                                                  ...
  104:  printflush message1                                          printflush(message1);
  105:  op add .QUERY_FLAG 99999900 LINK_ID                          while CORE == null do
        label *label253                                              ...
  106:  set :flag .QUERY_FLAG                                        flag = QUERY_FLAG;
  107:  ubind UNIT                                                   ubind(UNIT);
  108:  sensor *tmp44 @unit @controlled                              while @unit.@controlled != 0 do
  109:  jump *label45 equal *tmp44 0                                 ...
        label *label257                                              ...
  110:  ubind UNIT                                                   ubind(UNIT);
  111:  sensor *tmp44 @unit @controlled                              while @unit.@controlled != 0 do
  112:  jump *label257 notEqual *tmp44 0                             ...
        label *label45                                               ...
  113:  ucontrol flag .QUERY_FLAG 0 0 0 0                            flag(flag);
  114:  sensor *tmp47 @unit @dead                                    while flag == QUERY_FLAG and @unit.@dead == 0 do
  115:  op equal *tmp49 *tmp47 0                                     ...
  116:  jump *label48 equal *tmp49 false                             ...
        label *label258                                              ...
  117:  ucontrol stop 0 0 0 0 0                                      stop();                 // Keep controlling the unit
  118:  sensor :flag @unit @flag                                     flag = @unit.@flag;
  119:  op equal *tmp46 :flag .QUERY_FLAG                            while flag == QUERY_FLAG and @unit.@dead == 0 do
  120:  sensor *tmp47 @unit @dead                                    ...
  121:  op equal *tmp48 *tmp47 0                                     ...
  122:  op land *tmp49 *tmp46 *tmp48                                 ...
  123:  jump *label258 notEqual *tmp49 false                         ...
        label *label48                                               ...
  124:  jump *label49 equal :flag .QUERY_FLAG                        if flag != QUERY_FLAG then
  125:  op idiv :position :flag 100                                  position = flag \ 100;
  126:  op mod .CORE_X :position @mapw                               CORE_X = position % @mapw;
  127:  op idiv .CORE_Y :position @mapw                              CORE_Y = position \ @mapw;
  128:  sensor *tmp56 @unit @dead                                    while @unit.@dead == 0 and !within(CORE_X, CORE_Y, RADIUS_WITHIN) do
  129:  op equal *tmp57 *tmp56 0                                     ...
  130:  ucontrol within .CORE_X .CORE_Y 8 *tmp58 0                   ...
  131:  op equal *tmp59 *tmp58 false                                 ...
  132:  op land *tmp60 *tmp57 *tmp59                                 ...
  133:  jump *label53 equal *tmp60 false                             ...
        label *label259                                              ...
  134:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  135:  sensor *tmp56 @unit @dead                                    while @unit.@dead == 0 and !within(CORE_X, CORE_Y, RADIUS_WITHIN) do
  136:  op equal *tmp57 *tmp56 0                                     ...
  137:  ucontrol within .CORE_X .CORE_Y 8 *tmp58 0                   ...
  138:  op equal *tmp59 *tmp58 false                                 ...
  139:  op land *tmp60 *tmp57 *tmp59                                 ...
  140:  jump *label259 notEqual *tmp60 false                         ...
        label *label53                                               ...
  141:  ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0            CORE = getBlock(CORE_X, CORE_Y, out b_type);
  142:  jump *label54 equal :b_type @vault                           if b_type != @vault then
  143:  print "[salmon]Building at "                                 print($"[salmon]Building at $CORE_X, $CORE_Y is not a vault!");
  144:  print .CORE_X                                                ...
  145:  print ", "                                                   ...
  146:  print .CORE_Y                                                ...
  147:  print " is not a vault!"                                     ...
  148:  printflush message2                                          printflush(message2);
  149:  set .CORE null                                               CORE = null;
        label *label54                                               if b_type != @vault then
        label *label49                                               if flag != QUERY_FLAG then
  150:  ucontrol flag .S_UNUSED 0 0 0 0                              flag(S_UNUSED);               // Free the unit
  151:  jump *label253 equal .CORE null                              while CORE == null do
  152:  set .DISCARD_UNIT_MAX_ITEMS 0                                DISCARD_UNIT_MAX_ITEMS = DROP_TO_AIR ? UNIT_CAPACITY : 0;       // Cannot drop items to the remote vault
  153:  jump *label57 equal DROP_TO_AIR false                        ...
  154:  set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY                   ...
        label *label57                                               ...
  155:  set .DROP_TO_CORE false                                      DROP_TO_CORE = false;
        label *label34                                               if LINK_ID == 0 then
  156:  set .SORTER sorter1                                          SORTER = sorter1;
  157:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  158:  op notEqual *tmp67 :sorter_type @sorter                      while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
  159:  op notEqual *tmp68 :sorter_type @inverted-sorter             ...
  160:  op land *tmp69 *tmp67 *tmp68                                 ...
  161:  jump *label60 equal *tmp69 false                             ...
        label *label260                                              ...
  162:  print "[salmon]Block sorter1 is neither a sorter, nor an inv println("[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.");
  163:  jump *label61 equal .SORTER null                             if SORTER != null then
  164:  print "Block found: "                                        print("Block found: ", SORTER);
  165:  print .SORTER                                                ...
        label *label61                                               if SORTER != null then
  166:  printflush message1                                          printflush(message1);
  167:  set .SORTER sorter1                                          SORTER = sorter1;
  168:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  169:  op notEqual *tmp67 :sorter_type @sorter                      while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
  170:  op notEqual *tmp68 :sorter_type @inverted-sorter             ...
  171:  op land *tmp69 *tmp67 *tmp68                                 ...
  172:  jump *label260 notEqual *tmp69 false                         ...
        label *label60                                               ...
  173:  jump *label63 notEqual :sorter_type @sorter                  if sorter_type == @sorter then
  174:  set .SHOW_REMOTE_LEVEL true                                  SHOW_REMOTE_LEVEL = true;
  175:  set .SRC .CORE                                               SRC = CORE;
  176:  set .DST .CONTAINER                                          DST = CONTAINER;
  177:  sensor :src_capacity .CORE @itemCapacity                     src_capacity = SRC.@itemCapacity;
  178:  sensor :dst_capacity .CONTAINER @itemCapacity                dst_capacity = DST.@itemCapacity;
  179:  op sub *tmp77 100 .EFF_REMOTE_LIMIT                          LOAD_LEVEL = (src_capacity * (100 - EFF_REMOTE_LIMIT)) \ 100;
  180:  op mul *tmp78 :src_capacity *tmp77                           ...
  181:  op idiv .LOAD_LEVEL *tmp78 100                               ...
  182:  op mul *tmp80 :dst_capacity .EFF_LOCAL_LIMIT                 DROP_LEVEL = (dst_capacity * EFF_LOCAL_LIMIT) \ 100;
  183:  op idiv .DROP_LEVEL *tmp80 100                               ...
  184:  set .LOCAL_MARGIN .DROP_LEVEL                                LOCAL_MARGIN = DROP_LEVEL;
  185:  set .REMOTE_MARGIN .LOAD_LEVEL                               REMOTE_MARGIN = LOAD_LEVEL;
  186:  op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998  LOW_LEVEL_TRIGGER = dst_capacity * (1 - TRIGGER_LEVEL);
  187:  set .HIGH_LEVEL_TRIGGER :dst_capacity                        HIGH_LEVEL_TRIGGER = dst_capacity;  // never triggers
  188:  set .FLOW_CORR_SIGN 1                                        FLOW_CORR_SIGN = 1;                 // sign of flow-rate correction computed from container level
  189:  set .SRC_REMOTE_WAIT 1                                       SRC_REMOTE_WAIT = 1;
  190:  set .DST_REMOTE_WAIT 0                                       DST_REMOTE_WAIT = 0;
  191:  set .DIRECTION " from vault #"                               DIRECTION = (LINK_ID == 0) ? " from core"  : " from vault #";
  192:  jump *label64 notEqual LINK_ID 0                             ...
  193:  set .DIRECTION " from core"                                  ...
  194:  jump *label64 always 0 0                                     if sorter_type == @sorter then
        label *label63                                               ...
  195:  op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0                  SHOW_REMOTE_LEVEL = LINK_ID > 0;
  196:  set .SRC .CONTAINER                                          SRC = CONTAINER;
  197:  set .DST .CORE                                               DST = CORE;
  198:  sensor :src_capacity .CONTAINER @itemCapacity                src_capacity = SRC.@itemCapacity;
  199:  sensor :dst_capacity .CORE @itemCapacity                     dst_capacity = DST.@itemCapacity;
  200:  op sub *tmp89 100 .EFF_LOCAL_LIMIT                           LOAD_LEVEL = (src_capacity * (100 - EFF_LOCAL_LIMIT)) \ 100;
  201:  op mul *tmp90 :src_capacity *tmp89                           ...
  202:  op idiv .LOAD_LEVEL *tmp90 100                               ...
  203:  op mul *tmp92 :dst_capacity .EFF_REMOTE_LIMIT                DROP_LEVEL = (dst_capacity * EFF_REMOTE_LIMIT) \ 100 + ((LINK_ID == 0) * UNIT_CAPACITY);
  204:  op idiv *tmp93 *tmp92 100                                    ...
  205:  op equal *tmp94 LINK_ID 0                                    ...
  206:  op mul *tmp95 *tmp94 .UNIT_CAPACITY                          ...
  207:  op add .DROP_LEVEL *tmp93 *tmp95                             ...
  208:  set .LOCAL_MARGIN .LOAD_LEVEL                                LOCAL_MARGIN = LOAD_LEVEL;
  209:  set .REMOTE_MARGIN .DROP_LEVEL                               REMOTE_MARGIN = DROP_LEVEL;
  210:  op mul .HIGH_LEVEL_TRIGGER :src_capacity 0.9                 HIGH_LEVEL_TRIGGER = src_capacity * TRIGGER_LEVEL;
  211:  set .LOW_LEVEL_TRIGGER 0                                     LOW_LEVEL_TRIGGER = 0;              // never triggers
  212:  set .FLOW_CORR_SIGN -1                                       FLOW_CORR_SIGN = -1;                // sign of flow-rate correction computed from container level
  213:  set .SRC_REMOTE_WAIT 0                                       SRC_REMOTE_WAIT = 0;
  214:  set .DST_REMOTE_WAIT 1                                       DST_REMOTE_WAIT = 1;
  215:  set .DIRECTION " to vault #"                                 DIRECTION = (LINK_ID == 0) ? " to core" : " to vault #";
  216:  jump *label68 notEqual LINK_ID 0                             ...
  217:  set .DIRECTION " to core"                                    ...
        label *label68                                               ...
        label *label64                                               if sorter_type == @sorter then
  218:  set *tmp101 LINK_ID                                          LINK_TXT = (LINK_ID == 0) ? ""  : LINK_ID;
  219:  jump *label70 notEqual LINK_ID 0                             ...
  220:  set *tmp101 ""                                               ...
        label *label70                                               ...
  221:  op sub *tmp102 :src_capacity .LOAD_LEVEL                     LOAD_PACK = min(UNIT_CAPACITY, src_capacity - LOAD_LEVEL);
  222:  op min .LOAD_PACK .UNIT_CAPACITY *tmp102                     ...
  223:  op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL                 DROP_PACK = min(UNIT_CAPACITY, DROP_LEVEL);
  224:  sensor .SRC_X .SRC @x                                        SRC_X = SRC.@x;
  225:  sensor .SRC_Y .SRC @y                                        SRC_Y = SRC.@y;
  226:  sensor .DST_X .DST @x                                        DST_X = DST.@x;
  227:  sensor .DST_Y .DST @y                                        DST_Y = DST.@y;
  228:  op sub *tmp109 .DST_X .SRC_X                                 DISTANCE = len(DST_X - SRC_X, DST_Y - SRC_Y) - RADIUS_APPROACH - RADIUS_WITHIN;
  229:  op sub *tmp110 .DST_Y .SRC_Y                                 ...
  230:  op len *tmp111 *tmp109 *tmp110                               ...
  231:  op sub .DISTANCE *tmp111 14                                  ...
  232:  op max *tmp114 .DISTANCE 10                                  TRAVEL_TIME = (2 * max(DISTANCE, 10)) / SPEED;   // Travel time: both ways, in tiles/ms
  233:  op mul *tmp115 2 *tmp114                                     ...
  234:  op div .TRAVEL_TIME *tmp115 .SPEED                           ...
  235:  op add .PARK_X .CORE_X -15                                   PARK_X = CORE_X + ((CONTAINER.@x < CORE_X) ? 15 : -15);
  236:  sensor *tmp117 .CONTAINER @x                                 ...
  237:  jump *label72 greaterThanEq *tmp117 .CORE_X                  ...
  238:  op add .PARK_X .CORE_X 15                                    ...
        label *label72                                               ...
  239:  op add .PARK_Y .CORE_Y -15                                   PARK_Y = CORE_Y + ((CONTAINER.@y < CORE_Y) ? 15 : -15);
  240:  sensor *tmp121 .CONTAINER @y                                 ...
  241:  jump *label74 greaterThanEq *tmp121 .CORE_Y                  ...
  242:  op add .PARK_Y .CORE_Y 15                                    ...
        label *label74                                               ...
  243:  op equal *tmp125 LINK_ID 0                                   PARK_ITEM_LIMIT = (LINK_ID == 0) * UNIT_CAPACITY;
  244:  op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY               ...
  245:  set .TRANSFER_START @tick                                    TRANSFER_START = @tick;             // Prevent completely nonsensical values
  246:  op sub .LOOP_START @tick 60                                  LOOP_START = @tick - 60;            // Prevent completely nonsensical values
  247:  set .LAST_ITEM @mono                                         LAST_ITEM = @mono;                  // Must not be null
  248:  op add .MESSAGE_TIMEOUT @tick 600                            MESSAGE_TIMEOUT = @tick + 600;      // Ten seconds
  249:  set .WAIT_LIMIT 30000                                        WAIT_LIMIT = 30000;                 // Good initial value: half a minute
  250:  set :items_in_transit 0                                      items_in_transit = 0;
  251:  set :items_per_min_unit "--"                                 items_per_min_unit = "--";
  252:  set :items_per_min "-- "                                     items_per_min = "-- ";
  253:  set :turnaround_str "--"                                     turnaround_str = "--";
  254:  set :elapsed_str "--"                                        elapsed_str = "--";
  255:  set :wait_time_str 0                                         wait_time_str = 0;
  256:  set :wait_time 0                                             = total_flow_1 = total_flow_2 = transferred = transfers = wait_time = 0;
  257:  set :transfers 0                                             ...
  258:  set :transferred 0                                           ...
  259:  set :total_flow_2 0                                          ...
  260:  set :total_flow_1 0                                          ...
  261:  set :remote_wait_time 0                                      last_level = loop_time_ms = max_level = min_level = remote_wait_time
  262:  set :min_level 0                                             ...
  263:  set :max_level 0                                             ...
  264:  set :loop_time_ms 0                                          ...
  265:  set :last_level 0                                            ...
  266:  jump *label75 equal AUTO_ALLOCATION false                    if EFF_AUTO_ALLOCATION then
  267:  set .CORR_SIGN "[]([green]+"                                 CORR_SIGN = "[]([green]+";
  268:  set :corr_per_min 0                                          corr_per_min = 0;
  269:  set .SPEED_UNIT_TXT "[])/min"                                SPEED_UNIT_TXT = "[])/min";
  270:  set .AUTO_ALLOCATION_TXT "\n=== [gold]Gathering statistics[] AUTO_ALLOCATION_TXT = "\n=== [gold]Gathering statistics[] ===";
  271:  jump *label76 always 0 0                                     if EFF_AUTO_ALLOCATION then
        label *label75                                               ...
  272:  set .CORR_SIGN "[]"                                          CORR_SIGN = "[]";
  273:  set :corr_per_min ""                                         corr_per_min = "";
  274:  set .SPEED_UNIT_TXT "/min"                                   SPEED_UNIT_TXT = "/min";
  275:  set .AUTO_ALLOCATION_TXT ""                                  AUTO_ALLOCATION_TXT = "";
        label *label76                                               if EFF_AUTO_ALLOCATION then
        label *label77                                               while true do
  276:  ubind UNIT                                                   ubind(UNIT);
  277:  jump *label82 notEqual @unit null                            while @unit == null do
        label *label254                                              ...
  278:  print "No unit of type "                                     print($"No unit of type $UNIT found.");
  279:  print UNIT                                                   ...
  280:  print " found."                                              ...
  281:  printflush message1                                          printflush(message1);
  282:  ubind UNIT                                                   ubind(UNIT);
  283:  jump *label254 equal @unit null                              while @unit == null do
        label *label82                                               ...
  284:  sensor *tmp132 switch1 @enabled                              if switch1.@enabled then
  285:  jump *label83 equal *tmp132 false                            ...
  286:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  287:  set .EFF_AUTO_ALLOCATION false                               EFF_AUTO_ALLOCATION = false;
  288:  set .AUTO_ALLOCATION_TXT ""                                  AUTO_ALLOCATION_TXT = "";
  289:  op add *tmp135 .TARGET 1                                     TARGET = min(TARGET + 1, MAX_UNITS);
  290:  op min .TARGET *tmp135 MAX_UNITS                             ...
  291:  set .CORR_SIGN "[]"                                          CORR_SIGN = "[]";
  292:  set :corr_per_min ""                                         corr_per_min = "";
  293:  set .SPEED_UNIT_TXT "/min"                                   SPEED_UNIT_TXT = "/min";
  294:  set .WAIT_LIMIT 30000                                        WAIT_LIMIT = 30000;
        label *label83                                               if switch1.@enabled then
  295:  sensor *tmp137 switch2 @enabled                              if switch2.@enabled then
  296:  jump *label85 equal *tmp137 false                            ...
  297:  control enabled switch2 false 0 0 0                          switch2.enabled = false;
  298:  jump *label87 greaterThanEq .TARGET 1                        if TARGET < 1 then
  299:  set .EFF_AUTO_ALLOCATION true                                EFF_AUTO_ALLOCATION = true;
  300:  set .TARGET 1                                                TARGET = 1;
  301:  set .DEC_LIMIT 0                                             DEC_LIMIT = 0;           // No change for next iteration
  302:  set .INC_LIMIT 0                                             INC_LIMIT = 0;
  303:  set .CORR_SIGN "[]([green]+"                                 CORR_SIGN = "[]([green]+";
  304:  set :corr_per_min 0                                          corr_per_min = 0;
  305:  set .SPEED_UNIT_TXT "[])/min"                                SPEED_UNIT_TXT = "[])/min";
  306:  jump *label88 always 0 0                                     if TARGET < 1 then
        label *label87                                               ...
  307:  set .EFF_AUTO_ALLOCATION false                               EFF_AUTO_ALLOCATION = false;
  308:  op sub *tmp142 .TARGET 1                                     TARGET = max(TARGET - 1, 0);
  309:  op max .TARGET *tmp142 0                                     ...
  310:  set .CORR_SIGN "[]"                                          CORR_SIGN = "[]";
  311:  set :corr_per_min ""                                         corr_per_min = "";
  312:  set .SPEED_UNIT_TXT "/min"                                   SPEED_UNIT_TXT = "/min";
  313:  set .AUTO_ALLOCATION_TXT ""                                  AUTO_ALLOCATION_TXT = TARGET == 0 ? "\n=== [salmon]Transport deactivated[] ===" : "";
  314:  jump *label90 notEqual .TARGET 0                             ...
  315:  set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivate ...
        label *label90                                               ...
        label *label88                                               if TARGET < 1 then
  316:  set .WAIT_LIMIT 30000                                        WAIT_LIMIT = 30000;
        label *label85                                               if switch2.@enabled then
  317:  sensor *tmp146 :first_unit @dead                             alive = first_unit.@dead == 0;
  318:  op equal :alive *tmp146 0                                    ...
  319:  op equal *tmp148 @unit :first_unit                           if alive <= (@unit == first_unit) then
  320:  jump *label91 greaterThan :alive *tmp148                     ...
  321:  jump *label93 notEqual :active 0                             if active == 0 then
  322:  print "\n[salmon]No active units.[]"                         print("\n[salmon]No active units.[]");
        label *label93                                               if active == 0 then
  323:  printflush message2                                          printflush(message2);
  324:  set .STATE_LIMIT 6                                           STATE_LIMIT = S_LAST;
  325:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  326:  jump *label95 equal .ITEM .LAST_ITEM                         if ITEM != LAST_ITEM then
  327:  jump *label99 notEqual .ITEM null                            while ITEM == null do
        label *label255                                              ...
  328:  print "[salmon]No item type selected for transport.[]"       print("[salmon]No item type selected for transport.[]");
  329:  printflush message1                                          printflush(message1);
  330:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  331:  jump *label255 equal .ITEM null                              while ITEM == null do
        label *label99                                               ...
  332:  set .LAST_ITEM .ITEM                                         LAST_ITEM = ITEM;
  333:  sensor *tmp160 .ITEM @id                                     case itemType.@id
  334:  jump *label262 greaterThanEq *tmp160 3                       ...
  335:  jump *label263 greaterThanEq *tmp160 1                       ...
  336:  jump *label261 lessThan *tmp160 0                            ...
  337:  set *tmp159 "[]"                                            ...
  338:  jump *label101 always 0 0                                    ...
        label *label263                                              ...
  339:  jump *label113 greaterThanEq *tmp160 2                       ...
  340:  set *tmp159 "[]"                                            ...
  341:  jump *label101 always 0 0                                    ...
        label *label262                                              ...
  342:  jump *label261 greaterThanEq *tmp160 16                      ...
  343:  multijump *label265 *tmp160 3                                ...
        multilabel *label265                                         ...
  344:  jump *label109 always 0 0                                    ...
        multilabel *label266                                         ...
  345:  jump *label121 always 0 0                                    ...
        multilabel *label267                                         ...
  346:  jump *label105 always 0 0                                    ...
        multilabel *label268                                         ...
  347:  jump *label133 always 0 0                                    ...
        multilabel *label269                                         ...
  348:  jump *label131 always 0 0                                    ...
        multilabel *label270                                         ...
  349:  jump *label123 always 0 0                                    ...
        multilabel *label271                                         ...
  350:  jump *label125 always 0 0                                    ...
        multilabel *label272                                         ...
  351:  jump *label117 always 0 0                                    ...
        multilabel *label273                                         ...
  352:  jump *label115 always 0 0                                    ...
        multilabel *label274                                         ...
  353:  jump *label129 always 0 0                                    ...
        multilabel *label275                                         ...
  354:  jump *label127 always 0 0                                    ...
        multilabel *label276                                         ...
  355:  jump *label103 always 0 0                                    ...
        multilabel *label277                                         ...
  356:  set *tmp159 "[]"                                            ...
  357:  jump *label101 always 0 0                                    ...
        label *label103                                              ...
  358:  set *tmp159 "[]"                                            ...
  359:  jump *label101 always 0 0                                    ...
        label *label105                                              ...
  360:  set *tmp159 "[]"                                            ...
  361:  jump *label101 always 0 0                                    ...
        label *label109                                              ...
  362:  set *tmp159 "[]"                                            ...
  363:  jump *label101 always 0 0                                    ...
        label *label113                                              ...
  364:  set *tmp159 "[]"                                            ...
  365:  jump *label101 always 0 0                                    ...
        label *label115                                              ...
  366:  set *tmp159 "[]"                                            ...
  367:  jump *label101 always 0 0                                    ...
        label *label117                                              ...
  368:  set *tmp159 "[]"                                            ...
  369:  jump *label101 always 0 0                                    ...
        label *label121                                              ...
  370:  set *tmp159 "[]"                                            ...
  371:  jump *label101 always 0 0                                    ...
        label *label123                                              ...
  372:  set *tmp159 "[]"                                            ...
  373:  jump *label101 always 0 0                                    ...
        label *label125                                              ...
  374:  set *tmp159 "[]"                                            ...
  375:  jump *label101 always 0 0                                    ...
        label *label127                                              ...
  376:  set *tmp159 "[]"                                            ...
  377:  jump *label101 always 0 0                                    ...
        label *label129                                              ...
  378:  set *tmp159 "[]"                                            ...
  379:  jump *label101 always 0 0                                    ...
        label *label131                                              ...
  380:  set *tmp159 "[]"                                            ...
  381:  jump *label101 always 0 0                                    ...
        label *label133                                              ...
  382:  set *tmp159 "[]"                                            ...
  383:  jump *label101 always 0 0                                    ...
        label *label261                                              ...
  384:  set *tmp159 null                                             ...
        label *label101                                              ...
  385:  set .ITEM_ICON *tmp159                                       ITEM_ICON = itemTypeToIcon(ITEM);
  386:  set .STATE_LIMIT 1                                           STATE_LIMIT = S_UNLOAD;   // Switches all units to S_UNLOAD state
  387:  sensor :last_level .CONTAINER .ITEM                          last_level = CONTAINER.sensor(ITEM);
  388:  set :min_level 999999                                        min_level = 999999;
  389:  set :max_level 0                                             max_level = 0;
        label *label95                                               if ITEM != LAST_ITEM then
  390:  sensor :container_items .CONTAINER .ITEM                     container_items = CONTAINER.sensor(ITEM);
  391:  op min :min_level :min_level :container_items                min_level = min(min_level, container_items);
  392:  op max :max_level :max_level :container_items                max_level = max(max_level, container_items);
  393:  op sub :loop_time @tick .LOOP_START                          loop_time = @tick - LOOP_START;
  394:  set .LOOP_START @tick                                        LOOP_START = @tick;
  395:  op mul *tmp168 :loop_time 100                                loop_time_ms = (loop_time * 100) \ 6;
  396:  op idiv :loop_time_ms *tmp168 6                              ...
  397:  op greaterThanEq *tmp170 :transfers :active                  if transfers >= active or wait_time > WAIT_LIMIT then
  398:  op greaterThan *tmp171 :wait_time .WAIT_LIMIT                ...
  399:  op or *tmp172 *tmp170 *tmp171                                ...
  400:  jump *label134 equal *tmp172 false                           ...
  401:  op div *tmp174 :wait_time 100                                wait_time_str = ceil(wait_time / 100) / 10;
  402:  op ceil *tmp175 *tmp174 0                                    ...
  403:  op div :wait_time_str *tmp175 10                             ...
  404:  op sub :elapsed_ticks @tick .TRANSFER_START                  elapsed_ticks = @tick - TRANSFER_START;
  405:  set .TRANSFER_START @tick                                    TRANSFER_START = @tick;
  406:  op div :elapsed_ms :elapsed_ticks 0.06                       elapsed_ms = elapsed_ticks / 0.06;
  407:  op idiv *tmp180 :elapsed_ms 100                              elapsed_str = (elapsed_ms \ 100) / 10;
  408:  op div :elapsed_str *tmp180 10                               ...
  409:  op div :items_per_ms :transferred :elapsed_ms                items_per_ms = transferred / elapsed_ms;
  410:  op idiv :items_per_min :items_per_ms 0.000016666666666666667 items_per_min = items_per_ms \ (1.0 / 60000);    // save floor instruction; for display only
  411:  set :transferred 0                                           transferred = 0;
  412:  set :transfers 0                                             transfers = 0;
  413:  jump *label136 equal .EFF_AUTO_ALLOCATION false              if EFF_AUTO_ALLOCATION then
  414:  set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] AUTO_ALLOCATION_TXT = "\n=== [gold]Unit auto allocation[] ===";
  415:  op mul *tmp185 16.666666666666668 :loop_time                 turnaround_ms = TRAVEL_TIME + (LOOPS_TICKS_TO_MS * loop_time);
  416:  op add :turnaround_ms .TRAVEL_TIME *tmp185                   ...
  417:  op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION        WAIT_LIMIT = turnaround_ms * DEC_OVERALLOCATION;
  418:  op idiv *tmp188 :turnaround_ms 100                           turnaround_str = (turnaround_ms \ 100) / 10;
  419:  op div :turnaround_str *tmp188 10                            ...
  420:  op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms      items_per_ms_unit = UNIT_CAPACITY / turnaround_ms;
  421:  op idiv :items_per_min_unit :items_per_ms_unit 0.00001666666 items_per_min_unit = floor(items_per_ms_unit * 60000);
  422:  op add *tmp193 :min_level :max_level                         this_level = (min_level + max_level) / 2;
  423:  op div :this_level *tmp193 2                                 ...
  424:  op sub *tmp195 :last_level :this_level                       corr = (last_level - this_level) * FLOW_CORR_SIGN;
  425:  op mul :corr *tmp195 .FLOW_CORR_SIGN                         ...
  426:  op div :corr_per_ms :corr :elapsed_ms                        corr_per_ms = corr / elapsed_ms;
  427:  set :last_level :this_level                                  last_level = this_level;
  428:  op add :total_flow_per_ms :items_per_ms :corr_per_ms         total_flow_per_ms = items_per_ms + corr_per_ms;
  429:  op idiv :corr_per_min :corr_per_ms 0.000016666666666666667   corr_per_min = floor(60000 * corr_per_ms);
  430:  set .CORR_SIGN "[]([green]"                                  CORR_SIGN = corr_per_min >= 0 ? "[]([green]+" : "[]([green]";
  431:  jump *label139 lessThan :corr_per_min 0                      ...
  432:  set .CORR_SIGN "[]([green]+"                                 ...
        label *label139                                              ...
  433:  set .SPEED_UNIT_TXT "[])/min"                                SPEED_UNIT_TXT = "[])/min";
  434:  jump *label140 equal :alive false                            if alive then
  435:  op lessThan *tmp204 :min_level .LOW_LEVEL_TRIGGER            trigger = min_level < LOW_LEVEL_TRIGGER or max_level > HIGH_LEVEL_TRIGGER;
  436:  op greaterThan *tmp205 :max_level .HIGH_LEVEL_TRIGGER        ...
  437:  op or :trigger *tmp204 *tmp205                               ...
  438:  op equal *tmp207 :wait_time 0                                if wait_time == 0 or (trigger > remote_wait_time) then
  439:  op greaterThan *tmp208 :trigger :remote_wait_time            ...
  440:  op or *tmp209 *tmp207 *tmp208                                ...
  441:  jump *label142 equal *tmp209 false                           ...
  442:  jump *label144 equal STABILIZATION false                     if STABILIZATION then
  443:  set :total_flow_3 :total_flow_2                              total_flow_3 = total_flow_2;
  444:  set :total_flow_2 :total_flow_1                              total_flow_2 = total_flow_1;
  445:  set :total_flow_1 :total_flow_per_ms                         total_flow_1 = total_flow_per_ms;
  446:  op add *tmp212 :total_flow_3 :total_flow_2                   total_flow_per_ms = (total_flow_3 + total_flow_2 + total_flow_1) / 3;
  447:  op add *tmp213 *tmp212 :total_flow_per_ms                    ...
  448:  op div :total_flow_per_ms *tmp213 3                          ...
        label *label144                                              if STABILIZATION then
  449:  op div *tmp215 :total_flow_per_ms :items_per_ms_unit         new_target = ceil(total_flow_per_ms / items_per_ms_unit + INC_OVERALLOCATION);
  450:  op add *tmp216 *tmp215 OVERALLOCATION_LOW                    ...
  451:  op ceil :new_target *tmp216 0                                ...
  452:  op mul :level_boost 2 :trigger                               level_boost = TRIGGER_BOOST * trigger;
  453:  op add *tmp219 :new_target :level_boost                      new_target = min(new_target + level_boost, MAX_UNITS);
  454:  op min :new_target *tmp219 MAX_UNITS                         ...
  455:  op sub *tmp221 :new_target :active                           new_change = min(max(new_target - active, 0), INC_LIMIT);
  456:  op max *tmp222 *tmp221 0                                     ...
  457:  op min :new_change *tmp222 .INC_LIMIT                        ...
  458:  set .INC_LIMIT 6                                             INC_LIMIT = INC_MAX;                           // Can increase again next time
  459:  op lessThanEq *tmp224 :new_change 0                          DEC_LIMIT = (new_change <= 0) * DEC_MAX;       // No decreases after an increase
  460:  op mul .DEC_LIMIT *tmp224 -1                                 ...
  461:  jump *label143 always 0 0                                    if wait_time == 0 or (trigger > remote_wait_time) then
        label *label142                                              ...
  462:  op idiv *tmp226 :wait_time .WAIT_LIMIT                       new_change = max(-1 * (wait_time \ WAIT_LIMIT), DEC_LIMIT);
  463:  op mul *tmp227 -1 *tmp226                                    ...
  464:  op max :new_change *tmp227 .DEC_LIMIT                        ...
  465:  op greaterThanEq *tmp229 :new_change 0                       INC_LIMIT = (new_change >= 0) * INC_MAX;       // No increases after a decrease
  466:  op mul .INC_LIMIT *tmp229 6                                  ...
  467:  set .DEC_LIMIT -1                                            DEC_LIMIT = DEC_MAX;                           // Can decrease again next time
        label *label143                                              if wait_time == 0 or (trigger > remote_wait_time) then
  468:  op add *tmp231 :active :new_change                           TARGET = max(active + new_change, 1);
  469:  op max .TARGET *tmp231 1                                     ...
  470:  jump *label141 always 0 0                                    if alive then
        label *label140                                              ...
  471:  set .INC_LIMIT 0                                             INC_LIMIT = 0;
  472:  set .DEC_LIMIT 0                                             DEC_LIMIT = 0;
        label *label141                                              if alive then
  473:  set :min_level 999999                                        min_level = 999999;
  474:  set :max_level 0                                             max_level = 0;
        label *label136                                              if EFF_AUTO_ALLOCATION then
  475:  op greaterThan *tmp233 .CONTAINERS 1                         if CONTAINERS > 1 and SRC == CORE then
  476:  op equal *tmp234 .SRC .CORE                                  ...
  477:  op land *tmp235 *tmp233 *tmp234                              ...
  478:  jump *label146 equal *tmp235 false                           ...
  479:  sensor *tmp237 .DST .ITEM                                    max_drop = DROP_LEVEL - DST.sensor(ITEM);
  480:  op sub :max_drop .DROP_LEVEL *tmp237                         ...
  481:  jump *label148 greaterThanEq :max_drop .DROP_PACK            if max_drop < DROP_PACK then
  482:  set :findAnotherContainer:min_level 999999                   min_level = 999999;
  483:  set .CONTAINERS 0                                            CONTAINERS = 0;
  484:  set :findAnotherContainer:n @links                           n = @links;
  485:  jump *label153 lessThanEq :findAnotherContainer:n 0          while n > 0 do
        label *label256                                              ...
  486:  op sub :findAnotherContainer:n :findAnotherContainer:n 1     n = n - 1;
  487:  getlink :findAnotherContainer:block :findAnotherContainer:n  block = getlink(n);
  488:  sensor *tmp247 :findAnotherContainer:block @type             case block.@type
  489:  jump *label156 equal *tmp247 @vault                          ...
  490:  jump *label155 notEqual *tmp247 @container                   ...
        label *label156                                              ...
  491:  op add .CONTAINERS .CONTAINERS 1                             CONTAINERS += 1;
  492:  sensor :findAnotherContainer:level :findAnotherContainer:blo level = block.sensor(ITEM);
  493:  jump *label157 greaterThanEq :findAnotherContainer:level :fi if level < min_level then
  494:  set :findAnotherContainer:min_level :findAnotherContainer:le min_level = level;
  495:  set .CONTAINER :findAnotherContainer:block                   CONTAINER = block;
  496:  set .CONTAINER_INDEX :findAnotherContainer:n                 CONTAINER_INDEX = n;
        label *label157                                              if level < min_level then
        label *label155                                              case block.@type
  497:  jump *label256 greaterThan :findAnotherContainer:n 0         while n > 0 do
        label *label153                                              ...
  498:  jump *label159 notEqual .CONTAINERS 0                        if CONTAINERS == 0 then
  499:  set .CONTAINER @this                                         CONTAINER = @this;
  500:  jump *label160 always 0 0                                    if CONTAINERS == 0 then
        label *label159                                              ...
  501:  set .DST .CONTAINER                                          DST = CONTAINER;
  502:  sensor :findAnotherContainer:dst_capacity .CONTAINER @itemCa dst_capacity = DST.@itemCapacity;
  503:  op mul *tmp255 :findAnotherContainer:dst_capacity .EFF_LOCAL DROP_LEVEL = (dst_capacity * EFF_LOCAL_LIMIT) \ 100;
  504:  op idiv .DROP_LEVEL *tmp255 100                              ...
  505:  set .LOCAL_MARGIN .DROP_LEVEL                                LOCAL_MARGIN = DROP_LEVEL;
  506:  op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity LOW_LEVEL_TRIGGER = dst_capacity * (1 - TRIGGER_LEVEL);
  507:  set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity   HIGH_LEVEL_TRIGGER = dst_capacity;  // never triggers
  508:  sensor .DST_X .CONTAINER @x                                  DST_X = DST.@x;
  509:  sensor .DST_Y .CONTAINER @y                                  DST_Y = DST.@y;
  510:  op sub *tmp261 .DST_X .SRC_X                                 DISTANCE = len(DST_X - SRC_X, DST_Y - SRC_Y) - RADIUS_APPROACH - RADIUS_WITHIN;
  511:  op sub *tmp262 .DST_Y .SRC_Y                                 ...
  512:  op len *tmp263 *tmp261 *tmp262                               ...
  513:  op sub .DISTANCE *tmp263 14                                  ...
  514:  op max *tmp266 .DISTANCE 10                                  TRAVEL_TIME = (2 * max(DISTANCE, 10)) / SPEED;   // Travel time: both ways, in tiles/ms
  515:  op mul *tmp267 2 *tmp266                                     ...
  516:  op div .TRAVEL_TIME *tmp267 .SPEED                           ...
  517:  set .MESSAGE "[salmon]Container filled up, switching...[]\n" MESSAGE = "[salmon]Container filled up, switching...[]\n";
  518:  op add .MESSAGE_TIMEOUT @tick 600                            MESSAGE_TIMEOUT = @tick + 600;      // Ten seconds
        label *label160                                              if CONTAINERS == 0 then
  519:  set :last_level :findAnotherContainer:min_level              last_level = this_level = findAnotherContainer();
        label *label148                                              if max_drop < DROP_PACK then
        label *label146                                              if CONTAINERS > 1 and SRC == CORE then
  520:  set :wait_time 0                                             wait_time = 0;
  521:  set :remote_wait_time 0                                      remote_wait_time = 0;
  522:  jump *label161 lessThan @tick .MESSAGE_TIMEOUT               if @tick >= MESSAGE_TIMEOUT then
  523:  set .MESSAGE ""                                              MESSAGE = "";
        label *label161                                              if @tick >= MESSAGE_TIMEOUT then
        label *label134                                              if transfers >= active or wait_time > WAIT_LIMIT then
  524:  print .MESSAGE                                               print(MESSAGE);
  525:  print "Moving [green]"                                       print($"Moving [green]$ITEM[]$DIRECTION$LINK_TXT");
  526:  print .ITEM                                                  ...
  527:  print "[]"                                                   ...
  528:  print .DIRECTION                                             ...
  529:  print *tmp101                                                ...
  530:  print .AUTO_ALLOCATION_TXT                                   print(AUTO_ALLOCATION_TXT);
  531:  jump *label163 lessThanEq .TARGET 0                          if TARGET > 0 then
  532:  jump *label165 lessThan :active .TARGET                      if active >= TARGET then
  533:  print "\nUsing [green]"                                      print($"\nUsing [green]$active/$TARGET[] units ($UNIT) [gold]+$items_in_transit");
  534:  print :active                                                ...
  535:  print "/"                                                    ...
  536:  print .TARGET                                                ...
  537:  print "[] units ("                                           ...
  538:  print UNIT                                                   ...
  539:  print ") [gold]+"                                            ...
  540:  print :items_in_transit                                      ...
  541:  jump *label166 always 0 0                                    if active >= TARGET then
        label *label165                                              ...
  542:  print "\nUsing [salmon]"                                     print($"\nUsing [salmon]$active/$TARGET[] units ($UNIT) [gold]+$items_in_transit");
  543:  print :active                                                ...
  544:  print "/"                                                    ...
  545:  print .TARGET                                                ...
  546:  print "[] units ("                                           ...
  547:  print UNIT                                                   ...
  548:  print ") [gold]+"                                            ...
  549:  print :items_in_transit                                      ...
        label *label166                                              if active >= TARGET then
  550:  jump *label167 lessThanEq .CHANGE 0                          if CHANGE > 0 then
  551:  print "\n[][salmon]Cannot acquire additional units![]"       print("\n[][salmon]Cannot acquire additional units![]");
        label *label167                                              if CHANGE > 0 then
        label *label163                                              if TARGET > 0 then
  552:  print "\n[]Local items: [gold]"                              print($"\n[]Local items: [gold]$container_items");
  553:  print :container_items                                       ...
  554:  jump *label169 greaterThanEq .EFF_LOCAL_LIMIT 100            if EFF_LOCAL_LIMIT < 100 then
  555:  print "[] (limit [orange]"                                   print($"[] (limit [orange]$LOCAL_MARGIN[])");
  556:  print .LOCAL_MARGIN                                          ...
  557:  print "[])"                                                  ...
        label *label169                                              if EFF_LOCAL_LIMIT < 100 then
  558:  jump *label171 equal .SHOW_REMOTE_LEVEL false                if SHOW_REMOTE_LEVEL then
  559:  sensor :remote_level .CORE .ITEM                             remote_level = CORE.sensor(ITEM);
  560:  print "\n[]Remote items: [gold]"                             print($"\n[]Remote items: [gold]$remote_level");
  561:  print :remote_level                                          ...
  562:  jump *label173 greaterThanEq .EFF_REMOTE_LIMIT 100           if EFF_REMOTE_LIMIT < 100 then
  563:  print "[] (limit [orange]"                                   print($"[] (limit [orange]$REMOTE_MARGIN[])");
  564:  print .REMOTE_MARGIN                                         ...
  565:  print "[])"                                                  ...
        label *label173                                              if EFF_REMOTE_LIMIT < 100 then
        label *label171                                              if SHOW_REMOTE_LEVEL then
  566:  jump *label175 lessThanEq .TARGET 0                          if TARGET > 0 then
  567:  print "\n[]Speed: [green]"                                   print($"\n[]Speed: [green]$items_per_min$CORR_SIGN$corr_per_min$SPEED_UNIT_TXT");
  568:  print :items_per_min                                         ...
  569:  print .CORR_SIGN                                             ...
  570:  print :corr_per_min                                          ...
  571:  print .SPEED_UNIT_TXT                                        ...
  572:  jump *label177 equal .EFF_AUTO_ALLOCATION false              if EFF_AUTO_ALLOCATION then
  573:  print "\nUnit throughput: [green]"                           print($"\nUnit throughput: [green]$items_per_min_unit[]/min");
  574:  print :items_per_min_unit                                    ...
  575:  print "[]/min\nMin/last round: [green]"                      print($"\nMin/last round: [green]$turnaround_str[]/[green]$elapsed_str[] s");
  576:  print :turnaround_str                                        ...
  577:  print "[]/[green]"                                           ...
  578:  print :elapsed_str                                           ...
  579:  print "[] s"                                                 ...
  580:  jump *label178 always 0 0                                    if EFF_AUTO_ALLOCATION then
        label *label177                                              ...
  581:  print "\nLast round: [green]"                                print($"\nLast round: [green]$elapsed_str[] s");
  582:  print :elapsed_str                                           ...
  583:  print "[] s"                                                 ...
        label *label178                                              if EFF_AUTO_ALLOCATION then
  584:  print "\nTotal wait time: [green]"                           print($"\nTotal wait time: [green]$wait_time_str[] s");
  585:  print :wait_time_str                                         ...
  586:  print "[] s"                                                 ...
        label *label175                                              if TARGET > 0 then
  587:  print "\n[lightgray]Loop: "                                  print($"\n[lightgray]Loop: $loop_time_ms ms");
  588:  print :loop_time_ms                                          ...
  589:  print " ms"                                                  ...
  590:  printflush message1                                          printflush(message1);
  591:  op sub .CHANGE .TARGET :active                               CHANGE = TARGET - active;
  592:  set :active 0                                                active = 0;
  593:  set :first_unit @unit                                        first_unit = @unit;
  594:  set :items_in_transit 0                                      items_in_transit = 0;
  595:  print "Unit status:"                                         print("Unit status:");       // For message2
  596:  sensor *tmp289 .SRC @dead                                    if SRC.@dead != 0 then break; end;
  597:  jump *label79 notEqual *tmp289 0                             ...
  598:  sensor *tmp292 .DST @dead                                    if DST.@dead != 0 then break; end;
  599:  jump *label79 notEqual *tmp292 0                             ...
  600:  sensor *tmp295 .SORTER @dead                                 if SORTER.@dead != 0 then break; end;
  601:  jump *label79 notEqual *tmp295 0                             ...
  602:  getlink *tmp298 .CONTAINER_INDEX                             if CONTAINER != getlink(CONTAINER_INDEX) then break; end;
  603:  jump *label79 notEqual .CONTAINER *tmp298                    ...
        label *label91                                               if alive <= (@unit == first_unit) then
  604:  jump *label187 lessThanEq .CHANGE 0                          if CHANGE > 0 then
  605:  sensor *tmp303 @unit @controlled                             if @unit.@controlled == 0 then
  606:  jump *label189 notEqual *tmp303 0                            ...
  607:  op sub .CHANGE .CHANGE 1                                     CHANGE -= 1;
  608:  ucontrol flag 1 0 0 0 0                                      flag(S_FIRST);
        label *label189                                              if @unit.@controlled == 0 then
        label *label187                                              if CHANGE > 0 then
  609:  sensor *tmp306 @unit @controller                             if @unit.@controller == @this then
  610:  jump *label77 notEqual *tmp306 @this                         ...
  611:  sensor :state @unit @flag                                    state = @unit.@flag;
  612:  jump *label77 equal :state .S_UNUSED                         if state != S_UNUSED then
  613:  op max *tmp312 :state 1                                      state = min(max(state, S_FIRST), STATE_LIMIT);
  614:  op min :state *tmp312 .STATE_LIMIT                           ...
  615:  jump *label195 greaterThanEq .CHANGE 0                       if CHANGE < 0 then
  616:  jump *label197 equal :state 6                                if state != S_DISCARD then
  617:  sensor *tmp318 @unit @totalItems                             if @unit.@totalItems <= DISCARD_UNIT_MAX_ITEMS then
  618:  jump *label199 greaterThan *tmp318 .DISCARD_UNIT_MAX_ITEMS   ...
  619:  op add .CHANGE .CHANGE 1                                     CHANGE += 1;
  620:  set :state 6                                                 state = S_DISCARD;
        label *label199                                              if @unit.@totalItems <= DISCARD_UNIT_MAX_ITEMS then
        label *label197                                              if state != S_DISCARD then
        label *label195                                              if CHANGE < 0 then
  621:  jump *label201 notEqual :state 1                             if state == S_UNLOAD then
  622:  set :state 2                                                 state = S_APPROACH_SRC;
  623:  sensor *tmp323 @unit @totalItems                             if @unit.@totalItems == 0 then
  624:  jump *label204 equal *tmp323 0                               ...
  625:  set :state 4                                                 state = S_APPROACH_DST;
  626:  sensor *tmp326 @unit @firstItem                              elsif @unit.@firstItem == ITEM then
  627:  jump *label206 equal *tmp326 .ITEM                           ...
  628:  jump *label207 equal .DROP_TO_CORE false                     elsif DROP_TO_CORE then
  629:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  630:  ucontrol within .CORE_X .CORE_Y 8 *tmp330 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  631:  jump *label209 equal *tmp330 false                           ...
  632:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label209                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  633:  print "[]\nUnloading previous items: [green]"                print($"[]\nUnloading previous items: [green]");
  634:  jump *label208 always 0 0                                    elsif DROP_TO_CORE then
        label *label207                                              ...
  635:  ucontrol itemDrop @air .UNIT_CAPACITY 0 0 0                  itemDrop(@air, UNIT_CAPACITY);
  636:  set :state 2                                                 state = S_APPROACH_SRC;
        label *label208                                              elsif DROP_TO_CORE then
        label *label206                                              elsif @unit.@firstItem == ITEM then
        label *label204                                              if @unit.@totalItems == 0 then
        label *label201                                              if state == S_UNLOAD then
  637:  jump *label211 notEqual :state 2                             if state == S_APPROACH_SRC then
  638:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  639:  ucontrol within .SRC_X .SRC_Y 8 *tmp334 0                    if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
  640:  jump *label213 equal *tmp334 false                           ...
  641:  set :state 3                                                 state = S_LOAD_ITEMS;
  642:  jump *label214 always 0 0                                    if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label213                                              ...
  643:  sensor *tmp338 @unit @x                                      print($"[]\n[gold]$ sec[] to $name: [green]", len(x - @unit.@x, y - @unit.@y) \ SPEED_SEC / 10);
  644:  op sub *tmp339 .SRC_X *tmp338                                ...
  645:  sensor *tmp340 @unit @y                                      ...
  646:  op sub *tmp341 .SRC_Y *tmp340                                ...
  647:  op len *tmp342 *tmp339 *tmp341                               ...
  648:  op idiv *tmp343 *tmp342 .SPEED_SEC                           ...
  649:  op div *tmp344 *tmp343 10                                    ...
  650:  print "[]\n[gold]"                                           ...
  651:  print *tmp344                                                ...
  652:  print " sec[] to source: [green]"                            ...
        label *label214                                              if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label211                                              if state == S_APPROACH_SRC then
  653:  jump *label218 notEqual :state 3                             if state == S_LOAD_ITEMS then
  654:  sensor *tmp347 .SRC .ITEM                                    max_load = SRC.sensor(ITEM) - LOAD_LEVEL;
  655:  op sub :max_load *tmp347 .LOAD_LEVEL                         ...
  656:  jump *label220 lessThan :max_load .LOAD_PACK                 if max_load >= LOAD_PACK then
  657:  ucontrol itemTake .SRC .ITEM :max_load 0 0                   itemTake(SRC, ITEM, max_load);
        label *label220                                              if max_load >= LOAD_PACK then
  658:  sensor *tmp351 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  659:  jump *label222 lessThan *tmp351 .UNIT_CAPACITY               ...
  660:  set :state 4                                                 state = S_APPROACH_DST;
  661:  jump *label223 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label222                                              ...
  662:  print "[]\nWaiting at source: [green]"                       print($"[]\nWaiting at source: [green]");
  663:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  664:  op add :wait_time :wait_time :loop_time_ms                   wait_time += loop_time_ms;
  665:  op mul *tmp354 :loop_time_ms .SRC_REMOTE_WAIT                remote_wait_time += loop_time_ms * SRC_REMOTE_WAIT;
  666:  op add :remote_wait_time :remote_wait_time *tmp354           ...
        label *label223                                              if @unit.@totalItems >= UNIT_CAPACITY then
        label *label218                                              if state == S_LOAD_ITEMS then
  667:  jump *label224 notEqual :state 4                             if state == S_APPROACH_DST then
  668:  ucontrol approach .DST_X .DST_Y 6 0 0                        approach(DST_X, DST_Y, RADIUS_APPROACH);
  669:  ucontrol within .DST_X .DST_Y 8 *tmp357 0                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
  670:  jump *label226 equal *tmp357 false                           ...
  671:  sensor *tmp359 @unit @totalItems                             transferred += @unit.@totalItems;
  672:  op add :transferred :transferred *tmp359                     ...
  673:  op add :transfers :transfers 1                               transfers += 1;
  674:  set :state 5                                                 state = S_DROP_ITEMS;
  675:  jump *label227 always 0 0                                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label226                                              ...
  676:  sensor *tmp362 @unit @x                                      print($"[]\n[gold]$ sec[] to $name: [green]", len(x - @unit.@x, y - @unit.@y) \ SPEED_SEC / 10);
  677:  op sub *tmp363 .DST_X *tmp362                                ...
  678:  sensor *tmp364 @unit @y                                      ...
  679:  op sub *tmp365 .DST_Y *tmp364                                ...
  680:  op len *tmp366 *tmp363 *tmp365                               ...
  681:  op idiv *tmp367 *tmp366 .SPEED_SEC                           ...
  682:  op div *tmp368 *tmp367 10                                    ...
  683:  print "[]\n[gold]"                                           ...
  684:  print *tmp368                                                ...
  685:  print " sec[] to destination: [green]"                       ...
        label *label227                                              if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label224                                              if state == S_APPROACH_DST then
  686:  jump *label231 notEqual :state 5                             if state == S_DROP_ITEMS then
  687:  sensor *tmp371 .DST .ITEM                                    max_drop = DROP_LEVEL - DST.sensor(ITEM);
  688:  op sub :max_drop .DROP_LEVEL *tmp371                         ...
  689:  jump *label233 lessThan :max_drop .DROP_PACK                 if max_drop >= DROP_PACK then
  690:  ucontrol itemDrop .DST :max_drop 0 0 0                       itemDrop(DST, max_drop);
        label *label233                                              if max_drop >= DROP_PACK then
  691:  sensor *tmp375 @unit @totalItems                             if @unit.@totalItems <= 0 then
  692:  jump *label235 greaterThan *tmp375 0                         ...
  693:  set :state 2                                                 state = S_APPROACH_SRC;
  694:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  695:  sensor *tmp380 @unit @x                                      print($"[]\n[gold]$ sec[] to $name: [green]", len(x - @unit.@x, y - @unit.@y) \ SPEED_SEC / 10);
  696:  op sub *tmp381 .SRC_X *tmp380                                ...
  697:  sensor *tmp382 @unit @y                                      ...
  698:  op sub *tmp383 .SRC_Y *tmp382                                ...
  699:  op len *tmp384 *tmp381 *tmp383                               ...
  700:  op idiv *tmp385 *tmp384 .SPEED_SEC                           ...
  701:  op div *tmp386 *tmp385 10                                    ...
  702:  print "[]\n[gold]"                                           ...
  703:  print *tmp386                                                ...
  704:  print " sec[] to source: [green]"                            ...
  705:  jump *label236 always 0 0                                    if SHOW_UNIT_DISTANCE then
        label *label235                                              if @unit.@totalItems <= 0 then
  706:  print "[]\nWaiting at destination: [green]"                  print($"[]\nWaiting at destination: [green]");
  707:  ucontrol approach .DST_X .DST_Y 6 0 0                        approach(DST_X, DST_Y, RADIUS_APPROACH);
  708:  op add :wait_time :wait_time :loop_time_ms                   wait_time += loop_time_ms;
  709:  op mul *tmp387 :loop_time_ms .DST_REMOTE_WAIT                remote_wait_time += loop_time_ms * DST_REMOTE_WAIT;
  710:  op add :remote_wait_time :remote_wait_time *tmp387           ...
        label *label236                                              if @unit.@totalItems <= 0 then
        label *label231                                              if state == S_DROP_ITEMS then
  711:  sensor :items @unit @totalItems                              items = @unit.@totalItems;
  712:  op add :items_in_transit :items_in_transit :items            items_in_transit += items;
  713:  jump *label240 notEqual :state 6                             if state == S_DISCARD then
  714:  print "[]\nParking: [green]"                                 print($"[]\nParking: [green]");
  715:  jump *label242 lessThanEq :items 0                           if items > 0 then
  716:  jump *label244 equal .DROP_TO_CORE false                     if DROP_TO_CORE then
  717:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  718:  ucontrol within .CORE_X .CORE_Y 8 *tmp394 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  719:  jump *label245 equal *tmp394 false                           ...
  720:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
  721:  sensor :items @unit @totalItems                              items = @unit.@totalItems;
  722:  jump *label245 always 0 0                                    if DROP_TO_CORE then
        label *label244                                              ...
  723:  ucontrol itemDrop @air .UNIT_CAPACITY 0 0 0                  itemDrop(@air, UNIT_CAPACITY);
  724:  sensor :items @unit @totalItems                              items = @unit.@totalItems;
        label *label245                                              if DROP_TO_CORE then
        label *label242                                              if items > 0 then
  725:  jump *label241 greaterThan :items .PARK_ITEM_LIMIT           if items <= PARK_ITEM_LIMIT then
  726:  ucontrol move .PARK_X .PARK_Y 0 0 0                          move(PARK_X, PARK_Y);
  727:  set :state .S_UNUSED                                         state = S_UNUSED;
  728:  jump *label241 always 0 0                                    if state == S_DISCARD then
        label *label240                                              ...
  729:  op add :active :active 1                                     active += 1;
        label *label241                                              if state == S_DISCARD then
  730:  print :items                                                 print(items, ITEM_ICON);
  731:  print .ITEM_ICON                                             ...
  732:  ucontrol flag :state 0 0 0 0                                 flag(state);
  733:  jump *label77 always 0 0                                     while true do
        label *label79                                               ...
  734:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  735:  control enabled switch2 false 0 0 0                          switch2.enabled = false;


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   615     1x    615,0  <no function>
    52     1x     52,0  def itemTypeToIcon(in itemType)
    37     1x     37,0  def findAnotherContainer()
    31     3x     10,3  inline def printUnitInfo(in name, in x, in y)
     1     1x      1,0  inline void printflush()

Performance: parsed in 795 ms, compiled in 330 ms, optimized in 1,445 ms, run in 5 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (38 steps):
Configurable options:Which unit type to use:Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core:Start in auto allocation mode?Max units to use, in both manual and auto allocation modes:Leave discarded units with nonzero flag for housekeeping (flag-clearing) processor to pick them up:Drop superfluous items to air, even when there's a core:How much of local container capacity to use, in percents (20-100):How much of remote container capacity to use, in percents (20-100)Allocate at least this much more units than needed:Allocate at most this much more units than needed:Use average of last three flow rate values for better unit auto allocation stability:End of configurable options
Execution exception at instruction 37: ubind UNIT:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
