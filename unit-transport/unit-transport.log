  1224 instructions before optimizations.
   109 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
     3 instructions eliminated by Case Expression Optimization.
   135 instructions eliminated by Dead Code Elimination (8 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 7 iterations).
    78 instructions eliminated by Condition Optimization (2 passes, 9 iterations).
    61 instructions eliminated by Single Step Elimination (4 passes, 11 iterations).
     2 instructions eliminated by Expression Optimization (4 iterations).
     1 instructions eliminated by Boolean Optimization (8 iterations).
       1 final jumps of a short-circuited expression optimized.
     9 instructions eliminated by If Expression Optimization (2 passes, 4 iterations).
    28 instructions eliminated by Data Flow Optimization (2 passes, 12 iterations).
     1 loops improved by Loop Hoisting.
       2 loop conditions were fully rotated.
       9 loop conditions were partially rotated.
     2 instructions added by Case Switching (7 iterations).
     1 case expressions converted to switched jumps by Case Switching.
    26 instructions eliminated by Jump Straightening (2 passes, 9 iterations).
     7 instructions updated by Jump Threading.
     2 instructions eliminated by Unreachable Code Elimination (3 iterations).
    56 instructions eliminated by Print Merging.
   713 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 218):
  * Partial loop rotation at line 156:9                          size    +1, benefit      312.5, efficiency    312.500 (+1 instructions)
    Partial loop rotation at line 169:13                         size    +1, benefit      156.3, efficiency    156.250
    Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
    Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 217):
  * Partial loop rotation at line 169:13                         size    +1, benefit      156.3, efficiency    156.250 (+1 instructions)
    Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
    Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 216):
  o Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
  * Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844 (+2 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-3 instructions):
 
   116 getlink *tmp26 :n
   117 set :block *tmp26
   118 sensor *tmp28 :block @type
-    * set *tmp29 *tmp28
-    * jump *label31 equal *tmp29 @vault
-    * jump *label31 equal *tmp29 @container
+  119 jump *label31 equal *tmp28 @vault
+  120 jump *label31 equal *tmp28 @container
   121 jump *label30 always
   122 label *label31
   123 set .CONTAINER :block
 
   565 set .LAST_ITEM .ITEM
   566 set :itemTypeToIcon:itemType .ITEM
   567 sensor *tmp156 :itemTypeToIcon:itemType @id
-    * set *tmp157 *tmp156
-    * jump *label110 equal *tmp157 14
+  568 jump *label110 equal *tmp156 14
   569 jump *label109 always
   570 label *label110
   571 set *tmp155 "[]"
   572 jump *label108 always
   573 label *label109
-    * jump *label112 equal *tmp157 5
+  574 jump *label112 equal *tmp156 5
   575 jump *label111 always
   576 label *label112
   577 set *tmp155 "[]"
   578 jump *label108 always
   579 label *label111
-    * jump *label114 equal *tmp157 0
+  580 jump *label114 equal *tmp156 0
   581 jump *label113 always
   582 label *label114
   583 set *tmp155 "[]"
   584 jump *label108 always
   585 label *label113
-    * jump *label116 equal *tmp157 3
+  586 jump *label116 equal *tmp156 3
   587 jump *label115 always
   588 label *label116
   589 set *tmp155 "[]"
   590 jump *label108 always
   591 label *label115
-    * jump *label118 equal *tmp157 1
+  592 jump *label118 equal *tmp156 1
   593 jump *label117 always
   594 label *label118
   595 set *tmp155 "[]"
   596 jump *label108 always
   597 label *label117
-    * jump *label120 equal *tmp157 2
+  598 jump *label120 equal *tmp156 2
   599 jump *label119 always
   600 label *label120
   601 set *tmp155 "[]"
   602 jump *label108 always
   603 label *label119
-    * jump *label122 equal *tmp157 11
+  604 jump *label122 equal *tmp156 11
   605 jump *label121 always
   606 label *label122
   607 set *tmp155 "[]"
   608 jump *label108 always
   609 label *label121
-    * jump *label124 equal *tmp157 10
+  610 jump *label124 equal *tmp156 10
   611 jump *label123 always
   612 label *label124
   613 set *tmp155 "[]"
   614 jump *label108 always
   615 label *label123
-    * jump *label126 equal *tmp157 15
+  616 jump *label126 equal *tmp156 15
   617 jump *label125 always
   618 label *label126
   619 set *tmp155 "[]"
   620 jump *label108 always
   621 label *label125
-    * jump *label128 equal *tmp157 4
+  622 jump *label128 equal *tmp156 4
   623 jump *label127 always
   624 label *label128
   625 set *tmp155 "[]"
   626 jump *label108 always
   627 label *label127
-    * jump *label130 equal *tmp157 8
+  628 jump *label130 equal *tmp156 8
   629 jump *label129 always
   630 label *label130
   631 set *tmp155 "[]"
   632 jump *label108 always
   633 label *label129
-    * jump *label132 equal *tmp157 9
+  634 jump *label132 equal *tmp156 9
   635 jump *label131 always
   636 label *label132
   637 set *tmp155 "[]"
   638 jump *label108 always
   639 label *label131
-    * jump *label134 equal *tmp157 13
+  640 jump *label134 equal *tmp156 13
   641 jump *label133 always
   642 label *label134
   643 set *tmp155 "[]"
   644 jump *label108 always
   645 label *label133
-    * jump *label136 equal *tmp157 12
+  646 jump *label136 equal *tmp156 12
   647 jump *label135 always
   648 label *label136
   649 set *tmp155 "[]"
   650 jump *label108 always
   651 label *label135
-    * jump *label138 equal *tmp157 7
+  652 jump *label138 equal *tmp156 7
   653 jump *label137 always
   654 label *label138
   655 set *tmp155 "[]"
   656 jump *label108 always
   657 label *label137
-    * jump *label140 equal *tmp157 6
+  658 jump *label140 equal *tmp156 6
   659 jump *label139 always
   660 label *label140
   661 set *tmp155 "[]"
 
   858 getlink *tmp238 :findAnotherContainer:n
   859 set :findAnotherContainer:block *tmp238
   860 sensor *tmp240 :findAnotherContainer:block @type
-    * set *tmp241 *tmp240
-    * jump *label173 equal *tmp241 @vault
-    * jump *label173 equal *tmp241 @container
+  861 jump *label173 equal *tmp240 @vault
+  862 jump *label173 equal *tmp240 @container
   863 jump *label172 always
   864 label *label173
   865 op add .CONTAINERS .CONTAINERS 1

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-90 instructions):
 
    80 op lessThan *tmp17 :state 6
    81 op land *tmp18 *tmp16 *tmp17
    82 op add .TARGET .TARGET *tmp18
-    * set *tmp14 .TARGET
    83 jump *label21 always
    84 label *label20
-    * set *tmp14 null
    85 label *label21
    86 ubind UNIT
    87 label *label18
 
   121 set .CONTAINER :block
   122 op add .CONTAINERS .CONTAINERS 1
   123 set .CONTAINER_INDEX :n
-    * set *tmp27 .CONTAINER_INDEX
   124 jump *label29 always
   125 label *label30
-    * set *tmp27 null
   126 label *label29
   127 label *label27
   128 jump *label26 always
 
   131 jump *label32 equal *tmp30 false
   132 print "[salmon]No vault or container."
   133 printflush message1
-    * set *tmp31 null
   134 jump *label33 always
   135 label *label32
   136 jump *label25 always
-    * set *tmp31 null
   137 label *label33
   138 label *label24
   139 jump *label23 always
 
   153 ulocate building core false @copper .CORE_X .CORE_Y *tmp39 *tmp38
   154 set .CORE *tmp38
   155 ucontrol flag .S_UNUSED
-    * set *tmp37 null
   156 jump *label40 always
   157 label *label39
-    * set *tmp37 null
   158 label *label40
   159 label *label37
   160 jump *label36 always
 
   162 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   163 op equal *tmp40 DROP_TO_AIR false
   164 set .DROP_TO_CORE *tmp40
-    * set *tmp33 .DROP_TO_CORE
   165 jump *label35 always
   166 label *label34
   167 printflush message2
 
   241 label *label59
   242 set *tmp61 null
   243 label *label60
-    * set *tmp50 *tmp61
   244 jump *label53 always
   245 label *label52
-    * set *tmp50 null
   246 label *label53
   247 ucontrol flag .S_UNUSED
   248 label *label42
 
   256 label *label62
   257 set .DISCARD_UNIT_MAX_ITEMS *tmp62
   258 set .DROP_TO_CORE false
-    * set *tmp33 .DROP_TO_CORE
   259 label *label35
   260 set .SORTER sorter1
   261 sensor *tmp63 .SORTER @type
 
   274 jump *label68 equal *tmp66 false
   275 print "Block found: "
   276 print .SORTER
-    * set *tmp67 .SORTER
   277 jump *label69 always
   278 label *label68
-    * set *tmp67 null
   279 label *label69
   280 printflush message1
   281 set .SORTER sorter1
 
   317 set *tmp81 " from vault #"
   318 label *label73
   319 set .DIRECTION *tmp81
-    * set *tmp70 .DIRECTION
   320 jump *label71 always
   321 label *label70
   322 op greaterThan *tmp82 LINK_ID 0
 
   353 set *tmp95 " to vault #"
   354 label *label75
   355 set .DIRECTION *tmp95
-    * set *tmp70 .DIRECTION
   356 label *label71
   357 op equal *tmp96 LINK_ID 0
   358 jump *label76 equal *tmp96 false
 
   437 set :corr_per_min 0
   438 set .SPEED_UNIT_TXT "[])/min"
   439 set .AUTO_ALLOCATION_TXT "\n=== [gold]Gathering statistics[] ==="
-    * set *tmp126 .AUTO_ALLOCATION_TXT
   440 jump *label83 always
   441 label *label82
   442 set .CORR_SIGN "[]"
   443 set :corr_per_min ""
   444 set .SPEED_UNIT_TXT "/min"
   445 set .AUTO_ALLOCATION_TXT ""
-    * set *tmp126 .AUTO_ALLOCATION_TXT
   446 label *label83
   447 label *label84
   448 jump *label86 equal true false
 
   471 set :corr_per_min ""
   472 set .SPEED_UNIT_TXT "/min"
   473 set .WAIT_LIMIT 30000
-    * set *tmp129 .WAIT_LIMIT
   474 jump *label91 always
   475 label *label90
-    * set *tmp129 null
   476 label *label91
   477 sensor *tmp133 switch2 @enabled
   478 jump *label92 equal *tmp133 false
 
   486 set .CORR_SIGN "[]([green]+"
   487 set :corr_per_min 0
   488 set .SPEED_UNIT_TXT "[])/min"
-    * set *tmp137 .SPEED_UNIT_TXT
   489 jump *label95 always
   490 label *label94
   491 set .EFF_AUTO_ALLOCATION false
 
   503 set *tmp141 ""
   504 label *label97
   505 set .AUTO_ALLOCATION_TXT *tmp141
-    * set *tmp137 .AUTO_ALLOCATION_TXT
   506 label *label95
   507 set .WAIT_LIMIT 30000
-    * set *tmp134 .WAIT_LIMIT
   508 jump *label93 always
   509 label *label92
-    * set *tmp134 null
   510 label *label93
   511 sensor *tmp142 :first_unit @dead
   512 op equal *tmp143 *tmp142 0
 
   517 op equal *tmp147 :active 0
   518 jump *label100 equal *tmp147 false
   519 print "\n[salmon]No active units.[]"
-    * set *tmp148 "\n[salmon]No active units.[]"
   520 jump *label101 always
   521 label *label100
-    * set *tmp148 null
   522 label *label101
   523 printflush message2
   524 set .STATE_LIMIT 6
 
   645 set :last_level *tmp158
   646 set :min_level 999999
   647 set :max_level 0
-    * set *tmp151 :max_level
   648 jump *label103 always
   649 label *label102
-    * set *tmp151 null
   650 label *label103
   651 sensor *tmp159 .CONTAINER .ITEM
   652 set :container_items *tmp159
 
   754 op add *tmp207 *tmp206 :total_flow_1
   755 op div *tmp208 *tmp207 3
   756 set :total_flow_per_ms *tmp208
-    * set *tmp205 :total_flow_per_ms
   757 jump *label160 always
   758 label *label159
-    * set *tmp205 null
   759 label *label160
   760 op div *tmp209 :total_flow_per_ms :items_per_ms_unit
   761 op add *tmp210 *tmp209 .INC_OVERALLOCATION
 
   774 op lessThanEq *tmp218 :new_change 0
   775 op mul *tmp219 *tmp218 .DEC_MAX
   776 set .DEC_LIMIT *tmp219
-    * set *tmp204 .DEC_LIMIT
   777 jump *label156 always
   778 label *label155
   779 op idiv *tmp220 :wait_time .WAIT_LIMIT
 
   784 op mul *tmp224 *tmp223 .INC_MAX
   785 set .INC_LIMIT *tmp224
   786 set .DEC_LIMIT .DEC_MAX
-    * set *tmp204 .DEC_LIMIT
   787 label *label156
   788 op add *tmp225 :active :new_change
   789 op max *tmp226 *tmp225 1
   790 set .TARGET *tmp226
-    * set *tmp198 .TARGET
   791 jump *label150 always
   792 label *label149
   793 set .INC_LIMIT 0
   794 set .DEC_LIMIT 0
-    * set *tmp198 .DEC_LIMIT
   795 label *label150
   796 set :min_level 999999
   797 set :max_level 0
-    * set *tmp179 :max_level
   798 jump *label146 always
   799 label *label145
-    * set *tmp179 null
   800 label *label146
   801 op greaterThan *tmp227 .CONTAINERS 1
   802 jump *label161 equal *tmp227 false
 
   839 label *label174
   840 set *tmp244 null
   841 label *label175
-    * set *tmp239 *tmp244
   842 jump *label171 always
   843 label *label172
-    * set *tmp239 null
   844 label *label171
   845 label *label169
   846 jump *label168 always
 
   848 op equal *tmp245 .CONTAINERS 0
   849 jump *label176 equal *tmp245 false
   850 set .CONTAINER @this
-    * set *tmp246 .CONTAINER
   851 jump *label177 always
   852 label *label176
   853 set .DST .CONTAINER
 
   878 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   879 op add *tmp262 @tick 600
   880 set .MESSAGE_TIMEOUT *tmp262
-    * set *tmp246 .MESSAGE_TIMEOUT
   881 label *label177
   882 set *tmp234 :findAnotherContainer:min_level
   883 jump *label167 always
 
   890 label *label165
   891 set *tmp233 null
   892 label *label166
-    * set *tmp229 *tmp233
   893 jump *label162 always
   894 label *label161
-    * set *tmp229 null
   895 label *label162
   896 set :wait_time 0
   897 set :remote_wait_time 0
 
   903 label *label178
   904 set *tmp264 null
   905 label *label179
-    * set *tmp168 *tmp264
   906 jump *label142 always
   907 label *label141
-    * set *tmp168 null
   908 label *label142
   909 print .MESSAGE
   910 print "Moving [green]"
 
   929 print ")"
   930 print " [gold]+"
   931 print :items_in_transit
-    * set *tmp268 null
   932 jump *label183 always
   933 label *label182
   934 print "\n"
 
   942 print ")"
   943 print " [gold]+"
   944 print :items_in_transit
-    * set *tmp268 null
   945 label *label183
   946 op greaterThan *tmp269 .CHANGE 0
   947 jump *label184 equal *tmp269 false
 
   951 label *label184
   952 set *tmp270 null
   953 label *label185
-    * set *tmp266 *tmp270
   954 jump *label181 always
   955 label *label180
-    * set *tmp266 null
   956 label *label181
   957 print "\n"
   958 print "[]Local items: [gold]"
 
   963 print .LOCAL_MARGIN
   964 print "["
   965 print "])"
-    * set *tmp272 null
   966 jump *label187 always
   967 label *label186
-    * set *tmp272 null
   968 label *label187
   969 jump *label188 equal .SHOW_REMOTE_LEVEL false
   970 sensor *tmp274 .CORE .ITEM
 
   983 label *label190
   984 set *tmp276 null
   985 label *label191
-    * set *tmp273 *tmp276
   986 jump *label189 always
   987 label *label188
-    * set *tmp273 null
   988 label *label189
   989 op greaterThan *tmp277 .TARGET 0
   990 jump *label192 equal *tmp277 false
 
  1008 print :elapsed_str
  1009 print "["
  1010 print "] s"
-    * set *tmp279 null
  1011 jump *label195 always
  1012 label *label194
  1013 print "\n"
 
  1015 print :elapsed_str
  1016 print "["
  1017 print "] s"
-    * set *tmp279 null
  1018 label *label195
  1019 print "\n"
  1020 print "Total wait time: [green]"
  1021 print :wait_time_str
  1022 print "["
  1023 print "] s"
-    * set *tmp278 null
  1024 jump *label193 always
  1025 label *label192
-    * set *tmp278 null
  1026 label *label193
  1027 print "\n"
  1028 print "[lightgray]Loop: "
 
  1041 op notEqual *tmp283 *tmp282 0
  1042 jump *label196 equal *tmp283 false
  1043 jump *label86 always
-    * set *tmp284 null
  1044 jump *label197 always
  1045 label *label196
-    * set *tmp284 null
  1046 label *label197
  1047 sensor *tmp285 .DST @dead
  1048 op notEqual *tmp286 *tmp285 0
  1049 jump *label198 equal *tmp286 false
  1050 jump *label86 always
-    * set *tmp287 null
  1051 jump *label199 always
  1052 label *label198
-    * set *tmp287 null
  1053 label *label199
  1054 sensor *tmp288 .SORTER @dead
  1055 op notEqual *tmp289 *tmp288 0
  1056 jump *label200 equal *tmp289 false
  1057 jump *label86 always
-    * set *tmp290 null
  1058 jump *label201 always
  1059 label *label200
-    * set *tmp290 null
  1060 label *label201
  1061 getlink *tmp291 .CONTAINER_INDEX
  1062 op notEqual *tmp292 .CONTAINER *tmp291
 
  1067 label *label202
  1068 set *tmp293 null
  1069 label *label203
-    * set *tmp146 *tmp293
  1070 jump *label99 always
  1071 label *label98
-    * set *tmp146 null
  1072 label *label99
  1073 op greaterThan *tmp294 .CHANGE 0
  1074 jump *label204 equal *tmp294 false
 
  1082 label *label206
  1083 set *tmp298 null
  1084 label *label207
-    * set *tmp295 *tmp298
  1085 jump *label205 always
  1086 label *label204
-    * set *tmp295 null
  1087 label *label205
  1088 sensor *tmp299 @unit @controller
  1089 op equal *tmp300 *tmp299 @this
 
  1114 label *label214
  1115 set *tmp310 null
  1116 label *label215
-    * set *tmp308 *tmp310
  1117 jump *label213 always
  1118 label *label212
-    * set *tmp308 null
  1119 label *label213
  1120 op equal *tmp314 :state 1
  1121 jump *label218 equal *tmp314 false
 
  1138 ucontrol within .CORE_X .CORE_Y 8 *tmp323
  1139 jump *label226 equal *tmp323 false
  1140 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp324 null
  1141 jump *label227 always
  1142 label *label226
-    * set *tmp324 null
  1143 label *label227
  1144 print "[]"
  1145 print "\n"
 
  1155 label *label223
  1156 set *tmp318 *tmp321
  1157 label *label221
-    * set *tmp315 *tmp318
  1158 jump *label219 always
  1159 label *label218
-    * set *tmp315 null
  1160 label *label219
  1161 op equal *tmp325 :state 2
  1162 jump *label228 equal *tmp325 false
 
  1190 label *label232
  1191 set *tmp328 *tmp329
  1192 label *label231
-    * set *tmp326 *tmp328
  1193 jump *label229 always
  1194 label *label228
-    * set *tmp326 null
  1195 label *label229
  1196 op equal *tmp337 :state 3
  1197 jump *label233 equal *tmp337 false
 
  1201 op greaterThanEq *tmp341 :max_load .LOAD_PACK
  1202 jump *label235 equal *tmp341 false
  1203 ucontrol itemTake .SRC .ITEM :max_load
-    * set *tmp342 null
  1204 jump *label236 always
  1205 label *label235
-    * set *tmp342 null
  1206 label *label236
  1207 sensor *tmp343 @unit @totalItems
  1208 op greaterThanEq *tmp344 *tmp343 .UNIT_CAPACITY
 
  1220 op add :remote_wait_time :remote_wait_time *tmp346
  1221 set *tmp345 :remote_wait_time
  1222 label *label238
-    * set *tmp338 *tmp345
  1223 jump *label234 always
  1224 label *label233
-    * set *tmp338 null
  1225 label *label234
  1226 op equal *tmp347 :state 4
  1227 jump *label239 equal *tmp347 false
 
  1258 label *label243
  1259 set *tmp350 *tmp352
  1260 label *label242
-    * set *tmp348 *tmp350
  1261 jump *label240 always
  1262 label *label239
-    * set *tmp348 null
  1263 label *label240
  1264 op equal *tmp360 :state 5
  1265 jump *label244 equal *tmp360 false
 
  1269 op greaterThanEq *tmp364 :max_drop .DROP_PACK
  1270 jump *label246 equal *tmp364 false
  1271 ucontrol itemDrop .DST :max_drop
-    * set *tmp365 null
  1272 jump *label247 always
  1273 label *label246
-    * set *tmp365 null
  1274 label *label247
  1275 sensor *tmp366 @unit @totalItems
  1276 op lessThanEq *tmp367 *tmp366 0
 
  1310 op add :remote_wait_time :remote_wait_time *tmp377
  1311 set *tmp368 :remote_wait_time
  1312 label *label249
-    * set *tmp361 *tmp368
  1313 jump *label245 always
  1314 label *label244
-    * set *tmp361 null
  1315 label *label245
  1316 sensor *tmp378 @unit @totalItems
  1317 set :items *tmp378
 
  1343 set :items *tmp387
  1344 set *tmp383 :items
  1345 label *label256
-    * set *tmp382 *tmp383
  1346 jump *label254 always
  1347 label *label253
-    * set *tmp382 null
  1348 label *label254
  1349 op lessThanEq *tmp388 :items .PARK_ITEM_LIMIT
  1350 jump *label259 equal *tmp388 false
 
  1355 label *label259
  1356 set *tmp389 null
  1357 label *label260
-    * set *tmp380 *tmp389
  1358 jump *label252 always
  1359 label *label251
  1360 op add :active :active 1
-    * set *tmp380 :active
  1361 label *label252
  1362 print :items
  1363 print .ITEM_ICON
 
  1367 label *label210
  1368 set *tmp304 null
  1369 label *label211
-    * set *tmp301 *tmp304
  1370 jump *label209 always
  1371 label *label208
-    * set *tmp301 null
  1372 label *label209
  1373 label *label85
  1374 jump *label84 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-34 instructions):
 
   236 print "is not a vault!"
   237 printflush message2
   238 set .CORE null
-    * set *tmp61 .CORE
   239 jump *label60 always
   240 label *label59
-    * set *tmp61 null
   241 label *label60
   242 jump *label53 always
   243 label *label52
 
   832 set :findAnotherContainer:min_level :findAnotherContainer:level
   833 set .CONTAINER :findAnotherContainer:block
   834 set .CONTAINER_INDEX :findAnotherContainer:n
-    * set *tmp244 .CONTAINER_INDEX
   835 jump *label175 always
   836 label *label174
-    * set *tmp244 null
   837 label *label175
   838 jump *label171 always
   839 label *label172
 
   881 label *label167
   882 set :this_level *tmp234
   883 set :last_level :this_level
-    * set *tmp233 :last_level
   884 jump *label166 always
   885 label *label165
-    * set *tmp233 null
   886 label *label166
   887 jump *label162 always
   888 label *label161
 
   892 op greaterThanEq *tmp263 @tick .MESSAGE_TIMEOUT
   893 jump *label178 equal *tmp263 false
   894 set .MESSAGE ""
-    * set *tmp264 .MESSAGE
   895 jump *label179 always
   896 label *label178
-    * set *tmp264 null
   897 label *label179
   898 jump *label142 always
   899 label *label141
 
   938 op greaterThan *tmp269 .CHANGE 0
   939 jump *label184 equal *tmp269 false
   940 print "\n[][salmon]Cannot acquire additional units![]"
-    * set *tmp270 "\n[][salmon]Cannot acquire additional units![]"
   941 jump *label185 always
   942 label *label184
-    * set *tmp270 null
   943 label *label185
   944 jump *label181 always
   945 label *label180
 
   968 print .REMOTE_MARGIN
   969 print "["
   970 print "])"
-    * set *tmp276 null
   971 jump *label191 always
   972 label *label190
-    * set *tmp276 null
   973 label *label191
   974 jump *label189 always
   975 label *label188
 
  1050 op notEqual *tmp292 .CONTAINER *tmp291
  1051 jump *label202 equal *tmp292 false
  1052 jump *label86 always
-    * set *tmp293 null
  1053 jump *label203 always
  1054 label *label202
-    * set *tmp293 null
  1055 label *label203
  1056 jump *label99 always
  1057 label *label98
 
  1063 jump *label206 equal *tmp297 false
  1064 op sub .CHANGE .CHANGE 1
  1065 ucontrol flag 1
-    * set *tmp298 null
  1066 jump *label207 always
  1067 label *label206
-    * set *tmp298 null
  1068 label *label207
  1069 jump *label205 always
  1070 label *label204
 
  1093 label *label216
  1094 set *tmp313 null
  1095 label *label217
-    * set *tmp310 *tmp313
  1096 jump *label215 always
  1097 label *label214
-    * set *tmp310 null
  1098 label *label215
  1099 jump *label213 always
  1100 label *label212
 
  1105 op equal *tmp317 *tmp316 0
  1106 jump *label220 equal *tmp317 false
  1107 set :state 2
-    * set *tmp318 :state
  1108 jump *label221 always
  1109 label *label220
  1110 sensor *tmp319 @unit @firstItem
 
  1134 label *label225
  1135 set *tmp321 *tmp322
  1136 label *label223
-    * set *tmp318 *tmp321
  1137 label *label221
  1138 jump *label219 always
  1139 label *label218
 
  1144 ucontrol within .SRC_X .SRC_Y 8 *tmp327
  1145 jump *label230 equal *tmp327 false
  1146 set :state 3
-    * set *tmp328 :state
  1147 jump *label231 always
  1148 label *label230
  1149 set :printUnitInfo:name "source"
 
  1167 print " [green]"
  1168 set *tmp329 null
  1169 label *label232
-    * set *tmp328 *tmp329
  1170 label *label231
  1171 jump *label229 always
  1172 label *label228
 
  1186 op greaterThanEq *tmp344 *tmp343 .UNIT_CAPACITY
  1187 jump *label237 equal *tmp344 false
  1188 set :state 4
-    * set *tmp345 :state
  1189 jump *label238 always
  1190 label *label237
  1191 print "[]"
 
  1195 op add :wait_time :wait_time :loop_time_ms
  1196 op mul *tmp346 :loop_time_ms .SRC_REMOTE_WAIT
  1197 op add :remote_wait_time :remote_wait_time *tmp346
-    * set *tmp345 :remote_wait_time
  1198 label *label238
  1199 jump *label234 always
  1200 label *label233
 
  1208 op add :transferred :transferred *tmp351
  1209 op add :transfers :transfers 1
  1210 set :state 5
-    * set *tmp350 :state
  1211 jump *label242 always
  1212 label *label241
  1213 set :printUnitInfo.1:name "destination"
 
  1231 print " [green]"
  1232 set *tmp352 null
  1233 label *label243
-    * set *tmp350 *tmp352
  1234 label *label242
  1235 jump *label240 always
  1236 label *label239
 
  1272 print " [green]"
  1273 set *tmp369 null
  1274 label *label250
-    * set *tmp368 *tmp369
  1275 jump *label249 always
  1276 label *label248
  1277 print "[]"
 
  1281 op add :wait_time :wait_time :loop_time_ms
  1282 op mul *tmp377 :loop_time_ms .DST_REMOTE_WAIT
  1283 op add :remote_wait_time :remote_wait_time *tmp377
-    * set *tmp368 :remote_wait_time
  1284 label *label249
  1285 jump *label245 always
  1286 label *label244
 
  1307 label *label257
  1308 set *tmp385 null
  1309 label *label258
-    * set *tmp383 *tmp385
  1310 jump *label256 always
  1311 label *label255
  1312 ucontrol itemDrop @air .UNIT_CAPACITY
  1313 sensor *tmp387 @unit @totalItems
  1314 set :items *tmp387
-    * set *tmp383 :items
  1315 label *label256
  1316 jump *label254 always
  1317 label *label253
 
  1320 jump *label259 equal *tmp388 false
  1321 ucontrol move .PARK_X .PARK_Y
  1322 set :state .S_UNUSED
-    * set *tmp389 :state
  1323 jump *label260 always
  1324 label *label259
-    * set *tmp389 null
  1325 label *label260
  1326 jump *label252 always
  1327 label *label251
 
  1330 print :items
  1331 print .ITEM_ICON
  1332 ucontrol flag :state
-    * set *tmp304 null
  1333 jump *label211 always
  1334 label *label210
-    * set *tmp304 null
  1335 label *label211
  1336 jump *label209 always
  1337 label *label208

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-9 instructions):
 
  1088 jump *label216 equal *tmp312 false
  1089 op add .CHANGE .CHANGE 1
  1090 set :state 6
-    * set *tmp313 :state
  1091 jump *label217 always
  1092 label *label216
-    * set *tmp313 null
  1093 label *label217
  1094 jump *label215 always
  1095 label *label214
 
  1109 op equal *tmp320 *tmp319 .ITEM
  1110 jump *label222 equal *tmp320 false
  1111 set :state 4
-    * set *tmp321 :state
  1112 jump *label223 always
  1113 label *label222
  1114 jump *label224 equal .DROP_TO_CORE false
 
  1129 set :state 2
  1130 set *tmp322 :state
  1131 label *label225
-    * set *tmp321 *tmp322
  1132 label *label223
  1133 label *label221
  1134 jump *label219 always
 
  1161 print :printUnitInfo:name
  1162 print ":"
  1163 print " [green]"
-    * set *tmp329 null
  1164 label *label232
  1165 label *label231
  1166 jump *label229 always
 
  1224 print :printUnitInfo.1:name
  1225 print ":"
  1226 print " [green]"
-    * set *tmp352 null
  1227 label *label243
  1228 label *label242
  1229 jump *label240 always
 
  1264 print :printUnitInfo.2:name
  1265 print ":"
  1266 print " [green]"
-    * set *tmp369 null
  1267 label *label250
  1268 jump *label249 always
  1269 label *label248
 
  1295 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1296 sensor *tmp386 @unit @totalItems
  1297 set :items *tmp386
-    * set *tmp385 :items
  1298 jump *label258 always
  1299 label *label257
-    * set *tmp385 null
  1300 label *label258
  1301 jump *label256 always
  1302 label *label255

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
  1122 print "[]"
  1123 print "\n"
  1124 print "Unloading previous items: [green]"
-    * set *tmp322 null
  1125 jump *label225 always
  1126 label *label224
  1127 ucontrol itemDrop @air .UNIT_CAPACITY
  1128 set :state 2
-    * set *tmp322 :state
  1129 label *label225
  1130 label *label223
  1131 label *label221

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-109 instructions):
 
    24 printflush null
    25 label *label13
    26 set .MESSAGE ""
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+   27 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+   28 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    29 set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION
    30 set .TRIGGER_LEVEL 0.9
-    * op mul *tmp2 -1 HOUSEKEEPING
-    * set .S_UNUSED *tmp2
+   31 op mul .S_UNUSED -1 HOUSEKEEPING
    32 set .STATE_LIMIT null
    33 set .ITEM_ICON .STATE_LIMIT
    34 set .ITEM .ITEM_ICON
 
    37 set .CONTAINER_INDEX .CORE_X
    38 set .LOOPS 1
    39 op mul *tmp3 .LOOPS 1000
-    * op div *tmp4 *tmp3 60
-    * set .LOOPS_TICKS_TO_MS *tmp4
+   40 op div .LOOPS_TICKS_TO_MS *tmp3 60
    41 set .INC_OVERALLOCATION OVERALLOCATION_LOW
-    * op add *tmp5 1 OVERALLOCATION_HIGH
-    * set .DEC_OVERALLOCATION *tmp5
+   42 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    43 set .TRIGGER_BOOST 2
    44 set .INC_MAX 6
    45 set .DEC_MAX -1
 
    56 label *label15
    57 jump *label14 always
    58 label *label16
-    * set *tmp7 @unit
-    * set :first_unit *tmp7
+   59 set :first_unit @unit
    60 sensor *tmp8 @unit @speed
-    * op div *tmp9 *tmp8 10
-    * set .SPEED_SEC *tmp9
+   61 op div .SPEED_SEC *tmp8 10
    62 sensor *tmp10 @unit @speed
-    * op div *tmp11 *tmp10 1000
-    * set .SPEED *tmp11
+   63 op div .SPEED *tmp10 1000
    64 set .TARGET 0
    65 label *label17
    66 sensor *tmp12 @unit @controller
    67 op equal *tmp13 *tmp12 @this
    68 jump *label20 equal *tmp13 false
-    * sensor *tmp15 @unit @flag
-    * set :state *tmp15
+   69 sensor :state @unit @flag
    70 op greaterThanEq *tmp16 :state 1
    71 op lessThan *tmp17 :state 6
    72 op land *tmp18 *tmp16 *tmp17
 
    88 set :active .TARGET
    89 set .DEC_LIMIT 0
    90 set .INC_LIMIT 0
-    * sensor *tmp22 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp22
+   91 sensor .UNIT_CAPACITY @unit @itemCapacity
    92 set :first_unit null
    93 label *label23
    94 jump *label25 equal true false
    95 set .CONTAINER null
    96 set .CONTAINERS 0
-    * set *tmp23 @links
-    * set :n *tmp23
+   97 set :n @links
    98 label *label26
    99 op greaterThan *tmp24 :n 0
   100 jump *label28 equal *tmp24 false
-    * op sub *tmp25 :n 1
-    * set :n *tmp25
-    * getlink *tmp26 :n
-    * set :block *tmp26
+  101 op sub :n :n 1
+  102 getlink :block :n
   103 sensor *tmp28 :block @type
   104 jump *label31 equal *tmp28 @vault
   105 jump *label31 equal *tmp28 @container
 
   137 sensor *tmp35 @unit @controlled
   138 op equal *tmp36 *tmp35 0
   139 jump *label39 equal *tmp36 false
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp39 *tmp38
-    * set .CORE *tmp38
+  140 ulocate building core false @copper .CORE_X .CORE_Y *tmp39 .CORE
   141 ucontrol flag .S_UNUSED
   142 jump *label40 always
   143 label *label39
 
   146 jump *label36 always
   147 label *label38
   148 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
-    * op equal *tmp40 DROP_TO_AIR false
-    * set .DROP_TO_CORE *tmp40
+  149 op equal .DROP_TO_CORE DROP_TO_AIR false
   150 jump *label35 always
   151 label *label34
   152 printflush message2
 
   158 label *label41
   159 op equal *tmp41 .CORE null
   160 jump *label43 equal *tmp41 false
-    * op add *tmp42 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp42
+  161 op add .QUERY_FLAG 99999900 LINK_ID
   162 set :flag .QUERY_FLAG
   163 ubind UNIT
   164 label *label44
 
   180 jump *label50 always
   181 label *label50
   182 ucontrol stop
-    * sensor *tmp48 @unit @flag
-    * set :flag *tmp48
+  183 sensor :flag @unit @flag
   184 label *label48
   185 jump *label47 always
   186 label *label49
   187 op notEqual *tmp49 :flag .QUERY_FLAG
   188 jump *label52 equal *tmp49 false
-    * op idiv *tmp51 :flag 100
-    * set :position *tmp51
-    * op mod *tmp52 :position @mapw
-    * set .CORE_X *tmp52
-    * op idiv *tmp53 :position @mapw
-    * set .CORE_Y *tmp53
+  189 op idiv :position :flag 100
+  190 op mod .CORE_X :position @mapw
+  191 op idiv .CORE_Y :position @mapw
   192 label *label54
   193 sensor *tmp54 @unit @dead
   194 op equal *tmp55 *tmp54 0
 
   203 label *label55
   204 jump *label54 always
   205 label *label56
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp58 *tmp59
-    * set .CORE *tmp58
+  206 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp59
   207 op notEqual *tmp60 :b_type @vault
   208 jump *label59 equal *tmp60 false
   209 print "[salmon]Building at "
 
   235 set .DROP_TO_CORE false
   236 label *label35
   237 set .SORTER sorter1
-    * sensor *tmp63 .SORTER @type
-    * set :sorter_type *tmp63
+  238 sensor :sorter_type .SORTER @type
   239 label *label63
   240 op notEqual *tmp64 :sorter_type @sorter
   241 jump *label65 equal *tmp64 false
 
   255 label *label69
   256 printflush message1
   257 set .SORTER sorter1
-    * sensor *tmp68 .SORTER @type
-    * set :sorter_type *tmp68
+  258 sensor :sorter_type .SORTER @type
   259 label *label64
   260 jump *label63 always
   261 label *label65
 
   264 set .SHOW_REMOTE_LEVEL true
   265 set .SRC .CORE
   266 set .DST .CONTAINER
-    * sensor *tmp71 .SRC @itemCapacity
-    * set :src_capacity *tmp71
-    * sensor *tmp72 .DST @itemCapacity
-    * set :dst_capacity *tmp72
+  267 sensor :src_capacity .SRC @itemCapacity
+  268 sensor :dst_capacity .DST @itemCapacity
   269 op sub *tmp73 100 .EFF_REMOTE_LIMIT
   270 op mul *tmp74 :src_capacity *tmp73
-    * op idiv *tmp75 *tmp74 100
-    * set .LOAD_LEVEL *tmp75
+  271 op idiv .LOAD_LEVEL *tmp74 100
   272 op mul *tmp76 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp77 *tmp76 100
-    * set .DROP_LEVEL *tmp77
+  273 op idiv .DROP_LEVEL *tmp76 100
   274 set .LOCAL_MARGIN .DROP_LEVEL
   275 set .REMOTE_MARGIN .LOAD_LEVEL
   276 op sub *tmp78 1 .TRIGGER_LEVEL
-    * op mul *tmp79 :dst_capacity *tmp78
-    * set .LOW_LEVEL_TRIGGER *tmp79
+  277 op mul .LOW_LEVEL_TRIGGER :dst_capacity *tmp78
   278 set .HIGH_LEVEL_TRIGGER :dst_capacity
   279 set .FLOW_CORR_SIGN 1
   280 set .SRC_REMOTE_WAIT 1
 
   289 set .DIRECTION *tmp81
   290 jump *label71 always
   291 label *label70
-    * op greaterThan *tmp82 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp82
+  292 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   293 set .SRC .CONTAINER
   294 set .DST .CORE
-    * sensor *tmp83 .SRC @itemCapacity
-    * set :src_capacity *tmp83
-    * sensor *tmp84 .DST @itemCapacity
-    * set :dst_capacity *tmp84
+  295 sensor :src_capacity .SRC @itemCapacity
+  296 sensor :dst_capacity .DST @itemCapacity
   297 op sub *tmp85 100 .EFF_LOCAL_LIMIT
   298 op mul *tmp86 :src_capacity *tmp85
-    * op idiv *tmp87 *tmp86 100
-    * set .LOAD_LEVEL *tmp87
+  299 op idiv .LOAD_LEVEL *tmp86 100
   300 op mul *tmp88 :dst_capacity .EFF_REMOTE_LIMIT
   301 op idiv *tmp89 *tmp88 100
   302 op equal *tmp90 LINK_ID 0
   303 op mul *tmp91 *tmp90 .UNIT_CAPACITY
-    * op add *tmp92 *tmp89 *tmp91
-    * set .DROP_LEVEL *tmp92
+  304 op add .DROP_LEVEL *tmp89 *tmp91
   305 set .LOCAL_MARGIN .LOAD_LEVEL
   306 set .REMOTE_MARGIN .DROP_LEVEL
-    * op mul *tmp93 :src_capacity .TRIGGER_LEVEL
-    * set .HIGH_LEVEL_TRIGGER *tmp93
+  307 op mul .HIGH_LEVEL_TRIGGER :src_capacity .TRIGGER_LEVEL
   308 set .LOW_LEVEL_TRIGGER 0
   309 set .FLOW_CORR_SIGN -1
   310 set .SRC_REMOTE_WAIT 0
 
   327 label *label77
   328 set .LINK_TXT *tmp97
   329 op sub *tmp98 :src_capacity .LOAD_LEVEL
-    * op min *tmp99 .UNIT_CAPACITY *tmp98
-    * set .LOAD_PACK *tmp99
-    * op min *tmp100 .UNIT_CAPACITY .DROP_LEVEL
-    * set .DROP_PACK *tmp100
-    * sensor *tmp101 .SRC @x
-    * set .SRC_X *tmp101
-    * sensor *tmp102 .SRC @y
-    * set .SRC_Y *tmp102
-    * sensor *tmp103 .DST @x
-    * set .DST_X *tmp103
-    * sensor *tmp104 .DST @y
-    * set .DST_Y *tmp104
+  330 op min .LOAD_PACK .UNIT_CAPACITY *tmp98
+  331 op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL
+  332 sensor .SRC_X .SRC @x
+  333 sensor .SRC_Y .SRC @y
+  334 sensor .DST_X .DST @x
+  335 sensor .DST_Y .DST @y
   336 op sub *tmp105 .DST_X .SRC_X
   337 op sub *tmp106 .DST_Y .SRC_Y
   338 op len *tmp107 *tmp105 *tmp106
   339 op sub *tmp108 *tmp107 6
-    * op sub *tmp109 *tmp108 8
-    * set .DISTANCE *tmp109
+  340 op sub .DISTANCE *tmp108 8
   341 op max *tmp110 .DISTANCE 10
   342 op mul *tmp111 2 *tmp110
-    * op div *tmp112 *tmp111 .SPEED
-    * set .TRAVEL_TIME *tmp112
+  343 op div .TRAVEL_TIME *tmp111 .SPEED
   344 sensor *tmp113 .CONTAINER @x
   345 op lessThan *tmp114 *tmp113 .CORE_X
   346 jump *label78 equal *tmp114 false
 
   349 label *label78
   350 set *tmp115 -15
   351 label *label79
-    * op add *tmp116 .CORE_X *tmp115
-    * set .PARK_X *tmp116
+  352 op add .PARK_X .CORE_X *tmp115
   353 sensor *tmp117 .CONTAINER @y
   354 op lessThan *tmp118 *tmp117 .CORE_Y
   355 jump *label80 equal *tmp118 false
 
   358 label *label80
   359 set *tmp119 -15
   360 label *label81
-    * op add *tmp120 .CORE_Y *tmp119
-    * set .PARK_Y *tmp120
+  361 op add .PARK_Y .CORE_Y *tmp119
   362 op equal *tmp121 LINK_ID 0
-    * op mul *tmp122 *tmp121 .UNIT_CAPACITY
-    * set .PARK_ITEM_LIMIT *tmp122
-    * set *tmp123 @tick
-    * set .TRANSFER_START *tmp123
-    * op sub *tmp124 @tick 60
-    * set .LOOP_START *tmp124
+  363 op mul .PARK_ITEM_LIMIT *tmp121 .UNIT_CAPACITY
+  364 set .TRANSFER_START @tick
+  365 op sub .LOOP_START @tick 60
   366 set .LAST_ITEM @mono
-    * op add *tmp125 @tick 600
-    * set .MESSAGE_TIMEOUT *tmp125
+  367 op add .MESSAGE_TIMEOUT @tick 600
   368 set .WAIT_LIMIT 30000
   369 set :items_in_transit 0
   370 set :items_per_min_unit "--"
 
   415 set .EFF_AUTO_ALLOCATION false
   416 set .AUTO_ALLOCATION_TXT ""
   417 op add *tmp131 .TARGET 1
-    * op min *tmp132 *tmp131 MAX_UNITS
-    * set .TARGET *tmp132
+  418 op min .TARGET *tmp131 MAX_UNITS
   419 set .CORR_SIGN "[]"
   420 set :corr_per_min ""
   421 set .SPEED_UNIT_TXT "/min"
 
   439 label *label94
   440 set .EFF_AUTO_ALLOCATION false
   441 op sub *tmp138 .TARGET 1
-    * op max *tmp139 *tmp138 0
-    * set .TARGET *tmp139
+  442 op max .TARGET *tmp138 0
   443 set .CORR_SIGN "[]"
   444 set :corr_per_min ""
   445 set .SPEED_UNIT_TXT "/min"
 
   457 label *label92
   458 label *label93
   459 sensor *tmp142 :first_unit @dead
-    * op equal *tmp143 *tmp142 0
-    * set :alive *tmp143
+  460 op equal :alive *tmp142 0
   461 op equal *tmp144 @unit :first_unit
   462 op lessThanEq *tmp145 :alive *tmp144
   463 jump *label98 equal *tmp145 false
 
   469 label *label101
   470 printflush message2
   471 set .STATE_LIMIT 6
-    * sensor *tmp149 .SORTER @config
-    * set .ITEM *tmp149
+  472 sensor .ITEM .SORTER @config
   473 op notEqual *tmp150 .ITEM .LAST_ITEM
   474 jump *label102 equal *tmp150 false
   475 label *label104
 
   477 jump *label106 equal *tmp152 false
   478 print "[salmon]No item type selected for transport.[]"
   479 printflush message1
-    * sensor *tmp153 .SORTER @config
-    * set .ITEM *tmp153
+  480 sensor .ITEM .SORTER @config
   481 label *label105
   482 jump *label104 always
   483 label *label106
 
   586 label *label107
   587 set .ITEM_ICON *tmp154
   588 set .STATE_LIMIT 1
-    * sensor *tmp158 .CONTAINER .ITEM
-    * set :last_level *tmp158
+  589 sensor :last_level .CONTAINER .ITEM
   590 set :min_level 999999
   591 set :max_level 0
   592 jump *label103 always
   593 label *label102
   594 label *label103
-    * sensor *tmp159 .CONTAINER .ITEM
-    * set :container_items *tmp159
-    * op min *tmp160 :min_level :container_items
-    * set :min_level *tmp160
-    * op max *tmp161 :max_level :container_items
-    * set :max_level *tmp161
-    * op sub *tmp162 @tick .LOOP_START
-    * set :loop_time *tmp162
-    * set *tmp163 @tick
-    * set .LOOP_START *tmp163
+  595 sensor :container_items .CONTAINER .ITEM
+  596 op min :min_level :min_level :container_items
+  597 op max :max_level :max_level :container_items
+  598 op sub :loop_time @tick .LOOP_START
+  599 set .LOOP_START @tick
   600 op mul *tmp164 :loop_time 100
-    * op idiv *tmp165 *tmp164 6
-    * set :loop_time_ms *tmp165
+  601 op idiv :loop_time_ms *tmp164 6
   602 op greaterThanEq *tmp166 :transfers :active
   603 jump *label143 notEqual *tmp166 false
   604 label *label144
 
   608 label *label143
   609 op div *tmp169 :wait_time 100
   610 op ceil *tmp170 *tmp169
-    * op div *tmp171 *tmp170 10
-    * set :wait_time_str *tmp171
-    * op sub *tmp172 @tick .TRANSFER_START
-    * set :elapsed_ticks *tmp172
-    * set *tmp173 @tick
-    * set .TRANSFER_START *tmp173
-    * op div *tmp174 :elapsed_ticks 0.06
-    * set :elapsed_ms *tmp174
+  611 op div :wait_time_str *tmp170 10
+  612 op sub :elapsed_ticks @tick .TRANSFER_START
+  613 set .TRANSFER_START @tick
+  614 op div :elapsed_ms :elapsed_ticks 0.06
   615 op idiv *tmp175 :elapsed_ms 100
-    * op div *tmp176 *tmp175 10
-    * set :elapsed_str *tmp176
-    * op div *tmp177 :transferred :elapsed_ms
-    * set :items_per_ms *tmp177
-    * op idiv *tmp178 :items_per_ms 0.000016666666666666667
-    * set :items_per_min *tmp178
+  616 op div :elapsed_str *tmp175 10
+  617 op div :items_per_ms :transferred :elapsed_ms
+  618 op idiv :items_per_min :items_per_ms 0.000016666666666666667
   619 set :transferred 0
   620 set :transfers 0
   621 jump *label145 equal .EFF_AUTO_ALLOCATION false
   622 set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] ==="
   623 op mul *tmp180 .LOOPS_TICKS_TO_MS :loop_time
-    * op add *tmp181 .TRAVEL_TIME *tmp180
-    * set :turnaround_ms *tmp181
-    * op mul *tmp182 :turnaround_ms .DEC_OVERALLOCATION
-    * set .WAIT_LIMIT *tmp182
+  624 op add :turnaround_ms .TRAVEL_TIME *tmp180
+  625 op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION
   626 op idiv *tmp183 :turnaround_ms 100
-    * op div *tmp184 *tmp183 10
-    * set :turnaround_str *tmp184
-    * op div *tmp185 .UNIT_CAPACITY :turnaround_ms
-    * set :items_per_ms_unit *tmp185
+  627 op div :turnaround_str *tmp183 10
+  628 op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms
   629 op mul *tmp186 :items_per_ms_unit 60000
-    * op floor *tmp187 *tmp186
-    * set :items_per_min_unit *tmp187
+  630 op floor :items_per_min_unit *tmp186
   631 op add *tmp188 :min_level :max_level
-    * op div *tmp189 *tmp188 2
-    * set :this_level *tmp189
+  632 op div :this_level *tmp188 2
   633 op sub *tmp190 :last_level :this_level
-    * op mul *tmp191 *tmp190 .FLOW_CORR_SIGN
-    * set :corr *tmp191
-    * op div *tmp192 :corr :elapsed_ms
-    * set :corr_per_ms *tmp192
+  634 op mul :corr *tmp190 .FLOW_CORR_SIGN
+  635 op div :corr_per_ms :corr :elapsed_ms
   636 set :last_level :this_level
-    * op add *tmp193 :items_per_ms :corr_per_ms
-    * set :total_flow_per_ms *tmp193
+  637 op add :total_flow_per_ms :items_per_ms :corr_per_ms
   638 op mul *tmp194 60000 :corr_per_ms
-    * op floor *tmp195 *tmp194
-    * set :corr_per_min *tmp195
+  639 op floor :corr_per_min *tmp194
   640 op greaterThanEq *tmp196 :corr_per_min 0
   641 jump *label147 equal *tmp196 false
   642 set *tmp197 "[]([green]+"
 
   673 set :total_flow_1 :total_flow_per_ms
   674 op add *tmp206 :total_flow_3 :total_flow_2
   675 op add *tmp207 *tmp206 :total_flow_1
-    * op div *tmp208 *tmp207 3
-    * set :total_flow_per_ms *tmp208
+  676 op div :total_flow_per_ms *tmp207 3
   677 jump *label160 always
   678 label *label159
   679 label *label160
   680 op div *tmp209 :total_flow_per_ms :items_per_ms_unit
   681 op add *tmp210 *tmp209 .INC_OVERALLOCATION
-    * op ceil *tmp211 *tmp210
-    * set :new_target *tmp211
-    * op mul *tmp212 .TRIGGER_BOOST :trigger
-    * set :level_boost *tmp212
+  682 op ceil :new_target *tmp210
+  683 op mul :level_boost .TRIGGER_BOOST :trigger
   684 op add *tmp213 :new_target :level_boost
-    * op min *tmp214 *tmp213 MAX_UNITS
-    * set :new_target *tmp214
+  685 op min :new_target *tmp213 MAX_UNITS
   686 op sub *tmp215 :new_target :active
   687 op max *tmp216 *tmp215 0
-    * op min *tmp217 *tmp216 .INC_LIMIT
-    * set :new_change *tmp217
+  688 op min :new_change *tmp216 .INC_LIMIT
   689 set .INC_LIMIT .INC_MAX
   690 op lessThanEq *tmp218 :new_change 0
-    * op mul *tmp219 *tmp218 .DEC_MAX
-    * set .DEC_LIMIT *tmp219
+  691 op mul .DEC_LIMIT *tmp218 .DEC_MAX
   692 jump *label156 always
   693 label *label155
   694 op idiv *tmp220 :wait_time .WAIT_LIMIT
   695 op mul *tmp221 -1 *tmp220
-    * op max *tmp222 *tmp221 .DEC_LIMIT
-    * set :new_change *tmp222
+  696 op max :new_change *tmp221 .DEC_LIMIT
   697 op greaterThanEq *tmp223 :new_change 0
-    * op mul *tmp224 *tmp223 .INC_MAX
-    * set .INC_LIMIT *tmp224
+  698 op mul .INC_LIMIT *tmp223 .INC_MAX
   699 set .DEC_LIMIT .DEC_MAX
   700 label *label156
   701 op add *tmp225 :active :new_change
-    * op max *tmp226 *tmp225 1
-    * set .TARGET *tmp226
+  702 op max .TARGET *tmp225 1
   703 jump *label150 always
   704 label *label149
   705 set .INC_LIMIT 0
 
   718 jump *label163 always
   719 label *label163
   720 sensor *tmp230 .DST .ITEM
-    * op sub *tmp231 .DROP_LEVEL *tmp230
-    * set :max_drop *tmp231
+  721 op sub :max_drop .DROP_LEVEL *tmp230
   722 op lessThan *tmp232 :max_drop .DROP_PACK
   723 jump *label165 equal *tmp232 false
   724 set :findAnotherContainer:min_level 999999
   725 set .CONTAINERS 0
-    * set *tmp235 @links
-    * set :findAnotherContainer:n *tmp235
+  726 set :findAnotherContainer:n @links
   727 label *label168
   728 op greaterThan *tmp236 :findAnotherContainer:n 0
   729 jump *label170 equal *tmp236 false
-    * op sub *tmp237 :findAnotherContainer:n 1
-    * set :findAnotherContainer:n *tmp237
-    * getlink *tmp238 :findAnotherContainer:n
-    * set :findAnotherContainer:block *tmp238
+  730 op sub :findAnotherContainer:n :findAnotherContainer:n 1
+  731 getlink :findAnotherContainer:block :findAnotherContainer:n
   732 sensor *tmp240 :findAnotherContainer:block @type
   733 jump *label173 equal *tmp240 @vault
   734 jump *label173 equal *tmp240 @container
   735 jump *label172 always
   736 label *label173
   737 op add .CONTAINERS .CONTAINERS 1
-    * sensor *tmp242 :findAnotherContainer:block .ITEM
-    * set :findAnotherContainer:level *tmp242
+  738 sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM
   739 op lessThan *tmp243 :findAnotherContainer:level :findAnotherContainer:min_level
   740 jump *label174 equal *tmp243 false
   741 set :findAnotherContainer:min_level :findAnotherContainer:level
 
   756 jump *label177 always
   757 label *label176
   758 set .DST .CONTAINER
-    * sensor *tmp247 .DST @itemCapacity
-    * set :findAnotherContainer:dst_capacity *tmp247
+  759 sensor :findAnotherContainer:dst_capacity .DST @itemCapacity
   760 op mul *tmp248 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp249 *tmp248 100
-    * set .DROP_LEVEL *tmp249
+  761 op idiv .DROP_LEVEL *tmp248 100
   762 set .LOCAL_MARGIN .DROP_LEVEL
   763 op sub *tmp250 1 .TRIGGER_LEVEL
-    * op mul *tmp251 :findAnotherContainer:dst_capacity *tmp250
-    * set .LOW_LEVEL_TRIGGER *tmp251
+  764 op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity *tmp250
   765 set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
-    * sensor *tmp252 .DST @x
-    * set .DST_X *tmp252
-    * sensor *tmp253 .DST @y
-    * set .DST_Y *tmp253
+  766 sensor .DST_X .DST @x
+  767 sensor .DST_Y .DST @y
   768 op sub *tmp254 .DST_X .SRC_X
   769 op sub *tmp255 .DST_Y .SRC_Y
   770 op len *tmp256 *tmp254 *tmp255
   771 op sub *tmp257 *tmp256 6
-    * op sub *tmp258 *tmp257 8
-    * set .DISTANCE *tmp258
+  772 op sub .DISTANCE *tmp257 8
   773 op max *tmp259 .DISTANCE 10
   774 op mul *tmp260 2 *tmp259
-    * op div *tmp261 *tmp260 .SPEED
-    * set .TRAVEL_TIME *tmp261
+  775 op div .TRAVEL_TIME *tmp260 .SPEED
   776 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
-    * op add *tmp262 @tick 600
-    * set .MESSAGE_TIMEOUT *tmp262
+  777 op add .MESSAGE_TIMEOUT @tick 600
   778 label *label177
   779 set *tmp234 :findAnotherContainer:min_level
   780 jump *label167 always
 
   858 label *label186
   859 label *label187
   860 jump *label188 equal .SHOW_REMOTE_LEVEL false
-    * sensor *tmp274 .CORE .ITEM
-    * set :remote_level *tmp274
+  861 sensor :remote_level .CORE .ITEM
   862 print "\n"
   863 print "[]Remote items: [gold]"
   864 print :remote_level
 
   918 print " "
   919 print "ms"
   920 printflush message1
-    * op sub *tmp280 .TARGET :active
-    * set .CHANGE *tmp280
+  921 op sub .CHANGE .TARGET :active
   922 set :active 0
-    * set *tmp281 @unit
-    * set :first_unit *tmp281
+  923 set :first_unit @unit
   924 set :items_in_transit 0
   925 print "Unit status:"
   926 sensor *tmp282 .SRC @dead
 
   970 sensor *tmp299 @unit @controller
   971 op equal *tmp300 *tmp299 @this
   972 jump *label208 equal *tmp300 false
-    * sensor *tmp302 @unit @flag
-    * set :state *tmp302
+  973 sensor :state @unit @flag
   974 op notEqual *tmp303 :state .S_UNUSED
   975 jump *label210 equal *tmp303 false
   976 op max *tmp305 :state 1
-    * op min *tmp306 *tmp305 .STATE_LIMIT
-    * set :state *tmp306
+  977 op min :state *tmp305 .STATE_LIMIT
   978 op lessThan *tmp307 .CHANGE 0
   979 jump *label212 equal *tmp307 false
   980 op notEqual *tmp309 :state 6
 
  1063 op equal *tmp337 :state 3
  1064 jump *label233 equal *tmp337 false
  1065 sensor *tmp339 .SRC .ITEM
-    * op sub *tmp340 *tmp339 .LOAD_LEVEL
-    * set :max_load *tmp340
+ 1066 op sub :max_load *tmp339 .LOAD_LEVEL
  1067 op greaterThanEq *tmp341 :max_load .LOAD_PACK
  1068 jump *label235 equal *tmp341 false
  1069 ucontrol itemTake .SRC .ITEM :max_load
 
  1125 op equal *tmp360 :state 5
  1126 jump *label244 equal *tmp360 false
  1127 sensor *tmp362 .DST .ITEM
-    * op sub *tmp363 .DROP_LEVEL *tmp362
-    * set :max_drop *tmp363
+ 1128 op sub :max_drop .DROP_LEVEL *tmp362
  1129 op greaterThanEq *tmp364 :max_drop .DROP_PACK
  1130 jump *label246 equal *tmp364 false
  1131 ucontrol itemDrop .DST :max_drop
 
  1170 jump *label245 always
  1171 label *label244
  1172 label *label245
-    * sensor *tmp378 @unit @totalItems
-    * set :items *tmp378
+ 1173 sensor :items @unit @totalItems
  1174 op add :items_in_transit :items_in_transit :items
  1175 op equal *tmp379 :state 6
  1176 jump *label251 equal *tmp379 false
 
  1184 ucontrol within .CORE_X .CORE_Y 8 *tmp384
  1185 jump *label257 equal *tmp384 false
  1186 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * sensor *tmp386 @unit @totalItems
-    * set :items *tmp386
+ 1187 sensor :items @unit @totalItems
  1188 jump *label258 always
  1189 label *label257
  1190 label *label258
  1191 jump *label256 always
  1192 label *label255
  1193 ucontrol itemDrop @air .UNIT_CAPACITY
-    * sensor *tmp387 @unit @totalItems
-    * set :items *tmp387
+ 1194 sensor :items @unit @totalItems
  1195 label *label256
  1196 jump *label254 always
  1197 label *label253

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    91 sensor .UNIT_CAPACITY @unit @itemCapacity
    92 set :first_unit null
    93 label *label23
-    * jump *label25 equal true false
    94 set .CONTAINER null
    95 set .CONTAINERS 0
    96 set :n @links
 
   394 set .AUTO_ALLOCATION_TXT ""
   395 label *label83
   396 label *label84
-    * jump *label86 equal true false
   397 ubind UNIT
   398 label *label87
   399 op equal *tmp127 @unit null

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-22 instructions):
 
    81 label *label22
    82 sensor *tmp20 :first_unit @dead
    83 op equal *tmp21 *tmp20 0
-    * jump *label19 equal *tmp21 false
-    * jump *label17 always
+   84 jump *label17 notEqual *tmp21 false
    85 label *label19
    86 set .CHANGE 0
    87 set :active .TARGET
 
   100 getlink :block :n
   101 sensor *tmp28 :block @type
   102 jump *label31 equal *tmp28 @vault
-    * jump *label31 equal *tmp28 @container
-    * jump *label30 always
+  103 jump *label30 notEqual *tmp28 @container
   104 label *label31
   105 set .CONTAINER :block
   106 op add .CONTAINERS .CONTAINERS 1
 
   480 set .LAST_ITEM .ITEM
   481 set :itemTypeToIcon:itemType .ITEM
   482 sensor *tmp156 :itemTypeToIcon:itemType @id
-    * jump *label110 equal *tmp156 14
-    * jump *label109 always
+  483 jump *label109 notEqual *tmp156 14
   484 label *label110
   485 set *tmp155 "[]"
   486 jump *label108 always
   487 label *label109
-    * jump *label112 equal *tmp156 5
-    * jump *label111 always
+  488 jump *label111 notEqual *tmp156 5
   489 label *label112
   490 set *tmp155 "[]"
   491 jump *label108 always
   492 label *label111
-    * jump *label114 equal *tmp156 0
-    * jump *label113 always
+  493 jump *label113 notEqual *tmp156 0
   494 label *label114
   495 set *tmp155 "[]"
   496 jump *label108 always
   497 label *label113
-    * jump *label116 equal *tmp156 3
-    * jump *label115 always
+  498 jump *label115 notEqual *tmp156 3
   499 label *label116
   500 set *tmp155 "[]"
   501 jump *label108 always
   502 label *label115
-    * jump *label118 equal *tmp156 1
-    * jump *label117 always
+  503 jump *label117 notEqual *tmp156 1
   504 label *label118
   505 set *tmp155 "[]"
   506 jump *label108 always
   507 label *label117
-    * jump *label120 equal *tmp156 2
-    * jump *label119 always
+  508 jump *label119 notEqual *tmp156 2
   509 label *label120
   510 set *tmp155 "[]"
   511 jump *label108 always
   512 label *label119
-    * jump *label122 equal *tmp156 11
-    * jump *label121 always
+  513 jump *label121 notEqual *tmp156 11
   514 label *label122
   515 set *tmp155 "[]"
   516 jump *label108 always
   517 label *label121
-    * jump *label124 equal *tmp156 10
-    * jump *label123 always
+  518 jump *label123 notEqual *tmp156 10
   519 label *label124
   520 set *tmp155 "[]"
   521 jump *label108 always
   522 label *label123
-    * jump *label126 equal *tmp156 15
-    * jump *label125 always
+  523 jump *label125 notEqual *tmp156 15
   524 label *label126
   525 set *tmp155 "[]"
   526 jump *label108 always
   527 label *label125
-    * jump *label128 equal *tmp156 4
-    * jump *label127 always
+  528 jump *label127 notEqual *tmp156 4
   529 label *label128
   530 set *tmp155 "[]"
   531 jump *label108 always
   532 label *label127
-    * jump *label130 equal *tmp156 8
-    * jump *label129 always
+  533 jump *label129 notEqual *tmp156 8
   534 label *label130
   535 set *tmp155 "[]"
   536 jump *label108 always
   537 label *label129
-    * jump *label132 equal *tmp156 9
-    * jump *label131 always
+  538 jump *label131 notEqual *tmp156 9
   539 label *label132
   540 set *tmp155 "[]"
   541 jump *label108 always
   542 label *label131
-    * jump *label134 equal *tmp156 13
-    * jump *label133 always
+  543 jump *label133 notEqual *tmp156 13
   544 label *label134
   545 set *tmp155 "[]"
   546 jump *label108 always
   547 label *label133
-    * jump *label136 equal *tmp156 12
-    * jump *label135 always
+  548 jump *label135 notEqual *tmp156 12
   549 label *label136
   550 set *tmp155 "[]"
   551 jump *label108 always
   552 label *label135
-    * jump *label138 equal *tmp156 7
-    * jump *label137 always
+  553 jump *label137 notEqual *tmp156 7
   554 label *label138
   555 set *tmp155 "[]"
   556 jump *label108 always
   557 label *label137
-    * jump *label140 equal *tmp156 6
-    * jump *label139 always
+  558 jump *label139 notEqual *tmp156 6
   559 label *label140
   560 set *tmp155 "[]"
   561 jump *label108 always
 
   583 jump *label143 notEqual *tmp166 false
   584 label *label144
   585 op greaterThan *tmp167 :wait_time .WAIT_LIMIT
-    * jump *label143 notEqual *tmp167 false
-    * jump *label141 always
+  586 jump *label141 equal *tmp167 false
   587 label *label143
   588 op div *tmp169 :wait_time 100
   589 op ceil *tmp170 *tmp169
 
   630 jump *label153 notEqual *tmp199 false
   631 label *label154
   632 op greaterThan *tmp200 :max_level .HIGH_LEVEL_TRIGGER
-    * jump *label153 notEqual *tmp200 false
-    * jump *label151 always
+  633 jump *label151 equal *tmp200 false
   634 label *label153
   635 set *tmp201 true
   636 jump *label152 always
 
   642 jump *label157 notEqual *tmp202 false
   643 label *label158
   644 op greaterThan *tmp203 :trigger :remote_wait_time
-    * jump *label157 notEqual *tmp203 false
-    * jump *label155 always
+  645 jump *label155 equal *tmp203 false
   646 label *label157
   647 jump *label159 equal STABILIZATION false
   648 set :total_flow_3 :total_flow_2
 
   708 getlink :findAnotherContainer:block :findAnotherContainer:n
   709 sensor *tmp240 :findAnotherContainer:block @type
   710 jump *label173 equal *tmp240 @vault
-    * jump *label173 equal *tmp240 @container
-    * jump *label172 always
+  711 jump *label172 notEqual *tmp240 @container
   712 label *label173
   713 op add .CONTAINERS .CONTAINERS 1
   714 sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-78 instructions):
 
    45 set .DEC_MAX -1
    46 ubind UNIT
    47 label *label14
-    * op equal *tmp6 @unit null
-    * jump *label16 equal *tmp6 false
+   48 jump *label16 notEqual @unit null
    49 print "[salmon]No unit of type "
    50 print UNIT
    51 print " "
 
    63 set .TARGET 0
    64 label *label17
    65 sensor *tmp12 @unit @controller
-    * op equal *tmp13 *tmp12 @this
-    * jump *label20 equal *tmp13 false
+   66 jump *label20 notEqual *tmp12 @this
    67 sensor :state @unit @flag
    68 op greaterThanEq *tmp16 :state 1
    69 op lessThan *tmp17 :state 6
 
    74 label *label21
    75 ubind UNIT
    76 label *label18
-    * op notEqual *tmp19 @unit :first_unit
-    * jump *label19 equal *tmp19 false
+   77 jump *label19 equal @unit :first_unit
    78 label *label22
    79 sensor *tmp20 :first_unit @dead
-    * op equal *tmp21 *tmp20 0
-    * jump *label17 notEqual *tmp21 false
+   80 jump *label17 equal *tmp20 0
    81 label *label19
    82 set .CHANGE 0
    83 set :active .TARGET
 
    90 set .CONTAINERS 0
    91 set :n @links
    92 label *label26
-    * op greaterThan *tmp24 :n 0
-    * jump *label28 equal *tmp24 false
+   93 jump *label28 lessThanEq :n 0
    94 op sub :n :n 1
    95 getlink :block :n
    96 sensor *tmp28 :block @type
 
   106 label *label27
   107 jump *label26 always
   108 label *label28
-    * op equal *tmp30 .CONTAINER null
-    * jump *label32 equal *tmp30 false
+  109 jump *label32 notEqual .CONTAINER null
   110 print "[salmon]No vault or container."
   111 printflush message1
   112 jump *label33 always
 
   117 jump *label23 always
   118 label *label25
   119 set .CORE null
-    * op equal *tmp32 LINK_ID 0
-    * jump *label34 equal *tmp32 false
+  120 jump *label34 notEqual LINK_ID 0
   121 label *label36
-    * op equal *tmp34 .CORE null
-    * jump *label38 equal *tmp34 false
+  122 jump *label38 notEqual .CORE null
   123 print "[green]Locating core..."
   124 printflush message1
   125 ubind UNIT
   126 sensor *tmp35 @unit @controlled
-    * op equal *tmp36 *tmp35 0
-    * jump *label39 equal *tmp36 false
+  127 jump *label39 notEqual *tmp35 0
   128 ulocate building core false @copper .CORE_X .CORE_Y *tmp39 .CORE
   129 ucontrol flag .S_UNUSED
   130 jump *label40 always
 
   144 print ".."
   145 printflush message1
   146 label *label41
-    * op equal *tmp41 .CORE null
-    * jump *label43 equal *tmp41 false
+  147 jump *label43 notEqual .CORE null
   148 op add .QUERY_FLAG 99999900 LINK_ID
   149 set :flag .QUERY_FLAG
   150 ubind UNIT
   151 label *label44
   152 sensor *tmp43 @unit @controlled
-    * op notEqual *tmp44 *tmp43 0
-    * jump *label46 equal *tmp44 false
+  153 jump *label46 equal *tmp43 0
   154 ubind UNIT
   155 label *label45
   156 jump *label44 always
   157 label *label46
   158 ucontrol flag :flag
   159 label *label47
-    * op equal *tmp45 :flag .QUERY_FLAG
-    * jump *label49 equal *tmp45 false
+  160 jump *label49 notEqual :flag .QUERY_FLAG
   161 label *label51
   162 sensor *tmp46 @unit @dead
-    * op equal *tmp47 *tmp46 0
-    * jump *label49 equal *tmp47 false
+  163 jump *label49 notEqual *tmp46 0
   164 jump *label50 always
   165 label *label50
   166 ucontrol stop
 
   168 label *label48
   169 jump *label47 always
   170 label *label49
-    * op notEqual *tmp49 :flag .QUERY_FLAG
-    * jump *label52 equal *tmp49 false
+  171 jump *label52 equal :flag .QUERY_FLAG
   172 op idiv :position :flag 100
   173 op mod .CORE_X :position @mapw
   174 op idiv .CORE_Y :position @mapw
   175 label *label54
   176 sensor *tmp54 @unit @dead
-    * op equal *tmp55 *tmp54 0
-    * jump *label56 equal *tmp55 false
+  177 jump *label56 notEqual *tmp54 0
   178 label *label58
   179 ucontrol within .CORE_X .CORE_Y 8 *tmp56
-    * op equal *tmp57 *tmp56 false
-    * jump *label56 equal *tmp57 false
+  180 jump *label56 notEqual *tmp56 false
   181 jump *label57 always
   182 label *label57
   183 ucontrol approach .CORE_X .CORE_Y 6
 
   185 jump *label54 always
   186 label *label56
   187 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp59
-    * op notEqual *tmp60 :b_type @vault
-    * jump *label59 equal *tmp60 false
+  188 jump *label59 equal :b_type @vault
   189 print "[salmon]Building at "
   190 print .CORE_X
   191 print ","
 
   217 set .SORTER sorter1
   218 sensor :sorter_type .SORTER @type
   219 label *label63
-    * op notEqual *tmp64 :sorter_type @sorter
-    * jump *label65 equal *tmp64 false
+  220 jump *label65 equal :sorter_type @sorter
   221 label *label67
-    * op notEqual *tmp65 :sorter_type @inverted-sorter
-    * jump *label65 equal *tmp65 false
+  222 jump *label65 equal :sorter_type @inverted-sorter
   223 jump *label66 always
   224 label *label66
   225 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   226 print "\n"
-    * op notEqual *tmp66 .SORTER null
-    * jump *label68 equal *tmp66 false
+  227 jump *label68 equal .SORTER null
   228 print "Block found: "
   229 print .SORTER
   230 jump *label69 always
 
   236 label *label64
   237 jump *label63 always
   238 label *label65
-    * op equal *tmp69 :sorter_type @sorter
-    * jump *label70 equal *tmp69 false
+  239 jump *label70 notEqual :sorter_type @sorter
   240 set .SHOW_REMOTE_LEVEL true
   241 set .SRC .CORE
   242 set .DST .CONTAINER
 
   255 set .FLOW_CORR_SIGN 1
   256 set .SRC_REMOTE_WAIT 1
   257 set .DST_REMOTE_WAIT 0
-    * op equal *tmp80 LINK_ID 0
-    * jump *label72 equal *tmp80 false
+  258 jump *label72 notEqual LINK_ID 0
   259 set *tmp81 " from core"
   260 jump *label73 always
   261 label *label72
 
   284 set .FLOW_CORR_SIGN -1
   285 set .SRC_REMOTE_WAIT 0
   286 set .DST_REMOTE_WAIT 1
-    * op equal *tmp94 LINK_ID 0
-    * jump *label74 equal *tmp94 false
+  287 jump *label74 notEqual LINK_ID 0
   288 set *tmp95 " to core"
   289 jump *label75 always
   290 label *label74
 
   292 label *label75
   293 set .DIRECTION *tmp95
   294 label *label71
-    * op equal *tmp96 LINK_ID 0
-    * jump *label76 equal *tmp96 false
+  295 jump *label76 notEqual LINK_ID 0
   296 set *tmp97 ""
   297 jump *label77 always
   298 label *label76
 
   315 op mul *tmp111 2 *tmp110
   316 op div .TRAVEL_TIME *tmp111 .SPEED
   317 sensor *tmp113 .CONTAINER @x
-    * op lessThan *tmp114 *tmp113 .CORE_X
-    * jump *label78 equal *tmp114 false
+  318 jump *label78 greaterThanEq *tmp113 .CORE_X
   319 set *tmp115 15
   320 jump *label79 always
   321 label *label78
 
   323 label *label79
   324 op add .PARK_X .CORE_X *tmp115
   325 sensor *tmp117 .CONTAINER @y
-    * op lessThan *tmp118 *tmp117 .CORE_Y
-    * jump *label80 equal *tmp118 false
+  326 jump *label80 greaterThanEq *tmp117 .CORE_Y
   327 set *tmp119 15
   328 jump *label81 always
   329 label *label80
 
   368 label *label84
   369 ubind UNIT
   370 label *label87
-    * op equal *tmp127 @unit null
-    * jump *label89 equal *tmp127 false
+  371 jump *label89 notEqual @unit null
   372 print "No unit of type "
   373 print UNIT
   374 print " "
 
   395 sensor *tmp133 switch2 @enabled
   396 jump *label92 equal *tmp133 false
   397 control enabled switch2 false
-    * op lessThan *tmp136 .TARGET 1
-    * jump *label94 equal *tmp136 false
+  398 jump *label94 greaterThanEq .TARGET 1
   399 set .EFF_AUTO_ALLOCATION true
   400 set .TARGET 1
   401 set .DEC_LIMIT 0
 
   411 set .CORR_SIGN "[]"
   412 set :corr_per_min ""
   413 set .SPEED_UNIT_TXT "/min"
-    * op equal *tmp140 .TARGET 0
-    * jump *label96 equal *tmp140 false
+  414 jump *label96 notEqual .TARGET 0
   415 set *tmp141 "\n=== [salmon]Transport deactivated[] ==="
   416 jump *label97 always
   417 label *label96
 
   426 sensor *tmp142 :first_unit @dead
   427 op equal :alive *tmp142 0
   428 op equal *tmp144 @unit :first_unit
-    * op lessThanEq *tmp145 :alive *tmp144
-    * jump *label98 equal *tmp145 false
-    * op equal *tmp147 :active 0
-    * jump *label100 equal *tmp147 false
+  429 jump *label98 greaterThan :alive *tmp144
+  430 jump *label100 notEqual :active 0
   431 print "\n[salmon]No active units.[]"
   432 jump *label101 always
   433 label *label100
 
   435 printflush message2
   436 set .STATE_LIMIT 6
   437 sensor .ITEM .SORTER @config
-    * op notEqual *tmp150 .ITEM .LAST_ITEM
-    * jump *label102 equal *tmp150 false
+  438 jump *label102 equal .ITEM .LAST_ITEM
   439 label *label104
-    * op equal *tmp152 .ITEM null
-    * jump *label106 equal *tmp152 false
+  440 jump *label106 notEqual .ITEM null
   441 print "[salmon]No item type selected for transport.[]"
   442 printflush message1
   443 sensor .ITEM .SORTER @config
 
   546 set .LOOP_START @tick
   547 op mul *tmp164 :loop_time 100
   548 op idiv :loop_time_ms *tmp164 6
-    * op greaterThanEq *tmp166 :transfers :active
-    * jump *label143 notEqual *tmp166 false
+  549 jump *label143 greaterThanEq :transfers :active
   550 label *label144
-    * op greaterThan *tmp167 :wait_time .WAIT_LIMIT
-    * jump *label141 equal *tmp167 false
+  551 jump *label141 lessThanEq :wait_time .WAIT_LIMIT
   552 label *label143
   553 op div *tmp169 :wait_time 100
   554 op ceil *tmp170 *tmp169
 
   581 op add :total_flow_per_ms :items_per_ms :corr_per_ms
   582 op mul *tmp194 60000 :corr_per_ms
   583 op floor :corr_per_min *tmp194
-    * op greaterThanEq *tmp196 :corr_per_min 0
-    * jump *label147 equal *tmp196 false
+  584 jump *label147 lessThan :corr_per_min 0
   585 set *tmp197 "[]([green]+"
   586 jump *label148 always
   587 label *label147
 
   590 set .CORR_SIGN *tmp197
   591 set .SPEED_UNIT_TXT "[])/min"
   592 jump *label149 equal :alive false
-    * op lessThan *tmp199 :min_level .LOW_LEVEL_TRIGGER
-    * jump *label153 notEqual *tmp199 false
+  593 jump *label153 lessThan :min_level .LOW_LEVEL_TRIGGER
   594 label *label154
-    * op greaterThan *tmp200 :max_level .HIGH_LEVEL_TRIGGER
-    * jump *label151 equal *tmp200 false
+  595 jump *label151 lessThanEq :max_level .HIGH_LEVEL_TRIGGER
   596 label *label153
   597 set *tmp201 true
   598 jump *label152 always
 
   600 set *tmp201 false
   601 label *label152
   602 set :trigger *tmp201
-    * op equal *tmp202 :wait_time 0
-    * jump *label157 notEqual *tmp202 false
+  603 jump *label157 equal :wait_time 0
   604 label *label158
-    * op greaterThan *tmp203 :trigger :remote_wait_time
-    * jump *label155 equal *tmp203 false
+  605 jump *label155 lessThanEq :trigger :remote_wait_time
   606 label *label157
   607 jump *label159 equal STABILIZATION false
   608 set :total_flow_3 :total_flow_2
 
   647 jump *label146 always
   648 label *label145
   649 label *label146
-    * op greaterThan *tmp227 .CONTAINERS 1
-    * jump *label161 equal *tmp227 false
+  650 jump *label161 lessThanEq .CONTAINERS 1
   651 label *label164
-    * op equal *tmp228 .SRC .CORE
-    * jump *label161 equal *tmp228 false
+  652 jump *label161 notEqual .SRC .CORE
   653 jump *label163 always
   654 label *label163
   655 sensor *tmp230 .DST .ITEM
   656 op sub :max_drop .DROP_LEVEL *tmp230
-    * op lessThan *tmp232 :max_drop .DROP_PACK
-    * jump *label165 equal *tmp232 false
+  657 jump *label165 greaterThanEq :max_drop .DROP_PACK
   658 set :findAnotherContainer:min_level 999999
   659 set .CONTAINERS 0
   660 set :findAnotherContainer:n @links
   661 label *label168
-    * op greaterThan *tmp236 :findAnotherContainer:n 0
-    * jump *label170 equal *tmp236 false
+  662 jump *label170 lessThanEq :findAnotherContainer:n 0
   663 op sub :findAnotherContainer:n :findAnotherContainer:n 1
   664 getlink :findAnotherContainer:block :findAnotherContainer:n
   665 sensor *tmp240 :findAnotherContainer:block @type
 
   668 label *label173
   669 op add .CONTAINERS .CONTAINERS 1
   670 sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM
-    * op lessThan *tmp243 :findAnotherContainer:level :findAnotherContainer:min_level
-    * jump *label174 equal *tmp243 false
+  671 jump *label174 greaterThanEq :findAnotherContainer:level :findAnotherContainer:min_level
   672 set :findAnotherContainer:min_level :findAnotherContainer:level
   673 set .CONTAINER :findAnotherContainer:block
   674 set .CONTAINER_INDEX :findAnotherContainer:n
 
   681 label *label169
   682 jump *label168 always
   683 label *label170
-    * op equal *tmp245 .CONTAINERS 0
-    * jump *label176 equal *tmp245 false
+  684 jump *label176 notEqual .CONTAINERS 0
   685 set .CONTAINER @this
   686 jump *label177 always
   687 label *label176
 
   720 label *label162
   721 set :wait_time 0
   722 set :remote_wait_time 0
-    * op greaterThanEq *tmp263 @tick .MESSAGE_TIMEOUT
-    * jump *label178 equal *tmp263 false
+  723 jump *label178 lessThan @tick .MESSAGE_TIMEOUT
   724 set .MESSAGE ""
   725 jump *label179 always
   726 label *label178
 
   736 print .DIRECTION
   737 print .LINK_TXT
   738 print .AUTO_ALLOCATION_TXT
-    * op greaterThan *tmp265 .TARGET 0
-    * jump *label180 equal *tmp265 false
-    * op greaterThanEq *tmp267 :active .TARGET
-    * jump *label182 equal *tmp267 false
+  739 jump *label180 lessThanEq .TARGET 0
+  740 jump *label182 lessThan :active .TARGET
   741 print "\n"
   742 print "Using [green]"
   743 print :active
 
   763 print " [gold]+"
   764 print :items_in_transit
   765 label *label183
-    * op greaterThan *tmp269 .CHANGE 0
-    * jump *label184 equal *tmp269 false
+  766 jump *label184 lessThanEq .CHANGE 0
   767 print "\n[][salmon]Cannot acquire additional units![]"
   768 jump *label185 always
   769 label *label184
 
   774 print "\n"
   775 print "[]Local items: [gold]"
   776 print :container_items
-    * op lessThan *tmp271 .EFF_LOCAL_LIMIT 100
-    * jump *label186 equal *tmp271 false
+  777 jump *label186 greaterThanEq .EFF_LOCAL_LIMIT 100
   778 print "[] (limit [orange]"
   779 print .LOCAL_MARGIN
   780 print "["
 
   787 print "\n"
   788 print "[]Remote items: [gold]"
   789 print :remote_level
-    * op lessThan *tmp275 .EFF_REMOTE_LIMIT 100
-    * jump *label190 equal *tmp275 false
+  790 jump *label190 greaterThanEq .EFF_REMOTE_LIMIT 100
   791 print "[] (limit [orange]"
   792 print .REMOTE_MARGIN
   793 print "["
 
   798 jump *label189 always
   799 label *label188
   800 label *label189
-    * op greaterThan *tmp277 .TARGET 0
-    * jump *label192 equal *tmp277 false
+  801 jump *label192 lessThanEq .TARGET 0
   802 print "\n"
   803 print "[]Speed: [green]"
   804 print :items_per_min
 
   847 set :items_in_transit 0
   848 print "Unit status:"
   849 sensor *tmp282 .SRC @dead
-    * op notEqual *tmp283 *tmp282 0
-    * jump *label196 equal *tmp283 false
+  850 jump *label196 equal *tmp282 0
   851 jump *label86 always
   852 jump *label197 always
   853 label *label196
   854 label *label197
   855 sensor *tmp285 .DST @dead
-    * op notEqual *tmp286 *tmp285 0
-    * jump *label198 equal *tmp286 false
+  856 jump *label198 equal *tmp285 0
   857 jump *label86 always
   858 jump *label199 always
   859 label *label198
   860 label *label199
   861 sensor *tmp288 .SORTER @dead
-    * op notEqual *tmp289 *tmp288 0
-    * jump *label200 equal *tmp289 false
+  862 jump *label200 equal *tmp288 0
   863 jump *label86 always
   864 jump *label201 always
   865 label *label200
   866 label *label201
   867 getlink *tmp291 .CONTAINER_INDEX
-    * op notEqual *tmp292 .CONTAINER *tmp291
-    * jump *label202 equal *tmp292 false
+  868 jump *label202 equal .CONTAINER *tmp291
   869 jump *label86 always
   870 jump *label203 always
   871 label *label202
 
   873 jump *label99 always
   874 label *label98
   875 label *label99
-    * op greaterThan *tmp294 .CHANGE 0
-    * jump *label204 equal *tmp294 false
+  876 jump *label204 lessThanEq .CHANGE 0
   877 sensor *tmp296 @unit @controlled
-    * op equal *tmp297 *tmp296 0
-    * jump *label206 equal *tmp297 false
+  878 jump *label206 notEqual *tmp296 0
   879 op sub .CHANGE .CHANGE 1
   880 ucontrol flag 1
   881 jump *label207 always
 
   885 label *label204
   886 label *label205
   887 sensor *tmp299 @unit @controller
-    * op equal *tmp300 *tmp299 @this
-    * jump *label208 equal *tmp300 false
+  888 jump *label208 notEqual *tmp299 @this
   889 sensor :state @unit @flag
-    * op notEqual *tmp303 :state .S_UNUSED
-    * jump *label210 equal *tmp303 false
+  890 jump *label210 equal :state .S_UNUSED
   891 op max *tmp305 :state 1
   892 op min :state *tmp305 .STATE_LIMIT
-    * op lessThan *tmp307 .CHANGE 0
-    * jump *label212 equal *tmp307 false
-    * op notEqual *tmp309 :state 6
-    * jump *label214 equal *tmp309 false
+  893 jump *label212 greaterThanEq .CHANGE 0
+  894 jump *label214 equal :state 6
   895 sensor *tmp311 @unit @totalItems
-    * op lessThanEq *tmp312 *tmp311 .DISCARD_UNIT_MAX_ITEMS
-    * jump *label216 equal *tmp312 false
+  896 jump *label216 greaterThan *tmp311 .DISCARD_UNIT_MAX_ITEMS
   897 op add .CHANGE .CHANGE 1
   898 set :state 6
   899 jump *label217 always
 
   905 jump *label213 always
   906 label *label212
   907 label *label213
-    * op equal *tmp314 :state 1
-    * jump *label218 equal *tmp314 false
+  908 jump *label218 notEqual :state 1
   909 sensor *tmp316 @unit @totalItems
-    * op equal *tmp317 *tmp316 0
-    * jump *label220 equal *tmp317 false
+  910 jump *label220 notEqual *tmp316 0
   911 set :state 2
   912 jump *label221 always
   913 label *label220
   914 sensor *tmp319 @unit @firstItem
-    * op equal *tmp320 *tmp319 .ITEM
-    * jump *label222 equal *tmp320 false
+  915 jump *label222 notEqual *tmp319 .ITEM
   916 set :state 4
   917 jump *label223 always
   918 label *label222
 
   937 jump *label219 always
   938 label *label218
   939 label *label219
-    * op equal *tmp325 :state 2
-    * jump *label228 equal *tmp325 false
+  940 jump *label228 notEqual :state 2
   941 ucontrol approach .SRC_X .SRC_Y 6
   942 ucontrol within .SRC_X .SRC_Y 8 *tmp327
   943 jump *label230 equal *tmp327 false
 
   968 jump *label229 always
   969 label *label228
   970 label *label229
-    * op equal *tmp337 :state 3
-    * jump *label233 equal *tmp337 false
+  971 jump *label233 notEqual :state 3
   972 sensor *tmp339 .SRC .ITEM
   973 op sub :max_load *tmp339 .LOAD_LEVEL
-    * op greaterThanEq *tmp341 :max_load .LOAD_PACK
-    * jump *label235 equal *tmp341 false
+  974 jump *label235 lessThan :max_load .LOAD_PACK
   975 ucontrol itemTake .SRC .ITEM :max_load
   976 jump *label236 always
   977 label *label235
   978 label *label236
   979 sensor *tmp343 @unit @totalItems
-    * op greaterThanEq *tmp344 *tmp343 .UNIT_CAPACITY
-    * jump *label237 equal *tmp344 false
+  980 jump *label237 lessThan *tmp343 .UNIT_CAPACITY
   981 set :state 4
   982 jump *label238 always
   983 label *label237
 
   992 jump *label234 always
   993 label *label233
   994 label *label234
-    * op equal *tmp347 :state 4
-    * jump *label239 equal *tmp347 false
+  995 jump *label239 notEqual :state 4
   996 ucontrol approach .DST_X .DST_Y 6
   997 ucontrol within .DST_X .DST_Y 8 *tmp349
   998 jump *label241 equal *tmp349 false
 
  1026 jump *label240 always
  1027 label *label239
  1028 label *label240
-    * op equal *tmp360 :state 5
-    * jump *label244 equal *tmp360 false
+ 1029 jump *label244 notEqual :state 5
  1030 sensor *tmp362 .DST .ITEM
  1031 op sub :max_drop .DROP_LEVEL *tmp362
-    * op greaterThanEq *tmp364 :max_drop .DROP_PACK
-    * jump *label246 equal *tmp364 false
+ 1032 jump *label246 lessThan :max_drop .DROP_PACK
  1033 ucontrol itemDrop .DST :max_drop
  1034 jump *label247 always
  1035 label *label246
  1036 label *label247
  1037 sensor *tmp366 @unit @totalItems
-    * op lessThanEq *tmp367 *tmp366 0
-    * jump *label248 equal *tmp367 false
+ 1038 jump *label248 greaterThan *tmp366 0
  1039 set :state 2
  1040 ucontrol approach .SRC_X .SRC_Y 6
  1041 set :printUnitInfo.2:name "source"
 
  1073 label *label245
  1074 sensor :items @unit @totalItems
  1075 op add :items_in_transit :items_in_transit :items
-    * op equal *tmp379 :state 6
-    * jump *label251 equal *tmp379 false
+ 1076 jump *label251 notEqual :state 6
  1077 print "[]"
  1078 print "\n"
  1079 print "Parking: [green]"
-    * op greaterThan *tmp381 :items 0
-    * jump *label253 equal *tmp381 false
+ 1080 jump *label253 lessThanEq :items 0
  1081 jump *label255 equal .DROP_TO_CORE false
  1082 ucontrol approach .CORE_X .CORE_Y 6
  1083 ucontrol within .CORE_X .CORE_Y 8 *tmp384
 
  1095 jump *label254 always
  1096 label *label253
  1097 label *label254
-    * op lessThanEq *tmp388 :items .PARK_ITEM_LIMIT
-    * jump *label259 equal *tmp388 false
+ 1098 jump *label259 greaterThan :items .PARK_ITEM_LIMIT
  1099 ucontrol move .PARK_X .PARK_Y
  1100 set :state .S_UNUSED
  1101 jump *label260 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-51 instructions):
 
    69 op lessThan *tmp17 :state 6
    70 op land *tmp18 *tmp16 *tmp17
    71 op add .TARGET .TARGET *tmp18
-    * jump *label21 always
    72 label *label20
    73 label *label21
    74 ubind UNIT
 
    99 set .CONTAINER :block
   100 op add .CONTAINERS .CONTAINERS 1
   101 set .CONTAINER_INDEX :n
-    * jump *label29 always
   102 label *label30
   103 label *label29
   104 label *label27
 
   125 jump *label39 notEqual *tmp35 0
   126 ulocate building core false @copper .CORE_X .CORE_Y *tmp39 .CORE
   127 ucontrol flag .S_UNUSED
-    * jump *label40 always
   128 label *label39
   129 label *label40
   130 label *label37
 
   158 label *label51
   159 sensor *tmp46 @unit @dead
   160 jump *label49 notEqual *tmp46 0
-    * jump *label50 always
   161 label *label50
   162 ucontrol stop
   163 sensor :flag @unit @flag
 
   174 label *label58
   175 ucontrol within .CORE_X .CORE_Y 8 *tmp56
   176 jump *label56 notEqual *tmp56 false
-    * jump *label57 always
   177 label *label57
   178 ucontrol approach .CORE_X .CORE_Y 6
   179 label *label55
 
   190 print "is not a vault!"
   191 printflush message2
   192 set .CORE null
-    * jump *label60 always
   193 label *label59
   194 label *label60
-    * jump *label53 always
   195 label *label52
   196 label *label53
   197 ucontrol flag .S_UNUSED
 
   213 jump *label65 equal :sorter_type @sorter
   214 label *label67
   215 jump *label65 equal :sorter_type @inverted-sorter
-    * jump *label66 always
   216 label *label66
   217 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   218 print "\n"
   219 jump *label68 equal .SORTER null
   220 print "Block found: "
   221 print .SORTER
-    * jump *label69 always
   222 label *label68
   223 label *label69
   224 printflush message1
 
   380 set :corr_per_min ""
   381 set .SPEED_UNIT_TXT "/min"
   382 set .WAIT_LIMIT 30000
-    * jump *label91 always
   383 label *label90
   384 label *label91
   385 sensor *tmp133 switch2 @enabled
 
   410 set .AUTO_ALLOCATION_TXT *tmp141
   411 label *label95
   412 set .WAIT_LIMIT 30000
-    * jump *label93 always
   413 label *label92
   414 label *label93
   415 sensor *tmp142 :first_unit @dead
 
   418 jump *label98 greaterThan :alive *tmp144
   419 jump *label100 notEqual :active 0
   420 print "\n[salmon]No active units.[]"
-    * jump *label101 always
   421 label *label100
   422 label *label101
   423 printflush message2
 
   524 sensor :last_level .CONTAINER .ITEM
   525 set :min_level 999999
   526 set :max_level 0
-    * jump *label103 always
   527 label *label102
   528 label *label103
   529 sensor :container_items .CONTAINER .ITEM
 
   598 op add *tmp206 :total_flow_3 :total_flow_2
   599 op add *tmp207 *tmp206 :total_flow_1
   600 op div :total_flow_per_ms *tmp207 3
-    * jump *label160 always
   601 label *label159
   602 label *label160
   603 op div *tmp209 :total_flow_per_ms :items_per_ms_unit
 
   630 label *label150
   631 set :min_level 999999
   632 set :max_level 0
-    * jump *label146 always
   633 label *label145
   634 label *label146
   635 jump *label161 lessThanEq .CONTAINERS 1
   636 label *label164
   637 jump *label161 notEqual .SRC .CORE
-    * jump *label163 always
   638 label *label163
   639 sensor *tmp230 .DST .ITEM
   640 op sub :max_drop .DROP_LEVEL *tmp230
 
   656 set :findAnotherContainer:min_level :findAnotherContainer:level
   657 set .CONTAINER :findAnotherContainer:block
   658 set .CONTAINER_INDEX :findAnotherContainer:n
-    * jump *label175 always
   659 label *label174
   660 label *label175
-    * jump *label171 always
   661 label *label172
   662 label *label171
   663 label *label169
 
   694 label *label167
   695 set :this_level *tmp234
   696 set :last_level :this_level
-    * jump *label166 always
   697 label *label165
   698 label *label166
-    * jump *label162 always
   699 label *label161
   700 label *label162
   701 set :wait_time 0
   702 set :remote_wait_time 0
   703 jump *label178 lessThan @tick .MESSAGE_TIMEOUT
   704 set .MESSAGE ""
-    * jump *label179 always
   705 label *label178
   706 label *label179
-    * jump *label142 always
   707 label *label141
   708 label *label142
   709 print .MESSAGE
 
   743 label *label183
   744 jump *label184 lessThanEq .CHANGE 0
   745 print "\n[][salmon]Cannot acquire additional units![]"
-    * jump *label185 always
   746 label *label184
   747 label *label185
-    * jump *label181 always
   748 label *label180
   749 label *label181
   750 print "\n"
 
   755 print .LOCAL_MARGIN
   756 print "["
   757 print "])"
-    * jump *label187 always
   758 label *label186
   759 label *label187
   760 jump *label188 equal .SHOW_REMOTE_LEVEL false
 
   767 print .REMOTE_MARGIN
   768 print "["
   769 print "])"
-    * jump *label191 always
   770 label *label190
   771 label *label191
-    * jump *label189 always
   772 label *label188
   773 label *label189
   774 jump *label192 lessThanEq .TARGET 0
 
   805 print :wait_time_str
   806 print "["
   807 print "] s"
-    * jump *label193 always
   808 label *label192
   809 label *label193
   810 print "\n"
 
   821 sensor *tmp282 .SRC @dead
   822 jump *label196 equal *tmp282 0
   823 jump *label86 always
-    * jump *label197 always
   824 label *label196
   825 label *label197
   826 sensor *tmp285 .DST @dead
   827 jump *label198 equal *tmp285 0
   828 jump *label86 always
-    * jump *label199 always
   829 label *label198
   830 label *label199
   831 sensor *tmp288 .SORTER @dead
   832 jump *label200 equal *tmp288 0
   833 jump *label86 always
-    * jump *label201 always
   834 label *label200
   835 label *label201
   836 getlink *tmp291 .CONTAINER_INDEX
   837 jump *label202 equal .CONTAINER *tmp291
   838 jump *label86 always
-    * jump *label203 always
   839 label *label202
   840 label *label203
-    * jump *label99 always
   841 label *label98
   842 label *label99
   843 jump *label204 lessThanEq .CHANGE 0
 
   845 jump *label206 notEqual *tmp296 0
   846 op sub .CHANGE .CHANGE 1
   847 ucontrol flag 1
-    * jump *label207 always
   848 label *label206
   849 label *label207
-    * jump *label205 always
   850 label *label204
   851 label *label205
   852 sensor *tmp299 @unit @controller
 
   861 jump *label216 greaterThan *tmp311 .DISCARD_UNIT_MAX_ITEMS
   862 op add .CHANGE .CHANGE 1
   863 set :state 6
-    * jump *label217 always
   864 label *label216
   865 label *label217
-    * jump *label215 always
   866 label *label214
   867 label *label215
-    * jump *label213 always
   868 label *label212
   869 label *label213
   870 jump *label218 notEqual :state 1
 
   883 ucontrol within .CORE_X .CORE_Y 8 *tmp323
   884 jump *label226 equal *tmp323 false
   885 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label227 always
   886 label *label226
   887 label *label227
   888 print "[]"
 
   895 label *label225
   896 label *label223
   897 label *label221
-    * jump *label219 always
   898 label *label218
   899 label *label219
   900 jump *label228 notEqual :state 2
 
   925 print " [green]"
   926 label *label232
   927 label *label231
-    * jump *label229 always
   928 label *label228
   929 label *label229
   930 jump *label233 notEqual :state 3
 
   932 op sub :max_load *tmp339 .LOAD_LEVEL
   933 jump *label235 lessThan :max_load .LOAD_PACK
   934 ucontrol itemTake .SRC .ITEM :max_load
-    * jump *label236 always
   935 label *label235
   936 label *label236
   937 sensor *tmp343 @unit @totalItems
 
   947 op mul *tmp346 :loop_time_ms .SRC_REMOTE_WAIT
   948 op add :remote_wait_time :remote_wait_time *tmp346
   949 label *label238
-    * jump *label234 always
   950 label *label233
   951 label *label234
   952 jump *label239 notEqual :state 4
 
   980 print " [green]"
   981 label *label243
   982 label *label242
-    * jump *label240 always
   983 label *label239
   984 label *label240
   985 jump *label244 notEqual :state 5
 
   987 op sub :max_drop .DROP_LEVEL *tmp362
   988 jump *label246 lessThan :max_drop .DROP_PACK
   989 ucontrol itemDrop .DST :max_drop
-    * jump *label247 always
   990 label *label246
   991 label *label247
   992 sensor *tmp366 @unit @totalItems
 
  1023 op mul *tmp377 :loop_time_ms .DST_REMOTE_WAIT
  1024 op add :remote_wait_time :remote_wait_time *tmp377
  1025 label *label249
-    * jump *label245 always
  1026 label *label244
  1027 label *label245
  1028 sensor :items @unit @totalItems
 
  1038 jump *label257 equal *tmp384 false
  1039 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1040 sensor :items @unit @totalItems
-    * jump *label258 always
  1041 label *label257
  1042 label *label258
  1043 jump *label256 always
 
  1045 ucontrol itemDrop @air .UNIT_CAPACITY
  1046 sensor :items @unit @totalItems
  1047 label *label256
-    * jump *label254 always
  1048 label *label253
  1049 label *label254
  1050 jump *label259 greaterThan :items .PARK_ITEM_LIMIT
  1051 ucontrol move .PARK_X .PARK_Y
  1052 set :state .S_UNUSED
-    * jump *label260 always
  1053 label *label259
  1054 label *label260
  1055 jump *label252 always
 
  1059 print :items
  1060 print .ITEM_ICON
  1061 ucontrol flag :state
-    * jump *label211 always
  1062 label *label210
  1063 label *label211
-    * jump *label209 always
  1064 label *label208
  1065 label *label209
  1066 label *label85

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
   557 op idiv *tmp183 :turnaround_ms 100
   558 op div :turnaround_str *tmp183 10
   559 op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms
-    * op mul *tmp186 :items_per_ms_unit 60000
-    * op floor :items_per_min_unit *tmp186
+  560 op idiv :items_per_min_unit :items_per_ms_unit 0.000016666666666666667
   561 op add *tmp188 :min_level :max_level
   562 op div :this_level *tmp188 2
   563 op sub *tmp190 :last_level :this_level
 
   565 op div :corr_per_ms :corr :elapsed_ms
   566 set :last_level :this_level
   567 op add :total_flow_per_ms :items_per_ms :corr_per_ms
-    * op mul *tmp194 60000 :corr_per_ms
-    * op floor :corr_per_min *tmp194
+  568 op idiv :corr_per_min :corr_per_ms 0.000016666666666666667
   569 jump *label147 lessThan :corr_per_min 0
   570 set *tmp197 "[]([green]+"
   571 jump *label148 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    30 set .TRIGGER_LEVEL 0.9
    31 op mul .S_UNUSED -1 HOUSEKEEPING
    32 set .STATE_LIMIT null
-    * set .ITEM_ICON .STATE_LIMIT
-    * set .ITEM .ITEM_ICON
-    * set .CORE_Y .ITEM
-    * set .CORE_X .CORE_Y
-    * set .CONTAINER_INDEX .CORE_X
+   33 set .ITEM_ICON null
+   34 set .ITEM .STATE_LIMIT
+   35 set .CORE_Y .ITEM_ICON
+   36 set .CORE_X .ITEM
+   37 set .CONTAINER_INDEX .CORE_Y
    38 set .LOOPS 1
-    * op mul *tmp3 .LOOPS 1000
-    * op div .LOOPS_TICKS_TO_MS *tmp3 60
+   39 op mul *tmp3 1 1000
+   40 op div .LOOPS_TICKS_TO_MS 1000 60
    41 set .INC_OVERALLOCATION OVERALLOCATION_LOW
    42 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    43 set .TRIGGER_BOOST 2
 
   152 label *label45
   153 jump *label44 always
   154 label *label46
-    * ucontrol flag :flag
+  155 ucontrol flag .QUERY_FLAG
   156 label *label47
   157 jump *label49 notEqual :flag .QUERY_FLAG
   158 label *label51
 
   208 set .DROP_TO_CORE false
   209 label *label35
   210 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  211 sensor :sorter_type sorter1 @type
   212 label *label63
   213 jump *label65 equal :sorter_type @sorter
   214 label *label67
 
   223 label *label69
   224 printflush message1
   225 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  226 sensor :sorter_type sorter1 @type
   227 label *label64
   228 jump *label63 always
   229 label *label65
 
   231 set .SHOW_REMOTE_LEVEL true
   232 set .SRC .CORE
   233 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  234 sensor :src_capacity .CORE @itemCapacity
+  235 sensor :dst_capacity .CONTAINER @itemCapacity
   236 op sub *tmp73 100 .EFF_REMOTE_LIMIT
   237 op mul *tmp74 :src_capacity *tmp73
   238 op idiv .LOAD_LEVEL *tmp74 100
 
   240 op idiv .DROP_LEVEL *tmp76 100
   241 set .LOCAL_MARGIN .DROP_LEVEL
   242 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op sub *tmp78 1 .TRIGGER_LEVEL
-    * op mul .LOW_LEVEL_TRIGGER :dst_capacity *tmp78
+  243 op sub *tmp78 1 0.9
+  244 op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998
   245 set .HIGH_LEVEL_TRIGGER :dst_capacity
   246 set .FLOW_CORR_SIGN 1
   247 set .SRC_REMOTE_WAIT 1
 
   258 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   259 set .SRC .CONTAINER
   260 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  261 sensor :src_capacity .CONTAINER @itemCapacity
+  262 sensor :dst_capacity .CORE @itemCapacity
   263 op sub *tmp85 100 .EFF_LOCAL_LIMIT
   264 op mul *tmp86 :src_capacity *tmp85
   265 op idiv .LOAD_LEVEL *tmp86 100
 
   270 op add .DROP_LEVEL *tmp89 *tmp91
   271 set .LOCAL_MARGIN .LOAD_LEVEL
   272 set .REMOTE_MARGIN .DROP_LEVEL
-    * op mul .HIGH_LEVEL_TRIGGER :src_capacity .TRIGGER_LEVEL
+  273 op mul .HIGH_LEVEL_TRIGGER :src_capacity 0.9
   274 set .LOW_LEVEL_TRIGGER 0
   275 set .FLOW_CORR_SIGN -1
   276 set .SRC_REMOTE_WAIT 0
 
   301 op sub *tmp106 .DST_Y .SRC_Y
   302 op len *tmp107 *tmp105 *tmp106
   303 op sub *tmp108 *tmp107 6
-    * op sub .DISTANCE *tmp108 8
+  304 op sub .DISTANCE *tmp107 14
   305 op max *tmp110 .DISTANCE 10
   306 op mul *tmp111 2 *tmp110
   307 op div .TRAVEL_TIME *tmp111 .SPEED
 
   335 set :elapsed_str "--"
   336 set :wait_time_str 0
   337 set :wait_time 0
-    * set :transfers :wait_time
-    * set :transferred :transfers
-    * set :total_flow_2 :transferred
-    * set :total_flow_1 :total_flow_2
-    * set :remote_wait_time :total_flow_1
-    * set :min_level :remote_wait_time
-    * set :max_level :min_level
-    * set :loop_time_ms :max_level
-    * set :last_level :loop_time_ms
-    * jump *label82 equal .EFF_AUTO_ALLOCATION false
+  338 set :transfers 0
+  339 set :transferred :wait_time
+  340 set :total_flow_2 :transfers
+  341 set :total_flow_1 :transferred
+  342 set :remote_wait_time :total_flow_2
+  343 set :min_level :total_flow_1
+  344 set :max_level :remote_wait_time
+  345 set :loop_time_ms :min_level
+  346 set :last_level :max_level
+  347 jump *label82 equal AUTO_ALLOCATION false
   348 set .CORR_SIGN "[]([green]+"
   349 set :corr_per_min 0
   350 set .SPEED_UNIT_TXT "[])/min"
 
   434 label *label106
   435 set .LAST_ITEM .ITEM
   436 set :itemTypeToIcon:itemType .ITEM
-    * sensor *tmp156 :itemTypeToIcon:itemType @id
+  437 sensor *tmp156 .ITEM @id
   438 jump *label109 notEqual *tmp156 14
   439 label *label110
   440 set *tmp155 "[]"
 
   519 label *label108
   520 set *tmp154 *tmp155
   521 label *label107
-    * set .ITEM_ICON *tmp154
+  522 set .ITEM_ICON *tmp155
   523 set .STATE_LIMIT 1
   524 sensor :last_level .CONTAINER .ITEM
   525 set :min_level 999999
 
   551 set :transfers 0
   552 jump *label145 equal .EFF_AUTO_ALLOCATION false
   553 set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] ==="
-    * op mul *tmp180 .LOOPS_TICKS_TO_MS :loop_time
+  554 op mul *tmp180 16.666666666666668 :loop_time
   555 op add :turnaround_ms .TRAVEL_TIME *tmp180
   556 op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION
   557 op idiv *tmp183 :turnaround_ms 100
 
   587 set :trigger *tmp201
   588 jump *label157 equal :wait_time 0
   589 label *label158
-    * jump *label155 lessThanEq :trigger :remote_wait_time
+  590 jump *label155 lessThanEq *tmp201 :remote_wait_time
   591 label *label157
   592 jump *label159 equal STABILIZATION false
   593 set :total_flow_3 :total_flow_2
   594 set :total_flow_2 :total_flow_1
   595 set :total_flow_1 :total_flow_per_ms
   596 op add *tmp206 :total_flow_3 :total_flow_2
-    * op add *tmp207 *tmp206 :total_flow_1
+  597 op add *tmp207 *tmp206 :total_flow_per_ms
   598 op div :total_flow_per_ms *tmp207 3
   599 label *label159
   600 label *label160
   601 op div *tmp209 :total_flow_per_ms :items_per_ms_unit
-    * op add *tmp210 *tmp209 .INC_OVERALLOCATION
+  602 op add *tmp210 *tmp209 OVERALLOCATION_LOW
   603 op ceil :new_target *tmp210
-    * op mul :level_boost .TRIGGER_BOOST :trigger
+  604 op mul :level_boost 2 *tmp201
   605 op add *tmp213 :new_target :level_boost
   606 op min :new_target *tmp213 MAX_UNITS
   607 op sub *tmp215 :new_target :active
   608 op max *tmp216 *tmp215 0
   609 op min :new_change *tmp216 .INC_LIMIT
-    * set .INC_LIMIT .INC_MAX
+  610 set .INC_LIMIT 6
   611 op lessThanEq *tmp218 :new_change 0
-    * op mul .DEC_LIMIT *tmp218 .DEC_MAX
+  612 op mul .DEC_LIMIT *tmp218 -1
   613 jump *label156 always
   614 label *label155
   615 op idiv *tmp220 :wait_time .WAIT_LIMIT
   616 op mul *tmp221 -1 *tmp220
   617 op max :new_change *tmp221 .DEC_LIMIT
   618 op greaterThanEq *tmp223 :new_change 0
-    * op mul .INC_LIMIT *tmp223 .INC_MAX
-    * set .DEC_LIMIT .DEC_MAX
+  619 op mul .INC_LIMIT *tmp223 6
+  620 set .DEC_LIMIT -1
   621 label *label156
   622 op add *tmp225 :active :new_change
   623 op max .TARGET *tmp225 1
 
   666 jump *label177 always
   667 label *label176
   668 set .DST .CONTAINER
-    * sensor :findAnotherContainer:dst_capacity .DST @itemCapacity
+  669 sensor :findAnotherContainer:dst_capacity .CONTAINER @itemCapacity
   670 op mul *tmp248 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
   671 op idiv .DROP_LEVEL *tmp248 100
   672 set .LOCAL_MARGIN .DROP_LEVEL
-    * op sub *tmp250 1 .TRIGGER_LEVEL
-    * op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity *tmp250
+  673 op sub *tmp250 1 0.9
+  674 op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity 0.09999999999999998
   675 set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
-    * sensor .DST_X .DST @x
-    * sensor .DST_Y .DST @y
+  676 sensor .DST_X .CONTAINER @x
+  677 sensor .DST_Y .CONTAINER @y
   678 op sub *tmp254 .DST_X .SRC_X
   679 op sub *tmp255 .DST_Y .SRC_Y
   680 op len *tmp256 *tmp254 *tmp255
   681 op sub *tmp257 *tmp256 6
-    * op sub .DISTANCE *tmp257 8
+  682 op sub .DISTANCE *tmp256 14
   683 op max *tmp259 .DISTANCE 10
   684 op mul *tmp260 2 *tmp259
   685 op div .TRAVEL_TIME *tmp260 .SPEED
 
   688 label *label177
   689 set *tmp234 :findAnotherContainer:min_level
   690 jump *label167 always
-    * set *tmp234 null
   691 label *label167
-    * set :this_level *tmp234
-    * set :last_level :this_level
+  692 set :this_level :findAnotherContainer:min_level
+  693 set :last_level *tmp234
   694 label *label165
   695 label *label166
   696 label *label161
 
   709 print "["
   710 print "]"
   711 print .DIRECTION
-    * print .LINK_TXT
+  712 print *tmp97
   713 print .AUTO_ALLOCATION_TXT
   714 jump *label180 lessThanEq .TARGET 0
   715 jump *label182 lessThan :active .TARGET
 
   905 set :printUnitInfo:x .SRC_X
   906 set :printUnitInfo:y .SRC_Y
   907 sensor *tmp330 @unit @x
-    * op sub *tmp331 :printUnitInfo:x *tmp330
+  908 op sub *tmp331 .SRC_X *tmp330
   909 sensor *tmp332 @unit @y
-    * op sub *tmp333 :printUnitInfo:y *tmp332
+  910 op sub *tmp333 .SRC_Y *tmp332
   911 op len *tmp334 *tmp331 *tmp333
   912 op idiv *tmp335 *tmp334 .SPEED_SEC
   913 op div *tmp336 *tmp335 10
 
   917 print *tmp336
   918 print " "
   919 print "sec[] to "
-    * print :printUnitInfo:name
+  920 print "source"
   921 print ":"
   922 print " [green]"
   923 label *label232
 
   960 set :printUnitInfo.1:x .DST_X
   961 set :printUnitInfo.1:y .DST_Y
   962 sensor *tmp353 @unit @x
-    * op sub *tmp354 :printUnitInfo.1:x *tmp353
+  963 op sub *tmp354 .DST_X *tmp353
   964 sensor *tmp355 @unit @y
-    * op sub *tmp356 :printUnitInfo.1:y *tmp355
+  965 op sub *tmp356 .DST_Y *tmp355
   966 op len *tmp357 *tmp354 *tmp356
   967 op idiv *tmp358 *tmp357 .SPEED_SEC
   968 op div *tmp359 *tmp358 10
 
   972 print *tmp359
   973 print " "
   974 print "sec[] to "
-    * print :printUnitInfo.1:name
+  975 print "destination"
   976 print ":"
   977 print " [green]"
   978 label *label243
 
   994 set :printUnitInfo.2:x .SRC_X
   995 set :printUnitInfo.2:y .SRC_Y
   996 sensor *tmp370 @unit @x
-    * op sub *tmp371 :printUnitInfo.2:x *tmp370
+  997 op sub *tmp371 .SRC_X *tmp370
   998 sensor *tmp372 @unit @y
-    * op sub *tmp373 :printUnitInfo.2:y *tmp372
+  999 op sub *tmp373 .SRC_Y *tmp372
  1000 op len *tmp374 *tmp371 *tmp373
  1001 op idiv *tmp375 *tmp374 .SPEED_SEC
  1002 op div *tmp376 *tmp375 10
 
  1006 print *tmp376
  1007 print " "
  1008 print "sec[] to "
-    * print :printUnitInfo.2:name
+ 1009 print "source"
  1010 print ":"
  1011 print " [green]"
  1012 label *label250

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-26 instructions):
 
    27 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
    28 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    29 set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION
-    * set .TRIGGER_LEVEL 0.9
    30 op mul .S_UNUSED -1 HOUSEKEEPING
    31 set .STATE_LIMIT null
    32 set .ITEM_ICON null
-    * set .ITEM .STATE_LIMIT
-    * set .CORE_Y .ITEM_ICON
-    * set .CORE_X .ITEM
-    * set .CONTAINER_INDEX .CORE_Y
-    * set .LOOPS 1
-    * op mul *tmp3 1 1000
-    * op div .LOOPS_TICKS_TO_MS 1000 60
-    * set .INC_OVERALLOCATION OVERALLOCATION_LOW
+   33 set .ITEM null
+   34 set .CORE_Y null
+   35 set .CORE_X .STATE_LIMIT
+   36 set .CONTAINER_INDEX .ITEM_ICON
    37 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
-    * set .TRIGGER_BOOST 2
-    * set .INC_MAX 6
-    * set .DEC_MAX -1
    38 ubind UNIT
    39 label *label14
    40 jump *label16 notEqual @unit null
 
   232 op idiv .DROP_LEVEL *tmp76 100
   233 set .LOCAL_MARGIN .DROP_LEVEL
   234 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op sub *tmp78 1 0.9
   235 op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998
   236 set .HIGH_LEVEL_TRIGGER :dst_capacity
   237 set .FLOW_CORR_SIGN 1
 
   280 label *label76
   281 set *tmp97 LINK_ID
   282 label *label77
-    * set .LINK_TXT *tmp97
   283 op sub *tmp98 :src_capacity .LOAD_LEVEL
   284 op min .LOAD_PACK .UNIT_CAPACITY *tmp98
   285 op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL
 
   290 op sub *tmp105 .DST_X .SRC_X
   291 op sub *tmp106 .DST_Y .SRC_Y
   292 op len *tmp107 *tmp105 *tmp106
-    * op sub *tmp108 *tmp107 6
   293 op sub .DISTANCE *tmp107 14
   294 op max *tmp110 .DISTANCE 10
   295 op mul *tmp111 2 *tmp110
 
   325 set :wait_time_str 0
   326 set :wait_time 0
   327 set :transfers 0
-    * set :transferred :wait_time
-    * set :total_flow_2 :transfers
-    * set :total_flow_1 :transferred
-    * set :remote_wait_time :total_flow_2
-    * set :min_level :total_flow_1
-    * set :max_level :remote_wait_time
-    * set :loop_time_ms :min_level
-    * set :last_level :max_level
+  328 set :transferred 0
+  329 set :total_flow_2 0
+  330 set :total_flow_1 :wait_time
+  331 set :remote_wait_time :transfers
+  332 set :min_level :transferred
+  333 set :max_level :total_flow_2
+  334 set :loop_time_ms :total_flow_1
+  335 set :last_level :remote_wait_time
   336 jump *label82 equal AUTO_ALLOCATION false
   337 set .CORR_SIGN "[]([green]+"
   338 set :corr_per_min 0
 
   422 jump *label104 always
   423 label *label106
   424 set .LAST_ITEM .ITEM
-    * set :itemTypeToIcon:itemType .ITEM
   425 sensor *tmp156 .ITEM @id
   426 jump *label109 notEqual *tmp156 14
   427 label *label110
 
   505 label *label139
   506 set *tmp155 null
   507 label *label108
-    * set *tmp154 *tmp155
   508 label *label107
   509 set .ITEM_ICON *tmp155
   510 set .STATE_LIMIT 1
 
   571 label *label151
   572 set *tmp201 false
   573 label *label152
-    * set :trigger *tmp201
   574 jump *label157 equal :wait_time 0
   575 label *label158
   576 jump *label155 lessThanEq *tmp201 :remote_wait_time
 
   656 op mul *tmp248 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
   657 op idiv .DROP_LEVEL *tmp248 100
   658 set .LOCAL_MARGIN .DROP_LEVEL
-    * op sub *tmp250 1 0.9
   659 op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity 0.09999999999999998
   660 set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
   661 sensor .DST_X .CONTAINER @x
 
   663 op sub *tmp254 .DST_X .SRC_X
   664 op sub *tmp255 .DST_Y .SRC_Y
   665 op len *tmp256 *tmp254 *tmp255
-    * op sub *tmp257 *tmp256 6
   666 op sub .DISTANCE *tmp256 14
   667 op max *tmp259 .DISTANCE 10
   668 op mul *tmp260 2 *tmp259
 
   673 set *tmp234 :findAnotherContainer:min_level
   674 jump *label167 always
   675 label *label167
-    * set :this_level :findAnotherContainer:min_level
-    * set :last_level *tmp234
+  676 set :last_level :findAnotherContainer:min_level
   677 label *label165
   678 label *label166
   679 label *label161
 
   884 set :state 3
   885 jump *label231 always
   886 label *label230
-    * set :printUnitInfo:name "source"
-    * set :printUnitInfo:x .SRC_X
-    * set :printUnitInfo:y .SRC_Y
   887 sensor *tmp330 @unit @x
   888 op sub *tmp331 .SRC_X *tmp330
   889 sensor *tmp332 @unit @y
 
   936 set :state 5
   937 jump *label242 always
   938 label *label241
-    * set :printUnitInfo.1:name "destination"
-    * set :printUnitInfo.1:x .DST_X
-    * set :printUnitInfo.1:y .DST_Y
   939 sensor *tmp353 @unit @x
   940 op sub *tmp354 .DST_X *tmp353
   941 sensor *tmp355 @unit @y
 
   967 jump *label248 greaterThan *tmp366 0
   968 set :state 2
   969 ucontrol approach .SRC_X .SRC_Y 6
-    * set :printUnitInfo.2:name "source"
-    * set :printUnitInfo.2:x .SRC_X
-    * set :printUnitInfo.2:y .SRC_Y
   970 sensor *tmp370 @unit @x
   971 op sub *tmp371 .SRC_X *tmp370
   972 sensor *tmp372 @unit @y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
    32 set .ITEM_ICON null
    33 set .ITEM null
    34 set .CORE_Y null
-    * set .CORE_X .STATE_LIMIT
-    * set .CONTAINER_INDEX .ITEM_ICON
+   35 set .CORE_X null
+   36 set .CONTAINER_INDEX null
    37 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    38 ubind UNIT
    39 label *label14
 
   327 set :transfers 0
   328 set :transferred 0
   329 set :total_flow_2 0
-    * set :total_flow_1 :wait_time
-    * set :remote_wait_time :transfers
-    * set :min_level :transferred
-    * set :max_level :total_flow_2
-    * set :loop_time_ms :total_flow_1
-    * set :last_level :remote_wait_time
+  330 set :total_flow_1 0
+  331 set :remote_wait_time 0
+  332 set :min_level 0
+  333 set :max_level 0
+  334 set :loop_time_ms :wait_time
+  335 set :last_level :transfers
   336 jump *label82 equal AUTO_ALLOCATION false
   337 set .CORR_SIGN "[]([green]+"
   338 set :corr_per_min 0
 
   670 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   671 op add .MESSAGE_TIMEOUT @tick 600
   672 label *label177
-    * set *tmp234 :findAnotherContainer:min_level
   673 jump *label167 always
   674 label *label167
   675 set :last_level :findAnotherContainer:min_level

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4:
 
   331 set :remote_wait_time 0
   332 set :min_level 0
   333 set :max_level 0
-    * set :loop_time_ms :wait_time
-    * set :last_level :transfers
+  334 set :loop_time_ms 0
+  335 set :last_level 0
   336 jump *label82 equal AUTO_ALLOCATION false
   337 set .CORR_SIGN "[]([green]+"
   338 set :corr_per_min 0

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
   132 print "."
   133 print ".."
   134 printflush message1
+  135 op add .QUERY_FLAG 99999900 LINK_ID
   136 label *label41
   137 jump *label43 notEqual .CORE null
-    * op add .QUERY_FLAG 99999900 LINK_ID
   138 set :flag .QUERY_FLAG
   139 ubind UNIT
   140 label *label44

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1 (-2 instructions):
 
    38 ubind UNIT
    39 label *label14
    40 jump *label16 notEqual @unit null
+   41 label *label261
    42 print "[salmon]No unit of type "
    43 print UNIT
    44 print " "
 
    46 printflush message1
    47 ubind UNIT
    48 label *label15
-    * jump *label14 always
+   49 jump *label261 equal @unit null
    50 label *label16
    51 set :first_unit @unit
    52 sensor *tmp8 @unit @speed
 
    67 ubind UNIT
    68 label *label18
    69 jump *label19 equal @unit :first_unit
-    * label *label22
    70 sensor *tmp20 :first_unit @dead
    71 jump *label17 equal *tmp20 0
    72 label *label19
 
    82 set :n @links
    83 label *label26
    84 jump *label28 lessThanEq :n 0
+   85 label *label262
    86 op sub :n :n 1
    87 getlink :block :n
    88 sensor *tmp28 :block @type
 
    95 label *label30
    96 label *label29
    97 label *label27
-    * jump *label26 always
+   98 jump *label262 greaterThan :n 0
    99 label *label28
   100 jump *label32 notEqual .CONTAINER null
   101 print "[salmon]No vault or container."
 
   110 set .CORE null
   111 jump *label34 notEqual LINK_ID 0
   112 label *label36
-    * jump *label38 notEqual .CORE null
+  113 label *label263
   114 print "[green]Locating core..."
   115 printflush message1
   116 ubind UNIT
 
   121 label *label39
   122 label *label40
   123 label *label37
-    * jump *label36 always
+  124 jump *label263 equal .CORE null
   125 label *label38
   126 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   127 op equal .DROP_TO_CORE DROP_TO_AIR false
 
   135 printflush message1
   136 op add .QUERY_FLAG 99999900 LINK_ID
   137 label *label41
-    * jump *label43 notEqual .CORE null
+  138 label *label264
   139 set :flag .QUERY_FLAG
   140 ubind UNIT
   141 label *label44
 
   148 ucontrol flag .QUERY_FLAG
   149 label *label47
   150 jump *label49 notEqual :flag .QUERY_FLAG
-    * label *label51
+  151 label *label265
   152 sensor *tmp46 @unit @dead
   153 jump *label49 notEqual *tmp46 0
-    * label *label50
   154 ucontrol stop
   155 sensor :flag @unit @flag
   156 label *label48
-    * jump *label47 always
+  157 jump *label265 equal :flag .QUERY_FLAG
   158 label *label49
   159 jump *label52 equal :flag .QUERY_FLAG
   160 op idiv :position :flag 100
 
   163 label *label54
   164 sensor *tmp54 @unit @dead
   165 jump *label56 notEqual *tmp54 0
-    * label *label58
   166 ucontrol within .CORE_X .CORE_Y 8 *tmp56
   167 jump *label56 notEqual *tmp56 false
-    * label *label57
   168 ucontrol approach .CORE_X .CORE_Y 6
   169 label *label55
   170 jump *label54 always
 
   186 label *label53
   187 ucontrol flag .S_UNUSED
   188 label *label42
-    * jump *label41 always
+  189 jump *label264 equal .CORE null
   190 label *label43
   191 jump *label61 equal DROP_TO_AIR false
   192 set *tmp62 .UNIT_CAPACITY
 
   201 sensor :sorter_type sorter1 @type
   202 label *label63
   203 jump *label65 equal :sorter_type @sorter
-    * label *label67
+  204 label *label266
   205 jump *label65 equal :sorter_type @inverted-sorter
-    * label *label66
   206 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   207 print "\n"
   208 jump *label68 equal .SORTER null
 
   214 set .SORTER sorter1
   215 sensor :sorter_type sorter1 @type
   216 label *label64
-    * jump *label63 always
+  217 jump *label266 notEqual :sorter_type @sorter
   218 label *label65
   219 jump *label70 notEqual :sorter_type @sorter
   220 set .SHOW_REMOTE_LEVEL true
 
   346 ubind UNIT
   347 label *label87
   348 jump *label89 notEqual @unit null
+  349 label *label267
   350 print "No unit of type "
   351 print UNIT
   352 print " "
 
   354 printflush message1
   355 ubind UNIT
   356 label *label88
-    * jump *label87 always
+  357 jump *label267 equal @unit null
   358 label *label89
   359 sensor *tmp128 switch1 @enabled
   360 jump *label90 equal *tmp128 false
 
   413 jump *label102 equal .ITEM .LAST_ITEM
   414 label *label104
   415 jump *label106 notEqual .ITEM null
+  416 label *label268
   417 print "[salmon]No item type selected for transport.[]"
   418 printflush message1
   419 sensor .ITEM .SORTER @config
   420 label *label105
-    * jump *label104 always
+  421 jump *label268 equal .ITEM null
   422 label *label106
   423 set .LAST_ITEM .ITEM
   424 sensor *tmp156 .ITEM @id
 
   627 set :findAnotherContainer:n @links
   628 label *label168
   629 jump *label170 lessThanEq :findAnotherContainer:n 0
+  630 label *label269
   631 op sub :findAnotherContainer:n :findAnotherContainer:n 1
   632 getlink :findAnotherContainer:block :findAnotherContainer:n
   633 sensor *tmp240 :findAnotherContainer:block @type
 
   645 label *label172
   646 label *label171
   647 label *label169
-    * jump *label168 always
+  648 jump *label269 greaterThan :findAnotherContainer:n 0
   649 label *label170
   650 jump *label176 notEqual .CONTAINERS 0
   651 set .CONTAINER @this

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
   520 op mul *tmp164 :loop_time 100
   521 op idiv :loop_time_ms *tmp164 6
   522 jump *label143 greaterThanEq :transfers :active
-    * label *label144
   523 jump *label141 lessThanEq :wait_time .WAIT_LIMIT
   524 label *label143
   525 op div *tmp169 :wait_time 100
 
   560 set .CORR_SIGN *tmp197
   561 set .SPEED_UNIT_TXT "[])/min"
   562 jump *label149 equal :alive false
-    * jump *label153 lessThan :min_level .LOW_LEVEL_TRIGGER
-    * label *label154
-    * jump *label151 lessThanEq :max_level .HIGH_LEVEL_TRIGGER
+  563 jump *label151 greaterThanEq :min_level .LOW_LEVEL_TRIGGER
   564 label *label153
   565 set *tmp201 true
   566 jump *label152 always
   567 label *label151
-    * set *tmp201 false
+  568 op greaterThan *tmp201 :max_level .HIGH_LEVEL_TRIGGER
   569 label *label152
   570 jump *label157 equal :wait_time 0
-    * label *label158
   571 jump *label155 lessThanEq *tmp201 :remote_wait_time
   572 label *label157
   573 jump *label159 equal STABILIZATION false
 
   612 label *label145
   613 label *label146
   614 jump *label161 lessThanEq .CONTAINERS 1
-    * label *label164
   615 jump *label161 notEqual .SRC .CORE
-    * label *label163
   616 sensor *tmp230 .DST .ITEM
   617 op sub :max_drop .DROP_LEVEL *tmp230
   618 jump *label165 greaterThanEq :max_drop .DROP_PACK

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-9 instructions):
 
   188 label *label42
   189 jump *label264 equal .CORE null
   190 label *label43
-    * jump *label61 equal DROP_TO_AIR false
-    * set *tmp62 .UNIT_CAPACITY
+  191 set .DISCARD_UNIT_MAX_ITEMS 0
+  192 jump *label62 equal DROP_TO_AIR false
+  193 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   194 jump *label62 always
-    * label *label61
-    * set *tmp62 0
   195 label *label62
-    * set .DISCARD_UNIT_MAX_ITEMS *tmp62
   196 set .DROP_TO_CORE false
   197 label *label35
   198 set .SORTER sorter1
 
   232 set .FLOW_CORR_SIGN 1
   233 set .SRC_REMOTE_WAIT 1
   234 set .DST_REMOTE_WAIT 0
-    * jump *label72 notEqual LINK_ID 0
-    * set *tmp81 " from core"
+  235 set .DIRECTION " from vault #"
+  236 jump *label73 notEqual LINK_ID 0
+  237 set .DIRECTION " from core"
   238 jump *label73 always
-    * label *label72
-    * set *tmp81 " from vault #"
   239 label *label73
-    * set .DIRECTION *tmp81
   240 jump *label71 always
   241 label *label70
   242 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   259 set .FLOW_CORR_SIGN -1
   260 set .SRC_REMOTE_WAIT 0
   261 set .DST_REMOTE_WAIT 1
-    * jump *label74 notEqual LINK_ID 0
-    * set *tmp95 " to core"
+  262 set .DIRECTION " to vault #"
+  263 jump *label75 notEqual LINK_ID 0
+  264 set .DIRECTION " to core"
   265 jump *label75 always
-    * label *label74
-    * set *tmp95 " to vault #"
   266 label *label75
-    * set .DIRECTION *tmp95
   267 label *label71
-    * jump *label76 notEqual LINK_ID 0
+  268 set *tmp97 LINK_ID
+  269 jump *label77 notEqual LINK_ID 0
   270 set *tmp97 ""
   271 jump *label77 always
-    * label *label76
-    * set *tmp97 LINK_ID
   272 label *label77
   273 op sub *tmp98 :src_capacity .LOAD_LEVEL
   274 op min .LOAD_PACK .UNIT_CAPACITY *tmp98
 
   286 op div .TRAVEL_TIME *tmp111 .SPEED
   287 sensor *tmp113 .CONTAINER @x
   288 jump *label78 greaterThanEq *tmp113 .CORE_X
-    * set *tmp115 15
+  289 op add .PARK_X .CORE_X 15
   290 jump *label79 always
   291 label *label78
-    * set *tmp115 -15
+  292 op add .PARK_X .CORE_X -15
   293 label *label79
-    * op add .PARK_X .CORE_X *tmp115
   294 sensor *tmp117 .CONTAINER @y
   295 jump *label80 greaterThanEq *tmp117 .CORE_Y
-    * set *tmp119 15
+  296 op add .PARK_Y .CORE_Y 15
   297 jump *label81 always
   298 label *label80
-    * set *tmp119 -15
+  299 op add .PARK_Y .CORE_Y -15
   300 label *label81
-    * op add .PARK_Y .CORE_Y *tmp119
   301 op equal *tmp121 LINK_ID 0
   302 op mul .PARK_ITEM_LIMIT *tmp121 .UNIT_CAPACITY
   303 set .TRANSFER_START @tick
 
   379 set .CORR_SIGN "[]"
   380 set :corr_per_min ""
   381 set .SPEED_UNIT_TXT "/min"
-    * jump *label96 notEqual .TARGET 0
-    * set *tmp141 "\n=== [salmon]Transport deactivated[] ==="
+  382 set .AUTO_ALLOCATION_TXT ""
+  383 jump *label97 notEqual .TARGET 0
+  384 set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivated[] ==="
   385 jump *label97 always
-    * label *label96
-    * set *tmp141 ""
   386 label *label97
-    * set .AUTO_ALLOCATION_TXT *tmp141
   387 label *label95
   388 set .WAIT_LIMIT 30000
   389 label *label92
 
   540 set :last_level :this_level
   541 op add :total_flow_per_ms :items_per_ms :corr_per_ms
   542 op idiv :corr_per_min :corr_per_ms 0.000016666666666666667
-    * jump *label147 lessThan :corr_per_min 0
-    * set *tmp197 "[]([green]+"
+  543 set .CORR_SIGN "[]([green]"
+  544 jump *label148 lessThan :corr_per_min 0
+  545 set .CORR_SIGN "[]([green]+"
   546 jump *label148 always
-    * label *label147
-    * set *tmp197 "[]([green]"
   547 label *label148
-    * set .CORR_SIGN *tmp197
   548 set .SPEED_UNIT_TXT "[])/min"
   549 jump *label149 equal :alive false
   550 jump *label151 greaterThanEq :min_level .LOW_LEVEL_TRIGGER
 
   827 label *label212
   828 label *label213
   829 jump *label218 notEqual :state 1
+  830 set :state 2
   831 sensor *tmp316 @unit @totalItems
-    * jump *label220 notEqual *tmp316 0
-    * set :state 2
-    * jump *label221 always
+  832 jump *label221 equal *tmp316 0
   833 label *label220
+  834 set :state 4
   835 sensor *tmp319 @unit @firstItem
-    * jump *label222 notEqual *tmp319 .ITEM
-    * set :state 4
-    * jump *label223 always
+  836 jump *label223 equal *tmp319 .ITEM
   837 label *label222
   838 jump *label224 equal .DROP_TO_CORE false
   839 ucontrol approach .CORE_X .CORE_Y 6

Modifications by Partial loop rotation at line 156:9 (+1 instructions):
 
   141 label *label44
   142 sensor *tmp43 @unit @controlled
   143 jump *label46 equal *tmp43 0
+  144 label *label271
   145 ubind UNIT
   146 label *label45
-    * jump *label44 always
+  147 sensor *tmp43 @unit @controlled
+  148 jump *label271 notEqual *tmp43 0
   149 label *label46
   150 ucontrol flag .QUERY_FLAG
   151 label *label47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   149 label *label46
   150 ucontrol flag .QUERY_FLAG
   151 label *label47
-    * jump *label49 notEqual :flag .QUERY_FLAG
+  152 jump *label49 notEqual .QUERY_FLAG .QUERY_FLAG
   153 label *label265
   154 sensor *tmp46 @unit @dead
   155 jump *label49 notEqual *tmp46 0

Modifications by Partial loop rotation at line 169:13 (+1 instructions):
 
   165 label *label54
   166 sensor *tmp54 @unit @dead
   167 jump *label56 notEqual *tmp54 0
+  168 label *label272
   169 ucontrol within .CORE_X .CORE_Y 8 *tmp56
   170 jump *label56 notEqual *tmp56 false
   171 ucontrol approach .CORE_X .CORE_Y 6
   172 label *label55
-    * jump *label54 always
+  173 sensor *tmp54 @unit @dead
+  174 jump *label272 equal *tmp54 0
   175 label *label56
   176 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp59
   177 jump *label59 equal :b_type @vault

Modifications by Convert case at line 704:5 (segments: 4) (+2 instructions):
 
   415 label *label106
   416 set .LAST_ITEM .ITEM
   417 sensor *tmp156 .ITEM @id
-    * jump *label109 notEqual *tmp156 14
+  418 jump *label274 greaterThanEq *tmp156 3
+  419 jump *label275 greaterThanEq *tmp156 1
+  420 jump *label273 lessThan *tmp156 0
+  421 label *label114
+  422 set *tmp155 "[]"
+  423 jump *label108 always
+  424 label *label275
+  425 jump *label120 greaterThanEq *tmp156 2
+  426 label *label118
+  427 set *tmp155 "[]"
+  428 jump *label108 always
+  429 label *label274
+  430 jump *label273 greaterThanEq *tmp156 16
+  431 multijump *label277 *tmp156 3 (m:*label276)
+  432 multilabel *label277 (m:*label276)
+  433 jump *label116 always
+  434 multilabel *label278 (m:*label276)
+  435 jump *label128 always
+  436 multilabel *label279 (m:*label276)
+  437 jump *label112 always
+  438 multilabel *label280 (m:*label276)
+  439 jump *label140 always
+  440 multilabel *label281 (m:*label276)
+  441 jump *label138 always
+  442 multilabel *label282 (m:*label276)
+  443 jump *label130 always
+  444 multilabel *label283 (m:*label276)
+  445 jump *label132 always
+  446 multilabel *label284 (m:*label276)
+  447 jump *label124 always
+  448 multilabel *label285 (m:*label276)
+  449 jump *label122 always
+  450 multilabel *label286 (m:*label276)
+  451 jump *label136 always
+  452 multilabel *label287 (m:*label276)
+  453 jump *label134 always
+  454 multilabel *label288 (m:*label276)
+  455 jump *label110 always
+  456 multilabel *label289 (m:*label276)
+  457 label *label126
+  458 set *tmp155 "[]"
+  459 jump *label108 always
   460 label *label110
   461 set *tmp155 "[]"
   462 jump *label108 always
   463 label *label109
-    * jump *label111 notEqual *tmp156 5
   464 label *label112
   465 set *tmp155 "[]"
   466 jump *label108 always
   467 label *label111
-    * jump *label113 notEqual *tmp156 0
-    * label *label114
-    * set *tmp155 "[]"
-    * jump *label108 always
   468 label *label113
-    * jump *label115 notEqual *tmp156 3
   469 label *label116
   470 set *tmp155 "[]"
   471 jump *label108 always
   472 label *label115
-    * jump *label117 notEqual *tmp156 1
-    * label *label118
-    * set *tmp155 "[]"
-    * jump *label108 always
   473 label *label117
-    * jump *label119 notEqual *tmp156 2
   474 label *label120
   475 set *tmp155 "[]"
   476 jump *label108 always
   477 label *label119
-    * jump *label121 notEqual *tmp156 11
   478 label *label122
   479 set *tmp155 "[]"
   480 jump *label108 always
   481 label *label121
-    * jump *label123 notEqual *tmp156 10
   482 label *label124
   483 set *tmp155 "[]"
   484 jump *label108 always
   485 label *label123
-    * jump *label125 notEqual *tmp156 15
-    * label *label126
-    * set *tmp155 "[]"
-    * jump *label108 always
   486 label *label125
-    * jump *label127 notEqual *tmp156 4
   487 label *label128
   488 set *tmp155 "[]"
   489 jump *label108 always
   490 label *label127
-    * jump *label129 notEqual *tmp156 8
   491 label *label130
   492 set *tmp155 "[]"
   493 jump *label108 always
   494 label *label129
-    * jump *label131 notEqual *tmp156 9
   495 label *label132
   496 set *tmp155 "[]"
   497 jump *label108 always
   498 label *label131
-    * jump *label133 notEqual *tmp156 13
   499 label *label134
   500 set *tmp155 "[]"
   501 jump *label108 always
   502 label *label133
-    * jump *label135 notEqual *tmp156 12
   503 label *label136
   504 set *tmp155 "[]"
   505 jump *label108 always
   506 label *label135
-    * jump *label137 notEqual *tmp156 7
   507 label *label138
   508 set *tmp155 "[]"
   509 jump *label108 always
   510 label *label137
-    * jump *label139 notEqual *tmp156 6
   511 label *label140
   512 set *tmp155 "[]"
   513 jump *label108 always
   514 label *label139
+  515 label *label273
   516 set *tmp155 null
   517 label *label108
   518 label *label107

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   149 label *label46
   150 ucontrol flag .QUERY_FLAG
   151 label *label47
-    * jump *label49 notEqual .QUERY_FLAG .QUERY_FLAG
   152 label *label265
   153 sensor *tmp46 @unit @dead
   154 jump *label49 notEqual *tmp46 0

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1:
 
   567 jump *label148 always
   568 label *label148
   569 set .SPEED_UNIT_TXT "[])/min"
-    * jump *label149 equal :alive false
+  570 jump *label149 notEqual *tmp142 0
   571 jump *label151 greaterThanEq :min_level .LOW_LEVEL_TRIGGER
   572 set *tmp201 true
   573 jump *label152 always

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-7 instructions):
 
   194 set .DISCARD_UNIT_MAX_ITEMS 0
   195 jump *label62 equal DROP_TO_AIR false
   196 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
-    * jump *label62 always
   197 label *label62
   198 set .DROP_TO_CORE false
   199 label *label35
 
   237 set .DIRECTION " from vault #"
   238 jump *label73 notEqual LINK_ID 0
   239 set .DIRECTION " from core"
-    * jump *label73 always
   240 label *label73
   241 jump *label71 always
   242 label *label70
 
   263 set .DIRECTION " to vault #"
   264 jump *label75 notEqual LINK_ID 0
   265 set .DIRECTION " to core"
-    * jump *label75 always
   266 label *label75
   267 label *label71
   268 set *tmp97 LINK_ID
   269 jump *label77 notEqual LINK_ID 0
   270 set *tmp97 ""
-    * jump *label77 always
   271 label *label77
   272 op sub *tmp98 :src_capacity .LOAD_LEVEL
   273 op min .LOAD_PACK .UNIT_CAPACITY *tmp98
 
   381 set .AUTO_ALLOCATION_TXT ""
   382 jump *label97 notEqual .TARGET 0
   383 set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivated[] ==="
-    * jump *label97 always
   384 label *label97
   385 label *label95
   386 set .WAIT_LIMIT 30000
 
   559 set .CORR_SIGN "[]([green]"
   560 jump *label148 lessThan :corr_per_min 0
   561 set .CORR_SIGN "[]([green]+"
-    * jump *label148 always
   562 label *label148
   563 set .SPEED_UNIT_TXT "[])/min"
   564 jump *label149 notEqual *tmp142 0
 
   665 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   666 op add .MESSAGE_TIMEOUT @tick 600
   667 label *label177
-    * jump *label167 always
   668 label *label167
   669 set :last_level :findAnotherContainer:min_level
   670 label *label165

Modifications by Iterated phase, If Expression Optimization, pass 2, iteration 1:
 
   283 op max *tmp110 .DISTANCE 10
   284 op mul *tmp111 2 *tmp110
   285 op div .TRAVEL_TIME *tmp111 .SPEED
+  286 op add .PARK_X .CORE_X -15
   287 sensor *tmp113 .CONTAINER @x
-    * jump *label78 greaterThanEq *tmp113 .CORE_X
+  288 jump *label79 greaterThanEq *tmp113 .CORE_X
   289 op add .PARK_X .CORE_X 15
   290 jump *label79 always
-    * label *label78
-    * op add .PARK_X .CORE_X -15
   291 label *label79
+  292 op add .PARK_Y .CORE_Y -15
   293 sensor *tmp117 .CONTAINER @y
-    * jump *label80 greaterThanEq *tmp117 .CORE_Y
+  294 jump *label81 greaterThanEq *tmp117 .CORE_Y
   295 op add .PARK_Y .CORE_Y 15
   296 jump *label81 always
-    * label *label80
-    * op add .PARK_Y .CORE_Y -15
   297 label *label81
   298 op equal *tmp121 LINK_ID 0
   299 op mul .PARK_ITEM_LIMIT *tmp121 .UNIT_CAPACITY

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-2 instructions):
 
   287 sensor *tmp113 .CONTAINER @x
   288 jump *label79 greaterThanEq *tmp113 .CORE_X
   289 op add .PARK_X .CORE_X 15
-    * jump *label79 always
   290 label *label79
   291 op add .PARK_Y .CORE_Y -15
   292 sensor *tmp117 .CONTAINER @y
   293 jump *label81 greaterThanEq *tmp117 .CORE_Y
   294 op add .PARK_Y .CORE_Y 15
-    * jump *label81 always
   295 label *label81
   296 op equal *tmp121 LINK_ID 0
   297 op mul .PARK_ITEM_LIMIT *tmp121 .UNIT_CAPACITY

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-4 instructions):
 
   716 set :items_in_transit 0
   717 print "Unit status:"
   718 sensor *tmp282 .SRC @dead
-    * jump *label196 equal *tmp282 0
-    * jump *label86 always
+  719 jump *label86 notEqual *tmp282 0
   720 label *label196
   721 sensor *tmp285 .DST @dead
-    * jump *label198 equal *tmp285 0
-    * jump *label86 always
+  722 jump *label86 notEqual *tmp285 0
   723 label *label198
   724 sensor *tmp288 .SORTER @dead
-    * jump *label200 equal *tmp288 0
-    * jump *label86 always
+  725 jump *label86 notEqual *tmp288 0
   726 label *label200
   727 getlink *tmp291 .CONTAINER_INDEX
-    * jump *label202 equal .CONTAINER *tmp291
-    * jump *label86 always
+  728 jump *label86 notEqual .CONTAINER *tmp291
   729 label *label202
   730 label *label98
   731 jump *label204 lessThanEq .CHANGE 0

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
 
    89 label *label30
    90 jump *label262 greaterThan :n 0
    91 label *label28
-    * jump *label32 notEqual .CONTAINER null
+   92 jump *label25 notEqual .CONTAINER null
    93 print "[salmon]No vault or container."
    94 printflush message1
-    * jump *label33 always
+   95 jump *label23 always
    96 label *label32
    97 jump *label25 always
    98 label *label33
 
   208 set .SRC_REMOTE_WAIT 1
   209 set .DST_REMOTE_WAIT 0
   210 set .DIRECTION " from vault #"
-    * jump *label73 notEqual LINK_ID 0
+  211 jump *label71 notEqual LINK_ID 0
   212 set .DIRECTION " from core"
   213 label *label73
   214 jump *label71 always
 
   732 label *label206
   733 label *label204
   734 sensor *tmp299 @unit @controller
-    * jump *label208 notEqual *tmp299 @this
+  735 jump *label84 notEqual *tmp299 @this
   736 sensor :state @unit @flag
-    * jump *label210 equal :state .S_UNUSED
+  737 jump *label84 equal :state .S_UNUSED
   738 op max *tmp305 :state 1
   739 op min :state *tmp305 .STATE_LIMIT
   740 jump *label212 greaterThanEq .CHANGE 0
 
   890 jump *label255 equal .DROP_TO_CORE false
   891 ucontrol approach .CORE_X .CORE_Y 6
   892 ucontrol within .CORE_X .CORE_Y 8 *tmp384
-    * jump *label257 equal *tmp384 false
+  893 jump *label256 equal *tmp384 false
   894 ucontrol itemDrop .CORE .UNIT_CAPACITY
   895 sensor :items @unit @totalItems
   896 label *label257
 
   900 sensor :items @unit @totalItems
   901 label *label256
   902 label *label253
-    * jump *label259 greaterThan :items .PARK_ITEM_LIMIT
+  903 jump *label252 greaterThan :items .PARK_ITEM_LIMIT
   904 ucontrol move .PARK_X .PARK_Y
   905 set :state .S_UNUSED
   906 label *label259

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-1 instructions):
 
   910 label *label86
   911 control enabled switch1 false
   912 control enabled switch2 false
-    * end

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-2 instructions):
 
    93 print "[salmon]No vault or container."
    94 printflush message1
    95 jump *label23 always
-    * jump *label25 always
-    * jump *label23 always
    96 label *label25
    97 set .CORE null
    98 jump *label34 notEqual LINK_ID 0

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
   102 ubind UNIT
   103 sensor *tmp35 @unit @controlled
   104 jump *label39 notEqual *tmp35 0
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp39 .CORE
+  105 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   106 ucontrol flag .S_UNUSED
   107 label *label39
   108 jump *label263 equal .CORE null
 
   148 sensor *tmp54 @unit @dead
   149 jump *label272 equal *tmp54 0
   150 label *label56
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp59
+  151 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   152 jump *label59 equal :b_type @vault
   153 print "[salmon]Building at "
   154 print .CORE_X

Modifications by Final phase, Print Merging, iteration 1 (-56 instructions):
 
    39 label *label261
    40 print "[salmon]No unit of type "
    41 print UNIT
-    * print " "
-    * print "found."
+   42 print " found."
    43 printflush message1
    44 ubind UNIT
    45 jump *label261 equal @unit null
 
   112 printflush message2
   113 print "[green]Locating vault #"
   114 print LINK_ID
-    * print "."
-    * print ".."
+  115 print "..."
   116 printflush message1
   117 op add .QUERY_FLAG 99999900 LINK_ID
   118 label *label264
 
   150 jump *label59 equal :b_type @vault
   151 print "[salmon]Building at "
   152 print .CORE_X
-    * print ","
-    * print " "
+  153 print ", "
   154 print .CORE_Y
-    * print " "
-    * print "is not a vault!"
+  155 print " is not a vault!"
   156 printflush message2
   157 set .CORE null
   158 label *label59
 
   170 jump *label65 equal :sorter_type @sorter
   171 label *label266
   172 jump *label65 equal :sorter_type @inverted-sorter
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  173 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   174 jump *label68 equal .SORTER null
   175 print "Block found: "
   176 print .SORTER
 
   297 label *label267
   298 print "No unit of type "
   299 print UNIT
-    * print " "
-    * print "found."
+  300 print " found."
   301 printflush message1
   302 ubind UNIT
   303 jump *label267 equal @unit null
 
   601 print .MESSAGE
   602 print "Moving [green]"
   603 print .ITEM
-    * print "["
-    * print "]"
+  604 print "[]"
   605 print .DIRECTION
   606 print *tmp97
   607 print .AUTO_ALLOCATION_TXT
   608 jump *label180 lessThanEq .TARGET 0
   609 jump *label182 lessThan :active .TARGET
-    * print "\n"
-    * print "Using [green]"
+  610 print "\nUsing [green]"
   611 print :active
   612 print "/"
   613 print .TARGET
-    * print "["
-    * print "] units ("
+  614 print "[] units ("
   615 print UNIT
-    * print ")"
-    * print " [gold]+"
+  616 print ") [gold]+"
   617 print :items_in_transit
   618 jump *label183 always
   619 label *label182
-    * print "\n"
-    * print "Using [salmon]"
+  620 print "\nUsing [salmon]"
   621 print :active
   622 print "/"
   623 print .TARGET
-    * print "["
-    * print "] units ("
+  624 print "[] units ("
   625 print UNIT
-    * print ")"
-    * print " [gold]+"
+  626 print ") [gold]+"
   627 print :items_in_transit
   628 label *label183
   629 jump *label184 lessThanEq .CHANGE 0
   630 print "\n[][salmon]Cannot acquire additional units![]"
   631 label *label184
   632 label *label180
-    * print "\n"
-    * print "[]Local items: [gold]"
+  633 print "\n[]Local items: [gold]"
   634 print :container_items
   635 jump *label186 greaterThanEq .EFF_LOCAL_LIMIT 100
   636 print "[] (limit [orange]"
   637 print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  638 print "[])"
   639 label *label186
   640 jump *label188 equal .SHOW_REMOTE_LEVEL false
   641 sensor :remote_level .CORE .ITEM
-    * print "\n"
-    * print "[]Remote items: [gold]"
+  642 print "\n[]Remote items: [gold]"
   643 print :remote_level
   644 jump *label190 greaterThanEq .EFF_REMOTE_LIMIT 100
   645 print "[] (limit [orange]"
   646 print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  647 print "[])"
   648 label *label190
   649 label *label188
   650 jump *label192 lessThanEq .TARGET 0
-    * print "\n"
-    * print "[]Speed: [green]"
+  651 print "\n[]Speed: [green]"
   652 print :items_per_min
   653 print .CORR_SIGN
   654 print :corr_per_min
   655 print .SPEED_UNIT_TXT
   656 jump *label194 equal .EFF_AUTO_ALLOCATION false
-    * print "\n"
-    * print "Unit throughput: [green]"
+  657 print "\nUnit throughput: [green]"
   658 print :items_per_min_unit
-    * print "["
-    * print "]/min"
-    * print "\n"
-    * print "Min/last round: [green]"
+  659 print "[]/min\nMin/last round: [green]"
   660 print :turnaround_str
-    * print "["
-    * print "]/[green]"
+  661 print "[]/[green]"
   662 print :elapsed_str
-    * print "["
-    * print "] s"
+  663 print "[] s"
   664 jump *label195 always
   665 label *label194
-    * print "\n"
-    * print "Last round: [green]"
+  666 print "\nLast round: [green]"
   667 print :elapsed_str
-    * print "["
-    * print "] s"
+  668 print "[] s"
   669 label *label195
-    * print "\n"
-    * print "Total wait time: [green]"
+  670 print "\nTotal wait time: [green]"
   671 print :wait_time_str
-    * print "["
-    * print "] s"
+  672 print "[] s"
   673 label *label192
-    * print "\n"
-    * print "[lightgray]Loop: "
+  674 print "\n[lightgray]Loop: "
   675 print :loop_time_ms
-    * print " "
-    * print "ms"
+  676 print " ms"
   677 printflush message1
   678 op sub .CHANGE .TARGET :active
   679 set :active 0
 
   724 jump *label226 equal *tmp323 false
   725 ucontrol itemDrop .CORE .UNIT_CAPACITY
   726 label *label226
-    * print "[]"
-    * print "\n"
-    * print "Unloading previous items: [green]"
+  727 print "[]\nUnloading previous items: [green]"
   728 jump *label225 always
   729 label *label224
   730 ucontrol itemDrop @air .UNIT_CAPACITY
 
   747 op len *tmp334 *tmp331 *tmp333
   748 op idiv *tmp335 *tmp334 .SPEED_SEC
   749 op div *tmp336 *tmp335 10
-    * print "[]"
-    * print "\n"
-    * print "[gold]"
+  750 print "[]\n[gold]"
   751 print *tmp336
-    * print " "
-    * print "sec[] to "
-    * print "source"
-    * print ":"
-    * print " [green]"
+  752 print " sec[] to source: [green]"
   753 label *label231
   754 label *label228
   755 jump *label233 notEqual :state 3
 
   763 set :state 4
   764 jump *label238 always
   765 label *label237
-    * print "[]"
-    * print "\n"
-    * print "Waiting at source: [green]"
+  766 print "[]\nWaiting at source: [green]"
   767 ucontrol approach .SRC_X .SRC_Y 6
   768 op add :wait_time :wait_time :loop_time_ms
   769 op mul *tmp346 :loop_time_ms .SRC_REMOTE_WAIT
 
   787 op len *tmp357 *tmp354 *tmp356
   788 op idiv *tmp358 *tmp357 .SPEED_SEC
   789 op div *tmp359 *tmp358 10
-    * print "[]"
-    * print "\n"
-    * print "[gold]"
+  790 print "[]\n[gold]"
   791 print *tmp359
-    * print " "
-    * print "sec[] to "
-    * print "destination"
-    * print ":"
-    * print " [green]"
+  792 print " sec[] to destination: [green]"
   793 label *label242
   794 label *label239
   795 jump *label244 notEqual :state 5
 
   809 op len *tmp374 *tmp371 *tmp373
   810 op idiv *tmp375 *tmp374 .SPEED_SEC
   811 op div *tmp376 *tmp375 10
-    * print "[]"
-    * print "\n"
-    * print "[gold]"
+  812 print "[]\n[gold]"
   813 print *tmp376
-    * print " "
-    * print "sec[] to "
-    * print "source"
-    * print ":"
-    * print " [green]"
+  814 print " sec[] to source: [green]"
   815 jump *label249 always
   816 label *label248
-    * print "[]"
-    * print "\n"
-    * print "Waiting at destination: [green]"
+  817 print "[]\nWaiting at destination: [green]"
   818 ucontrol approach .DST_X .DST_Y 6
   819 op add :wait_time :wait_time :loop_time_ms
   820 op mul *tmp377 :loop_time_ms .DST_REMOTE_WAIT
 
   824 sensor :items @unit @totalItems
   825 op add :items_in_transit :items_in_transit :items
   826 jump *label251 notEqual :state 6
-    * print "[]"
-    * print "\n"
-    * print "Parking: [green]"
+  827 print "[]\nParking: [green]"
   828 jump *label253 lessThanEq :items 0
   829 jump *label255 equal .DROP_TO_CORE false
   830 ucontrol approach .CORE_X .CORE_Y 6

Final code before resolving virtual instructions:

    0:  remark "Configurable options:"                               /// Configurable options:
    1:  remark "Which unit type to use:"                             param UNIT                    = @mega;  /// Which unit type to use:
    2:  set UNIT @mega                                               ...
    3:  remark "Remote vault ID (1-99); if nonzero, items are moved  param LINK_ID                 = 0;      /// Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core:
    4:  set LINK_ID 0                                                ...
    5:  remark "Start in auto allocation mode?"                      param AUTO_ALLOCATION         = true;   /// Start in auto allocation mode?
    6:  set AUTO_ALLOCATION true                                     ...
    7:  remark "Max units to use, in both manual and auto allocation param MAX_UNITS               = 24;     /// Max units to use, in both manual and auto allocation modes:
    8:  set MAX_UNITS 24                                             ...
    9:  remark "Leave discarded units with nonzero flag for housekee param HOUSEKEEPING            = true;   /// Leave discarded units with nonzero flag for housekeeping (flag-clearing) processor to pick them up:
   10:  set HOUSEKEEPING true                                        ...
   11:  remark "Drop superfluous items to air, even when there's a c param DROP_TO_AIR             = true;   /// Drop superfluous items to air, even when there's a core:
   12:  set DROP_TO_AIR true                                         ...
   13:  remark "How much of local container capacity to use, in perc param LOCAL_LIMIT             = 100;    /// How much of local container capacity to use, in percents (20-100):
   14:  set LOCAL_LIMIT 100                                          ...
   15:  remark "How much of remote container capacity to use, in per param REMOTE_LIMIT            = 100;    /// How much of remote container capacity to use, in percents (20-100)
   16:  set REMOTE_LIMIT 100                                         ...
   17:  remark "Allocate at least this much more units than needed:" param OVERALLOCATION_LOW      = 0.25;   /// Allocate at least this much more units than needed:
   18:  set OVERALLOCATION_LOW 0.25                                  ...
   19:  remark "Allocate at most this much more units than needed:"  param OVERALLOCATION_HIGH     = 0.75;   /// Allocate at most this much more units than needed:
   20:  set OVERALLOCATION_HIGH 0.75                                 ...
   21:  remark "Use average of last three flow rate values for bette param STABILIZATION           = false;  /// Use average of last three flow rate values for better unit auto allocation stability:
   22:  set STABILIZATION false                                      ...
   23:  remark "End of configurable options"                         /// End of configurable options
   24:  printflush null                                              *printing: printflush(null);
   25:  set .MESSAGE ""                                              MESSAGE = "";
   26:  op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20                       EFF_LOCAL_LIMIT = max(LOCAL_LIMIT, 20);
   27:  op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20                     EFF_REMOTE_LIMIT = max(REMOTE_LIMIT, 20);
   28:  set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION                     EFF_AUTO_ALLOCATION = AUTO_ALLOCATION;
   29:  op mul .S_UNUSED -1 HOUSEKEEPING                             S_UNUSED = -1 * HOUSEKEEPING;           // Unit is not used. Regarded as a free unit even if controlled by this processor.
   30:  set .STATE_LIMIT null                                        CONTAINER_INDEX = CORE_X = CORE_Y = ITEM = ITEM_ICON = STATE_LIMIT = null;
   31:  set .ITEM_ICON null                                          ...
   32:  set .ITEM null                                               ...
   33:  set .CORE_Y null                                             ...
   34:  set .CORE_X null                                             ...
   35:  set .CONTAINER_INDEX null                                    ...
   36:  op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH             DEC_OVERALLOCATION      = 1 + OVERALLOCATION_HIGH;  // Deallocate on this much overcapacity (convert to multiplicational factor)
   37:  ubind UNIT                                                   ubind(UNIT);
   38:  jump *label16 notEqual @unit null                            while @unit == null do
        label *label261                                              ...
   39:  print "[salmon]No unit of type "                             print($"[salmon]No unit of type $UNIT found.");
   40:  print UNIT                                                   ...
   41:  print " found."                                              ...
   42:  printflush message1                                          printflush(message1);
   43:  ubind UNIT                                                   ubind(UNIT);
   44:  jump *label261 equal @unit null                              while @unit == null do
        label *label16                                               ...
   45:  set :first_unit @unit                                        first_unit = @unit;
   46:  sensor *tmp8 @unit @speed                                    SPEED_SEC = @unit.@speed / 10;
   47:  op div .SPEED_SEC *tmp8 10                                   ...
   48:  sensor *tmp10 @unit @speed                                   SPEED = @unit.@speed / 1000;                         // Unit speed in tiles/ms
   49:  op div .SPEED *tmp10 1000                                    ...
   50:  set .TARGET 0                                                TARGET = 0;
        label *label17                                               do
   51:  sensor *tmp12 @unit @controller                              if @unit.@controller == @this then
   52:  jump *label20 notEqual *tmp12 @this                          ...
   53:  sensor :state @unit @flag                                    state = @unit.@flag;
   54:  op greaterThanEq *tmp16 :state 1                             TARGET += (state >= S_FIRST) && (state < S_LAST);
   55:  op lessThan *tmp17 :state 6                                  ...
   56:  op land *tmp18 *tmp16 *tmp17                                 ...
   57:  op add .TARGET .TARGET *tmp18                                ...
        label *label20                                               if @unit.@controller == @this then
   58:  ubind UNIT                                                   ubind(UNIT);
   59:  jump *label19 equal @unit :first_unit                        while (@unit != first_unit) and (first_unit.@dead == 0);    // Don't get stuck if the first unit is killed
   60:  sensor *tmp20 :first_unit @dead                              ...
   61:  jump *label17 equal *tmp20 0                                 ...
        label *label19                                               do
   62:  set .CHANGE 0                                                CHANGE = 0;
   63:  set :active .TARGET                                          active = TARGET;
   64:  set .DEC_LIMIT 0                                             DEC_LIMIT = 0;
   65:  set .INC_LIMIT 0                                             INC_LIMIT = 0;
   66:  sensor .UNIT_CAPACITY @unit @itemCapacity                    UNIT_CAPACITY = @unit.@itemCapacity;
   67:  set :first_unit null                                         first_unit = null;
        label *label23                                               while true do
   68:  set .CONTAINER null                                          CONTAINER = null;
   69:  set .CONTAINERS 0                                            CONTAINERS = 0;
   70:  set :n @links                                                n = @links;
   71:  jump *label28 lessThanEq :n 0                                while n > 0 do
        label *label262                                              ...
   72:  op sub :n :n 1                                               n = n - 1;
   73:  getlink :block :n                                            block = getlink(n);
   74:  sensor *tmp28 :block @type                                   case block.@type
   75:  jump *label31 equal *tmp28 @vault                            ...
   76:  jump *label30 notEqual *tmp28 @container                     ...
        label *label31                                               ...
   77:  set .CONTAINER :block                                        CONTAINER = block;
   78:  op add .CONTAINERS .CONTAINERS 1                             CONTAINERS += 1;
   79:  set .CONTAINER_INDEX :n                                      CONTAINER_INDEX = n;
        label *label30                                               case block.@type
   80:  jump *label262 greaterThan :n 0                              while n > 0 do
        label *label28                                               ...
   81:  jump *label25 notEqual .CONTAINER null                       if CONTAINER == null then
   82:  print "[salmon]No vault or container."                       print("[salmon]No vault or container.");
   83:  printflush message1                                          printflush(message1);
   84:  jump *label23 always 0 0                                     if CONTAINER == null then
        label *label25                                               while true do
   85:  set .CORE null                                               CORE = null;
   86:  jump *label34 notEqual LINK_ID 0                             if LINK_ID == 0 then
        label *label263                                              while CORE == null do
   87:  print "[green]Locating core..."                              print("[green]Locating core...");
   88:  printflush message1                                          printflush(message1);
   89:  ubind UNIT                                                   ubind(UNIT);
   90:  sensor *tmp35 @unit @controlled                              if @unit.@controlled == 0 then
   91:  jump *label39 notEqual *tmp35 0                              ...
   92:  ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE  CORE = ulocate(:building, :core, false, out CORE_X, out CORE_Y);
   93:  ucontrol flag .S_UNUSED 0 0 0 0                              flag(S_UNUSED);
        label *label39                                               if @unit.@controlled == 0 then
   94:  jump *label263 equal .CORE null                              while CORE == null do
   95:  set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY                   DISCARD_UNIT_MAX_ITEMS = UNIT_CAPACITY;       // Can discard anything to the core
   96:  op equal .DROP_TO_CORE DROP_TO_AIR false                     DROP_TO_CORE = not DROP_TO_AIR;
   97:  jump *label35 always 0 0                                     if LINK_ID == 0 then
        label *label34                                               ...
   98:  printflush message2                                          printflush(message2);
   99:  print "[green]Locating vault #"                              print($"[green]Locating vault #$LINK_ID...");
  100:  print LINK_ID                                                ...
  101:  print "..."                                                  ...
  102:  printflush message1                                          printflush(message1);
  103:  op add .QUERY_FLAG 99999900 LINK_ID                          while CORE == null do
        label *label264                                              ...
  104:  set :flag .QUERY_FLAG                                        flag = QUERY_FLAG;
  105:  ubind UNIT                                                   ubind(UNIT);
  106:  sensor *tmp43 @unit @controlled                              while @unit.@controlled != 0 do
  107:  jump *label46 equal *tmp43 0                                 ...
        label *label271                                              ...
  108:  ubind UNIT                                                   ubind(UNIT);
  109:  sensor *tmp43 @unit @controlled                              while @unit.@controlled != 0 do
  110:  jump *label271 notEqual *tmp43 0                             ...
        label *label46                                               ...
  111:  ucontrol flag .QUERY_FLAG 0 0 0 0                            flag(flag);
        label *label265                                              while flag == QUERY_FLAG and @unit.@dead == 0 do
  112:  sensor *tmp46 @unit @dead                                    ...
  113:  jump *label49 notEqual *tmp46 0                              ...
  114:  ucontrol stop 0 0 0 0 0                                      stop();                 // Keep controlling the unit
  115:  sensor :flag @unit @flag                                     flag = @unit.@flag;
  116:  jump *label265 equal :flag .QUERY_FLAG                       while flag == QUERY_FLAG and @unit.@dead == 0 do
        label *label49                                               ...
  117:  jump *label52 equal :flag .QUERY_FLAG                        if flag != QUERY_FLAG then
  118:  op idiv :position :flag 100                                  position = flag \ 100;
  119:  op mod .CORE_X :position @mapw                               CORE_X = position % @mapw;
  120:  op idiv .CORE_Y :position @mapw                              CORE_Y = position \ @mapw;
  121:  sensor *tmp54 @unit @dead                                    while @unit.@dead == 0 and !within(CORE_X, CORE_Y, RADIUS_WITHIN) do
  122:  jump *label56 notEqual *tmp54 0                              ...
        label *label272                                              ...
  123:  ucontrol within .CORE_X .CORE_Y 8 *tmp56 0                   ...
  124:  jump *label56 notEqual *tmp56 false                          ...
  125:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  126:  sensor *tmp54 @unit @dead                                    while @unit.@dead == 0 and !within(CORE_X, CORE_Y, RADIUS_WITHIN) do
  127:  jump *label272 equal *tmp54 0                                ...
        label *label56                                               ...
  128:  ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0            CORE = getBlock(CORE_X, CORE_Y, out b_type);
  129:  jump *label59 equal :b_type @vault                           if b_type != @vault then
  130:  print "[salmon]Building at "                                 print($"[salmon]Building at $CORE_X, $CORE_Y is not a vault!");
  131:  print .CORE_X                                                ...
  132:  print ", "                                                   ...
  133:  print .CORE_Y                                                ...
  134:  print " is not a vault!"                                     ...
  135:  printflush message2                                          printflush(message2);
  136:  set .CORE null                                               CORE = null;
        label *label59                                               if b_type != @vault then
        label *label52                                               if flag != QUERY_FLAG then
  137:  ucontrol flag .S_UNUSED 0 0 0 0                              flag(S_UNUSED);               // Free the unit
  138:  jump *label264 equal .CORE null                              while CORE == null do
  139:  set .DISCARD_UNIT_MAX_ITEMS 0                                DISCARD_UNIT_MAX_ITEMS = DROP_TO_AIR ? UNIT_CAPACITY : 0;       // Cannot drop items to the remote vault
  140:  jump *label62 equal DROP_TO_AIR false                        ...
  141:  set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY                   ...
        label *label62                                               ...
  142:  set .DROP_TO_CORE false                                      DROP_TO_CORE = false;
        label *label35                                               if LINK_ID == 0 then
  143:  set .SORTER sorter1                                          SORTER = sorter1;
  144:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  145:  jump *label65 equal :sorter_type @sorter                     while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
        label *label266                                              ...
  146:  jump *label65 equal :sorter_type @inverted-sorter            ...
  147:  print "[salmon]Block sorter1 is neither a sorter, nor an inv println("[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.");
  148:  jump *label68 equal .SORTER null                             if SORTER != null then
  149:  print "Block found: "                                        print("Block found: ", SORTER);
  150:  print .SORTER                                                ...
        label *label68                                               if SORTER != null then
  151:  printflush message1                                          printflush(message1);
  152:  set .SORTER sorter1                                          SORTER = sorter1;
  153:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  154:  jump *label266 notEqual :sorter_type @sorter                 while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
        label *label65                                               ...
  155:  jump *label70 notEqual :sorter_type @sorter                  if sorter_type == @sorter then
  156:  set .SHOW_REMOTE_LEVEL true                                  SHOW_REMOTE_LEVEL = true;
  157:  set .SRC .CORE                                               SRC = CORE;
  158:  set .DST .CONTAINER                                          DST = CONTAINER;
  159:  sensor :src_capacity .CORE @itemCapacity                     src_capacity = SRC.@itemCapacity;
  160:  sensor :dst_capacity .CONTAINER @itemCapacity                dst_capacity = DST.@itemCapacity;
  161:  op sub *tmp73 100 .EFF_REMOTE_LIMIT                          LOAD_LEVEL = (src_capacity * (100 - EFF_REMOTE_LIMIT)) \ 100;
  162:  op mul *tmp74 :src_capacity *tmp73                           ...
  163:  op idiv .LOAD_LEVEL *tmp74 100                               ...
  164:  op mul *tmp76 :dst_capacity .EFF_LOCAL_LIMIT                 DROP_LEVEL = (dst_capacity * EFF_LOCAL_LIMIT) \ 100;
  165:  op idiv .DROP_LEVEL *tmp76 100                               ...
  166:  set .LOCAL_MARGIN .DROP_LEVEL                                LOCAL_MARGIN = DROP_LEVEL;
  167:  set .REMOTE_MARGIN .LOAD_LEVEL                               REMOTE_MARGIN = LOAD_LEVEL;
  168:  op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998  LOW_LEVEL_TRIGGER = dst_capacity * (1 - TRIGGER_LEVEL);
  169:  set .HIGH_LEVEL_TRIGGER :dst_capacity                        HIGH_LEVEL_TRIGGER = dst_capacity;  // never triggers
  170:  set .FLOW_CORR_SIGN 1                                        FLOW_CORR_SIGN = 1;                 // sign of flow-rate correction computed from container level
  171:  set .SRC_REMOTE_WAIT 1                                       SRC_REMOTE_WAIT = 1;
  172:  set .DST_REMOTE_WAIT 0                                       DST_REMOTE_WAIT = 0;
  173:  set .DIRECTION " from vault #"                               DIRECTION = (LINK_ID == 0) ? " from core"  : " from vault #";
  174:  jump *label71 notEqual LINK_ID 0                             ...
  175:  set .DIRECTION " from core"                                  ...
  176:  jump *label71 always 0 0                                     if sorter_type == @sorter then
        label *label70                                               ...
  177:  op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0                  SHOW_REMOTE_LEVEL = LINK_ID > 0;
  178:  set .SRC .CONTAINER                                          SRC = CONTAINER;
  179:  set .DST .CORE                                               DST = CORE;
  180:  sensor :src_capacity .CONTAINER @itemCapacity                src_capacity = SRC.@itemCapacity;
  181:  sensor :dst_capacity .CORE @itemCapacity                     dst_capacity = DST.@itemCapacity;
  182:  op sub *tmp85 100 .EFF_LOCAL_LIMIT                           LOAD_LEVEL = (src_capacity * (100 - EFF_LOCAL_LIMIT)) \ 100;
  183:  op mul *tmp86 :src_capacity *tmp85                           ...
  184:  op idiv .LOAD_LEVEL *tmp86 100                               ...
  185:  op mul *tmp88 :dst_capacity .EFF_REMOTE_LIMIT                DROP_LEVEL = (dst_capacity * EFF_REMOTE_LIMIT) \ 100 + ((LINK_ID == 0) * UNIT_CAPACITY);
  186:  op idiv *tmp89 *tmp88 100                                    ...
  187:  op equal *tmp90 LINK_ID 0                                    ...
  188:  op mul *tmp91 *tmp90 .UNIT_CAPACITY                          ...
  189:  op add .DROP_LEVEL *tmp89 *tmp91                             ...
  190:  set .LOCAL_MARGIN .LOAD_LEVEL                                LOCAL_MARGIN = LOAD_LEVEL;
  191:  set .REMOTE_MARGIN .DROP_LEVEL                               REMOTE_MARGIN = DROP_LEVEL;
  192:  op mul .HIGH_LEVEL_TRIGGER :src_capacity 0.9                 HIGH_LEVEL_TRIGGER = src_capacity * TRIGGER_LEVEL;
  193:  set .LOW_LEVEL_TRIGGER 0                                     LOW_LEVEL_TRIGGER = 0;              // never triggers
  194:  set .FLOW_CORR_SIGN -1                                       FLOW_CORR_SIGN = -1;                // sign of flow-rate correction computed from container level
  195:  set .SRC_REMOTE_WAIT 0                                       SRC_REMOTE_WAIT = 0;
  196:  set .DST_REMOTE_WAIT 1                                       DST_REMOTE_WAIT = 1;
  197:  set .DIRECTION " to vault #"                                 DIRECTION = (LINK_ID == 0) ? " to core" : " to vault #";
  198:  jump *label75 notEqual LINK_ID 0                             ...
  199:  set .DIRECTION " to core"                                    ...
        label *label75                                               ...
        label *label71                                               if sorter_type == @sorter then
  200:  set *tmp97 LINK_ID                                           LINK_TXT = (LINK_ID == 0) ? ""  : LINK_ID;
  201:  jump *label77 notEqual LINK_ID 0                             ...
  202:  set *tmp97 ""                                                ...
        label *label77                                               ...
  203:  op sub *tmp98 :src_capacity .LOAD_LEVEL                      LOAD_PACK = min(UNIT_CAPACITY, src_capacity - LOAD_LEVEL);
  204:  op min .LOAD_PACK .UNIT_CAPACITY *tmp98                      ...
  205:  op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL                 DROP_PACK = min(UNIT_CAPACITY, DROP_LEVEL);
  206:  sensor .SRC_X .SRC @x                                        SRC_X = SRC.@x;
  207:  sensor .SRC_Y .SRC @y                                        SRC_Y = SRC.@y;
  208:  sensor .DST_X .DST @x                                        DST_X = DST.@x;
  209:  sensor .DST_Y .DST @y                                        DST_Y = DST.@y;
  210:  op sub *tmp105 .DST_X .SRC_X                                 DISTANCE = len(DST_X - SRC_X, DST_Y - SRC_Y) - RADIUS_APPROACH - RADIUS_WITHIN;
  211:  op sub *tmp106 .DST_Y .SRC_Y                                 ...
  212:  op len *tmp107 *tmp105 *tmp106                               ...
  213:  op sub .DISTANCE *tmp107 14                                  ...
  214:  op max *tmp110 .DISTANCE 10                                  TRAVEL_TIME = (2 * max(DISTANCE, 10)) / SPEED;   // Travel time: both ways, in tiles/ms
  215:  op mul *tmp111 2 *tmp110                                     ...
  216:  op div .TRAVEL_TIME *tmp111 .SPEED                           ...
  217:  op add .PARK_X .CORE_X -15                                   PARK_X = CORE_X + ((CONTAINER.@x < CORE_X) ? 15 : -15);
  218:  sensor *tmp113 .CONTAINER @x                                 ...
  219:  jump *label79 greaterThanEq *tmp113 .CORE_X                  ...
  220:  op add .PARK_X .CORE_X 15                                    ...
        label *label79                                               ...
  221:  op add .PARK_Y .CORE_Y -15                                   PARK_Y = CORE_Y + ((CONTAINER.@y < CORE_Y) ? 15 : -15);
  222:  sensor *tmp117 .CONTAINER @y                                 ...
  223:  jump *label81 greaterThanEq *tmp117 .CORE_Y                  ...
  224:  op add .PARK_Y .CORE_Y 15                                    ...
        label *label81                                               ...
  225:  op equal *tmp121 LINK_ID 0                                   PARK_ITEM_LIMIT = (LINK_ID == 0) * UNIT_CAPACITY;
  226:  op mul .PARK_ITEM_LIMIT *tmp121 .UNIT_CAPACITY               ...
  227:  set .TRANSFER_START @tick                                    TRANSFER_START = @tick;             // Prevent completely nonsensical values
  228:  op sub .LOOP_START @tick 60                                  LOOP_START = @tick - 60;            // Prevent completely nonsensical values
  229:  set .LAST_ITEM @mono                                         LAST_ITEM = @mono;                  // Must not be null
  230:  op add .MESSAGE_TIMEOUT @tick 600                            MESSAGE_TIMEOUT = @tick + 600;      // Ten seconds
  231:  set .WAIT_LIMIT 30000                                        WAIT_LIMIT = 30000;                 // Good initial value: half a minute
  232:  set :items_in_transit 0                                      items_in_transit = 0;
  233:  set :items_per_min_unit "--"                                 items_per_min_unit = "--";
  234:  set :items_per_min "-- "                                     items_per_min = "-- ";
  235:  set :turnaround_str "--"                                     turnaround_str = "--";
  236:  set :elapsed_str "--"                                        elapsed_str = "--";
  237:  set :wait_time_str 0                                         wait_time_str = 0;
  238:  set :wait_time 0                                             = total_flow_1 = total_flow_2 = transferred = transfers = wait_time = 0;
  239:  set :transfers 0                                             ...
  240:  set :transferred 0                                           ...
  241:  set :total_flow_2 0                                          ...
  242:  set :total_flow_1 0                                          ...
  243:  set :remote_wait_time 0                                      last_level = loop_time_ms = max_level = min_level = remote_wait_time
  244:  set :min_level 0                                             ...
  245:  set :max_level 0                                             ...
  246:  set :loop_time_ms 0                                          ...
  247:  set :last_level 0                                            ...
  248:  jump *label82 equal AUTO_ALLOCATION false                    if EFF_AUTO_ALLOCATION then
  249:  set .CORR_SIGN "[]([green]+"                                 CORR_SIGN = "[]([green]+";
  250:  set :corr_per_min 0                                          corr_per_min = 0;
  251:  set .SPEED_UNIT_TXT "[])/min"                                SPEED_UNIT_TXT = "[])/min";
  252:  set .AUTO_ALLOCATION_TXT "\n=== [gold]Gathering statistics[] AUTO_ALLOCATION_TXT = "\n=== [gold]Gathering statistics[] ===";
  253:  jump *label83 always 0 0                                     if EFF_AUTO_ALLOCATION then
        label *label82                                               ...
  254:  set .CORR_SIGN "[]"                                          CORR_SIGN = "[]";
  255:  set :corr_per_min ""                                         corr_per_min = "";
  256:  set .SPEED_UNIT_TXT "/min"                                   SPEED_UNIT_TXT = "/min";
  257:  set .AUTO_ALLOCATION_TXT ""                                  AUTO_ALLOCATION_TXT = "";
        label *label83                                               if EFF_AUTO_ALLOCATION then
        label *label84                                               while true do
  258:  ubind UNIT                                                   ubind(UNIT);
  259:  jump *label89 notEqual @unit null                            while @unit == null do
        label *label267                                              ...
  260:  print "No unit of type "                                     print($"No unit of type $UNIT found.");
  261:  print UNIT                                                   ...
  262:  print " found."                                              ...
  263:  printflush message1                                          printflush(message1);
  264:  ubind UNIT                                                   ubind(UNIT);
  265:  jump *label267 equal @unit null                              while @unit == null do
        label *label89                                               ...
  266:  sensor *tmp128 switch1 @enabled                              if switch1.@enabled then
  267:  jump *label90 equal *tmp128 false                            ...
  268:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  269:  set .EFF_AUTO_ALLOCATION false                               EFF_AUTO_ALLOCATION = false;
  270:  set .AUTO_ALLOCATION_TXT ""                                  AUTO_ALLOCATION_TXT = "";
  271:  op add *tmp131 .TARGET 1                                     TARGET = min(TARGET + 1, MAX_UNITS);
  272:  op min .TARGET *tmp131 MAX_UNITS                             ...
  273:  set .CORR_SIGN "[]"                                          CORR_SIGN = "[]";
  274:  set :corr_per_min ""                                         corr_per_min = "";
  275:  set .SPEED_UNIT_TXT "/min"                                   SPEED_UNIT_TXT = "/min";
  276:  set .WAIT_LIMIT 30000                                        WAIT_LIMIT = 30000;
        label *label90                                               if switch1.@enabled then
  277:  sensor *tmp133 switch2 @enabled                              if switch2.@enabled then
  278:  jump *label92 equal *tmp133 false                            ...
  279:  control enabled switch2 false 0 0 0                          switch2.enabled = false;
  280:  jump *label94 greaterThanEq .TARGET 1                        if TARGET < 1 then
  281:  set .EFF_AUTO_ALLOCATION true                                EFF_AUTO_ALLOCATION = true;
  282:  set .TARGET 1                                                TARGET = 1;
  283:  set .DEC_LIMIT 0                                             DEC_LIMIT = 0;           // No change for next iteration
  284:  set .INC_LIMIT 0                                             INC_LIMIT = 0;
  285:  set .CORR_SIGN "[]([green]+"                                 CORR_SIGN = "[]([green]+";
  286:  set :corr_per_min 0                                          corr_per_min = 0;
  287:  set .SPEED_UNIT_TXT "[])/min"                                SPEED_UNIT_TXT = "[])/min";
  288:  jump *label95 always 0 0                                     if TARGET < 1 then
        label *label94                                               ...
  289:  set .EFF_AUTO_ALLOCATION false                               EFF_AUTO_ALLOCATION = false;
  290:  op sub *tmp138 .TARGET 1                                     TARGET = max(TARGET - 1, 0);
  291:  op max .TARGET *tmp138 0                                     ...
  292:  set .CORR_SIGN "[]"                                          CORR_SIGN = "[]";
  293:  set :corr_per_min ""                                         corr_per_min = "";
  294:  set .SPEED_UNIT_TXT "/min"                                   SPEED_UNIT_TXT = "/min";
  295:  set .AUTO_ALLOCATION_TXT ""                                  AUTO_ALLOCATION_TXT = TARGET == 0 ? "\n=== [salmon]Transport deactivated[] ===" : "";
  296:  jump *label97 notEqual .TARGET 0                             ...
  297:  set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivate ...
        label *label97                                               ...
        label *label95                                               if TARGET < 1 then
  298:  set .WAIT_LIMIT 30000                                        WAIT_LIMIT = 30000;
        label *label92                                               if switch2.@enabled then
  299:  sensor *tmp142 :first_unit @dead                             alive = first_unit.@dead == 0;
  300:  op equal :alive *tmp142 0                                    ...
  301:  op equal *tmp144 @unit :first_unit                           if alive <= (@unit == first_unit) then
  302:  jump *label98 greaterThan :alive *tmp144                     ...
  303:  jump *label100 notEqual :active 0                            if active == 0 then
  304:  print "\n[salmon]No active units.[]"                         print("\n[salmon]No active units.[]");
        label *label100                                              if active == 0 then
  305:  printflush message2                                          printflush(message2);
  306:  set .STATE_LIMIT 6                                           STATE_LIMIT = S_LAST;
  307:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  308:  jump *label102 equal .ITEM .LAST_ITEM                        if ITEM != LAST_ITEM then
  309:  jump *label106 notEqual .ITEM null                           while ITEM == null do
        label *label268                                              ...
  310:  print "[salmon]No item type selected for transport.[]"       print("[salmon]No item type selected for transport.[]");
  311:  printflush message1                                          printflush(message1);
  312:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  313:  jump *label268 equal .ITEM null                              while ITEM == null do
        label *label106                                              ...
  314:  set .LAST_ITEM .ITEM                                         LAST_ITEM = ITEM;
  315:  sensor *tmp156 .ITEM @id                                     case itemType.@id
  316:  jump *label274 greaterThanEq *tmp156 3                       ...
  317:  jump *label275 greaterThanEq *tmp156 1                       ...
  318:  jump *label273 lessThan *tmp156 0                            ...
  319:  set *tmp155 "[]"                                            ...
  320:  jump *label108 always 0 0                                    ...
        label *label275                                              ...
  321:  jump *label120 greaterThanEq *tmp156 2                       ...
  322:  set *tmp155 "[]"                                            ...
  323:  jump *label108 always 0 0                                    ...
        label *label274                                              ...
  324:  jump *label273 greaterThanEq *tmp156 16                      ...
  325:  multijump *label277 *tmp156 3                                ...
        multilabel *label277                                         ...
  326:  jump *label116 always 0 0                                    ...
        multilabel *label278                                         ...
  327:  jump *label128 always 0 0                                    ...
        multilabel *label279                                         ...
  328:  jump *label112 always 0 0                                    ...
        multilabel *label280                                         ...
  329:  jump *label140 always 0 0                                    ...
        multilabel *label281                                         ...
  330:  jump *label138 always 0 0                                    ...
        multilabel *label282                                         ...
  331:  jump *label130 always 0 0                                    ...
        multilabel *label283                                         ...
  332:  jump *label132 always 0 0                                    ...
        multilabel *label284                                         ...
  333:  jump *label124 always 0 0                                    ...
        multilabel *label285                                         ...
  334:  jump *label122 always 0 0                                    ...
        multilabel *label286                                         ...
  335:  jump *label136 always 0 0                                    ...
        multilabel *label287                                         ...
  336:  jump *label134 always 0 0                                    ...
        multilabel *label288                                         ...
  337:  jump *label110 always 0 0                                    ...
        multilabel *label289                                         ...
  338:  set *tmp155 "[]"                                            ...
  339:  jump *label108 always 0 0                                    ...
        label *label110                                              ...
  340:  set *tmp155 "[]"                                            ...
  341:  jump *label108 always 0 0                                    ...
        label *label112                                              ...
  342:  set *tmp155 "[]"                                            ...
  343:  jump *label108 always 0 0                                    ...
        label *label116                                              ...
  344:  set *tmp155 "[]"                                            ...
  345:  jump *label108 always 0 0                                    ...
        label *label120                                              ...
  346:  set *tmp155 "[]"                                            ...
  347:  jump *label108 always 0 0                                    ...
        label *label122                                              ...
  348:  set *tmp155 "[]"                                            ...
  349:  jump *label108 always 0 0                                    ...
        label *label124                                              ...
  350:  set *tmp155 "[]"                                            ...
  351:  jump *label108 always 0 0                                    ...
        label *label128                                              ...
  352:  set *tmp155 "[]"                                            ...
  353:  jump *label108 always 0 0                                    ...
        label *label130                                              ...
  354:  set *tmp155 "[]"                                            ...
  355:  jump *label108 always 0 0                                    ...
        label *label132                                              ...
  356:  set *tmp155 "[]"                                            ...
  357:  jump *label108 always 0 0                                    ...
        label *label134                                              ...
  358:  set *tmp155 "[]"                                            ...
  359:  jump *label108 always 0 0                                    ...
        label *label136                                              ...
  360:  set *tmp155 "[]"                                            ...
  361:  jump *label108 always 0 0                                    ...
        label *label138                                              ...
  362:  set *tmp155 "[]"                                            ...
  363:  jump *label108 always 0 0                                    ...
        label *label140                                              ...
  364:  set *tmp155 "[]"                                            ...
  365:  jump *label108 always 0 0                                    ...
        label *label273                                              ...
  366:  set *tmp155 null                                             ...
        label *label108                                              ...
  367:  set .ITEM_ICON *tmp155                                       ITEM_ICON = itemTypeToIcon(ITEM);
  368:  set .STATE_LIMIT 1                                           STATE_LIMIT = S_UNLOAD;   // Switches all units to S_UNLOAD state
  369:  sensor :last_level .CONTAINER .ITEM                          last_level = CONTAINER.sensor(ITEM);
  370:  set :min_level 999999                                        min_level = 999999;
  371:  set :max_level 0                                             max_level = 0;
        label *label102                                              if ITEM != LAST_ITEM then
  372:  sensor :container_items .CONTAINER .ITEM                     container_items = CONTAINER.sensor(ITEM);
  373:  op min :min_level :min_level :container_items                min_level = min(min_level, container_items);
  374:  op max :max_level :max_level :container_items                max_level = max(max_level, container_items);
  375:  op sub :loop_time @tick .LOOP_START                          loop_time = @tick - LOOP_START;
  376:  set .LOOP_START @tick                                        LOOP_START = @tick;
  377:  op mul *tmp164 :loop_time 100                                loop_time_ms = (loop_time * 100) \ 6;
  378:  op idiv :loop_time_ms *tmp164 6                              ...
  379:  jump *label143 greaterThanEq :transfers :active              if transfers >= active or wait_time > WAIT_LIMIT then
  380:  jump *label141 lessThanEq :wait_time .WAIT_LIMIT             ...
        label *label143                                              ...
  381:  op div *tmp169 :wait_time 100                                wait_time_str = ceil(wait_time / 100) / 10;
  382:  op ceil *tmp170 *tmp169 0                                    ...
  383:  op div :wait_time_str *tmp170 10                             ...
  384:  op sub :elapsed_ticks @tick .TRANSFER_START                  elapsed_ticks = @tick - TRANSFER_START;
  385:  set .TRANSFER_START @tick                                    TRANSFER_START = @tick;
  386:  op div :elapsed_ms :elapsed_ticks 0.06                       elapsed_ms = elapsed_ticks / 0.06;
  387:  op idiv *tmp175 :elapsed_ms 100                              elapsed_str = (elapsed_ms \ 100) / 10;
  388:  op div :elapsed_str *tmp175 10                               ...
  389:  op div :items_per_ms :transferred :elapsed_ms                items_per_ms = transferred / elapsed_ms;
  390:  op idiv :items_per_min :items_per_ms 0.000016666666666666667 items_per_min = items_per_ms \ (1.0 / 60000);    // save floor instruction; for display only
  391:  set :transferred 0                                           transferred = 0;
  392:  set :transfers 0                                             transfers = 0;
  393:  jump *label145 equal .EFF_AUTO_ALLOCATION false              if EFF_AUTO_ALLOCATION then
  394:  set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] AUTO_ALLOCATION_TXT = "\n=== [gold]Unit auto allocation[] ===";
  395:  op mul *tmp180 16.666666666666668 :loop_time                 turnaround_ms = TRAVEL_TIME + (LOOPS_TICKS_TO_MS * loop_time);
  396:  op add :turnaround_ms .TRAVEL_TIME *tmp180                   ...
  397:  op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION        WAIT_LIMIT = turnaround_ms * DEC_OVERALLOCATION;
  398:  op idiv *tmp183 :turnaround_ms 100                           turnaround_str = (turnaround_ms \ 100) / 10;
  399:  op div :turnaround_str *tmp183 10                            ...
  400:  op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms      items_per_ms_unit = UNIT_CAPACITY / turnaround_ms;
  401:  op idiv :items_per_min_unit :items_per_ms_unit 0.00001666666 items_per_min_unit = floor(items_per_ms_unit * 60000);
  402:  op add *tmp188 :min_level :max_level                         this_level = (min_level + max_level) / 2;
  403:  op div :this_level *tmp188 2                                 ...
  404:  op sub *tmp190 :last_level :this_level                       corr = (last_level - this_level) * FLOW_CORR_SIGN;
  405:  op mul :corr *tmp190 .FLOW_CORR_SIGN                         ...
  406:  op div :corr_per_ms :corr :elapsed_ms                        corr_per_ms = corr / elapsed_ms;
  407:  set :last_level :this_level                                  last_level = this_level;
  408:  op add :total_flow_per_ms :items_per_ms :corr_per_ms         total_flow_per_ms = items_per_ms + corr_per_ms;
  409:  op idiv :corr_per_min :corr_per_ms 0.000016666666666666667   corr_per_min = floor(60000 * corr_per_ms);
  410:  set .CORR_SIGN "[]([green]"                                  CORR_SIGN = corr_per_min >= 0 ? "[]([green]+" : "[]([green]";
  411:  jump *label148 lessThan :corr_per_min 0                      ...
  412:  set .CORR_SIGN "[]([green]+"                                 ...
        label *label148                                              ...
  413:  set .SPEED_UNIT_TXT "[])/min"                                SPEED_UNIT_TXT = "[])/min";
  414:  jump *label149 notEqual *tmp142 0                            if alive then
  415:  jump *label151 greaterThanEq :min_level .LOW_LEVEL_TRIGGER   trigger = min_level < LOW_LEVEL_TRIGGER or max_level > HIGH_LEVEL_TRIGGER;
  416:  set *tmp201 true                                             ...
  417:  jump *label152 always 0 0                                    ...
        label *label151                                              ...
  418:  op greaterThan *tmp201 :max_level .HIGH_LEVEL_TRIGGER        ...
        label *label152                                              ...
  419:  jump *label157 equal :wait_time 0                            if wait_time == 0 or (trigger > remote_wait_time) then
  420:  jump *label155 lessThanEq *tmp201 :remote_wait_time          ...
        label *label157                                              ...
  421:  jump *label159 equal STABILIZATION false                     if STABILIZATION then
  422:  set :total_flow_3 :total_flow_2                              total_flow_3 = total_flow_2;
  423:  set :total_flow_2 :total_flow_1                              total_flow_2 = total_flow_1;
  424:  set :total_flow_1 :total_flow_per_ms                         total_flow_1 = total_flow_per_ms;
  425:  op add *tmp206 :total_flow_3 :total_flow_2                   total_flow_per_ms = (total_flow_3 + total_flow_2 + total_flow_1) / 3;
  426:  op add *tmp207 *tmp206 :total_flow_per_ms                    ...
  427:  op div :total_flow_per_ms *tmp207 3                          ...
        label *label159                                              if STABILIZATION then
  428:  op div *tmp209 :total_flow_per_ms :items_per_ms_unit         new_target = ceil(total_flow_per_ms / items_per_ms_unit + INC_OVERALLOCATION);
  429:  op add *tmp210 *tmp209 OVERALLOCATION_LOW                    ...
  430:  op ceil :new_target *tmp210 0                                ...
  431:  op mul :level_boost 2 *tmp201                                level_boost = TRIGGER_BOOST * trigger;
  432:  op add *tmp213 :new_target :level_boost                      new_target = min(new_target + level_boost, MAX_UNITS);
  433:  op min :new_target *tmp213 MAX_UNITS                         ...
  434:  op sub *tmp215 :new_target :active                           new_change = min(max(new_target - active, 0), INC_LIMIT);
  435:  op max *tmp216 *tmp215 0                                     ...
  436:  op min :new_change *tmp216 .INC_LIMIT                        ...
  437:  set .INC_LIMIT 6                                             INC_LIMIT = INC_MAX;                           // Can increase again next time
  438:  op lessThanEq *tmp218 :new_change 0                          DEC_LIMIT = (new_change <= 0) * DEC_MAX;       // No decreases after an increase
  439:  op mul .DEC_LIMIT *tmp218 -1                                 ...
  440:  jump *label156 always 0 0                                    if wait_time == 0 or (trigger > remote_wait_time) then
        label *label155                                              ...
  441:  op idiv *tmp220 :wait_time .WAIT_LIMIT                       new_change = max(-1 * (wait_time \ WAIT_LIMIT), DEC_LIMIT);
  442:  op mul *tmp221 -1 *tmp220                                    ...
  443:  op max :new_change *tmp221 .DEC_LIMIT                        ...
  444:  op greaterThanEq *tmp223 :new_change 0                       INC_LIMIT = (new_change >= 0) * INC_MAX;       // No increases after a decrease
  445:  op mul .INC_LIMIT *tmp223 6                                  ...
  446:  set .DEC_LIMIT -1                                            DEC_LIMIT = DEC_MAX;                           // Can decrease again next time
        label *label156                                              if wait_time == 0 or (trigger > remote_wait_time) then
  447:  op add *tmp225 :active :new_change                           TARGET = max(active + new_change, 1);
  448:  op max .TARGET *tmp225 1                                     ...
  449:  jump *label150 always 0 0                                    if alive then
        label *label149                                              ...
  450:  set .INC_LIMIT 0                                             INC_LIMIT = 0;
  451:  set .DEC_LIMIT 0                                             DEC_LIMIT = 0;
        label *label150                                              if alive then
  452:  set :min_level 999999                                        min_level = 999999;
  453:  set :max_level 0                                             max_level = 0;
        label *label145                                              if EFF_AUTO_ALLOCATION then
  454:  jump *label161 lessThanEq .CONTAINERS 1                      if CONTAINERS > 1 and SRC == CORE then
  455:  jump *label161 notEqual .SRC .CORE                           ...
  456:  sensor *tmp230 .DST .ITEM                                    max_drop = DROP_LEVEL - DST.sensor(ITEM);
  457:  op sub :max_drop .DROP_LEVEL *tmp230                         ...
  458:  jump *label165 greaterThanEq :max_drop .DROP_PACK            if max_drop < DROP_PACK then
  459:  set :findAnotherContainer:min_level 999999                   min_level = 999999;
  460:  set .CONTAINERS 0                                            CONTAINERS = 0;
  461:  set :findAnotherContainer:n @links                           n = @links;
  462:  jump *label170 lessThanEq :findAnotherContainer:n 0          while n > 0 do
        label *label269                                              ...
  463:  op sub :findAnotherContainer:n :findAnotherContainer:n 1     n = n - 1;
  464:  getlink :findAnotherContainer:block :findAnotherContainer:n  block = getlink(n);
  465:  sensor *tmp240 :findAnotherContainer:block @type             case block.@type
  466:  jump *label173 equal *tmp240 @vault                          ...
  467:  jump *label172 notEqual *tmp240 @container                   ...
        label *label173                                              ...
  468:  op add .CONTAINERS .CONTAINERS 1                             CONTAINERS += 1;
  469:  sensor :findAnotherContainer:level :findAnotherContainer:blo level = block.sensor(ITEM);
  470:  jump *label174 greaterThanEq :findAnotherContainer:level :fi if level < min_level then
  471:  set :findAnotherContainer:min_level :findAnotherContainer:le min_level = level;
  472:  set .CONTAINER :findAnotherContainer:block                   CONTAINER = block;
  473:  set .CONTAINER_INDEX :findAnotherContainer:n                 CONTAINER_INDEX = n;
        label *label174                                              if level < min_level then
        label *label172                                              case block.@type
  474:  jump *label269 greaterThan :findAnotherContainer:n 0         while n > 0 do
        label *label170                                              ...
  475:  jump *label176 notEqual .CONTAINERS 0                        if CONTAINERS == 0 then
  476:  set .CONTAINER @this                                         CONTAINER = @this;
  477:  jump *label177 always 0 0                                    if CONTAINERS == 0 then
        label *label176                                              ...
  478:  set .DST .CONTAINER                                          DST = CONTAINER;
  479:  sensor :findAnotherContainer:dst_capacity .CONTAINER @itemCa dst_capacity = DST.@itemCapacity;
  480:  op mul *tmp248 :findAnotherContainer:dst_capacity .EFF_LOCAL DROP_LEVEL = (dst_capacity * EFF_LOCAL_LIMIT) \ 100;
  481:  op idiv .DROP_LEVEL *tmp248 100                              ...
  482:  set .LOCAL_MARGIN .DROP_LEVEL                                LOCAL_MARGIN = DROP_LEVEL;
  483:  op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity LOW_LEVEL_TRIGGER = dst_capacity * (1 - TRIGGER_LEVEL);
  484:  set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity   HIGH_LEVEL_TRIGGER = dst_capacity;  // never triggers
  485:  sensor .DST_X .CONTAINER @x                                  DST_X = DST.@x;
  486:  sensor .DST_Y .CONTAINER @y                                  DST_Y = DST.@y;
  487:  op sub *tmp254 .DST_X .SRC_X                                 DISTANCE = len(DST_X - SRC_X, DST_Y - SRC_Y) - RADIUS_APPROACH - RADIUS_WITHIN;
  488:  op sub *tmp255 .DST_Y .SRC_Y                                 ...
  489:  op len *tmp256 *tmp254 *tmp255                               ...
  490:  op sub .DISTANCE *tmp256 14                                  ...
  491:  op max *tmp259 .DISTANCE 10                                  TRAVEL_TIME = (2 * max(DISTANCE, 10)) / SPEED;   // Travel time: both ways, in tiles/ms
  492:  op mul *tmp260 2 *tmp259                                     ...
  493:  op div .TRAVEL_TIME *tmp260 .SPEED                           ...
  494:  set .MESSAGE "[salmon]Container filled up, switching...[]\n" MESSAGE = "[salmon]Container filled up, switching...[]\n";
  495:  op add .MESSAGE_TIMEOUT @tick 600                            MESSAGE_TIMEOUT = @tick + 600;      // Ten seconds
        label *label177                                              if CONTAINERS == 0 then
  496:  set :last_level :findAnotherContainer:min_level              last_level = this_level = findAnotherContainer();
        label *label165                                              if max_drop < DROP_PACK then
        label *label161                                              if CONTAINERS > 1 and SRC == CORE then
  497:  set :wait_time 0                                             wait_time = 0;
  498:  set :remote_wait_time 0                                      remote_wait_time = 0;
  499:  jump *label178 lessThan @tick .MESSAGE_TIMEOUT               if @tick >= MESSAGE_TIMEOUT then
  500:  set .MESSAGE ""                                              MESSAGE = "";
        label *label178                                              if @tick >= MESSAGE_TIMEOUT then
        label *label141                                              if transfers >= active or wait_time > WAIT_LIMIT then
  501:  print .MESSAGE                                               print(MESSAGE);
  502:  print "Moving [green]"                                       print($"Moving [green]$ITEM[]$DIRECTION$LINK_TXT");
  503:  print .ITEM                                                  ...
  504:  print "[]"                                                   ...
  505:  print .DIRECTION                                             ...
  506:  print *tmp97                                                 ...
  507:  print .AUTO_ALLOCATION_TXT                                   print(AUTO_ALLOCATION_TXT);
  508:  jump *label180 lessThanEq .TARGET 0                          if TARGET > 0 then
  509:  jump *label182 lessThan :active .TARGET                      if active >= TARGET then
  510:  print "\nUsing [green]"                                      print($"\nUsing [green]$active/$TARGET[] units ($UNIT) [gold]+$items_in_transit");
  511:  print :active                                                ...
  512:  print "/"                                                    ...
  513:  print .TARGET                                                ...
  514:  print "[] units ("                                           ...
  515:  print UNIT                                                   ...
  516:  print ") [gold]+"                                            ...
  517:  print :items_in_transit                                      ...
  518:  jump *label183 always 0 0                                    if active >= TARGET then
        label *label182                                              ...
  519:  print "\nUsing [salmon]"                                     print($"\nUsing [salmon]$active/$TARGET[] units ($UNIT) [gold]+$items_in_transit");
  520:  print :active                                                ...
  521:  print "/"                                                    ...
  522:  print .TARGET                                                ...
  523:  print "[] units ("                                           ...
  524:  print UNIT                                                   ...
  525:  print ") [gold]+"                                            ...
  526:  print :items_in_transit                                      ...
        label *label183                                              if active >= TARGET then
  527:  jump *label184 lessThanEq .CHANGE 0                          if CHANGE > 0 then
  528:  print "\n[][salmon]Cannot acquire additional units![]"       print("\n[][salmon]Cannot acquire additional units![]");
        label *label184                                              if CHANGE > 0 then
        label *label180                                              if TARGET > 0 then
  529:  print "\n[]Local items: [gold]"                              print($"\n[]Local items: [gold]$container_items");
  530:  print :container_items                                       ...
  531:  jump *label186 greaterThanEq .EFF_LOCAL_LIMIT 100            if EFF_LOCAL_LIMIT < 100 then
  532:  print "[] (limit [orange]"                                   print($"[] (limit [orange]$LOCAL_MARGIN[])");
  533:  print .LOCAL_MARGIN                                          ...
  534:  print "[])"                                                  ...
        label *label186                                              if EFF_LOCAL_LIMIT < 100 then
  535:  jump *label188 equal .SHOW_REMOTE_LEVEL false                if SHOW_REMOTE_LEVEL then
  536:  sensor :remote_level .CORE .ITEM                             remote_level = CORE.sensor(ITEM);
  537:  print "\n[]Remote items: [gold]"                             print($"\n[]Remote items: [gold]$remote_level");
  538:  print :remote_level                                          ...
  539:  jump *label190 greaterThanEq .EFF_REMOTE_LIMIT 100           if EFF_REMOTE_LIMIT < 100 then
  540:  print "[] (limit [orange]"                                   print($"[] (limit [orange]$REMOTE_MARGIN[])");
  541:  print .REMOTE_MARGIN                                         ...
  542:  print "[])"                                                  ...
        label *label190                                              if EFF_REMOTE_LIMIT < 100 then
        label *label188                                              if SHOW_REMOTE_LEVEL then
  543:  jump *label192 lessThanEq .TARGET 0                          if TARGET > 0 then
  544:  print "\n[]Speed: [green]"                                   print($"\n[]Speed: [green]$items_per_min$CORR_SIGN$corr_per_min$SPEED_UNIT_TXT");
  545:  print :items_per_min                                         ...
  546:  print .CORR_SIGN                                             ...
  547:  print :corr_per_min                                          ...
  548:  print .SPEED_UNIT_TXT                                        ...
  549:  jump *label194 equal .EFF_AUTO_ALLOCATION false              if EFF_AUTO_ALLOCATION then
  550:  print "\nUnit throughput: [green]"                           print($"\nUnit throughput: [green]$items_per_min_unit[]/min");
  551:  print :items_per_min_unit                                    ...
  552:  print "[]/min\nMin/last round: [green]"                      print($"\nMin/last round: [green]$turnaround_str[]/[green]$elapsed_str[] s");
  553:  print :turnaround_str                                        ...
  554:  print "[]/[green]"                                           ...
  555:  print :elapsed_str                                           ...
  556:  print "[] s"                                                 ...
  557:  jump *label195 always 0 0                                    if EFF_AUTO_ALLOCATION then
        label *label194                                              ...
  558:  print "\nLast round: [green]"                                print($"\nLast round: [green]$elapsed_str[] s");
  559:  print :elapsed_str                                           ...
  560:  print "[] s"                                                 ...
        label *label195                                              if EFF_AUTO_ALLOCATION then
  561:  print "\nTotal wait time: [green]"                           print($"\nTotal wait time: [green]$wait_time_str[] s");
  562:  print :wait_time_str                                         ...
  563:  print "[] s"                                                 ...
        label *label192                                              if TARGET > 0 then
  564:  print "\n[lightgray]Loop: "                                  print($"\n[lightgray]Loop: $loop_time_ms ms");
  565:  print :loop_time_ms                                          ...
  566:  print " ms"                                                  ...
  567:  printflush message1                                          printflush(message1);
  568:  op sub .CHANGE .TARGET :active                               CHANGE = TARGET - active;
  569:  set :active 0                                                active = 0;
  570:  set :first_unit @unit                                        first_unit = @unit;
  571:  set :items_in_transit 0                                      items_in_transit = 0;
  572:  print "Unit status:"                                         print("Unit status:");       // For message2
  573:  sensor *tmp282 .SRC @dead                                    if SRC.@dead != 0 then break; end;
  574:  jump *label86 notEqual *tmp282 0                             ...
  575:  sensor *tmp285 .DST @dead                                    if DST.@dead != 0 then break; end;
  576:  jump *label86 notEqual *tmp285 0                             ...
  577:  sensor *tmp288 .SORTER @dead                                 if SORTER.@dead != 0 then break; end;
  578:  jump *label86 notEqual *tmp288 0                             ...
  579:  getlink *tmp291 .CONTAINER_INDEX                             if CONTAINER != getlink(CONTAINER_INDEX) then break; end;
  580:  jump *label86 notEqual .CONTAINER *tmp291                    ...
        label *label98                                               if alive <= (@unit == first_unit) then
  581:  jump *label204 lessThanEq .CHANGE 0                          if CHANGE > 0 then
  582:  sensor *tmp296 @unit @controlled                             if @unit.@controlled == 0 then
  583:  jump *label206 notEqual *tmp296 0                            ...
  584:  op sub .CHANGE .CHANGE 1                                     CHANGE -= 1;
  585:  ucontrol flag 1 0 0 0 0                                      flag(S_FIRST);
        label *label206                                              if @unit.@controlled == 0 then
        label *label204                                              if CHANGE > 0 then
  586:  sensor *tmp299 @unit @controller                             if @unit.@controller == @this then
  587:  jump *label84 notEqual *tmp299 @this                         ...
  588:  sensor :state @unit @flag                                    state = @unit.@flag;
  589:  jump *label84 equal :state .S_UNUSED                         if state != S_UNUSED then
  590:  op max *tmp305 :state 1                                      state = min(max(state, S_FIRST), STATE_LIMIT);
  591:  op min :state *tmp305 .STATE_LIMIT                           ...
  592:  jump *label212 greaterThanEq .CHANGE 0                       if CHANGE < 0 then
  593:  jump *label214 equal :state 6                                if state != S_DISCARD then
  594:  sensor *tmp311 @unit @totalItems                             if @unit.@totalItems <= DISCARD_UNIT_MAX_ITEMS then
  595:  jump *label216 greaterThan *tmp311 .DISCARD_UNIT_MAX_ITEMS   ...
  596:  op add .CHANGE .CHANGE 1                                     CHANGE += 1;
  597:  set :state 6                                                 state = S_DISCARD;
        label *label216                                              if @unit.@totalItems <= DISCARD_UNIT_MAX_ITEMS then
        label *label214                                              if state != S_DISCARD then
        label *label212                                              if CHANGE < 0 then
  598:  jump *label218 notEqual :state 1                             if state == S_UNLOAD then
  599:  set :state 2                                                 state = S_APPROACH_SRC;
  600:  sensor *tmp316 @unit @totalItems                             if @unit.@totalItems == 0 then
  601:  jump *label221 equal *tmp316 0                               ...
  602:  set :state 4                                                 state = S_APPROACH_DST;
  603:  sensor *tmp319 @unit @firstItem                              elsif @unit.@firstItem == ITEM then
  604:  jump *label223 equal *tmp319 .ITEM                           ...
  605:  jump *label224 equal .DROP_TO_CORE false                     elsif DROP_TO_CORE then
  606:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  607:  ucontrol within .CORE_X .CORE_Y 8 *tmp323 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  608:  jump *label226 equal *tmp323 false                           ...
  609:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label226                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  610:  print "[]\nUnloading previous items: [green]"                print($"[]\nUnloading previous items: [green]");
  611:  jump *label225 always 0 0                                    elsif DROP_TO_CORE then
        label *label224                                              ...
  612:  ucontrol itemDrop @air .UNIT_CAPACITY 0 0 0                  itemDrop(@air, UNIT_CAPACITY);
  613:  set :state 2                                                 state = S_APPROACH_SRC;
        label *label225                                              elsif DROP_TO_CORE then
        label *label223                                              elsif @unit.@firstItem == ITEM then
        label *label221                                              if @unit.@totalItems == 0 then
        label *label218                                              if state == S_UNLOAD then
  614:  jump *label228 notEqual :state 2                             if state == S_APPROACH_SRC then
  615:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  616:  ucontrol within .SRC_X .SRC_Y 8 *tmp327 0                    if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
  617:  jump *label230 equal *tmp327 false                           ...
  618:  set :state 3                                                 state = S_LOAD_ITEMS;
  619:  jump *label231 always 0 0                                    if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label230                                              ...
  620:  sensor *tmp330 @unit @x                                      print($"[]\n[gold]$ sec[] to $name: [green]", len(x - @unit.@x, y - @unit.@y) \ SPEED_SEC / 10);
  621:  op sub *tmp331 .SRC_X *tmp330                                ...
  622:  sensor *tmp332 @unit @y                                      ...
  623:  op sub *tmp333 .SRC_Y *tmp332                                ...
  624:  op len *tmp334 *tmp331 *tmp333                               ...
  625:  op idiv *tmp335 *tmp334 .SPEED_SEC                           ...
  626:  op div *tmp336 *tmp335 10                                    ...
  627:  print "[]\n[gold]"                                           ...
  628:  print *tmp336                                                ...
  629:  print " sec[] to source: [green]"                            ...
        label *label231                                              if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label228                                              if state == S_APPROACH_SRC then
  630:  jump *label233 notEqual :state 3                             if state == S_LOAD_ITEMS then
  631:  sensor *tmp339 .SRC .ITEM                                    max_load = SRC.sensor(ITEM) - LOAD_LEVEL;
  632:  op sub :max_load *tmp339 .LOAD_LEVEL                         ...
  633:  jump *label235 lessThan :max_load .LOAD_PACK                 if max_load >= LOAD_PACK then
  634:  ucontrol itemTake .SRC .ITEM :max_load 0 0                   itemTake(SRC, ITEM, max_load);
        label *label235                                              if max_load >= LOAD_PACK then
  635:  sensor *tmp343 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  636:  jump *label237 lessThan *tmp343 .UNIT_CAPACITY               ...
  637:  set :state 4                                                 state = S_APPROACH_DST;
  638:  jump *label238 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label237                                              ...
  639:  print "[]\nWaiting at source: [green]"                       print($"[]\nWaiting at source: [green]");
  640:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  641:  op add :wait_time :wait_time :loop_time_ms                   wait_time += loop_time_ms;
  642:  op mul *tmp346 :loop_time_ms .SRC_REMOTE_WAIT                remote_wait_time += loop_time_ms * SRC_REMOTE_WAIT;
  643:  op add :remote_wait_time :remote_wait_time *tmp346           ...
        label *label238                                              if @unit.@totalItems >= UNIT_CAPACITY then
        label *label233                                              if state == S_LOAD_ITEMS then
  644:  jump *label239 notEqual :state 4                             if state == S_APPROACH_DST then
  645:  ucontrol approach .DST_X .DST_Y 6 0 0                        approach(DST_X, DST_Y, RADIUS_APPROACH);
  646:  ucontrol within .DST_X .DST_Y 8 *tmp349 0                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
  647:  jump *label241 equal *tmp349 false                           ...
  648:  sensor *tmp351 @unit @totalItems                             transferred += @unit.@totalItems;
  649:  op add :transferred :transferred *tmp351                     ...
  650:  op add :transfers :transfers 1                               transfers += 1;
  651:  set :state 5                                                 state = S_DROP_ITEMS;
  652:  jump *label242 always 0 0                                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label241                                              ...
  653:  sensor *tmp353 @unit @x                                      print($"[]\n[gold]$ sec[] to $name: [green]", len(x - @unit.@x, y - @unit.@y) \ SPEED_SEC / 10);
  654:  op sub *tmp354 .DST_X *tmp353                                ...
  655:  sensor *tmp355 @unit @y                                      ...
  656:  op sub *tmp356 .DST_Y *tmp355                                ...
  657:  op len *tmp357 *tmp354 *tmp356                               ...
  658:  op idiv *tmp358 *tmp357 .SPEED_SEC                           ...
  659:  op div *tmp359 *tmp358 10                                    ...
  660:  print "[]\n[gold]"                                           ...
  661:  print *tmp359                                                ...
  662:  print " sec[] to destination: [green]"                       ...
        label *label242                                              if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label239                                              if state == S_APPROACH_DST then
  663:  jump *label244 notEqual :state 5                             if state == S_DROP_ITEMS then
  664:  sensor *tmp362 .DST .ITEM                                    max_drop = DROP_LEVEL - DST.sensor(ITEM);
  665:  op sub :max_drop .DROP_LEVEL *tmp362                         ...
  666:  jump *label246 lessThan :max_drop .DROP_PACK                 if max_drop >= DROP_PACK then
  667:  ucontrol itemDrop .DST :max_drop 0 0 0                       itemDrop(DST, max_drop);
        label *label246                                              if max_drop >= DROP_PACK then
  668:  sensor *tmp366 @unit @totalItems                             if @unit.@totalItems <= 0 then
  669:  jump *label248 greaterThan *tmp366 0                         ...
  670:  set :state 2                                                 state = S_APPROACH_SRC;
  671:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  672:  sensor *tmp370 @unit @x                                      print($"[]\n[gold]$ sec[] to $name: [green]", len(x - @unit.@x, y - @unit.@y) \ SPEED_SEC / 10);
  673:  op sub *tmp371 .SRC_X *tmp370                                ...
  674:  sensor *tmp372 @unit @y                                      ...
  675:  op sub *tmp373 .SRC_Y *tmp372                                ...
  676:  op len *tmp374 *tmp371 *tmp373                               ...
  677:  op idiv *tmp375 *tmp374 .SPEED_SEC                           ...
  678:  op div *tmp376 *tmp375 10                                    ...
  679:  print "[]\n[gold]"                                           ...
  680:  print *tmp376                                                ...
  681:  print " sec[] to source: [green]"                            ...
  682:  jump *label249 always 0 0                                    if @unit.@totalItems <= 0 then
        label *label248                                              ...
  683:  print "[]\nWaiting at destination: [green]"                  print($"[]\nWaiting at destination: [green]");
  684:  ucontrol approach .DST_X .DST_Y 6 0 0                        approach(DST_X, DST_Y, RADIUS_APPROACH);
  685:  op add :wait_time :wait_time :loop_time_ms                   wait_time += loop_time_ms;
  686:  op mul *tmp377 :loop_time_ms .DST_REMOTE_WAIT                remote_wait_time += loop_time_ms * DST_REMOTE_WAIT;
  687:  op add :remote_wait_time :remote_wait_time *tmp377           ...
        label *label249                                              if @unit.@totalItems <= 0 then
        label *label244                                              if state == S_DROP_ITEMS then
  688:  sensor :items @unit @totalItems                              items = @unit.@totalItems;
  689:  op add :items_in_transit :items_in_transit :items            items_in_transit += items;
  690:  jump *label251 notEqual :state 6                             if state == S_DISCARD then
  691:  print "[]\nParking: [green]"                                 print($"[]\nParking: [green]");
  692:  jump *label253 lessThanEq :items 0                           if items > 0 then
  693:  jump *label255 equal .DROP_TO_CORE false                     if DROP_TO_CORE then
  694:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  695:  ucontrol within .CORE_X .CORE_Y 8 *tmp384 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  696:  jump *label256 equal *tmp384 false                           ...
  697:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
  698:  sensor :items @unit @totalItems                              items = @unit.@totalItems;
  699:  jump *label256 always 0 0                                    if DROP_TO_CORE then
        label *label255                                              ...
  700:  ucontrol itemDrop @air .UNIT_CAPACITY 0 0 0                  itemDrop(@air, UNIT_CAPACITY);
  701:  sensor :items @unit @totalItems                              items = @unit.@totalItems;
        label *label256                                              if DROP_TO_CORE then
        label *label253                                              if items > 0 then
  702:  jump *label252 greaterThan :items .PARK_ITEM_LIMIT           if items <= PARK_ITEM_LIMIT then
  703:  ucontrol move .PARK_X .PARK_Y 0 0 0                          move(PARK_X, PARK_Y);
  704:  set :state .S_UNUSED                                         state = S_UNUSED;
  705:  jump *label252 always 0 0                                    if state == S_DISCARD then
        label *label251                                              ...
  706:  op add :active :active 1                                     active += 1;
        label *label252                                              if state == S_DISCARD then
  707:  print :items                                                 print(items, ITEM_ICON);
  708:  print .ITEM_ICON                                             ...
  709:  ucontrol flag :state 0 0 0 0                                 flag(state);
  710:  jump *label84 always 0 0                                     while true do
        label *label86                                               ...
  711:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  712:  control enabled switch2 false 0 0 0                          switch2.enabled = false;


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   593     1x    593,0  <no function>
    52     1x     52,0  def itemTypeToIcon(in itemType)
    37     1x     37,0  def findAnotherContainer()
    30     3x     10,0  inline def printUnitInfo(in name, in x, in y)
     1     1x      1,0  inline void printflush()

Performance: parsed in 553 ms, compiled in 362 ms, optimized in 1,323 ms, run in 14 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (38 steps):
Configurable options:Which unit type to use:Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core:Start in auto allocation mode?Max units to use, in both manual and auto allocation modes:Leave discarded units with nonzero flag for housekeeping (flag-clearing) processor to pick them up:Drop superfluous items to air, even when there's a core:How much of local container capacity to use, in percents (20-100):How much of remote container capacity to use, in percents (20-100)Allocate at least this much more units than needed:Allocate at most this much more units than needed:Use average of last three flow rate values for better unit auto allocation stability:End of configurable options
Execution exception at instruction 37: ubind UNIT:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
