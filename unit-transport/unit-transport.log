  1258 instructions before optimizations.
   110 instructions eliminated by Temp Variables Elimination.
     3 instructions eliminated by Case Expression Optimization.
   141 instructions eliminated by Dead Code Elimination (7 iterations).
     5 instructions eliminated by Jump Normalization (6 iterations).
    62 instructions eliminated by Jump Optimization (6 iterations).
    59 instructions eliminated by Single Step Elimination (4 passes, 10 iterations).
     2 instructions eliminated by Expression Optimization (3 passes, 4 iterations).
     9 instructions eliminated by If Expression Optimization (2 passes, 4 iterations).
    45 instructions eliminated by Data Flow Optimization (4 passes, 17 iterations).
     1 loops improved by Loop Hoisting.
    11 instructions added by Loop Optimization (4 iterations).
    11 loops improved by Loop Optimization.
     2 instructions added by Case Switching (9 iterations).
     1 case expressions converted to switched jumps Case Switching.
    22 instructions eliminated by Jump Straightening (2 passes, 6 iterations).
     8 instructions updated by JumpThreading.
    21 instructions eliminated by Unreachable Code Elimination (2 iterations).
    56 instructions eliminated by Print Merging.
   736 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 184):
  * Replicate loop condition at line 156:9                       size    +1, benefit      312.5, efficiency    312.500 (+1 instructions)
    Replicate loop condition at line 160:9                       size    +4, benefit      312.5, efficiency     78.125
    Replicate loop condition at line 169:13                      size    +5, benefit      156.3, efficiency     31.250
    Replicate loop condition at line 189:1                       size    +3, benefit       25.0, efficiency      8.333
    Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
    Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 183):
  * Replicate loop condition at line 160:9                       size    +4, benefit      312.5, efficiency     78.125 (+4 instructions)
    Replicate loop condition at line 169:13                      size    +5, benefit      156.3, efficiency     31.250
    Replicate loop condition at line 189:1                       size    +3, benefit       25.0, efficiency      8.333
    Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
    Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 179):
  * Replicate loop condition at line 169:13                      size    +5, benefit      156.3, efficiency     31.250 (+5 instructions)
    Replicate loop condition at line 189:1                       size    +3, benefit       25.0, efficiency      8.333
    Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
    Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 174):
  * Replicate loop condition at line 189:1                       size    +3, benefit       25.0, efficiency      8.333 (+3 instructions)
  o Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
  o Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844

Pass 1: speed optimization selection (cost limit 171):
  o Convert case at line 704:5 (segments: 16)                    size    +1, benefit       27.0, efficiency     26.953
  * Convert case at line 704:5 (segments: 4)                     size    +2, benefit       29.7, efficiency     14.844 (+2 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-3 instructions):
 
   114 getlink *tmp27 :n
   115 set :block *tmp27
   116 sensor *tmp29 :block @type
-    * set *tmp30 *tmp29
-    * jump *label30 equal *tmp30 @vault
-    * jump *label30 equal *tmp30 @container
+  117 jump *label30 equal *tmp29 @vault
+  118 jump *label30 equal *tmp29 @container
   119 jump *label29 always
   120 label *label30
   121 set .CONTAINER :block
 
   554 set .LAST_ITEM .ITEM
   555 set :itemTypeToIcon:itemType .ITEM
   556 sensor *tmp160 :itemTypeToIcon:itemType @id
-    * set *tmp161 *tmp160
   557 sensor *tmp162 @blast-compound @id
-    * jump *label103 equal *tmp161 *tmp162
+  558 jump *label103 equal *tmp160 *tmp162
   559 jump *label102 always
   560 label *label103
   561 set *tmp159 "[]"
   562 jump *label101 always
   563 label *label102
   564 sensor *tmp163 @coal @id
-    * jump *label105 equal *tmp161 *tmp163
+  565 jump *label105 equal *tmp160 *tmp163
   566 jump *label104 always
   567 label *label105
   568 set *tmp159 "[]"
   569 jump *label101 always
   570 label *label104
   571 sensor *tmp164 @copper @id
-    * jump *label107 equal *tmp161 *tmp164
+  572 jump *label107 equal *tmp160 *tmp164
   573 jump *label106 always
   574 label *label107
   575 set *tmp159 "[]"
   576 jump *label101 always
   577 label *label106
   578 sensor *tmp165 @graphite @id
-    * jump *label109 equal *tmp161 *tmp165
+  579 jump *label109 equal *tmp160 *tmp165
   580 jump *label108 always
   581 label *label109
   582 set *tmp159 "[]"
   583 jump *label101 always
   584 label *label108
   585 sensor *tmp166 @lead @id
-    * jump *label111 equal *tmp161 *tmp166
+  586 jump *label111 equal *tmp160 *tmp166
   587 jump *label110 always
   588 label *label111
   589 set *tmp159 "[]"
   590 jump *label101 always
   591 label *label110
   592 sensor *tmp167 @metaglass @id
-    * jump *label113 equal *tmp161 *tmp167
+  593 jump *label113 equal *tmp160 *tmp167
   594 jump *label112 always
   595 label *label113
   596 set *tmp159 "[]"
   597 jump *label101 always
   598 label *label112
   599 sensor *tmp168 @phase-fabric @id
-    * jump *label115 equal *tmp161 *tmp168
+  600 jump *label115 equal *tmp160 *tmp168
   601 jump *label114 always
   602 label *label115
   603 set *tmp159 "[]"
   604 jump *label101 always
   605 label *label114
   606 sensor *tmp169 @plastanium @id
-    * jump *label117 equal *tmp161 *tmp169
+  607 jump *label117 equal *tmp160 *tmp169
   608 jump *label116 always
   609 label *label117
   610 set *tmp159 "[]"
   611 jump *label101 always
   612 label *label116
   613 sensor *tmp170 @pyratite @id
-    * jump *label119 equal *tmp161 *tmp170
+  614 jump *label119 equal *tmp160 *tmp170
   615 jump *label118 always
   616 label *label119
   617 set *tmp159 "[]"
   618 jump *label101 always
   619 label *label118
   620 sensor *tmp171 @sand @id
-    * jump *label121 equal *tmp161 *tmp171
+  621 jump *label121 equal *tmp160 *tmp171
   622 jump *label120 always
   623 label *label121
   624 set *tmp159 "[]"
   625 jump *label101 always
   626 label *label120
   627 sensor *tmp172 @scrap @id
-    * jump *label123 equal *tmp161 *tmp172
+  628 jump *label123 equal *tmp160 *tmp172
   629 jump *label122 always
   630 label *label123
   631 set *tmp159 "[]"
   632 jump *label101 always
   633 label *label122
   634 sensor *tmp173 @silicon @id
-    * jump *label125 equal *tmp161 *tmp173
+  635 jump *label125 equal *tmp160 *tmp173
   636 jump *label124 always
   637 label *label125
   638 set *tmp159 "[]"
   639 jump *label101 always
   640 label *label124
   641 sensor *tmp174 @spore-pod @id
-    * jump *label127 equal *tmp161 *tmp174
+  642 jump *label127 equal *tmp160 *tmp174
   643 jump *label126 always
   644 label *label127
   645 set *tmp159 "[]"
   646 jump *label101 always
   647 label *label126
   648 sensor *tmp175 @surge-alloy @id
-    * jump *label129 equal *tmp161 *tmp175
+  649 jump *label129 equal *tmp160 *tmp175
   650 jump *label128 always
   651 label *label129
   652 set *tmp159 "[]"
   653 jump *label101 always
   654 label *label128
   655 sensor *tmp176 @thorium @id
-    * jump *label131 equal *tmp161 *tmp176
+  656 jump *label131 equal *tmp160 *tmp176
   657 jump *label130 always
   658 label *label131
   659 set *tmp159 "[]"
   660 jump *label101 always
   661 label *label130
   662 sensor *tmp177 @titanium @id
-    * jump *label133 equal *tmp161 *tmp177
+  663 jump *label133 equal *tmp160 *tmp177
   664 jump *label132 always
   665 label *label133
   666 set *tmp159 "[]"
 
   845 getlink *tmp261 :findAnotherContainer:n
   846 set :findAnotherContainer:block *tmp261
   847 sensor *tmp263 :findAnotherContainer:block @type
-    * set *tmp264 *tmp263
-    * jump *label156 equal *tmp264 @vault
-    * jump *label156 equal *tmp264 @container
+  848 jump *label156 equal *tmp263 @vault
+  849 jump *label156 equal *tmp263 @container
   850 jump *label155 always
   851 label *label156
   852 op add .CONTAINERS .CONTAINERS 1

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-90 instructions):
 
    80 op lessThan *tmp17 :state 6
    81 op land *tmp18 *tmp16 *tmp17
    82 op add .TARGET .TARGET *tmp18
-    * set *tmp14 .TARGET
    83 jump *label21 always
    84 label *label20
-    * set *tmp14 null
    85 label *label21
    86 ubind UNIT
    87 label *label18
 
   119 set .CONTAINER :block
   120 op add .CONTAINERS .CONTAINERS 1
   121 set .CONTAINER_INDEX :n
-    * set *tmp28 .CONTAINER_INDEX
   122 jump *label28 always
   123 label *label29
-    * set *tmp28 null
   124 label *label28
   125 label *label26
   126 jump *label25 always
 
   129 jump *label31 equal *tmp31 false
   130 print "[salmon]No vault or container."
   131 printflush message1
-    * set *tmp32 null
   132 jump *label32 always
   133 label *label31
   134 jump *label24 always
-    * set *tmp32 null
   135 label *label32
   136 label *label23
   137 jump *label22 always
 
   151 ulocate building core false @copper .CORE_X .CORE_Y *tmp40 *tmp39
   152 set .CORE *tmp39
   153 ucontrol flag .S_UNUSED
-    * set *tmp38 null
   154 jump *label39 always
   155 label *label38
-    * set *tmp38 null
   156 label *label39
   157 label *label36
   158 jump *label35 always
 
   160 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   161 op equal *tmp41 DROP_TO_AIR false
   162 set .DROP_TO_CORE *tmp41
-    * set *tmp34 .DROP_TO_CORE
   163 jump *label34 always
   164 label *label33
   165 printflush message2
 
   233 label *label54
   234 set *tmp64 null
   235 label *label55
-    * set *tmp52 *tmp64
   236 jump *label50 always
   237 label *label49
-    * set *tmp52 null
   238 label *label50
   239 ucontrol flag .S_UNUSED
   240 label *label41
 
   248 label *label57
   249 set .DISCARD_UNIT_MAX_ITEMS *tmp65
   250 set .DROP_TO_CORE false
-    * set *tmp34 .DROP_TO_CORE
   251 label *label34
   252 set .SORTER sorter1
   253 sensor *tmp66 .SORTER @type
 
   263 jump *label61 equal *tmp70 false
   264 print "Block found: "
   265 print .SORTER
-    * set *tmp71 .SORTER
   266 jump *label62 always
   267 label *label61
-    * set *tmp71 null
   268 label *label62
   269 printflush message1
   270 set .SORTER sorter1
 
   306 set *tmp85 " from vault #"
   307 label *label66
   308 set .DIRECTION *tmp85
-    * set *tmp74 .DIRECTION
   309 jump *label64 always
   310 label *label63
   311 op greaterThan *tmp86 LINK_ID 0
 
   342 set *tmp99 " to vault #"
   343 label *label68
   344 set .DIRECTION *tmp99
-    * set *tmp74 .DIRECTION
   345 label *label64
   346 op equal *tmp100 LINK_ID 0
   347 jump *label69 equal *tmp100 false
 
   426 set :corr_per_min 0
   427 set .SPEED_UNIT_TXT "[])/min"
   428 set .AUTO_ALLOCATION_TXT "\n=== [gold]Gathering statistics[] ==="
-    * set *tmp130 .AUTO_ALLOCATION_TXT
   429 jump *label76 always
   430 label *label75
   431 set .CORR_SIGN "[]"
   432 set :corr_per_min ""
   433 set .SPEED_UNIT_TXT "/min"
   434 set .AUTO_ALLOCATION_TXT ""
-    * set *tmp130 .AUTO_ALLOCATION_TXT
   435 label *label76
   436 label *label77
   437 jump *label79 equal true false
 
   460 set :corr_per_min ""
   461 set .SPEED_UNIT_TXT "/min"
   462 set .WAIT_LIMIT 30000
-    * set *tmp133 .WAIT_LIMIT
   463 jump *label84 always
   464 label *label83
-    * set *tmp133 null
   465 label *label84
   466 sensor *tmp137 switch2 @enabled
   467 jump *label85 equal *tmp137 false
 
   475 set .CORR_SIGN "[]([green]+"
   476 set :corr_per_min 0
   477 set .SPEED_UNIT_TXT "[])/min"
-    * set *tmp141 .SPEED_UNIT_TXT
   478 jump *label88 always
   479 label *label87
   480 set .EFF_AUTO_ALLOCATION false
 
   492 set *tmp145 ""
   493 label *label90
   494 set .AUTO_ALLOCATION_TXT *tmp145
-    * set *tmp141 .AUTO_ALLOCATION_TXT
   495 label *label88
   496 set .WAIT_LIMIT 30000
-    * set *tmp138 .WAIT_LIMIT
   497 jump *label86 always
   498 label *label85
-    * set *tmp138 null
   499 label *label86
   500 sensor *tmp146 :first_unit @dead
   501 op equal *tmp147 *tmp146 0
 
   506 op equal *tmp151 :active 0
   507 jump *label93 equal *tmp151 false
   508 print "\n[salmon]No active units.[]"
-    * set *tmp152 "\n[salmon]No active units.[]"
   509 jump *label94 always
   510 label *label93
-    * set *tmp152 null
   511 label *label94
   512 printflush message2
   513 set .STATE_LIMIT 6
 
   650 set :last_level *tmp178
   651 set :min_level 999999
   652 set :max_level 0
-    * set *tmp155 :max_level
   653 jump *label96 always
   654 label *label95
-    * set *tmp155 null
   655 label *label96
   656 sensor *tmp179 .CONTAINER .ITEM
   657 set :container_items *tmp179
 
   744 op add *tmp229 *tmp228 :total_flow_1
   745 op div *tmp230 *tmp229 3
   746 set :total_flow_per_ms *tmp230
-    * set *tmp227 :total_flow_per_ms
   747 jump *label145 always
   748 label *label144
-    * set *tmp227 null
   749 label *label145
   750 op div *tmp231 :total_flow_per_ms :items_per_ms_unit
   751 op add *tmp232 *tmp231 .INC_OVERALLOCATION
 
   764 op lessThanEq *tmp240 :new_change 0
   765 op mul *tmp241 *tmp240 .DEC_MAX
   766 set .DEC_LIMIT *tmp241
-    * set *tmp226 .DEC_LIMIT
   767 jump *label143 always
   768 label *label142
   769 op idiv *tmp242 :wait_time .WAIT_LIMIT
 
   774 op mul *tmp246 *tmp245 .INC_MAX
   775 set .INC_LIMIT *tmp246
   776 set .DEC_LIMIT .DEC_MAX
-    * set *tmp226 .DEC_LIMIT
   777 label *label143
   778 op add *tmp247 :active :new_change
   779 op max *tmp248 *tmp247 1
   780 set .TARGET *tmp248
-    * set *tmp219 .TARGET
   781 jump *label141 always
   782 label *label140
   783 set .INC_LIMIT 0
   784 set .DEC_LIMIT 0
-    * set *tmp219 .DEC_LIMIT
   785 label *label141
   786 set :min_level 999999
   787 set :max_level 0
-    * set *tmp200 :max_level
   788 jump *label137 always
   789 label *label136
-    * set *tmp200 null
   790 label *label137
   791 op greaterThan *tmp249 .CONTAINERS 1
   792 op equal *tmp250 .SRC .CORE
 
   826 label *label157
   827 set *tmp267 null
   828 label *label158
-    * set *tmp262 *tmp267
   829 jump *label154 always
   830 label *label155
-    * set *tmp262 null
   831 label *label154
   832 label *label152
   833 jump *label151 always
 
   835 op equal *tmp268 .CONTAINERS 0
   836 jump *label159 equal *tmp268 false
   837 set .CONTAINER @this
-    * set *tmp269 .CONTAINER
   838 jump *label160 always
   839 label *label159
   840 set .DST .CONTAINER
 
   865 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   866 op add *tmp285 @tick 600
   867 set .MESSAGE_TIMEOUT *tmp285
-    * set *tmp269 .MESSAGE_TIMEOUT
   868 label *label160
   869 set *tmp257 :findAnotherContainer:min_level
   870 jump *label150 always
 
   877 label *label148
   878 set *tmp256 null
   879 label *label149
-    * set *tmp252 *tmp256
   880 jump *label147 always
   881 label *label146
-    * set *tmp252 null
   882 label *label147
   883 set :wait_time 0
   884 set :remote_wait_time 0
 
   890 label *label161
   891 set *tmp287 null
   892 label *label162
-    * set *tmp189 *tmp287
   893 jump *label135 always
   894 label *label134
-    * set *tmp189 null
   895 label *label135
   896 print .MESSAGE
   897 print "Moving [green]"
 
   916 print ")"
   917 print " [gold]+"
   918 print :items_in_transit
-    * set *tmp291 null
   919 jump *label166 always
   920 label *label165
   921 print "\n"
 
   929 print ")"
   930 print " [gold]+"
   931 print :items_in_transit
-    * set *tmp291 null
   932 label *label166
   933 op greaterThan *tmp292 .CHANGE 0
   934 jump *label167 equal *tmp292 false
 
   938 label *label167
   939 set *tmp293 null
   940 label *label168
-    * set *tmp289 *tmp293
   941 jump *label164 always
   942 label *label163
-    * set *tmp289 null
   943 label *label164
   944 print "\n"
   945 print "[]Local items: [gold]"
 
   950 print .LOCAL_MARGIN
   951 print "["
   952 print "])"
-    * set *tmp295 null
   953 jump *label170 always
   954 label *label169
-    * set *tmp295 null
   955 label *label170
   956 jump *label171 equal .SHOW_REMOTE_LEVEL false
   957 sensor *tmp297 .CORE .ITEM
 
   970 label *label173
   971 set *tmp299 null
   972 label *label174
-    * set *tmp296 *tmp299
   973 jump *label172 always
   974 label *label171
-    * set *tmp296 null
   975 label *label172
   976 op greaterThan *tmp300 .TARGET 0
   977 jump *label175 equal *tmp300 false
 
   995 print :elapsed_str
   996 print "["
   997 print "] s"
-    * set *tmp302 null
   998 jump *label178 always
   999 label *label177
  1000 print "\n"
 
  1002 print :elapsed_str
  1003 print "["
  1004 print "] s"
-    * set *tmp302 null
  1005 label *label178
  1006 print "\n"
  1007 print "Total wait time: [green]"
  1008 print :wait_time_str
  1009 print "["
  1010 print "] s"
-    * set *tmp301 null
  1011 jump *label176 always
  1012 label *label175
-    * set *tmp301 null
  1013 label *label176
  1014 print "\n"
  1015 print "[lightgray]Loop: "
 
  1028 op notEqual *tmp306 *tmp305 0
  1029 jump *label179 equal *tmp306 false
  1030 jump *label79 always
-    * set *tmp307 null
  1031 jump *label180 always
  1032 label *label179
-    * set *tmp307 null
  1033 label *label180
  1034 sensor *tmp308 .DST @dead
  1035 op notEqual *tmp309 *tmp308 0
  1036 jump *label181 equal *tmp309 false
  1037 jump *label79 always
-    * set *tmp310 null
  1038 jump *label182 always
  1039 label *label181
-    * set *tmp310 null
  1040 label *label182
  1041 sensor *tmp311 .SORTER @dead
  1042 op notEqual *tmp312 *tmp311 0
  1043 jump *label183 equal *tmp312 false
  1044 jump *label79 always
-    * set *tmp313 null
  1045 jump *label184 always
  1046 label *label183
-    * set *tmp313 null
  1047 label *label184
  1048 getlink *tmp314 .CONTAINER_INDEX
  1049 op notEqual *tmp315 .CONTAINER *tmp314
 
  1054 label *label185
  1055 set *tmp316 null
  1056 label *label186
-    * set *tmp150 *tmp316
  1057 jump *label92 always
  1058 label *label91
-    * set *tmp150 null
  1059 label *label92
  1060 op greaterThan *tmp317 .CHANGE 0
  1061 jump *label187 equal *tmp317 false
 
  1069 label *label189
  1070 set *tmp321 null
  1071 label *label190
-    * set *tmp318 *tmp321
  1072 jump *label188 always
  1073 label *label187
-    * set *tmp318 null
  1074 label *label188
  1075 sensor *tmp322 @unit @controller
  1076 op equal *tmp323 *tmp322 @this
 
  1101 label *label197
  1102 set *tmp333 null
  1103 label *label198
-    * set *tmp331 *tmp333
  1104 jump *label196 always
  1105 label *label195
-    * set *tmp331 null
  1106 label *label196
  1107 op equal *tmp337 :state 1
  1108 jump *label201 equal *tmp337 false
 
  1125 ucontrol within .CORE_X .CORE_Y 8 *tmp346
  1126 jump *label209 equal *tmp346 false
  1127 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp347 null
  1128 jump *label210 always
  1129 label *label209
-    * set *tmp347 null
  1130 label *label210
  1131 print "[]"
  1132 print "\n"
 
  1142 label *label206
  1143 set *tmp341 *tmp344
  1144 label *label204
-    * set *tmp338 *tmp341
  1145 jump *label202 always
  1146 label *label201
-    * set *tmp338 null
  1147 label *label202
  1148 op equal *tmp348 :state 2
  1149 jump *label211 equal *tmp348 false
 
  1189 label *label215
  1190 set *tmp351 *tmp352
  1191 label *label214
-    * set *tmp349 *tmp351
  1192 jump *label212 always
  1193 label *label211
-    * set *tmp349 null
  1194 label *label212
  1195 op equal *tmp361 :state 3
  1196 jump *label218 equal *tmp361 false
 
  1200 op greaterThanEq *tmp365 :max_load .LOAD_PACK
  1201 jump *label220 equal *tmp365 false
  1202 ucontrol itemTake .SRC .ITEM :max_load
-    * set *tmp366 null
  1203 jump *label221 always
  1204 label *label220
-    * set *tmp366 null
  1205 label *label221
  1206 sensor *tmp367 @unit @totalItems
  1207 op greaterThanEq *tmp368 *tmp367 .UNIT_CAPACITY
 
  1219 op add :remote_wait_time :remote_wait_time *tmp370
  1220 set *tmp369 :remote_wait_time
  1221 label *label223
-    * set *tmp362 *tmp369
  1222 jump *label219 always
  1223 label *label218
-    * set *tmp362 null
  1224 label *label219
  1225 op equal *tmp371 :state 4
  1226 jump *label224 equal *tmp371 false
 
  1269 label *label228
  1270 set *tmp374 *tmp376
  1271 label *label227
-    * set *tmp372 *tmp374
  1272 jump *label225 always
  1273 label *label224
-    * set *tmp372 null
  1274 label *label225
  1275 op equal *tmp385 :state 5
  1276 jump *label231 equal *tmp385 false
 
  1280 op greaterThanEq *tmp389 :max_drop .DROP_PACK
  1281 jump *label233 equal *tmp389 false
  1282 ucontrol itemDrop .DST :max_drop
-    * set *tmp390 null
  1283 jump *label234 always
  1284 label *label233
-    * set *tmp390 null
  1285 label *label234
  1286 sensor *tmp391 @unit @totalItems
  1287 op lessThanEq *tmp392 *tmp391 0
 
  1333 op add :remote_wait_time :remote_wait_time *tmp403
  1334 set *tmp393 :remote_wait_time
  1335 label *label236
-    * set *tmp386 *tmp393
  1336 jump *label232 always
  1337 label *label231
-    * set *tmp386 null
  1338 label *label232
  1339 sensor *tmp404 @unit @totalItems
  1340 set :items *tmp404
 
  1366 set :items *tmp413
  1367 set *tmp409 :items
  1368 label *label245
-    * set *tmp408 *tmp409
  1369 jump *label243 always
  1370 label *label242
-    * set *tmp408 null
  1371 label *label243
  1372 op lessThanEq *tmp414 :items .PARK_ITEM_LIMIT
  1373 jump *label248 equal *tmp414 false
 
  1378 label *label248
  1379 set *tmp415 null
  1380 label *label249
-    * set *tmp406 *tmp415
  1381 jump *label241 always
  1382 label *label240
  1383 op add :active :active 1
-    * set *tmp406 :active
  1384 label *label241
  1385 print :items
  1386 print .ITEM_ICON
 
  1390 label *label193
  1391 set *tmp327 null
  1392 label *label194
-    * set *tmp324 *tmp327
  1393 jump *label192 always
  1394 label *label191
-    * set *tmp324 null
  1395 label *label192
  1396 label *label78
  1397 jump *label77 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-34 instructions):
 
   228 print "is not a vault!"
   229 printflush message2
   230 set .CORE null
-    * set *tmp64 .CORE
   231 jump *label55 always
   232 label *label54
-    * set *tmp64 null
   233 label *label55
   234 jump *label50 always
   235 label *label49
 
   819 set :findAnotherContainer:min_level :findAnotherContainer:level
   820 set .CONTAINER :findAnotherContainer:block
   821 set .CONTAINER_INDEX :findAnotherContainer:n
-    * set *tmp267 .CONTAINER_INDEX
   822 jump *label158 always
   823 label *label157
-    * set *tmp267 null
   824 label *label158
   825 jump *label154 always
   826 label *label155
 
   868 label *label150
   869 set :this_level *tmp257
   870 set :last_level :this_level
-    * set *tmp256 :last_level
   871 jump *label149 always
   872 label *label148
-    * set *tmp256 null
   873 label *label149
   874 jump *label147 always
   875 label *label146
 
   879 op greaterThanEq *tmp286 @tick .MESSAGE_TIMEOUT
   880 jump *label161 equal *tmp286 false
   881 set .MESSAGE ""
-    * set *tmp287 .MESSAGE
   882 jump *label162 always
   883 label *label161
-    * set *tmp287 null
   884 label *label162
   885 jump *label135 always
   886 label *label134
 
   925 op greaterThan *tmp292 .CHANGE 0
   926 jump *label167 equal *tmp292 false
   927 print "\n[][salmon]Cannot acquire additional units![]"
-    * set *tmp293 "\n[][salmon]Cannot acquire additional units![]"
   928 jump *label168 always
   929 label *label167
-    * set *tmp293 null
   930 label *label168
   931 jump *label164 always
   932 label *label163
 
   955 print .REMOTE_MARGIN
   956 print "["
   957 print "])"
-    * set *tmp299 null
   958 jump *label174 always
   959 label *label173
-    * set *tmp299 null
   960 label *label174
   961 jump *label172 always
   962 label *label171
 
  1037 op notEqual *tmp315 .CONTAINER *tmp314
  1038 jump *label185 equal *tmp315 false
  1039 jump *label79 always
-    * set *tmp316 null
  1040 jump *label186 always
  1041 label *label185
-    * set *tmp316 null
  1042 label *label186
  1043 jump *label92 always
  1044 label *label91
 
  1050 jump *label189 equal *tmp320 false
  1051 op sub .CHANGE .CHANGE 1
  1052 ucontrol flag 1
-    * set *tmp321 null
  1053 jump *label190 always
  1054 label *label189
-    * set *tmp321 null
  1055 label *label190
  1056 jump *label188 always
  1057 label *label187
 
  1080 label *label199
  1081 set *tmp336 null
  1082 label *label200
-    * set *tmp333 *tmp336
  1083 jump *label198 always
  1084 label *label197
-    * set *tmp333 null
  1085 label *label198
  1086 jump *label196 always
  1087 label *label195
 
  1092 op equal *tmp340 *tmp339 0
  1093 jump *label203 equal *tmp340 false
  1094 set :state 2
-    * set *tmp341 :state
  1095 jump *label204 always
  1096 label *label203
  1097 sensor *tmp342 @unit @firstItem
 
  1121 label *label208
  1122 set *tmp344 *tmp345
  1123 label *label206
-    * set *tmp341 *tmp344
  1124 label *label204
  1125 jump *label202 always
  1126 label *label201
 
  1131 ucontrol within .SRC_X .SRC_Y 8 *tmp350
  1132 jump *label213 equal *tmp350 false
  1133 set :state 3
-    * set *tmp351 :state
  1134 jump *label214 always
  1135 label *label213
  1136 set :printUnitInfo:name "source"
 
  1166 label *label217
  1167 set *tmp352 *tmp353
  1168 label *label215
-    * set *tmp351 *tmp352
  1169 label *label214
  1170 jump *label212 always
  1171 label *label211
 
  1185 op greaterThanEq *tmp368 *tmp367 .UNIT_CAPACITY
  1186 jump *label222 equal *tmp368 false
  1187 set :state 4
-    * set *tmp369 :state
  1188 jump *label223 always
  1189 label *label222
  1190 print "[]"
 
  1194 op add :wait_time :wait_time :loop_time_ms
  1195 op mul *tmp370 :loop_time_ms .SRC_REMOTE_WAIT
  1196 op add :remote_wait_time :remote_wait_time *tmp370
-    * set *tmp369 :remote_wait_time
  1197 label *label223
  1198 jump *label219 always
  1199 label *label218
 
  1207 op add :transferred :transferred *tmp375
  1208 op add :transfers :transfers 1
  1209 set :state 5
-    * set *tmp374 :state
  1210 jump *label227 always
  1211 label *label226
  1212 set :printUnitInfo.1:name "destination"
 
  1242 label *label230
  1243 set *tmp376 *tmp377
  1244 label *label228
-    * set *tmp374 *tmp376
  1245 label *label227
  1246 jump *label225 always
  1247 label *label224
 
  1295 label *label239
  1296 set *tmp394 *tmp395
  1297 label *label237
-    * set *tmp393 *tmp394
  1298 jump *label236 always
  1299 label *label235
  1300 print "[]"
 
  1304 op add :wait_time :wait_time :loop_time_ms
  1305 op mul *tmp403 :loop_time_ms .DST_REMOTE_WAIT
  1306 op add :remote_wait_time :remote_wait_time *tmp403
-    * set *tmp393 :remote_wait_time
  1307 label *label236
  1308 jump *label232 always
  1309 label *label231
 
  1330 label *label246
  1331 set *tmp411 null
  1332 label *label247
-    * set *tmp409 *tmp411
  1333 jump *label245 always
  1334 label *label244
  1335 ucontrol itemDrop @air .UNIT_CAPACITY
  1336 sensor *tmp413 @unit @totalItems
  1337 set :items *tmp413
-    * set *tmp409 :items
  1338 label *label245
  1339 jump *label243 always
  1340 label *label242
 
  1343 jump *label248 equal *tmp414 false
  1344 ucontrol move .PARK_X .PARK_Y
  1345 set :state .S_UNUSED
-    * set *tmp415 :state
  1346 jump *label249 always
  1347 label *label248
-    * set *tmp415 null
  1348 label *label249
  1349 jump *label241 always
  1350 label *label240
 
  1353 print :items
  1354 print .ITEM_ICON
  1355 ucontrol flag :state
-    * set *tmp327 null
  1356 jump *label194 always
  1357 label *label193
-    * set *tmp327 null
  1358 label *label194
  1359 jump *label192 always
  1360 label *label191

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-9 instructions):
 
  1075 jump *label199 equal *tmp335 false
  1076 op add .CHANGE .CHANGE 1
  1077 set :state 6
-    * set *tmp336 :state
  1078 jump *label200 always
  1079 label *label199
-    * set *tmp336 null
  1080 label *label200
  1081 jump *label198 always
  1082 label *label197
 
  1096 op equal *tmp343 *tmp342 .ITEM
  1097 jump *label205 equal *tmp343 false
  1098 set :state 4
-    * set *tmp344 :state
  1099 jump *label206 always
  1100 label *label205
  1101 jump *label207 equal .DROP_TO_CORE false
 
  1116 set :state 2
  1117 set *tmp345 :state
  1118 label *label208
-    * set *tmp344 *tmp345
  1119 label *label206
  1120 label *label204
  1121 jump *label202 always
 
  1160 print " [green]"
  1161 set *tmp353 null
  1162 label *label217
-    * set *tmp352 *tmp353
  1163 label *label215
  1164 label *label214
  1165 jump *label212 always
 
  1235 print " [green]"
  1236 set *tmp377 null
  1237 label *label230
-    * set *tmp376 *tmp377
  1238 label *label228
  1239 label *label227
  1240 jump *label225 always
 
  1287 print " [green]"
  1288 set *tmp395 null
  1289 label *label239
-    * set *tmp394 *tmp395
  1290 label *label237
  1291 jump *label236 always
  1292 label *label235
 
  1318 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1319 sensor *tmp412 @unit @totalItems
  1320 set :items *tmp412
-    * set *tmp411 :items
  1321 jump *label247 always
  1322 label *label246
-    * set *tmp411 null
  1323 label *label247
  1324 jump *label245 always
  1325 label *label244

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
  1109 print "[]"
  1110 print "\n"
  1111 print "Unloading previous items: [green]"
-    * set *tmp345 null
  1112 jump *label208 always
  1113 label *label207
  1114 ucontrol itemDrop @air .UNIT_CAPACITY
  1115 set :state 2
-    * set *tmp345 :state
  1116 label *label208
  1117 label *label206
  1118 label *label204
 
  1147 print :printUnitInfo:name
  1148 print ":"
  1149 print " [green]"
-    * set *tmp353 null
  1150 jump *label217 always
  1151 label *label216
  1152 print "[]"
 
  1155 print :printUnitInfo:name
  1156 print ":"
  1157 print " [green]"
-    * set *tmp353 null
  1158 label *label217
  1159 label *label215
  1160 label *label214
 
  1220 print :printUnitInfo.1:name
  1221 print ":"
  1222 print " [green]"
-    * set *tmp377 null
  1223 jump *label230 always
  1224 label *label229
  1225 print "[]"
 
  1228 print :printUnitInfo.1:name
  1229 print ":"
  1230 print " [green]"
-    * set *tmp377 null
  1231 label *label230
  1232 label *label228
  1233 label *label227
 
  1270 print :printUnitInfo.2:name
  1271 print ":"
  1272 print " [green]"
-    * set *tmp395 null
  1273 jump *label239 always
  1274 label *label238
  1275 print "[]"
 
  1278 print :printUnitInfo.2:name
  1279 print ":"
  1280 print " [green]"
-    * set *tmp395 null
  1281 label *label239
  1282 label *label237
  1283 jump *label236 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-110 instructions):
 
    24 printflush null
    25 label *label13
    26 set .MESSAGE ""
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+   27 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+   28 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    29 set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION
    30 set .TRIGGER_LEVEL 0.9
-    * op mul *tmp2 -1 HOUSEKEEPING
-    * set .S_UNUSED *tmp2
+   31 op mul .S_UNUSED -1 HOUSEKEEPING
    32 set .STATE_LIMIT null
    33 set .ITEM_ICON .STATE_LIMIT
    34 set .ITEM .ITEM_ICON
 
    37 set .CONTAINER_INDEX .CORE_X
    38 set .LOOPS 1
    39 op mul *tmp3 .LOOPS 1000
-    * op div *tmp4 *tmp3 60
-    * set .LOOPS_TICKS_TO_MS *tmp4
+   40 op div .LOOPS_TICKS_TO_MS *tmp3 60
    41 set .INC_OVERALLOCATION OVERALLOCATION_LOW
-    * op add *tmp5 1 OVERALLOCATION_HIGH
-    * set .DEC_OVERALLOCATION *tmp5
+   42 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    43 set .TRIGGER_BOOST 2
    44 set .INC_MAX 6
    45 set .DEC_MAX -1
 
    56 label *label15
    57 jump *label14 always
    58 label *label16
-    * set *tmp7 @unit
-    * set :first_unit *tmp7
+   59 set :first_unit @unit
    60 sensor *tmp8 @unit @speed
-    * op div *tmp9 *tmp8 10
-    * set .SPEED_SEC *tmp9
+   61 op div .SPEED_SEC *tmp8 10
    62 sensor *tmp10 @unit @speed
-    * op div *tmp11 *tmp10 1000
-    * set .SPEED *tmp11
+   63 op div .SPEED *tmp10 1000
    64 set .TARGET 0
    65 label *label17
    66 sensor *tmp12 @unit @controller
    67 op equal *tmp13 *tmp12 @this
    68 jump *label20 equal *tmp13 false
-    * sensor *tmp15 @unit @flag
-    * set :state *tmp15
+   69 sensor :state @unit @flag
    70 op greaterThanEq *tmp16 :state 1
    71 op lessThan *tmp17 :state 6
    72 op land *tmp18 *tmp16 *tmp17
 
    86 set :active .TARGET
    87 set .DEC_LIMIT 0
    88 set .INC_LIMIT 0
-    * sensor *tmp23 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp23
+   89 sensor .UNIT_CAPACITY @unit @itemCapacity
    90 set :first_unit null
    91 label *label22
    92 jump *label24 equal true false
    93 set .CONTAINER null
    94 set .CONTAINERS 0
-    * set *tmp24 @links
-    * set :n *tmp24
+   95 set :n @links
    96 label *label25
    97 op greaterThan *tmp25 :n 0
    98 jump *label27 equal *tmp25 false
-    * op sub *tmp26 :n 1
-    * set :n *tmp26
-    * getlink *tmp27 :n
-    * set :block *tmp27
+   99 op sub :n :n 1
+  100 getlink :block :n
   101 sensor *tmp29 :block @type
   102 jump *label30 equal *tmp29 @vault
   103 jump *label30 equal *tmp29 @container
 
   135 sensor *tmp36 @unit @controlled
   136 op equal *tmp37 *tmp36 0
   137 jump *label38 equal *tmp37 false
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp40 *tmp39
-    * set .CORE *tmp39
+  138 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   139 ucontrol flag .S_UNUSED
   140 jump *label39 always
   141 label *label38
 
   144 jump *label35 always
   145 label *label37
   146 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
-    * op equal *tmp41 DROP_TO_AIR false
-    * set .DROP_TO_CORE *tmp41
+  147 op equal .DROP_TO_CORE DROP_TO_AIR false
   148 jump *label34 always
   149 label *label33
   150 printflush message2
 
   156 label *label40
   157 op equal *tmp42 .CORE null
   158 jump *label42 equal *tmp42 false
-    * op add *tmp43 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp43
+  159 op add .QUERY_FLAG 99999900 LINK_ID
   160 set :flag .QUERY_FLAG
   161 ubind UNIT
   162 label *label43
 
   175 op land *tmp49 *tmp46 *tmp48
   176 jump *label48 equal *tmp49 false
   177 ucontrol stop
-    * sensor *tmp50 @unit @flag
-    * set :flag *tmp50
+  178 sensor :flag @unit @flag
   179 label *label47
   180 jump *label46 always
   181 label *label48
   182 op notEqual *tmp51 :flag .QUERY_FLAG
   183 jump *label49 equal *tmp51 false
-    * op idiv *tmp53 :flag 100
-    * set :position *tmp53
-    * op mod *tmp54 :position @mapw
-    * set .CORE_X *tmp54
-    * op idiv *tmp55 :position @mapw
-    * set .CORE_Y *tmp55
+  184 op idiv :position :flag 100
+  185 op mod .CORE_X :position @mapw
+  186 op idiv .CORE_Y :position @mapw
   187 label *label51
   188 sensor *tmp56 @unit @dead
   189 op equal *tmp57 *tmp56 0
 
   195 label *label52
   196 jump *label51 always
   197 label *label53
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp61 *tmp62
-    * set .CORE *tmp61
+  198 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   199 op notEqual *tmp63 :b_type @vault
   200 jump *label54 equal *tmp63 false
   201 print "[salmon]Building at "
 
   227 set .DROP_TO_CORE false
   228 label *label34
   229 set .SORTER sorter1
-    * sensor *tmp66 .SORTER @type
-    * set :sorter_type *tmp66
+  230 sensor :sorter_type .SORTER @type
   231 label *label58
   232 op notEqual *tmp67 :sorter_type @sorter
   233 op notEqual *tmp68 :sorter_type @inverted-sorter
 
   244 label *label62
   245 printflush message1
   246 set .SORTER sorter1
-    * sensor *tmp72 .SORTER @type
-    * set :sorter_type *tmp72
+  247 sensor :sorter_type .SORTER @type
   248 label *label59
   249 jump *label58 always
   250 label *label60
 
   253 set .SHOW_REMOTE_LEVEL true
   254 set .SRC .CORE
   255 set .DST .CONTAINER
-    * sensor *tmp75 .SRC @itemCapacity
-    * set :src_capacity *tmp75
-    * sensor *tmp76 .DST @itemCapacity
-    * set :dst_capacity *tmp76
+  256 sensor :src_capacity .SRC @itemCapacity
+  257 sensor :dst_capacity .DST @itemCapacity
   258 op sub *tmp77 100 .EFF_REMOTE_LIMIT
   259 op mul *tmp78 :src_capacity *tmp77
-    * op idiv *tmp79 *tmp78 100
-    * set .LOAD_LEVEL *tmp79
+  260 op idiv .LOAD_LEVEL *tmp78 100
   261 op mul *tmp80 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp81 *tmp80 100
-    * set .DROP_LEVEL *tmp81
+  262 op idiv .DROP_LEVEL *tmp80 100
   263 set .LOCAL_MARGIN .DROP_LEVEL
   264 set .REMOTE_MARGIN .LOAD_LEVEL
   265 op sub *tmp82 1 .TRIGGER_LEVEL
-    * op mul *tmp83 :dst_capacity *tmp82
-    * set .LOW_LEVEL_TRIGGER *tmp83
+  266 op mul .LOW_LEVEL_TRIGGER :dst_capacity *tmp82
   267 set .HIGH_LEVEL_TRIGGER :dst_capacity
   268 set .FLOW_CORR_SIGN 1
   269 set .SRC_REMOTE_WAIT 1
 
   278 set .DIRECTION *tmp85
   279 jump *label64 always
   280 label *label63
-    * op greaterThan *tmp86 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp86
+  281 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   282 set .SRC .CONTAINER
   283 set .DST .CORE
-    * sensor *tmp87 .SRC @itemCapacity
-    * set :src_capacity *tmp87
-    * sensor *tmp88 .DST @itemCapacity
-    * set :dst_capacity *tmp88
+  284 sensor :src_capacity .SRC @itemCapacity
+  285 sensor :dst_capacity .DST @itemCapacity
   286 op sub *tmp89 100 .EFF_LOCAL_LIMIT
   287 op mul *tmp90 :src_capacity *tmp89
-    * op idiv *tmp91 *tmp90 100
-    * set .LOAD_LEVEL *tmp91
+  288 op idiv .LOAD_LEVEL *tmp90 100
   289 op mul *tmp92 :dst_capacity .EFF_REMOTE_LIMIT
   290 op idiv *tmp93 *tmp92 100
   291 op equal *tmp94 LINK_ID 0
   292 op mul *tmp95 *tmp94 .UNIT_CAPACITY
-    * op add *tmp96 *tmp93 *tmp95
-    * set .DROP_LEVEL *tmp96
+  293 op add .DROP_LEVEL *tmp93 *tmp95
   294 set .LOCAL_MARGIN .LOAD_LEVEL
   295 set .REMOTE_MARGIN .DROP_LEVEL
-    * op mul *tmp97 :src_capacity .TRIGGER_LEVEL
-    * set .HIGH_LEVEL_TRIGGER *tmp97
+  296 op mul .HIGH_LEVEL_TRIGGER :src_capacity .TRIGGER_LEVEL
   297 set .LOW_LEVEL_TRIGGER 0
   298 set .FLOW_CORR_SIGN -1
   299 set .SRC_REMOTE_WAIT 0
 
   316 label *label70
   317 set .LINK_TXT *tmp101
   318 op sub *tmp102 :src_capacity .LOAD_LEVEL
-    * op min *tmp103 .UNIT_CAPACITY *tmp102
-    * set .LOAD_PACK *tmp103
-    * op min *tmp104 .UNIT_CAPACITY .DROP_LEVEL
-    * set .DROP_PACK *tmp104
-    * sensor *tmp105 .SRC @x
-    * set .SRC_X *tmp105
-    * sensor *tmp106 .SRC @y
-    * set .SRC_Y *tmp106
-    * sensor *tmp107 .DST @x
-    * set .DST_X *tmp107
-    * sensor *tmp108 .DST @y
-    * set .DST_Y *tmp108
+  319 op min .LOAD_PACK .UNIT_CAPACITY *tmp102
+  320 op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL
+  321 sensor .SRC_X .SRC @x
+  322 sensor .SRC_Y .SRC @y
+  323 sensor .DST_X .DST @x
+  324 sensor .DST_Y .DST @y
   325 op sub *tmp109 .DST_X .SRC_X
   326 op sub *tmp110 .DST_Y .SRC_Y
   327 op len *tmp111 *tmp109 *tmp110
   328 op sub *tmp112 *tmp111 6
-    * op sub *tmp113 *tmp112 8
-    * set .DISTANCE *tmp113
+  329 op sub .DISTANCE *tmp112 8
   330 op max *tmp114 .DISTANCE 10
   331 op mul *tmp115 2 *tmp114
-    * op div *tmp116 *tmp115 .SPEED
-    * set .TRAVEL_TIME *tmp116
+  332 op div .TRAVEL_TIME *tmp115 .SPEED
   333 sensor *tmp117 .CONTAINER @x
   334 op lessThan *tmp118 *tmp117 .CORE_X
   335 jump *label71 equal *tmp118 false
 
   338 label *label71
   339 set *tmp119 -15
   340 label *label72
-    * op add *tmp120 .CORE_X *tmp119
-    * set .PARK_X *tmp120
+  341 op add .PARK_X .CORE_X *tmp119
   342 sensor *tmp121 .CONTAINER @y
   343 op lessThan *tmp122 *tmp121 .CORE_Y
   344 jump *label73 equal *tmp122 false
 
   347 label *label73
   348 set *tmp123 -15
   349 label *label74
-    * op add *tmp124 .CORE_Y *tmp123
-    * set .PARK_Y *tmp124
+  350 op add .PARK_Y .CORE_Y *tmp123
   351 op equal *tmp125 LINK_ID 0
-    * op mul *tmp126 *tmp125 .UNIT_CAPACITY
-    * set .PARK_ITEM_LIMIT *tmp126
-    * set *tmp127 @tick
-    * set .TRANSFER_START *tmp127
-    * op sub *tmp128 @tick 60
-    * set .LOOP_START *tmp128
+  352 op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY
+  353 set .TRANSFER_START @tick
+  354 op sub .LOOP_START @tick 60
   355 set .LAST_ITEM @mono
-    * op add *tmp129 @tick 600
-    * set .MESSAGE_TIMEOUT *tmp129
+  356 op add .MESSAGE_TIMEOUT @tick 600
   357 set .WAIT_LIMIT 30000
   358 set :items_in_transit 0
   359 set :items_per_min_unit "--"
 
   404 set .EFF_AUTO_ALLOCATION false
   405 set .AUTO_ALLOCATION_TXT ""
   406 op add *tmp135 .TARGET 1
-    * op min *tmp136 *tmp135 MAX_UNITS
-    * set .TARGET *tmp136
+  407 op min .TARGET *tmp135 MAX_UNITS
   408 set .CORR_SIGN "[]"
   409 set :corr_per_min ""
   410 set .SPEED_UNIT_TXT "/min"
 
   428 label *label87
   429 set .EFF_AUTO_ALLOCATION false
   430 op sub *tmp142 .TARGET 1
-    * op max *tmp143 *tmp142 0
-    * set .TARGET *tmp143
+  431 op max .TARGET *tmp142 0
   432 set .CORR_SIGN "[]"
   433 set :corr_per_min ""
   434 set .SPEED_UNIT_TXT "/min"
 
   446 label *label85
   447 label *label86
   448 sensor *tmp146 :first_unit @dead
-    * op equal *tmp147 *tmp146 0
-    * set :alive *tmp147
+  449 op equal :alive *tmp146 0
   450 op equal *tmp148 @unit :first_unit
   451 op lessThanEq *tmp149 :alive *tmp148
   452 jump *label91 equal *tmp149 false
 
   458 label *label94
   459 printflush message2
   460 set .STATE_LIMIT 6
-    * sensor *tmp153 .SORTER @config
-    * set .ITEM *tmp153
+  461 sensor .ITEM .SORTER @config
   462 op notEqual *tmp154 .ITEM .LAST_ITEM
   463 jump *label95 equal *tmp154 false
   464 label *label97
 
   466 jump *label99 equal *tmp156 false
   467 print "[salmon]No item type selected for transport.[]"
   468 printflush message1
-    * sensor *tmp157 .SORTER @config
-    * set .ITEM *tmp157
+  469 sensor .ITEM .SORTER @config
   470 label *label98
   471 jump *label97 always
   472 label *label99
 
   591 label *label100
   592 set .ITEM_ICON *tmp158
   593 set .STATE_LIMIT 1
-    * sensor *tmp178 .CONTAINER .ITEM
-    * set :last_level *tmp178
+  594 sensor :last_level .CONTAINER .ITEM
   595 set :min_level 999999
   596 set :max_level 0
   597 jump *label96 always
   598 label *label95
   599 label *label96
-    * sensor *tmp179 .CONTAINER .ITEM
-    * set :container_items *tmp179
-    * op min *tmp180 :min_level :container_items
-    * set :min_level *tmp180
-    * op max *tmp181 :max_level :container_items
-    * set :max_level *tmp181
-    * op sub *tmp182 @tick .LOOP_START
-    * set :loop_time *tmp182
-    * set *tmp183 @tick
-    * set .LOOP_START *tmp183
+  600 sensor :container_items .CONTAINER .ITEM
+  601 op min :min_level :min_level :container_items
+  602 op max :max_level :max_level :container_items
+  603 op sub :loop_time @tick .LOOP_START
+  604 set .LOOP_START @tick
   605 op mul *tmp184 :loop_time 100
-    * op idiv *tmp185 *tmp184 6
-    * set :loop_time_ms *tmp185
+  606 op idiv :loop_time_ms *tmp184 6
   607 op greaterThanEq *tmp186 :transfers :active
   608 op greaterThan *tmp187 :wait_time .WAIT_LIMIT
   609 op or *tmp188 *tmp186 *tmp187
   610 jump *label134 equal *tmp188 false
   611 op div *tmp190 :wait_time 100
   612 op ceil *tmp191 *tmp190
-    * op div *tmp192 *tmp191 10
-    * set :wait_time_str *tmp192
-    * op sub *tmp193 @tick .TRANSFER_START
-    * set :elapsed_ticks *tmp193
-    * set *tmp194 @tick
-    * set .TRANSFER_START *tmp194
-    * op div *tmp195 :elapsed_ticks 0.06
-    * set :elapsed_ms *tmp195
+  613 op div :wait_time_str *tmp191 10
+  614 op sub :elapsed_ticks @tick .TRANSFER_START
+  615 set .TRANSFER_START @tick
+  616 op div :elapsed_ms :elapsed_ticks 0.06
   617 op idiv *tmp196 :elapsed_ms 100
-    * op div *tmp197 *tmp196 10
-    * set :elapsed_str *tmp197
-    * op div *tmp198 :transferred :elapsed_ms
-    * set :items_per_ms *tmp198
-    * op idiv *tmp199 :items_per_ms 0.000016666666666666667
-    * set :items_per_min *tmp199
+  618 op div :elapsed_str *tmp196 10
+  619 op div :items_per_ms :transferred :elapsed_ms
+  620 op idiv :items_per_min :items_per_ms 0.000016666666666666667
   621 set :transferred 0
   622 set :transfers 0
   623 jump *label136 equal .EFF_AUTO_ALLOCATION false
   624 set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] ==="
   625 op mul *tmp201 .LOOPS_TICKS_TO_MS :loop_time
-    * op add *tmp202 .TRAVEL_TIME *tmp201
-    * set :turnaround_ms *tmp202
-    * op mul *tmp203 :turnaround_ms .DEC_OVERALLOCATION
-    * set .WAIT_LIMIT *tmp203
+  626 op add :turnaround_ms .TRAVEL_TIME *tmp201
+  627 op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION
   628 op idiv *tmp204 :turnaround_ms 100
-    * op div *tmp205 *tmp204 10
-    * set :turnaround_str *tmp205
-    * op div *tmp206 .UNIT_CAPACITY :turnaround_ms
-    * set :items_per_ms_unit *tmp206
+  629 op div :turnaround_str *tmp204 10
+  630 op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms
   631 op mul *tmp207 :items_per_ms_unit 60000
-    * op floor *tmp208 *tmp207
-    * set :items_per_min_unit *tmp208
+  632 op floor :items_per_min_unit *tmp207
   633 op add *tmp209 :min_level :max_level
-    * op div *tmp210 *tmp209 2
-    * set :this_level *tmp210
+  634 op div :this_level *tmp209 2
   635 op sub *tmp211 :last_level :this_level
-    * op mul *tmp212 *tmp211 .FLOW_CORR_SIGN
-    * set :corr *tmp212
-    * op div *tmp213 :corr :elapsed_ms
-    * set :corr_per_ms *tmp213
+  636 op mul :corr *tmp211 .FLOW_CORR_SIGN
+  637 op div :corr_per_ms :corr :elapsed_ms
   638 set :last_level :this_level
-    * op add *tmp214 :items_per_ms :corr_per_ms
-    * set :total_flow_per_ms *tmp214
+  639 op add :total_flow_per_ms :items_per_ms :corr_per_ms
   640 op mul *tmp215 60000 :corr_per_ms
-    * op floor *tmp216 *tmp215
-    * set :corr_per_min *tmp216
+  641 op floor :corr_per_min *tmp215
   642 op greaterThanEq *tmp217 :corr_per_min 0
   643 jump *label138 equal *tmp217 false
   644 set *tmp218 "[]([green]+"
 
   651 jump *label140 equal :alive false
   652 op lessThan *tmp220 :min_level .LOW_LEVEL_TRIGGER
   653 op greaterThan *tmp221 :max_level .HIGH_LEVEL_TRIGGER
-    * op or *tmp222 *tmp220 *tmp221
-    * set :trigger *tmp222
+  654 op or :trigger *tmp220 *tmp221
   655 op equal *tmp223 :wait_time 0
   656 op greaterThan *tmp224 :trigger :remote_wait_time
   657 op or *tmp225 *tmp223 *tmp224
 
   662 set :total_flow_1 :total_flow_per_ms
   663 op add *tmp228 :total_flow_3 :total_flow_2
   664 op add *tmp229 *tmp228 :total_flow_1
-    * op div *tmp230 *tmp229 3
-    * set :total_flow_per_ms *tmp230
+  665 op div :total_flow_per_ms *tmp229 3
   666 jump *label145 always
   667 label *label144
   668 label *label145
   669 op div *tmp231 :total_flow_per_ms :items_per_ms_unit
   670 op add *tmp232 *tmp231 .INC_OVERALLOCATION
-    * op ceil *tmp233 *tmp232
-    * set :new_target *tmp233
-    * op mul *tmp234 .TRIGGER_BOOST :trigger
-    * set :level_boost *tmp234
+  671 op ceil :new_target *tmp232
+  672 op mul :level_boost .TRIGGER_BOOST :trigger
   673 op add *tmp235 :new_target :level_boost
-    * op min *tmp236 *tmp235 MAX_UNITS
-    * set :new_target *tmp236
+  674 op min :new_target *tmp235 MAX_UNITS
   675 op sub *tmp237 :new_target :active
   676 op max *tmp238 *tmp237 0
-    * op min *tmp239 *tmp238 .INC_LIMIT
-    * set :new_change *tmp239
+  677 op min :new_change *tmp238 .INC_LIMIT
   678 set .INC_LIMIT .INC_MAX
   679 op lessThanEq *tmp240 :new_change 0
-    * op mul *tmp241 *tmp240 .DEC_MAX
-    * set .DEC_LIMIT *tmp241
+  680 op mul .DEC_LIMIT *tmp240 .DEC_MAX
   681 jump *label143 always
   682 label *label142
   683 op idiv *tmp242 :wait_time .WAIT_LIMIT
   684 op mul *tmp243 -1 *tmp242
-    * op max *tmp244 *tmp243 .DEC_LIMIT
-    * set :new_change *tmp244
+  685 op max :new_change *tmp243 .DEC_LIMIT
   686 op greaterThanEq *tmp245 :new_change 0
-    * op mul *tmp246 *tmp245 .INC_MAX
-    * set .INC_LIMIT *tmp246
+  687 op mul .INC_LIMIT *tmp245 .INC_MAX
   688 set .DEC_LIMIT .DEC_MAX
   689 label *label143
   690 op add *tmp247 :active :new_change
-    * op max *tmp248 *tmp247 1
-    * set .TARGET *tmp248
+  691 op max .TARGET *tmp247 1
   692 jump *label141 always
   693 label *label140
   694 set .INC_LIMIT 0
 
   704 op land *tmp251 *tmp249 *tmp250
   705 jump *label146 equal *tmp251 false
   706 sensor *tmp253 .DST .ITEM
-    * op sub *tmp254 .DROP_LEVEL *tmp253
-    * set :max_drop *tmp254
+  707 op sub :max_drop .DROP_LEVEL *tmp253
   708 op lessThan *tmp255 :max_drop .DROP_PACK
   709 jump *label148 equal *tmp255 false
   710 set :findAnotherContainer:min_level 999999
   711 set .CONTAINERS 0
-    * set *tmp258 @links
-    * set :findAnotherContainer:n *tmp258
+  712 set :findAnotherContainer:n @links
   713 label *label151
   714 op greaterThan *tmp259 :findAnotherContainer:n 0
   715 jump *label153 equal *tmp259 false
-    * op sub *tmp260 :findAnotherContainer:n 1
-    * set :findAnotherContainer:n *tmp260
-    * getlink *tmp261 :findAnotherContainer:n
-    * set :findAnotherContainer:block *tmp261
+  716 op sub :findAnotherContainer:n :findAnotherContainer:n 1
+  717 getlink :findAnotherContainer:block :findAnotherContainer:n
   718 sensor *tmp263 :findAnotherContainer:block @type
   719 jump *label156 equal *tmp263 @vault
   720 jump *label156 equal *tmp263 @container
   721 jump *label155 always
   722 label *label156
   723 op add .CONTAINERS .CONTAINERS 1
-    * sensor *tmp265 :findAnotherContainer:block .ITEM
-    * set :findAnotherContainer:level *tmp265
+  724 sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM
   725 op lessThan *tmp266 :findAnotherContainer:level :findAnotherContainer:min_level
   726 jump *label157 equal *tmp266 false
   727 set :findAnotherContainer:min_level :findAnotherContainer:level
 
   742 jump *label160 always
   743 label *label159
   744 set .DST .CONTAINER
-    * sensor *tmp270 .DST @itemCapacity
-    * set :findAnotherContainer:dst_capacity *tmp270
+  745 sensor :findAnotherContainer:dst_capacity .DST @itemCapacity
   746 op mul *tmp271 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp272 *tmp271 100
-    * set .DROP_LEVEL *tmp272
+  747 op idiv .DROP_LEVEL *tmp271 100
   748 set .LOCAL_MARGIN .DROP_LEVEL
   749 op sub *tmp273 1 .TRIGGER_LEVEL
-    * op mul *tmp274 :findAnotherContainer:dst_capacity *tmp273
-    * set .LOW_LEVEL_TRIGGER *tmp274
+  750 op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity *tmp273
   751 set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
-    * sensor *tmp275 .DST @x
-    * set .DST_X *tmp275
-    * sensor *tmp276 .DST @y
-    * set .DST_Y *tmp276
+  752 sensor .DST_X .DST @x
+  753 sensor .DST_Y .DST @y
   754 op sub *tmp277 .DST_X .SRC_X
   755 op sub *tmp278 .DST_Y .SRC_Y
   756 op len *tmp279 *tmp277 *tmp278
   757 op sub *tmp280 *tmp279 6
-    * op sub *tmp281 *tmp280 8
-    * set .DISTANCE *tmp281
+  758 op sub .DISTANCE *tmp280 8
   759 op max *tmp282 .DISTANCE 10
   760 op mul *tmp283 2 *tmp282
-    * op div *tmp284 *tmp283 .SPEED
-    * set .TRAVEL_TIME *tmp284
+  761 op div .TRAVEL_TIME *tmp283 .SPEED
   762 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
-    * op add *tmp285 @tick 600
-    * set .MESSAGE_TIMEOUT *tmp285
+  763 op add .MESSAGE_TIMEOUT @tick 600
   764 label *label160
   765 set *tmp257 :findAnotherContainer:min_level
   766 jump *label150 always
 
   844 label *label169
   845 label *label170
   846 jump *label171 equal .SHOW_REMOTE_LEVEL false
-    * sensor *tmp297 .CORE .ITEM
-    * set :remote_level *tmp297
+  847 sensor :remote_level .CORE .ITEM
   848 print "\n"
   849 print "[]Remote items: [gold]"
   850 print :remote_level
 
   904 print " "
   905 print "ms"
   906 printflush message1
-    * op sub *tmp303 .TARGET :active
-    * set .CHANGE *tmp303
+  907 op sub .CHANGE .TARGET :active
   908 set :active 0
-    * set *tmp304 @unit
-    * set :first_unit *tmp304
+  909 set :first_unit @unit
   910 set :items_in_transit 0
   911 print "Unit status:"
   912 sensor *tmp305 .SRC @dead
 
   956 sensor *tmp322 @unit @controller
   957 op equal *tmp323 *tmp322 @this
   958 jump *label191 equal *tmp323 false
-    * sensor *tmp325 @unit @flag
-    * set :state *tmp325
+  959 sensor :state @unit @flag
   960 op notEqual *tmp326 :state .S_UNUSED
   961 jump *label193 equal *tmp326 false
   962 op max *tmp328 :state 1
-    * op min *tmp329 *tmp328 .STATE_LIMIT
-    * set :state *tmp329
+  963 op min :state *tmp328 .STATE_LIMIT
   964 op lessThan *tmp330 .CHANGE 0
   965 jump *label195 equal *tmp330 false
   966 op notEqual *tmp332 :state 6
 
  1059 op equal *tmp361 :state 3
  1060 jump *label218 equal *tmp361 false
  1061 sensor *tmp363 .SRC .ITEM
-    * op sub *tmp364 *tmp363 .LOAD_LEVEL
-    * set :max_load *tmp364
+ 1062 op sub :max_load *tmp363 .LOAD_LEVEL
  1063 op greaterThanEq *tmp365 :max_load .LOAD_PACK
  1064 jump *label220 equal *tmp365 false
  1065 ucontrol itemTake .SRC .ITEM :max_load
 
  1131 op equal *tmp385 :state 5
  1132 jump *label231 equal *tmp385 false
  1133 sensor *tmp387 .DST .ITEM
-    * op sub *tmp388 .DROP_LEVEL *tmp387
-    * set :max_drop *tmp388
+ 1134 op sub :max_drop .DROP_LEVEL *tmp387
  1135 op greaterThanEq *tmp389 :max_drop .DROP_PACK
  1136 jump *label233 equal *tmp389 false
  1137 ucontrol itemDrop .DST :max_drop
 
  1186 jump *label232 always
  1187 label *label231
  1188 label *label232
-    * sensor *tmp404 @unit @totalItems
-    * set :items *tmp404
+ 1189 sensor :items @unit @totalItems
  1190 op add :items_in_transit :items_in_transit :items
  1191 op equal *tmp405 :state 6
  1192 jump *label240 equal *tmp405 false
 
  1200 ucontrol within .CORE_X .CORE_Y 8 *tmp410
  1201 jump *label246 equal *tmp410 false
  1202 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * sensor *tmp412 @unit @totalItems
-    * set :items *tmp412
+ 1203 sensor :items @unit @totalItems
  1204 jump *label247 always
  1205 label *label246
  1206 label *label247
  1207 jump *label245 always
  1208 label *label244
  1209 ucontrol itemDrop @air .UNIT_CAPACITY
-    * sensor *tmp413 @unit @totalItems
-    * set :items *tmp413
+ 1210 sensor :items @unit @totalItems
  1211 label *label245
  1212 jump *label243 always
  1213 label *label242

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-5 instructions):
 
    89 sensor .UNIT_CAPACITY @unit @itemCapacity
    90 set :first_unit null
    91 label *label22
-    * jump *label24 equal true false
    92 set .CONTAINER null
    93 set .CONTAINERS 0
    94 set :n @links
 
   383 set .AUTO_ALLOCATION_TXT ""
   384 label *label76
   385 label *label77
-    * jump *label79 equal true false
   386 ubind UNIT
   387 label *label80
   388 op equal *tmp131 @unit null
 
  1023 set :printUnitInfo:name "source"
  1024 set :printUnitInfo:x .SRC_X
  1025 set :printUnitInfo:y .SRC_Y
-    * jump *label216 equal true false
  1026 sensor *tmp354 @unit @x
  1027 op sub *tmp355 :printUnitInfo:x *tmp354
  1028 sensor *tmp356 @unit @y
 
  1094 set :printUnitInfo.1:name "destination"
  1095 set :printUnitInfo.1:x .DST_X
  1096 set :printUnitInfo.1:y .DST_Y
-    * jump *label229 equal true false
  1097 sensor *tmp378 @unit @x
  1098 op sub *tmp379 :printUnitInfo.1:x *tmp378
  1099 sensor *tmp380 @unit @y
 
  1142 set :printUnitInfo.2:name "source"
  1143 set :printUnitInfo.2:x .SRC_X
  1144 set :printUnitInfo.2:y .SRC_Y
-    * jump *label238 equal true false
  1145 sensor *tmp396 @unit @x
  1146 op sub *tmp397 :printUnitInfo.2:x *tmp396
  1147 sensor *tmp398 @unit @y

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-18 instructions):
 
    99 getlink :block :n
   100 sensor *tmp29 :block @type
   101 jump *label30 equal *tmp29 @vault
-    * jump *label30 equal *tmp29 @container
-    * jump *label29 always
+  102 jump *label29 notEqual *tmp29 @container
   103 label *label30
   104 set .CONTAINER :block
   105 op add .CONTAINERS .CONTAINERS 1
 
   471 set :itemTypeToIcon:itemType .ITEM
   472 sensor *tmp160 :itemTypeToIcon:itemType @id
   473 sensor *tmp162 @blast-compound @id
-    * jump *label103 equal *tmp160 *tmp162
-    * jump *label102 always
+  474 jump *label102 notEqual *tmp160 *tmp162
   475 label *label103
   476 set *tmp159 "[]"
   477 jump *label101 always
   478 label *label102
   479 sensor *tmp163 @coal @id
-    * jump *label105 equal *tmp160 *tmp163
-    * jump *label104 always
+  480 jump *label104 notEqual *tmp160 *tmp163
   481 label *label105
   482 set *tmp159 "[]"
   483 jump *label101 always
   484 label *label104
   485 sensor *tmp164 @copper @id
-    * jump *label107 equal *tmp160 *tmp164
-    * jump *label106 always
+  486 jump *label106 notEqual *tmp160 *tmp164
   487 label *label107
   488 set *tmp159 "[]"
   489 jump *label101 always
   490 label *label106
   491 sensor *tmp165 @graphite @id
-    * jump *label109 equal *tmp160 *tmp165
-    * jump *label108 always
+  492 jump *label108 notEqual *tmp160 *tmp165
   493 label *label109
   494 set *tmp159 "[]"
   495 jump *label101 always
   496 label *label108
   497 sensor *tmp166 @lead @id
-    * jump *label111 equal *tmp160 *tmp166
-    * jump *label110 always
+  498 jump *label110 notEqual *tmp160 *tmp166
   499 label *label111
   500 set *tmp159 "[]"
   501 jump *label101 always
   502 label *label110
   503 sensor *tmp167 @metaglass @id
-    * jump *label113 equal *tmp160 *tmp167
-    * jump *label112 always
+  504 jump *label112 notEqual *tmp160 *tmp167
   505 label *label113
   506 set *tmp159 "[]"
   507 jump *label101 always
   508 label *label112
   509 sensor *tmp168 @phase-fabric @id
-    * jump *label115 equal *tmp160 *tmp168
-    * jump *label114 always
+  510 jump *label114 notEqual *tmp160 *tmp168
   511 label *label115
   512 set *tmp159 "[]"
   513 jump *label101 always
   514 label *label114
   515 sensor *tmp169 @plastanium @id
-    * jump *label117 equal *tmp160 *tmp169
-    * jump *label116 always
+  516 jump *label116 notEqual *tmp160 *tmp169
   517 label *label117
   518 set *tmp159 "[]"
   519 jump *label101 always
   520 label *label116
   521 sensor *tmp170 @pyratite @id
-    * jump *label119 equal *tmp160 *tmp170
-    * jump *label118 always
+  522 jump *label118 notEqual *tmp160 *tmp170
   523 label *label119
   524 set *tmp159 "[]"
   525 jump *label101 always
   526 label *label118
   527 sensor *tmp171 @sand @id
-    * jump *label121 equal *tmp160 *tmp171
-    * jump *label120 always
+  528 jump *label120 notEqual *tmp160 *tmp171
   529 label *label121
   530 set *tmp159 "[]"
   531 jump *label101 always
   532 label *label120
   533 sensor *tmp172 @scrap @id
-    * jump *label123 equal *tmp160 *tmp172
-    * jump *label122 always
+  534 jump *label122 notEqual *tmp160 *tmp172
   535 label *label123
   536 set *tmp159 "[]"
   537 jump *label101 always
   538 label *label122
   539 sensor *tmp173 @silicon @id
-    * jump *label125 equal *tmp160 *tmp173
-    * jump *label124 always
+  540 jump *label124 notEqual *tmp160 *tmp173
   541 label *label125
   542 set *tmp159 "[]"
   543 jump *label101 always
   544 label *label124
   545 sensor *tmp174 @spore-pod @id
-    * jump *label127 equal *tmp160 *tmp174
-    * jump *label126 always
+  546 jump *label126 notEqual *tmp160 *tmp174
   547 label *label127
   548 set *tmp159 "[]"
   549 jump *label101 always
   550 label *label126
   551 sensor *tmp175 @surge-alloy @id
-    * jump *label129 equal *tmp160 *tmp175
-    * jump *label128 always
+  552 jump *label128 notEqual *tmp160 *tmp175
   553 label *label129
   554 set *tmp159 "[]"
   555 jump *label101 always
   556 label *label128
   557 sensor *tmp176 @thorium @id
-    * jump *label131 equal *tmp160 *tmp176
-    * jump *label130 always
+  558 jump *label130 notEqual *tmp160 *tmp176
   559 label *label131
   560 set *tmp159 "[]"
   561 jump *label101 always
   562 label *label130
   563 sensor *tmp177 @titanium @id
-    * jump *label133 equal *tmp160 *tmp177
-    * jump *label132 always
+  564 jump *label132 notEqual *tmp160 *tmp177
   565 label *label133
   566 set *tmp159 "[]"
   567 jump *label101 always
 
   698 getlink :findAnotherContainer:block :findAnotherContainer:n
   699 sensor *tmp263 :findAnotherContainer:block @type
   700 jump *label156 equal *tmp263 @vault
-    * jump *label156 equal *tmp263 @container
-    * jump *label155 always
+  701 jump *label155 notEqual *tmp263 @container
   702 label *label156
   703 op add .CONTAINERS .CONTAINERS 1
   704 sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-62 instructions):
 
    45 set .DEC_MAX -1
    46 ubind UNIT
    47 label *label14
-    * op equal *tmp6 @unit null
-    * jump *label16 equal *tmp6 false
+   48 jump *label16 notEqual @unit null
    49 print "[salmon]No unit of type "
    50 print UNIT
    51 print " "
 
    63 set .TARGET 0
    64 label *label17
    65 sensor *tmp12 @unit @controller
-    * op equal *tmp13 *tmp12 @this
-    * jump *label20 equal *tmp13 false
+   66 jump *label20 notEqual *tmp12 @this
    67 sensor :state @unit @flag
    68 op greaterThanEq *tmp16 :state 1
    69 op lessThan *tmp17 :state 6
 
    91 set .CONTAINERS 0
    92 set :n @links
    93 label *label25
-    * op greaterThan *tmp25 :n 0
-    * jump *label27 equal *tmp25 false
+   94 jump *label27 lessThanEq :n 0
    95 op sub :n :n 1
    96 getlink :block :n
    97 sensor *tmp29 :block @type
 
   107 label *label26
   108 jump *label25 always
   109 label *label27
-    * op equal *tmp31 .CONTAINER null
-    * jump *label31 equal *tmp31 false
+  110 jump *label31 notEqual .CONTAINER null
   111 print "[salmon]No vault or container."
   112 printflush message1
   113 jump *label32 always
 
   118 jump *label22 always
   119 label *label24
   120 set .CORE null
-    * op equal *tmp33 LINK_ID 0
-    * jump *label33 equal *tmp33 false
+  121 jump *label33 notEqual LINK_ID 0
   122 label *label35
-    * op equal *tmp35 .CORE null
-    * jump *label37 equal *tmp35 false
+  123 jump *label37 notEqual .CORE null
   124 print "[green]Locating core..."
   125 printflush message1
   126 ubind UNIT
   127 sensor *tmp36 @unit @controlled
-    * op equal *tmp37 *tmp36 0
-    * jump *label38 equal *tmp37 false
+  128 jump *label38 notEqual *tmp36 0
   129 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   130 ucontrol flag .S_UNUSED
   131 jump *label39 always
 
   145 print ".."
   146 printflush message1
   147 label *label40
-    * op equal *tmp42 .CORE null
-    * jump *label42 equal *tmp42 false
+  148 jump *label42 notEqual .CORE null
   149 op add .QUERY_FLAG 99999900 LINK_ID
   150 set :flag .QUERY_FLAG
   151 ubind UNIT
   152 label *label43
   153 sensor *tmp44 @unit @controlled
-    * op notEqual *tmp45 *tmp44 0
-    * jump *label45 equal *tmp45 false
+  154 jump *label45 equal *tmp44 0
   155 ubind UNIT
   156 label *label44
   157 jump *label43 always
 
   168 label *label47
   169 jump *label46 always
   170 label *label48
-    * op notEqual *tmp51 :flag .QUERY_FLAG
-    * jump *label49 equal *tmp51 false
+  171 jump *label49 equal :flag .QUERY_FLAG
   172 op idiv :position :flag 100
   173 op mod .CORE_X :position @mapw
   174 op idiv .CORE_Y :position @mapw
 
   184 jump *label51 always
   185 label *label53
   186 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
-    * op notEqual *tmp63 :b_type @vault
-    * jump *label54 equal *tmp63 false
+  187 jump *label54 equal :b_type @vault
   188 print "[salmon]Building at "
   189 print .CORE_X
   190 print ","
 
   222 jump *label60 equal *tmp69 false
   223 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   224 print "\n"
-    * op notEqual *tmp70 .SORTER null
-    * jump *label61 equal *tmp70 false
+  225 jump *label61 equal .SORTER null
   226 print "Block found: "
   227 print .SORTER
   228 jump *label62 always
 
   234 label *label59
   235 jump *label58 always
   236 label *label60
-    * op equal *tmp73 :sorter_type @sorter
-    * jump *label63 equal *tmp73 false
+  237 jump *label63 notEqual :sorter_type @sorter
   238 set .SHOW_REMOTE_LEVEL true
   239 set .SRC .CORE
   240 set .DST .CONTAINER
 
   253 set .FLOW_CORR_SIGN 1
   254 set .SRC_REMOTE_WAIT 1
   255 set .DST_REMOTE_WAIT 0
-    * op equal *tmp84 LINK_ID 0
-    * jump *label65 equal *tmp84 false
+  256 jump *label65 notEqual LINK_ID 0
   257 set *tmp85 " from core"
   258 jump *label66 always
   259 label *label65
 
   282 set .FLOW_CORR_SIGN -1
   283 set .SRC_REMOTE_WAIT 0
   284 set .DST_REMOTE_WAIT 1
-    * op equal *tmp98 LINK_ID 0
-    * jump *label67 equal *tmp98 false
+  285 jump *label67 notEqual LINK_ID 0
   286 set *tmp99 " to core"
   287 jump *label68 always
   288 label *label67
 
   290 label *label68
   291 set .DIRECTION *tmp99
   292 label *label64
-    * op equal *tmp100 LINK_ID 0
-    * jump *label69 equal *tmp100 false
+  293 jump *label69 notEqual LINK_ID 0
   294 set *tmp101 ""
   295 jump *label70 always
   296 label *label69
 
   313 op mul *tmp115 2 *tmp114
   314 op div .TRAVEL_TIME *tmp115 .SPEED
   315 sensor *tmp117 .CONTAINER @x
-    * op lessThan *tmp118 *tmp117 .CORE_X
-    * jump *label71 equal *tmp118 false
+  316 jump *label71 greaterThanEq *tmp117 .CORE_X
   317 set *tmp119 15
   318 jump *label72 always
   319 label *label71
 
   321 label *label72
   322 op add .PARK_X .CORE_X *tmp119
   323 sensor *tmp121 .CONTAINER @y
-    * op lessThan *tmp122 *tmp121 .CORE_Y
-    * jump *label73 equal *tmp122 false
+  324 jump *label73 greaterThanEq *tmp121 .CORE_Y
   325 set *tmp123 15
   326 jump *label74 always
   327 label *label73
 
   366 label *label77
   367 ubind UNIT
   368 label *label80
-    * op equal *tmp131 @unit null
-    * jump *label82 equal *tmp131 false
+  369 jump *label82 notEqual @unit null
   370 print "No unit of type "
   371 print UNIT
   372 print " "
 
   393 sensor *tmp137 switch2 @enabled
   394 jump *label85 equal *tmp137 false
   395 control enabled switch2 false
-    * op lessThan *tmp140 .TARGET 1
-    * jump *label87 equal *tmp140 false
+  396 jump *label87 greaterThanEq .TARGET 1
   397 set .EFF_AUTO_ALLOCATION true
   398 set .TARGET 1
   399 set .DEC_LIMIT 0
 
   409 set .CORR_SIGN "[]"
   410 set :corr_per_min ""
   411 set .SPEED_UNIT_TXT "/min"
-    * op equal *tmp144 .TARGET 0
-    * jump *label89 equal *tmp144 false
+  412 jump *label89 notEqual .TARGET 0
   413 set *tmp145 "\n=== [salmon]Transport deactivated[] ==="
   414 jump *label90 always
   415 label *label89
 
   424 sensor *tmp146 :first_unit @dead
   425 op equal :alive *tmp146 0
   426 op equal *tmp148 @unit :first_unit
-    * op lessThanEq *tmp149 :alive *tmp148
-    * jump *label91 equal *tmp149 false
-    * op equal *tmp151 :active 0
-    * jump *label93 equal *tmp151 false
+  427 jump *label91 greaterThan :alive *tmp148
+  428 jump *label93 notEqual :active 0
   429 print "\n[salmon]No active units.[]"
   430 jump *label94 always
   431 label *label93
 
   433 printflush message2
   434 set .STATE_LIMIT 6
   435 sensor .ITEM .SORTER @config
-    * op notEqual *tmp154 .ITEM .LAST_ITEM
-    * jump *label95 equal *tmp154 false
+  436 jump *label95 equal .ITEM .LAST_ITEM
   437 label *label97
-    * op equal *tmp156 .ITEM null
-    * jump *label99 equal *tmp156 false
+  438 jump *label99 notEqual .ITEM null
   439 print "[salmon]No item type selected for transport.[]"
   440 printflush message1
   441 sensor .ITEM .SORTER @config
 
   595 op add :total_flow_per_ms :items_per_ms :corr_per_ms
   596 op mul *tmp215 60000 :corr_per_ms
   597 op floor :corr_per_min *tmp215
-    * op greaterThanEq *tmp217 :corr_per_min 0
-    * jump *label138 equal *tmp217 false
+  598 jump *label138 lessThan :corr_per_min 0
   599 set *tmp218 "[]([green]+"
   600 jump *label139 always
   601 label *label138
 
   660 jump *label146 equal *tmp251 false
   661 sensor *tmp253 .DST .ITEM
   662 op sub :max_drop .DROP_LEVEL *tmp253
-    * op lessThan *tmp255 :max_drop .DROP_PACK
-    * jump *label148 equal *tmp255 false
+  663 jump *label148 greaterThanEq :max_drop .DROP_PACK
   664 set :findAnotherContainer:min_level 999999
   665 set .CONTAINERS 0
   666 set :findAnotherContainer:n @links
   667 label *label151
-    * op greaterThan *tmp259 :findAnotherContainer:n 0
-    * jump *label153 equal *tmp259 false
+  668 jump *label153 lessThanEq :findAnotherContainer:n 0
   669 op sub :findAnotherContainer:n :findAnotherContainer:n 1
   670 getlink :findAnotherContainer:block :findAnotherContainer:n
   671 sensor *tmp263 :findAnotherContainer:block @type
 
   674 label *label156
   675 op add .CONTAINERS .CONTAINERS 1
   676 sensor :findAnotherContainer:level :findAnotherContainer:block .ITEM
-    * op lessThan *tmp266 :findAnotherContainer:level :findAnotherContainer:min_level
-    * jump *label157 equal *tmp266 false
+  677 jump *label157 greaterThanEq :findAnotherContainer:level :findAnotherContainer:min_level
   678 set :findAnotherContainer:min_level :findAnotherContainer:level
   679 set .CONTAINER :findAnotherContainer:block
   680 set .CONTAINER_INDEX :findAnotherContainer:n
 
   687 label *label152
   688 jump *label151 always
   689 label *label153
-    * op equal *tmp268 .CONTAINERS 0
-    * jump *label159 equal *tmp268 false
+  690 jump *label159 notEqual .CONTAINERS 0
   691 set .CONTAINER @this
   692 jump *label160 always
   693 label *label159
 
   726 label *label147
   727 set :wait_time 0
   728 set :remote_wait_time 0
-    * op greaterThanEq *tmp286 @tick .MESSAGE_TIMEOUT
-    * jump *label161 equal *tmp286 false
+  729 jump *label161 lessThan @tick .MESSAGE_TIMEOUT
   730 set .MESSAGE ""
   731 jump *label162 always
   732 label *label161
 
   742 print .DIRECTION
   743 print .LINK_TXT
   744 print .AUTO_ALLOCATION_TXT
-    * op greaterThan *tmp288 .TARGET 0
-    * jump *label163 equal *tmp288 false
-    * op greaterThanEq *tmp290 :active .TARGET
-    * jump *label165 equal *tmp290 false
+  745 jump *label163 lessThanEq .TARGET 0
+  746 jump *label165 lessThan :active .TARGET
   747 print "\n"
   748 print "Using [green]"
   749 print :active
 
   769 print " [gold]+"
   770 print :items_in_transit
   771 label *label166
-    * op greaterThan *tmp292 .CHANGE 0
-    * jump *label167 equal *tmp292 false
+  772 jump *label167 lessThanEq .CHANGE 0
   773 print "\n[][salmon]Cannot acquire additional units![]"
   774 jump *label168 always
   775 label *label167
 
   780 print "\n"
   781 print "[]Local items: [gold]"
   782 print :container_items
-    * op lessThan *tmp294 .EFF_LOCAL_LIMIT 100
-    * jump *label169 equal *tmp294 false
+  783 jump *label169 greaterThanEq .EFF_LOCAL_LIMIT 100
   784 print "[] (limit [orange]"
   785 print .LOCAL_MARGIN
   786 print "["
 
   793 print "\n"
   794 print "[]Remote items: [gold]"
   795 print :remote_level
-    * op lessThan *tmp298 .EFF_REMOTE_LIMIT 100
-    * jump *label173 equal *tmp298 false
+  796 jump *label173 greaterThanEq .EFF_REMOTE_LIMIT 100
   797 print "[] (limit [orange]"
   798 print .REMOTE_MARGIN
   799 print "["
 
   804 jump *label172 always
   805 label *label171
   806 label *label172
-    * op greaterThan *tmp300 .TARGET 0
-    * jump *label175 equal *tmp300 false
+  807 jump *label175 lessThanEq .TARGET 0
   808 print "\n"
   809 print "[]Speed: [green]"
   810 print :items_per_min
 
   853 set :items_in_transit 0
   854 print "Unit status:"
   855 sensor *tmp305 .SRC @dead
-    * op notEqual *tmp306 *tmp305 0
-    * jump *label179 equal *tmp306 false
+  856 jump *label179 equal *tmp305 0
   857 jump *label79 always
   858 jump *label180 always
   859 label *label179
   860 label *label180
   861 sensor *tmp308 .DST @dead
-    * op notEqual *tmp309 *tmp308 0
-    * jump *label181 equal *tmp309 false
+  862 jump *label181 equal *tmp308 0
   863 jump *label79 always
   864 jump *label182 always
   865 label *label181
   866 label *label182
   867 sensor *tmp311 .SORTER @dead
-    * op notEqual *tmp312 *tmp311 0
-    * jump *label183 equal *tmp312 false
+  868 jump *label183 equal *tmp311 0
   869 jump *label79 always
   870 jump *label184 always
   871 label *label183
   872 label *label184
   873 getlink *tmp314 .CONTAINER_INDEX
-    * op notEqual *tmp315 .CONTAINER *tmp314
-    * jump *label185 equal *tmp315 false
+  874 jump *label185 equal .CONTAINER *tmp314
   875 jump *label79 always
   876 jump *label186 always
   877 label *label185
 
   879 jump *label92 always
   880 label *label91
   881 label *label92
-    * op greaterThan *tmp317 .CHANGE 0
-    * jump *label187 equal *tmp317 false
+  882 jump *label187 lessThanEq .CHANGE 0
   883 sensor *tmp319 @unit @controlled
-    * op equal *tmp320 *tmp319 0
-    * jump *label189 equal *tmp320 false
+  884 jump *label189 notEqual *tmp319 0
   885 op sub .CHANGE .CHANGE 1
   886 ucontrol flag 1
   887 jump *label190 always
 
   891 label *label187
   892 label *label188
   893 sensor *tmp322 @unit @controller
-    * op equal *tmp323 *tmp322 @this
-    * jump *label191 equal *tmp323 false
+  894 jump *label191 notEqual *tmp322 @this
   895 sensor :state @unit @flag
-    * op notEqual *tmp326 :state .S_UNUSED
-    * jump *label193 equal *tmp326 false
+  896 jump *label193 equal :state .S_UNUSED
   897 op max *tmp328 :state 1
   898 op min :state *tmp328 .STATE_LIMIT
-    * op lessThan *tmp330 .CHANGE 0
-    * jump *label195 equal *tmp330 false
-    * op notEqual *tmp332 :state 6
-    * jump *label197 equal *tmp332 false
+  899 jump *label195 greaterThanEq .CHANGE 0
+  900 jump *label197 equal :state 6
   901 sensor *tmp334 @unit @totalItems
-    * op lessThanEq *tmp335 *tmp334 .DISCARD_UNIT_MAX_ITEMS
-    * jump *label199 equal *tmp335 false
+  902 jump *label199 greaterThan *tmp334 .DISCARD_UNIT_MAX_ITEMS
   903 op add .CHANGE .CHANGE 1
   904 set :state 6
   905 jump *label200 always
 
   911 jump *label196 always
   912 label *label195
   913 label *label196
-    * op equal *tmp337 :state 1
-    * jump *label201 equal *tmp337 false
+  914 jump *label201 notEqual :state 1
   915 sensor *tmp339 @unit @totalItems
-    * op equal *tmp340 *tmp339 0
-    * jump *label203 equal *tmp340 false
+  916 jump *label203 notEqual *tmp339 0
   917 set :state 2
   918 jump *label204 always
   919 label *label203
   920 sensor *tmp342 @unit @firstItem
-    * op equal *tmp343 *tmp342 .ITEM
-    * jump *label205 equal *tmp343 false
+  921 jump *label205 notEqual *tmp342 .ITEM
   922 set :state 4
   923 jump *label206 always
   924 label *label205
 
   943 jump *label202 always
   944 label *label201
   945 label *label202
-    * op equal *tmp348 :state 2
-    * jump *label211 equal *tmp348 false
+  946 jump *label211 notEqual :state 2
   947 ucontrol approach .SRC_X .SRC_Y 6
   948 ucontrol within .SRC_X .SRC_Y 8 *tmp350
   949 jump *label213 equal *tmp350 false
 
   983 jump *label212 always
   984 label *label211
   985 label *label212
-    * op equal *tmp361 :state 3
-    * jump *label218 equal *tmp361 false
+  986 jump *label218 notEqual :state 3
   987 sensor *tmp363 .SRC .ITEM
   988 op sub :max_load *tmp363 .LOAD_LEVEL
-    * op greaterThanEq *tmp365 :max_load .LOAD_PACK
-    * jump *label220 equal *tmp365 false
+  989 jump *label220 lessThan :max_load .LOAD_PACK
   990 ucontrol itemTake .SRC .ITEM :max_load
   991 jump *label221 always
   992 label *label220
   993 label *label221
   994 sensor *tmp367 @unit @totalItems
-    * op greaterThanEq *tmp368 *tmp367 .UNIT_CAPACITY
-    * jump *label222 equal *tmp368 false
+  995 jump *label222 lessThan *tmp367 .UNIT_CAPACITY
   996 set :state 4
   997 jump *label223 always
   998 label *label222
 
  1007 jump *label219 always
  1008 label *label218
  1009 label *label219
-    * op equal *tmp371 :state 4
-    * jump *label224 equal *tmp371 false
+ 1010 jump *label224 notEqual :state 4
  1011 ucontrol approach .DST_X .DST_Y 6
  1012 ucontrol within .DST_X .DST_Y 8 *tmp373
  1013 jump *label226 equal *tmp373 false
 
  1050 jump *label225 always
  1051 label *label224
  1052 label *label225
-    * op equal *tmp385 :state 5
-    * jump *label231 equal *tmp385 false
+ 1053 jump *label231 notEqual :state 5
  1054 sensor *tmp387 .DST .ITEM
  1055 op sub :max_drop .DROP_LEVEL *tmp387
-    * op greaterThanEq *tmp389 :max_drop .DROP_PACK
-    * jump *label233 equal *tmp389 false
+ 1056 jump *label233 lessThan :max_drop .DROP_PACK
  1057 ucontrol itemDrop .DST :max_drop
  1058 jump *label234 always
  1059 label *label233
  1060 label *label234
  1061 sensor *tmp391 @unit @totalItems
-    * op lessThanEq *tmp392 *tmp391 0
-    * jump *label235 equal *tmp392 false
+ 1062 jump *label235 greaterThan *tmp391 0
  1063 set :state 2
  1064 ucontrol approach .SRC_X .SRC_Y 6
  1065 set :printUnitInfo.2:name "source"
 
  1106 label *label232
  1107 sensor :items @unit @totalItems
  1108 op add :items_in_transit :items_in_transit :items
-    * op equal *tmp405 :state 6
-    * jump *label240 equal *tmp405 false
+ 1109 jump *label240 notEqual :state 6
  1110 print "[]"
  1111 print "\n"
  1112 print "Parking: [green]"
-    * op greaterThan *tmp407 :items 0
-    * jump *label242 equal *tmp407 false
+ 1113 jump *label242 lessThanEq :items 0
  1114 jump *label244 equal .DROP_TO_CORE false
  1115 ucontrol approach .CORE_X .CORE_Y 6
  1116 ucontrol within .CORE_X .CORE_Y 8 *tmp410
 
  1128 jump *label243 always
  1129 label *label242
  1130 label *label243
-    * op lessThanEq *tmp414 :items .PARK_ITEM_LIMIT
-    * jump *label248 equal *tmp414 false
+ 1131 jump *label248 greaterThan :items .PARK_ITEM_LIMIT
  1132 ucontrol move .PARK_X .PARK_Y
  1133 set :state .S_UNUSED
  1134 jump *label249 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-47 instructions):
 
    69 op lessThan *tmp17 :state 6
    70 op land *tmp18 *tmp16 *tmp17
    71 op add .TARGET .TARGET *tmp18
-    * jump *label21 always
    72 label *label20
    73 label *label21
    74 ubind UNIT
 
   100 set .CONTAINER :block
   101 op add .CONTAINERS .CONTAINERS 1
   102 set .CONTAINER_INDEX :n
-    * jump *label28 always
   103 label *label29
   104 label *label28
   105 label *label26
 
   126 jump *label38 notEqual *tmp36 0
   127 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   128 ucontrol flag .S_UNUSED
-    * jump *label39 always
   129 label *label38
   130 label *label39
   131 label *label36
 
   191 print "is not a vault!"
   192 printflush message2
   193 set .CORE null
-    * jump *label55 always
   194 label *label54
   195 label *label55
-    * jump *label50 always
   196 label *label49
   197 label *label50
   198 ucontrol flag .S_UNUSED
 
   220 jump *label61 equal .SORTER null
   221 print "Block found: "
   222 print .SORTER
-    * jump *label62 always
   223 label *label61
   224 label *label62
   225 printflush message1
 
   381 set :corr_per_min ""
   382 set .SPEED_UNIT_TXT "/min"
   383 set .WAIT_LIMIT 30000
-    * jump *label84 always
   384 label *label83
   385 label *label84
   386 sensor *tmp137 switch2 @enabled
 
   411 set .AUTO_ALLOCATION_TXT *tmp145
   412 label *label88
   413 set .WAIT_LIMIT 30000
-    * jump *label86 always
   414 label *label85
   415 label *label86
   416 sensor *tmp146 :first_unit @dead
 
   419 jump *label91 greaterThan :alive *tmp148
   420 jump *label93 notEqual :active 0
   421 print "\n[salmon]No active units.[]"
-    * jump *label94 always
   422 label *label93
   423 label *label94
   424 printflush message2
 
   541 sensor :last_level .CONTAINER .ITEM
   542 set :min_level 999999
   543 set :max_level 0
-    * jump *label96 always
   544 label *label95
   545 label *label96
   546 sensor :container_items .CONTAINER .ITEM
 
   608 op add *tmp228 :total_flow_3 :total_flow_2
   609 op add *tmp229 *tmp228 :total_flow_1
   610 op div :total_flow_per_ms *tmp229 3
-    * jump *label145 always
   611 label *label144
   612 label *label145
   613 op div *tmp231 :total_flow_per_ms :items_per_ms_unit
 
   640 label *label141
   641 set :min_level 999999
   642 set :max_level 0
-    * jump *label137 always
   643 label *label136
   644 label *label137
   645 op greaterThan *tmp249 .CONTAINERS 1
 
   666 set :findAnotherContainer:min_level :findAnotherContainer:level
   667 set .CONTAINER :findAnotherContainer:block
   668 set .CONTAINER_INDEX :findAnotherContainer:n
-    * jump *label158 always
   669 label *label157
   670 label *label158
-    * jump *label154 always
   671 label *label155
   672 label *label154
   673 label *label152
 
   704 label *label150
   705 set :this_level *tmp257
   706 set :last_level :this_level
-    * jump *label149 always
   707 label *label148
   708 label *label149
-    * jump *label147 always
   709 label *label146
   710 label *label147
   711 set :wait_time 0
   712 set :remote_wait_time 0
   713 jump *label161 lessThan @tick .MESSAGE_TIMEOUT
   714 set .MESSAGE ""
-    * jump *label162 always
   715 label *label161
   716 label *label162
-    * jump *label135 always
   717 label *label134
   718 label *label135
   719 print .MESSAGE
 
   753 label *label166
   754 jump *label167 lessThanEq .CHANGE 0
   755 print "\n[][salmon]Cannot acquire additional units![]"
-    * jump *label168 always
   756 label *label167
   757 label *label168
-    * jump *label164 always
   758 label *label163
   759 label *label164
   760 print "\n"
 
   765 print .LOCAL_MARGIN
   766 print "["
   767 print "])"
-    * jump *label170 always
   768 label *label169
   769 label *label170
   770 jump *label171 equal .SHOW_REMOTE_LEVEL false
 
   777 print .REMOTE_MARGIN
   778 print "["
   779 print "])"
-    * jump *label174 always
   780 label *label173
   781 label *label174
-    * jump *label172 always
   782 label *label171
   783 label *label172
   784 jump *label175 lessThanEq .TARGET 0
 
   815 print :wait_time_str
   816 print "["
   817 print "] s"
-    * jump *label176 always
   818 label *label175
   819 label *label176
   820 print "\n"
 
   831 sensor *tmp305 .SRC @dead
   832 jump *label179 equal *tmp305 0
   833 jump *label79 always
-    * jump *label180 always
   834 label *label179
   835 label *label180
   836 sensor *tmp308 .DST @dead
   837 jump *label181 equal *tmp308 0
   838 jump *label79 always
-    * jump *label182 always
   839 label *label181
   840 label *label182
   841 sensor *tmp311 .SORTER @dead
   842 jump *label183 equal *tmp311 0
   843 jump *label79 always
-    * jump *label184 always
   844 label *label183
   845 label *label184
   846 getlink *tmp314 .CONTAINER_INDEX
   847 jump *label185 equal .CONTAINER *tmp314
   848 jump *label79 always
-    * jump *label186 always
   849 label *label185
   850 label *label186
-    * jump *label92 always
   851 label *label91
   852 label *label92
   853 jump *label187 lessThanEq .CHANGE 0
 
   855 jump *label189 notEqual *tmp319 0
   856 op sub .CHANGE .CHANGE 1
   857 ucontrol flag 1
-    * jump *label190 always
   858 label *label189
   859 label *label190
-    * jump *label188 always
   860 label *label187
   861 label *label188
   862 sensor *tmp322 @unit @controller
 
   871 jump *label199 greaterThan *tmp334 .DISCARD_UNIT_MAX_ITEMS
   872 op add .CHANGE .CHANGE 1
   873 set :state 6
-    * jump *label200 always
   874 label *label199
   875 label *label200
-    * jump *label198 always
   876 label *label197
   877 label *label198
-    * jump *label196 always
   878 label *label195
   879 label *label196
   880 jump *label201 notEqual :state 1
 
   893 ucontrol within .CORE_X .CORE_Y 8 *tmp346
   894 jump *label209 equal *tmp346 false
   895 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label210 always
   896 label *label209
   897 label *label210
   898 print "[]"
 
   905 label *label208
   906 label *label206
   907 label *label204
-    * jump *label202 always
   908 label *label201
   909 label *label202
   910 jump *label211 notEqual :state 2
 
   944 label *label217
   945 label *label215
   946 label *label214
-    * jump *label212 always
   947 label *label211
   948 label *label212
   949 jump *label218 notEqual :state 3
 
   951 op sub :max_load *tmp363 .LOAD_LEVEL
   952 jump *label220 lessThan :max_load .LOAD_PACK
   953 ucontrol itemTake .SRC .ITEM :max_load
-    * jump *label221 always
   954 label *label220
   955 label *label221
   956 sensor *tmp367 @unit @totalItems
 
   966 op mul *tmp370 :loop_time_ms .SRC_REMOTE_WAIT
   967 op add :remote_wait_time :remote_wait_time *tmp370
   968 label *label223
-    * jump *label219 always
   969 label *label218
   970 label *label219
   971 jump *label224 notEqual :state 4
 
  1008 label *label230
  1009 label *label228
  1010 label *label227
-    * jump *label225 always
  1011 label *label224
  1012 label *label225
  1013 jump *label231 notEqual :state 5
 
  1015 op sub :max_drop .DROP_LEVEL *tmp387
  1016 jump *label233 lessThan :max_drop .DROP_PACK
  1017 ucontrol itemDrop .DST :max_drop
-    * jump *label234 always
  1018 label *label233
  1019 label *label234
  1020 sensor *tmp391 @unit @totalItems
 
  1060 op mul *tmp403 :loop_time_ms .DST_REMOTE_WAIT
  1061 op add :remote_wait_time :remote_wait_time *tmp403
  1062 label *label236
-    * jump *label232 always
  1063 label *label231
  1064 label *label232
  1065 sensor :items @unit @totalItems
 
  1075 jump *label246 equal *tmp410 false
  1076 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1077 sensor :items @unit @totalItems
-    * jump *label247 always
  1078 label *label246
  1079 label *label247
  1080 jump *label245 always
 
  1082 ucontrol itemDrop @air .UNIT_CAPACITY
  1083 sensor :items @unit @totalItems
  1084 label *label245
-    * jump *label243 always
  1085 label *label242
  1086 label *label243
  1087 jump *label248 greaterThan :items .PARK_ITEM_LIMIT
  1088 ucontrol move .PARK_X .PARK_Y
  1089 set :state .S_UNUSED
-    * jump *label249 always
  1090 label *label248
  1091 label *label249
  1092 jump *label241 always
 
  1096 print :items
  1097 print .ITEM_ICON
  1098 ucontrol flag :state
-    * jump *label194 always
  1099 label *label193
  1100 label *label194
-    * jump *label192 always
  1101 label *label191
  1102 label *label192
  1103 label *label78

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
   436 set .LAST_ITEM .ITEM
   437 set :itemTypeToIcon:itemType .ITEM
   438 sensor *tmp160 :itemTypeToIcon:itemType @id
-    * sensor *tmp162 @blast-compound @id
+  439 set *tmp162 14
   440 jump *label102 notEqual *tmp160 *tmp162
   441 label *label103
   442 set *tmp159 "[]"
   443 jump *label101 always
   444 label *label102
-    * sensor *tmp163 @coal @id
+  445 set *tmp163 5
   446 jump *label104 notEqual *tmp160 *tmp163
   447 label *label105
   448 set *tmp159 "[]"
   449 jump *label101 always
   450 label *label104
-    * sensor *tmp164 @copper @id
+  451 set *tmp164 0
   452 jump *label106 notEqual *tmp160 *tmp164
   453 label *label107
   454 set *tmp159 "[]"
   455 jump *label101 always
   456 label *label106
-    * sensor *tmp165 @graphite @id
+  457 set *tmp165 3
   458 jump *label108 notEqual *tmp160 *tmp165
   459 label *label109
   460 set *tmp159 "[]"
   461 jump *label101 always
   462 label *label108
-    * sensor *tmp166 @lead @id
+  463 set *tmp166 1
   464 jump *label110 notEqual *tmp160 *tmp166
   465 label *label111
   466 set *tmp159 "[]"
   467 jump *label101 always
   468 label *label110
-    * sensor *tmp167 @metaglass @id
+  469 set *tmp167 2
   470 jump *label112 notEqual *tmp160 *tmp167
   471 label *label113
   472 set *tmp159 "[]"
   473 jump *label101 always
   474 label *label112
-    * sensor *tmp168 @phase-fabric @id
+  475 set *tmp168 11
   476 jump *label114 notEqual *tmp160 *tmp168
   477 label *label115
   478 set *tmp159 "[]"
   479 jump *label101 always
   480 label *label114
-    * sensor *tmp169 @plastanium @id
+  481 set *tmp169 10
   482 jump *label116 notEqual *tmp160 *tmp169
   483 label *label117
   484 set *tmp159 "[]"
   485 jump *label101 always
   486 label *label116
-    * sensor *tmp170 @pyratite @id
+  487 set *tmp170 15
   488 jump *label118 notEqual *tmp160 *tmp170
   489 label *label119
   490 set *tmp159 "[]"
   491 jump *label101 always
   492 label *label118
-    * sensor *tmp171 @sand @id
+  493 set *tmp171 4
   494 jump *label120 notEqual *tmp160 *tmp171
   495 label *label121
   496 set *tmp159 "[]"
   497 jump *label101 always
   498 label *label120
-    * sensor *tmp172 @scrap @id
+  499 set *tmp172 8
   500 jump *label122 notEqual *tmp160 *tmp172
   501 label *label123
   502 set *tmp159 "[]"
   503 jump *label101 always
   504 label *label122
-    * sensor *tmp173 @silicon @id
+  505 set *tmp173 9
   506 jump *label124 notEqual *tmp160 *tmp173
   507 label *label125
   508 set *tmp159 "[]"
   509 jump *label101 always
   510 label *label124
-    * sensor *tmp174 @spore-pod @id
+  511 set *tmp174 13
   512 jump *label126 notEqual *tmp160 *tmp174
   513 label *label127
   514 set *tmp159 "[]"
   515 jump *label101 always
   516 label *label126
-    * sensor *tmp175 @surge-alloy @id
+  517 set *tmp175 12
   518 jump *label128 notEqual *tmp160 *tmp175
   519 label *label129
   520 set *tmp159 "[]"
   521 jump *label101 always
   522 label *label128
-    * sensor *tmp176 @thorium @id
+  523 set *tmp176 7
   524 jump *label130 notEqual *tmp160 *tmp176
   525 label *label131
   526 set *tmp159 "[]"
   527 jump *label101 always
   528 label *label130
-    * sensor *tmp177 @titanium @id
+  529 set *tmp177 6
   530 jump *label132 notEqual *tmp160 *tmp177
   531 label *label133
   532 set *tmp159 "[]"
 
   574 op idiv *tmp204 :turnaround_ms 100
   575 op div :turnaround_str *tmp204 10
   576 op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms
-    * op mul *tmp207 :items_per_ms_unit 60000
-    * op floor :items_per_min_unit *tmp207
+  577 op idiv :items_per_min_unit :items_per_ms_unit 0.000016666666666666667
   578 op add *tmp209 :min_level :max_level
   579 op div :this_level *tmp209 2
   580 op sub *tmp211 :last_level :this_level
 
   582 op div :corr_per_ms :corr :elapsed_ms
   583 set :last_level :this_level
   584 op add :total_flow_per_ms :items_per_ms :corr_per_ms
-    * op mul *tmp215 60000 :corr_per_ms
-    * op floor :corr_per_min *tmp215
+  585 op idiv :corr_per_min :corr_per_ms 0.000016666666666666667
   586 jump *label138 lessThan :corr_per_min 0
   587 set *tmp218 "[]([green]+"
   588 jump *label139 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    30 set .TRIGGER_LEVEL 0.9
    31 op mul .S_UNUSED -1 HOUSEKEEPING
    32 set .STATE_LIMIT null
-    * set .ITEM_ICON .STATE_LIMIT
-    * set .ITEM .ITEM_ICON
-    * set .CORE_Y .ITEM
-    * set .CORE_X .CORE_Y
-    * set .CONTAINER_INDEX .CORE_X
+   33 set .ITEM_ICON null
+   34 set .ITEM .STATE_LIMIT
+   35 set .CORE_Y .ITEM_ICON
+   36 set .CORE_X .ITEM
+   37 set .CONTAINER_INDEX .CORE_Y
    38 set .LOOPS 1
-    * op mul *tmp3 .LOOPS 1000
-    * op div .LOOPS_TICKS_TO_MS *tmp3 60
+   39 op mul *tmp3 1 1000
+   40 op div .LOOPS_TICKS_TO_MS 1000 60
    41 set .INC_OVERALLOCATION OVERALLOCATION_LOW
    42 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    43 set .TRIGGER_BOOST 2
 
   153 label *label44
   154 jump *label43 always
   155 label *label45
-    * ucontrol flag :flag
+  156 ucontrol flag .QUERY_FLAG
   157 label *label46
   158 op equal *tmp46 :flag .QUERY_FLAG
   159 sensor *tmp47 @unit @dead
 
   209 set .DROP_TO_CORE false
   210 label *label34
   211 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  212 sensor :sorter_type sorter1 @type
   213 label *label58
   214 op notEqual *tmp67 :sorter_type @sorter
   215 op notEqual *tmp68 :sorter_type @inverted-sorter
 
   224 label *label62
   225 printflush message1
   226 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  227 sensor :sorter_type sorter1 @type
   228 label *label59
   229 jump *label58 always
   230 label *label60
 
   232 set .SHOW_REMOTE_LEVEL true
   233 set .SRC .CORE
   234 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  235 sensor :src_capacity .CORE @itemCapacity
+  236 sensor :dst_capacity .CONTAINER @itemCapacity
   237 op sub *tmp77 100 .EFF_REMOTE_LIMIT
   238 op mul *tmp78 :src_capacity *tmp77
   239 op idiv .LOAD_LEVEL *tmp78 100
 
   241 op idiv .DROP_LEVEL *tmp80 100
   242 set .LOCAL_MARGIN .DROP_LEVEL
   243 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op sub *tmp82 1 .TRIGGER_LEVEL
-    * op mul .LOW_LEVEL_TRIGGER :dst_capacity *tmp82
+  244 op sub *tmp82 1 0.9
+  245 op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998
   246 set .HIGH_LEVEL_TRIGGER :dst_capacity
   247 set .FLOW_CORR_SIGN 1
   248 set .SRC_REMOTE_WAIT 1
 
   259 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   260 set .SRC .CONTAINER
   261 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  262 sensor :src_capacity .CONTAINER @itemCapacity
+  263 sensor :dst_capacity .CORE @itemCapacity
   264 op sub *tmp89 100 .EFF_LOCAL_LIMIT
   265 op mul *tmp90 :src_capacity *tmp89
   266 op idiv .LOAD_LEVEL *tmp90 100
 
   271 op add .DROP_LEVEL *tmp93 *tmp95
   272 set .LOCAL_MARGIN .LOAD_LEVEL
   273 set .REMOTE_MARGIN .DROP_LEVEL
-    * op mul .HIGH_LEVEL_TRIGGER :src_capacity .TRIGGER_LEVEL
+  274 op mul .HIGH_LEVEL_TRIGGER :src_capacity 0.9
   275 set .LOW_LEVEL_TRIGGER 0
   276 set .FLOW_CORR_SIGN -1
   277 set .SRC_REMOTE_WAIT 0
 
   302 op sub *tmp110 .DST_Y .SRC_Y
   303 op len *tmp111 *tmp109 *tmp110
   304 op sub *tmp112 *tmp111 6
-    * op sub .DISTANCE *tmp112 8
+  305 op sub .DISTANCE *tmp111 14
   306 op max *tmp114 .DISTANCE 10
   307 op mul *tmp115 2 *tmp114
   308 op div .TRAVEL_TIME *tmp115 .SPEED
 
   336 set :elapsed_str "--"
   337 set :wait_time_str 0
   338 set :wait_time 0
-    * set :transfers :wait_time
-    * set :transferred :transfers
-    * set :total_flow_2 :transferred
-    * set :total_flow_1 :total_flow_2
-    * set :remote_wait_time :total_flow_1
-    * set :min_level :remote_wait_time
-    * set :max_level :min_level
-    * set :loop_time_ms :max_level
-    * set :last_level :loop_time_ms
-    * jump *label75 equal .EFF_AUTO_ALLOCATION false
+  339 set :transfers 0
+  340 set :transferred :wait_time
+  341 set :total_flow_2 :transfers
+  342 set :total_flow_1 :transferred
+  343 set :remote_wait_time :total_flow_2
+  344 set :min_level :total_flow_1
+  345 set :max_level :remote_wait_time
+  346 set :loop_time_ms :min_level
+  347 set :last_level :max_level
+  348 jump *label75 equal AUTO_ALLOCATION false
   349 set .CORR_SIGN "[]([green]+"
   350 set :corr_per_min 0
   351 set .SPEED_UNIT_TXT "[])/min"
 
   435 label *label99
   436 set .LAST_ITEM .ITEM
   437 set :itemTypeToIcon:itemType .ITEM
-    * sensor *tmp160 :itemTypeToIcon:itemType @id
+  438 sensor *tmp160 .ITEM @id
   439 set *tmp162 14
-    * jump *label102 notEqual *tmp160 *tmp162
+  440 jump *label102 notEqual *tmp160 14
   441 label *label103
   442 set *tmp159 "[]"
   443 jump *label101 always
   444 label *label102
   445 set *tmp163 5
-    * jump *label104 notEqual *tmp160 *tmp163
+  446 jump *label104 notEqual *tmp160 5
   447 label *label105
   448 set *tmp159 "[]"
   449 jump *label101 always
   450 label *label104
   451 set *tmp164 0
-    * jump *label106 notEqual *tmp160 *tmp164
+  452 jump *label106 notEqual *tmp160 0
   453 label *label107
   454 set *tmp159 "[]"
   455 jump *label101 always
   456 label *label106
   457 set *tmp165 3
-    * jump *label108 notEqual *tmp160 *tmp165
+  458 jump *label108 notEqual *tmp160 3
   459 label *label109
   460 set *tmp159 "[]"
   461 jump *label101 always
   462 label *label108
   463 set *tmp166 1
-    * jump *label110 notEqual *tmp160 *tmp166
+  464 jump *label110 notEqual *tmp160 1
   465 label *label111
   466 set *tmp159 "[]"
   467 jump *label101 always
   468 label *label110
   469 set *tmp167 2
-    * jump *label112 notEqual *tmp160 *tmp167
+  470 jump *label112 notEqual *tmp160 2
   471 label *label113
   472 set *tmp159 "[]"
   473 jump *label101 always
   474 label *label112
   475 set *tmp168 11
-    * jump *label114 notEqual *tmp160 *tmp168
+  476 jump *label114 notEqual *tmp160 11
   477 label *label115
   478 set *tmp159 "[]"
   479 jump *label101 always
   480 label *label114
   481 set *tmp169 10
-    * jump *label116 notEqual *tmp160 *tmp169
+  482 jump *label116 notEqual *tmp160 10
   483 label *label117
   484 set *tmp159 "[]"
   485 jump *label101 always
   486 label *label116
   487 set *tmp170 15
-    * jump *label118 notEqual *tmp160 *tmp170
+  488 jump *label118 notEqual *tmp160 15
   489 label *label119
   490 set *tmp159 "[]"
   491 jump *label101 always
   492 label *label118
   493 set *tmp171 4
-    * jump *label120 notEqual *tmp160 *tmp171
+  494 jump *label120 notEqual *tmp160 4
   495 label *label121
   496 set *tmp159 "[]"
   497 jump *label101 always
   498 label *label120
   499 set *tmp172 8
-    * jump *label122 notEqual *tmp160 *tmp172
+  500 jump *label122 notEqual *tmp160 8
   501 label *label123
   502 set *tmp159 "[]"
   503 jump *label101 always
   504 label *label122
   505 set *tmp173 9
-    * jump *label124 notEqual *tmp160 *tmp173
+  506 jump *label124 notEqual *tmp160 9
   507 label *label125
   508 set *tmp159 "[]"
   509 jump *label101 always
   510 label *label124
   511 set *tmp174 13
-    * jump *label126 notEqual *tmp160 *tmp174
+  512 jump *label126 notEqual *tmp160 13
   513 label *label127
   514 set *tmp159 "[]"
   515 jump *label101 always
   516 label *label126
   517 set *tmp175 12
-    * jump *label128 notEqual *tmp160 *tmp175
+  518 jump *label128 notEqual *tmp160 12
   519 label *label129
   520 set *tmp159 "[]"
   521 jump *label101 always
   522 label *label128
   523 set *tmp176 7
-    * jump *label130 notEqual *tmp160 *tmp176
+  524 jump *label130 notEqual *tmp160 7
   525 label *label131
   526 set *tmp159 "[]"
   527 jump *label101 always
   528 label *label130
   529 set *tmp177 6
-    * jump *label132 notEqual *tmp160 *tmp177
+  530 jump *label132 notEqual *tmp160 6
   531 label *label133
   532 set *tmp159 "[]"
   533 jump *label101 always
 
   536 label *label101
   537 set *tmp158 *tmp159
   538 label *label100
-    * set .ITEM_ICON *tmp158
+  539 set .ITEM_ICON *tmp159
   540 set .STATE_LIMIT 1
   541 sensor :last_level .CONTAINER .ITEM
   542 set :min_level 999999
 
   568 set :transfers 0
   569 jump *label136 equal .EFF_AUTO_ALLOCATION false
   570 set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] ==="
-    * op mul *tmp201 .LOOPS_TICKS_TO_MS :loop_time
+  571 op mul *tmp201 16.666666666666668 :loop_time
   572 op add :turnaround_ms .TRAVEL_TIME *tmp201
   573 op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION
   574 op idiv *tmp204 :turnaround_ms 100
 
   604 set :total_flow_2 :total_flow_1
   605 set :total_flow_1 :total_flow_per_ms
   606 op add *tmp228 :total_flow_3 :total_flow_2
-    * op add *tmp229 *tmp228 :total_flow_1
+  607 op add *tmp229 *tmp228 :total_flow_per_ms
   608 op div :total_flow_per_ms *tmp229 3
   609 label *label144
   610 label *label145
   611 op div *tmp231 :total_flow_per_ms :items_per_ms_unit
-    * op add *tmp232 *tmp231 .INC_OVERALLOCATION
+  612 op add *tmp232 *tmp231 OVERALLOCATION_LOW
   613 op ceil :new_target *tmp232
-    * op mul :level_boost .TRIGGER_BOOST :trigger
+  614 op mul :level_boost 2 :trigger
   615 op add *tmp235 :new_target :level_boost
   616 op min :new_target *tmp235 MAX_UNITS
   617 op sub *tmp237 :new_target :active
   618 op max *tmp238 *tmp237 0
   619 op min :new_change *tmp238 .INC_LIMIT
-    * set .INC_LIMIT .INC_MAX
+  620 set .INC_LIMIT 6
   621 op lessThanEq *tmp240 :new_change 0
-    * op mul .DEC_LIMIT *tmp240 .DEC_MAX
+  622 op mul .DEC_LIMIT *tmp240 -1
   623 jump *label143 always
   624 label *label142
   625 op idiv *tmp242 :wait_time .WAIT_LIMIT
   626 op mul *tmp243 -1 *tmp242
   627 op max :new_change *tmp243 .DEC_LIMIT
   628 op greaterThanEq *tmp245 :new_change 0
-    * op mul .INC_LIMIT *tmp245 .INC_MAX
-    * set .DEC_LIMIT .DEC_MAX
+  629 op mul .INC_LIMIT *tmp245 6
+  630 set .DEC_LIMIT -1
   631 label *label143
   632 op add *tmp247 :active :new_change
   633 op max .TARGET *tmp247 1
 
   676 jump *label160 always
   677 label *label159
   678 set .DST .CONTAINER
-    * sensor :findAnotherContainer:dst_capacity .DST @itemCapacity
+  679 sensor :findAnotherContainer:dst_capacity .CONTAINER @itemCapacity
   680 op mul *tmp271 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
   681 op idiv .DROP_LEVEL *tmp271 100
   682 set .LOCAL_MARGIN .DROP_LEVEL
-    * op sub *tmp273 1 .TRIGGER_LEVEL
-    * op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity *tmp273
+  683 op sub *tmp273 1 0.9
+  684 op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity 0.09999999999999998
   685 set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
-    * sensor .DST_X .DST @x
-    * sensor .DST_Y .DST @y
+  686 sensor .DST_X .CONTAINER @x
+  687 sensor .DST_Y .CONTAINER @y
   688 op sub *tmp277 .DST_X .SRC_X
   689 op sub *tmp278 .DST_Y .SRC_Y
   690 op len *tmp279 *tmp277 *tmp278
   691 op sub *tmp280 *tmp279 6
-    * op sub .DISTANCE *tmp280 8
+  692 op sub .DISTANCE *tmp279 14
   693 op max *tmp282 .DISTANCE 10
   694 op mul *tmp283 2 *tmp282
   695 op div .TRAVEL_TIME *tmp283 .SPEED
 
   698 label *label160
   699 set *tmp257 :findAnotherContainer:min_level
   700 jump *label150 always
-    * set *tmp257 null
   701 label *label150
-    * set :this_level *tmp257
-    * set :last_level :this_level
+  702 set :this_level :findAnotherContainer:min_level
+  703 set :last_level *tmp257
   704 label *label148
   705 label *label149
   706 label *label146
 
   719 print "["
   720 print "]"
   721 print .DIRECTION
-    * print .LINK_TXT
+  722 print *tmp101
   723 print .AUTO_ALLOCATION_TXT
   724 jump *label163 lessThanEq .TARGET 0
   725 jump *label165 lessThan :active .TARGET
 
   915 set :printUnitInfo:x .SRC_X
   916 set :printUnitInfo:y .SRC_Y
   917 sensor *tmp354 @unit @x
-    * op sub *tmp355 :printUnitInfo:x *tmp354
+  918 op sub *tmp355 .SRC_X *tmp354
   919 sensor *tmp356 @unit @y
-    * op sub *tmp357 :printUnitInfo:y *tmp356
+  920 op sub *tmp357 .SRC_Y *tmp356
   921 op len *tmp358 *tmp355 *tmp357
   922 op idiv *tmp359 *tmp358 .SPEED_SEC
   923 op div *tmp360 *tmp359 10
 
   927 print *tmp360
   928 print " "
   929 print "sec[] to "
-    * print :printUnitInfo:name
+  930 print "source"
   931 print ":"
   932 print " [green]"
   933 jump *label217 always
 
   935 print "[]"
   936 print "\n"
   937 print "Going to "
-    * print :printUnitInfo:name
+  938 print "source"
   939 print ":"
   940 print " [green]"
   941 label *label217
 
   979 set :printUnitInfo.1:x .DST_X
   980 set :printUnitInfo.1:y .DST_Y
   981 sensor *tmp378 @unit @x
-    * op sub *tmp379 :printUnitInfo.1:x *tmp378
+  982 op sub *tmp379 .DST_X *tmp378
   983 sensor *tmp380 @unit @y
-    * op sub *tmp381 :printUnitInfo.1:y *tmp380
+  984 op sub *tmp381 .DST_Y *tmp380
   985 op len *tmp382 *tmp379 *tmp381
   986 op idiv *tmp383 *tmp382 .SPEED_SEC
   987 op div *tmp384 *tmp383 10
 
   991 print *tmp384
   992 print " "
   993 print "sec[] to "
-    * print :printUnitInfo.1:name
+  994 print "destination"
   995 print ":"
   996 print " [green]"
   997 jump *label230 always
 
   999 print "[]"
  1000 print "\n"
  1001 print "Going to "
-    * print :printUnitInfo.1:name
+ 1002 print "destination"
  1003 print ":"
  1004 print " [green]"
  1005 label *label230
 
  1022 set :printUnitInfo.2:x .SRC_X
  1023 set :printUnitInfo.2:y .SRC_Y
  1024 sensor *tmp396 @unit @x
-    * op sub *tmp397 :printUnitInfo.2:x *tmp396
+ 1025 op sub *tmp397 .SRC_X *tmp396
  1026 sensor *tmp398 @unit @y
-    * op sub *tmp399 :printUnitInfo.2:y *tmp398
+ 1027 op sub *tmp399 .SRC_Y *tmp398
  1028 op len *tmp400 *tmp397 *tmp399
  1029 op idiv *tmp401 *tmp400 .SPEED_SEC
  1030 op div *tmp402 *tmp401 10
 
  1034 print *tmp402
  1035 print " "
  1036 print "sec[] to "
-    * print :printUnitInfo.2:name
+ 1037 print "source"
  1038 print ":"
  1039 print " [green]"
  1040 jump *label239 always
 
  1042 print "[]"
  1043 print "\n"
  1044 print "Going to "
-    * print :printUnitInfo.2:name
+ 1045 print "source"
  1046 print ":"
  1047 print " [green]"
  1048 label *label239

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-41 instructions):
 
    27 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
    28 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
    29 set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION
-    * set .TRIGGER_LEVEL 0.9
    30 op mul .S_UNUSED -1 HOUSEKEEPING
    31 set .STATE_LIMIT null
    32 set .ITEM_ICON null
-    * set .ITEM .STATE_LIMIT
-    * set .CORE_Y .ITEM_ICON
-    * set .CORE_X .ITEM
-    * set .CONTAINER_INDEX .CORE_Y
-    * set .LOOPS 1
-    * op mul *tmp3 1 1000
-    * op div .LOOPS_TICKS_TO_MS 1000 60
-    * set .INC_OVERALLOCATION OVERALLOCATION_LOW
+   33 set .ITEM null
+   34 set .CORE_Y null
+   35 set .CORE_X .STATE_LIMIT
+   36 set .CONTAINER_INDEX .ITEM_ICON
    37 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
-    * set .TRIGGER_BOOST 2
-    * set .INC_MAX 6
-    * set .DEC_MAX -1
    38 ubind UNIT
    39 label *label14
    40 jump *label16 notEqual @unit null
 
   233 op idiv .DROP_LEVEL *tmp80 100
   234 set .LOCAL_MARGIN .DROP_LEVEL
   235 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op sub *tmp82 1 0.9
   236 op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998
   237 set .HIGH_LEVEL_TRIGGER :dst_capacity
   238 set .FLOW_CORR_SIGN 1
 
   281 label *label69
   282 set *tmp101 LINK_ID
   283 label *label70
-    * set .LINK_TXT *tmp101
   284 op sub *tmp102 :src_capacity .LOAD_LEVEL
   285 op min .LOAD_PACK .UNIT_CAPACITY *tmp102
   286 op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL
 
   291 op sub *tmp109 .DST_X .SRC_X
   292 op sub *tmp110 .DST_Y .SRC_Y
   293 op len *tmp111 *tmp109 *tmp110
-    * op sub *tmp112 *tmp111 6
   294 op sub .DISTANCE *tmp111 14
   295 op max *tmp114 .DISTANCE 10
   296 op mul *tmp115 2 *tmp114
 
   326 set :wait_time_str 0
   327 set :wait_time 0
   328 set :transfers 0
-    * set :transferred :wait_time
-    * set :total_flow_2 :transfers
-    * set :total_flow_1 :transferred
-    * set :remote_wait_time :total_flow_2
-    * set :min_level :total_flow_1
-    * set :max_level :remote_wait_time
-    * set :loop_time_ms :min_level
-    * set :last_level :max_level
+  329 set :transferred 0
+  330 set :total_flow_2 0
+  331 set :total_flow_1 :wait_time
+  332 set :remote_wait_time :transfers
+  333 set :min_level :transferred
+  334 set :max_level :total_flow_2
+  335 set :loop_time_ms :total_flow_1
+  336 set :last_level :remote_wait_time
   337 jump *label75 equal AUTO_ALLOCATION false
   338 set .CORR_SIGN "[]([green]+"
   339 set :corr_per_min 0
 
   423 jump *label97 always
   424 label *label99
   425 set .LAST_ITEM .ITEM
-    * set :itemTypeToIcon:itemType .ITEM
   426 sensor *tmp160 .ITEM @id
-    * set *tmp162 14
   427 jump *label102 notEqual *tmp160 14
   428 label *label103
   429 set *tmp159 "[]"
   430 jump *label101 always
   431 label *label102
-    * set *tmp163 5
   432 jump *label104 notEqual *tmp160 5
   433 label *label105
   434 set *tmp159 "[]"
   435 jump *label101 always
   436 label *label104
-    * set *tmp164 0
   437 jump *label106 notEqual *tmp160 0
   438 label *label107
   439 set *tmp159 "[]"
   440 jump *label101 always
   441 label *label106
-    * set *tmp165 3
   442 jump *label108 notEqual *tmp160 3
   443 label *label109
   444 set *tmp159 "[]"
   445 jump *label101 always
   446 label *label108
-    * set *tmp166 1
   447 jump *label110 notEqual *tmp160 1
   448 label *label111
   449 set *tmp159 "[]"
   450 jump *label101 always
   451 label *label110
-    * set *tmp167 2
   452 jump *label112 notEqual *tmp160 2
   453 label *label113
   454 set *tmp159 "[]"
   455 jump *label101 always
   456 label *label112
-    * set *tmp168 11
   457 jump *label114 notEqual *tmp160 11
   458 label *label115
   459 set *tmp159 "[]"
   460 jump *label101 always
   461 label *label114
-    * set *tmp169 10
   462 jump *label116 notEqual *tmp160 10
   463 label *label117
   464 set *tmp159 "[]"
   465 jump *label101 always
   466 label *label116
-    * set *tmp170 15
   467 jump *label118 notEqual *tmp160 15
   468 label *label119
   469 set *tmp159 "[]"
   470 jump *label101 always
   471 label *label118
-    * set *tmp171 4
   472 jump *label120 notEqual *tmp160 4
   473 label *label121
   474 set *tmp159 "[]"
   475 jump *label101 always
   476 label *label120
-    * set *tmp172 8
   477 jump *label122 notEqual *tmp160 8
   478 label *label123
   479 set *tmp159 "[]"
   480 jump *label101 always
   481 label *label122
-    * set *tmp173 9
   482 jump *label124 notEqual *tmp160 9
   483 label *label125
   484 set *tmp159 "[]"
   485 jump *label101 always
   486 label *label124
-    * set *tmp174 13
   487 jump *label126 notEqual *tmp160 13
   488 label *label127
   489 set *tmp159 "[]"
   490 jump *label101 always
   491 label *label126
-    * set *tmp175 12
   492 jump *label128 notEqual *tmp160 12
   493 label *label129
   494 set *tmp159 "[]"
   495 jump *label101 always
   496 label *label128
-    * set *tmp176 7
   497 jump *label130 notEqual *tmp160 7
   498 label *label131
   499 set *tmp159 "[]"
   500 jump *label101 always
   501 label *label130
-    * set *tmp177 6
   502 jump *label132 notEqual *tmp160 6
   503 label *label133
   504 set *tmp159 "[]"
 
   506 label *label132
   507 set *tmp159 null
   508 label *label101
-    * set *tmp158 *tmp159
   509 label *label100
   510 set .ITEM_ICON *tmp159
   511 set .STATE_LIMIT 1
 
   651 op mul *tmp271 :findAnotherContainer:dst_capacity .EFF_LOCAL_LIMIT
   652 op idiv .DROP_LEVEL *tmp271 100
   653 set .LOCAL_MARGIN .DROP_LEVEL
-    * op sub *tmp273 1 0.9
   654 op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity 0.09999999999999998
   655 set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity
   656 sensor .DST_X .CONTAINER @x
 
   658 op sub *tmp277 .DST_X .SRC_X
   659 op sub *tmp278 .DST_Y .SRC_Y
   660 op len *tmp279 *tmp277 *tmp278
-    * op sub *tmp280 *tmp279 6
   661 op sub .DISTANCE *tmp279 14
   662 op max *tmp282 .DISTANCE 10
   663 op mul *tmp283 2 *tmp282
 
   668 set *tmp257 :findAnotherContainer:min_level
   669 jump *label150 always
   670 label *label150
-    * set :this_level :findAnotherContainer:min_level
-    * set :last_level *tmp257
+  671 set :last_level :findAnotherContainer:min_level
   672 label *label148
   673 label *label149
   674 label *label146
 
   879 set :state 3
   880 jump *label214 always
   881 label *label213
-    * set :printUnitInfo:name "source"
-    * set :printUnitInfo:x .SRC_X
-    * set :printUnitInfo:y .SRC_Y
   882 sensor *tmp354 @unit @x
   883 op sub *tmp355 .SRC_X *tmp354
   884 sensor *tmp356 @unit @y
 
   940 set :state 5
   941 jump *label227 always
   942 label *label226
-    * set :printUnitInfo.1:name "destination"
-    * set :printUnitInfo.1:x .DST_X
-    * set :printUnitInfo.1:y .DST_Y
   943 sensor *tmp378 @unit @x
   944 op sub *tmp379 .DST_X *tmp378
   945 sensor *tmp380 @unit @y
 
   980 jump *label235 greaterThan *tmp391 0
   981 set :state 2
   982 ucontrol approach .SRC_X .SRC_Y 6
-    * set :printUnitInfo.2:name "source"
-    * set :printUnitInfo.2:x .SRC_X
-    * set :printUnitInfo.2:y .SRC_Y
   983 sensor *tmp396 @unit @x
   984 op sub *tmp397 .SRC_X *tmp396
   985 sensor *tmp398 @unit @y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
    32 set .ITEM_ICON null
    33 set .ITEM null
    34 set .CORE_Y null
-    * set .CORE_X .STATE_LIMIT
-    * set .CONTAINER_INDEX .ITEM_ICON
+   35 set .CORE_X null
+   36 set .CONTAINER_INDEX null
    37 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    38 ubind UNIT
    39 label *label14
 
   328 set :transfers 0
   329 set :transferred 0
   330 set :total_flow_2 0
-    * set :total_flow_1 :wait_time
-    * set :remote_wait_time :transfers
-    * set :min_level :transferred
-    * set :max_level :total_flow_2
-    * set :loop_time_ms :total_flow_1
-    * set :last_level :remote_wait_time
+  331 set :total_flow_1 0
+  332 set :remote_wait_time 0
+  333 set :min_level 0
+  334 set :max_level 0
+  335 set :loop_time_ms :wait_time
+  336 set :last_level :transfers
   337 jump *label75 equal AUTO_ALLOCATION false
   338 set .CORR_SIGN "[]([green]+"
   339 set :corr_per_min 0
 
   665 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   666 op add .MESSAGE_TIMEOUT @tick 600
   667 label *label160
-    * set *tmp257 :findAnotherContainer:min_level
   668 jump *label150 always
   669 label *label150
   670 set :last_level :findAnotherContainer:min_level

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4:
 
   332 set :remote_wait_time 0
   333 set :min_level 0
   334 set :max_level 0
-    * set :loop_time_ms :wait_time
-    * set :last_level :transfers
+  335 set :loop_time_ms 0
+  336 set :last_level 0
   337 jump *label75 equal AUTO_ALLOCATION false
   338 set .CORR_SIGN "[]([green]+"
   339 set :corr_per_min 0

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
   133 print "."
   134 print ".."
   135 printflush message1
+  136 op add .QUERY_FLAG 99999900 LINK_ID
   137 label *label40
   138 jump *label42 notEqual .CORE null
-    * op add .QUERY_FLAG 99999900 LINK_ID
   139 set :flag .QUERY_FLAG
   140 ubind UNIT
   141 label *label43

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-2 instructions):
 
    38 ubind UNIT
    39 label *label14
    40 jump *label16 notEqual @unit null
+   41 label *label250
    42 print "[salmon]No unit of type "
    43 print UNIT
    44 print " "
 
    46 printflush message1
    47 ubind UNIT
    48 label *label15
-    * jump *label14 always
+   49 jump *label250 equal @unit null
    50 label *label16
    51 set :first_unit @unit
    52 sensor *tmp8 @unit @speed
 
    84 set :n @links
    85 label *label25
    86 jump *label27 lessThanEq :n 0
+   87 label *label251
    88 op sub :n :n 1
    89 getlink :block :n
    90 sensor *tmp29 :block @type
 
    97 label *label29
    98 label *label28
    99 label *label26
-    * jump *label25 always
+  100 jump *label251 greaterThan :n 0
   101 label *label27
   102 jump *label31 notEqual .CONTAINER null
   103 print "[salmon]No vault or container."
 
   112 set .CORE null
   113 jump *label33 notEqual LINK_ID 0
   114 label *label35
-    * jump *label37 notEqual .CORE null
+  115 label *label252
   116 print "[green]Locating core..."
   117 printflush message1
   118 ubind UNIT
 
   123 label *label38
   124 label *label39
   125 label *label36
-    * jump *label35 always
+  126 jump *label252 equal .CORE null
   127 label *label37
   128 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   129 op equal .DROP_TO_CORE DROP_TO_AIR false
 
   137 printflush message1
   138 op add .QUERY_FLAG 99999900 LINK_ID
   139 label *label40
-    * jump *label42 notEqual .CORE null
+  140 label *label253
   141 set :flag .QUERY_FLAG
   142 ubind UNIT
   143 label *label43
 
   191 label *label50
   192 ucontrol flag .S_UNUSED
   193 label *label41
-    * jump *label40 always
+  194 jump *label253 equal .CORE null
   195 label *label42
   196 jump *label56 equal DROP_TO_AIR false
   197 set *tmp65 .UNIT_CAPACITY
 
   352 ubind UNIT
   353 label *label80
   354 jump *label82 notEqual @unit null
+  355 label *label254
   356 print "No unit of type "
   357 print UNIT
   358 print " "
 
   360 printflush message1
   361 ubind UNIT
   362 label *label81
-    * jump *label80 always
+  363 jump *label254 equal @unit null
   364 label *label82
   365 sensor *tmp132 switch1 @enabled
   366 jump *label83 equal *tmp132 false
 
   419 jump *label95 equal .ITEM .LAST_ITEM
   420 label *label97
   421 jump *label99 notEqual .ITEM null
+  422 label *label255
   423 print "[salmon]No item type selected for transport.[]"
   424 printflush message1
   425 sensor .ITEM .SORTER @config
   426 label *label98
-    * jump *label97 always
+  427 jump *label255 equal .ITEM null
   428 label *label99
   429 set .LAST_ITEM .ITEM
   430 sensor *tmp160 .ITEM @id
 
   627 set :findAnotherContainer:n @links
   628 label *label151
   629 jump *label153 lessThanEq :findAnotherContainer:n 0
+  630 label *label256
   631 op sub :findAnotherContainer:n :findAnotherContainer:n 1
   632 getlink :findAnotherContainer:block :findAnotherContainer:n
   633 sensor *tmp263 :findAnotherContainer:block @type
 
   645 label *label155
   646 label *label154
   647 label *label152
-    * jump *label151 always
+  648 jump *label256 greaterThan :findAnotherContainer:n 0
   649 label *label153
   650 jump *label159 notEqual .CONTAINERS 0
   651 set .CONTAINER @this

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-9 instructions):
 
   193 label *label41
   194 jump *label253 equal .CORE null
   195 label *label42
-    * jump *label56 equal DROP_TO_AIR false
-    * set *tmp65 .UNIT_CAPACITY
+  196 set .DISCARD_UNIT_MAX_ITEMS 0
+  197 jump *label57 equal DROP_TO_AIR false
+  198 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   199 jump *label57 always
-    * label *label56
-    * set *tmp65 0
   200 label *label57
-    * set .DISCARD_UNIT_MAX_ITEMS *tmp65
   201 set .DROP_TO_CORE false
   202 label *label34
   203 set .SORTER sorter1
 
   238 set .FLOW_CORR_SIGN 1
   239 set .SRC_REMOTE_WAIT 1
   240 set .DST_REMOTE_WAIT 0
-    * jump *label65 notEqual LINK_ID 0
-    * set *tmp85 " from core"
+  241 set .DIRECTION " from vault #"
+  242 jump *label66 notEqual LINK_ID 0
+  243 set .DIRECTION " from core"
   244 jump *label66 always
-    * label *label65
-    * set *tmp85 " from vault #"
   245 label *label66
-    * set .DIRECTION *tmp85
   246 jump *label64 always
   247 label *label63
   248 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   265 set .FLOW_CORR_SIGN -1
   266 set .SRC_REMOTE_WAIT 0
   267 set .DST_REMOTE_WAIT 1
-    * jump *label67 notEqual LINK_ID 0
-    * set *tmp99 " to core"
+  268 set .DIRECTION " to vault #"
+  269 jump *label68 notEqual LINK_ID 0
+  270 set .DIRECTION " to core"
   271 jump *label68 always
-    * label *label67
-    * set *tmp99 " to vault #"
   272 label *label68
-    * set .DIRECTION *tmp99
   273 label *label64
-    * jump *label69 notEqual LINK_ID 0
+  274 set *tmp101 LINK_ID
+  275 jump *label70 notEqual LINK_ID 0
   276 set *tmp101 ""
   277 jump *label70 always
-    * label *label69
-    * set *tmp101 LINK_ID
   278 label *label70
   279 op sub *tmp102 :src_capacity .LOAD_LEVEL
   280 op min .LOAD_PACK .UNIT_CAPACITY *tmp102
 
   292 op div .TRAVEL_TIME *tmp115 .SPEED
   293 sensor *tmp117 .CONTAINER @x
   294 jump *label71 greaterThanEq *tmp117 .CORE_X
-    * set *tmp119 15
+  295 op add .PARK_X .CORE_X 15
   296 jump *label72 always
   297 label *label71
-    * set *tmp119 -15
+  298 op add .PARK_X .CORE_X -15
   299 label *label72
-    * op add .PARK_X .CORE_X *tmp119
   300 sensor *tmp121 .CONTAINER @y
   301 jump *label73 greaterThanEq *tmp121 .CORE_Y
-    * set *tmp123 15
+  302 op add .PARK_Y .CORE_Y 15
   303 jump *label74 always
   304 label *label73
-    * set *tmp123 -15
+  305 op add .PARK_Y .CORE_Y -15
   306 label *label74
-    * op add .PARK_Y .CORE_Y *tmp123
   307 op equal *tmp125 LINK_ID 0
   308 op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY
   309 set .TRANSFER_START @tick
 
   385 set .CORR_SIGN "[]"
   386 set :corr_per_min ""
   387 set .SPEED_UNIT_TXT "/min"
-    * jump *label89 notEqual .TARGET 0
-    * set *tmp145 "\n=== [salmon]Transport deactivated[] ==="
+  388 set .AUTO_ALLOCATION_TXT ""
+  389 jump *label90 notEqual .TARGET 0
+  390 set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivated[] ==="
   391 jump *label90 always
-    * label *label89
-    * set *tmp145 ""
   392 label *label90
-    * set .AUTO_ALLOCATION_TXT *tmp145
   393 label *label88
   394 set .WAIT_LIMIT 30000
   395 label *label85
 
   547 set :last_level :this_level
   548 op add :total_flow_per_ms :items_per_ms :corr_per_ms
   549 op idiv :corr_per_min :corr_per_ms 0.000016666666666666667
-    * jump *label138 lessThan :corr_per_min 0
-    * set *tmp218 "[]([green]+"
+  550 set .CORR_SIGN "[]([green]"
+  551 jump *label139 lessThan :corr_per_min 0
+  552 set .CORR_SIGN "[]([green]+"
   553 jump *label139 always
-    * label *label138
-    * set *tmp218 "[]([green]"
   554 label *label139
-    * set .CORR_SIGN *tmp218
   555 set .SPEED_UNIT_TXT "[])/min"
   556 jump *label140 equal :alive false
   557 op lessThan *tmp220 :min_level .LOW_LEVEL_TRIGGER
 
   834 label *label195
   835 label *label196
   836 jump *label201 notEqual :state 1
+  837 set :state 2
   838 sensor *tmp339 @unit @totalItems
-    * jump *label203 notEqual *tmp339 0
-    * set :state 2
-    * jump *label204 always
+  839 jump *label204 equal *tmp339 0
   840 label *label203
+  841 set :state 4
   842 sensor *tmp342 @unit @firstItem
-    * jump *label205 notEqual *tmp342 .ITEM
-    * set :state 4
-    * jump *label206 always
+  843 jump *label206 equal *tmp342 .ITEM
   844 label *label205
   845 jump *label207 equal .DROP_TO_CORE false
   846 ucontrol approach .CORE_X .CORE_Y 6

Modifications by Replicate loop condition at line 156:9 (+1 instructions):
 
   143 label *label43
   144 sensor *tmp44 @unit @controlled
   145 jump *label45 equal *tmp44 0
+  146 label *label257
   147 ubind UNIT
   148 label *label44
-    * jump *label43 always
+  149 sensor *tmp44 @unit @controlled
+  150 jump *label257 notEqual *tmp44 0
   151 label *label45
   152 ucontrol flag .QUERY_FLAG
   153 label *label46

Modifications by Replicate loop condition at line 160:9 (+4 instructions):
 
   156 op equal *tmp48 *tmp47 0
   157 op land *tmp49 *tmp46 *tmp48
   158 jump *label48 equal *tmp49 false
+  159 label *label258
   160 ucontrol stop
   161 sensor :flag @unit @flag
   162 label *label47
-    * jump *label46 always
+  163 op equal *tmp46 :flag .QUERY_FLAG
+  164 sensor *tmp47 @unit @dead
+  165 op equal *tmp48 *tmp47 0
+  166 op land *tmp49 *tmp46 *tmp48
+  167 jump *label258 notEqual *tmp49 false
   168 label *label48
   169 jump *label49 equal :flag .QUERY_FLAG
   170 op idiv :position :flag 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   151 label *label45
   152 ucontrol flag .QUERY_FLAG
   153 label *label46
-    * op equal *tmp46 :flag .QUERY_FLAG
+  154 op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
   155 sensor *tmp47 @unit @dead
   156 op equal *tmp48 *tmp47 0
   157 op land *tmp49 *tmp46 *tmp48

Modifications by Replicate loop condition at line 169:13 (+5 instructions):
 
   177 op equal *tmp59 *tmp58 false
   178 op land *tmp60 *tmp57 *tmp59
   179 jump *label53 equal *tmp60 false
+  180 label *label259
   181 ucontrol approach .CORE_X .CORE_Y 6
   182 label *label52
-    * jump *label51 always
+  183 sensor *tmp56 @unit @dead
+  184 op equal *tmp57 *tmp56 0
+  185 ucontrol within .CORE_X .CORE_Y 8 *tmp58
+  186 op equal *tmp59 *tmp58 false
+  187 op land *tmp60 *tmp57 *tmp59
+  188 jump *label259 notEqual *tmp60 false
   189 label *label53
   190 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   191 jump *label54 equal :b_type @vault

Modifications by Replicate loop condition at line 189:1 (+3 instructions):
 
   220 op notEqual *tmp68 :sorter_type @inverted-sorter
   221 op land *tmp69 *tmp67 *tmp68
   222 jump *label60 equal *tmp69 false
+  223 label *label260
   224 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   225 print "\n"
   226 jump *label61 equal .SORTER null
 
   232 set .SORTER sorter1
   233 sensor :sorter_type sorter1 @type
   234 label *label59
-    * jump *label58 always
+  235 op notEqual *tmp67 :sorter_type @sorter
+  236 op notEqual *tmp68 :sorter_type @inverted-sorter
+  237 op land *tmp69 *tmp67 *tmp68
+  238 jump *label260 notEqual *tmp69 false
   239 label *label60
   240 jump *label63 notEqual :sorter_type @sorter
   241 set .SHOW_REMOTE_LEVEL true

Modifications by Convert case at line 704:5 (segments: 4) (+2 instructions):
 
   434 label *label99
   435 set .LAST_ITEM .ITEM
   436 sensor *tmp160 .ITEM @id
-    * jump *label102 notEqual *tmp160 14
+  437 jump *label262 greaterThanEq *tmp160 3
+  438 jump *label263 greaterThanEq *tmp160 1
+  439 jump *label261 lessThan *tmp160 0
+  440 label *label107
+  441 set *tmp159 "[]"
+  442 jump *label101 always
+  443 label *label263
+  444 jump *label113 greaterThanEq *tmp160 2
+  445 label *label111
+  446 set *tmp159 "[]"
+  447 jump *label101 always
+  448 label *label262
+  449 jump *label261 greaterThanEq *tmp160 16
+  450 multijump *label264 *tmp160 3 (m:*label277)
+  451 multilabel *label264 (m:*label277)
+  452 jump *label109 always
+  453 multilabel *label265 (m:*label277)
+  454 jump *label121 always
+  455 multilabel *label266 (m:*label277)
+  456 jump *label105 always
+  457 multilabel *label267 (m:*label277)
+  458 jump *label133 always
+  459 multilabel *label268 (m:*label277)
+  460 jump *label131 always
+  461 multilabel *label269 (m:*label277)
+  462 jump *label123 always
+  463 multilabel *label270 (m:*label277)
+  464 jump *label125 always
+  465 multilabel *label271 (m:*label277)
+  466 jump *label117 always
+  467 multilabel *label272 (m:*label277)
+  468 jump *label115 always
+  469 multilabel *label273 (m:*label277)
+  470 jump *label129 always
+  471 multilabel *label274 (m:*label277)
+  472 jump *label127 always
+  473 multilabel *label275 (m:*label277)
+  474 jump *label103 always
+  475 multilabel *label276 (m:*label277)
+  476 label *label119
+  477 set *tmp159 "[]"
+  478 jump *label101 always
   479 label *label103
   480 set *tmp159 "[]"
   481 jump *label101 always
   482 label *label102
-    * jump *label104 notEqual *tmp160 5
   483 label *label105
   484 set *tmp159 "[]"
   485 jump *label101 always
   486 label *label104
-    * jump *label106 notEqual *tmp160 0
-    * label *label107
-    * set *tmp159 "[]"
-    * jump *label101 always
   487 label *label106
-    * jump *label108 notEqual *tmp160 3
   488 label *label109
   489 set *tmp159 "[]"
   490 jump *label101 always
   491 label *label108
-    * jump *label110 notEqual *tmp160 1
-    * label *label111
-    * set *tmp159 "[]"
-    * jump *label101 always
   492 label *label110
-    * jump *label112 notEqual *tmp160 2
   493 label *label113
   494 set *tmp159 "[]"
   495 jump *label101 always
   496 label *label112
-    * jump *label114 notEqual *tmp160 11
   497 label *label115
   498 set *tmp159 "[]"
   499 jump *label101 always
   500 label *label114
-    * jump *label116 notEqual *tmp160 10
   501 label *label117
   502 set *tmp159 "[]"
   503 jump *label101 always
   504 label *label116
-    * jump *label118 notEqual *tmp160 15
-    * label *label119
-    * set *tmp159 "[]"
-    * jump *label101 always
   505 label *label118
-    * jump *label120 notEqual *tmp160 4
   506 label *label121
   507 set *tmp159 "[]"
   508 jump *label101 always
   509 label *label120
-    * jump *label122 notEqual *tmp160 8
   510 label *label123
   511 set *tmp159 "[]"
   512 jump *label101 always
   513 label *label122
-    * jump *label124 notEqual *tmp160 9
   514 label *label125
   515 set *tmp159 "[]"
   516 jump *label101 always
   517 label *label124
-    * jump *label126 notEqual *tmp160 13
   518 label *label127
   519 set *tmp159 "[]"
   520 jump *label101 always
   521 label *label126
-    * jump *label128 notEqual *tmp160 12
   522 label *label129
   523 set *tmp159 "[]"
   524 jump *label101 always
   525 label *label128
-    * jump *label130 notEqual *tmp160 7
   526 label *label131
   527 set *tmp159 "[]"
   528 jump *label101 always
   529 label *label130
-    * jump *label132 notEqual *tmp160 6
   530 label *label133
   531 set *tmp159 "[]"
   532 jump *label101 always
   533 label *label132
+  534 label *label261
   535 set *tmp159 null
   536 label *label101
   537 label *label100

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-7 instructions):
 
   209 set .DISCARD_UNIT_MAX_ITEMS 0
   210 jump *label57 equal DROP_TO_AIR false
   211 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
-    * jump *label57 always
   212 label *label57
   213 set .DROP_TO_CORE false
   214 label *label34
 
   257 set .DIRECTION " from vault #"
   258 jump *label66 notEqual LINK_ID 0
   259 set .DIRECTION " from core"
-    * jump *label66 always
   260 label *label66
   261 jump *label64 always
   262 label *label63
 
   283 set .DIRECTION " to vault #"
   284 jump *label68 notEqual LINK_ID 0
   285 set .DIRECTION " to core"
-    * jump *label68 always
   286 label *label68
   287 label *label64
   288 set *tmp101 LINK_ID
   289 jump *label70 notEqual LINK_ID 0
   290 set *tmp101 ""
-    * jump *label70 always
   291 label *label70
   292 op sub *tmp102 :src_capacity .LOAD_LEVEL
   293 op min .LOAD_PACK .UNIT_CAPACITY *tmp102
 
   401 set .AUTO_ALLOCATION_TXT ""
   402 jump *label90 notEqual .TARGET 0
   403 set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivated[] ==="
-    * jump *label90 always
   404 label *label90
   405 label *label88
   406 set .WAIT_LIMIT 30000
 
   580 set .CORR_SIGN "[]([green]"
   581 jump *label139 lessThan :corr_per_min 0
   582 set .CORR_SIGN "[]([green]+"
-    * jump *label139 always
   583 label *label139
   584 set .SPEED_UNIT_TXT "[])/min"
   585 jump *label140 equal :alive false
 
   686 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   687 op add .MESSAGE_TIMEOUT @tick 600
   688 label *label160
-    * jump *label150 always
   689 label *label150
   690 set :last_level :findAnotherContainer:min_level
   691 label *label148

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   151 label *label45
   152 ucontrol flag .QUERY_FLAG
   153 label *label46
-    * op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
+  154 set *tmp46 true
   155 sensor *tmp47 @unit @dead
   156 op equal *tmp48 *tmp47 0
   157 op land *tmp49 *tmp46 *tmp48

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   154 set *tmp46 true
   155 sensor *tmp47 @unit @dead
   156 op equal *tmp48 *tmp47 0
-    * op land *tmp49 *tmp46 *tmp48
+  157 op land *tmp49 true *tmp48
   158 jump *label48 equal *tmp49 false
   159 label *label258
   160 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
   151 label *label45
   152 ucontrol flag .QUERY_FLAG
   153 label *label46
-    * set *tmp46 true
   154 sensor *tmp47 @unit @dead
   155 op equal *tmp48 *tmp47 0
   156 op land *tmp49 true *tmp48

Modifications by Iterated phase, If Expression Optimization, pass 2, iteration 1:
 
   302 op max *tmp114 .DISTANCE 10
   303 op mul *tmp115 2 *tmp114
   304 op div .TRAVEL_TIME *tmp115 .SPEED
+  305 op add .PARK_X .CORE_X -15
   306 sensor *tmp117 .CONTAINER @x
-    * jump *label71 greaterThanEq *tmp117 .CORE_X
+  307 jump *label72 greaterThanEq *tmp117 .CORE_X
   308 op add .PARK_X .CORE_X 15
   309 jump *label72 always
-    * label *label71
-    * op add .PARK_X .CORE_X -15
   310 label *label72
+  311 op add .PARK_Y .CORE_Y -15
   312 sensor *tmp121 .CONTAINER @y
-    * jump *label73 greaterThanEq *tmp121 .CORE_Y
+  313 jump *label74 greaterThanEq *tmp121 .CORE_Y
   314 op add .PARK_Y .CORE_Y 15
   315 jump *label74 always
-    * label *label73
-    * op add .PARK_Y .CORE_Y -15
   316 label *label74
   317 op equal *tmp125 LINK_ID 0
   318 op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-2 instructions):
 
   306 sensor *tmp117 .CONTAINER @x
   307 jump *label72 greaterThanEq *tmp117 .CORE_X
   308 op add .PARK_X .CORE_X 15
-    * jump *label72 always
   309 label *label72
   310 op add .PARK_Y .CORE_Y -15
   311 sensor *tmp121 .CONTAINER @y
   312 jump *label74 greaterThanEq *tmp121 .CORE_Y
   313 op add .PARK_Y .CORE_Y 15
-    * jump *label74 always
   314 label *label74
   315 op equal *tmp125 LINK_ID 0
   316 op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1:
 
   153 label *label46
   154 sensor *tmp47 @unit @dead
   155 op equal *tmp48 *tmp47 0
-    * op land *tmp49 true *tmp48
+  156 set *tmp49 *tmp48
   157 jump *label48 equal *tmp49 false
   158 label *label258
   159 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1 (-1 instructions):
 
   152 ucontrol flag .QUERY_FLAG
   153 label *label46
   154 sensor *tmp47 @unit @dead
-    * op equal *tmp48 *tmp47 0
-    * set *tmp49 *tmp48
+  155 op equal *tmp49 *tmp47 0
   156 jump *label48 equal *tmp49 false
   157 label *label258
   158 ucontrol stop

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
    22 set STABILIZATION false
    23 remark "End of configurable options"
    24 printflush null
-    * label *label13
    25 set .MESSAGE ""
    26 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
    27 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
 
    35 set .CONTAINER_INDEX null
    36 op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH
    37 ubind UNIT
-    * label *label14
    38 jump *label16 notEqual @unit null
    39 label *label250
    40 print "[salmon]No unit of type "
 
    43 print "found."
    44 printflush message1
    45 ubind UNIT
-    * label *label15
    46 jump *label250 equal @unit null
    47 label *label16
    48 set :first_unit @unit
 
    60 op land *tmp18 *tmp16 *tmp17
    61 op add .TARGET .TARGET *tmp18
    62 label *label20
-    * label *label21
    63 ubind UNIT
-    * label *label18
    64 op notEqual *tmp19 @unit :first_unit
    65 sensor *tmp20 :first_unit @dead
    66 op equal *tmp21 *tmp20 0
    67 op land *tmp22 *tmp19 *tmp21
    68 jump *label17 notEqual *tmp22 false
-    * label *label19
    69 set .CHANGE 0
    70 set :active .TARGET
    71 set .DEC_LIMIT 0
 
    76 set .CONTAINER null
    77 set .CONTAINERS 0
    78 set :n @links
-    * label *label25
    79 jump *label27 lessThanEq :n 0
    80 label *label251
    81 op sub :n :n 1
 
    88 op add .CONTAINERS .CONTAINERS 1
    89 set .CONTAINER_INDEX :n
    90 label *label29
-    * label *label28
-    * label *label26
    91 jump *label251 greaterThan :n 0
    92 label *label27
    93 jump *label31 notEqual .CONTAINER null
 
    97 label *label31
    98 jump *label24 always
    99 label *label32
-    * label *label23
   100 jump *label22 always
   101 label *label24
   102 set .CORE null
   103 jump *label33 notEqual LINK_ID 0
-    * label *label35
   104 label *label252
   105 print "[green]Locating core..."
   106 printflush message1
 
   110 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   111 ucontrol flag .S_UNUSED
   112 label *label38
-    * label *label39
-    * label *label36
   113 jump *label252 equal .CORE null
-    * label *label37
   114 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
   115 op equal .DROP_TO_CORE DROP_TO_AIR false
   116 jump *label34 always
 
   122 print ".."
   123 printflush message1
   124 op add .QUERY_FLAG 99999900 LINK_ID
-    * label *label40
   125 label *label253
   126 set :flag .QUERY_FLAG
   127 ubind UNIT
-    * label *label43
   128 sensor *tmp44 @unit @controlled
   129 jump *label45 equal *tmp44 0
   130 label *label257
   131 ubind UNIT
-    * label *label44
   132 sensor *tmp44 @unit @controlled
   133 jump *label257 notEqual *tmp44 0
   134 label *label45
   135 ucontrol flag .QUERY_FLAG
-    * label *label46
   136 sensor *tmp47 @unit @dead
   137 op equal *tmp49 *tmp47 0
   138 jump *label48 equal *tmp49 false
   139 label *label258
   140 ucontrol stop
   141 sensor :flag @unit @flag
-    * label *label47
   142 op equal *tmp46 :flag .QUERY_FLAG
   143 sensor *tmp47 @unit @dead
   144 op equal *tmp48 *tmp47 0
 
   149 op idiv :position :flag 100
   150 op mod .CORE_X :position @mapw
   151 op idiv .CORE_Y :position @mapw
-    * label *label51
   152 sensor *tmp56 @unit @dead
   153 op equal *tmp57 *tmp56 0
   154 ucontrol within .CORE_X .CORE_Y 8 *tmp58
 
   157 jump *label53 equal *tmp60 false
   158 label *label259
   159 ucontrol approach .CORE_X .CORE_Y 6
-    * label *label52
   160 sensor *tmp56 @unit @dead
   161 op equal *tmp57 *tmp56 0
   162 ucontrol within .CORE_X .CORE_Y 8 *tmp58
 
   176 printflush message2
   177 set .CORE null
   178 label *label54
-    * label *label55
   179 label *label49
-    * label *label50
   180 ucontrol flag .S_UNUSED
-    * label *label41
   181 jump *label253 equal .CORE null
-    * label *label42
   182 set .DISCARD_UNIT_MAX_ITEMS 0
   183 jump *label57 equal DROP_TO_AIR false
   184 set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY
 
   187 label *label34
   188 set .SORTER sorter1
   189 sensor :sorter_type sorter1 @type
-    * label *label58
   190 op notEqual *tmp67 :sorter_type @sorter
   191 op notEqual *tmp68 :sorter_type @inverted-sorter
   192 op land *tmp69 *tmp67 *tmp68
 
   198 print "Block found: "
   199 print .SORTER
   200 label *label61
-    * label *label62
   201 printflush message1
   202 set .SORTER sorter1
   203 sensor :sorter_type sorter1 @type
-    * label *label59
   204 op notEqual *tmp67 :sorter_type @sorter
   205 op notEqual *tmp68 :sorter_type @inverted-sorter
   206 op land *tmp69 *tmp67 *tmp68
 
   320 label *label76
   321 label *label77
   322 ubind UNIT
-    * label *label80
   323 jump *label82 notEqual @unit null
   324 label *label254
   325 print "No unit of type "
 
   328 print "found."
   329 printflush message1
   330 ubind UNIT
-    * label *label81
   331 jump *label254 equal @unit null
   332 label *label82
   333 sensor *tmp132 switch1 @enabled
 
   342 set .SPEED_UNIT_TXT "/min"
   343 set .WAIT_LIMIT 30000
   344 label *label83
-    * label *label84
   345 sensor *tmp137 switch2 @enabled
   346 jump *label85 equal *tmp137 false
   347 control enabled switch2 false
 
   368 label *label88
   369 set .WAIT_LIMIT 30000
   370 label *label85
-    * label *label86
   371 sensor *tmp146 :first_unit @dead
   372 op equal :alive *tmp146 0
   373 op equal *tmp148 @unit :first_unit
 
   375 jump *label93 notEqual :active 0
   376 print "\n[salmon]No active units.[]"
   377 label *label93
-    * label *label94
   378 printflush message2
   379 set .STATE_LIMIT 6
   380 sensor .ITEM .SORTER @config
   381 jump *label95 equal .ITEM .LAST_ITEM
-    * label *label97
   382 jump *label99 notEqual .ITEM null
   383 label *label255
   384 print "[salmon]No item type selected for transport.[]"
   385 printflush message1
   386 sensor .ITEM .SORTER @config
-    * label *label98
   387 jump *label255 equal .ITEM null
   388 label *label99
   389 set .LAST_ITEM .ITEM
 
   391 jump *label262 greaterThanEq *tmp160 3
   392 jump *label263 greaterThanEq *tmp160 1
   393 jump *label261 lessThan *tmp160 0
-    * label *label107
   394 set *tmp159 "[]"
   395 jump *label101 always
   396 label *label263
   397 jump *label113 greaterThanEq *tmp160 2
-    * label *label111
   398 set *tmp159 "[]"
   399 jump *label101 always
   400 label *label262
 
   425 multilabel *label275 (m:*label277)
   426 jump *label103 always
   427 multilabel *label276 (m:*label277)
-    * label *label119
   428 set *tmp159 "[]"
   429 jump *label101 always
   430 label *label103
   431 set *tmp159 "[]"
   432 jump *label101 always
-    * label *label102
   433 label *label105
   434 set *tmp159 "[]"
   435 jump *label101 always
-    * label *label104
-    * label *label106
   436 label *label109
   437 set *tmp159 "[]"
   438 jump *label101 always
-    * label *label108
-    * label *label110
   439 label *label113
   440 set *tmp159 "[]"
   441 jump *label101 always
-    * label *label112
   442 label *label115
   443 set *tmp159 "[]"
   444 jump *label101 always
-    * label *label114
   445 label *label117
   446 set *tmp159 "[]"
   447 jump *label101 always
-    * label *label116
-    * label *label118
   448 label *label121
   449 set *tmp159 "[]"
   450 jump *label101 always
-    * label *label120
   451 label *label123
   452 set *tmp159 "[]"
   453 jump *label101 always
-    * label *label122
   454 label *label125
   455 set *tmp159 "[]"
   456 jump *label101 always
-    * label *label124
   457 label *label127
   458 set *tmp159 "[]"
   459 jump *label101 always
-    * label *label126
   460 label *label129
   461 set *tmp159 "[]"
   462 jump *label101 always
-    * label *label128
   463 label *label131
   464 set *tmp159 "[]"
   465 jump *label101 always
-    * label *label130
   466 label *label133
   467 set *tmp159 "[]"
   468 jump *label101 always
-    * label *label132
   469 label *label261
   470 set *tmp159 null
   471 label *label101
-    * label *label100
   472 set .ITEM_ICON *tmp159
   473 set .STATE_LIMIT 1
   474 sensor :last_level .CONTAINER .ITEM
   475 set :min_level 999999
   476 set :max_level 0
   477 label *label95
-    * label *label96
   478 sensor :container_items .CONTAINER .ITEM
   479 op min :min_level :min_level :container_items
   480 op max :max_level :max_level :container_items
 
   536 op add *tmp229 *tmp228 :total_flow_per_ms
   537 op div :total_flow_per_ms *tmp229 3
   538 label *label144
-    * label *label145
   539 op div *tmp231 :total_flow_per_ms :items_per_ms_unit
   540 op add *tmp232 *tmp231 OVERALLOCATION_LOW
   541 op ceil :new_target *tmp232
 
   567 set :min_level 999999
   568 set :max_level 0
   569 label *label136
-    * label *label137
   570 op greaterThan *tmp249 .CONTAINERS 1
   571 op equal *tmp250 .SRC .CORE
   572 op land *tmp251 *tmp249 *tmp250
 
   577 set :findAnotherContainer:min_level 999999
   578 set .CONTAINERS 0
   579 set :findAnotherContainer:n @links
-    * label *label151
   580 jump *label153 lessThanEq :findAnotherContainer:n 0
   581 label *label256
   582 op sub :findAnotherContainer:n :findAnotherContainer:n 1
 
   592 set .CONTAINER :findAnotherContainer:block
   593 set .CONTAINER_INDEX :findAnotherContainer:n
   594 label *label157
-    * label *label158
   595 label *label155
-    * label *label154
-    * label *label152
   596 jump *label256 greaterThan :findAnotherContainer:n 0
   597 label *label153
   598 jump *label159 notEqual .CONTAINERS 0
 
   618 set .MESSAGE "[salmon]Container filled up, switching...[]\n"
   619 op add .MESSAGE_TIMEOUT @tick 600
   620 label *label160
-    * label *label150
   621 set :last_level :findAnotherContainer:min_level
   622 label *label148
-    * label *label149
   623 label *label146
-    * label *label147
   624 set :wait_time 0
   625 set :remote_wait_time 0
   626 jump *label161 lessThan @tick .MESSAGE_TIMEOUT
   627 set .MESSAGE ""
   628 label *label161
-    * label *label162
   629 label *label134
-    * label *label135
   630 print .MESSAGE
   631 print "Moving [green]"
   632 print .ITEM
 
   665 jump *label167 lessThanEq .CHANGE 0
   666 print "\n[][salmon]Cannot acquire additional units![]"
   667 label *label167
-    * label *label168
   668 label *label163
-    * label *label164
   669 print "\n"
   670 print "[]Local items: [gold]"
   671 print :container_items
 
   675 print "["
   676 print "])"
   677 label *label169
-    * label *label170
   678 jump *label171 equal .SHOW_REMOTE_LEVEL false
   679 sensor :remote_level .CORE .ITEM
   680 print "\n"
 
   686 print "["
   687 print "])"
   688 label *label173
-    * label *label174
   689 label *label171
-    * label *label172
   690 jump *label175 lessThanEq .TARGET 0
   691 print "\n"
   692 print "[]Speed: [green]"
 
   722 print "["
   723 print "] s"
   724 label *label175
-    * label *label176
   725 print "\n"
   726 print "[lightgray]Loop: "
   727 print :loop_time_ms
 
   737 jump *label179 equal *tmp305 0
   738 jump *label79 always
   739 label *label179
-    * label *label180
   740 sensor *tmp308 .DST @dead
   741 jump *label181 equal *tmp308 0
   742 jump *label79 always
   743 label *label181
-    * label *label182
   744 sensor *tmp311 .SORTER @dead
   745 jump *label183 equal *tmp311 0
   746 jump *label79 always
   747 label *label183
-    * label *label184
   748 getlink *tmp314 .CONTAINER_INDEX
   749 jump *label185 equal .CONTAINER *tmp314
   750 jump *label79 always
   751 label *label185
-    * label *label186
   752 label *label91
-    * label *label92
   753 jump *label187 lessThanEq .CHANGE 0
   754 sensor *tmp319 @unit @controlled
   755 jump *label189 notEqual *tmp319 0
   756 op sub .CHANGE .CHANGE 1
   757 ucontrol flag 1
   758 label *label189
-    * label *label190
   759 label *label187
-    * label *label188
   760 sensor *tmp322 @unit @controller
   761 jump *label191 notEqual *tmp322 @this
   762 sensor :state @unit @flag
 
   770 op add .CHANGE .CHANGE 1
   771 set :state 6
   772 label *label199
-    * label *label200
   773 label *label197
-    * label *label198
   774 label *label195
-    * label *label196
   775 jump *label201 notEqual :state 1
   776 set :state 2
   777 sensor *tmp339 @unit @totalItems
   778 jump *label204 equal *tmp339 0
-    * label *label203
   779 set :state 4
   780 sensor *tmp342 @unit @firstItem
   781 jump *label206 equal *tmp342 .ITEM
-    * label *label205
   782 jump *label207 equal .DROP_TO_CORE false
   783 ucontrol approach .CORE_X .CORE_Y 6
   784 ucontrol within .CORE_X .CORE_Y 8 *tmp346
   785 jump *label209 equal *tmp346 false
   786 ucontrol itemDrop .CORE .UNIT_CAPACITY
   787 label *label209
-    * label *label210
   788 print "[]"
   789 print "\n"
   790 print "Unloading previous items: [green]"
 
   796 label *label206
   797 label *label204
   798 label *label201
-    * label *label202
   799 jump *label211 notEqual :state 2
   800 ucontrol approach .SRC_X .SRC_Y 6
   801 ucontrol within .SRC_X .SRC_Y 8 *tmp350
 
   820 print ":"
   821 print " [green]"
   822 jump *label217 always
-    * label *label216
   823 print "[]"
   824 print "\n"
   825 print "Going to "
 
   827 print ":"
   828 print " [green]"
   829 label *label217
-    * label *label215
   830 label *label214
   831 label *label211
-    * label *label212
   832 jump *label218 notEqual :state 3
   833 sensor *tmp363 .SRC .ITEM
   834 op sub :max_load *tmp363 .LOAD_LEVEL
   835 jump *label220 lessThan :max_load .LOAD_PACK
   836 ucontrol itemTake .SRC .ITEM :max_load
   837 label *label220
-    * label *label221
   838 sensor *tmp367 @unit @totalItems
   839 jump *label222 lessThan *tmp367 .UNIT_CAPACITY
   840 set :state 4
 
   849 op add :remote_wait_time :remote_wait_time *tmp370
   850 label *label223
   851 label *label218
-    * label *label219
   852 jump *label224 notEqual :state 4
   853 ucontrol approach .DST_X .DST_Y 6
   854 ucontrol within .DST_X .DST_Y 8 *tmp373
 
   876 print ":"
   877 print " [green]"
   878 jump *label230 always
-    * label *label229
   879 print "[]"
   880 print "\n"
   881 print "Going to "
 
   883 print ":"
   884 print " [green]"
   885 label *label230
-    * label *label228
   886 label *label227
   887 label *label224
-    * label *label225
   888 jump *label231 notEqual :state 5
   889 sensor *tmp387 .DST .ITEM
   890 op sub :max_drop .DROP_LEVEL *tmp387
   891 jump *label233 lessThan :max_drop .DROP_PACK
   892 ucontrol itemDrop .DST :max_drop
   893 label *label233
-    * label *label234
   894 sensor *tmp391 @unit @totalItems
   895 jump *label235 greaterThan *tmp391 0
   896 set :state 2
 
   912 print ":"
   913 print " [green]"
   914 jump *label239 always
-    * label *label238
   915 print "[]"
   916 print "\n"
   917 print "Going to "
 
   919 print ":"
   920 print " [green]"
   921 label *label239
-    * label *label237
   922 jump *label236 always
   923 label *label235
   924 print "[]"
 
   930 op add :remote_wait_time :remote_wait_time *tmp403
   931 label *label236
   932 label *label231
-    * label *label232
   933 sensor :items @unit @totalItems
   934 op add :items_in_transit :items_in_transit :items
   935 jump *label240 notEqual :state 6
 
   944 ucontrol itemDrop .CORE .UNIT_CAPACITY
   945 sensor :items @unit @totalItems
   946 label *label246
-    * label *label247
   947 jump *label245 always
   948 label *label244
   949 ucontrol itemDrop @air .UNIT_CAPACITY
   950 sensor :items @unit @totalItems
   951 label *label245
   952 label *label242
-    * label *label243
   953 jump *label248 greaterThan :items .PARK_ITEM_LIMIT
   954 ucontrol move .PARK_X .PARK_Y
   955 set :state .S_UNUSED
   956 label *label248
-    * label *label249
   957 jump *label241 always
   958 label *label240
   959 op add :active :active 1
 
   962 print .ITEM_ICON
   963 ucontrol flag :state
   964 label *label193
-    * label *label194
   965 label *label191
-    * label *label192
-    * label *label78
   966 jump *label77 always
   967 label *label79
   968 control enabled switch1 false

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-4 instructions):
 
   734 set :items_in_transit 0
   735 print "Unit status:"
   736 sensor *tmp305 .SRC @dead
-    * jump *label179 equal *tmp305 0
-    * jump *label79 always
+  737 jump *label79 notEqual *tmp305 0
   738 label *label179
   739 sensor *tmp308 .DST @dead
-    * jump *label181 equal *tmp308 0
-    * jump *label79 always
+  740 jump *label79 notEqual *tmp308 0
   741 label *label181
   742 sensor *tmp311 .SORTER @dead
-    * jump *label183 equal *tmp311 0
-    * jump *label79 always
+  743 jump *label79 notEqual *tmp311 0
   744 label *label183
   745 getlink *tmp314 .CONTAINER_INDEX
-    * jump *label185 equal .CONTAINER *tmp314
-    * jump *label79 always
+  746 jump *label79 notEqual .CONTAINER *tmp314
   747 label *label185
   748 label *label91
   749 jump *label187 lessThanEq .CHANGE 0

Modifications by Jumps phase, Jump Optimization, pass 5, iteration 1:
 
   735 print "Unit status:"
   736 sensor *tmp305 .SRC @dead
   737 jump *label79 notEqual *tmp305 0
-    * label *label179
   738 sensor *tmp308 .DST @dead
   739 jump *label79 notEqual *tmp308 0
-    * label *label181
   740 sensor *tmp311 .SORTER @dead
   741 jump *label79 notEqual *tmp311 0
-    * label *label183
   742 getlink *tmp314 .CONTAINER_INDEX
   743 jump *label79 notEqual .CONTAINER *tmp314
-    * label *label185
   744 label *label91
   745 jump *label187 lessThanEq .CHANGE 0
   746 sensor *tmp319 @unit @controlled

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
 
    90 label *label29
    91 jump *label251 greaterThan :n 0
    92 label *label27
-    * jump *label31 notEqual .CONTAINER null
+   93 jump *label24 notEqual .CONTAINER null
    94 print "[salmon]No vault or container."
    95 printflush message1
-    * jump *label32 always
+   96 jump *label22 always
    97 label *label31
    98 jump *label24 always
    99 label *label32
 
   225 set .SRC_REMOTE_WAIT 1
   226 set .DST_REMOTE_WAIT 0
   227 set .DIRECTION " from vault #"
-    * jump *label66 notEqual LINK_ID 0
+  228 jump *label64 notEqual LINK_ID 0
   229 set .DIRECTION " from core"
   230 label *label66
   231 jump *label64 always
 
   750 label *label189
   751 label *label187
   752 sensor *tmp322 @unit @controller
-    * jump *label191 notEqual *tmp322 @this
+  753 jump *label77 notEqual *tmp322 @this
   754 sensor :state @unit @flag
-    * jump *label193 equal :state .S_UNUSED
+  755 jump *label77 equal :state .S_UNUSED
   756 op max *tmp328 :state 1
   757 op min :state *tmp328 .STATE_LIMIT
   758 jump *label195 greaterThanEq .CHANGE 0
 
   903 print "source"
   904 print ":"
   905 print " [green]"
-    * jump *label239 always
+  906 jump *label236 always
   907 print "[]"
   908 print "\n"
   909 print "Going to "
 
   932 jump *label244 equal .DROP_TO_CORE false
   933 ucontrol approach .CORE_X .CORE_Y 6
   934 ucontrol within .CORE_X .CORE_Y 8 *tmp410
-    * jump *label246 equal *tmp410 false
+  935 jump *label245 equal *tmp410 false
   936 ucontrol itemDrop .CORE .UNIT_CAPACITY
   937 sensor :items @unit @totalItems
   938 label *label246
 
   942 sensor :items @unit @totalItems
   943 label *label245
   944 label *label242
-    * jump *label248 greaterThan :items .PARK_ITEM_LIMIT
+  945 jump *label241 greaterThan :items .PARK_ITEM_LIMIT
   946 ucontrol move .PARK_X .PARK_Y
   947 set :state .S_UNUSED
   948 label *label248

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-21 instructions):
 
    94 print "[salmon]No vault or container."
    95 printflush message1
    96 jump *label22 always
-    * label *label31
-    * jump *label24 always
-    * label *label32
-    * jump *label22 always
    97 label *label24
    98 set .CORE null
    99 jump *label33 notEqual LINK_ID 0
 
   223 set .DIRECTION " from vault #"
   224 jump *label64 notEqual LINK_ID 0
   225 set .DIRECTION " from core"
-    * label *label66
   226 jump *label64 always
   227 label *label63
   228 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   807 print ":"
   808 print " [green]"
   809 jump *label217 always
-    * print "[]"
-    * print "\n"
-    * print "Going to "
-    * print "source"
-    * print ":"
-    * print " [green]"
   810 label *label217
   811 label *label214
   812 label *label211
 
   857 print ":"
   858 print " [green]"
   859 jump *label230 always
-    * print "[]"
-    * print "\n"
-    * print "Going to "
-    * print "destination"
-    * print ":"
-    * print " [green]"
   860 label *label230
   861 label *label227
   862 label *label224
 
   887 print ":"
   888 print " [green]"
   889 jump *label236 always
-    * print "[]"
-    * print "\n"
-    * print "Going to "
-    * print "source"
-    * print ":"
-    * print " [green]"
-    * label *label239
-    * jump *label236 always
   890 label *label235
   891 print "[]"
   892 print "\n"
 
   910 jump *label245 equal *tmp410 false
   911 ucontrol itemDrop .CORE .UNIT_CAPACITY
   912 sensor :items @unit @totalItems
-    * label *label246
   913 jump *label245 always
   914 label *label244
   915 ucontrol itemDrop @air .UNIT_CAPACITY
 
   919 jump *label241 greaterThan :items .PARK_ITEM_LIMIT
   920 ucontrol move .PARK_X .PARK_Y
   921 set :state .S_UNUSED
-    * label *label248
   922 jump *label241 always
   923 label *label240
   924 op add :active :active 1
 
   926 print :items
   927 print .ITEM_ICON
   928 ucontrol flag :state
-    * label *label193
-    * label *label191
   929 jump *label77 always
   930 label *label79
   931 control enabled switch1 false

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-3 instructions):
 
   806 print "source"
   807 print ":"
   808 print " [green]"
-    * jump *label217 always
   809 label *label217
   810 label *label214
   811 label *label211
 
   855 print "destination"
   856 print ":"
   857 print " [green]"
-    * jump *label230 always
   858 label *label230
   859 label *label227
   860 label *label224
 
   928 label *label79
   929 control enabled switch1 false
   930 control enabled switch2 false
-    * end

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
   806 print "source"
   807 print ":"
   808 print " [green]"
-    * label *label217
   809 label *label214
   810 label *label211
   811 jump *label218 notEqual :state 3
 
   854 print "destination"
   855 print ":"
   856 print " [green]"
-    * label *label230
   857 label *label227
   858 label *label224
   859 jump *label231 notEqual :state 5

Modifications by Final phase, Print Merging, iteration 1 (-56 instructions):
 
    39 label *label250
    40 print "[salmon]No unit of type "
    41 print UNIT
-    * print " "
-    * print "found."
+   42 print " found."
    43 printflush message1
    44 ubind UNIT
    45 jump *label250 equal @unit null
 
   113 printflush message2
   114 print "[green]Locating vault #"
   115 print LINK_ID
-    * print "."
-    * print ".."
+  116 print "..."
   117 printflush message1
   118 op add .QUERY_FLAG 99999900 LINK_ID
   119 label *label253
 
   162 jump *label54 equal :b_type @vault
   163 print "[salmon]Building at "
   164 print .CORE_X
-    * print ","
-    * print " "
+  165 print ", "
   166 print .CORE_Y
-    * print " "
-    * print "is not a vault!"
+  167 print " is not a vault!"
   168 printflush message2
   169 set .CORE null
   170 label *label54
 
   184 op land *tmp69 *tmp67 *tmp68
   185 jump *label60 equal *tmp69 false
   186 label *label260
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  187 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   188 jump *label61 equal .SORTER null
   189 print "Block found: "
   190 print .SORTER
 
   314 label *label254
   315 print "No unit of type "
   316 print UNIT
-    * print " "
-    * print "found."
+  317 print " found."
   318 printflush message1
   319 ubind UNIT
   320 jump *label254 equal @unit null
 
   619 print .MESSAGE
   620 print "Moving [green]"
   621 print .ITEM
-    * print "["
-    * print "]"
+  622 print "[]"
   623 print .DIRECTION
   624 print *tmp101
   625 print .AUTO_ALLOCATION_TXT
   626 jump *label163 lessThanEq .TARGET 0
   627 jump *label165 lessThan :active .TARGET
-    * print "\n"
-    * print "Using [green]"
+  628 print "\nUsing [green]"
   629 print :active
   630 print "/"
   631 print .TARGET
-    * print "["
-    * print "] units ("
+  632 print "[] units ("
   633 print UNIT
-    * print ")"
-    * print " [gold]+"
+  634 print ") [gold]+"
   635 print :items_in_transit
   636 jump *label166 always
   637 label *label165
-    * print "\n"
-    * print "Using [salmon]"
+  638 print "\nUsing [salmon]"
   639 print :active
   640 print "/"
   641 print .TARGET
-    * print "["
-    * print "] units ("
+  642 print "[] units ("
   643 print UNIT
-    * print ")"
-    * print " [gold]+"
+  644 print ") [gold]+"
   645 print :items_in_transit
   646 label *label166
   647 jump *label167 lessThanEq .CHANGE 0
   648 print "\n[][salmon]Cannot acquire additional units![]"
   649 label *label167
   650 label *label163
-    * print "\n"
-    * print "[]Local items: [gold]"
+  651 print "\n[]Local items: [gold]"
   652 print :container_items
   653 jump *label169 greaterThanEq .EFF_LOCAL_LIMIT 100
   654 print "[] (limit [orange]"
   655 print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  656 print "[])"
   657 label *label169
   658 jump *label171 equal .SHOW_REMOTE_LEVEL false
   659 sensor :remote_level .CORE .ITEM
-    * print "\n"
-    * print "[]Remote items: [gold]"
+  660 print "\n[]Remote items: [gold]"
   661 print :remote_level
   662 jump *label173 greaterThanEq .EFF_REMOTE_LIMIT 100
   663 print "[] (limit [orange]"
   664 print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  665 print "[])"
   666 label *label173
   667 label *label171
   668 jump *label175 lessThanEq .TARGET 0
-    * print "\n"
-    * print "[]Speed: [green]"
+  669 print "\n[]Speed: [green]"
   670 print :items_per_min
   671 print .CORR_SIGN
   672 print :corr_per_min
   673 print .SPEED_UNIT_TXT
   674 jump *label177 equal .EFF_AUTO_ALLOCATION false
-    * print "\n"
-    * print "Unit throughput: [green]"
+  675 print "\nUnit throughput: [green]"
   676 print :items_per_min_unit
-    * print "["
-    * print "]/min"
-    * print "\n"
-    * print "Min/last round: [green]"
+  677 print "[]/min\nMin/last round: [green]"
   678 print :turnaround_str
-    * print "["
-    * print "]/[green]"
+  679 print "[]/[green]"
   680 print :elapsed_str
-    * print "["
-    * print "] s"
+  681 print "[] s"
   682 jump *label178 always
   683 label *label177
-    * print "\n"
-    * print "Last round: [green]"
+  684 print "\nLast round: [green]"
   685 print :elapsed_str
-    * print "["
-    * print "] s"
+  686 print "[] s"
   687 label *label178
-    * print "\n"
-    * print "Total wait time: [green]"
+  688 print "\nTotal wait time: [green]"
   689 print :wait_time_str
-    * print "["
-    * print "] s"
+  690 print "[] s"
   691 label *label175
-    * print "\n"
-    * print "[lightgray]Loop: "
+  692 print "\n[lightgray]Loop: "
   693 print :loop_time_ms
-    * print " "
-    * print "ms"
+  694 print " ms"
   695 printflush message1
   696 op sub .CHANGE .TARGET :active
   697 set :active 0
 
   742 jump *label209 equal *tmp346 false
   743 ucontrol itemDrop .CORE .UNIT_CAPACITY
   744 label *label209
-    * print "[]"
-    * print "\n"
-    * print "Unloading previous items: [green]"
+  745 print "[]\nUnloading previous items: [green]"
   746 jump *label208 always
   747 label *label207
   748 ucontrol itemDrop @air .UNIT_CAPACITY
 
   765 op len *tmp358 *tmp355 *tmp357
   766 op idiv *tmp359 *tmp358 .SPEED_SEC
   767 op div *tmp360 *tmp359 10
-    * print "[]"
-    * print "\n"
-    * print "[gold]"
+  768 print "[]\n[gold]"
   769 print *tmp360
-    * print " "
-    * print "sec[] to "
-    * print "source"
-    * print ":"
-    * print " [green]"
+  770 print " sec[] to source: [green]"
   771 label *label214
   772 label *label211
   773 jump *label218 notEqual :state 3
 
   781 set :state 4
   782 jump *label223 always
   783 label *label222
-    * print "[]"
-    * print "\n"
-    * print "Waiting at source: [green]"
+  784 print "[]\nWaiting at source: [green]"
   785 ucontrol approach .SRC_X .SRC_Y 6
   786 op add :wait_time :wait_time :loop_time_ms
   787 op mul *tmp370 :loop_time_ms .SRC_REMOTE_WAIT
 
   805 op len *tmp382 *tmp379 *tmp381
   806 op idiv *tmp383 *tmp382 .SPEED_SEC
   807 op div *tmp384 *tmp383 10
-    * print "[]"
-    * print "\n"
-    * print "[gold]"
+  808 print "[]\n[gold]"
   809 print *tmp384
-    * print " "
-    * print "sec[] to "
-    * print "destination"
-    * print ":"
-    * print " [green]"
+  810 print " sec[] to destination: [green]"
   811 label *label227
   812 label *label224
   813 jump *label231 notEqual :state 5
 
   827 op len *tmp400 *tmp397 *tmp399
   828 op idiv *tmp401 *tmp400 .SPEED_SEC
   829 op div *tmp402 *tmp401 10
-    * print "[]"
-    * print "\n"
-    * print "[gold]"
+  830 print "[]\n[gold]"
   831 print *tmp402
-    * print " "
-    * print "sec[] to "
-    * print "source"
-    * print ":"
-    * print " [green]"
+  832 print " sec[] to source: [green]"
   833 jump *label236 always
   834 label *label235
-    * print "[]"
-    * print "\n"
-    * print "Waiting at destination: [green]"
+  835 print "[]\nWaiting at destination: [green]"
   836 ucontrol approach .DST_X .DST_Y 6
   837 op add :wait_time :wait_time :loop_time_ms
   838 op mul *tmp403 :loop_time_ms .DST_REMOTE_WAIT
 
   842 sensor :items @unit @totalItems
   843 op add :items_in_transit :items_in_transit :items
   844 jump *label240 notEqual :state 6
-    * print "[]"
-    * print "\n"
-    * print "Parking: [green]"
+  845 print "[]\nParking: [green]"
   846 jump *label242 lessThanEq :items 0
   847 jump *label244 equal .DROP_TO_CORE false
   848 ucontrol approach .CORE_X .CORE_Y 6

Final code before resolving virtual instructions:

    0:  remark "Configurable options:"                               /// Configurable options:
    1:  remark "Which unit type to use:"                             param UNIT                    = @mega;  /// Which unit type to use:
    2:  set UNIT @mega                                               ...
    3:  remark "Remote vault ID (1-99); if nonzero, items are moved  param LINK_ID                 = 0;      /// Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core:
    4:  set LINK_ID 0                                                ...
    5:  remark "Start in auto allocation mode?"                      param AUTO_ALLOCATION         = true;   /// Start in auto allocation mode?
    6:  set AUTO_ALLOCATION true                                     ...
    7:  remark "Max units to use, in both manual and auto allocation param MAX_UNITS               = 24;     /// Max units to use, in both manual and auto allocation modes:
    8:  set MAX_UNITS 24                                             ...
    9:  remark "Leave discarded units with nonzero flag for housekee param HOUSEKEEPING            = true;   /// Leave discarded units with nonzero flag for housekeeping (flag-clearing) processor to pick them up:
   10:  set HOUSEKEEPING true                                        ...
   11:  remark "Drop superfluous items to air, even when there's a c param DROP_TO_AIR             = true;   /// Drop superfluous items to air, even when there's a core:
   12:  set DROP_TO_AIR true                                         ...
   13:  remark "How much of local container capacity to use, in perc param LOCAL_LIMIT             = 100;    /// How much of local container capacity to use, in percents (20-100):
   14:  set LOCAL_LIMIT 100                                          ...
   15:  remark "How much of remote container capacity to use, in per param REMOTE_LIMIT            = 100;    /// How much of remote container capacity to use, in percents (20-100)
   16:  set REMOTE_LIMIT 100                                         ...
   17:  remark "Allocate at least this much more units than needed:" param OVERALLOCATION_LOW      = 0.25;   /// Allocate at least this much more units than needed:
   18:  set OVERALLOCATION_LOW 0.25                                  ...
   19:  remark "Allocate at most this much more units than needed:"  param OVERALLOCATION_HIGH     = 0.75;   /// Allocate at most this much more units than needed:
   20:  set OVERALLOCATION_HIGH 0.75                                 ...
   21:  remark "Use average of last three flow rate values for bette param STABILIZATION           = false;  /// Use average of last three flow rate values for better unit auto allocation stability:
   22:  set STABILIZATION false                                      ...
   23:  remark "End of configurable options"                         /// End of configurable options
   24:  printflush null                                              *printing: printflush(null);
   25:  set .MESSAGE ""                                              MESSAGE = "";
   26:  op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20                       EFF_LOCAL_LIMIT = max(LOCAL_LIMIT, 20);
   27:  op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20                     EFF_REMOTE_LIMIT = max(REMOTE_LIMIT, 20);
   28:  set .EFF_AUTO_ALLOCATION AUTO_ALLOCATION                     EFF_AUTO_ALLOCATION = AUTO_ALLOCATION;
   29:  op mul .S_UNUSED -1 HOUSEKEEPING                             S_UNUSED = -1 * HOUSEKEEPING;           // Unit is not used. Regarded as a free unit even if controlled by this processor.
   30:  set .STATE_LIMIT null                                        CONTAINER_INDEX = CORE_X = CORE_Y = ITEM = ITEM_ICON = STATE_LIMIT = null;
   31:  set .ITEM_ICON null                                          ...
   32:  set .ITEM null                                               ...
   33:  set .CORE_Y null                                             ...
   34:  set .CORE_X null                                             ...
   35:  set .CONTAINER_INDEX null                                    ...
   36:  op add .DEC_OVERALLOCATION 1 OVERALLOCATION_HIGH             DEC_OVERALLOCATION      = 1 + OVERALLOCATION_HIGH;  // Deallocate on this much overcapacity (convert to multiplicational factor)
   37:  ubind UNIT                                                   ubind(UNIT);
   38:  jump *label16 notEqual @unit null                            while @unit == null do
        label *label250                                              ...
   39:  print "[salmon]No unit of type "                             print($"[salmon]No unit of type $UNIT found.");
   40:  print UNIT                                                   ...
   41:  print " found."                                              ...
   42:  printflush message1                                          printflush(message1);
   43:  ubind UNIT                                                   ubind(UNIT);
   44:  jump *label250 equal @unit null                              while @unit == null do
        label *label16                                               ...
   45:  set :first_unit @unit                                        first_unit = @unit;
   46:  sensor *tmp8 @unit @speed                                    SPEED_SEC = @unit.@speed / 10;
   47:  op div .SPEED_SEC *tmp8 10                                   ...
   48:  sensor *tmp10 @unit @speed                                   SPEED = @unit.@speed / 1000;                         // Unit speed in tiles/ms
   49:  op div .SPEED *tmp10 1000                                    ...
   50:  set .TARGET 0                                                TARGET = 0;
        label *label17                                               do
   51:  sensor *tmp12 @unit @controller                              if @unit.@controller == @this then
   52:  jump *label20 notEqual *tmp12 @this                          ...
   53:  sensor :state @unit @flag                                    state = @unit.@flag;
   54:  op greaterThanEq *tmp16 :state 1                             TARGET += (state >= S_FIRST) && (state < S_LAST);
   55:  op lessThan *tmp17 :state 6                                  ...
   56:  op land *tmp18 *tmp16 *tmp17                                 ...
   57:  op add .TARGET .TARGET *tmp18                                ...
        label *label20                                               if @unit.@controller == @this then
   58:  ubind UNIT                                                   ubind(UNIT);
   59:  op notEqual *tmp19 @unit :first_unit                         while (@unit != first_unit) and (first_unit.@dead == 0);    // Don't get stuck if the first unit is killed
   60:  sensor *tmp20 :first_unit @dead                              ...
   61:  op equal *tmp21 *tmp20 0                                     ...
   62:  op land *tmp22 *tmp19 *tmp21                                 ...
   63:  jump *label17 notEqual *tmp22 false                          do
   64:  set .CHANGE 0                                                CHANGE = 0;
   65:  set :active .TARGET                                          active = TARGET;
   66:  set .DEC_LIMIT 0                                             DEC_LIMIT = 0;
   67:  set .INC_LIMIT 0                                             INC_LIMIT = 0;
   68:  sensor .UNIT_CAPACITY @unit @itemCapacity                    UNIT_CAPACITY = @unit.@itemCapacity;
   69:  set :first_unit null                                         first_unit = null;
        label *label22                                               while true do
   70:  set .CONTAINER null                                          CONTAINER = null;
   71:  set .CONTAINERS 0                                            CONTAINERS = 0;
   72:  set :n @links                                                n = @links;
   73:  jump *label27 lessThanEq :n 0                                while n > 0 do
        label *label251                                              ...
   74:  op sub :n :n 1                                               n = n - 1;
   75:  getlink :block :n                                            block = getlink(n);
   76:  sensor *tmp29 :block @type                                   case block.@type
   77:  jump *label30 equal *tmp29 @vault                            ...
   78:  jump *label29 notEqual *tmp29 @container                     ...
        label *label30                                               ...
   79:  set .CONTAINER :block                                        CONTAINER = block;
   80:  op add .CONTAINERS .CONTAINERS 1                             CONTAINERS += 1;
   81:  set .CONTAINER_INDEX :n                                      CONTAINER_INDEX = n;
        label *label29                                               case block.@type
   82:  jump *label251 greaterThan :n 0                              while n > 0 do
        label *label27                                               ...
   83:  jump *label24 notEqual .CONTAINER null                       if CONTAINER == null then
   84:  print "[salmon]No vault or container."                       print("[salmon]No vault or container.");
   85:  printflush message1                                          printflush(message1);
   86:  jump *label22 always 0 0                                     if CONTAINER == null then
        label *label24                                               while true do
   87:  set .CORE null                                               CORE = null;
   88:  jump *label33 notEqual LINK_ID 0                             if LINK_ID == 0 then
        label *label252                                              while CORE == null do
   89:  print "[green]Locating core..."                              print("[green]Locating core...");
   90:  printflush message1                                          printflush(message1);
   91:  ubind UNIT                                                   ubind(UNIT);
   92:  sensor *tmp36 @unit @controlled                              if @unit.@controlled == 0 then
   93:  jump *label38 notEqual *tmp36 0                              ...
   94:  ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE  CORE = ulocate(:building, :core, false, out CORE_X, out CORE_Y);
   95:  ucontrol flag .S_UNUSED 0 0 0 0                              flag(S_UNUSED);
        label *label38                                               if @unit.@controlled == 0 then
   96:  jump *label252 equal .CORE null                              while CORE == null do
   97:  set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY                   DISCARD_UNIT_MAX_ITEMS = UNIT_CAPACITY;       // Can discard anything to the core
   98:  op equal .DROP_TO_CORE DROP_TO_AIR false                     DROP_TO_CORE = not DROP_TO_AIR;
   99:  jump *label34 always 0 0                                     if LINK_ID == 0 then
        label *label33                                               ...
  100:  printflush message2                                          printflush(message2);
  101:  print "[green]Locating vault #"                              print($"[green]Locating vault #$LINK_ID...");
  102:  print LINK_ID                                                ...
  103:  print "..."                                                  ...
  104:  printflush message1                                          printflush(message1);
  105:  op add .QUERY_FLAG 99999900 LINK_ID                          while CORE == null do
        label *label253                                              ...
  106:  set :flag .QUERY_FLAG                                        flag = QUERY_FLAG;
  107:  ubind UNIT                                                   ubind(UNIT);
  108:  sensor *tmp44 @unit @controlled                              while @unit.@controlled != 0 do
  109:  jump *label45 equal *tmp44 0                                 ...
        label *label257                                              ...
  110:  ubind UNIT                                                   ubind(UNIT);
  111:  sensor *tmp44 @unit @controlled                              while @unit.@controlled != 0 do
  112:  jump *label257 notEqual *tmp44 0                             ...
        label *label45                                               ...
  113:  ucontrol flag .QUERY_FLAG 0 0 0 0                            flag(flag);
  114:  sensor *tmp47 @unit @dead                                    while flag == QUERY_FLAG and @unit.@dead == 0 do
  115:  op equal *tmp49 *tmp47 0                                     ...
  116:  jump *label48 equal *tmp49 false                             ...
        label *label258                                              ...
  117:  ucontrol stop 0 0 0 0 0                                      stop();                 // Keep controlling the unit
  118:  sensor :flag @unit @flag                                     flag = @unit.@flag;
  119:  op equal *tmp46 :flag .QUERY_FLAG                            while flag == QUERY_FLAG and @unit.@dead == 0 do
  120:  sensor *tmp47 @unit @dead                                    ...
  121:  op equal *tmp48 *tmp47 0                                     ...
  122:  op land *tmp49 *tmp46 *tmp48                                 ...
  123:  jump *label258 notEqual *tmp49 false                         ...
        label *label48                                               ...
  124:  jump *label49 equal :flag .QUERY_FLAG                        if flag != QUERY_FLAG then
  125:  op idiv :position :flag 100                                  position = flag \ 100;
  126:  op mod .CORE_X :position @mapw                               CORE_X = position % @mapw;
  127:  op idiv .CORE_Y :position @mapw                              CORE_Y = position \ @mapw;
  128:  sensor *tmp56 @unit @dead                                    while @unit.@dead == 0 and !within(CORE_X, CORE_Y, RADIUS_WITHIN) do
  129:  op equal *tmp57 *tmp56 0                                     ...
  130:  ucontrol within .CORE_X .CORE_Y 8 *tmp58 0                   ...
  131:  op equal *tmp59 *tmp58 false                                 ...
  132:  op land *tmp60 *tmp57 *tmp59                                 ...
  133:  jump *label53 equal *tmp60 false                             ...
        label *label259                                              ...
  134:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  135:  sensor *tmp56 @unit @dead                                    while @unit.@dead == 0 and !within(CORE_X, CORE_Y, RADIUS_WITHIN) do
  136:  op equal *tmp57 *tmp56 0                                     ...
  137:  ucontrol within .CORE_X .CORE_Y 8 *tmp58 0                   ...
  138:  op equal *tmp59 *tmp58 false                                 ...
  139:  op land *tmp60 *tmp57 *tmp59                                 ...
  140:  jump *label259 notEqual *tmp60 false                         ...
        label *label53                                               ...
  141:  ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0            CORE = getBlock(CORE_X, CORE_Y, out b_type);
  142:  jump *label54 equal :b_type @vault                           if b_type != @vault then
  143:  print "[salmon]Building at "                                 print($"[salmon]Building at $CORE_X, $CORE_Y is not a vault!");
  144:  print .CORE_X                                                ...
  145:  print ", "                                                   ...
  146:  print .CORE_Y                                                ...
  147:  print " is not a vault!"                                     ...
  148:  printflush message2                                          printflush(message2);
  149:  set .CORE null                                               CORE = null;
        label *label54                                               if b_type != @vault then
        label *label49                                               if flag != QUERY_FLAG then
  150:  ucontrol flag .S_UNUSED 0 0 0 0                              flag(S_UNUSED);               // Free the unit
  151:  jump *label253 equal .CORE null                              while CORE == null do
  152:  set .DISCARD_UNIT_MAX_ITEMS 0                                DISCARD_UNIT_MAX_ITEMS = DROP_TO_AIR ? UNIT_CAPACITY : 0;       // Cannot drop items to the remote vault
  153:  jump *label57 equal DROP_TO_AIR false                        ...
  154:  set .DISCARD_UNIT_MAX_ITEMS .UNIT_CAPACITY                   ...
        label *label57                                               ...
  155:  set .DROP_TO_CORE false                                      DROP_TO_CORE = false;
        label *label34                                               if LINK_ID == 0 then
  156:  set .SORTER sorter1                                          SORTER = sorter1;
  157:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  158:  op notEqual *tmp67 :sorter_type @sorter                      while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
  159:  op notEqual *tmp68 :sorter_type @inverted-sorter             ...
  160:  op land *tmp69 *tmp67 *tmp68                                 ...
  161:  jump *label60 equal *tmp69 false                             ...
        label *label260                                              ...
  162:  print "[salmon]Block sorter1 is neither a sorter, nor an inv println("[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.");
  163:  jump *label61 equal .SORTER null                             if SORTER != null then
  164:  print "Block found: "                                        print("Block found: ", SORTER);
  165:  print .SORTER                                                ...
        label *label61                                               if SORTER != null then
  166:  printflush message1                                          printflush(message1);
  167:  set .SORTER sorter1                                          SORTER = sorter1;
  168:  sensor :sorter_type sorter1 @type                            sorter_type = SORTER.@type;
  169:  op notEqual *tmp67 :sorter_type @sorter                      while (sorter_type != @sorter) and (sorter_type != @inverted-sorter) do
  170:  op notEqual *tmp68 :sorter_type @inverted-sorter             ...
  171:  op land *tmp69 *tmp67 *tmp68                                 ...
  172:  jump *label260 notEqual *tmp69 false                         ...
        label *label60                                               ...
  173:  jump *label63 notEqual :sorter_type @sorter                  if sorter_type == @sorter then
  174:  set .SHOW_REMOTE_LEVEL true                                  SHOW_REMOTE_LEVEL = true;
  175:  set .SRC .CORE                                               SRC = CORE;
  176:  set .DST .CONTAINER                                          DST = CONTAINER;
  177:  sensor :src_capacity .CORE @itemCapacity                     src_capacity = SRC.@itemCapacity;
  178:  sensor :dst_capacity .CONTAINER @itemCapacity                dst_capacity = DST.@itemCapacity;
  179:  op sub *tmp77 100 .EFF_REMOTE_LIMIT                          LOAD_LEVEL = (src_capacity * (100 - EFF_REMOTE_LIMIT)) \ 100;
  180:  op mul *tmp78 :src_capacity *tmp77                           ...
  181:  op idiv .LOAD_LEVEL *tmp78 100                               ...
  182:  op mul *tmp80 :dst_capacity .EFF_LOCAL_LIMIT                 DROP_LEVEL = (dst_capacity * EFF_LOCAL_LIMIT) \ 100;
  183:  op idiv .DROP_LEVEL *tmp80 100                               ...
  184:  set .LOCAL_MARGIN .DROP_LEVEL                                LOCAL_MARGIN = DROP_LEVEL;
  185:  set .REMOTE_MARGIN .LOAD_LEVEL                               REMOTE_MARGIN = LOAD_LEVEL;
  186:  op mul .LOW_LEVEL_TRIGGER :dst_capacity 0.09999999999999998  LOW_LEVEL_TRIGGER = dst_capacity * (1 - TRIGGER_LEVEL);
  187:  set .HIGH_LEVEL_TRIGGER :dst_capacity                        HIGH_LEVEL_TRIGGER = dst_capacity;  // never triggers
  188:  set .FLOW_CORR_SIGN 1                                        FLOW_CORR_SIGN = 1;                 // sign of flow-rate correction computed from container level
  189:  set .SRC_REMOTE_WAIT 1                                       SRC_REMOTE_WAIT = 1;
  190:  set .DST_REMOTE_WAIT 0                                       DST_REMOTE_WAIT = 0;
  191:  set .DIRECTION " from vault #"                               DIRECTION = (LINK_ID == 0) ? " from core"  : " from vault #";
  192:  jump *label64 notEqual LINK_ID 0                             ...
  193:  set .DIRECTION " from core"                                  ...
  194:  jump *label64 always 0 0                                     if sorter_type == @sorter then
        label *label63                                               ...
  195:  op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0                  SHOW_REMOTE_LEVEL = LINK_ID > 0;
  196:  set .SRC .CONTAINER                                          SRC = CONTAINER;
  197:  set .DST .CORE                                               DST = CORE;
  198:  sensor :src_capacity .CONTAINER @itemCapacity                src_capacity = SRC.@itemCapacity;
  199:  sensor :dst_capacity .CORE @itemCapacity                     dst_capacity = DST.@itemCapacity;
  200:  op sub *tmp89 100 .EFF_LOCAL_LIMIT                           LOAD_LEVEL = (src_capacity * (100 - EFF_LOCAL_LIMIT)) \ 100;
  201:  op mul *tmp90 :src_capacity *tmp89                           ...
  202:  op idiv .LOAD_LEVEL *tmp90 100                               ...
  203:  op mul *tmp92 :dst_capacity .EFF_REMOTE_LIMIT                DROP_LEVEL = (dst_capacity * EFF_REMOTE_LIMIT) \ 100 + ((LINK_ID == 0) * UNIT_CAPACITY);
  204:  op idiv *tmp93 *tmp92 100                                    ...
  205:  op equal *tmp94 LINK_ID 0                                    ...
  206:  op mul *tmp95 *tmp94 .UNIT_CAPACITY                          ...
  207:  op add .DROP_LEVEL *tmp93 *tmp95                             ...
  208:  set .LOCAL_MARGIN .LOAD_LEVEL                                LOCAL_MARGIN = LOAD_LEVEL;
  209:  set .REMOTE_MARGIN .DROP_LEVEL                               REMOTE_MARGIN = DROP_LEVEL;
  210:  op mul .HIGH_LEVEL_TRIGGER :src_capacity 0.9                 HIGH_LEVEL_TRIGGER = src_capacity * TRIGGER_LEVEL;
  211:  set .LOW_LEVEL_TRIGGER 0                                     LOW_LEVEL_TRIGGER = 0;              // never triggers
  212:  set .FLOW_CORR_SIGN -1                                       FLOW_CORR_SIGN = -1;                // sign of flow-rate correction computed from container level
  213:  set .SRC_REMOTE_WAIT 0                                       SRC_REMOTE_WAIT = 0;
  214:  set .DST_REMOTE_WAIT 1                                       DST_REMOTE_WAIT = 1;
  215:  set .DIRECTION " to vault #"                                 DIRECTION = (LINK_ID == 0) ? " to core" : " to vault #";
  216:  jump *label68 notEqual LINK_ID 0                             ...
  217:  set .DIRECTION " to core"                                    ...
        label *label68                                               ...
        label *label64                                               if sorter_type == @sorter then
  218:  set *tmp101 LINK_ID                                          LINK_TXT = (LINK_ID == 0) ? ""  : LINK_ID;
  219:  jump *label70 notEqual LINK_ID 0                             ...
  220:  set *tmp101 ""                                               ...
        label *label70                                               ...
  221:  op sub *tmp102 :src_capacity .LOAD_LEVEL                     LOAD_PACK = min(UNIT_CAPACITY, src_capacity - LOAD_LEVEL);
  222:  op min .LOAD_PACK .UNIT_CAPACITY *tmp102                     ...
  223:  op min .DROP_PACK .UNIT_CAPACITY .DROP_LEVEL                 DROP_PACK = min(UNIT_CAPACITY, DROP_LEVEL);
  224:  sensor .SRC_X .SRC @x                                        SRC_X = SRC.@x;
  225:  sensor .SRC_Y .SRC @y                                        SRC_Y = SRC.@y;
  226:  sensor .DST_X .DST @x                                        DST_X = DST.@x;
  227:  sensor .DST_Y .DST @y                                        DST_Y = DST.@y;
  228:  op sub *tmp109 .DST_X .SRC_X                                 DISTANCE = len(DST_X - SRC_X, DST_Y - SRC_Y) - RADIUS_APPROACH - RADIUS_WITHIN;
  229:  op sub *tmp110 .DST_Y .SRC_Y                                 ...
  230:  op len *tmp111 *tmp109 *tmp110                               ...
  231:  op sub .DISTANCE *tmp111 14                                  ...
  232:  op max *tmp114 .DISTANCE 10                                  TRAVEL_TIME = (2 * max(DISTANCE, 10)) / SPEED;   // Travel time: both ways, in tiles/ms
  233:  op mul *tmp115 2 *tmp114                                     ...
  234:  op div .TRAVEL_TIME *tmp115 .SPEED                           ...
  235:  op add .PARK_X .CORE_X -15                                   PARK_X = CORE_X + ((CONTAINER.@x < CORE_X) ? 15 : -15);
  236:  sensor *tmp117 .CONTAINER @x                                 ...
  237:  jump *label72 greaterThanEq *tmp117 .CORE_X                  ...
  238:  op add .PARK_X .CORE_X 15                                    ...
        label *label72                                               ...
  239:  op add .PARK_Y .CORE_Y -15                                   PARK_Y = CORE_Y + ((CONTAINER.@y < CORE_Y) ? 15 : -15);
  240:  sensor *tmp121 .CONTAINER @y                                 ...
  241:  jump *label74 greaterThanEq *tmp121 .CORE_Y                  ...
  242:  op add .PARK_Y .CORE_Y 15                                    ...
        label *label74                                               ...
  243:  op equal *tmp125 LINK_ID 0                                   PARK_ITEM_LIMIT = (LINK_ID == 0) * UNIT_CAPACITY;
  244:  op mul .PARK_ITEM_LIMIT *tmp125 .UNIT_CAPACITY               ...
  245:  set .TRANSFER_START @tick                                    TRANSFER_START = @tick;             // Prevent completely nonsensical values
  246:  op sub .LOOP_START @tick 60                                  LOOP_START = @tick - 60;            // Prevent completely nonsensical values
  247:  set .LAST_ITEM @mono                                         LAST_ITEM = @mono;                  // Must not be null
  248:  op add .MESSAGE_TIMEOUT @tick 600                            MESSAGE_TIMEOUT = @tick + 600;      // Ten seconds
  249:  set .WAIT_LIMIT 30000                                        WAIT_LIMIT = 30000;                 // Good initial value: half a minute
  250:  set :items_in_transit 0                                      items_in_transit = 0;
  251:  set :items_per_min_unit "--"                                 items_per_min_unit = "--";
  252:  set :items_per_min "-- "                                     items_per_min = "-- ";
  253:  set :turnaround_str "--"                                     turnaround_str = "--";
  254:  set :elapsed_str "--"                                        elapsed_str = "--";
  255:  set :wait_time_str 0                                         wait_time_str = 0;
  256:  set :wait_time 0                                             = total_flow_1 = total_flow_2 = transferred = transfers = wait_time = 0;
  257:  set :transfers 0                                             ...
  258:  set :transferred 0                                           ...
  259:  set :total_flow_2 0                                          ...
  260:  set :total_flow_1 0                                          ...
  261:  set :remote_wait_time 0                                      last_level = loop_time_ms = max_level = min_level = remote_wait_time
  262:  set :min_level 0                                             ...
  263:  set :max_level 0                                             ...
  264:  set :loop_time_ms 0                                          ...
  265:  set :last_level 0                                            ...
  266:  jump *label75 equal AUTO_ALLOCATION false                    if EFF_AUTO_ALLOCATION then
  267:  set .CORR_SIGN "[]([green]+"                                 CORR_SIGN = "[]([green]+";
  268:  set :corr_per_min 0                                          corr_per_min = 0;
  269:  set .SPEED_UNIT_TXT "[])/min"                                SPEED_UNIT_TXT = "[])/min";
  270:  set .AUTO_ALLOCATION_TXT "\n=== [gold]Gathering statistics[] AUTO_ALLOCATION_TXT = "\n=== [gold]Gathering statistics[] ===";
  271:  jump *label76 always 0 0                                     if EFF_AUTO_ALLOCATION then
        label *label75                                               ...
  272:  set .CORR_SIGN "[]"                                          CORR_SIGN = "[]";
  273:  set :corr_per_min ""                                         corr_per_min = "";
  274:  set .SPEED_UNIT_TXT "/min"                                   SPEED_UNIT_TXT = "/min";
  275:  set .AUTO_ALLOCATION_TXT ""                                  AUTO_ALLOCATION_TXT = "";
        label *label76                                               if EFF_AUTO_ALLOCATION then
        label *label77                                               while true do
  276:  ubind UNIT                                                   ubind(UNIT);
  277:  jump *label82 notEqual @unit null                            while @unit == null do
        label *label254                                              ...
  278:  print "No unit of type "                                     print($"No unit of type $UNIT found.");
  279:  print UNIT                                                   ...
  280:  print " found."                                              ...
  281:  printflush message1                                          printflush(message1);
  282:  ubind UNIT                                                   ubind(UNIT);
  283:  jump *label254 equal @unit null                              while @unit == null do
        label *label82                                               ...
  284:  sensor *tmp132 switch1 @enabled                              if switch1.@enabled then
  285:  jump *label83 equal *tmp132 false                            ...
  286:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  287:  set .EFF_AUTO_ALLOCATION false                               EFF_AUTO_ALLOCATION = false;
  288:  set .AUTO_ALLOCATION_TXT ""                                  AUTO_ALLOCATION_TXT = "";
  289:  op add *tmp135 .TARGET 1                                     TARGET = min(TARGET + 1, MAX_UNITS);
  290:  op min .TARGET *tmp135 MAX_UNITS                             ...
  291:  set .CORR_SIGN "[]"                                          CORR_SIGN = "[]";
  292:  set :corr_per_min ""                                         corr_per_min = "";
  293:  set .SPEED_UNIT_TXT "/min"                                   SPEED_UNIT_TXT = "/min";
  294:  set .WAIT_LIMIT 30000                                        WAIT_LIMIT = 30000;
        label *label83                                               if switch1.@enabled then
  295:  sensor *tmp137 switch2 @enabled                              if switch2.@enabled then
  296:  jump *label85 equal *tmp137 false                            ...
  297:  control enabled switch2 false 0 0 0                          switch2.enabled = false;
  298:  jump *label87 greaterThanEq .TARGET 1                        if TARGET < 1 then
  299:  set .EFF_AUTO_ALLOCATION true                                EFF_AUTO_ALLOCATION = true;
  300:  set .TARGET 1                                                TARGET = 1;
  301:  set .DEC_LIMIT 0                                             DEC_LIMIT = 0;           // No change for next iteration
  302:  set .INC_LIMIT 0                                             INC_LIMIT = 0;
  303:  set .CORR_SIGN "[]([green]+"                                 CORR_SIGN = "[]([green]+";
  304:  set :corr_per_min 0                                          corr_per_min = 0;
  305:  set .SPEED_UNIT_TXT "[])/min"                                SPEED_UNIT_TXT = "[])/min";
  306:  jump *label88 always 0 0                                     if TARGET < 1 then
        label *label87                                               ...
  307:  set .EFF_AUTO_ALLOCATION false                               EFF_AUTO_ALLOCATION = false;
  308:  op sub *tmp142 .TARGET 1                                     TARGET = max(TARGET - 1, 0);
  309:  op max .TARGET *tmp142 0                                     ...
  310:  set .CORR_SIGN "[]"                                          CORR_SIGN = "[]";
  311:  set :corr_per_min ""                                         corr_per_min = "";
  312:  set .SPEED_UNIT_TXT "/min"                                   SPEED_UNIT_TXT = "/min";
  313:  set .AUTO_ALLOCATION_TXT ""                                  AUTO_ALLOCATION_TXT = TARGET == 0 ? "\n=== [salmon]Transport deactivated[] ===" : "";
  314:  jump *label90 notEqual .TARGET 0                             ...
  315:  set .AUTO_ALLOCATION_TXT "\n=== [salmon]Transport deactivate ...
        label *label90                                               ...
        label *label88                                               if TARGET < 1 then
  316:  set .WAIT_LIMIT 30000                                        WAIT_LIMIT = 30000;
        label *label85                                               if switch2.@enabled then
  317:  sensor *tmp146 :first_unit @dead                             alive = first_unit.@dead == 0;
  318:  op equal :alive *tmp146 0                                    ...
  319:  op equal *tmp148 @unit :first_unit                           if alive <= (@unit == first_unit) then
  320:  jump *label91 greaterThan :alive *tmp148                     ...
  321:  jump *label93 notEqual :active 0                             if active == 0 then
  322:  print "\n[salmon]No active units.[]"                         print("\n[salmon]No active units.[]");
        label *label93                                               if active == 0 then
  323:  printflush message2                                          printflush(message2);
  324:  set .STATE_LIMIT 6                                           STATE_LIMIT = S_LAST;
  325:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  326:  jump *label95 equal .ITEM .LAST_ITEM                         if ITEM != LAST_ITEM then
  327:  jump *label99 notEqual .ITEM null                            while ITEM == null do
        label *label255                                              ...
  328:  print "[salmon]No item type selected for transport.[]"       print("[salmon]No item type selected for transport.[]");
  329:  printflush message1                                          printflush(message1);
  330:  sensor .ITEM .SORTER @config                                 ITEM = SORTER.@config;
  331:  jump *label255 equal .ITEM null                              while ITEM == null do
        label *label99                                               ...
  332:  set .LAST_ITEM .ITEM                                         LAST_ITEM = ITEM;
  333:  sensor *tmp160 .ITEM @id                                     case itemType.@id
  334:  jump *label262 greaterThanEq *tmp160 3                       ...
  335:  jump *label263 greaterThanEq *tmp160 1                       ...
  336:  jump *label261 lessThan *tmp160 0                            ...
  337:  set *tmp159 "[]"                                            ...
  338:  jump *label101 always 0 0                                    ...
        label *label263                                              ...
  339:  jump *label113 greaterThanEq *tmp160 2                       ...
  340:  set *tmp159 "[]"                                            ...
  341:  jump *label101 always 0 0                                    ...
        label *label262                                              ...
  342:  jump *label261 greaterThanEq *tmp160 16                      ...
  343:  multijump *label264 *tmp160 3                                ...
        multilabel *label264                                         ...
  344:  jump *label109 always 0 0                                    ...
        multilabel *label265                                         ...
  345:  jump *label121 always 0 0                                    ...
        multilabel *label266                                         ...
  346:  jump *label105 always 0 0                                    ...
        multilabel *label267                                         ...
  347:  jump *label133 always 0 0                                    ...
        multilabel *label268                                         ...
  348:  jump *label131 always 0 0                                    ...
        multilabel *label269                                         ...
  349:  jump *label123 always 0 0                                    ...
        multilabel *label270                                         ...
  350:  jump *label125 always 0 0                                    ...
        multilabel *label271                                         ...
  351:  jump *label117 always 0 0                                    ...
        multilabel *label272                                         ...
  352:  jump *label115 always 0 0                                    ...
        multilabel *label273                                         ...
  353:  jump *label129 always 0 0                                    ...
        multilabel *label274                                         ...
  354:  jump *label127 always 0 0                                    ...
        multilabel *label275                                         ...
  355:  jump *label103 always 0 0                                    ...
        multilabel *label276                                         ...
  356:  set *tmp159 "[]"                                            ...
  357:  jump *label101 always 0 0                                    ...
        label *label103                                              ...
  358:  set *tmp159 "[]"                                            ...
  359:  jump *label101 always 0 0                                    ...
        label *label105                                              ...
  360:  set *tmp159 "[]"                                            ...
  361:  jump *label101 always 0 0                                    ...
        label *label109                                              ...
  362:  set *tmp159 "[]"                                            ...
  363:  jump *label101 always 0 0                                    ...
        label *label113                                              ...
  364:  set *tmp159 "[]"                                            ...
  365:  jump *label101 always 0 0                                    ...
        label *label115                                              ...
  366:  set *tmp159 "[]"                                            ...
  367:  jump *label101 always 0 0                                    ...
        label *label117                                              ...
  368:  set *tmp159 "[]"                                            ...
  369:  jump *label101 always 0 0                                    ...
        label *label121                                              ...
  370:  set *tmp159 "[]"                                            ...
  371:  jump *label101 always 0 0                                    ...
        label *label123                                              ...
  372:  set *tmp159 "[]"                                            ...
  373:  jump *label101 always 0 0                                    ...
        label *label125                                              ...
  374:  set *tmp159 "[]"                                            ...
  375:  jump *label101 always 0 0                                    ...
        label *label127                                              ...
  376:  set *tmp159 "[]"                                            ...
  377:  jump *label101 always 0 0                                    ...
        label *label129                                              ...
  378:  set *tmp159 "[]"                                            ...
  379:  jump *label101 always 0 0                                    ...
        label *label131                                              ...
  380:  set *tmp159 "[]"                                            ...
  381:  jump *label101 always 0 0                                    ...
        label *label133                                              ...
  382:  set *tmp159 "[]"                                            ...
  383:  jump *label101 always 0 0                                    ...
        label *label261                                              ...
  384:  set *tmp159 null                                             ...
        label *label101                                              ...
  385:  set .ITEM_ICON *tmp159                                       ITEM_ICON = itemTypeToIcon(ITEM);
  386:  set .STATE_LIMIT 1                                           STATE_LIMIT = S_UNLOAD;   // Switches all units to S_UNLOAD state
  387:  sensor :last_level .CONTAINER .ITEM                          last_level = CONTAINER.sensor(ITEM);
  388:  set :min_level 999999                                        min_level = 999999;
  389:  set :max_level 0                                             max_level = 0;
        label *label95                                               if ITEM != LAST_ITEM then
  390:  sensor :container_items .CONTAINER .ITEM                     container_items = CONTAINER.sensor(ITEM);
  391:  op min :min_level :min_level :container_items                min_level = min(min_level, container_items);
  392:  op max :max_level :max_level :container_items                max_level = max(max_level, container_items);
  393:  op sub :loop_time @tick .LOOP_START                          loop_time = @tick - LOOP_START;
  394:  set .LOOP_START @tick                                        LOOP_START = @tick;
  395:  op mul *tmp184 :loop_time 100                                loop_time_ms = (loop_time * 100) \ 6;
  396:  op idiv :loop_time_ms *tmp184 6                              ...
  397:  op greaterThanEq *tmp186 :transfers :active                  if transfers >= active or wait_time > WAIT_LIMIT then
  398:  op greaterThan *tmp187 :wait_time .WAIT_LIMIT                ...
  399:  op or *tmp188 *tmp186 *tmp187                                ...
  400:  jump *label134 equal *tmp188 false                           ...
  401:  op div *tmp190 :wait_time 100                                wait_time_str = ceil(wait_time / 100) / 10;
  402:  op ceil *tmp191 *tmp190 0                                    ...
  403:  op div :wait_time_str *tmp191 10                             ...
  404:  op sub :elapsed_ticks @tick .TRANSFER_START                  elapsed_ticks = @tick - TRANSFER_START;
  405:  set .TRANSFER_START @tick                                    TRANSFER_START = @tick;
  406:  op div :elapsed_ms :elapsed_ticks 0.06                       elapsed_ms = elapsed_ticks / 0.06;
  407:  op idiv *tmp196 :elapsed_ms 100                              elapsed_str = (elapsed_ms \ 100) / 10;
  408:  op div :elapsed_str *tmp196 10                               ...
  409:  op div :items_per_ms :transferred :elapsed_ms                items_per_ms = transferred / elapsed_ms;
  410:  op idiv :items_per_min :items_per_ms 0.000016666666666666667 items_per_min = items_per_ms \ (1.0 / 60000);    // save floor instruction; for display only
  411:  set :transferred 0                                           transferred = 0;
  412:  set :transfers 0                                             transfers = 0;
  413:  jump *label136 equal .EFF_AUTO_ALLOCATION false              if EFF_AUTO_ALLOCATION then
  414:  set .AUTO_ALLOCATION_TXT "\n=== [gold]Unit auto allocation[] AUTO_ALLOCATION_TXT = "\n=== [gold]Unit auto allocation[] ===";
  415:  op mul *tmp201 16.666666666666668 :loop_time                 turnaround_ms = TRAVEL_TIME + (LOOPS_TICKS_TO_MS * loop_time);
  416:  op add :turnaround_ms .TRAVEL_TIME *tmp201                   ...
  417:  op mul .WAIT_LIMIT :turnaround_ms .DEC_OVERALLOCATION        WAIT_LIMIT = turnaround_ms * DEC_OVERALLOCATION;
  418:  op idiv *tmp204 :turnaround_ms 100                           turnaround_str = (turnaround_ms \ 100) / 10;
  419:  op div :turnaround_str *tmp204 10                            ...
  420:  op div :items_per_ms_unit .UNIT_CAPACITY :turnaround_ms      items_per_ms_unit = UNIT_CAPACITY / turnaround_ms;
  421:  op idiv :items_per_min_unit :items_per_ms_unit 0.00001666666 items_per_min_unit = floor(items_per_ms_unit * 60000);
  422:  op add *tmp209 :min_level :max_level                         this_level = (min_level + max_level) / 2;
  423:  op div :this_level *tmp209 2                                 ...
  424:  op sub *tmp211 :last_level :this_level                       corr = (last_level - this_level) * FLOW_CORR_SIGN;
  425:  op mul :corr *tmp211 .FLOW_CORR_SIGN                         ...
  426:  op div :corr_per_ms :corr :elapsed_ms                        corr_per_ms = corr / elapsed_ms;
  427:  set :last_level :this_level                                  last_level = this_level;
  428:  op add :total_flow_per_ms :items_per_ms :corr_per_ms         total_flow_per_ms = items_per_ms + corr_per_ms;
  429:  op idiv :corr_per_min :corr_per_ms 0.000016666666666666667   corr_per_min = floor(60000 * corr_per_ms);
  430:  set .CORR_SIGN "[]([green]"                                  CORR_SIGN = corr_per_min >= 0 ? "[]([green]+" : "[]([green]";
  431:  jump *label139 lessThan :corr_per_min 0                      ...
  432:  set .CORR_SIGN "[]([green]+"                                 ...
        label *label139                                              ...
  433:  set .SPEED_UNIT_TXT "[])/min"                                SPEED_UNIT_TXT = "[])/min";
  434:  jump *label140 equal :alive false                            if alive then
  435:  op lessThan *tmp220 :min_level .LOW_LEVEL_TRIGGER            trigger = min_level < LOW_LEVEL_TRIGGER or max_level > HIGH_LEVEL_TRIGGER;
  436:  op greaterThan *tmp221 :max_level .HIGH_LEVEL_TRIGGER        ...
  437:  op or :trigger *tmp220 *tmp221                               ...
  438:  op equal *tmp223 :wait_time 0                                if wait_time == 0 or (trigger > remote_wait_time) then
  439:  op greaterThan *tmp224 :trigger :remote_wait_time            ...
  440:  op or *tmp225 *tmp223 *tmp224                                ...
  441:  jump *label142 equal *tmp225 false                           ...
  442:  jump *label144 equal STABILIZATION false                     if STABILIZATION then
  443:  set :total_flow_3 :total_flow_2                              total_flow_3 = total_flow_2;
  444:  set :total_flow_2 :total_flow_1                              total_flow_2 = total_flow_1;
  445:  set :total_flow_1 :total_flow_per_ms                         total_flow_1 = total_flow_per_ms;
  446:  op add *tmp228 :total_flow_3 :total_flow_2                   total_flow_per_ms = (total_flow_3 + total_flow_2 + total_flow_1) / 3;
  447:  op add *tmp229 *tmp228 :total_flow_per_ms                    ...
  448:  op div :total_flow_per_ms *tmp229 3                          ...
        label *label144                                              if STABILIZATION then
  449:  op div *tmp231 :total_flow_per_ms :items_per_ms_unit         new_target = ceil(total_flow_per_ms / items_per_ms_unit + INC_OVERALLOCATION);
  450:  op add *tmp232 *tmp231 OVERALLOCATION_LOW                    ...
  451:  op ceil :new_target *tmp232 0                                ...
  452:  op mul :level_boost 2 :trigger                               level_boost = TRIGGER_BOOST * trigger;
  453:  op add *tmp235 :new_target :level_boost                      new_target = min(new_target + level_boost, MAX_UNITS);
  454:  op min :new_target *tmp235 MAX_UNITS                         ...
  455:  op sub *tmp237 :new_target :active                           new_change = min(max(new_target - active, 0), INC_LIMIT);
  456:  op max *tmp238 *tmp237 0                                     ...
  457:  op min :new_change *tmp238 .INC_LIMIT                        ...
  458:  set .INC_LIMIT 6                                             INC_LIMIT = INC_MAX;                           // Can increase again next time
  459:  op lessThanEq *tmp240 :new_change 0                          DEC_LIMIT = (new_change <= 0) * DEC_MAX;       // No decreases after an increase
  460:  op mul .DEC_LIMIT *tmp240 -1                                 ...
  461:  jump *label143 always 0 0                                    if wait_time == 0 or (trigger > remote_wait_time) then
        label *label142                                              ...
  462:  op idiv *tmp242 :wait_time .WAIT_LIMIT                       new_change = max(-1 * (wait_time \ WAIT_LIMIT), DEC_LIMIT);
  463:  op mul *tmp243 -1 *tmp242                                    ...
  464:  op max :new_change *tmp243 .DEC_LIMIT                        ...
  465:  op greaterThanEq *tmp245 :new_change 0                       INC_LIMIT = (new_change >= 0) * INC_MAX;       // No increases after a decrease
  466:  op mul .INC_LIMIT *tmp245 6                                  ...
  467:  set .DEC_LIMIT -1                                            DEC_LIMIT = DEC_MAX;                           // Can decrease again next time
        label *label143                                              if wait_time == 0 or (trigger > remote_wait_time) then
  468:  op add *tmp247 :active :new_change                           TARGET = max(active + new_change, 1);
  469:  op max .TARGET *tmp247 1                                     ...
  470:  jump *label141 always 0 0                                    if alive then
        label *label140                                              ...
  471:  set .INC_LIMIT 0                                             INC_LIMIT = 0;
  472:  set .DEC_LIMIT 0                                             DEC_LIMIT = 0;
        label *label141                                              if alive then
  473:  set :min_level 999999                                        min_level = 999999;
  474:  set :max_level 0                                             max_level = 0;
        label *label136                                              if EFF_AUTO_ALLOCATION then
  475:  op greaterThan *tmp249 .CONTAINERS 1                         if CONTAINERS > 1 and SRC == CORE then
  476:  op equal *tmp250 .SRC .CORE                                  ...
  477:  op land *tmp251 *tmp249 *tmp250                              ...
  478:  jump *label146 equal *tmp251 false                           ...
  479:  sensor *tmp253 .DST .ITEM                                    max_drop = DROP_LEVEL - DST.sensor(ITEM);
  480:  op sub :max_drop .DROP_LEVEL *tmp253                         ...
  481:  jump *label148 greaterThanEq :max_drop .DROP_PACK            if max_drop < DROP_PACK then
  482:  set :findAnotherContainer:min_level 999999                   min_level = 999999;
  483:  set .CONTAINERS 0                                            CONTAINERS = 0;
  484:  set :findAnotherContainer:n @links                           n = @links;
  485:  jump *label153 lessThanEq :findAnotherContainer:n 0          while n > 0 do
        label *label256                                              ...
  486:  op sub :findAnotherContainer:n :findAnotherContainer:n 1     n = n - 1;
  487:  getlink :findAnotherContainer:block :findAnotherContainer:n  block = getlink(n);
  488:  sensor *tmp263 :findAnotherContainer:block @type             case block.@type
  489:  jump *label156 equal *tmp263 @vault                          ...
  490:  jump *label155 notEqual *tmp263 @container                   ...
        label *label156                                              ...
  491:  op add .CONTAINERS .CONTAINERS 1                             CONTAINERS += 1;
  492:  sensor :findAnotherContainer:level :findAnotherContainer:blo level = block.sensor(ITEM);
  493:  jump *label157 greaterThanEq :findAnotherContainer:level :fi if level < min_level then
  494:  set :findAnotherContainer:min_level :findAnotherContainer:le min_level = level;
  495:  set .CONTAINER :findAnotherContainer:block                   CONTAINER = block;
  496:  set .CONTAINER_INDEX :findAnotherContainer:n                 CONTAINER_INDEX = n;
        label *label157                                              if level < min_level then
        label *label155                                              case block.@type
  497:  jump *label256 greaterThan :findAnotherContainer:n 0         while n > 0 do
        label *label153                                              ...
  498:  jump *label159 notEqual .CONTAINERS 0                        if CONTAINERS == 0 then
  499:  set .CONTAINER @this                                         CONTAINER = @this;
  500:  jump *label160 always 0 0                                    if CONTAINERS == 0 then
        label *label159                                              ...
  501:  set .DST .CONTAINER                                          DST = CONTAINER;
  502:  sensor :findAnotherContainer:dst_capacity .CONTAINER @itemCa dst_capacity = DST.@itemCapacity;
  503:  op mul *tmp271 :findAnotherContainer:dst_capacity .EFF_LOCAL DROP_LEVEL = (dst_capacity * EFF_LOCAL_LIMIT) \ 100;
  504:  op idiv .DROP_LEVEL *tmp271 100                              ...
  505:  set .LOCAL_MARGIN .DROP_LEVEL                                LOCAL_MARGIN = DROP_LEVEL;
  506:  op mul .LOW_LEVEL_TRIGGER :findAnotherContainer:dst_capacity LOW_LEVEL_TRIGGER = dst_capacity * (1 - TRIGGER_LEVEL);
  507:  set .HIGH_LEVEL_TRIGGER :findAnotherContainer:dst_capacity   HIGH_LEVEL_TRIGGER = dst_capacity;  // never triggers
  508:  sensor .DST_X .CONTAINER @x                                  DST_X = DST.@x;
  509:  sensor .DST_Y .CONTAINER @y                                  DST_Y = DST.@y;
  510:  op sub *tmp277 .DST_X .SRC_X                                 DISTANCE = len(DST_X - SRC_X, DST_Y - SRC_Y) - RADIUS_APPROACH - RADIUS_WITHIN;
  511:  op sub *tmp278 .DST_Y .SRC_Y                                 ...
  512:  op len *tmp279 *tmp277 *tmp278                               ...
  513:  op sub .DISTANCE *tmp279 14                                  ...
  514:  op max *tmp282 .DISTANCE 10                                  TRAVEL_TIME = (2 * max(DISTANCE, 10)) / SPEED;   // Travel time: both ways, in tiles/ms
  515:  op mul *tmp283 2 *tmp282                                     ...
  516:  op div .TRAVEL_TIME *tmp283 .SPEED                           ...
  517:  set .MESSAGE "[salmon]Container filled up, switching...[]\n" MESSAGE = "[salmon]Container filled up, switching...[]\n";
  518:  op add .MESSAGE_TIMEOUT @tick 600                            MESSAGE_TIMEOUT = @tick + 600;      // Ten seconds
        label *label160                                              if CONTAINERS == 0 then
  519:  set :last_level :findAnotherContainer:min_level              last_level = this_level = findAnotherContainer();
        label *label148                                              if max_drop < DROP_PACK then
        label *label146                                              if CONTAINERS > 1 and SRC == CORE then
  520:  set :wait_time 0                                             wait_time = 0;
  521:  set :remote_wait_time 0                                      remote_wait_time = 0;
  522:  jump *label161 lessThan @tick .MESSAGE_TIMEOUT               if @tick >= MESSAGE_TIMEOUT then
  523:  set .MESSAGE ""                                              MESSAGE = "";
        label *label161                                              if @tick >= MESSAGE_TIMEOUT then
        label *label134                                              if transfers >= active or wait_time > WAIT_LIMIT then
  524:  print .MESSAGE                                               print(MESSAGE);
  525:  print "Moving [green]"                                       print($"Moving [green]$ITEM[]$DIRECTION$LINK_TXT");
  526:  print .ITEM                                                  ...
  527:  print "[]"                                                   ...
  528:  print .DIRECTION                                             ...
  529:  print *tmp101                                                ...
  530:  print .AUTO_ALLOCATION_TXT                                   print(AUTO_ALLOCATION_TXT);
  531:  jump *label163 lessThanEq .TARGET 0                          if TARGET > 0 then
  532:  jump *label165 lessThan :active .TARGET                      if active >= TARGET then
  533:  print "\nUsing [green]"                                      print($"\nUsing [green]$active/$TARGET[] units ($UNIT) [gold]+$items_in_transit");
  534:  print :active                                                ...
  535:  print "/"                                                    ...
  536:  print .TARGET                                                ...
  537:  print "[] units ("                                           ...
  538:  print UNIT                                                   ...
  539:  print ") [gold]+"                                            ...
  540:  print :items_in_transit                                      ...
  541:  jump *label166 always 0 0                                    if active >= TARGET then
        label *label165                                              ...
  542:  print "\nUsing [salmon]"                                     print($"\nUsing [salmon]$active/$TARGET[] units ($UNIT) [gold]+$items_in_transit");
  543:  print :active                                                ...
  544:  print "/"                                                    ...
  545:  print .TARGET                                                ...
  546:  print "[] units ("                                           ...
  547:  print UNIT                                                   ...
  548:  print ") [gold]+"                                            ...
  549:  print :items_in_transit                                      ...
        label *label166                                              if active >= TARGET then
  550:  jump *label167 lessThanEq .CHANGE 0                          if CHANGE > 0 then
  551:  print "\n[][salmon]Cannot acquire additional units![]"       print("\n[][salmon]Cannot acquire additional units![]");
        label *label167                                              if CHANGE > 0 then
        label *label163                                              if TARGET > 0 then
  552:  print "\n[]Local items: [gold]"                              print($"\n[]Local items: [gold]$container_items");
  553:  print :container_items                                       ...
  554:  jump *label169 greaterThanEq .EFF_LOCAL_LIMIT 100            if EFF_LOCAL_LIMIT < 100 then
  555:  print "[] (limit [orange]"                                   print($"[] (limit [orange]$LOCAL_MARGIN[])");
  556:  print .LOCAL_MARGIN                                          ...
  557:  print "[])"                                                  ...
        label *label169                                              if EFF_LOCAL_LIMIT < 100 then
  558:  jump *label171 equal .SHOW_REMOTE_LEVEL false                if SHOW_REMOTE_LEVEL then
  559:  sensor :remote_level .CORE .ITEM                             remote_level = CORE.sensor(ITEM);
  560:  print "\n[]Remote items: [gold]"                             print($"\n[]Remote items: [gold]$remote_level");
  561:  print :remote_level                                          ...
  562:  jump *label173 greaterThanEq .EFF_REMOTE_LIMIT 100           if EFF_REMOTE_LIMIT < 100 then
  563:  print "[] (limit [orange]"                                   print($"[] (limit [orange]$REMOTE_MARGIN[])");
  564:  print .REMOTE_MARGIN                                         ...
  565:  print "[])"                                                  ...
        label *label173                                              if EFF_REMOTE_LIMIT < 100 then
        label *label171                                              if SHOW_REMOTE_LEVEL then
  566:  jump *label175 lessThanEq .TARGET 0                          if TARGET > 0 then
  567:  print "\n[]Speed: [green]"                                   print($"\n[]Speed: [green]$items_per_min$CORR_SIGN$corr_per_min$SPEED_UNIT_TXT");
  568:  print :items_per_min                                         ...
  569:  print .CORR_SIGN                                             ...
  570:  print :corr_per_min                                          ...
  571:  print .SPEED_UNIT_TXT                                        ...
  572:  jump *label177 equal .EFF_AUTO_ALLOCATION false              if EFF_AUTO_ALLOCATION then
  573:  print "\nUnit throughput: [green]"                           print($"\nUnit throughput: [green]$items_per_min_unit[]/min");
  574:  print :items_per_min_unit                                    ...
  575:  print "[]/min\nMin/last round: [green]"                      print($"\nMin/last round: [green]$turnaround_str[]/[green]$elapsed_str[] s");
  576:  print :turnaround_str                                        ...
  577:  print "[]/[green]"                                           ...
  578:  print :elapsed_str                                           ...
  579:  print "[] s"                                                 ...
  580:  jump *label178 always 0 0                                    if EFF_AUTO_ALLOCATION then
        label *label177                                              ...
  581:  print "\nLast round: [green]"                                print($"\nLast round: [green]$elapsed_str[] s");
  582:  print :elapsed_str                                           ...
  583:  print "[] s"                                                 ...
        label *label178                                              if EFF_AUTO_ALLOCATION then
  584:  print "\nTotal wait time: [green]"                           print($"\nTotal wait time: [green]$wait_time_str[] s");
  585:  print :wait_time_str                                         ...
  586:  print "[] s"                                                 ...
        label *label175                                              if TARGET > 0 then
  587:  print "\n[lightgray]Loop: "                                  print($"\n[lightgray]Loop: $loop_time_ms ms");
  588:  print :loop_time_ms                                          ...
  589:  print " ms"                                                  ...
  590:  printflush message1                                          printflush(message1);
  591:  op sub .CHANGE .TARGET :active                               CHANGE = TARGET - active;
  592:  set :active 0                                                active = 0;
  593:  set :first_unit @unit                                        first_unit = @unit;
  594:  set :items_in_transit 0                                      items_in_transit = 0;
  595:  print "Unit status:"                                         print("Unit status:");       // For message2
  596:  sensor *tmp305 .SRC @dead                                    if SRC.@dead != 0 then break; end;
  597:  jump *label79 notEqual *tmp305 0                             ...
  598:  sensor *tmp308 .DST @dead                                    if DST.@dead != 0 then break; end;
  599:  jump *label79 notEqual *tmp308 0                             ...
  600:  sensor *tmp311 .SORTER @dead                                 if SORTER.@dead != 0 then break; end;
  601:  jump *label79 notEqual *tmp311 0                             ...
  602:  getlink *tmp314 .CONTAINER_INDEX                             if CONTAINER != getlink(CONTAINER_INDEX) then break; end;
  603:  jump *label79 notEqual .CONTAINER *tmp314                    ...
        label *label91                                               if alive <= (@unit == first_unit) then
  604:  jump *label187 lessThanEq .CHANGE 0                          if CHANGE > 0 then
  605:  sensor *tmp319 @unit @controlled                             if @unit.@controlled == 0 then
  606:  jump *label189 notEqual *tmp319 0                            ...
  607:  op sub .CHANGE .CHANGE 1                                     CHANGE -= 1;
  608:  ucontrol flag 1 0 0 0 0                                      flag(S_FIRST);
        label *label189                                              if @unit.@controlled == 0 then
        label *label187                                              if CHANGE > 0 then
  609:  sensor *tmp322 @unit @controller                             if @unit.@controller == @this then
  610:  jump *label77 notEqual *tmp322 @this                         ...
  611:  sensor :state @unit @flag                                    state = @unit.@flag;
  612:  jump *label77 equal :state .S_UNUSED                         if state != S_UNUSED then
  613:  op max *tmp328 :state 1                                      state = min(max(state, S_FIRST), STATE_LIMIT);
  614:  op min :state *tmp328 .STATE_LIMIT                           ...
  615:  jump *label195 greaterThanEq .CHANGE 0                       if CHANGE < 0 then
  616:  jump *label197 equal :state 6                                if state != S_DISCARD then
  617:  sensor *tmp334 @unit @totalItems                             if @unit.@totalItems <= DISCARD_UNIT_MAX_ITEMS then
  618:  jump *label199 greaterThan *tmp334 .DISCARD_UNIT_MAX_ITEMS   ...
  619:  op add .CHANGE .CHANGE 1                                     CHANGE += 1;
  620:  set :state 6                                                 state = S_DISCARD;
        label *label199                                              if @unit.@totalItems <= DISCARD_UNIT_MAX_ITEMS then
        label *label197                                              if state != S_DISCARD then
        label *label195                                              if CHANGE < 0 then
  621:  jump *label201 notEqual :state 1                             if state == S_UNLOAD then
  622:  set :state 2                                                 state = S_APPROACH_SRC;
  623:  sensor *tmp339 @unit @totalItems                             if @unit.@totalItems == 0 then
  624:  jump *label204 equal *tmp339 0                               ...
  625:  set :state 4                                                 state = S_APPROACH_DST;
  626:  sensor *tmp342 @unit @firstItem                              elsif @unit.@firstItem == ITEM then
  627:  jump *label206 equal *tmp342 .ITEM                           ...
  628:  jump *label207 equal .DROP_TO_CORE false                     elsif DROP_TO_CORE then
  629:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  630:  ucontrol within .CORE_X .CORE_Y 8 *tmp346 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  631:  jump *label209 equal *tmp346 false                           ...
  632:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label209                                              if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  633:  print "[]\nUnloading previous items: [green]"                print($"[]\nUnloading previous items: [green]");
  634:  jump *label208 always 0 0                                    elsif DROP_TO_CORE then
        label *label207                                              ...
  635:  ucontrol itemDrop @air .UNIT_CAPACITY 0 0 0                  itemDrop(@air, UNIT_CAPACITY);
  636:  set :state 2                                                 state = S_APPROACH_SRC;
        label *label208                                              elsif DROP_TO_CORE then
        label *label206                                              elsif @unit.@firstItem == ITEM then
        label *label204                                              if @unit.@totalItems == 0 then
        label *label201                                              if state == S_UNLOAD then
  637:  jump *label211 notEqual :state 2                             if state == S_APPROACH_SRC then
  638:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  639:  ucontrol within .SRC_X .SRC_Y 8 *tmp350 0                    if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
  640:  jump *label213 equal *tmp350 false                           ...
  641:  set :state 3                                                 state = S_LOAD_ITEMS;
  642:  jump *label214 always 0 0                                    if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label213                                              ...
  643:  sensor *tmp354 @unit @x                                      print($"[]\n[gold]$ sec[] to $name: [green]", len(x - @unit.@x, y - @unit.@y) \ SPEED_SEC / 10);
  644:  op sub *tmp355 .SRC_X *tmp354                                ...
  645:  sensor *tmp356 @unit @y                                      ...
  646:  op sub *tmp357 .SRC_Y *tmp356                                ...
  647:  op len *tmp358 *tmp355 *tmp357                               ...
  648:  op idiv *tmp359 *tmp358 .SPEED_SEC                           ...
  649:  op div *tmp360 *tmp359 10                                    ...
  650:  print "[]\n[gold]"                                           ...
  651:  print *tmp360                                                ...
  652:  print " sec[] to source: [green]"                            ...
        label *label214                                              if within(SRC_X, SRC_Y, RADIUS_WITHIN) then
        label *label211                                              if state == S_APPROACH_SRC then
  653:  jump *label218 notEqual :state 3                             if state == S_LOAD_ITEMS then
  654:  sensor *tmp363 .SRC .ITEM                                    max_load = SRC.sensor(ITEM) - LOAD_LEVEL;
  655:  op sub :max_load *tmp363 .LOAD_LEVEL                         ...
  656:  jump *label220 lessThan :max_load .LOAD_PACK                 if max_load >= LOAD_PACK then
  657:  ucontrol itemTake .SRC .ITEM :max_load 0 0                   itemTake(SRC, ITEM, max_load);
        label *label220                                              if max_load >= LOAD_PACK then
  658:  sensor *tmp367 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  659:  jump *label222 lessThan *tmp367 .UNIT_CAPACITY               ...
  660:  set :state 4                                                 state = S_APPROACH_DST;
  661:  jump *label223 always 0 0                                    if @unit.@totalItems >= UNIT_CAPACITY then
        label *label222                                              ...
  662:  print "[]\nWaiting at source: [green]"                       print($"[]\nWaiting at source: [green]");
  663:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  664:  op add :wait_time :wait_time :loop_time_ms                   wait_time += loop_time_ms;
  665:  op mul *tmp370 :loop_time_ms .SRC_REMOTE_WAIT                remote_wait_time += loop_time_ms * SRC_REMOTE_WAIT;
  666:  op add :remote_wait_time :remote_wait_time *tmp370           ...
        label *label223                                              if @unit.@totalItems >= UNIT_CAPACITY then
        label *label218                                              if state == S_LOAD_ITEMS then
  667:  jump *label224 notEqual :state 4                             if state == S_APPROACH_DST then
  668:  ucontrol approach .DST_X .DST_Y 6 0 0                        approach(DST_X, DST_Y, RADIUS_APPROACH);
  669:  ucontrol within .DST_X .DST_Y 8 *tmp373 0                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
  670:  jump *label226 equal *tmp373 false                           ...
  671:  sensor *tmp375 @unit @totalItems                             transferred += @unit.@totalItems;
  672:  op add :transferred :transferred *tmp375                     ...
  673:  op add :transfers :transfers 1                               transfers += 1;
  674:  set :state 5                                                 state = S_DROP_ITEMS;
  675:  jump *label227 always 0 0                                    if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label226                                              ...
  676:  sensor *tmp378 @unit @x                                      print($"[]\n[gold]$ sec[] to $name: [green]", len(x - @unit.@x, y - @unit.@y) \ SPEED_SEC / 10);
  677:  op sub *tmp379 .DST_X *tmp378                                ...
  678:  sensor *tmp380 @unit @y                                      ...
  679:  op sub *tmp381 .DST_Y *tmp380                                ...
  680:  op len *tmp382 *tmp379 *tmp381                               ...
  681:  op idiv *tmp383 *tmp382 .SPEED_SEC                           ...
  682:  op div *tmp384 *tmp383 10                                    ...
  683:  print "[]\n[gold]"                                           ...
  684:  print *tmp384                                                ...
  685:  print " sec[] to destination: [green]"                       ...
        label *label227                                              if within(DST_X, DST_Y, RADIUS_WITHIN) then
        label *label224                                              if state == S_APPROACH_DST then
  686:  jump *label231 notEqual :state 5                             if state == S_DROP_ITEMS then
  687:  sensor *tmp387 .DST .ITEM                                    max_drop = DROP_LEVEL - DST.sensor(ITEM);
  688:  op sub :max_drop .DROP_LEVEL *tmp387                         ...
  689:  jump *label233 lessThan :max_drop .DROP_PACK                 if max_drop >= DROP_PACK then
  690:  ucontrol itemDrop .DST :max_drop 0 0 0                       itemDrop(DST, max_drop);
        label *label233                                              if max_drop >= DROP_PACK then
  691:  sensor *tmp391 @unit @totalItems                             if @unit.@totalItems <= 0 then
  692:  jump *label235 greaterThan *tmp391 0                         ...
  693:  set :state 2                                                 state = S_APPROACH_SRC;
  694:  ucontrol approach .SRC_X .SRC_Y 6 0 0                        approach(SRC_X, SRC_Y, RADIUS_APPROACH);
  695:  sensor *tmp396 @unit @x                                      print($"[]\n[gold]$ sec[] to $name: [green]", len(x - @unit.@x, y - @unit.@y) \ SPEED_SEC / 10);
  696:  op sub *tmp397 .SRC_X *tmp396                                ...
  697:  sensor *tmp398 @unit @y                                      ...
  698:  op sub *tmp399 .SRC_Y *tmp398                                ...
  699:  op len *tmp400 *tmp397 *tmp399                               ...
  700:  op idiv *tmp401 *tmp400 .SPEED_SEC                           ...
  701:  op div *tmp402 *tmp401 10                                    ...
  702:  print "[]\n[gold]"                                           ...
  703:  print *tmp402                                                ...
  704:  print " sec[] to source: [green]"                            ...
  705:  jump *label236 always 0 0                                    if SHOW_UNIT_DISTANCE then
        label *label235                                              if @unit.@totalItems <= 0 then
  706:  print "[]\nWaiting at destination: [green]"                  print($"[]\nWaiting at destination: [green]");
  707:  ucontrol approach .DST_X .DST_Y 6 0 0                        approach(DST_X, DST_Y, RADIUS_APPROACH);
  708:  op add :wait_time :wait_time :loop_time_ms                   wait_time += loop_time_ms;
  709:  op mul *tmp403 :loop_time_ms .DST_REMOTE_WAIT                remote_wait_time += loop_time_ms * DST_REMOTE_WAIT;
  710:  op add :remote_wait_time :remote_wait_time *tmp403           ...
        label *label236                                              if @unit.@totalItems <= 0 then
        label *label231                                              if state == S_DROP_ITEMS then
  711:  sensor :items @unit @totalItems                              items = @unit.@totalItems;
  712:  op add :items_in_transit :items_in_transit :items            items_in_transit += items;
  713:  jump *label240 notEqual :state 6                             if state == S_DISCARD then
  714:  print "[]\nParking: [green]"                                 print($"[]\nParking: [green]");
  715:  jump *label242 lessThanEq :items 0                           if items > 0 then
  716:  jump *label244 equal .DROP_TO_CORE false                     if DROP_TO_CORE then
  717:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  718:  ucontrol within .CORE_X .CORE_Y 8 *tmp410 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  719:  jump *label245 equal *tmp410 false                           ...
  720:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
  721:  sensor :items @unit @totalItems                              items = @unit.@totalItems;
  722:  jump *label245 always 0 0                                    if DROP_TO_CORE then
        label *label244                                              ...
  723:  ucontrol itemDrop @air .UNIT_CAPACITY 0 0 0                  itemDrop(@air, UNIT_CAPACITY);
  724:  sensor :items @unit @totalItems                              items = @unit.@totalItems;
        label *label245                                              if DROP_TO_CORE then
        label *label242                                              if items > 0 then
  725:  jump *label241 greaterThan :items .PARK_ITEM_LIMIT           if items <= PARK_ITEM_LIMIT then
  726:  ucontrol move .PARK_X .PARK_Y 0 0 0                          move(PARK_X, PARK_Y);
  727:  set :state .S_UNUSED                                         state = S_UNUSED;
  728:  jump *label241 always 0 0                                    if state == S_DISCARD then
        label *label240                                              ...
  729:  op add :active :active 1                                     active += 1;
        label *label241                                              if state == S_DISCARD then
  730:  print :items                                                 print(items, ITEM_ICON);
  731:  print .ITEM_ICON                                             ...
  732:  ucontrol flag :state 0 0 0 0                                 flag(state);
  733:  jump *label77 always 0 0                                     while true do
        label *label79                                               ...
  734:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  735:  control enabled switch2 false 0 0 0                          switch2.enabled = false;


Performance: parsed in 451 ms, compiled in 246 ms, optimized in 1,377 ms, run in 11 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (38 steps):
Configurable options:Which unit type to use:Remote vault ID (1-99); if nonzero, items are moved to/from this vault instead of core:Start in auto allocation mode?Max units to use, in both manual and auto allocation modes:Leave discarded units with nonzero flag for housekeeping (flag-clearing) processor to pick them up:Drop superfluous items to air, even when there's a core:How much of local container capacity to use, in percents (20-100):How much of remote container capacity to use, in percents (20-100)Allocate at least this much more units than needed:Allocate at most this much more units than needed:Use average of last three flow rate values for better unit auto allocation stability:End of configurable options
Execution exception at instruction 37: ubind UNIT:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
