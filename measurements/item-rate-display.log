   206 instructions before optimizations.
    35 instructions eliminated by Temp Variables Elimination (6 iterations).
    16 instructions eliminated by Dead Code Elimination (4 iterations).
    12 instructions eliminated by Condition Optimization (2 passes, 7 iterations).
    11 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     3 instructions modified by Expression Optimization (3 iterations).
   142 instructions eliminated by Data Flow Optimization (6 passes, 19 iterations).
     3 instructions eliminated by Loop Rotation (3 iterations).
       4 loop conditions were fully rotated.
       2 loop conditions were partially rotated.
   680 instructions added by Loop Unrolling (8 iterations).
     4 loops unrolled by Loop Unrolling.
    12 instructions eliminated by Print Merging.
   655 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 880):
    Partial loop rotation at line 32:1                           size    +1, benefit       25.0, efficiency     25.000
    Unroll loop at line 24:1                                     size  +137, benefit     1450.0, efficiency     10.584
  * Unroll loop at line 36:9                                     size    -3, benefit      625.0, efficiency   Infinity (-3 instructions)
    Unroll loop at line 55:5                                     size    +7, benefit     3750.0, efficiency    535.714
    Unroll loop at line 65:5                                     size  +473, benefit    36250.0, efficiency     76.638

Pass 1: speed optimization selection (cost limit 883):
    Partial loop rotation at line 32:1                           size    +1, benefit       25.0, efficiency     25.000
    Unroll loop at line 24:1                                     size  +137, benefit     1450.0, efficiency     10.584
  * Unroll loop at line 55:5                                     size    +7, benefit     3750.0, efficiency    535.714 (+6 instructions)
    Unroll loop at line 65:5                                     size  +473, benefit    36250.0, efficiency     76.638

Pass 1: speed optimization selection (cost limit 877):
    Partial loop rotation at line 32:1                           size    +1, benefit       25.0, efficiency     25.000
    Unroll loop at line 24:1                                     size  +137, benefit     1450.0, efficiency     10.584
  * Unroll loop at line 65:5                                     size  +473, benefit    36250.0, efficiency     76.638 (+411 instructions)

Pass 1: speed optimization selection (cost limit 466):
  * Partial loop rotation at line 32:1                           size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Unroll loop at line 24:1                                     size  +137, benefit     1450.0, efficiency     10.584

Pass 1: speed optimization selection (cost limit 465):
  * Unroll loop at line 24:1                                     size  +137, benefit     1450.0, efficiency     10.584 (+137 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-16 instructions):
 
    24 op lessThan *tmp6 :ptr .INDEX
    25 jump *label0 equal *tmp6 false
    26 op add :ptr :ptr .SKIP_SIZE
-    * set *tmp7 :ptr
    27 jump *label1 always
    28 label *label0
-    * set *tmp7 null
    29 label *label1
    30 set *tmp8 :ptr
    31 read *tmp9 .MEMORY *tmp8
 
    39 jump *label5 equal *tmp11 false
    40 op sub *tmp13 .SIZE 1
    41 set :ptr *tmp13
-    * set *tmp12 :ptr
    42 jump *label6 always
    43 label *label5
-    * set *tmp12 null
    44 label *label6
    45 set *tmp14 :ptr
    46 read *tmp15 .MEMORY *tmp14
 
    80 op add :n :n 1
    81 jump *label12 always
    82 label *label14
-    * set *tmp23 null
    83 jump *label11 always
    84 label *label10
-    * set *tmp23 null
    85 label *label11
    86 op div *tmp28 150 :maximum
    87 set :scale *tmp28
 
   107 op lessThan *tmp34 :head .INDEX
   108 jump *label15 equal *tmp34 false
   109 op add :head :head .SKIP_SIZE
-    * set *tmp35 :head
   110 jump *label16 always
   111 label *label15
-    * set *tmp35 null
   112 label *label16
   113 set :tail :head
   114 set :value 0
 
   124 jump *label20 equal *tmp39 false
   125 op sub *tmp41 .SIZE 1
   126 set :head *tmp41
-    * set *tmp40 :head
   127 jump *label21 always
   128 label *label20
-    * set *tmp40 null
   129 label *label21
   130 label *label18
   131 op add :i :i 1
 
   154 jump *label25 equal *tmp50 false
   155 op sub *tmp52 .SIZE 1
   156 set :head *tmp52
-    * set *tmp51 :head
   157 jump *label26 always
   158 label *label25
-    * set *tmp51 null
   159 label *label26
   160 op sub :tail :tail 1
   161 op lessThanEq *tmp53 :tail .INDEX
   162 jump *label27 equal *tmp53 false
   163 op sub *tmp55 .SIZE 1
   164 set :tail *tmp55
-    * set *tmp54 :tail
   165 jump *label28 always
   166 label *label27
-    * set *tmp54 null
   167 label *label28
   168 op mul *tmp56 :value :scale
   169 op add *tmp57 10 *tmp56
 
   188 jump *label29 equal *tmp63 false
   189 op mul *tmp65 1.5 :newMax
   190 set :maximum *tmp65
-    * set *tmp64 :maximum
   191 jump *label30 always
   192 label *label29
-    * set *tmp64 null
   193 label *label30
   194 set *tmp66 .POSITION
   195 write :maximum .COORD *tmp66

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-35 instructions):
 
    13 set .INDEX 256
    14 set .SIZE 511
    15 op sub *tmp0 .SIZE .INDEX
-    * op sub *tmp1 *tmp0 1
-    * set .SKIP_SIZE *tmp1
-    * op mul *tmp2 .POSITION 30
-    * set .SHIFT *tmp2
-    * set *tmp3 .INDEX
-    * read *tmp4 .MEMORY *tmp3
-    * op sub *tmp5 *tmp4 .SHIFT
-    * set :ptr *tmp5
+   16 op sub .SKIP_SIZE *tmp0 1
+   17 op mul .SHIFT .POSITION 30
+   18 read *tmp4 .MEMORY .INDEX
+   19 op sub :ptr *tmp4 .SHIFT
    20 op lessThan *tmp6 :ptr .INDEX
    21 jump *label0 equal *tmp6 false
    22 op add :ptr :ptr .SKIP_SIZE
    23 jump *label1 always
    24 label *label0
    25 label *label1
-    * set *tmp8 :ptr
-    * read *tmp9 .MEMORY *tmp8
-    * set :maximum *tmp9
+   26 read :maximum .MEMORY :ptr
    27 set :n 0
    28 label *label2
    29 jump *label4 greaterThanEq :n 29
-    * op sub *tmp10 :ptr 1
-    * set :ptr *tmp10
+   30 op sub :ptr :ptr 1
    31 op lessThanEq *tmp11 :ptr .INDEX
    32 jump *label5 equal *tmp11 false
-    * op sub *tmp13 .SIZE 1
-    * set :ptr *tmp13
+   33 op sub :ptr .SIZE 1
    34 jump *label6 always
    35 label *label5
    36 label *label6
-    * set *tmp14 :ptr
-    * read *tmp15 .MEMORY *tmp14
-    * op max *tmp16 :maximum *tmp15
-    * set :maximum *tmp16
+   37 read *tmp15 .MEMORY :ptr
+   38 op max :maximum :maximum *tmp15
    39 label *label3
    40 op add :n :n 1
    41 jump *label2 always
    42 label *label4
-    * op mul *tmp17 :maximum .SMOOTH
-    * set :maximum *tmp17
+   43 op mul :maximum :maximum .SMOOTH
    44 label *label7
    45 sensor *tmp18 switch1 @enabled
    46 op equal *tmp19 *tmp18 0
    47 jump *label9 equal *tmp19 false
    48 print "Item Rate Display"
-    * set *tmp20 @time
-    * set :start *tmp20
+   49 set :start @time
    50 sensor *tmp21 .COORD @dead
    51 op equal *tmp22 *tmp21 0
    52 jump *label10 equal *tmp22 false
 
    54 label *label12
    55 op lessThan *tmp24 :n .TOTAL
    56 jump *label14 equal *tmp24 false
-    * set *tmp25 :n
-    * read *tmp26 .COORD *tmp25
-    * set :m *tmp26
+   57 read :m .COORD :n
    58 print "\n"
    59 print "Coord: [gold]"
    60 print :m
    61 print "["
    62 print "]"
-    * op max *tmp27 :maximum :m
-    * set :maximum *tmp27
+   63 op max :maximum :maximum :m
    64 label *label13
    65 op add :n :n 1
    66 jump *label12 always
 
    68 jump *label11 always
    69 label *label10
    70 label *label11
-    * op div *tmp28 150 :maximum
-    * set :scale *tmp28
+   71 op div :scale 150 :maximum
    72 op ceil *tmp29 :maximum
    73 print "\n"
    74 print "Maximum: [green]"
 
    84 draw clear 0 0 80
    85 draw color 0 80 0 255
    86 draw rect 10 10 156 156
-    * set *tmp31 .INDEX
-    * read *tmp32 .MEMORY *tmp31
-    * op sub *tmp33 *tmp32 .SHIFT
-    * set :head *tmp33
+   87 read *tmp32 .MEMORY .INDEX
+   88 op sub :head *tmp32 .SHIFT
    89 op lessThan *tmp34 :head .INDEX
    90 jump *label15 equal *tmp34 false
    91 op add :head :head .SKIP_SIZE
 
    98 label *label17
    99 op lessThan *tmp36 :i .SMOOTH
   100 jump *label19 equal *tmp36 false
-    * set *tmp37 :head
-    * read *tmp38 .MEMORY *tmp37
+  101 read *tmp38 .MEMORY :head
   102 op add :value :value *tmp38
   103 op sub :head :head 1
   104 op lessThanEq *tmp39 :head .INDEX
   105 jump *label20 equal *tmp39 false
-    * op sub *tmp41 .SIZE 1
-    * set :head *tmp41
+  106 op sub :head .SIZE 1
   107 jump *label21 always
   108 label *label20
   109 label *label21
 
   112 jump *label17 always
   113 label *label19
   114 op mul *tmp42 :value :scale
-    * op add *tmp43 10 *tmp42
-    * set :last *tmp43
+  115 op add :last 10 *tmp42
   116 set :newMax :value
   117 draw color 80 255 80 255
   118 set :x 159
   119 set :n 0
   120 label *label22
   121 jump *label24 greaterThanEq :n 29
-    * set *tmp44 :tail
-    * read *tmp45 .MEMORY *tmp44
-    * set :t *tmp45
-    * set *tmp46 :head
-    * read *tmp47 .MEMORY *tmp46
-    * set :h *tmp47
+  122 read :t .MEMORY :tail
+  123 read :h .MEMORY :head
   124 op sub *tmp48 :value :t
-    * op add *tmp49 *tmp48 :h
-    * set :value *tmp49
+  125 op add :value *tmp48 :h
   126 op sub :head :head 1
   127 op lessThanEq *tmp50 :head .INDEX
   128 jump *label25 equal *tmp50 false
-    * op sub *tmp52 .SIZE 1
-    * set :head *tmp52
+  129 op sub :head .SIZE 1
   130 jump *label26 always
   131 label *label25
   132 label *label26
   133 op sub :tail :tail 1
   134 op lessThanEq *tmp53 :tail .INDEX
   135 jump *label27 equal *tmp53 false
-    * op sub *tmp55 .SIZE 1
-    * set :tail *tmp55
+  136 op sub :tail .SIZE 1
   137 jump *label28 always
   138 label *label27
   139 label *label28
   140 op mul *tmp56 :value :scale
-    * op add *tmp57 10 *tmp56
-    * set :y *tmp57
+  141 op add :y 10 *tmp56
   142 op sub *tmp58 :x 5
   143 draw line :x :last *tmp58 :y
-    * op sub *tmp59 :x 5
-    * set :x *tmp59
+  144 op sub :x :x 5
   145 set :last :y
-    * op max *tmp60 :newMax :value
-    * set :newMax *tmp60
+  146 op max :newMax :newMax :value
   147 label *label23
   148 op add :n :n 1
   149 jump *label22 always
   150 label *label24
   151 draw color 255 255 255 255
   152 draw lineRect 10 10 156 156
-    * op max *tmp61 :newMax :maximum
-    * set :maximum *tmp61
+  153 op max :maximum :newMax :maximum
   154 op mul *tmp62 3 :newMax
   155 op lessThan *tmp63 *tmp62 :maximum
   156 jump *label29 equal *tmp63 false
-    * op mul *tmp65 1.5 :newMax
-    * set :maximum *tmp65
+  157 op mul :maximum 1.5 :newMax
   158 jump *label30 always
   159 label *label29
   160 label *label30
-    * set *tmp66 .POSITION
-    * write :maximum .COORD *tmp66
+  161 write :maximum .COORD .POSITION
   162 op sub *tmp68 @time :start
   163 op floor *tmp69 *tmp68
   164 print "\n"
 
   168 print "ms"
   169 op div *tmp70 @time .FREQ
   170 op ceil *tmp71 *tmp70
-    * op mul *tmp72 .FREQ *tmp71
-    * set :wait *tmp72
+  171 op mul :wait .FREQ *tmp71
   172 set :loops 0
   173 label *label31
   174 op lessThan *tmp73 @time :wait

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-12 instructions):
 
    17 op mul .SHIFT .POSITION 30
    18 read *tmp4 .MEMORY .INDEX
    19 op sub :ptr *tmp4 .SHIFT
-    * op lessThan *tmp6 :ptr .INDEX
-    * jump *label0 equal *tmp6 false
+   20 jump *label0 greaterThanEq :ptr .INDEX
    21 op add :ptr :ptr .SKIP_SIZE
    22 jump *label1 always
    23 label *label0
 
    27 label *label2
    28 jump *label4 greaterThanEq :n 29
    29 op sub :ptr :ptr 1
-    * op lessThanEq *tmp11 :ptr .INDEX
-    * jump *label5 equal *tmp11 false
+   30 jump *label5 greaterThan :ptr .INDEX
    31 op sub :ptr .SIZE 1
    32 jump *label6 always
    33 label *label5
 
    41 op mul :maximum :maximum .SMOOTH
    42 label *label7
    43 sensor *tmp18 switch1 @enabled
-    * op equal *tmp19 *tmp18 0
-    * jump *label9 equal *tmp19 false
+   44 jump *label9 notEqual *tmp18 0
    45 print "Item Rate Display"
    46 set :start @time
    47 sensor *tmp21 .COORD @dead
-    * op equal *tmp22 *tmp21 0
-    * jump *label10 equal *tmp22 false
+   48 jump *label10 notEqual *tmp21 0
    49 set :n 0
    50 label *label12
-    * op lessThan *tmp24 :n .TOTAL
-    * jump *label14 equal *tmp24 false
+   51 jump *label14 greaterThanEq :n .TOTAL
    52 read :m .COORD :n
    53 print "\n"
    54 print "Coord: [gold]"
 
    81 draw rect 10 10 156 156
    82 read *tmp32 .MEMORY .INDEX
    83 op sub :head *tmp32 .SHIFT
-    * op lessThan *tmp34 :head .INDEX
-    * jump *label15 equal *tmp34 false
+   84 jump *label15 greaterThanEq :head .INDEX
    85 op add :head :head .SKIP_SIZE
    86 jump *label16 always
    87 label *label15
 
    90 set :value 0
    91 set :i 0
    92 label *label17
-    * op lessThan *tmp36 :i .SMOOTH
-    * jump *label19 equal *tmp36 false
+   93 jump *label19 greaterThanEq :i .SMOOTH
    94 read *tmp38 .MEMORY :head
    95 op add :value :value *tmp38
    96 op sub :head :head 1
-    * op lessThanEq *tmp39 :head .INDEX
-    * jump *label20 equal *tmp39 false
+   97 jump *label20 greaterThan :head .INDEX
    98 op sub :head .SIZE 1
    99 jump *label21 always
   100 label *label20
 
   116 op sub *tmp48 :value :t
   117 op add :value *tmp48 :h
   118 op sub :head :head 1
-    * op lessThanEq *tmp50 :head .INDEX
-    * jump *label25 equal *tmp50 false
+  119 jump *label25 greaterThan :head .INDEX
   120 op sub :head .SIZE 1
   121 jump *label26 always
   122 label *label25
   123 label *label26
   124 op sub :tail :tail 1
-    * op lessThanEq *tmp53 :tail .INDEX
-    * jump *label27 equal *tmp53 false
+  125 jump *label27 greaterThan :tail .INDEX
   126 op sub :tail .SIZE 1
   127 jump *label28 always
   128 label *label27
 
   142 draw lineRect 10 10 156 156
   143 op max :maximum :newMax :maximum
   144 op mul *tmp62 3 :newMax
-    * op lessThan *tmp63 *tmp62 :maximum
-    * jump *label29 equal *tmp63 false
+  145 jump *label29 greaterThanEq *tmp62 :maximum
   146 op mul :maximum 1.5 :newMax
   147 jump *label30 always
   148 label *label29
 
   160 op mul :wait .FREQ *tmp71
   161 set :loops 0
   162 label *label31
-    * op lessThan *tmp73 @time :wait
-    * jump *label33 equal *tmp73 false
+  163 jump *label33 greaterThanEq @time :wait
   164 op add :loops :loops 1
   165 label *label32
   166 jump *label31 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-8 instructions):
 
    19 op sub :ptr *tmp4 .SHIFT
    20 jump *label0 greaterThanEq :ptr .INDEX
    21 op add :ptr :ptr .SKIP_SIZE
-    * jump *label1 always
    22 label *label0
    23 label *label1
    24 read :maximum .MEMORY :ptr
 
    28 op sub :ptr :ptr 1
    29 jump *label5 greaterThan :ptr .INDEX
    30 op sub :ptr .SIZE 1
-    * jump *label6 always
    31 label *label5
    32 label *label6
    33 read *tmp15 .MEMORY :ptr
 
    58 op add :n :n 1
    59 jump *label12 always
    60 label *label14
-    * jump *label11 always
    61 label *label10
    62 label *label11
    63 op div :scale 150 :maximum
 
    80 op sub :head *tmp32 .SHIFT
    81 jump *label15 greaterThanEq :head .INDEX
    82 op add :head :head .SKIP_SIZE
-    * jump *label16 always
    83 label *label15
    84 label *label16
    85 set :tail :head
 
    92 op sub :head :head 1
    93 jump *label20 greaterThan :head .INDEX
    94 op sub :head .SIZE 1
-    * jump *label21 always
    95 label *label20
    96 label *label21
    97 label *label18
 
   113 op sub :head :head 1
   114 jump *label25 greaterThan :head .INDEX
   115 op sub :head .SIZE 1
-    * jump *label26 always
   116 label *label25
   117 label *label26
   118 op sub :tail :tail 1
   119 jump *label27 greaterThan :tail .INDEX
   120 op sub :tail .SIZE 1
-    * jump *label28 always
   121 label *label27
   122 label *label28
   123 op mul *tmp56 :value :scale
 
   137 op mul *tmp62 3 :newMax
   138 jump *label29 greaterThanEq *tmp62 :maximum
   139 op mul :maximum 1.5 :newMax
-    * jump *label30 always
   140 label *label29
   141 label *label30
   142 write :maximum .COORD .POSITION

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    12 draw stroke 1
    13 set .INDEX 256
    14 set .SIZE 511
-    * op sub *tmp0 .SIZE .INDEX
-    * op sub .SKIP_SIZE *tmp0 1
-    * op mul .SHIFT .POSITION 30
-    * read *tmp4 .MEMORY .INDEX
-    * op sub :ptr *tmp4 .SHIFT
-    * jump *label0 greaterThanEq :ptr .INDEX
-    * op add :ptr :ptr .SKIP_SIZE
+   15 op sub *tmp0 511 256
+   16 op sub .SKIP_SIZE 255 1
+   17 op mul .SHIFT 0 30
+   18 read *tmp4 bank1 256
+   19 op sub :ptr *tmp4 0
+   20 jump *label0 greaterThanEq :ptr 256
+   21 op add :ptr :ptr 254
    22 label *label0
    23 label *label1
-    * read :maximum .MEMORY :ptr
+   24 read :maximum bank1 :ptr
    25 set :n 0
    26 label *label2
    27 jump *label4 greaterThanEq :n 29
    28 op sub :ptr :ptr 1
-    * jump *label5 greaterThan :ptr .INDEX
-    * op sub :ptr .SIZE 1
+   29 jump *label5 greaterThan :ptr 256
+   30 op sub :ptr 511 1
    31 label *label5
    32 label *label6
-    * read *tmp15 .MEMORY :ptr
+   33 read *tmp15 bank1 :ptr
    34 op max :maximum :maximum *tmp15
    35 label *label3
    36 op add :n :n 1
    37 jump *label2 always
    38 label *label4
-    * op mul :maximum :maximum .SMOOTH
+   39 op mul :maximum :maximum 3
    40 label *label7
    41 sensor *tmp18 switch1 @enabled
    42 jump *label9 notEqual *tmp18 0
    43 print "Item Rate Display"
    44 set :start @time
-    * sensor *tmp21 .COORD @dead
+   45 sensor *tmp21 cell1 @dead
    46 jump *label10 notEqual *tmp21 0
    47 set :n 0
    48 label *label12
-    * jump *label14 greaterThanEq :n .TOTAL
-    * read :m .COORD :n
+   49 jump *label14 greaterThanEq :n 1
+   50 read :m cell1 :n
    51 print "\n"
    52 print "Coord: [gold]"
    53 print :m
 
    76 draw clear 0 0 80
    77 draw color 0 80 0 255
    78 draw rect 10 10 156 156
-    * read *tmp32 .MEMORY .INDEX
-    * op sub :head *tmp32 .SHIFT
-    * jump *label15 greaterThanEq :head .INDEX
-    * op add :head :head .SKIP_SIZE
+   79 read *tmp32 bank1 256
+   80 op sub :head *tmp32 0
+   81 jump *label15 greaterThanEq :head 256
+   82 op add :head :head 254
    83 label *label15
    84 label *label16
    85 set :tail :head
    86 set :value 0
    87 set :i 0
    88 label *label17
-    * jump *label19 greaterThanEq :i .SMOOTH
-    * read *tmp38 .MEMORY :head
+   89 jump *label19 greaterThanEq :i 3
+   90 read *tmp38 bank1 :head
    91 op add :value :value *tmp38
    92 op sub :head :head 1
-    * jump *label20 greaterThan :head .INDEX
-    * op sub :head .SIZE 1
+   93 jump *label20 greaterThan :head 256
+   94 op sub :head 511 1
    95 label *label20
    96 label *label21
    97 label *label18
 
   106 set :n 0
   107 label *label22
   108 jump *label24 greaterThanEq :n 29
-    * read :t .MEMORY :tail
-    * read :h .MEMORY :head
+  109 read :t bank1 :tail
+  110 read :h bank1 :head
   111 op sub *tmp48 :value :t
   112 op add :value *tmp48 :h
   113 op sub :head :head 1
-    * jump *label25 greaterThan :head .INDEX
-    * op sub :head .SIZE 1
+  114 jump *label25 greaterThan :head 256
+  115 op sub :head 511 1
   116 label *label25
   117 label *label26
   118 op sub :tail :tail 1
-    * jump *label27 greaterThan :tail .INDEX
-    * op sub :tail .SIZE 1
+  119 jump *label27 greaterThan :tail 256
+  120 op sub :tail 511 1
   121 label *label27
   122 label *label28
   123 op mul *tmp56 :value :scale
 
   139 op mul :maximum 1.5 :newMax
   140 label *label29
   141 label *label30
-    * write :maximum .COORD .POSITION
+  142 write :maximum cell1 0
   143 op sub *tmp68 @time :start
   144 op floor *tmp69 *tmp68
   145 print "\n"
 
   147 print *tmp69
   148 print " "
   149 print "ms"
-    * op div *tmp70 @time .FREQ
+  150 op div *tmp70 @time 1000
   151 op ceil *tmp71 *tmp70
-    * op mul :wait .FREQ *tmp71
+  152 op mul :wait 1000 *tmp71
   153 set :loops 0
   154 label *label31
   155 jump *label33 greaterThanEq @time :wait

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-11 instructions):
-    * set .MEMORY bank1
-    * set .COORD cell1
-    * set .SMOOTH 3
-    * set .POSITION 0
-    * set .TOTAL 1
-    * set .FREQ 1000
     0 printflush message1
     1 print "Item Rate Display"
     2 print "\n"
 
     4 print "\n"
     5 printflush message1
     6 draw stroke 1
-    * set .INDEX 256
-    * set .SIZE 511
-    * op sub *tmp0 511 256
-    * op sub .SKIP_SIZE 255 1
-    * op mul .SHIFT 0 30
     7 read *tmp4 bank1 256
     8 op sub :ptr *tmp4 0
     9 jump *label0 greaterThanEq :ptr 256
-    * op add :ptr :ptr 254
+   10 op add :ptr *tmp4 254
    11 label *label0
    12 label *label1
    13 read :maximum bank1 :ptr
 
    68 read *tmp32 bank1 256
    69 op sub :head *tmp32 0
    70 jump *label15 greaterThanEq :head 256
-    * op add :head :head 254
+   71 op add :head *tmp32 254
    72 label *label15
    73 label *label16
    74 set :tail :head

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1 (-4 instructions):
 
    13 read :maximum bank1 :ptr
    14 set :n 0
    15 label *label2
-    * jump *label4 greaterThanEq :n 29
+   16 label *label34
    17 op sub :ptr :ptr 1
    18 jump *label5 greaterThan :ptr 256
    19 op sub :ptr 511 1
 
    23 op max :maximum :maximum *tmp15
    24 label *label3
    25 op add :n :n 1
-    * jump *label2 always
+   26 jump *label34 lessThan :n 29
    27 label *label4
    28 op mul :maximum :maximum 3
    29 label *label7
 
    35 jump *label10 notEqual *tmp21 0
    36 set :n 0
    37 label *label12
-    * jump *label14 greaterThanEq :n 1
+   38 label *label35
    39 read :m cell1 :n
    40 print "\n"
    41 print "Coord: [gold]"
 
    45 op max :maximum :maximum :m
    46 label *label13
    47 op add :n :n 1
-    * jump *label12 always
+   48 jump *label35 lessThan :n 1
    49 label *label14
    50 label *label10
    51 label *label11
 
    75 set :value 0
    76 set :i 0
    77 label *label17
-    * jump *label19 greaterThanEq :i 3
+   78 label *label36
    79 read *tmp38 bank1 :head
    80 op add :value :value *tmp38
    81 op sub :head :head 1
 
    85 label *label21
    86 label *label18
    87 op add :i :i 1
-    * jump *label17 always
+   88 jump *label36 lessThan :i 3
    89 label *label19
    90 op mul *tmp42 :value :scale
    91 op add :last 10 *tmp42
 
    94 set :x 159
    95 set :n 0
    96 label *label22
-    * jump *label24 greaterThanEq :n 29
+   97 label *label37
    98 read :t bank1 :tail
    99 read :h bank1 :head
   100 op sub *tmp48 :value :t
 
   118 op max :newMax :newMax :value
   119 label *label23
   120 op add :n :n 1
-    * jump *label22 always
+  121 jump *label37 lessThan :n 29
   122 label *label24
   123 draw color 255 255 255 255
   124 draw lineRect 10 10 156 156
 
   142 set :loops 0
   143 label *label31
   144 jump *label33 greaterThanEq @time :wait
+  145 label *label38
   146 op add :loops :loops 1
   147 label *label32
-    * jump *label31 always
+  148 jump *label38 lessThan @time :wait
   149 label *label33
   150 drawflush display1
   151 print "\nLoops: "

Modifications by Unroll loop at line 36:9 (-1 instructions):
 
    33 set :start @time
    34 sensor *tmp21 cell1 @dead
    35 jump *label10 notEqual *tmp21 0
-    * set :n 0
-    * label *label12
-    * label *label35
-    * read :m cell1 :n
-    * print "\n"
-    * print "Coord: [gold]"
-    * print :m
-    * print "["
-    * print "]"
-    * op max :maximum :maximum :m
-    * label *label13
-    * op add :n :n 1
-    * jump *label35 lessThan :n 1
-    * label *label14
+   36 set :n 0
+   37 label *label39
+   38 label *label40
+   39 read :m cell1 :n
+   40 print "\n"
+   41 print "Coord: [gold]"
+   42 print :m
+   43 print "["
+   44 print "]"
+   45 op max :maximum :maximum :m
+   46 label *label41
+   47 op add :n :n 1
+   48 label *label14
    49 label *label10
    50 label *label11
    51 op div :scale 150 :maximum

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    36 set :n 0
    37 label *label39
    38 label *label40
-    * read :m cell1 :n
+   39 read :m cell1 0
    40 print "\n"
    41 print "Coord: [gold]"
    42 print :m
 
    44 print "]"
    45 op max :maximum :maximum :m
    46 label *label41
-    * op add :n :n 1
+   47 op add :n 0 1
    48 label *label14
    49 label *label10
    50 label *label11

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    33 set :start @time
    34 sensor *tmp21 cell1 @dead
    35 jump *label10 notEqual *tmp21 0
-    * set :n 0
    36 label *label39
    37 label *label40
    38 read :m cell1 0
 
    43 print "]"
    44 op max :maximum :maximum :m
    45 label *label41
-    * op add :n 0 1
    46 label *label14
    47 label *label10
    48 label *label11

Modifications by Unroll loop at line 55:5 (+11 instructions):
 
    70 label *label16
    71 set :tail :head
    72 set :value 0
-    * set :i 0
-    * label *label17
-    * label *label36
-    * read *tmp38 bank1 :head
-    * op add :value :value *tmp38
-    * op sub :head :head 1
-    * jump *label20 greaterThan :head 256
-    * op sub :head 511 1
-    * label *label20
-    * label *label21
-    * label *label18
-    * op add :i :i 1
-    * jump *label36 lessThan :i 3
-    * label *label19
+   73 set :i 0
+   74 label *label42
+   75 label *label43
+   76 read *tmp38 bank1 :head
+   77 op add :value :value *tmp38
+   78 op sub :head :head 1
+   79 jump *label44 greaterThan :head 256
+   80 op sub :head 511 1
+   81 label *label44
+   82 label *label45
+   83 label *label46
+   84 op add :i :i 1
+   85 read *tmp38 bank1 :head
+   86 op add :value :value *tmp38
+   87 op sub :head :head 1
+   88 jump *label47 greaterThan :head 256
+   89 op sub :head 511 1
+   90 label *label47
+   91 label *label48
+   92 label *label49
+   93 op add :i :i 1
+   94 read *tmp38 bank1 :head
+   95 op add :value :value *tmp38
+   96 op sub :head :head 1
+   97 jump *label50 greaterThan :head 256
+   98 op sub :head 511 1
+   99 label *label50
+  100 label *label51
+  101 label *label52
+  102 op add :i :i 1
+  103 label *label19
   104 op mul *tmp42 :value :scale
   105 op add :last 10 *tmp42
   106 set :newMax :value

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    74 label *label42
    75 label *label43
    76 read *tmp38 bank1 :head
-    * op add :value :value *tmp38
+   77 op add :value 0 *tmp38
    78 op sub :head :head 1
    79 jump *label44 greaterThan :head 256
    80 op sub :head 511 1
    81 label *label44
    82 label *label45
    83 label *label46
-    * op add :i :i 1
+   84 op add :i 0 1
    85 read *tmp38 bank1 :head
    86 op add :value :value *tmp38
    87 op sub :head :head 1
 
    90 label *label47
    91 label *label48
    92 label *label49
-    * op add :i :i 1
+   93 op add :i 1 1
    94 read *tmp38 bank1 :head
    95 op add :value :value *tmp38
    96 op sub :head :head 1
 
    99 label *label50
   100 label *label51
   101 label *label52
-    * op add :i :i 1
+  102 op add :i 2 1
   103 label *label19
   104 op mul *tmp42 :value :scale
   105 op add :last 10 *tmp42

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    69 label *label15
    70 label *label16
    71 set :tail :head
-    * set :value 0
-    * set :i 0
    72 label *label42
    73 label *label43
    74 read *tmp38 bank1 :head
 
    79 label *label44
    80 label *label45
    81 label *label46
-    * op add :i 0 1
    82 read *tmp38 bank1 :head
    83 op add :value :value *tmp38
    84 op sub :head :head 1
 
    87 label *label47
    88 label *label48
    89 label *label49
-    * op add :i 1 1
    90 read *tmp38 bank1 :head
    91 op add :value :value *tmp38
    92 op sub :head :head 1
 
    95 label *label50
    96 label *label51
    97 label *label52
-    * op add :i 2 1
    98 label *label19
    99 op mul *tmp42 :value :scale
   100 op add :last 10 *tmp42

Modifications by Unroll loop at line 65:5 (+503 instructions):
 
   101 set :newMax :value
   102 draw color 80 255 80 255
   103 set :x 159
-    * set :n 0
-    * label *label22
-    * label *label37
-    * read :t bank1 :tail
-    * read :h bank1 :head
-    * op sub *tmp48 :value :t
-    * op add :value *tmp48 :h
-    * op sub :head :head 1
-    * jump *label25 greaterThan :head 256
-    * op sub :head 511 1
-    * label *label25
-    * label *label26
-    * op sub :tail :tail 1
-    * jump *label27 greaterThan :tail 256
-    * op sub :tail 511 1
-    * label *label27
-    * label *label28
-    * op mul *tmp56 :value :scale
-    * op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
-    * set :last :y
-    * op max :newMax :newMax :value
-    * label *label23
-    * op add :n :n 1
-    * jump *label37 lessThan :n 29
-    * label *label24
+  104 set :n 0
+  105 label *label53
+  106 label *label54
+  107 read :t bank1 :tail
+  108 read :h bank1 :head
+  109 op sub *tmp48 :value :t
+  110 op add :value *tmp48 :h
+  111 op sub :head :head 1
+  112 jump *label55 greaterThan :head 256
+  113 op sub :head 511 1
+  114 label *label55
+  115 label *label56
+  116 op sub :tail :tail 1
+  117 jump *label57 greaterThan :tail 256
+  118 op sub :tail 511 1
+  119 label *label57
+  120 label *label58
+  121 op mul *tmp56 :value :scale
+  122 op add :y 10 *tmp56
+  123 op sub *tmp58 :x 5
+  124 draw line :x :last *tmp58 :y
+  125 op sub :x :x 5
+  126 set :last :y
+  127 op max :newMax :newMax :value
+  128 label *label59
+  129 op add :n :n 1
+  130 read :t bank1 :tail
+  131 read :h bank1 :head
+  132 op sub *tmp48 :value :t
+  133 op add :value *tmp48 :h
+  134 op sub :head :head 1
+  135 jump *label60 greaterThan :head 256
+  136 op sub :head 511 1
+  137 label *label60
+  138 label *label61
+  139 op sub :tail :tail 1
+  140 jump *label62 greaterThan :tail 256
+  141 op sub :tail 511 1
+  142 label *label62
+  143 label *label63
+  144 op mul *tmp56 :value :scale
+  145 op add :y 10 *tmp56
+  146 op sub *tmp58 :x 5
+  147 draw line :x :last *tmp58 :y
+  148 op sub :x :x 5
+  149 set :last :y
+  150 op max :newMax :newMax :value
+  151 label *label64
+  152 op add :n :n 1
+  153 read :t bank1 :tail
+  154 read :h bank1 :head
+  155 op sub *tmp48 :value :t
+  156 op add :value *tmp48 :h
+  157 op sub :head :head 1
+  158 jump *label65 greaterThan :head 256
+  159 op sub :head 511 1
+  160 label *label65
+  161 label *label66
+  162 op sub :tail :tail 1
+  163 jump *label67 greaterThan :tail 256
+  164 op sub :tail 511 1
+  165 label *label67
+  166 label *label68
+  167 op mul *tmp56 :value :scale
+  168 op add :y 10 *tmp56
+  169 op sub *tmp58 :x 5
+  170 draw line :x :last *tmp58 :y
+  171 op sub :x :x 5
+  172 set :last :y
+  173 op max :newMax :newMax :value
+  174 label *label69
+  175 op add :n :n 1
+  176 read :t bank1 :tail
+  177 read :h bank1 :head
+  178 op sub *tmp48 :value :t
+  179 op add :value *tmp48 :h
+  180 op sub :head :head 1
+  181 jump *label70 greaterThan :head 256
+  182 op sub :head 511 1
+  183 label *label70
+  184 label *label71
+  185 op sub :tail :tail 1
+  186 jump *label72 greaterThan :tail 256
+  187 op sub :tail 511 1
+  188 label *label72
+  189 label *label73
+  190 op mul *tmp56 :value :scale
+  191 op add :y 10 *tmp56
+  192 op sub *tmp58 :x 5
+  193 draw line :x :last *tmp58 :y
+  194 op sub :x :x 5
+  195 set :last :y
+  196 op max :newMax :newMax :value
+  197 label *label74
+  198 op add :n :n 1
+  199 read :t bank1 :tail
+  200 read :h bank1 :head
+  201 op sub *tmp48 :value :t
+  202 op add :value *tmp48 :h
+  203 op sub :head :head 1
+  204 jump *label75 greaterThan :head 256
+  205 op sub :head 511 1
+  206 label *label75
+  207 label *label76
+  208 op sub :tail :tail 1
+  209 jump *label77 greaterThan :tail 256
+  210 op sub :tail 511 1
+  211 label *label77
+  212 label *label78
+  213 op mul *tmp56 :value :scale
+  214 op add :y 10 *tmp56
+  215 op sub *tmp58 :x 5
+  216 draw line :x :last *tmp58 :y
+  217 op sub :x :x 5
+  218 set :last :y
+  219 op max :newMax :newMax :value
+  220 label *label79
+  221 op add :n :n 1
+  222 read :t bank1 :tail
+  223 read :h bank1 :head
+  224 op sub *tmp48 :value :t
+  225 op add :value *tmp48 :h
+  226 op sub :head :head 1
+  227 jump *label80 greaterThan :head 256
+  228 op sub :head 511 1
+  229 label *label80
+  230 label *label81
+  231 op sub :tail :tail 1
+  232 jump *label82 greaterThan :tail 256
+  233 op sub :tail 511 1
+  234 label *label82
+  235 label *label83
+  236 op mul *tmp56 :value :scale
+  237 op add :y 10 *tmp56
+  238 op sub *tmp58 :x 5
+  239 draw line :x :last *tmp58 :y
+  240 op sub :x :x 5
+  241 set :last :y
+  242 op max :newMax :newMax :value
+  243 label *label84
+  244 op add :n :n 1
+  245 read :t bank1 :tail
+  246 read :h bank1 :head
+  247 op sub *tmp48 :value :t
+  248 op add :value *tmp48 :h
+  249 op sub :head :head 1
+  250 jump *label85 greaterThan :head 256
+  251 op sub :head 511 1
+  252 label *label85
+  253 label *label86
+  254 op sub :tail :tail 1
+  255 jump *label87 greaterThan :tail 256
+  256 op sub :tail 511 1
+  257 label *label87
+  258 label *label88
+  259 op mul *tmp56 :value :scale
+  260 op add :y 10 *tmp56
+  261 op sub *tmp58 :x 5
+  262 draw line :x :last *tmp58 :y
+  263 op sub :x :x 5
+  264 set :last :y
+  265 op max :newMax :newMax :value
+  266 label *label89
+  267 op add :n :n 1
+  268 read :t bank1 :tail
+  269 read :h bank1 :head
+  270 op sub *tmp48 :value :t
+  271 op add :value *tmp48 :h
+  272 op sub :head :head 1
+  273 jump *label90 greaterThan :head 256
+  274 op sub :head 511 1
+  275 label *label90
+  276 label *label91
+  277 op sub :tail :tail 1
+  278 jump *label92 greaterThan :tail 256
+  279 op sub :tail 511 1
+  280 label *label92
+  281 label *label93
+  282 op mul *tmp56 :value :scale
+  283 op add :y 10 *tmp56
+  284 op sub *tmp58 :x 5
+  285 draw line :x :last *tmp58 :y
+  286 op sub :x :x 5
+  287 set :last :y
+  288 op max :newMax :newMax :value
+  289 label *label94
+  290 op add :n :n 1
+  291 read :t bank1 :tail
+  292 read :h bank1 :head
+  293 op sub *tmp48 :value :t
+  294 op add :value *tmp48 :h
+  295 op sub :head :head 1
+  296 jump *label95 greaterThan :head 256
+  297 op sub :head 511 1
+  298 label *label95
+  299 label *label96
+  300 op sub :tail :tail 1
+  301 jump *label97 greaterThan :tail 256
+  302 op sub :tail 511 1
+  303 label *label97
+  304 label *label98
+  305 op mul *tmp56 :value :scale
+  306 op add :y 10 *tmp56
+  307 op sub *tmp58 :x 5
+  308 draw line :x :last *tmp58 :y
+  309 op sub :x :x 5
+  310 set :last :y
+  311 op max :newMax :newMax :value
+  312 label *label99
+  313 op add :n :n 1
+  314 read :t bank1 :tail
+  315 read :h bank1 :head
+  316 op sub *tmp48 :value :t
+  317 op add :value *tmp48 :h
+  318 op sub :head :head 1
+  319 jump *label100 greaterThan :head 256
+  320 op sub :head 511 1
+  321 label *label100
+  322 label *label101
+  323 op sub :tail :tail 1
+  324 jump *label102 greaterThan :tail 256
+  325 op sub :tail 511 1
+  326 label *label102
+  327 label *label103
+  328 op mul *tmp56 :value :scale
+  329 op add :y 10 *tmp56
+  330 op sub *tmp58 :x 5
+  331 draw line :x :last *tmp58 :y
+  332 op sub :x :x 5
+  333 set :last :y
+  334 op max :newMax :newMax :value
+  335 label *label104
+  336 op add :n :n 1
+  337 read :t bank1 :tail
+  338 read :h bank1 :head
+  339 op sub *tmp48 :value :t
+  340 op add :value *tmp48 :h
+  341 op sub :head :head 1
+  342 jump *label105 greaterThan :head 256
+  343 op sub :head 511 1
+  344 label *label105
+  345 label *label106
+  346 op sub :tail :tail 1
+  347 jump *label107 greaterThan :tail 256
+  348 op sub :tail 511 1
+  349 label *label107
+  350 label *label108
+  351 op mul *tmp56 :value :scale
+  352 op add :y 10 *tmp56
+  353 op sub *tmp58 :x 5
+  354 draw line :x :last *tmp58 :y
+  355 op sub :x :x 5
+  356 set :last :y
+  357 op max :newMax :newMax :value
+  358 label *label109
+  359 op add :n :n 1
+  360 read :t bank1 :tail
+  361 read :h bank1 :head
+  362 op sub *tmp48 :value :t
+  363 op add :value *tmp48 :h
+  364 op sub :head :head 1
+  365 jump *label110 greaterThan :head 256
+  366 op sub :head 511 1
+  367 label *label110
+  368 label *label111
+  369 op sub :tail :tail 1
+  370 jump *label112 greaterThan :tail 256
+  371 op sub :tail 511 1
+  372 label *label112
+  373 label *label113
+  374 op mul *tmp56 :value :scale
+  375 op add :y 10 *tmp56
+  376 op sub *tmp58 :x 5
+  377 draw line :x :last *tmp58 :y
+  378 op sub :x :x 5
+  379 set :last :y
+  380 op max :newMax :newMax :value
+  381 label *label114
+  382 op add :n :n 1
+  383 read :t bank1 :tail
+  384 read :h bank1 :head
+  385 op sub *tmp48 :value :t
+  386 op add :value *tmp48 :h
+  387 op sub :head :head 1
+  388 jump *label115 greaterThan :head 256
+  389 op sub :head 511 1
+  390 label *label115
+  391 label *label116
+  392 op sub :tail :tail 1
+  393 jump *label117 greaterThan :tail 256
+  394 op sub :tail 511 1
+  395 label *label117
+  396 label *label118
+  397 op mul *tmp56 :value :scale
+  398 op add :y 10 *tmp56
+  399 op sub *tmp58 :x 5
+  400 draw line :x :last *tmp58 :y
+  401 op sub :x :x 5
+  402 set :last :y
+  403 op max :newMax :newMax :value
+  404 label *label119
+  405 op add :n :n 1
+  406 read :t bank1 :tail
+  407 read :h bank1 :head
+  408 op sub *tmp48 :value :t
+  409 op add :value *tmp48 :h
+  410 op sub :head :head 1
+  411 jump *label120 greaterThan :head 256
+  412 op sub :head 511 1
+  413 label *label120
+  414 label *label121
+  415 op sub :tail :tail 1
+  416 jump *label122 greaterThan :tail 256
+  417 op sub :tail 511 1
+  418 label *label122
+  419 label *label123
+  420 op mul *tmp56 :value :scale
+  421 op add :y 10 *tmp56
+  422 op sub *tmp58 :x 5
+  423 draw line :x :last *tmp58 :y
+  424 op sub :x :x 5
+  425 set :last :y
+  426 op max :newMax :newMax :value
+  427 label *label124
+  428 op add :n :n 1
+  429 read :t bank1 :tail
+  430 read :h bank1 :head
+  431 op sub *tmp48 :value :t
+  432 op add :value *tmp48 :h
+  433 op sub :head :head 1
+  434 jump *label125 greaterThan :head 256
+  435 op sub :head 511 1
+  436 label *label125
+  437 label *label126
+  438 op sub :tail :tail 1
+  439 jump *label127 greaterThan :tail 256
+  440 op sub :tail 511 1
+  441 label *label127
+  442 label *label128
+  443 op mul *tmp56 :value :scale
+  444 op add :y 10 *tmp56
+  445 op sub *tmp58 :x 5
+  446 draw line :x :last *tmp58 :y
+  447 op sub :x :x 5
+  448 set :last :y
+  449 op max :newMax :newMax :value
+  450 label *label129
+  451 op add :n :n 1
+  452 read :t bank1 :tail
+  453 read :h bank1 :head
+  454 op sub *tmp48 :value :t
+  455 op add :value *tmp48 :h
+  456 op sub :head :head 1
+  457 jump *label130 greaterThan :head 256
+  458 op sub :head 511 1
+  459 label *label130
+  460 label *label131
+  461 op sub :tail :tail 1
+  462 jump *label132 greaterThan :tail 256
+  463 op sub :tail 511 1
+  464 label *label132
+  465 label *label133
+  466 op mul *tmp56 :value :scale
+  467 op add :y 10 *tmp56
+  468 op sub *tmp58 :x 5
+  469 draw line :x :last *tmp58 :y
+  470 op sub :x :x 5
+  471 set :last :y
+  472 op max :newMax :newMax :value
+  473 label *label134
+  474 op add :n :n 1
+  475 read :t bank1 :tail
+  476 read :h bank1 :head
+  477 op sub *tmp48 :value :t
+  478 op add :value *tmp48 :h
+  479 op sub :head :head 1
+  480 jump *label135 greaterThan :head 256
+  481 op sub :head 511 1
+  482 label *label135
+  483 label *label136
+  484 op sub :tail :tail 1
+  485 jump *label137 greaterThan :tail 256
+  486 op sub :tail 511 1
+  487 label *label137
+  488 label *label138
+  489 op mul *tmp56 :value :scale
+  490 op add :y 10 *tmp56
+  491 op sub *tmp58 :x 5
+  492 draw line :x :last *tmp58 :y
+  493 op sub :x :x 5
+  494 set :last :y
+  495 op max :newMax :newMax :value
+  496 label *label139
+  497 op add :n :n 1
+  498 read :t bank1 :tail
+  499 read :h bank1 :head
+  500 op sub *tmp48 :value :t
+  501 op add :value *tmp48 :h
+  502 op sub :head :head 1
+  503 jump *label140 greaterThan :head 256
+  504 op sub :head 511 1
+  505 label *label140
+  506 label *label141
+  507 op sub :tail :tail 1
+  508 jump *label142 greaterThan :tail 256
+  509 op sub :tail 511 1
+  510 label *label142
+  511 label *label143
+  512 op mul *tmp56 :value :scale
+  513 op add :y 10 *tmp56
+  514 op sub *tmp58 :x 5
+  515 draw line :x :last *tmp58 :y
+  516 op sub :x :x 5
+  517 set :last :y
+  518 op max :newMax :newMax :value
+  519 label *label144
+  520 op add :n :n 1
+  521 read :t bank1 :tail
+  522 read :h bank1 :head
+  523 op sub *tmp48 :value :t
+  524 op add :value *tmp48 :h
+  525 op sub :head :head 1
+  526 jump *label145 greaterThan :head 256
+  527 op sub :head 511 1
+  528 label *label145
+  529 label *label146
+  530 op sub :tail :tail 1
+  531 jump *label147 greaterThan :tail 256
+  532 op sub :tail 511 1
+  533 label *label147
+  534 label *label148
+  535 op mul *tmp56 :value :scale
+  536 op add :y 10 *tmp56
+  537 op sub *tmp58 :x 5
+  538 draw line :x :last *tmp58 :y
+  539 op sub :x :x 5
+  540 set :last :y
+  541 op max :newMax :newMax :value
+  542 label *label149
+  543 op add :n :n 1
+  544 read :t bank1 :tail
+  545 read :h bank1 :head
+  546 op sub *tmp48 :value :t
+  547 op add :value *tmp48 :h
+  548 op sub :head :head 1
+  549 jump *label150 greaterThan :head 256
+  550 op sub :head 511 1
+  551 label *label150
+  552 label *label151
+  553 op sub :tail :tail 1
+  554 jump *label152 greaterThan :tail 256
+  555 op sub :tail 511 1
+  556 label *label152
+  557 label *label153
+  558 op mul *tmp56 :value :scale
+  559 op add :y 10 *tmp56
+  560 op sub *tmp58 :x 5
+  561 draw line :x :last *tmp58 :y
+  562 op sub :x :x 5
+  563 set :last :y
+  564 op max :newMax :newMax :value
+  565 label *label154
+  566 op add :n :n 1
+  567 read :t bank1 :tail
+  568 read :h bank1 :head
+  569 op sub *tmp48 :value :t
+  570 op add :value *tmp48 :h
+  571 op sub :head :head 1
+  572 jump *label155 greaterThan :head 256
+  573 op sub :head 511 1
+  574 label *label155
+  575 label *label156
+  576 op sub :tail :tail 1
+  577 jump *label157 greaterThan :tail 256
+  578 op sub :tail 511 1
+  579 label *label157
+  580 label *label158
+  581 op mul *tmp56 :value :scale
+  582 op add :y 10 *tmp56
+  583 op sub *tmp58 :x 5
+  584 draw line :x :last *tmp58 :y
+  585 op sub :x :x 5
+  586 set :last :y
+  587 op max :newMax :newMax :value
+  588 label *label159
+  589 op add :n :n 1
+  590 read :t bank1 :tail
+  591 read :h bank1 :head
+  592 op sub *tmp48 :value :t
+  593 op add :value *tmp48 :h
+  594 op sub :head :head 1
+  595 jump *label160 greaterThan :head 256
+  596 op sub :head 511 1
+  597 label *label160
+  598 label *label161
+  599 op sub :tail :tail 1
+  600 jump *label162 greaterThan :tail 256
+  601 op sub :tail 511 1
+  602 label *label162
+  603 label *label163
+  604 op mul *tmp56 :value :scale
+  605 op add :y 10 *tmp56
+  606 op sub *tmp58 :x 5
+  607 draw line :x :last *tmp58 :y
+  608 op sub :x :x 5
+  609 set :last :y
+  610 op max :newMax :newMax :value
+  611 label *label164
+  612 op add :n :n 1
+  613 read :t bank1 :tail
+  614 read :h bank1 :head
+  615 op sub *tmp48 :value :t
+  616 op add :value *tmp48 :h
+  617 op sub :head :head 1
+  618 jump *label165 greaterThan :head 256
+  619 op sub :head 511 1
+  620 label *label165
+  621 label *label166
+  622 op sub :tail :tail 1
+  623 jump *label167 greaterThan :tail 256
+  624 op sub :tail 511 1
+  625 label *label167
+  626 label *label168
+  627 op mul *tmp56 :value :scale
+  628 op add :y 10 *tmp56
+  629 op sub *tmp58 :x 5
+  630 draw line :x :last *tmp58 :y
+  631 op sub :x :x 5
+  632 set :last :y
+  633 op max :newMax :newMax :value
+  634 label *label169
+  635 op add :n :n 1
+  636 read :t bank1 :tail
+  637 read :h bank1 :head
+  638 op sub *tmp48 :value :t
+  639 op add :value *tmp48 :h
+  640 op sub :head :head 1
+  641 jump *label170 greaterThan :head 256
+  642 op sub :head 511 1
+  643 label *label170
+  644 label *label171
+  645 op sub :tail :tail 1
+  646 jump *label172 greaterThan :tail 256
+  647 op sub :tail 511 1
+  648 label *label172
+  649 label *label173
+  650 op mul *tmp56 :value :scale
+  651 op add :y 10 *tmp56
+  652 op sub *tmp58 :x 5
+  653 draw line :x :last *tmp58 :y
+  654 op sub :x :x 5
+  655 set :last :y
+  656 op max :newMax :newMax :value
+  657 label *label174
+  658 op add :n :n 1
+  659 read :t bank1 :tail
+  660 read :h bank1 :head
+  661 op sub *tmp48 :value :t
+  662 op add :value *tmp48 :h
+  663 op sub :head :head 1
+  664 jump *label175 greaterThan :head 256
+  665 op sub :head 511 1
+  666 label *label175
+  667 label *label176
+  668 op sub :tail :tail 1
+  669 jump *label177 greaterThan :tail 256
+  670 op sub :tail 511 1
+  671 label *label177
+  672 label *label178
+  673 op mul *tmp56 :value :scale
+  674 op add :y 10 *tmp56
+  675 op sub *tmp58 :x 5
+  676 draw line :x :last *tmp58 :y
+  677 op sub :x :x 5
+  678 set :last :y
+  679 op max :newMax :newMax :value
+  680 label *label179
+  681 op add :n :n 1
+  682 read :t bank1 :tail
+  683 read :h bank1 :head
+  684 op sub *tmp48 :value :t
+  685 op add :value *tmp48 :h
+  686 op sub :head :head 1
+  687 jump *label180 greaterThan :head 256
+  688 op sub :head 511 1
+  689 label *label180
+  690 label *label181
+  691 op sub :tail :tail 1
+  692 jump *label182 greaterThan :tail 256
+  693 op sub :tail 511 1
+  694 label *label182
+  695 label *label183
+  696 op mul *tmp56 :value :scale
+  697 op add :y 10 *tmp56
+  698 op sub *tmp58 :x 5
+  699 draw line :x :last *tmp58 :y
+  700 op sub :x :x 5
+  701 set :last :y
+  702 op max :newMax :newMax :value
+  703 label *label184
+  704 op add :n :n 1
+  705 read :t bank1 :tail
+  706 read :h bank1 :head
+  707 op sub *tmp48 :value :t
+  708 op add :value *tmp48 :h
+  709 op sub :head :head 1
+  710 jump *label185 greaterThan :head 256
+  711 op sub :head 511 1
+  712 label *label185
+  713 label *label186
+  714 op sub :tail :tail 1
+  715 jump *label187 greaterThan :tail 256
+  716 op sub :tail 511 1
+  717 label *label187
+  718 label *label188
+  719 op mul *tmp56 :value :scale
+  720 op add :y 10 *tmp56
+  721 op sub *tmp58 :x 5
+  722 draw line :x :last *tmp58 :y
+  723 op sub :x :x 5
+  724 set :last :y
+  725 op max :newMax :newMax :value
+  726 label *label189
+  727 op add :n :n 1
+  728 read :t bank1 :tail
+  729 read :h bank1 :head
+  730 op sub *tmp48 :value :t
+  731 op add :value *tmp48 :h
+  732 op sub :head :head 1
+  733 jump *label190 greaterThan :head 256
+  734 op sub :head 511 1
+  735 label *label190
+  736 label *label191
+  737 op sub :tail :tail 1
+  738 jump *label192 greaterThan :tail 256
+  739 op sub :tail 511 1
+  740 label *label192
+  741 label *label193
+  742 op mul *tmp56 :value :scale
+  743 op add :y 10 *tmp56
+  744 op sub *tmp58 :x 5
+  745 draw line :x :last *tmp58 :y
+  746 op sub :x :x 5
+  747 set :last :y
+  748 op max :newMax :newMax :value
+  749 label *label194
+  750 op add :n :n 1
+  751 read :t bank1 :tail
+  752 read :h bank1 :head
+  753 op sub *tmp48 :value :t
+  754 op add :value *tmp48 :h
+  755 op sub :head :head 1
+  756 jump *label195 greaterThan :head 256
+  757 op sub :head 511 1
+  758 label *label195
+  759 label *label196
+  760 op sub :tail :tail 1
+  761 jump *label197 greaterThan :tail 256
+  762 op sub :tail 511 1
+  763 label *label197
+  764 label *label198
+  765 op mul *tmp56 :value :scale
+  766 op add :y 10 *tmp56
+  767 op sub *tmp58 :x 5
+  768 draw line :x :last *tmp58 :y
+  769 op sub :x :x 5
+  770 set :last :y
+  771 op max :newMax :newMax :value
+  772 label *label199
+  773 op add :n :n 1
+  774 label *label24
   775 draw color 255 255 255 255
   776 draw lineRect 10 10 156 156
   777 op max :maximum :newMax :maximum

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-3 instructions):
 
   120 label *label58
   121 op mul *tmp56 :value :scale
   122 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  123 op sub *tmp58 159 5
+  124 draw line 159 :last 154 :y
+  125 op sub :x 159 5
   126 set :last :y
   127 op max :newMax :newMax :value
   128 label *label59
-    * op add :n :n 1
+  129 op add :n 0 1
   130 read :t bank1 :tail
   131 read :h bank1 :head
   132 op sub *tmp48 :value :t
 
   143 label *label63
   144 op mul *tmp56 :value :scale
   145 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  146 op sub *tmp58 154 5
+  147 draw line 154 :last 149 :y
+  148 op sub :x 154 5
   149 set :last :y
   150 op max :newMax :newMax :value
   151 label *label64
-    * op add :n :n 1
+  152 op add :n 1 1
   153 read :t bank1 :tail
   154 read :h bank1 :head
   155 op sub *tmp48 :value :t
 
   166 label *label68
   167 op mul *tmp56 :value :scale
   168 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  169 op sub *tmp58 149 5
+  170 draw line 149 :last 144 :y
+  171 op sub :x 149 5
   172 set :last :y
   173 op max :newMax :newMax :value
   174 label *label69
-    * op add :n :n 1
+  175 op add :n 2 1
   176 read :t bank1 :tail
   177 read :h bank1 :head
   178 op sub *tmp48 :value :t
 
   189 label *label73
   190 op mul *tmp56 :value :scale
   191 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  192 op sub *tmp58 144 5
+  193 draw line 144 :last 139 :y
+  194 op sub :x 144 5
   195 set :last :y
   196 op max :newMax :newMax :value
   197 label *label74
-    * op add :n :n 1
+  198 op add :n 3 1
   199 read :t bank1 :tail
   200 read :h bank1 :head
   201 op sub *tmp48 :value :t
 
   212 label *label78
   213 op mul *tmp56 :value :scale
   214 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  215 op sub *tmp58 139 5
+  216 draw line 139 :last 134 :y
+  217 op sub :x 139 5
   218 set :last :y
   219 op max :newMax :newMax :value
   220 label *label79
-    * op add :n :n 1
+  221 op add :n 4 1
   222 read :t bank1 :tail
   223 read :h bank1 :head
   224 op sub *tmp48 :value :t
 
   235 label *label83
   236 op mul *tmp56 :value :scale
   237 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  238 op sub *tmp58 134 5
+  239 draw line 134 :last 129 :y
+  240 op sub :x 134 5
   241 set :last :y
   242 op max :newMax :newMax :value
   243 label *label84
-    * op add :n :n 1
+  244 op add :n 5 1
   245 read :t bank1 :tail
   246 read :h bank1 :head
   247 op sub *tmp48 :value :t
 
   258 label *label88
   259 op mul *tmp56 :value :scale
   260 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  261 op sub *tmp58 129 5
+  262 draw line 129 :last 124 :y
+  263 op sub :x 129 5
   264 set :last :y
   265 op max :newMax :newMax :value
   266 label *label89
-    * op add :n :n 1
+  267 op add :n 6 1
   268 read :t bank1 :tail
   269 read :h bank1 :head
   270 op sub *tmp48 :value :t
 
   281 label *label93
   282 op mul *tmp56 :value :scale
   283 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  284 op sub *tmp58 124 5
+  285 draw line 124 :last 119 :y
+  286 op sub :x 124 5
   287 set :last :y
   288 op max :newMax :newMax :value
   289 label *label94
-    * op add :n :n 1
+  290 op add :n 7 1
   291 read :t bank1 :tail
   292 read :h bank1 :head
   293 op sub *tmp48 :value :t
 
   304 label *label98
   305 op mul *tmp56 :value :scale
   306 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  307 op sub *tmp58 119 5
+  308 draw line 119 :last 114 :y
+  309 op sub :x 119 5
   310 set :last :y
   311 op max :newMax :newMax :value
   312 label *label99
-    * op add :n :n 1
+  313 op add :n 8 1
   314 read :t bank1 :tail
   315 read :h bank1 :head
   316 op sub *tmp48 :value :t
 
   327 label *label103
   328 op mul *tmp56 :value :scale
   329 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  330 op sub *tmp58 114 5
+  331 draw line 114 :last 109 :y
+  332 op sub :x 114 5
   333 set :last :y
   334 op max :newMax :newMax :value
   335 label *label104
-    * op add :n :n 1
+  336 op add :n 9 1
   337 read :t bank1 :tail
   338 read :h bank1 :head
   339 op sub *tmp48 :value :t
 
   350 label *label108
   351 op mul *tmp56 :value :scale
   352 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  353 op sub *tmp58 109 5
+  354 draw line 109 :last 104 :y
+  355 op sub :x 109 5
   356 set :last :y
   357 op max :newMax :newMax :value
   358 label *label109
-    * op add :n :n 1
+  359 op add :n 10 1
   360 read :t bank1 :tail
   361 read :h bank1 :head
   362 op sub *tmp48 :value :t
 
   373 label *label113
   374 op mul *tmp56 :value :scale
   375 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  376 op sub *tmp58 104 5
+  377 draw line 104 :last 99 :y
+  378 op sub :x 104 5
   379 set :last :y
   380 op max :newMax :newMax :value
   381 label *label114
-    * op add :n :n 1
+  382 op add :n 11 1
   383 read :t bank1 :tail
   384 read :h bank1 :head
   385 op sub *tmp48 :value :t
 
   396 label *label118
   397 op mul *tmp56 :value :scale
   398 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  399 op sub *tmp58 99 5
+  400 draw line 99 :last 94 :y
+  401 op sub :x 99 5
   402 set :last :y
   403 op max :newMax :newMax :value
   404 label *label119
-    * op add :n :n 1
+  405 op add :n 12 1
   406 read :t bank1 :tail
   407 read :h bank1 :head
   408 op sub *tmp48 :value :t
 
   419 label *label123
   420 op mul *tmp56 :value :scale
   421 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  422 op sub *tmp58 94 5
+  423 draw line 94 :last 89 :y
+  424 op sub :x 94 5
   425 set :last :y
   426 op max :newMax :newMax :value
   427 label *label124
-    * op add :n :n 1
+  428 op add :n 13 1
   429 read :t bank1 :tail
   430 read :h bank1 :head
   431 op sub *tmp48 :value :t
 
   442 label *label128
   443 op mul *tmp56 :value :scale
   444 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  445 op sub *tmp58 89 5
+  446 draw line 89 :last 84 :y
+  447 op sub :x 89 5
   448 set :last :y
   449 op max :newMax :newMax :value
   450 label *label129
-    * op add :n :n 1
+  451 op add :n 14 1
   452 read :t bank1 :tail
   453 read :h bank1 :head
   454 op sub *tmp48 :value :t
 
   465 label *label133
   466 op mul *tmp56 :value :scale
   467 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  468 op sub *tmp58 84 5
+  469 draw line 84 :last 79 :y
+  470 op sub :x 84 5
   471 set :last :y
   472 op max :newMax :newMax :value
   473 label *label134
-    * op add :n :n 1
+  474 op add :n 15 1
   475 read :t bank1 :tail
   476 read :h bank1 :head
   477 op sub *tmp48 :value :t
 
   488 label *label138
   489 op mul *tmp56 :value :scale
   490 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  491 op sub *tmp58 79 5
+  492 draw line 79 :last 74 :y
+  493 op sub :x 79 5
   494 set :last :y
   495 op max :newMax :newMax :value
   496 label *label139
-    * op add :n :n 1
+  497 op add :n 16 1
   498 read :t bank1 :tail
   499 read :h bank1 :head
   500 op sub *tmp48 :value :t
 
   511 label *label143
   512 op mul *tmp56 :value :scale
   513 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  514 op sub *tmp58 74 5
+  515 draw line 74 :last 69 :y
+  516 op sub :x 74 5
   517 set :last :y
   518 op max :newMax :newMax :value
   519 label *label144
-    * op add :n :n 1
+  520 op add :n 17 1
   521 read :t bank1 :tail
   522 read :h bank1 :head
   523 op sub *tmp48 :value :t
 
   534 label *label148
   535 op mul *tmp56 :value :scale
   536 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  537 op sub *tmp58 69 5
+  538 draw line 69 :last 64 :y
+  539 op sub :x 69 5
   540 set :last :y
   541 op max :newMax :newMax :value
   542 label *label149
-    * op add :n :n 1
+  543 op add :n 18 1
   544 read :t bank1 :tail
   545 read :h bank1 :head
   546 op sub *tmp48 :value :t
 
   557 label *label153
   558 op mul *tmp56 :value :scale
   559 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  560 op sub *tmp58 64 5
+  561 draw line 64 :last 59 :y
+  562 op sub :x 64 5
   563 set :last :y
   564 op max :newMax :newMax :value
   565 label *label154
-    * op add :n :n 1
+  566 op add :n 19 1
   567 read :t bank1 :tail
   568 read :h bank1 :head
   569 op sub *tmp48 :value :t
 
   580 label *label158
   581 op mul *tmp56 :value :scale
   582 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  583 op sub *tmp58 59 5
+  584 draw line 59 :last 54 :y
+  585 op sub :x 59 5
   586 set :last :y
   587 op max :newMax :newMax :value
   588 label *label159
-    * op add :n :n 1
+  589 op add :n 20 1
   590 read :t bank1 :tail
   591 read :h bank1 :head
   592 op sub *tmp48 :value :t
 
   603 label *label163
   604 op mul *tmp56 :value :scale
   605 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  606 op sub *tmp58 54 5
+  607 draw line 54 :last 49 :y
+  608 op sub :x 54 5
   609 set :last :y
   610 op max :newMax :newMax :value
   611 label *label164
-    * op add :n :n 1
+  612 op add :n 21 1
   613 read :t bank1 :tail
   614 read :h bank1 :head
   615 op sub *tmp48 :value :t
 
   626 label *label168
   627 op mul *tmp56 :value :scale
   628 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  629 op sub *tmp58 49 5
+  630 draw line 49 :last 44 :y
+  631 op sub :x 49 5
   632 set :last :y
   633 op max :newMax :newMax :value
   634 label *label169
-    * op add :n :n 1
+  635 op add :n 22 1
   636 read :t bank1 :tail
   637 read :h bank1 :head
   638 op sub *tmp48 :value :t
 
   649 label *label173
   650 op mul *tmp56 :value :scale
   651 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  652 op sub *tmp58 44 5
+  653 draw line 44 :last 39 :y
+  654 op sub :x 44 5
   655 set :last :y
   656 op max :newMax :newMax :value
   657 label *label174
-    * op add :n :n 1
+  658 op add :n 23 1
   659 read :t bank1 :tail
   660 read :h bank1 :head
   661 op sub *tmp48 :value :t
 
   672 label *label178
   673 op mul *tmp56 :value :scale
   674 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  675 op sub *tmp58 39 5
+  676 draw line 39 :last 34 :y
+  677 op sub :x 39 5
   678 set :last :y
   679 op max :newMax :newMax :value
   680 label *label179
-    * op add :n :n 1
+  681 op add :n 24 1
   682 read :t bank1 :tail
   683 read :h bank1 :head
   684 op sub *tmp48 :value :t
 
   695 label *label183
   696 op mul *tmp56 :value :scale
   697 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  698 op sub *tmp58 34 5
+  699 draw line 34 :last 29 :y
+  700 op sub :x 34 5
   701 set :last :y
   702 op max :newMax :newMax :value
   703 label *label184
-    * op add :n :n 1
+  704 op add :n 25 1
   705 read :t bank1 :tail
   706 read :h bank1 :head
   707 op sub *tmp48 :value :t
 
   718 label *label188
   719 op mul *tmp56 :value :scale
   720 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  721 op sub *tmp58 29 5
+  722 draw line 29 :last 24 :y
+  723 op sub :x 29 5
   724 set :last :y
   725 op max :newMax :newMax :value
   726 label *label189
-    * op add :n :n 1
+  727 op add :n 26 1
   728 read :t bank1 :tail
   729 read :h bank1 :head
   730 op sub *tmp48 :value :t
 
   741 label *label193
   742 op mul *tmp56 :value :scale
   743 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  744 op sub *tmp58 24 5
+  745 draw line 24 :last 19 :y
+  746 op sub :x 24 5
   747 set :last :y
   748 op max :newMax :newMax :value
   749 label *label194
-    * op add :n :n 1
+  750 op add :n 27 1
   751 read :t bank1 :tail
   752 read :h bank1 :head
   753 op sub *tmp48 :value :t
   754 op add :value *tmp48 :h
   755 op sub :head :head 1
   756 jump *label195 greaterThan :head 256
-    * op sub :head 511 1
   757 label *label195
   758 label *label196
   759 op sub :tail :tail 1
   760 jump *label197 greaterThan :tail 256
-    * op sub :tail 511 1
   761 label *label197
   762 label *label198
   763 op mul *tmp56 :value :scale
   764 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
-    * set :last :y
+  765 op sub *tmp58 19 5
+  766 draw line 19 :last 14 :y
+  767 op sub :x 19 5
   768 op max :newMax :newMax :value
   769 label *label199
-    * op add :n :n 1
+  770 op add :n 28 1
   771 label *label24
   772 draw color 255 255 255 255
   773 draw lineRect 10 10 156 156

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-89 instructions):
 
   100 op add :last 10 *tmp42
   101 set :newMax :value
   102 draw color 80 255 80 255
-    * set :x 159
-    * set :n 0
   103 label *label53
   104 label *label54
   105 read :t bank1 :tail
 
   118 label *label58
   119 op mul *tmp56 :value :scale
   120 op add :y 10 *tmp56
-    * op sub *tmp58 159 5
   121 draw line 159 :last 154 :y
-    * op sub :x 159 5
   122 set :last :y
   123 op max :newMax :newMax :value
   124 label *label59
-    * op add :n 0 1
   125 read :t bank1 :tail
   126 read :h bank1 :head
   127 op sub *tmp48 :value :t
 
   138 label *label63
   139 op mul *tmp56 :value :scale
   140 op add :y 10 *tmp56
-    * op sub *tmp58 154 5
   141 draw line 154 :last 149 :y
-    * op sub :x 154 5
   142 set :last :y
   143 op max :newMax :newMax :value
   144 label *label64
-    * op add :n 1 1
   145 read :t bank1 :tail
   146 read :h bank1 :head
   147 op sub *tmp48 :value :t
 
   158 label *label68
   159 op mul *tmp56 :value :scale
   160 op add :y 10 *tmp56
-    * op sub *tmp58 149 5
   161 draw line 149 :last 144 :y
-    * op sub :x 149 5
   162 set :last :y
   163 op max :newMax :newMax :value
   164 label *label69
-    * op add :n 2 1
   165 read :t bank1 :tail
   166 read :h bank1 :head
   167 op sub *tmp48 :value :t
 
   178 label *label73
   179 op mul *tmp56 :value :scale
   180 op add :y 10 *tmp56
-    * op sub *tmp58 144 5
   181 draw line 144 :last 139 :y
-    * op sub :x 144 5
   182 set :last :y
   183 op max :newMax :newMax :value
   184 label *label74
-    * op add :n 3 1
   185 read :t bank1 :tail
   186 read :h bank1 :head
   187 op sub *tmp48 :value :t
 
   198 label *label78
   199 op mul *tmp56 :value :scale
   200 op add :y 10 *tmp56
-    * op sub *tmp58 139 5
   201 draw line 139 :last 134 :y
-    * op sub :x 139 5
   202 set :last :y
   203 op max :newMax :newMax :value
   204 label *label79
-    * op add :n 4 1
   205 read :t bank1 :tail
   206 read :h bank1 :head
   207 op sub *tmp48 :value :t
 
   218 label *label83
   219 op mul *tmp56 :value :scale
   220 op add :y 10 *tmp56
-    * op sub *tmp58 134 5
   221 draw line 134 :last 129 :y
-    * op sub :x 134 5
   222 set :last :y
   223 op max :newMax :newMax :value
   224 label *label84
-    * op add :n 5 1
   225 read :t bank1 :tail
   226 read :h bank1 :head
   227 op sub *tmp48 :value :t
 
   238 label *label88
   239 op mul *tmp56 :value :scale
   240 op add :y 10 *tmp56
-    * op sub *tmp58 129 5
   241 draw line 129 :last 124 :y
-    * op sub :x 129 5
   242 set :last :y
   243 op max :newMax :newMax :value
   244 label *label89
-    * op add :n 6 1
   245 read :t bank1 :tail
   246 read :h bank1 :head
   247 op sub *tmp48 :value :t
 
   258 label *label93
   259 op mul *tmp56 :value :scale
   260 op add :y 10 *tmp56
-    * op sub *tmp58 124 5
   261 draw line 124 :last 119 :y
-    * op sub :x 124 5
   262 set :last :y
   263 op max :newMax :newMax :value
   264 label *label94
-    * op add :n 7 1
   265 read :t bank1 :tail
   266 read :h bank1 :head
   267 op sub *tmp48 :value :t
 
   278 label *label98
   279 op mul *tmp56 :value :scale
   280 op add :y 10 *tmp56
-    * op sub *tmp58 119 5
   281 draw line 119 :last 114 :y
-    * op sub :x 119 5
   282 set :last :y
   283 op max :newMax :newMax :value
   284 label *label99
-    * op add :n 8 1
   285 read :t bank1 :tail
   286 read :h bank1 :head
   287 op sub *tmp48 :value :t
 
   298 label *label103
   299 op mul *tmp56 :value :scale
   300 op add :y 10 *tmp56
-    * op sub *tmp58 114 5
   301 draw line 114 :last 109 :y
-    * op sub :x 114 5
   302 set :last :y
   303 op max :newMax :newMax :value
   304 label *label104
-    * op add :n 9 1
   305 read :t bank1 :tail
   306 read :h bank1 :head
   307 op sub *tmp48 :value :t
 
   318 label *label108
   319 op mul *tmp56 :value :scale
   320 op add :y 10 *tmp56
-    * op sub *tmp58 109 5
   321 draw line 109 :last 104 :y
-    * op sub :x 109 5
   322 set :last :y
   323 op max :newMax :newMax :value
   324 label *label109
-    * op add :n 10 1
   325 read :t bank1 :tail
   326 read :h bank1 :head
   327 op sub *tmp48 :value :t
 
   338 label *label113
   339 op mul *tmp56 :value :scale
   340 op add :y 10 *tmp56
-    * op sub *tmp58 104 5
   341 draw line 104 :last 99 :y
-    * op sub :x 104 5
   342 set :last :y
   343 op max :newMax :newMax :value
   344 label *label114
-    * op add :n 11 1
   345 read :t bank1 :tail
   346 read :h bank1 :head
   347 op sub *tmp48 :value :t
 
   358 label *label118
   359 op mul *tmp56 :value :scale
   360 op add :y 10 *tmp56
-    * op sub *tmp58 99 5
   361 draw line 99 :last 94 :y
-    * op sub :x 99 5
   362 set :last :y
   363 op max :newMax :newMax :value
   364 label *label119
-    * op add :n 12 1
   365 read :t bank1 :tail
   366 read :h bank1 :head
   367 op sub *tmp48 :value :t
 
   378 label *label123
   379 op mul *tmp56 :value :scale
   380 op add :y 10 *tmp56
-    * op sub *tmp58 94 5
   381 draw line 94 :last 89 :y
-    * op sub :x 94 5
   382 set :last :y
   383 op max :newMax :newMax :value
   384 label *label124
-    * op add :n 13 1
   385 read :t bank1 :tail
   386 read :h bank1 :head
   387 op sub *tmp48 :value :t
 
   398 label *label128
   399 op mul *tmp56 :value :scale
   400 op add :y 10 *tmp56
-    * op sub *tmp58 89 5
   401 draw line 89 :last 84 :y
-    * op sub :x 89 5
   402 set :last :y
   403 op max :newMax :newMax :value
   404 label *label129
-    * op add :n 14 1
   405 read :t bank1 :tail
   406 read :h bank1 :head
   407 op sub *tmp48 :value :t
 
   418 label *label133
   419 op mul *tmp56 :value :scale
   420 op add :y 10 *tmp56
-    * op sub *tmp58 84 5
   421 draw line 84 :last 79 :y
-    * op sub :x 84 5
   422 set :last :y
   423 op max :newMax :newMax :value
   424 label *label134
-    * op add :n 15 1
   425 read :t bank1 :tail
   426 read :h bank1 :head
   427 op sub *tmp48 :value :t
 
   438 label *label138
   439 op mul *tmp56 :value :scale
   440 op add :y 10 *tmp56
-    * op sub *tmp58 79 5
   441 draw line 79 :last 74 :y
-    * op sub :x 79 5
   442 set :last :y
   443 op max :newMax :newMax :value
   444 label *label139
-    * op add :n 16 1
   445 read :t bank1 :tail
   446 read :h bank1 :head
   447 op sub *tmp48 :value :t
 
   458 label *label143
   459 op mul *tmp56 :value :scale
   460 op add :y 10 *tmp56
-    * op sub *tmp58 74 5
   461 draw line 74 :last 69 :y
-    * op sub :x 74 5
   462 set :last :y
   463 op max :newMax :newMax :value
   464 label *label144
-    * op add :n 17 1
   465 read :t bank1 :tail
   466 read :h bank1 :head
   467 op sub *tmp48 :value :t
 
   478 label *label148
   479 op mul *tmp56 :value :scale
   480 op add :y 10 *tmp56
-    * op sub *tmp58 69 5
   481 draw line 69 :last 64 :y
-    * op sub :x 69 5
   482 set :last :y
   483 op max :newMax :newMax :value
   484 label *label149
-    * op add :n 18 1
   485 read :t bank1 :tail
   486 read :h bank1 :head
   487 op sub *tmp48 :value :t
 
   498 label *label153
   499 op mul *tmp56 :value :scale
   500 op add :y 10 *tmp56
-    * op sub *tmp58 64 5
   501 draw line 64 :last 59 :y
-    * op sub :x 64 5
   502 set :last :y
   503 op max :newMax :newMax :value
   504 label *label154
-    * op add :n 19 1
   505 read :t bank1 :tail
   506 read :h bank1 :head
   507 op sub *tmp48 :value :t
 
   518 label *label158
   519 op mul *tmp56 :value :scale
   520 op add :y 10 *tmp56
-    * op sub *tmp58 59 5
   521 draw line 59 :last 54 :y
-    * op sub :x 59 5
   522 set :last :y
   523 op max :newMax :newMax :value
   524 label *label159
-    * op add :n 20 1
   525 read :t bank1 :tail
   526 read :h bank1 :head
   527 op sub *tmp48 :value :t
 
   538 label *label163
   539 op mul *tmp56 :value :scale
   540 op add :y 10 *tmp56
-    * op sub *tmp58 54 5
   541 draw line 54 :last 49 :y
-    * op sub :x 54 5
   542 set :last :y
   543 op max :newMax :newMax :value
   544 label *label164
-    * op add :n 21 1
   545 read :t bank1 :tail
   546 read :h bank1 :head
   547 op sub *tmp48 :value :t
 
   558 label *label168
   559 op mul *tmp56 :value :scale
   560 op add :y 10 *tmp56
-    * op sub *tmp58 49 5
   561 draw line 49 :last 44 :y
-    * op sub :x 49 5
   562 set :last :y
   563 op max :newMax :newMax :value
   564 label *label169
-    * op add :n 22 1
   565 read :t bank1 :tail
   566 read :h bank1 :head
   567 op sub *tmp48 :value :t
 
   578 label *label173
   579 op mul *tmp56 :value :scale
   580 op add :y 10 *tmp56
-    * op sub *tmp58 44 5
   581 draw line 44 :last 39 :y
-    * op sub :x 44 5
   582 set :last :y
   583 op max :newMax :newMax :value
   584 label *label174
-    * op add :n 23 1
   585 read :t bank1 :tail
   586 read :h bank1 :head
   587 op sub *tmp48 :value :t
 
   598 label *label178
   599 op mul *tmp56 :value :scale
   600 op add :y 10 *tmp56
-    * op sub *tmp58 39 5
   601 draw line 39 :last 34 :y
-    * op sub :x 39 5
   602 set :last :y
   603 op max :newMax :newMax :value
   604 label *label179
-    * op add :n 24 1
   605 read :t bank1 :tail
   606 read :h bank1 :head
   607 op sub *tmp48 :value :t
 
   618 label *label183
   619 op mul *tmp56 :value :scale
   620 op add :y 10 *tmp56
-    * op sub *tmp58 34 5
   621 draw line 34 :last 29 :y
-    * op sub :x 34 5
   622 set :last :y
   623 op max :newMax :newMax :value
   624 label *label184
-    * op add :n 25 1
   625 read :t bank1 :tail
   626 read :h bank1 :head
   627 op sub *tmp48 :value :t
 
   638 label *label188
   639 op mul *tmp56 :value :scale
   640 op add :y 10 *tmp56
-    * op sub *tmp58 29 5
   641 draw line 29 :last 24 :y
-    * op sub :x 29 5
   642 set :last :y
   643 op max :newMax :newMax :value
   644 label *label189
-    * op add :n 26 1
   645 read :t bank1 :tail
   646 read :h bank1 :head
   647 op sub *tmp48 :value :t
 
   658 label *label193
   659 op mul *tmp56 :value :scale
   660 op add :y 10 *tmp56
-    * op sub *tmp58 24 5
   661 draw line 24 :last 19 :y
-    * op sub :x 24 5
   662 set :last :y
   663 op max :newMax :newMax :value
   664 label *label194
-    * op add :n 27 1
   665 read :t bank1 :tail
   666 read :h bank1 :head
   667 op sub *tmp48 :value :t
 
   676 label *label198
   677 op mul *tmp56 :value :scale
   678 op add :y 10 *tmp56
-    * op sub *tmp58 19 5
   679 draw line 19 :last 14 :y
-    * op sub :x 19 5
   680 op max :newMax :newMax :value
   681 label *label199
-    * op add :n 28 1
   682 label *label24
   683 draw color 255 255 255 255
   684 draw lineRect 10 10 156 156

Modifications by Partial loop rotation at line 32:1 (+1 instructions):
 
    29 label *label7
    30 sensor *tmp18 switch1 @enabled
    31 jump *label9 notEqual *tmp18 0
+   32 label *label200
    33 print "Item Rate Display"
    34 set :start @time
    35 sensor *tmp21 cell1 @dead
 
   713 print :loops
   714 printflush message1
   715 label *label8
-    * jump *label7 always
+  716 sensor *tmp18 switch1 @enabled
+  717 jump *label200 equal *tmp18 0
   718 label *label9
   719 control enabled switch1 0
   720 end

Modifications by Unroll loop at line 24:1 (+167 instructions):
 
    11 label *label0
    12 label *label1
    13 read :maximum bank1 :ptr
-    * set :n 0
-    * label *label2
-    * label *label34
-    * op sub :ptr :ptr 1
-    * jump *label5 greaterThan :ptr 256
-    * op sub :ptr 511 1
-    * label *label5
-    * label *label6
-    * read *tmp15 bank1 :ptr
-    * op max :maximum :maximum *tmp15
-    * label *label3
-    * op add :n :n 1
-    * jump *label34 lessThan :n 29
-    * label *label4
+   14 set :n 0
+   15 label *label201
+   16 label *label202
+   17 op sub :ptr :ptr 1
+   18 jump *label203 greaterThan :ptr 256
+   19 op sub :ptr 511 1
+   20 label *label203
+   21 label *label204
+   22 read *tmp15 bank1 :ptr
+   23 op max :maximum :maximum *tmp15
+   24 label *label205
+   25 op add :n :n 1
+   26 op sub :ptr :ptr 1
+   27 jump *label206 greaterThan :ptr 256
+   28 op sub :ptr 511 1
+   29 label *label206
+   30 label *label207
+   31 read *tmp15 bank1 :ptr
+   32 op max :maximum :maximum *tmp15
+   33 label *label208
+   34 op add :n :n 1
+   35 op sub :ptr :ptr 1
+   36 jump *label209 greaterThan :ptr 256
+   37 op sub :ptr 511 1
+   38 label *label209
+   39 label *label210
+   40 read *tmp15 bank1 :ptr
+   41 op max :maximum :maximum *tmp15
+   42 label *label211
+   43 op add :n :n 1
+   44 op sub :ptr :ptr 1
+   45 jump *label212 greaterThan :ptr 256
+   46 op sub :ptr 511 1
+   47 label *label212
+   48 label *label213
+   49 read *tmp15 bank1 :ptr
+   50 op max :maximum :maximum *tmp15
+   51 label *label214
+   52 op add :n :n 1
+   53 op sub :ptr :ptr 1
+   54 jump *label215 greaterThan :ptr 256
+   55 op sub :ptr 511 1
+   56 label *label215
+   57 label *label216
+   58 read *tmp15 bank1 :ptr
+   59 op max :maximum :maximum *tmp15
+   60 label *label217
+   61 op add :n :n 1
+   62 op sub :ptr :ptr 1
+   63 jump *label218 greaterThan :ptr 256
+   64 op sub :ptr 511 1
+   65 label *label218
+   66 label *label219
+   67 read *tmp15 bank1 :ptr
+   68 op max :maximum :maximum *tmp15
+   69 label *label220
+   70 op add :n :n 1
+   71 op sub :ptr :ptr 1
+   72 jump *label221 greaterThan :ptr 256
+   73 op sub :ptr 511 1
+   74 label *label221
+   75 label *label222
+   76 read *tmp15 bank1 :ptr
+   77 op max :maximum :maximum *tmp15
+   78 label *label223
+   79 op add :n :n 1
+   80 op sub :ptr :ptr 1
+   81 jump *label224 greaterThan :ptr 256
+   82 op sub :ptr 511 1
+   83 label *label224
+   84 label *label225
+   85 read *tmp15 bank1 :ptr
+   86 op max :maximum :maximum *tmp15
+   87 label *label226
+   88 op add :n :n 1
+   89 op sub :ptr :ptr 1
+   90 jump *label227 greaterThan :ptr 256
+   91 op sub :ptr 511 1
+   92 label *label227
+   93 label *label228
+   94 read *tmp15 bank1 :ptr
+   95 op max :maximum :maximum *tmp15
+   96 label *label229
+   97 op add :n :n 1
+   98 op sub :ptr :ptr 1
+   99 jump *label230 greaterThan :ptr 256
+  100 op sub :ptr 511 1
+  101 label *label230
+  102 label *label231
+  103 read *tmp15 bank1 :ptr
+  104 op max :maximum :maximum *tmp15
+  105 label *label232
+  106 op add :n :n 1
+  107 op sub :ptr :ptr 1
+  108 jump *label233 greaterThan :ptr 256
+  109 op sub :ptr 511 1
+  110 label *label233
+  111 label *label234
+  112 read *tmp15 bank1 :ptr
+  113 op max :maximum :maximum *tmp15
+  114 label *label235
+  115 op add :n :n 1
+  116 op sub :ptr :ptr 1
+  117 jump *label236 greaterThan :ptr 256
+  118 op sub :ptr 511 1
+  119 label *label236
+  120 label *label237
+  121 read *tmp15 bank1 :ptr
+  122 op max :maximum :maximum *tmp15
+  123 label *label238
+  124 op add :n :n 1
+  125 op sub :ptr :ptr 1
+  126 jump *label239 greaterThan :ptr 256
+  127 op sub :ptr 511 1
+  128 label *label239
+  129 label *label240
+  130 read *tmp15 bank1 :ptr
+  131 op max :maximum :maximum *tmp15
+  132 label *label241
+  133 op add :n :n 1
+  134 op sub :ptr :ptr 1
+  135 jump *label242 greaterThan :ptr 256
+  136 op sub :ptr 511 1
+  137 label *label242
+  138 label *label243
+  139 read *tmp15 bank1 :ptr
+  140 op max :maximum :maximum *tmp15
+  141 label *label244
+  142 op add :n :n 1
+  143 op sub :ptr :ptr 1
+  144 jump *label245 greaterThan :ptr 256
+  145 op sub :ptr 511 1
+  146 label *label245
+  147 label *label246
+  148 read *tmp15 bank1 :ptr
+  149 op max :maximum :maximum *tmp15
+  150 label *label247
+  151 op add :n :n 1
+  152 op sub :ptr :ptr 1
+  153 jump *label248 greaterThan :ptr 256
+  154 op sub :ptr 511 1
+  155 label *label248
+  156 label *label249
+  157 read *tmp15 bank1 :ptr
+  158 op max :maximum :maximum *tmp15
+  159 label *label250
+  160 op add :n :n 1
+  161 op sub :ptr :ptr 1
+  162 jump *label251 greaterThan :ptr 256
+  163 op sub :ptr 511 1
+  164 label *label251
+  165 label *label252
+  166 read *tmp15 bank1 :ptr
+  167 op max :maximum :maximum *tmp15
+  168 label *label253
+  169 op add :n :n 1
+  170 op sub :ptr :ptr 1
+  171 jump *label254 greaterThan :ptr 256
+  172 op sub :ptr 511 1
+  173 label *label254
+  174 label *label255
+  175 read *tmp15 bank1 :ptr
+  176 op max :maximum :maximum *tmp15
+  177 label *label256
+  178 op add :n :n 1
+  179 op sub :ptr :ptr 1
+  180 jump *label257 greaterThan :ptr 256
+  181 op sub :ptr 511 1
+  182 label *label257
+  183 label *label258
+  184 read *tmp15 bank1 :ptr
+  185 op max :maximum :maximum *tmp15
+  186 label *label259
+  187 op add :n :n 1
+  188 op sub :ptr :ptr 1
+  189 jump *label260 greaterThan :ptr 256
+  190 op sub :ptr 511 1
+  191 label *label260
+  192 label *label261
+  193 read *tmp15 bank1 :ptr
+  194 op max :maximum :maximum *tmp15
+  195 label *label262
+  196 op add :n :n 1
+  197 op sub :ptr :ptr 1
+  198 jump *label263 greaterThan :ptr 256
+  199 op sub :ptr 511 1
+  200 label *label263
+  201 label *label264
+  202 read *tmp15 bank1 :ptr
+  203 op max :maximum :maximum *tmp15
+  204 label *label265
+  205 op add :n :n 1
+  206 op sub :ptr :ptr 1
+  207 jump *label266 greaterThan :ptr 256
+  208 op sub :ptr 511 1
+  209 label *label266
+  210 label *label267
+  211 read *tmp15 bank1 :ptr
+  212 op max :maximum :maximum *tmp15
+  213 label *label268
+  214 op add :n :n 1
+  215 op sub :ptr :ptr 1
+  216 jump *label269 greaterThan :ptr 256
+  217 op sub :ptr 511 1
+  218 label *label269
+  219 label *label270
+  220 read *tmp15 bank1 :ptr
+  221 op max :maximum :maximum *tmp15
+  222 label *label271
+  223 op add :n :n 1
+  224 op sub :ptr :ptr 1
+  225 jump *label272 greaterThan :ptr 256
+  226 op sub :ptr 511 1
+  227 label *label272
+  228 label *label273
+  229 read *tmp15 bank1 :ptr
+  230 op max :maximum :maximum *tmp15
+  231 label *label274
+  232 op add :n :n 1
+  233 op sub :ptr :ptr 1
+  234 jump *label275 greaterThan :ptr 256
+  235 op sub :ptr 511 1
+  236 label *label275
+  237 label *label276
+  238 read *tmp15 bank1 :ptr
+  239 op max :maximum :maximum *tmp15
+  240 label *label277
+  241 op add :n :n 1
+  242 op sub :ptr :ptr 1
+  243 jump *label278 greaterThan :ptr 256
+  244 op sub :ptr 511 1
+  245 label *label278
+  246 label *label279
+  247 read *tmp15 bank1 :ptr
+  248 op max :maximum :maximum *tmp15
+  249 label *label280
+  250 op add :n :n 1
+  251 op sub :ptr :ptr 1
+  252 jump *label281 greaterThan :ptr 256
+  253 op sub :ptr 511 1
+  254 label *label281
+  255 label *label282
+  256 read *tmp15 bank1 :ptr
+  257 op max :maximum :maximum *tmp15
+  258 label *label283
+  259 op add :n :n 1
+  260 op sub :ptr :ptr 1
+  261 jump *label284 greaterThan :ptr 256
+  262 op sub :ptr 511 1
+  263 label *label284
+  264 label *label285
+  265 read *tmp15 bank1 :ptr
+  266 op max :maximum :maximum *tmp15
+  267 label *label286
+  268 op add :n :n 1
+  269 op sub :ptr :ptr 1
+  270 jump *label287 greaterThan :ptr 256
+  271 op sub :ptr 511 1
+  272 label *label287
+  273 label *label288
+  274 read *tmp15 bank1 :ptr
+  275 op max :maximum :maximum *tmp15
+  276 label *label289
+  277 op add :n :n 1
+  278 label *label4
   279 op mul :maximum :maximum 3
   280 label *label7
   281 sensor *tmp18 switch1 @enabled

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    22 read *tmp15 bank1 :ptr
    23 op max :maximum :maximum *tmp15
    24 label *label205
-    * op add :n :n 1
+   25 op add :n 0 1
    26 op sub :ptr :ptr 1
    27 jump *label206 greaterThan :ptr 256
    28 op sub :ptr 511 1
 
    31 read *tmp15 bank1 :ptr
    32 op max :maximum :maximum *tmp15
    33 label *label208
-    * op add :n :n 1
+   34 op add :n 1 1
    35 op sub :ptr :ptr 1
    36 jump *label209 greaterThan :ptr 256
    37 op sub :ptr 511 1
 
    40 read *tmp15 bank1 :ptr
    41 op max :maximum :maximum *tmp15
    42 label *label211
-    * op add :n :n 1
+   43 op add :n 2 1
    44 op sub :ptr :ptr 1
    45 jump *label212 greaterThan :ptr 256
    46 op sub :ptr 511 1
 
    49 read *tmp15 bank1 :ptr
    50 op max :maximum :maximum *tmp15
    51 label *label214
-    * op add :n :n 1
+   52 op add :n 3 1
    53 op sub :ptr :ptr 1
    54 jump *label215 greaterThan :ptr 256
    55 op sub :ptr 511 1
 
    58 read *tmp15 bank1 :ptr
    59 op max :maximum :maximum *tmp15
    60 label *label217
-    * op add :n :n 1
+   61 op add :n 4 1
    62 op sub :ptr :ptr 1
    63 jump *label218 greaterThan :ptr 256
    64 op sub :ptr 511 1
 
    67 read *tmp15 bank1 :ptr
    68 op max :maximum :maximum *tmp15
    69 label *label220
-    * op add :n :n 1
+   70 op add :n 5 1
    71 op sub :ptr :ptr 1
    72 jump *label221 greaterThan :ptr 256
    73 op sub :ptr 511 1
 
    76 read *tmp15 bank1 :ptr
    77 op max :maximum :maximum *tmp15
    78 label *label223
-    * op add :n :n 1
+   79 op add :n 6 1
    80 op sub :ptr :ptr 1
    81 jump *label224 greaterThan :ptr 256
    82 op sub :ptr 511 1
 
    85 read *tmp15 bank1 :ptr
    86 op max :maximum :maximum *tmp15
    87 label *label226
-    * op add :n :n 1
+   88 op add :n 7 1
    89 op sub :ptr :ptr 1
    90 jump *label227 greaterThan :ptr 256
    91 op sub :ptr 511 1
 
    94 read *tmp15 bank1 :ptr
    95 op max :maximum :maximum *tmp15
    96 label *label229
-    * op add :n :n 1
+   97 op add :n 8 1
    98 op sub :ptr :ptr 1
    99 jump *label230 greaterThan :ptr 256
   100 op sub :ptr 511 1
 
   103 read *tmp15 bank1 :ptr
   104 op max :maximum :maximum *tmp15
   105 label *label232
-    * op add :n :n 1
+  106 op add :n 9 1
   107 op sub :ptr :ptr 1
   108 jump *label233 greaterThan :ptr 256
   109 op sub :ptr 511 1
 
   112 read *tmp15 bank1 :ptr
   113 op max :maximum :maximum *tmp15
   114 label *label235
-    * op add :n :n 1
+  115 op add :n 10 1
   116 op sub :ptr :ptr 1
   117 jump *label236 greaterThan :ptr 256
   118 op sub :ptr 511 1
 
   121 read *tmp15 bank1 :ptr
   122 op max :maximum :maximum *tmp15
   123 label *label238
-    * op add :n :n 1
+  124 op add :n 11 1
   125 op sub :ptr :ptr 1
   126 jump *label239 greaterThan :ptr 256
   127 op sub :ptr 511 1
 
   130 read *tmp15 bank1 :ptr
   131 op max :maximum :maximum *tmp15
   132 label *label241
-    * op add :n :n 1
+  133 op add :n 12 1
   134 op sub :ptr :ptr 1
   135 jump *label242 greaterThan :ptr 256
   136 op sub :ptr 511 1
 
   139 read *tmp15 bank1 :ptr
   140 op max :maximum :maximum *tmp15
   141 label *label244
-    * op add :n :n 1
+  142 op add :n 13 1
   143 op sub :ptr :ptr 1
   144 jump *label245 greaterThan :ptr 256
   145 op sub :ptr 511 1
 
   148 read *tmp15 bank1 :ptr
   149 op max :maximum :maximum *tmp15
   150 label *label247
-    * op add :n :n 1
+  151 op add :n 14 1
   152 op sub :ptr :ptr 1
   153 jump *label248 greaterThan :ptr 256
   154 op sub :ptr 511 1
 
   157 read *tmp15 bank1 :ptr
   158 op max :maximum :maximum *tmp15
   159 label *label250
-    * op add :n :n 1
+  160 op add :n 15 1
   161 op sub :ptr :ptr 1
   162 jump *label251 greaterThan :ptr 256
   163 op sub :ptr 511 1
 
   166 read *tmp15 bank1 :ptr
   167 op max :maximum :maximum *tmp15
   168 label *label253
-    * op add :n :n 1
+  169 op add :n 16 1
   170 op sub :ptr :ptr 1
   171 jump *label254 greaterThan :ptr 256
   172 op sub :ptr 511 1
 
   175 read *tmp15 bank1 :ptr
   176 op max :maximum :maximum *tmp15
   177 label *label256
-    * op add :n :n 1
+  178 op add :n 17 1
   179 op sub :ptr :ptr 1
   180 jump *label257 greaterThan :ptr 256
   181 op sub :ptr 511 1
 
   184 read *tmp15 bank1 :ptr
   185 op max :maximum :maximum *tmp15
   186 label *label259
-    * op add :n :n 1
+  187 op add :n 18 1
   188 op sub :ptr :ptr 1
   189 jump *label260 greaterThan :ptr 256
   190 op sub :ptr 511 1
 
   193 read *tmp15 bank1 :ptr
   194 op max :maximum :maximum *tmp15
   195 label *label262
-    * op add :n :n 1
+  196 op add :n 19 1
   197 op sub :ptr :ptr 1
   198 jump *label263 greaterThan :ptr 256
   199 op sub :ptr 511 1
 
   202 read *tmp15 bank1 :ptr
   203 op max :maximum :maximum *tmp15
   204 label *label265
-    * op add :n :n 1
+  205 op add :n 20 1
   206 op sub :ptr :ptr 1
   207 jump *label266 greaterThan :ptr 256
   208 op sub :ptr 511 1
 
   211 read *tmp15 bank1 :ptr
   212 op max :maximum :maximum *tmp15
   213 label *label268
-    * op add :n :n 1
+  214 op add :n 21 1
   215 op sub :ptr :ptr 1
   216 jump *label269 greaterThan :ptr 256
   217 op sub :ptr 511 1
 
   220 read *tmp15 bank1 :ptr
   221 op max :maximum :maximum *tmp15
   222 label *label271
-    * op add :n :n 1
+  223 op add :n 22 1
   224 op sub :ptr :ptr 1
   225 jump *label272 greaterThan :ptr 256
   226 op sub :ptr 511 1
 
   229 read *tmp15 bank1 :ptr
   230 op max :maximum :maximum *tmp15
   231 label *label274
-    * op add :n :n 1
+  232 op add :n 23 1
   233 op sub :ptr :ptr 1
   234 jump *label275 greaterThan :ptr 256
   235 op sub :ptr 511 1
 
   238 read *tmp15 bank1 :ptr
   239 op max :maximum :maximum *tmp15
   240 label *label277
-    * op add :n :n 1
+  241 op add :n 24 1
   242 op sub :ptr :ptr 1
   243 jump *label278 greaterThan :ptr 256
   244 op sub :ptr 511 1
 
   247 read *tmp15 bank1 :ptr
   248 op max :maximum :maximum *tmp15
   249 label *label280
-    * op add :n :n 1
+  250 op add :n 25 1
   251 op sub :ptr :ptr 1
   252 jump *label281 greaterThan :ptr 256
   253 op sub :ptr 511 1
 
   256 read *tmp15 bank1 :ptr
   257 op max :maximum :maximum *tmp15
   258 label *label283
-    * op add :n :n 1
+  259 op add :n 26 1
   260 op sub :ptr :ptr 1
   261 jump *label284 greaterThan :ptr 256
   262 op sub :ptr 511 1
 
   265 read *tmp15 bank1 :ptr
   266 op max :maximum :maximum *tmp15
   267 label *label286
-    * op add :n :n 1
+  268 op add :n 27 1
   269 op sub :ptr :ptr 1
   270 jump *label287 greaterThan :ptr 256
   271 op sub :ptr 511 1
 
   274 read *tmp15 bank1 :ptr
   275 op max :maximum :maximum *tmp15
   276 label *label289
-    * op add :n :n 1
+  277 op add :n 28 1
   278 label *label4
   279 op mul :maximum :maximum 3
   280 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-30 instructions):
 
    11 label *label0
    12 label *label1
    13 read :maximum bank1 :ptr
-    * set :n 0
    14 label *label201
    15 label *label202
    16 op sub :ptr :ptr 1
 
    21 read *tmp15 bank1 :ptr
    22 op max :maximum :maximum *tmp15
    23 label *label205
-    * op add :n 0 1
    24 op sub :ptr :ptr 1
    25 jump *label206 greaterThan :ptr 256
    26 op sub :ptr 511 1
 
    29 read *tmp15 bank1 :ptr
    30 op max :maximum :maximum *tmp15
    31 label *label208
-    * op add :n 1 1
    32 op sub :ptr :ptr 1
    33 jump *label209 greaterThan :ptr 256
    34 op sub :ptr 511 1
 
    37 read *tmp15 bank1 :ptr
    38 op max :maximum :maximum *tmp15
    39 label *label211
-    * op add :n 2 1
    40 op sub :ptr :ptr 1
    41 jump *label212 greaterThan :ptr 256
    42 op sub :ptr 511 1
 
    45 read *tmp15 bank1 :ptr
    46 op max :maximum :maximum *tmp15
    47 label *label214
-    * op add :n 3 1
    48 op sub :ptr :ptr 1
    49 jump *label215 greaterThan :ptr 256
    50 op sub :ptr 511 1
 
    53 read *tmp15 bank1 :ptr
    54 op max :maximum :maximum *tmp15
    55 label *label217
-    * op add :n 4 1
    56 op sub :ptr :ptr 1
    57 jump *label218 greaterThan :ptr 256
    58 op sub :ptr 511 1
 
    61 read *tmp15 bank1 :ptr
    62 op max :maximum :maximum *tmp15
    63 label *label220
-    * op add :n 5 1
    64 op sub :ptr :ptr 1
    65 jump *label221 greaterThan :ptr 256
    66 op sub :ptr 511 1
 
    69 read *tmp15 bank1 :ptr
    70 op max :maximum :maximum *tmp15
    71 label *label223
-    * op add :n 6 1
    72 op sub :ptr :ptr 1
    73 jump *label224 greaterThan :ptr 256
    74 op sub :ptr 511 1
 
    77 read *tmp15 bank1 :ptr
    78 op max :maximum :maximum *tmp15
    79 label *label226
-    * op add :n 7 1
    80 op sub :ptr :ptr 1
    81 jump *label227 greaterThan :ptr 256
    82 op sub :ptr 511 1
 
    85 read *tmp15 bank1 :ptr
    86 op max :maximum :maximum *tmp15
    87 label *label229
-    * op add :n 8 1
    88 op sub :ptr :ptr 1
    89 jump *label230 greaterThan :ptr 256
    90 op sub :ptr 511 1
 
    93 read *tmp15 bank1 :ptr
    94 op max :maximum :maximum *tmp15
    95 label *label232
-    * op add :n 9 1
    96 op sub :ptr :ptr 1
    97 jump *label233 greaterThan :ptr 256
    98 op sub :ptr 511 1
 
   101 read *tmp15 bank1 :ptr
   102 op max :maximum :maximum *tmp15
   103 label *label235
-    * op add :n 10 1
   104 op sub :ptr :ptr 1
   105 jump *label236 greaterThan :ptr 256
   106 op sub :ptr 511 1
 
   109 read *tmp15 bank1 :ptr
   110 op max :maximum :maximum *tmp15
   111 label *label238
-    * op add :n 11 1
   112 op sub :ptr :ptr 1
   113 jump *label239 greaterThan :ptr 256
   114 op sub :ptr 511 1
 
   117 read *tmp15 bank1 :ptr
   118 op max :maximum :maximum *tmp15
   119 label *label241
-    * op add :n 12 1
   120 op sub :ptr :ptr 1
   121 jump *label242 greaterThan :ptr 256
   122 op sub :ptr 511 1
 
   125 read *tmp15 bank1 :ptr
   126 op max :maximum :maximum *tmp15
   127 label *label244
-    * op add :n 13 1
   128 op sub :ptr :ptr 1
   129 jump *label245 greaterThan :ptr 256
   130 op sub :ptr 511 1
 
   133 read *tmp15 bank1 :ptr
   134 op max :maximum :maximum *tmp15
   135 label *label247
-    * op add :n 14 1
   136 op sub :ptr :ptr 1
   137 jump *label248 greaterThan :ptr 256
   138 op sub :ptr 511 1
 
   141 read *tmp15 bank1 :ptr
   142 op max :maximum :maximum *tmp15
   143 label *label250
-    * op add :n 15 1
   144 op sub :ptr :ptr 1
   145 jump *label251 greaterThan :ptr 256
   146 op sub :ptr 511 1
 
   149 read *tmp15 bank1 :ptr
   150 op max :maximum :maximum *tmp15
   151 label *label253
-    * op add :n 16 1
   152 op sub :ptr :ptr 1
   153 jump *label254 greaterThan :ptr 256
   154 op sub :ptr 511 1
 
   157 read *tmp15 bank1 :ptr
   158 op max :maximum :maximum *tmp15
   159 label *label256
-    * op add :n 17 1
   160 op sub :ptr :ptr 1
   161 jump *label257 greaterThan :ptr 256
   162 op sub :ptr 511 1
 
   165 read *tmp15 bank1 :ptr
   166 op max :maximum :maximum *tmp15
   167 label *label259
-    * op add :n 18 1
   168 op sub :ptr :ptr 1
   169 jump *label260 greaterThan :ptr 256
   170 op sub :ptr 511 1
 
   173 read *tmp15 bank1 :ptr
   174 op max :maximum :maximum *tmp15
   175 label *label262
-    * op add :n 19 1
   176 op sub :ptr :ptr 1
   177 jump *label263 greaterThan :ptr 256
   178 op sub :ptr 511 1
 
   181 read *tmp15 bank1 :ptr
   182 op max :maximum :maximum *tmp15
   183 label *label265
-    * op add :n 20 1
   184 op sub :ptr :ptr 1
   185 jump *label266 greaterThan :ptr 256
   186 op sub :ptr 511 1
 
   189 read *tmp15 bank1 :ptr
   190 op max :maximum :maximum *tmp15
   191 label *label268
-    * op add :n 21 1
   192 op sub :ptr :ptr 1
   193 jump *label269 greaterThan :ptr 256
   194 op sub :ptr 511 1
 
   197 read *tmp15 bank1 :ptr
   198 op max :maximum :maximum *tmp15
   199 label *label271
-    * op add :n 22 1
   200 op sub :ptr :ptr 1
   201 jump *label272 greaterThan :ptr 256
   202 op sub :ptr 511 1
 
   205 read *tmp15 bank1 :ptr
   206 op max :maximum :maximum *tmp15
   207 label *label274
-    * op add :n 23 1
   208 op sub :ptr :ptr 1
   209 jump *label275 greaterThan :ptr 256
   210 op sub :ptr 511 1
 
   213 read *tmp15 bank1 :ptr
   214 op max :maximum :maximum *tmp15
   215 label *label277
-    * op add :n 24 1
   216 op sub :ptr :ptr 1
   217 jump *label278 greaterThan :ptr 256
   218 op sub :ptr 511 1
 
   221 read *tmp15 bank1 :ptr
   222 op max :maximum :maximum *tmp15
   223 label *label280
-    * op add :n 25 1
   224 op sub :ptr :ptr 1
   225 jump *label281 greaterThan :ptr 256
   226 op sub :ptr 511 1
 
   229 read *tmp15 bank1 :ptr
   230 op max :maximum :maximum *tmp15
   231 label *label283
-    * op add :n 26 1
   232 op sub :ptr :ptr 1
   233 jump *label284 greaterThan :ptr 256
   234 op sub :ptr 511 1
 
   237 read *tmp15 bank1 :ptr
   238 op max :maximum :maximum *tmp15
   239 label *label286
-    * op add :n 27 1
   240 op sub :ptr :ptr 1
   241 jump *label287 greaterThan :ptr 256
   242 op sub :ptr 511 1
 
   245 read *tmp15 bank1 :ptr
   246 op max :maximum :maximum *tmp15
   247 label *label289
-    * op add :n 28 1
   248 label *label4
   249 op mul :maximum :maximum 3
   250 label *label7

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1:
 
     6 draw stroke 1
     7 read *tmp4 bank1 256
     8 op sub :ptr *tmp4 0
-    * jump *label0 greaterThanEq :ptr 256
+    9 jump *label0 greaterThanEq *tmp4 256
    10 op add :ptr *tmp4 254
    11 label *label0
    12 label *label1
 
   286 draw rect 10 10 156 156
   287 read *tmp32 bank1 256
   288 op sub :head *tmp32 0
-    * jump *label15 greaterThanEq :head 256
+  289 jump *label15 greaterThanEq *tmp32 256
   290 op add :head *tmp32 254
   291 label *label15
   292 label *label16

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   889 op sub *tmp48 :value :t
   890 op add :value *tmp48 :h
   891 op sub :head :head 1
-    * jump *label195 greaterThan :head 256
   892 label *label195
   893 label *label196
   894 op sub :tail :tail 1
-    * jump *label197 greaterThan :tail 256
   895 label *label197
   896 label *label198
   897 op mul *tmp56 :value :scale

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
     5 printflush message1
     6 draw stroke 1
     7 read *tmp4 bank1 256
-    * op sub :ptr *tmp4 0
+    8 set :ptr *tmp4
     9 jump *label0 greaterThanEq *tmp4 256
    10 op add :ptr *tmp4 254
    11 label *label0
 
   285 draw color 0 80 0 255
   286 draw rect 10 10 156 156
   287 read *tmp32 bank1 256
-    * op sub :head *tmp32 0
+  288 set :head *tmp32
   289 jump *label15 greaterThanEq *tmp32 256
   290 op add :head *tmp32 254
   291 label *label15
 
   294 label *label42
   295 label *label43
   296 read *tmp38 bank1 :head
-    * op add :value 0 *tmp38
+  297 set :value *tmp38
   298 op sub :head :head 1
   299 jump *label44 greaterThan :head 256
   300 op sub :head 511 1

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-2 instructions):
 
   888 read :h bank1 :head
   889 op sub *tmp48 :value :t
   890 op add :value *tmp48 :h
-    * op sub :head :head 1
   891 label *label195
   892 label *label196
-    * op sub :tail :tail 1
   893 label *label197
   894 label *label198
   895 op mul *tmp56 :value :scale

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   760 jump *label200 equal *tmp18 0
   761 label *label9
   762 control enabled switch1 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-12 instructions):
     0 printflush message1
-    * print "Item Rate Display"
-    * print "\n"
-    * print "[gold]Initializing...[]"
-    * print "\n"
+    1 print "Item Rate Display\n[gold]Initializing...[]\n"
     2 printflush message1
     3 draw stroke 1
     4 read *tmp4 bank1 256
 
   190 sensor *tmp21 cell1 @dead
   191 jump *label10 notEqual *tmp21 0
   192 read :m cell1 0
-    * print "\n"
-    * print "Coord: [gold]"
+  193 print "\nCoord: [gold]"
   194 print :m
-    * print "["
-    * print "]"
+  195 print "[]"
   196 op max :maximum :maximum :m
   197 label *label10
   198 op div :scale 150 :maximum
   199 op ceil *tmp29 :maximum
-    * print "\n"
-    * print "Maximum: [green]"
+  200 print "\nMaximum: [green]"
   201 print *tmp29
-    * print "["
-    * print "]"
   202 op floor *tmp30 :scale
-    * print "\n"
-    * print "Scale: [green]"
+  203 print "[]\nScale: [green]"
   204 print *tmp30
-    * print "["
-    * print "]"
+  205 print "[]"
   206 draw clear 0 0 80
   207 draw color 0 80 0 255
   208 draw rect 10 10 156 156
 
   728 write :maximum cell1 0
   729 op sub *tmp68 @time :start
   730 op floor *tmp69 *tmp68
-    * print "\n"
-    * print "[lightgray]Loop time: "
+  731 print "\n[lightgray]Loop time: "
   732 print *tmp69
-    * print " "
-    * print "ms"
+  733 print " ms"
   734 op div *tmp70 @time 1000
   735 op ceil *tmp71 *tmp70
   736 op mul :wait 1000 *tmp71

Final code before resolving virtual instructions:

    0:  printflush message1                                          printflush(message1);
    1:  print "Item Rate Display\n[gold]Initializing...[]\n"         println("[gold]Initializing...[]");
    2:  printflush message1                                          printflush(message1);
    3:  draw stroke 1 0 0 0 0 0                                      stroke(1);
    4:  read *tmp4 bank1 256                                         ptr = MEMORY[INDEX] - SHIFT;
    5:  set :ptr *tmp4                                               ...
    6:  jump *label0 greaterThanEq *tmp4 256                         if ptr < INDEX then ptr += SKIP_SIZE; end;
    7:  op add :ptr *tmp4 254                                        ...
        label *label0                                                ...
    8:  read :maximum bank1 :ptr                                     maximum = MEMORY[ptr];
    9:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   10:  jump *label203 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   11:  op sub :ptr 511 1                                            ...
        label *label203                                              ...
   12:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   13:  op max :maximum :maximum *tmp15                              ...
   14:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   15:  jump *label206 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   16:  op sub :ptr 511 1                                            ...
        label *label206                                              ...
   17:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   18:  op max :maximum :maximum *tmp15                              ...
   19:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   20:  jump *label209 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   21:  op sub :ptr 511 1                                            ...
        label *label209                                              ...
   22:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   23:  op max :maximum :maximum *tmp15                              ...
   24:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   25:  jump *label212 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   26:  op sub :ptr 511 1                                            ...
        label *label212                                              ...
   27:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   28:  op max :maximum :maximum *tmp15                              ...
   29:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   30:  jump *label215 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   31:  op sub :ptr 511 1                                            ...
        label *label215                                              ...
   32:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   33:  op max :maximum :maximum *tmp15                              ...
   34:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   35:  jump *label218 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   36:  op sub :ptr 511 1                                            ...
        label *label218                                              ...
   37:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   38:  op max :maximum :maximum *tmp15                              ...
   39:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   40:  jump *label221 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   41:  op sub :ptr 511 1                                            ...
        label *label221                                              ...
   42:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   43:  op max :maximum :maximum *tmp15                              ...
   44:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   45:  jump *label224 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   46:  op sub :ptr 511 1                                            ...
        label *label224                                              ...
   47:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   48:  op max :maximum :maximum *tmp15                              ...
   49:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   50:  jump *label227 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   51:  op sub :ptr 511 1                                            ...
        label *label227                                              ...
   52:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   53:  op max :maximum :maximum *tmp15                              ...
   54:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   55:  jump *label230 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   56:  op sub :ptr 511 1                                            ...
        label *label230                                              ...
   57:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   58:  op max :maximum :maximum *tmp15                              ...
   59:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   60:  jump *label233 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   61:  op sub :ptr 511 1                                            ...
        label *label233                                              ...
   62:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   63:  op max :maximum :maximum *tmp15                              ...
   64:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   65:  jump *label236 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   66:  op sub :ptr 511 1                                            ...
        label *label236                                              ...
   67:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   68:  op max :maximum :maximum *tmp15                              ...
   69:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   70:  jump *label239 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   71:  op sub :ptr 511 1                                            ...
        label *label239                                              ...
   72:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   73:  op max :maximum :maximum *tmp15                              ...
   74:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   75:  jump *label242 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   76:  op sub :ptr 511 1                                            ...
        label *label242                                              ...
   77:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   78:  op max :maximum :maximum *tmp15                              ...
   79:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   80:  jump *label245 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   81:  op sub :ptr 511 1                                            ...
        label *label245                                              ...
   82:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   83:  op max :maximum :maximum *tmp15                              ...
   84:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   85:  jump *label248 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   86:  op sub :ptr 511 1                                            ...
        label *label248                                              ...
   87:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   88:  op max :maximum :maximum *tmp15                              ...
   89:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   90:  jump *label251 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   91:  op sub :ptr 511 1                                            ...
        label *label251                                              ...
   92:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   93:  op max :maximum :maximum *tmp15                              ...
   94:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   95:  jump *label254 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   96:  op sub :ptr 511 1                                            ...
        label *label254                                              ...
   97:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   98:  op max :maximum :maximum *tmp15                              ...
   99:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  100:  jump *label257 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  101:  op sub :ptr 511 1                                            ...
        label *label257                                              ...
  102:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  103:  op max :maximum :maximum *tmp15                              ...
  104:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  105:  jump *label260 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  106:  op sub :ptr 511 1                                            ...
        label *label260                                              ...
  107:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  108:  op max :maximum :maximum *tmp15                              ...
  109:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  110:  jump *label263 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  111:  op sub :ptr 511 1                                            ...
        label *label263                                              ...
  112:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  113:  op max :maximum :maximum *tmp15                              ...
  114:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  115:  jump *label266 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  116:  op sub :ptr 511 1                                            ...
        label *label266                                              ...
  117:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  118:  op max :maximum :maximum *tmp15                              ...
  119:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  120:  jump *label269 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  121:  op sub :ptr 511 1                                            ...
        label *label269                                              ...
  122:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  123:  op max :maximum :maximum *tmp15                              ...
  124:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  125:  jump *label272 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  126:  op sub :ptr 511 1                                            ...
        label *label272                                              ...
  127:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  128:  op max :maximum :maximum *tmp15                              ...
  129:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  130:  jump *label275 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  131:  op sub :ptr 511 1                                            ...
        label *label275                                              ...
  132:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  133:  op max :maximum :maximum *tmp15                              ...
  134:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  135:  jump *label278 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  136:  op sub :ptr 511 1                                            ...
        label *label278                                              ...
  137:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  138:  op max :maximum :maximum *tmp15                              ...
  139:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  140:  jump *label281 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  141:  op sub :ptr 511 1                                            ...
        label *label281                                              ...
  142:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  143:  op max :maximum :maximum *tmp15                              ...
  144:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  145:  jump *label284 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  146:  op sub :ptr 511 1                                            ...
        label *label284                                              ...
  147:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  148:  op max :maximum :maximum *tmp15                              ...
  149:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  150:  jump *label287 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  151:  op sub :ptr 511 1                                            ...
        label *label287                                              ...
  152:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  153:  op max :maximum :maximum *tmp15                              ...
  154:  op mul :maximum :maximum 3                                   maximum = maximum * SMOOTH;
  155:  sensor *tmp18 switch1 @enabled                               while switch1.@enabled == 0 do
  156:  jump *label9 notEqual *tmp18 0                               ...
        label *label200                                              ...
  157:  print "Item Rate Display"                                    print("Item Rate Display");
  158:  set :start @time                                             start = @time;
  159:  sensor *tmp21 cell1 @dead                                    if COORD.@dead == 0 then
  160:  jump *label10 notEqual *tmp21 0                              ...
  161:  read :m cell1 0                                              m = COORD[n];
  162:  print "\nCoord: [gold]"                                      print($"\nCoord: [gold]$m[]");
  163:  print :m                                                     ...
  164:  print "[]"                                                   ...
  165:  op max :maximum :maximum :m                                  maximum = max(maximum, m);
        label *label10                                               if COORD.@dead == 0 then
  166:  op div :scale 150 :maximum                                   scale = 150 / maximum;
  167:  op ceil *tmp29 :maximum 0                                    print($"\nMaximum: [green]$[]", ceil(maximum));
  168:  print "\nMaximum: [green]"                                   ...
  169:  print *tmp29                                                 ...
  170:  op floor *tmp30 :scale 0                                     print($"\nScale: [green]$[]", floor(scale));
  171:  print "[]\nScale: [green]"                                   ...
  172:  print *tmp30                                                 ...
  173:  print "[]"                                                   ...
  174:  draw clear 0 0 80 0 0 0                                      clear(0,0,80);
  175:  draw color 0 80 0 255 0 0                                    color(0,80,0,255);
  176:  draw rect 10 10 156 156 0 0                                  rect(10,10,156,156);
  177:  read *tmp32 bank1 256                                        head = MEMORY[INDEX] - SHIFT;
  178:  set :head *tmp32                                             ...
  179:  jump *label15 greaterThanEq *tmp32 256                       if head < INDEX then head += SKIP_SIZE; end;
  180:  op add :head *tmp32 254                                      ...
        label *label15                                               ...
  181:  set :tail :head                                              tail = head;
  182:  read *tmp38 bank1 :head                                      value += MEMORY[head];
  183:  set :value *tmp38                                            ...
  184:  op sub :head :head 1                                         head -= 1;
  185:  jump *label44 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  186:  op sub :head 511 1                                           ...
        label *label44                                               ...
  187:  read *tmp38 bank1 :head                                      value += MEMORY[head];
  188:  op add :value :value *tmp38                                  ...
  189:  op sub :head :head 1                                         head -= 1;
  190:  jump *label47 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  191:  op sub :head 511 1                                           ...
        label *label47                                               ...
  192:  read *tmp38 bank1 :head                                      value += MEMORY[head];
  193:  op add :value :value *tmp38                                  ...
  194:  op sub :head :head 1                                         head -= 1;
  195:  jump *label50 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  196:  op sub :head 511 1                                           ...
        label *label50                                               ...
  197:  op mul *tmp42 :value :scale                                  last = 10 + value * scale;
  198:  op add :last 10 *tmp42                                       ...
  199:  set :newMax :value                                           newMax = value;
  200:  draw color 80 255 80 255 0 0                                 color(80,255,80,255);
  201:  read :t bank1 :tail                                          t = MEMORY[tail];
  202:  read :h bank1 :head                                          h = MEMORY[head];
  203:  op sub *tmp48 :value :t                                      value = value - t + h;
  204:  op add :value *tmp48 :h                                      ...
  205:  op sub :head :head 1                                         head -= 1;
  206:  jump *label55 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  207:  op sub :head 511 1                                           ...
        label *label55                                               ...
  208:  op sub :tail :tail 1                                         tail -= 1;
  209:  jump *label57 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  210:  op sub :tail 511 1                                           ...
        label *label57                                               ...
  211:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  212:  op add :y 10 *tmp56                                          ...
  213:  draw line 159 :last 154 :y 0 0                               line(x, last, x - 5, y);
  214:  set :last :y                                                 last = y;
  215:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  216:  read :t bank1 :tail                                          t = MEMORY[tail];
  217:  read :h bank1 :head                                          h = MEMORY[head];
  218:  op sub *tmp48 :value :t                                      value = value - t + h;
  219:  op add :value *tmp48 :h                                      ...
  220:  op sub :head :head 1                                         head -= 1;
  221:  jump *label60 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  222:  op sub :head 511 1                                           ...
        label *label60                                               ...
  223:  op sub :tail :tail 1                                         tail -= 1;
  224:  jump *label62 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  225:  op sub :tail 511 1                                           ...
        label *label62                                               ...
  226:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  227:  op add :y 10 *tmp56                                          ...
  228:  draw line 154 :last 149 :y 0 0                               line(x, last, x - 5, y);
  229:  set :last :y                                                 last = y;
  230:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  231:  read :t bank1 :tail                                          t = MEMORY[tail];
  232:  read :h bank1 :head                                          h = MEMORY[head];
  233:  op sub *tmp48 :value :t                                      value = value - t + h;
  234:  op add :value *tmp48 :h                                      ...
  235:  op sub :head :head 1                                         head -= 1;
  236:  jump *label65 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  237:  op sub :head 511 1                                           ...
        label *label65                                               ...
  238:  op sub :tail :tail 1                                         tail -= 1;
  239:  jump *label67 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  240:  op sub :tail 511 1                                           ...
        label *label67                                               ...
  241:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  242:  op add :y 10 *tmp56                                          ...
  243:  draw line 149 :last 144 :y 0 0                               line(x, last, x - 5, y);
  244:  set :last :y                                                 last = y;
  245:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  246:  read :t bank1 :tail                                          t = MEMORY[tail];
  247:  read :h bank1 :head                                          h = MEMORY[head];
  248:  op sub *tmp48 :value :t                                      value = value - t + h;
  249:  op add :value *tmp48 :h                                      ...
  250:  op sub :head :head 1                                         head -= 1;
  251:  jump *label70 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  252:  op sub :head 511 1                                           ...
        label *label70                                               ...
  253:  op sub :tail :tail 1                                         tail -= 1;
  254:  jump *label72 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  255:  op sub :tail 511 1                                           ...
        label *label72                                               ...
  256:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  257:  op add :y 10 *tmp56                                          ...
  258:  draw line 144 :last 139 :y 0 0                               line(x, last, x - 5, y);
  259:  set :last :y                                                 last = y;
  260:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  261:  read :t bank1 :tail                                          t = MEMORY[tail];
  262:  read :h bank1 :head                                          h = MEMORY[head];
  263:  op sub *tmp48 :value :t                                      value = value - t + h;
  264:  op add :value *tmp48 :h                                      ...
  265:  op sub :head :head 1                                         head -= 1;
  266:  jump *label75 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  267:  op sub :head 511 1                                           ...
        label *label75                                               ...
  268:  op sub :tail :tail 1                                         tail -= 1;
  269:  jump *label77 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  270:  op sub :tail 511 1                                           ...
        label *label77                                               ...
  271:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  272:  op add :y 10 *tmp56                                          ...
  273:  draw line 139 :last 134 :y 0 0                               line(x, last, x - 5, y);
  274:  set :last :y                                                 last = y;
  275:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  276:  read :t bank1 :tail                                          t = MEMORY[tail];
  277:  read :h bank1 :head                                          h = MEMORY[head];
  278:  op sub *tmp48 :value :t                                      value = value - t + h;
  279:  op add :value *tmp48 :h                                      ...
  280:  op sub :head :head 1                                         head -= 1;
  281:  jump *label80 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  282:  op sub :head 511 1                                           ...
        label *label80                                               ...
  283:  op sub :tail :tail 1                                         tail -= 1;
  284:  jump *label82 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  285:  op sub :tail 511 1                                           ...
        label *label82                                               ...
  286:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  287:  op add :y 10 *tmp56                                          ...
  288:  draw line 134 :last 129 :y 0 0                               line(x, last, x - 5, y);
  289:  set :last :y                                                 last = y;
  290:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  291:  read :t bank1 :tail                                          t = MEMORY[tail];
  292:  read :h bank1 :head                                          h = MEMORY[head];
  293:  op sub *tmp48 :value :t                                      value = value - t + h;
  294:  op add :value *tmp48 :h                                      ...
  295:  op sub :head :head 1                                         head -= 1;
  296:  jump *label85 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  297:  op sub :head 511 1                                           ...
        label *label85                                               ...
  298:  op sub :tail :tail 1                                         tail -= 1;
  299:  jump *label87 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  300:  op sub :tail 511 1                                           ...
        label *label87                                               ...
  301:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  302:  op add :y 10 *tmp56                                          ...
  303:  draw line 129 :last 124 :y 0 0                               line(x, last, x - 5, y);
  304:  set :last :y                                                 last = y;
  305:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  306:  read :t bank1 :tail                                          t = MEMORY[tail];
  307:  read :h bank1 :head                                          h = MEMORY[head];
  308:  op sub *tmp48 :value :t                                      value = value - t + h;
  309:  op add :value *tmp48 :h                                      ...
  310:  op sub :head :head 1                                         head -= 1;
  311:  jump *label90 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  312:  op sub :head 511 1                                           ...
        label *label90                                               ...
  313:  op sub :tail :tail 1                                         tail -= 1;
  314:  jump *label92 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  315:  op sub :tail 511 1                                           ...
        label *label92                                               ...
  316:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  317:  op add :y 10 *tmp56                                          ...
  318:  draw line 124 :last 119 :y 0 0                               line(x, last, x - 5, y);
  319:  set :last :y                                                 last = y;
  320:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  321:  read :t bank1 :tail                                          t = MEMORY[tail];
  322:  read :h bank1 :head                                          h = MEMORY[head];
  323:  op sub *tmp48 :value :t                                      value = value - t + h;
  324:  op add :value *tmp48 :h                                      ...
  325:  op sub :head :head 1                                         head -= 1;
  326:  jump *label95 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  327:  op sub :head 511 1                                           ...
        label *label95                                               ...
  328:  op sub :tail :tail 1                                         tail -= 1;
  329:  jump *label97 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  330:  op sub :tail 511 1                                           ...
        label *label97                                               ...
  331:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  332:  op add :y 10 *tmp56                                          ...
  333:  draw line 119 :last 114 :y 0 0                               line(x, last, x - 5, y);
  334:  set :last :y                                                 last = y;
  335:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  336:  read :t bank1 :tail                                          t = MEMORY[tail];
  337:  read :h bank1 :head                                          h = MEMORY[head];
  338:  op sub *tmp48 :value :t                                      value = value - t + h;
  339:  op add :value *tmp48 :h                                      ...
  340:  op sub :head :head 1                                         head -= 1;
  341:  jump *label100 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  342:  op sub :head 511 1                                           ...
        label *label100                                              ...
  343:  op sub :tail :tail 1                                         tail -= 1;
  344:  jump *label102 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  345:  op sub :tail 511 1                                           ...
        label *label102                                              ...
  346:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  347:  op add :y 10 *tmp56                                          ...
  348:  draw line 114 :last 109 :y 0 0                               line(x, last, x - 5, y);
  349:  set :last :y                                                 last = y;
  350:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  351:  read :t bank1 :tail                                          t = MEMORY[tail];
  352:  read :h bank1 :head                                          h = MEMORY[head];
  353:  op sub *tmp48 :value :t                                      value = value - t + h;
  354:  op add :value *tmp48 :h                                      ...
  355:  op sub :head :head 1                                         head -= 1;
  356:  jump *label105 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  357:  op sub :head 511 1                                           ...
        label *label105                                              ...
  358:  op sub :tail :tail 1                                         tail -= 1;
  359:  jump *label107 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  360:  op sub :tail 511 1                                           ...
        label *label107                                              ...
  361:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  362:  op add :y 10 *tmp56                                          ...
  363:  draw line 109 :last 104 :y 0 0                               line(x, last, x - 5, y);
  364:  set :last :y                                                 last = y;
  365:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  366:  read :t bank1 :tail                                          t = MEMORY[tail];
  367:  read :h bank1 :head                                          h = MEMORY[head];
  368:  op sub *tmp48 :value :t                                      value = value - t + h;
  369:  op add :value *tmp48 :h                                      ...
  370:  op sub :head :head 1                                         head -= 1;
  371:  jump *label110 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  372:  op sub :head 511 1                                           ...
        label *label110                                              ...
  373:  op sub :tail :tail 1                                         tail -= 1;
  374:  jump *label112 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  375:  op sub :tail 511 1                                           ...
        label *label112                                              ...
  376:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  377:  op add :y 10 *tmp56                                          ...
  378:  draw line 104 :last 99 :y 0 0                                line(x, last, x - 5, y);
  379:  set :last :y                                                 last = y;
  380:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  381:  read :t bank1 :tail                                          t = MEMORY[tail];
  382:  read :h bank1 :head                                          h = MEMORY[head];
  383:  op sub *tmp48 :value :t                                      value = value - t + h;
  384:  op add :value *tmp48 :h                                      ...
  385:  op sub :head :head 1                                         head -= 1;
  386:  jump *label115 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  387:  op sub :head 511 1                                           ...
        label *label115                                              ...
  388:  op sub :tail :tail 1                                         tail -= 1;
  389:  jump *label117 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  390:  op sub :tail 511 1                                           ...
        label *label117                                              ...
  391:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  392:  op add :y 10 *tmp56                                          ...
  393:  draw line 99 :last 94 :y 0 0                                 line(x, last, x - 5, y);
  394:  set :last :y                                                 last = y;
  395:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  396:  read :t bank1 :tail                                          t = MEMORY[tail];
  397:  read :h bank1 :head                                          h = MEMORY[head];
  398:  op sub *tmp48 :value :t                                      value = value - t + h;
  399:  op add :value *tmp48 :h                                      ...
  400:  op sub :head :head 1                                         head -= 1;
  401:  jump *label120 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  402:  op sub :head 511 1                                           ...
        label *label120                                              ...
  403:  op sub :tail :tail 1                                         tail -= 1;
  404:  jump *label122 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  405:  op sub :tail 511 1                                           ...
        label *label122                                              ...
  406:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  407:  op add :y 10 *tmp56                                          ...
  408:  draw line 94 :last 89 :y 0 0                                 line(x, last, x - 5, y);
  409:  set :last :y                                                 last = y;
  410:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  411:  read :t bank1 :tail                                          t = MEMORY[tail];
  412:  read :h bank1 :head                                          h = MEMORY[head];
  413:  op sub *tmp48 :value :t                                      value = value - t + h;
  414:  op add :value *tmp48 :h                                      ...
  415:  op sub :head :head 1                                         head -= 1;
  416:  jump *label125 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  417:  op sub :head 511 1                                           ...
        label *label125                                              ...
  418:  op sub :tail :tail 1                                         tail -= 1;
  419:  jump *label127 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  420:  op sub :tail 511 1                                           ...
        label *label127                                              ...
  421:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  422:  op add :y 10 *tmp56                                          ...
  423:  draw line 89 :last 84 :y 0 0                                 line(x, last, x - 5, y);
  424:  set :last :y                                                 last = y;
  425:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  426:  read :t bank1 :tail                                          t = MEMORY[tail];
  427:  read :h bank1 :head                                          h = MEMORY[head];
  428:  op sub *tmp48 :value :t                                      value = value - t + h;
  429:  op add :value *tmp48 :h                                      ...
  430:  op sub :head :head 1                                         head -= 1;
  431:  jump *label130 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  432:  op sub :head 511 1                                           ...
        label *label130                                              ...
  433:  op sub :tail :tail 1                                         tail -= 1;
  434:  jump *label132 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  435:  op sub :tail 511 1                                           ...
        label *label132                                              ...
  436:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  437:  op add :y 10 *tmp56                                          ...
  438:  draw line 84 :last 79 :y 0 0                                 line(x, last, x - 5, y);
  439:  set :last :y                                                 last = y;
  440:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  441:  read :t bank1 :tail                                          t = MEMORY[tail];
  442:  read :h bank1 :head                                          h = MEMORY[head];
  443:  op sub *tmp48 :value :t                                      value = value - t + h;
  444:  op add :value *tmp48 :h                                      ...
  445:  op sub :head :head 1                                         head -= 1;
  446:  jump *label135 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  447:  op sub :head 511 1                                           ...
        label *label135                                              ...
  448:  op sub :tail :tail 1                                         tail -= 1;
  449:  jump *label137 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  450:  op sub :tail 511 1                                           ...
        label *label137                                              ...
  451:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  452:  op add :y 10 *tmp56                                          ...
  453:  draw line 79 :last 74 :y 0 0                                 line(x, last, x - 5, y);
  454:  set :last :y                                                 last = y;
  455:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  456:  read :t bank1 :tail                                          t = MEMORY[tail];
  457:  read :h bank1 :head                                          h = MEMORY[head];
  458:  op sub *tmp48 :value :t                                      value = value - t + h;
  459:  op add :value *tmp48 :h                                      ...
  460:  op sub :head :head 1                                         head -= 1;
  461:  jump *label140 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  462:  op sub :head 511 1                                           ...
        label *label140                                              ...
  463:  op sub :tail :tail 1                                         tail -= 1;
  464:  jump *label142 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  465:  op sub :tail 511 1                                           ...
        label *label142                                              ...
  466:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  467:  op add :y 10 *tmp56                                          ...
  468:  draw line 74 :last 69 :y 0 0                                 line(x, last, x - 5, y);
  469:  set :last :y                                                 last = y;
  470:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  471:  read :t bank1 :tail                                          t = MEMORY[tail];
  472:  read :h bank1 :head                                          h = MEMORY[head];
  473:  op sub *tmp48 :value :t                                      value = value - t + h;
  474:  op add :value *tmp48 :h                                      ...
  475:  op sub :head :head 1                                         head -= 1;
  476:  jump *label145 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  477:  op sub :head 511 1                                           ...
        label *label145                                              ...
  478:  op sub :tail :tail 1                                         tail -= 1;
  479:  jump *label147 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  480:  op sub :tail 511 1                                           ...
        label *label147                                              ...
  481:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  482:  op add :y 10 *tmp56                                          ...
  483:  draw line 69 :last 64 :y 0 0                                 line(x, last, x - 5, y);
  484:  set :last :y                                                 last = y;
  485:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  486:  read :t bank1 :tail                                          t = MEMORY[tail];
  487:  read :h bank1 :head                                          h = MEMORY[head];
  488:  op sub *tmp48 :value :t                                      value = value - t + h;
  489:  op add :value *tmp48 :h                                      ...
  490:  op sub :head :head 1                                         head -= 1;
  491:  jump *label150 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  492:  op sub :head 511 1                                           ...
        label *label150                                              ...
  493:  op sub :tail :tail 1                                         tail -= 1;
  494:  jump *label152 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  495:  op sub :tail 511 1                                           ...
        label *label152                                              ...
  496:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  497:  op add :y 10 *tmp56                                          ...
  498:  draw line 64 :last 59 :y 0 0                                 line(x, last, x - 5, y);
  499:  set :last :y                                                 last = y;
  500:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  501:  read :t bank1 :tail                                          t = MEMORY[tail];
  502:  read :h bank1 :head                                          h = MEMORY[head];
  503:  op sub *tmp48 :value :t                                      value = value - t + h;
  504:  op add :value *tmp48 :h                                      ...
  505:  op sub :head :head 1                                         head -= 1;
  506:  jump *label155 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  507:  op sub :head 511 1                                           ...
        label *label155                                              ...
  508:  op sub :tail :tail 1                                         tail -= 1;
  509:  jump *label157 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  510:  op sub :tail 511 1                                           ...
        label *label157                                              ...
  511:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  512:  op add :y 10 *tmp56                                          ...
  513:  draw line 59 :last 54 :y 0 0                                 line(x, last, x - 5, y);
  514:  set :last :y                                                 last = y;
  515:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  516:  read :t bank1 :tail                                          t = MEMORY[tail];
  517:  read :h bank1 :head                                          h = MEMORY[head];
  518:  op sub *tmp48 :value :t                                      value = value - t + h;
  519:  op add :value *tmp48 :h                                      ...
  520:  op sub :head :head 1                                         head -= 1;
  521:  jump *label160 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  522:  op sub :head 511 1                                           ...
        label *label160                                              ...
  523:  op sub :tail :tail 1                                         tail -= 1;
  524:  jump *label162 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  525:  op sub :tail 511 1                                           ...
        label *label162                                              ...
  526:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  527:  op add :y 10 *tmp56                                          ...
  528:  draw line 54 :last 49 :y 0 0                                 line(x, last, x - 5, y);
  529:  set :last :y                                                 last = y;
  530:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  531:  read :t bank1 :tail                                          t = MEMORY[tail];
  532:  read :h bank1 :head                                          h = MEMORY[head];
  533:  op sub *tmp48 :value :t                                      value = value - t + h;
  534:  op add :value *tmp48 :h                                      ...
  535:  op sub :head :head 1                                         head -= 1;
  536:  jump *label165 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  537:  op sub :head 511 1                                           ...
        label *label165                                              ...
  538:  op sub :tail :tail 1                                         tail -= 1;
  539:  jump *label167 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  540:  op sub :tail 511 1                                           ...
        label *label167                                              ...
  541:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  542:  op add :y 10 *tmp56                                          ...
  543:  draw line 49 :last 44 :y 0 0                                 line(x, last, x - 5, y);
  544:  set :last :y                                                 last = y;
  545:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  546:  read :t bank1 :tail                                          t = MEMORY[tail];
  547:  read :h bank1 :head                                          h = MEMORY[head];
  548:  op sub *tmp48 :value :t                                      value = value - t + h;
  549:  op add :value *tmp48 :h                                      ...
  550:  op sub :head :head 1                                         head -= 1;
  551:  jump *label170 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  552:  op sub :head 511 1                                           ...
        label *label170                                              ...
  553:  op sub :tail :tail 1                                         tail -= 1;
  554:  jump *label172 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  555:  op sub :tail 511 1                                           ...
        label *label172                                              ...
  556:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  557:  op add :y 10 *tmp56                                          ...
  558:  draw line 44 :last 39 :y 0 0                                 line(x, last, x - 5, y);
  559:  set :last :y                                                 last = y;
  560:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  561:  read :t bank1 :tail                                          t = MEMORY[tail];
  562:  read :h bank1 :head                                          h = MEMORY[head];
  563:  op sub *tmp48 :value :t                                      value = value - t + h;
  564:  op add :value *tmp48 :h                                      ...
  565:  op sub :head :head 1                                         head -= 1;
  566:  jump *label175 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  567:  op sub :head 511 1                                           ...
        label *label175                                              ...
  568:  op sub :tail :tail 1                                         tail -= 1;
  569:  jump *label177 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  570:  op sub :tail 511 1                                           ...
        label *label177                                              ...
  571:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  572:  op add :y 10 *tmp56                                          ...
  573:  draw line 39 :last 34 :y 0 0                                 line(x, last, x - 5, y);
  574:  set :last :y                                                 last = y;
  575:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  576:  read :t bank1 :tail                                          t = MEMORY[tail];
  577:  read :h bank1 :head                                          h = MEMORY[head];
  578:  op sub *tmp48 :value :t                                      value = value - t + h;
  579:  op add :value *tmp48 :h                                      ...
  580:  op sub :head :head 1                                         head -= 1;
  581:  jump *label180 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  582:  op sub :head 511 1                                           ...
        label *label180                                              ...
  583:  op sub :tail :tail 1                                         tail -= 1;
  584:  jump *label182 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  585:  op sub :tail 511 1                                           ...
        label *label182                                              ...
  586:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  587:  op add :y 10 *tmp56                                          ...
  588:  draw line 34 :last 29 :y 0 0                                 line(x, last, x - 5, y);
  589:  set :last :y                                                 last = y;
  590:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  591:  read :t bank1 :tail                                          t = MEMORY[tail];
  592:  read :h bank1 :head                                          h = MEMORY[head];
  593:  op sub *tmp48 :value :t                                      value = value - t + h;
  594:  op add :value *tmp48 :h                                      ...
  595:  op sub :head :head 1                                         head -= 1;
  596:  jump *label185 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  597:  op sub :head 511 1                                           ...
        label *label185                                              ...
  598:  op sub :tail :tail 1                                         tail -= 1;
  599:  jump *label187 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  600:  op sub :tail 511 1                                           ...
        label *label187                                              ...
  601:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  602:  op add :y 10 *tmp56                                          ...
  603:  draw line 29 :last 24 :y 0 0                                 line(x, last, x - 5, y);
  604:  set :last :y                                                 last = y;
  605:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  606:  read :t bank1 :tail                                          t = MEMORY[tail];
  607:  read :h bank1 :head                                          h = MEMORY[head];
  608:  op sub *tmp48 :value :t                                      value = value - t + h;
  609:  op add :value *tmp48 :h                                      ...
  610:  op sub :head :head 1                                         head -= 1;
  611:  jump *label190 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  612:  op sub :head 511 1                                           ...
        label *label190                                              ...
  613:  op sub :tail :tail 1                                         tail -= 1;
  614:  jump *label192 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  615:  op sub :tail 511 1                                           ...
        label *label192                                              ...
  616:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  617:  op add :y 10 *tmp56                                          ...
  618:  draw line 24 :last 19 :y 0 0                                 line(x, last, x - 5, y);
  619:  set :last :y                                                 last = y;
  620:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  621:  read :t bank1 :tail                                          t = MEMORY[tail];
  622:  read :h bank1 :head                                          h = MEMORY[head];
  623:  op sub *tmp48 :value :t                                      value = value - t + h;
  624:  op add :value *tmp48 :h                                      ...
  625:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  626:  op add :y 10 *tmp56                                          ...
  627:  draw line 19 :last 14 :y 0 0                                 line(x, last, x - 5, y);
  628:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  629:  draw color 255 255 255 255 0 0                               color(255,255,255,255);
  630:  draw lineRect 10 10 156 156 0 0                              lineRect(10,10,156,156);
  631:  op max :maximum :newMax :maximum                             maximum = max(newMax, maximum);
  632:  op mul *tmp62 3 :newMax                                      if 3 * newMax < maximum then
  633:  jump *label29 greaterThanEq *tmp62 :maximum                  ...
  634:  op mul :maximum 1.5 :newMax                                  maximum = 1.5 * newMax;
        label *label29                                               if 3 * newMax < maximum then
  635:  write :maximum cell1 0                                       COORD[POSITION] = maximum;
  636:  op sub *tmp68 @time :start                                   print($"\n[lightgray]Loop time: $ ms", floor(@time - start));
  637:  op floor *tmp69 *tmp68 0                                     ...
  638:  print "\n[lightgray]Loop time: "                             ...
  639:  print *tmp69                                                 ...
  640:  print " ms"                                                  ...
  641:  op div *tmp70 @time 1000                                     wait = FREQ * ceil(@time / FREQ);
  642:  op ceil *tmp71 *tmp70 0                                      ...
  643:  op mul :wait 1000 *tmp71                                     ...
  644:  set :loops 0                                                 loops = 0;
  645:  jump *label33 greaterThanEq @time :wait                      while @time < wait do
        label *label38                                               ...
  646:  op add :loops :loops 1                                       loops += 1;
  647:  jump *label38 lessThan @time :wait                           while @time < wait do
        label *label33                                               ...
  648:  drawflush display1                                           drawflush(display1);
  649:  print "\nLoops: "                                            print("\nLoops: ", loops);
  650:  print :loops                                                 ...
  651:  printflush message1                                          printflush(message1);
  652:  sensor *tmp18 switch1 @enabled                               while switch1.@enabled == 0 do
  653:  jump *label200 equal *tmp18 0                                ...
        label *label9                                                ...
  654:  control enabled switch1 0 0 0 0                              switch1.enabled = 0;


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   655     1x    655,0  <no function>

Performance: parsed in 190 ms, compiled in 248 ms, optimized in 556 ms, run in 24 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (128 steps):
Item Rate Display
[gold]Initializing...[]

Execution exception at instruction 155: sensor *tmp18 switch1 @enabled:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
