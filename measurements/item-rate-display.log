   206 instructions before optimizations.
    35 instructions eliminated by Temp Variables Elimination.
    16 instructions eliminated by Dead Code Elimination (3 iterations).
    12 instructions eliminated by Jump Optimization (4 iterations).
    11 instructions eliminated by Single Step Elimination (3 passes, 7 iterations).
     3 instructions modified by Expression Optimization (3 iterations).
   143 instructions eliminated by Data Flow Optimization (6 passes, 20 iterations).
     3 instructions eliminated by Loop Optimization (3 iterations).
     6 loops improved by Loop Optimization.
   680 instructions added by Loop Unrolling (8 iterations).
     4 loops unrolled by Loop Unrolling.
    12 instructions eliminated by Print Merging.
   654 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 880):
    Replicate loop condition at line 32:1                        cost     1, benefit       25.0, efficiency       25.0
    Unroll loop at line 24:1                                     cost   137, benefit     1450.0, efficiency       10.6
  * Unroll loop at line 36:9                                     cost     0, benefit      625.0, efficiency   Infinity (-3 instructions)
    Unroll loop at line 55:5                                     cost     7, benefit     3750.0, efficiency      535.7
    Unroll loop at line 65:5                                     cost   473, benefit    36250.0, efficiency       76.6

Pass 1: speed optimization selection (cost limit 883):
    Replicate loop condition at line 32:1                        cost     1, benefit       25.0, efficiency       25.0
    Unroll loop at line 24:1                                     cost   137, benefit     1450.0, efficiency       10.6
  * Unroll loop at line 55:5                                     cost     7, benefit     3750.0, efficiency      535.7 (+6 instructions)
    Unroll loop at line 65:5                                     cost   473, benefit    36250.0, efficiency       76.6

Pass 1: speed optimization selection (cost limit 877):
    Replicate loop condition at line 32:1                        cost     1, benefit       25.0, efficiency       25.0
    Unroll loop at line 24:1                                     cost   137, benefit     1450.0, efficiency       10.6
  * Unroll loop at line 65:5                                     cost   473, benefit    36250.0, efficiency       76.6 (+411 instructions)

Pass 1: speed optimization selection (cost limit 466):
  * Replicate loop condition at line 32:1                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
    Unroll loop at line 24:1                                     cost   137, benefit     1450.0, efficiency       10.6

Pass 1: speed optimization selection (cost limit 465):
  * Unroll loop at line 24:1                                     cost   137, benefit     1450.0, efficiency       10.6 (+137 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-16 instructions):
 
    24 op lessThan *tmp6 :ptr .INDEX
    25 jump *label0 equal *tmp6 false
    26 op add :ptr :ptr .SKIP_SIZE
-    * set *tmp7 :ptr
    27 jump *label1 always
    28 label *label0
-    * set *tmp7 null
    29 label *label1
    30 set *tmp8 :ptr
    31 read *tmp9 .MEMORY *tmp8
 
    39 jump *label5 equal *tmp11 false
    40 op sub *tmp13 .SIZE 1
    41 set :ptr *tmp13
-    * set *tmp12 :ptr
    42 jump *label6 always
    43 label *label5
-    * set *tmp12 null
    44 label *label6
    45 set *tmp14 :ptr
    46 read *tmp15 .MEMORY *tmp14
 
    80 op add :n :n 1
    81 jump *label12 always
    82 label *label14
-    * set *tmp23 null
    83 jump *label11 always
    84 label *label10
-    * set *tmp23 null
    85 label *label11
    86 op div *tmp28 150 :maximum
    87 set :scale *tmp28
 
   107 op lessThan *tmp34 :head .INDEX
   108 jump *label15 equal *tmp34 false
   109 op add :head :head .SKIP_SIZE
-    * set *tmp35 :head
   110 jump *label16 always
   111 label *label15
-    * set *tmp35 null
   112 label *label16
   113 set :tail :head
   114 set :value 0
 
   124 jump *label20 equal *tmp39 false
   125 op sub *tmp41 .SIZE 1
   126 set :head *tmp41
-    * set *tmp40 :head
   127 jump *label21 always
   128 label *label20
-    * set *tmp40 null
   129 label *label21
   130 label *label18
   131 op add :i :i 1
 
   154 jump *label25 equal *tmp50 false
   155 op sub *tmp52 .SIZE 1
   156 set :head *tmp52
-    * set *tmp51 :head
   157 jump *label26 always
   158 label *label25
-    * set *tmp51 null
   159 label *label26
   160 op sub :tail :tail 1
   161 op lessThanEq *tmp53 :tail .INDEX
   162 jump *label27 equal *tmp53 false
   163 op sub *tmp55 .SIZE 1
   164 set :tail *tmp55
-    * set *tmp54 :tail
   165 jump *label28 always
   166 label *label27
-    * set *tmp54 null
   167 label *label28
   168 op mul *tmp56 :value :scale
   169 op add *tmp57 10 *tmp56
 
   188 jump *label29 equal *tmp63 false
   189 op mul *tmp65 1.5 :newMax
   190 set :maximum *tmp65
-    * set *tmp64 :maximum
   191 jump *label30 always
   192 label *label29
-    * set *tmp64 null
   193 label *label30
   194 set *tmp66 .POSITION
   195 write :maximum .COORD *tmp66

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-35 instructions):
 
    13 set .INDEX 256
    14 set .SIZE 511
    15 op sub *tmp0 .SIZE .INDEX
-    * op sub *tmp1 *tmp0 1
-    * set .SKIP_SIZE *tmp1
-    * op mul *tmp2 .POSITION 30
-    * set .SHIFT *tmp2
-    * set *tmp3 .INDEX
-    * read *tmp4 .MEMORY *tmp3
-    * op sub *tmp5 *tmp4 .SHIFT
-    * set :ptr *tmp5
+   16 op sub .SKIP_SIZE *tmp0 1
+   17 op mul .SHIFT .POSITION 30
+   18 read *tmp4 .MEMORY .INDEX
+   19 op sub :ptr *tmp4 .SHIFT
    20 op lessThan *tmp6 :ptr .INDEX
    21 jump *label0 equal *tmp6 false
    22 op add :ptr :ptr .SKIP_SIZE
    23 jump *label1 always
    24 label *label0
    25 label *label1
-    * set *tmp8 :ptr
-    * read *tmp9 .MEMORY *tmp8
-    * set :maximum *tmp9
+   26 read :maximum .MEMORY :ptr
    27 set :n 0
    28 label *label2
    29 jump *label4 greaterThanEq :n 29
-    * op sub *tmp10 :ptr 1
-    * set :ptr *tmp10
+   30 op sub :ptr :ptr 1
    31 op lessThanEq *tmp11 :ptr .INDEX
    32 jump *label5 equal *tmp11 false
-    * op sub *tmp13 .SIZE 1
-    * set :ptr *tmp13
+   33 op sub :ptr .SIZE 1
    34 jump *label6 always
    35 label *label5
    36 label *label6
-    * set *tmp14 :ptr
-    * read *tmp15 .MEMORY *tmp14
-    * op max *tmp16 :maximum *tmp15
-    * set :maximum *tmp16
+   37 read *tmp15 .MEMORY :ptr
+   38 op max :maximum :maximum *tmp15
    39 label *label3
    40 op add :n :n 1
    41 jump *label2 always
    42 label *label4
-    * op mul *tmp17 :maximum .SMOOTH
-    * set :maximum *tmp17
+   43 op mul :maximum :maximum .SMOOTH
    44 label *label7
    45 sensor *tmp18 switch1 @enabled
    46 op equal *tmp19 *tmp18 0
    47 jump *label9 equal *tmp19 false
    48 print "Item Rate Display"
-    * set *tmp20 @time
-    * set :start *tmp20
+   49 set :start @time
    50 sensor *tmp21 .COORD @dead
    51 op equal *tmp22 *tmp21 0
    52 jump *label10 equal *tmp22 false
 
    54 label *label12
    55 op lessThan *tmp24 :n .TOTAL
    56 jump *label14 equal *tmp24 false
-    * set *tmp25 :n
-    * read *tmp26 .COORD *tmp25
-    * set :m *tmp26
+   57 read :m .COORD :n
    58 print "\n"
    59 print "Coord: [gold]"
    60 print :m
    61 print "["
    62 print "]"
-    * op max *tmp27 :maximum :m
-    * set :maximum *tmp27
+   63 op max :maximum :maximum :m
    64 label *label13
    65 op add :n :n 1
    66 jump *label12 always
 
    68 jump *label11 always
    69 label *label10
    70 label *label11
-    * op div *tmp28 150 :maximum
-    * set :scale *tmp28
+   71 op div :scale 150 :maximum
    72 op ceil *tmp29 :maximum
    73 print "\n"
    74 print "Maximum: [green]"
 
    84 draw clear 0 0 80
    85 draw color 0 80 0 255
    86 draw rect 10 10 156 156
-    * set *tmp31 .INDEX
-    * read *tmp32 .MEMORY *tmp31
-    * op sub *tmp33 *tmp32 .SHIFT
-    * set :head *tmp33
+   87 read *tmp32 .MEMORY .INDEX
+   88 op sub :head *tmp32 .SHIFT
    89 op lessThan *tmp34 :head .INDEX
    90 jump *label15 equal *tmp34 false
    91 op add :head :head .SKIP_SIZE
 
    98 label *label17
    99 op lessThan *tmp36 :i .SMOOTH
   100 jump *label19 equal *tmp36 false
-    * set *tmp37 :head
-    * read *tmp38 .MEMORY *tmp37
+  101 read *tmp38 .MEMORY :head
   102 op add :value :value *tmp38
   103 op sub :head :head 1
   104 op lessThanEq *tmp39 :head .INDEX
   105 jump *label20 equal *tmp39 false
-    * op sub *tmp41 .SIZE 1
-    * set :head *tmp41
+  106 op sub :head .SIZE 1
   107 jump *label21 always
   108 label *label20
   109 label *label21
 
   112 jump *label17 always
   113 label *label19
   114 op mul *tmp42 :value :scale
-    * op add *tmp43 10 *tmp42
-    * set :last *tmp43
+  115 op add :last 10 *tmp42
   116 set :newMax :value
   117 draw color 80 255 80 255
   118 set :x 159
   119 set :n 0
   120 label *label22
   121 jump *label24 greaterThanEq :n 29
-    * set *tmp44 :tail
-    * read *tmp45 .MEMORY *tmp44
-    * set :t *tmp45
-    * set *tmp46 :head
-    * read *tmp47 .MEMORY *tmp46
-    * set :h *tmp47
+  122 read :t .MEMORY :tail
+  123 read :h .MEMORY :head
   124 op sub *tmp48 :value :t
-    * op add *tmp49 *tmp48 :h
-    * set :value *tmp49
+  125 op add :value *tmp48 :h
   126 op sub :head :head 1
   127 op lessThanEq *tmp50 :head .INDEX
   128 jump *label25 equal *tmp50 false
-    * op sub *tmp52 .SIZE 1
-    * set :head *tmp52
+  129 op sub :head .SIZE 1
   130 jump *label26 always
   131 label *label25
   132 label *label26
   133 op sub :tail :tail 1
   134 op lessThanEq *tmp53 :tail .INDEX
   135 jump *label27 equal *tmp53 false
-    * op sub *tmp55 .SIZE 1
-    * set :tail *tmp55
+  136 op sub :tail .SIZE 1
   137 jump *label28 always
   138 label *label27
   139 label *label28
   140 op mul *tmp56 :value :scale
-    * op add *tmp57 10 *tmp56
-    * set :y *tmp57
+  141 op add :y 10 *tmp56
   142 op sub *tmp58 :x 5
   143 draw line :x :last *tmp58 :y
-    * op sub *tmp59 :x 5
-    * set :x *tmp59
+  144 op sub :x :x 5
   145 set :last :y
-    * op max *tmp60 :newMax :value
-    * set :newMax *tmp60
+  146 op max :newMax :newMax :value
   147 label *label23
   148 op add :n :n 1
   149 jump *label22 always
   150 label *label24
   151 draw color 255 255 255 255
   152 draw lineRect 10 10 156 156
-    * op max *tmp61 :newMax :maximum
-    * set :maximum *tmp61
+  153 op max :maximum :newMax :maximum
   154 op mul *tmp62 3 :newMax
   155 op lessThan *tmp63 *tmp62 :maximum
   156 jump *label29 equal *tmp63 false
-    * op mul *tmp65 1.5 :newMax
-    * set :maximum *tmp65
+  157 op mul :maximum 1.5 :newMax
   158 jump *label30 always
   159 label *label29
   160 label *label30
-    * set *tmp66 .POSITION
-    * write :maximum .COORD *tmp66
+  161 write :maximum .COORD .POSITION
   162 op sub *tmp68 @time :start
   163 op floor *tmp69 *tmp68
   164 print "\n"
 
   168 print "ms"
   169 op div *tmp70 @time .FREQ
   170 op ceil *tmp71 *tmp70
-    * op mul *tmp72 .FREQ *tmp71
-    * set :wait *tmp72
+  171 op mul :wait .FREQ *tmp71
   172 set :loops 0
   173 label *label31
   174 op lessThan *tmp73 @time :wait

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-12 instructions):
 
    17 op mul .SHIFT .POSITION 30
    18 read *tmp4 .MEMORY .INDEX
    19 op sub :ptr *tmp4 .SHIFT
-    * op lessThan *tmp6 :ptr .INDEX
-    * jump *label0 equal *tmp6 false
+   20 jump *label0 greaterThanEq :ptr .INDEX
    21 op add :ptr :ptr .SKIP_SIZE
    22 jump *label1 always
    23 label *label0
 
    27 label *label2
    28 jump *label4 greaterThanEq :n 29
    29 op sub :ptr :ptr 1
-    * op lessThanEq *tmp11 :ptr .INDEX
-    * jump *label5 equal *tmp11 false
+   30 jump *label5 greaterThan :ptr .INDEX
    31 op sub :ptr .SIZE 1
    32 jump *label6 always
    33 label *label5
 
    41 op mul :maximum :maximum .SMOOTH
    42 label *label7
    43 sensor *tmp18 switch1 @enabled
-    * op equal *tmp19 *tmp18 0
-    * jump *label9 equal *tmp19 false
+   44 jump *label9 notEqual *tmp18 0
    45 print "Item Rate Display"
    46 set :start @time
    47 sensor *tmp21 .COORD @dead
-    * op equal *tmp22 *tmp21 0
-    * jump *label10 equal *tmp22 false
+   48 jump *label10 notEqual *tmp21 0
    49 set :n 0
    50 label *label12
-    * op lessThan *tmp24 :n .TOTAL
-    * jump *label14 equal *tmp24 false
+   51 jump *label14 greaterThanEq :n .TOTAL
    52 read :m .COORD :n
    53 print "\n"
    54 print "Coord: [gold]"
 
    81 draw rect 10 10 156 156
    82 read *tmp32 .MEMORY .INDEX
    83 op sub :head *tmp32 .SHIFT
-    * op lessThan *tmp34 :head .INDEX
-    * jump *label15 equal *tmp34 false
+   84 jump *label15 greaterThanEq :head .INDEX
    85 op add :head :head .SKIP_SIZE
    86 jump *label16 always
    87 label *label15
 
    90 set :value 0
    91 set :i 0
    92 label *label17
-    * op lessThan *tmp36 :i .SMOOTH
-    * jump *label19 equal *tmp36 false
+   93 jump *label19 greaterThanEq :i .SMOOTH
    94 read *tmp38 .MEMORY :head
    95 op add :value :value *tmp38
    96 op sub :head :head 1
-    * op lessThanEq *tmp39 :head .INDEX
-    * jump *label20 equal *tmp39 false
+   97 jump *label20 greaterThan :head .INDEX
    98 op sub :head .SIZE 1
    99 jump *label21 always
   100 label *label20
 
   116 op sub *tmp48 :value :t
   117 op add :value *tmp48 :h
   118 op sub :head :head 1
-    * op lessThanEq *tmp50 :head .INDEX
-    * jump *label25 equal *tmp50 false
+  119 jump *label25 greaterThan :head .INDEX
   120 op sub :head .SIZE 1
   121 jump *label26 always
   122 label *label25
   123 label *label26
   124 op sub :tail :tail 1
-    * op lessThanEq *tmp53 :tail .INDEX
-    * jump *label27 equal *tmp53 false
+  125 jump *label27 greaterThan :tail .INDEX
   126 op sub :tail .SIZE 1
   127 jump *label28 always
   128 label *label27
 
   142 draw lineRect 10 10 156 156
   143 op max :maximum :newMax :maximum
   144 op mul *tmp62 3 :newMax
-    * op lessThan *tmp63 *tmp62 :maximum
-    * jump *label29 equal *tmp63 false
+  145 jump *label29 greaterThanEq *tmp62 :maximum
   146 op mul :maximum 1.5 :newMax
   147 jump *label30 always
   148 label *label29
 
   160 op mul :wait .FREQ *tmp71
   161 set :loops 0
   162 label *label31
-    * op lessThan *tmp73 @time :wait
-    * jump *label33 equal *tmp73 false
+  163 jump *label33 greaterThanEq @time :wait
   164 op add :loops :loops 1
   165 label *label32
   166 jump *label31 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-8 instructions):
 
    19 op sub :ptr *tmp4 .SHIFT
    20 jump *label0 greaterThanEq :ptr .INDEX
    21 op add :ptr :ptr .SKIP_SIZE
-    * jump *label1 always
    22 label *label0
    23 label *label1
    24 read :maximum .MEMORY :ptr
 
    28 op sub :ptr :ptr 1
    29 jump *label5 greaterThan :ptr .INDEX
    30 op sub :ptr .SIZE 1
-    * jump *label6 always
    31 label *label5
    32 label *label6
    33 read *tmp15 .MEMORY :ptr
 
    58 op add :n :n 1
    59 jump *label12 always
    60 label *label14
-    * jump *label11 always
    61 label *label10
    62 label *label11
    63 op div :scale 150 :maximum
 
    80 op sub :head *tmp32 .SHIFT
    81 jump *label15 greaterThanEq :head .INDEX
    82 op add :head :head .SKIP_SIZE
-    * jump *label16 always
    83 label *label15
    84 label *label16
    85 set :tail :head
 
    92 op sub :head :head 1
    93 jump *label20 greaterThan :head .INDEX
    94 op sub :head .SIZE 1
-    * jump *label21 always
    95 label *label20
    96 label *label21
    97 label *label18
 
   113 op sub :head :head 1
   114 jump *label25 greaterThan :head .INDEX
   115 op sub :head .SIZE 1
-    * jump *label26 always
   116 label *label25
   117 label *label26
   118 op sub :tail :tail 1
   119 jump *label27 greaterThan :tail .INDEX
   120 op sub :tail .SIZE 1
-    * jump *label28 always
   121 label *label27
   122 label *label28
   123 op mul *tmp56 :value :scale
 
   137 op mul *tmp62 3 :newMax
   138 jump *label29 greaterThanEq *tmp62 :maximum
   139 op mul :maximum 1.5 :newMax
-    * jump *label30 always
   140 label *label29
   141 label *label30
   142 write :maximum .COORD .POSITION

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    12 draw stroke 1
    13 set .INDEX 256
    14 set .SIZE 511
-    * op sub *tmp0 .SIZE .INDEX
-    * op sub .SKIP_SIZE *tmp0 1
-    * op mul .SHIFT .POSITION 30
-    * read *tmp4 .MEMORY .INDEX
-    * op sub :ptr *tmp4 .SHIFT
-    * jump *label0 greaterThanEq :ptr .INDEX
-    * op add :ptr :ptr .SKIP_SIZE
+   15 op sub *tmp0 511 256
+   16 op sub .SKIP_SIZE 255 1
+   17 op mul .SHIFT 0 30
+   18 read *tmp4 bank1 256
+   19 op sub :ptr *tmp4 0
+   20 jump *label0 greaterThanEq :ptr 256
+   21 op add :ptr :ptr 254
    22 label *label0
    23 label *label1
-    * read :maximum .MEMORY :ptr
+   24 read :maximum bank1 :ptr
    25 set :n 0
    26 label *label2
    27 jump *label4 greaterThanEq :n 29
    28 op sub :ptr :ptr 1
-    * jump *label5 greaterThan :ptr .INDEX
-    * op sub :ptr .SIZE 1
+   29 jump *label5 greaterThan :ptr 256
+   30 op sub :ptr 511 1
    31 label *label5
    32 label *label6
-    * read *tmp15 .MEMORY :ptr
+   33 read *tmp15 bank1 :ptr
    34 op max :maximum :maximum *tmp15
    35 label *label3
    36 op add :n :n 1
    37 jump *label2 always
    38 label *label4
-    * op mul :maximum :maximum .SMOOTH
+   39 op mul :maximum :maximum 3
    40 label *label7
    41 sensor *tmp18 switch1 @enabled
    42 jump *label9 notEqual *tmp18 0
    43 print "Item Rate Display"
    44 set :start @time
-    * sensor *tmp21 .COORD @dead
+   45 sensor *tmp21 cell1 @dead
    46 jump *label10 notEqual *tmp21 0
    47 set :n 0
    48 label *label12
-    * jump *label14 greaterThanEq :n .TOTAL
-    * read :m .COORD :n
+   49 jump *label14 greaterThanEq :n 1
+   50 read :m cell1 :n
    51 print "\n"
    52 print "Coord: [gold]"
    53 print :m
 
    76 draw clear 0 0 80
    77 draw color 0 80 0 255
    78 draw rect 10 10 156 156
-    * read *tmp32 .MEMORY .INDEX
-    * op sub :head *tmp32 .SHIFT
-    * jump *label15 greaterThanEq :head .INDEX
-    * op add :head :head .SKIP_SIZE
+   79 read *tmp32 bank1 256
+   80 op sub :head *tmp32 0
+   81 jump *label15 greaterThanEq :head 256
+   82 op add :head :head 254
    83 label *label15
    84 label *label16
    85 set :tail :head
    86 set :value 0
    87 set :i 0
    88 label *label17
-    * jump *label19 greaterThanEq :i .SMOOTH
-    * read *tmp38 .MEMORY :head
+   89 jump *label19 greaterThanEq :i 3
+   90 read *tmp38 bank1 :head
    91 op add :value :value *tmp38
    92 op sub :head :head 1
-    * jump *label20 greaterThan :head .INDEX
-    * op sub :head .SIZE 1
+   93 jump *label20 greaterThan :head 256
+   94 op sub :head 511 1
    95 label *label20
    96 label *label21
    97 label *label18
 
   106 set :n 0
   107 label *label22
   108 jump *label24 greaterThanEq :n 29
-    * read :t .MEMORY :tail
-    * read :h .MEMORY :head
+  109 read :t bank1 :tail
+  110 read :h bank1 :head
   111 op sub *tmp48 :value :t
   112 op add :value *tmp48 :h
   113 op sub :head :head 1
-    * jump *label25 greaterThan :head .INDEX
-    * op sub :head .SIZE 1
+  114 jump *label25 greaterThan :head 256
+  115 op sub :head 511 1
   116 label *label25
   117 label *label26
   118 op sub :tail :tail 1
-    * jump *label27 greaterThan :tail .INDEX
-    * op sub :tail .SIZE 1
+  119 jump *label27 greaterThan :tail 256
+  120 op sub :tail 511 1
   121 label *label27
   122 label *label28
   123 op mul *tmp56 :value :scale
 
   139 op mul :maximum 1.5 :newMax
   140 label *label29
   141 label *label30
-    * write :maximum .COORD .POSITION
+  142 write :maximum cell1 0
   143 op sub *tmp68 @time :start
   144 op floor *tmp69 *tmp68
   145 print "\n"
 
   147 print *tmp69
   148 print " "
   149 print "ms"
-    * op div *tmp70 @time .FREQ
+  150 op div *tmp70 @time 1000
   151 op ceil *tmp71 *tmp70
-    * op mul :wait .FREQ *tmp71
+  152 op mul :wait 1000 *tmp71
   153 set :loops 0
   154 label *label31
   155 jump *label33 greaterThanEq @time :wait

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-11 instructions):
-    * set .MEMORY bank1
-    * set .COORD cell1
-    * set .SMOOTH 3
-    * set .POSITION 0
-    * set .TOTAL 1
-    * set .FREQ 1000
     0 printflush message1
     1 print "Item Rate Display"
     2 print "\n"
 
     4 print "\n"
     5 printflush message1
     6 draw stroke 1
-    * set .INDEX 256
-    * set .SIZE 511
-    * op sub *tmp0 511 256
-    * op sub .SKIP_SIZE 255 1
-    * op mul .SHIFT 0 30
     7 read *tmp4 bank1 256
     8 op sub :ptr *tmp4 0
     9 jump *label0 greaterThanEq :ptr 256
-    * op add :ptr :ptr 254
+   10 op add :ptr *tmp4 254
    11 label *label0
    12 label *label1
    13 read :maximum bank1 :ptr
 
    68 read *tmp32 bank1 256
    69 op sub :head *tmp32 0
    70 jump *label15 greaterThanEq :head 256
-    * op add :head :head 254
+   71 op add :head *tmp32 254
    72 label *label15
    73 label *label16
    74 set :tail :head

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-4 instructions):
 
    13 read :maximum bank1 :ptr
    14 set :n 0
    15 label *label2
-    * jump *label4 greaterThanEq :n 29
+   16 label *label34
    17 op sub :ptr :ptr 1
    18 jump *label5 greaterThan :ptr 256
    19 op sub :ptr 511 1
 
    23 op max :maximum :maximum *tmp15
    24 label *label3
    25 op add :n :n 1
-    * jump *label2 always
+   26 jump *label34 lessThan :n 29
    27 label *label4
    28 op mul :maximum :maximum 3
    29 label *label7
 
    35 jump *label10 notEqual *tmp21 0
    36 set :n 0
    37 label *label12
-    * jump *label14 greaterThanEq :n 1
+   38 label *label35
    39 read :m cell1 :n
    40 print "\n"
    41 print "Coord: [gold]"
 
    45 op max :maximum :maximum :m
    46 label *label13
    47 op add :n :n 1
-    * jump *label12 always
+   48 jump *label35 lessThan :n 1
    49 label *label14
    50 label *label10
    51 label *label11
 
    75 set :value 0
    76 set :i 0
    77 label *label17
-    * jump *label19 greaterThanEq :i 3
+   78 label *label36
    79 read *tmp38 bank1 :head
    80 op add :value :value *tmp38
    81 op sub :head :head 1
 
    85 label *label21
    86 label *label18
    87 op add :i :i 1
-    * jump *label17 always
+   88 jump *label36 lessThan :i 3
    89 label *label19
    90 op mul *tmp42 :value :scale
    91 op add :last 10 *tmp42
 
    94 set :x 159
    95 set :n 0
    96 label *label22
-    * jump *label24 greaterThanEq :n 29
+   97 label *label37
    98 read :t bank1 :tail
    99 read :h bank1 :head
   100 op sub *tmp48 :value :t
 
   118 op max :newMax :newMax :value
   119 label *label23
   120 op add :n :n 1
-    * jump *label22 always
+  121 jump *label37 lessThan :n 29
   122 label *label24
   123 draw color 255 255 255 255
   124 draw lineRect 10 10 156 156
 
   142 set :loops 0
   143 label *label31
   144 jump *label33 greaterThanEq @time :wait
+  145 label *label38
   146 op add :loops :loops 1
   147 label *label32
-    * jump *label31 always
+  148 jump *label38 lessThan @time :wait
   149 label *label33
   150 drawflush display1
   151 print "\nLoops: "

Modifications by Unroll loop at line 36:9 (-1 instructions):
 
    33 set :start @time
    34 sensor *tmp21 cell1 @dead
    35 jump *label10 notEqual *tmp21 0
-    * set :n 0
-    * label *label12
-    * label *label35
-    * read :m cell1 :n
-    * print "\n"
-    * print "Coord: [gold]"
-    * print :m
-    * print "["
-    * print "]"
-    * op max :maximum :maximum :m
-    * label *label13
-    * op add :n :n 1
-    * jump *label35 lessThan :n 1
-    * label *label14
+   36 set :n 0
+   37 label *label39
+   38 label *label40
+   39 read :m cell1 :n
+   40 print "\n"
+   41 print "Coord: [gold]"
+   42 print :m
+   43 print "["
+   44 print "]"
+   45 op max :maximum :maximum :m
+   46 label *label41
+   47 op add :n :n 1
+   48 label *label14
    49 label *label10
    50 label *label11
    51 op div :scale 150 :maximum

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    36 set :n 0
    37 label *label39
    38 label *label40
-    * read :m cell1 :n
+   39 read :m cell1 0
    40 print "\n"
    41 print "Coord: [gold]"
    42 print :m
 
    44 print "]"
    45 op max :maximum :maximum :m
    46 label *label41
-    * op add :n :n 1
+   47 op add :n 0 1
    48 label *label14
    49 label *label10
    50 label *label11

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    33 set :start @time
    34 sensor *tmp21 cell1 @dead
    35 jump *label10 notEqual *tmp21 0
-    * set :n 0
    36 label *label39
    37 label *label40
    38 read :m cell1 0
 
    43 print "]"
    44 op max :maximum :maximum :m
    45 label *label41
-    * op add :n 0 1
    46 label *label14
    47 label *label10
    48 label *label11

Modifications by Unroll loop at line 55:5 (+11 instructions):
 
    70 label *label16
    71 set :tail :head
    72 set :value 0
-    * set :i 0
-    * label *label17
-    * label *label36
-    * read *tmp38 bank1 :head
-    * op add :value :value *tmp38
-    * op sub :head :head 1
-    * jump *label20 greaterThan :head 256
-    * op sub :head 511 1
-    * label *label20
-    * label *label21
-    * label *label18
-    * op add :i :i 1
-    * jump *label36 lessThan :i 3
-    * label *label19
+   73 set :i 0
+   74 label *label42
+   75 label *label43
+   76 read *tmp38 bank1 :head
+   77 op add :value :value *tmp38
+   78 op sub :head :head 1
+   79 jump *label44 greaterThan :head 256
+   80 op sub :head 511 1
+   81 label *label44
+   82 label *label45
+   83 label *label46
+   84 op add :i :i 1
+   85 label *label47
+   86 read *tmp38 bank1 :head
+   87 op add :value :value *tmp38
+   88 op sub :head :head 1
+   89 jump *label48 greaterThan :head 256
+   90 op sub :head 511 1
+   91 label *label48
+   92 label *label49
+   93 label *label50
+   94 op add :i :i 1
+   95 label *label51
+   96 read *tmp38 bank1 :head
+   97 op add :value :value *tmp38
+   98 op sub :head :head 1
+   99 jump *label52 greaterThan :head 256
+  100 op sub :head 511 1
+  101 label *label52
+  102 label *label53
+  103 label *label54
+  104 op add :i :i 1
+  105 label *label19
   106 op mul *tmp42 :value :scale
   107 op add :last 10 *tmp42
   108 set :newMax :value

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    74 label *label42
    75 label *label43
    76 read *tmp38 bank1 :head
-    * op add :value :value *tmp38
+   77 op add :value 0 *tmp38
    78 op sub :head :head 1
    79 jump *label44 greaterThan :head 256
    80 op sub :head 511 1
    81 label *label44
    82 label *label45
    83 label *label46
-    * op add :i :i 1
+   84 op add :i 0 1
    85 label *label47
    86 read *tmp38 bank1 :head
    87 op add :value :value *tmp38
 
    91 label *label48
    92 label *label49
    93 label *label50
-    * op add :i :i 1
+   94 op add :i 1 1
    95 label *label51
    96 read *tmp38 bank1 :head
    97 op add :value :value *tmp38
 
   101 label *label52
   102 label *label53
   103 label *label54
-    * op add :i :i 1
+  104 op add :i 2 1
   105 label *label19
   106 op mul *tmp42 :value :scale
   107 op add :last 10 *tmp42

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    69 label *label15
    70 label *label16
    71 set :tail :head
-    * set :value 0
-    * set :i 0
    72 label *label42
    73 label *label43
    74 read *tmp38 bank1 :head
 
    79 label *label44
    80 label *label45
    81 label *label46
-    * op add :i 0 1
    82 label *label47
    83 read *tmp38 bank1 :head
    84 op add :value :value *tmp38
 
    88 label *label48
    89 label *label49
    90 label *label50
-    * op add :i 1 1
    91 label *label51
    92 read *tmp38 bank1 :head
    93 op add :value :value *tmp38
 
    97 label *label52
    98 label *label53
    99 label *label54
-    * op add :i 2 1
   100 label *label19
   101 op mul *tmp42 :value :scale
   102 op add :last 10 *tmp42

Modifications by Unroll loop at line 65:5 (+503 instructions):
 
   103 set :newMax :value
   104 draw color 80 255 80 255
   105 set :x 159
-    * set :n 0
-    * label *label22
-    * label *label37
-    * read :t bank1 :tail
-    * read :h bank1 :head
-    * op sub *tmp48 :value :t
-    * op add :value *tmp48 :h
-    * op sub :head :head 1
-    * jump *label25 greaterThan :head 256
-    * op sub :head 511 1
-    * label *label25
-    * label *label26
-    * op sub :tail :tail 1
-    * jump *label27 greaterThan :tail 256
-    * op sub :tail 511 1
-    * label *label27
-    * label *label28
-    * op mul *tmp56 :value :scale
-    * op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
-    * set :last :y
-    * op max :newMax :newMax :value
-    * label *label23
-    * op add :n :n 1
-    * jump *label37 lessThan :n 29
-    * label *label24
+  106 set :n 0
+  107 label *label55
+  108 label *label56
+  109 read :t bank1 :tail
+  110 read :h bank1 :head
+  111 op sub *tmp48 :value :t
+  112 op add :value *tmp48 :h
+  113 op sub :head :head 1
+  114 jump *label57 greaterThan :head 256
+  115 op sub :head 511 1
+  116 label *label57
+  117 label *label58
+  118 op sub :tail :tail 1
+  119 jump *label59 greaterThan :tail 256
+  120 op sub :tail 511 1
+  121 label *label59
+  122 label *label60
+  123 op mul *tmp56 :value :scale
+  124 op add :y 10 *tmp56
+  125 op sub *tmp58 :x 5
+  126 draw line :x :last *tmp58 :y
+  127 op sub :x :x 5
+  128 set :last :y
+  129 op max :newMax :newMax :value
+  130 label *label61
+  131 op add :n :n 1
+  132 label *label62
+  133 read :t bank1 :tail
+  134 read :h bank1 :head
+  135 op sub *tmp48 :value :t
+  136 op add :value *tmp48 :h
+  137 op sub :head :head 1
+  138 jump *label63 greaterThan :head 256
+  139 op sub :head 511 1
+  140 label *label63
+  141 label *label64
+  142 op sub :tail :tail 1
+  143 jump *label65 greaterThan :tail 256
+  144 op sub :tail 511 1
+  145 label *label65
+  146 label *label66
+  147 op mul *tmp56 :value :scale
+  148 op add :y 10 *tmp56
+  149 op sub *tmp58 :x 5
+  150 draw line :x :last *tmp58 :y
+  151 op sub :x :x 5
+  152 set :last :y
+  153 op max :newMax :newMax :value
+  154 label *label67
+  155 op add :n :n 1
+  156 label *label68
+  157 read :t bank1 :tail
+  158 read :h bank1 :head
+  159 op sub *tmp48 :value :t
+  160 op add :value *tmp48 :h
+  161 op sub :head :head 1
+  162 jump *label69 greaterThan :head 256
+  163 op sub :head 511 1
+  164 label *label69
+  165 label *label70
+  166 op sub :tail :tail 1
+  167 jump *label71 greaterThan :tail 256
+  168 op sub :tail 511 1
+  169 label *label71
+  170 label *label72
+  171 op mul *tmp56 :value :scale
+  172 op add :y 10 *tmp56
+  173 op sub *tmp58 :x 5
+  174 draw line :x :last *tmp58 :y
+  175 op sub :x :x 5
+  176 set :last :y
+  177 op max :newMax :newMax :value
+  178 label *label73
+  179 op add :n :n 1
+  180 label *label74
+  181 read :t bank1 :tail
+  182 read :h bank1 :head
+  183 op sub *tmp48 :value :t
+  184 op add :value *tmp48 :h
+  185 op sub :head :head 1
+  186 jump *label75 greaterThan :head 256
+  187 op sub :head 511 1
+  188 label *label75
+  189 label *label76
+  190 op sub :tail :tail 1
+  191 jump *label77 greaterThan :tail 256
+  192 op sub :tail 511 1
+  193 label *label77
+  194 label *label78
+  195 op mul *tmp56 :value :scale
+  196 op add :y 10 *tmp56
+  197 op sub *tmp58 :x 5
+  198 draw line :x :last *tmp58 :y
+  199 op sub :x :x 5
+  200 set :last :y
+  201 op max :newMax :newMax :value
+  202 label *label79
+  203 op add :n :n 1
+  204 label *label80
+  205 read :t bank1 :tail
+  206 read :h bank1 :head
+  207 op sub *tmp48 :value :t
+  208 op add :value *tmp48 :h
+  209 op sub :head :head 1
+  210 jump *label81 greaterThan :head 256
+  211 op sub :head 511 1
+  212 label *label81
+  213 label *label82
+  214 op sub :tail :tail 1
+  215 jump *label83 greaterThan :tail 256
+  216 op sub :tail 511 1
+  217 label *label83
+  218 label *label84
+  219 op mul *tmp56 :value :scale
+  220 op add :y 10 *tmp56
+  221 op sub *tmp58 :x 5
+  222 draw line :x :last *tmp58 :y
+  223 op sub :x :x 5
+  224 set :last :y
+  225 op max :newMax :newMax :value
+  226 label *label85
+  227 op add :n :n 1
+  228 label *label86
+  229 read :t bank1 :tail
+  230 read :h bank1 :head
+  231 op sub *tmp48 :value :t
+  232 op add :value *tmp48 :h
+  233 op sub :head :head 1
+  234 jump *label87 greaterThan :head 256
+  235 op sub :head 511 1
+  236 label *label87
+  237 label *label88
+  238 op sub :tail :tail 1
+  239 jump *label89 greaterThan :tail 256
+  240 op sub :tail 511 1
+  241 label *label89
+  242 label *label90
+  243 op mul *tmp56 :value :scale
+  244 op add :y 10 *tmp56
+  245 op sub *tmp58 :x 5
+  246 draw line :x :last *tmp58 :y
+  247 op sub :x :x 5
+  248 set :last :y
+  249 op max :newMax :newMax :value
+  250 label *label91
+  251 op add :n :n 1
+  252 label *label92
+  253 read :t bank1 :tail
+  254 read :h bank1 :head
+  255 op sub *tmp48 :value :t
+  256 op add :value *tmp48 :h
+  257 op sub :head :head 1
+  258 jump *label93 greaterThan :head 256
+  259 op sub :head 511 1
+  260 label *label93
+  261 label *label94
+  262 op sub :tail :tail 1
+  263 jump *label95 greaterThan :tail 256
+  264 op sub :tail 511 1
+  265 label *label95
+  266 label *label96
+  267 op mul *tmp56 :value :scale
+  268 op add :y 10 *tmp56
+  269 op sub *tmp58 :x 5
+  270 draw line :x :last *tmp58 :y
+  271 op sub :x :x 5
+  272 set :last :y
+  273 op max :newMax :newMax :value
+  274 label *label97
+  275 op add :n :n 1
+  276 label *label98
+  277 read :t bank1 :tail
+  278 read :h bank1 :head
+  279 op sub *tmp48 :value :t
+  280 op add :value *tmp48 :h
+  281 op sub :head :head 1
+  282 jump *label99 greaterThan :head 256
+  283 op sub :head 511 1
+  284 label *label99
+  285 label *label100
+  286 op sub :tail :tail 1
+  287 jump *label101 greaterThan :tail 256
+  288 op sub :tail 511 1
+  289 label *label101
+  290 label *label102
+  291 op mul *tmp56 :value :scale
+  292 op add :y 10 *tmp56
+  293 op sub *tmp58 :x 5
+  294 draw line :x :last *tmp58 :y
+  295 op sub :x :x 5
+  296 set :last :y
+  297 op max :newMax :newMax :value
+  298 label *label103
+  299 op add :n :n 1
+  300 label *label104
+  301 read :t bank1 :tail
+  302 read :h bank1 :head
+  303 op sub *tmp48 :value :t
+  304 op add :value *tmp48 :h
+  305 op sub :head :head 1
+  306 jump *label105 greaterThan :head 256
+  307 op sub :head 511 1
+  308 label *label105
+  309 label *label106
+  310 op sub :tail :tail 1
+  311 jump *label107 greaterThan :tail 256
+  312 op sub :tail 511 1
+  313 label *label107
+  314 label *label108
+  315 op mul *tmp56 :value :scale
+  316 op add :y 10 *tmp56
+  317 op sub *tmp58 :x 5
+  318 draw line :x :last *tmp58 :y
+  319 op sub :x :x 5
+  320 set :last :y
+  321 op max :newMax :newMax :value
+  322 label *label109
+  323 op add :n :n 1
+  324 label *label110
+  325 read :t bank1 :tail
+  326 read :h bank1 :head
+  327 op sub *tmp48 :value :t
+  328 op add :value *tmp48 :h
+  329 op sub :head :head 1
+  330 jump *label111 greaterThan :head 256
+  331 op sub :head 511 1
+  332 label *label111
+  333 label *label112
+  334 op sub :tail :tail 1
+  335 jump *label113 greaterThan :tail 256
+  336 op sub :tail 511 1
+  337 label *label113
+  338 label *label114
+  339 op mul *tmp56 :value :scale
+  340 op add :y 10 *tmp56
+  341 op sub *tmp58 :x 5
+  342 draw line :x :last *tmp58 :y
+  343 op sub :x :x 5
+  344 set :last :y
+  345 op max :newMax :newMax :value
+  346 label *label115
+  347 op add :n :n 1
+  348 label *label116
+  349 read :t bank1 :tail
+  350 read :h bank1 :head
+  351 op sub *tmp48 :value :t
+  352 op add :value *tmp48 :h
+  353 op sub :head :head 1
+  354 jump *label117 greaterThan :head 256
+  355 op sub :head 511 1
+  356 label *label117
+  357 label *label118
+  358 op sub :tail :tail 1
+  359 jump *label119 greaterThan :tail 256
+  360 op sub :tail 511 1
+  361 label *label119
+  362 label *label120
+  363 op mul *tmp56 :value :scale
+  364 op add :y 10 *tmp56
+  365 op sub *tmp58 :x 5
+  366 draw line :x :last *tmp58 :y
+  367 op sub :x :x 5
+  368 set :last :y
+  369 op max :newMax :newMax :value
+  370 label *label121
+  371 op add :n :n 1
+  372 label *label122
+  373 read :t bank1 :tail
+  374 read :h bank1 :head
+  375 op sub *tmp48 :value :t
+  376 op add :value *tmp48 :h
+  377 op sub :head :head 1
+  378 jump *label123 greaterThan :head 256
+  379 op sub :head 511 1
+  380 label *label123
+  381 label *label124
+  382 op sub :tail :tail 1
+  383 jump *label125 greaterThan :tail 256
+  384 op sub :tail 511 1
+  385 label *label125
+  386 label *label126
+  387 op mul *tmp56 :value :scale
+  388 op add :y 10 *tmp56
+  389 op sub *tmp58 :x 5
+  390 draw line :x :last *tmp58 :y
+  391 op sub :x :x 5
+  392 set :last :y
+  393 op max :newMax :newMax :value
+  394 label *label127
+  395 op add :n :n 1
+  396 label *label128
+  397 read :t bank1 :tail
+  398 read :h bank1 :head
+  399 op sub *tmp48 :value :t
+  400 op add :value *tmp48 :h
+  401 op sub :head :head 1
+  402 jump *label129 greaterThan :head 256
+  403 op sub :head 511 1
+  404 label *label129
+  405 label *label130
+  406 op sub :tail :tail 1
+  407 jump *label131 greaterThan :tail 256
+  408 op sub :tail 511 1
+  409 label *label131
+  410 label *label132
+  411 op mul *tmp56 :value :scale
+  412 op add :y 10 *tmp56
+  413 op sub *tmp58 :x 5
+  414 draw line :x :last *tmp58 :y
+  415 op sub :x :x 5
+  416 set :last :y
+  417 op max :newMax :newMax :value
+  418 label *label133
+  419 op add :n :n 1
+  420 label *label134
+  421 read :t bank1 :tail
+  422 read :h bank1 :head
+  423 op sub *tmp48 :value :t
+  424 op add :value *tmp48 :h
+  425 op sub :head :head 1
+  426 jump *label135 greaterThan :head 256
+  427 op sub :head 511 1
+  428 label *label135
+  429 label *label136
+  430 op sub :tail :tail 1
+  431 jump *label137 greaterThan :tail 256
+  432 op sub :tail 511 1
+  433 label *label137
+  434 label *label138
+  435 op mul *tmp56 :value :scale
+  436 op add :y 10 *tmp56
+  437 op sub *tmp58 :x 5
+  438 draw line :x :last *tmp58 :y
+  439 op sub :x :x 5
+  440 set :last :y
+  441 op max :newMax :newMax :value
+  442 label *label139
+  443 op add :n :n 1
+  444 label *label140
+  445 read :t bank1 :tail
+  446 read :h bank1 :head
+  447 op sub *tmp48 :value :t
+  448 op add :value *tmp48 :h
+  449 op sub :head :head 1
+  450 jump *label141 greaterThan :head 256
+  451 op sub :head 511 1
+  452 label *label141
+  453 label *label142
+  454 op sub :tail :tail 1
+  455 jump *label143 greaterThan :tail 256
+  456 op sub :tail 511 1
+  457 label *label143
+  458 label *label144
+  459 op mul *tmp56 :value :scale
+  460 op add :y 10 *tmp56
+  461 op sub *tmp58 :x 5
+  462 draw line :x :last *tmp58 :y
+  463 op sub :x :x 5
+  464 set :last :y
+  465 op max :newMax :newMax :value
+  466 label *label145
+  467 op add :n :n 1
+  468 label *label146
+  469 read :t bank1 :tail
+  470 read :h bank1 :head
+  471 op sub *tmp48 :value :t
+  472 op add :value *tmp48 :h
+  473 op sub :head :head 1
+  474 jump *label147 greaterThan :head 256
+  475 op sub :head 511 1
+  476 label *label147
+  477 label *label148
+  478 op sub :tail :tail 1
+  479 jump *label149 greaterThan :tail 256
+  480 op sub :tail 511 1
+  481 label *label149
+  482 label *label150
+  483 op mul *tmp56 :value :scale
+  484 op add :y 10 *tmp56
+  485 op sub *tmp58 :x 5
+  486 draw line :x :last *tmp58 :y
+  487 op sub :x :x 5
+  488 set :last :y
+  489 op max :newMax :newMax :value
+  490 label *label151
+  491 op add :n :n 1
+  492 label *label152
+  493 read :t bank1 :tail
+  494 read :h bank1 :head
+  495 op sub *tmp48 :value :t
+  496 op add :value *tmp48 :h
+  497 op sub :head :head 1
+  498 jump *label153 greaterThan :head 256
+  499 op sub :head 511 1
+  500 label *label153
+  501 label *label154
+  502 op sub :tail :tail 1
+  503 jump *label155 greaterThan :tail 256
+  504 op sub :tail 511 1
+  505 label *label155
+  506 label *label156
+  507 op mul *tmp56 :value :scale
+  508 op add :y 10 *tmp56
+  509 op sub *tmp58 :x 5
+  510 draw line :x :last *tmp58 :y
+  511 op sub :x :x 5
+  512 set :last :y
+  513 op max :newMax :newMax :value
+  514 label *label157
+  515 op add :n :n 1
+  516 label *label158
+  517 read :t bank1 :tail
+  518 read :h bank1 :head
+  519 op sub *tmp48 :value :t
+  520 op add :value *tmp48 :h
+  521 op sub :head :head 1
+  522 jump *label159 greaterThan :head 256
+  523 op sub :head 511 1
+  524 label *label159
+  525 label *label160
+  526 op sub :tail :tail 1
+  527 jump *label161 greaterThan :tail 256
+  528 op sub :tail 511 1
+  529 label *label161
+  530 label *label162
+  531 op mul *tmp56 :value :scale
+  532 op add :y 10 *tmp56
+  533 op sub *tmp58 :x 5
+  534 draw line :x :last *tmp58 :y
+  535 op sub :x :x 5
+  536 set :last :y
+  537 op max :newMax :newMax :value
+  538 label *label163
+  539 op add :n :n 1
+  540 label *label164
+  541 read :t bank1 :tail
+  542 read :h bank1 :head
+  543 op sub *tmp48 :value :t
+  544 op add :value *tmp48 :h
+  545 op sub :head :head 1
+  546 jump *label165 greaterThan :head 256
+  547 op sub :head 511 1
+  548 label *label165
+  549 label *label166
+  550 op sub :tail :tail 1
+  551 jump *label167 greaterThan :tail 256
+  552 op sub :tail 511 1
+  553 label *label167
+  554 label *label168
+  555 op mul *tmp56 :value :scale
+  556 op add :y 10 *tmp56
+  557 op sub *tmp58 :x 5
+  558 draw line :x :last *tmp58 :y
+  559 op sub :x :x 5
+  560 set :last :y
+  561 op max :newMax :newMax :value
+  562 label *label169
+  563 op add :n :n 1
+  564 label *label170
+  565 read :t bank1 :tail
+  566 read :h bank1 :head
+  567 op sub *tmp48 :value :t
+  568 op add :value *tmp48 :h
+  569 op sub :head :head 1
+  570 jump *label171 greaterThan :head 256
+  571 op sub :head 511 1
+  572 label *label171
+  573 label *label172
+  574 op sub :tail :tail 1
+  575 jump *label173 greaterThan :tail 256
+  576 op sub :tail 511 1
+  577 label *label173
+  578 label *label174
+  579 op mul *tmp56 :value :scale
+  580 op add :y 10 *tmp56
+  581 op sub *tmp58 :x 5
+  582 draw line :x :last *tmp58 :y
+  583 op sub :x :x 5
+  584 set :last :y
+  585 op max :newMax :newMax :value
+  586 label *label175
+  587 op add :n :n 1
+  588 label *label176
+  589 read :t bank1 :tail
+  590 read :h bank1 :head
+  591 op sub *tmp48 :value :t
+  592 op add :value *tmp48 :h
+  593 op sub :head :head 1
+  594 jump *label177 greaterThan :head 256
+  595 op sub :head 511 1
+  596 label *label177
+  597 label *label178
+  598 op sub :tail :tail 1
+  599 jump *label179 greaterThan :tail 256
+  600 op sub :tail 511 1
+  601 label *label179
+  602 label *label180
+  603 op mul *tmp56 :value :scale
+  604 op add :y 10 *tmp56
+  605 op sub *tmp58 :x 5
+  606 draw line :x :last *tmp58 :y
+  607 op sub :x :x 5
+  608 set :last :y
+  609 op max :newMax :newMax :value
+  610 label *label181
+  611 op add :n :n 1
+  612 label *label182
+  613 read :t bank1 :tail
+  614 read :h bank1 :head
+  615 op sub *tmp48 :value :t
+  616 op add :value *tmp48 :h
+  617 op sub :head :head 1
+  618 jump *label183 greaterThan :head 256
+  619 op sub :head 511 1
+  620 label *label183
+  621 label *label184
+  622 op sub :tail :tail 1
+  623 jump *label185 greaterThan :tail 256
+  624 op sub :tail 511 1
+  625 label *label185
+  626 label *label186
+  627 op mul *tmp56 :value :scale
+  628 op add :y 10 *tmp56
+  629 op sub *tmp58 :x 5
+  630 draw line :x :last *tmp58 :y
+  631 op sub :x :x 5
+  632 set :last :y
+  633 op max :newMax :newMax :value
+  634 label *label187
+  635 op add :n :n 1
+  636 label *label188
+  637 read :t bank1 :tail
+  638 read :h bank1 :head
+  639 op sub *tmp48 :value :t
+  640 op add :value *tmp48 :h
+  641 op sub :head :head 1
+  642 jump *label189 greaterThan :head 256
+  643 op sub :head 511 1
+  644 label *label189
+  645 label *label190
+  646 op sub :tail :tail 1
+  647 jump *label191 greaterThan :tail 256
+  648 op sub :tail 511 1
+  649 label *label191
+  650 label *label192
+  651 op mul *tmp56 :value :scale
+  652 op add :y 10 *tmp56
+  653 op sub *tmp58 :x 5
+  654 draw line :x :last *tmp58 :y
+  655 op sub :x :x 5
+  656 set :last :y
+  657 op max :newMax :newMax :value
+  658 label *label193
+  659 op add :n :n 1
+  660 label *label194
+  661 read :t bank1 :tail
+  662 read :h bank1 :head
+  663 op sub *tmp48 :value :t
+  664 op add :value *tmp48 :h
+  665 op sub :head :head 1
+  666 jump *label195 greaterThan :head 256
+  667 op sub :head 511 1
+  668 label *label195
+  669 label *label196
+  670 op sub :tail :tail 1
+  671 jump *label197 greaterThan :tail 256
+  672 op sub :tail 511 1
+  673 label *label197
+  674 label *label198
+  675 op mul *tmp56 :value :scale
+  676 op add :y 10 *tmp56
+  677 op sub *tmp58 :x 5
+  678 draw line :x :last *tmp58 :y
+  679 op sub :x :x 5
+  680 set :last :y
+  681 op max :newMax :newMax :value
+  682 label *label199
+  683 op add :n :n 1
+  684 label *label200
+  685 read :t bank1 :tail
+  686 read :h bank1 :head
+  687 op sub *tmp48 :value :t
+  688 op add :value *tmp48 :h
+  689 op sub :head :head 1
+  690 jump *label201 greaterThan :head 256
+  691 op sub :head 511 1
+  692 label *label201
+  693 label *label202
+  694 op sub :tail :tail 1
+  695 jump *label203 greaterThan :tail 256
+  696 op sub :tail 511 1
+  697 label *label203
+  698 label *label204
+  699 op mul *tmp56 :value :scale
+  700 op add :y 10 *tmp56
+  701 op sub *tmp58 :x 5
+  702 draw line :x :last *tmp58 :y
+  703 op sub :x :x 5
+  704 set :last :y
+  705 op max :newMax :newMax :value
+  706 label *label205
+  707 op add :n :n 1
+  708 label *label206
+  709 read :t bank1 :tail
+  710 read :h bank1 :head
+  711 op sub *tmp48 :value :t
+  712 op add :value *tmp48 :h
+  713 op sub :head :head 1
+  714 jump *label207 greaterThan :head 256
+  715 op sub :head 511 1
+  716 label *label207
+  717 label *label208
+  718 op sub :tail :tail 1
+  719 jump *label209 greaterThan :tail 256
+  720 op sub :tail 511 1
+  721 label *label209
+  722 label *label210
+  723 op mul *tmp56 :value :scale
+  724 op add :y 10 *tmp56
+  725 op sub *tmp58 :x 5
+  726 draw line :x :last *tmp58 :y
+  727 op sub :x :x 5
+  728 set :last :y
+  729 op max :newMax :newMax :value
+  730 label *label211
+  731 op add :n :n 1
+  732 label *label212
+  733 read :t bank1 :tail
+  734 read :h bank1 :head
+  735 op sub *tmp48 :value :t
+  736 op add :value *tmp48 :h
+  737 op sub :head :head 1
+  738 jump *label213 greaterThan :head 256
+  739 op sub :head 511 1
+  740 label *label213
+  741 label *label214
+  742 op sub :tail :tail 1
+  743 jump *label215 greaterThan :tail 256
+  744 op sub :tail 511 1
+  745 label *label215
+  746 label *label216
+  747 op mul *tmp56 :value :scale
+  748 op add :y 10 *tmp56
+  749 op sub *tmp58 :x 5
+  750 draw line :x :last *tmp58 :y
+  751 op sub :x :x 5
+  752 set :last :y
+  753 op max :newMax :newMax :value
+  754 label *label217
+  755 op add :n :n 1
+  756 label *label218
+  757 read :t bank1 :tail
+  758 read :h bank1 :head
+  759 op sub *tmp48 :value :t
+  760 op add :value *tmp48 :h
+  761 op sub :head :head 1
+  762 jump *label219 greaterThan :head 256
+  763 op sub :head 511 1
+  764 label *label219
+  765 label *label220
+  766 op sub :tail :tail 1
+  767 jump *label221 greaterThan :tail 256
+  768 op sub :tail 511 1
+  769 label *label221
+  770 label *label222
+  771 op mul *tmp56 :value :scale
+  772 op add :y 10 *tmp56
+  773 op sub *tmp58 :x 5
+  774 draw line :x :last *tmp58 :y
+  775 op sub :x :x 5
+  776 set :last :y
+  777 op max :newMax :newMax :value
+  778 label *label223
+  779 op add :n :n 1
+  780 label *label224
+  781 read :t bank1 :tail
+  782 read :h bank1 :head
+  783 op sub *tmp48 :value :t
+  784 op add :value *tmp48 :h
+  785 op sub :head :head 1
+  786 jump *label225 greaterThan :head 256
+  787 op sub :head 511 1
+  788 label *label225
+  789 label *label226
+  790 op sub :tail :tail 1
+  791 jump *label227 greaterThan :tail 256
+  792 op sub :tail 511 1
+  793 label *label227
+  794 label *label228
+  795 op mul *tmp56 :value :scale
+  796 op add :y 10 *tmp56
+  797 op sub *tmp58 :x 5
+  798 draw line :x :last *tmp58 :y
+  799 op sub :x :x 5
+  800 set :last :y
+  801 op max :newMax :newMax :value
+  802 label *label229
+  803 op add :n :n 1
+  804 label *label24
   805 draw color 255 255 255 255
   806 draw lineRect 10 10 156 156
   807 op max :maximum :newMax :maximum

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-3 instructions):
 
   122 label *label60
   123 op mul *tmp56 :value :scale
   124 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  125 op sub *tmp58 159 5
+  126 draw line 159 :last 154 :y
+  127 op sub :x 159 5
   128 set :last :y
   129 op max :newMax :newMax :value
   130 label *label61
-    * op add :n :n 1
+  131 op add :n 0 1
   132 label *label62
   133 read :t bank1 :tail
   134 read :h bank1 :head
 
   146 label *label66
   147 op mul *tmp56 :value :scale
   148 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  149 op sub *tmp58 154 5
+  150 draw line 154 :last 149 :y
+  151 op sub :x 154 5
   152 set :last :y
   153 op max :newMax :newMax :value
   154 label *label67
-    * op add :n :n 1
+  155 op add :n 1 1
   156 label *label68
   157 read :t bank1 :tail
   158 read :h bank1 :head
 
   170 label *label72
   171 op mul *tmp56 :value :scale
   172 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  173 op sub *tmp58 149 5
+  174 draw line 149 :last 144 :y
+  175 op sub :x 149 5
   176 set :last :y
   177 op max :newMax :newMax :value
   178 label *label73
-    * op add :n :n 1
+  179 op add :n 2 1
   180 label *label74
   181 read :t bank1 :tail
   182 read :h bank1 :head
 
   194 label *label78
   195 op mul *tmp56 :value :scale
   196 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  197 op sub *tmp58 144 5
+  198 draw line 144 :last 139 :y
+  199 op sub :x 144 5
   200 set :last :y
   201 op max :newMax :newMax :value
   202 label *label79
-    * op add :n :n 1
+  203 op add :n 3 1
   204 label *label80
   205 read :t bank1 :tail
   206 read :h bank1 :head
 
   218 label *label84
   219 op mul *tmp56 :value :scale
   220 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  221 op sub *tmp58 139 5
+  222 draw line 139 :last 134 :y
+  223 op sub :x 139 5
   224 set :last :y
   225 op max :newMax :newMax :value
   226 label *label85
-    * op add :n :n 1
+  227 op add :n 4 1
   228 label *label86
   229 read :t bank1 :tail
   230 read :h bank1 :head
 
   242 label *label90
   243 op mul *tmp56 :value :scale
   244 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  245 op sub *tmp58 134 5
+  246 draw line 134 :last 129 :y
+  247 op sub :x 134 5
   248 set :last :y
   249 op max :newMax :newMax :value
   250 label *label91
-    * op add :n :n 1
+  251 op add :n 5 1
   252 label *label92
   253 read :t bank1 :tail
   254 read :h bank1 :head
 
   266 label *label96
   267 op mul *tmp56 :value :scale
   268 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  269 op sub *tmp58 129 5
+  270 draw line 129 :last 124 :y
+  271 op sub :x 129 5
   272 set :last :y
   273 op max :newMax :newMax :value
   274 label *label97
-    * op add :n :n 1
+  275 op add :n 6 1
   276 label *label98
   277 read :t bank1 :tail
   278 read :h bank1 :head
 
   290 label *label102
   291 op mul *tmp56 :value :scale
   292 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  293 op sub *tmp58 124 5
+  294 draw line 124 :last 119 :y
+  295 op sub :x 124 5
   296 set :last :y
   297 op max :newMax :newMax :value
   298 label *label103
-    * op add :n :n 1
+  299 op add :n 7 1
   300 label *label104
   301 read :t bank1 :tail
   302 read :h bank1 :head
 
   314 label *label108
   315 op mul *tmp56 :value :scale
   316 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  317 op sub *tmp58 119 5
+  318 draw line 119 :last 114 :y
+  319 op sub :x 119 5
   320 set :last :y
   321 op max :newMax :newMax :value
   322 label *label109
-    * op add :n :n 1
+  323 op add :n 8 1
   324 label *label110
   325 read :t bank1 :tail
   326 read :h bank1 :head
 
   338 label *label114
   339 op mul *tmp56 :value :scale
   340 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  341 op sub *tmp58 114 5
+  342 draw line 114 :last 109 :y
+  343 op sub :x 114 5
   344 set :last :y
   345 op max :newMax :newMax :value
   346 label *label115
-    * op add :n :n 1
+  347 op add :n 9 1
   348 label *label116
   349 read :t bank1 :tail
   350 read :h bank1 :head
 
   362 label *label120
   363 op mul *tmp56 :value :scale
   364 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  365 op sub *tmp58 109 5
+  366 draw line 109 :last 104 :y
+  367 op sub :x 109 5
   368 set :last :y
   369 op max :newMax :newMax :value
   370 label *label121
-    * op add :n :n 1
+  371 op add :n 10 1
   372 label *label122
   373 read :t bank1 :tail
   374 read :h bank1 :head
 
   386 label *label126
   387 op mul *tmp56 :value :scale
   388 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  389 op sub *tmp58 104 5
+  390 draw line 104 :last 99 :y
+  391 op sub :x 104 5
   392 set :last :y
   393 op max :newMax :newMax :value
   394 label *label127
-    * op add :n :n 1
+  395 op add :n 11 1
   396 label *label128
   397 read :t bank1 :tail
   398 read :h bank1 :head
 
   410 label *label132
   411 op mul *tmp56 :value :scale
   412 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  413 op sub *tmp58 99 5
+  414 draw line 99 :last 94 :y
+  415 op sub :x 99 5
   416 set :last :y
   417 op max :newMax :newMax :value
   418 label *label133
-    * op add :n :n 1
+  419 op add :n 12 1
   420 label *label134
   421 read :t bank1 :tail
   422 read :h bank1 :head
 
   434 label *label138
   435 op mul *tmp56 :value :scale
   436 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  437 op sub *tmp58 94 5
+  438 draw line 94 :last 89 :y
+  439 op sub :x 94 5
   440 set :last :y
   441 op max :newMax :newMax :value
   442 label *label139
-    * op add :n :n 1
+  443 op add :n 13 1
   444 label *label140
   445 read :t bank1 :tail
   446 read :h bank1 :head
 
   458 label *label144
   459 op mul *tmp56 :value :scale
   460 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  461 op sub *tmp58 89 5
+  462 draw line 89 :last 84 :y
+  463 op sub :x 89 5
   464 set :last :y
   465 op max :newMax :newMax :value
   466 label *label145
-    * op add :n :n 1
+  467 op add :n 14 1
   468 label *label146
   469 read :t bank1 :tail
   470 read :h bank1 :head
 
   482 label *label150
   483 op mul *tmp56 :value :scale
   484 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  485 op sub *tmp58 84 5
+  486 draw line 84 :last 79 :y
+  487 op sub :x 84 5
   488 set :last :y
   489 op max :newMax :newMax :value
   490 label *label151
-    * op add :n :n 1
+  491 op add :n 15 1
   492 label *label152
   493 read :t bank1 :tail
   494 read :h bank1 :head
 
   506 label *label156
   507 op mul *tmp56 :value :scale
   508 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  509 op sub *tmp58 79 5
+  510 draw line 79 :last 74 :y
+  511 op sub :x 79 5
   512 set :last :y
   513 op max :newMax :newMax :value
   514 label *label157
-    * op add :n :n 1
+  515 op add :n 16 1
   516 label *label158
   517 read :t bank1 :tail
   518 read :h bank1 :head
 
   530 label *label162
   531 op mul *tmp56 :value :scale
   532 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  533 op sub *tmp58 74 5
+  534 draw line 74 :last 69 :y
+  535 op sub :x 74 5
   536 set :last :y
   537 op max :newMax :newMax :value
   538 label *label163
-    * op add :n :n 1
+  539 op add :n 17 1
   540 label *label164
   541 read :t bank1 :tail
   542 read :h bank1 :head
 
   554 label *label168
   555 op mul *tmp56 :value :scale
   556 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  557 op sub *tmp58 69 5
+  558 draw line 69 :last 64 :y
+  559 op sub :x 69 5
   560 set :last :y
   561 op max :newMax :newMax :value
   562 label *label169
-    * op add :n :n 1
+  563 op add :n 18 1
   564 label *label170
   565 read :t bank1 :tail
   566 read :h bank1 :head
 
   578 label *label174
   579 op mul *tmp56 :value :scale
   580 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  581 op sub *tmp58 64 5
+  582 draw line 64 :last 59 :y
+  583 op sub :x 64 5
   584 set :last :y
   585 op max :newMax :newMax :value
   586 label *label175
-    * op add :n :n 1
+  587 op add :n 19 1
   588 label *label176
   589 read :t bank1 :tail
   590 read :h bank1 :head
 
   602 label *label180
   603 op mul *tmp56 :value :scale
   604 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  605 op sub *tmp58 59 5
+  606 draw line 59 :last 54 :y
+  607 op sub :x 59 5
   608 set :last :y
   609 op max :newMax :newMax :value
   610 label *label181
-    * op add :n :n 1
+  611 op add :n 20 1
   612 label *label182
   613 read :t bank1 :tail
   614 read :h bank1 :head
 
   626 label *label186
   627 op mul *tmp56 :value :scale
   628 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  629 op sub *tmp58 54 5
+  630 draw line 54 :last 49 :y
+  631 op sub :x 54 5
   632 set :last :y
   633 op max :newMax :newMax :value
   634 label *label187
-    * op add :n :n 1
+  635 op add :n 21 1
   636 label *label188
   637 read :t bank1 :tail
   638 read :h bank1 :head
 
   650 label *label192
   651 op mul *tmp56 :value :scale
   652 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  653 op sub *tmp58 49 5
+  654 draw line 49 :last 44 :y
+  655 op sub :x 49 5
   656 set :last :y
   657 op max :newMax :newMax :value
   658 label *label193
-    * op add :n :n 1
+  659 op add :n 22 1
   660 label *label194
   661 read :t bank1 :tail
   662 read :h bank1 :head
 
   674 label *label198
   675 op mul *tmp56 :value :scale
   676 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  677 op sub *tmp58 44 5
+  678 draw line 44 :last 39 :y
+  679 op sub :x 44 5
   680 set :last :y
   681 op max :newMax :newMax :value
   682 label *label199
-    * op add :n :n 1
+  683 op add :n 23 1
   684 label *label200
   685 read :t bank1 :tail
   686 read :h bank1 :head
 
   698 label *label204
   699 op mul *tmp56 :value :scale
   700 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  701 op sub *tmp58 39 5
+  702 draw line 39 :last 34 :y
+  703 op sub :x 39 5
   704 set :last :y
   705 op max :newMax :newMax :value
   706 label *label205
-    * op add :n :n 1
+  707 op add :n 24 1
   708 label *label206
   709 read :t bank1 :tail
   710 read :h bank1 :head
 
   722 label *label210
   723 op mul *tmp56 :value :scale
   724 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  725 op sub *tmp58 34 5
+  726 draw line 34 :last 29 :y
+  727 op sub :x 34 5
   728 set :last :y
   729 op max :newMax :newMax :value
   730 label *label211
-    * op add :n :n 1
+  731 op add :n 25 1
   732 label *label212
   733 read :t bank1 :tail
   734 read :h bank1 :head
 
   746 label *label216
   747 op mul *tmp56 :value :scale
   748 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  749 op sub *tmp58 29 5
+  750 draw line 29 :last 24 :y
+  751 op sub :x 29 5
   752 set :last :y
   753 op max :newMax :newMax :value
   754 label *label217
-    * op add :n :n 1
+  755 op add :n 26 1
   756 label *label218
   757 read :t bank1 :tail
   758 read :h bank1 :head
 
   770 label *label222
   771 op mul *tmp56 :value :scale
   772 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
+  773 op sub *tmp58 24 5
+  774 draw line 24 :last 19 :y
+  775 op sub :x 24 5
   776 set :last :y
   777 op max :newMax :newMax :value
   778 label *label223
-    * op add :n :n 1
+  779 op add :n 27 1
   780 label *label224
   781 read :t bank1 :tail
   782 read :h bank1 :head
 
   784 op add :value *tmp48 :h
   785 op sub :head :head 1
   786 jump *label225 greaterThan :head 256
-    * op sub :head 511 1
   787 label *label225
   788 label *label226
   789 op sub :tail :tail 1
   790 jump *label227 greaterThan :tail 256
-    * op sub :tail 511 1
   791 label *label227
   792 label *label228
   793 op mul *tmp56 :value :scale
   794 op add :y 10 *tmp56
-    * op sub *tmp58 :x 5
-    * draw line :x :last *tmp58 :y
-    * op sub :x :x 5
-    * set :last :y
+  795 op sub *tmp58 19 5
+  796 draw line 19 :last 14 :y
+  797 op sub :x 19 5
   798 op max :newMax :newMax :value
   799 label *label229
-    * op add :n :n 1
+  800 op add :n 28 1
   801 label *label24
   802 draw color 255 255 255 255
   803 draw lineRect 10 10 156 156

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-89 instructions):
 
   102 op add :last 10 *tmp42
   103 set :newMax :value
   104 draw color 80 255 80 255
-    * set :x 159
-    * set :n 0
   105 label *label55
   106 label *label56
   107 read :t bank1 :tail
 
   120 label *label60
   121 op mul *tmp56 :value :scale
   122 op add :y 10 *tmp56
-    * op sub *tmp58 159 5
   123 draw line 159 :last 154 :y
-    * op sub :x 159 5
   124 set :last :y
   125 op max :newMax :newMax :value
   126 label *label61
-    * op add :n 0 1
   127 label *label62
   128 read :t bank1 :tail
   129 read :h bank1 :head
 
   141 label *label66
   142 op mul *tmp56 :value :scale
   143 op add :y 10 *tmp56
-    * op sub *tmp58 154 5
   144 draw line 154 :last 149 :y
-    * op sub :x 154 5
   145 set :last :y
   146 op max :newMax :newMax :value
   147 label *label67
-    * op add :n 1 1
   148 label *label68
   149 read :t bank1 :tail
   150 read :h bank1 :head
 
   162 label *label72
   163 op mul *tmp56 :value :scale
   164 op add :y 10 *tmp56
-    * op sub *tmp58 149 5
   165 draw line 149 :last 144 :y
-    * op sub :x 149 5
   166 set :last :y
   167 op max :newMax :newMax :value
   168 label *label73
-    * op add :n 2 1
   169 label *label74
   170 read :t bank1 :tail
   171 read :h bank1 :head
 
   183 label *label78
   184 op mul *tmp56 :value :scale
   185 op add :y 10 *tmp56
-    * op sub *tmp58 144 5
   186 draw line 144 :last 139 :y
-    * op sub :x 144 5
   187 set :last :y
   188 op max :newMax :newMax :value
   189 label *label79
-    * op add :n 3 1
   190 label *label80
   191 read :t bank1 :tail
   192 read :h bank1 :head
 
   204 label *label84
   205 op mul *tmp56 :value :scale
   206 op add :y 10 *tmp56
-    * op sub *tmp58 139 5
   207 draw line 139 :last 134 :y
-    * op sub :x 139 5
   208 set :last :y
   209 op max :newMax :newMax :value
   210 label *label85
-    * op add :n 4 1
   211 label *label86
   212 read :t bank1 :tail
   213 read :h bank1 :head
 
   225 label *label90
   226 op mul *tmp56 :value :scale
   227 op add :y 10 *tmp56
-    * op sub *tmp58 134 5
   228 draw line 134 :last 129 :y
-    * op sub :x 134 5
   229 set :last :y
   230 op max :newMax :newMax :value
   231 label *label91
-    * op add :n 5 1
   232 label *label92
   233 read :t bank1 :tail
   234 read :h bank1 :head
 
   246 label *label96
   247 op mul *tmp56 :value :scale
   248 op add :y 10 *tmp56
-    * op sub *tmp58 129 5
   249 draw line 129 :last 124 :y
-    * op sub :x 129 5
   250 set :last :y
   251 op max :newMax :newMax :value
   252 label *label97
-    * op add :n 6 1
   253 label *label98
   254 read :t bank1 :tail
   255 read :h bank1 :head
 
   267 label *label102
   268 op mul *tmp56 :value :scale
   269 op add :y 10 *tmp56
-    * op sub *tmp58 124 5
   270 draw line 124 :last 119 :y
-    * op sub :x 124 5
   271 set :last :y
   272 op max :newMax :newMax :value
   273 label *label103
-    * op add :n 7 1
   274 label *label104
   275 read :t bank1 :tail
   276 read :h bank1 :head
 
   288 label *label108
   289 op mul *tmp56 :value :scale
   290 op add :y 10 *tmp56
-    * op sub *tmp58 119 5
   291 draw line 119 :last 114 :y
-    * op sub :x 119 5
   292 set :last :y
   293 op max :newMax :newMax :value
   294 label *label109
-    * op add :n 8 1
   295 label *label110
   296 read :t bank1 :tail
   297 read :h bank1 :head
 
   309 label *label114
   310 op mul *tmp56 :value :scale
   311 op add :y 10 *tmp56
-    * op sub *tmp58 114 5
   312 draw line 114 :last 109 :y
-    * op sub :x 114 5
   313 set :last :y
   314 op max :newMax :newMax :value
   315 label *label115
-    * op add :n 9 1
   316 label *label116
   317 read :t bank1 :tail
   318 read :h bank1 :head
 
   330 label *label120
   331 op mul *tmp56 :value :scale
   332 op add :y 10 *tmp56
-    * op sub *tmp58 109 5
   333 draw line 109 :last 104 :y
-    * op sub :x 109 5
   334 set :last :y
   335 op max :newMax :newMax :value
   336 label *label121
-    * op add :n 10 1
   337 label *label122
   338 read :t bank1 :tail
   339 read :h bank1 :head
 
   351 label *label126
   352 op mul *tmp56 :value :scale
   353 op add :y 10 *tmp56
-    * op sub *tmp58 104 5
   354 draw line 104 :last 99 :y
-    * op sub :x 104 5
   355 set :last :y
   356 op max :newMax :newMax :value
   357 label *label127
-    * op add :n 11 1
   358 label *label128
   359 read :t bank1 :tail
   360 read :h bank1 :head
 
   372 label *label132
   373 op mul *tmp56 :value :scale
   374 op add :y 10 *tmp56
-    * op sub *tmp58 99 5
   375 draw line 99 :last 94 :y
-    * op sub :x 99 5
   376 set :last :y
   377 op max :newMax :newMax :value
   378 label *label133
-    * op add :n 12 1
   379 label *label134
   380 read :t bank1 :tail
   381 read :h bank1 :head
 
   393 label *label138
   394 op mul *tmp56 :value :scale
   395 op add :y 10 *tmp56
-    * op sub *tmp58 94 5
   396 draw line 94 :last 89 :y
-    * op sub :x 94 5
   397 set :last :y
   398 op max :newMax :newMax :value
   399 label *label139
-    * op add :n 13 1
   400 label *label140
   401 read :t bank1 :tail
   402 read :h bank1 :head
 
   414 label *label144
   415 op mul *tmp56 :value :scale
   416 op add :y 10 *tmp56
-    * op sub *tmp58 89 5
   417 draw line 89 :last 84 :y
-    * op sub :x 89 5
   418 set :last :y
   419 op max :newMax :newMax :value
   420 label *label145
-    * op add :n 14 1
   421 label *label146
   422 read :t bank1 :tail
   423 read :h bank1 :head
 
   435 label *label150
   436 op mul *tmp56 :value :scale
   437 op add :y 10 *tmp56
-    * op sub *tmp58 84 5
   438 draw line 84 :last 79 :y
-    * op sub :x 84 5
   439 set :last :y
   440 op max :newMax :newMax :value
   441 label *label151
-    * op add :n 15 1
   442 label *label152
   443 read :t bank1 :tail
   444 read :h bank1 :head
 
   456 label *label156
   457 op mul *tmp56 :value :scale
   458 op add :y 10 *tmp56
-    * op sub *tmp58 79 5
   459 draw line 79 :last 74 :y
-    * op sub :x 79 5
   460 set :last :y
   461 op max :newMax :newMax :value
   462 label *label157
-    * op add :n 16 1
   463 label *label158
   464 read :t bank1 :tail
   465 read :h bank1 :head
 
   477 label *label162
   478 op mul *tmp56 :value :scale
   479 op add :y 10 *tmp56
-    * op sub *tmp58 74 5
   480 draw line 74 :last 69 :y
-    * op sub :x 74 5
   481 set :last :y
   482 op max :newMax :newMax :value
   483 label *label163
-    * op add :n 17 1
   484 label *label164
   485 read :t bank1 :tail
   486 read :h bank1 :head
 
   498 label *label168
   499 op mul *tmp56 :value :scale
   500 op add :y 10 *tmp56
-    * op sub *tmp58 69 5
   501 draw line 69 :last 64 :y
-    * op sub :x 69 5
   502 set :last :y
   503 op max :newMax :newMax :value
   504 label *label169
-    * op add :n 18 1
   505 label *label170
   506 read :t bank1 :tail
   507 read :h bank1 :head
 
   519 label *label174
   520 op mul *tmp56 :value :scale
   521 op add :y 10 *tmp56
-    * op sub *tmp58 64 5
   522 draw line 64 :last 59 :y
-    * op sub :x 64 5
   523 set :last :y
   524 op max :newMax :newMax :value
   525 label *label175
-    * op add :n 19 1
   526 label *label176
   527 read :t bank1 :tail
   528 read :h bank1 :head
 
   540 label *label180
   541 op mul *tmp56 :value :scale
   542 op add :y 10 *tmp56
-    * op sub *tmp58 59 5
   543 draw line 59 :last 54 :y
-    * op sub :x 59 5
   544 set :last :y
   545 op max :newMax :newMax :value
   546 label *label181
-    * op add :n 20 1
   547 label *label182
   548 read :t bank1 :tail
   549 read :h bank1 :head
 
   561 label *label186
   562 op mul *tmp56 :value :scale
   563 op add :y 10 *tmp56
-    * op sub *tmp58 54 5
   564 draw line 54 :last 49 :y
-    * op sub :x 54 5
   565 set :last :y
   566 op max :newMax :newMax :value
   567 label *label187
-    * op add :n 21 1
   568 label *label188
   569 read :t bank1 :tail
   570 read :h bank1 :head
 
   582 label *label192
   583 op mul *tmp56 :value :scale
   584 op add :y 10 *tmp56
-    * op sub *tmp58 49 5
   585 draw line 49 :last 44 :y
-    * op sub :x 49 5
   586 set :last :y
   587 op max :newMax :newMax :value
   588 label *label193
-    * op add :n 22 1
   589 label *label194
   590 read :t bank1 :tail
   591 read :h bank1 :head
 
   603 label *label198
   604 op mul *tmp56 :value :scale
   605 op add :y 10 *tmp56
-    * op sub *tmp58 44 5
   606 draw line 44 :last 39 :y
-    * op sub :x 44 5
   607 set :last :y
   608 op max :newMax :newMax :value
   609 label *label199
-    * op add :n 23 1
   610 label *label200
   611 read :t bank1 :tail
   612 read :h bank1 :head
 
   624 label *label204
   625 op mul *tmp56 :value :scale
   626 op add :y 10 *tmp56
-    * op sub *tmp58 39 5
   627 draw line 39 :last 34 :y
-    * op sub :x 39 5
   628 set :last :y
   629 op max :newMax :newMax :value
   630 label *label205
-    * op add :n 24 1
   631 label *label206
   632 read :t bank1 :tail
   633 read :h bank1 :head
 
   645 label *label210
   646 op mul *tmp56 :value :scale
   647 op add :y 10 *tmp56
-    * op sub *tmp58 34 5
   648 draw line 34 :last 29 :y
-    * op sub :x 34 5
   649 set :last :y
   650 op max :newMax :newMax :value
   651 label *label211
-    * op add :n 25 1
   652 label *label212
   653 read :t bank1 :tail
   654 read :h bank1 :head
 
   666 label *label216
   667 op mul *tmp56 :value :scale
   668 op add :y 10 *tmp56
-    * op sub *tmp58 29 5
   669 draw line 29 :last 24 :y
-    * op sub :x 29 5
   670 set :last :y
   671 op max :newMax :newMax :value
   672 label *label217
-    * op add :n 26 1
   673 label *label218
   674 read :t bank1 :tail
   675 read :h bank1 :head
 
   687 label *label222
   688 op mul *tmp56 :value :scale
   689 op add :y 10 *tmp56
-    * op sub *tmp58 24 5
   690 draw line 24 :last 19 :y
-    * op sub :x 24 5
   691 set :last :y
   692 op max :newMax :newMax :value
   693 label *label223
-    * op add :n 27 1
   694 label *label224
   695 read :t bank1 :tail
   696 read :h bank1 :head
 
   706 label *label228
   707 op mul *tmp56 :value :scale
   708 op add :y 10 *tmp56
-    * op sub *tmp58 19 5
   709 draw line 19 :last 14 :y
-    * op sub :x 19 5
   710 op max :newMax :newMax :value
   711 label *label229
-    * op add :n 28 1
   712 label *label24
   713 draw color 255 255 255 255
   714 draw lineRect 10 10 156 156

Modifications by Replicate loop condition at line 32:1 (+1 instructions):
 
    29 label *label7
    30 sensor *tmp18 switch1 @enabled
    31 jump *label9 notEqual *tmp18 0
+   32 label *label230
    33 print "Item Rate Display"
    34 set :start @time
    35 sensor *tmp21 cell1 @dead
 
   743 print :loops
   744 printflush message1
   745 label *label8
-    * jump *label7 always
+  746 sensor *tmp18 switch1 @enabled
+  747 jump *label230 equal *tmp18 0
   748 label *label9
   749 control enabled switch1 0
   750 end

Modifications by Unroll loop at line 24:1 (+167 instructions):
 
    11 label *label0
    12 label *label1
    13 read :maximum bank1 :ptr
-    * set :n 0
-    * label *label2
-    * label *label34
-    * op sub :ptr :ptr 1
-    * jump *label5 greaterThan :ptr 256
-    * op sub :ptr 511 1
-    * label *label5
-    * label *label6
-    * read *tmp15 bank1 :ptr
-    * op max :maximum :maximum *tmp15
-    * label *label3
-    * op add :n :n 1
-    * jump *label34 lessThan :n 29
-    * label *label4
+   14 set :n 0
+   15 label *label231
+   16 label *label232
+   17 op sub :ptr :ptr 1
+   18 jump *label233 greaterThan :ptr 256
+   19 op sub :ptr 511 1
+   20 label *label233
+   21 label *label234
+   22 read *tmp15 bank1 :ptr
+   23 op max :maximum :maximum *tmp15
+   24 label *label235
+   25 op add :n :n 1
+   26 label *label236
+   27 op sub :ptr :ptr 1
+   28 jump *label237 greaterThan :ptr 256
+   29 op sub :ptr 511 1
+   30 label *label237
+   31 label *label238
+   32 read *tmp15 bank1 :ptr
+   33 op max :maximum :maximum *tmp15
+   34 label *label239
+   35 op add :n :n 1
+   36 label *label240
+   37 op sub :ptr :ptr 1
+   38 jump *label241 greaterThan :ptr 256
+   39 op sub :ptr 511 1
+   40 label *label241
+   41 label *label242
+   42 read *tmp15 bank1 :ptr
+   43 op max :maximum :maximum *tmp15
+   44 label *label243
+   45 op add :n :n 1
+   46 label *label244
+   47 op sub :ptr :ptr 1
+   48 jump *label245 greaterThan :ptr 256
+   49 op sub :ptr 511 1
+   50 label *label245
+   51 label *label246
+   52 read *tmp15 bank1 :ptr
+   53 op max :maximum :maximum *tmp15
+   54 label *label247
+   55 op add :n :n 1
+   56 label *label248
+   57 op sub :ptr :ptr 1
+   58 jump *label249 greaterThan :ptr 256
+   59 op sub :ptr 511 1
+   60 label *label249
+   61 label *label250
+   62 read *tmp15 bank1 :ptr
+   63 op max :maximum :maximum *tmp15
+   64 label *label251
+   65 op add :n :n 1
+   66 label *label252
+   67 op sub :ptr :ptr 1
+   68 jump *label253 greaterThan :ptr 256
+   69 op sub :ptr 511 1
+   70 label *label253
+   71 label *label254
+   72 read *tmp15 bank1 :ptr
+   73 op max :maximum :maximum *tmp15
+   74 label *label255
+   75 op add :n :n 1
+   76 label *label256
+   77 op sub :ptr :ptr 1
+   78 jump *label257 greaterThan :ptr 256
+   79 op sub :ptr 511 1
+   80 label *label257
+   81 label *label258
+   82 read *tmp15 bank1 :ptr
+   83 op max :maximum :maximum *tmp15
+   84 label *label259
+   85 op add :n :n 1
+   86 label *label260
+   87 op sub :ptr :ptr 1
+   88 jump *label261 greaterThan :ptr 256
+   89 op sub :ptr 511 1
+   90 label *label261
+   91 label *label262
+   92 read *tmp15 bank1 :ptr
+   93 op max :maximum :maximum *tmp15
+   94 label *label263
+   95 op add :n :n 1
+   96 label *label264
+   97 op sub :ptr :ptr 1
+   98 jump *label265 greaterThan :ptr 256
+   99 op sub :ptr 511 1
+  100 label *label265
+  101 label *label266
+  102 read *tmp15 bank1 :ptr
+  103 op max :maximum :maximum *tmp15
+  104 label *label267
+  105 op add :n :n 1
+  106 label *label268
+  107 op sub :ptr :ptr 1
+  108 jump *label269 greaterThan :ptr 256
+  109 op sub :ptr 511 1
+  110 label *label269
+  111 label *label270
+  112 read *tmp15 bank1 :ptr
+  113 op max :maximum :maximum *tmp15
+  114 label *label271
+  115 op add :n :n 1
+  116 label *label272
+  117 op sub :ptr :ptr 1
+  118 jump *label273 greaterThan :ptr 256
+  119 op sub :ptr 511 1
+  120 label *label273
+  121 label *label274
+  122 read *tmp15 bank1 :ptr
+  123 op max :maximum :maximum *tmp15
+  124 label *label275
+  125 op add :n :n 1
+  126 label *label276
+  127 op sub :ptr :ptr 1
+  128 jump *label277 greaterThan :ptr 256
+  129 op sub :ptr 511 1
+  130 label *label277
+  131 label *label278
+  132 read *tmp15 bank1 :ptr
+  133 op max :maximum :maximum *tmp15
+  134 label *label279
+  135 op add :n :n 1
+  136 label *label280
+  137 op sub :ptr :ptr 1
+  138 jump *label281 greaterThan :ptr 256
+  139 op sub :ptr 511 1
+  140 label *label281
+  141 label *label282
+  142 read *tmp15 bank1 :ptr
+  143 op max :maximum :maximum *tmp15
+  144 label *label283
+  145 op add :n :n 1
+  146 label *label284
+  147 op sub :ptr :ptr 1
+  148 jump *label285 greaterThan :ptr 256
+  149 op sub :ptr 511 1
+  150 label *label285
+  151 label *label286
+  152 read *tmp15 bank1 :ptr
+  153 op max :maximum :maximum *tmp15
+  154 label *label287
+  155 op add :n :n 1
+  156 label *label288
+  157 op sub :ptr :ptr 1
+  158 jump *label289 greaterThan :ptr 256
+  159 op sub :ptr 511 1
+  160 label *label289
+  161 label *label290
+  162 read *tmp15 bank1 :ptr
+  163 op max :maximum :maximum *tmp15
+  164 label *label291
+  165 op add :n :n 1
+  166 label *label292
+  167 op sub :ptr :ptr 1
+  168 jump *label293 greaterThan :ptr 256
+  169 op sub :ptr 511 1
+  170 label *label293
+  171 label *label294
+  172 read *tmp15 bank1 :ptr
+  173 op max :maximum :maximum *tmp15
+  174 label *label295
+  175 op add :n :n 1
+  176 label *label296
+  177 op sub :ptr :ptr 1
+  178 jump *label297 greaterThan :ptr 256
+  179 op sub :ptr 511 1
+  180 label *label297
+  181 label *label298
+  182 read *tmp15 bank1 :ptr
+  183 op max :maximum :maximum *tmp15
+  184 label *label299
+  185 op add :n :n 1
+  186 label *label300
+  187 op sub :ptr :ptr 1
+  188 jump *label301 greaterThan :ptr 256
+  189 op sub :ptr 511 1
+  190 label *label301
+  191 label *label302
+  192 read *tmp15 bank1 :ptr
+  193 op max :maximum :maximum *tmp15
+  194 label *label303
+  195 op add :n :n 1
+  196 label *label304
+  197 op sub :ptr :ptr 1
+  198 jump *label305 greaterThan :ptr 256
+  199 op sub :ptr 511 1
+  200 label *label305
+  201 label *label306
+  202 read *tmp15 bank1 :ptr
+  203 op max :maximum :maximum *tmp15
+  204 label *label307
+  205 op add :n :n 1
+  206 label *label308
+  207 op sub :ptr :ptr 1
+  208 jump *label309 greaterThan :ptr 256
+  209 op sub :ptr 511 1
+  210 label *label309
+  211 label *label310
+  212 read *tmp15 bank1 :ptr
+  213 op max :maximum :maximum *tmp15
+  214 label *label311
+  215 op add :n :n 1
+  216 label *label312
+  217 op sub :ptr :ptr 1
+  218 jump *label313 greaterThan :ptr 256
+  219 op sub :ptr 511 1
+  220 label *label313
+  221 label *label314
+  222 read *tmp15 bank1 :ptr
+  223 op max :maximum :maximum *tmp15
+  224 label *label315
+  225 op add :n :n 1
+  226 label *label316
+  227 op sub :ptr :ptr 1
+  228 jump *label317 greaterThan :ptr 256
+  229 op sub :ptr 511 1
+  230 label *label317
+  231 label *label318
+  232 read *tmp15 bank1 :ptr
+  233 op max :maximum :maximum *tmp15
+  234 label *label319
+  235 op add :n :n 1
+  236 label *label320
+  237 op sub :ptr :ptr 1
+  238 jump *label321 greaterThan :ptr 256
+  239 op sub :ptr 511 1
+  240 label *label321
+  241 label *label322
+  242 read *tmp15 bank1 :ptr
+  243 op max :maximum :maximum *tmp15
+  244 label *label323
+  245 op add :n :n 1
+  246 label *label324
+  247 op sub :ptr :ptr 1
+  248 jump *label325 greaterThan :ptr 256
+  249 op sub :ptr 511 1
+  250 label *label325
+  251 label *label326
+  252 read *tmp15 bank1 :ptr
+  253 op max :maximum :maximum *tmp15
+  254 label *label327
+  255 op add :n :n 1
+  256 label *label328
+  257 op sub :ptr :ptr 1
+  258 jump *label329 greaterThan :ptr 256
+  259 op sub :ptr 511 1
+  260 label *label329
+  261 label *label330
+  262 read *tmp15 bank1 :ptr
+  263 op max :maximum :maximum *tmp15
+  264 label *label331
+  265 op add :n :n 1
+  266 label *label332
+  267 op sub :ptr :ptr 1
+  268 jump *label333 greaterThan :ptr 256
+  269 op sub :ptr 511 1
+  270 label *label333
+  271 label *label334
+  272 read *tmp15 bank1 :ptr
+  273 op max :maximum :maximum *tmp15
+  274 label *label335
+  275 op add :n :n 1
+  276 label *label336
+  277 op sub :ptr :ptr 1
+  278 jump *label337 greaterThan :ptr 256
+  279 op sub :ptr 511 1
+  280 label *label337
+  281 label *label338
+  282 read *tmp15 bank1 :ptr
+  283 op max :maximum :maximum *tmp15
+  284 label *label339
+  285 op add :n :n 1
+  286 label *label340
+  287 op sub :ptr :ptr 1
+  288 jump *label341 greaterThan :ptr 256
+  289 op sub :ptr 511 1
+  290 label *label341
+  291 label *label342
+  292 read *tmp15 bank1 :ptr
+  293 op max :maximum :maximum *tmp15
+  294 label *label343
+  295 op add :n :n 1
+  296 label *label344
+  297 op sub :ptr :ptr 1
+  298 jump *label345 greaterThan :ptr 256
+  299 op sub :ptr 511 1
+  300 label *label345
+  301 label *label346
+  302 read *tmp15 bank1 :ptr
+  303 op max :maximum :maximum *tmp15
+  304 label *label347
+  305 op add :n :n 1
+  306 label *label4
   307 op mul :maximum :maximum 3
   308 label *label7
   309 sensor *tmp18 switch1 @enabled

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    22 read *tmp15 bank1 :ptr
    23 op max :maximum :maximum *tmp15
    24 label *label235
-    * op add :n :n 1
+   25 op add :n 0 1
    26 label *label236
    27 op sub :ptr :ptr 1
    28 jump *label237 greaterThan :ptr 256
 
    32 read *tmp15 bank1 :ptr
    33 op max :maximum :maximum *tmp15
    34 label *label239
-    * op add :n :n 1
+   35 op add :n 1 1
    36 label *label240
    37 op sub :ptr :ptr 1
    38 jump *label241 greaterThan :ptr 256
 
    42 read *tmp15 bank1 :ptr
    43 op max :maximum :maximum *tmp15
    44 label *label243
-    * op add :n :n 1
+   45 op add :n 2 1
    46 label *label244
    47 op sub :ptr :ptr 1
    48 jump *label245 greaterThan :ptr 256
 
    52 read *tmp15 bank1 :ptr
    53 op max :maximum :maximum *tmp15
    54 label *label247
-    * op add :n :n 1
+   55 op add :n 3 1
    56 label *label248
    57 op sub :ptr :ptr 1
    58 jump *label249 greaterThan :ptr 256
 
    62 read *tmp15 bank1 :ptr
    63 op max :maximum :maximum *tmp15
    64 label *label251
-    * op add :n :n 1
+   65 op add :n 4 1
    66 label *label252
    67 op sub :ptr :ptr 1
    68 jump *label253 greaterThan :ptr 256
 
    72 read *tmp15 bank1 :ptr
    73 op max :maximum :maximum *tmp15
    74 label *label255
-    * op add :n :n 1
+   75 op add :n 5 1
    76 label *label256
    77 op sub :ptr :ptr 1
    78 jump *label257 greaterThan :ptr 256
 
    82 read *tmp15 bank1 :ptr
    83 op max :maximum :maximum *tmp15
    84 label *label259
-    * op add :n :n 1
+   85 op add :n 6 1
    86 label *label260
    87 op sub :ptr :ptr 1
    88 jump *label261 greaterThan :ptr 256
 
    92 read *tmp15 bank1 :ptr
    93 op max :maximum :maximum *tmp15
    94 label *label263
-    * op add :n :n 1
+   95 op add :n 7 1
    96 label *label264
    97 op sub :ptr :ptr 1
    98 jump *label265 greaterThan :ptr 256
 
   102 read *tmp15 bank1 :ptr
   103 op max :maximum :maximum *tmp15
   104 label *label267
-    * op add :n :n 1
+  105 op add :n 8 1
   106 label *label268
   107 op sub :ptr :ptr 1
   108 jump *label269 greaterThan :ptr 256
 
   112 read *tmp15 bank1 :ptr
   113 op max :maximum :maximum *tmp15
   114 label *label271
-    * op add :n :n 1
+  115 op add :n 9 1
   116 label *label272
   117 op sub :ptr :ptr 1
   118 jump *label273 greaterThan :ptr 256
 
   122 read *tmp15 bank1 :ptr
   123 op max :maximum :maximum *tmp15
   124 label *label275
-    * op add :n :n 1
+  125 op add :n 10 1
   126 label *label276
   127 op sub :ptr :ptr 1
   128 jump *label277 greaterThan :ptr 256
 
   132 read *tmp15 bank1 :ptr
   133 op max :maximum :maximum *tmp15
   134 label *label279
-    * op add :n :n 1
+  135 op add :n 11 1
   136 label *label280
   137 op sub :ptr :ptr 1
   138 jump *label281 greaterThan :ptr 256
 
   142 read *tmp15 bank1 :ptr
   143 op max :maximum :maximum *tmp15
   144 label *label283
-    * op add :n :n 1
+  145 op add :n 12 1
   146 label *label284
   147 op sub :ptr :ptr 1
   148 jump *label285 greaterThan :ptr 256
 
   152 read *tmp15 bank1 :ptr
   153 op max :maximum :maximum *tmp15
   154 label *label287
-    * op add :n :n 1
+  155 op add :n 13 1
   156 label *label288
   157 op sub :ptr :ptr 1
   158 jump *label289 greaterThan :ptr 256
 
   162 read *tmp15 bank1 :ptr
   163 op max :maximum :maximum *tmp15
   164 label *label291
-    * op add :n :n 1
+  165 op add :n 14 1
   166 label *label292
   167 op sub :ptr :ptr 1
   168 jump *label293 greaterThan :ptr 256
 
   172 read *tmp15 bank1 :ptr
   173 op max :maximum :maximum *tmp15
   174 label *label295
-    * op add :n :n 1
+  175 op add :n 15 1
   176 label *label296
   177 op sub :ptr :ptr 1
   178 jump *label297 greaterThan :ptr 256
 
   182 read *tmp15 bank1 :ptr
   183 op max :maximum :maximum *tmp15
   184 label *label299
-    * op add :n :n 1
+  185 op add :n 16 1
   186 label *label300
   187 op sub :ptr :ptr 1
   188 jump *label301 greaterThan :ptr 256
 
   192 read *tmp15 bank1 :ptr
   193 op max :maximum :maximum *tmp15
   194 label *label303
-    * op add :n :n 1
+  195 op add :n 17 1
   196 label *label304
   197 op sub :ptr :ptr 1
   198 jump *label305 greaterThan :ptr 256
 
   202 read *tmp15 bank1 :ptr
   203 op max :maximum :maximum *tmp15
   204 label *label307
-    * op add :n :n 1
+  205 op add :n 18 1
   206 label *label308
   207 op sub :ptr :ptr 1
   208 jump *label309 greaterThan :ptr 256
 
   212 read *tmp15 bank1 :ptr
   213 op max :maximum :maximum *tmp15
   214 label *label311
-    * op add :n :n 1
+  215 op add :n 19 1
   216 label *label312
   217 op sub :ptr :ptr 1
   218 jump *label313 greaterThan :ptr 256
 
   222 read *tmp15 bank1 :ptr
   223 op max :maximum :maximum *tmp15
   224 label *label315
-    * op add :n :n 1
+  225 op add :n 20 1
   226 label *label316
   227 op sub :ptr :ptr 1
   228 jump *label317 greaterThan :ptr 256
 
   232 read *tmp15 bank1 :ptr
   233 op max :maximum :maximum *tmp15
   234 label *label319
-    * op add :n :n 1
+  235 op add :n 21 1
   236 label *label320
   237 op sub :ptr :ptr 1
   238 jump *label321 greaterThan :ptr 256
 
   242 read *tmp15 bank1 :ptr
   243 op max :maximum :maximum *tmp15
   244 label *label323
-    * op add :n :n 1
+  245 op add :n 22 1
   246 label *label324
   247 op sub :ptr :ptr 1
   248 jump *label325 greaterThan :ptr 256
 
   252 read *tmp15 bank1 :ptr
   253 op max :maximum :maximum *tmp15
   254 label *label327
-    * op add :n :n 1
+  255 op add :n 23 1
   256 label *label328
   257 op sub :ptr :ptr 1
   258 jump *label329 greaterThan :ptr 256
 
   262 read *tmp15 bank1 :ptr
   263 op max :maximum :maximum *tmp15
   264 label *label331
-    * op add :n :n 1
+  265 op add :n 24 1
   266 label *label332
   267 op sub :ptr :ptr 1
   268 jump *label333 greaterThan :ptr 256
 
   272 read *tmp15 bank1 :ptr
   273 op max :maximum :maximum *tmp15
   274 label *label335
-    * op add :n :n 1
+  275 op add :n 25 1
   276 label *label336
   277 op sub :ptr :ptr 1
   278 jump *label337 greaterThan :ptr 256
 
   282 read *tmp15 bank1 :ptr
   283 op max :maximum :maximum *tmp15
   284 label *label339
-    * op add :n :n 1
+  285 op add :n 26 1
   286 label *label340
   287 op sub :ptr :ptr 1
   288 jump *label341 greaterThan :ptr 256
 
   292 read *tmp15 bank1 :ptr
   293 op max :maximum :maximum *tmp15
   294 label *label343
-    * op add :n :n 1
+  295 op add :n 27 1
   296 label *label344
   297 op sub :ptr :ptr 1
   298 jump *label345 greaterThan :ptr 256
 
   302 read *tmp15 bank1 :ptr
   303 op max :maximum :maximum *tmp15
   304 label *label347
-    * op add :n :n 1
+  305 op add :n 28 1
   306 label *label4
   307 op mul :maximum :maximum 3
   308 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-30 instructions):
 
    11 label *label0
    12 label *label1
    13 read :maximum bank1 :ptr
-    * set :n 0
    14 label *label231
    15 label *label232
    16 op sub :ptr :ptr 1
 
    21 read *tmp15 bank1 :ptr
    22 op max :maximum :maximum *tmp15
    23 label *label235
-    * op add :n 0 1
    24 label *label236
    25 op sub :ptr :ptr 1
    26 jump *label237 greaterThan :ptr 256
 
    30 read *tmp15 bank1 :ptr
    31 op max :maximum :maximum *tmp15
    32 label *label239
-    * op add :n 1 1
    33 label *label240
    34 op sub :ptr :ptr 1
    35 jump *label241 greaterThan :ptr 256
 
    39 read *tmp15 bank1 :ptr
    40 op max :maximum :maximum *tmp15
    41 label *label243
-    * op add :n 2 1
    42 label *label244
    43 op sub :ptr :ptr 1
    44 jump *label245 greaterThan :ptr 256
 
    48 read *tmp15 bank1 :ptr
    49 op max :maximum :maximum *tmp15
    50 label *label247
-    * op add :n 3 1
    51 label *label248
    52 op sub :ptr :ptr 1
    53 jump *label249 greaterThan :ptr 256
 
    57 read *tmp15 bank1 :ptr
    58 op max :maximum :maximum *tmp15
    59 label *label251
-    * op add :n 4 1
    60 label *label252
    61 op sub :ptr :ptr 1
    62 jump *label253 greaterThan :ptr 256
 
    66 read *tmp15 bank1 :ptr
    67 op max :maximum :maximum *tmp15
    68 label *label255
-    * op add :n 5 1
    69 label *label256
    70 op sub :ptr :ptr 1
    71 jump *label257 greaterThan :ptr 256
 
    75 read *tmp15 bank1 :ptr
    76 op max :maximum :maximum *tmp15
    77 label *label259
-    * op add :n 6 1
    78 label *label260
    79 op sub :ptr :ptr 1
    80 jump *label261 greaterThan :ptr 256
 
    84 read *tmp15 bank1 :ptr
    85 op max :maximum :maximum *tmp15
    86 label *label263
-    * op add :n 7 1
    87 label *label264
    88 op sub :ptr :ptr 1
    89 jump *label265 greaterThan :ptr 256
 
    93 read *tmp15 bank1 :ptr
    94 op max :maximum :maximum *tmp15
    95 label *label267
-    * op add :n 8 1
    96 label *label268
    97 op sub :ptr :ptr 1
    98 jump *label269 greaterThan :ptr 256
 
   102 read *tmp15 bank1 :ptr
   103 op max :maximum :maximum *tmp15
   104 label *label271
-    * op add :n 9 1
   105 label *label272
   106 op sub :ptr :ptr 1
   107 jump *label273 greaterThan :ptr 256
 
   111 read *tmp15 bank1 :ptr
   112 op max :maximum :maximum *tmp15
   113 label *label275
-    * op add :n 10 1
   114 label *label276
   115 op sub :ptr :ptr 1
   116 jump *label277 greaterThan :ptr 256
 
   120 read *tmp15 bank1 :ptr
   121 op max :maximum :maximum *tmp15
   122 label *label279
-    * op add :n 11 1
   123 label *label280
   124 op sub :ptr :ptr 1
   125 jump *label281 greaterThan :ptr 256
 
   129 read *tmp15 bank1 :ptr
   130 op max :maximum :maximum *tmp15
   131 label *label283
-    * op add :n 12 1
   132 label *label284
   133 op sub :ptr :ptr 1
   134 jump *label285 greaterThan :ptr 256
 
   138 read *tmp15 bank1 :ptr
   139 op max :maximum :maximum *tmp15
   140 label *label287
-    * op add :n 13 1
   141 label *label288
   142 op sub :ptr :ptr 1
   143 jump *label289 greaterThan :ptr 256
 
   147 read *tmp15 bank1 :ptr
   148 op max :maximum :maximum *tmp15
   149 label *label291
-    * op add :n 14 1
   150 label *label292
   151 op sub :ptr :ptr 1
   152 jump *label293 greaterThan :ptr 256
 
   156 read *tmp15 bank1 :ptr
   157 op max :maximum :maximum *tmp15
   158 label *label295
-    * op add :n 15 1
   159 label *label296
   160 op sub :ptr :ptr 1
   161 jump *label297 greaterThan :ptr 256
 
   165 read *tmp15 bank1 :ptr
   166 op max :maximum :maximum *tmp15
   167 label *label299
-    * op add :n 16 1
   168 label *label300
   169 op sub :ptr :ptr 1
   170 jump *label301 greaterThan :ptr 256
 
   174 read *tmp15 bank1 :ptr
   175 op max :maximum :maximum *tmp15
   176 label *label303
-    * op add :n 17 1
   177 label *label304
   178 op sub :ptr :ptr 1
   179 jump *label305 greaterThan :ptr 256
 
   183 read *tmp15 bank1 :ptr
   184 op max :maximum :maximum *tmp15
   185 label *label307
-    * op add :n 18 1
   186 label *label308
   187 op sub :ptr :ptr 1
   188 jump *label309 greaterThan :ptr 256
 
   192 read *tmp15 bank1 :ptr
   193 op max :maximum :maximum *tmp15
   194 label *label311
-    * op add :n 19 1
   195 label *label312
   196 op sub :ptr :ptr 1
   197 jump *label313 greaterThan :ptr 256
 
   201 read *tmp15 bank1 :ptr
   202 op max :maximum :maximum *tmp15
   203 label *label315
-    * op add :n 20 1
   204 label *label316
   205 op sub :ptr :ptr 1
   206 jump *label317 greaterThan :ptr 256
 
   210 read *tmp15 bank1 :ptr
   211 op max :maximum :maximum *tmp15
   212 label *label319
-    * op add :n 21 1
   213 label *label320
   214 op sub :ptr :ptr 1
   215 jump *label321 greaterThan :ptr 256
 
   219 read *tmp15 bank1 :ptr
   220 op max :maximum :maximum *tmp15
   221 label *label323
-    * op add :n 22 1
   222 label *label324
   223 op sub :ptr :ptr 1
   224 jump *label325 greaterThan :ptr 256
 
   228 read *tmp15 bank1 :ptr
   229 op max :maximum :maximum *tmp15
   230 label *label327
-    * op add :n 23 1
   231 label *label328
   232 op sub :ptr :ptr 1
   233 jump *label329 greaterThan :ptr 256
 
   237 read *tmp15 bank1 :ptr
   238 op max :maximum :maximum *tmp15
   239 label *label331
-    * op add :n 24 1
   240 label *label332
   241 op sub :ptr :ptr 1
   242 jump *label333 greaterThan :ptr 256
 
   246 read *tmp15 bank1 :ptr
   247 op max :maximum :maximum *tmp15
   248 label *label335
-    * op add :n 25 1
   249 label *label336
   250 op sub :ptr :ptr 1
   251 jump *label337 greaterThan :ptr 256
 
   255 read *tmp15 bank1 :ptr
   256 op max :maximum :maximum *tmp15
   257 label *label339
-    * op add :n 26 1
   258 label *label340
   259 op sub :ptr :ptr 1
   260 jump *label341 greaterThan :ptr 256
 
   264 read *tmp15 bank1 :ptr
   265 op max :maximum :maximum *tmp15
   266 label *label343
-    * op add :n 27 1
   267 label *label344
   268 op sub :ptr :ptr 1
   269 jump *label345 greaterThan :ptr 256
 
   273 read *tmp15 bank1 :ptr
   274 op max :maximum :maximum *tmp15
   275 label *label347
-    * op add :n 28 1
   276 label *label4
   277 op mul :maximum :maximum 3
   278 label *label7

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   947 op sub *tmp48 :value :t
   948 op add :value *tmp48 :h
   949 op sub :head :head 1
-    * jump *label225 greaterThan :head 256
   950 label *label225
   951 label *label226
   952 op sub :tail :tail 1
-    * jump *label227 greaterThan :tail 256
   953 label *label227
   954 label *label228
   955 op mul *tmp56 :value :scale

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
     5 printflush message1
     6 draw stroke 1
     7 read *tmp4 bank1 256
-    * op sub :ptr *tmp4 0
+    8 set :ptr *tmp4
     9 jump *label0 greaterThanEq :ptr 256
    10 op add :ptr *tmp4 254
    11 label *label0
 
   313 draw color 0 80 0 255
   314 draw rect 10 10 156 156
   315 read *tmp32 bank1 256
-    * op sub :head *tmp32 0
+  316 set :head *tmp32
   317 jump *label15 greaterThanEq :head 256
   318 op add :head *tmp32 254
   319 label *label15
 
   322 label *label42
   323 label *label43
   324 read *tmp38 bank1 :head
-    * op add :value 0 *tmp38
+  325 set :value *tmp38
   326 op sub :head :head 1
   327 jump *label44 greaterThan :head 256
   328 op sub :head 511 1

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   321 set :tail :head
   322 label *label42
   323 label *label43
-    * read *tmp38 bank1 :head
-    * set :value *tmp38
+  324 read :value bank1 :head
   325 op sub :head :head 1
   326 jump *label44 greaterThan :head 256
   327 op sub :head 511 1

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-2 instructions):
 
     6 draw stroke 1
     7 read *tmp4 bank1 256
     8 set :ptr *tmp4
-    * jump *label0 greaterThanEq :ptr 256
+    9 jump *label0 greaterThanEq *tmp4 256
    10 op add :ptr *tmp4 254
    11 label *label0
    12 label *label1
 
   314 draw rect 10 10 156 156
   315 read *tmp32 bank1 256
   316 set :head *tmp32
-    * jump *label15 greaterThanEq :head 256
+  317 jump *label15 greaterThanEq *tmp32 256
   318 op add :head *tmp32 254
   319 label *label15
   320 label *label16
 
   945 read :h bank1 :head
   946 op sub *tmp48 :value :t
   947 op add :value *tmp48 :h
-    * op sub :head :head 1
   948 label *label225
   949 label *label226
-    * op sub :tail :tail 1
   950 label *label227
   951 label *label228
   952 op mul *tmp56 :value :scale

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   991 jump *label230 equal *tmp18 0
   992 label *label9
   993 control enabled switch1 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-12 instructions):
     0 printflush message1
-    * print "Item Rate Display"
-    * print "\n"
-    * print "[gold]Initializing...[]"
-    * print "\n"
+    1 print "Item Rate Display\n[gold]Initializing...[]\n"
     2 printflush message1
     3 draw stroke 1
     4 read *tmp4 bank1 256
 
   283 label *label39
   284 label *label40
   285 read :m cell1 0
-    * print "\n"
-    * print "Coord: [gold]"
+  286 print "\nCoord: [gold]"
   287 print :m
-    * print "["
-    * print "]"
+  288 print "[]"
   289 op max :maximum :maximum :m
   290 label *label41
   291 label *label14
 
   293 label *label11
   294 op div :scale 150 :maximum
   295 op ceil *tmp29 :maximum
-    * print "\n"
-    * print "Maximum: [green]"
+  296 print "\nMaximum: [green]"
   297 print *tmp29
-    * print "["
-    * print "]"
   298 op floor *tmp30 :scale
-    * print "\n"
-    * print "Scale: [green]"
+  299 print "[]\nScale: [green]"
   300 print *tmp30
-    * print "["
-    * print "]"
+  301 print "[]"
   302 draw clear 0 0 80
   303 draw color 0 80 0 255
   304 draw rect 10 10 156 156
 
   956 write :maximum cell1 0
   957 op sub *tmp68 @time :start
   958 op floor *tmp69 *tmp68
-    * print "\n"
-    * print "[lightgray]Loop time: "
+  959 print "\n[lightgray]Loop time: "
   960 print *tmp69
-    * print " "
-    * print "ms"
+  961 print " ms"
   962 op div *tmp70 @time 1000
   963 op ceil *tmp71 *tmp70
   964 op mul :wait 1000 *tmp71

Final code before resolving virtual instructions:

    0:  printflush message1                                          printflush(message1);
    1:  print "Item Rate Display\n[gold]Initializing...[]\n"         println("[gold]Initializing...[]");
    2:  printflush message1                                          printflush(message1);
    3:  draw stroke 1 0 0 0 0 0                                      stroke(1);
    4:  read *tmp4 bank1 256                                         ptr = MEMORY[INDEX] - SHIFT;
    5:  set :ptr *tmp4                                               ...
    6:  jump *label0 greaterThanEq *tmp4 256                         if ptr < INDEX then ptr += SKIP_SIZE; end;
    7:  op add :ptr *tmp4 254                                        ...
        label *label0                                                ...
    8:  read :maximum bank1 :ptr                                     maximum = MEMORY[ptr];
    9:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   10:  jump *label233 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   11:  op sub :ptr 511 1                                            ...
        label *label233                                              ...
   12:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   13:  op max :maximum :maximum *tmp15                              ...
   14:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   15:  jump *label237 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   16:  op sub :ptr 511 1                                            ...
        label *label237                                              ...
   17:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   18:  op max :maximum :maximum *tmp15                              ...
   19:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   20:  jump *label241 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   21:  op sub :ptr 511 1                                            ...
        label *label241                                              ...
   22:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   23:  op max :maximum :maximum *tmp15                              ...
   24:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   25:  jump *label245 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   26:  op sub :ptr 511 1                                            ...
        label *label245                                              ...
   27:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   28:  op max :maximum :maximum *tmp15                              ...
   29:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   30:  jump *label249 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   31:  op sub :ptr 511 1                                            ...
        label *label249                                              ...
   32:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   33:  op max :maximum :maximum *tmp15                              ...
   34:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   35:  jump *label253 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   36:  op sub :ptr 511 1                                            ...
        label *label253                                              ...
   37:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   38:  op max :maximum :maximum *tmp15                              ...
   39:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   40:  jump *label257 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   41:  op sub :ptr 511 1                                            ...
        label *label257                                              ...
   42:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   43:  op max :maximum :maximum *tmp15                              ...
   44:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   45:  jump *label261 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   46:  op sub :ptr 511 1                                            ...
        label *label261                                              ...
   47:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   48:  op max :maximum :maximum *tmp15                              ...
   49:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   50:  jump *label265 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   51:  op sub :ptr 511 1                                            ...
        label *label265                                              ...
   52:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   53:  op max :maximum :maximum *tmp15                              ...
   54:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   55:  jump *label269 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   56:  op sub :ptr 511 1                                            ...
        label *label269                                              ...
   57:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   58:  op max :maximum :maximum *tmp15                              ...
   59:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   60:  jump *label273 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   61:  op sub :ptr 511 1                                            ...
        label *label273                                              ...
   62:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   63:  op max :maximum :maximum *tmp15                              ...
   64:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   65:  jump *label277 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   66:  op sub :ptr 511 1                                            ...
        label *label277                                              ...
   67:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   68:  op max :maximum :maximum *tmp15                              ...
   69:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   70:  jump *label281 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   71:  op sub :ptr 511 1                                            ...
        label *label281                                              ...
   72:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   73:  op max :maximum :maximum *tmp15                              ...
   74:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   75:  jump *label285 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   76:  op sub :ptr 511 1                                            ...
        label *label285                                              ...
   77:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   78:  op max :maximum :maximum *tmp15                              ...
   79:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   80:  jump *label289 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   81:  op sub :ptr 511 1                                            ...
        label *label289                                              ...
   82:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   83:  op max :maximum :maximum *tmp15                              ...
   84:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   85:  jump *label293 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   86:  op sub :ptr 511 1                                            ...
        label *label293                                              ...
   87:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   88:  op max :maximum :maximum *tmp15                              ...
   89:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   90:  jump *label297 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   91:  op sub :ptr 511 1                                            ...
        label *label297                                              ...
   92:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   93:  op max :maximum :maximum *tmp15                              ...
   94:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
   95:  jump *label301 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
   96:  op sub :ptr 511 1                                            ...
        label *label301                                              ...
   97:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
   98:  op max :maximum :maximum *tmp15                              ...
   99:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  100:  jump *label305 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  101:  op sub :ptr 511 1                                            ...
        label *label305                                              ...
  102:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  103:  op max :maximum :maximum *tmp15                              ...
  104:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  105:  jump *label309 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  106:  op sub :ptr 511 1                                            ...
        label *label309                                              ...
  107:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  108:  op max :maximum :maximum *tmp15                              ...
  109:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  110:  jump *label313 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  111:  op sub :ptr 511 1                                            ...
        label *label313                                              ...
  112:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  113:  op max :maximum :maximum *tmp15                              ...
  114:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  115:  jump *label317 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  116:  op sub :ptr 511 1                                            ...
        label *label317                                              ...
  117:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  118:  op max :maximum :maximum *tmp15                              ...
  119:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  120:  jump *label321 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  121:  op sub :ptr 511 1                                            ...
        label *label321                                              ...
  122:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  123:  op max :maximum :maximum *tmp15                              ...
  124:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  125:  jump *label325 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  126:  op sub :ptr 511 1                                            ...
        label *label325                                              ...
  127:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  128:  op max :maximum :maximum *tmp15                              ...
  129:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  130:  jump *label329 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  131:  op sub :ptr 511 1                                            ...
        label *label329                                              ...
  132:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  133:  op max :maximum :maximum *tmp15                              ...
  134:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  135:  jump *label333 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  136:  op sub :ptr 511 1                                            ...
        label *label333                                              ...
  137:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  138:  op max :maximum :maximum *tmp15                              ...
  139:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  140:  jump *label337 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  141:  op sub :ptr 511 1                                            ...
        label *label337                                              ...
  142:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  143:  op max :maximum :maximum *tmp15                              ...
  144:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  145:  jump *label341 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  146:  op sub :ptr 511 1                                            ...
        label *label341                                              ...
  147:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  148:  op max :maximum :maximum *tmp15                              ...
  149:  op sub :ptr :ptr 1                                           ptr = ptr - 1;
  150:  jump *label345 greaterThan :ptr 256                          if ptr <= INDEX then ptr = SIZE - 1; end;
  151:  op sub :ptr 511 1                                            ...
        label *label345                                              ...
  152:  read *tmp15 bank1 :ptr                                       maximum = max(maximum, MEMORY[ptr]);
  153:  op max :maximum :maximum *tmp15                              ...
  154:  op mul :maximum :maximum 3                                   maximum = maximum * SMOOTH;
  155:  sensor *tmp18 switch1 @enabled                               while switch1.@enabled == 0 do
  156:  jump *label9 notEqual *tmp18 0                               ...
        label *label230                                              ...
  157:  print "Item Rate Display"                                    print("Item Rate Display");
  158:  set :start @time                                             start = @time;
  159:  sensor *tmp21 cell1 @dead                                    if COORD.@dead == 0 then
  160:  jump *label10 notEqual *tmp21 0                              ...
  161:  read :m cell1 0                                              m = COORD[n];
  162:  print "\nCoord: [gold]"                                      print($"\nCoord: [gold]$m[]");
  163:  print :m                                                     ...
  164:  print "[]"                                                   ...
  165:  op max :maximum :maximum :m                                  maximum = max(maximum, m);
        label *label10                                               if COORD.@dead == 0 then
  166:  op div :scale 150 :maximum                                   scale = 150 / maximum;
  167:  op ceil *tmp29 :maximum 0                                    print($"\nMaximum: [green]$[]", ceil(maximum));
  168:  print "\nMaximum: [green]"                                   ...
  169:  print *tmp29                                                 ...
  170:  op floor *tmp30 :scale 0                                     print($"\nScale: [green]$[]", floor(scale));
  171:  print "[]\nScale: [green]"                                   ...
  172:  print *tmp30                                                 ...
  173:  print "[]"                                                   ...
  174:  draw clear 0 0 80 0 0 0                                      clear(0,0,80);
  175:  draw color 0 80 0 255 0 0                                    color(0,80,0,255);
  176:  draw rect 10 10 156 156 0 0                                  rect(10,10,156,156);
  177:  read *tmp32 bank1 256                                        head = MEMORY[INDEX] - SHIFT;
  178:  set :head *tmp32                                             ...
  179:  jump *label15 greaterThanEq *tmp32 256                       if head < INDEX then head += SKIP_SIZE; end;
  180:  op add :head *tmp32 254                                      ...
        label *label15                                               ...
  181:  set :tail :head                                              tail = head;
  182:  read :value bank1 :head                                      value += MEMORY[head];
  183:  op sub :head :head 1                                         head -= 1;
  184:  jump *label44 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  185:  op sub :head 511 1                                           ...
        label *label44                                               ...
  186:  read *tmp38 bank1 :head                                      value += MEMORY[head];
  187:  op add :value :value *tmp38                                  ...
  188:  op sub :head :head 1                                         head -= 1;
  189:  jump *label48 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  190:  op sub :head 511 1                                           ...
        label *label48                                               ...
  191:  read *tmp38 bank1 :head                                      value += MEMORY[head];
  192:  op add :value :value *tmp38                                  ...
  193:  op sub :head :head 1                                         head -= 1;
  194:  jump *label52 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  195:  op sub :head 511 1                                           ...
        label *label52                                               ...
  196:  op mul *tmp42 :value :scale                                  last = 10 + value * scale;
  197:  op add :last 10 *tmp42                                       ...
  198:  set :newMax :value                                           newMax = value;
  199:  draw color 80 255 80 255 0 0                                 color(80,255,80,255);
  200:  read :t bank1 :tail                                          t = MEMORY[tail];
  201:  read :h bank1 :head                                          h = MEMORY[head];
  202:  op sub *tmp48 :value :t                                      value = value - t + h;
  203:  op add :value *tmp48 :h                                      ...
  204:  op sub :head :head 1                                         head -= 1;
  205:  jump *label57 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  206:  op sub :head 511 1                                           ...
        label *label57                                               ...
  207:  op sub :tail :tail 1                                         tail -= 1;
  208:  jump *label59 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  209:  op sub :tail 511 1                                           ...
        label *label59                                               ...
  210:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  211:  op add :y 10 *tmp56                                          ...
  212:  draw line 159 :last 154 :y 0 0                               line(x, last, x - 5, y);
  213:  set :last :y                                                 last = y;
  214:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  215:  read :t bank1 :tail                                          t = MEMORY[tail];
  216:  read :h bank1 :head                                          h = MEMORY[head];
  217:  op sub *tmp48 :value :t                                      value = value - t + h;
  218:  op add :value *tmp48 :h                                      ...
  219:  op sub :head :head 1                                         head -= 1;
  220:  jump *label63 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  221:  op sub :head 511 1                                           ...
        label *label63                                               ...
  222:  op sub :tail :tail 1                                         tail -= 1;
  223:  jump *label65 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  224:  op sub :tail 511 1                                           ...
        label *label65                                               ...
  225:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  226:  op add :y 10 *tmp56                                          ...
  227:  draw line 154 :last 149 :y 0 0                               line(x, last, x - 5, y);
  228:  set :last :y                                                 last = y;
  229:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  230:  read :t bank1 :tail                                          t = MEMORY[tail];
  231:  read :h bank1 :head                                          h = MEMORY[head];
  232:  op sub *tmp48 :value :t                                      value = value - t + h;
  233:  op add :value *tmp48 :h                                      ...
  234:  op sub :head :head 1                                         head -= 1;
  235:  jump *label69 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  236:  op sub :head 511 1                                           ...
        label *label69                                               ...
  237:  op sub :tail :tail 1                                         tail -= 1;
  238:  jump *label71 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  239:  op sub :tail 511 1                                           ...
        label *label71                                               ...
  240:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  241:  op add :y 10 *tmp56                                          ...
  242:  draw line 149 :last 144 :y 0 0                               line(x, last, x - 5, y);
  243:  set :last :y                                                 last = y;
  244:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  245:  read :t bank1 :tail                                          t = MEMORY[tail];
  246:  read :h bank1 :head                                          h = MEMORY[head];
  247:  op sub *tmp48 :value :t                                      value = value - t + h;
  248:  op add :value *tmp48 :h                                      ...
  249:  op sub :head :head 1                                         head -= 1;
  250:  jump *label75 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  251:  op sub :head 511 1                                           ...
        label *label75                                               ...
  252:  op sub :tail :tail 1                                         tail -= 1;
  253:  jump *label77 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  254:  op sub :tail 511 1                                           ...
        label *label77                                               ...
  255:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  256:  op add :y 10 *tmp56                                          ...
  257:  draw line 144 :last 139 :y 0 0                               line(x, last, x - 5, y);
  258:  set :last :y                                                 last = y;
  259:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  260:  read :t bank1 :tail                                          t = MEMORY[tail];
  261:  read :h bank1 :head                                          h = MEMORY[head];
  262:  op sub *tmp48 :value :t                                      value = value - t + h;
  263:  op add :value *tmp48 :h                                      ...
  264:  op sub :head :head 1                                         head -= 1;
  265:  jump *label81 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  266:  op sub :head 511 1                                           ...
        label *label81                                               ...
  267:  op sub :tail :tail 1                                         tail -= 1;
  268:  jump *label83 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  269:  op sub :tail 511 1                                           ...
        label *label83                                               ...
  270:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  271:  op add :y 10 *tmp56                                          ...
  272:  draw line 139 :last 134 :y 0 0                               line(x, last, x - 5, y);
  273:  set :last :y                                                 last = y;
  274:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  275:  read :t bank1 :tail                                          t = MEMORY[tail];
  276:  read :h bank1 :head                                          h = MEMORY[head];
  277:  op sub *tmp48 :value :t                                      value = value - t + h;
  278:  op add :value *tmp48 :h                                      ...
  279:  op sub :head :head 1                                         head -= 1;
  280:  jump *label87 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  281:  op sub :head 511 1                                           ...
        label *label87                                               ...
  282:  op sub :tail :tail 1                                         tail -= 1;
  283:  jump *label89 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  284:  op sub :tail 511 1                                           ...
        label *label89                                               ...
  285:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  286:  op add :y 10 *tmp56                                          ...
  287:  draw line 134 :last 129 :y 0 0                               line(x, last, x - 5, y);
  288:  set :last :y                                                 last = y;
  289:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  290:  read :t bank1 :tail                                          t = MEMORY[tail];
  291:  read :h bank1 :head                                          h = MEMORY[head];
  292:  op sub *tmp48 :value :t                                      value = value - t + h;
  293:  op add :value *tmp48 :h                                      ...
  294:  op sub :head :head 1                                         head -= 1;
  295:  jump *label93 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  296:  op sub :head 511 1                                           ...
        label *label93                                               ...
  297:  op sub :tail :tail 1                                         tail -= 1;
  298:  jump *label95 greaterThan :tail 256                          if tail <= INDEX then tail = SIZE - 1; end;
  299:  op sub :tail 511 1                                           ...
        label *label95                                               ...
  300:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  301:  op add :y 10 *tmp56                                          ...
  302:  draw line 129 :last 124 :y 0 0                               line(x, last, x - 5, y);
  303:  set :last :y                                                 last = y;
  304:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  305:  read :t bank1 :tail                                          t = MEMORY[tail];
  306:  read :h bank1 :head                                          h = MEMORY[head];
  307:  op sub *tmp48 :value :t                                      value = value - t + h;
  308:  op add :value *tmp48 :h                                      ...
  309:  op sub :head :head 1                                         head -= 1;
  310:  jump *label99 greaterThan :head 256                          if head <= INDEX then head = SIZE - 1; end;
  311:  op sub :head 511 1                                           ...
        label *label99                                               ...
  312:  op sub :tail :tail 1                                         tail -= 1;
  313:  jump *label101 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  314:  op sub :tail 511 1                                           ...
        label *label101                                              ...
  315:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  316:  op add :y 10 *tmp56                                          ...
  317:  draw line 124 :last 119 :y 0 0                               line(x, last, x - 5, y);
  318:  set :last :y                                                 last = y;
  319:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  320:  read :t bank1 :tail                                          t = MEMORY[tail];
  321:  read :h bank1 :head                                          h = MEMORY[head];
  322:  op sub *tmp48 :value :t                                      value = value - t + h;
  323:  op add :value *tmp48 :h                                      ...
  324:  op sub :head :head 1                                         head -= 1;
  325:  jump *label105 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  326:  op sub :head 511 1                                           ...
        label *label105                                              ...
  327:  op sub :tail :tail 1                                         tail -= 1;
  328:  jump *label107 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  329:  op sub :tail 511 1                                           ...
        label *label107                                              ...
  330:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  331:  op add :y 10 *tmp56                                          ...
  332:  draw line 119 :last 114 :y 0 0                               line(x, last, x - 5, y);
  333:  set :last :y                                                 last = y;
  334:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  335:  read :t bank1 :tail                                          t = MEMORY[tail];
  336:  read :h bank1 :head                                          h = MEMORY[head];
  337:  op sub *tmp48 :value :t                                      value = value - t + h;
  338:  op add :value *tmp48 :h                                      ...
  339:  op sub :head :head 1                                         head -= 1;
  340:  jump *label111 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  341:  op sub :head 511 1                                           ...
        label *label111                                              ...
  342:  op sub :tail :tail 1                                         tail -= 1;
  343:  jump *label113 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  344:  op sub :tail 511 1                                           ...
        label *label113                                              ...
  345:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  346:  op add :y 10 *tmp56                                          ...
  347:  draw line 114 :last 109 :y 0 0                               line(x, last, x - 5, y);
  348:  set :last :y                                                 last = y;
  349:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  350:  read :t bank1 :tail                                          t = MEMORY[tail];
  351:  read :h bank1 :head                                          h = MEMORY[head];
  352:  op sub *tmp48 :value :t                                      value = value - t + h;
  353:  op add :value *tmp48 :h                                      ...
  354:  op sub :head :head 1                                         head -= 1;
  355:  jump *label117 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  356:  op sub :head 511 1                                           ...
        label *label117                                              ...
  357:  op sub :tail :tail 1                                         tail -= 1;
  358:  jump *label119 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  359:  op sub :tail 511 1                                           ...
        label *label119                                              ...
  360:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  361:  op add :y 10 *tmp56                                          ...
  362:  draw line 109 :last 104 :y 0 0                               line(x, last, x - 5, y);
  363:  set :last :y                                                 last = y;
  364:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  365:  read :t bank1 :tail                                          t = MEMORY[tail];
  366:  read :h bank1 :head                                          h = MEMORY[head];
  367:  op sub *tmp48 :value :t                                      value = value - t + h;
  368:  op add :value *tmp48 :h                                      ...
  369:  op sub :head :head 1                                         head -= 1;
  370:  jump *label123 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  371:  op sub :head 511 1                                           ...
        label *label123                                              ...
  372:  op sub :tail :tail 1                                         tail -= 1;
  373:  jump *label125 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  374:  op sub :tail 511 1                                           ...
        label *label125                                              ...
  375:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  376:  op add :y 10 *tmp56                                          ...
  377:  draw line 104 :last 99 :y 0 0                                line(x, last, x - 5, y);
  378:  set :last :y                                                 last = y;
  379:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  380:  read :t bank1 :tail                                          t = MEMORY[tail];
  381:  read :h bank1 :head                                          h = MEMORY[head];
  382:  op sub *tmp48 :value :t                                      value = value - t + h;
  383:  op add :value *tmp48 :h                                      ...
  384:  op sub :head :head 1                                         head -= 1;
  385:  jump *label129 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  386:  op sub :head 511 1                                           ...
        label *label129                                              ...
  387:  op sub :tail :tail 1                                         tail -= 1;
  388:  jump *label131 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  389:  op sub :tail 511 1                                           ...
        label *label131                                              ...
  390:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  391:  op add :y 10 *tmp56                                          ...
  392:  draw line 99 :last 94 :y 0 0                                 line(x, last, x - 5, y);
  393:  set :last :y                                                 last = y;
  394:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  395:  read :t bank1 :tail                                          t = MEMORY[tail];
  396:  read :h bank1 :head                                          h = MEMORY[head];
  397:  op sub *tmp48 :value :t                                      value = value - t + h;
  398:  op add :value *tmp48 :h                                      ...
  399:  op sub :head :head 1                                         head -= 1;
  400:  jump *label135 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  401:  op sub :head 511 1                                           ...
        label *label135                                              ...
  402:  op sub :tail :tail 1                                         tail -= 1;
  403:  jump *label137 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  404:  op sub :tail 511 1                                           ...
        label *label137                                              ...
  405:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  406:  op add :y 10 *tmp56                                          ...
  407:  draw line 94 :last 89 :y 0 0                                 line(x, last, x - 5, y);
  408:  set :last :y                                                 last = y;
  409:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  410:  read :t bank1 :tail                                          t = MEMORY[tail];
  411:  read :h bank1 :head                                          h = MEMORY[head];
  412:  op sub *tmp48 :value :t                                      value = value - t + h;
  413:  op add :value *tmp48 :h                                      ...
  414:  op sub :head :head 1                                         head -= 1;
  415:  jump *label141 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  416:  op sub :head 511 1                                           ...
        label *label141                                              ...
  417:  op sub :tail :tail 1                                         tail -= 1;
  418:  jump *label143 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  419:  op sub :tail 511 1                                           ...
        label *label143                                              ...
  420:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  421:  op add :y 10 *tmp56                                          ...
  422:  draw line 89 :last 84 :y 0 0                                 line(x, last, x - 5, y);
  423:  set :last :y                                                 last = y;
  424:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  425:  read :t bank1 :tail                                          t = MEMORY[tail];
  426:  read :h bank1 :head                                          h = MEMORY[head];
  427:  op sub *tmp48 :value :t                                      value = value - t + h;
  428:  op add :value *tmp48 :h                                      ...
  429:  op sub :head :head 1                                         head -= 1;
  430:  jump *label147 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  431:  op sub :head 511 1                                           ...
        label *label147                                              ...
  432:  op sub :tail :tail 1                                         tail -= 1;
  433:  jump *label149 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  434:  op sub :tail 511 1                                           ...
        label *label149                                              ...
  435:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  436:  op add :y 10 *tmp56                                          ...
  437:  draw line 84 :last 79 :y 0 0                                 line(x, last, x - 5, y);
  438:  set :last :y                                                 last = y;
  439:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  440:  read :t bank1 :tail                                          t = MEMORY[tail];
  441:  read :h bank1 :head                                          h = MEMORY[head];
  442:  op sub *tmp48 :value :t                                      value = value - t + h;
  443:  op add :value *tmp48 :h                                      ...
  444:  op sub :head :head 1                                         head -= 1;
  445:  jump *label153 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  446:  op sub :head 511 1                                           ...
        label *label153                                              ...
  447:  op sub :tail :tail 1                                         tail -= 1;
  448:  jump *label155 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  449:  op sub :tail 511 1                                           ...
        label *label155                                              ...
  450:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  451:  op add :y 10 *tmp56                                          ...
  452:  draw line 79 :last 74 :y 0 0                                 line(x, last, x - 5, y);
  453:  set :last :y                                                 last = y;
  454:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  455:  read :t bank1 :tail                                          t = MEMORY[tail];
  456:  read :h bank1 :head                                          h = MEMORY[head];
  457:  op sub *tmp48 :value :t                                      value = value - t + h;
  458:  op add :value *tmp48 :h                                      ...
  459:  op sub :head :head 1                                         head -= 1;
  460:  jump *label159 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  461:  op sub :head 511 1                                           ...
        label *label159                                              ...
  462:  op sub :tail :tail 1                                         tail -= 1;
  463:  jump *label161 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  464:  op sub :tail 511 1                                           ...
        label *label161                                              ...
  465:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  466:  op add :y 10 *tmp56                                          ...
  467:  draw line 74 :last 69 :y 0 0                                 line(x, last, x - 5, y);
  468:  set :last :y                                                 last = y;
  469:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  470:  read :t bank1 :tail                                          t = MEMORY[tail];
  471:  read :h bank1 :head                                          h = MEMORY[head];
  472:  op sub *tmp48 :value :t                                      value = value - t + h;
  473:  op add :value *tmp48 :h                                      ...
  474:  op sub :head :head 1                                         head -= 1;
  475:  jump *label165 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  476:  op sub :head 511 1                                           ...
        label *label165                                              ...
  477:  op sub :tail :tail 1                                         tail -= 1;
  478:  jump *label167 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  479:  op sub :tail 511 1                                           ...
        label *label167                                              ...
  480:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  481:  op add :y 10 *tmp56                                          ...
  482:  draw line 69 :last 64 :y 0 0                                 line(x, last, x - 5, y);
  483:  set :last :y                                                 last = y;
  484:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  485:  read :t bank1 :tail                                          t = MEMORY[tail];
  486:  read :h bank1 :head                                          h = MEMORY[head];
  487:  op sub *tmp48 :value :t                                      value = value - t + h;
  488:  op add :value *tmp48 :h                                      ...
  489:  op sub :head :head 1                                         head -= 1;
  490:  jump *label171 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  491:  op sub :head 511 1                                           ...
        label *label171                                              ...
  492:  op sub :tail :tail 1                                         tail -= 1;
  493:  jump *label173 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  494:  op sub :tail 511 1                                           ...
        label *label173                                              ...
  495:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  496:  op add :y 10 *tmp56                                          ...
  497:  draw line 64 :last 59 :y 0 0                                 line(x, last, x - 5, y);
  498:  set :last :y                                                 last = y;
  499:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  500:  read :t bank1 :tail                                          t = MEMORY[tail];
  501:  read :h bank1 :head                                          h = MEMORY[head];
  502:  op sub *tmp48 :value :t                                      value = value - t + h;
  503:  op add :value *tmp48 :h                                      ...
  504:  op sub :head :head 1                                         head -= 1;
  505:  jump *label177 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  506:  op sub :head 511 1                                           ...
        label *label177                                              ...
  507:  op sub :tail :tail 1                                         tail -= 1;
  508:  jump *label179 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  509:  op sub :tail 511 1                                           ...
        label *label179                                              ...
  510:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  511:  op add :y 10 *tmp56                                          ...
  512:  draw line 59 :last 54 :y 0 0                                 line(x, last, x - 5, y);
  513:  set :last :y                                                 last = y;
  514:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  515:  read :t bank1 :tail                                          t = MEMORY[tail];
  516:  read :h bank1 :head                                          h = MEMORY[head];
  517:  op sub *tmp48 :value :t                                      value = value - t + h;
  518:  op add :value *tmp48 :h                                      ...
  519:  op sub :head :head 1                                         head -= 1;
  520:  jump *label183 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  521:  op sub :head 511 1                                           ...
        label *label183                                              ...
  522:  op sub :tail :tail 1                                         tail -= 1;
  523:  jump *label185 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  524:  op sub :tail 511 1                                           ...
        label *label185                                              ...
  525:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  526:  op add :y 10 *tmp56                                          ...
  527:  draw line 54 :last 49 :y 0 0                                 line(x, last, x - 5, y);
  528:  set :last :y                                                 last = y;
  529:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  530:  read :t bank1 :tail                                          t = MEMORY[tail];
  531:  read :h bank1 :head                                          h = MEMORY[head];
  532:  op sub *tmp48 :value :t                                      value = value - t + h;
  533:  op add :value *tmp48 :h                                      ...
  534:  op sub :head :head 1                                         head -= 1;
  535:  jump *label189 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  536:  op sub :head 511 1                                           ...
        label *label189                                              ...
  537:  op sub :tail :tail 1                                         tail -= 1;
  538:  jump *label191 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  539:  op sub :tail 511 1                                           ...
        label *label191                                              ...
  540:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  541:  op add :y 10 *tmp56                                          ...
  542:  draw line 49 :last 44 :y 0 0                                 line(x, last, x - 5, y);
  543:  set :last :y                                                 last = y;
  544:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  545:  read :t bank1 :tail                                          t = MEMORY[tail];
  546:  read :h bank1 :head                                          h = MEMORY[head];
  547:  op sub *tmp48 :value :t                                      value = value - t + h;
  548:  op add :value *tmp48 :h                                      ...
  549:  op sub :head :head 1                                         head -= 1;
  550:  jump *label195 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  551:  op sub :head 511 1                                           ...
        label *label195                                              ...
  552:  op sub :tail :tail 1                                         tail -= 1;
  553:  jump *label197 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  554:  op sub :tail 511 1                                           ...
        label *label197                                              ...
  555:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  556:  op add :y 10 *tmp56                                          ...
  557:  draw line 44 :last 39 :y 0 0                                 line(x, last, x - 5, y);
  558:  set :last :y                                                 last = y;
  559:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  560:  read :t bank1 :tail                                          t = MEMORY[tail];
  561:  read :h bank1 :head                                          h = MEMORY[head];
  562:  op sub *tmp48 :value :t                                      value = value - t + h;
  563:  op add :value *tmp48 :h                                      ...
  564:  op sub :head :head 1                                         head -= 1;
  565:  jump *label201 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  566:  op sub :head 511 1                                           ...
        label *label201                                              ...
  567:  op sub :tail :tail 1                                         tail -= 1;
  568:  jump *label203 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  569:  op sub :tail 511 1                                           ...
        label *label203                                              ...
  570:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  571:  op add :y 10 *tmp56                                          ...
  572:  draw line 39 :last 34 :y 0 0                                 line(x, last, x - 5, y);
  573:  set :last :y                                                 last = y;
  574:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  575:  read :t bank1 :tail                                          t = MEMORY[tail];
  576:  read :h bank1 :head                                          h = MEMORY[head];
  577:  op sub *tmp48 :value :t                                      value = value - t + h;
  578:  op add :value *tmp48 :h                                      ...
  579:  op sub :head :head 1                                         head -= 1;
  580:  jump *label207 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  581:  op sub :head 511 1                                           ...
        label *label207                                              ...
  582:  op sub :tail :tail 1                                         tail -= 1;
  583:  jump *label209 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  584:  op sub :tail 511 1                                           ...
        label *label209                                              ...
  585:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  586:  op add :y 10 *tmp56                                          ...
  587:  draw line 34 :last 29 :y 0 0                                 line(x, last, x - 5, y);
  588:  set :last :y                                                 last = y;
  589:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  590:  read :t bank1 :tail                                          t = MEMORY[tail];
  591:  read :h bank1 :head                                          h = MEMORY[head];
  592:  op sub *tmp48 :value :t                                      value = value - t + h;
  593:  op add :value *tmp48 :h                                      ...
  594:  op sub :head :head 1                                         head -= 1;
  595:  jump *label213 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  596:  op sub :head 511 1                                           ...
        label *label213                                              ...
  597:  op sub :tail :tail 1                                         tail -= 1;
  598:  jump *label215 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  599:  op sub :tail 511 1                                           ...
        label *label215                                              ...
  600:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  601:  op add :y 10 *tmp56                                          ...
  602:  draw line 29 :last 24 :y 0 0                                 line(x, last, x - 5, y);
  603:  set :last :y                                                 last = y;
  604:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  605:  read :t bank1 :tail                                          t = MEMORY[tail];
  606:  read :h bank1 :head                                          h = MEMORY[head];
  607:  op sub *tmp48 :value :t                                      value = value - t + h;
  608:  op add :value *tmp48 :h                                      ...
  609:  op sub :head :head 1                                         head -= 1;
  610:  jump *label219 greaterThan :head 256                         if head <= INDEX then head = SIZE - 1; end;
  611:  op sub :head 511 1                                           ...
        label *label219                                              ...
  612:  op sub :tail :tail 1                                         tail -= 1;
  613:  jump *label221 greaterThan :tail 256                         if tail <= INDEX then tail = SIZE - 1; end;
  614:  op sub :tail 511 1                                           ...
        label *label221                                              ...
  615:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  616:  op add :y 10 *tmp56                                          ...
  617:  draw line 24 :last 19 :y 0 0                                 line(x, last, x - 5, y);
  618:  set :last :y                                                 last = y;
  619:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  620:  read :t bank1 :tail                                          t = MEMORY[tail];
  621:  read :h bank1 :head                                          h = MEMORY[head];
  622:  op sub *tmp48 :value :t                                      value = value - t + h;
  623:  op add :value *tmp48 :h                                      ...
  624:  op mul *tmp56 :value :scale                                  y = 10 + value * scale;
  625:  op add :y 10 *tmp56                                          ...
  626:  draw line 19 :last 14 :y 0 0                                 line(x, last, x - 5, y);
  627:  op max :newMax :newMax :value                                newMax = max(newMax, value);
  628:  draw color 255 255 255 255 0 0                               color(255,255,255,255);
  629:  draw lineRect 10 10 156 156 0 0                              lineRect(10,10,156,156);
  630:  op max :maximum :newMax :maximum                             maximum = max(newMax, maximum);
  631:  op mul *tmp62 3 :newMax                                      if 3 * newMax < maximum then
  632:  jump *label29 greaterThanEq *tmp62 :maximum                  ...
  633:  op mul :maximum 1.5 :newMax                                  maximum = 1.5 * newMax;
        label *label29                                               if 3 * newMax < maximum then
  634:  write :maximum cell1 0                                       COORD[POSITION] = maximum;
  635:  op sub *tmp68 @time :start                                   print($"\n[lightgray]Loop time: $ ms", floor(@time - start));
  636:  op floor *tmp69 *tmp68 0                                     ...
  637:  print "\n[lightgray]Loop time: "                             ...
  638:  print *tmp69                                                 ...
  639:  print " ms"                                                  ...
  640:  op div *tmp70 @time 1000                                     wait = FREQ * ceil(@time / FREQ);
  641:  op ceil *tmp71 *tmp70 0                                      ...
  642:  op mul :wait 1000 *tmp71                                     ...
  643:  set :loops 0                                                 loops = 0;
  644:  jump *label33 greaterThanEq @time :wait                      while @time < wait do
        label *label38                                               ...
  645:  op add :loops :loops 1                                       loops += 1;
  646:  jump *label38 lessThan @time :wait                           while @time < wait do
        label *label33                                               ...
  647:  drawflush display1                                           drawflush(display1);
  648:  print "\nLoops: "                                            print("\nLoops: ", loops);
  649:  print :loops                                                 ...
  650:  printflush message1                                          printflush(message1);
  651:  sensor *tmp18 switch1 @enabled                               while switch1.@enabled == 0 do
  652:  jump *label230 equal *tmp18 0                                ...
        label *label9                                                ...
  653:  control enabled switch1 0 0 0 0                              switch1.enabled = 0;


Performance: parsed in 161 ms, compiled in 208 ms, optimized in 519 ms, run in 18 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (128 steps):
Item Rate Display
[gold]Initializing...[]

Execution exception at instruction 155: sensor *tmp18 switch1 @enabled:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
