   239 instructions before optimizations.
    10 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    16 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     8 instructions eliminated by Jump Optimization (4 iterations).
     7 instructions eliminated by Single Step Elimination (3 passes, 7 iterations).
    97 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
     1 instructions modified by If Expression Optimization (3 iterations).
    54 instructions eliminated by Data Flow Optimization (4 passes, 15 iterations).
     2 instructions eliminated by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
   110 instructions added by Loop Unrolling (6 iterations).
     3 loops unrolled by Loop Unrolling.
     2 instructions eliminated by Jump Straightening (4 iterations).
     3 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination.
    21 instructions eliminated by Print Merging.
    89 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 818):
  * Unroll iteration loop at line 32:9                           cost     0, benefit      475.0, efficiency   Infinity (-8 instructions)
    Unroll loop at line 73:9                                     cost     6, benefit     5000.0, efficiency      833.3
    Unroll loop at line 86:9                                     cost     6, benefit     5000.0, efficiency      833.3

Pass 1: speed optimization selection (cost limit 826):
  * Unroll loop at line 73:9                                     cost     6, benefit     5000.0, efficiency      833.3 (+54 instructions)
    Unroll loop at line 86:9                                     cost     6, benefit     5000.0, efficiency      833.3

Pass 1: speed optimization selection (cost limit 772):
  * Unroll loop at line 86:9                                     cost     6, benefit     5000.0, efficiency      833.3 (+54 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    33 getlink *tmp2 :initialize.0:n
    34 set :initialize.0:block *tmp2
    35 sensor *tmp4 :initialize.0:block @type
-    * set *tmp5 *tmp4
-    * jump *label16 equal *tmp5 @memory-cell
-    * jump *label16 equal *tmp5 @memory-bank
+   36 jump *label16 equal *tmp4 @memory-cell
+   37 jump *label16 equal *tmp4 @memory-bank
    38 jump *label15 always
    39 label *label16
    40 set .memory :initialize.0:block
    41 set *tmp3 .memory
    42 jump *label14 always
    43 label *label15
-    * jump *label18 equal *tmp5 @plastanium-conveyor
+   44 jump *label18 equal *tmp4 @plastanium-conveyor
    45 jump *label17 always
    46 label *label18
    47 set .conv*3 .conv*2

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-11 instructions):
 
    38 jump *label15 always
    39 label *label16
    40 set .memory :initialize.0:block
-    * set *tmp3 .memory
    41 jump *label14 always
    42 label *label15
    43 jump *label18 equal *tmp4 @plastanium-conveyor
 
    49 set .conv*0 :initialize.0:block
    50 set *tmp6 .found
    51 op add .found .found 1
-    * set *tmp3 *tmp6
    52 jump *label14 always
    53 label *label17
-    * set *tmp3 null
    54 label *label14
    55 label *label12
    56 op sub :initialize.0:n :initialize.0:n 1
 
    67 print .found
    68 print ")"
    69 printflush message1
-    * set *tmp8 null
    70 jump *label20 always
    71 label *label19
    72 op greaterThan *tmp9 .found 4
 
   107 label *label24
   108 set *tmp10 *tmp12
   109 label *label22
-    * set *tmp8 *tmp10
   110 label *label20
   111 label *label2
   112 jump *label1 always
 
   131 jump *label33 equal *tmp28 false
   132 op add *tmp30 .total 10
   133 set .total *tmp30
-    * set *tmp29 *tmp30
   134 jump *label34 always
   135 label *label33
-    * set *tmp29 null
   136 label *label34
   137 label *label31
   138 op add :i :i 1
 
   171 jump *label38 equal *tmp43 false
   172 op add *tmp45 .total 10
   173 set .total *tmp45
-    * set *tmp44 *tmp45
   174 jump *label39 always
   175 label *label38
-    * set *tmp44 null
   176 label *label39
   177 label *label36
   178 op add :i.1 :i.1 1
 
   190 op notEqual *tmp49 .links @links
   191 jump *label40 equal *tmp49 false
   192 end
-    * set *tmp50 null
   193 jump *label41 always
   194 label *label40
-    * set *tmp50 null
   195 label *label41
   196 label *label28
   197 sensor *tmp51 switch1 @enabled

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-3 instructions):
 
    47 set .conv*2 .conv*1
    48 set .conv*1 .conv*0
    49 set .conv*0 :initialize.0:block
-    * set *tmp6 .found
    50 op add .found .found 1
    51 jump *label14 always
    52 label *label17
 
    79 print .found
    80 print ")"
    81 printflush message1
-    * set *tmp10 null
    82 jump *label22 always
    83 label *label21
    84 op equal *tmp11 .memory null
 
   103 jump *label3 always
   104 set *tmp12 null
   105 label *label24
-    * set *tmp10 *tmp12
   106 label *label22
   107 label *label20
   108 label *label2

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
    85 jump *label23 equal *tmp11 false
    86 print "$TITLE\n[salmon]No memory attached."
    87 printflush message1
-    * set *tmp12 null
    88 jump *label24 always
    89 label *label23
    90 sensor *tmp13 .memory @type
 
   100 read *tmp17 .memory *tmp16
   101 set .total *tmp17
   102 jump *label3 always
-    * set *tmp12 null
   103 label *label24
   104 label *label22
   105 label *label20

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-10 instructions):
 
    25 label *label6
    26 set .memory null
    27 set .found 0
-    * set *tmp1 @links
-    * set .links *tmp1
+   28 set .links @links
    29 op sub :initialize.0:n .links 1
    30 label *label11
    31 jump *label13 lessThan :initialize.0:n 0
-    * getlink *tmp2 :initialize.0:n
-    * set :initialize.0:block *tmp2
+   32 getlink :initialize.0:block :initialize.0:n
    33 sensor *tmp4 :initialize.0:block @type
    34 jump *label16 equal *tmp4 @memory-cell
    35 jump *label16 equal *tmp4 @memory-bank
 
    94 set *tmp15 511
    95 label *label26
    96 set .totalIndex *tmp15
-    * set *tmp16 .totalIndex
-    * read *tmp17 .memory *tmp16
-    * set .total *tmp17
+   97 read .total .memory .totalIndex
    98 jump *label3 always
    99 label *label24
   100 label *label22
 
   110 label *label30
   111 jump *label32 greaterThanEq :i 4
   112 set *tmp19 :i
-    * set *tmp21 :i
-    * readarr *tmp22 .conv[] *tmp21
+  113 readarr *tmp22 .conv[] :i
   114 sensor *tmp23 *tmp22 @totalItems
   115 writearr *tmp23 .state1[] *tmp19
   116 set *tmp24 :i
 
   119 readarr *tmp27 .state2[] *tmp26
   120 op lessThan *tmp28 *tmp25 *tmp27
   121 jump *label33 equal *tmp28 false
-    * op add *tmp30 .total 10
-    * set .total *tmp30
+  122 op add .total .total 10
   123 jump *label34 always
   124 label *label33
   125 label *label34
 
   128 jump *label30 always
   129 label *label32
   130 set *tmp31 .totalIndex
-    * set *tmp33 .total
-    * write *tmp33 .memory *tmp31
+  131 write .total .memory *tmp31
   132 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   133 print " "
   134 print "           "
 
   147 label *label35
   148 jump *label37 greaterThanEq :i.1 4
   149 set *tmp34 :i.1
-    * set *tmp36 :i.1
-    * readarr *tmp37 .conv[] *tmp36
+  150 readarr *tmp37 .conv[] :i.1
   151 sensor *tmp38 *tmp37 @totalItems
   152 writearr *tmp38 .state2[] *tmp34
   153 set *tmp39 :i.1
 
   156 readarr *tmp42 .state1[] *tmp41
   157 op lessThan *tmp43 *tmp40 *tmp42
   158 jump *label38 equal *tmp43 false
-    * op add *tmp45 .total 10
-    * set .total *tmp45
+  159 op add .total .total 10
   160 jump *label39 always
   161 label *label38
   162 label *label39
 
   185 jump *label27 notEqual *tmp52 false
   186 label *label29
   187 set .total 0
-    * set *tmp53 .totalIndex
-    * write 0 .memory *tmp53
+  188 write 0 .memory .totalIndex
   189 end

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
     0 label *label1
-    * jump *label3 equal true false
     1 setaddr *tmp0 *label7
     2 set :initialize.0:c .conv*0
     3 jump *label4 always

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-2 instructions):
 
    31 getlink :initialize.0:block :initialize.0:n
    32 sensor *tmp4 :initialize.0:block @type
    33 jump *label16 equal *tmp4 @memory-cell
-    * jump *label16 equal *tmp4 @memory-bank
-    * jump *label15 always
+   34 jump *label15 notEqual *tmp4 @memory-bank
    35 label *label16
    36 set .memory :initialize.0:block
    37 jump *label14 always
    38 label *label15
-    * jump *label18 equal *tmp4 @plastanium-conveyor
-    * jump *label17 always
+   39 jump *label17 notEqual *tmp4 @plastanium-conveyor
    40 label *label18
    41 set .conv*3 .conv*2
    42 set .conv*2 .conv*1

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-8 instructions):
 
    50 op sub :initialize.0:n :initialize.0:n 1
    51 jump *label11 always
    52 label *label13
-    * op equal *tmp7 .found 0
-    * jump *label19 equal *tmp7 false
+   53 jump *label19 notEqual .found 0
    54 print "[gold]Item Counter Micro[], version [gold]1.0[]"
    55 print "\"
    56 print "n[salmon]No plastanium conveyor attached (maximum: "
 
    62 printflush message1
    63 jump *label20 always
    64 label *label19
-    * op greaterThan *tmp9 .found 4
-    * jump *label21 equal *tmp9 false
+   65 jump *label21 lessThanEq .found 4
    66 print "[gold]Item Counter Micro[], version [gold]1.0[]"
    67 print "\"
    68 print "n[salmon]Too many plastanium conveyors attached (maximum: "
 
    74 printflush message1
    75 jump *label22 always
    76 label *label21
-    * op equal *tmp11 .memory null
-    * jump *label23 equal *tmp11 false
+   77 jump *label23 notEqual .memory null
    78 print "$TITLE\n[salmon]No memory attached."
    79 printflush message1
    80 jump *label24 always
    81 label *label23
    82 sensor *tmp13 .memory @type
-    * op equal *tmp14 *tmp13 @memory-cell
-    * jump *label25 equal *tmp14 false
+   83 jump *label25 notEqual *tmp13 @memory-cell
    84 set *tmp15 63
    85 jump *label26 always
    86 label *label25
 
   110 set *tmp26 :i
   111 readarr *tmp25 .state1[] *tmp24
   112 readarr *tmp27 .state2[] *tmp26
-    * op lessThan *tmp28 *tmp25 *tmp27
-    * jump *label33 equal *tmp28 false
+  113 jump *label33 greaterThanEq *tmp25 *tmp27
   114 op add .total .total 10
   115 jump *label34 always
   116 label *label33
 
   146 set *tmp41 :i.1
   147 readarr *tmp40 .state2[] *tmp39
   148 readarr *tmp42 .state1[] *tmp41
-    * op lessThan *tmp43 *tmp40 *tmp42
-    * jump *label38 equal *tmp43 false
+  149 jump *label38 greaterThanEq *tmp40 *tmp42
   150 op add .total .total 10
   151 jump *label39 always
   152 label *label38
 
   164 print "ms"
   165 print "\n"
   166 printflush message1
-    * op notEqual *tmp49 .links @links
-    * jump *label40 equal *tmp49 false
+  167 jump *label40 equal .links @links
   168 end
   169 jump *label41 always
   170 label *label40
   171 label *label41
   172 label *label28
   173 sensor *tmp51 switch1 @enabled
-    * op equal *tmp52 *tmp51 false
-    * jump *label27 notEqual *tmp52 false
+  174 jump *label27 equal *tmp51 false
   175 label *label29
   176 set .total 0
   177 write 0 .memory .totalIndex

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    43 set .conv*1 .conv*0
    44 set .conv*0 :initialize.0:block
    45 op add .found .found 1
-    * jump *label14 always
    46 label *label17
    47 label *label14
    48 label *label12
 
   111 readarr *tmp27 .state2[] *tmp26
   112 jump *label33 greaterThanEq *tmp25 *tmp27
   113 op add .total .total 10
-    * jump *label34 always
   114 label *label33
   115 label *label34
   116 label *label31
 
   146 readarr *tmp42 .state1[] *tmp41
   147 jump *label38 greaterThanEq *tmp40 *tmp42
   148 op add .total .total 10
-    * jump *label39 always
   149 label *label38
   150 label *label39
   151 label *label36
 
   163 printflush message1
   164 jump *label40 equal .links @links
   165 end
-    * jump *label41 always
   166 label *label40
   167 label *label41
   168 label *label28

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   153 jump *label35 always
   154 label *label37
   155 op sub *tmp46 @time :start
-    * op div *tmp47 *tmp46 2
-    * op floor *tmp48 *tmp47
+  156 op idiv *tmp48 *tmp46 2
   157 print "[lightgray]Loop time: "
   158 print *tmp48
   159 print " "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
     0 label *label1
     1 setaddr *tmp0 *label7
-    * set :initialize.0:c .conv*0
     2 jump *label4 always
     3 multilabel *label7 marker0
-    * set .conv*0 :initialize.0:c
+    4 set .conv*0 null
     5 setaddr *tmp0 *label8
-    * set :initialize.0:c .conv*1
     6 jump *label4 always
     7 multilabel *label8 marker0
-    * set .conv*1 :initialize.0:c
+    8 set .conv*1 null
     9 setaddr *tmp0 *label9
-    * set :initialize.0:c .conv*2
    10 jump *label4 always
    11 multilabel *label9 marker0
-    * set .conv*2 :initialize.0:c
+   12 set .conv*2 null
    13 setaddr *tmp0 *label10
-    * set :initialize.0:c .conv*3
    14 label *label4
    15 set :initialize.0:c null
    16 label *label5
    17 multijump *tmp0 0 0 marker0
    18 multilabel *label10 marker0
-    * set .conv*3 :initialize.0:c
+   19 set .conv*3 null
    20 label *label6
    21 set .memory null
    22 set .found 0
 
    82 set *tmp15 511
    83 label *label26
    84 set .totalIndex *tmp15
-    * read .total .memory .totalIndex
+   85 read .total .memory *tmp15
    86 jump *label3 always
    87 label *label24
    88 label *label22
 
   100 set *tmp19 :i
   101 readarr *tmp22 .conv[] :i
   102 sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] *tmp19
+  103 writearr *tmp23 .state1[] :i
   104 set *tmp24 :i
   105 set *tmp26 :i
-    * readarr *tmp25 .state1[] *tmp24
-    * readarr *tmp27 .state2[] *tmp26
+  106 readarr *tmp25 .state1[] :i
+  107 readarr *tmp27 .state2[] :i
   108 jump *label33 greaterThanEq *tmp25 *tmp27
   109 op add .total .total 10
   110 label *label33
 
   114 jump *label30 always
   115 label *label32
   116 set *tmp31 .totalIndex
-    * write .total .memory *tmp31
+  117 write .total .memory .totalIndex
   118 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   119 print " "
   120 print "           "
 
   135 set *tmp34 :i.1
   136 readarr *tmp37 .conv[] :i.1
   137 sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] *tmp34
+  138 writearr *tmp38 .state2[] :i.1
   139 set *tmp39 :i.1
   140 set *tmp41 :i.1
-    * readarr *tmp40 .state2[] *tmp39
-    * readarr *tmp42 .state1[] *tmp41
+  141 readarr *tmp40 .state2[] :i.1
+  142 readarr *tmp42 .state1[] :i.1
   143 jump *label38 greaterThanEq *tmp40 *tmp42
   144 op add .total .total 10
   145 label *label38

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-8 instructions):
 
    12 set .conv*2 null
    13 setaddr *tmp0 *label10
    14 label *label4
-    * set :initialize.0:c null
    15 label *label5
    16 multijump *tmp0 0 0 marker0
    17 multilabel *label10 marker0
 
    96 set :i 0
    97 label *label30
    98 jump *label32 greaterThanEq :i 4
-    * set *tmp19 :i
    99 readarr *tmp22 .conv[] :i
   100 sensor *tmp23 *tmp22 @totalItems
   101 writearr *tmp23 .state1[] :i
-    * set *tmp24 :i
-    * set *tmp26 :i
   102 readarr *tmp25 .state1[] :i
   103 readarr *tmp27 .state2[] :i
   104 jump *label33 greaterThanEq *tmp25 *tmp27
 
   109 op add :i :i 1
   110 jump *label30 always
   111 label *label32
-    * set *tmp31 .totalIndex
   112 write .total .memory .totalIndex
   113 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   114 print " "
 
   127 set :i.1 0
   128 label *label35
   129 jump *label37 greaterThanEq :i.1 4
-    * set *tmp34 :i.1
   130 readarr *tmp37 .conv[] :i.1
   131 sensor *tmp38 *tmp37 @totalItems
   132 writearr *tmp38 .state2[] :i.1
-    * set *tmp39 :i.1
-    * set *tmp41 :i.1
   133 readarr *tmp40 .state2[] :i.1
   134 readarr *tmp42 .state1[] :i.1
   135 jump *label38 greaterThanEq *tmp40 *tmp42

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-2 instructions):
 
    23 op sub :initialize.0:n .links 1
    24 label *label11
    25 jump *label13 lessThan :initialize.0:n 0
+   26 label *label42
    27 getlink :initialize.0:block :initialize.0:n
    28 sensor *tmp4 :initialize.0:block @type
    29 jump *label16 equal *tmp4 @memory-cell
 
    43 label *label14
    44 label *label12
    45 op sub :initialize.0:n :initialize.0:n 1
-    * jump *label11 always
+   46 jump *label42 greaterThanEq :initialize.0:n 0
    47 label *label13
    48 jump *label19 notEqual .found 0
    49 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
    96 set :start @time
    97 set :i 0
    98 label *label30
-    * jump *label32 greaterThanEq :i 4
+   99 label *label43
   100 readarr *tmp22 .conv[] :i
   101 sensor *tmp23 *tmp22 @totalItems
   102 writearr *tmp23 .state1[] :i
 
   108 label *label34
   109 label *label31
   110 op add :i :i 1
-    * jump *label30 always
+  111 jump *label43 lessThan :i 4
   112 label *label32
   113 write .total .memory .totalIndex
   114 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
   127 print "\n"
   128 set :i.1 0
   129 label *label35
-    * jump *label37 greaterThanEq :i.1 4
+  130 label *label44
   131 readarr *tmp37 .conv[] :i.1
   132 sensor *tmp38 *tmp37 @totalItems
   133 writearr *tmp38 .state2[] :i.1
 
   139 label *label39
   140 label *label36
   141 op add :i.1 :i.1 1
-    * jump *label35 always
+  142 jump *label44 lessThan :i.1 4
   143 label *label37
   144 op sub *tmp46 @time :start
   145 op idiv *tmp48 *tmp46 2

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1:
 
    74 printflush message1
    75 jump *label24 always
    76 label *label23
+   77 set *tmp15 511
    78 sensor *tmp13 .memory @type
-    * jump *label25 notEqual *tmp13 @memory-cell
+   79 jump *label26 notEqual *tmp13 @memory-cell
    80 set *tmp15 63
    81 jump *label26 always
-    * label *label25
-    * set *tmp15 511
    82 label *label26
    83 set .totalIndex *tmp15
    84 read .total .memory *tmp15

Modifications by Unroll iteration loop at line 32:9 (-8 instructions):
     0 label *label1
-    * setaddr *tmp0 *label7
-    * jump *label4 always
-    * multilabel *label7 marker0
-    * set .conv*0 null
-    * setaddr *tmp0 *label8
-    * jump *label4 always
-    * multilabel *label8 marker0
-    * set .conv*1 null
-    * setaddr *tmp0 *label9
-    * jump *label4 always
-    * multilabel *label9 marker0
-    * set .conv*2 null
-    * setaddr *tmp0 *label10
-    * label *label4
-    * label *label5
-    * multijump *tmp0 0 0 marker0
-    * multilabel *label10 marker0
-    * set .conv*3 null
-    * label *label6
+    1 label *label45
+    2 label *label46
+    3 set .conv*0 null
+    4 label *label49
+    5 label *label50
+    6 set .conv*1 null
+    7 label *label53
+    8 label *label54
+    9 set .conv*2 null
+   10 label *label57
+   11 label *label58
+   12 set .conv*3 null
+   13 label *label6
    14 set .memory null
    15 set .found 0
    16 set .links @links

Modifications by Unroll loop at line 73:9 (+59 instructions):
 
    87 control enabled switch1 false
    88 label *label27
    89 set :start @time
-    * set :i 0
-    * label *label30
-    * label *label43
-    * readarr *tmp22 .conv[] :i
-    * sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] :i
-    * readarr *tmp25 .state1[] :i
-    * readarr *tmp27 .state2[] :i
-    * jump *label33 greaterThanEq *tmp25 *tmp27
-    * op add .total .total 10
-    * label *label33
-    * label *label34
-    * label *label31
-    * op add :i :i 1
-    * jump *label43 lessThan :i 4
-    * label *label32
+   90 set :i 0
+   91 label *label62
+   92 label *label63
+   93 readarr *tmp22 .conv[] :i
+   94 sensor *tmp23 *tmp22 @totalItems
+   95 writearr *tmp23 .state1[] :i
+   96 readarr *tmp25 .state1[] :i
+   97 readarr *tmp27 .state2[] :i
+   98 jump *label64 greaterThanEq *tmp25 *tmp27
+   99 op add .total .total 10
+  100 label *label64
+  101 label *label65
+  102 label *label66
+  103 op add :i :i 1
+  104 label *label67
+  105 readarr *tmp22 .conv[] :i
+  106 sensor *tmp23 *tmp22 @totalItems
+  107 writearr *tmp23 .state1[] :i
+  108 readarr *tmp25 .state1[] :i
+  109 readarr *tmp27 .state2[] :i
+  110 jump *label68 greaterThanEq *tmp25 *tmp27
+  111 op add .total .total 10
+  112 label *label68
+  113 label *label69
+  114 label *label70
+  115 op add :i :i 1
+  116 label *label71
+  117 readarr *tmp22 .conv[] :i
+  118 sensor *tmp23 *tmp22 @totalItems
+  119 writearr *tmp23 .state1[] :i
+  120 readarr *tmp25 .state1[] :i
+  121 readarr *tmp27 .state2[] :i
+  122 jump *label72 greaterThanEq *tmp25 *tmp27
+  123 op add .total .total 10
+  124 label *label72
+  125 label *label73
+  126 label *label74
+  127 op add :i :i 1
+  128 label *label75
+  129 readarr *tmp22 .conv[] :i
+  130 sensor *tmp23 *tmp22 @totalItems
+  131 writearr *tmp23 .state1[] :i
+  132 readarr *tmp25 .state1[] :i
+  133 readarr *tmp27 .state2[] :i
+  134 jump *label76 greaterThanEq *tmp25 *tmp27
+  135 op add .total .total 10
+  136 label *label76
+  137 label *label77
+  138 label *label78
+  139 op add :i :i 1
+  140 label *label32
   141 write .total .memory .totalIndex
   142 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   143 print " "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    90 set :i 0
    91 label *label62
    92 label *label63
-    * readarr *tmp22 .conv[] :i
+   93 readarr *tmp22 .conv[] 0
    94 sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] :i
-    * readarr *tmp25 .state1[] :i
-    * readarr *tmp27 .state2[] :i
+   95 writearr *tmp23 .state1[] 0
+   96 readarr *tmp25 .state1[] 0
+   97 readarr *tmp27 .state2[] 0
    98 jump *label64 greaterThanEq *tmp25 *tmp27
    99 op add .total .total 10
   100 label *label64
   101 label *label65
   102 label *label66
-    * op add :i :i 1
+  103 op add :i 0 1
   104 label *label67
-    * readarr *tmp22 .conv[] :i
+  105 readarr *tmp22 .conv[] 1
   106 sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] :i
-    * readarr *tmp25 .state1[] :i
-    * readarr *tmp27 .state2[] :i
+  107 writearr *tmp23 .state1[] 1
+  108 readarr *tmp25 .state1[] 1
+  109 readarr *tmp27 .state2[] 1
   110 jump *label68 greaterThanEq *tmp25 *tmp27
   111 op add .total .total 10
   112 label *label68
   113 label *label69
   114 label *label70
-    * op add :i :i 1
+  115 op add :i 1 1
   116 label *label71
-    * readarr *tmp22 .conv[] :i
+  117 readarr *tmp22 .conv[] 2
   118 sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] :i
-    * readarr *tmp25 .state1[] :i
-    * readarr *tmp27 .state2[] :i
+  119 writearr *tmp23 .state1[] 2
+  120 readarr *tmp25 .state1[] 2
+  121 readarr *tmp27 .state2[] 2
   122 jump *label72 greaterThanEq *tmp25 *tmp27
   123 op add .total .total 10
   124 label *label72
   125 label *label73
   126 label *label74
-    * op add :i :i 1
+  127 op add :i 2 1
   128 label *label75
-    * readarr *tmp22 .conv[] :i
+  129 readarr *tmp22 .conv[] 3
   130 sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] :i
-    * readarr *tmp25 .state1[] :i
-    * readarr *tmp27 .state2[] :i
+  131 writearr *tmp23 .state1[] 3
+  132 readarr *tmp25 .state1[] 3
+  133 readarr *tmp27 .state2[] 3
   134 jump *label76 greaterThanEq *tmp25 *tmp27
   135 op add .total .total 10
   136 label *label76
   137 label *label77
   138 label *label78
-    * op add :i :i 1
+  139 op add :i 3 1
   140 label *label32
   141 write .total .memory .totalIndex
   142 print "[gold]Item Counter Micro[], version [gold]1.0[]"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    87 control enabled switch1 false
    88 label *label27
    89 set :start @time
-    * set :i 0
    90 label *label62
    91 label *label63
    92 readarr *tmp22 .conv[] 0
 
    99 label *label64
   100 label *label65
   101 label *label66
-    * op add :i 0 1
   102 label *label67
   103 readarr *tmp22 .conv[] 1
   104 sensor *tmp23 *tmp22 @totalItems
 
   110 label *label68
   111 label *label69
   112 label *label70
-    * op add :i 1 1
   113 label *label71
   114 readarr *tmp22 .conv[] 2
   115 sensor *tmp23 *tmp22 @totalItems
 
   121 label *label72
   122 label *label73
   123 label *label74
-    * op add :i 2 1
   124 label *label75
   125 readarr *tmp22 .conv[] 3
   126 sensor *tmp23 *tmp22 @totalItems
 
   132 label *label76
   133 label *label77
   134 label *label78
-    * op add :i 3 1
   135 label *label32
   136 write .total .memory .totalIndex
   137 print "[gold]Item Counter Micro[], version [gold]1.0[]"

Modifications by Unroll loop at line 86:9 (+59 instructions):
 
   148 print "["
   149 print "]"
   150 print "\n"
-    * set :i.1 0
-    * label *label35
-    * label *label44
-    * readarr *tmp37 .conv[] :i.1
-    * sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] :i.1
-    * readarr *tmp40 .state2[] :i.1
-    * readarr *tmp42 .state1[] :i.1
-    * jump *label38 greaterThanEq *tmp40 *tmp42
-    * op add .total .total 10
-    * label *label38
-    * label *label39
-    * label *label36
-    * op add :i.1 :i.1 1
-    * jump *label44 lessThan :i.1 4
-    * label *label37
+  151 set :i.1 0
+  152 label *label79
+  153 label *label80
+  154 readarr *tmp37 .conv[] :i.1
+  155 sensor *tmp38 *tmp37 @totalItems
+  156 writearr *tmp38 .state2[] :i.1
+  157 readarr *tmp40 .state2[] :i.1
+  158 readarr *tmp42 .state1[] :i.1
+  159 jump *label81 greaterThanEq *tmp40 *tmp42
+  160 op add .total .total 10
+  161 label *label81
+  162 label *label82
+  163 label *label83
+  164 op add :i.1 :i.1 1
+  165 label *label84
+  166 readarr *tmp37 .conv[] :i.1
+  167 sensor *tmp38 *tmp37 @totalItems
+  168 writearr *tmp38 .state2[] :i.1
+  169 readarr *tmp40 .state2[] :i.1
+  170 readarr *tmp42 .state1[] :i.1
+  171 jump *label85 greaterThanEq *tmp40 *tmp42
+  172 op add .total .total 10
+  173 label *label85
+  174 label *label86
+  175 label *label87
+  176 op add :i.1 :i.1 1
+  177 label *label88
+  178 readarr *tmp37 .conv[] :i.1
+  179 sensor *tmp38 *tmp37 @totalItems
+  180 writearr *tmp38 .state2[] :i.1
+  181 readarr *tmp40 .state2[] :i.1
+  182 readarr *tmp42 .state1[] :i.1
+  183 jump *label89 greaterThanEq *tmp40 *tmp42
+  184 op add .total .total 10
+  185 label *label89
+  186 label *label90
+  187 label *label91
+  188 op add :i.1 :i.1 1
+  189 label *label92
+  190 readarr *tmp37 .conv[] :i.1
+  191 sensor *tmp38 *tmp37 @totalItems
+  192 writearr *tmp38 .state2[] :i.1
+  193 readarr *tmp40 .state2[] :i.1
+  194 readarr *tmp42 .state1[] :i.1
+  195 jump *label93 greaterThanEq *tmp40 *tmp42
+  196 op add .total .total 10
+  197 label *label93
+  198 label *label94
+  199 label *label95
+  200 op add :i.1 :i.1 1
+  201 label *label37
   202 op sub *tmp46 @time :start
   203 op idiv *tmp48 *tmp46 2
   204 print "[lightgray]Loop time: "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   151 set :i.1 0
   152 label *label79
   153 label *label80
-    * readarr *tmp37 .conv[] :i.1
+  154 readarr *tmp37 .conv[] 0
   155 sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] :i.1
-    * readarr *tmp40 .state2[] :i.1
-    * readarr *tmp42 .state1[] :i.1
+  156 writearr *tmp38 .state2[] 0
+  157 readarr *tmp40 .state2[] 0
+  158 readarr *tmp42 .state1[] 0
   159 jump *label81 greaterThanEq *tmp40 *tmp42
   160 op add .total .total 10
   161 label *label81
   162 label *label82
   163 label *label83
-    * op add :i.1 :i.1 1
+  164 op add :i.1 0 1
   165 label *label84
-    * readarr *tmp37 .conv[] :i.1
+  166 readarr *tmp37 .conv[] 1
   167 sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] :i.1
-    * readarr *tmp40 .state2[] :i.1
-    * readarr *tmp42 .state1[] :i.1
+  168 writearr *tmp38 .state2[] 1
+  169 readarr *tmp40 .state2[] 1
+  170 readarr *tmp42 .state1[] 1
   171 jump *label85 greaterThanEq *tmp40 *tmp42
   172 op add .total .total 10
   173 label *label85
   174 label *label86
   175 label *label87
-    * op add :i.1 :i.1 1
+  176 op add :i.1 1 1
   177 label *label88
-    * readarr *tmp37 .conv[] :i.1
+  178 readarr *tmp37 .conv[] 2
   179 sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] :i.1
-    * readarr *tmp40 .state2[] :i.1
-    * readarr *tmp42 .state1[] :i.1
+  180 writearr *tmp38 .state2[] 2
+  181 readarr *tmp40 .state2[] 2
+  182 readarr *tmp42 .state1[] 2
   183 jump *label89 greaterThanEq *tmp40 *tmp42
   184 op add .total .total 10
   185 label *label89
   186 label *label90
   187 label *label91
-    * op add :i.1 :i.1 1
+  188 op add :i.1 2 1
   189 label *label92
-    * readarr *tmp37 .conv[] :i.1
+  190 readarr *tmp37 .conv[] 3
   191 sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] :i.1
-    * readarr *tmp40 .state2[] :i.1
-    * readarr *tmp42 .state1[] :i.1
+  192 writearr *tmp38 .state2[] 3
+  193 readarr *tmp40 .state2[] 3
+  194 readarr *tmp42 .state1[] 3
   195 jump *label93 greaterThanEq *tmp40 *tmp42
   196 op add .total .total 10
   197 label *label93
   198 label *label94
   199 label *label95
-    * op add :i.1 :i.1 1
+  200 op add :i.1 3 1
   201 label *label37
   202 op sub *tmp46 @time :start
   203 op idiv *tmp48 *tmp46 2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
   148 print "["
   149 print "]"
   150 print "\n"
-    * set :i.1 0
   151 label *label79
   152 label *label80
   153 readarr *tmp37 .conv[] 0
 
   160 label *label81
   161 label *label82
   162 label *label83
-    * op add :i.1 0 1
   163 label *label84
   164 readarr *tmp37 .conv[] 1
   165 sensor *tmp38 *tmp37 @totalItems
 
   171 label *label85
   172 label *label86
   173 label *label87
-    * op add :i.1 1 1
   174 label *label88
   175 readarr *tmp37 .conv[] 2
   176 sensor *tmp38 *tmp37 @totalItems
 
   182 label *label89
   183 label *label90
   184 label *label91
-    * op add :i.1 2 1
   185 label *label92
   186 readarr *tmp37 .conv[] 3
   187 sensor *tmp38 *tmp37 @totalItems
 
   193 label *label93
   194 label *label94
   195 label *label95
-    * op add :i.1 3 1
   196 label *label37
   197 op sub *tmp46 @time :start
   198 op idiv *tmp48 *tmp46 2

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    72 sensor *tmp13 .memory @type
    73 jump *label26 notEqual *tmp13 @memory-cell
    74 set *tmp15 63
-    * jump *label26 always
    75 label *label26
    76 set .totalIndex *tmp15
    77 read .total .memory *tmp15

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-136 instructions):
 
    88 set :start @time
    89 label *label62
    90 label *label63
-    * readarr *tmp22 .conv[] 0
+   91 set *tmp22 .conv*0
    92 sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] 0
-    * readarr *tmp25 .state1[] 0
-    * readarr *tmp27 .state2[] 0
+   93 set .state1*0 *tmp23
+   94 set *tmp25 .state1*0
+   95 set *tmp27 .state2*0
    96 jump *label64 greaterThanEq *tmp25 *tmp27
    97 op add .total .total 10
    98 label *label64
    99 label *label65
   100 label *label66
   101 label *label67
-    * readarr *tmp22 .conv[] 1
+  102 set *tmp22 .conv*1
   103 sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] 1
-    * readarr *tmp25 .state1[] 1
-    * readarr *tmp27 .state2[] 1
+  104 set .state1*1 *tmp23
+  105 set *tmp25 .state1*1
+  106 set *tmp27 .state2*1
   107 jump *label68 greaterThanEq *tmp25 *tmp27
   108 op add .total .total 10
   109 label *label68
   110 label *label69
   111 label *label70
   112 label *label71
-    * readarr *tmp22 .conv[] 2
+  113 set *tmp22 .conv*2
   114 sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] 2
-    * readarr *tmp25 .state1[] 2
-    * readarr *tmp27 .state2[] 2
+  115 set .state1*2 *tmp23
+  116 set *tmp25 .state1*2
+  117 set *tmp27 .state2*2
   118 jump *label72 greaterThanEq *tmp25 *tmp27
   119 op add .total .total 10
   120 label *label72
   121 label *label73
   122 label *label74
   123 label *label75
-    * readarr *tmp22 .conv[] 3
+  124 set *tmp22 .conv*3
   125 sensor *tmp23 *tmp22 @totalItems
-    * writearr *tmp23 .state1[] 3
-    * readarr *tmp25 .state1[] 3
-    * readarr *tmp27 .state2[] 3
+  126 set .state1*3 *tmp23
+  127 set *tmp25 .state1*3
+  128 set *tmp27 .state2*3
   129 jump *label76 greaterThanEq *tmp25 *tmp27
   130 op add .total .total 10
   131 label *label76
 
   149 print "\n"
   150 label *label79
   151 label *label80
-    * readarr *tmp37 .conv[] 0
+  152 set *tmp37 .conv*0
   153 sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] 0
-    * readarr *tmp40 .state2[] 0
-    * readarr *tmp42 .state1[] 0
+  154 set .state2*0 *tmp38
+  155 set *tmp40 .state2*0
+  156 set *tmp42 .state1*0
   157 jump *label81 greaterThanEq *tmp40 *tmp42
   158 op add .total .total 10
   159 label *label81
   160 label *label82
   161 label *label83
   162 label *label84
-    * readarr *tmp37 .conv[] 1
+  163 set *tmp37 .conv*1
   164 sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] 1
-    * readarr *tmp40 .state2[] 1
-    * readarr *tmp42 .state1[] 1
+  165 set .state2*1 *tmp38
+  166 set *tmp40 .state2*1
+  167 set *tmp42 .state1*1
   168 jump *label85 greaterThanEq *tmp40 *tmp42
   169 op add .total .total 10
   170 label *label85
   171 label *label86
   172 label *label87
   173 label *label88
-    * readarr *tmp37 .conv[] 2
+  174 set *tmp37 .conv*2
   175 sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] 2
-    * readarr *tmp40 .state2[] 2
-    * readarr *tmp42 .state1[] 2
+  176 set .state2*2 *tmp38
+  177 set *tmp40 .state2*2
+  178 set *tmp42 .state1*2
   179 jump *label89 greaterThanEq *tmp40 *tmp42
   180 op add .total .total 10
   181 label *label89
   182 label *label90
   183 label *label91
   184 label *label92
-    * readarr *tmp37 .conv[] 3
+  185 set *tmp37 .conv*3
   186 sensor *tmp38 *tmp37 @totalItems
-    * writearr *tmp38 .state2[] 3
-    * readarr *tmp40 .state2[] 3
-    * readarr *tmp42 .state1[] 3
+  187 set .state2*3 *tmp38
+  188 set *tmp40 .state2*3
+  189 set *tmp42 .state1*3
   190 jump *label93 greaterThanEq *tmp40 *tmp42
   191 op add .total .total 10
   192 label *label93

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-8 instructions):
 
    89 label *label62
    90 label *label63
    91 set *tmp22 .conv*0
-    * sensor *tmp23 *tmp22 @totalItems
-    * set .state1*0 *tmp23
+   92 sensor .state1*0 *tmp22 @totalItems
    93 set *tmp25 .state1*0
    94 set *tmp27 .state2*0
    95 jump *label64 greaterThanEq *tmp25 *tmp27
 
    99 label *label66
   100 label *label67
   101 set *tmp22 .conv*1
-    * sensor *tmp23 *tmp22 @totalItems
-    * set .state1*1 *tmp23
+  102 sensor .state1*1 *tmp22 @totalItems
   103 set *tmp25 .state1*1
   104 set *tmp27 .state2*1
   105 jump *label68 greaterThanEq *tmp25 *tmp27
 
   109 label *label70
   110 label *label71
   111 set *tmp22 .conv*2
-    * sensor *tmp23 *tmp22 @totalItems
-    * set .state1*2 *tmp23
+  112 sensor .state1*2 *tmp22 @totalItems
   113 set *tmp25 .state1*2
   114 set *tmp27 .state2*2
   115 jump *label72 greaterThanEq *tmp25 *tmp27
 
   119 label *label74
   120 label *label75
   121 set *tmp22 .conv*3
-    * sensor *tmp23 *tmp22 @totalItems
-    * set .state1*3 *tmp23
+  122 sensor .state1*3 *tmp22 @totalItems
   123 set *tmp25 .state1*3
   124 set *tmp27 .state2*3
   125 jump *label76 greaterThanEq *tmp25 *tmp27
 
   146 label *label79
   147 label *label80
   148 set *tmp37 .conv*0
-    * sensor *tmp38 *tmp37 @totalItems
-    * set .state2*0 *tmp38
+  149 sensor .state2*0 *tmp37 @totalItems
   150 set *tmp40 .state2*0
   151 set *tmp42 .state1*0
   152 jump *label81 greaterThanEq *tmp40 *tmp42
 
   156 label *label83
   157 label *label84
   158 set *tmp37 .conv*1
-    * sensor *tmp38 *tmp37 @totalItems
-    * set .state2*1 *tmp38
+  159 sensor .state2*1 *tmp37 @totalItems
   160 set *tmp40 .state2*1
   161 set *tmp42 .state1*1
   162 jump *label85 greaterThanEq *tmp40 *tmp42
 
   166 label *label87
   167 label *label88
   168 set *tmp37 .conv*2
-    * sensor *tmp38 *tmp37 @totalItems
-    * set .state2*2 *tmp38
+  169 sensor .state2*2 *tmp37 @totalItems
   170 set *tmp40 .state2*2
   171 set *tmp42 .state1*2
   172 jump *label89 greaterThanEq *tmp40 *tmp42
 
   176 label *label91
   177 label *label92
   178 set *tmp37 .conv*3
-    * sensor *tmp38 *tmp37 @totalItems
-    * set .state2*3 *tmp38
+  179 sensor .state2*3 *tmp37 @totalItems
   180 set *tmp40 .state2*3
   181 set *tmp42 .state1*3
   182 jump *label93 greaterThanEq *tmp40 *tmp42

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2:
 
    89 label *label62
    90 label *label63
    91 set *tmp22 .conv*0
-    * sensor .state1*0 *tmp22 @totalItems
+   92 sensor .state1*0 .conv*0 @totalItems
    93 set *tmp25 .state1*0
    94 set *tmp27 .state2*0
-    * jump *label64 greaterThanEq *tmp25 *tmp27
+   95 jump *label64 greaterThanEq .state1*0 .state2*0
    96 op add .total .total 10
    97 label *label64
    98 label *label65
    99 label *label66
   100 label *label67
   101 set *tmp22 .conv*1
-    * sensor .state1*1 *tmp22 @totalItems
+  102 sensor .state1*1 .conv*1 @totalItems
   103 set *tmp25 .state1*1
   104 set *tmp27 .state2*1
-    * jump *label68 greaterThanEq *tmp25 *tmp27
+  105 jump *label68 greaterThanEq .state1*1 .state2*1
   106 op add .total .total 10
   107 label *label68
   108 label *label69
   109 label *label70
   110 label *label71
   111 set *tmp22 .conv*2
-    * sensor .state1*2 *tmp22 @totalItems
+  112 sensor .state1*2 .conv*2 @totalItems
   113 set *tmp25 .state1*2
   114 set *tmp27 .state2*2
-    * jump *label72 greaterThanEq *tmp25 *tmp27
+  115 jump *label72 greaterThanEq .state1*2 .state2*2
   116 op add .total .total 10
   117 label *label72
   118 label *label73
   119 label *label74
   120 label *label75
   121 set *tmp22 .conv*3
-    * sensor .state1*3 *tmp22 @totalItems
+  122 sensor .state1*3 .conv*3 @totalItems
   123 set *tmp25 .state1*3
   124 set *tmp27 .state2*3
-    * jump *label76 greaterThanEq *tmp25 *tmp27
+  125 jump *label76 greaterThanEq .state1*3 .state2*3
   126 op add .total .total 10
   127 label *label76
   128 label *label77
 
   146 label *label79
   147 label *label80
   148 set *tmp37 .conv*0
-    * sensor .state2*0 *tmp37 @totalItems
+  149 sensor .state2*0 .conv*0 @totalItems
   150 set *tmp40 .state2*0
   151 set *tmp42 .state1*0
-    * jump *label81 greaterThanEq *tmp40 *tmp42
+  152 jump *label81 greaterThanEq .state2*0 .state1*0
   153 op add .total .total 10
   154 label *label81
   155 label *label82
   156 label *label83
   157 label *label84
   158 set *tmp37 .conv*1
-    * sensor .state2*1 *tmp37 @totalItems
+  159 sensor .state2*1 .conv*1 @totalItems
   160 set *tmp40 .state2*1
   161 set *tmp42 .state1*1
-    * jump *label85 greaterThanEq *tmp40 *tmp42
+  162 jump *label85 greaterThanEq .state2*1 .state1*1
   163 op add .total .total 10
   164 label *label85
   165 label *label86
   166 label *label87
   167 label *label88
   168 set *tmp37 .conv*2
-    * sensor .state2*2 *tmp37 @totalItems
+  169 sensor .state2*2 .conv*2 @totalItems
   170 set *tmp40 .state2*2
   171 set *tmp42 .state1*2
-    * jump *label89 greaterThanEq *tmp40 *tmp42
+  172 jump *label89 greaterThanEq .state2*2 .state1*2
   173 op add .total .total 10
   174 label *label89
   175 label *label90
   176 label *label91
   177 label *label92
   178 set *tmp37 .conv*3
-    * sensor .state2*3 *tmp37 @totalItems
+  179 sensor .state2*3 .conv*3 @totalItems
   180 set *tmp40 .state2*3
   181 set *tmp42 .state1*3
-    * jump *label93 greaterThanEq *tmp40 *tmp42
+  182 jump *label93 greaterThanEq .state2*3 .state1*3
   183 op add .total .total 10
   184 label *label93
   185 label *label94

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-24 instructions):
 
    88 set :start @time
    89 label *label62
    90 label *label63
-    * set *tmp22 .conv*0
    91 sensor .state1*0 .conv*0 @totalItems
-    * set *tmp25 .state1*0
-    * set *tmp27 .state2*0
    92 jump *label64 greaterThanEq .state1*0 .state2*0
    93 op add .total .total 10
    94 label *label64
    95 label *label65
    96 label *label66
    97 label *label67
-    * set *tmp22 .conv*1
    98 sensor .state1*1 .conv*1 @totalItems
-    * set *tmp25 .state1*1
-    * set *tmp27 .state2*1
    99 jump *label68 greaterThanEq .state1*1 .state2*1
   100 op add .total .total 10
   101 label *label68
   102 label *label69
   103 label *label70
   104 label *label71
-    * set *tmp22 .conv*2
   105 sensor .state1*2 .conv*2 @totalItems
-    * set *tmp25 .state1*2
-    * set *tmp27 .state2*2
   106 jump *label72 greaterThanEq .state1*2 .state2*2
   107 op add .total .total 10
   108 label *label72
   109 label *label73
   110 label *label74
   111 label *label75
-    * set *tmp22 .conv*3
   112 sensor .state1*3 .conv*3 @totalItems
-    * set *tmp25 .state1*3
-    * set *tmp27 .state2*3
   113 jump *label76 greaterThanEq .state1*3 .state2*3
   114 op add .total .total 10
   115 label *label76
 
   133 print "\n"
   134 label *label79
   135 label *label80
-    * set *tmp37 .conv*0
   136 sensor .state2*0 .conv*0 @totalItems
-    * set *tmp40 .state2*0
-    * set *tmp42 .state1*0
   137 jump *label81 greaterThanEq .state2*0 .state1*0
   138 op add .total .total 10
   139 label *label81
   140 label *label82
   141 label *label83
   142 label *label84
-    * set *tmp37 .conv*1
   143 sensor .state2*1 .conv*1 @totalItems
-    * set *tmp40 .state2*1
-    * set *tmp42 .state1*1
   144 jump *label85 greaterThanEq .state2*1 .state1*1
   145 op add .total .total 10
   146 label *label85
   147 label *label86
   148 label *label87
   149 label *label88
-    * set *tmp37 .conv*2
   150 sensor .state2*2 .conv*2 @totalItems
-    * set *tmp40 .state2*2
-    * set *tmp42 .state1*2
   151 jump *label89 greaterThanEq .state2*2 .state1*2
   152 op add .total .total 10
   153 label *label89
   154 label *label90
   155 label *label91
   156 label *label92
-    * set *tmp37 .conv*3
   157 sensor .state2*3 .conv*3 @totalItems
-    * set *tmp40 .state2*3
-    * set *tmp42 .state1*3
   158 jump *label93 greaterThanEq .state2*3 .state1*3
   159 op add .total .total 10
   160 label *label93

Modifications by Final phase, Jump Threading, iteration 1:
 
    49 print .found
    50 print ")"
    51 printflush message1
-    * jump *label20 always
+   52 jump *label1 always
    53 label *label19
    54 jump *label21 lessThanEq .found 4
    55 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
    61 print .found
    62 print ")"
    63 printflush message1
-    * jump *label22 always
+   64 jump *label1 always
    65 label *label21
    66 jump *label23 notEqual .memory null
    67 print "$TITLE\n[salmon]No memory attached."
    68 printflush message1
-    * jump *label24 always
+   69 jump *label1 always
    70 label *label23
    71 set *tmp15 511
    72 sensor *tmp13 .memory @type

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
    76 set .totalIndex *tmp15
    77 read .total .memory *tmp15
    78 jump *label3 always
-    * label *label24
-    * label *label22
-    * label *label20
-    * label *label2
-    * jump *label1 always
    79 label *label3
    80 label *label0
    81 control enabled switch1 false

Modifications by Final phase, Single Step Elimination, iteration 1 (-2 instructions):
 
    75 label *label26
    76 set .totalIndex *tmp15
    77 read .total .memory *tmp15
-    * jump *label3 always
    78 label *label3
    79 label *label0
    80 control enabled switch1 false
 
   173 label *label29
   174 set .total 0
   175 write 0 .memory .totalIndex
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-21 instructions):
 
    40 jump *label42 greaterThanEq :initialize.0:n 0
    41 label *label13
    42 jump *label19 notEqual .found 0
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print "\"
-    * print "n[salmon]No plastanium conveyor attached (maximum: "
-    * print 4
-    * print ","
-    * print " found: "
+   43 print "[gold]Item Counter Micro[], version [gold]1.0[]\n[salmon]No plastanium conveyor attached (maximum: 4, found: "
    44 print .found
    45 print ")"
    46 printflush message1
    47 jump *label1 always
    48 label *label19
    49 jump *label21 lessThanEq .found 4
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print "\"
-    * print "n[salmon]Too many plastanium conveyors attached (maximum: "
-    * print 4
-    * print ","
-    * print " found: "
+   50 print "[gold]Item Counter Micro[], version [gold]1.0[]\n[salmon]Too many plastanium conveyors attached (maximum: 4, found: "
    51 print .found
    52 print ")"
    53 printflush message1
 
   101 label *label78
   102 label *label32
   103 write .total .memory .totalIndex
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print " "
-    * print "           "
-    * print "\n"
-    * print "Monitoring [green]"
+  104 print "[gold]Item Counter Micro[], version [gold]1.0[]            \nMonitoring [green]"
   105 print .found
-    * print "["
-    * print "] conveyors"
-    * print "\n"
-    * print "Total items: [gold]"
+  106 print "[] conveyors\nTotal items: [gold]"
   107 print .total
-    * print "["
-    * print "]"
-    * print "\n"
+  108 print "[]\n"
   109 label *label79
   110 label *label80
   111 sensor .state2*0 .conv*0 @totalItems
 
   140 op idiv *tmp48 *tmp46 2
   141 print "[lightgray]Loop time: "
   142 print *tmp48
-    * print " "
-    * print "ms"
-    * print "\n"
+  143 print " ms\n"
   144 printflush message1
   145 jump *label40 equal .links @links
   146 end

Final code before resolving virtual instructions:

        label *label1                                                while true do
    0:  set .conv*0 null                                             for var out c in conv do c = null; end;
    1:  set .conv*1 null                                             ...
    2:  set .conv*2 null                                             ...
    3:  set .conv*3 null                                             ...
    4:  set .memory null                                             memory = null;
    5:  set .found 0                                                 found = 0;
    6:  set .links @links                                            links = @links;
    7:  op sub :initialize.0:n .links 1                              for var n in 0 ... links descending do
    8:  jump *label13 lessThan :initialize.0:n 0                     ...
        label *label42                                               ...
    9:  getlink :initialize.0:block :initialize.0:n                  var block = getlink(n);
   10:  sensor *tmp4 :initialize.0:block @type                       case block.@type
   11:  jump *label16 equal *tmp4 @memory-cell                       ...
   12:  jump *label15 notEqual *tmp4 @memory-bank                    ...
        label *label16                                               ...
   13:  set .memory :initialize.0:block                              memory = block;
   14:  jump *label14 always 0 0                                     case block.@type
        label *label15                                               ...
   15:  jump *label17 notEqual *tmp4 @plastanium-conveyor            ...
   16:  set .conv*3 .conv*2                                          conv[1 ... MAX_LINKED] = conv[0 ... MAX_LINKED - 1];
   17:  set .conv*2 .conv*1                                          ...
   18:  set .conv*1 .conv*0                                          ...
   19:  set .conv*0 :initialize.0:block                              conv[0] = block;
   20:  op add .found .found 1                                       case block.@type
        label *label17                                               ...
        label *label14                                               ...
   21:  op sub :initialize.0:n :initialize.0:n 1                     for var n in 0 ... links descending do
   22:  jump *label42 greaterThanEq :initialize.0:n 0                ...
        label *label13                                               ...
   23:  jump *label19 notEqual .found 0                              if found == 0 then
   24:  print "[gold]Item Counter Micro[], version [gold]1.0[]\n[sal print($"$TITLE\n[salmon]No plastanium conveyor attached (maximum: $MAX_LINKED, found: $found)");
   25:  print .found                                                 ...
   26:  print ")"                                                    ...
   27:  printflush message1                                          printflush(message1);
   28:  jump *label1 always 0 0                                      if found == 0 then
        label *label19                                               ...
   29:  jump *label21 lessThanEq .found 4                            elsif found > MAX_LINKED then
   30:  print "[gold]Item Counter Micro[], version [gold]1.0[]\n[sal print($"$TITLE\n[salmon]Too many plastanium conveyors attached (maximum: $MAX_LINKED, found: $found)");
   31:  print .found                                                 ...
   32:  print ")"                                                    ...
   33:  printflush message1                                          printflush(message1);
   34:  jump *label1 always 0 0                                      elsif found > MAX_LINKED then
        label *label21                                               ...
   35:  jump *label23 notEqual .memory null                          elsif memory == null then
   36:  print "$TITLE\n[salmon]No memory attached."                  print("$TITLE\n[salmon]No memory attached.");
   37:  printflush message1                                          printflush(message1);
   38:  jump *label1 always 0 0                                      elsif memory == null then
        label *label23                                               ...
   39:  set *tmp15 511                                               totalIndex = memory.@type == @memory-cell ? 63 : 511;
   40:  sensor *tmp13 .memory @type                                  ...
   41:  jump *label26 notEqual *tmp13 @memory-cell                   ...
   42:  set *tmp15 63                                                ...
        label *label26                                               ...
   43:  set .totalIndex *tmp15                                       ...
   44:  read .total .memory *tmp15                                   total = memory[totalIndex];
   45:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
        label *label27                                               do
   46:  set :start @time                                             var start = @time;
   47:  sensor .state1*0 .conv*0 @totalItems                         state1[i] = conv[i].@totalItems;
   48:  jump *label64 greaterThanEq .state1*0 .state2*0              if state1[i] < state2[i] then
   49:  op add .total .total 10                                      total += 10;
        label *label64                                               if state1[i] < state2[i] then
   50:  sensor .state1*1 .conv*1 @totalItems                         state1[i] = conv[i].@totalItems;
   51:  jump *label68 greaterThanEq .state1*1 .state2*1              if state1[i] < state2[i] then
   52:  op add .total .total 10                                      total += 10;
        label *label68                                               if state1[i] < state2[i] then
   53:  sensor .state1*2 .conv*2 @totalItems                         state1[i] = conv[i].@totalItems;
   54:  jump *label72 greaterThanEq .state1*2 .state2*2              if state1[i] < state2[i] then
   55:  op add .total .total 10                                      total += 10;
        label *label72                                               if state1[i] < state2[i] then
   56:  sensor .state1*3 .conv*3 @totalItems                         state1[i] = conv[i].@totalItems;
   57:  jump *label76 greaterThanEq .state1*3 .state2*3              if state1[i] < state2[i] then
   58:  op add .total .total 10                                      total += 10;
        label *label76                                               if state1[i] < state2[i] then
   59:  write .total .memory .totalIndex                             memory[totalIndex] = total;
   60:  print "[gold]Item Counter Micro[], version [gold]1.0[]       println($"Monitoring [green]$found[] conveyors");
   61:  print .found                                                 ...
   62:  print "[] conveyors\nTotal items: [gold]"                    println($"Total items: [gold]$total[]");
   63:  print .total                                                 ...
   64:  print "[]\n"                                                 ...
   65:  sensor .state2*0 .conv*0 @totalItems                         state2[i] = conv[i].@totalItems;
   66:  jump *label81 greaterThanEq .state2*0 .state1*0              if state2[i] < state1[i] then
   67:  op add .total .total 10                                      total += 10;
        label *label81                                               if state2[i] < state1[i] then
   68:  sensor .state2*1 .conv*1 @totalItems                         state2[i] = conv[i].@totalItems;
   69:  jump *label85 greaterThanEq .state2*1 .state1*1              if state2[i] < state1[i] then
   70:  op add .total .total 10                                      total += 10;
        label *label85                                               if state2[i] < state1[i] then
   71:  sensor .state2*2 .conv*2 @totalItems                         state2[i] = conv[i].@totalItems;
   72:  jump *label89 greaterThanEq .state2*2 .state1*2              if state2[i] < state1[i] then
   73:  op add .total .total 10                                      total += 10;
        label *label89                                               if state2[i] < state1[i] then
   74:  sensor .state2*3 .conv*3 @totalItems                         state2[i] = conv[i].@totalItems;
   75:  jump *label93 greaterThanEq .state2*3 .state1*3              if state2[i] < state1[i] then
   76:  op add .total .total 10                                      total += 10;
        label *label93                                               if state2[i] < state1[i] then
   77:  op sub *tmp46 @time :start                                   println($"[lightgray]Loop time: $ ms", floor((@time - start) / 2));
   78:  op idiv *tmp48 *tmp46 2                                      ...
   79:  print "[lightgray]Loop time: "                               ...
   80:  print *tmp48                                                 ...
   81:  print " ms\n"                                                ...
   82:  printflush message1                                          printflush(message1);
   83:  jump *label40 equal .links @links                            if links != @links then
   84:  end                                                          end();
        label *label40                                               if links != @links then
   85:  sensor *tmp51 switch1 @enabled                               while !switch1.@enabled;
   86:  jump *label27 equal *tmp51 false                             do
   87:  set .total 0                                                 total = 0;
   88:  write 0 .memory .totalIndex                                  memory[totalIndex] = 0;


Performance: parsed in 196 ms, compiled in 223 ms, optimized in 232 ms, run in 65 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (100,000 steps):
[gold]Item Counter Micro[], version [gold]1.0[]
[salmon]No plastanium conveyor attached (maximum: 4, found: 0)
[--- Previous segment repeated 361,00 times ---]

Execution step limit of 100 000 exceeded.
