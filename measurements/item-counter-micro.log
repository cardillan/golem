   240 instructions before optimizations.
    11 instructions eliminated by Temp Variables Elimination (7 iterations).
     1 instructions eliminated by Case Expression Optimization.
    16 instructions eliminated by Dead Code Elimination (7 iterations).
     1 instructions eliminated by Jump Normalization (6 iterations).
     8 instructions eliminated by Condition Optimization (2 passes, 8 iterations).
     6 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
   257 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
    46 instructions eliminated by Data Flow Optimization (4 passes, 38 iterations).
     2 instructions eliminated by Loop Rotation (3 iterations).
       2 loop conditions were fully rotated.
       1 loop conditions were partially rotated.
   140 instructions added by Loop Unrolling (29 iterations).
     3 loops unrolled by Loop Unrolling.
   130 instructions added by Array Optimization (29 iterations).
     3 array(s) improved by Array Optimization.
     2 instructions eliminated by Jump Straightening (7 iterations).
     3 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (3 iterations).
    21 instructions eliminated by Print Merging.
    98 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 817):
    Inline shared table of array 'conv'                          size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state1'                        size    +2, benefit     2562.5, efficiency   1281.250
  * Inline array access to 'state1' at line 74:13                size    -3, benefit     1281.3, efficiency   Infinity (-3 instructions)
    Inline shared table of array 'state2'                        size    +2, benefit     2562.5, efficiency   1281.250
    Inline array access to 'state2' at line 87:13                size    -3, benefit     1281.3, efficiency   Infinity
    Unroll iteration loop at line 32:9                           size   -19, benefit      475.0, efficiency   Infinity
    Unroll loop at line 73:9                                     size    +6, benefit     5000.0, efficiency    833.333
    Unroll loop at line 86:9                                     size    +6, benefit     5000.0, efficiency    833.333

Pass 1: speed optimization selection (cost limit 820):
    Inline shared table of array 'conv'                          size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state1'                        size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state2'                        size    +2, benefit     2562.5, efficiency   1281.250
  * Inline array access to 'state2' at line 87:13                size    -3, benefit     1281.3, efficiency   Infinity (-3 instructions)
    Unroll iteration loop at line 32:9                           size   -19, benefit      475.0, efficiency   Infinity
    Unroll loop at line 73:9                                     size    +1, benefit     5000.0, efficiency   5000.000
    Unroll loop at line 86:9                                     size    +6, benefit     5000.0, efficiency    833.333

Pass 1: speed optimization selection (cost limit 823):
    Inline shared table of array 'conv'                          size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state1'                        size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state2'                        size    +2, benefit     2562.5, efficiency   1281.250
  * Unroll iteration loop at line 32:9                           size   -19, benefit      475.0, efficiency   Infinity (-8 instructions)
    Unroll loop at line 73:9                                     size    +1, benefit     5000.0, efficiency   5000.000
    Unroll loop at line 86:9                                     size    +1, benefit     5000.0, efficiency   5000.000

Pass 1: speed optimization selection (cost limit 831):
    Inline shared table of array 'conv'                          size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state1'                        size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state2'                        size    +2, benefit     2562.5, efficiency   1281.250
  * Unroll loop at line 73:9                                     size    +1, benefit     5000.0, efficiency   5000.000 (+69 instructions)
    Unroll loop at line 86:9                                     size    +1, benefit     5000.0, efficiency   5000.000

Pass 1: speed optimization selection (cost limit 762):
    Inline shared table of array 'conv'                          size   +17, benefit     1486.3, efficiency     87.426
    Inline shared table of array 'state1'                        size   +17, benefit     1486.3, efficiency     87.426
    Inline shared table of array 'state2'                        size   +17, benefit     1486.3, efficiency     87.426
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit     1281.3, efficiency    256.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit     1281.3, efficiency    256.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit     1281.3, efficiency    256.250
  * Unroll loop at line 86:9                                     size    +1, benefit     5000.0, efficiency   5000.000 (+69 instructions)

Pass 1: speed optimization selection (cost limit 693):
  o Inline shared table of array 'conv'                          size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 688):
  o Inline shared table of array 'conv'                          size   +27, benefit      358.7, efficiency     13.287
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 683):
  o Inline shared table of array 'conv'                          size   +22, benefit      307.5, efficiency     13.977
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 678):
  o Inline shared table of array 'conv'                          size   +17, benefit      256.2, efficiency     15.074
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 673):
  o Inline shared table of array 'conv'                          size   +12, benefit      205.0, efficiency     17.083
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 668):
  o Inline shared table of array 'conv'                          size    +7, benefit      153.7, efficiency     21.964
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 663):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 658):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +27, benefit      358.7, efficiency     13.287
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 653):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +22, benefit      307.5, efficiency     13.977
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 648):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +17, benefit      256.2, efficiency     15.074
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 643):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +12, benefit      205.0, efficiency     17.083
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 638):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +7, benefit      153.7, efficiency     21.964
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 633):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 628):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +27, benefit      358.7, efficiency     13.287
  * Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 623):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +22, benefit      307.5, efficiency     13.977
  * Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 618):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +17, benefit      256.2, efficiency     15.074
  * Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 613):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +12, benefit      205.0, efficiency     17.083
  * Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 608):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size    +7, benefit      153.7, efficiency     21.964
  * Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 603):
  * Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250 (+2 instructions)
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size    +2, benefit      102.5, efficiency     51.250

Pass 1: speed optimization selection (cost limit 601):
  * Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250 (+2 instructions)
  o Inline shared table of array 'state2'                        size    +2, benefit      102.5, efficiency     51.250

Pass 1: speed optimization selection (cost limit 599):
  * Inline shared table of array 'state2'                        size    +2, benefit      102.5, efficiency     51.250 (+2 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    33 getlink *tmp2 :initialize:n
    34 set :initialize:block *tmp2
    35 sensor *tmp4 :initialize:block @type
-    * set *tmp5 *tmp4
-    * jump *label16 equal *tmp5 @memory-cell
-    * jump *label16 equal *tmp5 @memory-bank
+   36 jump *label16 equal *tmp4 @memory-cell
+   37 jump *label16 equal *tmp4 @memory-bank
    38 jump *label15 always
    39 label *label16
    40 set .memory :initialize:block
    41 set *tmp3 .memory
    42 jump *label14 always
    43 label *label15
-    * jump *label18 equal *tmp5 @plastanium-conveyor
+   44 jump *label18 equal *tmp4 @plastanium-conveyor
    45 jump *label17 always
    46 label *label18
    47 set .conv*3 .conv*2

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-11 instructions):
 
    38 jump *label15 always
    39 label *label16
    40 set .memory :initialize:block
-    * set *tmp3 .memory
    41 jump *label14 always
    42 label *label15
    43 jump *label18 equal *tmp4 @plastanium-conveyor
 
    49 set .conv*0 :initialize:block
    50 set *tmp6 .found
    51 op add .found .found 1
-    * set *tmp3 *tmp6
    52 jump *label14 always
    53 label *label17
-    * set *tmp3 null
    54 label *label14
    55 label *label12
    56 op sub :initialize:n :initialize:n 1
 
    67 print .found
    68 print ")"
    69 printflush message1
-    * set *tmp8 null
    70 jump *label20 always
    71 label *label19
    72 op greaterThan *tmp9 .found 4
 
   107 label *label24
   108 set *tmp10 *tmp12
   109 label *label22
-    * set *tmp8 *tmp10
   110 label *label20
   111 label *label2
   112 jump *label1 always
 
   131 jump *label33 equal *tmp28 false
   132 op add *tmp30 .total 10
   133 set .total *tmp30
-    * set *tmp29 *tmp30
   134 jump *label34 always
   135 label *label33
-    * set *tmp29 null
   136 label *label34
   137 label *label31
   138 op add :i :i 1
 
   171 jump *label38 equal *tmp43 false
   172 op add *tmp45 .total 10
   173 set .total *tmp45
-    * set *tmp44 *tmp45
   174 jump *label39 always
   175 label *label38
-    * set *tmp44 null
   176 label *label39
   177 label *label36
   178 op add :i.1 :i.1 1
 
   190 op notEqual *tmp49 .links @links
   191 jump *label40 equal *tmp49 false
   192 end
-    * set *tmp50 null
   193 jump *label41 always
   194 label *label40
-    * set *tmp50 null
   195 label *label41
   196 label *label28
   197 sensor *tmp51 switch1 @enabled

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-3 instructions):
 
    47 set .conv*2 .conv*1
    48 set .conv*1 .conv*0
    49 set .conv*0 :initialize:block
-    * set *tmp6 .found
    50 op add .found .found 1
    51 jump *label14 always
    52 label *label17
 
    79 print .found
    80 print ")"
    81 printflush message1
-    * set *tmp10 null
    82 jump *label22 always
    83 label *label21
    84 op equal *tmp11 .memory null
 
   103 jump *label3 always
   104 set *tmp12 null
   105 label *label24
-    * set *tmp10 *tmp12
   106 label *label22
   107 label *label20
   108 label *label2

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
    85 jump *label23 equal *tmp11 false
    86 print "$TITLE\n[salmon]No memory attached."
    87 printflush message1
-    * set *tmp12 null
    88 jump *label24 always
    89 label *label23
    90 sensor *tmp13 .memory @type
 
   100 read *tmp17 .memory *tmp16
   101 set .total *tmp17
   102 jump *label3 always
-    * set *tmp12 null
   103 label *label24
   104 label *label22
   105 label *label20

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-10 instructions):
 
    25 label *label6
    26 set .memory null
    27 set .found 0
-    * set *tmp1 @links
-    * set .links *tmp1
+   28 set .links @links
    29 op sub :initialize:n .links 1
    30 label *label11
    31 jump *label13 lessThan :initialize:n 0
-    * getlink *tmp2 :initialize:n
-    * set :initialize:block *tmp2
+   32 getlink :initialize:block :initialize:n
    33 sensor *tmp4 :initialize:block @type
    34 jump *label16 equal *tmp4 @memory-cell
    35 jump *label16 equal *tmp4 @memory-bank
 
    94 set *tmp15 511
    95 label *label26
    96 set .totalIndex *tmp15
-    * set *tmp16 .totalIndex
-    * read *tmp17 .memory *tmp16
-    * set .total *tmp17
+   97 read .total .memory .totalIndex
    98 jump *label3 always
    99 label *label24
   100 label *label22
 
   110 label *label30
   111 jump *label32 greaterThanEq :i 4
   112 set *tmp19 :i
-    * set *tmp21 :i
-    * readarr<internal:regular> *tmp22 .conv[] *tmp21
+  113 readarr<internal:regular> *tmp22 .conv[] :i
   114 sensor *tmp23 *tmp22 @totalItems
   115 writearr<internal:regular> *tmp23 .state1[] *tmp19
   116 set *tmp24 :i
 
   119 readarr<internal:regular> *tmp27 .state2[] *tmp26
   120 op lessThan *tmp28 *tmp25 *tmp27
   121 jump *label33 equal *tmp28 false
-    * op add *tmp30 .total 10
-    * set .total *tmp30
+  122 op add .total .total 10
   123 jump *label34 always
   124 label *label33
   125 label *label34
 
   128 jump *label30 always
   129 label *label32
   130 set *tmp31 .totalIndex
-    * set *tmp33 .total
-    * write *tmp33 .memory *tmp31
+  131 write .total .memory *tmp31
   132 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   133 print " "
   134 print "           "
 
   147 label *label35
   148 jump *label37 greaterThanEq :i.1 4
   149 set *tmp34 :i.1
-    * set *tmp36 :i.1
-    * readarr<internal:regular> *tmp37 .conv[] *tmp36
+  150 readarr<internal:regular> *tmp37 .conv[] :i.1
   151 sensor *tmp38 *tmp37 @totalItems
   152 writearr<internal:regular> *tmp38 .state2[] *tmp34
   153 set *tmp39 :i.1
 
   156 readarr<internal:regular> *tmp42 .state1[] *tmp41
   157 op lessThan *tmp43 *tmp40 *tmp42
   158 jump *label38 equal *tmp43 false
-    * op add *tmp45 .total 10
-    * set .total *tmp45
+  159 op add .total .total 10
   160 jump *label39 always
   161 label *label38
   162 label *label39
 
   185 jump *label27 notEqual *tmp52 false
   186 label *label29
   187 set .total 0
-    * set *tmp53 .totalIndex
-    * write 0 .memory *tmp53
+  188 write 0 .memory .totalIndex
   189 end

Modifications by Initial phase, Temp Variables Elimination, iteration 2 (-1 instructions):
 
   127 op add :i :i 1
   128 jump *label30 always
   129 label *label32
-    * set *tmp31 .totalIndex
-    * write .total .memory *tmp31
+  130 write .total .memory .totalIndex
   131 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   132 print " "
   133 print "           "

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
     0 label *label1
-    * jump *label3 equal true false
     1 set :initialize:c .conv*0
     2 setaddr *tmp0 *label7
     3 jump *label4 always

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-2 instructions):
 
    31 getlink :initialize:block :initialize:n
    32 sensor *tmp4 :initialize:block @type
    33 jump *label16 equal *tmp4 @memory-cell
-    * jump *label16 equal *tmp4 @memory-bank
-    * jump *label15 always
+   34 jump *label15 notEqual *tmp4 @memory-bank
    35 label *label16
    36 set .memory :initialize:block
    37 jump *label14 always
    38 label *label15
-    * jump *label18 equal *tmp4 @plastanium-conveyor
-    * jump *label17 always
+   39 jump *label17 notEqual *tmp4 @plastanium-conveyor
    40 label *label18
    41 set .conv*3 .conv*2
    42 set .conv*2 .conv*1

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-8 instructions):
 
    50 op sub :initialize:n :initialize:n 1
    51 jump *label11 always
    52 label *label13
-    * op equal *tmp7 .found 0
-    * jump *label19 equal *tmp7 false
+   53 jump *label19 notEqual .found 0
    54 print "[gold]Item Counter Micro[], version [gold]1.0[]"
    55 print "\"
    56 print "n[salmon]No plastanium conveyor attached (maximum: "
 
    62 printflush message1
    63 jump *label20 always
    64 label *label19
-    * op greaterThan *tmp9 .found 4
-    * jump *label21 equal *tmp9 false
+   65 jump *label21 lessThanEq .found 4
    66 print "[gold]Item Counter Micro[], version [gold]1.0[]"
    67 print "\"
    68 print "n[salmon]Too many plastanium conveyors attached (maximum: "
 
    74 printflush message1
    75 jump *label22 always
    76 label *label21
-    * op equal *tmp11 .memory null
-    * jump *label23 equal *tmp11 false
+   77 jump *label23 notEqual .memory null
    78 print "$TITLE\n[salmon]No memory attached."
    79 printflush message1
    80 jump *label24 always
    81 label *label23
    82 sensor *tmp13 .memory @type
-    * op equal *tmp14 *tmp13 @memory-cell
-    * jump *label25 equal *tmp14 false
+   83 jump *label25 notEqual *tmp13 @memory-cell
    84 set *tmp15 63
    85 jump *label26 always
    86 label *label25
 
   110 set *tmp26 :i
   111 readarr<internal:regular> *tmp25 .state1[] *tmp24
   112 readarr<internal:regular> *tmp27 .state2[] *tmp26
-    * op lessThan *tmp28 *tmp25 *tmp27
-    * jump *label33 equal *tmp28 false
+  113 jump *label33 greaterThanEq *tmp25 *tmp27
   114 op add .total .total 10
   115 jump *label34 always
   116 label *label33
 
   145 set *tmp41 :i.1
   146 readarr<internal:regular> *tmp40 .state2[] *tmp39
   147 readarr<internal:regular> *tmp42 .state1[] *tmp41
-    * op lessThan *tmp43 *tmp40 *tmp42
-    * jump *label38 equal *tmp43 false
+  148 jump *label38 greaterThanEq *tmp40 *tmp42
   149 op add .total .total 10
   150 jump *label39 always
   151 label *label38
 
   163 print "ms"
   164 print "\n"
   165 printflush message1
-    * op notEqual *tmp49 .links @links
-    * jump *label40 equal *tmp49 false
+  166 jump *label40 equal .links @links
   167 end
   168 jump *label41 always
   169 label *label40
   170 label *label41
   171 label *label28
   172 sensor *tmp51 switch1 @enabled
-    * op equal *tmp52 *tmp51 false
-    * jump *label27 notEqual *tmp52 false
+  173 jump *label27 equal *tmp51 false
   174 label *label29
   175 set .total 0
   176 write 0 .memory .totalIndex

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    43 set .conv*1 .conv*0
    44 set .conv*0 :initialize:block
    45 op add .found .found 1
-    * jump *label14 always
    46 label *label17
    47 label *label14
    48 label *label12
 
   111 readarr<internal:regular> *tmp27 .state2[] *tmp26
   112 jump *label33 greaterThanEq *tmp25 *tmp27
   113 op add .total .total 10
-    * jump *label34 always
   114 label *label33
   115 label *label34
   116 label *label31
 
   145 readarr<internal:regular> *tmp42 .state1[] *tmp41
   146 jump *label38 greaterThanEq *tmp40 *tmp42
   147 op add .total .total 10
-    * jump *label39 always
   148 label *label38
   149 label *label39
   150 label *label36
 
   162 printflush message1
   163 jump *label40 equal .links @links
   164 end
-    * jump *label41 always
   165 label *label40
   166 label *label41
   167 label *label28

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   152 jump *label35 always
   153 label *label37
   154 op sub *tmp46 @time :start
-    * op div *tmp47 *tmp46 2
-    * op floor *tmp48 *tmp47
+  155 op idiv *tmp48 *tmp46 2
   156 print "[lightgray]Loop time: "
   157 print *tmp48
   158 print " "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
     0 label *label1
-    * set :initialize:c .conv*0
     1 setaddr *tmp0 *label7
     2 jump *label4 always
     3 multilabel *label7 (m:marker0)
-    * set .conv*0 :initialize:c
-    * set :initialize:c .conv*1
+    4 set .conv*0 null
     5 setaddr *tmp0 *label8
     6 jump *label4 always
     7 multilabel *label8 (m:marker0)
-    * set .conv*1 :initialize:c
-    * set :initialize:c .conv*2
+    8 set .conv*1 null
     9 setaddr *tmp0 *label9
    10 jump *label4 always
    11 multilabel *label9 (m:marker0)
-    * set .conv*2 :initialize:c
-    * set :initialize:c .conv*3
+   12 set .conv*2 null
    13 setaddr *tmp0 *label10
    14 label *label4
    15 set :initialize:c null
    16 label *label5
    17 multijump *tmp0 0 0 (m:marker0)
    18 multilabel *label10 (m:marker0)
-    * set .conv*3 :initialize:c
+   19 set .conv*3 null
    20 label *label6
    21 set .memory null
    22 set .found 0
 
    82 set *tmp15 511
    83 label *label26
    84 set .totalIndex *tmp15
-    * read .total .memory .totalIndex
+   85 read .total .memory *tmp15
    86 jump *label3 always
    87 label *label24
    88 label *label22
 
   100 set *tmp19 :i
   101 readarr<internal:regular> *tmp22 .conv[] :i
   102 sensor *tmp23 *tmp22 @totalItems
-    * writearr<internal:regular> *tmp23 .state1[] *tmp19
+  103 writearr<internal:regular> *tmp23 .state1[] :i
   104 set *tmp24 :i
   105 set *tmp26 :i
-    * readarr<internal:regular> *tmp25 .state1[] *tmp24
-    * readarr<internal:regular> *tmp27 .state2[] *tmp26
+  106 readarr<internal:regular> *tmp25 .state1[] :i
+  107 readarr<internal:regular> *tmp27 .state2[] :i
   108 jump *label33 greaterThanEq *tmp25 *tmp27
   109 op add .total .total 10
   110 label *label33
 
   134 set *tmp34 :i.1
   135 readarr<internal:regular> *tmp37 .conv[] :i.1
   136 sensor *tmp38 *tmp37 @totalItems
-    * writearr<internal:regular> *tmp38 .state2[] *tmp34
+  137 writearr<internal:regular> *tmp38 .state2[] :i.1
   138 set *tmp39 :i.1
   139 set *tmp41 :i.1
-    * readarr<internal:regular> *tmp40 .state2[] *tmp39
-    * readarr<internal:regular> *tmp42 .state1[] *tmp41
+  140 readarr<internal:regular> *tmp40 .state2[] :i.1
+  141 readarr<internal:regular> *tmp42 .state1[] :i.1
   142 jump *label38 greaterThanEq *tmp40 *tmp42
   143 op add .total .total 10
   144 label *label38

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
    12 set .conv*2 null
    13 setaddr *tmp0 *label10
    14 label *label4
-    * set :initialize:c null
    15 label *label5
    16 multijump *tmp0 0 0 (m:marker0)
    17 multilabel *label10 (m:marker0)
 
    96 set :i 0
    97 label *label30
    98 jump *label32 greaterThanEq :i 4
-    * set *tmp19 :i
    99 readarr<internal:regular> *tmp22 .conv[] :i
   100 sensor *tmp23 *tmp22 @totalItems
   101 writearr<internal:regular> *tmp23 .state1[] :i
-    * set *tmp24 :i
-    * set *tmp26 :i
   102 readarr<internal:regular> *tmp25 .state1[] :i
   103 readarr<internal:regular> *tmp27 .state2[] :i
   104 jump *label33 greaterThanEq *tmp25 *tmp27
 
   127 set :i.1 0
   128 label *label35
   129 jump *label37 greaterThanEq :i.1 4
-    * set *tmp34 :i.1
   130 readarr<internal:regular> *tmp37 .conv[] :i.1
   131 sensor *tmp38 *tmp37 @totalItems
   132 writearr<internal:regular> *tmp38 .state2[] :i.1
-    * set *tmp39 :i.1
-    * set *tmp41 :i.1
   133 readarr<internal:regular> *tmp40 .state2[] :i.1
   134 readarr<internal:regular> *tmp42 .state1[] :i.1
   135 jump *label38 greaterThanEq *tmp40 *tmp42

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1 (-2 instructions):
 
    23 op sub :initialize:n .links 1
    24 label *label11
    25 jump *label13 lessThan :initialize:n 0
+   26 label *label42
    27 getlink :initialize:block :initialize:n
    28 sensor *tmp4 :initialize:block @type
    29 jump *label16 equal *tmp4 @memory-cell
 
    43 label *label14
    44 label *label12
    45 op sub :initialize:n :initialize:n 1
-    * jump *label11 always
+   46 jump *label42 greaterThanEq :initialize:n 0
    47 label *label13
    48 jump *label19 notEqual .found 0
    49 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
    96 set :start @time
    97 set :i 0
    98 label *label30
-    * jump *label32 greaterThanEq :i 4
+   99 label *label43
   100 readarr<internal:regular> *tmp22 .conv[] :i
   101 sensor *tmp23 *tmp22 @totalItems
   102 writearr<internal:regular> *tmp23 .state1[] :i
 
   108 label *label34
   109 label *label31
   110 op add :i :i 1
-    * jump *label30 always
+  111 jump *label43 lessThan :i 4
   112 label *label32
   113 write .total .memory .totalIndex
   114 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
   127 print "\n"
   128 set :i.1 0
   129 label *label35
-    * jump *label37 greaterThanEq :i.1 4
+  130 label *label44
   131 readarr<internal:regular> *tmp37 .conv[] :i.1
   132 sensor *tmp38 *tmp37 @totalItems
   133 writearr<internal:regular> *tmp38 .state2[] :i.1
 
   139 label *label39
   140 label *label36
   141 op add :i.1 :i.1 1
-    * jump *label35 always
+  142 jump *label44 lessThan :i.1 4
   143 label *label37
   144 op sub *tmp46 @time :start
   145 op idiv *tmp48 *tmp46 2

Modifications by Inline array access to 'state1' at line 74:13 (-3 instructions):
 
    99 label *label43
   100 readarr<internal:regular> *tmp22 .conv[] :i
   101 sensor *tmp23 *tmp22 @totalItems
-    * writearr<internal:regular> *tmp23 .state1[] :i
+  102 writearr<inlined:regular> *tmp23 .state1[] :i
   103 readarr<internal:regular> *tmp25 .state1[] :i
   104 readarr<internal:regular> *tmp27 .state2[] :i
   105 jump *label33 greaterThanEq *tmp25 *tmp27

Modifications by Inline array access to 'state2' at line 87:13 (-3 instructions):
 
   130 label *label44
   131 readarr<internal:regular> *tmp37 .conv[] :i.1
   132 sensor *tmp38 *tmp37 @totalItems
-    * writearr<internal:regular> *tmp38 .state2[] :i.1
+  133 writearr<inlined:regular> *tmp38 .state2[] :i.1
   134 readarr<internal:regular> *tmp40 .state2[] :i.1
   135 readarr<internal:regular> *tmp42 .state1[] :i.1
   136 jump *label38 greaterThanEq *tmp40 *tmp42

Modifications by Unroll iteration loop at line 32:9 (-8 instructions):
     0 label *label1
-    * setaddr *tmp0 *label7
-    * jump *label4 always
-    * multilabel *label7 (m:marker0)
-    * set .conv*0 null
-    * setaddr *tmp0 *label8
-    * jump *label4 always
-    * multilabel *label8 (m:marker0)
-    * set .conv*1 null
-    * setaddr *tmp0 *label9
-    * jump *label4 always
-    * multilabel *label9 (m:marker0)
-    * set .conv*2 null
-    * setaddr *tmp0 *label10
-    * label *label4
-    * label *label5
-    * multijump *tmp0 0 0 (m:marker0)
-    * multilabel *label10 (m:marker0)
-    * set .conv*3 null
-    * label *label6
+    1 label *label45
+    2 label *label46
+    3 set .conv*0 null
+    4 label *label49
+    5 label *label50
+    6 set .conv*1 null
+    7 label *label53
+    8 label *label54
+    9 set .conv*2 null
+   10 label *label57
+   11 label *label58
+   12 set .conv*3 null
+   13 label *label6
    14 set .memory null
    15 set .found 0
    16 set .links @links

Modifications by Unroll loop at line 73:9 (+74 instructions):
 
    88 control enabled switch1 false
    89 label *label27
    90 set :start @time
-    * set :i 0
-    * label *label30
-    * label *label43
-    * readarr<internal:regular> *tmp22 .conv[] :i
-    * sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
-    * jump *label33 greaterThanEq *tmp25 *tmp27
-    * op add .total .total 10
-    * label *label33
-    * label *label34
-    * label *label31
-    * op add :i :i 1
-    * jump *label43 lessThan :i 4
-    * label *label32
+   91 set :i 0
+   92 label *label62
+   93 label *label63
+   94 readarr<internal:regular> *tmp22 .conv[] :i
+   95 sensor *tmp23 *tmp22 @totalItems
+   96 writearr<inlined:regular> *tmp23 .state1[] :i
+   97 readarr<internal:regular> *tmp25 .state1[] :i
+   98 readarr<internal:regular> *tmp27 .state2[] :i
+   99 jump *label64 greaterThanEq *tmp25 *tmp27
+  100 op add .total .total 10
+  101 label *label64
+  102 label *label65
+  103 label *label66
+  104 op add :i :i 1
+  105 readarr<internal:regular> *tmp22 .conv[] :i
+  106 sensor *tmp23 *tmp22 @totalItems
+  107 writearr<inlined:regular> *tmp23 .state1[] :i
+  108 readarr<internal:regular> *tmp25 .state1[] :i
+  109 readarr<internal:regular> *tmp27 .state2[] :i
+  110 jump *label67 greaterThanEq *tmp25 *tmp27
+  111 op add .total .total 10
+  112 label *label67
+  113 label *label68
+  114 label *label69
+  115 op add :i :i 1
+  116 readarr<internal:regular> *tmp22 .conv[] :i
+  117 sensor *tmp23 *tmp22 @totalItems
+  118 writearr<inlined:regular> *tmp23 .state1[] :i
+  119 readarr<internal:regular> *tmp25 .state1[] :i
+  120 readarr<internal:regular> *tmp27 .state2[] :i
+  121 jump *label70 greaterThanEq *tmp25 *tmp27
+  122 op add .total .total 10
+  123 label *label70
+  124 label *label71
+  125 label *label72
+  126 op add :i :i 1
+  127 readarr<internal:regular> *tmp22 .conv[] :i
+  128 sensor *tmp23 *tmp22 @totalItems
+  129 writearr<inlined:regular> *tmp23 .state1[] :i
+  130 readarr<internal:regular> *tmp25 .state1[] :i
+  131 readarr<internal:regular> *tmp27 .state2[] :i
+  132 jump *label73 greaterThanEq *tmp25 *tmp27
+  133 op add .total .total 10
+  134 label *label73
+  135 label *label74
+  136 label *label75
+  137 op add :i :i 1
+  138 label *label32
   139 write .total .memory .totalIndex
   140 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   141 print " "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    91 set :i 0
    92 label *label62
    93 label *label63
-    * readarr<internal:regular> *tmp22 .conv[] :i
+   94 readarr<internal:regular> *tmp22 .conv[] 0
    95 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
+   96 writearr<inlined:regular> *tmp23 .state1[] 0
+   97 readarr<internal:regular> *tmp25 .state1[] 0
+   98 readarr<internal:regular> *tmp27 .state2[] 0
    99 jump *label64 greaterThanEq *tmp25 *tmp27
   100 op add .total .total 10
   101 label *label64
   102 label *label65
   103 label *label66
-    * op add :i :i 1
-    * readarr<internal:regular> *tmp22 .conv[] :i
+  104 op add :i 0 1
+  105 readarr<internal:regular> *tmp22 .conv[] 1
   106 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
+  107 writearr<inlined:regular> *tmp23 .state1[] 1
+  108 readarr<internal:regular> *tmp25 .state1[] 1
+  109 readarr<internal:regular> *tmp27 .state2[] 1
   110 jump *label67 greaterThanEq *tmp25 *tmp27
   111 op add .total .total 10
   112 label *label67
   113 label *label68
   114 label *label69
-    * op add :i :i 1
-    * readarr<internal:regular> *tmp22 .conv[] :i
+  115 op add :i 1 1
+  116 readarr<internal:regular> *tmp22 .conv[] 2
   117 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
+  118 writearr<inlined:regular> *tmp23 .state1[] 2
+  119 readarr<internal:regular> *tmp25 .state1[] 2
+  120 readarr<internal:regular> *tmp27 .state2[] 2
   121 jump *label70 greaterThanEq *tmp25 *tmp27
   122 op add .total .total 10
   123 label *label70
   124 label *label71
   125 label *label72
-    * op add :i :i 1
-    * readarr<internal:regular> *tmp22 .conv[] :i
+  126 op add :i 2 1
+  127 readarr<internal:regular> *tmp22 .conv[] 3
   128 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
+  129 writearr<inlined:regular> *tmp23 .state1[] 3
+  130 readarr<internal:regular> *tmp25 .state1[] 3
+  131 readarr<internal:regular> *tmp27 .state2[] 3
   132 jump *label73 greaterThanEq *tmp25 *tmp27
   133 op add .total .total 10
   134 label *label73
   135 label *label74
   136 label *label75
-    * op add :i :i 1
+  137 op add :i 3 1
   138 label *label32
   139 write .total .memory .totalIndex
   140 print "[gold]Item Counter Micro[], version [gold]1.0[]"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    88 control enabled switch1 false
    89 label *label27
    90 set :start @time
-    * set :i 0
    91 label *label62
    92 label *label63
    93 readarr<internal:regular> *tmp22 .conv[] 0
 
   100 label *label64
   101 label *label65
   102 label *label66
-    * op add :i 0 1
   103 readarr<internal:regular> *tmp22 .conv[] 1
   104 sensor *tmp23 *tmp22 @totalItems
   105 writearr<inlined:regular> *tmp23 .state1[] 1
 
   110 label *label67
   111 label *label68
   112 label *label69
-    * op add :i 1 1
   113 readarr<internal:regular> *tmp22 .conv[] 2
   114 sensor *tmp23 *tmp22 @totalItems
   115 writearr<inlined:regular> *tmp23 .state1[] 2
 
   120 label *label70
   121 label *label71
   122 label *label72
-    * op add :i 2 1
   123 readarr<internal:regular> *tmp22 .conv[] 3
   124 sensor *tmp23 *tmp22 @totalItems
   125 writearr<inlined:regular> *tmp23 .state1[] 3
 
   130 label *label73
   131 label *label74
   132 label *label75
-    * op add :i 3 1
   133 label *label32
   134 write .total .memory .totalIndex
   135 print "[gold]Item Counter Micro[], version [gold]1.0[]"

Modifications by Unroll loop at line 86:9 (+74 instructions):
 
   146 print "["
   147 print "]"
   148 print "\n"
-    * set :i.1 0
-    * label *label35
-    * label *label44
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
-    * sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
-    * jump *label38 greaterThanEq *tmp40 *tmp42
-    * op add .total .total 10
-    * label *label38
-    * label *label39
-    * label *label36
-    * op add :i.1 :i.1 1
-    * jump *label44 lessThan :i.1 4
-    * label *label37
+  149 set :i.1 0
+  150 label *label76
+  151 label *label77
+  152 readarr<internal:regular> *tmp37 .conv[] :i.1
+  153 sensor *tmp38 *tmp37 @totalItems
+  154 writearr<inlined:regular> *tmp38 .state2[] :i.1
+  155 readarr<internal:regular> *tmp40 .state2[] :i.1
+  156 readarr<internal:regular> *tmp42 .state1[] :i.1
+  157 jump *label78 greaterThanEq *tmp40 *tmp42
+  158 op add .total .total 10
+  159 label *label78
+  160 label *label79
+  161 label *label80
+  162 op add :i.1 :i.1 1
+  163 readarr<internal:regular> *tmp37 .conv[] :i.1
+  164 sensor *tmp38 *tmp37 @totalItems
+  165 writearr<inlined:regular> *tmp38 .state2[] :i.1
+  166 readarr<internal:regular> *tmp40 .state2[] :i.1
+  167 readarr<internal:regular> *tmp42 .state1[] :i.1
+  168 jump *label81 greaterThanEq *tmp40 *tmp42
+  169 op add .total .total 10
+  170 label *label81
+  171 label *label82
+  172 label *label83
+  173 op add :i.1 :i.1 1
+  174 readarr<internal:regular> *tmp37 .conv[] :i.1
+  175 sensor *tmp38 *tmp37 @totalItems
+  176 writearr<inlined:regular> *tmp38 .state2[] :i.1
+  177 readarr<internal:regular> *tmp40 .state2[] :i.1
+  178 readarr<internal:regular> *tmp42 .state1[] :i.1
+  179 jump *label84 greaterThanEq *tmp40 *tmp42
+  180 op add .total .total 10
+  181 label *label84
+  182 label *label85
+  183 label *label86
+  184 op add :i.1 :i.1 1
+  185 readarr<internal:regular> *tmp37 .conv[] :i.1
+  186 sensor *tmp38 *tmp37 @totalItems
+  187 writearr<inlined:regular> *tmp38 .state2[] :i.1
+  188 readarr<internal:regular> *tmp40 .state2[] :i.1
+  189 readarr<internal:regular> *tmp42 .state1[] :i.1
+  190 jump *label87 greaterThanEq *tmp40 *tmp42
+  191 op add .total .total 10
+  192 label *label87
+  193 label *label88
+  194 label *label89
+  195 op add :i.1 :i.1 1
+  196 label *label37
   197 op sub *tmp46 @time :start
   198 op idiv *tmp48 *tmp46 2
   199 print "[lightgray]Loop time: "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   149 set :i.1 0
   150 label *label76
   151 label *label77
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
+  152 readarr<internal:regular> *tmp37 .conv[] 0
   153 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
+  154 writearr<inlined:regular> *tmp38 .state2[] 0
+  155 readarr<internal:regular> *tmp40 .state2[] 0
+  156 readarr<internal:regular> *tmp42 .state1[] 0
   157 jump *label78 greaterThanEq *tmp40 *tmp42
   158 op add .total .total 10
   159 label *label78
   160 label *label79
   161 label *label80
-    * op add :i.1 :i.1 1
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
+  162 op add :i.1 0 1
+  163 readarr<internal:regular> *tmp37 .conv[] 1
   164 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
+  165 writearr<inlined:regular> *tmp38 .state2[] 1
+  166 readarr<internal:regular> *tmp40 .state2[] 1
+  167 readarr<internal:regular> *tmp42 .state1[] 1
   168 jump *label81 greaterThanEq *tmp40 *tmp42
   169 op add .total .total 10
   170 label *label81
   171 label *label82
   172 label *label83
-    * op add :i.1 :i.1 1
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
+  173 op add :i.1 1 1
+  174 readarr<internal:regular> *tmp37 .conv[] 2
   175 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
+  176 writearr<inlined:regular> *tmp38 .state2[] 2
+  177 readarr<internal:regular> *tmp40 .state2[] 2
+  178 readarr<internal:regular> *tmp42 .state1[] 2
   179 jump *label84 greaterThanEq *tmp40 *tmp42
   180 op add .total .total 10
   181 label *label84
   182 label *label85
   183 label *label86
-    * op add :i.1 :i.1 1
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
+  184 op add :i.1 2 1
+  185 readarr<internal:regular> *tmp37 .conv[] 3
   186 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
+  187 writearr<inlined:regular> *tmp38 .state2[] 3
+  188 readarr<internal:regular> *tmp40 .state2[] 3
+  189 readarr<internal:regular> *tmp42 .state1[] 3
   190 jump *label87 greaterThanEq *tmp40 *tmp42
   191 op add .total .total 10
   192 label *label87
   193 label *label88
   194 label *label89
-    * op add :i.1 :i.1 1
+  195 op add :i.1 3 1
   196 label *label37
   197 op sub *tmp46 @time :start
   198 op idiv *tmp48 *tmp46 2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
   146 print "["
   147 print "]"
   148 print "\n"
-    * set :i.1 0
   149 label *label76
   150 label *label77
   151 readarr<internal:regular> *tmp37 .conv[] 0
 
   158 label *label78
   159 label *label79
   160 label *label80
-    * op add :i.1 0 1
   161 readarr<internal:regular> *tmp37 .conv[] 1
   162 sensor *tmp38 *tmp37 @totalItems
   163 writearr<inlined:regular> *tmp38 .state2[] 1
 
   168 label *label81
   169 label *label82
   170 label *label83
-    * op add :i.1 1 1
   171 readarr<internal:regular> *tmp37 .conv[] 2
   172 sensor *tmp38 *tmp37 @totalItems
   173 writearr<inlined:regular> *tmp38 .state2[] 2
 
   178 label *label84
   179 label *label85
   180 label *label86
-    * op add :i.1 2 1
   181 readarr<internal:regular> *tmp37 .conv[] 3
   182 sensor *tmp38 *tmp37 @totalItems
   183 writearr<inlined:regular> *tmp38 .state2[] 3
 
   188 label *label87
   189 label *label88
   190 label *label89
-    * op add :i.1 3 1
   191 label *label37
   192 op sub *tmp46 @time :start
   193 op idiv *tmp48 *tmp46 2

Modifications by Inline array access to 'conv' at line 74:25 (+5 instructions):
 
    90 set :start @time
    91 label *label62
    92 label *label63
-    * readarr<internal:regular> *tmp22 .conv[] 0
+   93 readarr<inlined:regular> *tmp22 .conv[] 0
    94 sensor *tmp23 *tmp22 @totalItems
    95 writearr<inlined:regular> *tmp23 .state1[] 0
    96 readarr<internal:regular> *tmp25 .state1[] 0

Modifications by Inline array access to 'conv' at line 74:25 (+5 instructions):
 
   100 label *label64
   101 label *label65
   102 label *label66
-    * readarr<internal:regular> *tmp22 .conv[] 1
+  103 readarr<inlined:regular> *tmp22 .conv[] 1
   104 sensor *tmp23 *tmp22 @totalItems
   105 writearr<inlined:regular> *tmp23 .state1[] 1
   106 readarr<internal:regular> *tmp25 .state1[] 1

Modifications by Inline array access to 'conv' at line 74:25 (+5 instructions):
 
   110 label *label67
   111 label *label68
   112 label *label69
-    * readarr<internal:regular> *tmp22 .conv[] 2
+  113 readarr<inlined:regular> *tmp22 .conv[] 2
   114 sensor *tmp23 *tmp22 @totalItems
   115 writearr<inlined:regular> *tmp23 .state1[] 2
   116 readarr<internal:regular> *tmp25 .state1[] 2

Modifications by Inline array access to 'conv' at line 74:25 (+5 instructions):
 
   120 label *label70
   121 label *label71
   122 label *label72
-    * readarr<internal:regular> *tmp22 .conv[] 3
+  123 readarr<inlined:regular> *tmp22 .conv[] 3
   124 sensor *tmp23 *tmp22 @totalItems
   125 writearr<inlined:regular> *tmp23 .state1[] 3
   126 readarr<internal:regular> *tmp25 .state1[] 3

Modifications by Inline array access to 'conv' at line 87:25 (+5 instructions):
 
   148 print "\n"
   149 label *label76
   150 label *label77
-    * readarr<internal:regular> *tmp37 .conv[] 0
+  151 readarr<inlined:regular> *tmp37 .conv[] 0
   152 sensor *tmp38 *tmp37 @totalItems
   153 writearr<inlined:regular> *tmp38 .state2[] 0
   154 readarr<internal:regular> *tmp40 .state2[] 0

Modifications by Inline array access to 'conv' at line 87:25 (+5 instructions):
 
   158 label *label78
   159 label *label79
   160 label *label80
-    * readarr<internal:regular> *tmp37 .conv[] 1
+  161 readarr<inlined:regular> *tmp37 .conv[] 1
   162 sensor *tmp38 *tmp37 @totalItems
   163 writearr<inlined:regular> *tmp38 .state2[] 1
   164 readarr<internal:regular> *tmp40 .state2[] 1

Modifications by Inline array access to 'state1' at line 75:26 (+5 instructions):
 
    93 readarr<inlined:regular> *tmp22 .conv[] 0
    94 sensor *tmp23 *tmp22 @totalItems
    95 writearr<inlined:regular> *tmp23 .state1[] 0
-    * readarr<internal:regular> *tmp25 .state1[] 0
+   96 readarr<inlined:regular> *tmp25 .state1[] 0
    97 readarr<internal:regular> *tmp27 .state2[] 0
    98 jump *label64 greaterThanEq *tmp25 *tmp27
    99 op add .total .total 10

Modifications by Inline array access to 'state1' at line 75:26 (+5 instructions):
 
   103 readarr<inlined:regular> *tmp22 .conv[] 1
   104 sensor *tmp23 *tmp22 @totalItems
   105 writearr<inlined:regular> *tmp23 .state1[] 1
-    * readarr<internal:regular> *tmp25 .state1[] 1
+  106 readarr<inlined:regular> *tmp25 .state1[] 1
   107 readarr<internal:regular> *tmp27 .state2[] 1
   108 jump *label67 greaterThanEq *tmp25 *tmp27
   109 op add .total .total 10

Modifications by Inline array access to 'state1' at line 75:26 (+5 instructions):
 
   113 readarr<inlined:regular> *tmp22 .conv[] 2
   114 sensor *tmp23 *tmp22 @totalItems
   115 writearr<inlined:regular> *tmp23 .state1[] 2
-    * readarr<internal:regular> *tmp25 .state1[] 2
+  116 readarr<inlined:regular> *tmp25 .state1[] 2
   117 readarr<internal:regular> *tmp27 .state2[] 2
   118 jump *label70 greaterThanEq *tmp25 *tmp27
   119 op add .total .total 10

Modifications by Inline array access to 'state1' at line 75:26 (+5 instructions):
 
   123 readarr<inlined:regular> *tmp22 .conv[] 3
   124 sensor *tmp23 *tmp22 @totalItems
   125 writearr<inlined:regular> *tmp23 .state1[] 3
-    * readarr<internal:regular> *tmp25 .state1[] 3
+  126 readarr<inlined:regular> *tmp25 .state1[] 3
   127 readarr<internal:regular> *tmp27 .state2[] 3
   128 jump *label73 greaterThanEq *tmp25 *tmp27
   129 op add .total .total 10

Modifications by Inline array access to 'state1' at line 88:26 (+5 instructions):
 
   152 sensor *tmp38 *tmp37 @totalItems
   153 writearr<inlined:regular> *tmp38 .state2[] 0
   154 readarr<internal:regular> *tmp40 .state2[] 0
-    * readarr<internal:regular> *tmp42 .state1[] 0
+  155 readarr<inlined:regular> *tmp42 .state1[] 0
   156 jump *label78 greaterThanEq *tmp40 *tmp42
   157 op add .total .total 10
   158 label *label78

Modifications by Inline array access to 'state1' at line 88:26 (+5 instructions):
 
   162 sensor *tmp38 *tmp37 @totalItems
   163 writearr<inlined:regular> *tmp38 .state2[] 1
   164 readarr<internal:regular> *tmp40 .state2[] 1
-    * readarr<internal:regular> *tmp42 .state1[] 1
+  165 readarr<inlined:regular> *tmp42 .state1[] 1
   166 jump *label81 greaterThanEq *tmp40 *tmp42
   167 op add .total .total 10
   168 label *label81

Modifications by Inline array access to 'state2' at line 75:26 (+5 instructions):
 
    94 sensor *tmp23 *tmp22 @totalItems
    95 writearr<inlined:regular> *tmp23 .state1[] 0
    96 readarr<inlined:regular> *tmp25 .state1[] 0
-    * readarr<internal:regular> *tmp27 .state2[] 0
+   97 readarr<inlined:regular> *tmp27 .state2[] 0
    98 jump *label64 greaterThanEq *tmp25 *tmp27
    99 op add .total .total 10
   100 label *label64

Modifications by Inline array access to 'state2' at line 75:26 (+5 instructions):
 
   104 sensor *tmp23 *tmp22 @totalItems
   105 writearr<inlined:regular> *tmp23 .state1[] 1
   106 readarr<inlined:regular> *tmp25 .state1[] 1
-    * readarr<internal:regular> *tmp27 .state2[] 1
+  107 readarr<inlined:regular> *tmp27 .state2[] 1
   108 jump *label67 greaterThanEq *tmp25 *tmp27
   109 op add .total .total 10
   110 label *label67

Modifications by Inline array access to 'state2' at line 75:26 (+5 instructions):
 
   114 sensor *tmp23 *tmp22 @totalItems
   115 writearr<inlined:regular> *tmp23 .state1[] 2
   116 readarr<inlined:regular> *tmp25 .state1[] 2
-    * readarr<internal:regular> *tmp27 .state2[] 2
+  117 readarr<inlined:regular> *tmp27 .state2[] 2
   118 jump *label70 greaterThanEq *tmp25 *tmp27
   119 op add .total .total 10
   120 label *label70

Modifications by Inline array access to 'state2' at line 75:26 (+5 instructions):
 
   124 sensor *tmp23 *tmp22 @totalItems
   125 writearr<inlined:regular> *tmp23 .state1[] 3
   126 readarr<inlined:regular> *tmp25 .state1[] 3
-    * readarr<internal:regular> *tmp27 .state2[] 3
+  127 readarr<inlined:regular> *tmp27 .state2[] 3
   128 jump *label73 greaterThanEq *tmp25 *tmp27
   129 op add .total .total 10
   130 label *label73

Modifications by Inline array access to 'state2' at line 88:26 (+5 instructions):
 
   151 readarr<inlined:regular> *tmp37 .conv[] 0
   152 sensor *tmp38 *tmp37 @totalItems
   153 writearr<inlined:regular> *tmp38 .state2[] 0
-    * readarr<internal:regular> *tmp40 .state2[] 0
+  154 readarr<inlined:regular> *tmp40 .state2[] 0
   155 readarr<inlined:regular> *tmp42 .state1[] 0
   156 jump *label78 greaterThanEq *tmp40 *tmp42
   157 op add .total .total 10

Modifications by Inline array access to 'state2' at line 88:26 (+5 instructions):
 
   161 readarr<inlined:regular> *tmp37 .conv[] 1
   162 sensor *tmp38 *tmp37 @totalItems
   163 writearr<inlined:regular> *tmp38 .state2[] 1
-    * readarr<internal:regular> *tmp40 .state2[] 1
+  164 readarr<inlined:regular> *tmp40 .state2[] 1
   165 readarr<inlined:regular> *tmp42 .state1[] 1
   166 jump *label81 greaterThanEq *tmp40 *tmp42
   167 op add .total .total 10

Modifications by Inline shared table of array 'conv' (+2 instructions):
 
   168 label *label81
   169 label *label82
   170 label *label83
-    * readarr<internal:regular> *tmp37 .conv[] 2
+  171 readarr<inlined:regular> *tmp37 .conv[] 2
   172 sensor *tmp38 *tmp37 @totalItems
   173 writearr<inlined:regular> *tmp38 .state2[] 2
   174 readarr<internal:regular> *tmp40 .state2[] 2
 
   178 label *label84
   179 label *label85
   180 label *label86
-    * readarr<internal:regular> *tmp37 .conv[] 3
+  181 readarr<inlined:regular> *tmp37 .conv[] 3
   182 sensor *tmp38 *tmp37 @totalItems
   183 writearr<inlined:regular> *tmp38 .state2[] 3
   184 readarr<internal:regular> *tmp40 .state2[] 3

Modifications by Inline shared table of array 'state1' (+2 instructions):
 
   172 sensor *tmp38 *tmp37 @totalItems
   173 writearr<inlined:regular> *tmp38 .state2[] 2
   174 readarr<internal:regular> *tmp40 .state2[] 2
-    * readarr<internal:regular> *tmp42 .state1[] 2
+  175 readarr<inlined:regular> *tmp42 .state1[] 2
   176 jump *label84 greaterThanEq *tmp40 *tmp42
   177 op add .total .total 10
   178 label *label84
 
   182 sensor *tmp38 *tmp37 @totalItems
   183 writearr<inlined:regular> *tmp38 .state2[] 3
   184 readarr<internal:regular> *tmp40 .state2[] 3
-    * readarr<internal:regular> *tmp42 .state1[] 3
+  185 readarr<inlined:regular> *tmp42 .state1[] 3
   186 jump *label87 greaterThanEq *tmp40 *tmp42
   187 op add .total .total 10
   188 label *label87

Modifications by Inline shared table of array 'state2' (+2 instructions):
 
   171 readarr<inlined:regular> *tmp37 .conv[] 2
   172 sensor *tmp38 *tmp37 @totalItems
   173 writearr<inlined:regular> *tmp38 .state2[] 2
-    * readarr<internal:regular> *tmp40 .state2[] 2
+  174 readarr<inlined:regular> *tmp40 .state2[] 2
   175 readarr<inlined:regular> *tmp42 .state1[] 2
   176 jump *label84 greaterThanEq *tmp40 *tmp42
   177 op add .total .total 10
 
   181 readarr<inlined:regular> *tmp37 .conv[] 3
   182 sensor *tmp38 *tmp37 @totalItems
   183 writearr<inlined:regular> *tmp38 .state2[] 3
-    * readarr<internal:regular> *tmp40 .state2[] 3
+  184 readarr<inlined:regular> *tmp40 .state2[] 3
   185 readarr<inlined:regular> *tmp42 .state1[] 3
   186 jump *label87 greaterThanEq *tmp40 *tmp42
   187 op add .total .total 10

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1:
 
    16 set .links @links
    17 op sub :initialize:n .links 1
    18 label *label11
-    * jump *label13 lessThan :initialize:n 0
+   19 jump *label13 lessThan .links 1
    20 label *label42
    21 getlink :initialize:block :initialize:n
    22 sensor *tmp4 :initialize:block @type

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-256 instructions):
 
    90 set :start @time
    91 label *label62
    92 label *label63
-    * readarr<inlined:regular> *tmp22 .conv[] 0
+   93 set *tmp22 .conv*0
    94 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] 0
-    * readarr<inlined:regular> *tmp25 .state1[] 0
-    * readarr<inlined:regular> *tmp27 .state2[] 0
+   95 set .state1*0 *tmp23
+   96 set *tmp25 .state1*0
+   97 set *tmp27 .state2*0
    98 jump *label64 greaterThanEq *tmp25 *tmp27
    99 op add .total .total 10
   100 label *label64
   101 label *label65
   102 label *label66
-    * readarr<inlined:regular> *tmp22 .conv[] 1
+  103 set *tmp22 .conv*1
   104 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] 1
-    * readarr<inlined:regular> *tmp25 .state1[] 1
-    * readarr<inlined:regular> *tmp27 .state2[] 1
+  105 set .state1*1 *tmp23
+  106 set *tmp25 .state1*1
+  107 set *tmp27 .state2*1
   108 jump *label67 greaterThanEq *tmp25 *tmp27
   109 op add .total .total 10
   110 label *label67
   111 label *label68
   112 label *label69
-    * readarr<inlined:regular> *tmp22 .conv[] 2
+  113 set *tmp22 .conv*2
   114 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] 2
-    * readarr<inlined:regular> *tmp25 .state1[] 2
-    * readarr<inlined:regular> *tmp27 .state2[] 2
+  115 set .state1*2 *tmp23
+  116 set *tmp25 .state1*2
+  117 set *tmp27 .state2*2
   118 jump *label70 greaterThanEq *tmp25 *tmp27
   119 op add .total .total 10
   120 label *label70
   121 label *label71
   122 label *label72
-    * readarr<inlined:regular> *tmp22 .conv[] 3
+  123 set *tmp22 .conv*3
   124 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] 3
-    * readarr<inlined:regular> *tmp25 .state1[] 3
-    * readarr<inlined:regular> *tmp27 .state2[] 3
+  125 set .state1*3 *tmp23
+  126 set *tmp25 .state1*3
+  127 set *tmp27 .state2*3
   128 jump *label73 greaterThanEq *tmp25 *tmp27
   129 op add .total .total 10
   130 label *label73
 
   148 print "\n"
   149 label *label76
   150 label *label77
-    * readarr<inlined:regular> *tmp37 .conv[] 0
+  151 set *tmp37 .conv*0
   152 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] 0
-    * readarr<inlined:regular> *tmp40 .state2[] 0
-    * readarr<inlined:regular> *tmp42 .state1[] 0
+  153 set .state2*0 *tmp38
+  154 set *tmp40 .state2*0
+  155 set *tmp42 .state1*0
   156 jump *label78 greaterThanEq *tmp40 *tmp42
   157 op add .total .total 10
   158 label *label78
   159 label *label79
   160 label *label80
-    * readarr<inlined:regular> *tmp37 .conv[] 1
+  161 set *tmp37 .conv*1
   162 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] 1
-    * readarr<inlined:regular> *tmp40 .state2[] 1
-    * readarr<inlined:regular> *tmp42 .state1[] 1
+  163 set .state2*1 *tmp38
+  164 set *tmp40 .state2*1
+  165 set *tmp42 .state1*1
   166 jump *label81 greaterThanEq *tmp40 *tmp42
   167 op add .total .total 10
   168 label *label81
   169 label *label82
   170 label *label83
-    * readarr<inlined:regular> *tmp37 .conv[] 2
+  171 set *tmp37 .conv*2
   172 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] 2
-    * readarr<inlined:regular> *tmp40 .state2[] 2
-    * readarr<inlined:regular> *tmp42 .state1[] 2
+  173 set .state2*2 *tmp38
+  174 set *tmp40 .state2*2
+  175 set *tmp42 .state1*2
   176 jump *label84 greaterThanEq *tmp40 *tmp42
   177 op add .total .total 10
   178 label *label84
   179 label *label85
   180 label *label86
-    * readarr<inlined:regular> *tmp37 .conv[] 3
+  181 set *tmp37 .conv*3
   182 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] 3
-    * readarr<inlined:regular> *tmp40 .state2[] 3
-    * readarr<inlined:regular> *tmp42 .state1[] 3
+  183 set .state2*3 *tmp38
+  184 set *tmp40 .state2*3
+  185 set *tmp42 .state1*3
   186 jump *label87 greaterThanEq *tmp40 *tmp42
   187 op add .total .total 10
   188 label *label87

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    91 label *label62
    92 label *label63
    93 set *tmp22 .conv*0
-    * sensor *tmp23 *tmp22 @totalItems
+   94 sensor *tmp23 .conv*0 @totalItems
    95 set .state1*0 *tmp23
-    * set *tmp25 .state1*0
+   96 set *tmp25 *tmp23
    97 set *tmp27 .state2*0
-    * jump *label64 greaterThanEq *tmp25 *tmp27
+   98 jump *label64 greaterThanEq .state1*0 .state2*0
    99 op add .total .total 10
   100 label *label64
   101 label *label65
   102 label *label66
   103 set *tmp22 .conv*1
-    * sensor *tmp23 *tmp22 @totalItems
+  104 sensor *tmp23 .conv*1 @totalItems
   105 set .state1*1 *tmp23
-    * set *tmp25 .state1*1
+  106 set *tmp25 *tmp23
   107 set *tmp27 .state2*1
-    * jump *label67 greaterThanEq *tmp25 *tmp27
+  108 jump *label67 greaterThanEq .state1*1 .state2*1
   109 op add .total .total 10
   110 label *label67
   111 label *label68
   112 label *label69
   113 set *tmp22 .conv*2
-    * sensor *tmp23 *tmp22 @totalItems
+  114 sensor *tmp23 .conv*2 @totalItems
   115 set .state1*2 *tmp23
-    * set *tmp25 .state1*2
+  116 set *tmp25 *tmp23
   117 set *tmp27 .state2*2
-    * jump *label70 greaterThanEq *tmp25 *tmp27
+  118 jump *label70 greaterThanEq .state1*2 .state2*2
   119 op add .total .total 10
   120 label *label70
   121 label *label71
   122 label *label72
   123 set *tmp22 .conv*3
-    * sensor *tmp23 *tmp22 @totalItems
+  124 sensor *tmp23 .conv*3 @totalItems
   125 set .state1*3 *tmp23
-    * set *tmp25 .state1*3
+  126 set *tmp25 *tmp23
   127 set *tmp27 .state2*3
-    * jump *label73 greaterThanEq *tmp25 *tmp27
+  128 jump *label73 greaterThanEq .state1*3 .state2*3
   129 op add .total .total 10
   130 label *label73
   131 label *label74
 
   149 label *label76
   150 label *label77
   151 set *tmp37 .conv*0
-    * sensor *tmp38 *tmp37 @totalItems
+  152 sensor *tmp38 .conv*0 @totalItems
   153 set .state2*0 *tmp38
-    * set *tmp40 .state2*0
+  154 set *tmp40 *tmp38
   155 set *tmp42 .state1*0
-    * jump *label78 greaterThanEq *tmp40 *tmp42
+  156 jump *label78 greaterThanEq .state2*0 .state1*0
   157 op add .total .total 10
   158 label *label78
   159 label *label79
   160 label *label80
   161 set *tmp37 .conv*1
-    * sensor *tmp38 *tmp37 @totalItems
+  162 sensor *tmp38 .conv*1 @totalItems
   163 set .state2*1 *tmp38
-    * set *tmp40 .state2*1
+  164 set *tmp40 *tmp38
   165 set *tmp42 .state1*1
-    * jump *label81 greaterThanEq *tmp40 *tmp42
+  166 jump *label81 greaterThanEq .state2*1 .state1*1
   167 op add .total .total 10
   168 label *label81
   169 label *label82
   170 label *label83
   171 set *tmp37 .conv*2
-    * sensor *tmp38 *tmp37 @totalItems
+  172 sensor *tmp38 .conv*2 @totalItems
   173 set .state2*2 *tmp38
-    * set *tmp40 .state2*2
+  174 set *tmp40 *tmp38
   175 set *tmp42 .state1*2
-    * jump *label84 greaterThanEq *tmp40 *tmp42
+  176 jump *label84 greaterThanEq .state2*2 .state1*2
   177 op add .total .total 10
   178 label *label84
   179 label *label85
   180 label *label86
   181 set *tmp37 .conv*3
-    * sensor *tmp38 *tmp37 @totalItems
+  182 sensor *tmp38 .conv*3 @totalItems
   183 set .state2*3 *tmp38
-    * set *tmp40 .state2*3
-    * set *tmp42 .state1*3
-    * jump *label87 greaterThanEq *tmp40 *tmp42
+  184 set *tmp40 *tmp38
+  185 set *tmp42 *tmp23
+  186 jump *label87 greaterThanEq .state2*3 .state1*3
   187 op add .total .total 10
   188 label *label87
   189 label *label88

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-24 instructions):
 
    90 set :start @time
    91 label *label62
    92 label *label63
-    * set *tmp22 .conv*0
    93 sensor *tmp23 .conv*0 @totalItems
    94 set .state1*0 *tmp23
-    * set *tmp25 *tmp23
-    * set *tmp27 .state2*0
-    * jump *label64 greaterThanEq .state1*0 .state2*0
+   95 jump *label64 greaterThanEq *tmp23 .state2*0
    96 op add .total .total 10
    97 label *label64
    98 label *label65
    99 label *label66
-    * set *tmp22 .conv*1
   100 sensor *tmp23 .conv*1 @totalItems
   101 set .state1*1 *tmp23
-    * set *tmp25 *tmp23
-    * set *tmp27 .state2*1
-    * jump *label67 greaterThanEq .state1*1 .state2*1
+  102 jump *label67 greaterThanEq *tmp23 .state2*1
   103 op add .total .total 10
   104 label *label67
   105 label *label68
   106 label *label69
-    * set *tmp22 .conv*2
   107 sensor *tmp23 .conv*2 @totalItems
   108 set .state1*2 *tmp23
-    * set *tmp25 *tmp23
-    * set *tmp27 .state2*2
-    * jump *label70 greaterThanEq .state1*2 .state2*2
+  109 jump *label70 greaterThanEq *tmp23 .state2*2
   110 op add .total .total 10
   111 label *label70
   112 label *label71
   113 label *label72
-    * set *tmp22 .conv*3
   114 sensor *tmp23 .conv*3 @totalItems
   115 set .state1*3 *tmp23
-    * set *tmp25 *tmp23
-    * set *tmp27 .state2*3
-    * jump *label73 greaterThanEq .state1*3 .state2*3
+  116 jump *label73 greaterThanEq *tmp23 .state2*3
   117 op add .total .total 10
   118 label *label73
   119 label *label74
 
   136 print "\n"
   137 label *label76
   138 label *label77
-    * set *tmp37 .conv*0
   139 sensor *tmp38 .conv*0 @totalItems
   140 set .state2*0 *tmp38
-    * set *tmp40 *tmp38
-    * set *tmp42 .state1*0
-    * jump *label78 greaterThanEq .state2*0 .state1*0
+  141 jump *label78 greaterThanEq *tmp38 .state1*0
   142 op add .total .total 10
   143 label *label78
   144 label *label79
   145 label *label80
-    * set *tmp37 .conv*1
   146 sensor *tmp38 .conv*1 @totalItems
   147 set .state2*1 *tmp38
-    * set *tmp40 *tmp38
-    * set *tmp42 .state1*1
-    * jump *label81 greaterThanEq .state2*1 .state1*1
+  148 jump *label81 greaterThanEq *tmp38 .state1*1
   149 op add .total .total 10
   150 label *label81
   151 label *label82
   152 label *label83
-    * set *tmp37 .conv*2
   153 sensor *tmp38 .conv*2 @totalItems
   154 set .state2*2 *tmp38
-    * set *tmp40 *tmp38
-    * set *tmp42 .state1*2
-    * jump *label84 greaterThanEq .state2*2 .state1*2
+  155 jump *label84 greaterThanEq *tmp38 .state1*2
   156 op add .total .total 10
   157 label *label84
   158 label *label85
   159 label *label86
-    * set *tmp37 .conv*3
   160 sensor *tmp38 .conv*3 @totalItems
   161 set .state2*3 *tmp38
-    * set *tmp40 *tmp38
-    * set *tmp42 *tmp23
-    * jump *label87 greaterThanEq .state2*3 .state1*3
+  162 jump *label87 greaterThanEq *tmp38 *tmp23
   163 op add .total .total 10
   164 label *label87
   165 label *label88

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-1 instructions):
 
   112 label *label71
   113 label *label72
   114 sensor *tmp23 .conv*3 @totalItems
-    * set .state1*3 *tmp23
   115 jump *label73 greaterThanEq *tmp23 .state2*3
   116 op add .total .total 10
   117 label *label73

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    37 print .found
    38 print ")"
    39 printflush message1
-    * jump *label20 always
+   40 jump *label1 always
    41 label *label19
    42 jump *label21 lessThanEq .found 4
    43 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
    49 print .found
    50 print ")"
    51 printflush message1
-    * jump *label22 always
+   52 jump *label1 always
    53 label *label21
    54 jump *label23 notEqual .memory null
    55 print "$TITLE\n[salmon]No memory attached."
    56 printflush message1
-    * jump *label24 always
+   57 jump *label1 always
    58 label *label23
    59 sensor *tmp13 .memory @type
    60 jump *label25 notEqual *tmp13 @memory-cell

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   140 jump *label27 equal *tmp51 false
   141 set .total 0
   142 write 0 .memory .totalIndex
-    * end

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-1 instructions):
 
    66 set .totalIndex *tmp15
    67 read .total .memory *tmp15
    68 jump *label3 always
-    * jump *label1 always
    69 label *label3
    70 control enabled switch1 false
    71 label *label27

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-1 instructions):
 
    65 label *label26
    66 set .totalIndex *tmp15
    67 read .total .memory *tmp15
-    * jump *label3 always
    68 label *label3
    69 control enabled switch1 false
    70 label *label27

Modifications by Final phase, Print Merging, iteration 1 (-21 instructions):
 
    28 jump *label42 greaterThanEq :initialize:n 0
    29 label *label13
    30 jump *label19 notEqual .found 0
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print "\"
-    * print "n[salmon]No plastanium conveyor attached (maximum: "
-    * print 4
-    * print ","
-    * print " found: "
+   31 print "[gold]Item Counter Micro[], version [gold]1.0[]\n[salmon]No plastanium conveyor attached (maximum: 4, found: "
    32 print .found
    33 print ")"
    34 printflush message1
    35 jump *label1 always
    36 label *label19
    37 jump *label21 lessThanEq .found 4
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print "\"
-    * print "n[salmon]Too many plastanium conveyors attached (maximum: "
-    * print 4
-    * print ","
-    * print " found: "
+   38 print "[gold]Item Counter Micro[], version [gold]1.0[]\n[salmon]Too many plastanium conveyors attached (maximum: 4, found: "
    39 print .found
    40 print ")"
    41 printflush message1
 
    78 op add .total .total 10
    79 label *label73
    80 write .total .memory .totalIndex
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print " "
-    * print "           "
-    * print "\n"
-    * print "Monitoring [green]"
+   81 print "[gold]Item Counter Micro[], version [gold]1.0[]            \nMonitoring [green]"
    82 print .found
-    * print "["
-    * print "] conveyors"
-    * print "\n"
-    * print "Total items: [gold]"
+   83 print "[] conveyors\nTotal items: [gold]"
    84 print .total
-    * print "["
-    * print "]"
-    * print "\n"
+   85 print "[]\n"
    86 sensor *tmp38 .conv*0 @totalItems
    87 set .state2*0 *tmp38
    88 jump *label78 greaterThanEq *tmp38 .state1*0
 
   107 op idiv *tmp48 *tmp46 2
   108 print "[lightgray]Loop time: "
   109 print *tmp48
-    * print " "
-    * print "ms"
-    * print "\n"
+  110 print " ms\n"
   111 printflush message1
   112 jump *label40 equal .links @links
   113 end

Final code before resolving virtual instructions:

        label *label1                                                while true do
    0:  set .conv*0 null                                             for var out c in conv do c = null; end;
    1:  set .conv*1 null                                             ...
    2:  set .conv*2 null                                             ...
    3:  set .conv*3 null                                             ...
    4:  set .memory null                                             memory = null;
    5:  set .found 0                                                 found = 0;
    6:  set .links @links                                            links = @links;
    7:  op sub :initialize:n .links 1                                for var n in 0 ... links descending do
    8:  jump *label13 lessThan .links 1                              ...
        label *label42                                               ...
    9:  getlink :initialize:block :initialize:n                      var block = getlink(n);
   10:  sensor *tmp4 :initialize:block @type                         case block.@type
   11:  jump *label16 equal *tmp4 @memory-cell                       ...
   12:  jump *label15 notEqual *tmp4 @memory-bank                    ...
        label *label16                                               ...
   13:  set .memory :initialize:block                                memory = block;
   14:  jump *label14 always 0 0                                     case block.@type
        label *label15                                               ...
   15:  jump *label17 notEqual *tmp4 @plastanium-conveyor            ...
   16:  set .conv*3 .conv*2                                          conv[1 ... MAX_LINKED] = conv[0 ... MAX_LINKED - 1];
   17:  set .conv*2 .conv*1                                          ...
   18:  set .conv*1 .conv*0                                          ...
   19:  set .conv*0 :initialize:block                                conv[0] = block;
   20:  op add .found .found 1                                       case block.@type
        label *label17                                               ...
        label *label14                                               ...
   21:  op sub :initialize:n :initialize:n 1                         for var n in 0 ... links descending do
   22:  jump *label42 greaterThanEq :initialize:n 0                  ...
        label *label13                                               ...
   23:  jump *label19 notEqual .found 0                              if found == 0 then
   24:  print "[gold]Item Counter Micro[], version [gold]1.0[]\n[sal print($"$TITLE\n[salmon]No plastanium conveyor attached (maximum: $MAX_LINKED, found: $found)");
   25:  print .found                                                 ...
   26:  print ")"                                                    ...
   27:  printflush message1                                          printflush(message1);
   28:  jump *label1 always 0 0                                      if found == 0 then
        label *label19                                               ...
   29:  jump *label21 lessThanEq .found 4                            elsif found > MAX_LINKED then
   30:  print "[gold]Item Counter Micro[], version [gold]1.0[]\n[sal print($"$TITLE\n[salmon]Too many plastanium conveyors attached (maximum: $MAX_LINKED, found: $found)");
   31:  print .found                                                 ...
   32:  print ")"                                                    ...
   33:  printflush message1                                          printflush(message1);
   34:  jump *label1 always 0 0                                      elsif found > MAX_LINKED then
        label *label21                                               ...
   35:  jump *label23 notEqual .memory null                          elsif memory == null then
   36:  print "$TITLE\n[salmon]No memory attached."                  print("$TITLE\n[salmon]No memory attached.");
   37:  printflush message1                                          printflush(message1);
   38:  jump *label1 always 0 0                                      elsif memory == null then
        label *label23                                               ...
   39:  sensor *tmp13 .memory @type                                  totalIndex = memory.@type == @memory-cell ? 63 : 511;
   40:  jump *label25 notEqual *tmp13 @memory-cell                   ...
   41:  set *tmp15 63                                                ...
   42:  jump *label26 always 0 0                                     ...
        label *label25                                               ...
   43:  set *tmp15 511                                               ...
        label *label26                                               ...
   44:  set .totalIndex *tmp15                                       ...
   45:  read .total .memory *tmp15                                   total = memory[totalIndex];
   46:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
        label *label27                                               do
   47:  set :start @time                                             var start = @time;
   48:  sensor *tmp23 .conv*0 @totalItems                            state1[i] = conv[i].@totalItems;
   49:  set .state1*0 *tmp23                                         ...
   50:  jump *label64 greaterThanEq *tmp23 .state2*0                 if state1[i] < state2[i] then
   51:  op add .total .total 10                                      total += 10;
        label *label64                                               if state1[i] < state2[i] then
   52:  sensor *tmp23 .conv*1 @totalItems                            state1[i] = conv[i].@totalItems;
   53:  set .state1*1 *tmp23                                         ...
   54:  jump *label67 greaterThanEq *tmp23 .state2*1                 if state1[i] < state2[i] then
   55:  op add .total .total 10                                      total += 10;
        label *label67                                               if state1[i] < state2[i] then
   56:  sensor *tmp23 .conv*2 @totalItems                            state1[i] = conv[i].@totalItems;
   57:  set .state1*2 *tmp23                                         ...
   58:  jump *label70 greaterThanEq *tmp23 .state2*2                 if state1[i] < state2[i] then
   59:  op add .total .total 10                                      total += 10;
        label *label70                                               if state1[i] < state2[i] then
   60:  sensor *tmp23 .conv*3 @totalItems                            state1[i] = conv[i].@totalItems;
   61:  jump *label73 greaterThanEq *tmp23 .state2*3                 if state1[i] < state2[i] then
   62:  op add .total .total 10                                      total += 10;
        label *label73                                               if state1[i] < state2[i] then
   63:  write .total .memory .totalIndex                             memory[totalIndex] = total;
   64:  print "[gold]Item Counter Micro[], version [gold]1.0[]       println($"Monitoring [green]$found[] conveyors");
   65:  print .found                                                 ...
   66:  print "[] conveyors\nTotal items: [gold]"                    println($"Total items: [gold]$total[]");
   67:  print .total                                                 ...
   68:  print "[]\n"                                                 ...
   69:  sensor *tmp38 .conv*0 @totalItems                            state2[i] = conv[i].@totalItems;
   70:  set .state2*0 *tmp38                                         ...
   71:  jump *label78 greaterThanEq *tmp38 .state1*0                 if state2[i] < state1[i] then
   72:  op add .total .total 10                                      total += 10;
        label *label78                                               if state2[i] < state1[i] then
   73:  sensor *tmp38 .conv*1 @totalItems                            state2[i] = conv[i].@totalItems;
   74:  set .state2*1 *tmp38                                         ...
   75:  jump *label81 greaterThanEq *tmp38 .state1*1                 if state2[i] < state1[i] then
   76:  op add .total .total 10                                      total += 10;
        label *label81                                               if state2[i] < state1[i] then
   77:  sensor *tmp38 .conv*2 @totalItems                            state2[i] = conv[i].@totalItems;
   78:  set .state2*2 *tmp38                                         ...
   79:  jump *label84 greaterThanEq *tmp38 .state1*2                 if state2[i] < state1[i] then
   80:  op add .total .total 10                                      total += 10;
        label *label84                                               if state2[i] < state1[i] then
   81:  sensor *tmp38 .conv*3 @totalItems                            state2[i] = conv[i].@totalItems;
   82:  set .state2*3 *tmp38                                         ...
   83:  jump *label87 greaterThanEq *tmp38 *tmp23                    if state2[i] < state1[i] then
   84:  op add .total .total 10                                      total += 10;
        label *label87                                               if state2[i] < state1[i] then
   85:  op sub *tmp46 @time :start                                   println($"[lightgray]Loop time: $ ms", floor((@time - start) / 2));
   86:  op idiv *tmp48 *tmp46 2                                      ...
   87:  print "[lightgray]Loop time: "                               ...
   88:  print *tmp48                                                 ...
   89:  print " ms\n"                                                ...
   90:  printflush message1                                          printflush(message1);
   91:  jump *label40 equal .links @links                            if links != @links then
   92:  end                                                          end();
        label *label40                                               if links != @links then
   93:  sensor *tmp51 switch1 @enabled                               while !switch1.@enabled;
   94:  jump *label27 equal *tmp51 false                             do
   95:  set .total 0                                                 total = 0;
   96:  write 0 .memory .totalIndex                                  memory[totalIndex] = 0;


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    51     1x     51,0  <no function>
    46     1x     46,0  void initialize()

Performance: parsed in 227 ms, compiled in 283 ms, optimized in 444 ms, run in 96 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
[gold]Item Counter Micro[], version [gold]1.0[]
[salmon]No plastanium conveyor attached (maximum: 4, found: 0)
[--- Previous segment repeated 361,00 times ---]

Execution step limit of 100000 exceeded.
