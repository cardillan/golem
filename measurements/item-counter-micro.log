   240 instructions before optimizations.
    11 instructions eliminated by Temp Variables Elimination (7 iterations).
     1 instructions eliminated by Case Expression Optimization.
    16 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
     8 instructions eliminated by Jump Optimization (5 iterations).
     7 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
   257 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
     1 instructions modified by If Expression Optimization (3 iterations).
    46 instructions eliminated by Data Flow Optimization (4 passes, 38 iterations).
     2 instructions eliminated by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
   140 instructions added by Loop Unrolling (29 iterations).
     3 loops unrolled by Loop Unrolling.
   130 instructions added by Array Optimization (29 iterations).
     3 array(s) improved by Array Optimization.
     2 instructions eliminated by Jump Straightening (5 iterations).
     3 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    21 instructions eliminated by Print Merging.
    97 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 817):
    Inline shared table of array 'conv'                          size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state1'                        size    +2, benefit     2562.5, efficiency   1281.250
  * Inline array access to 'state1' at line 74:13                size    -3, benefit     1281.3, efficiency   Infinity (-3 instructions)
    Inline shared table of array 'state2'                        size    +2, benefit     2562.5, efficiency   1281.250
    Inline array access to 'state2' at line 87:13                size    -3, benefit     1281.3, efficiency   Infinity
    Unroll iteration loop at line 32:9                           size   -19, benefit      475.0, efficiency   Infinity
    Unroll loop at line 73:9                                     size    +6, benefit     5000.0, efficiency    833.333
    Unroll loop at line 86:9                                     size    +6, benefit     5000.0, efficiency    833.333

Pass 1: speed optimization selection (cost limit 820):
    Inline shared table of array 'conv'                          size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state1'                        size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state2'                        size    +2, benefit     2562.5, efficiency   1281.250
  * Inline array access to 'state2' at line 87:13                size    -3, benefit     1281.3, efficiency   Infinity (-3 instructions)
    Unroll iteration loop at line 32:9                           size   -19, benefit      475.0, efficiency   Infinity
    Unroll loop at line 73:9                                     size    +1, benefit     5000.0, efficiency   5000.000
    Unroll loop at line 86:9                                     size    +6, benefit     5000.0, efficiency    833.333

Pass 1: speed optimization selection (cost limit 823):
    Inline shared table of array 'conv'                          size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state1'                        size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state2'                        size    +2, benefit     2562.5, efficiency   1281.250
  * Unroll iteration loop at line 32:9                           size   -19, benefit      475.0, efficiency   Infinity (-8 instructions)
    Unroll loop at line 73:9                                     size    +1, benefit     5000.0, efficiency   5000.000
    Unroll loop at line 86:9                                     size    +1, benefit     5000.0, efficiency   5000.000

Pass 1: speed optimization selection (cost limit 831):
    Inline shared table of array 'conv'                          size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state1'                        size    +2, benefit     2562.5, efficiency   1281.250
    Inline shared table of array 'state2'                        size    +2, benefit     2562.5, efficiency   1281.250
  * Unroll loop at line 73:9                                     size    +1, benefit     5000.0, efficiency   5000.000 (+69 instructions)
    Unroll loop at line 86:9                                     size    +1, benefit     5000.0, efficiency   5000.000

Pass 1: speed optimization selection (cost limit 762):
    Inline shared table of array 'conv'                          size   +17, benefit     1486.3, efficiency     87.426
    Inline shared table of array 'state1'                        size   +17, benefit     1486.3, efficiency     87.426
    Inline shared table of array 'state2'                        size   +17, benefit     1486.3, efficiency     87.426
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit     1281.3, efficiency    256.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit     1281.3, efficiency    256.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit     1281.3, efficiency    256.250
  * Unroll loop at line 86:9                                     size    +1, benefit     5000.0, efficiency   5000.000 (+69 instructions)

Pass 1: speed optimization selection (cost limit 693):
  o Inline shared table of array 'conv'                          size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 688):
  o Inline shared table of array 'conv'                          size   +27, benefit      358.7, efficiency     13.287
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 683):
  o Inline shared table of array 'conv'                          size   +22, benefit      307.5, efficiency     13.977
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 678):
  o Inline shared table of array 'conv'                          size   +17, benefit      256.2, efficiency     15.074
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 74:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 673):
  o Inline shared table of array 'conv'                          size   +12, benefit      205.0, efficiency     17.083
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 668):
  o Inline shared table of array 'conv'                          size    +7, benefit      153.7, efficiency     21.964
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'conv' at line 87:25                  size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 663):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +32, benefit      410.0, efficiency     12.812
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 658):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +27, benefit      358.7, efficiency     13.287
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 653):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +22, benefit      307.5, efficiency     13.977
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 648):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +17, benefit      256.2, efficiency     15.074
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 643):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size   +12, benefit      205.0, efficiency     17.083
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 638):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +7, benefit      153.7, efficiency     21.964
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state1' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 633):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +32, benefit      410.0, efficiency     12.812
  * Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 628):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +27, benefit      358.7, efficiency     13.287
  * Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 623):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +22, benefit      307.5, efficiency     13.977
  * Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 618):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +17, benefit      256.2, efficiency     15.074
  * Inline array access to 'state2' at line 75:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 613):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size   +12, benefit      205.0, efficiency     17.083
  * Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 608):
  o Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size    +7, benefit      153.7, efficiency     21.964
  * Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250 (+5 instructions)
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250
    Inline array access to 'state2' at line 88:26                size    +5, benefit       51.2, efficiency     10.250

Pass 1: speed optimization selection (cost limit 603):
  * Inline shared table of array 'conv'                          size    +2, benefit      102.5, efficiency     51.250 (+2 instructions)
  o Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250
  o Inline shared table of array 'state2'                        size    +2, benefit      102.5, efficiency     51.250

Pass 1: speed optimization selection (cost limit 601):
  * Inline shared table of array 'state1'                        size    +2, benefit      102.5, efficiency     51.250 (+2 instructions)
  o Inline shared table of array 'state2'                        size    +2, benefit      102.5, efficiency     51.250

Pass 1: speed optimization selection (cost limit 599):
  * Inline shared table of array 'state2'                        size    +2, benefit      102.5, efficiency     51.250 (+2 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    33 getlink *tmp2 :initialize:n
    34 set :initialize:block *tmp2
    35 sensor *tmp4 :initialize:block @type
-    * set *tmp5 *tmp4
-    * jump *label16 equal *tmp5 @memory-cell
-    * jump *label16 equal *tmp5 @memory-bank
+   36 jump *label16 equal *tmp4 @memory-cell
+   37 jump *label16 equal *tmp4 @memory-bank
    38 jump *label15 always
    39 label *label16
    40 set .memory :initialize:block
    41 set *tmp3 .memory
    42 jump *label14 always
    43 label *label15
-    * jump *label18 equal *tmp5 @plastanium-conveyor
+   44 jump *label18 equal *tmp4 @plastanium-conveyor
    45 jump *label17 always
    46 label *label18
    47 set .conv*3 .conv*2

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-11 instructions):
 
    38 jump *label15 always
    39 label *label16
    40 set .memory :initialize:block
-    * set *tmp3 .memory
    41 jump *label14 always
    42 label *label15
    43 jump *label18 equal *tmp4 @plastanium-conveyor
 
    49 set .conv*0 :initialize:block
    50 set *tmp6 .found
    51 op add .found .found 1
-    * set *tmp3 *tmp6
    52 jump *label14 always
    53 label *label17
-    * set *tmp3 null
    54 label *label14
    55 label *label12
    56 op sub :initialize:n :initialize:n 1
 
    67 print .found
    68 print ")"
    69 printflush message1
-    * set *tmp8 null
    70 jump *label20 always
    71 label *label19
    72 op greaterThan *tmp9 .found 4
 
   107 label *label24
   108 set *tmp10 *tmp12
   109 label *label22
-    * set *tmp8 *tmp10
   110 label *label20
   111 label *label2
   112 jump *label1 always
 
   131 jump *label33 equal *tmp28 false
   132 op add *tmp30 .total 10
   133 set .total *tmp30
-    * set *tmp29 *tmp30
   134 jump *label34 always
   135 label *label33
-    * set *tmp29 null
   136 label *label34
   137 label *label31
   138 op add :i :i 1
 
   171 jump *label38 equal *tmp43 false
   172 op add *tmp45 .total 10
   173 set .total *tmp45
-    * set *tmp44 *tmp45
   174 jump *label39 always
   175 label *label38
-    * set *tmp44 null
   176 label *label39
   177 label *label36
   178 op add :i.1 :i.1 1
 
   190 op notEqual *tmp49 .links @links
   191 jump *label40 equal *tmp49 false
   192 end
-    * set *tmp50 null
   193 jump *label41 always
   194 label *label40
-    * set *tmp50 null
   195 label *label41
   196 label *label28
   197 sensor *tmp51 switch1 @enabled

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-3 instructions):
 
    47 set .conv*2 .conv*1
    48 set .conv*1 .conv*0
    49 set .conv*0 :initialize:block
-    * set *tmp6 .found
    50 op add .found .found 1
    51 jump *label14 always
    52 label *label17
 
    79 print .found
    80 print ")"
    81 printflush message1
-    * set *tmp10 null
    82 jump *label22 always
    83 label *label21
    84 op equal *tmp11 .memory null
 
   103 jump *label3 always
   104 set *tmp12 null
   105 label *label24
-    * set *tmp10 *tmp12
   106 label *label22
   107 label *label20
   108 label *label2

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
    85 jump *label23 equal *tmp11 false
    86 print "$TITLE\n[salmon]No memory attached."
    87 printflush message1
-    * set *tmp12 null
    88 jump *label24 always
    89 label *label23
    90 sensor *tmp13 .memory @type
 
   100 read *tmp17 .memory *tmp16
   101 set .total *tmp17
   102 jump *label3 always
-    * set *tmp12 null
   103 label *label24
   104 label *label22
   105 label *label20

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-10 instructions):
 
    25 label *label6
    26 set .memory null
    27 set .found 0
-    * set *tmp1 @links
-    * set .links *tmp1
+   28 set .links @links
    29 op sub :initialize:n .links 1
    30 label *label11
    31 jump *label13 lessThan :initialize:n 0
-    * getlink *tmp2 :initialize:n
-    * set :initialize:block *tmp2
+   32 getlink :initialize:block :initialize:n
    33 sensor *tmp4 :initialize:block @type
    34 jump *label16 equal *tmp4 @memory-cell
    35 jump *label16 equal *tmp4 @memory-bank
 
    94 set *tmp15 511
    95 label *label26
    96 set .totalIndex *tmp15
-    * set *tmp16 .totalIndex
-    * read *tmp17 .memory *tmp16
-    * set .total *tmp17
+   97 read .total .memory .totalIndex
    98 jump *label3 always
    99 label *label24
   100 label *label22
 
   110 label *label30
   111 jump *label32 greaterThanEq :i 4
   112 set *tmp19 :i
-    * set *tmp21 :i
-    * readarr<internal:regular> *tmp22 .conv[] *tmp21
+  113 readarr<internal:regular> *tmp22 .conv[] :i
   114 sensor *tmp23 *tmp22 @totalItems
   115 writearr<internal:regular> *tmp23 .state1[] *tmp19
   116 set *tmp24 :i
 
   119 readarr<internal:regular> *tmp27 .state2[] *tmp26
   120 op lessThan *tmp28 *tmp25 *tmp27
   121 jump *label33 equal *tmp28 false
-    * op add *tmp30 .total 10
-    * set .total *tmp30
+  122 op add .total .total 10
   123 jump *label34 always
   124 label *label33
   125 label *label34
 
   128 jump *label30 always
   129 label *label32
   130 set *tmp31 .totalIndex
-    * set *tmp33 .total
-    * write *tmp33 .memory *tmp31
+  131 write .total .memory *tmp31
   132 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   133 print " "
   134 print "           "
 
   147 label *label35
   148 jump *label37 greaterThanEq :i.1 4
   149 set *tmp34 :i.1
-    * set *tmp36 :i.1
-    * readarr<internal:regular> *tmp37 .conv[] *tmp36
+  150 readarr<internal:regular> *tmp37 .conv[] :i.1
   151 sensor *tmp38 *tmp37 @totalItems
   152 writearr<internal:regular> *tmp38 .state2[] *tmp34
   153 set *tmp39 :i.1
 
   156 readarr<internal:regular> *tmp42 .state1[] *tmp41
   157 op lessThan *tmp43 *tmp40 *tmp42
   158 jump *label38 equal *tmp43 false
-    * op add *tmp45 .total 10
-    * set .total *tmp45
+  159 op add .total .total 10
   160 jump *label39 always
   161 label *label38
   162 label *label39
 
   185 jump *label27 notEqual *tmp52 false
   186 label *label29
   187 set .total 0
-    * set *tmp53 .totalIndex
-    * write 0 .memory *tmp53
+  188 write 0 .memory .totalIndex
   189 end

Modifications by Initial phase, Temp Variables Elimination, iteration 2 (-1 instructions):
 
   127 op add :i :i 1
   128 jump *label30 always
   129 label *label32
-    * set *tmp31 .totalIndex
-    * write .total .memory *tmp31
+  130 write .total .memory .totalIndex
   131 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   132 print " "
   133 print "           "

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
     0 label *label1
-    * jump *label3 equal true false
     1 set :initialize:c .conv*0
     2 setaddr *tmp0 *label7
     3 jump *label4 always

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-2 instructions):
 
    31 getlink :initialize:block :initialize:n
    32 sensor *tmp4 :initialize:block @type
    33 jump *label16 equal *tmp4 @memory-cell
-    * jump *label16 equal *tmp4 @memory-bank
-    * jump *label15 always
+   34 jump *label15 notEqual *tmp4 @memory-bank
    35 label *label16
    36 set .memory :initialize:block
    37 jump *label14 always
    38 label *label15
-    * jump *label18 equal *tmp4 @plastanium-conveyor
-    * jump *label17 always
+   39 jump *label17 notEqual *tmp4 @plastanium-conveyor
    40 label *label18
    41 set .conv*3 .conv*2
    42 set .conv*2 .conv*1

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-8 instructions):
 
    50 op sub :initialize:n :initialize:n 1
    51 jump *label11 always
    52 label *label13
-    * op equal *tmp7 .found 0
-    * jump *label19 equal *tmp7 false
+   53 jump *label19 notEqual .found 0
    54 print "[gold]Item Counter Micro[], version [gold]1.0[]"
    55 print "\"
    56 print "n[salmon]No plastanium conveyor attached (maximum: "
 
    62 printflush message1
    63 jump *label20 always
    64 label *label19
-    * op greaterThan *tmp9 .found 4
-    * jump *label21 equal *tmp9 false
+   65 jump *label21 lessThanEq .found 4
    66 print "[gold]Item Counter Micro[], version [gold]1.0[]"
    67 print "\"
    68 print "n[salmon]Too many plastanium conveyors attached (maximum: "
 
    74 printflush message1
    75 jump *label22 always
    76 label *label21
-    * op equal *tmp11 .memory null
-    * jump *label23 equal *tmp11 false
+   77 jump *label23 notEqual .memory null
    78 print "$TITLE\n[salmon]No memory attached."
    79 printflush message1
    80 jump *label24 always
    81 label *label23
    82 sensor *tmp13 .memory @type
-    * op equal *tmp14 *tmp13 @memory-cell
-    * jump *label25 equal *tmp14 false
+   83 jump *label25 notEqual *tmp13 @memory-cell
    84 set *tmp15 63
    85 jump *label26 always
    86 label *label25
 
   110 set *tmp26 :i
   111 readarr<internal:regular> *tmp25 .state1[] *tmp24
   112 readarr<internal:regular> *tmp27 .state2[] *tmp26
-    * op lessThan *tmp28 *tmp25 *tmp27
-    * jump *label33 equal *tmp28 false
+  113 jump *label33 greaterThanEq *tmp25 *tmp27
   114 op add .total .total 10
   115 jump *label34 always
   116 label *label33
 
   145 set *tmp41 :i.1
   146 readarr<internal:regular> *tmp40 .state2[] *tmp39
   147 readarr<internal:regular> *tmp42 .state1[] *tmp41
-    * op lessThan *tmp43 *tmp40 *tmp42
-    * jump *label38 equal *tmp43 false
+  148 jump *label38 greaterThanEq *tmp40 *tmp42
   149 op add .total .total 10
   150 jump *label39 always
   151 label *label38
 
   163 print "ms"
   164 print "\n"
   165 printflush message1
-    * op notEqual *tmp49 .links @links
-    * jump *label40 equal *tmp49 false
+  166 jump *label40 equal .links @links
   167 end
   168 jump *label41 always
   169 label *label40
   170 label *label41
   171 label *label28
   172 sensor *tmp51 switch1 @enabled
-    * op equal *tmp52 *tmp51 false
-    * jump *label27 notEqual *tmp52 false
+  173 jump *label27 equal *tmp51 false
   174 label *label29
   175 set .total 0
   176 write 0 .memory .totalIndex

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    43 set .conv*1 .conv*0
    44 set .conv*0 :initialize:block
    45 op add .found .found 1
-    * jump *label14 always
    46 label *label17
    47 label *label14
    48 label *label12
 
   111 readarr<internal:regular> *tmp27 .state2[] *tmp26
   112 jump *label33 greaterThanEq *tmp25 *tmp27
   113 op add .total .total 10
-    * jump *label34 always
   114 label *label33
   115 label *label34
   116 label *label31
 
   145 readarr<internal:regular> *tmp42 .state1[] *tmp41
   146 jump *label38 greaterThanEq *tmp40 *tmp42
   147 op add .total .total 10
-    * jump *label39 always
   148 label *label38
   149 label *label39
   150 label *label36
 
   162 printflush message1
   163 jump *label40 equal .links @links
   164 end
-    * jump *label41 always
   165 label *label40
   166 label *label41
   167 label *label28

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   152 jump *label35 always
   153 label *label37
   154 op sub *tmp46 @time :start
-    * op div *tmp47 *tmp46 2
-    * op floor *tmp48 *tmp47
+  155 op idiv *tmp48 *tmp46 2
   156 print "[lightgray]Loop time: "
   157 print *tmp48
   158 print " "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
     0 label *label1
-    * set :initialize:c .conv*0
     1 setaddr *tmp0 *label7
     2 jump *label4 always
     3 multilabel *label7 (m:marker0)
-    * set .conv*0 :initialize:c
-    * set :initialize:c .conv*1
+    4 set .conv*0 null
     5 setaddr *tmp0 *label8
     6 jump *label4 always
     7 multilabel *label8 (m:marker0)
-    * set .conv*1 :initialize:c
-    * set :initialize:c .conv*2
+    8 set .conv*1 null
     9 setaddr *tmp0 *label9
    10 jump *label4 always
    11 multilabel *label9 (m:marker0)
-    * set .conv*2 :initialize:c
-    * set :initialize:c .conv*3
+   12 set .conv*2 null
    13 setaddr *tmp0 *label10
    14 label *label4
    15 set :initialize:c null
    16 label *label5
    17 multijump *tmp0 0 0 (m:marker0)
    18 multilabel *label10 (m:marker0)
-    * set .conv*3 :initialize:c
+   19 set .conv*3 null
    20 label *label6
    21 set .memory null
    22 set .found 0
 
    82 set *tmp15 511
    83 label *label26
    84 set .totalIndex *tmp15
-    * read .total .memory .totalIndex
+   85 read .total .memory *tmp15
    86 jump *label3 always
    87 label *label24
    88 label *label22
 
   100 set *tmp19 :i
   101 readarr<internal:regular> *tmp22 .conv[] :i
   102 sensor *tmp23 *tmp22 @totalItems
-    * writearr<internal:regular> *tmp23 .state1[] *tmp19
+  103 writearr<internal:regular> *tmp23 .state1[] :i
   104 set *tmp24 :i
   105 set *tmp26 :i
-    * readarr<internal:regular> *tmp25 .state1[] *tmp24
-    * readarr<internal:regular> *tmp27 .state2[] *tmp26
+  106 readarr<internal:regular> *tmp25 .state1[] :i
+  107 readarr<internal:regular> *tmp27 .state2[] :i
   108 jump *label33 greaterThanEq *tmp25 *tmp27
   109 op add .total .total 10
   110 label *label33
 
   134 set *tmp34 :i.1
   135 readarr<internal:regular> *tmp37 .conv[] :i.1
   136 sensor *tmp38 *tmp37 @totalItems
-    * writearr<internal:regular> *tmp38 .state2[] *tmp34
+  137 writearr<internal:regular> *tmp38 .state2[] :i.1
   138 set *tmp39 :i.1
   139 set *tmp41 :i.1
-    * readarr<internal:regular> *tmp40 .state2[] *tmp39
-    * readarr<internal:regular> *tmp42 .state1[] *tmp41
+  140 readarr<internal:regular> *tmp40 .state2[] :i.1
+  141 readarr<internal:regular> *tmp42 .state1[] :i.1
   142 jump *label38 greaterThanEq *tmp40 *tmp42
   143 op add .total .total 10
   144 label *label38

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
    12 set .conv*2 null
    13 setaddr *tmp0 *label10
    14 label *label4
-    * set :initialize:c null
    15 label *label5
    16 multijump *tmp0 0 0 (m:marker0)
    17 multilabel *label10 (m:marker0)
 
    96 set :i 0
    97 label *label30
    98 jump *label32 greaterThanEq :i 4
-    * set *tmp19 :i
    99 readarr<internal:regular> *tmp22 .conv[] :i
   100 sensor *tmp23 *tmp22 @totalItems
   101 writearr<internal:regular> *tmp23 .state1[] :i
-    * set *tmp24 :i
-    * set *tmp26 :i
   102 readarr<internal:regular> *tmp25 .state1[] :i
   103 readarr<internal:regular> *tmp27 .state2[] :i
   104 jump *label33 greaterThanEq *tmp25 *tmp27
 
   127 set :i.1 0
   128 label *label35
   129 jump *label37 greaterThanEq :i.1 4
-    * set *tmp34 :i.1
   130 readarr<internal:regular> *tmp37 .conv[] :i.1
   131 sensor *tmp38 *tmp37 @totalItems
   132 writearr<internal:regular> *tmp38 .state2[] :i.1
-    * set *tmp39 :i.1
-    * set *tmp41 :i.1
   133 readarr<internal:regular> *tmp40 .state2[] :i.1
   134 readarr<internal:regular> *tmp42 .state1[] :i.1
   135 jump *label38 greaterThanEq *tmp40 *tmp42

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-2 instructions):
 
    23 op sub :initialize:n .links 1
    24 label *label11
    25 jump *label13 lessThan :initialize:n 0
+   26 label *label42
    27 getlink :initialize:block :initialize:n
    28 sensor *tmp4 :initialize:block @type
    29 jump *label16 equal *tmp4 @memory-cell
 
    43 label *label14
    44 label *label12
    45 op sub :initialize:n :initialize:n 1
-    * jump *label11 always
+   46 jump *label42 greaterThanEq :initialize:n 0
    47 label *label13
    48 jump *label19 notEqual .found 0
    49 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
    96 set :start @time
    97 set :i 0
    98 label *label30
-    * jump *label32 greaterThanEq :i 4
+   99 label *label43
   100 readarr<internal:regular> *tmp22 .conv[] :i
   101 sensor *tmp23 *tmp22 @totalItems
   102 writearr<internal:regular> *tmp23 .state1[] :i
 
   108 label *label34
   109 label *label31
   110 op add :i :i 1
-    * jump *label30 always
+  111 jump *label43 lessThan :i 4
   112 label *label32
   113 write .total .memory .totalIndex
   114 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
   127 print "\n"
   128 set :i.1 0
   129 label *label35
-    * jump *label37 greaterThanEq :i.1 4
+  130 label *label44
   131 readarr<internal:regular> *tmp37 .conv[] :i.1
   132 sensor *tmp38 *tmp37 @totalItems
   133 writearr<internal:regular> *tmp38 .state2[] :i.1
 
   139 label *label39
   140 label *label36
   141 op add :i.1 :i.1 1
-    * jump *label35 always
+  142 jump *label44 lessThan :i.1 4
   143 label *label37
   144 op sub *tmp46 @time :start
   145 op idiv *tmp48 *tmp46 2

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1:
 
    74 printflush message1
    75 jump *label24 always
    76 label *label23
+   77 set *tmp15 511
    78 sensor *tmp13 .memory @type
-    * jump *label25 notEqual *tmp13 @memory-cell
+   79 jump *label26 notEqual *tmp13 @memory-cell
    80 set *tmp15 63
    81 jump *label26 always
-    * label *label25
-    * set *tmp15 511
    82 label *label26
    83 set .totalIndex *tmp15
    84 read .total .memory *tmp15

Modifications by Inline array access to 'state1' at line 74:13 (-3 instructions):
 
    98 label *label43
    99 readarr<internal:regular> *tmp22 .conv[] :i
   100 sensor *tmp23 *tmp22 @totalItems
-    * writearr<internal:regular> *tmp23 .state1[] :i
+  101 writearr<inlined:regular> *tmp23 .state1[] :i
   102 readarr<internal:regular> *tmp25 .state1[] :i
   103 readarr<internal:regular> *tmp27 .state2[] :i
   104 jump *label33 greaterThanEq *tmp25 *tmp27

Modifications by Inline array access to 'state2' at line 87:13 (-3 instructions):
 
   129 label *label44
   130 readarr<internal:regular> *tmp37 .conv[] :i.1
   131 sensor *tmp38 *tmp37 @totalItems
-    * writearr<internal:regular> *tmp38 .state2[] :i.1
+  132 writearr<inlined:regular> *tmp38 .state2[] :i.1
   133 readarr<internal:regular> *tmp40 .state2[] :i.1
   134 readarr<internal:regular> *tmp42 .state1[] :i.1
   135 jump *label38 greaterThanEq *tmp40 *tmp42

Modifications by Unroll iteration loop at line 32:9 (-8 instructions):
     0 label *label1
-    * setaddr *tmp0 *label7
-    * jump *label4 always
-    * multilabel *label7 (m:marker0)
-    * set .conv*0 null
-    * setaddr *tmp0 *label8
-    * jump *label4 always
-    * multilabel *label8 (m:marker0)
-    * set .conv*1 null
-    * setaddr *tmp0 *label9
-    * jump *label4 always
-    * multilabel *label9 (m:marker0)
-    * set .conv*2 null
-    * setaddr *tmp0 *label10
-    * label *label4
-    * label *label5
-    * multijump *tmp0 0 0 (m:marker0)
-    * multilabel *label10 (m:marker0)
-    * set .conv*3 null
-    * label *label6
+    1 label *label45
+    2 label *label46
+    3 set .conv*0 null
+    4 label *label49
+    5 label *label50
+    6 set .conv*1 null
+    7 label *label53
+    8 label *label54
+    9 set .conv*2 null
+   10 label *label57
+   11 label *label58
+   12 set .conv*3 null
+   13 label *label6
    14 set .memory null
    15 set .found 0
    16 set .links @links

Modifications by Unroll loop at line 73:9 (+74 instructions):
 
    87 control enabled switch1 false
    88 label *label27
    89 set :start @time
-    * set :i 0
-    * label *label30
-    * label *label43
-    * readarr<internal:regular> *tmp22 .conv[] :i
-    * sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
-    * jump *label33 greaterThanEq *tmp25 *tmp27
-    * op add .total .total 10
-    * label *label33
-    * label *label34
-    * label *label31
-    * op add :i :i 1
-    * jump *label43 lessThan :i 4
-    * label *label32
+   90 set :i 0
+   91 label *label62
+   92 label *label63
+   93 readarr<internal:regular> *tmp22 .conv[] :i
+   94 sensor *tmp23 *tmp22 @totalItems
+   95 writearr<inlined:regular> *tmp23 .state1[] :i
+   96 readarr<internal:regular> *tmp25 .state1[] :i
+   97 readarr<internal:regular> *tmp27 .state2[] :i
+   98 jump *label64 greaterThanEq *tmp25 *tmp27
+   99 op add .total .total 10
+  100 label *label64
+  101 label *label65
+  102 label *label66
+  103 op add :i :i 1
+  104 label *label67
+  105 readarr<internal:regular> *tmp22 .conv[] :i
+  106 sensor *tmp23 *tmp22 @totalItems
+  107 writearr<inlined:regular> *tmp23 .state1[] :i
+  108 readarr<internal:regular> *tmp25 .state1[] :i
+  109 readarr<internal:regular> *tmp27 .state2[] :i
+  110 jump *label68 greaterThanEq *tmp25 *tmp27
+  111 op add .total .total 10
+  112 label *label68
+  113 label *label69
+  114 label *label70
+  115 op add :i :i 1
+  116 label *label71
+  117 readarr<internal:regular> *tmp22 .conv[] :i
+  118 sensor *tmp23 *tmp22 @totalItems
+  119 writearr<inlined:regular> *tmp23 .state1[] :i
+  120 readarr<internal:regular> *tmp25 .state1[] :i
+  121 readarr<internal:regular> *tmp27 .state2[] :i
+  122 jump *label72 greaterThanEq *tmp25 *tmp27
+  123 op add .total .total 10
+  124 label *label72
+  125 label *label73
+  126 label *label74
+  127 op add :i :i 1
+  128 label *label75
+  129 readarr<internal:regular> *tmp22 .conv[] :i
+  130 sensor *tmp23 *tmp22 @totalItems
+  131 writearr<inlined:regular> *tmp23 .state1[] :i
+  132 readarr<internal:regular> *tmp25 .state1[] :i
+  133 readarr<internal:regular> *tmp27 .state2[] :i
+  134 jump *label76 greaterThanEq *tmp25 *tmp27
+  135 op add .total .total 10
+  136 label *label76
+  137 label *label77
+  138 label *label78
+  139 op add :i :i 1
+  140 label *label32
   141 write .total .memory .totalIndex
   142 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   143 print " "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    90 set :i 0
    91 label *label62
    92 label *label63
-    * readarr<internal:regular> *tmp22 .conv[] :i
+   93 readarr<internal:regular> *tmp22 .conv[] 0
    94 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
+   95 writearr<inlined:regular> *tmp23 .state1[] 0
+   96 readarr<internal:regular> *tmp25 .state1[] 0
+   97 readarr<internal:regular> *tmp27 .state2[] 0
    98 jump *label64 greaterThanEq *tmp25 *tmp27
    99 op add .total .total 10
   100 label *label64
   101 label *label65
   102 label *label66
-    * op add :i :i 1
+  103 op add :i 0 1
   104 label *label67
-    * readarr<internal:regular> *tmp22 .conv[] :i
+  105 readarr<internal:regular> *tmp22 .conv[] 1
   106 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
+  107 writearr<inlined:regular> *tmp23 .state1[] 1
+  108 readarr<internal:regular> *tmp25 .state1[] 1
+  109 readarr<internal:regular> *tmp27 .state2[] 1
   110 jump *label68 greaterThanEq *tmp25 *tmp27
   111 op add .total .total 10
   112 label *label68
   113 label *label69
   114 label *label70
-    * op add :i :i 1
+  115 op add :i 1 1
   116 label *label71
-    * readarr<internal:regular> *tmp22 .conv[] :i
+  117 readarr<internal:regular> *tmp22 .conv[] 2
   118 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
+  119 writearr<inlined:regular> *tmp23 .state1[] 2
+  120 readarr<internal:regular> *tmp25 .state1[] 2
+  121 readarr<internal:regular> *tmp27 .state2[] 2
   122 jump *label72 greaterThanEq *tmp25 *tmp27
   123 op add .total .total 10
   124 label *label72
   125 label *label73
   126 label *label74
-    * op add :i :i 1
+  127 op add :i 2 1
   128 label *label75
-    * readarr<internal:regular> *tmp22 .conv[] :i
+  129 readarr<internal:regular> *tmp22 .conv[] 3
   130 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] :i
-    * readarr<internal:regular> *tmp25 .state1[] :i
-    * readarr<internal:regular> *tmp27 .state2[] :i
+  131 writearr<inlined:regular> *tmp23 .state1[] 3
+  132 readarr<internal:regular> *tmp25 .state1[] 3
+  133 readarr<internal:regular> *tmp27 .state2[] 3
   134 jump *label76 greaterThanEq *tmp25 *tmp27
   135 op add .total .total 10
   136 label *label76
   137 label *label77
   138 label *label78
-    * op add :i :i 1
+  139 op add :i 3 1
   140 label *label32
   141 write .total .memory .totalIndex
   142 print "[gold]Item Counter Micro[], version [gold]1.0[]"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    87 control enabled switch1 false
    88 label *label27
    89 set :start @time
-    * set :i 0
    90 label *label62
    91 label *label63
    92 readarr<internal:regular> *tmp22 .conv[] 0
 
    99 label *label64
   100 label *label65
   101 label *label66
-    * op add :i 0 1
   102 label *label67
   103 readarr<internal:regular> *tmp22 .conv[] 1
   104 sensor *tmp23 *tmp22 @totalItems
 
   110 label *label68
   111 label *label69
   112 label *label70
-    * op add :i 1 1
   113 label *label71
   114 readarr<internal:regular> *tmp22 .conv[] 2
   115 sensor *tmp23 *tmp22 @totalItems
 
   121 label *label72
   122 label *label73
   123 label *label74
-    * op add :i 2 1
   124 label *label75
   125 readarr<internal:regular> *tmp22 .conv[] 3
   126 sensor *tmp23 *tmp22 @totalItems
 
   132 label *label76
   133 label *label77
   134 label *label78
-    * op add :i 3 1
   135 label *label32
   136 write .total .memory .totalIndex
   137 print "[gold]Item Counter Micro[], version [gold]1.0[]"

Modifications by Unroll loop at line 86:9 (+74 instructions):
 
   148 print "["
   149 print "]"
   150 print "\n"
-    * set :i.1 0
-    * label *label35
-    * label *label44
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
-    * sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
-    * jump *label38 greaterThanEq *tmp40 *tmp42
-    * op add .total .total 10
-    * label *label38
-    * label *label39
-    * label *label36
-    * op add :i.1 :i.1 1
-    * jump *label44 lessThan :i.1 4
-    * label *label37
+  151 set :i.1 0
+  152 label *label79
+  153 label *label80
+  154 readarr<internal:regular> *tmp37 .conv[] :i.1
+  155 sensor *tmp38 *tmp37 @totalItems
+  156 writearr<inlined:regular> *tmp38 .state2[] :i.1
+  157 readarr<internal:regular> *tmp40 .state2[] :i.1
+  158 readarr<internal:regular> *tmp42 .state1[] :i.1
+  159 jump *label81 greaterThanEq *tmp40 *tmp42
+  160 op add .total .total 10
+  161 label *label81
+  162 label *label82
+  163 label *label83
+  164 op add :i.1 :i.1 1
+  165 label *label84
+  166 readarr<internal:regular> *tmp37 .conv[] :i.1
+  167 sensor *tmp38 *tmp37 @totalItems
+  168 writearr<inlined:regular> *tmp38 .state2[] :i.1
+  169 readarr<internal:regular> *tmp40 .state2[] :i.1
+  170 readarr<internal:regular> *tmp42 .state1[] :i.1
+  171 jump *label85 greaterThanEq *tmp40 *tmp42
+  172 op add .total .total 10
+  173 label *label85
+  174 label *label86
+  175 label *label87
+  176 op add :i.1 :i.1 1
+  177 label *label88
+  178 readarr<internal:regular> *tmp37 .conv[] :i.1
+  179 sensor *tmp38 *tmp37 @totalItems
+  180 writearr<inlined:regular> *tmp38 .state2[] :i.1
+  181 readarr<internal:regular> *tmp40 .state2[] :i.1
+  182 readarr<internal:regular> *tmp42 .state1[] :i.1
+  183 jump *label89 greaterThanEq *tmp40 *tmp42
+  184 op add .total .total 10
+  185 label *label89
+  186 label *label90
+  187 label *label91
+  188 op add :i.1 :i.1 1
+  189 label *label92
+  190 readarr<internal:regular> *tmp37 .conv[] :i.1
+  191 sensor *tmp38 *tmp37 @totalItems
+  192 writearr<inlined:regular> *tmp38 .state2[] :i.1
+  193 readarr<internal:regular> *tmp40 .state2[] :i.1
+  194 readarr<internal:regular> *tmp42 .state1[] :i.1
+  195 jump *label93 greaterThanEq *tmp40 *tmp42
+  196 op add .total .total 10
+  197 label *label93
+  198 label *label94
+  199 label *label95
+  200 op add :i.1 :i.1 1
+  201 label *label37
   202 op sub *tmp46 @time :start
   203 op idiv *tmp48 *tmp46 2
   204 print "[lightgray]Loop time: "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   151 set :i.1 0
   152 label *label79
   153 label *label80
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
+  154 readarr<internal:regular> *tmp37 .conv[] 0
   155 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
+  156 writearr<inlined:regular> *tmp38 .state2[] 0
+  157 readarr<internal:regular> *tmp40 .state2[] 0
+  158 readarr<internal:regular> *tmp42 .state1[] 0
   159 jump *label81 greaterThanEq *tmp40 *tmp42
   160 op add .total .total 10
   161 label *label81
   162 label *label82
   163 label *label83
-    * op add :i.1 :i.1 1
+  164 op add :i.1 0 1
   165 label *label84
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
+  166 readarr<internal:regular> *tmp37 .conv[] 1
   167 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
+  168 writearr<inlined:regular> *tmp38 .state2[] 1
+  169 readarr<internal:regular> *tmp40 .state2[] 1
+  170 readarr<internal:regular> *tmp42 .state1[] 1
   171 jump *label85 greaterThanEq *tmp40 *tmp42
   172 op add .total .total 10
   173 label *label85
   174 label *label86
   175 label *label87
-    * op add :i.1 :i.1 1
+  176 op add :i.1 1 1
   177 label *label88
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
+  178 readarr<internal:regular> *tmp37 .conv[] 2
   179 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
+  180 writearr<inlined:regular> *tmp38 .state2[] 2
+  181 readarr<internal:regular> *tmp40 .state2[] 2
+  182 readarr<internal:regular> *tmp42 .state1[] 2
   183 jump *label89 greaterThanEq *tmp40 *tmp42
   184 op add .total .total 10
   185 label *label89
   186 label *label90
   187 label *label91
-    * op add :i.1 :i.1 1
+  188 op add :i.1 2 1
   189 label *label92
-    * readarr<internal:regular> *tmp37 .conv[] :i.1
+  190 readarr<internal:regular> *tmp37 .conv[] 3
   191 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] :i.1
-    * readarr<internal:regular> *tmp40 .state2[] :i.1
-    * readarr<internal:regular> *tmp42 .state1[] :i.1
+  192 writearr<inlined:regular> *tmp38 .state2[] 3
+  193 readarr<internal:regular> *tmp40 .state2[] 3
+  194 readarr<internal:regular> *tmp42 .state1[] 3
   195 jump *label93 greaterThanEq *tmp40 *tmp42
   196 op add .total .total 10
   197 label *label93
   198 label *label94
   199 label *label95
-    * op add :i.1 :i.1 1
+  200 op add :i.1 3 1
   201 label *label37
   202 op sub *tmp46 @time :start
   203 op idiv *tmp48 *tmp46 2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
   148 print "["
   149 print "]"
   150 print "\n"
-    * set :i.1 0
   151 label *label79
   152 label *label80
   153 readarr<internal:regular> *tmp37 .conv[] 0
 
   160 label *label81
   161 label *label82
   162 label *label83
-    * op add :i.1 0 1
   163 label *label84
   164 readarr<internal:regular> *tmp37 .conv[] 1
   165 sensor *tmp38 *tmp37 @totalItems
 
   171 label *label85
   172 label *label86
   173 label *label87
-    * op add :i.1 1 1
   174 label *label88
   175 readarr<internal:regular> *tmp37 .conv[] 2
   176 sensor *tmp38 *tmp37 @totalItems
 
   182 label *label89
   183 label *label90
   184 label *label91
-    * op add :i.1 2 1
   185 label *label92
   186 readarr<internal:regular> *tmp37 .conv[] 3
   187 sensor *tmp38 *tmp37 @totalItems
 
   193 label *label93
   194 label *label94
   195 label *label95
-    * op add :i.1 3 1
   196 label *label37
   197 op sub *tmp46 @time :start
   198 op idiv *tmp48 *tmp46 2

Modifications by Inline array access to 'conv' at line 74:25 (+5 instructions):
 
    89 set :start @time
    90 label *label62
    91 label *label63
-    * readarr<internal:regular> *tmp22 .conv[] 0
+   92 readarr<inlined:regular> *tmp22 .conv[] 0
    93 sensor *tmp23 *tmp22 @totalItems
    94 writearr<inlined:regular> *tmp23 .state1[] 0
    95 readarr<internal:regular> *tmp25 .state1[] 0

Modifications by Inline array access to 'conv' at line 74:25 (+5 instructions):
 
   100 label *label65
   101 label *label66
   102 label *label67
-    * readarr<internal:regular> *tmp22 .conv[] 1
+  103 readarr<inlined:regular> *tmp22 .conv[] 1
   104 sensor *tmp23 *tmp22 @totalItems
   105 writearr<inlined:regular> *tmp23 .state1[] 1
   106 readarr<internal:regular> *tmp25 .state1[] 1

Modifications by Inline array access to 'conv' at line 74:25 (+5 instructions):
 
   111 label *label69
   112 label *label70
   113 label *label71
-    * readarr<internal:regular> *tmp22 .conv[] 2
+  114 readarr<inlined:regular> *tmp22 .conv[] 2
   115 sensor *tmp23 *tmp22 @totalItems
   116 writearr<inlined:regular> *tmp23 .state1[] 2
   117 readarr<internal:regular> *tmp25 .state1[] 2

Modifications by Inline array access to 'conv' at line 74:25 (+5 instructions):
 
   122 label *label73
   123 label *label74
   124 label *label75
-    * readarr<internal:regular> *tmp22 .conv[] 3
+  125 readarr<inlined:regular> *tmp22 .conv[] 3
   126 sensor *tmp23 *tmp22 @totalItems
   127 writearr<inlined:regular> *tmp23 .state1[] 3
   128 readarr<internal:regular> *tmp25 .state1[] 3

Modifications by Inline array access to 'conv' at line 87:25 (+5 instructions):
 
   150 print "\n"
   151 label *label79
   152 label *label80
-    * readarr<internal:regular> *tmp37 .conv[] 0
+  153 readarr<inlined:regular> *tmp37 .conv[] 0
   154 sensor *tmp38 *tmp37 @totalItems
   155 writearr<inlined:regular> *tmp38 .state2[] 0
   156 readarr<internal:regular> *tmp40 .state2[] 0

Modifications by Inline array access to 'conv' at line 87:25 (+5 instructions):
 
   161 label *label82
   162 label *label83
   163 label *label84
-    * readarr<internal:regular> *tmp37 .conv[] 1
+  164 readarr<inlined:regular> *tmp37 .conv[] 1
   165 sensor *tmp38 *tmp37 @totalItems
   166 writearr<inlined:regular> *tmp38 .state2[] 1
   167 readarr<internal:regular> *tmp40 .state2[] 1

Modifications by Inline array access to 'state1' at line 75:26 (+5 instructions):
 
    92 readarr<inlined:regular> *tmp22 .conv[] 0
    93 sensor *tmp23 *tmp22 @totalItems
    94 writearr<inlined:regular> *tmp23 .state1[] 0
-    * readarr<internal:regular> *tmp25 .state1[] 0
+   95 readarr<inlined:regular> *tmp25 .state1[] 0
    96 readarr<internal:regular> *tmp27 .state2[] 0
    97 jump *label64 greaterThanEq *tmp25 *tmp27
    98 op add .total .total 10

Modifications by Inline array access to 'state1' at line 75:26 (+5 instructions):
 
   103 readarr<inlined:regular> *tmp22 .conv[] 1
   104 sensor *tmp23 *tmp22 @totalItems
   105 writearr<inlined:regular> *tmp23 .state1[] 1
-    * readarr<internal:regular> *tmp25 .state1[] 1
+  106 readarr<inlined:regular> *tmp25 .state1[] 1
   107 readarr<internal:regular> *tmp27 .state2[] 1
   108 jump *label68 greaterThanEq *tmp25 *tmp27
   109 op add .total .total 10

Modifications by Inline array access to 'state1' at line 75:26 (+5 instructions):
 
   114 readarr<inlined:regular> *tmp22 .conv[] 2
   115 sensor *tmp23 *tmp22 @totalItems
   116 writearr<inlined:regular> *tmp23 .state1[] 2
-    * readarr<internal:regular> *tmp25 .state1[] 2
+  117 readarr<inlined:regular> *tmp25 .state1[] 2
   118 readarr<internal:regular> *tmp27 .state2[] 2
   119 jump *label72 greaterThanEq *tmp25 *tmp27
   120 op add .total .total 10

Modifications by Inline array access to 'state1' at line 75:26 (+5 instructions):
 
   125 readarr<inlined:regular> *tmp22 .conv[] 3
   126 sensor *tmp23 *tmp22 @totalItems
   127 writearr<inlined:regular> *tmp23 .state1[] 3
-    * readarr<internal:regular> *tmp25 .state1[] 3
+  128 readarr<inlined:regular> *tmp25 .state1[] 3
   129 readarr<internal:regular> *tmp27 .state2[] 3
   130 jump *label76 greaterThanEq *tmp25 *tmp27
   131 op add .total .total 10

Modifications by Inline array access to 'state1' at line 88:26 (+5 instructions):
 
   154 sensor *tmp38 *tmp37 @totalItems
   155 writearr<inlined:regular> *tmp38 .state2[] 0
   156 readarr<internal:regular> *tmp40 .state2[] 0
-    * readarr<internal:regular> *tmp42 .state1[] 0
+  157 readarr<inlined:regular> *tmp42 .state1[] 0
   158 jump *label81 greaterThanEq *tmp40 *tmp42
   159 op add .total .total 10
   160 label *label81

Modifications by Inline array access to 'state1' at line 88:26 (+5 instructions):
 
   165 sensor *tmp38 *tmp37 @totalItems
   166 writearr<inlined:regular> *tmp38 .state2[] 1
   167 readarr<internal:regular> *tmp40 .state2[] 1
-    * readarr<internal:regular> *tmp42 .state1[] 1
+  168 readarr<inlined:regular> *tmp42 .state1[] 1
   169 jump *label85 greaterThanEq *tmp40 *tmp42
   170 op add .total .total 10
   171 label *label85

Modifications by Inline array access to 'state2' at line 75:26 (+5 instructions):
 
    93 sensor *tmp23 *tmp22 @totalItems
    94 writearr<inlined:regular> *tmp23 .state1[] 0
    95 readarr<inlined:regular> *tmp25 .state1[] 0
-    * readarr<internal:regular> *tmp27 .state2[] 0
+   96 readarr<inlined:regular> *tmp27 .state2[] 0
    97 jump *label64 greaterThanEq *tmp25 *tmp27
    98 op add .total .total 10
    99 label *label64

Modifications by Inline array access to 'state2' at line 75:26 (+5 instructions):
 
   104 sensor *tmp23 *tmp22 @totalItems
   105 writearr<inlined:regular> *tmp23 .state1[] 1
   106 readarr<inlined:regular> *tmp25 .state1[] 1
-    * readarr<internal:regular> *tmp27 .state2[] 1
+  107 readarr<inlined:regular> *tmp27 .state2[] 1
   108 jump *label68 greaterThanEq *tmp25 *tmp27
   109 op add .total .total 10
   110 label *label68

Modifications by Inline array access to 'state2' at line 75:26 (+5 instructions):
 
   115 sensor *tmp23 *tmp22 @totalItems
   116 writearr<inlined:regular> *tmp23 .state1[] 2
   117 readarr<inlined:regular> *tmp25 .state1[] 2
-    * readarr<internal:regular> *tmp27 .state2[] 2
+  118 readarr<inlined:regular> *tmp27 .state2[] 2
   119 jump *label72 greaterThanEq *tmp25 *tmp27
   120 op add .total .total 10
   121 label *label72

Modifications by Inline array access to 'state2' at line 75:26 (+5 instructions):
 
   126 sensor *tmp23 *tmp22 @totalItems
   127 writearr<inlined:regular> *tmp23 .state1[] 3
   128 readarr<inlined:regular> *tmp25 .state1[] 3
-    * readarr<internal:regular> *tmp27 .state2[] 3
+  129 readarr<inlined:regular> *tmp27 .state2[] 3
   130 jump *label76 greaterThanEq *tmp25 *tmp27
   131 op add .total .total 10
   132 label *label76

Modifications by Inline array access to 'state2' at line 88:26 (+5 instructions):
 
   153 readarr<inlined:regular> *tmp37 .conv[] 0
   154 sensor *tmp38 *tmp37 @totalItems
   155 writearr<inlined:regular> *tmp38 .state2[] 0
-    * readarr<internal:regular> *tmp40 .state2[] 0
+  156 readarr<inlined:regular> *tmp40 .state2[] 0
   157 readarr<inlined:regular> *tmp42 .state1[] 0
   158 jump *label81 greaterThanEq *tmp40 *tmp42
   159 op add .total .total 10

Modifications by Inline array access to 'state2' at line 88:26 (+5 instructions):
 
   164 readarr<inlined:regular> *tmp37 .conv[] 1
   165 sensor *tmp38 *tmp37 @totalItems
   166 writearr<inlined:regular> *tmp38 .state2[] 1
-    * readarr<internal:regular> *tmp40 .state2[] 1
+  167 readarr<inlined:regular> *tmp40 .state2[] 1
   168 readarr<inlined:regular> *tmp42 .state1[] 1
   169 jump *label85 greaterThanEq *tmp40 *tmp42
   170 op add .total .total 10

Modifications by Inline shared table of array 'conv' (+2 instructions):
 
   172 label *label86
   173 label *label87
   174 label *label88
-    * readarr<internal:regular> *tmp37 .conv[] 2
+  175 readarr<inlined:regular> *tmp37 .conv[] 2
   176 sensor *tmp38 *tmp37 @totalItems
   177 writearr<inlined:regular> *tmp38 .state2[] 2
   178 readarr<internal:regular> *tmp40 .state2[] 2
 
   183 label *label90
   184 label *label91
   185 label *label92
-    * readarr<internal:regular> *tmp37 .conv[] 3
+  186 readarr<inlined:regular> *tmp37 .conv[] 3
   187 sensor *tmp38 *tmp37 @totalItems
   188 writearr<inlined:regular> *tmp38 .state2[] 3
   189 readarr<internal:regular> *tmp40 .state2[] 3

Modifications by Inline shared table of array 'state1' (+2 instructions):
 
   176 sensor *tmp38 *tmp37 @totalItems
   177 writearr<inlined:regular> *tmp38 .state2[] 2
   178 readarr<internal:regular> *tmp40 .state2[] 2
-    * readarr<internal:regular> *tmp42 .state1[] 2
+  179 readarr<inlined:regular> *tmp42 .state1[] 2
   180 jump *label89 greaterThanEq *tmp40 *tmp42
   181 op add .total .total 10
   182 label *label89
 
   187 sensor *tmp38 *tmp37 @totalItems
   188 writearr<inlined:regular> *tmp38 .state2[] 3
   189 readarr<internal:regular> *tmp40 .state2[] 3
-    * readarr<internal:regular> *tmp42 .state1[] 3
+  190 readarr<inlined:regular> *tmp42 .state1[] 3
   191 jump *label93 greaterThanEq *tmp40 *tmp42
   192 op add .total .total 10
   193 label *label93

Modifications by Inline shared table of array 'state2' (+2 instructions):
 
   175 readarr<inlined:regular> *tmp37 .conv[] 2
   176 sensor *tmp38 *tmp37 @totalItems
   177 writearr<inlined:regular> *tmp38 .state2[] 2
-    * readarr<internal:regular> *tmp40 .state2[] 2
+  178 readarr<inlined:regular> *tmp40 .state2[] 2
   179 readarr<inlined:regular> *tmp42 .state1[] 2
   180 jump *label89 greaterThanEq *tmp40 *tmp42
   181 op add .total .total 10
 
   186 readarr<inlined:regular> *tmp37 .conv[] 3
   187 sensor *tmp38 *tmp37 @totalItems
   188 writearr<inlined:regular> *tmp38 .state2[] 3
-    * readarr<internal:regular> *tmp40 .state2[] 3
+  189 readarr<inlined:regular> *tmp40 .state2[] 3
   190 readarr<inlined:regular> *tmp42 .state1[] 3
   191 jump *label93 greaterThanEq *tmp40 *tmp42
   192 op add .total .total 10

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    72 sensor *tmp13 .memory @type
    73 jump *label26 notEqual *tmp13 @memory-cell
    74 set *tmp15 63
-    * jump *label26 always
    75 label *label26
    76 set .totalIndex *tmp15
    77 read .total .memory *tmp15

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-256 instructions):
 
    88 set :start @time
    89 label *label62
    90 label *label63
-    * readarr<inlined:regular> *tmp22 .conv[] 0
+   91 set *tmp22 .conv*0
    92 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] 0
-    * readarr<inlined:regular> *tmp25 .state1[] 0
-    * readarr<inlined:regular> *tmp27 .state2[] 0
+   93 set .state1*0 *tmp23
+   94 set *tmp25 .state1*0
+   95 set *tmp27 .state2*0
    96 jump *label64 greaterThanEq *tmp25 *tmp27
    97 op add .total .total 10
    98 label *label64
    99 label *label65
   100 label *label66
   101 label *label67
-    * readarr<inlined:regular> *tmp22 .conv[] 1
+  102 set *tmp22 .conv*1
   103 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] 1
-    * readarr<inlined:regular> *tmp25 .state1[] 1
-    * readarr<inlined:regular> *tmp27 .state2[] 1
+  104 set .state1*1 *tmp23
+  105 set *tmp25 .state1*1
+  106 set *tmp27 .state2*1
   107 jump *label68 greaterThanEq *tmp25 *tmp27
   108 op add .total .total 10
   109 label *label68
   110 label *label69
   111 label *label70
   112 label *label71
-    * readarr<inlined:regular> *tmp22 .conv[] 2
+  113 set *tmp22 .conv*2
   114 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] 2
-    * readarr<inlined:regular> *tmp25 .state1[] 2
-    * readarr<inlined:regular> *tmp27 .state2[] 2
+  115 set .state1*2 *tmp23
+  116 set *tmp25 .state1*2
+  117 set *tmp27 .state2*2
   118 jump *label72 greaterThanEq *tmp25 *tmp27
   119 op add .total .total 10
   120 label *label72
   121 label *label73
   122 label *label74
   123 label *label75
-    * readarr<inlined:regular> *tmp22 .conv[] 3
+  124 set *tmp22 .conv*3
   125 sensor *tmp23 *tmp22 @totalItems
-    * writearr<inlined:regular> *tmp23 .state1[] 3
-    * readarr<inlined:regular> *tmp25 .state1[] 3
-    * readarr<inlined:regular> *tmp27 .state2[] 3
+  126 set .state1*3 *tmp23
+  127 set *tmp25 .state1*3
+  128 set *tmp27 .state2*3
   129 jump *label76 greaterThanEq *tmp25 *tmp27
   130 op add .total .total 10
   131 label *label76
 
   149 print "\n"
   150 label *label79
   151 label *label80
-    * readarr<inlined:regular> *tmp37 .conv[] 0
+  152 set *tmp37 .conv*0
   153 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] 0
-    * readarr<inlined:regular> *tmp40 .state2[] 0
-    * readarr<inlined:regular> *tmp42 .state1[] 0
+  154 set .state2*0 *tmp38
+  155 set *tmp40 .state2*0
+  156 set *tmp42 .state1*0
   157 jump *label81 greaterThanEq *tmp40 *tmp42
   158 op add .total .total 10
   159 label *label81
   160 label *label82
   161 label *label83
   162 label *label84
-    * readarr<inlined:regular> *tmp37 .conv[] 1
+  163 set *tmp37 .conv*1
   164 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] 1
-    * readarr<inlined:regular> *tmp40 .state2[] 1
-    * readarr<inlined:regular> *tmp42 .state1[] 1
+  165 set .state2*1 *tmp38
+  166 set *tmp40 .state2*1
+  167 set *tmp42 .state1*1
   168 jump *label85 greaterThanEq *tmp40 *tmp42
   169 op add .total .total 10
   170 label *label85
   171 label *label86
   172 label *label87
   173 label *label88
-    * readarr<inlined:regular> *tmp37 .conv[] 2
+  174 set *tmp37 .conv*2
   175 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] 2
-    * readarr<inlined:regular> *tmp40 .state2[] 2
-    * readarr<inlined:regular> *tmp42 .state1[] 2
+  176 set .state2*2 *tmp38
+  177 set *tmp40 .state2*2
+  178 set *tmp42 .state1*2
   179 jump *label89 greaterThanEq *tmp40 *tmp42
   180 op add .total .total 10
   181 label *label89
   182 label *label90
   183 label *label91
   184 label *label92
-    * readarr<inlined:regular> *tmp37 .conv[] 3
+  185 set *tmp37 .conv*3
   186 sensor *tmp38 *tmp37 @totalItems
-    * writearr<inlined:regular> *tmp38 .state2[] 3
-    * readarr<inlined:regular> *tmp40 .state2[] 3
-    * readarr<inlined:regular> *tmp42 .state1[] 3
+  187 set .state2*3 *tmp38
+  188 set *tmp40 .state2*3
+  189 set *tmp42 .state1*3
   190 jump *label93 greaterThanEq *tmp40 *tmp42
   191 op add .total .total 10
   192 label *label93

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    89 label *label62
    90 label *label63
    91 set *tmp22 .conv*0
-    * sensor *tmp23 *tmp22 @totalItems
+   92 sensor *tmp23 .conv*0 @totalItems
    93 set .state1*0 *tmp23
-    * set *tmp25 .state1*0
+   94 set *tmp25 *tmp23
    95 set *tmp27 .state2*0
-    * jump *label64 greaterThanEq *tmp25 *tmp27
+   96 jump *label64 greaterThanEq .state1*0 .state2*0
    97 op add .total .total 10
    98 label *label64
    99 label *label65
   100 label *label66
   101 label *label67
   102 set *tmp22 .conv*1
-    * sensor *tmp23 *tmp22 @totalItems
+  103 sensor *tmp23 .conv*1 @totalItems
   104 set .state1*1 *tmp23
-    * set *tmp25 .state1*1
+  105 set *tmp25 *tmp23
   106 set *tmp27 .state2*1
-    * jump *label68 greaterThanEq *tmp25 *tmp27
+  107 jump *label68 greaterThanEq .state1*1 .state2*1
   108 op add .total .total 10
   109 label *label68
   110 label *label69
   111 label *label70
   112 label *label71
   113 set *tmp22 .conv*2
-    * sensor *tmp23 *tmp22 @totalItems
+  114 sensor *tmp23 .conv*2 @totalItems
   115 set .state1*2 *tmp23
-    * set *tmp25 .state1*2
+  116 set *tmp25 *tmp23
   117 set *tmp27 .state2*2
-    * jump *label72 greaterThanEq *tmp25 *tmp27
+  118 jump *label72 greaterThanEq .state1*2 .state2*2
   119 op add .total .total 10
   120 label *label72
   121 label *label73
   122 label *label74
   123 label *label75
   124 set *tmp22 .conv*3
-    * sensor *tmp23 *tmp22 @totalItems
+  125 sensor *tmp23 .conv*3 @totalItems
   126 set .state1*3 *tmp23
-    * set *tmp25 .state1*3
+  127 set *tmp25 *tmp23
   128 set *tmp27 .state2*3
-    * jump *label76 greaterThanEq *tmp25 *tmp27
+  129 jump *label76 greaterThanEq .state1*3 .state2*3
   130 op add .total .total 10
   131 label *label76
   132 label *label77
 
   150 label *label79
   151 label *label80
   152 set *tmp37 .conv*0
-    * sensor *tmp38 *tmp37 @totalItems
+  153 sensor *tmp38 .conv*0 @totalItems
   154 set .state2*0 *tmp38
-    * set *tmp40 .state2*0
+  155 set *tmp40 *tmp38
   156 set *tmp42 .state1*0
-    * jump *label81 greaterThanEq *tmp40 *tmp42
+  157 jump *label81 greaterThanEq .state2*0 .state1*0
   158 op add .total .total 10
   159 label *label81
   160 label *label82
   161 label *label83
   162 label *label84
   163 set *tmp37 .conv*1
-    * sensor *tmp38 *tmp37 @totalItems
+  164 sensor *tmp38 .conv*1 @totalItems
   165 set .state2*1 *tmp38
-    * set *tmp40 .state2*1
+  166 set *tmp40 *tmp38
   167 set *tmp42 .state1*1
-    * jump *label85 greaterThanEq *tmp40 *tmp42
+  168 jump *label85 greaterThanEq .state2*1 .state1*1
   169 op add .total .total 10
   170 label *label85
   171 label *label86
   172 label *label87
   173 label *label88
   174 set *tmp37 .conv*2
-    * sensor *tmp38 *tmp37 @totalItems
+  175 sensor *tmp38 .conv*2 @totalItems
   176 set .state2*2 *tmp38
-    * set *tmp40 .state2*2
+  177 set *tmp40 *tmp38
   178 set *tmp42 .state1*2
-    * jump *label89 greaterThanEq *tmp40 *tmp42
+  179 jump *label89 greaterThanEq .state2*2 .state1*2
   180 op add .total .total 10
   181 label *label89
   182 label *label90
   183 label *label91
   184 label *label92
   185 set *tmp37 .conv*3
-    * sensor *tmp38 *tmp37 @totalItems
+  186 sensor *tmp38 .conv*3 @totalItems
   187 set .state2*3 *tmp38
-    * set *tmp40 .state2*3
-    * set *tmp42 .state1*3
-    * jump *label93 greaterThanEq *tmp40 *tmp42
+  188 set *tmp40 *tmp38
+  189 set *tmp42 *tmp23
+  190 jump *label93 greaterThanEq .state2*3 .state1*3
   191 op add .total .total 10
   192 label *label93
   193 label *label94

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-24 instructions):
 
    88 set :start @time
    89 label *label62
    90 label *label63
-    * set *tmp22 .conv*0
    91 sensor *tmp23 .conv*0 @totalItems
    92 set .state1*0 *tmp23
-    * set *tmp25 *tmp23
-    * set *tmp27 .state2*0
-    * jump *label64 greaterThanEq .state1*0 .state2*0
+   93 jump *label64 greaterThanEq *tmp23 .state2*0
    94 op add .total .total 10
    95 label *label64
    96 label *label65
    97 label *label66
    98 label *label67
-    * set *tmp22 .conv*1
    99 sensor *tmp23 .conv*1 @totalItems
   100 set .state1*1 *tmp23
-    * set *tmp25 *tmp23
-    * set *tmp27 .state2*1
-    * jump *label68 greaterThanEq .state1*1 .state2*1
+  101 jump *label68 greaterThanEq *tmp23 .state2*1
   102 op add .total .total 10
   103 label *label68
   104 label *label69
   105 label *label70
   106 label *label71
-    * set *tmp22 .conv*2
   107 sensor *tmp23 .conv*2 @totalItems
   108 set .state1*2 *tmp23
-    * set *tmp25 *tmp23
-    * set *tmp27 .state2*2
-    * jump *label72 greaterThanEq .state1*2 .state2*2
+  109 jump *label72 greaterThanEq *tmp23 .state2*2
   110 op add .total .total 10
   111 label *label72
   112 label *label73
   113 label *label74
   114 label *label75
-    * set *tmp22 .conv*3
   115 sensor *tmp23 .conv*3 @totalItems
   116 set .state1*3 *tmp23
-    * set *tmp25 *tmp23
-    * set *tmp27 .state2*3
-    * jump *label76 greaterThanEq .state1*3 .state2*3
+  117 jump *label76 greaterThanEq *tmp23 .state2*3
   118 op add .total .total 10
   119 label *label76
   120 label *label77
 
   137 print "\n"
   138 label *label79
   139 label *label80
-    * set *tmp37 .conv*0
   140 sensor *tmp38 .conv*0 @totalItems
   141 set .state2*0 *tmp38
-    * set *tmp40 *tmp38
-    * set *tmp42 .state1*0
-    * jump *label81 greaterThanEq .state2*0 .state1*0
+  142 jump *label81 greaterThanEq *tmp38 .state1*0
   143 op add .total .total 10
   144 label *label81
   145 label *label82
   146 label *label83
   147 label *label84
-    * set *tmp37 .conv*1
   148 sensor *tmp38 .conv*1 @totalItems
   149 set .state2*1 *tmp38
-    * set *tmp40 *tmp38
-    * set *tmp42 .state1*1
-    * jump *label85 greaterThanEq .state2*1 .state1*1
+  150 jump *label85 greaterThanEq *tmp38 .state1*1
   151 op add .total .total 10
   152 label *label85
   153 label *label86
   154 label *label87
   155 label *label88
-    * set *tmp37 .conv*2
   156 sensor *tmp38 .conv*2 @totalItems
   157 set .state2*2 *tmp38
-    * set *tmp40 *tmp38
-    * set *tmp42 .state1*2
-    * jump *label89 greaterThanEq .state2*2 .state1*2
+  158 jump *label89 greaterThanEq *tmp38 .state1*2
   159 op add .total .total 10
   160 label *label89
   161 label *label90
   162 label *label91
   163 label *label92
-    * set *tmp37 .conv*3
   164 sensor *tmp38 .conv*3 @totalItems
   165 set .state2*3 *tmp38
-    * set *tmp40 *tmp38
-    * set *tmp42 *tmp23
-    * jump *label93 greaterThanEq .state2*3 .state1*3
+  166 jump *label93 greaterThanEq *tmp38 *tmp23
   167 op add .total .total 10
   168 label *label93
   169 label *label94

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-1 instructions):
 
   113 label *label74
   114 label *label75
   115 sensor *tmp23 .conv*3 @totalItems
-    * set .state1*3 *tmp23
   116 jump *label76 greaterThanEq *tmp23 .state2*3
   117 op add .total .total 10
   118 label *label76

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
     0 label *label1
-    * label *label45
-    * label *label46
     1 set .conv*0 null
-    * label *label49
-    * label *label50
     2 set .conv*1 null
-    * label *label53
-    * label *label54
     3 set .conv*2 null
-    * label *label57
-    * label *label58
     4 set .conv*3 null
-    * label *label6
     5 set .memory null
     6 set .found 0
     7 set .links @links
     8 op sub :initialize:n .links 1
-    * label *label11
     9 jump *label13 lessThan :initialize:n 0
    10 label *label42
    11 getlink :initialize:block :initialize:n
 
    17 jump *label14 always
    18 label *label15
    19 jump *label17 notEqual *tmp4 @plastanium-conveyor
-    * label *label18
    20 set .conv*3 .conv*2
    21 set .conv*2 .conv*1
    22 set .conv*1 .conv*0
 
    24 op add .found .found 1
    25 label *label17
    26 label *label14
-    * label *label12
    27 op sub :initialize:n :initialize:n 1
    28 jump *label42 greaterThanEq :initialize:n 0
    29 label *label13
 
    67 label *label24
    68 label *label22
    69 label *label20
-    * label *label2
    70 jump *label1 always
    71 label *label3
-    * label *label0
    72 control enabled switch1 false
    73 label *label27
    74 set :start @time
-    * label *label62
-    * label *label63
    75 sensor *tmp23 .conv*0 @totalItems
    76 set .state1*0 *tmp23
    77 jump *label64 greaterThanEq *tmp23 .state2*0
    78 op add .total .total 10
    79 label *label64
-    * label *label65
-    * label *label66
-    * label *label67
    80 sensor *tmp23 .conv*1 @totalItems
    81 set .state1*1 *tmp23
    82 jump *label68 greaterThanEq *tmp23 .state2*1
    83 op add .total .total 10
    84 label *label68
-    * label *label69
-    * label *label70
-    * label *label71
    85 sensor *tmp23 .conv*2 @totalItems
    86 set .state1*2 *tmp23
    87 jump *label72 greaterThanEq *tmp23 .state2*2
    88 op add .total .total 10
    89 label *label72
-    * label *label73
-    * label *label74
-    * label *label75
    90 sensor *tmp23 .conv*3 @totalItems
    91 jump *label76 greaterThanEq *tmp23 .state2*3
    92 op add .total .total 10
    93 label *label76
-    * label *label77
-    * label *label78
-    * label *label32
    94 write .total .memory .totalIndex
    95 print "[gold]Item Counter Micro[], version [gold]1.0[]"
    96 print " "
 
   106 print "["
   107 print "]"
   108 print "\n"
-    * label *label79
-    * label *label80
   109 sensor *tmp38 .conv*0 @totalItems
   110 set .state2*0 *tmp38
   111 jump *label81 greaterThanEq *tmp38 .state1*0
   112 op add .total .total 10
   113 label *label81
-    * label *label82
-    * label *label83
-    * label *label84
   114 sensor *tmp38 .conv*1 @totalItems
   115 set .state2*1 *tmp38
   116 jump *label85 greaterThanEq *tmp38 .state1*1
   117 op add .total .total 10
   118 label *label85
-    * label *label86
-    * label *label87
-    * label *label88
   119 sensor *tmp38 .conv*2 @totalItems
   120 set .state2*2 *tmp38
   121 jump *label89 greaterThanEq *tmp38 .state1*2
   122 op add .total .total 10
   123 label *label89
-    * label *label90
-    * label *label91
-    * label *label92
   124 sensor *tmp38 .conv*3 @totalItems
   125 set .state2*3 *tmp38
   126 jump *label93 greaterThanEq *tmp38 *tmp23
   127 op add .total .total 10
   128 label *label93
-    * label *label94
-    * label *label95
-    * label *label37
   129 op sub *tmp46 @time :start
   130 op idiv *tmp48 *tmp46 2
   131 print "[lightgray]Loop time: "
 
   137 jump *label40 equal .links @links
   138 end
   139 label *label40
-    * label *label41
-    * label *label28
   140 sensor *tmp51 switch1 @enabled
   141 jump *label27 equal *tmp51 false
-    * label *label29
   142 set .total 0
   143 write 0 .memory .totalIndex
   144 end

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    37 print .found
    38 print ")"
    39 printflush message1
-    * jump *label20 always
+   40 jump *label1 always
    41 label *label19
    42 jump *label21 lessThanEq .found 4
    43 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
    49 print .found
    50 print ")"
    51 printflush message1
-    * jump *label22 always
+   52 jump *label1 always
    53 label *label21
    54 jump *label23 notEqual .memory null
    55 print "$TITLE\n[salmon]No memory attached."
    56 printflush message1
-    * jump *label24 always
+   57 jump *label1 always
    58 label *label23
    59 set *tmp15 511
    60 sensor *tmp13 .memory @type

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-1 instructions):
 
    64 set .totalIndex *tmp15
    65 read .total .memory *tmp15
    66 jump *label3 always
-    * label *label24
-    * label *label22
-    * label *label20
-    * jump *label1 always
    67 label *label3
    68 control enabled switch1 false
    69 label *label27

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-2 instructions):
 
    63 label *label26
    64 set .totalIndex *tmp15
    65 read .total .memory *tmp15
-    * jump *label3 always
    66 label *label3
    67 control enabled switch1 false
    68 label *label27
 
   136 jump *label27 equal *tmp51 false
   137 set .total 0
   138 write 0 .memory .totalIndex
-    * end

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
    63 label *label26
    64 set .totalIndex *tmp15
    65 read .total .memory *tmp15
-    * label *label3
    66 control enabled switch1 false
    67 label *label27
    68 set :start @time

Modifications by Final phase, Print Merging, iteration 1 (-21 instructions):
 
    28 jump *label42 greaterThanEq :initialize:n 0
    29 label *label13
    30 jump *label19 notEqual .found 0
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print "\"
-    * print "n[salmon]No plastanium conveyor attached (maximum: "
-    * print 4
-    * print ","
-    * print " found: "
+   31 print "[gold]Item Counter Micro[], version [gold]1.0[]\n[salmon]No plastanium conveyor attached (maximum: 4, found: "
    32 print .found
    33 print ")"
    34 printflush message1
    35 jump *label1 always
    36 label *label19
    37 jump *label21 lessThanEq .found 4
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print "\"
-    * print "n[salmon]Too many plastanium conveyors attached (maximum: "
-    * print 4
-    * print ","
-    * print " found: "
+   38 print "[gold]Item Counter Micro[], version [gold]1.0[]\n[salmon]Too many plastanium conveyors attached (maximum: 4, found: "
    39 print .found
    40 print ")"
    41 printflush message1
 
    76 op add .total .total 10
    77 label *label76
    78 write .total .memory .totalIndex
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print " "
-    * print "           "
-    * print "\n"
-    * print "Monitoring [green]"
+   79 print "[gold]Item Counter Micro[], version [gold]1.0[]            \nMonitoring [green]"
    80 print .found
-    * print "["
-    * print "] conveyors"
-    * print "\n"
-    * print "Total items: [gold]"
+   81 print "[] conveyors\nTotal items: [gold]"
    82 print .total
-    * print "["
-    * print "]"
-    * print "\n"
+   83 print "[]\n"
    84 sensor *tmp38 .conv*0 @totalItems
    85 set .state2*0 *tmp38
    86 jump *label81 greaterThanEq *tmp38 .state1*0
 
   105 op idiv *tmp48 *tmp46 2
   106 print "[lightgray]Loop time: "
   107 print *tmp48
-    * print " "
-    * print "ms"
-    * print "\n"
+  108 print " ms\n"
   109 printflush message1
   110 jump *label40 equal .links @links
   111 end

Final code before resolving virtual instructions:

        label *label1                                                while true do
    0:  set .conv*0 null                                             for var out c in conv do c = null; end;
    1:  set .conv*1 null                                             ...
    2:  set .conv*2 null                                             ...
    3:  set .conv*3 null                                             ...
    4:  set .memory null                                             memory = null;
    5:  set .found 0                                                 found = 0;
    6:  set .links @links                                            links = @links;
    7:  op sub :initialize:n .links 1                                for var n in 0 ... links descending do
    8:  jump *label13 lessThan :initialize:n 0                       ...
        label *label42                                               ...
    9:  getlink :initialize:block :initialize:n                      var block = getlink(n);
   10:  sensor *tmp4 :initialize:block @type                         case block.@type
   11:  jump *label16 equal *tmp4 @memory-cell                       ...
   12:  jump *label15 notEqual *tmp4 @memory-bank                    ...
        label *label16                                               ...
   13:  set .memory :initialize:block                                memory = block;
   14:  jump *label14 always 0 0                                     case block.@type
        label *label15                                               ...
   15:  jump *label17 notEqual *tmp4 @plastanium-conveyor            ...
   16:  set .conv*3 .conv*2                                          conv[1 ... MAX_LINKED] = conv[0 ... MAX_LINKED - 1];
   17:  set .conv*2 .conv*1                                          ...
   18:  set .conv*1 .conv*0                                          ...
   19:  set .conv*0 :initialize:block                                conv[0] = block;
   20:  op add .found .found 1                                       case block.@type
        label *label17                                               ...
        label *label14                                               ...
   21:  op sub :initialize:n :initialize:n 1                         for var n in 0 ... links descending do
   22:  jump *label42 greaterThanEq :initialize:n 0                  ...
        label *label13                                               ...
   23:  jump *label19 notEqual .found 0                              if found == 0 then
   24:  print "[gold]Item Counter Micro[], version [gold]1.0[]\n[sal print($"$TITLE\n[salmon]No plastanium conveyor attached (maximum: $MAX_LINKED, found: $found)");
   25:  print .found                                                 ...
   26:  print ")"                                                    ...
   27:  printflush message1                                          printflush(message1);
   28:  jump *label1 always 0 0                                      if found == 0 then
        label *label19                                               ...
   29:  jump *label21 lessThanEq .found 4                            elsif found > MAX_LINKED then
   30:  print "[gold]Item Counter Micro[], version [gold]1.0[]\n[sal print($"$TITLE\n[salmon]Too many plastanium conveyors attached (maximum: $MAX_LINKED, found: $found)");
   31:  print .found                                                 ...
   32:  print ")"                                                    ...
   33:  printflush message1                                          printflush(message1);
   34:  jump *label1 always 0 0                                      elsif found > MAX_LINKED then
        label *label21                                               ...
   35:  jump *label23 notEqual .memory null                          elsif memory == null then
   36:  print "$TITLE\n[salmon]No memory attached."                  print("$TITLE\n[salmon]No memory attached.");
   37:  printflush message1                                          printflush(message1);
   38:  jump *label1 always 0 0                                      elsif memory == null then
        label *label23                                               ...
   39:  set *tmp15 511                                               totalIndex = memory.@type == @memory-cell ? 63 : 511;
   40:  sensor *tmp13 .memory @type                                  ...
   41:  jump *label26 notEqual *tmp13 @memory-cell                   ...
   42:  set *tmp15 63                                                ...
        label *label26                                               ...
   43:  set .totalIndex *tmp15                                       ...
   44:  read .total .memory *tmp15                                   total = memory[totalIndex];
   45:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
        label *label27                                               do
   46:  set :start @time                                             var start = @time;
   47:  sensor *tmp23 .conv*0 @totalItems                            state1[i] = conv[i].@totalItems;
   48:  set .state1*0 *tmp23                                         ...
   49:  jump *label64 greaterThanEq *tmp23 .state2*0                 if state1[i] < state2[i] then
   50:  op add .total .total 10                                      total += 10;
        label *label64                                               if state1[i] < state2[i] then
   51:  sensor *tmp23 .conv*1 @totalItems                            state1[i] = conv[i].@totalItems;
   52:  set .state1*1 *tmp23                                         ...
   53:  jump *label68 greaterThanEq *tmp23 .state2*1                 if state1[i] < state2[i] then
   54:  op add .total .total 10                                      total += 10;
        label *label68                                               if state1[i] < state2[i] then
   55:  sensor *tmp23 .conv*2 @totalItems                            state1[i] = conv[i].@totalItems;
   56:  set .state1*2 *tmp23                                         ...
   57:  jump *label72 greaterThanEq *tmp23 .state2*2                 if state1[i] < state2[i] then
   58:  op add .total .total 10                                      total += 10;
        label *label72                                               if state1[i] < state2[i] then
   59:  sensor *tmp23 .conv*3 @totalItems                            state1[i] = conv[i].@totalItems;
   60:  jump *label76 greaterThanEq *tmp23 .state2*3                 if state1[i] < state2[i] then
   61:  op add .total .total 10                                      total += 10;
        label *label76                                               if state1[i] < state2[i] then
   62:  write .total .memory .totalIndex                             memory[totalIndex] = total;
   63:  print "[gold]Item Counter Micro[], version [gold]1.0[]       println($"Monitoring [green]$found[] conveyors");
   64:  print .found                                                 ...
   65:  print "[] conveyors\nTotal items: [gold]"                    println($"Total items: [gold]$total[]");
   66:  print .total                                                 ...
   67:  print "[]\n"                                                 ...
   68:  sensor *tmp38 .conv*0 @totalItems                            state2[i] = conv[i].@totalItems;
   69:  set .state2*0 *tmp38                                         ...
   70:  jump *label81 greaterThanEq *tmp38 .state1*0                 if state2[i] < state1[i] then
   71:  op add .total .total 10                                      total += 10;
        label *label81                                               if state2[i] < state1[i] then
   72:  sensor *tmp38 .conv*1 @totalItems                            state2[i] = conv[i].@totalItems;
   73:  set .state2*1 *tmp38                                         ...
   74:  jump *label85 greaterThanEq *tmp38 .state1*1                 if state2[i] < state1[i] then
   75:  op add .total .total 10                                      total += 10;
        label *label85                                               if state2[i] < state1[i] then
   76:  sensor *tmp38 .conv*2 @totalItems                            state2[i] = conv[i].@totalItems;
   77:  set .state2*2 *tmp38                                         ...
   78:  jump *label89 greaterThanEq *tmp38 .state1*2                 if state2[i] < state1[i] then
   79:  op add .total .total 10                                      total += 10;
        label *label89                                               if state2[i] < state1[i] then
   80:  sensor *tmp38 .conv*3 @totalItems                            state2[i] = conv[i].@totalItems;
   81:  set .state2*3 *tmp38                                         ...
   82:  jump *label93 greaterThanEq *tmp38 *tmp23                    if state2[i] < state1[i] then
   83:  op add .total .total 10                                      total += 10;
        label *label93                                               if state2[i] < state1[i] then
   84:  op sub *tmp46 @time :start                                   println($"[lightgray]Loop time: $ ms", floor((@time - start) / 2));
   85:  op idiv *tmp48 *tmp46 2                                      ...
   86:  print "[lightgray]Loop time: "                               ...
   87:  print *tmp48                                                 ...
   88:  print " ms\n"                                                ...
   89:  printflush message1                                          printflush(message1);
   90:  jump *label40 equal .links @links                            if links != @links then
   91:  end                                                          end();
        label *label40                                               if links != @links then
   92:  sensor *tmp51 switch1 @enabled                               while !switch1.@enabled;
   93:  jump *label27 equal *tmp51 false                             do
   94:  set .total 0                                                 total = 0;
   95:  write 0 .memory .totalIndex                                  memory[totalIndex] = 0;


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    51     1x     51,0  <no function>
    45     1x     45,0  void initialize()

Performance: parsed in 212 ms, compiled in 234 ms, optimized in 413 ms, run in 89 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
[gold]Item Counter Micro[], version [gold]1.0[]
[salmon]No plastanium conveyor attached (maximum: 4, found: 0)
[--- Previous segment repeated 361,00 times ---]

Execution step limit of 100000 exceeded.
