   232 instructions before optimizations.
    17 instructions eliminated by Temp Variables Elimination.
     2 instructions eliminated by Case Expression Optimization.
    19 instructions eliminated by Dead Code Elimination (4 iterations).
    11 instructions eliminated by Jump Optimization (4 iterations).
     8 instructions eliminated by Single Step Elimination (3 passes, 7 iterations).
     1 instructions eliminated by Expression Optimization (3 iterations).
     1 instructions eliminated by If Expression Optimization (3 iterations).
    12 instructions eliminated by Data Flow Optimization (2 passes, 9 iterations).
     2 instructions modified by Loop Optimization (3 iterations).
     2 loops improved by Loop Optimization.
    10 instructions eliminated by Loop Unrolling (4 iterations).
     1 loops unrolled by Loop Unrolling.
     5 instructions eliminated by Jump Straightening (4 iterations).
     1 instructions eliminated by Unreachable Code Elimination.
    21 instructions eliminated by Print Merging.
   124 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 832):
  * Unroll iteration loop at line 119:9                          cost     0, benefit      875.0, efficiency   Infinity (-20 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
    15 print "\nFound: "
    16 print :initialize.0:block
    17 sensor *tmp2 :initialize.0:block @type
-    * set *tmp3 *tmp2
-    * jump *label9 equal *tmp3 @message
+   18 jump *label9 equal *tmp2 @message
    19 jump *label8 always
    20 label *label9
    21 set .message :initialize.0:block
    22 set *tmp1 .message
    23 jump *label7 always
    24 label *label8
-    * jump *label11 equal *tmp3 @switch
+   25 jump *label11 equal *tmp2 @switch
    26 jump *label10 always
    27 label *label11
    28 set .switch :initialize.0:block
    29 set *tmp1 .switch
    30 jump *label7 always
    31 label *label10
-    * jump *label13 equal *tmp3 @memory-bank
-    * jump *label13 equal *tmp3 @memory-cell
+   32 jump *label13 equal *tmp2 @memory-bank
+   33 jump *label13 equal *tmp2 @memory-cell
    34 jump *label12 always
    35 label *label13
    36 set .dstMem .srcMem
 
    74 set *tmp8 null
    75 label *label17
    76 sensor *tmp10 .dstMem @type
-    * set *tmp11 *tmp10
-    * jump *label20 equal *tmp11 @memory-cell
+   77 jump *label20 equal *tmp10 @memory-cell
    78 jump *label19 always
    79 label *label20
    80 set *tmp9 64
    81 jump *label18 always
    82 label *label19
-    * jump *label22 equal *tmp11 @memory-bank
+   83 jump *label22 equal *tmp10 @memory-bank
    84 jump *label21 always
    85 label *label22
    86 set *tmp9 512

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-17 instructions):
 
    19 jump *label8 always
    20 label *label9
    21 set .message :initialize.0:block
-    * set *tmp1 .message
    22 jump *label7 always
    23 label *label8
    24 jump *label11 equal *tmp2 @switch
    25 jump *label10 always
    26 label *label11
    27 set .switch :initialize.0:block
-    * set *tmp1 .switch
    28 jump *label7 always
    29 label *label10
    30 jump *label13 equal *tmp2 @memory-bank
 
    33 label *label13
    34 set .dstMem .srcMem
    35 set .srcMem :initialize.0:block
-    * set *tmp1 .srcMem
    36 jump *label7 always
    37 label *label12
-    * set *tmp1 null
    38 label *label7
    39 label *label5
    40 op sub :initialize.0:n :initialize.0:n 1
 
    51 op equal *tmp4 .srcMem null
    52 jump *label14 equal *tmp4 false
    53 print "\nNo memory."
-    * set *tmp5 "\nNo memory."
    54 jump *label15 always
    55 label *label14
-    * set *tmp5 null
    56 label *label15
    57 printflush .message
    58 label *label2
 
    62 op equal *tmp7 .dstMem null
    63 jump *label16 equal *tmp7 false
    64 set .dstMem .srcMem
-    * set *tmp8 .dstMem
    65 jump *label17 always
    66 label *label16
-    * set *tmp8 null
    67 label *label17
    68 sensor *tmp10 .dstMem @type
    69 jump *label20 equal *tmp10 @memory-cell
 
    85 jump *label23 equal *tmp12 false
    86 op sub .memSize .memSize 1
    87 set .startIndex 1
-    * set *tmp13 .startIndex
    88 jump *label24 always
    89 label *label23
    90 set .startIndex 0
-    * set *tmp13 .startIndex
    91 label *label24
    92 label *label0
    93 set :prevTick @tick
 
   116 set :curr *tmp25
   117 print "[red]ERR[]"
   118 print "\n"
-    * set *tmp22 "[red]ERR[]"
   119 jump *label29 always
   120 label *label28
-    * set *tmp22 null
   121 label *label29
   122 set :prevTick :currTick
   123 set :prev :curr
 
   127 op lessThan *tmp27 @tick :prevTick
   128 jump *label33 equal *tmp27 false
   129 end
-    * set *tmp28 null
   130 jump *label34 always
   131 label *label33
   132 read *tmp29 .srcMem 0
 
   141 label *label35
   142 set *tmp31 null
   143 label *label36
-    * set *tmp28 *tmp31
   144 label *label34
   145 label *label31
   146 jump *label30 always
 
   212 label *label41
   213 op div *tmp40 :total 10
   214 set :average *tmp40
-    * set *tmp41 :index
   215 op add :index :index 1
   216 op greaterThanEq *tmp42 :index .memSize
   217 jump *label51 equal *tmp42 false
   218 op add *tmp44 .startIndex 1
   219 set :index *tmp44
-    * set *tmp43 :index
   220 jump *label52 always
   221 label *label51
-    * set *tmp43 null
   222 label *label52
   223 set *tmp45 .startIndex
   224 write :index .dstMem *tmp45

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
   136 set *tmp32 @tick
   137 set :currTick *tmp32
   138 set :curr :value
-    * set *tmp31 :curr
   139 jump *label36 always
   140 label *label35
-    * set *tmp31 null
   141 label *label36
   142 label *label34
   143 label *label31

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-17 instructions):
 
    10 op sub :initialize.0:n @links 1
    11 label *label4
    12 jump *label6 lessThan :initialize.0:n 0
-    * getlink *tmp0 :initialize.0:n
-    * set :initialize.0:block *tmp0
+   13 getlink :initialize.0:block :initialize.0:n
    14 print "\nFound: "
    15 print :initialize.0:block
    16 sensor *tmp2 :initialize.0:block @type
 
    90 label *label24
    91 label *label0
    92 set :prevTick @tick
-    * read *tmp14 .srcMem 0
-    * set :prev *tmp14
+   93 read :prev .srcMem 0
    94 set :currTick :prevTick
    95 set :curr :prev
-    * set *tmp15 .startIndex
-    * read *tmp16 .dstMem *tmp15
-    * op max *tmp17 .startIndex *tmp16
-    * set :index *tmp17
+   96 read *tmp16 .dstMem .startIndex
+   97 op max :index .startIndex *tmp16
    98 set :nextTick :prevTick
-    * set *tmp18 .switch
-    * control enabled *tmp18 false
+   99 control enabled .switch false
   100 label *label25
   101 set :start @time
   102 op add :nextTick :nextTick TICKS
   103 op add *tmp20 :nextTick TICKS
   104 op greaterThan *tmp21 @tick *tmp20
   105 jump *label28 equal *tmp21 false
-    * set *tmp23 @tick
-    * set :currTick *tmp23
-    * op add *tmp24 :prevTick TICKS
-    * set :currTick *tmp24
-    * read *tmp25 .srcMem 0
-    * set :curr *tmp25
+  106 set :currTick @tick
+  107 op add :currTick :prevTick TICKS
+  108 read :curr .srcMem 0
   109 print "[red]ERR[]"
   110 print "\n"
   111 jump *label29 always
 
   121 end
   122 jump *label34 always
   123 label *label33
-    * read *tmp29 .srcMem 0
-    * set :value *tmp29
+  124 read :value .srcMem 0
   125 op notEqual *tmp30 :value :curr
   126 jump *label35 equal *tmp30 false
-    * set *tmp32 @tick
-    * set :currTick *tmp32
+  127 set :currTick @tick
   128 set :curr :value
   129 jump *label36 always
   130 label *label35
 
   133 label *label31
   134 jump *label30 always
   135 label *label32
-    * op sub *tmp33 :curr :prev
-    * set :amount *tmp33
-    * op sub *tmp34 :currTick :prevTick
-    * set :time *tmp34
+  136 op sub :amount :curr :prev
+  137 op sub :time :currTick :prevTick
   138 op equal *tmp35 :amount 0
   139 jump *label37 equal *tmp35 false
   140 set *tmp36 0
   141 jump *label38 always
   142 label *label37
   143 op div *tmp37 :amount :time
-    * op max *tmp38 *tmp37 0
-    * set *tmp36 *tmp38
+  144 op max *tmp36 *tmp37 0
   145 label *label38
   146 set :rate *tmp36
   147 set .samples*9 .samples*8
 
   195 multijump *tmp39 0 0 marker0
   196 multilabel *label50 marker0
   197 label *label41
-    * op div *tmp40 :total 10
-    * set :average *tmp40
+  198 op div :average :total 10
   199 op add :index :index 1
   200 op greaterThanEq *tmp42 :index .memSize
   201 jump *label51 equal *tmp42 false
-    * op add *tmp44 .startIndex 1
-    * set :index *tmp44
+  202 op add :index .startIndex 1
   203 jump *label52 always
   204 label *label51
   205 label *label52
-    * set *tmp45 .startIndex
-    * write :index .dstMem *tmp45
-    * set *tmp47 :index
-    * write :average .dstMem *tmp47
+  206 write :index .dstMem .startIndex
+  207 write :average .dstMem :index
   208 print "[gold]Item Rate Meter[], version [gold]1.0[]"
   209 print " "
   210 print "           "

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-5 instructions):
 
    14 print "\nFound: "
    15 print :initialize.0:block
    16 sensor *tmp2 :initialize.0:block @type
-    * jump *label9 equal *tmp2 @message
-    * jump *label8 always
+   17 jump *label8 notEqual *tmp2 @message
    18 label *label9
    19 set .message :initialize.0:block
    20 jump *label7 always
    21 label *label8
-    * jump *label11 equal *tmp2 @switch
-    * jump *label10 always
+   22 jump *label10 notEqual *tmp2 @switch
    23 label *label11
    24 set .switch :initialize.0:block
    25 jump *label7 always
    26 label *label10
    27 jump *label13 equal *tmp2 @memory-bank
-    * jump *label13 equal *tmp2 @memory-cell
-    * jump *label12 always
+   28 jump *label12 notEqual *tmp2 @memory-cell
    29 label *label13
    30 set .dstMem .srcMem
    31 set .srcMem :initialize.0:block
 
    62 label *label16
    63 label *label17
    64 sensor *tmp10 .dstMem @type
-    * jump *label20 equal *tmp10 @memory-cell
-    * jump *label19 always
+   65 jump *label19 notEqual *tmp10 @memory-cell
    66 label *label20
    67 set *tmp9 64
    68 jump *label18 always
    69 label *label19
-    * jump *label22 equal *tmp10 @memory-bank
-    * jump *label21 always
+   70 jump *label21 notEqual *tmp10 @memory-bank
    71 label *label22
    72 set *tmp9 512
    73 jump *label18 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-11 instructions):
 
    44 print .srcMem
    45 print "\nTarget memory: "
    46 print .dstMem
-    * op equal *tmp4 .srcMem null
-    * jump *label14 equal *tmp4 false
+   47 jump *label14 notEqual .srcMem null
    48 print "\nNo memory."
    49 jump *label15 always
    50 label *label14
    51 label *label15
    52 printflush .message
    53 label *label2
-    * op equal *tmp6 .srcMem null
-    * jump *label1 notEqual *tmp6 false
+   54 jump *label1 equal .srcMem null
    55 label *label3
-    * op equal *tmp7 .dstMem null
-    * jump *label16 equal *tmp7 false
+   56 jump *label16 notEqual .dstMem null
    57 set .dstMem .srcMem
    58 jump *label17 always
    59 label *label16
 
    72 set *tmp9 0
    73 label *label18
    74 set .memSize *tmp9
-    * op equal *tmp12 .srcMem .dstMem
-    * jump *label23 equal *tmp12 false
+   75 jump *label23 notEqual .srcMem .dstMem
    76 op sub .memSize .memSize 1
    77 set .startIndex 1
    78 jump *label24 always
 
    92 set :start @time
    93 op add :nextTick :nextTick TICKS
    94 op add *tmp20 :nextTick TICKS
-    * op greaterThan *tmp21 @tick *tmp20
-    * jump *label28 equal *tmp21 false
+   95 jump *label28 lessThanEq @tick *tmp20
    96 set :currTick @tick
    97 op add :currTick :prevTick TICKS
    98 read :curr .srcMem 0
 
   104 set :prevTick :currTick
   105 set :prev :curr
   106 label *label30
-    * op lessThan *tmp26 @tick :nextTick
-    * jump *label32 equal *tmp26 false
-    * op lessThan *tmp27 @tick :prevTick
-    * jump *label33 equal *tmp27 false
+  107 jump *label32 greaterThanEq @tick :nextTick
+  108 jump *label33 greaterThanEq @tick :prevTick
   109 end
   110 jump *label34 always
   111 label *label33
   112 read :value .srcMem 0
-    * op notEqual *tmp30 :value :curr
-    * jump *label35 equal *tmp30 false
+  113 jump *label35 equal :value :curr
   114 set :currTick @tick
   115 set :curr :value
   116 jump *label36 always
 
   122 label *label32
   123 op sub :amount :curr :prev
   124 op sub :time :currTick :prevTick
-    * op equal *tmp35 :amount 0
-    * jump *label37 equal *tmp35 false
+  125 jump *label37 notEqual :amount 0
   126 set *tmp36 0
   127 jump *label38 always
   128 label *label37
 
   183 label *label41
   184 op div :average :total 10
   185 op add :index :index 1
-    * op greaterThanEq *tmp42 :index .memSize
-    * jump *label51 equal *tmp42 false
+  186 jump *label51 lessThan :index .memSize
   187 op add :index .startIndex 1
   188 jump *label52 always
   189 label *label51
 
   225 printflush .message
   226 label *label26
   227 sensor *tmp53 .switch @enabled
-    * op equal *tmp54 *tmp53 false
-    * jump *label25 notEqual *tmp54 false
+  228 jump *label25 equal *tmp53 false
   229 label *label27
   230 end

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-6 instructions):
 
    29 label *label13
    30 set .dstMem .srcMem
    31 set .srcMem :initialize.0:block
-    * jump *label7 always
    32 label *label12
    33 label *label7
    34 label *label5
 
    45 print .dstMem
    46 jump *label14 notEqual .srcMem null
    47 print "\nNo memory."
-    * jump *label15 always
    48 label *label14
    49 label *label15
    50 printflush .message
 
    53 label *label3
    54 jump *label16 notEqual .dstMem null
    55 set .dstMem .srcMem
-    * jump *label17 always
    56 label *label16
    57 label *label17
    58 sensor *tmp10 .dstMem @type
 
    95 read :curr .srcMem 0
    96 print "[red]ERR[]"
    97 print "\n"
-    * jump *label29 always
    98 label *label28
    99 label *label29
   100 set :prevTick :currTick
 
   109 jump *label35 equal :value :curr
   110 set :currTick @tick
   111 set :curr :value
-    * jump *label36 always
   112 label *label35
   113 label *label36
   114 label *label34
 
   180 op add :index :index 1
   181 jump *label51 lessThan :index .memSize
   182 op add :index .startIndex 1
-    * jump *label52 always
   183 label *label51
   184 label *label52
   185 write :index .dstMem .startIndex

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   193 print "["
   194 print "]"
   195 print "\n"
-    * op mul *tmp49 :average 3600
-    * op floor *tmp50 *tmp49
+  196 op idiv *tmp50 :average 0.0002777777777777778
   197 print "Current rate [green]"
   198 print *tmp50
   199 print "[]/min"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    70 label *label18
    71 set .memSize *tmp9
    72 jump *label23 notEqual .srcMem .dstMem
-    * op sub .memSize .memSize 1
+   73 op sub .memSize *tmp9 1
    74 set .startIndex 1
    75 jump *label24 always
    76 label *label23
 
    90 op add :nextTick :nextTick TICKS
    91 op add *tmp20 :nextTick TICKS
    92 jump *label28 lessThanEq @tick *tmp20
-    * set :currTick @tick
    93 op add :currTick :prevTick TICKS
    94 read :curr .srcMem 0
    95 print "[red]ERR[]"
 
   133 set .samples*3 .samples*2
   134 set .samples*2 .samples*1
   135 set .samples*1 .samples*0
-    * set .samples*0 :rate
-    * set :total .samples*0
+  136 set .samples*0 *tmp36
+  137 set :total :rate
   138 setaddr *tmp39 *label42
   139 set :i .samples*1
   140 jump *label39 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2:
 
   134 set .samples*2 .samples*1
   135 set .samples*1 .samples*0
   136 set .samples*0 *tmp36
-    * set :total :rate
+  137 set :total *tmp36
   138 setaddr *tmp39 *label42
   139 set :i .samples*1
   140 jump *label39 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
   123 op div *tmp37 :amount :time
   124 op max *tmp36 *tmp37 0
   125 label *label38
-    * set :rate *tmp36
   126 set .samples*9 .samples*8
   127 set .samples*8 .samples*7
   128 set .samples*7 .samples*6

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    10 op sub :initialize.0:n @links 1
    11 label *label4
    12 jump *label6 lessThan :initialize.0:n 0
+   13 label *label53
    14 getlink :initialize.0:block :initialize.0:n
    15 print "\nFound: "
    16 print :initialize.0:block
 
    34 label *label7
    35 label *label5
    36 op sub :initialize.0:n :initialize.0:n 1
-    * jump *label4 always
+   37 jump *label53 greaterThanEq :initialize.0:n 0
    38 label *label6
    39 print "\nMessage: "
    40 print .message
 
   101 set :prev :curr
   102 label *label30
   103 jump *label32 greaterThanEq @tick :nextTick
+  104 label *label54
   105 jump *label33 greaterThanEq @tick :prevTick
   106 end
   107 jump *label34 always
 
   114 label *label36
   115 label *label34
   116 label *label31
-    * jump *label30 always
+  117 jump *label54 lessThan @tick :nextTick
   118 label *label32
   119 op sub :amount :curr :prev
   120 op sub :time :currTick :prevTick

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    70 set *tmp9 0
    71 label *label18
    72 set .memSize *tmp9
-    * jump *label23 notEqual .srcMem .dstMem
+   73 set .startIndex 0
+   74 jump *label24 notEqual .srcMem .dstMem
    75 op sub .memSize *tmp9 1
    76 set .startIndex 1
    77 jump *label24 always
-    * label *label23
-    * set .startIndex 0
    78 label *label24
    79 label *label0
    80 set :prevTick @tick
 
   117 label *label32
   118 op sub :amount :curr :prev
   119 op sub :time :currTick :prevTick
-    * jump *label37 notEqual :amount 0
   120 set *tmp36 0
-    * jump *label38 always
+  121 jump *label38 equal :amount 0
   122 label *label37
   123 op div *tmp37 :amount :time
   124 op max *tmp36 *tmp37 0

Modifications by Unroll iteration loop at line 119:9 (-10 instructions):
 
   134 set .samples*1 .samples*0
   135 set .samples*0 *tmp36
   136 set :total *tmp36
-    * setaddr *tmp39 *label42
-    * set :i .samples*1
-    * jump *label39 always
-    * multilabel *label42 marker0
-    * setaddr *tmp39 *label43
-    * set :i .samples*2
-    * jump *label39 always
-    * multilabel *label43 marker0
-    * setaddr *tmp39 *label44
-    * set :i .samples*3
-    * jump *label39 always
-    * multilabel *label44 marker0
-    * setaddr *tmp39 *label45
-    * set :i .samples*4
-    * jump *label39 always
-    * multilabel *label45 marker0
-    * setaddr *tmp39 *label46
-    * set :i .samples*5
-    * jump *label39 always
-    * multilabel *label46 marker0
-    * setaddr *tmp39 *label47
-    * set :i .samples*6
-    * jump *label39 always
-    * multilabel *label47 marker0
-    * setaddr *tmp39 *label48
-    * set :i .samples*7
-    * jump *label39 always
-    * multilabel *label48 marker0
-    * setaddr *tmp39 *label49
-    * set :i .samples*8
-    * jump *label39 always
-    * multilabel *label49 marker0
-    * setaddr *tmp39 *label50
-    * set :i .samples*9
-    * label *label39
-    * op add :total :total :i
-    * label *label40
-    * multijump *tmp39 0 0 marker0
-    * multilabel *label50 marker0
-    * label *label41
+  137 set :i .samples*1
+  138 label *label55
+  139 op add :total :total :i
+  140 label *label56
+  141 set :i .samples*2
+  142 label *label59
+  143 op add :total :total :i
+  144 label *label60
+  145 set :i .samples*3
+  146 label *label63
+  147 op add :total :total :i
+  148 label *label64
+  149 set :i .samples*4
+  150 label *label67
+  151 op add :total :total :i
+  152 label *label68
+  153 set :i .samples*5
+  154 label *label71
+  155 op add :total :total :i
+  156 label *label72
+  157 set :i .samples*6
+  158 label *label75
+  159 op add :total :total :i
+  160 label *label76
+  161 set :i .samples*7
+  162 label *label79
+  163 op add :total :total :i
+  164 label *label80
+  165 set :i .samples*8
+  166 label *label83
+  167 op add :total :total :i
+  168 label *label84
+  169 set :i .samples*9
+  170 label *label87
+  171 op add :total :total :i
+  172 label *label88
+  173 label *label41
   174 op div :average :total 10
   175 op add :index :index 1
   176 jump *label51 lessThan :index .memSize

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   136 set :total *tmp36
   137 set :i .samples*1
   138 label *label55
-    * op add :total :total :i
+  139 op add :total *tmp36 .samples*1
   140 label *label56
   141 set :i .samples*2
   142 label *label59
-    * op add :total :total :i
+  143 op add :total :total .samples*2
   144 label *label60
   145 set :i .samples*3
   146 label *label63
-    * op add :total :total :i
+  147 op add :total :total .samples*3
   148 label *label64
   149 set :i .samples*4
   150 label *label67
-    * op add :total :total :i
+  151 op add :total :total .samples*4
   152 label *label68
   153 set :i .samples*5
   154 label *label71
-    * op add :total :total :i
+  155 op add :total :total .samples*5
   156 label *label72
   157 set :i .samples*6
   158 label *label75
-    * op add :total :total :i
+  159 op add :total :total .samples*6
   160 label *label76
   161 set :i .samples*7
   162 label *label79
-    * op add :total :total :i
+  163 op add :total :total .samples*7
   164 label *label80
   165 set :i .samples*8
   166 label *label83
-    * op add :total :total :i
+  167 op add :total :total .samples*8
   168 label *label84
   169 set :i .samples*9
   170 label *label87
-    * op add :total :total :i
+  171 op add :total :total .samples*9
   172 label *label88
   173 label *label41
   174 op div :average :total 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-10 instructions):
 
   133 set .samples*2 .samples*1
   134 set .samples*1 .samples*0
   135 set .samples*0 *tmp36
-    * set :total *tmp36
-    * set :i .samples*1
   136 label *label55
   137 op add :total *tmp36 .samples*1
   138 label *label56
-    * set :i .samples*2
   139 label *label59
   140 op add :total :total .samples*2
   141 label *label60
-    * set :i .samples*3
   142 label *label63
   143 op add :total :total .samples*3
   144 label *label64
-    * set :i .samples*4
   145 label *label67
   146 op add :total :total .samples*4
   147 label *label68
-    * set :i .samples*5
   148 label *label71
   149 op add :total :total .samples*5
   150 label *label72
-    * set :i .samples*6
   151 label *label75
   152 op add :total :total .samples*6
   153 label *label76
-    * set :i .samples*7
   154 label *label79
   155 op add :total :total .samples*7
   156 label *label80
-    * set :i .samples*8
   157 label *label83
   158 op add :total :total .samples*8
   159 label *label84
-    * set :i .samples*9
   160 label *label87
   161 op add :total :total .samples*9
   162 label *label88

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    74 jump *label24 notEqual .srcMem .dstMem
    75 op sub .memSize *tmp9 1
    76 set .startIndex 1
-    * jump *label24 always
    77 label *label24
    78 label *label0
    79 set :prevTick @tick

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
   102 label *label54
   103 jump *label33 greaterThanEq @tick :prevTick
   104 end
-    * jump *label34 always
   105 label *label33
   106 read :value .srcMem 0
   107 jump *label35 equal :value :curr

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   203 sensor *tmp53 .switch @enabled
   204 jump *label25 equal *tmp53 false
   205 label *label27
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-21 instructions):
 
     3 set .message null
     4 set .srcMem null
     5 set .dstMem null
-    * print "[gold]Item Rate Meter[], version [gold]1.0[]"
-    * print " "
-    * print "           "
-    * print "\n"
+    6 print "[gold]Item Rate Meter[], version [gold]1.0[]            \n"
     7 op sub :initialize.0:n @links 1
     8 label *label4
     9 jump *label6 lessThan :initialize.0:n 0
 
    88 jump *label28 lessThanEq @tick *tmp20
    89 op add :currTick :prevTick TICKS
    90 read :curr .srcMem 0
-    * print "[red]ERR[]"
-    * print "\n"
+   91 print "[red]ERR[]\n"
    92 label *label28
    93 label *label29
    94 set :prevTick :currTick
 
   163 label *label52
   164 write :index .dstMem .startIndex
   165 write :average .dstMem :index
-    * print "[gold]Item Rate Meter[], version [gold]1.0[]"
-    * print " "
-    * print "           "
-    * print "\n"
-    * print "Total items: [gold]"
+  166 print "[gold]Item Rate Meter[], version [gold]1.0[]            \nTotal items: [gold]"
   167 print :curr
-    * print "["
-    * print "]"
-    * print "\n"
   168 op idiv *tmp50 :average 0.0002777777777777778
-    * print "Current rate [green]"
+  169 print "[]\nCurrent rate [green]"
   170 print *tmp50
-    * print "[]/min"
-    * print "\n"
-    * print "  memory start: [gold]"
+  171 print "[]/min\n  memory start: [gold]"
   172 print .startIndex
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "\n"
-    * print "  memory index: [gold]"
+  173 print "[]\n\n  memory index: [gold]"
   174 print :index
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "\n"
   175 op sub *tmp51 @time :start
   176 op floor *tmp52 *tmp51
-    * print "[lightgray]Loop time: "
+  177 print "[]\n\n[lightgray]Loop time: "
   178 print *tmp52
   179 print " ms"
   180 printflush .message

Final code before resolving virtual instructions:

    0:  set TICKS 60                                                 param TICKS = 60;
        label *label1                                                do
    1:  set .switch null                                             switch = null;
    2:  set .message null                                            message = null;
    3:  set .srcMem null                                             srcMem = null;
    4:  set .dstMem null                                             dstMem = null;
    5:  print "[gold]Item Rate Meter[], version [gold]1.0[]          println($"$TITLE            ");
    6:  op sub :initialize.0:n @links 1                              for var n in 0 ... @links descending do
    7:  jump *label6 lessThan :initialize.0:n 0                      ...
        label *label53                                               ...
    8:  getlink :initialize.0:block :initialize.0:n                  var block = getlink(n);
    9:  print "\nFound: "                                            print("\nFound: ", block);
   10:  print :initialize.0:block                                    ...
   11:  sensor *tmp2 :initialize.0:block @type                       case block.@type
   12:  jump *label8 notEqual *tmp2 @message                         ...
   13:  set .message :initialize.0:block                             message = block;
   14:  jump *label7 always 0 0                                      case block.@type
        label *label8                                                ...
   15:  jump *label10 notEqual *tmp2 @switch                         ...
   16:  set .switch :initialize.0:block                              switch = block;
   17:  jump *label7 always 0 0                                      case block.@type
        label *label10                                               ...
   18:  jump *label13 equal *tmp2 @memory-bank                       ...
   19:  jump *label12 notEqual *tmp2 @memory-cell                    ...
        label *label13                                               ...
   20:  set .dstMem .srcMem                                          dstMem = srcMem;
   21:  set .srcMem :initialize.0:block                              srcMem = block;
        label *label12                                               case block.@type
        label *label7                                                ...
   22:  op sub :initialize.0:n :initialize.0:n 1                     for var n in 0 ... @links descending do
   23:  jump *label53 greaterThanEq :initialize.0:n 0                ...
        label *label6                                                ...
   24:  print "\nMessage: "                                          print("\nMessage: ", message);
   25:  print .message                                               ...
   26:  print "\nSwitch: "                                           print("\nSwitch: ", switch);
   27:  print .switch                                                ...
   28:  print "\nSource memory: "                                    print("\nSource memory: ", srcMem);
   29:  print .srcMem                                                ...
   30:  print "\nTarget memory: "                                    print("\nTarget memory: ", dstMem);
   31:  print .dstMem                                                ...
   32:  jump *label14 notEqual .srcMem null                          if srcMem == null then
   33:  print "\nNo memory."                                         print("\nNo memory.");
        label *label14                                               if srcMem == null then
   34:  printflush .message                                          printflush(message);
   35:  jump *label1 equal .srcMem null                              do
   36:  jump *label16 notEqual .dstMem null                          if dstMem == null then
   37:  set .dstMem .srcMem                                          dstMem = srcMem;
        label *label16                                               if dstMem == null then
   38:  sensor *tmp10 .dstMem @type                                  memSize = case dstMem.@type
   39:  jump *label19 notEqual *tmp10 @memory-cell                   ...
   40:  set *tmp9 64                                                 ...
   41:  jump *label18 always 0 0                                     ...
        label *label19                                               ...
   42:  jump *label21 notEqual *tmp10 @memory-bank                   ...
   43:  set *tmp9 512                                                ...
   44:  jump *label18 always 0 0                                     ...
        label *label21                                               ...
   45:  set *tmp9 0                                                  ...
        label *label18                                               ...
   46:  set .memSize *tmp9                                           ...
   47:  set .startIndex 0                                            startIndex = 0;
   48:  jump *label24 notEqual .srcMem .dstMem                       if srcMem == dstMem then
   49:  op sub .memSize *tmp9 1                                      memSize -= 1;
   50:  set .startIndex 1                                            startIndex = 1;
        label *label24                                               if srcMem == dstMem then
   51:  set :prevTick @tick                                          var prevTick = @tick;
   52:  read :prev .srcMem 0                                         var prev = srcMem[0];
   53:  set :currTick :prevTick                                      var currTick = prevTick;
   54:  set :curr :prev                                              var curr = prev;
   55:  read *tmp16 .dstMem .startIndex                              var index = max(startIndex, dstMem[startIndex]);
   56:  op max :index .startIndex *tmp16                             ...
   57:  set :nextTick :prevTick                                      var nextTick = prevTick;
   58:  control enabled .switch false 0 0 0                          switch.enabled = false;
        label *label25                                               do
   59:  set :start @time                                             var start = @time;
   60:  op add :nextTick :nextTick TICKS                             nextTick += TICKS;
   61:  op add *tmp20 :nextTick TICKS                                if @tick > nextTick + TICKS then
   62:  jump *label28 lessThanEq @tick *tmp20                        ...
   63:  op add :currTick :prevTick TICKS                             currTick = prevTick + TICKS;
   64:  read :curr .srcMem 0                                         curr = srcMem[0];
   65:  print "[red]ERR[]\n"                                         println("[red]ERR[]");
        label *label28                                               if @tick > nextTick + TICKS then
   66:  set :prevTick :currTick                                      prevTick = currTick;
   67:  set :prev :curr                                              prev = curr;
   68:  jump *label32 greaterThanEq @tick :nextTick                  while @tick < nextTick do
        label *label54                                               ...
   69:  jump *label33 greaterThanEq @tick :prevTick                  if @tick < prevTick then
   70:  end                                                          end();
        label *label33                                               if @tick < prevTick then
   71:  read :value .srcMem 0                                        var value = srcMem[0];
   72:  jump *label35 equal :value :curr                             if value != curr then
   73:  set :currTick @tick                                          currTick = @tick;
   74:  set :curr :value                                             curr = value;
        label *label35                                               if value != curr then
   75:  jump *label54 lessThan @tick :nextTick                       while @tick < nextTick do
        label *label32                                               ...
   76:  op sub :amount :curr :prev                                   var amount = curr - prev;
   77:  op sub :time :currTick :prevTick                             var time = currTick - prevTick;
   78:  set *tmp36 0                                                 var rate = amount == 0 ? 0 : max(amount / time, 0);  // Items per tick
   79:  jump *label38 equal :amount 0                                ...
   80:  op div *tmp37 :amount :time                                  ...
   81:  op max *tmp36 *tmp37 0                                       ...
        label *label38                                               ...
   82:  set .samples*9 .samples*8                                    samples[1 ... SAMPLES] = samples[0 ... SAMPLES - 1];
   83:  set .samples*8 .samples*7                                    ...
   84:  set .samples*7 .samples*6                                    ...
   85:  set .samples*6 .samples*5                                    ...
   86:  set .samples*5 .samples*4                                    ...
   87:  set .samples*4 .samples*3                                    ...
   88:  set .samples*3 .samples*2                                    ...
   89:  set .samples*2 .samples*1                                    ...
   90:  set .samples*1 .samples*0                                    ...
   91:  set .samples*0 *tmp36                                        samples[0] = rate;
   92:  op add :total *tmp36 .samples*1                              for var i in samples[1 ... SAMPLES] do total += i; end;
   93:  op add :total :total .samples*2                              ...
   94:  op add :total :total .samples*3                              ...
   95:  op add :total :total .samples*4                              ...
   96:  op add :total :total .samples*5                              ...
   97:  op add :total :total .samples*6                              ...
   98:  op add :total :total .samples*7                              ...
   99:  op add :total :total .samples*8                              ...
  100:  op add :total :total .samples*9                              ...
  101:  op div :average :total 10                                    var average = total / SAMPLES;
  102:  op add :index :index 1                                       do
  103:  jump *label51 lessThan :index .memSize                       if index >= memSize then
  104:  op add :index .startIndex 1                                  index = startIndex + 1;
        label *label51                                               if index >= memSize then
  105:  write :index .dstMem .startIndex                             dstMem[startIndex] = index;
  106:  write :average .dstMem :index                                dstMem[index] = average;
  107:  print "[gold]Item Rate Meter[], version [gold]1.0[]          println($"Total items: [gold]$curr[]");
  108:  print :curr                                                  ...
  109:  op idiv *tmp50 :average 0.0002777777777777778                println($"Current rate [green]${floor(average * 3600)}[]/min");
  110:  print "[]\nCurrent rate [green]"                             ...
  111:  print *tmp50                                                 ...
  112:  print "[]/min\n  memory start: [gold]"                       println($"  memory start: [gold]$startIndex[]\n");
  113:  print .startIndex                                            ...
  114:  print "[]\n\n  memory index: [gold]"                         println($"  memory index: [gold]$index[]\n");
  115:  print :index                                                 ...
  116:  op sub *tmp51 @time :start                                   print($"[lightgray]Loop time: ${floor(@time - start)} ms");
  117:  op floor *tmp52 *tmp51 0                                     ...
  118:  print "[]\n\n[lightgray]Loop time: "                         ...
  119:  print *tmp52                                                 ...
  120:  print " ms"                                                  ...
  121:  printflush .message                                          printflush(message);
  122:  sensor *tmp53 .switch @enabled                               while !switch.@enabled;
  123:  jump *label25 equal *tmp53 false                             do


Performance: parsed in 191 ms, compiled in 243 ms, optimized in 239 ms, run in 53 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (100,000 steps):
[gold]Item Rate Meter[], version [gold]1.0[]            

Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Source memory: cell
Target memory: cell
Execution step limit of 100 000 exceeded.
