   306 instructions before optimizations.
    53 instructions eliminated by Temp Variables Elimination.
     2 instructions eliminated by Case Expression Optimization.
    24 instructions eliminated by Dead Code Elimination (4 iterations).
    11 instructions eliminated by Jump Optimization (4 iterations).
    10 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     3 instructions eliminated by Expression Optimization (3 iterations).
    10 instructions eliminated by Data Flow Optimization (3 passes, 9 iterations).
     3 instructions modified by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
    10 instructions added by Function Inlining (4 iterations).
     3 function calls inlined by Function Inlining.
     6 instructions eliminated by Jump Straightening (2 passes, 4 iterations).
     1 instructions updated by JumpThreading.
    24 instructions eliminated by Print Merging.
   173 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 804):
  * Inline function 'memorySize' defined at item-rate-meter-init.mnd:84:1 cost    15, benefit        5.3, efficiency        0.4 (+4 instructions)
    Inline function call at item-rate-meter-init.mnd:53:23       cost     8, benefit        1.8, efficiency        0.2
    Inline function call at item-rate-meter-init.mnd:65:27       cost     8, benefit        1.8, efficiency        0.2
    Inline function call at item-rate-meter-init.mnd:66:29       cost     8, benefit        1.8, efficiency        0.2

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
    18 print :init.0:block
    19 print "\n"
    20 sensor *tmp2 :init.0:block @type
-    * set *tmp3 *tmp2
-    * jump *label10 equal *tmp3 @message
+   21 jump *label10 equal *tmp2 @message
    22 jump *label9 always
    23 label *label10
    24 set .message :init.0:block
    25 set *tmp1 .message
    26 jump *label8 always
    27 label *label9
-    * jump *label12 equal *tmp3 @switch
+   28 jump *label12 equal *tmp2 @switch
    29 jump *label11 always
    30 label *label12
    31 set .switch :init.0:block
    32 set *tmp1 .switch
    33 jump *label8 always
    34 label *label11
-    * jump *label14 equal *tmp3 @memory-bank
-    * jump *label14 equal *tmp3 @memory-cell
+   35 jump *label14 equal *tmp2 @memory-bank
+   36 jump *label14 equal *tmp2 @memory-cell
    37 jump *label13 always
    38 label *label14
    39 set .primaryMem .secondaryMem
 
   334 end
   335 label *label0
   336 sensor *tmp107 :memorySize.0:block @type
-    * set *tmp108 *tmp107
-    * jump *label48 equal *tmp108 @memory-cell
+  337 jump *label48 equal *tmp107 @memory-cell
   338 jump *label47 always
   339 label *label48
   340 set *tmp106 64
   341 jump *label46 always
   342 label *label47
-    * jump *label50 equal *tmp108 @memory-bank
+  343 jump *label50 equal *tmp107 @memory-bank
   344 jump *label49 always
   345 label *label50
   346 set *tmp106 512

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-23 instructions):
 
    22 jump *label9 always
    23 label *label10
    24 set .message :init.0:block
-    * set *tmp1 .message
    25 jump *label8 always
    26 label *label9
    27 jump *label12 equal *tmp2 @switch
    28 jump *label11 always
    29 label *label12
    30 set .switch :init.0:block
-    * set *tmp1 .switch
    31 jump *label8 always
    32 label *label11
    33 jump *label14 equal *tmp2 @memory-bank
 
    36 label *label14
    37 set .primaryMem .secondaryMem
    38 set .secondaryMem :init.0:block
-    * set *tmp1 .secondaryMem
    39 jump *label8 always
    40 label *label13
-    * set *tmp1 null
    41 label *label8
    42 label *label6
    43 op sub :init.0:n :init.0:n 1
 
    59 jump *label15 equal *tmp4 false
    60 print "No memory."
    61 print "\n"
-    * set *tmp5 "No memory."
    62 jump *label16 always
    63 label *label15
-    * set *tmp5 null
    64 label *label16
    65 printflush .message
    66 label *label3
 
    94 set .valueIndex *tmp16
    95 op sub *tmp17 :init.0:memSize 1
    96 set .totalIndex *tmp17
-    * set *tmp8 .totalIndex
    97 jump *label18 always
    98 label *label17
    99 set :memorySize.0:block .primaryMem
 
   127 set .minIndex *tmp27
   128 op sub *tmp28 :init.0:secondarySize 3
   129 set .maxIndex *tmp28
-    * set *tmp8 .maxIndex
   130 label *label18
   131 set *tmp29 .bufferStartIndex
   132 write .bufferStart .secondaryMem *tmp29
 
   172 set *tmp48 .totalIndex
   173 read *tmp49 .primaryMem *tmp48
   174 set :prev *tmp49
-    * set *tmp46 :prev
   175 jump *label29 always
   176 label *label28
-    * set *tmp46 null
   177 label *label29
   178 set :waits 0
   179 label *label30
 
   182 op lessThan *tmp51 @tick :prevTick
   183 jump *label33 equal *tmp51 false
   184 jump *label27 always
-    * set *tmp52 null
   185 jump *label34 always
   186 label *label33
-    * set *tmp52 null
   187 label *label34
-    * set *tmp53 :waits
   188 op add :waits :waits 1
   189 wait 0.000000000000001
   190 label *label31
 
   212 jump *label35 equal *tmp66 false
   213 set *tmp68 :samples
   214 op add :samples :samples 1
-    * set *tmp67 *tmp68
   215 jump *label36 always
   216 label *label35
-    * set *tmp67 null
   217 label *label36
   218 op add :iteration :iteration MEASUREMENT
   219 op greaterThanEq *tmp69 :iteration UPDATE
 
   225 op greaterThanEq *tmp73 :head .bufferEnd
   226 jump *label39 equal *tmp73 false
   227 set :head .bufferStart
-    * set *tmp74 :head
   228 jump *label40 always
   229 label *label39
-    * set *tmp74 null
   230 label *label40
   231 jump *label41 equal :first false
   232 set *tmp76 .minIndex
 
   234 set *tmp78 .maxIndex
   235 write :rate .secondaryMem *tmp78
   236 set :first false
-    * set *tmp75 :first
   237 jump *label42 always
   238 label *label41
-    * set *tmp75 null
   239 label *label42
   240 set *tmp80 .valueIndex
   241 write :rate .primaryMem *tmp80
 
   263 jump *label43 equal *tmp96 false
   264 print "[salmon]Initializing...[]"
   265 print "\n"
-    * set *tmp97 null
   266 jump *label44 always
   267 label *label43
-    * set *tmp97 null
   268 label *label44
   269 print "Total items: [gold]"
   270 print :curr
 
   300 set :minWaits 10000000000
   301 printflush .message
   302 op sub :iteration :iteration UPDATE
-    * set *tmp70 :iteration
   303 jump *label38 always
   304 label *label37
-    * set *tmp70 null
   305 label *label38
   306 label *label26
   307 sensor *tmp104 .switch @enabled

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-1 instructions):
 
   210 set :cacheHead *tmp65
   211 op lessThan *tmp66 :samples .cacheSize
   212 jump *label35 equal *tmp66 false
-    * set *tmp68 :samples
   213 op add :samples :samples 1
   214 jump *label36 always
   215 label *label35

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-53 instructions):
 
    12 op sub :init.0:n @links 1
    13 label *label5
    14 jump *label7 lessThan :init.0:n 0
-    * getlink *tmp0 :init.0:n
-    * set :init.0:block *tmp0
+   15 getlink :init.0:block :init.0:n
    16 print "Found: "
    17 print :init.0:block
    18 print "\n"
 
    73 setaddr :memorySize.0*retaddr *label19
    74 call *label0 :memorySize.0*retval
    75 label *label19
-    * set *tmp9 :memorySize.0*retval
-    * set :init.0:memSize *tmp9
+   76 set :init.0:memSize :memorySize.0*retval
    77 set .cacheSize 50
    78 set .bufferStart .cacheSize
-    * op sub *tmp10 :init.0:memSize 7
-    * set .bufferEnd *tmp10
-    * op sub *tmp11 :init.0:memSize 7
-    * set .bufferStartIndex *tmp11
-    * op sub *tmp12 :init.0:memSize 6
-    * set .bufferEndIndex *tmp12
-    * op sub *tmp13 :init.0:memSize 5
-    * set .headIndex *tmp13
-    * op sub *tmp14 :init.0:memSize 4
-    * set .minIndex *tmp14
-    * op sub *tmp15 :init.0:memSize 3
-    * set .maxIndex *tmp15
-    * op sub *tmp16 :init.0:memSize 2
-    * set .valueIndex *tmp16
-    * op sub *tmp17 :init.0:memSize 1
-    * set .totalIndex *tmp17
+   79 op sub .bufferEnd :init.0:memSize 7
+   80 op sub .bufferStartIndex :init.0:memSize 7
+   81 op sub .bufferEndIndex :init.0:memSize 6
+   82 op sub .headIndex :init.0:memSize 5
+   83 op sub .minIndex :init.0:memSize 4
+   84 op sub .maxIndex :init.0:memSize 3
+   85 op sub .valueIndex :init.0:memSize 2
+   86 op sub .totalIndex :init.0:memSize 1
    87 jump *label18 always
    88 label *label17
    89 set :memorySize.0:block .primaryMem
    90 setaddr :memorySize.0*retaddr *label20
    91 call *label0 :memorySize.0*retval
    92 label *label20
-    * set *tmp18 :memorySize.0*retval
-    * set :init.0:primarySize *tmp18
+   93 set :init.0:primarySize :memorySize.0*retval
    94 set :memorySize.0:block .secondaryMem
    95 setaddr :memorySize.0*retaddr *label21
    96 call *label0 :memorySize.0*retval
    97 label *label21
-    * set *tmp19 :memorySize.0*retval
-    * set :init.0:secondarySize *tmp19
-    * op sub *tmp20 :init.0:primarySize 2
-    * set .cacheSize *tmp20
-    * op sub *tmp21 :init.0:primarySize 2
-    * set .valueIndex *tmp21
-    * op sub *tmp22 :init.0:primarySize 1
-    * set .totalIndex *tmp22
+   98 set :init.0:secondarySize :memorySize.0*retval
+   99 op sub .cacheSize :init.0:primarySize 2
+  100 op sub .valueIndex :init.0:primarySize 2
+  101 op sub .totalIndex :init.0:primarySize 1
   102 set .bufferStart 0
-    * op sub *tmp23 :init.0:secondarySize 8
-    * set .bufferEnd *tmp23
-    * op sub *tmp24 :init.0:secondarySize 7
-    * set .bufferStartIndex *tmp24
-    * op sub *tmp25 :init.0:secondarySize 6
-    * set .bufferEndIndex *tmp25
-    * op sub *tmp26 :init.0:secondarySize 5
-    * set .headIndex *tmp26
-    * op sub *tmp27 :init.0:secondarySize 4
-    * set .minIndex *tmp27
-    * op sub *tmp28 :init.0:secondarySize 3
-    * set .maxIndex *tmp28
+  103 op sub .bufferEnd :init.0:secondarySize 8
+  104 op sub .bufferStartIndex :init.0:secondarySize 7
+  105 op sub .bufferEndIndex :init.0:secondarySize 6
+  106 op sub .headIndex :init.0:secondarySize 5
+  107 op sub .minIndex :init.0:secondarySize 4
+  108 op sub .maxIndex :init.0:secondarySize 3
   109 label *label18
-    * set *tmp29 .bufferStartIndex
-    * write .bufferStart .secondaryMem *tmp29
-    * set *tmp31 .bufferEndIndex
-    * write .bufferEnd .secondaryMem *tmp31
+  110 write .bufferStart .secondaryMem .bufferStartIndex
+  111 write .bufferEnd .secondaryMem .bufferEndIndex
   112 label *label1
-    * op min *tmp33 SMOOTHING .cacheSize
-    * set .cacheSize *tmp33
+  113 op min .cacheSize SMOOTHING .cacheSize
   114 set *tmp34 .cacheSize
   115 set :i 0
   116 label *label22
   117 jump *label24 greaterThanEq :i *tmp34
-    * set *tmp35 :i
-    * write 0 .primaryMem *tmp35
+  118 write 0 .primaryMem :i
   119 label *label23
   120 op add :i :i 1
   121 jump *label22 always
   122 label *label24
   123 set :cacheHead 0
   124 set :samples 0
-    * set *tmp37 .headIndex
-    * read *tmp38 .secondaryMem *tmp37
-    * op max *tmp39 .bufferStart *tmp38
-    * set :head *tmp39
+  125 read *tmp38 .secondaryMem .headIndex
+  126 op max :head .bufferStart *tmp38
   127 set :total 0
   128 set :iteration 0
-    * set *tmp40 .switch
-    * control enabled *tmp40 false
+  129 control enabled .switch false
   130 set :nextTick @tick
-    * set *tmp42 .totalIndex
-    * read *tmp43 .primaryMem *tmp42
-    * set :prev *tmp43
+  131 read :prev .primaryMem .totalIndex
   132 set :minWaits 10000000000
   133 set :first true
   134 label *label25
 
   137 op add *tmp44 :nextTick MEASUREMENT
   138 op greaterThan *tmp45 @tick *tmp44
   139 jump *label28 equal *tmp45 false
-    * op add *tmp47 @tick MEASUREMENT
-    * set :nextTick *tmp47
-    * set *tmp48 .totalIndex
-    * read *tmp49 .primaryMem *tmp48
-    * set :prev *tmp49
+  140 op add :nextTick @tick MEASUREMENT
+  141 read :prev .primaryMem .totalIndex
   142 jump *label29 always
   143 label *label28
   144 label *label29
 
   157 label *label31
   158 jump *label30 always
   159 label *label32
-    * op min *tmp54 :waits :minWaits
-    * set :minWaits *tmp54
-    * set *tmp55 .totalIndex
-    * read *tmp56 .primaryMem *tmp55
-    * set :curr *tmp56
-    * op sub *tmp57 :curr :prev
-    * set :amount *tmp57
+  160 op min :minWaits :waits :minWaits
+  161 read :curr .primaryMem .totalIndex
+  162 op sub :amount :curr :prev
   163 set :prev :curr
-    * set *tmp58 :cacheHead
-    * read *tmp59 .primaryMem *tmp58
+  164 read *tmp59 .primaryMem :cacheHead
   165 op sub *tmp60 :total *tmp59
-    * op add *tmp61 *tmp60 :amount
-    * set :total *tmp61
-    * set *tmp62 :cacheHead
-    * write :amount .primaryMem *tmp62
+  166 op add :total *tmp60 :amount
+  167 write :amount .primaryMem :cacheHead
   168 op add *tmp64 :cacheHead 1
-    * op mod *tmp65 *tmp64 .cacheSize
-    * set :cacheHead *tmp65
+  169 op mod :cacheHead *tmp64 .cacheSize
   170 op lessThan *tmp66 :samples .cacheSize
   171 jump *label35 equal *tmp66 false
   172 op add :samples :samples 1
 
   177 op greaterThanEq *tmp69 :iteration UPDATE
   178 jump *label37 equal *tmp69 false
   179 op div *tmp71 :total :samples
-    * op div *tmp72 *tmp71 MEASUREMENT
-    * set :rate *tmp72
+  180 op div :rate *tmp71 MEASUREMENT
   181 op add :head :head 1
   182 op greaterThanEq *tmp73 :head .bufferEnd
   183 jump *label39 equal *tmp73 false
 
   186 label *label39
   187 label *label40
   188 jump *label41 equal :first false
-    * set *tmp76 .minIndex
-    * write :rate .secondaryMem *tmp76
-    * set *tmp78 .maxIndex
-    * write :rate .secondaryMem *tmp78
+  189 write :rate .secondaryMem .minIndex
+  190 write :rate .secondaryMem .maxIndex
   191 set :first false
   192 jump *label42 always
   193 label *label41
   194 label *label42
-    * set *tmp80 .valueIndex
-    * write :rate .primaryMem *tmp80
-    * set *tmp82 .headIndex
-    * write :head .secondaryMem *tmp82
-    * set *tmp84 :head
-    * write :rate .secondaryMem *tmp84
-    * set *tmp86 .minIndex
-    * read *tmp87 .secondaryMem *tmp86
-    * op min *tmp88 *tmp87 :rate
-    * set :min *tmp88
-    * set *tmp89 .minIndex
-    * write :min .secondaryMem *tmp89
-    * set *tmp91 .maxIndex
-    * read *tmp92 .secondaryMem *tmp91
-    * op max *tmp93 *tmp92 :rate
-    * set :max *tmp93
-    * set *tmp94 .maxIndex
-    * write :max .secondaryMem *tmp94
+  195 write :rate .primaryMem .valueIndex
+  196 write :head .secondaryMem .headIndex
+  197 write :rate .secondaryMem :head
+  198 read *tmp87 .secondaryMem .minIndex
+  199 op min :min *tmp87 :rate
+  200 write :min .secondaryMem .minIndex
+  201 read *tmp92 .secondaryMem .maxIndex
+  202 op max :max *tmp92 :rate
+  203 write :max .secondaryMem .maxIndex
   204 print "[gold]Item Rate Meter[], version [gold]1.0[]"
   205 print " "
   206 print "           "

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-5 instructions):
 
    17 print :init.0:block
    18 print "\n"
    19 sensor *tmp2 :init.0:block @type
-    * jump *label10 equal *tmp2 @message
-    * jump *label9 always
+   20 jump *label9 notEqual *tmp2 @message
    21 label *label10
    22 set .message :init.0:block
    23 jump *label8 always
    24 label *label9
-    * jump *label12 equal *tmp2 @switch
-    * jump *label11 always
+   25 jump *label11 notEqual *tmp2 @switch
    26 label *label12
    27 set .switch :init.0:block
    28 jump *label8 always
    29 label *label11
    30 jump *label14 equal *tmp2 @memory-bank
-    * jump *label14 equal *tmp2 @memory-cell
-    * jump *label13 always
+   31 jump *label13 notEqual *tmp2 @memory-cell
    32 label *label14
    33 set .primaryMem .secondaryMem
    34 set .secondaryMem :init.0:block
 
   254 end
   255 label *label0
   256 sensor *tmp107 :memorySize.0:block @type
-    * jump *label48 equal *tmp107 @memory-cell
-    * jump *label47 always
+  257 jump *label47 notEqual *tmp107 @memory-cell
   258 label *label48
   259 set *tmp106 64
   260 jump *label46 always
   261 label *label47
-    * jump *label50 equal *tmp107 @memory-bank
-    * jump *label49 always
+  262 jump *label49 notEqual *tmp107 @memory-bank
   263 label *label50
   264 set *tmp106 512
   265 jump *label46 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-11 instructions):
 
    51 print "Target memory: "
    52 print .secondaryMem
    53 print "\n"
-    * op equal *tmp4 .primaryMem null
-    * jump *label15 equal *tmp4 false
+   54 jump *label15 notEqual .primaryMem null
    55 print "No memory."
    56 print "\n"
    57 jump *label16 always
 
    59 label *label16
    60 printflush .message
    61 label *label3
-    * op equal *tmp6 .secondaryMem null
-    * jump *label2 notEqual *tmp6 false
+   62 jump *label2 equal .secondaryMem null
    63 label *label4
-    * op equal *tmp7 .primaryMem null
-    * jump *label17 equal *tmp7 false
+   64 jump *label17 notEqual .primaryMem null
    65 set .primaryMem .secondaryMem
    66 set :memorySize.0:block .primaryMem
    67 setaddr :memorySize.0*retaddr *label19
 
   129 set :prevTick :nextTick
   130 op add :nextTick :nextTick MEASUREMENT
   131 op add *tmp44 :nextTick MEASUREMENT
-    * op greaterThan *tmp45 @tick *tmp44
-    * jump *label28 equal *tmp45 false
+  132 jump *label28 lessThanEq @tick *tmp44
   133 op add :nextTick @tick MEASUREMENT
   134 read :prev .primaryMem .totalIndex
   135 jump *label29 always
 
   137 label *label29
   138 set :waits 0
   139 label *label30
-    * op lessThan *tmp50 @tick :nextTick
-    * jump *label32 equal *tmp50 false
-    * op lessThan *tmp51 @tick :prevTick
-    * jump *label33 equal *tmp51 false
+  140 jump *label32 greaterThanEq @tick :nextTick
+  141 jump *label33 greaterThanEq @tick :prevTick
   142 jump *label27 always
   143 jump *label34 always
   144 label *label33
 
   158 write :amount .primaryMem :cacheHead
   159 op add *tmp64 :cacheHead 1
   160 op mod :cacheHead *tmp64 .cacheSize
-    * op lessThan *tmp66 :samples .cacheSize
-    * jump *label35 equal *tmp66 false
+  161 jump *label35 greaterThanEq :samples .cacheSize
   162 op add :samples :samples 1
   163 jump *label36 always
   164 label *label35
   165 label *label36
   166 op add :iteration :iteration MEASUREMENT
-    * op greaterThanEq *tmp69 :iteration UPDATE
-    * jump *label37 equal *tmp69 false
+  167 jump *label37 lessThan :iteration UPDATE
   168 op div *tmp71 :total :samples
   169 op div :rate *tmp71 MEASUREMENT
   170 op add :head :head 1
-    * op greaterThanEq *tmp73 :head .bufferEnd
-    * jump *label39 equal *tmp73 false
+  171 jump *label39 lessThan :head .bufferEnd
   172 set :head .bufferStart
   173 jump *label40 always
   174 label *label39
 
   193 print " "
   194 print "           "
   195 print "\n"
-    * op lessThan *tmp96 :samples .cacheSize
-    * jump *label43 equal *tmp96 false
+  196 jump *label43 greaterThanEq :samples .cacheSize
   197 print "[salmon]Initializing...[]"
   198 print "\n"
   199 jump *label44 always
 
   238 label *label38
   239 label *label26
   240 sensor *tmp104 .switch @enabled
-    * op equal *tmp105 *tmp104 false
-    * jump *label25 notEqual *tmp105 false
+  241 jump *label25 equal *tmp104 false
   242 label *label27
   243 end
   244 label *label0

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-9 instructions):
 
    32 label *label14
    33 set .primaryMem .secondaryMem
    34 set .secondaryMem :init.0:block
-    * jump *label8 always
    35 label *label13
    36 label *label8
    37 label *label6
 
    53 jump *label15 notEqual .primaryMem null
    54 print "No memory."
    55 print "\n"
-    * jump *label16 always
    56 label *label15
    57 label *label16
    58 printflush .message
 
   130 jump *label28 lessThanEq @tick *tmp44
   131 op add :nextTick @tick MEASUREMENT
   132 read :prev .primaryMem .totalIndex
-    * jump *label29 always
   133 label *label28
   134 label *label29
   135 set :waits 0
 
   137 jump *label32 greaterThanEq @tick :nextTick
   138 jump *label33 greaterThanEq @tick :prevTick
   139 jump *label27 always
-    * jump *label34 always
   140 label *label33
   141 label *label34
   142 op add :waits :waits 1
 
   156 op mod :cacheHead *tmp64 .cacheSize
   157 jump *label35 greaterThanEq :samples .cacheSize
   158 op add :samples :samples 1
-    * jump *label36 always
   159 label *label35
   160 label *label36
   161 op add :iteration :iteration MEASUREMENT
 
   165 op add :head :head 1
   166 jump *label39 lessThan :head .bufferEnd
   167 set :head .bufferStart
-    * jump *label40 always
   168 label *label39
   169 label *label40
   170 jump *label41 equal :first false
   171 write :rate .secondaryMem .minIndex
   172 write :rate .secondaryMem .maxIndex
   173 set :first false
-    * jump *label42 always
   174 label *label41
   175 label *label42
   176 write :rate .primaryMem .valueIndex
 
   189 jump *label43 greaterThanEq :samples .cacheSize
   190 print "[salmon]Initializing...[]"
   191 print "\n"
-    * jump *label44 always
   192 label *label43
   193 label *label44
   194 print "Total items: [gold]"
 
   225 set :minWaits 10000000000
   226 printflush .message
   227 op sub :iteration :iteration UPDATE
-    * jump *label38 always
   228 label *label37
   229 label *label38
   230 label *label26

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
   196 print "["
   197 print "]"
   198 print "\n"
-    * op mul *tmp98 :rate 3600
-    * op floor *tmp99 *tmp98
+  199 op idiv *tmp99 :rate 0.0002777777777777778
   200 print "Current rate: [green]"
   201 print *tmp99
   202 print "["
   203 print "]/min"
   204 print "\n"
-    * op mul *tmp100 :min 3600
-    * op floor *tmp101 *tmp100
+  205 op idiv *tmp101 :min 0.0002777777777777778
   206 print "Minimum: [gold]"
   207 print *tmp101
   208 print "["
   209 print "]/min"
   210 print "\n"
-    * op mul *tmp102 :max 3600
-    * op floor *tmp103 *tmp102
+  211 op idiv *tmp103 :max 0.0002777777777777778
   212 print "Maximum: [gold]"
   213 print *tmp103
   214 print "["

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    61 label *label4
    62 jump *label17 notEqual .primaryMem null
    63 set .primaryMem .secondaryMem
-    * set :memorySize.0:block .primaryMem
+   64 set :memorySize.0:block .secondaryMem
    65 setaddr :memorySize.0*retaddr *label19
    66 call *label0 :memorySize.0*retval
    67 label *label19
    68 set :init.0:memSize :memorySize.0*retval
    69 set .cacheSize 50
-    * set .bufferStart .cacheSize
-    * op sub .bufferEnd :init.0:memSize 7
-    * op sub .bufferStartIndex :init.0:memSize 7
-    * op sub .bufferEndIndex :init.0:memSize 6
-    * op sub .headIndex :init.0:memSize 5
-    * op sub .minIndex :init.0:memSize 4
-    * op sub .maxIndex :init.0:memSize 3
-    * op sub .valueIndex :init.0:memSize 2
-    * op sub .totalIndex :init.0:memSize 1
+   70 set .bufferStart 50
+   71 op sub .bufferEnd :memorySize.0*retval 7
+   72 op sub .bufferStartIndex :memorySize.0*retval 7
+   73 op sub .bufferEndIndex :memorySize.0*retval 6
+   74 op sub .headIndex :memorySize.0*retval 5
+   75 op sub .minIndex :memorySize.0*retval 4
+   76 op sub .maxIndex :memorySize.0*retval 3
+   77 op sub .valueIndex :memorySize.0*retval 2
+   78 op sub .totalIndex :memorySize.0*retval 1
    79 jump *label18 always
    80 label *label17
    81 set :memorySize.0:block .primaryMem
 
    92 op sub .valueIndex :init.0:primarySize 2
    93 op sub .totalIndex :init.0:primarySize 1
    94 set .bufferStart 0
-    * op sub .bufferEnd :init.0:secondarySize 8
-    * op sub .bufferStartIndex :init.0:secondarySize 7
-    * op sub .bufferEndIndex :init.0:secondarySize 6
-    * op sub .headIndex :init.0:secondarySize 5
-    * op sub .minIndex :init.0:secondarySize 4
-    * op sub .maxIndex :init.0:secondarySize 3
+   95 op sub .bufferEnd :memorySize.0*retval 8
+   96 op sub .bufferStartIndex :memorySize.0*retval 7
+   97 op sub .bufferEndIndex :memorySize.0*retval 6
+   98 op sub .headIndex :memorySize.0*retval 5
+   99 op sub .minIndex :memorySize.0*retval 4
+  100 op sub .maxIndex :memorySize.0*retval 3
   101 label *label18
   102 write .bufferStart .secondaryMem .bufferStartIndex
   103 write .bufferEnd .secondaryMem .bufferEndIndex
 
   106 set *tmp34 .cacheSize
   107 set :i 0
   108 label *label22
-    * jump *label24 greaterThanEq :i *tmp34
+  109 jump *label24 greaterThanEq :i .cacheSize
   110 write 0 .primaryMem :i
   111 label *label23
   112 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    65 setaddr :memorySize.0*retaddr *label19
    66 call *label0 :memorySize.0*retval
    67 label *label19
-    * set :init.0:memSize :memorySize.0*retval
    68 set .cacheSize 50
    69 set .bufferStart 50
    70 op sub .bufferEnd :memorySize.0*retval 7
 
    86 setaddr :memorySize.0*retaddr *label21
    87 call *label0 :memorySize.0*retval
    88 label *label21
-    * set :init.0:secondarySize :memorySize.0*retval
    89 op sub .cacheSize :init.0:primarySize 2
    90 op sub .valueIndex :init.0:primarySize 2
    91 op sub .totalIndex :init.0:primarySize 1
 
   101 write .bufferEnd .secondaryMem .bufferEndIndex
   102 label *label1
   103 op min .cacheSize SMOOTHING .cacheSize
-    * set *tmp34 .cacheSize
   104 set :i 0
   105 label *label22
   106 jump *label24 greaterThanEq :i .cacheSize

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    12 op sub :init.0:n @links 1
    13 label *label5
    14 jump *label7 lessThan :init.0:n 0
+   15 label *label51
    16 getlink :init.0:block :init.0:n
    17 print "Found: "
    18 print :init.0:block
 
    37 label *label8
    38 label *label6
    39 op sub :init.0:n :init.0:n 1
-    * jump *label5 always
+   40 jump *label51 greaterThanEq :init.0:n 0
    41 label *label7
    42 print "Message: "
    43 print .message
 
   105 set :i 0
   106 label *label22
   107 jump *label24 greaterThanEq :i .cacheSize
+  108 label *label52
   109 write 0 .primaryMem :i
   110 label *label23
   111 op add :i :i 1
-    * jump *label22 always
+  112 jump *label52 lessThan :i .cacheSize
   113 label *label24
   114 set :cacheHead 0
   115 set :samples 0
 
   134 set :waits 0
   135 label *label30
   136 jump *label32 greaterThanEq @tick :nextTick
+  137 label *label53
   138 jump *label33 greaterThanEq @tick :prevTick
   139 jump *label27 always
   140 label *label33
 
   142 op add :waits :waits 1
   143 wait 0.000000000000001
   144 label *label31
-    * jump *label30 always
+  145 jump *label53 lessThan @tick :nextTick
   146 label *label32
   147 op min :minWaits :waits :minWaits
   148 read :curr .primaryMem .totalIndex

Modifications by Inline function 'memorySize' defined at item-rate-meter-init.mnd:84:1 (+10 instructions):
 
    63 jump *label17 notEqual .primaryMem null
    64 set .primaryMem .secondaryMem
    65 set :memorySize.0:block .secondaryMem
-    * setaddr :memorySize.0*retaddr *label19
-    * call *label0 :memorySize.0*retval
-    * label *label19
+   66 label *label54
+   67 sensor *tmp107 :memorySize.0:block @type
+   68 jump *label56 notEqual *tmp107 @memory-cell
+   69 label *label55
+   70 set *tmp106 64
+   71 jump *label59 always
+   72 label *label56
+   73 jump *label58 notEqual *tmp107 @memory-bank
+   74 label *label57
+   75 set *tmp106 512
+   76 jump *label59 always
+   77 label *label58
+   78 set *tmp106 null
+   79 label *label59
+   80 set :memorySize.0*retval *tmp106
+   81 label *label60
    82 set .cacheSize 50
    83 set .bufferStart 50
    84 op sub .bufferEnd :memorySize.0*retval 7
 
    92 jump *label18 always
    93 label *label17
    94 set :memorySize.0:block .primaryMem
-    * setaddr :memorySize.0*retaddr *label20
-    * call *label0 :memorySize.0*retval
-    * label *label20
+   95 label *label61
+   96 sensor *tmp107 :memorySize.0:block @type
+   97 jump *label63 notEqual *tmp107 @memory-cell
+   98 label *label62
+   99 set *tmp106 64
+  100 jump *label66 always
+  101 label *label63
+  102 jump *label65 notEqual *tmp107 @memory-bank
+  103 label *label64
+  104 set *tmp106 512
+  105 jump *label66 always
+  106 label *label65
+  107 set *tmp106 null
+  108 label *label66
+  109 set :memorySize.0*retval *tmp106
+  110 label *label67
   111 set :init.0:primarySize :memorySize.0*retval
   112 set :memorySize.0:block .secondaryMem
-    * setaddr :memorySize.0*retaddr *label21
-    * call *label0 :memorySize.0*retval
-    * label *label21
+  113 label *label68
+  114 sensor *tmp107 :memorySize.0:block @type
+  115 jump *label70 notEqual *tmp107 @memory-cell
+  116 label *label69
+  117 set *tmp106 64
+  118 jump *label73 always
+  119 label *label70
+  120 jump *label72 notEqual *tmp107 @memory-bank
+  121 label *label71
+  122 set *tmp106 512
+  123 jump *label73 always
+  124 label *label72
+  125 set *tmp106 null
+  126 label *label73
+  127 set :memorySize.0*retval *tmp106
+  128 label *label74
   129 op sub .cacheSize :init.0:primarySize 2
   130 op sub .valueIndex :init.0:primarySize 2
   131 op sub .totalIndex :init.0:primarySize 1
 
   268 jump *label25 equal *tmp104 false
   269 label *label27
   270 end
-    * label *label0
-    * sensor *tmp107 :memorySize.0:block @type
-    * jump *label47 notEqual *tmp107 @memory-cell
-    * label *label48
-    * set *tmp106 64
-    * jump *label46 always
-    * label *label47
-    * jump *label49 notEqual *tmp107 @memory-bank
-    * label *label50
-    * set *tmp106 512
-    * jump *label46 always
-    * label *label49
-    * set *tmp106 null
-    * label *label46
-    * set :memorySize.0*retval *tmp106
-    * label *label45
-    * return :memorySize.0*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    64 set .primaryMem .secondaryMem
    65 set :memorySize.0:block .secondaryMem
    66 label *label54
-    * sensor *tmp107 :memorySize.0:block @type
+   67 sensor *tmp107 .secondaryMem @type
    68 jump *label56 notEqual *tmp107 @memory-cell
    69 label *label55
    70 set *tmp106 64
 
    81 label *label60
    82 set .cacheSize 50
    83 set .bufferStart 50
-    * op sub .bufferEnd :memorySize.0*retval 7
-    * op sub .bufferStartIndex :memorySize.0*retval 7
-    * op sub .bufferEndIndex :memorySize.0*retval 6
-    * op sub .headIndex :memorySize.0*retval 5
-    * op sub .minIndex :memorySize.0*retval 4
-    * op sub .maxIndex :memorySize.0*retval 3
-    * op sub .valueIndex :memorySize.0*retval 2
-    * op sub .totalIndex :memorySize.0*retval 1
+   84 op sub .bufferEnd *tmp106 7
+   85 op sub .bufferStartIndex *tmp106 7
+   86 op sub .bufferEndIndex *tmp106 6
+   87 op sub .headIndex *tmp106 5
+   88 op sub .minIndex *tmp106 4
+   89 op sub .maxIndex *tmp106 3
+   90 op sub .valueIndex *tmp106 2
+   91 op sub .totalIndex *tmp106 1
    92 jump *label18 always
    93 label *label17
    94 set :memorySize.0:block .primaryMem
    95 label *label61
-    * sensor *tmp107 :memorySize.0:block @type
+   96 sensor *tmp107 .primaryMem @type
    97 jump *label63 notEqual *tmp107 @memory-cell
    98 label *label62
    99 set *tmp106 64
 
   108 label *label66
   109 set :memorySize.0*retval *tmp106
   110 label *label67
-    * set :init.0:primarySize :memorySize.0*retval
+  111 set :init.0:primarySize *tmp106
   112 set :memorySize.0:block .secondaryMem
   113 label *label68
-    * sensor *tmp107 :memorySize.0:block @type
+  114 sensor *tmp107 .secondaryMem @type
   115 jump *label70 notEqual *tmp107 @memory-cell
   116 label *label69
   117 set *tmp106 64
 
   130 op sub .valueIndex :init.0:primarySize 2
   131 op sub .totalIndex :init.0:primarySize 1
   132 set .bufferStart 0
-    * op sub .bufferEnd :memorySize.0*retval 8
-    * op sub .bufferStartIndex :memorySize.0*retval 7
-    * op sub .bufferEndIndex :memorySize.0*retval 6
-    * op sub .headIndex :memorySize.0*retval 5
-    * op sub .minIndex :memorySize.0*retval 4
-    * op sub .maxIndex :memorySize.0*retval 3
+  133 op sub .bufferEnd *tmp106 8
+  134 op sub .bufferStartIndex *tmp106 7
+  135 op sub .bufferEndIndex *tmp106 6
+  136 op sub .headIndex *tmp106 5
+  137 op sub .minIndex *tmp106 4
+  138 op sub .maxIndex *tmp106 3
   139 label *label18
   140 write .bufferStart .secondaryMem .bufferStartIndex
   141 write .bufferEnd .secondaryMem .bufferEndIndex
 
   143 op min .cacheSize SMOOTHING .cacheSize
   144 set :i 0
   145 label *label22
-    * jump *label24 greaterThanEq :i .cacheSize
+  146 jump *label24 greaterThanEq 0 .cacheSize
   147 label *label52
   148 write 0 .primaryMem :i
   149 label *label23

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-6 instructions):
 
    62 label *label4
    63 jump *label17 notEqual .primaryMem null
    64 set .primaryMem .secondaryMem
-    * set :memorySize.0:block .secondaryMem
    65 label *label54
    66 sensor *tmp107 .secondaryMem @type
    67 jump *label56 notEqual *tmp107 @memory-cell
 
    76 label *label58
    77 set *tmp106 null
    78 label *label59
-    * set :memorySize.0*retval *tmp106
    79 label *label60
    80 set .cacheSize 50
    81 set .bufferStart 50
 
    89 op sub .totalIndex *tmp106 1
    90 jump *label18 always
    91 label *label17
-    * set :memorySize.0:block .primaryMem
    92 label *label61
    93 sensor *tmp107 .primaryMem @type
    94 jump *label63 notEqual *tmp107 @memory-cell
 
   103 label *label65
   104 set *tmp106 null
   105 label *label66
-    * set :memorySize.0*retval *tmp106
   106 label *label67
   107 set :init.0:primarySize *tmp106
-    * set :memorySize.0:block .secondaryMem
   108 label *label68
   109 sensor *tmp107 .secondaryMem @type
   110 jump *label70 notEqual *tmp107 @memory-cell
 
   119 label *label72
   120 set *tmp106 null
   121 label *label73
-    * set :memorySize.0*retval *tmp106
   122 label *label74
   123 op sub .cacheSize :init.0:primarySize 2
   124 op sub .valueIndex :init.0:primarySize 2

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
    93 sensor *tmp107 .primaryMem @type
    94 jump *label63 notEqual *tmp107 @memory-cell
    95 label *label62
-    * set *tmp106 64
+   96 set :init.0:primarySize 64
    97 jump *label66 always
    98 label *label63
    99 jump *label65 notEqual *tmp107 @memory-bank
   100 label *label64
-    * set *tmp106 512
+  101 set :init.0:primarySize 512
   102 jump *label66 always
   103 label *label65
-    * set *tmp106 null
+  104 set :init.0:primarySize null
   105 label *label66
   106 label *label67
-    * set :init.0:primarySize *tmp106
   107 label *label68
   108 sensor *tmp107 .secondaryMem @type
   109 jump *label70 notEqual *tmp107 @memory-cell

Modifications by Final phase, Jump Straightening, iteration 1 (-1 instructions):
 
   167 label *label30
   168 jump *label32 greaterThanEq @tick :nextTick
   169 label *label53
-    * jump *label33 greaterThanEq @tick :prevTick
-    * jump *label27 always
+  170 jump *label27 lessThan @tick :prevTick
   171 label *label33
   172 label *label34
   173 op add :waits :waits 1

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 set MEASUREMENT 15
     2 set UPDATE 60
     3 set SMOOTHING 20
 
   168 label *label30
   169 jump *label32 greaterThanEq @tick :nextTick
   170 label *label53
-    * jump *label27 lessThan @tick :prevTick
+  171 jump __start__ lessThan @tick :prevTick
   172 label *label33
   173 label *label34
   174 op add :waits :waits 1

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   260 sensor *tmp104 .switch @enabled
   261 jump *label25 equal *tmp104 false
   262 label *label27
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-24 instructions):
 
     6 set .message null
     7 set .primaryMem null
     8 set .secondaryMem null
-    * print "[gold]Item Rate Meter[], version [gold]1.0[]"
-    * print "\n"
-    * print "[salmon]Initializing...[]"
-    * print "\n"
+    9 print "[gold]Item Rate Meter[], version [gold]1.0[]\n[salmon]Initializing...[]\n"
    10 op sub :init.0:n @links 1
    11 label *label5
    12 jump *label7 lessThan :init.0:n 0
 
    39 label *label7
    40 print "Message: "
    41 print .message
-    * print "\n"
-    * print "Switch: "
+   42 print "\nSwitch: "
    43 print .switch
-    * print "\n"
-    * print "Source memory: "
+   44 print "\nSource memory: "
    45 print .primaryMem
-    * print "\n"
-    * print "Target memory: "
+   46 print "\nTarget memory: "
    47 print .secondaryMem
    48 print "\n"
    49 jump *label15 notEqual .primaryMem null
-    * print "No memory."
-    * print "\n"
+   50 print "No memory.\n"
    51 label *label15
    52 label *label16
    53 printflush .message
 
   207 read *tmp92 .secondaryMem .maxIndex
   208 op max :max *tmp92 :rate
   209 write :max .secondaryMem .maxIndex
-    * print "[gold]Item Rate Meter[], version [gold]1.0[]"
-    * print " "
-    * print "           "
-    * print "\n"
+  210 print "[gold]Item Rate Meter[], version [gold]1.0[]            \n"
   211 jump *label43 greaterThanEq :samples .cacheSize
-    * print "[salmon]Initializing...[]"
-    * print "\n"
+  212 print "[salmon]Initializing...[]\n"
   213 label *label43
   214 label *label44
   215 print "Total items: [gold]"
   216 print :curr
-    * print "["
-    * print "]"
-    * print "\n"
   217 op idiv *tmp99 :rate 0.0002777777777777778
-    * print "Current rate: [green]"
+  218 print "[]\nCurrent rate: [green]"
   219 print *tmp99
-    * print "["
-    * print "]/min"
-    * print "\n"
   220 op idiv *tmp101 :min 0.0002777777777777778
-    * print "Minimum: [gold]"
+  221 print "[]/min\nMinimum: [gold]"
   222 print *tmp101
-    * print "["
-    * print "]/min"
-    * print "\n"
   223 op idiv *tmp103 :max 0.0002777777777777778
-    * print "Maximum: [gold]"
+  224 print "[]/min\nMaximum: [gold]"
   225 print *tmp103
-    * print "["
-    * print "]/min"
-    * print "\n"
-    * print "Smoothing: "
+  226 print "[]/min\nSmoothing: "
   227 print .cacheSize
-    * print "\n"
-    * print "[lightgray]Waits: "
+  228 print "\n[lightgray]Waits: "
   229 print :minWaits
   230 set :minWaits 10000000000
   231 printflush .message

Final code before resolving virtual instructions:

        label __start__                                              item-rate-meter.mnd: param MEASUREMENT = 15;         // Measurement interval in ticks
    0:  set MEASUREMENT 15                                           ...
    1:  set UPDATE 60                                                item-rate-meter.mnd: param UPDATE = 60;              // Update interval in ticks
    2:  set SMOOTHING 20                                             item-rate-meter.mnd: param SMOOTHING = 20;           // Size of averaging window
        label *label2                                                item-rate-meter-init.mnd: do
    3:  set .switch null                                             item-rate-meter-init.mnd: switch = null;
    4:  set .message null                                            item-rate-meter-init.mnd: message = null;
    5:  set .primaryMem null                                         item-rate-meter-init.mnd: primaryMem = null;
    6:  set .secondaryMem null                                       item-rate-meter-init.mnd: secondaryMem = null;
    7:  print "[gold]Item Rate Meter[], version [gold]1.0[]\n[salmon item-rate-meter-init.mnd: println("[salmon]Initializing...[]");
    8:  op sub :init.0:n @links 1                                    item-rate-meter-init.mnd: for var n in 0 ... @links descending do
    9:  jump *label7 lessThan :init.0:n 0                            ...
        label *label51                                               ...
   10:  getlink :init.0:block :init.0:n                              item-rate-meter-init.mnd: var block = getlink(n);
   11:  print "Found: "                                              item-rate-meter-init.mnd: println("Found: ", block);
   12:  print :init.0:block                                          ...
   13:  print "\n"                                                   ...
   14:  sensor *tmp2 :init.0:block @type                             item-rate-meter-init.mnd: case block.@type
   15:  jump *label9 notEqual *tmp2 @message                         ...
   16:  set .message :init.0:block                                   item-rate-meter-init.mnd: message = block;
   17:  jump *label8 always 0 0                                      item-rate-meter-init.mnd: case block.@type
        label *label9                                                ...
   18:  jump *label11 notEqual *tmp2 @switch                         ...
   19:  set .switch :init.0:block                                    item-rate-meter-init.mnd: switch = block;
   20:  jump *label8 always 0 0                                      item-rate-meter-init.mnd: case block.@type
        label *label11                                               ...
   21:  jump *label14 equal *tmp2 @memory-bank                       ...
   22:  jump *label13 notEqual *tmp2 @memory-cell                    ...
        label *label14                                               ...
   23:  set .primaryMem .secondaryMem                                item-rate-meter-init.mnd: primaryMem = secondaryMem;
   24:  set .secondaryMem :init.0:block                              item-rate-meter-init.mnd: secondaryMem = block;
        label *label13                                               item-rate-meter-init.mnd: case block.@type
        label *label8                                                ...
   25:  op sub :init.0:n :init.0:n 1                                 item-rate-meter-init.mnd: for var n in 0 ... @links descending do
   26:  jump *label51 greaterThanEq :init.0:n 0                      ...
        label *label7                                                ...
   27:  print "Message: "                                            item-rate-meter-init.mnd: println("Message: ", message);
   28:  print .message                                               ...
   29:  print "\nSwitch: "                                           item-rate-meter-init.mnd: println("Switch: ", switch);
   30:  print .switch                                                ...
   31:  print "\nSource memory: "                                    item-rate-meter-init.mnd: println("Source memory: ", primaryMem);
   32:  print .primaryMem                                            ...
   33:  print "\nTarget memory: "                                    item-rate-meter-init.mnd: println("Target memory: ", secondaryMem);
   34:  print .secondaryMem                                          ...
   35:  print "\n"                                                   ...
   36:  jump *label15 notEqual .primaryMem null                      item-rate-meter-init.mnd: if primaryMem == null then
   37:  print "No memory.\n"                                         item-rate-meter-init.mnd: println("No memory.");
        label *label15                                               item-rate-meter-init.mnd: if primaryMem == null then
   38:  printflush .message                                          item-rate-meter-init.mnd: printflush(message);
   39:  jump *label2 equal .secondaryMem null                        item-rate-meter-init.mnd: do
   40:  jump *label17 notEqual .primaryMem null                      item-rate-meter-init.mnd: if primaryMem == null then
   41:  set .primaryMem .secondaryMem                                item-rate-meter-init.mnd: primaryMem = secondaryMem;
   42:  sensor *tmp107 .secondaryMem @type                           item-rate-meter-init.mnd: case block.@type
   43:  jump *label56 notEqual *tmp107 @memory-cell                  ...
   44:  set *tmp106 64                                               ...
   45:  jump *label59 always 0 0                                     ...
        label *label56                                               ...
   46:  jump *label58 notEqual *tmp107 @memory-bank                  ...
   47:  set *tmp106 512                                              ...
   48:  jump *label59 always 0 0                                     ...
        label *label58                                               ...
   49:  set *tmp106 null                                             ...
        label *label59                                               ...
   50:  set .cacheSize 50                                            item-rate-meter-init.mnd: cacheSize = 50;
   51:  set .bufferStart 50                                          item-rate-meter-init.mnd: bufferStart = cacheSize;
   52:  op sub .bufferEnd *tmp106 7                                  item-rate-meter-init.mnd: bufferEnd = memSize - 7;
   53:  op sub .bufferStartIndex *tmp106 7                           item-rate-meter-init.mnd: bufferStartIndex = memSize - 7;
   54:  op sub .bufferEndIndex *tmp106 6                             item-rate-meter-init.mnd: bufferEndIndex = memSize - 6;
   55:  op sub .headIndex *tmp106 5                                  item-rate-meter-init.mnd: headIndex = memSize - 5;
   56:  op sub .minIndex *tmp106 4                                   item-rate-meter-init.mnd: minIndex = memSize - 4;
   57:  op sub .maxIndex *tmp106 3                                   item-rate-meter-init.mnd: maxIndex = memSize - 3;
   58:  op sub .valueIndex *tmp106 2                                 item-rate-meter-init.mnd: valueIndex = memSize - 2;
   59:  op sub .totalIndex *tmp106 1                                 item-rate-meter-init.mnd: totalIndex = memSize - 1;
   60:  jump *label18 always 0 0                                     item-rate-meter-init.mnd: if primaryMem == null then
        label *label17                                               ...
   61:  sensor *tmp107 .primaryMem @type                             item-rate-meter-init.mnd: case block.@type
   62:  jump *label63 notEqual *tmp107 @memory-cell                  ...
   63:  set :init.0:primarySize 64                                   ...
   64:  jump *label66 always 0 0                                     ...
        label *label63                                               ...
   65:  jump *label65 notEqual *tmp107 @memory-bank                  ...
   66:  set :init.0:primarySize 512                                  ...
   67:  jump *label66 always 0 0                                     ...
        label *label65                                               ...
   68:  set :init.0:primarySize null                                 ...
        label *label66                                               ...
   69:  sensor *tmp107 .secondaryMem @type                           ...
   70:  jump *label70 notEqual *tmp107 @memory-cell                  ...
   71:  set *tmp106 64                                               ...
   72:  jump *label73 always 0 0                                     ...
        label *label70                                               ...
   73:  jump *label72 notEqual *tmp107 @memory-bank                  ...
   74:  set *tmp106 512                                              ...
   75:  jump *label73 always 0 0                                     ...
        label *label72                                               ...
   76:  set *tmp106 null                                             ...
        label *label73                                               ...
   77:  op sub .cacheSize :init.0:primarySize 2                      item-rate-meter-init.mnd: cacheSize = primarySize - 2;
   78:  op sub .valueIndex :init.0:primarySize 2                     item-rate-meter-init.mnd: valueIndex = primarySize - 2;
   79:  op sub .totalIndex :init.0:primarySize 1                     item-rate-meter-init.mnd: totalIndex = primarySize - 1;
   80:  set .bufferStart 0                                           item-rate-meter-init.mnd: bufferStart = 0;
   81:  op sub .bufferEnd *tmp106 8                                  item-rate-meter-init.mnd: bufferEnd = secondarySize - 8;
   82:  op sub .bufferStartIndex *tmp106 7                           item-rate-meter-init.mnd: bufferStartIndex = secondarySize - 7;
   83:  op sub .bufferEndIndex *tmp106 6                             item-rate-meter-init.mnd: bufferEndIndex = secondarySize - 6;
   84:  op sub .headIndex *tmp106 5                                  item-rate-meter-init.mnd: headIndex = secondarySize - 5;
   85:  op sub .minIndex *tmp106 4                                   item-rate-meter-init.mnd: minIndex = secondarySize - 4;
   86:  op sub .maxIndex *tmp106 3                                   item-rate-meter-init.mnd: maxIndex = secondarySize - 3;
        label *label18                                               item-rate-meter-init.mnd: if primaryMem == null then
   87:  write .bufferStart .secondaryMem .bufferStartIndex           item-rate-meter-init.mnd: secondaryMem[bufferStartIndex] = bufferStart;
   88:  write .bufferEnd .secondaryMem .bufferEndIndex               item-rate-meter-init.mnd: secondaryMem[bufferEndIndex] = bufferEnd;
   89:  op min .cacheSize SMOOTHING .cacheSize                       item-rate-meter.mnd: cacheSize = min(SMOOTHING, cacheSize);
   90:  set :i 0                                                     item-rate-meter.mnd: for var i in 0 ... cacheSize do primaryMem[i] = 0; end;
   91:  jump *label24 greaterThanEq 0 .cacheSize                     ...
        label *label52                                               ...
   92:  write 0 .primaryMem :i                                       ...
   93:  op add :i :i 1                                               ...
   94:  jump *label52 lessThan :i .cacheSize                         ...
        label *label24                                               ...
   95:  set :cacheHead 0                                             item-rate-meter.mnd: var cacheHead = 0;
   96:  set :samples 0                                               item-rate-meter.mnd: var samples = 0;
   97:  read *tmp38 .secondaryMem .headIndex                         item-rate-meter.mnd: var head = max(bufferStart, secondaryMem[headIndex]);
   98:  op max :head .bufferStart *tmp38                             ...
   99:  set :total 0                                                 item-rate-meter.mnd: var total = 0;
  100:  set :iteration 0                                             item-rate-meter.mnd: var iteration = 0;
  101:  control enabled .switch false 0 0 0                          item-rate-meter.mnd: switch.enabled = false;
  102:  set :nextTick @tick                                          item-rate-meter.mnd: var nextTick = @tick;
  103:  read :prev .primaryMem .totalIndex                           item-rate-meter.mnd: var prev = primaryMem[totalIndex];
  104:  set :minWaits 10000000000                                    item-rate-meter.mnd: var minWaits = 1e10;
  105:  set :first true                                              item-rate-meter.mnd: var first = true;
        label *label25                                               item-rate-meter.mnd: MainLoop:
  106:  set :prevTick :nextTick                                      item-rate-meter.mnd: prevTick = nextTick;
  107:  op add :nextTick :nextTick MEASUREMENT                       item-rate-meter.mnd: nextTick += MEASUREMENT;
  108:  op add *tmp44 :nextTick MEASUREMENT                          item-rate-meter.mnd: if @tick > nextTick + MEASUREMENT then
  109:  jump *label28 lessThanEq @tick *tmp44                        ...
  110:  op add :nextTick @tick MEASUREMENT                           item-rate-meter.mnd: nextTick = @tick + MEASUREMENT;
  111:  read :prev .primaryMem .totalIndex                           item-rate-meter.mnd: prev = primaryMem[totalIndex];
        label *label28                                               item-rate-meter.mnd: if @tick > nextTick + MEASUREMENT then
  112:  set :waits 0                                                 item-rate-meter.mnd: var waits = 0;
  113:  jump *label32 greaterThanEq @tick :nextTick                  item-rate-meter.mnd: while @tick < nextTick do
        label *label53                                               ...
  114:  jump __start__ lessThan @tick :prevTick                      item-rate-meter.mnd: if @tick < prevTick then
  115:  op add :waits :waits 1                                       item-rate-meter.mnd: while @tick < nextTick do
  116:  wait 0.000000000000001                                       item-rate-meter.mnd: wait(1e-15);
  117:  jump *label53 lessThan @tick :nextTick                       item-rate-meter.mnd: while @tick < nextTick do
        label *label32                                               ...
  118:  op min :minWaits :waits :minWaits                            item-rate-meter.mnd: minWaits = min(waits, minWaits);
  119:  read :curr .primaryMem .totalIndex                           item-rate-meter.mnd: var curr = primaryMem[totalIndex];
  120:  op sub :amount :curr :prev                                   item-rate-meter.mnd: var amount = curr - prev;
  121:  set :prev :curr                                              item-rate-meter.mnd: prev = curr;
  122:  read *tmp59 .primaryMem :cacheHead                           item-rate-meter.mnd: total = total - primaryMem[cacheHead] + amount;
  123:  op sub *tmp60 :total *tmp59                                  ...
  124:  op add :total *tmp60 :amount                                 ...
  125:  write :amount .primaryMem :cacheHead                         item-rate-meter.mnd: primaryMem[cacheHead] = amount;
  126:  op add *tmp64 :cacheHead 1                                   item-rate-meter.mnd: cacheHead = (cacheHead + 1) % cacheSize;
  127:  op mod :cacheHead *tmp64 .cacheSize                          ...
  128:  jump *label35 greaterThanEq :samples .cacheSize              item-rate-meter.mnd: if samples < cacheSize then samples++; end;
  129:  op add :samples :samples 1                                   ...
        label *label35                                               ...
  130:  op add :iteration :iteration MEASUREMENT                     item-rate-meter.mnd: iteration += MEASUREMENT;
  131:  jump *label37 lessThan :iteration UPDATE                     item-rate-meter.mnd: if iteration >= UPDATE then
  132:  op div *tmp71 :total :samples                                item-rate-meter.mnd: var rate = total / samples / MEASUREMENT;   // items per tick
  133:  op div :rate *tmp71 MEASUREMENT                              ...
  134:  op add :head :head 1                                         item-rate-meter.mnd: if ++head >= bufferEnd then
  135:  jump *label39 lessThan :head .bufferEnd                      ...
  136:  set :head .bufferStart                                       item-rate-meter.mnd: head = bufferStart;
        label *label39                                               item-rate-meter.mnd: if ++head >= bufferEnd then
  137:  jump *label41 equal :first false                             item-rate-meter.mnd: if first then
  138:  write :rate .secondaryMem .minIndex                          item-rate-meter.mnd: secondaryMem[minIndex] = rate;
  139:  write :rate .secondaryMem .maxIndex                          item-rate-meter.mnd: secondaryMem[maxIndex] = rate;
  140:  set :first false                                             item-rate-meter.mnd: first = false;
        label *label41                                               item-rate-meter.mnd: if first then
  141:  write :rate .primaryMem .valueIndex                          item-rate-meter.mnd: primaryMem[valueIndex] = rate;
  142:  write :head .secondaryMem .headIndex                         item-rate-meter.mnd: secondaryMem[headIndex] = head;
  143:  write :rate .secondaryMem :head                              item-rate-meter.mnd: secondaryMem[head] = rate;
  144:  read *tmp87 .secondaryMem .minIndex                          item-rate-meter.mnd: var min = min(secondaryMem[minIndex], rate);
  145:  op min :min *tmp87 :rate                                     ...
  146:  write :min .secondaryMem .minIndex                           item-rate-meter.mnd: secondaryMem[minIndex] = min;
  147:  read *tmp92 .secondaryMem .maxIndex                          item-rate-meter.mnd: var max = max(secondaryMem[maxIndex], rate);
  148:  op max :max *tmp92 :rate                                     ...
  149:  write :max .secondaryMem .maxIndex                           item-rate-meter.mnd: secondaryMem[maxIndex] = max;
  150:  print "[gold]Item Rate Meter[], version [gold]1.0[]          item-rate-meter.mnd: println($"$TITLE            ");
  151:  jump *label43 greaterThanEq :samples .cacheSize              item-rate-meter.mnd: if samples < cacheSize then
  152:  print "[salmon]Initializing...[]\n"                          item-rate-meter.mnd: println($"[salmon]Initializing...[]");
        label *label43                                               item-rate-meter.mnd: if samples < cacheSize then
  153:  print "Total items: [gold]"                                  item-rate-meter.mnd: println($"Total items: [gold]$curr[]");
  154:  print :curr                                                  ...
  155:  op idiv *tmp99 :rate 0.0002777777777777778                   item-rate-meter.mnd: println($"Current rate: [green]$[]/min", floor(rate * 3600));
  156:  print "[]\nCurrent rate: [green]"                            ...
  157:  print *tmp99                                                 ...
  158:  op idiv *tmp101 :min 0.0002777777777777778                   item-rate-meter.mnd: println($"Minimum: [gold]$[]/min", floor(min * 3600));
  159:  print "[]/min\nMinimum: [gold]"                              ...
  160:  print *tmp101                                                ...
  161:  op idiv *tmp103 :max 0.0002777777777777778                   item-rate-meter.mnd: println($"Maximum: [gold]$[]/min", floor(max * 3600));
  162:  print "[]/min\nMaximum: [gold]"                              ...
  163:  print *tmp103                                                ...
  164:  print "[]/min\nSmoothing: "                                  item-rate-meter.mnd: println($"Smoothing: $cacheSize");
  165:  print .cacheSize                                             ...
  166:  print "\n[lightgray]Waits: "                                 item-rate-meter.mnd: print($"[lightgray]Waits: $minWaits");
  167:  print :minWaits                                              ...
  168:  set :minWaits 10000000000                                    item-rate-meter.mnd: minWaits = 1e10;
  169:  printflush .message                                          item-rate-meter.mnd: printflush(message);
  170:  op sub :iteration :iteration UPDATE                          item-rate-meter.mnd: iteration -= UPDATE;
        label *label37                                               item-rate-meter.mnd: if iteration >= UPDATE then
  171:  sensor *tmp104 .switch @enabled                              item-rate-meter.mnd: while !switch.@enabled;
  172:  jump *label25 equal *tmp104 false                            item-rate-meter.mnd: MainLoop:


Performance: parsed in 232 ms, compiled in 227 ms, optimized in 248 ms, run in 16 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (540 steps):
[gold]Item Rate Meter[], version [gold]1.0[]
[salmon]Initializing...[]
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Source memory: cell
Target memory: cell

Execution exception at instruction 116: wait 0.000000000000001:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
