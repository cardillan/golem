   248 instructions before optimizations.
    34 instructions eliminated by Temp Variables Elimination (5 iterations).
     1 instructions eliminated by Case Expression Optimization.
    17 instructions eliminated by Dead Code Elimination (4 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     7 instructions eliminated by Jump Optimization (4 iterations).
     6 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
    10 instructions eliminated by Data Flow Optimization (6 iterations).
     1 instructions added by Loop Optimization (2 iterations).
     3 loops improved by Loop Optimization.
   136 instructions added by Case Switching (4 iterations).
     1 case expressions converted to switched jumps Case Switching.
     8 instructions eliminated by Jump Straightening (4 iterations).
     2 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
     5 instructions eliminated by Print Merging.
   295 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 834):
  * Replicate loop condition at line 119:1                       size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  o Convert case at line 31:9 (segments: 15)                     size    +5, benefit      576.9, efficiency    115.385
  o Convert case at line 31:9 (segments: 6)                      size    +7, benefit      817.3, efficiency    116.758
  o Convert case at line 31:9 (segments: 5)                      size   +12, benefit     1009.6, efficiency     84.135
    Convert case at line 31:9 (segments: 1)                      size   +73, benefit     1298.1, efficiency     17.782
    Convert case at line 31:9 (segments: 3, padded low)          size   +78, benefit     1394.2, efficiency     17.875
    Convert case at line 31:9 (segments: 1, padded low)          size  +136, benefit     1923.1, efficiency     14.140

Pass 1: speed optimization selection (cost limit 833):
  o Convert case at line 31:9 (segments: 15)                     size    +5, benefit      576.9, efficiency    115.385
  o Convert case at line 31:9 (segments: 6)                      size    +7, benefit      817.3, efficiency    116.758
  o Convert case at line 31:9 (segments: 5)                      size   +12, benefit     1009.6, efficiency     84.135
  o Convert case at line 31:9 (segments: 1)                      size   +73, benefit     1298.1, efficiency     17.782
  o Convert case at line 31:9 (segments: 3, padded low)          size   +78, benefit     1394.2, efficiency     17.875
  * Convert case at line 31:9 (segments: 1, padded low)          size  +136, benefit     1923.1, efficiency     14.140 (+136 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    45 print "\nFound: "
    46 print :block
    47 sensor *tmp13 :block @type
-    * set *tmp14 *tmp13
-    * jump *label8 equal *tmp14 @message
+   48 jump *label8 equal *tmp13 @message
    49 jump *label7 always
    50 label *label8
    51 set .MESSAGE :block
    52 set *tmp12 .MESSAGE
    53 jump *label6 always
    54 label *label7
-    * jump *label10 equal *tmp14 @switch
+   55 jump *label10 equal *tmp13 @switch
    56 jump *label9 always
    57 label *label10
    58 set .SWITCH :block
    59 set *tmp12 .SWITCH
    60 jump *label6 always
    61 label *label9
-    * jump *label12 equal *tmp14 @memory-bank
+   62 jump *label12 equal *tmp13 @memory-bank
    63 jump *label11 always
    64 label *label12
    65 set .MEMORY :block
 
    69 set *tmp12 .SIZE
    70 jump *label6 always
    71 label *label11
-    * jump *label14 equal *tmp14 @memory-cell
+   72 jump *label14 equal *tmp13 @memory-cell
    73 jump *label13 always
    74 label *label14
    75 set .MEMORY :block
 
    79 set *tmp12 .SIZE
    80 jump *label6 always
    81 label *label13
-    * jump *label16 equal *tmp14 @vault
-    * jump *label16 equal *tmp14 @container
+   82 jump *label16 equal *tmp13 @vault
+   83 jump *label16 equal *tmp13 @container
    84 jump *label15 always
    85 label *label16
    86 set .CONTAINER :block
 
    95 set *tmp12 .B1
    96 jump *label6 always
    97 label *label15
-    * jump *label18 equal *tmp14 @battery
-    * jump *label18 equal *tmp14 @battery-large
+   98 jump *label18 equal *tmp13 @battery
+   99 jump *label18 equal *tmp13 @battery-large
   100 jump *label17 always
   101 label *label18
   102 set .CONTAINER :block
 
   111 set *tmp12 .B1
   112 jump *label6 always
   113 label *label17
-    * jump *label20 equal *tmp14 @liquid-tank
-    * jump *label20 equal *tmp14 @liquid-container
+  114 jump *label20 equal *tmp13 @liquid-tank
+  115 jump *label20 equal *tmp13 @liquid-container
   116 jump *label19 always
   117 label *label20
   118 set .CONTAINER :block
 
   127 set *tmp12 .B1
   128 jump *label6 always
   129 label *label19
-    * jump *label22 equal *tmp14 @power-node
-    * jump *label22 equal *tmp14 @power-node-large
-    * jump *label22 equal *tmp14 @surge-tower
+  130 jump *label22 equal *tmp13 @power-node
+  131 jump *label22 equal *tmp13 @power-node-large
+  132 jump *label22 equal *tmp13 @surge-tower
   133 jump *label21 always
   134 label *label22
   135 set .CONTAINER :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-17 instructions):
 
    49 jump *label7 always
    50 label *label8
    51 set .MESSAGE :block
-    * set *tmp12 .MESSAGE
    52 jump *label6 always
    53 label *label7
    54 jump *label10 equal *tmp13 @switch
    55 jump *label9 always
    56 label *label10
    57 set .SWITCH :block
-    * set *tmp12 .SWITCH
    58 jump *label6 always
    59 label *label9
    60 jump *label12 equal *tmp13 @memory-bank
 
    64 set .START_INDEX 264
    65 set .END_INDEX 511
    66 set .SIZE 248
-    * set *tmp12 .SIZE
    67 jump *label6 always
    68 label *label11
    69 jump *label14 equal *tmp13 @memory-cell
 
    73 set .START_INDEX 40
    74 set .END_INDEX 63
    75 set .SIZE 24
-    * set *tmp12 .SIZE
    76 jump *label6 always
    77 label *label13
    78 jump *label16 equal *tmp13 @vault
 
    88 set .R1 80
    89 set .G1 255
    90 set .B1 80
-    * set *tmp12 .B1
    91 jump *label6 always
    92 label *label15
    93 jump *label18 equal *tmp13 @battery
 
   103 set .R1 255
   104 set .G1 255
   105 set .B1 80
-    * set *tmp12 .B1
   106 jump *label6 always
   107 label *label17
   108 jump *label20 equal *tmp13 @liquid-tank
 
   118 set .R1 192
   119 set .G1 192
   120 set .B1 255
-    * set *tmp12 .B1
   121 jump *label6 always
   122 label *label19
   123 jump *label22 equal *tmp13 @power-node
 
   134 set .R1 255
   135 set .G1 255
   136 set .B1 80
-    * set *tmp12 .B1
   137 jump *label6 always
   138 label *label21
-    * set *tmp12 null
   139 label *label6
   140 label *label4
   141 jump *label3 always
 
   155 jump *label23 equal *tmp17 false
   156 print "\nNo memory or container."
   157 printflush .MESSAGE
-    * set *tmp19 null
   158 jump *label24 always
   159 label *label23
   160 printflush .MESSAGE
   161 jump *label2 always
-    * set *tmp19 null
   162 label *label24
   163 label *label1
   164 jump *label0 always
 
   204 set :prevTick *tmp50
   205 op add *tmp51 :prevTick .TICKS
   206 set :nextTick *tmp51
-    * set *tmp49 :nextTick
   207 jump *label29 always
   208 label *label28
-    * set *tmp49 null
   209 label *label29
   210 label *label30
   211 op lessThan *tmp52 @tick :nextTick
 
   213 op lessThan *tmp53 @tick :prevTick
   214 jump *label33 equal *tmp53 false
   215 end
-    * set *tmp54 null
   216 jump *label34 always
   217 label *label33
-    * set *tmp54 null
   218 label *label34
   219 label *label31
   220 jump *label30 always
 
   232 op greaterThan *tmp61 :index .END_INDEX
   233 jump *label35 equal *tmp61 false
   234 set :index .START_INDEX
-    * set *tmp62 :index
   235 jump *label36 always
   236 label *label35
-    * set *tmp62 null
   237 label *label36
   238 set *tmp63 .M_START_INDEX
   239 write :index .MEMORY *tmp63

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-34 instructions):
     0 set .TICKS 60
     1 set .M_START_INDEX 0
-    * op add *tmp0 .M_START_INDEX 1
-    * set .M_CURRENT_INDEX *tmp0
-    * op add *tmp1 .M_CURRENT_INDEX 1
-    * set .M_END_INDEX *tmp1
-    * op add *tmp2 .M_END_INDEX 1
-    * set .M_R0 *tmp2
-    * op add *tmp3 .M_R0 1
-    * set .M_G0 *tmp3
-    * op add *tmp4 .M_G0 1
-    * set .M_B0 *tmp4
-    * op add *tmp5 .M_B0 1
-    * set .M_R1 *tmp5
-    * op add *tmp6 .M_R1 1
-    * set .M_G1 *tmp6
-    * op add *tmp7 .M_G1 1
-    * set .M_B1 *tmp7
+    2 op add .M_CURRENT_INDEX .M_START_INDEX 1
+    3 op add .M_END_INDEX .M_CURRENT_INDEX 1
+    4 op add .M_R0 .M_END_INDEX 1
+    5 op add .M_G0 .M_R0 1
+    6 op add .M_B0 .M_G0 1
+    7 op add .M_R1 .M_B0 1
+    8 op add .M_G1 .M_R1 1
+    9 op add .M_B1 .M_G1 1
    10 set .B0 null
    11 set .B1 null
    12 set .END_INDEX null
 
    25 print "Item/Liquid/Energy Level Meter"
    26 set .CONTAINER null
    27 set .MEMORY null
-    * set *tmp8 @links
-    * set :n *tmp8
+   28 set :n @links
    29 label *label3
    30 op greaterThan *tmp9 :n 0
    31 jump *label5 equal *tmp9 false
-    * op sub *tmp10 :n 1
-    * set :n *tmp10
-    * getlink *tmp11 :n
-    * set :block *tmp11
+   32 op sub :n :n 1
+   33 getlink :block :n
    34 print "\nFound: "
    35 print :block
    36 sensor *tmp13 :block @type
 
   152 label *label1
   153 jump *label0 always
   154 label *label2
-    * set *tmp20 .M_START_INDEX
-    * write .START_INDEX .MEMORY *tmp20
-    * set *tmp22 .M_END_INDEX
-    * write .END_INDEX .MEMORY *tmp22
-    * set *tmp24 .M_R0
-    * write .R0 .MEMORY *tmp24
-    * set *tmp26 .M_G0
-    * write .G0 .MEMORY *tmp26
-    * set *tmp28 .M_B0
-    * write .B0 .MEMORY *tmp28
-    * set *tmp30 .M_R1
-    * write .R1 .MEMORY *tmp30
-    * set *tmp32 .M_G1
-    * write .G1 .MEMORY *tmp32
-    * set *tmp34 .M_B1
-    * write .B1 .MEMORY *tmp34
-    * set *tmp36 .M_CURRENT_INDEX
-    * read *tmp37 .MEMORY *tmp36
+  155 write .START_INDEX .MEMORY .M_START_INDEX
+  156 write .END_INDEX .MEMORY .M_END_INDEX
+  157 write .R0 .MEMORY .M_R0
+  158 write .G0 .MEMORY .M_G0
+  159 write .B0 .MEMORY .M_B0
+  160 write .R1 .MEMORY .M_R1
+  161 write .G1 .MEMORY .M_G1
+  162 write .B1 .MEMORY .M_B1
+  163 read *tmp37 .MEMORY .M_CURRENT_INDEX
   164 op max *tmp38 .START_INDEX *tmp37
-    * op min *tmp39 *tmp38 .END_INDEX
-    * set :index *tmp39
-    * set *tmp40 @tick
-    * set :nextTick *tmp40
-    * set *tmp41 .SWITCH
-    * control enabled *tmp41 0
+  165 op min :index *tmp38 .END_INDEX
+  166 set :nextTick @tick
+  167 control enabled .SWITCH 0
   168 label *label25
   169 sensor *tmp43 .SWITCH @enabled
   170 op equal *tmp44 *tmp43 0
   171 jump *label27 equal *tmp44 false
-    * set *tmp45 @time
-    * set :startTime *tmp45
+  172 set :startTime @time
   173 set :prevTick :nextTick
-    * op add *tmp46 :nextTick .TICKS
-    * set :nextTick *tmp46
+  174 op add :nextTick :nextTick .TICKS
   175 op add *tmp47 :nextTick .TICKS
   176 op greaterThan *tmp48 @tick *tmp47
   177 jump *label28 equal *tmp48 false
-    * set *tmp50 @tick
-    * set :prevTick *tmp50
-    * op add *tmp51 :prevTick .TICKS
-    * set :nextTick *tmp51
+  178 set :prevTick @tick
+  179 op add :nextTick :prevTick .TICKS
   180 jump *label29 always
   181 label *label28
   182 label *label29
 
   192 label *label31
   193 jump *label30 always
   194 label *label32
-    * sensor *tmp55 .CONTAINER .SENSOR
-    * set :amount *tmp55
-    * sensor *tmp56 .CONTAINER .MAXIMUM
-    * set :max *tmp56
+  195 sensor :amount .CONTAINER .SENSOR
+  196 sensor :max .CONTAINER .MAXIMUM
   197 op mul *tmp57 :amount 150
   198 op div *tmp58 *tmp57 :max
-    * op add *tmp59 10 *tmp58
-    * set :scaled *tmp59
-    * op add *tmp60 :index 1
-    * set :index *tmp60
+  199 op add :scaled 10 *tmp58
+  200 op add :index :index 1
   201 op greaterThan *tmp61 :index .END_INDEX
   202 jump *label35 equal *tmp61 false
   203 set :index .START_INDEX
   204 jump *label36 always
   205 label *label35
   206 label *label36
-    * set *tmp63 .M_START_INDEX
-    * write :index .MEMORY *tmp63
-    * set *tmp65 :index
-    * write :scaled .MEMORY *tmp65
+  207 write :index .MEMORY .M_START_INDEX
+  208 write :scaled .MEMORY :index
   209 op sub *tmp67 :index .SIZE
-    * set *tmp68 *tmp67
-    * write :scaled .MEMORY *tmp68
+  210 write :scaled .MEMORY *tmp67
   211 print "Item/Liquid/Energy Level Meter\n"
   212 print "StartIndex: "
   213 print .START_INDEX

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    21 set .START_INDEX null
    22 set .SWITCH null
    23 label *label0
-    * jump *label2 equal true false
    24 print "Item/Liquid/Energy Level Meter"
    25 set .CONTAINER null
    26 set .MEMORY null

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-8 instructions):
 
    33 print "\nFound: "
    34 print :block
    35 sensor *tmp13 :block @type
-    * jump *label8 equal *tmp13 @message
-    * jump *label7 always
+   36 jump *label7 notEqual *tmp13 @message
    37 label *label8
    38 set .MESSAGE :block
    39 jump *label6 always
    40 label *label7
-    * jump *label10 equal *tmp13 @switch
-    * jump *label9 always
+   41 jump *label9 notEqual *tmp13 @switch
    42 label *label10
    43 set .SWITCH :block
    44 jump *label6 always
    45 label *label9
-    * jump *label12 equal *tmp13 @memory-bank
-    * jump *label11 always
+   46 jump *label11 notEqual *tmp13 @memory-bank
    47 label *label12
    48 set .MEMORY :block
    49 set .START_INDEX 264
 
    51 set .SIZE 248
    52 jump *label6 always
    53 label *label11
-    * jump *label14 equal *tmp13 @memory-cell
-    * jump *label13 always
+   54 jump *label13 notEqual *tmp13 @memory-cell
    55 label *label14
    56 set .MEMORY :block
    57 set .START_INDEX 40
 
    60 jump *label6 always
    61 label *label13
    62 jump *label16 equal *tmp13 @vault
-    * jump *label16 equal *tmp13 @container
-    * jump *label15 always
+   63 jump *label15 notEqual *tmp13 @container
    64 label *label16
    65 set .CONTAINER :block
    66 set .SENSOR @totalItems
 
    74 jump *label6 always
    75 label *label15
    76 jump *label18 equal *tmp13 @battery
-    * jump *label18 equal *tmp13 @battery-large
-    * jump *label17 always
+   77 jump *label17 notEqual *tmp13 @battery-large
    78 label *label18
    79 set .CONTAINER :block
    80 set .SENSOR @totalPower
 
    88 jump *label6 always
    89 label *label17
    90 jump *label20 equal *tmp13 @liquid-tank
-    * jump *label20 equal *tmp13 @liquid-container
-    * jump *label19 always
+   91 jump *label19 notEqual *tmp13 @liquid-container
    92 label *label20
    93 set .CONTAINER :block
    94 set .SENSOR @totalLiquids
 
   103 label *label19
   104 jump *label22 equal *tmp13 @power-node
   105 jump *label22 equal *tmp13 @power-node-large
-    * jump *label22 equal *tmp13 @surge-tower
-    * jump *label21 always
+  106 jump *label21 notEqual *tmp13 @surge-tower
   107 label *label22
   108 set .CONTAINER :block
   109 set .SENSOR @powerNetStored

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-7 instructions):
 
    26 set .MEMORY null
    27 set :n @links
    28 label *label3
-    * op greaterThan *tmp9 :n 0
-    * jump *label5 equal *tmp9 false
+   29 jump *label5 lessThanEq :n 0
    30 op sub :n :n 1
    31 getlink :block :n
    32 print "\nFound: "
 
   130 op equal *tmp15 .CONTAINER null
   131 op equal *tmp16 .MEMORY null
   132 op or *tmp18 *tmp15 *tmp16
-    * op notEqual *tmp17 *tmp18 false
-    * jump *label23 equal *tmp17 false
+  133 jump *label23 equal *tmp18 false
   134 print "\nNo memory or container."
   135 printflush .MESSAGE
   136 jump *label24 always
 
   156 control enabled .SWITCH 0
   157 label *label25
   158 sensor *tmp43 .SWITCH @enabled
-    * op equal *tmp44 *tmp43 0
-    * jump *label27 equal *tmp44 false
+  159 jump *label27 notEqual *tmp43 0
   160 set :startTime @time
   161 set :prevTick :nextTick
   162 op add :nextTick :nextTick .TICKS
   163 op add *tmp47 :nextTick .TICKS
-    * op greaterThan *tmp48 @tick *tmp47
-    * jump *label28 equal *tmp48 false
+  164 jump *label28 lessThanEq @tick *tmp47
   165 set :prevTick @tick
   166 op add :nextTick :prevTick .TICKS
   167 jump *label29 always
   168 label *label28
   169 label *label29
   170 label *label30
-    * op lessThan *tmp52 @tick :nextTick
-    * jump *label32 equal *tmp52 false
-    * op lessThan *tmp53 @tick :prevTick
-    * jump *label33 equal *tmp53 false
+  171 jump *label32 greaterThanEq @tick :nextTick
+  172 jump *label33 greaterThanEq @tick :prevTick
   173 end
   174 jump *label34 always
   175 label *label33
 
   183 op div *tmp58 *tmp57 :max
   184 op add :scaled 10 *tmp58
   185 op add :index :index 1
-    * op greaterThan *tmp61 :index .END_INDEX
-    * jump *label35 equal *tmp61 false
+  186 jump *label35 lessThanEq :index .END_INDEX
   187 set :index .START_INDEX
   188 jump *label36 always
   189 label *label35

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
   113 set .R1 255
   114 set .G1 255
   115 set .B1 80
-    * jump *label6 always
   116 label *label21
   117 label *label6
   118 label *label4
 
   163 jump *label28 lessThanEq @tick *tmp47
   164 set :prevTick @tick
   165 op add :nextTick :prevTick .TICKS
-    * jump *label29 always
   166 label *label28
   167 label *label29
   168 label *label30
   169 jump *label32 greaterThanEq @tick :nextTick
   170 jump *label33 greaterThanEq @tick :prevTick
   171 end
-    * jump *label34 always
   172 label *label33
   173 label *label34
   174 label *label31
 
   182 op add :index :index 1
   183 jump *label35 lessThanEq :index .END_INDEX
   184 set :index .START_INDEX
-    * jump *label36 always
   185 label *label35
   186 label *label36
   187 write :index .MEMORY .M_START_INDEX

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set .TICKS 60
     1 set .M_START_INDEX 0
-    * op add .M_CURRENT_INDEX .M_START_INDEX 1
-    * op add .M_END_INDEX .M_CURRENT_INDEX 1
-    * op add .M_R0 .M_END_INDEX 1
-    * op add .M_G0 .M_R0 1
-    * op add .M_B0 .M_G0 1
-    * op add .M_R1 .M_B0 1
-    * op add .M_G1 .M_R1 1
-    * op add .M_B1 .M_G1 1
+    2 op add .M_CURRENT_INDEX 0 1
+    3 op add .M_END_INDEX 1 1
+    4 op add .M_R0 2 1
+    5 op add .M_G0 3 1
+    6 op add .M_B0 4 1
+    7 op add .M_R1 5 1
+    8 op add .M_G1 6 1
+    9 op add .M_B1 7 1
    10 set .B0 null
    11 set .B1 null
    12 set .END_INDEX null
 
   140 label *label1
   141 jump *label0 always
   142 label *label2
-    * write .START_INDEX .MEMORY .M_START_INDEX
-    * write .END_INDEX .MEMORY .M_END_INDEX
-    * write .R0 .MEMORY .M_R0
-    * write .G0 .MEMORY .M_G0
-    * write .B0 .MEMORY .M_B0
-    * write .R1 .MEMORY .M_R1
-    * write .G1 .MEMORY .M_G1
-    * write .B1 .MEMORY .M_B1
-    * read *tmp37 .MEMORY .M_CURRENT_INDEX
+  143 write .START_INDEX .MEMORY 0
+  144 write .END_INDEX .MEMORY 2
+  145 write .R0 .MEMORY 3
+  146 write .G0 .MEMORY 4
+  147 write .B0 .MEMORY 5
+  148 write .R1 .MEMORY 6
+  149 write .G1 .MEMORY 7
+  150 write .B1 .MEMORY 8
+  151 read *tmp37 .MEMORY 1
   152 op max *tmp38 .START_INDEX *tmp37
   153 op min :index *tmp38 .END_INDEX
   154 set :nextTick @tick
 
   158 jump *label27 notEqual *tmp43 0
   159 set :startTime @time
   160 set :prevTick :nextTick
-    * op add :nextTick :nextTick .TICKS
-    * op add *tmp47 :nextTick .TICKS
+  161 op add :nextTick :nextTick 60
+  162 op add *tmp47 :nextTick 60
   163 jump *label28 lessThanEq @tick *tmp47
   164 set :prevTick @tick
-    * op add :nextTick :prevTick .TICKS
+  165 op add :nextTick :prevTick 60
   166 label *label28
   167 label *label29
   168 label *label30
 
   184 set :index .START_INDEX
   185 label *label35
   186 label *label36
-    * write :index .MEMORY .M_START_INDEX
+  187 write :index .MEMORY 0
   188 write :scaled .MEMORY :index
   189 op sub *tmp67 :index .SIZE
   190 write :scaled .MEMORY *tmp67

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-10 instructions):
-    * set .TICKS 60
-    * set .M_START_INDEX 0
-    * op add .M_CURRENT_INDEX 0 1
-    * op add .M_END_INDEX 1 1
-    * op add .M_R0 2 1
-    * op add .M_G0 3 1
-    * op add .M_B0 4 1
-    * op add .M_R1 5 1
-    * op add .M_G1 6 1
-    * op add .M_B1 7 1
     0 set .B0 null
     1 set .B1 null
     2 set .END_INDEX null

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    17 set :n @links
    18 label *label3
    19 jump *label5 lessThanEq :n 0
+   20 label *label37
    21 op sub :n :n 1
    22 getlink :block :n
    23 print "\nFound: "
 
   107 label *label21
   108 label *label6
   109 label *label4
-    * jump *label3 always
+  110 jump *label37 greaterThan :n 0
   111 label *label5
   112 print "\nMessage: "
   113 print .MESSAGE
 
   158 label *label29
   159 label *label30
   160 jump *label32 greaterThanEq @tick :nextTick
+  161 label *label38
   162 jump *label33 greaterThanEq @tick :prevTick
   163 end
   164 label *label33
   165 label *label34
   166 label *label31
-    * jump *label30 always
+  167 jump *label38 lessThan @tick :nextTick
   168 label *label32
   169 sensor :amount .CONTAINER .SENSOR
   170 sensor :max .CONTAINER .MAXIMUM

Modifications by Replicate loop condition at line 119:1 (+1 instructions):
 
   147 label *label25
   148 sensor *tmp43 .SWITCH @enabled
   149 jump *label27 notEqual *tmp43 0
+  150 label *label39
   151 set :startTime @time
   152 set :prevTick :nextTick
   153 op add :nextTick :nextTick 60
 
   200 print "\n"
   201 printflush .MESSAGE
   202 label *label26
-    * jump *label25 always
+  203 sensor *tmp43 .SWITCH @enabled
+  204 jump *label39 equal *tmp43 0
   205 label *label27
   206 end

Modifications by Convert case at line 31:9 (segments: 1, padded low) (+136 instructions):
 
    23 print "\nFound: "
    24 print :block
    25 sensor *tmp13 :block @type
-    * jump *label7 notEqual *tmp13 @message
+   26 sensor *tmp71 *tmp13 @id
+   27 jump *label40 greaterThanEq *tmp71 147
+   28 multijump *label42 *tmp71 0 (m:*label41)
+   29 multilabel *label42 (m:*label41)
+   30 jump *label40 always
+   31 multilabel *label43 (m:*label41)
+   32 jump *label40 always
+   33 multilabel *label44 (m:*label41)
+   34 jump *label40 always
+   35 multilabel *label45 (m:*label41)
+   36 jump *label40 always
+   37 multilabel *label46 (m:*label41)
+   38 jump *label40 always
+   39 multilabel *label47 (m:*label41)
+   40 jump *label40 always
+   41 multilabel *label48 (m:*label41)
+   42 jump *label40 always
+   43 multilabel *label49 (m:*label41)
+   44 jump *label40 always
+   45 multilabel *label50 (m:*label41)
+   46 jump *label40 always
+   47 multilabel *label51 (m:*label41)
+   48 jump *label40 always
+   49 multilabel *label52 (m:*label41)
+   50 jump *label40 always
+   51 multilabel *label53 (m:*label41)
+   52 jump *label40 always
+   53 multilabel *label54 (m:*label41)
+   54 jump *label40 always
+   55 multilabel *label55 (m:*label41)
+   56 jump *label40 always
+   57 multilabel *label56 (m:*label41)
+   58 jump *label40 always
+   59 multilabel *label57 (m:*label41)
+   60 jump *label40 always
+   61 multilabel *label58 (m:*label41)
+   62 jump *label40 always
+   63 multilabel *label59 (m:*label41)
+   64 jump *label40 always
+   65 multilabel *label60 (m:*label41)
+   66 jump *label40 always
+   67 multilabel *label61 (m:*label41)
+   68 jump *label40 always
+   69 multilabel *label62 (m:*label41)
+   70 jump *label40 always
+   71 multilabel *label63 (m:*label41)
+   72 jump *label40 always
+   73 multilabel *label64 (m:*label41)
+   74 jump *label40 always
+   75 multilabel *label65 (m:*label41)
+   76 jump *label40 always
+   77 multilabel *label66 (m:*label41)
+   78 jump *label40 always
+   79 multilabel *label67 (m:*label41)
+   80 jump *label40 always
+   81 multilabel *label68 (m:*label41)
+   82 jump *label40 always
+   83 multilabel *label69 (m:*label41)
+   84 jump *label40 always
+   85 multilabel *label70 (m:*label41)
+   86 jump *label40 always
+   87 multilabel *label71 (m:*label41)
+   88 jump *label40 always
+   89 multilabel *label72 (m:*label41)
+   90 jump *label40 always
+   91 multilabel *label73 (m:*label41)
+   92 jump *label40 always
+   93 multilabel *label74 (m:*label41)
+   94 jump *label40 always
+   95 multilabel *label75 (m:*label41)
+   96 jump *label40 always
+   97 multilabel *label76 (m:*label41)
+   98 jump *label40 always
+   99 multilabel *label77 (m:*label41)
+  100 jump *label40 always
+  101 multilabel *label78 (m:*label41)
+  102 jump *label40 always
+  103 multilabel *label79 (m:*label41)
+  104 jump *label40 always
+  105 multilabel *label80 (m:*label41)
+  106 jump *label40 always
+  107 multilabel *label81 (m:*label41)
+  108 jump *label40 always
+  109 multilabel *label82 (m:*label41)
+  110 jump *label40 always
+  111 multilabel *label83 (m:*label41)
+  112 jump *label40 always
+  113 multilabel *label84 (m:*label41)
+  114 jump *label40 always
+  115 multilabel *label85 (m:*label41)
+  116 jump *label40 always
+  117 multilabel *label86 (m:*label41)
+  118 jump *label40 always
+  119 multilabel *label87 (m:*label41)
+  120 jump *label40 always
+  121 multilabel *label88 (m:*label41)
+  122 jump *label40 always
+  123 multilabel *label89 (m:*label41)
+  124 jump *label40 always
+  125 multilabel *label90 (m:*label41)
+  126 jump *label40 always
+  127 multilabel *label91 (m:*label41)
+  128 jump *label40 always
+  129 multilabel *label92 (m:*label41)
+  130 jump *label40 always
+  131 multilabel *label93 (m:*label41)
+  132 jump *label40 always
+  133 multilabel *label94 (m:*label41)
+  134 jump *label40 always
+  135 multilabel *label95 (m:*label41)
+  136 jump *label40 always
+  137 multilabel *label96 (m:*label41)
+  138 jump *label40 always
+  139 multilabel *label97 (m:*label41)
+  140 jump *label40 always
+  141 multilabel *label98 (m:*label41)
+  142 jump *label40 always
+  143 multilabel *label99 (m:*label41)
+  144 jump *label40 always
+  145 multilabel *label100 (m:*label41)
+  146 jump *label40 always
+  147 multilabel *label101 (m:*label41)
+  148 jump *label40 always
+  149 multilabel *label102 (m:*label41)
+  150 jump *label40 always
+  151 multilabel *label103 (m:*label41)
+  152 jump *label40 always
+  153 multilabel *label104 (m:*label41)
+  154 jump *label40 always
+  155 multilabel *label105 (m:*label41)
+  156 jump *label40 always
+  157 multilabel *label106 (m:*label41)
+  158 jump *label20 always
+  159 multilabel *label107 (m:*label41)
+  160 jump *label40 always
+  161 multilabel *label108 (m:*label41)
+  162 jump *label40 always
+  163 multilabel *label109 (m:*label41)
+  164 jump *label40 always
+  165 multilabel *label110 (m:*label41)
+  166 jump *label22 always
+  167 multilabel *label111 (m:*label41)
+  168 jump *label22 always
+  169 multilabel *label112 (m:*label41)
+  170 jump *label22 always
+  171 multilabel *label113 (m:*label41)
+  172 jump *label40 always
+  173 multilabel *label114 (m:*label41)
+  174 jump *label18 always
+  175 multilabel *label115 (m:*label41)
+  176 jump *label18 always
+  177 multilabel *label116 (m:*label41)
+  178 jump *label40 always
+  179 multilabel *label117 (m:*label41)
+  180 jump *label40 always
+  181 multilabel *label118 (m:*label41)
+  182 jump *label40 always
+  183 multilabel *label119 (m:*label41)
+  184 jump *label40 always
+  185 multilabel *label120 (m:*label41)
+  186 jump *label40 always
+  187 multilabel *label121 (m:*label41)
+  188 jump *label40 always
+  189 multilabel *label122 (m:*label41)
+  190 jump *label40 always
+  191 multilabel *label123 (m:*label41)
+  192 jump *label40 always
+  193 multilabel *label124 (m:*label41)
+  194 jump *label40 always
+  195 multilabel *label125 (m:*label41)
+  196 jump *label40 always
+  197 multilabel *label126 (m:*label41)
+  198 jump *label40 always
+  199 multilabel *label127 (m:*label41)
+  200 jump *label40 always
+  201 multilabel *label128 (m:*label41)
+  202 jump *label40 always
+  203 multilabel *label129 (m:*label41)
+  204 jump *label40 always
+  205 multilabel *label130 (m:*label41)
+  206 jump *label40 always
+  207 multilabel *label131 (m:*label41)
+  208 jump *label40 always
+  209 multilabel *label132 (m:*label41)
+  210 jump *label40 always
+  211 multilabel *label133 (m:*label41)
+  212 jump *label40 always
+  213 multilabel *label134 (m:*label41)
+  214 jump *label40 always
+  215 multilabel *label135 (m:*label41)
+  216 jump *label16 always
+  217 multilabel *label136 (m:*label41)
+  218 jump *label16 always
+  219 multilabel *label137 (m:*label41)
+  220 jump *label40 always
+  221 multilabel *label138 (m:*label41)
+  222 jump *label40 always
+  223 multilabel *label139 (m:*label41)
+  224 jump *label40 always
+  225 multilabel *label140 (m:*label41)
+  226 jump *label40 always
+  227 multilabel *label141 (m:*label41)
+  228 jump *label40 always
+  229 multilabel *label142 (m:*label41)
+  230 jump *label40 always
+  231 multilabel *label143 (m:*label41)
+  232 jump *label40 always
+  233 multilabel *label144 (m:*label41)
+  234 jump *label40 always
+  235 multilabel *label145 (m:*label41)
+  236 jump *label40 always
+  237 multilabel *label146 (m:*label41)
+  238 jump *label40 always
+  239 multilabel *label147 (m:*label41)
+  240 jump *label40 always
+  241 multilabel *label148 (m:*label41)
+  242 jump *label40 always
+  243 multilabel *label149 (m:*label41)
+  244 jump *label40 always
+  245 multilabel *label150 (m:*label41)
+  246 jump *label40 always
+  247 multilabel *label151 (m:*label41)
+  248 jump *label40 always
+  249 multilabel *label152 (m:*label41)
+  250 jump *label40 always
+  251 multilabel *label153 (m:*label41)
+  252 jump *label40 always
+  253 multilabel *label154 (m:*label41)
+  254 jump *label40 always
+  255 multilabel *label155 (m:*label41)
+  256 jump *label40 always
+  257 multilabel *label156 (m:*label41)
+  258 jump *label40 always
+  259 multilabel *label157 (m:*label41)
+  260 jump *label40 always
+  261 multilabel *label158 (m:*label41)
+  262 jump *label40 always
+  263 multilabel *label159 (m:*label41)
+  264 jump *label40 always
+  265 multilabel *label160 (m:*label41)
+  266 jump *label40 always
+  267 multilabel *label161 (m:*label41)
+  268 jump *label40 always
+  269 multilabel *label162 (m:*label41)
+  270 jump *label40 always
+  271 multilabel *label163 (m:*label41)
+  272 jump *label40 always
+  273 multilabel *label164 (m:*label41)
+  274 jump *label40 always
+  275 multilabel *label165 (m:*label41)
+  276 jump *label40 always
+  277 multilabel *label166 (m:*label41)
+  278 jump *label40 always
+  279 multilabel *label167 (m:*label41)
+  280 jump *label40 always
+  281 multilabel *label168 (m:*label41)
+  282 jump *label40 always
+  283 multilabel *label169 (m:*label41)
+  284 jump *label40 always
+  285 multilabel *label170 (m:*label41)
+  286 jump *label40 always
+  287 multilabel *label171 (m:*label41)
+  288 jump *label40 always
+  289 multilabel *label172 (m:*label41)
+  290 jump *label40 always
+  291 multilabel *label173 (m:*label41)
+  292 jump *label40 always
+  293 multilabel *label174 (m:*label41)
+  294 jump *label40 always
+  295 multilabel *label175 (m:*label41)
+  296 jump *label40 always
+  297 multilabel *label176 (m:*label41)
+  298 jump *label40 always
+  299 multilabel *label177 (m:*label41)
+  300 jump *label40 always
+  301 multilabel *label178 (m:*label41)
+  302 jump *label40 always
+  303 multilabel *label179 (m:*label41)
+  304 jump *label8 always
+  305 multilabel *label180 (m:*label41)
+  306 jump *label10 always
+  307 multilabel *label181 (m:*label41)
+  308 jump *label40 always
+  309 multilabel *label182 (m:*label41)
+  310 jump *label40 always
+  311 multilabel *label183 (m:*label41)
+  312 jump *label40 always
+  313 multilabel *label184 (m:*label41)
+  314 jump *label14 always
+  315 multilabel *label185 (m:*label41)
+  316 jump *label12 always
+  317 multilabel *label186 (m:*label41)
+  318 jump *label40 always
+  319 multilabel *label187 (m:*label41)
+  320 jump *label40 always
+  321 multilabel *label188 (m:*label41)
+  322 label *label20
+  323 set .CONTAINER :block
+  324 set .SENSOR @totalLiquids
+  325 set .MAXIMUM @liquidCapacity
+  326 set .R0 0
+  327 set .G0 0
+  328 set .B0 192
+  329 set .R1 192
+  330 set .G1 192
+  331 set .B1 255
+  332 jump *label6 always
   333 label *label8
   334 set .MESSAGE :block
   335 jump *label6 always
   336 label *label7
-    * jump *label9 notEqual *tmp13 @switch
   337 label *label10
   338 set .SWITCH :block
   339 jump *label6 always
   340 label *label9
-    * jump *label11 notEqual *tmp13 @memory-bank
   341 label *label12
   342 set .MEMORY :block
   343 set .START_INDEX 264
 
   345 set .SIZE 248
   346 jump *label6 always
   347 label *label11
-    * jump *label13 notEqual *tmp13 @memory-cell
   348 label *label14
   349 set .MEMORY :block
   350 set .START_INDEX 40
 
   352 set .SIZE 24
   353 jump *label6 always
   354 label *label13
-    * jump *label16 equal *tmp13 @vault
-    * jump *label15 notEqual *tmp13 @container
   355 label *label16
   356 set .CONTAINER :block
   357 set .SENSOR @totalItems
 
   364 set .B1 80
   365 jump *label6 always
   366 label *label15
-    * jump *label18 equal *tmp13 @battery
-    * jump *label17 notEqual *tmp13 @battery-large
   367 label *label18
   368 set .CONTAINER :block
   369 set .SENSOR @totalPower
 
   376 set .B1 80
   377 jump *label6 always
   378 label *label17
-    * jump *label20 equal *tmp13 @liquid-tank
-    * jump *label19 notEqual *tmp13 @liquid-container
-    * label *label20
-    * set .CONTAINER :block
-    * set .SENSOR @totalLiquids
-    * set .MAXIMUM @liquidCapacity
-    * set .R0 0
-    * set .G0 0
-    * set .B0 192
-    * set .R1 192
-    * set .G1 192
-    * set .B1 255
-    * jump *label6 always
   379 label *label19
-    * jump *label22 equal *tmp13 @power-node
-    * jump *label22 equal *tmp13 @power-node-large
-    * jump *label21 notEqual *tmp13 @surge-tower
   380 label *label22
   381 set .CONTAINER :block
   382 set .SENSOR @powerNetStored
 
   388 set .G1 255
   389 set .B1 80
   390 label *label21
+  391 label *label40
   392 label *label6
   393 label *label4
   394 jump *label37 greaterThan :n 0

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
    15 set .CONTAINER null
    16 set .MEMORY null
    17 set :n @links
-    * label *label3
    18 jump *label5 lessThanEq :n 0
    19 label *label37
    20 op sub :n :n 1
 
   332 label *label8
   333 set .MESSAGE :block
   334 jump *label6 always
-    * label *label7
   335 label *label10
   336 set .SWITCH :block
   337 jump *label6 always
-    * label *label9
   338 label *label12
   339 set .MEMORY :block
   340 set .START_INDEX 264
   341 set .END_INDEX 511
   342 set .SIZE 248
   343 jump *label6 always
-    * label *label11
   344 label *label14
   345 set .MEMORY :block
   346 set .START_INDEX 40
   347 set .END_INDEX 63
   348 set .SIZE 24
   349 jump *label6 always
-    * label *label13
   350 label *label16
   351 set .CONTAINER :block
   352 set .SENSOR @totalItems
 
   358 set .G1 255
   359 set .B1 80
   360 jump *label6 always
-    * label *label15
   361 label *label18
   362 set .CONTAINER :block
   363 set .SENSOR @totalPower
 
   369 set .G1 255
   370 set .B1 80
   371 jump *label6 always
-    * label *label17
-    * label *label19
   372 label *label22
   373 set .CONTAINER :block
   374 set .SENSOR @powerNetStored
 
   379 set .R1 255
   380 set .G1 255
   381 set .B1 80
-    * label *label21
   382 label *label40
   383 label *label6
-    * label *label4
   384 jump *label37 greaterThan :n 0
   385 label *label5
   386 print "\nMessage: "
 
   402 printflush .MESSAGE
   403 jump *label2 always
   404 label *label24
-    * label *label1
   405 jump *label0 always
   406 label *label2
   407 write .START_INDEX .MEMORY 0
 
   417 op min :index *tmp38 .END_INDEX
   418 set :nextTick @tick
   419 control enabled .SWITCH 0
-    * label *label25
   420 sensor *tmp43 .SWITCH @enabled
   421 jump *label27 notEqual *tmp43 0
   422 label *label39
 
   428 set :prevTick @tick
   429 op add :nextTick :prevTick 60
   430 label *label28
-    * label *label29
-    * label *label30
   431 jump *label32 greaterThanEq @tick :nextTick
   432 label *label38
   433 jump *label33 greaterThanEq @tick :prevTick
   434 end
   435 label *label33
-    * label *label34
-    * label *label31
   436 jump *label38 lessThan @tick :nextTick
   437 label *label32
   438 sensor :amount .CONTAINER .SENSOR
 
   444 jump *label35 lessThanEq :index .END_INDEX
   445 set :index .START_INDEX
   446 label *label35
-    * label *label36
   447 write :index .MEMORY 0
   448 write :scaled .MEMORY :index
   449 op sub *tmp67 :index .SIZE
 
   466 print *tmp70
   467 print "\n"
   468 printflush .MESSAGE
-    * label *label26
   469 sensor *tmp43 .SWITCH @enabled
   470 jump *label39 equal *tmp43 0
   471 label *label27

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
+    0 label __start__
     1 set .B0 null
     2 set .B1 null
     3 set .END_INDEX null
 
   398 jump *label23 equal *tmp18 false
   399 print "\nNo memory or container."
   400 printflush .MESSAGE
-    * jump *label24 always
+  401 jump *label0 always
   402 label *label23
   403 printflush .MESSAGE
   404 jump *label2 always
 
   419 set :nextTick @tick
   420 control enabled .SWITCH 0
   421 sensor *tmp43 .SWITCH @enabled
-    * jump *label27 notEqual *tmp43 0
+  422 jump __start__ notEqual *tmp43 0
   423 label *label39
   424 set :startTime @time
   425 set :prevTick :nextTick

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-1 instructions):
 
   402 label *label23
   403 printflush .MESSAGE
   404 jump *label2 always
-    * label *label24
-    * jump *label0 always
   405 label *label2
   406 write .START_INDEX .MEMORY 0
   407 write .END_INDEX .MEMORY 2
 
   467 printflush .MESSAGE
   468 sensor *tmp43 .SWITCH @enabled
   469 jump *label39 equal *tmp43 0
-    * label *label27
   470 end

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-2 instructions):
 
   401 jump *label0 always
   402 label *label23
   403 printflush .MESSAGE
-    * jump *label2 always
   404 label *label2
   405 write .START_INDEX .MEMORY 0
   406 write .END_INDEX .MEMORY 2
 
   466 printflush .MESSAGE
   467 sensor *tmp43 .SWITCH @enabled
   468 jump *label39 equal *tmp43 0
-    * end

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
   401 jump *label0 always
   402 label *label23
   403 printflush .MESSAGE
-    * label *label2
   404 write .START_INDEX .MEMORY 0
   405 write .END_INDEX .MEMORY 2
   406 write .R0 .MEMORY 3

Modifications by Final phase, Print Merging, iteration 1 (-5 instructions):
 
   445 write :scaled .MEMORY :index
   446 op sub *tmp67 :index .SIZE
   447 write :scaled .MEMORY *tmp67
-    * print "Item/Liquid/Energy Level Meter\n"
-    * print "StartIndex: "
+  448 print "Item/Liquid/Energy Level Meter\nStartIndex: "
   449 print .START_INDEX
-    * print "\n"
-    * print "Index: "
+  450 print "\nIndex: "
   451 print :index
-    * print "\n"
-    * print "Amount: "
+  452 print "\nAmount: "
   453 print :amount
-    * print "\n"
-    * print "Scaled: "
+  454 print "\nScaled: "
   455 print :scaled
-    * print "\n"
   456 op sub *tmp70 @time :startTime
-    * print "Elapsed: "
+  457 print "\nElapsed: "
   458 print *tmp70
   459 print "\n"
   460 printflush .MESSAGE

Final code before resolving virtual instructions:

        label __start__                                              B0 = null; B1 = null; END_INDEX = null; G0 = null; G1 = null; MAXIMUM = null; MESSAGE = null;
    0:  set .B0 null                                                 ...
    1:  set .B1 null                                                 ...
    2:  set .END_INDEX null                                          ...
    3:  set .G0 null                                                 ...
    4:  set .G1 null                                                 ...
    5:  set .MAXIMUM null                                            ...
    6:  set .MESSAGE null                                            ...
    7:  set .R0 null                                                 R0 = null; R1 = null; SENSOR = null; SIZE = null; START_INDEX = null; SWITCH = null;
    8:  set .R1 null                                                 ...
    9:  set .SENSOR null                                             ...
   10:  set .SIZE null                                               ...
   11:  set .START_INDEX null                                        ...
   12:  set .SWITCH null                                             ...
        label *label0                                                while true do
   13:  print "Item/Liquid/Energy Level Meter"                       print("Item/Liquid/Energy Level Meter");
   14:  set .CONTAINER null                                          CONTAINER = null;
   15:  set .MEMORY null                                             MEMORY = null;
   16:  set :n @links                                                n = @links;
   17:  jump *label5 lessThanEq :n 0                                 while n > 0 do
        label *label37                                               ...
   18:  op sub :n :n 1                                               n = n - 1;
   19:  getlink :block :n                                            block = getlink(n);
   20:  print "\nFound: "                                            print("\nFound: ", block);
   21:  print :block                                                 ...
   22:  sensor *tmp13 :block @type                                   case block.@type
   23:  sensor *tmp71 *tmp13 @id                                     while n > 0 do
   24:  jump *label40 greaterThanEq *tmp71 147                       case block.@type
   25:  multijump *label42 *tmp71 0                                  ...
        multilabel *label42                                          ...
   26:  jump *label40 always 0 0                                     ...
        multilabel *label43                                          ...
   27:  jump *label40 always 0 0                                     ...
        multilabel *label44                                          ...
   28:  jump *label40 always 0 0                                     ...
        multilabel *label45                                          ...
   29:  jump *label40 always 0 0                                     ...
        multilabel *label46                                          ...
   30:  jump *label40 always 0 0                                     ...
        multilabel *label47                                          ...
   31:  jump *label40 always 0 0                                     ...
        multilabel *label48                                          ...
   32:  jump *label40 always 0 0                                     ...
        multilabel *label49                                          ...
   33:  jump *label40 always 0 0                                     ...
        multilabel *label50                                          ...
   34:  jump *label40 always 0 0                                     ...
        multilabel *label51                                          ...
   35:  jump *label40 always 0 0                                     ...
        multilabel *label52                                          ...
   36:  jump *label40 always 0 0                                     ...
        multilabel *label53                                          ...
   37:  jump *label40 always 0 0                                     ...
        multilabel *label54                                          ...
   38:  jump *label40 always 0 0                                     ...
        multilabel *label55                                          ...
   39:  jump *label40 always 0 0                                     ...
        multilabel *label56                                          ...
   40:  jump *label40 always 0 0                                     ...
        multilabel *label57                                          ...
   41:  jump *label40 always 0 0                                     ...
        multilabel *label58                                          ...
   42:  jump *label40 always 0 0                                     ...
        multilabel *label59                                          ...
   43:  jump *label40 always 0 0                                     ...
        multilabel *label60                                          ...
   44:  jump *label40 always 0 0                                     ...
        multilabel *label61                                          ...
   45:  jump *label40 always 0 0                                     ...
        multilabel *label62                                          ...
   46:  jump *label40 always 0 0                                     ...
        multilabel *label63                                          ...
   47:  jump *label40 always 0 0                                     ...
        multilabel *label64                                          ...
   48:  jump *label40 always 0 0                                     ...
        multilabel *label65                                          ...
   49:  jump *label40 always 0 0                                     ...
        multilabel *label66                                          ...
   50:  jump *label40 always 0 0                                     ...
        multilabel *label67                                          ...
   51:  jump *label40 always 0 0                                     ...
        multilabel *label68                                          ...
   52:  jump *label40 always 0 0                                     ...
        multilabel *label69                                          ...
   53:  jump *label40 always 0 0                                     ...
        multilabel *label70                                          ...
   54:  jump *label40 always 0 0                                     ...
        multilabel *label71                                          ...
   55:  jump *label40 always 0 0                                     ...
        multilabel *label72                                          ...
   56:  jump *label40 always 0 0                                     ...
        multilabel *label73                                          ...
   57:  jump *label40 always 0 0                                     ...
        multilabel *label74                                          ...
   58:  jump *label40 always 0 0                                     ...
        multilabel *label75                                          ...
   59:  jump *label40 always 0 0                                     ...
        multilabel *label76                                          ...
   60:  jump *label40 always 0 0                                     ...
        multilabel *label77                                          ...
   61:  jump *label40 always 0 0                                     ...
        multilabel *label78                                          ...
   62:  jump *label40 always 0 0                                     ...
        multilabel *label79                                          ...
   63:  jump *label40 always 0 0                                     ...
        multilabel *label80                                          ...
   64:  jump *label40 always 0 0                                     ...
        multilabel *label81                                          ...
   65:  jump *label40 always 0 0                                     ...
        multilabel *label82                                          ...
   66:  jump *label40 always 0 0                                     ...
        multilabel *label83                                          ...
   67:  jump *label40 always 0 0                                     ...
        multilabel *label84                                          ...
   68:  jump *label40 always 0 0                                     ...
        multilabel *label85                                          ...
   69:  jump *label40 always 0 0                                     ...
        multilabel *label86                                          ...
   70:  jump *label40 always 0 0                                     ...
        multilabel *label87                                          ...
   71:  jump *label40 always 0 0                                     ...
        multilabel *label88                                          ...
   72:  jump *label40 always 0 0                                     ...
        multilabel *label89                                          ...
   73:  jump *label40 always 0 0                                     ...
        multilabel *label90                                          ...
   74:  jump *label40 always 0 0                                     ...
        multilabel *label91                                          ...
   75:  jump *label40 always 0 0                                     ...
        multilabel *label92                                          ...
   76:  jump *label40 always 0 0                                     ...
        multilabel *label93                                          ...
   77:  jump *label40 always 0 0                                     ...
        multilabel *label94                                          ...
   78:  jump *label40 always 0 0                                     ...
        multilabel *label95                                          ...
   79:  jump *label40 always 0 0                                     ...
        multilabel *label96                                          ...
   80:  jump *label40 always 0 0                                     ...
        multilabel *label97                                          ...
   81:  jump *label40 always 0 0                                     ...
        multilabel *label98                                          ...
   82:  jump *label40 always 0 0                                     ...
        multilabel *label99                                          ...
   83:  jump *label40 always 0 0                                     ...
        multilabel *label100                                         ...
   84:  jump *label40 always 0 0                                     ...
        multilabel *label101                                         ...
   85:  jump *label40 always 0 0                                     ...
        multilabel *label102                                         ...
   86:  jump *label40 always 0 0                                     ...
        multilabel *label103                                         ...
   87:  jump *label40 always 0 0                                     ...
        multilabel *label104                                         ...
   88:  jump *label40 always 0 0                                     ...
        multilabel *label105                                         ...
   89:  jump *label40 always 0 0                                     ...
        multilabel *label106                                         ...
   90:  jump *label20 always 0 0                                     ...
        multilabel *label107                                         ...
   91:  jump *label40 always 0 0                                     ...
        multilabel *label108                                         ...
   92:  jump *label40 always 0 0                                     ...
        multilabel *label109                                         ...
   93:  jump *label40 always 0 0                                     ...
        multilabel *label110                                         ...
   94:  jump *label22 always 0 0                                     ...
        multilabel *label111                                         ...
   95:  jump *label22 always 0 0                                     ...
        multilabel *label112                                         ...
   96:  jump *label22 always 0 0                                     ...
        multilabel *label113                                         ...
   97:  jump *label40 always 0 0                                     ...
        multilabel *label114                                         ...
   98:  jump *label18 always 0 0                                     ...
        multilabel *label115                                         ...
   99:  jump *label18 always 0 0                                     ...
        multilabel *label116                                         ...
  100:  jump *label40 always 0 0                                     ...
        multilabel *label117                                         ...
  101:  jump *label40 always 0 0                                     ...
        multilabel *label118                                         ...
  102:  jump *label40 always 0 0                                     ...
        multilabel *label119                                         ...
  103:  jump *label40 always 0 0                                     ...
        multilabel *label120                                         ...
  104:  jump *label40 always 0 0                                     ...
        multilabel *label121                                         ...
  105:  jump *label40 always 0 0                                     ...
        multilabel *label122                                         ...
  106:  jump *label40 always 0 0                                     ...
        multilabel *label123                                         ...
  107:  jump *label40 always 0 0                                     ...
        multilabel *label124                                         ...
  108:  jump *label40 always 0 0                                     ...
        multilabel *label125                                         ...
  109:  jump *label40 always 0 0                                     ...
        multilabel *label126                                         ...
  110:  jump *label40 always 0 0                                     ...
        multilabel *label127                                         ...
  111:  jump *label40 always 0 0                                     ...
        multilabel *label128                                         ...
  112:  jump *label40 always 0 0                                     ...
        multilabel *label129                                         ...
  113:  jump *label40 always 0 0                                     ...
        multilabel *label130                                         ...
  114:  jump *label40 always 0 0                                     ...
        multilabel *label131                                         ...
  115:  jump *label40 always 0 0                                     ...
        multilabel *label132                                         ...
  116:  jump *label40 always 0 0                                     ...
        multilabel *label133                                         ...
  117:  jump *label40 always 0 0                                     ...
        multilabel *label134                                         ...
  118:  jump *label40 always 0 0                                     ...
        multilabel *label135                                         ...
  119:  jump *label16 always 0 0                                     ...
        multilabel *label136                                         ...
  120:  jump *label16 always 0 0                                     ...
        multilabel *label137                                         ...
  121:  jump *label40 always 0 0                                     ...
        multilabel *label138                                         ...
  122:  jump *label40 always 0 0                                     ...
        multilabel *label139                                         ...
  123:  jump *label40 always 0 0                                     ...
        multilabel *label140                                         ...
  124:  jump *label40 always 0 0                                     ...
        multilabel *label141                                         ...
  125:  jump *label40 always 0 0                                     ...
        multilabel *label142                                         ...
  126:  jump *label40 always 0 0                                     ...
        multilabel *label143                                         ...
  127:  jump *label40 always 0 0                                     ...
        multilabel *label144                                         ...
  128:  jump *label40 always 0 0                                     ...
        multilabel *label145                                         ...
  129:  jump *label40 always 0 0                                     ...
        multilabel *label146                                         ...
  130:  jump *label40 always 0 0                                     ...
        multilabel *label147                                         ...
  131:  jump *label40 always 0 0                                     ...
        multilabel *label148                                         ...
  132:  jump *label40 always 0 0                                     ...
        multilabel *label149                                         ...
  133:  jump *label40 always 0 0                                     ...
        multilabel *label150                                         ...
  134:  jump *label40 always 0 0                                     ...
        multilabel *label151                                         ...
  135:  jump *label40 always 0 0                                     ...
        multilabel *label152                                         ...
  136:  jump *label40 always 0 0                                     ...
        multilabel *label153                                         ...
  137:  jump *label40 always 0 0                                     ...
        multilabel *label154                                         ...
  138:  jump *label40 always 0 0                                     ...
        multilabel *label155                                         ...
  139:  jump *label40 always 0 0                                     ...
        multilabel *label156                                         ...
  140:  jump *label40 always 0 0                                     ...
        multilabel *label157                                         ...
  141:  jump *label40 always 0 0                                     ...
        multilabel *label158                                         ...
  142:  jump *label40 always 0 0                                     ...
        multilabel *label159                                         ...
  143:  jump *label40 always 0 0                                     ...
        multilabel *label160                                         ...
  144:  jump *label40 always 0 0                                     ...
        multilabel *label161                                         ...
  145:  jump *label40 always 0 0                                     ...
        multilabel *label162                                         ...
  146:  jump *label40 always 0 0                                     ...
        multilabel *label163                                         ...
  147:  jump *label40 always 0 0                                     ...
        multilabel *label164                                         ...
  148:  jump *label40 always 0 0                                     ...
        multilabel *label165                                         ...
  149:  jump *label40 always 0 0                                     ...
        multilabel *label166                                         ...
  150:  jump *label40 always 0 0                                     ...
        multilabel *label167                                         ...
  151:  jump *label40 always 0 0                                     ...
        multilabel *label168                                         ...
  152:  jump *label40 always 0 0                                     ...
        multilabel *label169                                         ...
  153:  jump *label40 always 0 0                                     ...
        multilabel *label170                                         ...
  154:  jump *label40 always 0 0                                     ...
        multilabel *label171                                         ...
  155:  jump *label40 always 0 0                                     ...
        multilabel *label172                                         ...
  156:  jump *label40 always 0 0                                     ...
        multilabel *label173                                         ...
  157:  jump *label40 always 0 0                                     ...
        multilabel *label174                                         ...
  158:  jump *label40 always 0 0                                     ...
        multilabel *label175                                         ...
  159:  jump *label40 always 0 0                                     ...
        multilabel *label176                                         ...
  160:  jump *label40 always 0 0                                     ...
        multilabel *label177                                         ...
  161:  jump *label40 always 0 0                                     ...
        multilabel *label178                                         ...
  162:  jump *label40 always 0 0                                     ...
        multilabel *label179                                         ...
  163:  jump *label8 always 0 0                                      ...
        multilabel *label180                                         ...
  164:  jump *label10 always 0 0                                     ...
        multilabel *label181                                         ...
  165:  jump *label40 always 0 0                                     ...
        multilabel *label182                                         ...
  166:  jump *label40 always 0 0                                     ...
        multilabel *label183                                         ...
  167:  jump *label40 always 0 0                                     ...
        multilabel *label184                                         ...
  168:  jump *label14 always 0 0                                     ...
        multilabel *label185                                         ...
  169:  jump *label12 always 0 0                                     ...
        multilabel *label186                                         ...
  170:  jump *label40 always 0 0                                     ...
        multilabel *label187                                         ...
  171:  jump *label40 always 0 0                                     ...
        multilabel *label188                                         ...
        label *label20                                               ...
  172:  set .CONTAINER :block                                        CONTAINER = block;
  173:  set .SENSOR @totalLiquids                                    SENSOR = @totalLiquids;
  174:  set .MAXIMUM @liquidCapacity                                 MAXIMUM = @liquidCapacity;
  175:  set .R0 0                                                    R0 = 0;
  176:  set .G0 0                                                    G0 = 0;
  177:  set .B0 192                                                  B0 = 192;
  178:  set .R1 192                                                  R1 = 192;
  179:  set .G1 192                                                  G1 = 192;
  180:  set .B1 255                                                  B1 = 255;
  181:  jump *label6 always 0 0                                      case block.@type
        label *label8                                                ...
  182:  set .MESSAGE :block                                          MESSAGE = block;
  183:  jump *label6 always 0 0                                      case block.@type
        label *label10                                               ...
  184:  set .SWITCH :block                                           SWITCH = block;
  185:  jump *label6 always 0 0                                      case block.@type
        label *label12                                               ...
  186:  set .MEMORY :block                                           MEMORY = block;
  187:  set .START_INDEX 264                                         START_INDEX = 264;
  188:  set .END_INDEX 511                                           END_INDEX = 511;
  189:  set .SIZE 248                                                SIZE = 248;
  190:  jump *label6 always 0 0                                      case block.@type
        label *label14                                               ...
  191:  set .MEMORY :block                                           MEMORY = block;
  192:  set .START_INDEX 40                                          START_INDEX = 40;
  193:  set .END_INDEX 63                                            END_INDEX = 63;
  194:  set .SIZE 24                                                 SIZE = 24;
  195:  jump *label6 always 0 0                                      case block.@type
        label *label16                                               ...
  196:  set .CONTAINER :block                                        CONTAINER = block;
  197:  set .SENSOR @totalItems                                      SENSOR = @totalItems;
  198:  set .MAXIMUM @itemCapacity                                   MAXIMUM = @itemCapacity;
  199:  set .R0 0                                                    R0 = 0;
  200:  set .G0 80                                                   G0 = 80;
  201:  set .B0 0                                                    B0 = 0;
  202:  set .R1 80                                                   R1 = 80;
  203:  set .G1 255                                                  G1 = 255;
  204:  set .B1 80                                                   B1 = 80;
  205:  jump *label6 always 0 0                                      case block.@type
        label *label18                                               ...
  206:  set .CONTAINER :block                                        CONTAINER = block;
  207:  set .SENSOR @totalPower                                      SENSOR = @totalPower;
  208:  set .MAXIMUM @powerCapacity                                  MAXIMUM = @powerCapacity;
  209:  set .R0 80                                                   R0 = 80;
  210:  set .G0 80                                                   G0 = 80;
  211:  set .B0 0                                                    B0 = 0;
  212:  set .R1 255                                                  R1 = 255;
  213:  set .G1 255                                                  G1 = 255;
  214:  set .B1 80                                                   B1 = 80;
  215:  jump *label6 always 0 0                                      case block.@type
        label *label22                                               ...
  216:  set .CONTAINER :block                                        CONTAINER = block;
  217:  set .SENSOR @powerNetStored                                  SENSOR = @powerNetStored;
  218:  set .MAXIMUM @powerNetCapacity                               MAXIMUM = @powerNetCapacity;
  219:  set .R0 80                                                   R0 = 80;
  220:  set .G0 80                                                   G0 = 80;
  221:  set .B0 0                                                    B0 = 0;
  222:  set .R1 255                                                  R1 = 255;
  223:  set .G1 255                                                  G1 = 255;
  224:  set .B1 80                                                   B1 = 80;
        label *label40                                               case block.@type
        label *label6                                                ...
  225:  jump *label37 greaterThan :n 0                               while n > 0 do
        label *label5                                                ...
  226:  print "\nMessage: "                                          print("\nMessage: ", MESSAGE);
  227:  print .MESSAGE                                               ...
  228:  print "\nSwitch: "                                           print("\nSwitch: ", SWITCH);
  229:  print .SWITCH                                                ...
  230:  print "\nMemory: "                                           print("\nMemory: ", MEMORY);
  231:  print .MEMORY                                                ...
  232:  print "\nContainer: "                                        print("\nContainer: ", CONTAINER);
  233:  print .CONTAINER                                             ...
  234:  op equal *tmp15 .CONTAINER null                              if CONTAINER == null || MEMORY == null then
  235:  op equal *tmp16 .MEMORY null                                 ...
  236:  op or *tmp18 *tmp15 *tmp16                                   ...
  237:  jump *label23 equal *tmp18 false                             ...
  238:  print "\nNo memory or container."                            print("\nNo memory or container.");
  239:  printflush .MESSAGE                                          printflush(MESSAGE);
  240:  jump *label0 always 0 0                                      if CONTAINER == null || MEMORY == null then
        label *label23                                               ...
  241:  printflush .MESSAGE                                          printflush(MESSAGE);
  242:  write .START_INDEX .MEMORY 0                                 MEMORY[M_START_INDEX] = START_INDEX;
  243:  write .END_INDEX .MEMORY 2                                   MEMORY[M_END_INDEX] = END_INDEX;
  244:  write .R0 .MEMORY 3                                          MEMORY[M_R0] = R0;
  245:  write .G0 .MEMORY 4                                          MEMORY[M_G0] = G0;
  246:  write .B0 .MEMORY 5                                          MEMORY[M_B0] = B0;
  247:  write .R1 .MEMORY 6                                          MEMORY[M_R1] = R1;
  248:  write .G1 .MEMORY 7                                          MEMORY[M_G1] = G1;
  249:  write .B1 .MEMORY 8                                          MEMORY[M_B1] = B1;
  250:  read *tmp37 .MEMORY 1                                        index = min(max(START_INDEX, MEMORY[M_CURRENT_INDEX]), END_INDEX);
  251:  op max *tmp38 .START_INDEX *tmp37                            ...
  252:  op min :index *tmp38 .END_INDEX                              ...
  253:  set :nextTick @tick                                          nextTick = @tick;
  254:  control enabled .SWITCH 0 0 0 0                              SWITCH.enabled = 0;
  255:  sensor *tmp43 .SWITCH @enabled                               while SWITCH.@enabled == 0 do
  256:  jump __start__ notEqual *tmp43 0                             ...
        label *label39                                               ...
  257:  set :startTime @time                                         startTime = @time;
  258:  set :prevTick :nextTick                                      prevTick = nextTick;
  259:  op add :nextTick :nextTick 60                                nextTick = nextTick + TICKS;
  260:  op add *tmp47 :nextTick 60                                   if @tick > nextTick + TICKS then
  261:  jump *label28 lessThanEq @tick *tmp47                        ...
  262:  set :prevTick @tick                                          prevTick = @tick;
  263:  op add :nextTick :prevTick 60                                nextTick = prevTick + TICKS;
        label *label28                                               if @tick > nextTick + TICKS then
  264:  jump *label32 greaterThanEq @tick :nextTick                  while @tick < nextTick do
        label *label38                                               ...
  265:  jump *label33 greaterThanEq @tick :prevTick                  if @tick < prevTick then        // can happen after loading game
  266:  end                                                          end();
        label *label33                                               if @tick < prevTick then        // can happen after loading game
  267:  jump *label38 lessThan @tick :nextTick                       while @tick < nextTick do
        label *label32                                               ...
  268:  sensor :amount .CONTAINER .SENSOR                            amount = CONTAINER.sensor(SENSOR);
  269:  sensor :max .CONTAINER .MAXIMUM                              max = CONTAINER.sensor(MAXIMUM);
  270:  op mul *tmp57 :amount 150                                    scaled = 10 + amount * 150 / max;
  271:  op div *tmp58 *tmp57 :max                                    ...
  272:  op add :scaled 10 *tmp58                                     ...
  273:  op add :index :index 1                                       index = index + 1;
  274:  jump *label35 lessThanEq :index .END_INDEX                   if index > END_INDEX then index = START_INDEX; end;
  275:  set :index .START_INDEX                                      ...
        label *label35                                               ...
  276:  write :index .MEMORY 0                                       MEMORY[M_START_INDEX] = index;
  277:  write :scaled .MEMORY :index                                 MEMORY[index] = scaled;
  278:  op sub *tmp67 :index .SIZE                                   MEMORY[index - SIZE] = scaled;
  279:  write :scaled .MEMORY *tmp67                                 ...
  280:  print "Item/Liquid/Energy Level Meter\nStartIndex: "         print("StartIndex: ", START_INDEX, "\n");
  281:  print .START_INDEX                                           ...
  282:  print "\nIndex: "                                            print("Index: ", index, "\n");
  283:  print :index                                                 ...
  284:  print "\nAmount: "                                           print("Amount: ", amount, "\n");
  285:  print :amount                                                ...
  286:  print "\nScaled: "                                           print("Scaled: ", scaled, "\n");
  287:  print :scaled                                                ...
  288:  op sub *tmp70 @time :startTime                               print("Elapsed: ", @time - startTime, "\n");
  289:  print "\nElapsed: "                                          ...
  290:  print *tmp70                                                 ...
  291:  print "\n"                                                   ...
  292:  printflush .MESSAGE                                          printflush(MESSAGE);
  293:  sensor *tmp43 .SWITCH @enabled                               while SWITCH.@enabled == 0 do
  294:  jump *label39 equal *tmp43 0                                 ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   295     1x    295,0  <no function>

Performance: parsed in 208 ms, compiled in 238 ms, optimized in 330 ms, run in 40 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Item/Liquid/Energy Level Meter
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Memory: cell
Container: null
No memory or container.
[--- Previous segment repeated 203,82 times ---]

Execution step limit of 100000 exceeded.
