   248 instructions before optimizations.
    34 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    17 instructions eliminated by Dead Code Elimination (3 iterations).
     1 instructions eliminated by Jump Normalization (3 iterations).
     7 instructions eliminated by Jump Optimization (3 iterations).
     6 instructions eliminated by Single Step Elimination (2 passes, 5 iterations).
    10 instructions eliminated by Data Flow Optimization (5 iterations).
     1 instructions added by Loop Optimization (2 iterations).
     3 loops improved by Loop Optimization.
     8 instructions eliminated by Jump Straightening (3 iterations).
     2 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination.
     5 instructions eliminated by Print Merging.
   159 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 834):
  * Replicate loop condition at line 119:1                       cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    45 print "\nFound: "
    46 print :block
    47 sensor *tmp13 :block @type
-    * set *tmp14 *tmp13
-    * jump *label8 equal *tmp14 @message
+   48 jump *label8 equal *tmp13 @message
    49 jump *label7 always
    50 label *label8
    51 set .MESSAGE :block
    52 set *tmp12 .MESSAGE
    53 jump *label6 always
    54 label *label7
-    * jump *label10 equal *tmp14 @switch
+   55 jump *label10 equal *tmp13 @switch
    56 jump *label9 always
    57 label *label10
    58 set .SWITCH :block
    59 set *tmp12 .SWITCH
    60 jump *label6 always
    61 label *label9
-    * jump *label12 equal *tmp14 @memory-bank
+   62 jump *label12 equal *tmp13 @memory-bank
    63 jump *label11 always
    64 label *label12
    65 set .MEMORY :block
 
    69 set *tmp12 .SIZE
    70 jump *label6 always
    71 label *label11
-    * jump *label14 equal *tmp14 @memory-cell
+   72 jump *label14 equal *tmp13 @memory-cell
    73 jump *label13 always
    74 label *label14
    75 set .MEMORY :block
 
    79 set *tmp12 .SIZE
    80 jump *label6 always
    81 label *label13
-    * jump *label16 equal *tmp14 @vault
-    * jump *label16 equal *tmp14 @container
+   82 jump *label16 equal *tmp13 @vault
+   83 jump *label16 equal *tmp13 @container
    84 jump *label15 always
    85 label *label16
    86 set .CONTAINER :block
 
    95 set *tmp12 .B1
    96 jump *label6 always
    97 label *label15
-    * jump *label18 equal *tmp14 @battery
-    * jump *label18 equal *tmp14 @battery-large
+   98 jump *label18 equal *tmp13 @battery
+   99 jump *label18 equal *tmp13 @battery-large
   100 jump *label17 always
   101 label *label18
   102 set .CONTAINER :block
 
   111 set *tmp12 .B1
   112 jump *label6 always
   113 label *label17
-    * jump *label20 equal *tmp14 @liquid-tank
-    * jump *label20 equal *tmp14 @liquid-container
+  114 jump *label20 equal *tmp13 @liquid-tank
+  115 jump *label20 equal *tmp13 @liquid-container
   116 jump *label19 always
   117 label *label20
   118 set .CONTAINER :block
 
   127 set *tmp12 .B1
   128 jump *label6 always
   129 label *label19
-    * jump *label22 equal *tmp14 @power-node
-    * jump *label22 equal *tmp14 @power-node-large
-    * jump *label22 equal *tmp14 @surge-tower
+  130 jump *label22 equal *tmp13 @power-node
+  131 jump *label22 equal *tmp13 @power-node-large
+  132 jump *label22 equal *tmp13 @surge-tower
   133 jump *label21 always
   134 label *label22
   135 set .CONTAINER :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-17 instructions):
 
    49 jump *label7 always
    50 label *label8
    51 set .MESSAGE :block
-    * set *tmp12 .MESSAGE
    52 jump *label6 always
    53 label *label7
    54 jump *label10 equal *tmp13 @switch
    55 jump *label9 always
    56 label *label10
    57 set .SWITCH :block
-    * set *tmp12 .SWITCH
    58 jump *label6 always
    59 label *label9
    60 jump *label12 equal *tmp13 @memory-bank
 
    64 set .START_INDEX 264
    65 set .END_INDEX 511
    66 set .SIZE 248
-    * set *tmp12 .SIZE
    67 jump *label6 always
    68 label *label11
    69 jump *label14 equal *tmp13 @memory-cell
 
    73 set .START_INDEX 40
    74 set .END_INDEX 63
    75 set .SIZE 24
-    * set *tmp12 .SIZE
    76 jump *label6 always
    77 label *label13
    78 jump *label16 equal *tmp13 @vault
 
    88 set .R1 80
    89 set .G1 255
    90 set .B1 80
-    * set *tmp12 .B1
    91 jump *label6 always
    92 label *label15
    93 jump *label18 equal *tmp13 @battery
 
   103 set .R1 255
   104 set .G1 255
   105 set .B1 80
-    * set *tmp12 .B1
   106 jump *label6 always
   107 label *label17
   108 jump *label20 equal *tmp13 @liquid-tank
 
   118 set .R1 192
   119 set .G1 192
   120 set .B1 255
-    * set *tmp12 .B1
   121 jump *label6 always
   122 label *label19
   123 jump *label22 equal *tmp13 @power-node
 
   134 set .R1 255
   135 set .G1 255
   136 set .B1 80
-    * set *tmp12 .B1
   137 jump *label6 always
   138 label *label21
-    * set *tmp12 null
   139 label *label6
   140 label *label4
   141 jump *label3 always
 
   155 jump *label23 equal *tmp17 false
   156 print "\nNo memory or container."
   157 printflush .MESSAGE
-    * set *tmp19 null
   158 jump *label24 always
   159 label *label23
   160 printflush .MESSAGE
   161 jump *label2 always
-    * set *tmp19 null
   162 label *label24
   163 label *label1
   164 jump *label0 always
 
   204 set :prevTick *tmp50
   205 op add *tmp51 :prevTick .TICKS
   206 set :nextTick *tmp51
-    * set *tmp49 :nextTick
   207 jump *label29 always
   208 label *label28
-    * set *tmp49 null
   209 label *label29
   210 label *label30
   211 op lessThan *tmp52 @tick :nextTick
 
   213 op lessThan *tmp53 @tick :prevTick
   214 jump *label33 equal *tmp53 false
   215 end
-    * set *tmp54 null
   216 jump *label34 always
   217 label *label33
-    * set *tmp54 null
   218 label *label34
   219 label *label31
   220 jump *label30 always
 
   232 op greaterThan *tmp61 :index .END_INDEX
   233 jump *label35 equal *tmp61 false
   234 set :index .START_INDEX
-    * set *tmp62 :index
   235 jump *label36 always
   236 label *label35
-    * set *tmp62 null
   237 label *label36
   238 set *tmp63 .M_START_INDEX
   239 write :index .MEMORY *tmp63

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-34 instructions):
     0 set .TICKS 60
     1 set .M_START_INDEX 0
-    * op add *tmp0 .M_START_INDEX 1
-    * set .M_CURRENT_INDEX *tmp0
-    * op add *tmp1 .M_CURRENT_INDEX 1
-    * set .M_END_INDEX *tmp1
-    * op add *tmp2 .M_END_INDEX 1
-    * set .M_R0 *tmp2
-    * op add *tmp3 .M_R0 1
-    * set .M_G0 *tmp3
-    * op add *tmp4 .M_G0 1
-    * set .M_B0 *tmp4
-    * op add *tmp5 .M_B0 1
-    * set .M_R1 *tmp5
-    * op add *tmp6 .M_R1 1
-    * set .M_G1 *tmp6
-    * op add *tmp7 .M_G1 1
-    * set .M_B1 *tmp7
+    2 op add .M_CURRENT_INDEX .M_START_INDEX 1
+    3 op add .M_END_INDEX .M_CURRENT_INDEX 1
+    4 op add .M_R0 .M_END_INDEX 1
+    5 op add .M_G0 .M_R0 1
+    6 op add .M_B0 .M_G0 1
+    7 op add .M_R1 .M_B0 1
+    8 op add .M_G1 .M_R1 1
+    9 op add .M_B1 .M_G1 1
    10 set .B0 null
    11 set .B1 null
    12 set .END_INDEX null
 
    25 print "Item/Liquid/Energy Level Meter"
    26 set .CONTAINER null
    27 set .MEMORY null
-    * set *tmp8 @links
-    * set :n *tmp8
+   28 set :n @links
    29 label *label3
    30 op greaterThan *tmp9 :n 0
    31 jump *label5 equal *tmp9 false
-    * op sub *tmp10 :n 1
-    * set :n *tmp10
-    * getlink *tmp11 :n
-    * set :block *tmp11
+   32 op sub :n :n 1
+   33 getlink :block :n
    34 print "\nFound: "
    35 print :block
    36 sensor *tmp13 :block @type
 
   152 label *label1
   153 jump *label0 always
   154 label *label2
-    * set *tmp20 .M_START_INDEX
-    * write .START_INDEX .MEMORY *tmp20
-    * set *tmp22 .M_END_INDEX
-    * write .END_INDEX .MEMORY *tmp22
-    * set *tmp24 .M_R0
-    * write .R0 .MEMORY *tmp24
-    * set *tmp26 .M_G0
-    * write .G0 .MEMORY *tmp26
-    * set *tmp28 .M_B0
-    * write .B0 .MEMORY *tmp28
-    * set *tmp30 .M_R1
-    * write .R1 .MEMORY *tmp30
-    * set *tmp32 .M_G1
-    * write .G1 .MEMORY *tmp32
-    * set *tmp34 .M_B1
-    * write .B1 .MEMORY *tmp34
-    * set *tmp36 .M_CURRENT_INDEX
-    * read *tmp37 .MEMORY *tmp36
+  155 write .START_INDEX .MEMORY .M_START_INDEX
+  156 write .END_INDEX .MEMORY .M_END_INDEX
+  157 write .R0 .MEMORY .M_R0
+  158 write .G0 .MEMORY .M_G0
+  159 write .B0 .MEMORY .M_B0
+  160 write .R1 .MEMORY .M_R1
+  161 write .G1 .MEMORY .M_G1
+  162 write .B1 .MEMORY .M_B1
+  163 read *tmp37 .MEMORY .M_CURRENT_INDEX
   164 op max *tmp38 .START_INDEX *tmp37
-    * op min *tmp39 *tmp38 .END_INDEX
-    * set :index *tmp39
-    * set *tmp40 @tick
-    * set :nextTick *tmp40
-    * set *tmp41 .SWITCH
-    * control enabled *tmp41 0
+  165 op min :index *tmp38 .END_INDEX
+  166 set :nextTick @tick
+  167 control enabled .SWITCH 0
   168 label *label25
   169 sensor *tmp43 .SWITCH @enabled
   170 op equal *tmp44 *tmp43 0
   171 jump *label27 equal *tmp44 false
-    * set *tmp45 @time
-    * set :startTime *tmp45
+  172 set :startTime @time
   173 set :prevTick :nextTick
-    * op add *tmp46 :nextTick .TICKS
-    * set :nextTick *tmp46
+  174 op add :nextTick :nextTick .TICKS
   175 op add *tmp47 :nextTick .TICKS
   176 op greaterThan *tmp48 @tick *tmp47
   177 jump *label28 equal *tmp48 false
-    * set *tmp50 @tick
-    * set :prevTick *tmp50
-    * op add *tmp51 :prevTick .TICKS
-    * set :nextTick *tmp51
+  178 set :prevTick @tick
+  179 op add :nextTick :prevTick .TICKS
   180 jump *label29 always
   181 label *label28
   182 label *label29
 
   192 label *label31
   193 jump *label30 always
   194 label *label32
-    * sensor *tmp55 .CONTAINER .SENSOR
-    * set :amount *tmp55
-    * sensor *tmp56 .CONTAINER .MAXIMUM
-    * set :max *tmp56
+  195 sensor :amount .CONTAINER .SENSOR
+  196 sensor :max .CONTAINER .MAXIMUM
   197 op mul *tmp57 :amount 150
   198 op div *tmp58 *tmp57 :max
-    * op add *tmp59 10 *tmp58
-    * set :scaled *tmp59
-    * op add *tmp60 :index 1
-    * set :index *tmp60
+  199 op add :scaled 10 *tmp58
+  200 op add :index :index 1
   201 op greaterThan *tmp61 :index .END_INDEX
   202 jump *label35 equal *tmp61 false
   203 set :index .START_INDEX
   204 jump *label36 always
   205 label *label35
   206 label *label36
-    * set *tmp63 .M_START_INDEX
-    * write :index .MEMORY *tmp63
-    * set *tmp65 :index
-    * write :scaled .MEMORY *tmp65
+  207 write :index .MEMORY .M_START_INDEX
+  208 write :scaled .MEMORY :index
   209 op sub *tmp67 :index .SIZE
-    * set *tmp68 *tmp67
-    * write :scaled .MEMORY *tmp68
+  210 write :scaled .MEMORY *tmp67
   211 print "Item/Liquid/Energy Level Meter\n"
   212 print "StartIndex: "
   213 print .START_INDEX

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    21 set .START_INDEX null
    22 set .SWITCH null
    23 label *label0
-    * jump *label2 equal true false
    24 print "Item/Liquid/Energy Level Meter"
    25 set .CONTAINER null
    26 set .MEMORY null

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-8 instructions):
 
    33 print "\nFound: "
    34 print :block
    35 sensor *tmp13 :block @type
-    * jump *label8 equal *tmp13 @message
-    * jump *label7 always
+   36 jump *label7 notEqual *tmp13 @message
    37 label *label8
    38 set .MESSAGE :block
    39 jump *label6 always
    40 label *label7
-    * jump *label10 equal *tmp13 @switch
-    * jump *label9 always
+   41 jump *label9 notEqual *tmp13 @switch
    42 label *label10
    43 set .SWITCH :block
    44 jump *label6 always
    45 label *label9
-    * jump *label12 equal *tmp13 @memory-bank
-    * jump *label11 always
+   46 jump *label11 notEqual *tmp13 @memory-bank
    47 label *label12
    48 set .MEMORY :block
    49 set .START_INDEX 264
 
    51 set .SIZE 248
    52 jump *label6 always
    53 label *label11
-    * jump *label14 equal *tmp13 @memory-cell
-    * jump *label13 always
+   54 jump *label13 notEqual *tmp13 @memory-cell
    55 label *label14
    56 set .MEMORY :block
    57 set .START_INDEX 40
 
    60 jump *label6 always
    61 label *label13
    62 jump *label16 equal *tmp13 @vault
-    * jump *label16 equal *tmp13 @container
-    * jump *label15 always
+   63 jump *label15 notEqual *tmp13 @container
    64 label *label16
    65 set .CONTAINER :block
    66 set .SENSOR @totalItems
 
    74 jump *label6 always
    75 label *label15
    76 jump *label18 equal *tmp13 @battery
-    * jump *label18 equal *tmp13 @battery-large
-    * jump *label17 always
+   77 jump *label17 notEqual *tmp13 @battery-large
    78 label *label18
    79 set .CONTAINER :block
    80 set .SENSOR @totalPower
 
    88 jump *label6 always
    89 label *label17
    90 jump *label20 equal *tmp13 @liquid-tank
-    * jump *label20 equal *tmp13 @liquid-container
-    * jump *label19 always
+   91 jump *label19 notEqual *tmp13 @liquid-container
    92 label *label20
    93 set .CONTAINER :block
    94 set .SENSOR @totalLiquids
 
   103 label *label19
   104 jump *label22 equal *tmp13 @power-node
   105 jump *label22 equal *tmp13 @power-node-large
-    * jump *label22 equal *tmp13 @surge-tower
-    * jump *label21 always
+  106 jump *label21 notEqual *tmp13 @surge-tower
   107 label *label22
   108 set .CONTAINER :block
   109 set .SENSOR @powerNetStored

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-7 instructions):
 
    26 set .MEMORY null
    27 set :n @links
    28 label *label3
-    * op greaterThan *tmp9 :n 0
-    * jump *label5 equal *tmp9 false
+   29 jump *label5 lessThanEq :n 0
    30 op sub :n :n 1
    31 getlink :block :n
    32 print "\nFound: "
 
   130 op equal *tmp15 .CONTAINER null
   131 op equal *tmp16 .MEMORY null
   132 op or *tmp18 *tmp15 *tmp16
-    * op notEqual *tmp17 *tmp18 false
-    * jump *label23 equal *tmp17 false
+  133 jump *label23 equal *tmp18 false
   134 print "\nNo memory or container."
   135 printflush .MESSAGE
   136 jump *label24 always
 
   156 control enabled .SWITCH 0
   157 label *label25
   158 sensor *tmp43 .SWITCH @enabled
-    * op equal *tmp44 *tmp43 0
-    * jump *label27 equal *tmp44 false
+  159 jump *label27 notEqual *tmp43 0
   160 set :startTime @time
   161 set :prevTick :nextTick
   162 op add :nextTick :nextTick .TICKS
   163 op add *tmp47 :nextTick .TICKS
-    * op greaterThan *tmp48 @tick *tmp47
-    * jump *label28 equal *tmp48 false
+  164 jump *label28 lessThanEq @tick *tmp47
   165 set :prevTick @tick
   166 op add :nextTick :prevTick .TICKS
   167 jump *label29 always
   168 label *label28
   169 label *label29
   170 label *label30
-    * op lessThan *tmp52 @tick :nextTick
-    * jump *label32 equal *tmp52 false
-    * op lessThan *tmp53 @tick :prevTick
-    * jump *label33 equal *tmp53 false
+  171 jump *label32 greaterThanEq @tick :nextTick
+  172 jump *label33 greaterThanEq @tick :prevTick
   173 end
   174 jump *label34 always
   175 label *label33
 
   183 op div *tmp58 *tmp57 :max
   184 op add :scaled 10 *tmp58
   185 op add :index :index 1
-    * op greaterThan *tmp61 :index .END_INDEX
-    * jump *label35 equal *tmp61 false
+  186 jump *label35 lessThanEq :index .END_INDEX
   187 set :index .START_INDEX
   188 jump *label36 always
   189 label *label35

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
   113 set .R1 255
   114 set .G1 255
   115 set .B1 80
-    * jump *label6 always
   116 label *label21
   117 label *label6
   118 label *label4
 
   163 jump *label28 lessThanEq @tick *tmp47
   164 set :prevTick @tick
   165 op add :nextTick :prevTick .TICKS
-    * jump *label29 always
   166 label *label28
   167 label *label29
   168 label *label30
   169 jump *label32 greaterThanEq @tick :nextTick
   170 jump *label33 greaterThanEq @tick :prevTick
   171 end
-    * jump *label34 always
   172 label *label33
   173 label *label34
   174 label *label31
 
   182 op add :index :index 1
   183 jump *label35 lessThanEq :index .END_INDEX
   184 set :index .START_INDEX
-    * jump *label36 always
   185 label *label35
   186 label *label36
   187 write :index .MEMORY .M_START_INDEX

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set .TICKS 60
     1 set .M_START_INDEX 0
-    * op add .M_CURRENT_INDEX .M_START_INDEX 1
-    * op add .M_END_INDEX .M_CURRENT_INDEX 1
-    * op add .M_R0 .M_END_INDEX 1
-    * op add .M_G0 .M_R0 1
-    * op add .M_B0 .M_G0 1
-    * op add .M_R1 .M_B0 1
-    * op add .M_G1 .M_R1 1
-    * op add .M_B1 .M_G1 1
+    2 op add .M_CURRENT_INDEX 0 1
+    3 op add .M_END_INDEX 1 1
+    4 op add .M_R0 2 1
+    5 op add .M_G0 3 1
+    6 op add .M_B0 4 1
+    7 op add .M_R1 5 1
+    8 op add .M_G1 6 1
+    9 op add .M_B1 7 1
    10 set .B0 null
    11 set .B1 null
    12 set .END_INDEX null
 
   140 label *label1
   141 jump *label0 always
   142 label *label2
-    * write .START_INDEX .MEMORY .M_START_INDEX
-    * write .END_INDEX .MEMORY .M_END_INDEX
-    * write .R0 .MEMORY .M_R0
-    * write .G0 .MEMORY .M_G0
-    * write .B0 .MEMORY .M_B0
-    * write .R1 .MEMORY .M_R1
-    * write .G1 .MEMORY .M_G1
-    * write .B1 .MEMORY .M_B1
-    * read *tmp37 .MEMORY .M_CURRENT_INDEX
+  143 write .START_INDEX .MEMORY 0
+  144 write .END_INDEX .MEMORY 2
+  145 write .R0 .MEMORY 3
+  146 write .G0 .MEMORY 4
+  147 write .B0 .MEMORY 5
+  148 write .R1 .MEMORY 6
+  149 write .G1 .MEMORY 7
+  150 write .B1 .MEMORY 8
+  151 read *tmp37 .MEMORY 1
   152 op max *tmp38 .START_INDEX *tmp37
   153 op min :index *tmp38 .END_INDEX
   154 set :nextTick @tick
 
   158 jump *label27 notEqual *tmp43 0
   159 set :startTime @time
   160 set :prevTick :nextTick
-    * op add :nextTick :nextTick .TICKS
-    * op add *tmp47 :nextTick .TICKS
+  161 op add :nextTick :nextTick 60
+  162 op add *tmp47 :nextTick 60
   163 jump *label28 lessThanEq @tick *tmp47
   164 set :prevTick @tick
-    * op add :nextTick :prevTick .TICKS
+  165 op add :nextTick :prevTick 60
   166 label *label28
   167 label *label29
   168 label *label30
 
   184 set :index .START_INDEX
   185 label *label35
   186 label *label36
-    * write :index .MEMORY .M_START_INDEX
+  187 write :index .MEMORY 0
   188 write :scaled .MEMORY :index
   189 op sub *tmp67 :index .SIZE
   190 write :scaled .MEMORY *tmp67

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-10 instructions):
-    * set .TICKS 60
-    * set .M_START_INDEX 0
-    * op add .M_CURRENT_INDEX 0 1
-    * op add .M_END_INDEX 1 1
-    * op add .M_R0 2 1
-    * op add .M_G0 3 1
-    * op add .M_B0 4 1
-    * op add .M_R1 5 1
-    * op add .M_G1 6 1
-    * op add .M_B1 7 1
     0 set .B0 null
     1 set .B1 null
     2 set .END_INDEX null

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    17 set :n @links
    18 label *label3
    19 jump *label5 lessThanEq :n 0
+   20 label *label37
    21 op sub :n :n 1
    22 getlink :block :n
    23 print "\nFound: "
 
   107 label *label21
   108 label *label6
   109 label *label4
-    * jump *label3 always
+  110 jump *label37 greaterThan :n 0
   111 label *label5
   112 print "\nMessage: "
   113 print .MESSAGE
 
   158 label *label29
   159 label *label30
   160 jump *label32 greaterThanEq @tick :nextTick
+  161 label *label38
   162 jump *label33 greaterThanEq @tick :prevTick
   163 end
   164 label *label33
   165 label *label34
   166 label *label31
-    * jump *label30 always
+  167 jump *label38 lessThan @tick :nextTick
   168 label *label32
   169 sensor :amount .CONTAINER .SENSOR
   170 sensor :max .CONTAINER .MAXIMUM

Modifications by Replicate loop condition at line 119:1 (+1 instructions):
 
   147 label *label25
   148 sensor *tmp43 .SWITCH @enabled
   149 jump *label27 notEqual *tmp43 0
+  150 label *label39
   151 set :startTime @time
   152 set :prevTick :nextTick
   153 op add :nextTick :nextTick 60
 
   200 print "\n"
   201 printflush .MESSAGE
   202 label *label26
-    * jump *label25 always
+  203 sensor *tmp43 .SWITCH @enabled
+  204 jump *label39 equal *tmp43 0
   205 label *label27
   206 end

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 set .B0 null
     2 set .B1 null
     3 set .END_INDEX null
 
   124 jump *label23 equal *tmp18 false
   125 print "\nNo memory or container."
   126 printflush .MESSAGE
-    * jump *label24 always
+  127 jump *label0 always
   128 label *label23
   129 printflush .MESSAGE
   130 jump *label2 always
 
   147 control enabled .SWITCH 0
   148 label *label25
   149 sensor *tmp43 .SWITCH @enabled
-    * jump *label27 notEqual *tmp43 0
+  150 jump __start__ notEqual *tmp43 0
   151 label *label39
   152 set :startTime @time
   153 set :prevTick :nextTick

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
   128 label *label23
   129 printflush .MESSAGE
   130 jump *label2 always
-    * label *label24
-    * label *label1
-    * jump *label0 always
   131 label *label2
   132 write .START_INDEX .MEMORY 0
   133 write .END_INDEX .MEMORY 2

Modifications by Final phase, Single Step Elimination, iteration 1 (-2 instructions):
 
   127 jump *label0 always
   128 label *label23
   129 printflush .MESSAGE
-    * jump *label2 always
   130 label *label2
   131 write .START_INDEX .MEMORY 0
   132 write .END_INDEX .MEMORY 2
 
   200 sensor *tmp43 .SWITCH @enabled
   201 jump *label39 equal *tmp43 0
   202 label *label27
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-5 instructions):
 
   178 write :scaled .MEMORY :index
   179 op sub *tmp67 :index .SIZE
   180 write :scaled .MEMORY *tmp67
-    * print "Item/Liquid/Energy Level Meter\n"
-    * print "StartIndex: "
+  181 print "Item/Liquid/Energy Level Meter\nStartIndex: "
   182 print .START_INDEX
-    * print "\n"
-    * print "Index: "
+  183 print "\nIndex: "
   184 print :index
-    * print "\n"
-    * print "Amount: "
+  185 print "\nAmount: "
   186 print :amount
-    * print "\n"
-    * print "Scaled: "
+  187 print "\nScaled: "
   188 print :scaled
-    * print "\n"
   189 op sub *tmp70 @time :startTime
-    * print "Elapsed: "
+  190 print "\nElapsed: "
   191 print *tmp70
   192 print "\n"
   193 printflush .MESSAGE

Final code before resolving virtual instructions:

        label __start__                                              B0 = null; B1 = null; END_INDEX = null; G0 = null; G1 = null; MAXIMUM = null; MESSAGE = null;
    0:  set .B0 null                                                 ...
    1:  set .B1 null                                                 ...
    2:  set .END_INDEX null                                          ...
    3:  set .G0 null                                                 ...
    4:  set .G1 null                                                 ...
    5:  set .MAXIMUM null                                            ...
    6:  set .MESSAGE null                                            ...
    7:  set .R0 null                                                 R0 = null; R1 = null; SENSOR = null; SIZE = null; START_INDEX = null; SWITCH = null;
    8:  set .R1 null                                                 ...
    9:  set .SENSOR null                                             ...
   10:  set .SIZE null                                               ...
   11:  set .START_INDEX null                                        ...
   12:  set .SWITCH null                                             ...
        label *label0                                                while true do
   13:  print "Item/Liquid/Energy Level Meter"                       print("Item/Liquid/Energy Level Meter");
   14:  set .CONTAINER null                                          CONTAINER = null;
   15:  set .MEMORY null                                             MEMORY = null;
   16:  set :n @links                                                n = @links;
   17:  jump *label5 lessThanEq :n 0                                 while n > 0 do
        label *label37                                               ...
   18:  op sub :n :n 1                                               n = n - 1;
   19:  getlink :block :n                                            block = getlink(n);
   20:  print "\nFound: "                                            print("\nFound: ", block);
   21:  print :block                                                 ...
   22:  sensor *tmp13 :block @type                                   case block.@type
   23:  jump *label7 notEqual *tmp13 @message                        ...
   24:  set .MESSAGE :block                                          MESSAGE = block;
   25:  jump *label6 always 0 0                                      case block.@type
        label *label7                                                ...
   26:  jump *label9 notEqual *tmp13 @switch                         ...
   27:  set .SWITCH :block                                           SWITCH = block;
   28:  jump *label6 always 0 0                                      case block.@type
        label *label9                                                ...
   29:  jump *label11 notEqual *tmp13 @memory-bank                   ...
   30:  set .MEMORY :block                                           MEMORY = block;
   31:  set .START_INDEX 264                                         START_INDEX = 264;
   32:  set .END_INDEX 511                                           END_INDEX = 511;
   33:  set .SIZE 248                                                SIZE = 248;
   34:  jump *label6 always 0 0                                      case block.@type
        label *label11                                               ...
   35:  jump *label13 notEqual *tmp13 @memory-cell                   ...
   36:  set .MEMORY :block                                           MEMORY = block;
   37:  set .START_INDEX 40                                          START_INDEX = 40;
   38:  set .END_INDEX 63                                            END_INDEX = 63;
   39:  set .SIZE 24                                                 SIZE = 24;
   40:  jump *label6 always 0 0                                      case block.@type
        label *label13                                               ...
   41:  jump *label16 equal *tmp13 @vault                            ...
   42:  jump *label15 notEqual *tmp13 @container                     ...
        label *label16                                               ...
   43:  set .CONTAINER :block                                        CONTAINER = block;
   44:  set .SENSOR @totalItems                                      SENSOR = @totalItems;
   45:  set .MAXIMUM @itemCapacity                                   MAXIMUM = @itemCapacity;
   46:  set .R0 0                                                    R0 = 0;
   47:  set .G0 80                                                   G0 = 80;
   48:  set .B0 0                                                    B0 = 0;
   49:  set .R1 80                                                   R1 = 80;
   50:  set .G1 255                                                  G1 = 255;
   51:  set .B1 80                                                   B1 = 80;
   52:  jump *label6 always 0 0                                      case block.@type
        label *label15                                               ...
   53:  jump *label18 equal *tmp13 @battery                          ...
   54:  jump *label17 notEqual *tmp13 @battery-large                 ...
        label *label18                                               ...
   55:  set .CONTAINER :block                                        CONTAINER = block;
   56:  set .SENSOR @totalPower                                      SENSOR = @totalPower;
   57:  set .MAXIMUM @powerCapacity                                  MAXIMUM = @powerCapacity;
   58:  set .R0 80                                                   R0 = 80;
   59:  set .G0 80                                                   G0 = 80;
   60:  set .B0 0                                                    B0 = 0;
   61:  set .R1 255                                                  R1 = 255;
   62:  set .G1 255                                                  G1 = 255;
   63:  set .B1 80                                                   B1 = 80;
   64:  jump *label6 always 0 0                                      case block.@type
        label *label17                                               ...
   65:  jump *label20 equal *tmp13 @liquid-tank                      ...
   66:  jump *label19 notEqual *tmp13 @liquid-container              ...
        label *label20                                               ...
   67:  set .CONTAINER :block                                        CONTAINER = block;
   68:  set .SENSOR @totalLiquids                                    SENSOR = @totalLiquids;
   69:  set .MAXIMUM @liquidCapacity                                 MAXIMUM = @liquidCapacity;
   70:  set .R0 0                                                    R0 = 0;
   71:  set .G0 0                                                    G0 = 0;
   72:  set .B0 192                                                  B0 = 192;
   73:  set .R1 192                                                  R1 = 192;
   74:  set .G1 192                                                  G1 = 192;
   75:  set .B1 255                                                  B1 = 255;
   76:  jump *label6 always 0 0                                      case block.@type
        label *label19                                               ...
   77:  jump *label22 equal *tmp13 @power-node                       ...
   78:  jump *label22 equal *tmp13 @power-node-large                 ...
   79:  jump *label21 notEqual *tmp13 @surge-tower                   ...
        label *label22                                               ...
   80:  set .CONTAINER :block                                        CONTAINER = block;
   81:  set .SENSOR @powerNetStored                                  SENSOR = @powerNetStored;
   82:  set .MAXIMUM @powerNetCapacity                               MAXIMUM = @powerNetCapacity;
   83:  set .R0 80                                                   R0 = 80;
   84:  set .G0 80                                                   G0 = 80;
   85:  set .B0 0                                                    B0 = 0;
   86:  set .R1 255                                                  R1 = 255;
   87:  set .G1 255                                                  G1 = 255;
   88:  set .B1 80                                                   B1 = 80;
        label *label21                                               case block.@type
        label *label6                                                ...
   89:  jump *label37 greaterThan :n 0                               while n > 0 do
        label *label5                                                ...
   90:  print "\nMessage: "                                          print("\nMessage: ", MESSAGE);
   91:  print .MESSAGE                                               ...
   92:  print "\nSwitch: "                                           print("\nSwitch: ", SWITCH);
   93:  print .SWITCH                                                ...
   94:  print "\nMemory: "                                           print("\nMemory: ", MEMORY);
   95:  print .MEMORY                                                ...
   96:  print "\nContainer: "                                        print("\nContainer: ", CONTAINER);
   97:  print .CONTAINER                                             ...
   98:  op equal *tmp15 .CONTAINER null                              if CONTAINER == null || MEMORY == null then
   99:  op equal *tmp16 .MEMORY null                                 ...
  100:  op or *tmp18 *tmp15 *tmp16                                   ...
  101:  jump *label23 equal *tmp18 false                             ...
  102:  print "\nNo memory or container."                            print("\nNo memory or container.");
  103:  printflush .MESSAGE                                          printflush(MESSAGE);
  104:  jump *label0 always 0 0                                      if CONTAINER == null || MEMORY == null then
        label *label23                                               ...
  105:  printflush .MESSAGE                                          printflush(MESSAGE);
  106:  write .START_INDEX .MEMORY 0                                 MEMORY[M_START_INDEX] = START_INDEX;
  107:  write .END_INDEX .MEMORY 2                                   MEMORY[M_END_INDEX] = END_INDEX;
  108:  write .R0 .MEMORY 3                                          MEMORY[M_R0] = R0;
  109:  write .G0 .MEMORY 4                                          MEMORY[M_G0] = G0;
  110:  write .B0 .MEMORY 5                                          MEMORY[M_B0] = B0;
  111:  write .R1 .MEMORY 6                                          MEMORY[M_R1] = R1;
  112:  write .G1 .MEMORY 7                                          MEMORY[M_G1] = G1;
  113:  write .B1 .MEMORY 8                                          MEMORY[M_B1] = B1;
  114:  read *tmp37 .MEMORY 1                                        index = min(max(START_INDEX, MEMORY[M_CURRENT_INDEX]), END_INDEX);
  115:  op max *tmp38 .START_INDEX *tmp37                            ...
  116:  op min :index *tmp38 .END_INDEX                              ...
  117:  set :nextTick @tick                                          nextTick = @tick;
  118:  control enabled .SWITCH 0 0 0 0                              SWITCH.enabled = 0;
  119:  sensor *tmp43 .SWITCH @enabled                               while SWITCH.@enabled == 0 do
  120:  jump __start__ notEqual *tmp43 0                             ...
        label *label39                                               ...
  121:  set :startTime @time                                         startTime = @time;
  122:  set :prevTick :nextTick                                      prevTick = nextTick;
  123:  op add :nextTick :nextTick 60                                nextTick = nextTick + TICKS;
  124:  op add *tmp47 :nextTick 60                                   if @tick > nextTick + TICKS then
  125:  jump *label28 lessThanEq @tick *tmp47                        ...
  126:  set :prevTick @tick                                          prevTick = @tick;
  127:  op add :nextTick :prevTick 60                                nextTick = prevTick + TICKS;
        label *label28                                               if @tick > nextTick + TICKS then
  128:  jump *label32 greaterThanEq @tick :nextTick                  while @tick < nextTick do
        label *label38                                               ...
  129:  jump *label33 greaterThanEq @tick :prevTick                  if @tick < prevTick then        // can happen after loading game
  130:  end                                                          end();
        label *label33                                               if @tick < prevTick then        // can happen after loading game
  131:  jump *label38 lessThan @tick :nextTick                       while @tick < nextTick do
        label *label32                                               ...
  132:  sensor :amount .CONTAINER .SENSOR                            amount = CONTAINER.sensor(SENSOR);
  133:  sensor :max .CONTAINER .MAXIMUM                              max = CONTAINER.sensor(MAXIMUM);
  134:  op mul *tmp57 :amount 150                                    scaled = 10 + amount * 150 / max;
  135:  op div *tmp58 *tmp57 :max                                    ...
  136:  op add :scaled 10 *tmp58                                     ...
  137:  op add :index :index 1                                       index = index + 1;
  138:  jump *label35 lessThanEq :index .END_INDEX                   if index > END_INDEX then index = START_INDEX; end;
  139:  set :index .START_INDEX                                      ...
        label *label35                                               ...
  140:  write :index .MEMORY 0                                       MEMORY[M_START_INDEX] = index;
  141:  write :scaled .MEMORY :index                                 MEMORY[index] = scaled;
  142:  op sub *tmp67 :index .SIZE                                   MEMORY[index - SIZE] = scaled;
  143:  write :scaled .MEMORY *tmp67                                 ...
  144:  print "Item/Liquid/Energy Level Meter\nStartIndex: "         print("StartIndex: ", START_INDEX, "\n");
  145:  print .START_INDEX                                           ...
  146:  print "\nIndex: "                                            print("Index: ", index, "\n");
  147:  print :index                                                 ...
  148:  print "\nAmount: "                                           print("Amount: ", amount, "\n");
  149:  print :amount                                                ...
  150:  print "\nScaled: "                                           print("Scaled: ", scaled, "\n");
  151:  print :scaled                                                ...
  152:  op sub *tmp70 @time :startTime                               print("Elapsed: ", @time - startTime, "\n");
  153:  print "\nElapsed: "                                          ...
  154:  print *tmp70                                                 ...
  155:  print "\n"                                                   ...
  156:  printflush .MESSAGE                                          printflush(MESSAGE);
  157:  sensor *tmp43 .SWITCH @enabled                               while SWITCH.@enabled == 0 do
  158:  jump *label39 equal *tmp43 0                                 ...


Performance: parsed in 184 ms, compiled in 222 ms, optimized in 191 ms, run in 60 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (100,000 steps):
Item/Liquid/Energy Level Meter
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Memory: cell
Container: null
No memory or container.
[--- Previous segment repeated 186,59 times ---]

Execution step limit of 100Â 000 exceeded.
