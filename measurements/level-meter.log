File level-meter.mnd: number of reported ambiguities: 25
Active optimizations:
    case-expression-optimization = experimental,
    case-switching = experimental,
    data-flow-optimization = experimental,
    dead-code-elimination = experimental,
    expression-optimization = experimental,
    function-inlining = experimental,
    if-expression-optimization = experimental,
    jump-normalization = experimental,
    jump-optimization = experimental,
    jump-straightening = experimental,
    jump-threading = experimental,
    loop-hoisting = experimental,
    loop-optimization = experimental,
    loop-unrolling = experimental,
    print-merging = experimental,
    return-optimization = experimental,
    single-step-elimination = experimental,
    stack-optimization = experimental,
    temp-variables-elimination = experimental,
    unreachable-code-elimination = experimental

   235 instructions before optimizations.
    21 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    17 instructions eliminated by Dead Code Elimination (3 iterations).
     1 instructions eliminated by Jump Normalization (3 iterations).
     7 instructions eliminated by Jump Optimization (3 iterations).
     6 instructions eliminated by Single Step Elimination (2 passes, 5 iterations).
    10 instructions eliminated by Data Flow Optimization (5 iterations).
     1 instructions added by Loop Optimization (2 iterations).
     3 loops improved by Loop Optimization.
     8 instructions eliminated by Jump Straightening (3 iterations).
     2 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination.
     5 instructions eliminated by Print Merging.
   159 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 834):
  * Loop Optimization: replicate condition at line 119           cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    45 print "\nFound: "
    46 print block
    47 sensor __tmp12 block @type
-    * set __ast0 __tmp12
-    * jump __label8 equal __ast0 @message
+   48 jump __label8 equal __tmp12 @message
    49 jump __label7 always
    50 label __label8
    51 set MESSAGE block
    52 set __tmp13 MESSAGE
    53 jump __label6 always
    54 label __label7
-    * jump __label10 equal __ast0 @switch
+   55 jump __label10 equal __tmp12 @switch
    56 jump __label9 always
    57 label __label10
    58 set SWITCH block
    59 set __tmp13 SWITCH
    60 jump __label6 always
    61 label __label9
-    * jump __label12 equal __ast0 @memory-bank
+   62 jump __label12 equal __tmp12 @memory-bank
    63 jump __label11 always
    64 label __label12
    65 set MEMORY block
 
    69 set __tmp13 SIZE
    70 jump __label6 always
    71 label __label11
-    * jump __label14 equal __ast0 @memory-cell
+   72 jump __label14 equal __tmp12 @memory-cell
    73 jump __label13 always
    74 label __label14
    75 set MEMORY block
 
    79 set __tmp13 SIZE
    80 jump __label6 always
    81 label __label13
-    * jump __label16 equal __ast0 @vault
-    * jump __label16 equal __ast0 @container
+   82 jump __label16 equal __tmp12 @vault
+   83 jump __label16 equal __tmp12 @container
    84 jump __label15 always
    85 label __label16
    86 set CONTAINER block
 
    95 set __tmp13 B1
    96 jump __label6 always
    97 label __label15
-    * jump __label18 equal __ast0 @battery
-    * jump __label18 equal __ast0 @battery-large
+   98 jump __label18 equal __tmp12 @battery
+   99 jump __label18 equal __tmp12 @battery-large
   100 jump __label17 always
   101 label __label18
   102 set CONTAINER block
 
   111 set __tmp13 B1
   112 jump __label6 always
   113 label __label17
-    * jump __label20 equal __ast0 @liquid-tank
-    * jump __label20 equal __ast0 @liquid-container
+  114 jump __label20 equal __tmp12 @liquid-tank
+  115 jump __label20 equal __tmp12 @liquid-container
   116 jump __label19 always
   117 label __label20
   118 set CONTAINER block
 
   127 set __tmp13 B1
   128 jump __label6 always
   129 label __label19
-    * jump __label22 equal __ast0 @power-node
-    * jump __label22 equal __ast0 @power-node-large
-    * jump __label22 equal __ast0 @surge-tower
+  130 jump __label22 equal __tmp12 @power-node
+  131 jump __label22 equal __tmp12 @power-node-large
+  132 jump __label22 equal __tmp12 @surge-tower
   133 jump __label21 always
   134 label __label22
   135 set CONTAINER block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-17 instructions):
 
    49 jump __label7 always
    50 label __label8
    51 set MESSAGE block
-    * set __tmp13 MESSAGE
    52 jump __label6 always
    53 label __label7
    54 jump __label10 equal __tmp12 @switch
    55 jump __label9 always
    56 label __label10
    57 set SWITCH block
-    * set __tmp13 SWITCH
    58 jump __label6 always
    59 label __label9
    60 jump __label12 equal __tmp12 @memory-bank
 
    64 set START_INDEX 264
    65 set END_INDEX 511
    66 set SIZE 248
-    * set __tmp13 SIZE
    67 jump __label6 always
    68 label __label11
    69 jump __label14 equal __tmp12 @memory-cell
 
    73 set START_INDEX 40
    74 set END_INDEX 63
    75 set SIZE 24
-    * set __tmp13 SIZE
    76 jump __label6 always
    77 label __label13
    78 jump __label16 equal __tmp12 @vault
 
    88 set R1 80
    89 set G1 255
    90 set B1 80
-    * set __tmp13 B1
    91 jump __label6 always
    92 label __label15
    93 jump __label18 equal __tmp12 @battery
 
   103 set R1 255
   104 set G1 255
   105 set B1 80
-    * set __tmp13 B1
   106 jump __label6 always
   107 label __label17
   108 jump __label20 equal __tmp12 @liquid-tank
 
   118 set R1 192
   119 set G1 192
   120 set B1 255
-    * set __tmp13 B1
   121 jump __label6 always
   122 label __label19
   123 jump __label22 equal __tmp12 @power-node
 
   134 set R1 255
   135 set G1 255
   136 set B1 80
-    * set __tmp13 B1
   137 jump __label6 always
   138 label __label21
-    * set __tmp13 null
   139 label __label6
   140 label __label4
   141 jump __label3 always
 
   155 jump __label23 equal __tmp17 false
   156 print "\nNo memory or container."
   157 printflush MESSAGE
-    * set __tmp18 null
   158 jump __label24 always
   159 label __label23
   160 printflush MESSAGE
   161 jump __label2 always
-    * set __tmp18 null
   162 label __label24
   163 label __label1
   164 jump __label0 always
 
   194 set prevTick __tmp30
   195 op add __tmp31 prevTick TICKS
   196 set nextTick __tmp31
-    * set __tmp29 nextTick
   197 jump __label29 always
   198 label __label28
-    * set __tmp29 null
   199 label __label29
   200 label __label30
   201 op lessThan __tmp32 @tick nextTick
 
   203 op lessThan __tmp33 @tick prevTick
   204 jump __label33 equal __tmp33 false
   205 end
-    * set __tmp34 null
   206 jump __label34 always
   207 label __label33
-    * set __tmp34 null
   208 label __label34
   209 label __label31
   210 jump __label30 always
 
   222 op greaterThan __tmp41 index END_INDEX
   223 jump __label35 equal __tmp41 false
   224 set index START_INDEX
-    * set __tmp42 index
   225 jump __label36 always
   226 label __label35
-    * set __tmp42 null
   227 label __label36
   228 write index MEMORY M_START_INDEX
   229 write scaled MEMORY index

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-21 instructions):
     0 set TICKS 60
     1 set M_START_INDEX 0
-    * op add __tmp0 M_START_INDEX 1
-    * set M_CURRENT_INDEX __tmp0
-    * op add __tmp1 M_CURRENT_INDEX 1
-    * set M_END_INDEX __tmp1
-    * op add __tmp2 M_END_INDEX 1
-    * set M_R0 __tmp2
-    * op add __tmp3 M_R0 1
-    * set M_G0 __tmp3
-    * op add __tmp4 M_G0 1
-    * set M_B0 __tmp4
-    * op add __tmp5 M_B0 1
-    * set M_R1 __tmp5
-    * op add __tmp6 M_R1 1
-    * set M_G1 __tmp6
-    * op add __tmp7 M_G1 1
-    * set M_B1 __tmp7
+    2 op add M_CURRENT_INDEX M_START_INDEX 1
+    3 op add M_END_INDEX M_CURRENT_INDEX 1
+    4 op add M_R0 M_END_INDEX 1
+    5 op add M_G0 M_R0 1
+    6 op add M_B0 M_G0 1
+    7 op add M_R1 M_B0 1
+    8 op add M_G1 M_R1 1
+    9 op add M_B1 M_G1 1
    10 set B0 null
    11 set B1 null
    12 set END_INDEX null
 
    25 print "Item/Liquid/Energy Level Meter"
    26 set CONTAINER null
    27 set MEMORY null
-    * set __tmp8 @links
-    * set n __tmp8
+   28 set n @links
    29 label __label3
    30 op greaterThan __tmp9 n 0
    31 jump __label5 equal __tmp9 false
-    * op sub __tmp10 n 1
-    * set n __tmp10
-    * getlink __tmp11 n
-    * set block __tmp11
+   32 op sub n n 1
+   33 getlink block n
    34 print "\nFound: "
    35 print block
    36 sensor __tmp12 block @type
 
   162 write B1 MEMORY M_B1
   163 read __tmp19 MEMORY M_CURRENT_INDEX
   164 op max __tmp20 START_INDEX __tmp19
-    * op min __tmp21 __tmp20 END_INDEX
-    * set index __tmp21
-    * set __tmp22 @tick
-    * set nextTick __tmp22
+  165 op min index __tmp20 END_INDEX
+  166 set nextTick @tick
   167 control enabled SWITCH 0
   168 label __label25
   169 sensor __tmp23 SWITCH @enabled
   170 op equal __tmp24 __tmp23 0
   171 jump __label27 equal __tmp24 false
-    * set __tmp25 @time
-    * set startTime __tmp25
+  172 set startTime @time
   173 set prevTick nextTick
-    * op add __tmp26 nextTick TICKS
-    * set nextTick __tmp26
+  174 op add nextTick nextTick TICKS
   175 op add __tmp27 nextTick TICKS
   176 op greaterThan __tmp28 @tick __tmp27
   177 jump __label28 equal __tmp28 false
-    * set __tmp30 @tick
-    * set prevTick __tmp30
-    * op add __tmp31 prevTick TICKS
-    * set nextTick __tmp31
+  178 set prevTick @tick
+  179 op add nextTick prevTick TICKS
   180 jump __label29 always
   181 label __label28
   182 label __label29
 
   192 label __label31
   193 jump __label30 always
   194 label __label32
-    * sensor __tmp35 CONTAINER SENSOR
-    * set amount __tmp35
-    * sensor __tmp36 CONTAINER MAXIMUM
-    * set max __tmp36
+  195 sensor amount CONTAINER SENSOR
+  196 sensor max CONTAINER MAXIMUM
   197 op mul __tmp37 amount 150
   198 op div __tmp38 __tmp37 max
-    * op add __tmp39 10 __tmp38
-    * set scaled __tmp39
-    * op add __tmp40 index 1
-    * set index __tmp40
+  199 op add scaled 10 __tmp38
+  200 op add index index 1
   201 op greaterThan __tmp41 index END_INDEX
   202 jump __label35 equal __tmp41 false
   203 set index START_INDEX

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    21 set START_INDEX null
    22 set SWITCH null
    23 label __label0
-    * jump __label2 equal true false
    24 print "Item/Liquid/Energy Level Meter"
    25 set CONTAINER null
    26 set MEMORY null

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-8 instructions):
 
    33 print "\nFound: "
    34 print block
    35 sensor __tmp12 block @type
-    * jump __label8 equal __tmp12 @message
-    * jump __label7 always
+   36 jump __label7 notEqual __tmp12 @message
    37 label __label8
    38 set MESSAGE block
    39 jump __label6 always
    40 label __label7
-    * jump __label10 equal __tmp12 @switch
-    * jump __label9 always
+   41 jump __label9 notEqual __tmp12 @switch
    42 label __label10
    43 set SWITCH block
    44 jump __label6 always
    45 label __label9
-    * jump __label12 equal __tmp12 @memory-bank
-    * jump __label11 always
+   46 jump __label11 notEqual __tmp12 @memory-bank
    47 label __label12
    48 set MEMORY block
    49 set START_INDEX 264
 
    51 set SIZE 248
    52 jump __label6 always
    53 label __label11
-    * jump __label14 equal __tmp12 @memory-cell
-    * jump __label13 always
+   54 jump __label13 notEqual __tmp12 @memory-cell
    55 label __label14
    56 set MEMORY block
    57 set START_INDEX 40
 
    60 jump __label6 always
    61 label __label13
    62 jump __label16 equal __tmp12 @vault
-    * jump __label16 equal __tmp12 @container
-    * jump __label15 always
+   63 jump __label15 notEqual __tmp12 @container
    64 label __label16
    65 set CONTAINER block
    66 set SENSOR @totalItems
 
    74 jump __label6 always
    75 label __label15
    76 jump __label18 equal __tmp12 @battery
-    * jump __label18 equal __tmp12 @battery-large
-    * jump __label17 always
+   77 jump __label17 notEqual __tmp12 @battery-large
    78 label __label18
    79 set CONTAINER block
    80 set SENSOR @totalPower
 
    88 jump __label6 always
    89 label __label17
    90 jump __label20 equal __tmp12 @liquid-tank
-    * jump __label20 equal __tmp12 @liquid-container
-    * jump __label19 always
+   91 jump __label19 notEqual __tmp12 @liquid-container
    92 label __label20
    93 set CONTAINER block
    94 set SENSOR @totalLiquids
 
   103 label __label19
   104 jump __label22 equal __tmp12 @power-node
   105 jump __label22 equal __tmp12 @power-node-large
-    * jump __label22 equal __tmp12 @surge-tower
-    * jump __label21 always
+  106 jump __label21 notEqual __tmp12 @surge-tower
   107 label __label22
   108 set CONTAINER block
   109 set SENSOR @powerNetStored

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-7 instructions):
 
    26 set MEMORY null
    27 set n @links
    28 label __label3
-    * op greaterThan __tmp9 n 0
-    * jump __label5 equal __tmp9 false
+   29 jump __label5 lessThanEq n 0
    30 op sub n n 1
    31 getlink block n
    32 print "\nFound: "
 
   130 op equal __tmp14 CONTAINER null
   131 op equal __tmp15 MEMORY null
   132 op or __tmp16 __tmp14 __tmp15
-    * op notEqual __tmp17 __tmp16 false
-    * jump __label23 equal __tmp17 false
+  133 jump __label23 equal __tmp16 false
   134 print "\nNo memory or container."
   135 printflush MESSAGE
   136 jump __label24 always
 
   156 control enabled SWITCH 0
   157 label __label25
   158 sensor __tmp23 SWITCH @enabled
-    * op equal __tmp24 __tmp23 0
-    * jump __label27 equal __tmp24 false
+  159 jump __label27 notEqual __tmp23 0
   160 set startTime @time
   161 set prevTick nextTick
   162 op add nextTick nextTick TICKS
   163 op add __tmp27 nextTick TICKS
-    * op greaterThan __tmp28 @tick __tmp27
-    * jump __label28 equal __tmp28 false
+  164 jump __label28 lessThanEq @tick __tmp27
   165 set prevTick @tick
   166 op add nextTick prevTick TICKS
   167 jump __label29 always
   168 label __label28
   169 label __label29
   170 label __label30
-    * op lessThan __tmp32 @tick nextTick
-    * jump __label32 equal __tmp32 false
-    * op lessThan __tmp33 @tick prevTick
-    * jump __label33 equal __tmp33 false
+  171 jump __label32 greaterThanEq @tick nextTick
+  172 jump __label33 greaterThanEq @tick prevTick
   173 end
   174 jump __label34 always
   175 label __label33
 
   183 op div __tmp38 __tmp37 max
   184 op add scaled 10 __tmp38
   185 op add index index 1
-    * op greaterThan __tmp41 index END_INDEX
-    * jump __label35 equal __tmp41 false
+  186 jump __label35 lessThanEq index END_INDEX
   187 set index START_INDEX
   188 jump __label36 always
   189 label __label35

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
   113 set R1 255
   114 set G1 255
   115 set B1 80
-    * jump __label6 always
   116 label __label21
   117 label __label6
   118 label __label4
 
   163 jump __label28 lessThanEq @tick __tmp27
   164 set prevTick @tick
   165 op add nextTick prevTick TICKS
-    * jump __label29 always
   166 label __label28
   167 label __label29
   168 label __label30
   169 jump __label32 greaterThanEq @tick nextTick
   170 jump __label33 greaterThanEq @tick prevTick
   171 end
-    * jump __label34 always
   172 label __label33
   173 label __label34
   174 label __label31
 
   182 op add index index 1
   183 jump __label35 lessThanEq index END_INDEX
   184 set index START_INDEX
-    * jump __label36 always
   185 label __label35
   186 label __label36
   187 write index MEMORY M_START_INDEX

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set TICKS 60
     1 set M_START_INDEX 0
-    * op add M_CURRENT_INDEX M_START_INDEX 1
-    * op add M_END_INDEX M_CURRENT_INDEX 1
-    * op add M_R0 M_END_INDEX 1
-    * op add M_G0 M_R0 1
-    * op add M_B0 M_G0 1
-    * op add M_R1 M_B0 1
-    * op add M_G1 M_R1 1
-    * op add M_B1 M_G1 1
+    2 op add M_CURRENT_INDEX 0 1
+    3 op add M_END_INDEX 1 1
+    4 op add M_R0 2 1
+    5 op add M_G0 3 1
+    6 op add M_B0 4 1
+    7 op add M_R1 5 1
+    8 op add M_G1 6 1
+    9 op add M_B1 7 1
    10 set B0 null
    11 set B1 null
    12 set END_INDEX null
 
   140 label __label1
   141 jump __label0 always
   142 label __label2
-    * write START_INDEX MEMORY M_START_INDEX
-    * write END_INDEX MEMORY M_END_INDEX
-    * write R0 MEMORY M_R0
-    * write G0 MEMORY M_G0
-    * write B0 MEMORY M_B0
-    * write R1 MEMORY M_R1
-    * write G1 MEMORY M_G1
-    * write B1 MEMORY M_B1
-    * read __tmp19 MEMORY M_CURRENT_INDEX
+  143 write START_INDEX MEMORY 0
+  144 write END_INDEX MEMORY 2
+  145 write R0 MEMORY 3
+  146 write G0 MEMORY 4
+  147 write B0 MEMORY 5
+  148 write R1 MEMORY 6
+  149 write G1 MEMORY 7
+  150 write B1 MEMORY 8
+  151 read __tmp19 MEMORY 1
   152 op max __tmp20 START_INDEX __tmp19
   153 op min index __tmp20 END_INDEX
   154 set nextTick @tick
 
   158 jump __label27 notEqual __tmp23 0
   159 set startTime @time
   160 set prevTick nextTick
-    * op add nextTick nextTick TICKS
-    * op add __tmp27 nextTick TICKS
+  161 op add nextTick nextTick 60
+  162 op add __tmp27 nextTick 60
   163 jump __label28 lessThanEq @tick __tmp27
   164 set prevTick @tick
-    * op add nextTick prevTick TICKS
+  165 op add nextTick prevTick 60
   166 label __label28
   167 label __label29
   168 label __label30
 
   184 set index START_INDEX
   185 label __label35
   186 label __label36
-    * write index MEMORY M_START_INDEX
+  187 write index MEMORY 0
   188 write scaled MEMORY index
   189 op sub __tmp43 index SIZE
   190 write scaled MEMORY __tmp43

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-10 instructions):
-    * set TICKS 60
-    * set M_START_INDEX 0
-    * op add M_CURRENT_INDEX 0 1
-    * op add M_END_INDEX 1 1
-    * op add M_R0 2 1
-    * op add M_G0 3 1
-    * op add M_B0 4 1
-    * op add M_R1 5 1
-    * op add M_G1 6 1
-    * op add M_B1 7 1
     0 set B0 null
     1 set B1 null
     2 set END_INDEX null

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    17 set n @links
    18 label __label3
    19 jump __label5 lessThanEq n 0
+   20 label __label37
    21 op sub n n 1
    22 getlink block n
    23 print "\nFound: "
 
   107 label __label21
   108 label __label6
   109 label __label4
-    * jump __label3 always
+  110 jump __label37 greaterThan n 0
   111 label __label5
   112 print "\nMessage: "
   113 print MESSAGE
 
   158 label __label29
   159 label __label30
   160 jump __label32 greaterThanEq @tick nextTick
+  161 label __label38
   162 jump __label33 greaterThanEq @tick prevTick
   163 end
   164 label __label33
   165 label __label34
   166 label __label31
-    * jump __label30 always
+  167 jump __label38 lessThan @tick nextTick
   168 label __label32
   169 sensor amount CONTAINER SENSOR
   170 sensor max CONTAINER MAXIMUM

Modifications by Loop Optimization: replicate condition at line 119 (+1 instructions):
 
   147 label __label25
   148 sensor __tmp23 SWITCH @enabled
   149 jump __label27 notEqual __tmp23 0
+  150 label __label39
   151 set startTime @time
   152 set prevTick nextTick
   153 op add nextTick nextTick 60
 
   200 print "\n"
   201 printflush MESSAGE
   202 label __label26
-    * jump __label25 always
+  203 sensor __tmp23 SWITCH @enabled
+  204 jump __label39 equal __tmp23 0
   205 label __label27
   206 end

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 set B0 null
     2 set B1 null
     3 set END_INDEX null
 
   124 jump __label23 equal __tmp16 false
   125 print "\nNo memory or container."
   126 printflush MESSAGE
-    * jump __label24 always
+  127 jump __label0 always
   128 label __label23
   129 printflush MESSAGE
   130 jump __label2 always
 
   147 control enabled SWITCH 0
   148 label __label25
   149 sensor __tmp23 SWITCH @enabled
-    * jump __label27 notEqual __tmp23 0
+  150 jump __start__ notEqual __tmp23 0
   151 label __label39
   152 set startTime @time
   153 set prevTick nextTick

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
   128 label __label23
   129 printflush MESSAGE
   130 jump __label2 always
-    * label __label24
-    * label __label1
-    * jump __label0 always
   131 label __label2
   132 write START_INDEX MEMORY 0
   133 write END_INDEX MEMORY 2

Modifications by Final phase, Single Step Elimination, iteration 1 (-2 instructions):
 
   127 jump __label0 always
   128 label __label23
   129 printflush MESSAGE
-    * jump __label2 always
   130 label __label2
   131 write START_INDEX MEMORY 0
   132 write END_INDEX MEMORY 2
 
   200 sensor __tmp23 SWITCH @enabled
   201 jump __label39 equal __tmp23 0
   202 label __label27
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-5 instructions):
 
   178 write scaled MEMORY index
   179 op sub __tmp43 index SIZE
   180 write scaled MEMORY __tmp43
-    * print "Item/Liquid/Energy Level Meter\n"
-    * print "StartIndex: "
+  181 print "Item/Liquid/Energy Level Meter\nStartIndex: "
   182 print START_INDEX
-    * print "\n"
-    * print "Index: "
+  183 print "\nIndex: "
   184 print index
-    * print "\n"
-    * print "Amount: "
+  185 print "\nAmount: "
   186 print amount
-    * print "\n"
-    * print "Scaled: "
+  187 print "\nScaled: "
   188 print scaled
-    * print "\n"
   189 op sub __tmp44 @time startTime
-    * print "Elapsed: "
+  190 print "\nElapsed: "
   191 print __tmp44
   192 print "\n"
   193 printflush MESSAGE

Final code before resolving virtual instructions:

        label __start__                                              B0 = null; B1 = null; END_INDEX = null; G0 = null; G1 = null; MAXIMUM = null; MESSAGE = null;
    0:  set B0 null                                                  ...
    1:  set B1 null                                                  ...
    2:  set END_INDEX null                                           ...
    3:  set G0 null                                                  ...
    4:  set G1 null                                                  ...
    5:  set MAXIMUM null                                             ...
    6:  set MESSAGE null                                             ...
    7:  set R0 null                                                  R0 = null; R1 = null; SENSOR = null; SIZE = null; START_INDEX = null; SWITCH = null;
    8:  set R1 null                                                  ...
    9:  set SENSOR null                                              ...
   10:  set SIZE null                                                ...
   11:  set START_INDEX null                                         ...
   12:  set SWITCH null                                              ...
        label __label0                                               while true do
   13:  print "Item/Liquid/Energy Level Meter"                       print("Item/Liquid/Energy Level Meter");
   14:  set CONTAINER null                                           CONTAINER = null;
   15:  set MEMORY null                                              MEMORY = null;
   16:  set n @links                                                 n = @links;
   17:  jump __label5 lessThanEq n 0                                 while n > 0 do
        label __label37                                              ...
   18:  op sub n n 1                                                 n = n - 1;
   19:  getlink block n                                              block = getlink(n);
   20:  print "\nFound: "                                            print("\nFound: ", block);
   21:  print block                                                  ...
   22:  sensor __tmp12 block @type                                   case block.@type
   23:  jump __label7 notEqual __tmp12 @message                      ...
   24:  set MESSAGE block                                            MESSAGE = block;
   25:  jump __label6 always 0 0                                     case block.@type
        label __label7                                               ...
   26:  jump __label9 notEqual __tmp12 @switch                       ...
   27:  set SWITCH block                                             SWITCH = block;
   28:  jump __label6 always 0 0                                     case block.@type
        label __label9                                               ...
   29:  jump __label11 notEqual __tmp12 @memory-bank                 ...
   30:  set MEMORY block                                             MEMORY = block;
   31:  set START_INDEX 264                                          START_INDEX = 264;
   32:  set END_INDEX 511                                            END_INDEX = 511;
   33:  set SIZE 248                                                 SIZE = 248;
   34:  jump __label6 always 0 0                                     case block.@type
        label __label11                                              ...
   35:  jump __label13 notEqual __tmp12 @memory-cell                 ...
   36:  set MEMORY block                                             MEMORY = block;
   37:  set START_INDEX 40                                           START_INDEX = 40;
   38:  set END_INDEX 63                                             END_INDEX = 63;
   39:  set SIZE 24                                                  SIZE = 24;
   40:  jump __label6 always 0 0                                     case block.@type
        label __label13                                              ...
   41:  jump __label16 equal __tmp12 @vault                          ...
   42:  jump __label15 notEqual __tmp12 @container                   ...
        label __label16                                              ...
   43:  set CONTAINER block                                          CONTAINER = block;
   44:  set SENSOR @totalItems                                       SENSOR = @totalItems;
   45:  set MAXIMUM @itemCapacity                                    MAXIMUM = @itemCapacity;
   46:  set R0 0                                                     R0 = 0;
   47:  set G0 80                                                    G0 = 80;
   48:  set B0 0                                                     B0 = 0;
   49:  set R1 80                                                    R1 = 80;
   50:  set G1 255                                                   G1 = 255;
   51:  set B1 80                                                    B1 = 80;
   52:  jump __label6 always 0 0                                     case block.@type
        label __label15                                              ...
   53:  jump __label18 equal __tmp12 @battery                        ...
   54:  jump __label17 notEqual __tmp12 @battery-large               ...
        label __label18                                              ...
   55:  set CONTAINER block                                          CONTAINER = block;
   56:  set SENSOR @totalPower                                       SENSOR = @totalPower;
   57:  set MAXIMUM @powerCapacity                                   MAXIMUM = @powerCapacity;
   58:  set R0 80                                                    R0 = 80;
   59:  set G0 80                                                    G0 = 80;
   60:  set B0 0                                                     B0 = 0;
   61:  set R1 255                                                   R1 = 255;
   62:  set G1 255                                                   G1 = 255;
   63:  set B1 80                                                    B1 = 80;
   64:  jump __label6 always 0 0                                     case block.@type
        label __label17                                              ...
   65:  jump __label20 equal __tmp12 @liquid-tank                    ...
   66:  jump __label19 notEqual __tmp12 @liquid-container            ...
        label __label20                                              ...
   67:  set CONTAINER block                                          CONTAINER = block;
   68:  set SENSOR @totalLiquids                                     SENSOR = @totalLiquids;
   69:  set MAXIMUM @liquidCapacity                                  MAXIMUM = @liquidCapacity;
   70:  set R0 0                                                     R0 = 0;
   71:  set G0 0                                                     G0 = 0;
   72:  set B0 192                                                   B0 = 192;
   73:  set R1 192                                                   R1 = 192;
   74:  set G1 192                                                   G1 = 192;
   75:  set B1 255                                                   B1 = 255;
   76:  jump __label6 always 0 0                                     case block.@type
        label __label19                                              ...
   77:  jump __label22 equal __tmp12 @power-node                     ...
   78:  jump __label22 equal __tmp12 @power-node-large               ...
   79:  jump __label21 notEqual __tmp12 @surge-tower                 ...
        label __label22                                              ...
   80:  set CONTAINER block                                          CONTAINER = block;
   81:  set SENSOR @powerNetStored                                   SENSOR = @powerNetStored;
   82:  set MAXIMUM @powerNetCapacity                                MAXIMUM = @powerNetCapacity;
   83:  set R0 80                                                    R0 = 80;
   84:  set G0 80                                                    G0 = 80;
   85:  set B0 0                                                     B0 = 0;
   86:  set R1 255                                                   R1 = 255;
   87:  set G1 255                                                   G1 = 255;
   88:  set B1 80                                                    B1 = 80;
        label __label21                                              case block.@type
        label __label6                                               ...
   89:  jump __label37 greaterThan n 0                               while n > 0 do
        label __label5                                               ...
   90:  print "\nMessage: "                                          print("\nMessage: ", MESSAGE);
   91:  print MESSAGE                                                ...
   92:  print "\nSwitch: "                                           print("\nSwitch: ", SWITCH);
   93:  print SWITCH                                                 ...
   94:  print "\nMemory: "                                           print("\nMemory: ", MEMORY);
   95:  print MEMORY                                                 ...
   96:  print "\nContainer: "                                        print("\nContainer: ", CONTAINER);
   97:  print CONTAINER                                              ...
   98:  op equal __tmp14 CONTAINER null                              if CONTAINER == null || MEMORY == null then
   99:  op equal __tmp15 MEMORY null                                 ...
  100:  op or __tmp16 __tmp14 __tmp15                                ...
  101:  jump __label23 equal __tmp16 false                           ...
  102:  print "\nNo memory or container."                            print("\nNo memory or container.");
  103:  printflush MESSAGE                                           printflush(MESSAGE);
  104:  jump __label0 always 0 0                                     if CONTAINER == null || MEMORY == null then
        label __label23                                              ...
  105:  printflush MESSAGE                                           printflush(MESSAGE);
  106:  write START_INDEX MEMORY 0                                   MEMORY[M_START_INDEX] = START_INDEX;
  107:  write END_INDEX MEMORY 2                                     MEMORY[M_END_INDEX] = END_INDEX;
  108:  write R0 MEMORY 3                                            MEMORY[M_R0] = R0;
  109:  write G0 MEMORY 4                                            MEMORY[M_G0] = G0;
  110:  write B0 MEMORY 5                                            MEMORY[M_B0] = B0;
  111:  write R1 MEMORY 6                                            MEMORY[M_R1] = R1;
  112:  write G1 MEMORY 7                                            MEMORY[M_G1] = G1;
  113:  write B1 MEMORY 8                                            MEMORY[M_B1] = B1;
  114:  read __tmp19 MEMORY 1                                        index = min(max(START_INDEX, MEMORY[M_CURRENT_INDEX]), END_INDEX);
  115:  op max __tmp20 START_INDEX __tmp19                           ...
  116:  op min index __tmp20 END_INDEX                               ...
  117:  set nextTick @tick                                           nextTick = @tick;
  118:  control enabled SWITCH 0 0 0 0                               SWITCH.enabled = 0;
  119:  sensor __tmp23 SWITCH @enabled                               while SWITCH.@enabled == 0 do
  120:  jump __start__ notEqual __tmp23 0                            ...
        label __label39                                              ...
  121:  set startTime @time                                          startTime = @time;
  122:  set prevTick nextTick                                        prevTick = nextTick;
  123:  op add nextTick nextTick 60                                  nextTick = nextTick + TICKS;
  124:  op add __tmp27 nextTick 60                                   if @tick > nextTick + TICKS then
  125:  jump __label28 lessThanEq @tick __tmp27                      ...
  126:  set prevTick @tick                                           prevTick = @tick;
  127:  op add nextTick prevTick 60                                  nextTick = prevTick + TICKS;
        label __label28                                              if @tick > nextTick + TICKS then
  128:  jump __label32 greaterThanEq @tick nextTick                  while @tick < nextTick do
        label __label38                                              ...
  129:  jump __label33 greaterThanEq @tick prevTick                  if @tick < prevTick then        // can happen after loading game
  130:  end                                                          end();
        label __label33                                              if @tick < prevTick then        // can happen after loading game
  131:  jump __label38 lessThan @tick nextTick                       while @tick < nextTick do
        label __label32                                              ...
  132:  sensor amount CONTAINER SENSOR                               amount = CONTAINER.sensor(SENSOR);
  133:  sensor max CONTAINER MAXIMUM                                 max = CONTAINER.sensor(MAXIMUM);
  134:  op mul __tmp37 amount 150                                    scaled = 10 + amount * 150 / max;
  135:  op div __tmp38 __tmp37 max                                   ...
  136:  op add scaled 10 __tmp38                                     ...
  137:  op add index index 1                                         index = index + 1;
  138:  jump __label35 lessThanEq index END_INDEX                    if index > END_INDEX then index = START_INDEX; end;
  139:  set index START_INDEX                                        ...
        label __label35                                              ...
  140:  write index MEMORY 0                                         MEMORY[M_START_INDEX] = index;
  141:  write scaled MEMORY index                                    MEMORY[index] = scaled;
  142:  op sub __tmp43 index SIZE                                    MEMORY[index - SIZE] = scaled;
  143:  write scaled MEMORY __tmp43                                  ...
  144:  print "Item/Liquid/Energy Level Meter\nStartIndex: "         print("StartIndex: ", START_INDEX, "\n");
  145:  print START_INDEX                                            ...
  146:  print "\nIndex: "                                            print("Index: ", index, "\n");
  147:  print index                                                  ...
  148:  print "\nAmount: "                                           print("Amount: ", amount, "\n");
  149:  print amount                                                 ...
  150:  print "\nScaled: "                                           print("Scaled: ", scaled, "\n");
  151:  print scaled                                                 ...
  152:  op sub __tmp44 @time startTime                               print("Elapsed: ", @time - startTime, "\n");
  153:  print "\nElapsed: "                                          ...
  154:  print __tmp44                                                ...
  155:  print "\n"                                                   ...
  156:  printflush MESSAGE                                           printflush(MESSAGE);
  157:  sensor __tmp23 SWITCH @enabled                               while SWITCH.@enabled == 0 do
  158:  jump __label39 equal __tmp23 0                               ...


Performance: parsed in 511 ms, compiled in 131 ms, optimized in 202 ms, run in 66 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (100,000 steps):
Item/Liquid/Energy Level Meter
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Memory: cell
Container: null
No memory or container.
[--- Previous segment repeated 186 times ---]
Item/Liquid/Energy Level Meter
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: 
Execution step limit of 100 000 exceeded.
