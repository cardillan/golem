   162 instructions before optimizations.
    34 instructions eliminated by Temp Variables Elimination (5 iterations).
     1 instructions eliminated by Case Expression Optimization.
     7 instructions eliminated by Dead Code Elimination (4 iterations).
     4 instructions eliminated by Condition Optimization (5 iterations).
     3 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     2 instructions eliminated by Expression Optimization (2 iterations).
    16 instructions eliminated by Data Flow Optimization (3 passes, 9 iterations).
     2 instructions added by Loop Rotation (2 iterations).
       2 loop conditions were fully rotated.
       3 loop conditions were partially rotated.
     4 instructions eliminated by Jump Straightening (5 iterations).
     5 instructions eliminated by Print Merging.
    88 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 903):
    Partial loop rotation at line 17:1                           size    +3, benefit       25.0, efficiency      8.333
    Full loop rotation at line 17:1                              size    +2, benefit       26.0, efficiency     13.000
  * Partial loop rotation at line 49:1                           size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)

Pass 1: speed optimization selection (cost limit 902):
    Partial loop rotation at line 17:1                           size    +3, benefit       25.0, efficiency      8.333
  * Full loop rotation at line 17:1                              size    +2, benefit       26.0, efficiency     13.000 (-4 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    37 print "\nFound: "
    38 print :block
    39 sensor *tmp16 :block @type
-    * set *tmp17 *tmp16
-    * jump *label8 equal *tmp17 @large-logic-display
+   40 jump *label8 equal *tmp16 @large-logic-display
    41 jump *label7 always
    42 label *label8
    43 set .DISPLAY :block
    44 set *tmp15 .DISPLAY
    45 jump *label6 always
    46 label *label7
-    * jump *label10 equal *tmp17 @message
+   47 jump *label10 equal *tmp16 @message
    48 jump *label9 always
    49 label *label10
    50 set .MESSAGE :block
    51 set *tmp15 .MESSAGE
    52 jump *label6 always
    53 label *label9
-    * jump *label12 equal *tmp17 @switch
+   54 jump *label12 equal *tmp16 @switch
    55 jump *label11 always
    56 label *label12
    57 set .SWITCH :block
    58 set *tmp15 .SWITCH
    59 jump *label6 always
    60 label *label11
-    * jump *label14 equal *tmp17 @memory-bank
-    * jump *label14 equal *tmp17 @memory-cell
+   61 jump *label14 equal *tmp16 @memory-bank
+   62 jump *label14 equal *tmp16 @memory-cell
    63 jump *label13 always
    64 label *label14
    65 set .MEMORY :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-7 instructions):
 
    41 jump *label7 always
    42 label *label8
    43 set .DISPLAY :block
-    * set *tmp15 .DISPLAY
    44 jump *label6 always
    45 label *label7
    46 jump *label10 equal *tmp16 @message
    47 jump *label9 always
    48 label *label10
    49 set .MESSAGE :block
-    * set *tmp15 .MESSAGE
    50 jump *label6 always
    51 label *label9
    52 jump *label12 equal *tmp16 @switch
    53 jump *label11 always
    54 label *label12
    55 set .SWITCH :block
-    * set *tmp15 .SWITCH
    56 jump *label6 always
    57 label *label11
    58 jump *label14 equal *tmp16 @memory-bank
 
    60 jump *label13 always
    61 label *label14
    62 set .MEMORY :block
-    * set *tmp15 .MEMORY
    63 jump *label6 always
    64 label *label13
-    * set *tmp15 null
    65 label *label6
    66 label *label4
    67 jump *label3 always
 
    83 op lor *tmp20 *tmp18 *tmp19
    84 jump *label15 equal *tmp20 false
    85 print "\nNo memory or display."
-    * set *tmp21 "\nNo memory or display."
    86 jump *label16 always
    87 label *label15
-    * set *tmp21 null
    88 label *label16
    89 printflush .MESSAGE
    90 label *label1

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-34 instructions):
 
     3 set .MESSAGE null
     4 set .SWITCH null
     5 set .M_START_INDEX 0
-    * op add *tmp0 .M_START_INDEX 1
-    * set .M_CURRENT_INDEX *tmp0
-    * op add *tmp1 .M_CURRENT_INDEX 1
-    * set .M_END_INDEX *tmp1
-    * op add *tmp2 .M_END_INDEX 1
-    * set .M_R0 *tmp2
-    * op add *tmp3 .M_R0 1
-    * set .M_G0 *tmp3
-    * op add *tmp4 .M_G0 1
-    * set .M_B0 *tmp4
-    * op add *tmp5 .M_B0 1
-    * set .M_R1 *tmp5
-    * op add *tmp6 .M_R1 1
-    * set .M_G1 *tmp6
-    * op add *tmp7 .M_G1 1
-    * set .M_B1 *tmp7
+    6 op add .M_CURRENT_INDEX .M_START_INDEX 1
+    7 op add .M_END_INDEX .M_CURRENT_INDEX 1
+    8 op add .M_R0 .M_END_INDEX 1
+    9 op add .M_G0 .M_R0 1
+   10 op add .M_B0 .M_G0 1
+   11 op add .M_R1 .M_B0 1
+   12 op add .M_G1 .M_R1 1
+   13 op add .M_B1 .M_G1 1
    14 label *label0
    15 op equal *tmp8 .MEMORY null
    16 op equal *tmp9 .DISPLAY null
    17 op lor *tmp10 *tmp8 *tmp9
    18 jump *label2 equal *tmp10 false
    19 print "Item/Liquid/Energy Level Display"
-    * set *tmp11 @links
-    * set :n *tmp11
+   20 set :n @links
    21 label *label3
    22 op greaterThan *tmp12 :n 0
    23 jump *label5 equal *tmp12 false
-    * op sub *tmp13 :n 1
-    * set :n *tmp13
-    * getlink *tmp14 :n
-    * set :block *tmp14
+   24 op sub :n :n 1
+   25 getlink :block :n
    26 print "\nFound: "
    27 print :block
    28 sensor *tmp16 :block @type
 
    79 label *label1
    80 jump *label0 always
    81 label *label2
-    * set *tmp22 .M_CURRENT_INDEX
-    * read *tmp23 .MEMORY *tmp22
-    * set .CURRENT_INDEX *tmp23
-    * set *tmp24 .M_R0
-    * read *tmp25 .MEMORY *tmp24
-    * set .R0 *tmp25
-    * set *tmp26 .M_G0
-    * read *tmp27 .MEMORY *tmp26
-    * set .G0 *tmp27
-    * set *tmp28 .M_B0
-    * read *tmp29 .MEMORY *tmp28
-    * set .B0 *tmp29
-    * set *tmp30 .M_R1
-    * read *tmp31 .MEMORY *tmp30
-    * set .R1 *tmp31
-    * set *tmp32 .M_G1
-    * read *tmp33 .MEMORY *tmp32
-    * set .G1 *tmp33
-    * set *tmp34 .M_B1
-    * read *tmp35 .MEMORY *tmp34
-    * set .B1 *tmp35
+   82 read .CURRENT_INDEX .MEMORY .M_CURRENT_INDEX
+   83 read .R0 .MEMORY .M_R0
+   84 read .G0 .MEMORY .M_G0
+   85 read .B0 .MEMORY .M_B0
+   86 read .R1 .MEMORY .M_R1
+   87 read .G1 .MEMORY .M_G1
+   88 read .B1 .MEMORY .M_B1
    89 draw stroke 1
    90 label *label17
    91 sensor *tmp36 .SWITCH @enabled
    92 op equal *tmp37 *tmp36 0
    93 jump *label19 equal *tmp37 false
-    * set *tmp38 @time
-    * set :start *tmp38
+   94 set :start @time
    95 print "Item/Liquid/Energy Level Display"
    96 draw clear 0 0 80
    97 draw color .R0 .G0 .B0 255
    98 draw rect 10 10 156 156
-    * set *tmp39 .CURRENT_INDEX
-    * read *tmp40 .MEMORY *tmp39
-    * set :head *tmp40
-    * set *tmp41 :head
-    * read *tmp42 .MEMORY *tmp41
-    * set :last *tmp42
+   99 read :head .MEMORY .CURRENT_INDEX
+  100 read :last .MEMORY :head
   101 print "\nIndex: "
   102 print :head
   103 print "\nValue: "
 
   108 op greaterThan *tmp43 :x 10
   109 jump *label22 equal *tmp43 false
   110 op sub :head :head 1
-    * set *tmp44 :head
-    * read *tmp45 .MEMORY *tmp44
-    * set :value *tmp45
-    * op sub *tmp46 :x 5
-    * set :x1 *tmp46
+  111 read :value .MEMORY :head
+  112 op sub :x1 :x 5
   113 draw line :x :last :x1 :value
   114 set :x :x1
   115 set :last :value
 
   123 print *tmp47
   124 op div *tmp48 @time .FREQ
   125 op ceil *tmp49 *tmp48
-    * op mul *tmp50 .FREQ *tmp49
-    * set :wait *tmp50
+  126 op mul :wait .FREQ *tmp49
   127 set :loops 0
   128 label *label23
   129 op lessThan *tmp51 @time :wait

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-4 instructions):
 
    26 print "\nFound: "
    27 print :block
    28 sensor *tmp16 :block @type
-    * jump *label8 equal *tmp16 @large-logic-display
-    * jump *label7 always
+   29 jump *label7 notEqual *tmp16 @large-logic-display
    30 label *label8
    31 set .DISPLAY :block
    32 jump *label6 always
    33 label *label7
-    * jump *label10 equal *tmp16 @message
-    * jump *label9 always
+   34 jump *label9 notEqual *tmp16 @message
    35 label *label10
    36 set .MESSAGE :block
    37 jump *label6 always
    38 label *label9
-    * jump *label12 equal *tmp16 @switch
-    * jump *label11 always
+   39 jump *label11 notEqual *tmp16 @switch
    40 label *label12
    41 set .SWITCH :block
    42 jump *label6 always
    43 label *label11
    44 jump *label14 equal *tmp16 @memory-bank
-    * jump *label14 equal *tmp16 @memory-cell
-    * jump *label13 always
+   45 jump *label13 notEqual *tmp16 @memory-cell
    46 label *label14
    47 set .MEMORY :block
    48 jump *label6 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-4 instructions):
 
    19 print "Item/Liquid/Energy Level Display"
    20 set :n @links
    21 label *label3
-    * op greaterThan *tmp12 :n 0
-    * jump *label5 equal *tmp12 false
+   22 jump *label5 lessThanEq :n 0
    23 op sub :n :n 1
    24 getlink :block :n
    25 print "\nFound: "
 
    84 draw stroke 1
    85 label *label17
    86 sensor *tmp36 .SWITCH @enabled
-    * op equal *tmp37 *tmp36 0
-    * jump *label19 equal *tmp37 false
+   87 jump *label19 notEqual *tmp36 0
    88 set :start @time
    89 print "Item/Liquid/Energy Level Display"
    90 draw clear 0 0 80
 
    99 draw color .R1 .G1 .B1 255
   100 set :x 159
   101 label *label20
-    * op greaterThan *tmp43 :x 10
-    * jump *label22 equal *tmp43 false
+  102 jump *label22 lessThanEq :x 10
   103 op sub :head :head 1
   104 read :value .MEMORY :head
   105 op sub :x1 :x 5
 
   119 op mul :wait .FREQ *tmp49
   120 set :loops 0
   121 label *label23
-    * op lessThan *tmp51 @time :wait
-    * jump *label25 equal *tmp51 false
+  122 jump *label25 greaterThanEq @time :wait
   123 op add :loops :loops 1
   124 label *label24
   125 jump *label23 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    44 jump *label13 notEqual *tmp16 @memory-cell
    45 label *label14
    46 set .MEMORY :block
-    * jump *label6 always
    47 label *label13
    48 label *label6
    49 label *label4
 
    66 op lor *tmp20 *tmp18 *tmp19
    67 jump *label15 equal *tmp20 false
    68 print "\nNo memory or display."
-    * jump *label16 always
    69 label *label15
    70 label *label16
    71 printflush .MESSAGE

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    14 label *label0
    15 op equal *tmp8 .MEMORY null
    16 op equal *tmp9 .DISPLAY null
-    * op lor *tmp10 *tmp8 *tmp9
+   17 op or *tmp10 *tmp8 *tmp9
    18 jump *label2 equal *tmp10 false
    19 print "Item/Liquid/Energy Level Display"
    20 set :n @links
 
    63 print .DISPLAY
    64 op equal *tmp18 .MEMORY null
    65 op equal *tmp19 .DISPLAY null
-    * op lor *tmp20 *tmp18 *tmp19
+   66 op or *tmp20 *tmp18 *tmp19
    67 jump *label15 equal *tmp20 false
    68 print "\nNo memory or display."
    69 label *label15

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 set .MESSAGE null
     4 set .SWITCH null
     5 set .M_START_INDEX 0
-    * op add .M_CURRENT_INDEX .M_START_INDEX 1
-    * op add .M_END_INDEX .M_CURRENT_INDEX 1
-    * op add .M_R0 .M_END_INDEX 1
-    * op add .M_G0 .M_R0 1
-    * op add .M_B0 .M_G0 1
-    * op add .M_R1 .M_B0 1
-    * op add .M_G1 .M_R1 1
-    * op add .M_B1 .M_G1 1
+    6 op add .M_CURRENT_INDEX 0 1
+    7 op add .M_END_INDEX 1 1
+    8 op add .M_R0 2 1
+    9 op add .M_G0 3 1
+   10 op add .M_B0 4 1
+   11 op add .M_R1 5 1
+   12 op add .M_G1 6 1
+   13 op add .M_B1 7 1
    14 label *label0
    15 op equal *tmp8 .MEMORY null
    16 op equal *tmp9 .DISPLAY null
 
    72 label *label1
    73 jump *label0 always
    74 label *label2
-    * read .CURRENT_INDEX .MEMORY .M_CURRENT_INDEX
-    * read .R0 .MEMORY .M_R0
-    * read .G0 .MEMORY .M_G0
-    * read .B0 .MEMORY .M_B0
-    * read .R1 .MEMORY .M_R1
-    * read .G1 .MEMORY .M_G1
-    * read .B1 .MEMORY .M_B1
+   75 read .CURRENT_INDEX .MEMORY 1
+   76 read .R0 .MEMORY 3
+   77 read .G0 .MEMORY 4
+   78 read .B0 .MEMORY 5
+   79 read .R1 .MEMORY 6
+   80 read .G1 .MEMORY 7
+   81 read .B1 .MEMORY 8
    82 draw stroke 1
    83 label *label17
    84 sensor *tmp36 .SWITCH @enabled
 
   112 op sub *tmp47 @time :start
   113 print "\nTime: "
   114 print *tmp47
-    * op div *tmp48 @time .FREQ
+  115 op div *tmp48 @time 100
   116 op ceil *tmp49 *tmp48
-    * op mul :wait .FREQ *tmp49
+  117 op mul :wait 100 *tmp49
   118 set :loops 0
   119 label *label23
   120 jump *label25 greaterThanEq @time :wait

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-10 instructions):
-    * set .FREQ 100
     0 set .DISPLAY null
     1 set .MEMORY null
     2 set .MESSAGE null
     3 set .SWITCH null
-    * set .M_START_INDEX 0
-    * op add .M_CURRENT_INDEX 0 1
-    * op add .M_END_INDEX 1 1
-    * op add .M_R0 2 1
-    * op add .M_G0 3 1
-    * op add .M_B0 4 1
-    * op add .M_R1 5 1
-    * op add .M_G1 6 1
-    * op add .M_B1 7 1
     4 label *label0
     5 op equal *tmp8 .MEMORY null
     6 op equal *tmp9 .DISPLAY null

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1 (-1 instructions):
 
    10 set :n @links
    11 label *label3
    12 jump *label5 lessThanEq :n 0
+   13 label *label26
    14 op sub :n :n 1
    15 getlink :block :n
    16 print "\nFound: "
 
    38 label *label13
    39 label *label6
    40 label *label4
-    * jump *label3 always
+   41 jump *label26 greaterThan :n 0
    42 label *label5
    43 print "\n"
    44 print "Message: "
 
    88 draw color .R1 .G1 .B1 255
    89 set :x 159
    90 label *label20
-    * jump *label22 lessThanEq :x 10
+   91 label *label27
    92 op sub :head :head 1
    93 read :value .MEMORY :head
    94 op sub :x1 :x 5
 
    96 set :x :x1
    97 set :last :value
    98 label *label21
-    * jump *label20 always
+   99 jump *label27 greaterThan :x 10
   100 label *label22
   101 draw color 255 255 255 255
   102 draw lineRect 10 10 156 156
 
   109 set :loops 0
   110 label *label23
   111 jump *label25 greaterThanEq @time :wait
+  112 label *label28
   113 op add :loops :loops 1
   114 label *label24
-    * jump *label23 always
+  115 jump *label28 lessThan @time :wait
   116 label *label25
   117 drawflush .DISPLAY
   118 print "\nWait loops: "

Modifications by Partial loop rotation at line 49:1 (+1 instructions):
 
    74 label *label17
    75 sensor *tmp36 .SWITCH @enabled
    76 jump *label19 notEqual *tmp36 0
+   77 label *label29
    78 set :start @time
    79 print "Item/Liquid/Energy Level Display"
    80 draw clear 0 0 80
 
   120 print :loops
   121 printflush .MESSAGE
   122 label *label18
-    * jump *label17 always
+  123 sensor *tmp36 .SWITCH @enabled
+  124 jump *label29 equal *tmp36 0
   125 label *label19
   126 control enabled switch1 0
   127 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    97 set :x :x1
    98 set :last :value
    99 label *label21
-    * jump *label27 greaterThan :x 10
+  100 jump *label27 greaterThan :x1 10
   101 label *label22
   102 draw color 255 255 255 255
   103 draw lineRect 10 10 156 156

Modifications by Full loop rotation at line 17:1 (+2 instructions):
 
     5 op equal *tmp8 .MEMORY null
     6 op equal *tmp9 .DISPLAY null
     7 op or *tmp10 *tmp8 *tmp9
-    * jump *label2 equal *tmp10 false
+    8 label *label30
     9 print "Item/Liquid/Energy Level Display"
    10 set :n @links
    11 label *label3
 
    61 label *label16
    62 printflush .MESSAGE
    63 label *label1
-    * jump *label0 always
+   64 op equal *tmp8 .MEMORY null
+   65 op equal *tmp9 .DISPLAY null
+   66 op or *tmp10 *tmp8 *tmp9
+   67 jump *label30 notEqual *tmp10 false
    68 label *label2
    69 read .CURRENT_INDEX .MEMORY 1
    70 read .R0 .MEMORY 3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set .MESSAGE null
     3 set .SWITCH null
     4 label *label0
-    * op equal *tmp8 .MEMORY null
-    * op equal *tmp9 .DISPLAY null
-    * op or *tmp10 *tmp8 *tmp9
+    5 op equal *tmp8 null null
+    6 op equal *tmp9 null null
+    7 op or *tmp10 true true
     8 label *label30
     9 print "Item/Liquid/Energy Level Display"
    10 set :n @links
 
    63 label *label1
    64 op equal *tmp8 .MEMORY null
    65 op equal *tmp9 .DISPLAY null
-    * op or *tmp10 *tmp8 *tmp9
-    * jump *label30 notEqual *tmp10 false
+   66 op or *tmp10 *tmp18 *tmp19
+   67 jump *label30 notEqual *tmp20 false
    68 label *label2
    69 read .CURRENT_INDEX .MEMORY 1
    70 read .R0 .MEMORY 3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-6 instructions):
 
     2 set .MESSAGE null
     3 set .SWITCH null
     4 label *label0
-    * op equal *tmp8 null null
-    * op equal *tmp9 null null
-    * op or *tmp10 true true
     5 label *label30
     6 print "Item/Liquid/Energy Level Display"
     7 set :n @links
 
    58 label *label16
    59 printflush .MESSAGE
    60 label *label1
-    * op equal *tmp8 .MEMORY null
-    * op equal *tmp9 .DISPLAY null
-    * op or *tmp10 *tmp18 *tmp19
    61 jump *label30 notEqual *tmp20 false
    62 label *label2
    63 read .CURRENT_INDEX .MEMORY 1

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
   105 jump *label29 equal *tmp36 0
   106 label *label19
   107 control enabled switch1 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-5 instructions):
 
    31 label *label6
    32 jump *label26 greaterThan :n 0
    33 label *label5
-    * print "\n"
-    * print "Message: "
+   34 print "\nMessage: "
    35 print .MESSAGE
-    * print "\"
-    * print "nSwitch: "
+   36 print "\nSwitch: "
    37 print .SWITCH
-    * print "\"
-    * print "nMemory: "
+   38 print "\nMemory: "
    39 print .MEMORY
-    * print "\"
-    * print "nDisplay: "
+   40 print "\nDisplay: "
    41 print .DISPLAY
    42 op equal *tmp18 .MEMORY null
    43 op equal *tmp19 .DISPLAY null
 
    59 jump *label19 notEqual *tmp36 0
    60 label *label29
    61 set :start @time
-    * print "Item/Liquid/Energy Level Display"
    62 draw clear 0 0 80
    63 draw color .R0 .G0 .B0 255
    64 draw rect 10 10 156 156
    65 read :head .MEMORY .CURRENT_INDEX
    66 read :last .MEMORY :head
-    * print "\nIndex: "
+   67 print "Item/Liquid/Energy Level Display\nIndex: "
    68 print :head
    69 print "\nValue: "
    70 print :last

Final code before resolving virtual instructions:

    0:  set .DISPLAY null                                            DISPLAY = null;
    1:  set .MEMORY null                                             MEMORY = null;
    2:  set .MESSAGE null                                            MESSAGE = null;
    3:  set .SWITCH null                                             SWITCH = null;
        label *label30                                               while MEMORY == null || DISPLAY == null do
    4:  print "Item/Liquid/Energy Level Display"                     print("Item/Liquid/Energy Level Display");
    5:  set :n @links                                                n = @links;
    6:  jump *label5 lessThanEq :n 0                                 while n > 0 do
        label *label26                                               ...
    7:  op sub :n :n 1                                               n = n - 1;
    8:  getlink :block :n                                            block = getlink(n);
    9:  print "\nFound: "                                            print("\nFound: ", block);
   10:  print :block                                                 ...
   11:  sensor *tmp16 :block @type                                   case block.@type
   12:  jump *label7 notEqual *tmp16 @large-logic-display            ...
   13:  set .DISPLAY :block                                          when @large-logic-display       then DISPLAY = block;
   14:  jump *label6 always 0 0                                      case block.@type
        label *label7                                                ...
   15:  jump *label9 notEqual *tmp16 @message                        ...
   16:  set .MESSAGE :block                                          when @message                   then MESSAGE = block;
   17:  jump *label6 always 0 0                                      case block.@type
        label *label9                                                ...
   18:  jump *label11 notEqual *tmp16 @switch                        ...
   19:  set .SWITCH :block                                           when @switch                    then SWITCH = block;
   20:  jump *label6 always 0 0                                      case block.@type
        label *label11                                               ...
   21:  jump *label14 equal *tmp16 @memory-bank                      ...
   22:  jump *label13 notEqual *tmp16 @memory-cell                   ...
        label *label14                                               ...
   23:  set .MEMORY :block                                           when @memory-bank, @memory-cell then MEMORY = block;
        label *label13                                               case block.@type
        label *label6                                                ...
   24:  jump *label26 greaterThan :n 0                               while n > 0 do
        label *label5                                                ...
   25:  print "\nMessage: "                                          print($"\nMessage: $MESSAGE\nSwitch: $SWITCH\nMemory: $MEMORY\nDisplay: $DISPLAY");
   26:  print .MESSAGE                                               ...
   27:  print "\nSwitch: "                                           ...
   28:  print .SWITCH                                                ...
   29:  print "\nMemory: "                                           ...
   30:  print .MEMORY                                                ...
   31:  print "\nDisplay: "                                          ...
   32:  print .DISPLAY                                               ...
   33:  op equal *tmp18 .MEMORY null                                 if MEMORY == null || DISPLAY == null then
   34:  op equal *tmp19 .DISPLAY null                                ...
   35:  op or *tmp20 *tmp18 *tmp19                                   ...
   36:  jump *label15 equal *tmp20 false                             ...
   37:  print "\nNo memory or display."                              print("\nNo memory or display.");
        label *label15                                               if MEMORY == null || DISPLAY == null then
   38:  printflush .MESSAGE                                          printflush(MESSAGE);
   39:  jump *label30 notEqual *tmp20 false                          while MEMORY == null || DISPLAY == null do
   40:  read .CURRENT_INDEX .MEMORY 1                                CURRENT_INDEX = MEMORY[M_CURRENT_INDEX];
   41:  read .R0 .MEMORY 3                                           R0 = MEMORY[M_R0];
   42:  read .G0 .MEMORY 4                                           G0 = MEMORY[M_G0];
   43:  read .B0 .MEMORY 5                                           B0 = MEMORY[M_B0];
   44:  read .R1 .MEMORY 6                                           R1 = MEMORY[M_R1];
   45:  read .G1 .MEMORY 7                                           G1 = MEMORY[M_G1];
   46:  read .B1 .MEMORY 8                                           B1 = MEMORY[M_B1];
   47:  draw stroke 1 0 0 0 0 0                                      stroke(1);
   48:  sensor *tmp36 .SWITCH @enabled                               while SWITCH.@enabled == 0 do
   49:  jump *label19 notEqual *tmp36 0                              ...
        label *label29                                               ...
   50:  set :start @time                                             start = @time;
   51:  draw clear 0 0 80 0 0 0                                      clear(0,0,80);
   52:  draw color .R0 .G0 .B0 255 0 0                               color(R0,G0,B0,255);
   53:  draw rect 10 10 156 156 0 0                                  rect(10,10,156,156);
   54:  read :head .MEMORY .CURRENT_INDEX                            head = MEMORY[CURRENT_INDEX];
   55:  read :last .MEMORY :head                                     last = MEMORY[head];
   56:  print "Item/Liquid/Energy Level Display\nIndex: "            print("\nIndex: ", head);
   57:  print :head                                                  ...
   58:  print "\nValue: "                                            print("\nValue: ", last);
   59:  print :last                                                  ...
   60:  draw color .R1 .G1 .B1 255 0 0                               color(R1,G1,B1,255);
   61:  set :x 159                                                   x = 159;
        label *label27                                               while x > 10 do
   62:  op sub :head :head 1                                         head -= 1;
   63:  read :value .MEMORY :head                                    value = MEMORY[head];
   64:  op sub :x1 :x 5                                              x1 = x - 5;
   65:  draw line :x :last :x1 :value 0 0                            line(x, last, x1, value);
   66:  set :x :x1                                                   x = x1;
   67:  set :last :value                                             last = value;
   68:  jump *label27 greaterThan :x1 10                             while x > 10 do
   69:  draw color 255 255 255 255 0 0                               color(255,255,255,255);
   70:  draw lineRect 10 10 156 156 0 0                              lineRect(10,10,156,156);
   71:  op sub *tmp47 @time :start                                   print("\nTime: ", @time - start);
   72:  print "\nTime: "                                             ...
   73:  print *tmp47                                                 ...
   74:  op div *tmp48 @time 100                                      wait = FREQ * ceil(@time / FREQ);
   75:  op ceil *tmp49 *tmp48 0                                      ...
   76:  op mul :wait 100 *tmp49                                      ...
   77:  set :loops 0                                                 loops = 0;
   78:  jump *label25 greaterThanEq @time :wait                      while @time < wait do
        label *label28                                               ...
   79:  op add :loops :loops 1                                       loops += 1;
   80:  jump *label28 lessThan @time :wait                           while @time < wait do
        label *label25                                               ...
   81:  drawflush .DISPLAY                                           drawflush(DISPLAY);
   82:  print "\nWait loops: "                                       print("\nWait loops: ", loops);
   83:  print :loops                                                 ...
   84:  printflush .MESSAGE                                          printflush(MESSAGE);
   85:  sensor *tmp36 .SWITCH @enabled                               while SWITCH.@enabled == 0 do
   86:  jump *label29 equal *tmp36 0                                 ...
        label *label19                                               ...
   87:  control enabled switch1 0 0 0 0                              switch1.enabled = 0;


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    88     1x     88,0  <no function>

Performance: parsed in 179 ms, compiled in 304 ms, optimized in 293 ms, run in 13 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (418 steps):
Item/Liquid/Energy Level Display
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Memory: cell
Display: display
Execution exception at instruction 48: sensor *tmp36 .SWITCH @enabled:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
