   162 instructions before optimizations.
    34 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
     7 instructions eliminated by Dead Code Elimination (3 iterations).
     6 instructions eliminated by Jump Optimization (3 iterations).
     3 instructions eliminated by Single Step Elimination (2 passes, 5 iterations).
    16 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     2 instructions added by Loop Optimization (2 iterations).
     5 loops improved by Loop Optimization.
     4 instructions eliminated by Jump Straightening (3 iterations).
     5 instructions eliminated by Print Merging.
    88 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 901):
  * Replicate loop condition at line 49:1                        cost     1, benefit       25.0, efficiency       25.0 (-5 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    38 print "\nFound: "
    39 print :block
    40 sensor *tmp17 :block @type
-    * set *tmp18 *tmp17
-    * jump *label8 equal *tmp18 @large-logic-display
+   41 jump *label8 equal *tmp17 @large-logic-display
    42 jump *label7 always
    43 label *label8
    44 set .DISPLAY :block
    45 set *tmp16 .DISPLAY
    46 jump *label6 always
    47 label *label7
-    * jump *label10 equal *tmp18 @message
+   48 jump *label10 equal *tmp17 @message
    49 jump *label9 always
    50 label *label10
    51 set .MESSAGE :block
    52 set *tmp16 .MESSAGE
    53 jump *label6 always
    54 label *label9
-    * jump *label12 equal *tmp18 @switch
+   55 jump *label12 equal *tmp17 @switch
    56 jump *label11 always
    57 label *label12
    58 set .SWITCH :block
    59 set *tmp16 .SWITCH
    60 jump *label6 always
    61 label *label11
-    * jump *label14 equal *tmp18 @memory-bank
-    * jump *label14 equal *tmp18 @memory-cell
+   62 jump *label14 equal *tmp17 @memory-bank
+   63 jump *label14 equal *tmp17 @memory-cell
    64 jump *label13 always
    65 label *label14
    66 set .MEMORY :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-7 instructions):
 
    42 jump *label7 always
    43 label *label8
    44 set .DISPLAY :block
-    * set *tmp16 .DISPLAY
    45 jump *label6 always
    46 label *label7
    47 jump *label10 equal *tmp17 @message
    48 jump *label9 always
    49 label *label10
    50 set .MESSAGE :block
-    * set *tmp16 .MESSAGE
    51 jump *label6 always
    52 label *label9
    53 jump *label12 equal *tmp17 @switch
    54 jump *label11 always
    55 label *label12
    56 set .SWITCH :block
-    * set *tmp16 .SWITCH
    57 jump *label6 always
    58 label *label11
    59 jump *label14 equal *tmp17 @memory-bank
 
    61 jump *label13 always
    62 label *label14
    63 set .MEMORY :block
-    * set *tmp16 .MEMORY
    64 jump *label6 always
    65 label *label13
-    * set *tmp16 null
    66 label *label6
    67 label *label4
    68 jump *label3 always
 
    85 op notEqual *tmp21 *tmp22 false
    86 jump *label15 equal *tmp21 false
    87 print "\nNo memory or display."
-    * set *tmp23 "\nNo memory or display."
    88 jump *label16 always
    89 label *label15
-    * set *tmp23 null
    90 label *label16
    91 printflush .MESSAGE
    92 label *label1

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-34 instructions):
 
     3 set .MESSAGE null
     4 set .SWITCH null
     5 set .M_START_INDEX 0
-    * op add *tmp0 .M_START_INDEX 1
-    * set .M_CURRENT_INDEX *tmp0
-    * op add *tmp1 .M_CURRENT_INDEX 1
-    * set .M_END_INDEX *tmp1
-    * op add *tmp2 .M_END_INDEX 1
-    * set .M_R0 *tmp2
-    * op add *tmp3 .M_R0 1
-    * set .M_G0 *tmp3
-    * op add *tmp4 .M_G0 1
-    * set .M_B0 *tmp4
-    * op add *tmp5 .M_B0 1
-    * set .M_R1 *tmp5
-    * op add *tmp6 .M_R1 1
-    * set .M_G1 *tmp6
-    * op add *tmp7 .M_G1 1
-    * set .M_B1 *tmp7
+    6 op add .M_CURRENT_INDEX .M_START_INDEX 1
+    7 op add .M_END_INDEX .M_CURRENT_INDEX 1
+    8 op add .M_R0 .M_END_INDEX 1
+    9 op add .M_G0 .M_R0 1
+   10 op add .M_B0 .M_G0 1
+   11 op add .M_R1 .M_B0 1
+   12 op add .M_G1 .M_R1 1
+   13 op add .M_B1 .M_G1 1
    14 label *label0
    15 op equal *tmp8 .MEMORY null
    16 op equal *tmp9 .DISPLAY null
 
    18 op notEqual *tmp10 *tmp11 false
    19 jump *label2 equal *tmp10 false
    20 print "Item/Liquid/Energy Level Display"
-    * set *tmp12 @links
-    * set :n *tmp12
+   21 set :n @links
    22 label *label3
    23 op greaterThan *tmp13 :n 0
    24 jump *label5 equal *tmp13 false
-    * op sub *tmp14 :n 1
-    * set :n *tmp14
-    * getlink *tmp15 :n
-    * set :block *tmp15
+   25 op sub :n :n 1
+   26 getlink :block :n
    27 print "\nFound: "
    28 print :block
    29 sensor *tmp17 :block @type
 
    81 label *label1
    82 jump *label0 always
    83 label *label2
-    * set *tmp24 .M_CURRENT_INDEX
-    * read *tmp25 .MEMORY *tmp24
-    * set .CURRENT_INDEX *tmp25
-    * set *tmp26 .M_R0
-    * read *tmp27 .MEMORY *tmp26
-    * set .R0 *tmp27
-    * set *tmp28 .M_G0
-    * read *tmp29 .MEMORY *tmp28
-    * set .G0 *tmp29
-    * set *tmp30 .M_B0
-    * read *tmp31 .MEMORY *tmp30
-    * set .B0 *tmp31
-    * set *tmp32 .M_R1
-    * read *tmp33 .MEMORY *tmp32
-    * set .R1 *tmp33
-    * set *tmp34 .M_G1
-    * read *tmp35 .MEMORY *tmp34
-    * set .G1 *tmp35
-    * set *tmp36 .M_B1
-    * read *tmp37 .MEMORY *tmp36
-    * set .B1 *tmp37
+   84 read .CURRENT_INDEX .MEMORY .M_CURRENT_INDEX
+   85 read .R0 .MEMORY .M_R0
+   86 read .G0 .MEMORY .M_G0
+   87 read .B0 .MEMORY .M_B0
+   88 read .R1 .MEMORY .M_R1
+   89 read .G1 .MEMORY .M_G1
+   90 read .B1 .MEMORY .M_B1
    91 draw stroke 1
    92 label *label17
    93 sensor *tmp38 .SWITCH @enabled
    94 op equal *tmp39 *tmp38 0
    95 jump *label19 equal *tmp39 false
-    * set *tmp40 @time
-    * set :start *tmp40
+   96 set :start @time
    97 print "Item/Liquid/Energy Level Display"
    98 draw clear 0 0 80
    99 draw color .R0 .G0 .B0 255
   100 draw rect 10 10 156 156
-    * set *tmp41 .CURRENT_INDEX
-    * read *tmp42 .MEMORY *tmp41
-    * set :head *tmp42
-    * set *tmp43 :head
-    * read *tmp44 .MEMORY *tmp43
-    * set :last *tmp44
+  101 read :head .MEMORY .CURRENT_INDEX
+  102 read :last .MEMORY :head
   103 print "\nIndex: "
   104 print :head
   105 print "\nValue: "
 
   110 op greaterThan *tmp45 :x 10
   111 jump *label22 equal *tmp45 false
   112 op sub :head :head 1
-    * set *tmp46 :head
-    * read *tmp47 .MEMORY *tmp46
-    * set :value *tmp47
-    * op sub *tmp48 :x 5
-    * set :x1 *tmp48
+  113 read :value .MEMORY :head
+  114 op sub :x1 :x 5
   115 draw line :x :last :x1 :value
   116 set :x :x1
   117 set :last :value
 
   125 print *tmp49
   126 op div *tmp50 @time .FREQ
   127 op ceil *tmp51 *tmp50
-    * op mul *tmp52 .FREQ *tmp51
-    * set :wait *tmp52
+  128 op mul :wait .FREQ *tmp51
   129 set :loops 0
   130 label *label23
   131 op lessThan *tmp53 @time :wait

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-4 instructions):
 
    27 print "\nFound: "
    28 print :block
    29 sensor *tmp17 :block @type
-    * jump *label8 equal *tmp17 @large-logic-display
-    * jump *label7 always
+   30 jump *label7 notEqual *tmp17 @large-logic-display
    31 label *label8
    32 set .DISPLAY :block
    33 jump *label6 always
    34 label *label7
-    * jump *label10 equal *tmp17 @message
-    * jump *label9 always
+   35 jump *label9 notEqual *tmp17 @message
    36 label *label10
    37 set .MESSAGE :block
    38 jump *label6 always
    39 label *label9
-    * jump *label12 equal *tmp17 @switch
-    * jump *label11 always
+   40 jump *label11 notEqual *tmp17 @switch
    41 label *label12
    42 set .SWITCH :block
    43 jump *label6 always
    44 label *label11
    45 jump *label14 equal *tmp17 @memory-bank
-    * jump *label14 equal *tmp17 @memory-cell
-    * jump *label13 always
+   46 jump *label13 notEqual *tmp17 @memory-cell
    47 label *label14
    48 set .MEMORY :block
    49 jump *label6 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-6 instructions):
 
    15 op equal *tmp8 .MEMORY null
    16 op equal *tmp9 .DISPLAY null
    17 op or *tmp11 *tmp8 *tmp9
-    * op notEqual *tmp10 *tmp11 false
-    * jump *label2 equal *tmp10 false
+   18 jump *label2 equal *tmp11 false
    19 print "Item/Liquid/Energy Level Display"
    20 set :n @links
    21 label *label3
-    * op greaterThan *tmp13 :n 0
-    * jump *label5 equal *tmp13 false
+   22 jump *label5 lessThanEq :n 0
    23 op sub :n :n 1
    24 getlink :block :n
    25 print "\nFound: "
 
    65 op equal *tmp19 .MEMORY null
    66 op equal *tmp20 .DISPLAY null
    67 op or *tmp22 *tmp19 *tmp20
-    * op notEqual *tmp21 *tmp22 false
-    * jump *label15 equal *tmp21 false
+   68 jump *label15 equal *tmp22 false
    69 print "\nNo memory or display."
    70 jump *label16 always
    71 label *label15
 
    84 draw stroke 1
    85 label *label17
    86 sensor *tmp38 .SWITCH @enabled
-    * op equal *tmp39 *tmp38 0
-    * jump *label19 equal *tmp39 false
+   87 jump *label19 notEqual *tmp38 0
    88 set :start @time
    89 print "Item/Liquid/Energy Level Display"
    90 draw clear 0 0 80
 
    99 draw color .R1 .G1 .B1 255
   100 set :x 159
   101 label *label20
-    * op greaterThan *tmp45 :x 10
-    * jump *label22 equal *tmp45 false
+  102 jump *label22 lessThanEq :x 10
   103 op sub :head :head 1
   104 read :value .MEMORY :head
   105 op sub :x1 :x 5
 
   119 op mul :wait .FREQ *tmp51
   120 set :loops 0
   121 label *label23
-    * op lessThan *tmp53 @time :wait
-    * jump *label25 equal *tmp53 false
+  122 jump *label25 greaterThanEq @time :wait
   123 op add :loops :loops 1
   124 label *label24
   125 jump *label23 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    44 jump *label13 notEqual *tmp17 @memory-cell
    45 label *label14
    46 set .MEMORY :block
-    * jump *label6 always
    47 label *label13
    48 label *label6
    49 label *label4
 
    66 op or *tmp22 *tmp19 *tmp20
    67 jump *label15 equal *tmp22 false
    68 print "\nNo memory or display."
-    * jump *label16 always
    69 label *label15
    70 label *label16
    71 printflush .MESSAGE

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 set .MESSAGE null
     4 set .SWITCH null
     5 set .M_START_INDEX 0
-    * op add .M_CURRENT_INDEX .M_START_INDEX 1
-    * op add .M_END_INDEX .M_CURRENT_INDEX 1
-    * op add .M_R0 .M_END_INDEX 1
-    * op add .M_G0 .M_R0 1
-    * op add .M_B0 .M_G0 1
-    * op add .M_R1 .M_B0 1
-    * op add .M_G1 .M_R1 1
-    * op add .M_B1 .M_G1 1
+    6 op add .M_CURRENT_INDEX 0 1
+    7 op add .M_END_INDEX 1 1
+    8 op add .M_R0 2 1
+    9 op add .M_G0 3 1
+   10 op add .M_B0 4 1
+   11 op add .M_R1 5 1
+   12 op add .M_G1 6 1
+   13 op add .M_B1 7 1
    14 label *label0
    15 op equal *tmp8 .MEMORY null
    16 op equal *tmp9 .DISPLAY null
 
    72 label *label1
    73 jump *label0 always
    74 label *label2
-    * read .CURRENT_INDEX .MEMORY .M_CURRENT_INDEX
-    * read .R0 .MEMORY .M_R0
-    * read .G0 .MEMORY .M_G0
-    * read .B0 .MEMORY .M_B0
-    * read .R1 .MEMORY .M_R1
-    * read .G1 .MEMORY .M_G1
-    * read .B1 .MEMORY .M_B1
+   75 read .CURRENT_INDEX .MEMORY 1
+   76 read .R0 .MEMORY 3
+   77 read .G0 .MEMORY 4
+   78 read .B0 .MEMORY 5
+   79 read .R1 .MEMORY 6
+   80 read .G1 .MEMORY 7
+   81 read .B1 .MEMORY 8
    82 draw stroke 1
    83 label *label17
    84 sensor *tmp38 .SWITCH @enabled
 
   112 op sub *tmp49 @time :start
   113 print "\nTime: "
   114 print *tmp49
-    * op div *tmp50 @time .FREQ
+  115 op div *tmp50 @time 100
   116 op ceil *tmp51 *tmp50
-    * op mul :wait .FREQ *tmp51
+  117 op mul :wait 100 *tmp51
   118 set :loops 0
   119 label *label23
   120 jump *label25 greaterThanEq @time :wait

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-10 instructions):
-    * set .FREQ 100
     0 set .DISPLAY null
     1 set .MEMORY null
     2 set .MESSAGE null
     3 set .SWITCH null
-    * set .M_START_INDEX 0
-    * op add .M_CURRENT_INDEX 0 1
-    * op add .M_END_INDEX 1 1
-    * op add .M_R0 2 1
-    * op add .M_G0 3 1
-    * op add .M_B0 4 1
-    * op add .M_R1 5 1
-    * op add .M_G1 6 1
-    * op add .M_B1 7 1
     4 label *label0
     5 op equal *tmp8 .MEMORY null
     6 op equal *tmp9 .DISPLAY null

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (+1 instructions):
 
     5 op equal *tmp8 .MEMORY null
     6 op equal *tmp9 .DISPLAY null
     7 op or *tmp11 *tmp8 *tmp9
-    * jump *label2 equal *tmp11 false
+    8 label *label26
     9 print "Item/Liquid/Energy Level Display"
    10 set :n @links
    11 label *label3
    12 jump *label5 lessThanEq :n 0
+   13 label *label27
    14 op sub :n :n 1
    15 getlink :block :n
    16 print "\nFound: "
 
    38 label *label13
    39 label *label6
    40 label *label4
-    * jump *label3 always
+   41 jump *label27 greaterThan :n 0
    42 label *label5
    43 print "\n"
    44 print "Message: "
 
    61 label *label16
    62 printflush .MESSAGE
    63 label *label1
-    * jump *label0 always
+   64 op equal *tmp8 .MEMORY null
+   65 op equal *tmp9 .DISPLAY null
+   66 op or *tmp11 *tmp8 *tmp9
+   67 jump *label26 notEqual *tmp11 false
    68 label *label2
    69 read .CURRENT_INDEX .MEMORY 1
    70 read .R0 .MEMORY 3
 
    91 draw color .R1 .G1 .B1 255
    92 set :x 159
    93 label *label20
-    * jump *label22 lessThanEq :x 10
+   94 label *label28
    95 op sub :head :head 1
    96 read :value .MEMORY :head
    97 op sub :x1 :x 5
 
    99 set :x :x1
   100 set :last :value
   101 label *label21
-    * jump *label20 always
+  102 jump *label28 greaterThan :x 10
   103 label *label22
   104 draw color 255 255 255 255
   105 draw lineRect 10 10 156 156
 
   112 set :loops 0
   113 label *label23
   114 jump *label25 greaterThanEq @time :wait
+  115 label *label29
   116 op add :loops :loops 1
   117 label *label24
-    * jump *label23 always
+  118 jump *label29 lessThan @time :wait
   119 label *label25
   120 drawflush .DISPLAY
   121 print "\nWait loops: "

Modifications by Replicate loop condition at line 49:1 (+1 instructions):
 
    77 label *label17
    78 sensor *tmp38 .SWITCH @enabled
    79 jump *label19 notEqual *tmp38 0
+   80 label *label30
    81 set :start @time
    82 print "Item/Liquid/Energy Level Display"
    83 draw clear 0 0 80
 
   123 print :loops
   124 printflush .MESSAGE
   125 label *label18
-    * jump *label17 always
+  126 sensor *tmp38 .SWITCH @enabled
+  127 jump *label30 equal *tmp38 0
   128 label *label19
   129 control enabled switch1 0
   130 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set .MESSAGE null
     3 set .SWITCH null
     4 label *label0
-    * op equal *tmp8 .MEMORY null
-    * op equal *tmp9 .DISPLAY null
-    * op or *tmp11 *tmp8 *tmp9
+    5 op equal *tmp8 null null
+    6 op equal *tmp9 null null
+    7 op or *tmp11 true true
     8 label *label26
     9 print "Item/Liquid/Energy Level Display"
    10 set :n @links
 
    63 label *label1
    64 op equal *tmp8 .MEMORY null
    65 op equal *tmp9 .DISPLAY null
-    * op or *tmp11 *tmp8 *tmp9
-    * jump *label26 notEqual *tmp11 false
+   66 op or *tmp11 *tmp19 *tmp20
+   67 jump *label26 notEqual *tmp22 false
    68 label *label2
    69 read .CURRENT_INDEX .MEMORY 1
    70 read .R0 .MEMORY 3
 
   100 set :x :x1
   101 set :last :value
   102 label *label21
-    * jump *label28 greaterThan :x 10
+  103 jump *label28 greaterThan :x1 10
   104 label *label22
   105 draw color 255 255 255 255
   106 draw lineRect 10 10 156 156

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-6 instructions):
 
     2 set .MESSAGE null
     3 set .SWITCH null
     4 label *label0
-    * op equal *tmp8 null null
-    * op equal *tmp9 null null
-    * op or *tmp11 true true
     5 label *label26
     6 print "Item/Liquid/Energy Level Display"
     7 set :n @links
 
    58 label *label16
    59 printflush .MESSAGE
    60 label *label1
-    * op equal *tmp8 .MEMORY null
-    * op equal *tmp9 .DISPLAY null
-    * op or *tmp11 *tmp19 *tmp20
    61 jump *label26 notEqual *tmp22 false
    62 label *label2
    63 read .CURRENT_INDEX .MEMORY 1

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   121 jump *label30 equal *tmp38 0
   122 label *label19
   123 control enabled switch1 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-5 instructions):
 
    37 label *label4
    38 jump *label27 greaterThan :n 0
    39 label *label5
-    * print "\n"
-    * print "Message: "
+   40 print "\nMessage: "
    41 print .MESSAGE
-    * print "\"
-    * print "nSwitch: "
+   42 print "\nSwitch: "
    43 print .SWITCH
-    * print "\"
-    * print "nMemory: "
+   44 print "\nMemory: "
    45 print .MEMORY
-    * print "\"
-    * print "nDisplay: "
+   46 print "\nDisplay: "
    47 print .DISPLAY
    48 op equal *tmp19 .MEMORY null
    49 op equal *tmp20 .DISPLAY null
 
    69 jump *label19 notEqual *tmp38 0
    70 label *label30
    71 set :start @time
-    * print "Item/Liquid/Energy Level Display"
    72 draw clear 0 0 80
    73 draw color .R0 .G0 .B0 255
    74 draw rect 10 10 156 156
    75 read :head .MEMORY .CURRENT_INDEX
    76 read :last .MEMORY :head
-    * print "\nIndex: "
+   77 print "Item/Liquid/Energy Level Display\nIndex: "
    78 print :head
    79 print "\nValue: "
    80 print :last

Final code before resolving virtual instructions:

    0:  set .DISPLAY null                                            DISPLAY = null;
    1:  set .MEMORY null                                             MEMORY = null;
    2:  set .MESSAGE null                                            MESSAGE = null;
    3:  set .SWITCH null                                             SWITCH = null;
        label *label26                                               while MEMORY == null || DISPLAY == null do
    4:  print "Item/Liquid/Energy Level Display"                     print("Item/Liquid/Energy Level Display");
    5:  set :n @links                                                n = @links;
    6:  jump *label5 lessThanEq :n 0                                 while n > 0 do
        label *label27                                               ...
    7:  op sub :n :n 1                                               n = n - 1;
    8:  getlink :block :n                                            block = getlink(n);
    9:  print "\nFound: "                                            print("\nFound: ", block);
   10:  print :block                                                 ...
   11:  sensor *tmp17 :block @type                                   case block.@type
   12:  jump *label7 notEqual *tmp17 @large-logic-display            ...
   13:  set .DISPLAY :block                                          when @large-logic-display       then DISPLAY = block;
   14:  jump *label6 always 0 0                                      case block.@type
        label *label7                                                ...
   15:  jump *label9 notEqual *tmp17 @message                        ...
   16:  set .MESSAGE :block                                          when @message                   then MESSAGE = block;
   17:  jump *label6 always 0 0                                      case block.@type
        label *label9                                                ...
   18:  jump *label11 notEqual *tmp17 @switch                        ...
   19:  set .SWITCH :block                                           when @switch                    then SWITCH = block;
   20:  jump *label6 always 0 0                                      case block.@type
        label *label11                                               ...
   21:  jump *label14 equal *tmp17 @memory-bank                      ...
   22:  jump *label13 notEqual *tmp17 @memory-cell                   ...
        label *label14                                               ...
   23:  set .MEMORY :block                                           when @memory-bank, @memory-cell then MEMORY = block;
        label *label13                                               case block.@type
        label *label6                                                ...
   24:  jump *label27 greaterThan :n 0                               while n > 0 do
        label *label5                                                ...
   25:  print "\nMessage: "                                          print($"\nMessage: $MESSAGE\nSwitch: $SWITCH\nMemory: $MEMORY\nDisplay: $DISPLAY");
   26:  print .MESSAGE                                               ...
   27:  print "\nSwitch: "                                           ...
   28:  print .SWITCH                                                ...
   29:  print "\nMemory: "                                           ...
   30:  print .MEMORY                                                ...
   31:  print "\nDisplay: "                                          ...
   32:  print .DISPLAY                                               ...
   33:  op equal *tmp19 .MEMORY null                                 if MEMORY == null || DISPLAY == null then
   34:  op equal *tmp20 .DISPLAY null                                ...
   35:  op or *tmp22 *tmp19 *tmp20                                   ...
   36:  jump *label15 equal *tmp22 false                             ...
   37:  print "\nNo memory or display."                              print("\nNo memory or display.");
        label *label15                                               if MEMORY == null || DISPLAY == null then
   38:  printflush .MESSAGE                                          printflush(MESSAGE);
   39:  jump *label26 notEqual *tmp22 false                          while MEMORY == null || DISPLAY == null do
   40:  read .CURRENT_INDEX .MEMORY 1                                CURRENT_INDEX = MEMORY[M_CURRENT_INDEX];
   41:  read .R0 .MEMORY 3                                           R0 = MEMORY[M_R0];
   42:  read .G0 .MEMORY 4                                           G0 = MEMORY[M_G0];
   43:  read .B0 .MEMORY 5                                           B0 = MEMORY[M_B0];
   44:  read .R1 .MEMORY 6                                           R1 = MEMORY[M_R1];
   45:  read .G1 .MEMORY 7                                           G1 = MEMORY[M_G1];
   46:  read .B1 .MEMORY 8                                           B1 = MEMORY[M_B1];
   47:  draw stroke 1 0 0 0 0 0                                      stroke(1);
   48:  sensor *tmp38 .SWITCH @enabled                               while SWITCH.@enabled == 0 do
   49:  jump *label19 notEqual *tmp38 0                              ...
        label *label30                                               ...
   50:  set :start @time                                             start = @time;
   51:  draw clear 0 0 80 0 0 0                                      clear(0,0,80);
   52:  draw color .R0 .G0 .B0 255 0 0                               color(R0,G0,B0,255);
   53:  draw rect 10 10 156 156 0 0                                  rect(10,10,156,156);
   54:  read :head .MEMORY .CURRENT_INDEX                            head = MEMORY[CURRENT_INDEX];
   55:  read :last .MEMORY :head                                     last = MEMORY[head];
   56:  print "Item/Liquid/Energy Level Display\nIndex: "            print("\nIndex: ", head);
   57:  print :head                                                  ...
   58:  print "\nValue: "                                            print("\nValue: ", last);
   59:  print :last                                                  ...
   60:  draw color .R1 .G1 .B1 255 0 0                               color(R1,G1,B1,255);
   61:  set :x 159                                                   x = 159;
        label *label28                                               while x > 10 do
   62:  op sub :head :head 1                                         head -= 1;
   63:  read :value .MEMORY :head                                    value = MEMORY[head];
   64:  op sub :x1 :x 5                                              x1 = x - 5;
   65:  draw line :x :last :x1 :value 0 0                            line(x, last, x1, value);
   66:  set :x :x1                                                   x = x1;
   67:  set :last :value                                             last = value;
   68:  jump *label28 greaterThan :x1 10                             while x > 10 do
   69:  draw color 255 255 255 255 0 0                               color(255,255,255,255);
   70:  draw lineRect 10 10 156 156 0 0                              lineRect(10,10,156,156);
   71:  op sub *tmp49 @time :start                                   print("\nTime: ", @time - start);
   72:  print "\nTime: "                                             ...
   73:  print *tmp49                                                 ...
   74:  op div *tmp50 @time 100                                      wait = FREQ * ceil(@time / FREQ);
   75:  op ceil *tmp51 *tmp50 0                                      ...
   76:  op mul :wait 100 *tmp51                                      ...
   77:  set :loops 0                                                 loops = 0;
   78:  jump *label25 greaterThanEq @time :wait                      while @time < wait do
        label *label29                                               ...
   79:  op add :loops :loops 1                                       loops += 1;
   80:  jump *label29 lessThan @time :wait                           while @time < wait do
        label *label25                                               ...
   81:  drawflush .DISPLAY                                           drawflush(DISPLAY);
   82:  print "\nWait loops: "                                       print("\nWait loops: ", loops);
   83:  print :loops                                                 ...
   84:  printflush .MESSAGE                                          printflush(MESSAGE);
   85:  sensor *tmp38 .SWITCH @enabled                               while SWITCH.@enabled == 0 do
   86:  jump *label30 equal *tmp38 0                                 ...
        label *label19                                               ...
   87:  control enabled switch1 0 0 0 0                              switch1.enabled = 0;


Performance: parsed in 144 ms, compiled in 215 ms, optimized in 161 ms, run in 18 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (418 steps):
Item/Liquid/Energy Level Display
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Memory: cell
Display: display
Execution exception at instruction 48: sensor *tmp38 .SWITCH @enabled:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
