    91 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (6 iterations).
    10 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (6 iterations).
     6 instructions eliminated by Condition Optimization (7 iterations).
    10 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
     1 instructions eliminated by Boolean Optimization (7 iterations).
       1 fully-evaluated expressions optimized using selects.
     9 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
   102 instructions added by Loop Unrolling (4 iterations).
     1 loops unrolled by Loop Unrolling.
     5 instructions eliminated by Jump Straightening (7 iterations).
     6 instructions updated by Jump Threading.
     9 instructions eliminated by Unreachable Code Elimination (2 passes, 3 iterations).
   140 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 937):
  * Unroll iteration loop at line 22:9                           size  +121, benefit      475.0, efficiency      3.926 (+97 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-8 instructions):
 
    40 op equal *tmp2 :findUnit:type :findUnit:currentType
    41 jump *label20 equal *tmp2 false
    42 jump *label14 always
-    * set *tmp3 null
    43 jump *label21 always
    44 label *label20
-    * set *tmp3 null
    45 label *label21
    46 print "Finding unit: "
    47 print :findUnit:type
 
    53 jump *label23 equal *tmp5 false
    54 set *tmp4 null
    55 jump *label22 always
-    * set *tmp6 null
    56 jump *label24 always
    57 label *label23
-    * set *tmp6 null
    58 label *label24
    59 set :findFreeUnit:first_unit @unit
    60 label *label25
 
    64 ucontrol flag :findFreeUnit:initial_flag
    65 set *tmp4 @unit
    66 jump *label22 always
-    * set *tmp9 null
    67 jump *label29 always
    68 label *label28
    69 sensor *tmp10 :findFreeUnit:first_unit @dead
 
    76 label *label30
    77 set *tmp12 null
    78 label *label31
-    * set *tmp9 *tmp12
    79 label *label29
    80 ubind :findFreeUnit:unit_type
    81 label *label26
 
    94 printflush message1
    95 set :findUnit*retval :findUnit:unit
    96 jump *label8 always
-    * set *tmp16 null
    97 jump *label33 always
    98 label *label32
-    * set *tmp16 null
    99 label *label33
   100 label *label13
   101 multijump *tmp1 0 0 (m:marker0)

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
    71 jump *label30 equal *tmp11 false
    72 set *tmp13 @unit
    73 set :findFreeUnit:first_unit *tmp13
-    * set *tmp12 :findFreeUnit:first_unit
    74 jump *label31 always
    75 label *label30
-    * set *tmp12 null
    76 label *label31
    77 label *label29
    78 ubind :findFreeUnit:unit_type

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
    11 jump *label7 always
    12 end
    13 label *label0
-    * sensor *tmp0 :findUnit:currentUnit @type
-    * set :findUnit:currentType *tmp0
+   14 sensor :findUnit:currentType :findUnit:currentUnit @type
    15 print "Trying to find unit better than "
    16 print :findUnit:currentUnit
    17 printflush message1
 
    68 sensor *tmp10 :findFreeUnit:first_unit @dead
    69 op equal *tmp11 *tmp10 1
    70 jump *label30 equal *tmp11 false
-    * set *tmp13 @unit
-    * set :findFreeUnit:first_unit *tmp13
+   71 set :findFreeUnit:first_unit @unit
    72 jump *label31 always
    73 label *label30
    74 label *label31

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    16 print :findUnit:currentUnit
    17 printflush message1
    18 label *label9
-    * jump *label11 equal true false
    19 set :findUnit:type .types*0
    20 setaddr *tmp1 *label15
    21 jump *label12 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-6 instructions):
 
    35 set :findUnit:type .types*4
    36 setaddr *tmp1 *label19
    37 label *label12
-    * op equal *tmp2 :findUnit:type :findUnit:currentType
-    * jump *label20 equal *tmp2 false
+   38 jump *label20 notEqual :findUnit:type :findUnit:currentType
    39 jump *label14 always
    40 jump *label21 always
    41 label *label20
 
    46 set :findFreeUnit:unit_type :findUnit:type
    47 set :findFreeUnit:initial_flag 0
    48 ubind :findFreeUnit:unit_type
-    * op equal *tmp5 @unit null
-    * jump *label23 equal *tmp5 false
+   49 jump *label23 notEqual @unit null
    50 set *tmp4 null
    51 jump *label22 always
    52 jump *label24 always
 
    55 set :findFreeUnit:first_unit @unit
    56 label *label25
    57 sensor *tmp7 @unit @controlled
-    * op equal *tmp8 *tmp7 0
-    * jump *label28 equal *tmp8 false
+   58 jump *label28 notEqual *tmp7 0
    59 ucontrol flag :findFreeUnit:initial_flag
    60 set *tmp4 @unit
    61 jump *label22 always
    62 jump *label29 always
    63 label *label28
    64 sensor *tmp10 :findFreeUnit:first_unit @dead
-    * op equal *tmp11 *tmp10 1
-    * jump *label30 equal *tmp11 false
+   65 jump *label30 notEqual *tmp10 1
    66 set :findFreeUnit:first_unit @unit
    67 jump *label31 always
    68 label *label30
 
    70 label *label29
    71 ubind :findFreeUnit:unit_type
    72 label *label26
-    * op notEqual *tmp14 :findFreeUnit:first_unit @unit
-    * jump *label25 notEqual *tmp14 false
+   73 jump *label25 notEqual :findFreeUnit:first_unit @unit
    74 label *label27
    75 set *tmp4 null
    76 jump *label22 always
    77 set *tmp4 null
    78 label *label22
    79 set :findUnit:unit *tmp4
-    * op notEqual *tmp15 :findUnit:unit null
-    * jump *label32 equal *tmp15 false
+   80 jump *label32 equal :findUnit:unit null
    81 print "Returning unit: "
    82 print :findUnit:unit
    83 printflush message1

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    37 label *label12
    38 jump *label20 notEqual :findUnit:type :findUnit:currentType
    39 jump *label14 always
-    * jump *label21 always
    40 label *label20
    41 label *label21
    42 print "Finding unit: "
 
    48 jump *label23 notEqual @unit null
    49 set *tmp4 null
    50 jump *label22 always
-    * jump *label24 always
    51 label *label23
    52 label *label24
    53 set :findFreeUnit:first_unit @unit
 
    62 sensor *tmp10 :findFreeUnit:first_unit @dead
    63 jump *label30 notEqual *tmp10 1
    64 set :findFreeUnit:first_unit @unit
-    * jump *label31 always
    65 label *label30
    66 label *label31
    67 label *label29
 
    80 printflush message1
    81 set :findUnit*retval :findUnit:unit
    82 jump *label8 always
-    * jump *label33 always
    83 label *label32
    84 label *label33
    85 label *label13

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    44 printflush message1
    45 set :findFreeUnit:unit_type :findUnit:type
    46 set :findFreeUnit:initial_flag 0
-    * ubind :findFreeUnit:unit_type
+   47 ubind :findUnit:type
    48 jump *label23 notEqual @unit null
    49 set *tmp4 null
    50 jump *label22 always
 
    54 label *label25
    55 sensor *tmp7 @unit @controlled
    56 jump *label28 notEqual *tmp7 0
-    * ucontrol flag :findFreeUnit:initial_flag
+   57 ucontrol flag 0
    58 set *tmp4 @unit
    59 jump *label22 always
    60 jump *label29 always
 
    65 label *label30
    66 label *label31
    67 label *label29
-    * ubind :findFreeUnit:unit_type
+   68 ubind :findUnit:type
    69 label *label26
    70 jump *label25 notEqual :findFreeUnit:first_unit @unit
    71 label *label27
    72 set *tmp4 null
    73 jump *label22 always
-    * set *tmp4 null
    74 label *label22
    75 set :findUnit:unit *tmp4
-    * jump *label32 equal :findUnit:unit null
+   76 jump *label32 equal *tmp4 null
    77 print "Returning unit: "
-    * print :findUnit:unit
+   78 print *tmp4
    79 printflush message1
-    * set :findUnit*retval :findUnit:unit
+   80 set :findUnit*retval *tmp4
    81 jump *label8 always
    82 label *label32
    83 label *label33

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    42 print "Finding unit: "
    43 print :findUnit:type
    44 printflush message1
-    * set :findFreeUnit:unit_type :findUnit:type
-    * set :findFreeUnit:initial_flag 0
    45 ubind :findUnit:type
    46 jump *label23 notEqual @unit null
    47 set *tmp4 null
 
    70 set *tmp4 null
    71 jump *label22 always
    72 label *label22
-    * set :findUnit:unit *tmp4
    73 jump *label32 equal *tmp4 null
    74 print "Returning unit: "
    75 print *tmp4

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
    57 jump *label22 always
    58 jump *label29 always
    59 label *label28
-    * sensor *tmp10 :findFreeUnit:first_unit @dead
-    * jump *label30 notEqual *tmp10 1
-    * set :findFreeUnit:first_unit @unit
-    * label *label30
-    * label *label31
+   60 sensor *tmp10 :findFreeUnit:first_unit @dead
+   61 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
    62 label *label29
    63 ubind :findUnit:type
    64 label *label26

Modifications by Unroll iteration loop at line 22:9 (+102 instructions):
 
    16 print :findUnit:currentUnit
    17 printflush message1
    18 label *label9
-    * set :findUnit:type .types*0
-    * setaddr *tmp1 *label15
-    * jump *label12 always
-    * multilabel *label15 (m:marker0)
-    * set :findUnit:type .types*1
-    * setaddr *tmp1 *label16
-    * jump *label12 always
-    * multilabel *label16 (m:marker0)
-    * set :findUnit:type .types*2
-    * setaddr *tmp1 *label17
-    * jump *label12 always
-    * multilabel *label17 (m:marker0)
-    * set :findUnit:type .types*3
-    * setaddr *tmp1 *label18
-    * jump *label12 always
-    * multilabel *label18 (m:marker0)
-    * set :findUnit:type .types*4
-    * setaddr *tmp1 *label19
-    * label *label12
-    * jump *label20 notEqual :findUnit:type :findUnit:currentType
-    * jump *label14 always
-    * label *label20
-    * label *label21
-    * print "Finding unit: "
-    * print :findUnit:type
-    * printflush message1
-    * ubind :findUnit:type
-    * jump *label23 notEqual @unit null
-    * set *tmp4 null
-    * jump *label22 always
-    * label *label23
-    * label *label24
-    * set :findFreeUnit:first_unit @unit
-    * label *label25
-    * sensor *tmp7 @unit @controlled
-    * jump *label28 notEqual *tmp7 0
-    * ucontrol flag 0
-    * set *tmp4 @unit
-    * jump *label22 always
-    * jump *label29 always
-    * label *label28
-    * sensor *tmp10 :findFreeUnit:first_unit @dead
-    * select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
-    * label *label29
-    * ubind :findUnit:type
-    * label *label26
-    * jump *label25 notEqual :findFreeUnit:first_unit @unit
-    * label *label27
-    * set *tmp4 null
-    * jump *label22 always
-    * label *label22
-    * jump *label32 equal *tmp4 null
-    * print "Returning unit: "
-    * print *tmp4
-    * printflush message1
-    * set :findUnit*retval *tmp4
-    * jump *label8 always
-    * label *label32
-    * label *label33
-    * label *label13
-    * multijump *tmp1 0 0 (m:marker0)
-    * multilabel *label19 (m:marker0)
-    * label *label14
+   19 set :findUnit:type .types*0
+   20 label *label34
+   21 jump *label35 notEqual :findUnit:type :findUnit:currentType
+   22 jump *label14 always
+   23 label *label35
+   24 label *label36
+   25 print "Finding unit: "
+   26 print :findUnit:type
+   27 printflush message1
+   28 ubind :findUnit:type
+   29 jump *label37 notEqual @unit null
+   30 set *tmp4 null
+   31 jump *label44 always
+   32 label *label37
+   33 label *label38
+   34 set :findFreeUnit:first_unit @unit
+   35 label *label39
+   36 sensor *tmp7 @unit @controlled
+   37 jump *label40 notEqual *tmp7 0
+   38 ucontrol flag 0
+   39 set *tmp4 @unit
+   40 jump *label44 always
+   41 jump *label41 always
+   42 label *label40
+   43 sensor *tmp10 :findFreeUnit:first_unit @dead
+   44 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
+   45 label *label41
+   46 ubind :findUnit:type
+   47 label *label42
+   48 jump *label39 notEqual :findFreeUnit:first_unit @unit
+   49 label *label43
+   50 set *tmp4 null
+   51 jump *label44 always
+   52 label *label44
+   53 jump *label45 equal *tmp4 null
+   54 print "Returning unit: "
+   55 print *tmp4
+   56 printflush message1
+   57 set :findUnit*retval *tmp4
+   58 jump *label8 always
+   59 label *label45
+   60 label *label46
+   61 label *label47
+   62 set :findUnit:type .types*1
+   63 label *label50
+   64 jump *label51 notEqual :findUnit:type :findUnit:currentType
+   65 jump *label14 always
+   66 label *label51
+   67 label *label52
+   68 print "Finding unit: "
+   69 print :findUnit:type
+   70 printflush message1
+   71 ubind :findUnit:type
+   72 jump *label53 notEqual @unit null
+   73 set *tmp4 null
+   74 jump *label60 always
+   75 label *label53
+   76 label *label54
+   77 set :findFreeUnit:first_unit @unit
+   78 label *label55
+   79 sensor *tmp7 @unit @controlled
+   80 jump *label56 notEqual *tmp7 0
+   81 ucontrol flag 0
+   82 set *tmp4 @unit
+   83 jump *label60 always
+   84 jump *label57 always
+   85 label *label56
+   86 sensor *tmp10 :findFreeUnit:first_unit @dead
+   87 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
+   88 label *label57
+   89 ubind :findUnit:type
+   90 label *label58
+   91 jump *label55 notEqual :findFreeUnit:first_unit @unit
+   92 label *label59
+   93 set *tmp4 null
+   94 jump *label60 always
+   95 label *label60
+   96 jump *label61 equal *tmp4 null
+   97 print "Returning unit: "
+   98 print *tmp4
+   99 printflush message1
+  100 set :findUnit*retval *tmp4
+  101 jump *label8 always
+  102 label *label61
+  103 label *label62
+  104 label *label63
+  105 set :findUnit:type .types*2
+  106 label *label66
+  107 jump *label67 notEqual :findUnit:type :findUnit:currentType
+  108 jump *label14 always
+  109 label *label67
+  110 label *label68
+  111 print "Finding unit: "
+  112 print :findUnit:type
+  113 printflush message1
+  114 ubind :findUnit:type
+  115 jump *label69 notEqual @unit null
+  116 set *tmp4 null
+  117 jump *label76 always
+  118 label *label69
+  119 label *label70
+  120 set :findFreeUnit:first_unit @unit
+  121 label *label71
+  122 sensor *tmp7 @unit @controlled
+  123 jump *label72 notEqual *tmp7 0
+  124 ucontrol flag 0
+  125 set *tmp4 @unit
+  126 jump *label76 always
+  127 jump *label73 always
+  128 label *label72
+  129 sensor *tmp10 :findFreeUnit:first_unit @dead
+  130 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
+  131 label *label73
+  132 ubind :findUnit:type
+  133 label *label74
+  134 jump *label71 notEqual :findFreeUnit:first_unit @unit
+  135 label *label75
+  136 set *tmp4 null
+  137 jump *label76 always
+  138 label *label76
+  139 jump *label77 equal *tmp4 null
+  140 print "Returning unit: "
+  141 print *tmp4
+  142 printflush message1
+  143 set :findUnit*retval *tmp4
+  144 jump *label8 always
+  145 label *label77
+  146 label *label78
+  147 label *label79
+  148 set :findUnit:type .types*3
+  149 label *label82
+  150 jump *label83 notEqual :findUnit:type :findUnit:currentType
+  151 jump *label14 always
+  152 label *label83
+  153 label *label84
+  154 print "Finding unit: "
+  155 print :findUnit:type
+  156 printflush message1
+  157 ubind :findUnit:type
+  158 jump *label85 notEqual @unit null
+  159 set *tmp4 null
+  160 jump *label92 always
+  161 label *label85
+  162 label *label86
+  163 set :findFreeUnit:first_unit @unit
+  164 label *label87
+  165 sensor *tmp7 @unit @controlled
+  166 jump *label88 notEqual *tmp7 0
+  167 ucontrol flag 0
+  168 set *tmp4 @unit
+  169 jump *label92 always
+  170 jump *label89 always
+  171 label *label88
+  172 sensor *tmp10 :findFreeUnit:first_unit @dead
+  173 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
+  174 label *label89
+  175 ubind :findUnit:type
+  176 label *label90
+  177 jump *label87 notEqual :findFreeUnit:first_unit @unit
+  178 label *label91
+  179 set *tmp4 null
+  180 jump *label92 always
+  181 label *label92
+  182 jump *label93 equal *tmp4 null
+  183 print "Returning unit: "
+  184 print *tmp4
+  185 printflush message1
+  186 set :findUnit*retval *tmp4
+  187 jump *label8 always
+  188 label *label93
+  189 label *label94
+  190 label *label95
+  191 set :findUnit:type .types*4
+  192 label *label98
+  193 jump *label99 notEqual :findUnit:type :findUnit:currentType
+  194 jump *label14 always
+  195 label *label99
+  196 label *label100
+  197 print "Finding unit: "
+  198 print :findUnit:type
+  199 printflush message1
+  200 ubind :findUnit:type
+  201 jump *label101 notEqual @unit null
+  202 set *tmp4 null
+  203 jump *label108 always
+  204 label *label101
+  205 label *label102
+  206 set :findFreeUnit:first_unit @unit
+  207 label *label103
+  208 sensor *tmp7 @unit @controlled
+  209 jump *label104 notEqual *tmp7 0
+  210 ucontrol flag 0
+  211 set *tmp4 @unit
+  212 jump *label108 always
+  213 jump *label105 always
+  214 label *label104
+  215 sensor *tmp10 :findFreeUnit:first_unit @dead
+  216 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
+  217 label *label105
+  218 ubind :findUnit:type
+  219 label *label106
+  220 jump *label103 notEqual :findFreeUnit:first_unit @unit
+  221 label *label107
+  222 set *tmp4 null
+  223 jump *label108 always
+  224 label *label108
+  225 jump *label109 equal *tmp4 null
+  226 print "Returning unit: "
+  227 print *tmp4
+  228 printflush message1
+  229 set :findUnit*retval *tmp4
+  230 jump *label8 always
+  231 label *label109
+  232 label *label110
+  233 label *label111
+  234 label *label14
   235 label *label10
   236 jump *label9 always
   237 label *label11

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    18 label *label9
    19 set :findUnit:type .types*0
    20 label *label34
-    * jump *label35 notEqual :findUnit:type :findUnit:currentType
+   21 jump *label35 notEqual .types*0 :findUnit:currentType
    22 jump *label14 always
    23 label *label35
    24 label *label36
    25 print "Finding unit: "
-    * print :findUnit:type
+   26 print .types*0
    27 printflush message1
-    * ubind :findUnit:type
+   28 ubind .types*0
    29 jump *label37 notEqual @unit null
    30 set *tmp4 null
    31 jump *label44 always
 
    43 sensor *tmp10 :findFreeUnit:first_unit @dead
    44 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
    45 label *label41
-    * ubind :findUnit:type
+   46 ubind .types*0
    47 label *label42
    48 jump *label39 notEqual :findFreeUnit:first_unit @unit
    49 label *label43
 
    61 label *label47
    62 set :findUnit:type .types*1
    63 label *label50
-    * jump *label51 notEqual :findUnit:type :findUnit:currentType
+   64 jump *label51 notEqual .types*1 :findUnit:currentType
    65 jump *label14 always
    66 label *label51
    67 label *label52
    68 print "Finding unit: "
-    * print :findUnit:type
+   69 print .types*1
    70 printflush message1
-    * ubind :findUnit:type
+   71 ubind .types*1
    72 jump *label53 notEqual @unit null
    73 set *tmp4 null
    74 jump *label60 always
 
    86 sensor *tmp10 :findFreeUnit:first_unit @dead
    87 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
    88 label *label57
-    * ubind :findUnit:type
+   89 ubind .types*1
    90 label *label58
    91 jump *label55 notEqual :findFreeUnit:first_unit @unit
    92 label *label59
 
   104 label *label63
   105 set :findUnit:type .types*2
   106 label *label66
-    * jump *label67 notEqual :findUnit:type :findUnit:currentType
+  107 jump *label67 notEqual .types*2 :findUnit:currentType
   108 jump *label14 always
   109 label *label67
   110 label *label68
   111 print "Finding unit: "
-    * print :findUnit:type
+  112 print .types*2
   113 printflush message1
-    * ubind :findUnit:type
+  114 ubind .types*2
   115 jump *label69 notEqual @unit null
   116 set *tmp4 null
   117 jump *label76 always
 
   129 sensor *tmp10 :findFreeUnit:first_unit @dead
   130 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
   131 label *label73
-    * ubind :findUnit:type
+  132 ubind .types*2
   133 label *label74
   134 jump *label71 notEqual :findFreeUnit:first_unit @unit
   135 label *label75
 
   147 label *label79
   148 set :findUnit:type .types*3
   149 label *label82
-    * jump *label83 notEqual :findUnit:type :findUnit:currentType
+  150 jump *label83 notEqual .types*3 :findUnit:currentType
   151 jump *label14 always
   152 label *label83
   153 label *label84
   154 print "Finding unit: "
-    * print :findUnit:type
+  155 print .types*3
   156 printflush message1
-    * ubind :findUnit:type
+  157 ubind .types*3
   158 jump *label85 notEqual @unit null
   159 set *tmp4 null
   160 jump *label92 always
 
   172 sensor *tmp10 :findFreeUnit:first_unit @dead
   173 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
   174 label *label89
-    * ubind :findUnit:type
+  175 ubind .types*3
   176 label *label90
   177 jump *label87 notEqual :findFreeUnit:first_unit @unit
   178 label *label91
 
   190 label *label95
   191 set :findUnit:type .types*4
   192 label *label98
-    * jump *label99 notEqual :findUnit:type :findUnit:currentType
+  193 jump *label99 notEqual .types*4 :findUnit:currentType
   194 jump *label14 always
   195 label *label99
   196 label *label100
   197 print "Finding unit: "
-    * print :findUnit:type
+  198 print .types*4
   199 printflush message1
-    * ubind :findUnit:type
+  200 ubind .types*4
   201 jump *label101 notEqual @unit null
   202 set *tmp4 null
   203 jump *label108 always
 
   215 sensor *tmp10 :findFreeUnit:first_unit @dead
   216 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
   217 label *label105
-    * ubind :findUnit:type
+  218 ubind .types*4
   219 label *label106
   220 jump *label103 notEqual :findFreeUnit:first_unit @unit
   221 label *label107

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    16 print :findUnit:currentUnit
    17 printflush message1
    18 label *label9
-    * set :findUnit:type .types*0
    19 label *label34
    20 jump *label35 notEqual .types*0 :findUnit:currentType
    21 jump *label14 always
 
    58 label *label45
    59 label *label46
    60 label *label47
-    * set :findUnit:type .types*1
    61 label *label50
    62 jump *label51 notEqual .types*1 :findUnit:currentType
    63 jump *label14 always
 
   100 label *label61
   101 label *label62
   102 label *label63
-    * set :findUnit:type .types*2
   103 label *label66
   104 jump *label67 notEqual .types*2 :findUnit:currentType
   105 jump *label14 always
 
   142 label *label77
   143 label *label78
   144 label *label79
-    * set :findUnit:type .types*3
   145 label *label82
   146 jump *label83 notEqual .types*3 :findUnit:currentType
   147 jump *label14 always
 
   184 label *label93
   185 label *label94
   186 label *label95
-    * set :findUnit:type .types*4
   187 label *label98
   188 jump *label99 notEqual .types*4 :findUnit:currentType
   189 jump *label14 always

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-5 instructions):
 
    47 jump *label39 notEqual :findFreeUnit:first_unit @unit
    48 label *label43
    49 set *tmp4 null
-    * jump *label44 always
    50 label *label44
    51 jump *label45 equal *tmp4 null
    52 print "Returning unit: "
 
    88 jump *label55 notEqual :findFreeUnit:first_unit @unit
    89 label *label59
    90 set *tmp4 null
-    * jump *label60 always
    91 label *label60
    92 jump *label61 equal *tmp4 null
    93 print "Returning unit: "
 
   129 jump *label71 notEqual :findFreeUnit:first_unit @unit
   130 label *label75
   131 set *tmp4 null
-    * jump *label76 always
   132 label *label76
   133 jump *label77 equal *tmp4 null
   134 print "Returning unit: "
 
   170 jump *label87 notEqual :findFreeUnit:first_unit @unit
   171 label *label91
   172 set *tmp4 null
-    * jump *label92 always
   173 label *label92
   174 jump *label93 equal *tmp4 null
   175 print "Returning unit: "
 
   211 jump *label103 notEqual :findFreeUnit:first_unit @unit
   212 label *label107
   213 set *tmp4 null
-    * jump *label108 always
   214 label *label108
   215 jump *label109 equal *tmp4 null
   216 print "Returning unit: "

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-8 instructions):
 
     9 label *label7
    10 wait 1e12
    11 jump *label7 always
-    * end
    12 label *label0
    13 sensor :findUnit:currentType :findUnit:currentUnit @type
    14 print "Trying to find unit better than "
    15 print :findUnit:currentUnit
    16 printflush message1
    17 label *label9
-    * label *label34
    18 jump *label35 notEqual .types*0 :findUnit:currentType
    19 jump *label14 always
    20 label *label35
-    * label *label36
    21 print "Finding unit: "
    22 print .types*0
    23 printflush message1
 
    26 set *tmp4 null
    27 jump *label44 always
    28 label *label37
-    * label *label38
    29 set :findFreeUnit:first_unit @unit
    30 label *label39
    31 sensor *tmp7 @unit @controlled
 
    33 ucontrol flag 0
    34 set *tmp4 @unit
    35 jump *label44 always
-    * jump *label41 always
    36 label *label40
    37 sensor *tmp10 :findFreeUnit:first_unit @dead
    38 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
    39 label *label41
    40 ubind .types*0
-    * label *label42
    41 jump *label39 notEqual :findFreeUnit:first_unit @unit
-    * label *label43
    42 set *tmp4 null
    43 label *label44
    44 jump *label45 equal *tmp4 null
 
    48 set :findUnit*retval *tmp4
    49 jump *label8 always
    50 label *label45
-    * label *label46
-    * label *label47
-    * label *label50
    51 jump *label51 notEqual .types*1 :findUnit:currentType
    52 jump *label14 always
    53 label *label51
-    * label *label52
    54 print "Finding unit: "
    55 print .types*1
    56 printflush message1
 
    59 set *tmp4 null
    60 jump *label60 always
    61 label *label53
-    * label *label54
    62 set :findFreeUnit:first_unit @unit
    63 label *label55
    64 sensor *tmp7 @unit @controlled
 
    66 ucontrol flag 0
    67 set *tmp4 @unit
    68 jump *label60 always
-    * jump *label57 always
    69 label *label56
    70 sensor *tmp10 :findFreeUnit:first_unit @dead
    71 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
    72 label *label57
    73 ubind .types*1
-    * label *label58
    74 jump *label55 notEqual :findFreeUnit:first_unit @unit
-    * label *label59
    75 set *tmp4 null
    76 label *label60
    77 jump *label61 equal *tmp4 null
 
    81 set :findUnit*retval *tmp4
    82 jump *label8 always
    83 label *label61
-    * label *label62
-    * label *label63
-    * label *label66
    84 jump *label67 notEqual .types*2 :findUnit:currentType
    85 jump *label14 always
    86 label *label67
-    * label *label68
    87 print "Finding unit: "
    88 print .types*2
    89 printflush message1
 
    92 set *tmp4 null
    93 jump *label76 always
    94 label *label69
-    * label *label70
    95 set :findFreeUnit:first_unit @unit
    96 label *label71
    97 sensor *tmp7 @unit @controlled
 
    99 ucontrol flag 0
   100 set *tmp4 @unit
   101 jump *label76 always
-    * jump *label73 always
   102 label *label72
   103 sensor *tmp10 :findFreeUnit:first_unit @dead
   104 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
   105 label *label73
   106 ubind .types*2
-    * label *label74
   107 jump *label71 notEqual :findFreeUnit:first_unit @unit
-    * label *label75
   108 set *tmp4 null
   109 label *label76
   110 jump *label77 equal *tmp4 null
 
   114 set :findUnit*retval *tmp4
   115 jump *label8 always
   116 label *label77
-    * label *label78
-    * label *label79
-    * label *label82
   117 jump *label83 notEqual .types*3 :findUnit:currentType
   118 jump *label14 always
   119 label *label83
-    * label *label84
   120 print "Finding unit: "
   121 print .types*3
   122 printflush message1
 
   125 set *tmp4 null
   126 jump *label92 always
   127 label *label85
-    * label *label86
   128 set :findFreeUnit:first_unit @unit
   129 label *label87
   130 sensor *tmp7 @unit @controlled
 
   132 ucontrol flag 0
   133 set *tmp4 @unit
   134 jump *label92 always
-    * jump *label89 always
   135 label *label88
   136 sensor *tmp10 :findFreeUnit:first_unit @dead
   137 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
   138 label *label89
   139 ubind .types*3
-    * label *label90
   140 jump *label87 notEqual :findFreeUnit:first_unit @unit
-    * label *label91
   141 set *tmp4 null
   142 label *label92
   143 jump *label93 equal *tmp4 null
 
   147 set :findUnit*retval *tmp4
   148 jump *label8 always
   149 label *label93
-    * label *label94
-    * label *label95
-    * label *label98
   150 jump *label99 notEqual .types*4 :findUnit:currentType
   151 jump *label14 always
   152 label *label99
-    * label *label100
   153 print "Finding unit: "
   154 print .types*4
   155 printflush message1
 
   158 set *tmp4 null
   159 jump *label108 always
   160 label *label101
-    * label *label102
   161 set :findFreeUnit:first_unit @unit
   162 label *label103
   163 sensor *tmp7 @unit @controlled
 
   165 ucontrol flag 0
   166 set *tmp4 @unit
   167 jump *label108 always
-    * jump *label105 always
   168 label *label104
   169 sensor *tmp10 :findFreeUnit:first_unit @dead
   170 select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFreeUnit:first_unit
   171 label *label105
   172 ubind .types*4
-    * label *label106
   173 jump *label103 notEqual :findFreeUnit:first_unit @unit
-    * label *label107
   174 set *tmp4 null
   175 label *label108
   176 jump *label109 equal *tmp4 null
 
   180 set :findUnit*retval *tmp4
   181 jump *label8 always
   182 label *label109
-    * label *label110
-    * label *label111
   183 label *label14
-    * label *label10
   184 jump *label9 always
-    * label *label11
-    * set :findUnit*retval null
   185 label *label8
   186 set :findUnit*finished true
   187 jump *label7 always
-    * end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-5 instructions):
 
    15 print :findUnit:currentUnit
    16 printflush message1
    17 label *label9
-    * jump *label35 notEqual .types*0 :findUnit:currentType
-    * jump *label14 always
+   18 jump *label14 equal .types*0 :findUnit:currentType
    19 label *label35
    20 print "Finding unit: "
    21 print .types*0
 
    46 set :findUnit*retval *tmp4
    47 jump *label8 always
    48 label *label45
-    * jump *label51 notEqual .types*1 :findUnit:currentType
-    * jump *label14 always
+   49 jump *label14 equal .types*1 :findUnit:currentType
    50 label *label51
    51 print "Finding unit: "
    52 print .types*1
 
    77 set :findUnit*retval *tmp4
    78 jump *label8 always
    79 label *label61
-    * jump *label67 notEqual .types*2 :findUnit:currentType
-    * jump *label14 always
+   80 jump *label14 equal .types*2 :findUnit:currentType
    81 label *label67
    82 print "Finding unit: "
    83 print .types*2
 
   108 set :findUnit*retval *tmp4
   109 jump *label8 always
   110 label *label77
-    * jump *label83 notEqual .types*3 :findUnit:currentType
-    * jump *label14 always
+  111 jump *label14 equal .types*3 :findUnit:currentType
   112 label *label83
   113 print "Finding unit: "
   114 print .types*3
 
   139 set :findUnit*retval *tmp4
   140 jump *label8 always
   141 label *label93
-    * jump *label99 notEqual .types*4 :findUnit:currentType
-    * jump *label14 always
+  142 jump *label14 equal .types*4 :findUnit:currentType
   143 label *label99
   144 print "Finding unit: "
   145 print .types*4

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    15 print :findUnit:currentUnit
    16 printflush message1
    17 label *label9
-    * jump *label14 equal .types*0 :findUnit:currentType
+   18 jump *label9 equal .types*0 :findUnit:currentType
    19 print "Finding unit: "
    20 print .types*0
    21 printflush message1
 
    45 set :findUnit*retval *tmp4
    46 jump *label8 always
    47 label *label45
-    * jump *label14 equal .types*1 :findUnit:currentType
+   48 jump *label9 equal .types*1 :findUnit:currentType
    49 print "Finding unit: "
    50 print .types*1
    51 printflush message1
 
    75 set :findUnit*retval *tmp4
    76 jump *label8 always
    77 label *label61
-    * jump *label14 equal .types*2 :findUnit:currentType
+   78 jump *label9 equal .types*2 :findUnit:currentType
    79 print "Finding unit: "
    80 print .types*2
    81 printflush message1
 
   105 set :findUnit*retval *tmp4
   106 jump *label8 always
   107 label *label77
-    * jump *label14 equal .types*3 :findUnit:currentType
+  108 jump *label9 equal .types*3 :findUnit:currentType
   109 print "Finding unit: "
   110 print .types*3
   111 printflush message1
 
   135 set :findUnit*retval *tmp4
   136 jump *label8 always
   137 label *label93
-    * jump *label14 equal .types*4 :findUnit:currentType
+  138 jump *label9 equal .types*4 :findUnit:currentType
   139 print "Finding unit: "
   140 print .types*4
   141 printflush message1
 
   158 jump *label103 notEqual :findFreeUnit:first_unit @unit
   159 set *tmp4 null
   160 label *label108
-    * jump *label109 equal *tmp4 null
+  161 jump *label9 equal *tmp4 null
   162 print "Returning unit: "
   163 print *tmp4
   164 printflush message1

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-1 instructions):
 
   164 printflush message1
   165 set :findUnit*retval *tmp4
   166 jump *label8 always
-    * jump *label9 always
   167 label *label8
   168 set :findUnit*finished true
   169 jump *label7 always

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-1 instructions):
 
   163 print *tmp4
   164 printflush message1
   165 set :findUnit*retval *tmp4
-    * jump *label8 always
   166 label *label8
   167 set :findUnit*finished true
   168 jump *label7 always

Final code before resolving virtual instructions:

    0:  jump *label6 always 0 0                                      #set target = 8;
    1:  jump *label0 always 0 0                                      ...
        label *label6                                                ...
    2:  set .types*0 @mega                                           var types[5] = (@mega, @poly, @horizon, @flare, @mono);
    3:  set .types*1 @poly                                           ...
    4:  set .types*2 @horizon                                        ...
    5:  set .types*3 @flare                                          ...
    6:  set .types*4 @mono                                           ...
    7:  set *signature "d6ba00c23bee94f3:v1"                         #set target = 8;
        label *label7                                                ...
    8:  wait 1e12                                                    ...
    9:  jump *label7 always 0 0                                      ...
        label *label0                                                export def findUnit(currentUnit)
   10:  sensor :findUnit:currentType :findUnit:currentUnit @type     var currentType = currentUnit.@type;
   11:  print "Trying to find unit better than "                     print("Trying to find unit better than ", currentUnit);
   12:  print :findUnit:currentUnit                                  ...
   13:  printflush message1                                          printflush(message1);
        label *label9                                                while true do
   14:  jump *label9 equal .types*0 :findUnit:currentType            if type == currentType then break; end;
   15:  print "Finding unit: "                                       print("Finding unit: ", type);
   16:  print .types*0                                               ...
   17:  printflush message1                                          printflush(message1);
   18:  ubind .types*0                                               *units: ubind(unit_type);
   19:  jump *label37 notEqual @unit null                            *units: if @unit == null then return null; end;
   20:  set *tmp4 null                                               ...
   21:  jump *label44 always 0 0                                     ...
        label *label37                                               ...
   22:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label39                                               *units: do
   23:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   24:  jump *label40 notEqual *tmp7 0                               ...
   25:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   26:  set *tmp4 @unit                                              *units: return @unit;
   27:  jump *label44 always 0 0                                     ...
        label *label40                                               *units: if @unit.@controlled == 0 then
   28:  sensor *tmp10 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   29:  select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFr ...
   30:  ubind .types*0                                               *units: ubind(unit_type);
   31:  jump *label39 notEqual :findFreeUnit:first_unit @unit        *units: do
   32:  set *tmp4 null                                               *units: return null;
        label *label44                                               var unit = findFreeUnit(type, 0);
   33:  jump *label45 equal *tmp4 null                               if unit != null then
   34:  print "Returning unit: "                                     print("Returning unit: ", unit);
   35:  print *tmp4                                                  ...
   36:  printflush message1                                          printflush(message1);
   37:  set :findUnit*retval *tmp4                                   return unit;
   38:  jump *label8 always 0 0                                      ...
        label *label45                                               if unit != null then
   39:  jump *label9 equal .types*1 :findUnit:currentType            if type == currentType then break; end;
   40:  print "Finding unit: "                                       print("Finding unit: ", type);
   41:  print .types*1                                               ...
   42:  printflush message1                                          printflush(message1);
   43:  ubind .types*1                                               *units: ubind(unit_type);
   44:  jump *label53 notEqual @unit null                            *units: if @unit == null then return null; end;
   45:  set *tmp4 null                                               ...
   46:  jump *label60 always 0 0                                     ...
        label *label53                                               ...
   47:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label55                                               *units: do
   48:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   49:  jump *label56 notEqual *tmp7 0                               ...
   50:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   51:  set *tmp4 @unit                                              *units: return @unit;
   52:  jump *label60 always 0 0                                     ...
        label *label56                                               *units: if @unit.@controlled == 0 then
   53:  sensor *tmp10 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   54:  select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFr ...
   55:  ubind .types*1                                               *units: ubind(unit_type);
   56:  jump *label55 notEqual :findFreeUnit:first_unit @unit        *units: do
   57:  set *tmp4 null                                               *units: return null;
        label *label60                                               var unit = findFreeUnit(type, 0);
   58:  jump *label61 equal *tmp4 null                               if unit != null then
   59:  print "Returning unit: "                                     print("Returning unit: ", unit);
   60:  print *tmp4                                                  ...
   61:  printflush message1                                          printflush(message1);
   62:  set :findUnit*retval *tmp4                                   return unit;
   63:  jump *label8 always 0 0                                      ...
        label *label61                                               if unit != null then
   64:  jump *label9 equal .types*2 :findUnit:currentType            if type == currentType then break; end;
   65:  print "Finding unit: "                                       print("Finding unit: ", type);
   66:  print .types*2                                               ...
   67:  printflush message1                                          printflush(message1);
   68:  ubind .types*2                                               *units: ubind(unit_type);
   69:  jump *label69 notEqual @unit null                            *units: if @unit == null then return null; end;
   70:  set *tmp4 null                                               ...
   71:  jump *label76 always 0 0                                     ...
        label *label69                                               ...
   72:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label71                                               *units: do
   73:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   74:  jump *label72 notEqual *tmp7 0                               ...
   75:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   76:  set *tmp4 @unit                                              *units: return @unit;
   77:  jump *label76 always 0 0                                     ...
        label *label72                                               *units: if @unit.@controlled == 0 then
   78:  sensor *tmp10 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   79:  select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFr ...
   80:  ubind .types*2                                               *units: ubind(unit_type);
   81:  jump *label71 notEqual :findFreeUnit:first_unit @unit        *units: do
   82:  set *tmp4 null                                               *units: return null;
        label *label76                                               var unit = findFreeUnit(type, 0);
   83:  jump *label77 equal *tmp4 null                               if unit != null then
   84:  print "Returning unit: "                                     print("Returning unit: ", unit);
   85:  print *tmp4                                                  ...
   86:  printflush message1                                          printflush(message1);
   87:  set :findUnit*retval *tmp4                                   return unit;
   88:  jump *label8 always 0 0                                      ...
        label *label77                                               if unit != null then
   89:  jump *label9 equal .types*3 :findUnit:currentType            if type == currentType then break; end;
   90:  print "Finding unit: "                                       print("Finding unit: ", type);
   91:  print .types*3                                               ...
   92:  printflush message1                                          printflush(message1);
   93:  ubind .types*3                                               *units: ubind(unit_type);
   94:  jump *label85 notEqual @unit null                            *units: if @unit == null then return null; end;
   95:  set *tmp4 null                                               ...
   96:  jump *label92 always 0 0                                     ...
        label *label85                                               ...
   97:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label87                                               *units: do
   98:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   99:  jump *label88 notEqual *tmp7 0                               ...
  100:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  101:  set *tmp4 @unit                                              *units: return @unit;
  102:  jump *label92 always 0 0                                     ...
        label *label88                                               *units: if @unit.@controlled == 0 then
  103:  sensor *tmp10 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  104:  select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFr ...
  105:  ubind .types*3                                               *units: ubind(unit_type);
  106:  jump *label87 notEqual :findFreeUnit:first_unit @unit        *units: do
  107:  set *tmp4 null                                               *units: return null;
        label *label92                                               var unit = findFreeUnit(type, 0);
  108:  jump *label93 equal *tmp4 null                               if unit != null then
  109:  print "Returning unit: "                                     print("Returning unit: ", unit);
  110:  print *tmp4                                                  ...
  111:  printflush message1                                          printflush(message1);
  112:  set :findUnit*retval *tmp4                                   return unit;
  113:  jump *label8 always 0 0                                      ...
        label *label93                                               if unit != null then
  114:  jump *label9 equal .types*4 :findUnit:currentType            if type == currentType then break; end;
  115:  print "Finding unit: "                                       print("Finding unit: ", type);
  116:  print .types*4                                               ...
  117:  printflush message1                                          printflush(message1);
  118:  ubind .types*4                                               *units: ubind(unit_type);
  119:  jump *label101 notEqual @unit null                           *units: if @unit == null then return null; end;
  120:  set *tmp4 null                                               ...
  121:  jump *label108 always 0 0                                    ...
        label *label101                                              ...
  122:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label103                                              *units: do
  123:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
  124:  jump *label104 notEqual *tmp7 0                              ...
  125:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  126:  set *tmp4 @unit                                              *units: return @unit;
  127:  jump *label108 always 0 0                                    ...
        label *label104                                              *units: if @unit.@controlled == 0 then
  128:  sensor *tmp10 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  129:  select :findFreeUnit:first_unit equal *tmp10 1 @unit :findFr ...
  130:  ubind .types*4                                               *units: ubind(unit_type);
  131:  jump *label103 notEqual :findFreeUnit:first_unit @unit       *units: do
  132:  set *tmp4 null                                               *units: return null;
        label *label108                                              var unit = findFreeUnit(type, 0);
  133:  jump *label9 equal *tmp4 null                                if unit != null then
  134:  print "Returning unit: "                                     print("Returning unit: ", unit);
  135:  print *tmp4                                                  ...
  136:  printflush message1                                          printflush(message1);
  137:  set :findUnit*retval *tmp4                                   return unit;
        label *label8                                                export def findUnit(currentUnit)
  138:  set :findUnit*finished true                                  ...
  139:  jump *label7 always 0 0                                      ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    75     5x     15,0  def findFreeUnit(in unit_type, in initial_flag)
    56     1x     56,0  export def findUnit(in currentUnit)
    10     1x     10,0  <no function>

Performance: parsed in 199 ms, compiled in 277 ms, optimized in 251 ms, run in 7 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (8 steps):
The program didn't generate any output.
Execution exception at instruction 8: wait 1e12:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
