    91 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
    10 instructions eliminated by Dead Code Elimination (4 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     6 instructions eliminated by Jump Optimization (4 iterations).
    10 instructions eliminated by Single Step Elimination (3 passes, 7 iterations).
     9 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
   106 instructions added by Loop Unrolling (4 iterations).
     1 loops unrolled by Loop Unrolling.
     5 instructions eliminated by Jump Straightening (4 iterations).
     6 instructions updated by JumpThreading.
     9 instructions eliminated by Unreachable Code Elimination.
   145 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 936):
  * Unroll iteration loop at line 22:9                           cost   126, benefit      475.0, efficiency        3.8 (+101 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-8 instructions):
 
    38 op equal *tmp2 :findUnit:type :findUnit:currentType
    39 jump *label17 equal *tmp2 false
    40 jump *label11 always
-    * set *tmp3 null
    41 jump *label18 always
    42 label *label17
-    * set *tmp3 null
    43 label *label18
    44 print "Finding unit: "
    45 print :findUnit:type
 
    51 jump *label20 equal *tmp5 false
    52 set *tmp4 null
    53 jump *label19 always
-    * set *tmp6 null
    54 jump *label21 always
    55 label *label20
-    * set *tmp6 null
    56 label *label21
    57 set :findFreeUnit.0:first_unit @unit
    58 label *label22
 
    62 ucontrol flag :findFreeUnit.0:initial_flag
    63 set *tmp4 @unit
    64 jump *label19 always
-    * set *tmp9 null
    65 jump *label26 always
    66 label *label25
    67 sensor *tmp10 :findFreeUnit.0:first_unit @dead
 
    74 label *label27
    75 set *tmp12 null
    76 label *label28
-    * set *tmp9 *tmp12
    77 label *label26
    78 ubind :findFreeUnit.0:unit_type
    79 label *label23
 
    92 printflush message1
    93 set :findUnit*retval :findUnit:unit
    94 jump *label5 always
-    * set *tmp16 null
    95 jump *label30 always
    96 label *label29
-    * set *tmp16 null
    97 label *label30
    98 label *label10
    99 multijump *tmp1 0 0 marker0

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
    69 jump *label27 equal *tmp11 false
    70 set *tmp13 @unit
    71 set :findFreeUnit.0:first_unit *tmp13
-    * set *tmp12 :findFreeUnit.0:first_unit
    72 jump *label28 always
    73 label *label27
-    * set *tmp12 null
    74 label *label28
    75 label *label26
    76 ubind :findFreeUnit.0:unit_type

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
     9 jump *label4 always
    10 end
    11 label *label3
-    * sensor *tmp0 :findUnit:currentUnit @type
-    * set :findUnit:currentType *tmp0
+   12 sensor :findUnit:currentType :findUnit:currentUnit @type
    13 print "Trying to find unit better than "
    14 print :findUnit:currentUnit
    15 printflush message1
 
    66 sensor *tmp10 :findFreeUnit.0:first_unit @dead
    67 op equal *tmp11 *tmp10 1
    68 jump *label27 equal *tmp11 false
-    * set *tmp13 @unit
-    * set :findFreeUnit.0:first_unit *tmp13
+   69 set :findFreeUnit.0:first_unit @unit
    70 jump *label28 always
    71 label *label27
    72 label *label28

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    14 print :findUnit:currentUnit
    15 printflush message1
    16 label *label6
-    * jump *label8 equal true false
    17 setaddr *tmp1 *label12
    18 set :findUnit:type .types*0
    19 jump *label9 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-6 instructions):
 
    33 setaddr *tmp1 *label16
    34 set :findUnit:type .types*4
    35 label *label9
-    * op equal *tmp2 :findUnit:type :findUnit:currentType
-    * jump *label17 equal *tmp2 false
+   36 jump *label17 notEqual :findUnit:type :findUnit:currentType
    37 jump *label11 always
    38 jump *label18 always
    39 label *label17
 
    44 set :findFreeUnit.0:unit_type :findUnit:type
    45 set :findFreeUnit.0:initial_flag 0
    46 ubind :findFreeUnit.0:unit_type
-    * op equal *tmp5 @unit null
-    * jump *label20 equal *tmp5 false
+   47 jump *label20 notEqual @unit null
    48 set *tmp4 null
    49 jump *label19 always
    50 jump *label21 always
 
    53 set :findFreeUnit.0:first_unit @unit
    54 label *label22
    55 sensor *tmp7 @unit @controlled
-    * op equal *tmp8 *tmp7 0
-    * jump *label25 equal *tmp8 false
+   56 jump *label25 notEqual *tmp7 0
    57 ucontrol flag :findFreeUnit.0:initial_flag
    58 set *tmp4 @unit
    59 jump *label19 always
    60 jump *label26 always
    61 label *label25
    62 sensor *tmp10 :findFreeUnit.0:first_unit @dead
-    * op equal *tmp11 *tmp10 1
-    * jump *label27 equal *tmp11 false
+   63 jump *label27 notEqual *tmp10 1
    64 set :findFreeUnit.0:first_unit @unit
    65 jump *label28 always
    66 label *label27
 
    68 label *label26
    69 ubind :findFreeUnit.0:unit_type
    70 label *label23
-    * op notEqual *tmp14 :findFreeUnit.0:first_unit @unit
-    * jump *label22 notEqual *tmp14 false
+   71 jump *label22 notEqual :findFreeUnit.0:first_unit @unit
    72 label *label24
    73 set *tmp4 null
    74 jump *label19 always
    75 set *tmp4 null
    76 label *label19
    77 set :findUnit:unit *tmp4
-    * op notEqual *tmp15 :findUnit:unit null
-    * jump *label29 equal *tmp15 false
+   78 jump *label29 equal :findUnit:unit null
    79 print "Returning unit: "
    80 print :findUnit:unit
    81 printflush message1

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    35 label *label9
    36 jump *label17 notEqual :findUnit:type :findUnit:currentType
    37 jump *label11 always
-    * jump *label18 always
    38 label *label17
    39 label *label18
    40 print "Finding unit: "
 
    46 jump *label20 notEqual @unit null
    47 set *tmp4 null
    48 jump *label19 always
-    * jump *label21 always
    49 label *label20
    50 label *label21
    51 set :findFreeUnit.0:first_unit @unit
 
    60 sensor *tmp10 :findFreeUnit.0:first_unit @dead
    61 jump *label27 notEqual *tmp10 1
    62 set :findFreeUnit.0:first_unit @unit
-    * jump *label28 always
    63 label *label27
    64 label *label28
    65 label *label26
 
    78 printflush message1
    79 set :findUnit*retval :findUnit:unit
    80 jump *label5 always
-    * jump *label30 always
    81 label *label29
    82 label *label30
    83 label *label10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    42 printflush message1
    43 set :findFreeUnit.0:unit_type :findUnit:type
    44 set :findFreeUnit.0:initial_flag 0
-    * ubind :findFreeUnit.0:unit_type
+   45 ubind :findUnit:type
    46 jump *label20 notEqual @unit null
    47 set *tmp4 null
    48 jump *label19 always
 
    52 label *label22
    53 sensor *tmp7 @unit @controlled
    54 jump *label25 notEqual *tmp7 0
-    * ucontrol flag :findFreeUnit.0:initial_flag
+   55 ucontrol flag 0
    56 set *tmp4 @unit
    57 jump *label19 always
    58 jump *label26 always
 
    63 label *label27
    64 label *label28
    65 label *label26
-    * ubind :findFreeUnit.0:unit_type
+   66 ubind :findUnit:type
    67 label *label23
    68 jump *label22 notEqual :findFreeUnit.0:first_unit @unit
    69 label *label24
    70 set *tmp4 null
    71 jump *label19 always
-    * set *tmp4 null
    72 label *label19
    73 set :findUnit:unit *tmp4
-    * jump *label29 equal :findUnit:unit null
+   74 jump *label29 equal *tmp4 null
    75 print "Returning unit: "
-    * print :findUnit:unit
+   76 print *tmp4
    77 printflush message1
-    * set :findUnit*retval :findUnit:unit
+   78 set :findUnit*retval *tmp4
    79 jump *label5 always
    80 label *label29
    81 label *label30

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    40 print "Finding unit: "
    41 print :findUnit:type
    42 printflush message1
-    * set :findFreeUnit.0:unit_type :findUnit:type
-    * set :findFreeUnit.0:initial_flag 0
    43 ubind :findUnit:type
    44 jump *label20 notEqual @unit null
    45 set *tmp4 null
 
    68 set *tmp4 null
    69 jump *label19 always
    70 label *label19
-    * set :findUnit:unit *tmp4
    71 jump *label29 equal *tmp4 null
    72 print "Returning unit: "
    73 print *tmp4

Modifications by Unroll iteration loop at line 22:9 (+106 instructions):
 
    14 print :findUnit:currentUnit
    15 printflush message1
    16 label *label6
-    * setaddr *tmp1 *label12
-    * set :findUnit:type .types*0
-    * jump *label9 always
-    * multilabel *label12 marker0
-    * setaddr *tmp1 *label13
-    * set :findUnit:type .types*1
-    * jump *label9 always
-    * multilabel *label13 marker0
-    * setaddr *tmp1 *label14
-    * set :findUnit:type .types*2
-    * jump *label9 always
-    * multilabel *label14 marker0
-    * setaddr *tmp1 *label15
-    * set :findUnit:type .types*3
-    * jump *label9 always
-    * multilabel *label15 marker0
-    * setaddr *tmp1 *label16
-    * set :findUnit:type .types*4
-    * label *label9
-    * jump *label17 notEqual :findUnit:type :findUnit:currentType
-    * jump *label11 always
-    * label *label17
-    * label *label18
-    * print "Finding unit: "
-    * print :findUnit:type
-    * printflush message1
-    * ubind :findUnit:type
-    * jump *label20 notEqual @unit null
-    * set *tmp4 null
-    * jump *label19 always
-    * label *label20
-    * label *label21
-    * set :findFreeUnit.0:first_unit @unit
-    * label *label22
-    * sensor *tmp7 @unit @controlled
-    * jump *label25 notEqual *tmp7 0
-    * ucontrol flag 0
-    * set *tmp4 @unit
-    * jump *label19 always
-    * jump *label26 always
-    * label *label25
-    * sensor *tmp10 :findFreeUnit.0:first_unit @dead
-    * jump *label27 notEqual *tmp10 1
-    * set :findFreeUnit.0:first_unit @unit
-    * label *label27
-    * label *label28
-    * label *label26
-    * ubind :findUnit:type
-    * label *label23
-    * jump *label22 notEqual :findFreeUnit.0:first_unit @unit
-    * label *label24
-    * set *tmp4 null
-    * jump *label19 always
-    * label *label19
-    * jump *label29 equal *tmp4 null
-    * print "Returning unit: "
-    * print *tmp4
-    * printflush message1
-    * set :findUnit*retval *tmp4
-    * jump *label5 always
-    * label *label29
-    * label *label30
-    * label *label10
-    * multijump *tmp1 0 0 marker0
-    * multilabel *label16 marker0
-    * label *label11
+   17 set :findUnit:type .types*0
+   18 label *label31
+   19 jump *label32 notEqual :findUnit:type :findUnit:currentType
+   20 jump *label11 always
+   21 label *label32
+   22 label *label33
+   23 print "Finding unit: "
+   24 print :findUnit:type
+   25 printflush message1
+   26 ubind :findUnit:type
+   27 jump *label34 notEqual @unit null
+   28 set *tmp4 null
+   29 jump *label43 always
+   30 label *label34
+   31 label *label35
+   32 set :findFreeUnit.0:first_unit @unit
+   33 label *label36
+   34 sensor *tmp7 @unit @controlled
+   35 jump *label37 notEqual *tmp7 0
+   36 ucontrol flag 0
+   37 set *tmp4 @unit
+   38 jump *label43 always
+   39 jump *label40 always
+   40 label *label37
+   41 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+   42 jump *label38 notEqual *tmp10 1
+   43 set :findFreeUnit.0:first_unit @unit
+   44 label *label38
+   45 label *label39
+   46 label *label40
+   47 ubind :findUnit:type
+   48 label *label41
+   49 jump *label36 notEqual :findFreeUnit.0:first_unit @unit
+   50 label *label42
+   51 set *tmp4 null
+   52 jump *label43 always
+   53 label *label43
+   54 jump *label44 equal *tmp4 null
+   55 print "Returning unit: "
+   56 print *tmp4
+   57 printflush message1
+   58 set :findUnit*retval *tmp4
+   59 jump *label5 always
+   60 label *label44
+   61 label *label45
+   62 label *label46
+   63 set :findUnit:type .types*1
+   64 label *label49
+   65 jump *label50 notEqual :findUnit:type :findUnit:currentType
+   66 jump *label11 always
+   67 label *label50
+   68 label *label51
+   69 print "Finding unit: "
+   70 print :findUnit:type
+   71 printflush message1
+   72 ubind :findUnit:type
+   73 jump *label52 notEqual @unit null
+   74 set *tmp4 null
+   75 jump *label61 always
+   76 label *label52
+   77 label *label53
+   78 set :findFreeUnit.0:first_unit @unit
+   79 label *label54
+   80 sensor *tmp7 @unit @controlled
+   81 jump *label55 notEqual *tmp7 0
+   82 ucontrol flag 0
+   83 set *tmp4 @unit
+   84 jump *label61 always
+   85 jump *label58 always
+   86 label *label55
+   87 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+   88 jump *label56 notEqual *tmp10 1
+   89 set :findFreeUnit.0:first_unit @unit
+   90 label *label56
+   91 label *label57
+   92 label *label58
+   93 ubind :findUnit:type
+   94 label *label59
+   95 jump *label54 notEqual :findFreeUnit.0:first_unit @unit
+   96 label *label60
+   97 set *tmp4 null
+   98 jump *label61 always
+   99 label *label61
+  100 jump *label62 equal *tmp4 null
+  101 print "Returning unit: "
+  102 print *tmp4
+  103 printflush message1
+  104 set :findUnit*retval *tmp4
+  105 jump *label5 always
+  106 label *label62
+  107 label *label63
+  108 label *label64
+  109 set :findUnit:type .types*2
+  110 label *label67
+  111 jump *label68 notEqual :findUnit:type :findUnit:currentType
+  112 jump *label11 always
+  113 label *label68
+  114 label *label69
+  115 print "Finding unit: "
+  116 print :findUnit:type
+  117 printflush message1
+  118 ubind :findUnit:type
+  119 jump *label70 notEqual @unit null
+  120 set *tmp4 null
+  121 jump *label79 always
+  122 label *label70
+  123 label *label71
+  124 set :findFreeUnit.0:first_unit @unit
+  125 label *label72
+  126 sensor *tmp7 @unit @controlled
+  127 jump *label73 notEqual *tmp7 0
+  128 ucontrol flag 0
+  129 set *tmp4 @unit
+  130 jump *label79 always
+  131 jump *label76 always
+  132 label *label73
+  133 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+  134 jump *label74 notEqual *tmp10 1
+  135 set :findFreeUnit.0:first_unit @unit
+  136 label *label74
+  137 label *label75
+  138 label *label76
+  139 ubind :findUnit:type
+  140 label *label77
+  141 jump *label72 notEqual :findFreeUnit.0:first_unit @unit
+  142 label *label78
+  143 set *tmp4 null
+  144 jump *label79 always
+  145 label *label79
+  146 jump *label80 equal *tmp4 null
+  147 print "Returning unit: "
+  148 print *tmp4
+  149 printflush message1
+  150 set :findUnit*retval *tmp4
+  151 jump *label5 always
+  152 label *label80
+  153 label *label81
+  154 label *label82
+  155 set :findUnit:type .types*3
+  156 label *label85
+  157 jump *label86 notEqual :findUnit:type :findUnit:currentType
+  158 jump *label11 always
+  159 label *label86
+  160 label *label87
+  161 print "Finding unit: "
+  162 print :findUnit:type
+  163 printflush message1
+  164 ubind :findUnit:type
+  165 jump *label88 notEqual @unit null
+  166 set *tmp4 null
+  167 jump *label97 always
+  168 label *label88
+  169 label *label89
+  170 set :findFreeUnit.0:first_unit @unit
+  171 label *label90
+  172 sensor *tmp7 @unit @controlled
+  173 jump *label91 notEqual *tmp7 0
+  174 ucontrol flag 0
+  175 set *tmp4 @unit
+  176 jump *label97 always
+  177 jump *label94 always
+  178 label *label91
+  179 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+  180 jump *label92 notEqual *tmp10 1
+  181 set :findFreeUnit.0:first_unit @unit
+  182 label *label92
+  183 label *label93
+  184 label *label94
+  185 ubind :findUnit:type
+  186 label *label95
+  187 jump *label90 notEqual :findFreeUnit.0:first_unit @unit
+  188 label *label96
+  189 set *tmp4 null
+  190 jump *label97 always
+  191 label *label97
+  192 jump *label98 equal *tmp4 null
+  193 print "Returning unit: "
+  194 print *tmp4
+  195 printflush message1
+  196 set :findUnit*retval *tmp4
+  197 jump *label5 always
+  198 label *label98
+  199 label *label99
+  200 label *label100
+  201 set :findUnit:type .types*4
+  202 label *label103
+  203 jump *label104 notEqual :findUnit:type :findUnit:currentType
+  204 jump *label11 always
+  205 label *label104
+  206 label *label105
+  207 print "Finding unit: "
+  208 print :findUnit:type
+  209 printflush message1
+  210 ubind :findUnit:type
+  211 jump *label106 notEqual @unit null
+  212 set *tmp4 null
+  213 jump *label115 always
+  214 label *label106
+  215 label *label107
+  216 set :findFreeUnit.0:first_unit @unit
+  217 label *label108
+  218 sensor *tmp7 @unit @controlled
+  219 jump *label109 notEqual *tmp7 0
+  220 ucontrol flag 0
+  221 set *tmp4 @unit
+  222 jump *label115 always
+  223 jump *label112 always
+  224 label *label109
+  225 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+  226 jump *label110 notEqual *tmp10 1
+  227 set :findFreeUnit.0:first_unit @unit
+  228 label *label110
+  229 label *label111
+  230 label *label112
+  231 ubind :findUnit:type
+  232 label *label113
+  233 jump *label108 notEqual :findFreeUnit.0:first_unit @unit
+  234 label *label114
+  235 set *tmp4 null
+  236 jump *label115 always
+  237 label *label115
+  238 jump *label116 equal *tmp4 null
+  239 print "Returning unit: "
+  240 print *tmp4
+  241 printflush message1
+  242 set :findUnit*retval *tmp4
+  243 jump *label5 always
+  244 label *label116
+  245 label *label117
+  246 label *label118
+  247 label *label11
   248 label *label7
   249 jump *label6 always
   250 label *label8

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    16 label *label6
    17 set :findUnit:type .types*0
    18 label *label31
-    * jump *label32 notEqual :findUnit:type :findUnit:currentType
+   19 jump *label32 notEqual .types*0 :findUnit:currentType
    20 jump *label11 always
    21 label *label32
    22 label *label33
    23 print "Finding unit: "
-    * print :findUnit:type
+   24 print .types*0
    25 printflush message1
-    * ubind :findUnit:type
+   26 ubind .types*0
    27 jump *label34 notEqual @unit null
    28 set *tmp4 null
    29 jump *label43 always
 
    44 label *label38
    45 label *label39
    46 label *label40
-    * ubind :findUnit:type
+   47 ubind .types*0
    48 label *label41
    49 jump *label36 notEqual :findFreeUnit.0:first_unit @unit
    50 label *label42
 
    62 label *label46
    63 set :findUnit:type .types*1
    64 label *label49
-    * jump *label50 notEqual :findUnit:type :findUnit:currentType
+   65 jump *label50 notEqual .types*1 :findUnit:currentType
    66 jump *label11 always
    67 label *label50
    68 label *label51
    69 print "Finding unit: "
-    * print :findUnit:type
+   70 print .types*1
    71 printflush message1
-    * ubind :findUnit:type
+   72 ubind .types*1
    73 jump *label52 notEqual @unit null
    74 set *tmp4 null
    75 jump *label61 always
 
    90 label *label56
    91 label *label57
    92 label *label58
-    * ubind :findUnit:type
+   93 ubind .types*1
    94 label *label59
    95 jump *label54 notEqual :findFreeUnit.0:first_unit @unit
    96 label *label60
 
   108 label *label64
   109 set :findUnit:type .types*2
   110 label *label67
-    * jump *label68 notEqual :findUnit:type :findUnit:currentType
+  111 jump *label68 notEqual .types*2 :findUnit:currentType
   112 jump *label11 always
   113 label *label68
   114 label *label69
   115 print "Finding unit: "
-    * print :findUnit:type
+  116 print .types*2
   117 printflush message1
-    * ubind :findUnit:type
+  118 ubind .types*2
   119 jump *label70 notEqual @unit null
   120 set *tmp4 null
   121 jump *label79 always
 
   136 label *label74
   137 label *label75
   138 label *label76
-    * ubind :findUnit:type
+  139 ubind .types*2
   140 label *label77
   141 jump *label72 notEqual :findFreeUnit.0:first_unit @unit
   142 label *label78
 
   154 label *label82
   155 set :findUnit:type .types*3
   156 label *label85
-    * jump *label86 notEqual :findUnit:type :findUnit:currentType
+  157 jump *label86 notEqual .types*3 :findUnit:currentType
   158 jump *label11 always
   159 label *label86
   160 label *label87
   161 print "Finding unit: "
-    * print :findUnit:type
+  162 print .types*3
   163 printflush message1
-    * ubind :findUnit:type
+  164 ubind .types*3
   165 jump *label88 notEqual @unit null
   166 set *tmp4 null
   167 jump *label97 always
 
   182 label *label92
   183 label *label93
   184 label *label94
-    * ubind :findUnit:type
+  185 ubind .types*3
   186 label *label95
   187 jump *label90 notEqual :findFreeUnit.0:first_unit @unit
   188 label *label96
 
   200 label *label100
   201 set :findUnit:type .types*4
   202 label *label103
-    * jump *label104 notEqual :findUnit:type :findUnit:currentType
+  203 jump *label104 notEqual .types*4 :findUnit:currentType
   204 jump *label11 always
   205 label *label104
   206 label *label105
   207 print "Finding unit: "
-    * print :findUnit:type
+  208 print .types*4
   209 printflush message1
-    * ubind :findUnit:type
+  210 ubind .types*4
   211 jump *label106 notEqual @unit null
   212 set *tmp4 null
   213 jump *label115 always
 
   228 label *label110
   229 label *label111
   230 label *label112
-    * ubind :findUnit:type
+  231 ubind .types*4
   232 label *label113
   233 jump *label108 notEqual :findFreeUnit.0:first_unit @unit
   234 label *label114

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    14 print :findUnit:currentUnit
    15 printflush message1
    16 label *label6
-    * set :findUnit:type .types*0
    17 label *label31
    18 jump *label32 notEqual .types*0 :findUnit:currentType
    19 jump *label11 always
 
    59 label *label44
    60 label *label45
    61 label *label46
-    * set :findUnit:type .types*1
    62 label *label49
    63 jump *label50 notEqual .types*1 :findUnit:currentType
    64 jump *label11 always
 
   104 label *label62
   105 label *label63
   106 label *label64
-    * set :findUnit:type .types*2
   107 label *label67
   108 jump *label68 notEqual .types*2 :findUnit:currentType
   109 jump *label11 always
 
   149 label *label80
   150 label *label81
   151 label *label82
-    * set :findUnit:type .types*3
   152 label *label85
   153 jump *label86 notEqual .types*3 :findUnit:currentType
   154 jump *label11 always
 
   194 label *label98
   195 label *label99
   196 label *label100
-    * set :findUnit:type .types*4
   197 label *label103
   198 jump *label104 notEqual .types*4 :findUnit:currentType
   199 jump *label11 always

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-5 instructions):
 
    48 jump *label36 notEqual :findFreeUnit.0:first_unit @unit
    49 label *label42
    50 set *tmp4 null
-    * jump *label43 always
    51 label *label43
    52 jump *label44 equal *tmp4 null
    53 print "Returning unit: "
 
    92 jump *label54 notEqual :findFreeUnit.0:first_unit @unit
    93 label *label60
    94 set *tmp4 null
-    * jump *label61 always
    95 label *label61
    96 jump *label62 equal *tmp4 null
    97 print "Returning unit: "
 
   136 jump *label72 notEqual :findFreeUnit.0:first_unit @unit
   137 label *label78
   138 set *tmp4 null
-    * jump *label79 always
   139 label *label79
   140 jump *label80 equal *tmp4 null
   141 print "Returning unit: "
 
   180 jump *label90 notEqual :findFreeUnit.0:first_unit @unit
   181 label *label96
   182 set *tmp4 null
-    * jump *label97 always
   183 label *label97
   184 jump *label98 equal *tmp4 null
   185 print "Returning unit: "
 
   224 jump *label108 notEqual :findFreeUnit.0:first_unit @unit
   225 label *label114
   226 set *tmp4 null
-    * jump *label115 always
   227 label *label115
   228 jump *label116 equal *tmp4 null
   229 print "Returning unit: "

Modifications by Final phase, Jump Straightening, iteration 1 (-5 instructions):
 
    15 printflush message1
    16 label *label6
    17 label *label31
-    * jump *label32 notEqual .types*0 :findUnit:currentType
-    * jump *label11 always
+   18 jump *label11 equal .types*0 :findUnit:currentType
    19 label *label32
    20 label *label33
    21 print "Finding unit: "
 
    58 label *label45
    59 label *label46
    60 label *label49
-    * jump *label50 notEqual .types*1 :findUnit:currentType
-    * jump *label11 always
+   61 jump *label11 equal .types*1 :findUnit:currentType
    62 label *label50
    63 label *label51
    64 print "Finding unit: "
 
   101 label *label63
   102 label *label64
   103 label *label67
-    * jump *label68 notEqual .types*2 :findUnit:currentType
-    * jump *label11 always
+  104 jump *label11 equal .types*2 :findUnit:currentType
   105 label *label68
   106 label *label69
   107 print "Finding unit: "
 
   144 label *label81
   145 label *label82
   146 label *label85
-    * jump *label86 notEqual .types*3 :findUnit:currentType
-    * jump *label11 always
+  147 jump *label11 equal .types*3 :findUnit:currentType
   148 label *label86
   149 label *label87
   150 print "Finding unit: "
 
   187 label *label99
   188 label *label100
   189 label *label103
-    * jump *label104 notEqual .types*4 :findUnit:currentType
-    * jump *label11 always
+  190 jump *label11 equal .types*4 :findUnit:currentType
   191 label *label104
   192 label *label105
   193 print "Finding unit: "

Modifications by Final phase, Jump Threading, iteration 1:
 
    15 printflush message1
    16 label *label6
    17 label *label31
-    * jump *label11 equal .types*0 :findUnit:currentType
+   18 jump *label6 equal .types*0 :findUnit:currentType
    19 label *label32
    20 label *label33
    21 print "Finding unit: "
 
    58 label *label45
    59 label *label46
    60 label *label49
-    * jump *label11 equal .types*1 :findUnit:currentType
+   61 jump *label6 equal .types*1 :findUnit:currentType
    62 label *label50
    63 label *label51
    64 print "Finding unit: "
 
   101 label *label63
   102 label *label64
   103 label *label67
-    * jump *label11 equal .types*2 :findUnit:currentType
+  104 jump *label6 equal .types*2 :findUnit:currentType
   105 label *label68
   106 label *label69
   107 print "Finding unit: "
 
   144 label *label81
   145 label *label82
   146 label *label85
-    * jump *label11 equal .types*3 :findUnit:currentType
+  147 jump *label6 equal .types*3 :findUnit:currentType
   148 label *label86
   149 label *label87
   150 print "Finding unit: "
 
   187 label *label99
   188 label *label100
   189 label *label103
-    * jump *label11 equal .types*4 :findUnit:currentType
+  190 jump *label6 equal .types*4 :findUnit:currentType
   191 label *label104
   192 label *label105
   193 print "Finding unit: "
 
   220 label *label114
   221 set *tmp4 null
   222 label *label115
-    * jump *label116 equal *tmp4 null
+  223 jump *label6 equal *tmp4 null
   224 print "Returning unit: "
   225 print *tmp4
   226 printflush message1

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-9 instructions):
 
     7 label *label4
     8 wait 1e12
     9 jump *label4 always
-    * end
    10 label *label3
    11 sensor :findUnit:currentType :findUnit:currentUnit @type
    12 print "Trying to find unit better than "
 
    33 ucontrol flag 0
    34 set *tmp4 @unit
    35 jump *label43 always
-    * jump *label40 always
    36 label *label37
    37 sensor *tmp10 :findFreeUnit.0:first_unit @dead
    38 jump *label38 notEqual *tmp10 1
 
    75 ucontrol flag 0
    76 set *tmp4 @unit
    77 jump *label61 always
-    * jump *label58 always
    78 label *label55
    79 sensor *tmp10 :findFreeUnit.0:first_unit @dead
    80 jump *label56 notEqual *tmp10 1
 
   117 ucontrol flag 0
   118 set *tmp4 @unit
   119 jump *label79 always
-    * jump *label76 always
   120 label *label73
   121 sensor *tmp10 :findFreeUnit.0:first_unit @dead
   122 jump *label74 notEqual *tmp10 1
 
   159 ucontrol flag 0
   160 set *tmp4 @unit
   161 jump *label97 always
-    * jump *label94 always
   162 label *label91
   163 sensor *tmp10 :findFreeUnit.0:first_unit @dead
   164 jump *label92 notEqual *tmp10 1
 
   201 ucontrol flag 0
   202 set *tmp4 @unit
   203 jump *label115 always
-    * jump *label112 always
   204 label *label109
   205 sensor *tmp10 :findFreeUnit.0:first_unit @dead
   206 jump *label110 notEqual *tmp10 1
 
   220 printflush message1
   221 set :findUnit*retval *tmp4
   222 jump *label5 always
-    * label *label116
-    * label *label117
-    * label *label118
-    * label *label11
-    * label *label7
-    * jump *label6 always
-    * label *label8
-    * set :findUnit*retval null
   223 label *label5
   224 write :findUnit*retval *mainProcessor ":findUnit*retval"
   225 write true *mainProcessor ":findUnit*finished"
   226 jump *label4 always
-    * end

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   219 print *tmp4
   220 printflush message1
   221 set :findUnit*retval *tmp4
-    * jump *label5 always
   222 label *label5
   223 write :findUnit*retval *mainProcessor ":findUnit*retval"
   224 write true *mainProcessor ":findUnit*finished"

Final code before resolving virtual instructions:

    0:  set .types*0 @mega                                           var types[5] = (@mega, @poly, @horizon, @flare, @mono);
    1:  set .types*1 @poly                                           ...
    2:  set .types*2 @horizon                                        ...
    3:  set .types*3 @flare                                          ...
    4:  set .types*4 @mono                                           ...
    5:  setaddr :findUnit*address *label3                            #set target = 8;
    6:  set *mainProcessor @this                                     ...
        label *label4                                                ...
    7:  wait 1e12                                                    ...
    8:  jump *label4 always 0 0                                      ...
        label *label3                                                remote def findUnit(currentUnit)
    9:  sensor :findUnit:currentType :findUnit:currentUnit @type     var currentType = currentUnit.@type;
   10:  print "Trying to find unit better than "                     print("Trying to find unit better than ", currentUnit);
   11:  print :findUnit:currentUnit                                  ...
   12:  printflush message1                                          printflush(message1);
        label *label6                                                while true do
   13:  jump *label6 equal .types*0 :findUnit:currentType            if type == currentType then break; end;
   14:  print "Finding unit: "                                       print("Finding unit: ", type);
   15:  print .types*0                                               ...
   16:  printflush message1                                          printflush(message1);
   17:  ubind .types*0                                               *units: ubind(unit_type);
   18:  jump *label34 notEqual @unit null                            *units: if @unit == null then return null; end;
   19:  set *tmp4 null                                               ...
   20:  jump *label43 always 0 0                                     ...
        label *label34                                               ...
   21:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label36                                               *units: do
   22:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   23:  jump *label37 notEqual *tmp7 0                               ...
   24:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   25:  set *tmp4 @unit                                              *units: return @unit;
   26:  jump *label43 always 0 0                                     ...
        label *label37                                               *units: if @unit.@controlled == 0 then
   27:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
   28:  jump *label38 notEqual *tmp10 1                              ...
   29:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label38                                               *units: elsif first_unit.@dead == 1 then
   30:  ubind .types*0                                               *units: ubind(unit_type);
   31:  jump *label36 notEqual :findFreeUnit.0:first_unit @unit      *units: do
   32:  set *tmp4 null                                               *units: return null;
        label *label43                                               var unit = findFreeUnit(type, 0);
   33:  jump *label44 equal *tmp4 null                               if unit != null then
   34:  print "Returning unit: "                                     print("Returning unit: ", unit);
   35:  print *tmp4                                                  ...
   36:  printflush message1                                          printflush(message1);
   37:  set :findUnit*retval *tmp4                                   return unit;
   38:  jump *label5 always 0 0                                      ...
        label *label44                                               if unit != null then
   39:  jump *label6 equal .types*1 :findUnit:currentType            if type == currentType then break; end;
   40:  print "Finding unit: "                                       print("Finding unit: ", type);
   41:  print .types*1                                               ...
   42:  printflush message1                                          printflush(message1);
   43:  ubind .types*1                                               *units: ubind(unit_type);
   44:  jump *label52 notEqual @unit null                            *units: if @unit == null then return null; end;
   45:  set *tmp4 null                                               ...
   46:  jump *label61 always 0 0                                     ...
        label *label52                                               ...
   47:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label54                                               *units: do
   48:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   49:  jump *label55 notEqual *tmp7 0                               ...
   50:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   51:  set *tmp4 @unit                                              *units: return @unit;
   52:  jump *label61 always 0 0                                     ...
        label *label55                                               *units: if @unit.@controlled == 0 then
   53:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
   54:  jump *label56 notEqual *tmp10 1                              ...
   55:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label56                                               *units: elsif first_unit.@dead == 1 then
   56:  ubind .types*1                                               *units: ubind(unit_type);
   57:  jump *label54 notEqual :findFreeUnit.0:first_unit @unit      *units: do
   58:  set *tmp4 null                                               *units: return null;
        label *label61                                               var unit = findFreeUnit(type, 0);
   59:  jump *label62 equal *tmp4 null                               if unit != null then
   60:  print "Returning unit: "                                     print("Returning unit: ", unit);
   61:  print *tmp4                                                  ...
   62:  printflush message1                                          printflush(message1);
   63:  set :findUnit*retval *tmp4                                   return unit;
   64:  jump *label5 always 0 0                                      ...
        label *label62                                               if unit != null then
   65:  jump *label6 equal .types*2 :findUnit:currentType            if type == currentType then break; end;
   66:  print "Finding unit: "                                       print("Finding unit: ", type);
   67:  print .types*2                                               ...
   68:  printflush message1                                          printflush(message1);
   69:  ubind .types*2                                               *units: ubind(unit_type);
   70:  jump *label70 notEqual @unit null                            *units: if @unit == null then return null; end;
   71:  set *tmp4 null                                               ...
   72:  jump *label79 always 0 0                                     ...
        label *label70                                               ...
   73:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label72                                               *units: do
   74:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   75:  jump *label73 notEqual *tmp7 0                               ...
   76:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   77:  set *tmp4 @unit                                              *units: return @unit;
   78:  jump *label79 always 0 0                                     ...
        label *label73                                               *units: if @unit.@controlled == 0 then
   79:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
   80:  jump *label74 notEqual *tmp10 1                              ...
   81:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label74                                               *units: elsif first_unit.@dead == 1 then
   82:  ubind .types*2                                               *units: ubind(unit_type);
   83:  jump *label72 notEqual :findFreeUnit.0:first_unit @unit      *units: do
   84:  set *tmp4 null                                               *units: return null;
        label *label79                                               var unit = findFreeUnit(type, 0);
   85:  jump *label80 equal *tmp4 null                               if unit != null then
   86:  print "Returning unit: "                                     print("Returning unit: ", unit);
   87:  print *tmp4                                                  ...
   88:  printflush message1                                          printflush(message1);
   89:  set :findUnit*retval *tmp4                                   return unit;
   90:  jump *label5 always 0 0                                      ...
        label *label80                                               if unit != null then
   91:  jump *label6 equal .types*3 :findUnit:currentType            if type == currentType then break; end;
   92:  print "Finding unit: "                                       print("Finding unit: ", type);
   93:  print .types*3                                               ...
   94:  printflush message1                                          printflush(message1);
   95:  ubind .types*3                                               *units: ubind(unit_type);
   96:  jump *label88 notEqual @unit null                            *units: if @unit == null then return null; end;
   97:  set *tmp4 null                                               ...
   98:  jump *label97 always 0 0                                     ...
        label *label88                                               ...
   99:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label90                                               *units: do
  100:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
  101:  jump *label91 notEqual *tmp7 0                               ...
  102:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  103:  set *tmp4 @unit                                              *units: return @unit;
  104:  jump *label97 always 0 0                                     ...
        label *label91                                               *units: if @unit.@controlled == 0 then
  105:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
  106:  jump *label92 notEqual *tmp10 1                              ...
  107:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label92                                               *units: elsif first_unit.@dead == 1 then
  108:  ubind .types*3                                               *units: ubind(unit_type);
  109:  jump *label90 notEqual :findFreeUnit.0:first_unit @unit      *units: do
  110:  set *tmp4 null                                               *units: return null;
        label *label97                                               var unit = findFreeUnit(type, 0);
  111:  jump *label98 equal *tmp4 null                               if unit != null then
  112:  print "Returning unit: "                                     print("Returning unit: ", unit);
  113:  print *tmp4                                                  ...
  114:  printflush message1                                          printflush(message1);
  115:  set :findUnit*retval *tmp4                                   return unit;
  116:  jump *label5 always 0 0                                      ...
        label *label98                                               if unit != null then
  117:  jump *label6 equal .types*4 :findUnit:currentType            if type == currentType then break; end;
  118:  print "Finding unit: "                                       print("Finding unit: ", type);
  119:  print .types*4                                               ...
  120:  printflush message1                                          printflush(message1);
  121:  ubind .types*4                                               *units: ubind(unit_type);
  122:  jump *label106 notEqual @unit null                           *units: if @unit == null then return null; end;
  123:  set *tmp4 null                                               ...
  124:  jump *label115 always 0 0                                    ...
        label *label106                                              ...
  125:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label108                                              *units: do
  126:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
  127:  jump *label109 notEqual *tmp7 0                              ...
  128:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  129:  set *tmp4 @unit                                              *units: return @unit;
  130:  jump *label115 always 0 0                                    ...
        label *label109                                              *units: if @unit.@controlled == 0 then
  131:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
  132:  jump *label110 notEqual *tmp10 1                             ...
  133:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label110                                              *units: elsif first_unit.@dead == 1 then
  134:  ubind .types*4                                               *units: ubind(unit_type);
  135:  jump *label108 notEqual :findFreeUnit.0:first_unit @unit     *units: do
  136:  set *tmp4 null                                               *units: return null;
        label *label115                                              var unit = findFreeUnit(type, 0);
  137:  jump *label6 equal *tmp4 null                                if unit != null then
  138:  print "Returning unit: "                                     print("Returning unit: ", unit);
  139:  print *tmp4                                                  ...
  140:  printflush message1                                          printflush(message1);
  141:  set :findUnit*retval *tmp4                                   return unit;
        label *label5                                                remote def findUnit(currentUnit)
  142:  write :findUnit*retval *mainProcessor ":findUnit*retval"     ...
  143:  write true *mainProcessor ":findUnit*finished"               ...
  144:  jump *label4 always 0 0                                      ...


Performance: parsed in 167 ms, compiled in 231 ms, optimized in 192 ms, run in 10 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (8 steps):
The program didn't generate any output.
Execution exception at instruction 7: wait 1e12:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
