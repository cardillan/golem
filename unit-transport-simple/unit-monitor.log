    82 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
    10 instructions eliminated by Dead Code Elimination (4 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     6 instructions eliminated by Jump Optimization (4 iterations).
    10 instructions eliminated by Single Step Elimination (3 passes, 7 iterations).
     9 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
    82 instructions added by Loop Unrolling (4 iterations).
     1 loops unrolled by Loop Unrolling.
     5 instructions eliminated by Jump Straightening (4 iterations).
     6 instructions updated by JumpThreading.
     9 instructions eliminated by Unreachable Code Elimination.
   112 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 945):
  * Unroll iteration loop at line 18:9                           cost    96, benefit      475.0, efficiency        4.9 (+77 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-8 instructions):
 
    35 op equal *tmp2 :findUnit:type :findUnit:currentType
    36 jump *label17 equal *tmp2 false
    37 jump *label11 always
-    * set *tmp3 null
    38 jump *label18 always
    39 label *label17
-    * set *tmp3 null
    40 label *label18
    41 set :findFreeUnit.0:unit_type :findUnit:type
    42 set :findFreeUnit.0:initial_flag 0
 
    45 jump *label20 equal *tmp5 false
    46 set *tmp4 null
    47 jump *label19 always
-    * set *tmp6 null
    48 jump *label21 always
    49 label *label20
-    * set *tmp6 null
    50 label *label21
    51 set :findFreeUnit.0:first_unit @unit
    52 label *label22
 
    56 ucontrol flag :findFreeUnit.0:initial_flag
    57 set *tmp4 @unit
    58 jump *label19 always
-    * set *tmp9 null
    59 jump *label26 always
    60 label *label25
    61 sensor *tmp10 :findFreeUnit.0:first_unit @dead
 
    68 label *label27
    69 set *tmp12 null
    70 label *label28
-    * set *tmp9 *tmp12
    71 label *label26
    72 ubind :findFreeUnit.0:unit_type
    73 label *label23
 
    83 jump *label29 equal *tmp15 false
    84 set :findUnit*retval :findUnit:unit
    85 jump *label5 always
-    * set *tmp16 null
    86 jump *label30 always
    87 label *label29
-    * set *tmp16 null
    88 label *label30
    89 label *label10
    90 multijump *tmp1 0 0 marker0

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
    63 jump *label27 equal *tmp11 false
    64 set *tmp13 @unit
    65 set :findFreeUnit.0:first_unit *tmp13
-    * set *tmp12 :findFreeUnit.0:first_unit
    66 jump *label28 always
    67 label *label27
-    * set *tmp12 null
    68 label *label28
    69 label *label26
    70 ubind :findFreeUnit.0:unit_type

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
     9 jump *label4 always
    10 end
    11 label *label3
-    * sensor *tmp0 :findUnit:currentUnit @type
-    * set :findUnit:currentType *tmp0
+   12 sensor :findUnit:currentType :findUnit:currentUnit @type
    13 label *label6
    14 jump *label8 equal true false
    15 setaddr *tmp1 *label12
 
    60 sensor *tmp10 :findFreeUnit.0:first_unit @dead
    61 op equal *tmp11 *tmp10 1
    62 jump *label27 equal *tmp11 false
-    * set *tmp13 @unit
-    * set :findFreeUnit.0:first_unit *tmp13
+   63 set :findFreeUnit.0:first_unit @unit
    64 jump *label28 always
    65 label *label27
    66 label *label28

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    11 label *label3
    12 sensor :findUnit:currentType :findUnit:currentUnit @type
    13 label *label6
-    * jump *label8 equal true false
    14 setaddr *tmp1 *label12
    15 set :findUnit:type .types*0
    16 jump *label9 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-6 instructions):
 
    30 setaddr *tmp1 *label16
    31 set :findUnit:type .types*4
    32 label *label9
-    * op equal *tmp2 :findUnit:type :findUnit:currentType
-    * jump *label17 equal *tmp2 false
+   33 jump *label17 notEqual :findUnit:type :findUnit:currentType
    34 jump *label11 always
    35 jump *label18 always
    36 label *label17
 
    38 set :findFreeUnit.0:unit_type :findUnit:type
    39 set :findFreeUnit.0:initial_flag 0
    40 ubind :findFreeUnit.0:unit_type
-    * op equal *tmp5 @unit null
-    * jump *label20 equal *tmp5 false
+   41 jump *label20 notEqual @unit null
    42 set *tmp4 null
    43 jump *label19 always
    44 jump *label21 always
 
    47 set :findFreeUnit.0:first_unit @unit
    48 label *label22
    49 sensor *tmp7 @unit @controlled
-    * op equal *tmp8 *tmp7 0
-    * jump *label25 equal *tmp8 false
+   50 jump *label25 notEqual *tmp7 0
    51 ucontrol flag :findFreeUnit.0:initial_flag
    52 set *tmp4 @unit
    53 jump *label19 always
    54 jump *label26 always
    55 label *label25
    56 sensor *tmp10 :findFreeUnit.0:first_unit @dead
-    * op equal *tmp11 *tmp10 1
-    * jump *label27 equal *tmp11 false
+   57 jump *label27 notEqual *tmp10 1
    58 set :findFreeUnit.0:first_unit @unit
    59 jump *label28 always
    60 label *label27
 
    62 label *label26
    63 ubind :findFreeUnit.0:unit_type
    64 label *label23
-    * op notEqual *tmp14 :findFreeUnit.0:first_unit @unit
-    * jump *label22 notEqual *tmp14 false
+   65 jump *label22 notEqual :findFreeUnit.0:first_unit @unit
    66 label *label24
    67 set *tmp4 null
    68 jump *label19 always
    69 set *tmp4 null
    70 label *label19
    71 set :findUnit:unit *tmp4
-    * op notEqual *tmp15 :findUnit:unit null
-    * jump *label29 equal *tmp15 false
+   72 jump *label29 equal :findUnit:unit null
    73 set :findUnit*retval :findUnit:unit
    74 jump *label5 always
    75 jump *label30 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    32 label *label9
    33 jump *label17 notEqual :findUnit:type :findUnit:currentType
    34 jump *label11 always
-    * jump *label18 always
    35 label *label17
    36 label *label18
    37 set :findFreeUnit.0:unit_type :findUnit:type
 
    40 jump *label20 notEqual @unit null
    41 set *tmp4 null
    42 jump *label19 always
-    * jump *label21 always
    43 label *label20
    44 label *label21
    45 set :findFreeUnit.0:first_unit @unit
 
    54 sensor *tmp10 :findFreeUnit.0:first_unit @dead
    55 jump *label27 notEqual *tmp10 1
    56 set :findFreeUnit.0:first_unit @unit
-    * jump *label28 always
    57 label *label27
    58 label *label28
    59 label *label26
 
    69 jump *label29 equal :findUnit:unit null
    70 set :findUnit*retval :findUnit:unit
    71 jump *label5 always
-    * jump *label30 always
    72 label *label29
    73 label *label30
    74 label *label10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    36 label *label18
    37 set :findFreeUnit.0:unit_type :findUnit:type
    38 set :findFreeUnit.0:initial_flag 0
-    * ubind :findFreeUnit.0:unit_type
+   39 ubind :findUnit:type
    40 jump *label20 notEqual @unit null
    41 set *tmp4 null
    42 jump *label19 always
 
    46 label *label22
    47 sensor *tmp7 @unit @controlled
    48 jump *label25 notEqual *tmp7 0
-    * ucontrol flag :findFreeUnit.0:initial_flag
+   49 ucontrol flag 0
    50 set *tmp4 @unit
    51 jump *label19 always
    52 jump *label26 always
 
    57 label *label27
    58 label *label28
    59 label *label26
-    * ubind :findFreeUnit.0:unit_type
+   60 ubind :findUnit:type
    61 label *label23
    62 jump *label22 notEqual :findFreeUnit.0:first_unit @unit
    63 label *label24
    64 set *tmp4 null
    65 jump *label19 always
-    * set *tmp4 null
    66 label *label19
    67 set :findUnit:unit *tmp4
-    * jump *label29 equal :findUnit:unit null
-    * set :findUnit*retval :findUnit:unit
+   68 jump *label29 equal *tmp4 null
+   69 set :findUnit*retval *tmp4
    70 jump *label5 always
    71 label *label29
    72 label *label30

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    34 jump *label11 always
    35 label *label17
    36 label *label18
-    * set :findFreeUnit.0:unit_type :findUnit:type
-    * set :findFreeUnit.0:initial_flag 0
    37 ubind :findUnit:type
    38 jump *label20 notEqual @unit null
    39 set *tmp4 null
 
    62 set *tmp4 null
    63 jump *label19 always
    64 label *label19
-    * set :findUnit:unit *tmp4
    65 jump *label29 equal *tmp4 null
    66 set :findUnit*retval *tmp4
    67 jump *label5 always

Modifications by Unroll iteration loop at line 18:9 (+82 instructions):
 
    11 label *label3
    12 sensor :findUnit:currentType :findUnit:currentUnit @type
    13 label *label6
-    * setaddr *tmp1 *label12
-    * set :findUnit:type .types*0
-    * jump *label9 always
-    * multilabel *label12 marker0
-    * setaddr *tmp1 *label13
-    * set :findUnit:type .types*1
-    * jump *label9 always
-    * multilabel *label13 marker0
-    * setaddr *tmp1 *label14
-    * set :findUnit:type .types*2
-    * jump *label9 always
-    * multilabel *label14 marker0
-    * setaddr *tmp1 *label15
-    * set :findUnit:type .types*3
-    * jump *label9 always
-    * multilabel *label15 marker0
-    * setaddr *tmp1 *label16
-    * set :findUnit:type .types*4
-    * label *label9
-    * jump *label17 notEqual :findUnit:type :findUnit:currentType
-    * jump *label11 always
-    * label *label17
-    * label *label18
-    * ubind :findUnit:type
-    * jump *label20 notEqual @unit null
-    * set *tmp4 null
-    * jump *label19 always
-    * label *label20
-    * label *label21
-    * set :findFreeUnit.0:first_unit @unit
-    * label *label22
-    * sensor *tmp7 @unit @controlled
-    * jump *label25 notEqual *tmp7 0
-    * ucontrol flag 0
-    * set *tmp4 @unit
-    * jump *label19 always
-    * jump *label26 always
-    * label *label25
-    * sensor *tmp10 :findFreeUnit.0:first_unit @dead
-    * jump *label27 notEqual *tmp10 1
-    * set :findFreeUnit.0:first_unit @unit
-    * label *label27
-    * label *label28
-    * label *label26
-    * ubind :findUnit:type
-    * label *label23
-    * jump *label22 notEqual :findFreeUnit.0:first_unit @unit
-    * label *label24
-    * set *tmp4 null
-    * jump *label19 always
-    * label *label19
-    * jump *label29 equal *tmp4 null
-    * set :findUnit*retval *tmp4
-    * jump *label5 always
-    * label *label29
-    * label *label30
-    * label *label10
-    * multijump *tmp1 0 0 marker0
-    * multilabel *label16 marker0
-    * label *label11
+   14 set :findUnit:type .types*0
+   15 label *label31
+   16 jump *label32 notEqual :findUnit:type :findUnit:currentType
+   17 jump *label11 always
+   18 label *label32
+   19 label *label33
+   20 ubind :findUnit:type
+   21 jump *label34 notEqual @unit null
+   22 set *tmp4 null
+   23 jump *label43 always
+   24 label *label34
+   25 label *label35
+   26 set :findFreeUnit.0:first_unit @unit
+   27 label *label36
+   28 sensor *tmp7 @unit @controlled
+   29 jump *label37 notEqual *tmp7 0
+   30 ucontrol flag 0
+   31 set *tmp4 @unit
+   32 jump *label43 always
+   33 jump *label40 always
+   34 label *label37
+   35 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+   36 jump *label38 notEqual *tmp10 1
+   37 set :findFreeUnit.0:first_unit @unit
+   38 label *label38
+   39 label *label39
+   40 label *label40
+   41 ubind :findUnit:type
+   42 label *label41
+   43 jump *label36 notEqual :findFreeUnit.0:first_unit @unit
+   44 label *label42
+   45 set *tmp4 null
+   46 jump *label43 always
+   47 label *label43
+   48 jump *label44 equal *tmp4 null
+   49 set :findUnit*retval *tmp4
+   50 jump *label5 always
+   51 label *label44
+   52 label *label45
+   53 label *label46
+   54 set :findUnit:type .types*1
+   55 label *label49
+   56 jump *label50 notEqual :findUnit:type :findUnit:currentType
+   57 jump *label11 always
+   58 label *label50
+   59 label *label51
+   60 ubind :findUnit:type
+   61 jump *label52 notEqual @unit null
+   62 set *tmp4 null
+   63 jump *label61 always
+   64 label *label52
+   65 label *label53
+   66 set :findFreeUnit.0:first_unit @unit
+   67 label *label54
+   68 sensor *tmp7 @unit @controlled
+   69 jump *label55 notEqual *tmp7 0
+   70 ucontrol flag 0
+   71 set *tmp4 @unit
+   72 jump *label61 always
+   73 jump *label58 always
+   74 label *label55
+   75 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+   76 jump *label56 notEqual *tmp10 1
+   77 set :findFreeUnit.0:first_unit @unit
+   78 label *label56
+   79 label *label57
+   80 label *label58
+   81 ubind :findUnit:type
+   82 label *label59
+   83 jump *label54 notEqual :findFreeUnit.0:first_unit @unit
+   84 label *label60
+   85 set *tmp4 null
+   86 jump *label61 always
+   87 label *label61
+   88 jump *label62 equal *tmp4 null
+   89 set :findUnit*retval *tmp4
+   90 jump *label5 always
+   91 label *label62
+   92 label *label63
+   93 label *label64
+   94 set :findUnit:type .types*2
+   95 label *label67
+   96 jump *label68 notEqual :findUnit:type :findUnit:currentType
+   97 jump *label11 always
+   98 label *label68
+   99 label *label69
+  100 ubind :findUnit:type
+  101 jump *label70 notEqual @unit null
+  102 set *tmp4 null
+  103 jump *label79 always
+  104 label *label70
+  105 label *label71
+  106 set :findFreeUnit.0:first_unit @unit
+  107 label *label72
+  108 sensor *tmp7 @unit @controlled
+  109 jump *label73 notEqual *tmp7 0
+  110 ucontrol flag 0
+  111 set *tmp4 @unit
+  112 jump *label79 always
+  113 jump *label76 always
+  114 label *label73
+  115 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+  116 jump *label74 notEqual *tmp10 1
+  117 set :findFreeUnit.0:first_unit @unit
+  118 label *label74
+  119 label *label75
+  120 label *label76
+  121 ubind :findUnit:type
+  122 label *label77
+  123 jump *label72 notEqual :findFreeUnit.0:first_unit @unit
+  124 label *label78
+  125 set *tmp4 null
+  126 jump *label79 always
+  127 label *label79
+  128 jump *label80 equal *tmp4 null
+  129 set :findUnit*retval *tmp4
+  130 jump *label5 always
+  131 label *label80
+  132 label *label81
+  133 label *label82
+  134 set :findUnit:type .types*3
+  135 label *label85
+  136 jump *label86 notEqual :findUnit:type :findUnit:currentType
+  137 jump *label11 always
+  138 label *label86
+  139 label *label87
+  140 ubind :findUnit:type
+  141 jump *label88 notEqual @unit null
+  142 set *tmp4 null
+  143 jump *label97 always
+  144 label *label88
+  145 label *label89
+  146 set :findFreeUnit.0:first_unit @unit
+  147 label *label90
+  148 sensor *tmp7 @unit @controlled
+  149 jump *label91 notEqual *tmp7 0
+  150 ucontrol flag 0
+  151 set *tmp4 @unit
+  152 jump *label97 always
+  153 jump *label94 always
+  154 label *label91
+  155 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+  156 jump *label92 notEqual *tmp10 1
+  157 set :findFreeUnit.0:first_unit @unit
+  158 label *label92
+  159 label *label93
+  160 label *label94
+  161 ubind :findUnit:type
+  162 label *label95
+  163 jump *label90 notEqual :findFreeUnit.0:first_unit @unit
+  164 label *label96
+  165 set *tmp4 null
+  166 jump *label97 always
+  167 label *label97
+  168 jump *label98 equal *tmp4 null
+  169 set :findUnit*retval *tmp4
+  170 jump *label5 always
+  171 label *label98
+  172 label *label99
+  173 label *label100
+  174 set :findUnit:type .types*4
+  175 label *label103
+  176 jump *label104 notEqual :findUnit:type :findUnit:currentType
+  177 jump *label11 always
+  178 label *label104
+  179 label *label105
+  180 ubind :findUnit:type
+  181 jump *label106 notEqual @unit null
+  182 set *tmp4 null
+  183 jump *label115 always
+  184 label *label106
+  185 label *label107
+  186 set :findFreeUnit.0:first_unit @unit
+  187 label *label108
+  188 sensor *tmp7 @unit @controlled
+  189 jump *label109 notEqual *tmp7 0
+  190 ucontrol flag 0
+  191 set *tmp4 @unit
+  192 jump *label115 always
+  193 jump *label112 always
+  194 label *label109
+  195 sensor *tmp10 :findFreeUnit.0:first_unit @dead
+  196 jump *label110 notEqual *tmp10 1
+  197 set :findFreeUnit.0:first_unit @unit
+  198 label *label110
+  199 label *label111
+  200 label *label112
+  201 ubind :findUnit:type
+  202 label *label113
+  203 jump *label108 notEqual :findFreeUnit.0:first_unit @unit
+  204 label *label114
+  205 set *tmp4 null
+  206 jump *label115 always
+  207 label *label115
+  208 jump *label116 equal *tmp4 null
+  209 set :findUnit*retval *tmp4
+  210 jump *label5 always
+  211 label *label116
+  212 label *label117
+  213 label *label118
+  214 label *label11
   215 label *label7
   216 jump *label6 always
   217 label *label8

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    13 label *label6
    14 set :findUnit:type .types*0
    15 label *label31
-    * jump *label32 notEqual :findUnit:type :findUnit:currentType
+   16 jump *label32 notEqual .types*0 :findUnit:currentType
    17 jump *label11 always
    18 label *label32
    19 label *label33
-    * ubind :findUnit:type
+   20 ubind .types*0
    21 jump *label34 notEqual @unit null
    22 set *tmp4 null
    23 jump *label43 always
 
    38 label *label38
    39 label *label39
    40 label *label40
-    * ubind :findUnit:type
+   41 ubind .types*0
    42 label *label41
    43 jump *label36 notEqual :findFreeUnit.0:first_unit @unit
    44 label *label42
 
    53 label *label46
    54 set :findUnit:type .types*1
    55 label *label49
-    * jump *label50 notEqual :findUnit:type :findUnit:currentType
+   56 jump *label50 notEqual .types*1 :findUnit:currentType
    57 jump *label11 always
    58 label *label50
    59 label *label51
-    * ubind :findUnit:type
+   60 ubind .types*1
    61 jump *label52 notEqual @unit null
    62 set *tmp4 null
    63 jump *label61 always
 
    78 label *label56
    79 label *label57
    80 label *label58
-    * ubind :findUnit:type
+   81 ubind .types*1
    82 label *label59
    83 jump *label54 notEqual :findFreeUnit.0:first_unit @unit
    84 label *label60
 
    93 label *label64
    94 set :findUnit:type .types*2
    95 label *label67
-    * jump *label68 notEqual :findUnit:type :findUnit:currentType
+   96 jump *label68 notEqual .types*2 :findUnit:currentType
    97 jump *label11 always
    98 label *label68
    99 label *label69
-    * ubind :findUnit:type
+  100 ubind .types*2
   101 jump *label70 notEqual @unit null
   102 set *tmp4 null
   103 jump *label79 always
 
   118 label *label74
   119 label *label75
   120 label *label76
-    * ubind :findUnit:type
+  121 ubind .types*2
   122 label *label77
   123 jump *label72 notEqual :findFreeUnit.0:first_unit @unit
   124 label *label78
 
   133 label *label82
   134 set :findUnit:type .types*3
   135 label *label85
-    * jump *label86 notEqual :findUnit:type :findUnit:currentType
+  136 jump *label86 notEqual .types*3 :findUnit:currentType
   137 jump *label11 always
   138 label *label86
   139 label *label87
-    * ubind :findUnit:type
+  140 ubind .types*3
   141 jump *label88 notEqual @unit null
   142 set *tmp4 null
   143 jump *label97 always
 
   158 label *label92
   159 label *label93
   160 label *label94
-    * ubind :findUnit:type
+  161 ubind .types*3
   162 label *label95
   163 jump *label90 notEqual :findFreeUnit.0:first_unit @unit
   164 label *label96
 
   173 label *label100
   174 set :findUnit:type .types*4
   175 label *label103
-    * jump *label104 notEqual :findUnit:type :findUnit:currentType
+  176 jump *label104 notEqual .types*4 :findUnit:currentType
   177 jump *label11 always
   178 label *label104
   179 label *label105
-    * ubind :findUnit:type
+  180 ubind .types*4
   181 jump *label106 notEqual @unit null
   182 set *tmp4 null
   183 jump *label115 always
 
   198 label *label110
   199 label *label111
   200 label *label112
-    * ubind :findUnit:type
+  201 ubind .types*4
   202 label *label113
   203 jump *label108 notEqual :findFreeUnit.0:first_unit @unit
   204 label *label114

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    11 label *label3
    12 sensor :findUnit:currentType :findUnit:currentUnit @type
    13 label *label6
-    * set :findUnit:type .types*0
    14 label *label31
    15 jump *label32 notEqual .types*0 :findUnit:currentType
    16 jump *label11 always
 
    50 label *label44
    51 label *label45
    52 label *label46
-    * set :findUnit:type .types*1
    53 label *label49
    54 jump *label50 notEqual .types*1 :findUnit:currentType
    55 jump *label11 always
 
    89 label *label62
    90 label *label63
    91 label *label64
-    * set :findUnit:type .types*2
    92 label *label67
    93 jump *label68 notEqual .types*2 :findUnit:currentType
    94 jump *label11 always
 
   128 label *label80
   129 label *label81
   130 label *label82
-    * set :findUnit:type .types*3
   131 label *label85
   132 jump *label86 notEqual .types*3 :findUnit:currentType
   133 jump *label11 always
 
   167 label *label98
   168 label *label99
   169 label *label100
-    * set :findUnit:type .types*4
   170 label *label103
   171 jump *label104 notEqual .types*4 :findUnit:currentType
   172 jump *label11 always

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-5 instructions):
 
    42 jump *label36 notEqual :findFreeUnit.0:first_unit @unit
    43 label *label42
    44 set *tmp4 null
-    * jump *label43 always
    45 label *label43
    46 jump *label44 equal *tmp4 null
    47 set :findUnit*retval *tmp4
 
    80 jump *label54 notEqual :findFreeUnit.0:first_unit @unit
    81 label *label60
    82 set *tmp4 null
-    * jump *label61 always
    83 label *label61
    84 jump *label62 equal *tmp4 null
    85 set :findUnit*retval *tmp4
 
   118 jump *label72 notEqual :findFreeUnit.0:first_unit @unit
   119 label *label78
   120 set *tmp4 null
-    * jump *label79 always
   121 label *label79
   122 jump *label80 equal *tmp4 null
   123 set :findUnit*retval *tmp4
 
   156 jump *label90 notEqual :findFreeUnit.0:first_unit @unit
   157 label *label96
   158 set *tmp4 null
-    * jump *label97 always
   159 label *label97
   160 jump *label98 equal *tmp4 null
   161 set :findUnit*retval *tmp4
 
   194 jump *label108 notEqual :findFreeUnit.0:first_unit @unit
   195 label *label114
   196 set *tmp4 null
-    * jump *label115 always
   197 label *label115
   198 jump *label116 equal *tmp4 null
   199 set :findUnit*retval *tmp4

Modifications by Final phase, Jump Straightening, iteration 1 (-5 instructions):
 
    12 sensor :findUnit:currentType :findUnit:currentUnit @type
    13 label *label6
    14 label *label31
-    * jump *label32 notEqual .types*0 :findUnit:currentType
-    * jump *label11 always
+   15 jump *label11 equal .types*0 :findUnit:currentType
    16 label *label32
    17 label *label33
    18 ubind .types*0
 
    49 label *label45
    50 label *label46
    51 label *label49
-    * jump *label50 notEqual .types*1 :findUnit:currentType
-    * jump *label11 always
+   52 jump *label11 equal .types*1 :findUnit:currentType
    53 label *label50
    54 label *label51
    55 ubind .types*1
 
    86 label *label63
    87 label *label64
    88 label *label67
-    * jump *label68 notEqual .types*2 :findUnit:currentType
-    * jump *label11 always
+   89 jump *label11 equal .types*2 :findUnit:currentType
    90 label *label68
    91 label *label69
    92 ubind .types*2
 
   123 label *label81
   124 label *label82
   125 label *label85
-    * jump *label86 notEqual .types*3 :findUnit:currentType
-    * jump *label11 always
+  126 jump *label11 equal .types*3 :findUnit:currentType
   127 label *label86
   128 label *label87
   129 ubind .types*3
 
   160 label *label99
   161 label *label100
   162 label *label103
-    * jump *label104 notEqual .types*4 :findUnit:currentType
-    * jump *label11 always
+  163 jump *label11 equal .types*4 :findUnit:currentType
   164 label *label104
   165 label *label105
   166 ubind .types*4

Modifications by Final phase, Jump Threading, iteration 1:
 
    12 sensor :findUnit:currentType :findUnit:currentUnit @type
    13 label *label6
    14 label *label31
-    * jump *label11 equal .types*0 :findUnit:currentType
+   15 jump *label6 equal .types*0 :findUnit:currentType
    16 label *label32
    17 label *label33
    18 ubind .types*0
 
    49 label *label45
    50 label *label46
    51 label *label49
-    * jump *label11 equal .types*1 :findUnit:currentType
+   52 jump *label6 equal .types*1 :findUnit:currentType
    53 label *label50
    54 label *label51
    55 ubind .types*1
 
    86 label *label63
    87 label *label64
    88 label *label67
-    * jump *label11 equal .types*2 :findUnit:currentType
+   89 jump *label6 equal .types*2 :findUnit:currentType
    90 label *label68
    91 label *label69
    92 ubind .types*2
 
   123 label *label81
   124 label *label82
   125 label *label85
-    * jump *label11 equal .types*3 :findUnit:currentType
+  126 jump *label6 equal .types*3 :findUnit:currentType
   127 label *label86
   128 label *label87
   129 ubind .types*3
 
   160 label *label99
   161 label *label100
   162 label *label103
-    * jump *label11 equal .types*4 :findUnit:currentType
+  163 jump *label6 equal .types*4 :findUnit:currentType
   164 label *label104
   165 label *label105
   166 ubind .types*4
 
   190 label *label114
   191 set *tmp4 null
   192 label *label115
-    * jump *label116 equal *tmp4 null
+  193 jump *label6 equal *tmp4 null
   194 set :findUnit*retval *tmp4
   195 jump *label5 always
   196 label *label116

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-9 instructions):
 
     7 label *label4
     8 wait 1e12
     9 jump *label4 always
-    * end
    10 label *label3
    11 sensor :findUnit:currentType :findUnit:currentUnit @type
    12 label *label6
 
    27 ucontrol flag 0
    28 set *tmp4 @unit
    29 jump *label43 always
-    * jump *label40 always
    30 label *label37
    31 sensor *tmp10 :findFreeUnit.0:first_unit @dead
    32 jump *label38 notEqual *tmp10 1
 
    63 ucontrol flag 0
    64 set *tmp4 @unit
    65 jump *label61 always
-    * jump *label58 always
    66 label *label55
    67 sensor *tmp10 :findFreeUnit.0:first_unit @dead
    68 jump *label56 notEqual *tmp10 1
 
    99 ucontrol flag 0
   100 set *tmp4 @unit
   101 jump *label79 always
-    * jump *label76 always
   102 label *label73
   103 sensor *tmp10 :findFreeUnit.0:first_unit @dead
   104 jump *label74 notEqual *tmp10 1
 
   135 ucontrol flag 0
   136 set *tmp4 @unit
   137 jump *label97 always
-    * jump *label94 always
   138 label *label91
   139 sensor *tmp10 :findFreeUnit.0:first_unit @dead
   140 jump *label92 notEqual *tmp10 1
 
   171 ucontrol flag 0
   172 set *tmp4 @unit
   173 jump *label115 always
-    * jump *label112 always
   174 label *label109
   175 sensor *tmp10 :findFreeUnit.0:first_unit @dead
   176 jump *label110 notEqual *tmp10 1
 
   187 jump *label6 equal *tmp4 null
   188 set :findUnit*retval *tmp4
   189 jump *label5 always
-    * label *label116
-    * label *label117
-    * label *label118
-    * label *label11
-    * label *label7
-    * jump *label6 always
-    * label *label8
-    * set :findUnit*retval null
   190 label *label5
   191 write :findUnit*retval *mainProcessor ":findUnit*retval"
   192 write true *mainProcessor ":findUnit*finished"
   193 jump *label4 always
-    * end

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   186 label *label115
   187 jump *label6 equal *tmp4 null
   188 set :findUnit*retval *tmp4
-    * jump *label5 always
   189 label *label5
   190 write :findUnit*retval *mainProcessor ":findUnit*retval"
   191 write true *mainProcessor ":findUnit*finished"

Final code before resolving virtual instructions:

    0:  set .types*0 @mega                                           var types[5] = (@mega, @poly, @zenith, @flare, @mono);
    1:  set .types*1 @poly                                           ...
    2:  set .types*2 @zenith                                         ...
    3:  set .types*3 @flare                                          ...
    4:  set .types*4 @mono                                           ...
    5:  setaddr :findUnit*address *label3                            #set target = 8;
    6:  set *mainProcessor @this                                     ...
        label *label4                                                ...
    7:  wait 1e12                                                    ...
    8:  jump *label4 always 0 0                                      ...
        label *label3                                                remote def findUnit(currentUnit)
    9:  sensor :findUnit:currentType :findUnit:currentUnit @type     var currentType = currentUnit.@type;
        label *label6                                                while true do
   10:  jump *label6 equal .types*0 :findUnit:currentType            if type == currentType then break; end;
   11:  ubind .types*0                                               *units: ubind(unit_type);
   12:  jump *label34 notEqual @unit null                            *units: if @unit == null then return null; end;
   13:  set *tmp4 null                                               ...
   14:  jump *label43 always 0 0                                     ...
        label *label34                                               ...
   15:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label36                                               *units: do
   16:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   17:  jump *label37 notEqual *tmp7 0                               ...
   18:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   19:  set *tmp4 @unit                                              *units: return @unit;
   20:  jump *label43 always 0 0                                     ...
        label *label37                                               *units: if @unit.@controlled == 0 then
   21:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
   22:  jump *label38 notEqual *tmp10 1                              ...
   23:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label38                                               *units: elsif first_unit.@dead == 1 then
   24:  ubind .types*0                                               *units: ubind(unit_type);
   25:  jump *label36 notEqual :findFreeUnit.0:first_unit @unit      *units: do
   26:  set *tmp4 null                                               *units: return null;
        label *label43                                               var unit = findFreeUnit(type, 0);
   27:  jump *label44 equal *tmp4 null                               if unit != null then return unit; end;
   28:  set :findUnit*retval *tmp4                                   ...
   29:  jump *label5 always 0 0                                      ...
        label *label44                                               ...
   30:  jump *label6 equal .types*1 :findUnit:currentType            if type == currentType then break; end;
   31:  ubind .types*1                                               *units: ubind(unit_type);
   32:  jump *label52 notEqual @unit null                            *units: if @unit == null then return null; end;
   33:  set *tmp4 null                                               ...
   34:  jump *label61 always 0 0                                     ...
        label *label52                                               ...
   35:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label54                                               *units: do
   36:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   37:  jump *label55 notEqual *tmp7 0                               ...
   38:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   39:  set *tmp4 @unit                                              *units: return @unit;
   40:  jump *label61 always 0 0                                     ...
        label *label55                                               *units: if @unit.@controlled == 0 then
   41:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
   42:  jump *label56 notEqual *tmp10 1                              ...
   43:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label56                                               *units: elsif first_unit.@dead == 1 then
   44:  ubind .types*1                                               *units: ubind(unit_type);
   45:  jump *label54 notEqual :findFreeUnit.0:first_unit @unit      *units: do
   46:  set *tmp4 null                                               *units: return null;
        label *label61                                               var unit = findFreeUnit(type, 0);
   47:  jump *label62 equal *tmp4 null                               if unit != null then return unit; end;
   48:  set :findUnit*retval *tmp4                                   ...
   49:  jump *label5 always 0 0                                      ...
        label *label62                                               ...
   50:  jump *label6 equal .types*2 :findUnit:currentType            if type == currentType then break; end;
   51:  ubind .types*2                                               *units: ubind(unit_type);
   52:  jump *label70 notEqual @unit null                            *units: if @unit == null then return null; end;
   53:  set *tmp4 null                                               ...
   54:  jump *label79 always 0 0                                     ...
        label *label70                                               ...
   55:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label72                                               *units: do
   56:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   57:  jump *label73 notEqual *tmp7 0                               ...
   58:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   59:  set *tmp4 @unit                                              *units: return @unit;
   60:  jump *label79 always 0 0                                     ...
        label *label73                                               *units: if @unit.@controlled == 0 then
   61:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
   62:  jump *label74 notEqual *tmp10 1                              ...
   63:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label74                                               *units: elsif first_unit.@dead == 1 then
   64:  ubind .types*2                                               *units: ubind(unit_type);
   65:  jump *label72 notEqual :findFreeUnit.0:first_unit @unit      *units: do
   66:  set *tmp4 null                                               *units: return null;
        label *label79                                               var unit = findFreeUnit(type, 0);
   67:  jump *label80 equal *tmp4 null                               if unit != null then return unit; end;
   68:  set :findUnit*retval *tmp4                                   ...
   69:  jump *label5 always 0 0                                      ...
        label *label80                                               ...
   70:  jump *label6 equal .types*3 :findUnit:currentType            if type == currentType then break; end;
   71:  ubind .types*3                                               *units: ubind(unit_type);
   72:  jump *label88 notEqual @unit null                            *units: if @unit == null then return null; end;
   73:  set *tmp4 null                                               ...
   74:  jump *label97 always 0 0                                     ...
        label *label88                                               ...
   75:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label90                                               *units: do
   76:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   77:  jump *label91 notEqual *tmp7 0                               ...
   78:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   79:  set *tmp4 @unit                                              *units: return @unit;
   80:  jump *label97 always 0 0                                     ...
        label *label91                                               *units: if @unit.@controlled == 0 then
   81:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
   82:  jump *label92 notEqual *tmp10 1                              ...
   83:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label92                                               *units: elsif first_unit.@dead == 1 then
   84:  ubind .types*3                                               *units: ubind(unit_type);
   85:  jump *label90 notEqual :findFreeUnit.0:first_unit @unit      *units: do
   86:  set *tmp4 null                                               *units: return null;
        label *label97                                               var unit = findFreeUnit(type, 0);
   87:  jump *label98 equal *tmp4 null                               if unit != null then return unit; end;
   88:  set :findUnit*retval *tmp4                                   ...
   89:  jump *label5 always 0 0                                      ...
        label *label98                                               ...
   90:  jump *label6 equal .types*4 :findUnit:currentType            if type == currentType then break; end;
   91:  ubind .types*4                                               *units: ubind(unit_type);
   92:  jump *label106 notEqual @unit null                           *units: if @unit == null then return null; end;
   93:  set *tmp4 null                                               ...
   94:  jump *label115 always 0 0                                    ...
        label *label106                                              ...
   95:  set :findFreeUnit.0:first_unit @unit                         *units: var first_unit = @unit;
        label *label108                                              *units: do
   96:  sensor *tmp7 @unit @controlled                               *units: if @unit.@controlled == 0 then
   97:  jump *label109 notEqual *tmp7 0                              ...
   98:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   99:  set *tmp4 @unit                                              *units: return @unit;
  100:  jump *label115 always 0 0                                    ...
        label *label109                                              *units: if @unit.@controlled == 0 then
  101:  sensor *tmp10 :findFreeUnit.0:first_unit @dead               *units: elsif first_unit.@dead == 1 then
  102:  jump *label110 notEqual *tmp10 1                             ...
  103:  set :findFreeUnit.0:first_unit @unit                         *units: first_unit = @unit;
        label *label110                                              *units: elsif first_unit.@dead == 1 then
  104:  ubind .types*4                                               *units: ubind(unit_type);
  105:  jump *label108 notEqual :findFreeUnit.0:first_unit @unit     *units: do
  106:  set *tmp4 null                                               *units: return null;
        label *label115                                              var unit = findFreeUnit(type, 0);
  107:  jump *label6 equal *tmp4 null                                if unit != null then return unit; end;
  108:  set :findUnit*retval *tmp4                                   ...
        label *label5                                                remote def findUnit(currentUnit)
  109:  write :findUnit*retval *mainProcessor ":findUnit*retval"     ...
  110:  write true *mainProcessor ":findUnit*finished"               ...
  111:  jump *label4 always 0 0                                      ...


Performance: parsed in 159 ms, compiled in 247 ms, optimized in 169 ms, run in 10 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (8 steps):
The program didn't generate any output.
Execution exception at instruction 7: wait 1e12:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
