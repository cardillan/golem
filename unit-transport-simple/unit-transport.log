   138 instructions before optimizations.
     7 instructions eliminated by Temp Variables Elimination (2 passes, 5 iterations).
     8 instructions eliminated by Dead Code Elimination (4 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
    12 instructions eliminated by Condition Optimization (5 iterations).
     6 instructions eliminated by Single Step Elimination (5 iterations).
     3 instructions eliminated by Boolean Optimization (5 iterations).
       1 fully-evaluated expressions optimized using selects.
     7 instructions eliminated by Data Flow Optimization (3 passes, 12 iterations).
     1 loops improved by Loop Hoisting.
     2 instructions added by Function Inlining (6 iterations).
    10 function calls inlined by Function Inlining.
     3 instructions eliminated by Jump Straightening (5 iterations).
     5 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    92 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 902):
    Inline function 'message' defined at unit-transport.mnd:59:1 size    +3, benefit     2453.5, efficiency    817.833
    Inline function 'checkUnit' defined at unit-transport.mnd:65:1 size    +7, benefit     7500.0, efficiency   1071.429
    Inline function 'moveTo' defined at unit-transport.mnd:72:1  size    +5, benefit      175.0, efficiency     35.000
    Inline function call at unit-transport.mnd:17:5              size    +1, benefit        3.5, efficiency      3.500
    Inline function call at unit-transport.mnd:86:5              size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:87:5              size    +6, benefit       87.5, efficiency     14.583
  * Inline function call at unit-transport.mnd:91:9              size    +1, benefit     2187.5, efficiency   2187.500 (-1 instructions)
    Inline function call at unit-transport.mnd:99:9              size    +4, benefit     1875.0, efficiency    468.750
    Inline function call at unit-transport.mnd:102:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:103:5             size    +6, benefit       87.5, efficiency     14.583
    Inline function call at unit-transport.mnd:107:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:110:9             size    +4, benefit     1875.0, efficiency    468.750
    Inline function call at unit-transport.mnd:77:9              size    +4, benefit     3750.0, efficiency    937.500

Pass 1: speed optimization selection (cost limit 903):
    Inline function 'message' defined at unit-transport.mnd:59:1 size    +2, benefit      266.0, efficiency    133.000
  * Inline function 'checkUnit' defined at unit-transport.mnd:65:1 size    +7, benefit     7500.0, efficiency   1071.429 (+2 instructions)
    Inline function 'moveTo' defined at unit-transport.mnd:72:1  size    +5, benefit      175.0, efficiency     35.000
    Inline function call at unit-transport.mnd:17:5              size    +1, benefit        3.5, efficiency      3.500
    Inline function call at unit-transport.mnd:86:5              size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:87:5              size    +6, benefit       87.5, efficiency     14.583
    Inline function call at unit-transport.mnd:99:9              size    +4, benefit     1875.0, efficiency    468.750
    Inline function call at unit-transport.mnd:102:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:103:5             size    +6, benefit       87.5, efficiency     14.583
    Inline function call at unit-transport.mnd:107:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:110:9             size    +4, benefit     1875.0, efficiency    468.750
    Inline function call at unit-transport.mnd:77:9              size    +4, benefit     3750.0, efficiency    937.500

Pass 1: speed optimization selection (cost limit 901):
  * Inline function 'message' defined at unit-transport.mnd:59:1 size    +2, benefit      266.0, efficiency    133.000 (-8 instructions)
    Inline function 'moveTo' defined at unit-transport.mnd:72:1  size    +8, benefit      175.0, efficiency     21.875
    Inline function call at unit-transport.mnd:17:5              size    +1, benefit        3.5, efficiency      3.500
    Inline function call at unit-transport.mnd:86:5              size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:87:5              size    +9, benefit       87.5, efficiency      9.722
    Inline function call at unit-transport.mnd:102:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:103:5             size    +9, benefit       87.5, efficiency      9.722
    Inline function call at unit-transport.mnd:107:5             size    +1, benefit       87.5, efficiency     87.500

Pass 1: speed optimization selection (cost limit 909):
  * Inline function 'moveTo' defined at unit-transport.mnd:72:1  size    +8, benefit      175.0, efficiency     21.875 (+2 instructions)
    Inline function call at unit-transport.mnd:87:5              size    +9, benefit       87.5, efficiency      9.722
    Inline function call at unit-transport.mnd:103:5             size    +9, benefit       87.5, efficiency      9.722

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-8 instructions):
 
    61 jump *label25 always
    62 label *label25
    63 ucontrol itemDrop @air :moveItems:capacity
-    * set *tmp19 null
    64 jump *label24 always
    65 label *label23
-    * set *tmp19 null
    66 label *label24
    67 ucontrol itemTake .core :moveItems:item :moveItems:capacity
    68 setaddr :checkUnit*retaddr *label27 (h:*label27)
 
   127 ucontrol unbind
   128 ubind :unit.1
   129 ucontrol flag 1764335678894
-    * set *tmp36 null
   130 jump *label40 always
   131 label *label39
-    * set *tmp36 null
   132 label *label40
   133 write @unit processor1 ":findUnit:currentUnit"
   134 write false processor1 ":findUnit*finished"
   135 write 1 processor1 "@counter"
-    * set *tmp27 null
   136 jump *label37 always
   137 label *label36
-    * set *tmp27 null
   138 label *label37
   139 label *label12
   140 jump *label11 always
 
   156 jump *label46 always
   157 label *label48
   158 end
-    * set *tmp41 null
   159 jump *label47 always
   160 label *label46
-    * set *tmp41 null
   161 label *label47
   162 label *label45
   163 return :checkUnit*retaddr

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-7 instructions):
 
    12 wait 1e-15
    13 read *tmp3 processor1 ":findUnit*finished"
    14 jump *label10 equal *tmp3 false
-    * read *tmp4 processor1 ":findUnit*retval"
-    * set :unit *tmp4
+   15 read :unit processor1 ":findUnit*retval"
    16 ubind :unit
    17 ucontrol flag 1764335678894
-    * ulocate building core false @copper *tmp6 *tmp7 *tmp8 *tmp5
-    * set .core *tmp5
+   18 ulocate building core false @copper *tmp6 *tmp7 *tmp8 .core
    19 label *label8
    20 op equal *tmp9 .core null
    21 jump *label7 notEqual *tmp9 false
 
    25 write 1 processor1 "@counter"
    26 label *label11
    27 jump *label13 equal true false
-    * sensor *tmp11 @unit @itemCapacity
-    * set :moveItems:capacity *tmp11
+   28 sensor :moveItems:capacity @unit @itemCapacity
    29 set :message:text "Moving to core"
    30 setaddr :message*retaddr *label15 (h:*label15)
    31 call *label2 *invalid :message*retval (m:*label15) (h:*label15)
 
    35 call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
    36 label *label16
    37 label *label17
-    * sensor *tmp12 sorter1 @config
-    * set :moveItems:item *tmp12
+   38 sensor :moveItems:item sorter1 @config
    39 op equal *tmp13 :moveItems:item null
    40 jump *label20 equal *tmp13 false
    41 set *tmp14 "Please select item to transport"
 
   103 wait 1e-15
   104 read *tmp28 processor1 ":findUnit*finished"
   105 jump *label38 equal *tmp28 false
-    * read *tmp29 processor1 ":findUnit*retval"
-    * set :unit.1 *tmp29
+  106 read :unit.1 processor1 ":findUnit*retval"
   107 sensor *tmp30 :unit.1 @dead
   108 op equal *tmp31 *tmp30 false
   109 jump *label39 equal *tmp31 false
 
   158 return :checkUnit*retaddr
   159 end
   160 label *label4
-    * sensor *tmp42 :moveTo:building @x
-    * set :moveTo:x *tmp42
-    * sensor *tmp43 :moveTo:building @y
-    * set :moveTo:y *tmp43
+  161 sensor :moveTo:x :moveTo:building @x
+  162 sensor :moveTo:y :moveTo:building @y
   163 label *label51
   164 ucontrol approach :moveTo:x :moveTo:y 5
   165 setaddr :checkUnit*retaddr *label54 (h:*label54)

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    24 write false processor1 ":findUnit*finished"
    25 write 1 processor1 "@counter"
    26 label *label11
-    * jump *label13 equal true false
    27 sensor :moveItems:capacity @unit @itemCapacity
    28 set :message:text "Moving to core"
    29 setaddr :message*retaddr *label15 (h:*label15)

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
    92 label *label35
    93 sensor *tmp24 @unit @totalItems
    94 op greaterThan *tmp25 *tmp24 0
-    * jump *label33 equal *tmp25 false
-    * jump *label31 always
+   95 jump *label31 notEqual *tmp25 false
    96 label *label33
    97 label *label14
    98 read *tmp26 processor1 ":findUnit*finished"
 
   112 label *label43
   113 sensor *tmp34 :unit.1 @controlled
   114 op equal *tmp35 *tmp34 false
-    * jump *label41 notEqual *tmp35 false
-    * jump *label39 always
+  115 jump *label39 equal *tmp35 false
   116 jump *label41 always
   117 label *label41
   118 ucontrol flag null
 
   144 label *label49
   145 sensor *tmp39 @unit @controller
   146 op notEqual *tmp40 *tmp39 @this
-    * jump *label48 notEqual *tmp40 false
-    * jump *label46 always
+  147 jump *label46 equal *tmp40 false
   148 label *label48
   149 end
   150 jump *label47 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-12 instructions):
 
    17 ucontrol flag 1764335678894
    18 ulocate building core false @copper *tmp6 *tmp7 *tmp8 .core
    19 label *label8
-    * op equal *tmp9 .core null
-    * jump *label7 notEqual *tmp9 false
+   20 jump *label7 equal .core null
    21 label *label9
    22 write @unit processor1 ":findUnit:currentUnit"
    23 write false processor1 ":findUnit*finished"
 
    34 label *label16
    35 label *label17
    36 sensor :moveItems:item sorter1 @config
-    * op equal *tmp13 :moveItems:item null
-    * jump *label20 equal *tmp13 false
+   37 jump *label20 notEqual :moveItems:item null
    38 set *tmp14 "Please select item to transport"
    39 jump *label21 always
    40 label *label20
 
    45 call *label2 *invalid :message*retval (m:*label22) (h:*label22)
    46 label *label22
    47 sensor *tmp15 @unit @firstItem
-    * op notEqual *tmp16 *tmp15 null
-    * jump *label23 equal *tmp16 false
+   48 jump *label23 equal *tmp15 null
    49 label *label26
    50 sensor *tmp17 @unit @firstItem
-    * op notEqual *tmp18 *tmp17 :moveItems:item
-    * jump *label23 equal *tmp18 false
+   51 jump *label23 equal *tmp17 :moveItems:item
    52 jump *label25 always
    53 label *label25
    54 ucontrol itemDrop @air :moveItems:capacity
 
    61 label *label27
    62 label *label18
    63 sensor *tmp20 @unit @totalItems
-    * op notEqual *tmp21 *tmp20 :moveItems:capacity
-    * jump *label17 notEqual *tmp21 false
+   64 jump *label17 notEqual *tmp20 :moveItems:capacity
    65 label *label19
    66 set :message:text "Moving to vault"
    67 setaddr :message*retaddr *label28 (h:*label28)
 
    82 label *label34
    83 label *label32
    84 sensor *tmp22 sorter1 @config
-    * op equal *tmp23 :moveItems:item *tmp22
-    * jump *label33 equal *tmp23 false
+   85 jump *label33 notEqual :moveItems:item *tmp22
    86 label *label35
    87 sensor *tmp24 @unit @totalItems
-    * op greaterThan *tmp25 *tmp24 0
-    * jump *label31 notEqual *tmp25 false
+   88 jump *label31 greaterThan *tmp24 0
    89 label *label33
    90 label *label14
    91 read *tmp26 processor1 ":findUnit*finished"
 
    96 jump *label38 equal *tmp28 false
    97 read :unit.1 processor1 ":findUnit*retval"
    98 sensor *tmp30 :unit.1 @dead
-    * op equal *tmp31 *tmp30 false
-    * jump *label39 equal *tmp31 false
+   99 jump *label39 notEqual *tmp30 false
   100 label *label42
   101 sensor *tmp32 :unit.1 @controller
-    * op equal *tmp33 *tmp32 processor1
-    * jump *label41 notEqual *tmp33 false
+  102 jump *label41 equal *tmp32 processor1
   103 label *label43
   104 sensor *tmp34 :unit.1 @controlled
-    * op equal *tmp35 *tmp34 false
-    * jump *label39 equal *tmp35 false
+  105 jump *label39 notEqual *tmp34 false
   106 jump *label41 always
   107 label *label41
   108 ucontrol flag null
 
   133 jump *label48 notEqual *tmp38 false
   134 label *label49
   135 sensor *tmp39 @unit @controller
-    * op notEqual *tmp40 *tmp39 @this
-    * jump *label46 equal *tmp40 false
+  136 jump *label46 equal *tmp39 @this
   137 label *label48
   138 end
   139 jump *label47 always
 
   152 label *label54
   153 label *label52
   154 ucontrol within :moveTo:x :moveTo:y 5 *tmp44
-    * op equal *tmp45 *tmp44 false
-    * jump *label51 notEqual *tmp45 false
+  155 jump *label51 equal *tmp44 false
   156 label *label53
   157 label *label50
   158 return :moveTo*retaddr

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-6 instructions):
 
    49 label *label26
    50 sensor *tmp17 @unit @firstItem
    51 jump *label23 equal *tmp17 :moveItems:item
-    * jump *label25 always
    52 label *label25
    53 ucontrol itemDrop @air :moveItems:capacity
-    * jump *label24 always
    54 label *label23
    55 label *label24
    56 ucontrol itemTake .core :moveItems:item :moveItems:capacity
 
   101 label *label43
   102 sensor *tmp34 :unit.1 @controlled
   103 jump *label39 notEqual *tmp34 false
-    * jump *label41 always
   104 label *label41
   105 ucontrol flag null
   106 ucontrol unbind
   107 ubind :unit.1
   108 ucontrol flag 1764335678894
-    * jump *label40 always
   109 label *label39
   110 label *label40
   111 write @unit processor1 ":findUnit:currentUnit"
   112 write false processor1 ":findUnit*finished"
   113 write 1 processor1 "@counter"
-    * jump *label37 always
   114 label *label36
   115 label *label37
   116 label *label12
 
   131 jump *label46 equal *tmp39 @this
   132 label *label48
   133 end
-    * jump *label47 always
   134 label *label46
   135 label *label47
   136 label *label45

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    32 setaddr :moveTo*retaddr *label16 (h:*label16)
    33 call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
    34 label *label16
+   35 setaddr :message*retaddr *label22 (h:*label22)
    36 label *label17
    37 sensor :moveItems:item sorter1 @config
    38 jump *label20 notEqual :moveItems:item null
 
    42 set *tmp14 "Taking items"
    43 label *label21
    44 set :message:text *tmp14
-    * setaddr :message*retaddr *label22 (h:*label22)
    45 call *label2 *invalid :message*retval (m:*label22) (h:*label22)
    46 label *label22
    47 sensor *tmp15 @unit @firstItem

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-3 instructions):
 
    35 setaddr :message*retaddr *label22 (h:*label22)
    36 label *label17
    37 sensor :moveItems:item sorter1 @config
-    * jump *label20 notEqual :moveItems:item null
-    * set *tmp14 "Please select item to transport"
-    * jump *label21 always
-    * label *label20
-    * set *tmp14 "Taking items"
-    * label *label21
+   38 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
    39 set :message:text *tmp14
    40 call *label2 *invalid :message*retval (m:*label22) (h:*label22)
    41 label *label22
    42 sensor *tmp15 @unit @firstItem
    43 jump *label23 equal *tmp15 null
-    * label *label26
    44 sensor *tmp17 @unit @firstItem
    45 jump *label23 equal *tmp17 :moveItems:item
-    * label *label25
    46 ucontrol itemDrop @air :moveItems:capacity
    47 label *label23
    48 label *label24
 
    87 read :unit.1 processor1 ":findUnit*retval"
    88 sensor *tmp30 :unit.1 @dead
    89 jump *label39 notEqual *tmp30 false
-    * label *label42
    90 sensor *tmp32 :unit.1 @controller
    91 jump *label41 equal *tmp32 processor1
-    * label *label43
    92 sensor *tmp34 :unit.1 @controlled
    93 jump *label39 notEqual *tmp34 false
    94 label *label41
 
   116 label *label3
   117 sensor *tmp38 @unit @dead
   118 jump *label48 notEqual *tmp38 false
-    * label *label49
   119 sensor *tmp39 @unit @controller
   120 jump *label46 equal *tmp39 @this
   121 label *label48

Modifications by Inline function call at unit-transport.mnd:91:9:
 
    32 setaddr :moveTo*retaddr *label16 (h:*label16)
    33 call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
    34 label *label16
-    * setaddr :message*retaddr *label22 (h:*label22)
    35 label *label17
    36 sensor :moveItems:item sorter1 @config
    37 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
    38 set :message:text *tmp14
-    * call *label2 *invalid :message*retval (m:*label22) (h:*label22)
-    * label *label22
+   39 label *label55
+   40 print :message:text
+   41 printflush message1
+   42 label *label56
    43 sensor *tmp15 @unit @firstItem
    44 jump *label23 equal *tmp15 null
    45 sensor *tmp17 @unit @firstItem

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    37 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
    38 set :message:text *tmp14
    39 label *label55
-    * print :message:text
+   40 print *tmp14
    41 printflush message1
    42 label *label56
    43 sensor *tmp15 @unit @firstItem

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    35 label *label17
    36 sensor :moveItems:item sorter1 @config
    37 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
-    * set :message:text *tmp14
    38 label *label55
    39 print *tmp14
    40 printflush message1

Modifications by Inline function 'checkUnit' defined at unit-transport.mnd:65:1 (+2 instructions):
 
    47 label *label23
    48 label *label24
    49 ucontrol itemTake .core :moveItems:item :moveItems:capacity
-    * setaddr :checkUnit*retaddr *label27 (h:*label27)
-    * call *label3 *invalid :checkUnit*retval (m:*label27) (h:*label27)
-    * label *label27
+   50 label *label57
+   51 sensor *tmp38 @unit @dead
+   52 jump *label58 notEqual *tmp38 false
+   53 sensor *tmp39 @unit @controller
+   54 jump *label59 equal *tmp39 @this
+   55 label *label58
+   56 end
+   57 label *label59
+   58 label *label60
+   59 label *label61
    60 label *label18
    61 sensor *tmp20 @unit @totalItems
    62 jump *label17 notEqual *tmp20 :moveItems:capacity
 
    75 label *label30
    76 label *label31
    77 ucontrol itemDrop vault1 :moveItems:capacity
-    * setaddr :checkUnit*retaddr *label34 (h:*label34)
-    * call *label3 *invalid :checkUnit*retval (m:*label34) (h:*label34)
-    * label *label34
+   78 label *label62
+   79 sensor *tmp38 @unit @dead
+   80 jump *label63 notEqual *tmp38 false
+   81 sensor *tmp39 @unit @controller
+   82 jump *label64 equal *tmp39 @this
+   83 label *label63
+   84 end
+   85 label *label64
+   86 label *label65
+   87 label *label66
    88 label *label32
    89 sensor *tmp22 sorter1 @config
    90 jump *label33 notEqual :moveItems:item *tmp22
 
   127 label *label44
   128 return :message*retaddr
   129 end
-    * label *label3
-    * sensor *tmp38 @unit @dead
-    * jump *label48 notEqual *tmp38 false
-    * sensor *tmp39 @unit @controller
-    * jump *label46 equal *tmp39 @this
-    * label *label48
-    * end
-    * label *label46
-    * label *label47
-    * label *label45
-    * return :checkUnit*retaddr
-    * end
   130 label *label4
   131 sensor :moveTo:x :moveTo:building @x
   132 sensor :moveTo:y :moveTo:building @y
   133 label *label51
   134 ucontrol approach :moveTo:x :moveTo:y 5
-    * setaddr :checkUnit*retaddr *label54 (h:*label54)
-    * call *label3 *invalid :checkUnit*retval (m:*label54) (h:*label54)
-    * label *label54
+  135 label *label67
+  136 sensor *tmp38 @unit @dead
+  137 jump *label68 notEqual *tmp38 false
+  138 sensor *tmp39 @unit @controller
+  139 jump *label69 equal *tmp39 @this
+  140 label *label68
+  141 end
+  142 label *label69
+  143 label *label70
+  144 label *label71
   145 label *label52
   146 ucontrol within :moveTo:x :moveTo:y 5 *tmp44
   147 jump *label51 equal *tmp44 false

Modifications by Inline function 'message' defined at unit-transport.mnd:59:1 (-4 instructions):
 
     1 read *tmp1 processor1 "*signature"
     2 jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"
     3 set :message:text "Initializing..."
-    * setaddr :message*retaddr *label6 (h:*label6)
-    * call *label2 *invalid :message*retval (m:*label6) (h:*label6)
-    * label *label6
+    4 label *label72
+    5 print :message:text
+    6 printflush message1
+    7 label *label73
     8 label *label7
     9 write null processor1 ":findUnit:currentUnit"
    10 write false processor1 ":findUnit*finished"
 
    26 label *label11
    27 sensor :moveItems:capacity @unit @itemCapacity
    28 set :message:text "Moving to core"
-    * setaddr :message*retaddr *label15 (h:*label15)
-    * call *label2 *invalid :message*retval (m:*label15) (h:*label15)
-    * label *label15
+   29 label *label74
+   30 print :message:text
+   31 printflush message1
+   32 label *label75
    33 set :moveTo:building .core
    34 setaddr :moveTo*retaddr *label16 (h:*label16)
    35 call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
 
    64 jump *label17 notEqual *tmp20 :moveItems:capacity
    65 label *label19
    66 set :message:text "Moving to vault"
-    * setaddr :message*retaddr *label28 (h:*label28)
-    * call *label2 *invalid :message*retval (m:*label28) (h:*label28)
-    * label *label28
+   67 label *label76
+   68 print :message:text
+   69 printflush message1
+   70 label *label77
    71 set :moveTo:building vault1
    72 setaddr :moveTo*retaddr *label29 (h:*label29)
    73 call *label4 *invalid :moveTo*retval (m:*label29) (h:*label29)
    74 label *label29
    75 set :message:text "Dropping items"
-    * setaddr :message*retaddr *label30 (h:*label30)
-    * call *label2 *invalid :message*retval (m:*label30) (h:*label30)
-    * label *label30
+   76 label *label78
+   77 print :message:text
+   78 printflush message1
+   79 label *label79
    80 label *label31
    81 ucontrol itemDrop vault1 :moveItems:capacity
    82 label *label62
 
   125 jump *label11 always
   126 label *label13
   127 end
-    * label *label2
-    * print :message:text
-    * printflush message1
-    * label *label44
-    * return :message*retaddr
-    * end
   128 label *label4
   129 sensor :moveTo:x :moveTo:building @x
   130 sensor :moveTo:y :moveTo:building @y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"
     3 set :message:text "Initializing..."
     4 label *label72
-    * print :message:text
+    5 print "Initializing..."
     6 printflush message1
     7 label *label73
     8 label *label7
 
    27 sensor :moveItems:capacity @unit @itemCapacity
    28 set :message:text "Moving to core"
    29 label *label74
-    * print :message:text
+   30 print "Moving to core"
    31 printflush message1
    32 label *label75
    33 set :moveTo:building .core
 
    65 label *label19
    66 set :message:text "Moving to vault"
    67 label *label76
-    * print :message:text
+   68 print "Moving to vault"
    69 printflush message1
    70 label *label77
    71 set :moveTo:building vault1
 
    74 label *label29
    75 set :message:text "Dropping items"
    76 label *label78
-    * print :message:text
+   77 print "Dropping items"
    78 printflush message1
    79 label *label79
    80 label *label31

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
     0 label *label5
     1 read *tmp1 processor1 "*signature"
     2 jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"
-    * set :message:text "Initializing..."
     3 label *label72
     4 print "Initializing..."
     5 printflush message1
 
    24 write 1 processor1 "@counter"
    25 label *label11
    26 sensor :moveItems:capacity @unit @itemCapacity
-    * set :message:text "Moving to core"
    27 label *label74
    28 print "Moving to core"
    29 printflush message1
 
    61 sensor *tmp20 @unit @totalItems
    62 jump *label17 notEqual *tmp20 :moveItems:capacity
    63 label *label19
-    * set :message:text "Moving to vault"
    64 label *label76
    65 print "Moving to vault"
    66 printflush message1
 
    69 setaddr :moveTo*retaddr *label29 (h:*label29)
    70 call *label4 *invalid :moveTo*retval (m:*label29) (h:*label29)
    71 label *label29
-    * set :message:text "Dropping items"
    72 label *label78
    73 print "Dropping items"
    74 printflush message1

Modifications by Inline function 'moveTo' defined at unit-transport.mnd:72:1 (+4 instructions):
 
    29 printflush message1
    30 label *label75
    31 set :moveTo:building .core
-    * setaddr :moveTo*retaddr *label16 (h:*label16)
-    * call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
-    * label *label16
+   32 label *label80
+   33 sensor :moveTo:x :moveTo:building @x
+   34 sensor :moveTo:y :moveTo:building @y
+   35 label *label81
+   36 ucontrol approach :moveTo:x :moveTo:y 5
+   37 label *label82
+   38 sensor *tmp38 @unit @dead
+   39 jump *label83 notEqual *tmp38 false
+   40 sensor *tmp39 @unit @controller
+   41 jump *label84 equal *tmp39 @this
+   42 label *label83
+   43 end
+   44 label *label84
+   45 label *label85
+   46 label *label86
+   47 label *label87
+   48 ucontrol within :moveTo:x :moveTo:y 5 *tmp44
+   49 jump *label81 equal *tmp44 false
+   50 label *label88
+   51 label *label89
    52 label *label17
    53 sensor :moveItems:item sorter1 @config
    54 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
 
    83 printflush message1
    84 label *label77
    85 set :moveTo:building vault1
-    * setaddr :moveTo*retaddr *label29 (h:*label29)
-    * call *label4 *invalid :moveTo*retval (m:*label29) (h:*label29)
-    * label *label29
+   86 label *label90
+   87 sensor :moveTo:x :moveTo:building @x
+   88 sensor :moveTo:y :moveTo:building @y
+   89 label *label91
+   90 ucontrol approach :moveTo:x :moveTo:y 5
+   91 label *label92
+   92 sensor *tmp38 @unit @dead
+   93 jump *label93 notEqual *tmp38 false
+   94 sensor *tmp39 @unit @controller
+   95 jump *label94 equal *tmp39 @this
+   96 label *label93
+   97 end
+   98 label *label94
+   99 label *label95
+  100 label *label96
+  101 label *label97
+  102 ucontrol within :moveTo:x :moveTo:y 5 *tmp44
+  103 jump *label91 equal *tmp44 false
+  104 label *label98
+  105 label *label99
   106 label *label78
   107 print "Dropping items"
   108 printflush message1
 
   155 jump *label11 always
   156 label *label13
   157 end
-    * label *label4
-    * sensor :moveTo:x :moveTo:building @x
-    * sensor :moveTo:y :moveTo:building @y
-    * label *label51
-    * ucontrol approach :moveTo:x :moveTo:y 5
-    * label *label67
-    * sensor *tmp38 @unit @dead
-    * jump *label68 notEqual *tmp38 false
-    * sensor *tmp39 @unit @controller
-    * jump *label69 equal *tmp39 @this
-    * label *label68
-    * end
-    * label *label69
-    * label *label70
-    * label *label71
-    * label *label52
-    * ucontrol within :moveTo:x :moveTo:y 5 *tmp44
-    * jump *label51 equal *tmp44 false
-    * label *label53
-    * label *label50
-    * return :moveTo*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    30 label *label75
    31 set :moveTo:building .core
    32 label *label80
-    * sensor :moveTo:x :moveTo:building @x
-    * sensor :moveTo:y :moveTo:building @y
+   33 sensor :moveTo:x .core @x
+   34 sensor :moveTo:y .core @y
    35 label *label81
    36 ucontrol approach :moveTo:x :moveTo:y 5
    37 label *label82
 
    84 label *label77
    85 set :moveTo:building vault1
    86 label *label90
-    * sensor :moveTo:x :moveTo:building @x
-    * sensor :moveTo:y :moveTo:building @y
+   87 sensor :moveTo:x vault1 @x
+   88 sensor :moveTo:y vault1 @y
    89 label *label91
    90 ucontrol approach :moveTo:x :moveTo:y 5
    91 label *label92

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    28 print "Moving to core"
    29 printflush message1
    30 label *label75
-    * set :moveTo:building .core
    31 label *label80
    32 sensor :moveTo:x .core @x
    33 sensor :moveTo:y .core @y
 
    81 print "Moving to vault"
    82 printflush message1
    83 label *label77
-    * set :moveTo:building vault1
    84 label *label90
    85 sensor :moveTo:x vault1 @x
    86 sensor :moveTo:y vault1 @y

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-1 instructions):
     0 label *label5
     1 read *tmp1 processor1 "*signature"
     2 jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"
-    * label *label72
     3 print "Initializing..."
     4 printflush message1
-    * label *label73
     5 label *label7
     6 write null processor1 ":findUnit:currentUnit"
     7 write false processor1 ":findUnit*finished"
 
    14 ubind :unit
    15 ucontrol flag 1764335678894
    16 ulocate building core false @copper *tmp6 *tmp7 *tmp8 .core
-    * label *label8
    17 jump *label7 equal .core null
-    * label *label9
    18 write @unit processor1 ":findUnit:currentUnit"
    19 write false processor1 ":findUnit*finished"
    20 write 1 processor1 "@counter"
    21 label *label11
    22 sensor :moveItems:capacity @unit @itemCapacity
-    * label *label74
    23 print "Moving to core"
    24 printflush message1
-    * label *label75
-    * label *label80
    25 sensor :moveTo:x .core @x
    26 sensor :moveTo:y .core @y
    27 label *label81
    28 ucontrol approach :moveTo:x :moveTo:y 5
-    * label *label82
    29 sensor *tmp38 @unit @dead
    30 jump *label83 notEqual *tmp38 false
    31 sensor *tmp39 @unit @controller
 
    33 label *label83
    34 end
    35 label *label84
-    * label *label85
-    * label *label86
-    * label *label87
    36 ucontrol within :moveTo:x :moveTo:y 5 *tmp44
    37 jump *label81 equal *tmp44 false
-    * label *label88
-    * label *label89
    38 label *label17
    39 sensor :moveItems:item sorter1 @config
    40 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
-    * label *label55
    41 print *tmp14
    42 printflush message1
-    * label *label56
    43 sensor *tmp15 @unit @firstItem
    44 jump *label23 equal *tmp15 null
    45 sensor *tmp17 @unit @firstItem
    46 jump *label23 equal *tmp17 :moveItems:item
    47 ucontrol itemDrop @air :moveItems:capacity
    48 label *label23
-    * label *label24
    49 ucontrol itemTake .core :moveItems:item :moveItems:capacity
-    * label *label57
    50 sensor *tmp38 @unit @dead
    51 jump *label58 notEqual *tmp38 false
    52 sensor *tmp39 @unit @controller
 
    54 label *label58
    55 end
    56 label *label59
-    * label *label60
-    * label *label61
-    * label *label18
    57 sensor *tmp20 @unit @totalItems
    58 jump *label17 notEqual *tmp20 :moveItems:capacity
-    * label *label19
-    * label *label76
    59 print "Moving to vault"
    60 printflush message1
-    * label *label77
-    * label *label90
    61 sensor :moveTo:x vault1 @x
    62 sensor :moveTo:y vault1 @y
    63 label *label91
    64 ucontrol approach :moveTo:x :moveTo:y 5
-    * label *label92
    65 sensor *tmp38 @unit @dead
    66 jump *label93 notEqual *tmp38 false
    67 sensor *tmp39 @unit @controller
 
    69 label *label93
    70 end
    71 label *label94
-    * label *label95
-    * label *label96
-    * label *label97
    72 ucontrol within :moveTo:x :moveTo:y 5 *tmp44
    73 jump *label91 equal *tmp44 false
-    * label *label98
-    * label *label99
-    * label *label78
    74 print "Dropping items"
    75 printflush message1
-    * label *label79
    76 label *label31
    77 ucontrol itemDrop vault1 :moveItems:capacity
-    * label *label62
    78 sensor *tmp38 @unit @dead
    79 jump *label63 notEqual *tmp38 false
    80 sensor *tmp39 @unit @controller
 
    82 label *label63
    83 end
    84 label *label64
-    * label *label65
-    * label *label66
-    * label *label32
    85 sensor *tmp22 sorter1 @config
    86 jump *label33 notEqual :moveItems:item *tmp22
    87 sensor *tmp24 @unit @totalItems
    88 jump *label31 greaterThan *tmp24 0
    89 label *label33
-    * label *label14
    90 read *tmp26 processor1 ":findUnit*finished"
    91 jump *label36 equal *tmp26 false
    92 label *label38
 
   106 ubind :unit.1
   107 ucontrol flag 1764335678894
   108 label *label39
-    * label *label40
   109 write @unit processor1 ":findUnit:currentUnit"
   110 write false processor1 ":findUnit*finished"
   111 write 1 processor1 "@counter"
   112 label *label36
-    * label *label37
-    * label *label12
   113 jump *label11 always
-    * label *label13
-    * end

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
+    0 label __start__
     1 label *label5
     2 read *tmp1 processor1 "*signature"
     3 jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"
 
    28 label *label81
    29 ucontrol approach :moveTo:x :moveTo:y 5
    30 sensor *tmp38 @unit @dead
-    * jump *label83 notEqual *tmp38 false
+   31 jump __start__ notEqual *tmp38 false
    32 sensor *tmp39 @unit @controller
    33 jump *label84 equal *tmp39 @this
    34 label *label83
 
    49 label *label23
    50 ucontrol itemTake .core :moveItems:item :moveItems:capacity
    51 sensor *tmp38 @unit @dead
-    * jump *label58 notEqual *tmp38 false
+   52 jump __start__ notEqual *tmp38 false
    53 sensor *tmp39 @unit @controller
    54 jump *label59 equal *tmp39 @this
    55 label *label58
 
    64 label *label91
    65 ucontrol approach :moveTo:x :moveTo:y 5
    66 sensor *tmp38 @unit @dead
-    * jump *label93 notEqual *tmp38 false
+   67 jump __start__ notEqual *tmp38 false
    68 sensor *tmp39 @unit @controller
    69 jump *label94 equal *tmp39 @this
    70 label *label93
 
    77 label *label31
    78 ucontrol itemDrop vault1 :moveItems:capacity
    79 sensor *tmp38 @unit @dead
-    * jump *label63 notEqual *tmp38 false
+   80 jump __start__ notEqual *tmp38 false
    81 sensor *tmp39 @unit @controller
    82 jump *label64 equal *tmp39 @this
    83 label *label63
 
    89 jump *label31 greaterThan *tmp24 0
    90 label *label33
    91 read *tmp26 processor1 ":findUnit*finished"
-    * jump *label36 equal *tmp26 false
+   92 jump *label11 equal *tmp26 false
    93 label *label38
    94 wait 1e-15
    95 read *tmp28 processor1 ":findUnit*finished"

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
    14 read :unit processor1 ":findUnit*retval"
    15 ubind :unit
    16 ucontrol flag 1764335678894
-    * ulocate building core false @copper *tmp6 *tmp7 *tmp8 .core
+   17 ulocate building core false @copper 0 0 0 .core
    18 jump *label7 equal .core null
    19 write @unit processor1 ":findUnit:currentUnit"
    20 write false processor1 ":findUnit*finished"

Final code before resolving virtual instructions:

        label __start__
        label *label5                                                unit-transport.mnd: require "unit-monitor.mnd" remote processor1;
    0:  read *tmp1 processor1 "*signature"                           ...
    1:  jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"            ...
    2:  print "Initializing..."                                      unit-transport.mnd: print(text);
    3:  printflush message1                                          unit-transport.mnd: printflush(message1);
        label *label7                                                unit-transport.mnd: do
    4:  write null processor1 ":findUnit:currentUnit"                unit-transport.mnd: var unit = processor1.findUnit(null);
    5:  write false processor1 ":findUnit*finished"                  ...
    6:  write 1 processor1 "@counter"                                ...
        label *label10                                               ...
    7:  wait 1e-15                                                   ...
    8:  read *tmp3 processor1 ":findUnit*finished"                   ...
    9:  jump *label10 equal *tmp3 false                              ...
   10:  read :unit processor1 ":findUnit*retval"                     ...
   11:  ubind :unit                                                  unit-transport.mnd: ubind(unit);
   12:  ucontrol flag 1764335678894 0 0 0 0                          unit-transport.mnd: flag(FLAG);
   13:  ulocate building core false @copper 0 0 0 .core              unit-transport.mnd: core = ulocate(:building, :core, false);
   14:  jump *label7 equal .core null                                unit-transport.mnd: do
   15:  write @unit processor1 ":findUnit:currentUnit"               unit-transport.mnd: async(processor1.findUnit(@unit));
   16:  write false processor1 ":findUnit*finished"                  ...
   17:  write 1 processor1 "@counter"                                ...
        label *label11                                               unit-transport.mnd: while true do
   18:  sensor :moveItems:capacity @unit @itemCapacity               unit-transport.mnd: var capacity = @unit.@itemCapacity;
   19:  print "Moving to core"                                       unit-transport.mnd: print(text);
   20:  printflush message1                                          unit-transport.mnd: printflush(message1);
   21:  sensor :moveTo:x .core @x                                    unit-transport.mnd: var x = building.@x;
   22:  sensor :moveTo:y .core @y                                    unit-transport.mnd: var y = building.@y;
        label *label81                                               unit-transport.mnd: do
   23:  ucontrol approach :moveTo:x :moveTo:y 5 0 0                  unit-transport.mnd: approach(x, y, 5);
   24:  sensor *tmp38 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   25:  jump __start__ notEqual *tmp38 false                         ...
   26:  sensor *tmp39 @unit @controller                              ...
   27:  jump *label84 equal *tmp39 @this                             ...
   28:  end                                                          unit-transport.mnd: end();
        label *label84                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   29:  ucontrol within :moveTo:x :moveTo:y 5 *tmp44 0               unit-transport.mnd: while !within(x, y, 5);
   30:  jump *label81 equal *tmp44 false                             unit-transport.mnd: do
        label *label17                                               unit-transport.mnd: do
   31:  sensor :moveItems:item sorter1 @config                       unit-transport.mnd: item = sorter1.@config;
   32:  select *tmp14 equal :moveItems:item null "Please select item unit-transport.mnd: message(item == null ? "Please select item to transport" : "Taking items");
   33:  print *tmp14                                                 unit-transport.mnd: print(text);
   34:  printflush message1                                          unit-transport.mnd: printflush(message1);
   35:  sensor *tmp15 @unit @firstItem                               unit-transport.mnd: if @unit.@firstItem != null and @unit.@firstItem != item then
   36:  jump *label23 equal *tmp15 null                              ...
   37:  sensor *tmp17 @unit @firstItem                               ...
   38:  jump *label23 equal *tmp17 :moveItems:item                   ...
   39:  ucontrol itemDrop @air :moveItems:capacity 0 0 0             unit-transport.mnd: itemDrop(@air, capacity);
        label *label23                                               unit-transport.mnd: if @unit.@firstItem != null and @unit.@firstItem != item then
   40:  ucontrol itemTake .core :moveItems:item :moveItems:capacity  unit-transport.mnd: itemTake(core, item, capacity);
   41:  sensor *tmp38 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   42:  jump __start__ notEqual *tmp38 false                         ...
   43:  sensor *tmp39 @unit @controller                              ...
   44:  jump *label59 equal *tmp39 @this                             ...
   45:  end                                                          unit-transport.mnd: end();
        label *label59                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   46:  sensor *tmp20 @unit @totalItems                              unit-transport.mnd: while @unit.@totalItems != capacity;
   47:  jump *label17 notEqual *tmp20 :moveItems:capacity            unit-transport.mnd: do
   48:  print "Moving to vault"                                      unit-transport.mnd: print(text);
   49:  printflush message1                                          unit-transport.mnd: printflush(message1);
   50:  sensor :moveTo:x vault1 @x                                   unit-transport.mnd: var x = building.@x;
   51:  sensor :moveTo:y vault1 @y                                   unit-transport.mnd: var y = building.@y;
        label *label91                                               unit-transport.mnd: do
   52:  ucontrol approach :moveTo:x :moveTo:y 5 0 0                  unit-transport.mnd: approach(x, y, 5);
   53:  sensor *tmp38 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   54:  jump __start__ notEqual *tmp38 false                         ...
   55:  sensor *tmp39 @unit @controller                              ...
   56:  jump *label94 equal *tmp39 @this                             ...
   57:  end                                                          unit-transport.mnd: end();
        label *label94                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   58:  ucontrol within :moveTo:x :moveTo:y 5 *tmp44 0               unit-transport.mnd: while !within(x, y, 5);
   59:  jump *label91 equal *tmp44 false                             unit-transport.mnd: do
   60:  print "Dropping items"                                       unit-transport.mnd: print(text);
   61:  printflush message1                                          unit-transport.mnd: printflush(message1);
        label *label31                                               unit-transport.mnd: do
   62:  ucontrol itemDrop vault1 :moveItems:capacity 0 0 0           unit-transport.mnd: itemDrop(storage, capacity);
   63:  sensor *tmp38 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   64:  jump __start__ notEqual *tmp38 false                         ...
   65:  sensor *tmp39 @unit @controller                              ...
   66:  jump *label64 equal *tmp39 @this                             ...
   67:  end                                                          unit-transport.mnd: end();
        label *label64                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   68:  sensor *tmp22 sorter1 @config                                unit-transport.mnd: while item == sorter1.@config and @unit.@totalItems > 0;
   69:  jump *label33 notEqual :moveItems:item *tmp22                ...
   70:  sensor *tmp24 @unit @totalItems                              ...
   71:  jump *label31 greaterThan *tmp24 0                           ...
        label *label33                                               unit-transport.mnd: do
   72:  read *tmp26 processor1 ":findUnit*finished"                  unit-transport.mnd: if finished(processor1.findUnit) then
   73:  jump *label11 equal *tmp26 false                             ...
        label *label38                                               unit-transport.mnd: var unit = await(processor1.findUnit);
   74:  wait 1e-15                                                   ...
   75:  read *tmp28 processor1 ":findUnit*finished"                  ...
   76:  jump *label38 equal *tmp28 false                             ...
   77:  read :unit.1 processor1 ":findUnit*retval"                   ...
   78:  sensor *tmp30 :unit.1 @dead                                  unit-transport.mnd: if !unit.@dead and (unit.@controller == processor1 or !unit.@controlled) then
   79:  jump *label39 notEqual *tmp30 false                          ...
   80:  sensor *tmp32 :unit.1 @controller                            ...
   81:  jump *label41 equal *tmp32 processor1                        ...
   82:  sensor *tmp34 :unit.1 @controlled                            ...
   83:  jump *label39 notEqual *tmp34 false                          ...
        label *label41                                               ...
   84:  ucontrol flag null 0 0 0 0                                   unit-transport.mnd: flag(null);
   85:  ucontrol unbind 0 0 0 0 0                                    unit-transport.mnd: unbind();
   86:  ubind :unit.1                                                unit-transport.mnd: ubind(unit);
   87:  ucontrol flag 1764335678894 0 0 0 0                          unit-transport.mnd: flag(FLAG);
        label *label39                                               unit-transport.mnd: if !unit.@dead and (unit.@controller == processor1 or !unit.@controlled) then
   88:  write @unit processor1 ":findUnit:currentUnit"               unit-transport.mnd: async(processor1.findUnit(@unit));
   89:  write false processor1 ":findUnit*finished"                  ...
   90:  write 1 processor1 "@counter"                                ...
   91:  jump *label11 always 0 0                                     unit-transport.mnd: while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    37     1x     37,0  <no function>
    20     4x      5,0  void checkUnit()
    16     1x     16,0  void moveItems()
    10     5x      2,0  void message(in text)
    10     2x      5,0  void moveTo(in building)

Performance: parsed in 225 ms, compiled in 250 ms, optimized in 267 ms, run in 3 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (1 steps):
The program didn't generate any output.
Execution exception at instruction 0: read *tmp1 processor1 "*signature":
Variable 'processor1' is not an object.
(Use the '#set err-not-an-object = false;' directive or the '--err-not-an-object false' command line option to ignore this exception.)
