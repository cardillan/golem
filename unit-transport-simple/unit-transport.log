   133 instructions before optimizations.
     7 instructions eliminated by Temp Variables Elimination (2 passes, 5 iterations).
     8 instructions eliminated by Dead Code Elimination (4 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     4 instructions eliminated by Jump Optimization (4 iterations).
     4 instructions eliminated by Single Step Elimination (5 iterations).
     3 instructions eliminated by If Expression Optimization (3 iterations).
     7 instructions eliminated by Data Flow Optimization (3 passes, 12 iterations).
     1 loops improved by Loop Hoisting.
     5 instructions added by Function Inlining (6 iterations).
    10 function calls inlined by Function Inlining.
     1 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
   103 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 894):
    Inline function 'message' defined at unit-transport.mnd:59:1 size    +3, benefit     2453.5, efficiency    817.833
    Inline function 'checkUnit' defined at unit-transport.mnd:65:1 size    +9, benefit     7500.0, efficiency    833.333
    Inline function 'moveTo' defined at unit-transport.mnd:72:1  size    +5, benefit      175.0, efficiency     35.000
    Inline function call at unit-transport.mnd:17:5              size    +1, benefit        3.5, efficiency      3.500
    Inline function call at unit-transport.mnd:86:5              size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:87:5              size    +6, benefit       87.5, efficiency     14.583
  * Inline function call at unit-transport.mnd:91:9              size    +1, benefit     2187.5, efficiency   2187.500 (-1 instructions)
    Inline function call at unit-transport.mnd:99:9              size    +5, benefit     1875.0, efficiency    375.000
    Inline function call at unit-transport.mnd:102:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:103:5             size    +6, benefit       87.5, efficiency     14.583
    Inline function call at unit-transport.mnd:107:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:110:9             size    +5, benefit     1875.0, efficiency    375.000
    Inline function call at unit-transport.mnd:77:9              size    +5, benefit     3750.0, efficiency    750.000

Pass 1: speed optimization selection (cost limit 895):
    Inline function 'message' defined at unit-transport.mnd:59:1 size    +2, benefit      266.0, efficiency    133.000
  * Inline function 'checkUnit' defined at unit-transport.mnd:65:1 size    +9, benefit     7500.0, efficiency    833.333 (+4 instructions)
    Inline function 'moveTo' defined at unit-transport.mnd:72:1  size    +5, benefit      175.0, efficiency     35.000
    Inline function call at unit-transport.mnd:17:5              size    +1, benefit        3.5, efficiency      3.500
    Inline function call at unit-transport.mnd:86:5              size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:87:5              size    +6, benefit       87.5, efficiency     14.583
    Inline function call at unit-transport.mnd:99:9              size    +5, benefit     1875.0, efficiency    375.000
    Inline function call at unit-transport.mnd:102:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:103:5             size    +6, benefit       87.5, efficiency     14.583
    Inline function call at unit-transport.mnd:107:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:110:9             size    +5, benefit     1875.0, efficiency    375.000
    Inline function call at unit-transport.mnd:77:9              size    +5, benefit     3750.0, efficiency    750.000

Pass 1: speed optimization selection (cost limit 891):
  * Inline function 'message' defined at unit-transport.mnd:59:1 size    +2, benefit      266.0, efficiency    133.000 (-8 instructions)
    Inline function 'moveTo' defined at unit-transport.mnd:72:1  size    +9, benefit      175.0, efficiency     19.444
    Inline function call at unit-transport.mnd:17:5              size    +1, benefit        3.5, efficiency      3.500
    Inline function call at unit-transport.mnd:86:5              size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:87:5              size   +10, benefit       87.5, efficiency      8.750
    Inline function call at unit-transport.mnd:102:5             size    +1, benefit       87.5, efficiency     87.500
    Inline function call at unit-transport.mnd:103:5             size   +10, benefit       87.5, efficiency      8.750
    Inline function call at unit-transport.mnd:107:5             size    +1, benefit       87.5, efficiency     87.500

Pass 1: speed optimization selection (cost limit 899):
  * Inline function 'moveTo' defined at unit-transport.mnd:72:1  size    +9, benefit      175.0, efficiency     19.444 (+3 instructions)
    Inline function call at unit-transport.mnd:87:5              size   +10, benefit       87.5, efficiency      8.750
    Inline function call at unit-transport.mnd:103:5             size   +10, benefit       87.5, efficiency      8.750

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-8 instructions):
 
    58 op land *tmp19 *tmp16 *tmp18
    59 jump *label23 equal *tmp19 false
    60 ucontrol itemDrop @air :moveItems:capacity
-    * set *tmp20 null
    61 jump *label24 always
    62 label *label23
-    * set *tmp20 null
    63 label *label24
    64 ucontrol itemTake .core :moveItems:item :moveItems:capacity
    65 setaddr :checkUnit*retaddr *label25 (h:*label25)
 
   117 ucontrol unbind
   118 ubind :unit.1
   119 ucontrol flag 1764335678894
-    * set *tmp40 null
   120 jump *label37 always
   121 label *label36
-    * set *tmp40 null
   122 label *label37
   123 write @unit processor1 ":findUnit:currentUnit"
   124 write false processor1 ":findUnit*finished"
   125 write 1 processor1 "@counter"
-    * set *tmp29 null
   126 jump *label34 always
   127 label *label33
-    * set *tmp29 null
   128 label *label34
   129 label *label12
   130 jump *label11 always
 
   143 op or *tmp45 *tmp42 *tmp44
   144 jump *label40 equal *tmp45 false
   145 end
-    * set *tmp46 null
   146 jump *label41 always
   147 label *label40
-    * set *tmp46 null
   148 label *label41
   149 label *label39
   150 return :checkUnit*retaddr

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-7 instructions):
 
    12 wait 1e-15
    13 read *tmp3 processor1 ":findUnit*finished"
    14 jump *label10 equal *tmp3 false
-    * read *tmp4 processor1 ":findUnit*retval"
-    * set :unit *tmp4
+   15 read :unit processor1 ":findUnit*retval"
    16 ubind :unit
    17 ucontrol flag 1764335678894
-    * ulocate building core false @copper *tmp6 *tmp7 *tmp8 *tmp5
-    * set .core *tmp5
+   18 ulocate building core false @copper *tmp6 *tmp7 *tmp8 .core
    19 label *label8
    20 op equal *tmp9 .core null
    21 jump *label7 notEqual *tmp9 false
 
    25 write 1 processor1 "@counter"
    26 label *label11
    27 jump *label13 equal true false
-    * sensor *tmp11 @unit @itemCapacity
-    * set :moveItems:capacity *tmp11
+   28 sensor :moveItems:capacity @unit @itemCapacity
    29 set :message:text "Moving to core"
    30 setaddr :message*retaddr *label15 (h:*label15)
    31 call *label2 *invalid :message*retval (m:*label15) (h:*label15)
 
    35 call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
    36 label *label16
    37 label *label17
-    * sensor *tmp12 sorter1 @config
-    * set :moveItems:item *tmp12
+   38 sensor :moveItems:item sorter1 @config
    39 op equal *tmp13 :moveItems:item null
    40 jump *label20 equal *tmp13 false
    41 set *tmp14 "Please select item to transport"
 
    98 wait 1e-15
    99 read *tmp30 processor1 ":findUnit*finished"
   100 jump *label35 equal *tmp30 false
-    * read *tmp31 processor1 ":findUnit*retval"
-    * set :unit.1 *tmp31
+  101 read :unit.1 processor1 ":findUnit*retval"
   102 sensor *tmp32 :unit.1 @dead
   103 op equal *tmp33 *tmp32 false
   104 sensor *tmp34 :unit.1 @controller
 
   145 return :checkUnit*retaddr
   146 end
   147 label *label4
-    * sensor *tmp47 :moveTo:building @x
-    * set :moveTo:x *tmp47
-    * sensor *tmp48 :moveTo:building @y
-    * set :moveTo:y *tmp48
+  148 sensor :moveTo:x :moveTo:building @x
+  149 sensor :moveTo:y :moveTo:building @y
   150 label *label43
   151 ucontrol approach :moveTo:x :moveTo:y 5
   152 setaddr :checkUnit*retaddr *label46 (h:*label46)

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    24 write false processor1 ":findUnit*finished"
    25 write 1 processor1 "@counter"
    26 label *label11
-    * jump *label13 equal true false
    27 sensor :moveItems:capacity @unit @itemCapacity
    28 set :message:text "Moving to core"
    29 setaddr :message*retaddr *label15 (h:*label15)

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-4 instructions):
 
    17 ucontrol flag 1764335678894
    18 ulocate building core false @copper *tmp6 *tmp7 *tmp8 .core
    19 label *label8
-    * op equal *tmp9 .core null
-    * jump *label7 notEqual *tmp9 false
+   20 jump *label7 equal .core null
    21 label *label9
    22 write @unit processor1 ":findUnit:currentUnit"
    23 write false processor1 ":findUnit*finished"
 
    34 label *label16
    35 label *label17
    36 sensor :moveItems:item sorter1 @config
-    * op equal *tmp13 :moveItems:item null
-    * jump *label20 equal *tmp13 false
+   37 jump *label20 notEqual :moveItems:item null
    38 set *tmp14 "Please select item to transport"
    39 jump *label21 always
    40 label *label20
 
    60 label *label25
    61 label *label18
    62 sensor *tmp21 @unit @totalItems
-    * op notEqual *tmp22 *tmp21 :moveItems:capacity
-    * jump *label17 notEqual *tmp22 false
+   63 jump *label17 notEqual *tmp21 :moveItems:capacity
    64 label *label19
    65 set :message:text "Moving to vault"
    66 setaddr :message*retaddr *label26 (h:*label26)
 
   150 label *label46
   151 label *label44
   152 ucontrol within :moveTo:x :moveTo:y 5 *tmp49
-    * op equal *tmp50 *tmp49 false
-    * jump *label43 notEqual *tmp50 false
+  153 jump *label43 equal *tmp49 false
   154 label *label45
   155 label *label42
   156 return :moveTo*retaddr

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    51 op land *tmp19 *tmp16 *tmp18
    52 jump *label23 equal *tmp19 false
    53 ucontrol itemDrop @air :moveItems:capacity
-    * jump *label24 always
    54 label *label23
    55 label *label24
    56 ucontrol itemTake .core :moveItems:item :moveItems:capacity
 
   107 ucontrol unbind
   108 ubind :unit.1
   109 ucontrol flag 1764335678894
-    * jump *label37 always
   110 label *label36
   111 label *label37
   112 write @unit processor1 ":findUnit:currentUnit"
   113 write false processor1 ":findUnit*finished"
   114 write 1 processor1 "@counter"
-    * jump *label34 always
   115 label *label33
   116 label *label34
   117 label *label12
 
   131 op or *tmp45 *tmp42 *tmp44
   132 jump *label40 equal *tmp45 false
   133 end
-    * jump *label41 always
   134 label *label40
   135 label *label41
   136 label *label39

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    32 setaddr :moveTo*retaddr *label16 (h:*label16)
    33 call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
    34 label *label16
+   35 setaddr :message*retaddr *label22 (h:*label22)
    36 label *label17
    37 sensor :moveItems:item sorter1 @config
    38 jump *label20 notEqual :moveItems:item null
 
    42 set *tmp14 "Taking items"
    43 label *label21
    44 set :message:text *tmp14
-    * setaddr :message*retaddr *label22 (h:*label22)
    45 call *label2 *invalid :message*retval (m:*label22) (h:*label22)
    46 label *label22
    47 sensor *tmp15 @unit @firstItem

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
    35 setaddr :message*retaddr *label22 (h:*label22)
    36 label *label17
    37 sensor :moveItems:item sorter1 @config
-    * jump *label20 notEqual :moveItems:item null
-    * set *tmp14 "Please select item to transport"
-    * jump *label21 always
-    * label *label20
-    * set *tmp14 "Taking items"
-    * label *label21
+   38 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
    39 set :message:text *tmp14
    40 call *label2 *invalid :message*retval (m:*label22) (h:*label22)
    41 label *label22

Modifications by Inline function call at unit-transport.mnd:91:9:
 
    32 setaddr :moveTo*retaddr *label16 (h:*label16)
    33 call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
    34 label *label16
-    * setaddr :message*retaddr *label22 (h:*label22)
    35 label *label17
    36 sensor :moveItems:item sorter1 @config
    37 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
    38 set :message:text *tmp14
-    * call *label2 *invalid :message*retval (m:*label22) (h:*label22)
-    * label *label22
+   39 label *label47
+   40 print :message:text
+   41 printflush message1
+   42 label *label48
    43 sensor *tmp15 @unit @firstItem
    44 op notEqual *tmp16 *tmp15 null
    45 sensor *tmp17 @unit @firstItem

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    37 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
    38 set :message:text *tmp14
    39 label *label47
-    * print :message:text
+   40 print *tmp14
    41 printflush message1
    42 label *label48
    43 sensor *tmp15 @unit @firstItem

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    35 label *label17
    36 sensor :moveItems:item sorter1 @config
    37 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
-    * set :message:text *tmp14
    38 label *label47
    39 print *tmp14
    40 printflush message1

Modifications by Inline function 'checkUnit' defined at unit-transport.mnd:65:1 (+4 instructions):
 
    49 label *label23
    50 label *label24
    51 ucontrol itemTake .core :moveItems:item :moveItems:capacity
-    * setaddr :checkUnit*retaddr *label25 (h:*label25)
-    * call *label3 *invalid :checkUnit*retval (m:*label25) (h:*label25)
-    * label *label25
+   52 label *label49
+   53 sensor *tmp42 @unit @dead
+   54 sensor *tmp43 @unit @controller
+   55 op notEqual *tmp44 *tmp43 @this
+   56 op or *tmp45 *tmp42 *tmp44
+   57 jump *label50 equal *tmp45 false
+   58 end
+   59 label *label50
+   60 label *label51
+   61 label *label52
    62 label *label18
    63 sensor *tmp21 @unit @totalItems
    64 jump *label17 notEqual *tmp21 :moveItems:capacity
 
    77 label *label28
    78 label *label29
    79 ucontrol itemDrop vault1 :moveItems:capacity
-    * setaddr :checkUnit*retaddr *label32 (h:*label32)
-    * call *label3 *invalid :checkUnit*retval (m:*label32) (h:*label32)
-    * label *label32
+   80 label *label53
+   81 sensor *tmp42 @unit @dead
+   82 sensor *tmp43 @unit @controller
+   83 op notEqual *tmp44 *tmp43 @this
+   84 op or *tmp45 *tmp42 *tmp44
+   85 jump *label54 equal *tmp45 false
+   86 end
+   87 label *label54
+   88 label *label55
+   89 label *label56
    90 label *label30
    91 sensor *tmp23 sorter1 @config
    92 op equal *tmp24 :moveItems:item *tmp23
 
   133 label *label38
   134 return :message*retaddr
   135 end
-    * label *label3
-    * sensor *tmp42 @unit @dead
-    * sensor *tmp43 @unit @controller
-    * op notEqual *tmp44 *tmp43 @this
-    * op or *tmp45 *tmp42 *tmp44
-    * jump *label40 equal *tmp45 false
-    * end
-    * label *label40
-    * label *label41
-    * label *label39
-    * return :checkUnit*retaddr
-    * end
   136 label *label4
   137 sensor :moveTo:x :moveTo:building @x
   138 sensor :moveTo:y :moveTo:building @y
   139 label *label43
   140 ucontrol approach :moveTo:x :moveTo:y 5
-    * setaddr :checkUnit*retaddr *label46 (h:*label46)
-    * call *label3 *invalid :checkUnit*retval (m:*label46) (h:*label46)
-    * label *label46
+  141 label *label57
+  142 sensor *tmp42 @unit @dead
+  143 sensor *tmp43 @unit @controller
+  144 op notEqual *tmp44 *tmp43 @this
+  145 op or *tmp45 *tmp42 *tmp44
+  146 jump *label58 equal *tmp45 false
+  147 end
+  148 label *label58
+  149 label *label59
+  150 label *label60
   151 label *label44
   152 ucontrol within :moveTo:x :moveTo:y 5 *tmp49
   153 jump *label43 equal *tmp49 false

Modifications by Inline function 'message' defined at unit-transport.mnd:59:1 (-4 instructions):
 
     1 read *tmp1 processor1 "*signature"
     2 jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"
     3 set :message:text "Initializing..."
-    * setaddr :message*retaddr *label6 (h:*label6)
-    * call *label2 *invalid :message*retval (m:*label6) (h:*label6)
-    * label *label6
+    4 label *label61
+    5 print :message:text
+    6 printflush message1
+    7 label *label62
     8 label *label7
     9 write null processor1 ":findUnit:currentUnit"
    10 write false processor1 ":findUnit*finished"
 
    26 label *label11
    27 sensor :moveItems:capacity @unit @itemCapacity
    28 set :message:text "Moving to core"
-    * setaddr :message*retaddr *label15 (h:*label15)
-    * call *label2 *invalid :message*retval (m:*label15) (h:*label15)
-    * label *label15
+   29 label *label63
+   30 print :message:text
+   31 printflush message1
+   32 label *label64
    33 set :moveTo:building .core
    34 setaddr :moveTo*retaddr *label16 (h:*label16)
    35 call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
 
    66 jump *label17 notEqual *tmp21 :moveItems:capacity
    67 label *label19
    68 set :message:text "Moving to vault"
-    * setaddr :message*retaddr *label26 (h:*label26)
-    * call *label2 *invalid :message*retval (m:*label26) (h:*label26)
-    * label *label26
+   69 label *label65
+   70 print :message:text
+   71 printflush message1
+   72 label *label66
    73 set :moveTo:building vault1
    74 setaddr :moveTo*retaddr *label27 (h:*label27)
    75 call *label4 *invalid :moveTo*retval (m:*label27) (h:*label27)
    76 label *label27
    77 set :message:text "Dropping items"
-    * setaddr :message*retaddr *label28 (h:*label28)
-    * call *label2 *invalid :message*retval (m:*label28) (h:*label28)
-    * label *label28
+   78 label *label67
+   79 print :message:text
+   80 printflush message1
+   81 label *label68
    82 label *label29
    83 ucontrol itemDrop vault1 :moveItems:capacity
    84 label *label53
 
   131 jump *label11 always
   132 label *label13
   133 end
-    * label *label2
-    * print :message:text
-    * printflush message1
-    * label *label38
-    * return :message*retaddr
-    * end
   134 label *label4
   135 sensor :moveTo:x :moveTo:building @x
   136 sensor :moveTo:y :moveTo:building @y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"
     3 set :message:text "Initializing..."
     4 label *label61
-    * print :message:text
+    5 print "Initializing..."
     6 printflush message1
     7 label *label62
     8 label *label7
 
    27 sensor :moveItems:capacity @unit @itemCapacity
    28 set :message:text "Moving to core"
    29 label *label63
-    * print :message:text
+   30 print "Moving to core"
    31 printflush message1
    32 label *label64
    33 set :moveTo:building .core
 
    67 label *label19
    68 set :message:text "Moving to vault"
    69 label *label65
-    * print :message:text
+   70 print "Moving to vault"
    71 printflush message1
    72 label *label66
    73 set :moveTo:building vault1
 
    76 label *label27
    77 set :message:text "Dropping items"
    78 label *label67
-    * print :message:text
+   79 print "Dropping items"
    80 printflush message1
    81 label *label68
    82 label *label29

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
     0 label *label5
     1 read *tmp1 processor1 "*signature"
     2 jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"
-    * set :message:text "Initializing..."
     3 label *label61
     4 print "Initializing..."
     5 printflush message1
 
    24 write 1 processor1 "@counter"
    25 label *label11
    26 sensor :moveItems:capacity @unit @itemCapacity
-    * set :message:text "Moving to core"
    27 label *label63
    28 print "Moving to core"
    29 printflush message1
 
    63 sensor *tmp21 @unit @totalItems
    64 jump *label17 notEqual *tmp21 :moveItems:capacity
    65 label *label19
-    * set :message:text "Moving to vault"
    66 label *label65
    67 print "Moving to vault"
    68 printflush message1
 
    71 setaddr :moveTo*retaddr *label27 (h:*label27)
    72 call *label4 *invalid :moveTo*retval (m:*label27) (h:*label27)
    73 label *label27
-    * set :message:text "Dropping items"
    74 label *label67
    75 print "Dropping items"
    76 printflush message1

Modifications by Inline function 'moveTo' defined at unit-transport.mnd:72:1 (+5 instructions):
 
    29 printflush message1
    30 label *label64
    31 set :moveTo:building .core
-    * setaddr :moveTo*retaddr *label16 (h:*label16)
-    * call *label4 *invalid :moveTo*retval (m:*label16) (h:*label16)
-    * label *label16
+   32 label *label69
+   33 sensor :moveTo:x :moveTo:building @x
+   34 sensor :moveTo:y :moveTo:building @y
+   35 label *label70
+   36 ucontrol approach :moveTo:x :moveTo:y 5
+   37 label *label71
+   38 sensor *tmp42 @unit @dead
+   39 sensor *tmp43 @unit @controller
+   40 op notEqual *tmp44 *tmp43 @this
+   41 op or *tmp45 *tmp42 *tmp44
+   42 jump *label72 equal *tmp45 false
+   43 end
+   44 label *label72
+   45 label *label73
+   46 label *label74
+   47 label *label75
+   48 ucontrol within :moveTo:x :moveTo:y 5 *tmp49
+   49 jump *label70 equal *tmp49 false
+   50 label *label76
+   51 label *label77
    52 label *label17
    53 sensor :moveItems:item sorter1 @config
    54 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
 
    85 printflush message1
    86 label *label66
    87 set :moveTo:building vault1
-    * setaddr :moveTo*retaddr *label27 (h:*label27)
-    * call *label4 *invalid :moveTo*retval (m:*label27) (h:*label27)
-    * label *label27
+   88 label *label78
+   89 sensor :moveTo:x :moveTo:building @x
+   90 sensor :moveTo:y :moveTo:building @y
+   91 label *label79
+   92 ucontrol approach :moveTo:x :moveTo:y 5
+   93 label *label80
+   94 sensor *tmp42 @unit @dead
+   95 sensor *tmp43 @unit @controller
+   96 op notEqual *tmp44 *tmp43 @this
+   97 op or *tmp45 *tmp42 *tmp44
+   98 jump *label81 equal *tmp45 false
+   99 end
+  100 label *label81
+  101 label *label82
+  102 label *label83
+  103 label *label84
+  104 ucontrol within :moveTo:x :moveTo:y 5 *tmp49
+  105 jump *label79 equal *tmp49 false
+  106 label *label85
+  107 label *label86
   108 label *label67
   109 print "Dropping items"
   110 printflush message1
 
   161 jump *label11 always
   162 label *label13
   163 end
-    * label *label4
-    * sensor :moveTo:x :moveTo:building @x
-    * sensor :moveTo:y :moveTo:building @y
-    * label *label43
-    * ucontrol approach :moveTo:x :moveTo:y 5
-    * label *label57
-    * sensor *tmp42 @unit @dead
-    * sensor *tmp43 @unit @controller
-    * op notEqual *tmp44 *tmp43 @this
-    * op or *tmp45 *tmp42 *tmp44
-    * jump *label58 equal *tmp45 false
-    * end
-    * label *label58
-    * label *label59
-    * label *label60
-    * label *label44
-    * ucontrol within :moveTo:x :moveTo:y 5 *tmp49
-    * jump *label43 equal *tmp49 false
-    * label *label45
-    * label *label42
-    * return :moveTo*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    30 label *label64
    31 set :moveTo:building .core
    32 label *label69
-    * sensor :moveTo:x :moveTo:building @x
-    * sensor :moveTo:y :moveTo:building @y
+   33 sensor :moveTo:x .core @x
+   34 sensor :moveTo:y .core @y
    35 label *label70
    36 ucontrol approach :moveTo:x :moveTo:y 5
    37 label *label71
 
    86 label *label66
    87 set :moveTo:building vault1
    88 label *label78
-    * sensor :moveTo:x :moveTo:building @x
-    * sensor :moveTo:y :moveTo:building @y
+   89 sensor :moveTo:x vault1 @x
+   90 sensor :moveTo:y vault1 @y
    91 label *label79
    92 ucontrol approach :moveTo:x :moveTo:y 5
    93 label *label80

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    28 print "Moving to core"
    29 printflush message1
    30 label *label64
-    * set :moveTo:building .core
    31 label *label69
    32 sensor :moveTo:x .core @x
    33 sensor :moveTo:y .core @y
 
    83 print "Moving to vault"
    84 printflush message1
    85 label *label66
-    * set :moveTo:building vault1
    86 label *label78
    87 sensor :moveTo:x vault1 @x
    88 sensor :moveTo:y vault1 @y

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
     0 label *label5
     1 read *tmp1 processor1 "*signature"
     2 jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"
-    * label *label61
     3 print "Initializing..."
     4 printflush message1
-    * label *label62
     5 label *label7
     6 write null processor1 ":findUnit:currentUnit"
     7 write false processor1 ":findUnit*finished"
 
    14 ubind :unit
    15 ucontrol flag 1764335678894
    16 ulocate building core false @copper *tmp6 *tmp7 *tmp8 .core
-    * label *label8
    17 jump *label7 equal .core null
-    * label *label9
    18 write @unit processor1 ":findUnit:currentUnit"
    19 write false processor1 ":findUnit*finished"
    20 write 1 processor1 "@counter"
    21 label *label11
    22 sensor :moveItems:capacity @unit @itemCapacity
-    * label *label63
    23 print "Moving to core"
    24 printflush message1
-    * label *label64
-    * label *label69
    25 sensor :moveTo:x .core @x
    26 sensor :moveTo:y .core @y
    27 label *label70
    28 ucontrol approach :moveTo:x :moveTo:y 5
-    * label *label71
    29 sensor *tmp42 @unit @dead
    30 sensor *tmp43 @unit @controller
    31 op notEqual *tmp44 *tmp43 @this
 
    33 jump *label72 equal *tmp45 false
    34 end
    35 label *label72
-    * label *label73
-    * label *label74
-    * label *label75
    36 ucontrol within :moveTo:x :moveTo:y 5 *tmp49
    37 jump *label70 equal *tmp49 false
-    * label *label76
-    * label *label77
    38 label *label17
    39 sensor :moveItems:item sorter1 @config
    40 select *tmp14 equal :moveItems:item null "Please select item to transport" "Taking items"
-    * label *label47
    41 print *tmp14
    42 printflush message1
-    * label *label48
    43 sensor *tmp15 @unit @firstItem
    44 op notEqual *tmp16 *tmp15 null
    45 sensor *tmp17 @unit @firstItem
 
    48 jump *label23 equal *tmp19 false
    49 ucontrol itemDrop @air :moveItems:capacity
    50 label *label23
-    * label *label24
    51 ucontrol itemTake .core :moveItems:item :moveItems:capacity
-    * label *label49
    52 sensor *tmp42 @unit @dead
    53 sensor *tmp43 @unit @controller
    54 op notEqual *tmp44 *tmp43 @this
 
    56 jump *label50 equal *tmp45 false
    57 end
    58 label *label50
-    * label *label51
-    * label *label52
-    * label *label18
    59 sensor *tmp21 @unit @totalItems
    60 jump *label17 notEqual *tmp21 :moveItems:capacity
-    * label *label19
-    * label *label65
    61 print "Moving to vault"
    62 printflush message1
-    * label *label66
-    * label *label78
    63 sensor :moveTo:x vault1 @x
    64 sensor :moveTo:y vault1 @y
    65 label *label79
    66 ucontrol approach :moveTo:x :moveTo:y 5
-    * label *label80
    67 sensor *tmp42 @unit @dead
    68 sensor *tmp43 @unit @controller
    69 op notEqual *tmp44 *tmp43 @this
 
    71 jump *label81 equal *tmp45 false
    72 end
    73 label *label81
-    * label *label82
-    * label *label83
-    * label *label84
    74 ucontrol within :moveTo:x :moveTo:y 5 *tmp49
    75 jump *label79 equal *tmp49 false
-    * label *label85
-    * label *label86
-    * label *label67
    76 print "Dropping items"
    77 printflush message1
-    * label *label68
    78 label *label29
    79 ucontrol itemDrop vault1 :moveItems:capacity
-    * label *label53
    80 sensor *tmp42 @unit @dead
    81 sensor *tmp43 @unit @controller
    82 op notEqual *tmp44 *tmp43 @this
 
    84 jump *label54 equal *tmp45 false
    85 end
    86 label *label54
-    * label *label55
-    * label *label56
-    * label *label30
    87 sensor *tmp23 sorter1 @config
    88 op equal *tmp24 :moveItems:item *tmp23
    89 sensor *tmp25 @unit @totalItems
    90 op greaterThan *tmp26 *tmp25 0
    91 op land *tmp27 *tmp24 *tmp26
    92 jump *label29 notEqual *tmp27 false
-    * label *label31
-    * label *label14
    93 read *tmp28 processor1 ":findUnit*finished"
    94 jump *label33 equal *tmp28 false
    95 label *label35
 
   111 ubind :unit.1
   112 ucontrol flag 1764335678894
   113 label *label36
-    * label *label37
   114 write @unit processor1 ":findUnit:currentUnit"
   115 write false processor1 ":findUnit*finished"
   116 write 1 processor1 "@counter"
   117 label *label33
-    * label *label34
-    * label *label12
   118 jump *label11 always
-    * label *label13
   119 end

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
 
    91 op land *tmp27 *tmp24 *tmp26
    92 jump *label29 notEqual *tmp27 false
    93 read *tmp28 processor1 ":findUnit*finished"
-    * jump *label33 equal *tmp28 false
+   94 jump *label11 equal *tmp28 false
    95 label *label35
    96 wait 1e-15
    97 read *tmp30 processor1 ":findUnit*finished"

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-1 instructions):
 
   114 write @unit processor1 ":findUnit:currentUnit"
   115 write false processor1 ":findUnit*finished"
   116 write 1 processor1 "@counter"
-    * label *label33
   117 jump *label11 always
-    * end

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
    13 read :unit processor1 ":findUnit*retval"
    14 ubind :unit
    15 ucontrol flag 1764335678894
-    * ulocate building core false @copper *tmp6 *tmp7 *tmp8 .core
+   16 ulocate building core false @copper 0 0 0 .core
    17 jump *label7 equal .core null
    18 write @unit processor1 ":findUnit:currentUnit"
    19 write false processor1 ":findUnit*finished"

Final code before resolving virtual instructions:

        label *label5                                                unit-transport.mnd: require "unit-monitor.mnd" remote processor1;
    0:  read *tmp1 processor1 "*signature"                           ...
    1:  jump *label5 notEqual *tmp1 "d6ba00c23bee94f3:v1"            ...
    2:  print "Initializing..."                                      unit-transport.mnd: print(text);
    3:  printflush message1                                          unit-transport.mnd: printflush(message1);
        label *label7                                                unit-transport.mnd: do
    4:  write null processor1 ":findUnit:currentUnit"                unit-transport.mnd: var unit = processor1.findUnit(null);
    5:  write false processor1 ":findUnit*finished"                  ...
    6:  write 1 processor1 "@counter"                                ...
        label *label10                                               ...
    7:  wait 1e-15                                                   ...
    8:  read *tmp3 processor1 ":findUnit*finished"                   ...
    9:  jump *label10 equal *tmp3 false                              ...
   10:  read :unit processor1 ":findUnit*retval"                     ...
   11:  ubind :unit                                                  unit-transport.mnd: ubind(unit);
   12:  ucontrol flag 1764335678894 0 0 0 0                          unit-transport.mnd: flag(FLAG);
   13:  ulocate building core false @copper 0 0 0 .core              unit-transport.mnd: core = ulocate(:building, :core, false);
   14:  jump *label7 equal .core null                                unit-transport.mnd: do
   15:  write @unit processor1 ":findUnit:currentUnit"               unit-transport.mnd: async(processor1.findUnit(@unit));
   16:  write false processor1 ":findUnit*finished"                  ...
   17:  write 1 processor1 "@counter"                                ...
        label *label11                                               unit-transport.mnd: while true do
   18:  sensor :moveItems:capacity @unit @itemCapacity               unit-transport.mnd: var capacity = @unit.@itemCapacity;
   19:  print "Moving to core"                                       unit-transport.mnd: print(text);
   20:  printflush message1                                          unit-transport.mnd: printflush(message1);
   21:  sensor :moveTo:x .core @x                                    unit-transport.mnd: var x = building.@x;
   22:  sensor :moveTo:y .core @y                                    unit-transport.mnd: var y = building.@y;
        label *label70                                               unit-transport.mnd: do
   23:  ucontrol approach :moveTo:x :moveTo:y 5 0 0                  unit-transport.mnd: approach(x, y, 5);
   24:  sensor *tmp42 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   25:  sensor *tmp43 @unit @controller                              ...
   26:  op notEqual *tmp44 *tmp43 @this                              ...
   27:  op or *tmp45 *tmp42 *tmp44                                   ...
   28:  jump *label72 equal *tmp45 false                             ...
   29:  end                                                          unit-transport.mnd: end();
        label *label72                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   30:  ucontrol within :moveTo:x :moveTo:y 5 *tmp49 0               unit-transport.mnd: while !within(x, y, 5);
   31:  jump *label70 equal *tmp49 false                             unit-transport.mnd: do
        label *label17                                               unit-transport.mnd: do
   32:  sensor :moveItems:item sorter1 @config                       unit-transport.mnd: item = sorter1.@config;
   33:  select *tmp14 equal :moveItems:item null "Please select item unit-transport.mnd: message(item == null ? "Please select item to transport" : "Taking items");
   34:  print *tmp14                                                 unit-transport.mnd: print(text);
   35:  printflush message1                                          unit-transport.mnd: printflush(message1);
   36:  sensor *tmp15 @unit @firstItem                               unit-transport.mnd: if @unit.@firstItem != null and @unit.@firstItem != item then
   37:  op notEqual *tmp16 *tmp15 null                               ...
   38:  sensor *tmp17 @unit @firstItem                               ...
   39:  op notEqual *tmp18 *tmp17 :moveItems:item                    ...
   40:  op land *tmp19 *tmp16 *tmp18                                 ...
   41:  jump *label23 equal *tmp19 false                             ...
   42:  ucontrol itemDrop @air :moveItems:capacity 0 0 0             unit-transport.mnd: itemDrop(@air, capacity);
        label *label23                                               unit-transport.mnd: if @unit.@firstItem != null and @unit.@firstItem != item then
   43:  ucontrol itemTake .core :moveItems:item :moveItems:capacity  unit-transport.mnd: itemTake(core, item, capacity);
   44:  sensor *tmp42 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   45:  sensor *tmp43 @unit @controller                              ...
   46:  op notEqual *tmp44 *tmp43 @this                              ...
   47:  op or *tmp45 *tmp42 *tmp44                                   ...
   48:  jump *label50 equal *tmp45 false                             ...
   49:  end                                                          unit-transport.mnd: end();
        label *label50                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   50:  sensor *tmp21 @unit @totalItems                              unit-transport.mnd: while @unit.@totalItems != capacity;
   51:  jump *label17 notEqual *tmp21 :moveItems:capacity            unit-transport.mnd: do
   52:  print "Moving to vault"                                      unit-transport.mnd: print(text);
   53:  printflush message1                                          unit-transport.mnd: printflush(message1);
   54:  sensor :moveTo:x vault1 @x                                   unit-transport.mnd: var x = building.@x;
   55:  sensor :moveTo:y vault1 @y                                   unit-transport.mnd: var y = building.@y;
        label *label79                                               unit-transport.mnd: do
   56:  ucontrol approach :moveTo:x :moveTo:y 5 0 0                  unit-transport.mnd: approach(x, y, 5);
   57:  sensor *tmp42 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   58:  sensor *tmp43 @unit @controller                              ...
   59:  op notEqual *tmp44 *tmp43 @this                              ...
   60:  op or *tmp45 *tmp42 *tmp44                                   ...
   61:  jump *label81 equal *tmp45 false                             ...
   62:  end                                                          unit-transport.mnd: end();
        label *label81                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   63:  ucontrol within :moveTo:x :moveTo:y 5 *tmp49 0               unit-transport.mnd: while !within(x, y, 5);
   64:  jump *label79 equal *tmp49 false                             unit-transport.mnd: do
   65:  print "Dropping items"                                       unit-transport.mnd: print(text);
   66:  printflush message1                                          unit-transport.mnd: printflush(message1);
        label *label29                                               unit-transport.mnd: do
   67:  ucontrol itemDrop vault1 :moveItems:capacity 0 0 0           unit-transport.mnd: itemDrop(storage, capacity);
   68:  sensor *tmp42 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   69:  sensor *tmp43 @unit @controller                              ...
   70:  op notEqual *tmp44 *tmp43 @this                              ...
   71:  op or *tmp45 *tmp42 *tmp44                                   ...
   72:  jump *label54 equal *tmp45 false                             ...
   73:  end                                                          unit-transport.mnd: end();
        label *label54                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   74:  sensor *tmp23 sorter1 @config                                unit-transport.mnd: while item == sorter1.@config and @unit.@totalItems > 0;
   75:  op equal *tmp24 :moveItems:item *tmp23                       ...
   76:  sensor *tmp25 @unit @totalItems                              ...
   77:  op greaterThan *tmp26 *tmp25 0                               ...
   78:  op land *tmp27 *tmp24 *tmp26                                 ...
   79:  jump *label29 notEqual *tmp27 false                          unit-transport.mnd: do
   80:  read *tmp28 processor1 ":findUnit*finished"                  unit-transport.mnd: if finished(processor1.findUnit) then
   81:  jump *label11 equal *tmp28 false                             ...
        label *label35                                               unit-transport.mnd: var unit = await(processor1.findUnit);
   82:  wait 1e-15                                                   ...
   83:  read *tmp30 processor1 ":findUnit*finished"                  ...
   84:  jump *label35 equal *tmp30 false                             ...
   85:  read :unit.1 processor1 ":findUnit*retval"                   ...
   86:  sensor *tmp32 :unit.1 @dead                                  unit-transport.mnd: if !unit.@dead and (unit.@controller == processor1 or !unit.@controlled) then
   87:  op equal *tmp33 *tmp32 false                                 ...
   88:  sensor *tmp34 :unit.1 @controller                            ...
   89:  op equal *tmp35 *tmp34 processor1                            ...
   90:  sensor *tmp36 :unit.1 @controlled                            ...
   91:  op equal *tmp37 *tmp36 false                                 ...
   92:  op or *tmp38 *tmp35 *tmp37                                   ...
   93:  op land *tmp39 *tmp33 *tmp38                                 ...
   94:  jump *label36 equal *tmp39 false                             ...
   95:  ucontrol flag null 0 0 0 0                                   unit-transport.mnd: flag(null);
   96:  ucontrol unbind 0 0 0 0 0                                    unit-transport.mnd: unbind();
   97:  ubind :unit.1                                                unit-transport.mnd: ubind(unit);
   98:  ucontrol flag 1764335678894 0 0 0 0                          unit-transport.mnd: flag(FLAG);
        label *label36                                               unit-transport.mnd: if !unit.@dead and (unit.@controller == processor1 or !unit.@controlled) then
   99:  write @unit processor1 ":findUnit:currentUnit"               unit-transport.mnd: async(processor1.findUnit(@unit));
  100:  write false processor1 ":findUnit*finished"                  ...
  101:  write 1 processor1 "@counter"                                ...
  102:  jump *label11 always 0 0                                     unit-transport.mnd: while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    40     1x     40,0  <no function>
    24     4x      6,0  void checkUnit()
    20     1x     20,0  void moveItems()
    10     5x      2,0  void message(in text)
    10     2x      5,0  void moveTo(in building)

Performance: parsed in 231 ms, compiled in 289 ms, optimized in 280 ms, run in 3 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (1 steps):
The program didn't generate any output.
Execution exception at instruction 0: read *tmp1 processor1 "*signature":
Variable 'processor1' is not an object.
(Use the '#set err-not-an-object = false;' directive or the '--err-not-an-object false' command line option to ignore this exception.)
