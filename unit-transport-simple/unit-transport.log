   134 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination.
     8 instructions eliminated by Dead Code Elimination (3 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     4 instructions eliminated by Jump Optimization (4 iterations).
     5 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     1 instructions eliminated by If Expression Optimization (3 iterations).
     8 instructions eliminated by Data Flow Optimization (3 passes, 13 iterations).
     5 instructions added by Function Inlining (7 iterations).
    10 function calls inlined by Function Inlining.
     1 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination.
   105 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 892):
    Inline function 'message' defined at unit-transport.mnd:59:1 cost     3, benefit     2453.5, efficiency      817.8
    Inline function 'checkUnit' defined at unit-transport.mnd:65:1 cost     9, benefit     7500.0, efficiency      833.3
    Inline function 'moveTo' defined at unit-transport.mnd:72:1  cost     5, benefit      175.0, efficiency       35.0
    Inline function call at unit-transport.mnd:17:5              cost     1, benefit        3.5, efficiency        3.5
    Inline function call at unit-transport.mnd:86:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:87:5              cost     6, benefit       87.5, efficiency       14.6
  * Inline function call at unit-transport.mnd:91:9              cost     1, benefit     2187.5, efficiency     2187.5 (+0 instructions)
    Inline function call at unit-transport.mnd:99:9              cost     5, benefit     1875.0, efficiency      375.0
    Inline function call at unit-transport.mnd:102:5             cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:103:5             cost     6, benefit       87.5, efficiency       14.6
    Inline function call at unit-transport.mnd:107:5             cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:110:9             cost     5, benefit     1875.0, efficiency      375.0
    Inline function call at unit-transport.mnd:77:9              cost     5, benefit     3750.0, efficiency      750.0

Pass 1: speed optimization selection (cost limit 892):
    Inline function 'message' defined at unit-transport.mnd:59:1 cost     2, benefit      266.0, efficiency      133.0
  * Inline function 'checkUnit' defined at unit-transport.mnd:65:1 cost     9, benefit     7500.0, efficiency      833.3 (+4 instructions)
    Inline function 'moveTo' defined at unit-transport.mnd:72:1  cost     5, benefit      175.0, efficiency       35.0
    Inline function call at unit-transport.mnd:17:5              cost     1, benefit        3.5, efficiency        3.5
    Inline function call at unit-transport.mnd:86:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:87:5              cost     6, benefit       87.5, efficiency       14.6
    Inline function call at unit-transport.mnd:99:9              cost     5, benefit     1875.0, efficiency      375.0
    Inline function call at unit-transport.mnd:102:5             cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:103:5             cost     6, benefit       87.5, efficiency       14.6
    Inline function call at unit-transport.mnd:107:5             cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:110:9             cost     5, benefit     1875.0, efficiency      375.0
    Inline function call at unit-transport.mnd:77:9              cost     5, benefit     3750.0, efficiency      750.0

Pass 1: speed optimization selection (cost limit 888):
  * Inline function 'message' defined at unit-transport.mnd:59:1 cost     2, benefit      266.0, efficiency      133.0 (-8 instructions)
    Inline function 'moveTo' defined at unit-transport.mnd:72:1  cost     9, benefit      175.0, efficiency       19.4
    Inline function call at unit-transport.mnd:17:5              cost     1, benefit        3.5, efficiency        3.5
    Inline function call at unit-transport.mnd:86:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:87:5              cost    10, benefit       87.5, efficiency        8.8
    Inline function call at unit-transport.mnd:102:5             cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:103:5             cost    10, benefit       87.5, efficiency        8.8
    Inline function call at unit-transport.mnd:107:5             cost     1, benefit       87.5, efficiency       87.5

Pass 1: speed optimization selection (cost limit 896):
  * Inline function 'moveTo' defined at unit-transport.mnd:72:1  cost     9, benefit      175.0, efficiency       19.4 (+3 instructions)
    Inline function call at unit-transport.mnd:87:5              cost    10, benefit       87.5, efficiency        8.8
    Inline function call at unit-transport.mnd:103:5             cost    10, benefit       87.5, efficiency        8.8

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-8 instructions):
 
    65 op land *tmp16 *tmp13 *tmp15
    66 jump *label25 equal *tmp16 false
    67 ucontrol itemDrop @air :moveItems.0:capacity
-    * set *tmp17 null
    68 jump *label26 always
    69 label *label25
-    * set *tmp17 null
    70 label *label26
    71 ucontrol itemTake .core :moveItems.0:item :moveItems.0:capacity
    72 setaddr :checkUnit.0*retaddr *label27
 
   121 ucontrol unbind
   122 ubind :unit.1
   123 ucontrol flag 1764335678894
-    * set *tmp34 null
   124 jump *label39 always
   125 label *label38
-    * set *tmp34 null
   126 label *label39
   127 write @unit processor1 ":findUnit:currentUnit"
   128 set :findUnit*finished false
   129 write :findUnit*address processor1 "@counter"
-    * set *tmp25 null
   130 jump *label36 always
   131 label *label35
-    * set *tmp25 null
   132 label *label36
   133 label *label14
   134 jump *label13 always
 
   147 op or *tmp38 *tmp35 *tmp37
   148 jump *label42 equal *tmp38 false
   149 end
-    * set *tmp39 null
   150 jump *label43 always
   151 label *label42
-    * set *tmp39 null
   152 label *label43
   153 label *label41
   154 return :checkUnit.0*retaddr

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
    19 label *label12
    20 wait 1e-15
    21 jump *label12 equal :findUnit*finished false
-    * set *tmp2 :findUnit*retval
-    * set :unit *tmp2
+   22 set :unit :findUnit*retval
    23 ubind :unit
    24 ucontrol flag 1764335678894
-    * ulocate building core false @copper *tmp4 *tmp5 *tmp6 *tmp3
-    * set .core *tmp3
+   25 ulocate building core false @copper 0 0 0 .core
    26 label *label10
    27 op equal *tmp7 .core null
    28 jump *label9 notEqual *tmp7 false
 
    32 write :findUnit*address processor1 "@counter"
    33 label *label13
    34 jump *label15 equal true false
-    * sensor *tmp8 @unit @itemCapacity
-    * set :moveItems.0:capacity *tmp8
+   35 sensor :moveItems.0:capacity @unit @itemCapacity
    36 set :message.0:text "Moving to core"
    37 setaddr :message.0*retaddr *label17
    38 call *label1 :message.0*retval
 
    42 call *label3 :moveTo.0*retval
    43 label *label18
    44 label *label19
-    * sensor *tmp9 sorter1 @config
-    * set :moveItems.0:item *tmp9
+   45 sensor :moveItems.0:item sorter1 @config
    46 op equal *tmp10 :moveItems.0:item null
    47 jump *label22 equal *tmp10 false
    48 set *tmp11 "Please select item to transport"
 
   150 return :checkUnit.0*retaddr
   151 end
   152 label *label3
-    * sensor *tmp40 :moveTo.0:building @x
-    * set :moveTo.0:x *tmp40
-    * sensor *tmp41 :moveTo.0:building @y
-    * set :moveTo.0:y *tmp41
+  153 sensor :moveTo.0:x :moveTo.0:building @x
+  154 sensor :moveTo.0:y :moveTo.0:building @y
   155 label *label45
   156 ucontrol approach :moveTo.0:x :moveTo.0:y 5
   157 setaddr :checkUnit.0*retaddr *label48

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    31 set :findUnit*finished false
    32 write :findUnit*address processor1 "@counter"
    33 label *label13
-    * jump *label15 equal true false
    34 sensor :moveItems.0:capacity @unit @itemCapacity
    35 set :message.0:text "Moving to core"
    36 setaddr :message.0*retaddr *label17

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-4 instructions):
 
    24 ucontrol flag 1764335678894
    25 ulocate building core false @copper 0 0 0 .core
    26 label *label10
-    * op equal *tmp7 .core null
-    * jump *label9 notEqual *tmp7 false
+   27 jump *label9 equal .core null
    28 label *label11
    29 write @unit processor1 ":findUnit:currentUnit"
    30 set :findUnit*finished false
 
    41 label *label18
    42 label *label19
    43 sensor :moveItems.0:item sorter1 @config
-    * op equal *tmp10 :moveItems.0:item null
-    * jump *label22 equal *tmp10 false
+   44 jump *label22 notEqual :moveItems.0:item null
    45 set *tmp11 "Please select item to transport"
    46 jump *label23 always
    47 label *label22
 
    67 label *label27
    68 label *label20
    69 sensor *tmp18 @unit @totalItems
-    * op notEqual *tmp19 *tmp18 :moveItems.0:capacity
-    * jump *label19 notEqual *tmp19 false
+   70 jump *label19 notEqual *tmp18 :moveItems.0:capacity
    71 label *label21
    72 set :message.0:text "Moving to vault"
    73 setaddr :message.0*retaddr *label28
 
   155 label *label48
   156 label *label46
   157 ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp42
-    * op equal *tmp43 *tmp42 false
-    * jump *label45 notEqual *tmp43 false
+  158 jump *label45 equal *tmp42 false
   159 label *label47
   160 label *label44
   161 return :moveTo.0*retaddr

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    58 op land *tmp16 *tmp13 *tmp15
    59 jump *label25 equal *tmp16 false
    60 ucontrol itemDrop @air :moveItems.0:capacity
-    * jump *label26 always
    61 label *label25
    62 label *label26
    63 ucontrol itemTake .core :moveItems.0:item :moveItems.0:capacity
 
   112 ucontrol unbind
   113 ubind :unit.1
   114 ucontrol flag 1764335678894
-    * jump *label39 always
   115 label *label38
   116 label *label39
   117 write @unit processor1 ":findUnit:currentUnit"
   118 set :findUnit*finished false
   119 write :findUnit*address processor1 "@counter"
-    * jump *label36 always
   120 label *label35
   121 label *label36
   122 label *label14
 
   136 op or *tmp38 *tmp35 *tmp37
   137 jump *label42 equal *tmp38 false
   138 end
-    * jump *label43 always
   139 label *label42
   140 label *label43
   141 label *label41

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    20 wait 1e-15
    21 jump *label12 equal :findUnit*finished false
    22 set :unit :findUnit*retval
-    * ubind :unit
+   23 ubind :findUnit*retval
    24 ucontrol flag 1764335678894
    25 ulocate building core false @copper 0 0 0 .core
    26 label *label10
 
    99 wait 1e-15
   100 jump *label37 equal :findUnit*finished false
   101 set :unit.1 :findUnit*retval
-    * sensor *tmp26 :unit.1 @dead
+  102 sensor *tmp26 :findUnit*retval @dead
   103 op equal *tmp27 *tmp26 false
-    * sensor *tmp28 :unit.1 @controller
+  104 sensor *tmp28 :findUnit*retval @controller
   105 op equal *tmp29 *tmp28 processor1
-    * sensor *tmp30 :unit.1 @controlled
+  106 sensor *tmp30 :findUnit*retval @controlled
   107 op equal *tmp31 *tmp30 false
   108 op or *tmp32 *tmp29 *tmp31
   109 op land *tmp33 *tmp27 *tmp32
   110 jump *label38 equal *tmp33 false
   111 ucontrol flag null
   112 ucontrol unbind
-    * ubind :unit.1
+  113 ubind :findUnit*retval
   114 ucontrol flag 1764335678894
   115 label *label38
   116 label *label39

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    19 label *label12
    20 wait 1e-15
    21 jump *label12 equal :findUnit*finished false
-    * set :unit :findUnit*retval
    22 ubind :findUnit*retval
    23 ucontrol flag 1764335678894
    24 ulocate building core false @copper 0 0 0 .core
 
    97 label *label37
    98 wait 1e-15
    99 jump *label37 equal :findUnit*finished false
-    * set :unit.1 :findUnit*retval
   100 sensor *tmp26 :findUnit*retval @dead
   101 op equal *tmp27 *tmp26 false
   102 sensor *tmp28 :findUnit*retval @controller

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    40 label *label18
    41 label *label19
    42 sensor :moveItems.0:item sorter1 @config
-    * jump *label22 notEqual :moveItems.0:item null
-    * set *tmp11 "Please select item to transport"
+   43 set :message.0:text "Taking items"
+   44 jump *label23 notEqual :moveItems.0:item null
+   45 set :message.0:text "Please select item to transport"
    46 jump *label23 always
-    * label *label22
-    * set *tmp11 "Taking items"
    47 label *label23
-    * set :message.0:text *tmp11
    48 setaddr :message.0*retaddr *label24
    49 call *label1 :message.0*retval
    50 label *label24

Modifications by Inline function call at unit-transport.mnd:91:9:
 
    45 set :message.0:text "Please select item to transport"
    46 jump *label23 always
    47 label *label23
-    * setaddr :message.0*retaddr *label24
-    * call *label1 :message.0*retval
-    * label *label24
+   48 label *label49
+   49 print :message.0:text
+   50 printflush message1
+   51 label *label50
    52 sensor *tmp12 @unit @firstItem
    53 op notEqual *tmp13 *tmp12 null
    54 sensor *tmp14 @unit @firstItem

Modifications by Inline function 'checkUnit' defined at unit-transport.mnd:65:1 (+4 instructions):
 
    59 label *label25
    60 label *label26
    61 ucontrol itemTake .core :moveItems.0:item :moveItems.0:capacity
-    * setaddr :checkUnit.0*retaddr *label27
-    * call *label2 :checkUnit.0*retval
-    * label *label27
+   62 label *label51
+   63 sensor *tmp35 @unit @dead
+   64 sensor *tmp36 @unit @controller
+   65 op notEqual *tmp37 *tmp36 @this
+   66 op or *tmp38 *tmp35 *tmp37
+   67 jump *label52 equal *tmp38 false
+   68 end
+   69 label *label52
+   70 label *label53
+   71 label *label54
    72 label *label20
    73 sensor *tmp18 @unit @totalItems
    74 jump *label19 notEqual *tmp18 :moveItems.0:capacity
 
    87 label *label30
    88 label *label31
    89 ucontrol itemDrop vault1 :moveItems.0:capacity
-    * setaddr :checkUnit.0*retaddr *label34
-    * call *label2 :checkUnit.0*retval
-    * label *label34
+   90 label *label55
+   91 sensor *tmp35 @unit @dead
+   92 sensor *tmp36 @unit @controller
+   93 op notEqual *tmp37 *tmp36 @this
+   94 op or *tmp38 *tmp35 *tmp37
+   95 jump *label56 equal *tmp38 false
+   96 end
+   97 label *label56
+   98 label *label57
+   99 label *label58
   100 label *label32
   101 sensor *tmp20 sorter1 @config
   102 op equal *tmp21 :moveItems.0:item *tmp20
 
   140 label *label40
   141 return :message.0*retaddr
   142 end
-    * label *label2
-    * sensor *tmp35 @unit @dead
-    * sensor *tmp36 @unit @controller
-    * op notEqual *tmp37 *tmp36 @this
-    * op or *tmp38 *tmp35 *tmp37
-    * jump *label42 equal *tmp38 false
-    * end
-    * label *label42
-    * label *label43
-    * label *label41
-    * return :checkUnit.0*retaddr
-    * end
   143 label *label3
   144 sensor :moveTo.0:x :moveTo.0:building @x
   145 sensor :moveTo.0:y :moveTo.0:building @y
   146 label *label45
   147 ucontrol approach :moveTo.0:x :moveTo.0:y 5
-    * setaddr :checkUnit.0*retaddr *label48
-    * call *label2 :checkUnit.0*retval
-    * label *label48
+  148 label *label59
+  149 sensor *tmp35 @unit @dead
+  150 sensor *tmp36 @unit @controller
+  151 op notEqual *tmp37 *tmp36 @this
+  152 op or *tmp38 *tmp35 *tmp37
+  153 jump *label60 equal *tmp38 false
+  154 end
+  155 label *label60
+  156 label *label61
+  157 label *label62
   158 label *label46
   159 ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp42
   160 jump *label45 equal *tmp42 false

Modifications by Inline function 'message' defined at unit-transport.mnd:59:1 (-4 instructions):
 
     9 label *label7
    10 jump *label7 equal vault1 null
    11 set :message.0:text "Initializing..."
-    * setaddr :message.0*retaddr *label8
-    * call *label1 :message.0*retval
-    * label *label8
+   12 label *label63
+   13 print :message.0:text
+   14 printflush message1
+   15 label *label64
    16 label *label9
    17 write null processor1 ":findUnit:currentUnit"
    18 set :findUnit*finished false
 
    32 label *label13
    33 sensor :moveItems.0:capacity @unit @itemCapacity
    34 set :message.0:text "Moving to core"
-    * setaddr :message.0*retaddr *label17
-    * call *label1 :message.0*retval
-    * label *label17
+   35 label *label65
+   36 print :message.0:text
+   37 printflush message1
+   38 label *label66
    39 set :moveTo.0:building .core
    40 setaddr :moveTo.0*retaddr *label18
    41 call *label3 :moveTo.0*retval
 
    76 jump *label19 notEqual *tmp18 :moveItems.0:capacity
    77 label *label21
    78 set :message.0:text "Moving to vault"
-    * setaddr :message.0*retaddr *label28
-    * call *label1 :message.0*retval
-    * label *label28
+   79 label *label67
+   80 print :message.0:text
+   81 printflush message1
+   82 label *label68
    83 set :moveTo.0:building vault1
    84 setaddr :moveTo.0*retaddr *label29
    85 call *label3 :moveTo.0*retval
    86 label *label29
    87 set :message.0:text "Dropping items"
-    * setaddr :message.0*retaddr *label30
-    * call *label1 :message.0*retval
-    * label *label30
+   88 label *label69
+   89 print :message.0:text
+   90 printflush message1
+   91 label *label70
    92 label *label31
    93 ucontrol itemDrop vault1 :moveItems.0:capacity
    94 label *label55
 
   138 jump *label13 always
   139 label *label15
   140 end
-    * label *label1
-    * print :message.0:text
-    * printflush message1
-    * label *label40
-    * return :message.0*retaddr
-    * end
   141 label *label3
   142 sensor :moveTo.0:x :moveTo.0:building @x
   143 sensor :moveTo.0:y :moveTo.0:building @y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    10 jump *label7 equal vault1 null
    11 set :message.0:text "Initializing..."
    12 label *label63
-    * print :message.0:text
+   13 print "Initializing..."
    14 printflush message1
    15 label *label64
    16 label *label9
 
    33 sensor :moveItems.0:capacity @unit @itemCapacity
    34 set :message.0:text "Moving to core"
    35 label *label65
-    * print :message.0:text
+   36 print "Moving to core"
    37 printflush message1
    38 label *label66
    39 set :moveTo.0:building .core
 
    77 label *label21
    78 set :message.0:text "Moving to vault"
    79 label *label67
-    * print :message.0:text
+   80 print "Moving to vault"
    81 printflush message1
    82 label *label68
    83 set :moveTo.0:building vault1
 
    86 label *label29
    87 set :message.0:text "Dropping items"
    88 label *label69
-    * print :message.0:text
+   89 print "Dropping items"
    90 printflush message1
    91 label *label70
    92 label *label31

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
     8 jump *label6 equal message1 null
     9 label *label7
    10 jump *label7 equal vault1 null
-    * set :message.0:text "Initializing..."
    11 label *label63
    12 print "Initializing..."
    13 printflush message1
 
    30 write :findUnit*address processor1 "@counter"
    31 label *label13
    32 sensor :moveItems.0:capacity @unit @itemCapacity
-    * set :message.0:text "Moving to core"
    33 label *label65
    34 print "Moving to core"
    35 printflush message1
 
    73 sensor *tmp18 @unit @totalItems
    74 jump *label19 notEqual *tmp18 :moveItems.0:capacity
    75 label *label21
-    * set :message.0:text "Moving to vault"
    76 label *label67
    77 print "Moving to vault"
    78 printflush message1
 
    81 setaddr :moveTo.0*retaddr *label29
    82 call *label3 :moveTo.0*retval
    83 label *label29
-    * set :message.0:text "Dropping items"
    84 label *label69
    85 print "Dropping items"
    86 printflush message1

Modifications by Inline function 'moveTo' defined at unit-transport.mnd:72:1 (+5 instructions):
 
    35 printflush message1
    36 label *label66
    37 set :moveTo.0:building .core
-    * setaddr :moveTo.0*retaddr *label18
-    * call *label3 :moveTo.0*retval
-    * label *label18
+   38 label *label71
+   39 sensor :moveTo.0:x :moveTo.0:building @x
+   40 sensor :moveTo.0:y :moveTo.0:building @y
+   41 label *label72
+   42 ucontrol approach :moveTo.0:x :moveTo.0:y 5
+   43 label *label73
+   44 sensor *tmp35 @unit @dead
+   45 sensor *tmp36 @unit @controller
+   46 op notEqual *tmp37 *tmp36 @this
+   47 op or *tmp38 *tmp35 *tmp37
+   48 jump *label74 equal *tmp38 false
+   49 end
+   50 label *label74
+   51 label *label75
+   52 label *label76
+   53 label *label77
+   54 ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp42
+   55 jump *label72 equal *tmp42 false
+   56 label *label78
+   57 label *label79
    58 label *label19
    59 sensor :moveItems.0:item sorter1 @config
    60 set :message.0:text "Taking items"
 
    95 printflush message1
    96 label *label68
    97 set :moveTo.0:building vault1
-    * setaddr :moveTo.0*retaddr *label29
-    * call *label3 :moveTo.0*retval
-    * label *label29
+   98 label *label80
+   99 sensor :moveTo.0:x :moveTo.0:building @x
+  100 sensor :moveTo.0:y :moveTo.0:building @y
+  101 label *label81
+  102 ucontrol approach :moveTo.0:x :moveTo.0:y 5
+  103 label *label82
+  104 sensor *tmp35 @unit @dead
+  105 sensor *tmp36 @unit @controller
+  106 op notEqual *tmp37 *tmp36 @this
+  107 op or *tmp38 *tmp35 *tmp37
+  108 jump *label83 equal *tmp38 false
+  109 end
+  110 label *label83
+  111 label *label84
+  112 label *label85
+  113 label *label86
+  114 ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp42
+  115 jump *label81 equal *tmp42 false
+  116 label *label87
+  117 label *label88
   118 label *label69
   119 print "Dropping items"
   120 printflush message1
 
   168 jump *label13 always
   169 label *label15
   170 end
-    * label *label3
-    * sensor :moveTo.0:x :moveTo.0:building @x
-    * sensor :moveTo.0:y :moveTo.0:building @y
-    * label *label45
-    * ucontrol approach :moveTo.0:x :moveTo.0:y 5
-    * label *label59
-    * sensor *tmp35 @unit @dead
-    * sensor *tmp36 @unit @controller
-    * op notEqual *tmp37 *tmp36 @this
-    * op or *tmp38 *tmp35 *tmp37
-    * jump *label60 equal *tmp38 false
-    * end
-    * label *label60
-    * label *label61
-    * label *label62
-    * label *label46
-    * ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp42
-    * jump *label45 equal *tmp42 false
-    * label *label47
-    * label *label44
-    * return :moveTo.0*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    36 label *label66
    37 set :moveTo.0:building .core
    38 label *label71
-    * sensor :moveTo.0:x :moveTo.0:building @x
-    * sensor :moveTo.0:y :moveTo.0:building @y
+   39 sensor :moveTo.0:x .core @x
+   40 sensor :moveTo.0:y .core @y
    41 label *label72
    42 ucontrol approach :moveTo.0:x :moveTo.0:y 5
    43 label *label73
 
    96 label *label68
    97 set :moveTo.0:building vault1
    98 label *label80
-    * sensor :moveTo.0:x :moveTo.0:building @x
-    * sensor :moveTo.0:y :moveTo.0:building @y
+   99 sensor :moveTo.0:x vault1 @x
+  100 sensor :moveTo.0:y vault1 @y
   101 label *label81
   102 ucontrol approach :moveTo.0:x :moveTo.0:y 5
   103 label *label82

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    34 print "Moving to core"
    35 printflush message1
    36 label *label66
-    * set :moveTo.0:building .core
    37 label *label71
    38 sensor :moveTo.0:x .core @x
    39 sensor :moveTo.0:y .core @y
 
    93 print "Moving to vault"
    94 printflush message1
    95 label *label68
-    * set :moveTo.0:building vault1
    96 label *label80
    97 sensor :moveTo.0:x vault1 @x
    98 sensor :moveTo.0:y vault1 @y

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    59 set :message.0:text "Taking items"
    60 jump *label23 notEqual :moveItems.0:item null
    61 set :message.0:text "Please select item to transport"
-    * jump *label23 always
    62 label *label23
    63 label *label49
    64 print :message.0:text

Modifications by Final phase, Jump Threading, iteration 1:
 
   137 jump *label31 notEqual *tmp24 false
   138 label *label33
   139 label *label16
-    * jump *label35 equal :findUnit*finished false
+  140 jump *label13 equal :findUnit*finished false
   141 label *label37
   142 wait 1e-15
   143 jump *label37 equal :findUnit*finished false

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
   163 label *label36
   164 label *label14
   165 jump *label13 always
-    * label *label15
-    * end

Final code before resolving virtual instructions:

        label *label4                                                unit-transport.mnd: require "unit-monitor.mnd" remote processor1;
    0:  read *tmp0 processor1 "*mainProcessor"                       ...
    1:  jump *label4 equal *tmp0 null                                ...
    2:  write @this processor1 "*mainProcessor"                      ...
    3:  read :findUnit*address processor1 ":findUnit*address"        ...
        label *label5                                                unit-transport.mnd: linked sorter1, message1;
    4:  jump *label5 equal sorter1 null                              ...
        label *label6                                                ...
    5:  jump *label6 equal message1 null                             ...
        label *label7                                                unit-transport.mnd: linked storage = vault1;
    6:  jump *label7 equal vault1 null                               ...
    7:  print "Initializing..."                                      unit-transport.mnd: print(text);
    8:  printflush message1                                          unit-transport.mnd: printflush(message1);
        label *label9                                                unit-transport.mnd: do
    9:  write null processor1 ":findUnit:currentUnit"                unit-transport.mnd: var unit = findUnit(null);
   10:  set :findUnit*finished false                                 ...
   11:  write :findUnit*address processor1 "@counter"                ...
        label *label12                                               ...
   12:  wait 1e-15                                                   ...
   13:  jump *label12 equal :findUnit*finished false                 ...
   14:  ubind :findUnit*retval                                       unit-transport.mnd: ubind(unit);
   15:  ucontrol flag 1764335678894 0 0 0 0                          unit-transport.mnd: flag(FLAG);
   16:  ulocate building core false @copper 0 0 0 .core              unit-transport.mnd: core = ulocate(:building, :core, false);
   17:  jump *label9 equal .core null                                unit-transport.mnd: do
   18:  write @unit processor1 ":findUnit:currentUnit"               unit-transport.mnd: async(findUnit(@unit));
   19:  set :findUnit*finished false                                 ...
   20:  write :findUnit*address processor1 "@counter"                ...
        label *label13                                               unit-transport.mnd: while true do
   21:  sensor :moveItems.0:capacity @unit @itemCapacity             unit-transport.mnd: var capacity = @unit.@itemCapacity;
   22:  print "Moving to core"                                       unit-transport.mnd: print(text);
   23:  printflush message1                                          unit-transport.mnd: printflush(message1);
   24:  sensor :moveTo.0:x .core @x                                  unit-transport.mnd: var x = building.@x;
   25:  sensor :moveTo.0:y .core @y                                  unit-transport.mnd: var y = building.@y;
        label *label72                                               unit-transport.mnd: do
   26:  ucontrol approach :moveTo.0:x :moveTo.0:y 5 0 0              unit-transport.mnd: approach(x, y, 5);
   27:  sensor *tmp35 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   28:  sensor *tmp36 @unit @controller                              ...
   29:  op notEqual *tmp37 *tmp36 @this                              ...
   30:  op or *tmp38 *tmp35 *tmp37                                   ...
   31:  jump *label74 equal *tmp38 false                             ...
   32:  end                                                          unit-transport.mnd: end();
        label *label74                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   33:  ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp42 0           unit-transport.mnd: while !within(x, y, 5);
   34:  jump *label72 equal *tmp42 false                             unit-transport.mnd: do
        label *label19                                               unit-transport.mnd: do
   35:  sensor :moveItems.0:item sorter1 @config                     unit-transport.mnd: item = sorter1.@config;
   36:  set :message.0:text "Taking items"                           unit-transport.mnd: message(item == null ? "Please select item to transport" : "Taking items");
   37:  jump *label23 notEqual :moveItems.0:item null                ...
   38:  set :message.0:text "Please select item to transport"        ...
        label *label23                                               ...
   39:  print :message.0:text                                        unit-transport.mnd: print(text);
   40:  printflush message1                                          unit-transport.mnd: printflush(message1);
   41:  sensor *tmp12 @unit @firstItem                               unit-transport.mnd: if @unit.@firstItem != null and @unit.@firstItem != item then
   42:  op notEqual *tmp13 *tmp12 null                               ...
   43:  sensor *tmp14 @unit @firstItem                               ...
   44:  op notEqual *tmp15 *tmp14 :moveItems.0:item                  ...
   45:  op land *tmp16 *tmp13 *tmp15                                 ...
   46:  jump *label25 equal *tmp16 false                             ...
   47:  ucontrol itemDrop @air :moveItems.0:capacity 0 0 0           unit-transport.mnd: itemDrop(@air, capacity);
        label *label25                                               unit-transport.mnd: if @unit.@firstItem != null and @unit.@firstItem != item then
   48:  ucontrol itemTake .core :moveItems.0:item :moveItems.0:capac unit-transport.mnd: itemTake(core, item, capacity);
   49:  sensor *tmp35 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   50:  sensor *tmp36 @unit @controller                              ...
   51:  op notEqual *tmp37 *tmp36 @this                              ...
   52:  op or *tmp38 *tmp35 *tmp37                                   ...
   53:  jump *label52 equal *tmp38 false                             ...
   54:  end                                                          unit-transport.mnd: end();
        label *label52                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   55:  sensor *tmp18 @unit @totalItems                              unit-transport.mnd: while @unit.@totalItems != capacity;
   56:  jump *label19 notEqual *tmp18 :moveItems.0:capacity          unit-transport.mnd: do
   57:  print "Moving to vault"                                      unit-transport.mnd: print(text);
   58:  printflush message1                                          unit-transport.mnd: printflush(message1);
   59:  sensor :moveTo.0:x vault1 @x                                 unit-transport.mnd: var x = building.@x;
   60:  sensor :moveTo.0:y vault1 @y                                 unit-transport.mnd: var y = building.@y;
        label *label81                                               unit-transport.mnd: do
   61:  ucontrol approach :moveTo.0:x :moveTo.0:y 5 0 0              unit-transport.mnd: approach(x, y, 5);
   62:  sensor *tmp35 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   63:  sensor *tmp36 @unit @controller                              ...
   64:  op notEqual *tmp37 *tmp36 @this                              ...
   65:  op or *tmp38 *tmp35 *tmp37                                   ...
   66:  jump *label83 equal *tmp38 false                             ...
   67:  end                                                          unit-transport.mnd: end();
        label *label83                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   68:  ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp42 0           unit-transport.mnd: while !within(x, y, 5);
   69:  jump *label81 equal *tmp42 false                             unit-transport.mnd: do
   70:  print "Dropping items"                                       unit-transport.mnd: print(text);
   71:  printflush message1                                          unit-transport.mnd: printflush(message1);
        label *label31                                               unit-transport.mnd: do
   72:  ucontrol itemDrop vault1 :moveItems.0:capacity 0 0 0         unit-transport.mnd: itemDrop(storage, capacity);
   73:  sensor *tmp35 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   74:  sensor *tmp36 @unit @controller                              ...
   75:  op notEqual *tmp37 *tmp36 @this                              ...
   76:  op or *tmp38 *tmp35 *tmp37                                   ...
   77:  jump *label56 equal *tmp38 false                             ...
   78:  end                                                          unit-transport.mnd: end();
        label *label56                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   79:  sensor *tmp20 sorter1 @config                                unit-transport.mnd: while item == sorter1.@config and @unit.@totalItems > 0;
   80:  op equal *tmp21 :moveItems.0:item *tmp20                     ...
   81:  sensor *tmp22 @unit @totalItems                              ...
   82:  op greaterThan *tmp23 *tmp22 0                               ...
   83:  op land *tmp24 *tmp21 *tmp23                                 ...
   84:  jump *label31 notEqual *tmp24 false                          unit-transport.mnd: do
   85:  jump *label13 equal :findUnit*finished false                 unit-transport.mnd: if finished(findUnit) then
        label *label37                                               unit-transport.mnd: var unit = await(findUnit);
   86:  wait 1e-15                                                   ...
   87:  jump *label37 equal :findUnit*finished false                 ...
   88:  sensor *tmp26 :findUnit*retval @dead                         unit-transport.mnd: if !unit.@dead and (unit.@controller == processor1 or !unit.@controlled) then
   89:  op equal *tmp27 *tmp26 false                                 ...
   90:  sensor *tmp28 :findUnit*retval @controller                   ...
   91:  op equal *tmp29 *tmp28 processor1                            ...
   92:  sensor *tmp30 :findUnit*retval @controlled                   ...
   93:  op equal *tmp31 *tmp30 false                                 ...
   94:  op or *tmp32 *tmp29 *tmp31                                   ...
   95:  op land *tmp33 *tmp27 *tmp32                                 ...
   96:  jump *label38 equal *tmp33 false                             ...
   97:  ucontrol flag null 0 0 0 0                                   unit-transport.mnd: flag(null);
   98:  ucontrol unbind 0 0 0 0 0                                    unit-transport.mnd: unbind();
   99:  ubind :findUnit*retval                                       unit-transport.mnd: ubind(unit);
  100:  ucontrol flag 1764335678894 0 0 0 0                          unit-transport.mnd: flag(FLAG);
        label *label38                                               unit-transport.mnd: if !unit.@dead and (unit.@controller == processor1 or !unit.@controlled) then
  101:  write @unit processor1 ":findUnit:currentUnit"               unit-transport.mnd: async(findUnit(@unit));
  102:  set :findUnit*finished false                                 ...
  103:  write :findUnit*address processor1 "@counter"                ...
  104:  jump *label13 always 0 0                                     unit-transport.mnd: while true do


Performance: parsed in 175 ms, compiled in 218 ms, optimized in 239 ms, run in 7 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (1 steps):
The program didn't generate any output.
Execution exception at instruction 0: read *tmp0 processor1 "*mainProcessor":
Variable 'processor1' is not an object.
(Use the '#set err-not-an-object = false;' directive or the '--err-not-an-object false' command line option to ignore this exception.)
