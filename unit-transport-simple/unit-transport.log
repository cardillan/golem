   121 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination.
     6 instructions eliminated by Dead Code Elimination (3 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     4 instructions eliminated by Jump Optimization (4 iterations).
     4 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     1 instructions eliminated by If Expression Optimization (3 iterations).
     8 instructions eliminated by Data Flow Optimization (3 passes, 13 iterations).
     5 instructions added by Function Inlining (7 iterations).
    10 function calls inlined by Function Inlining.
     1 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination.
    95 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 902):
    Inline function 'message' defined at unit-transport.mnd:47:1 cost     3, benefit     2453.5, efficiency      817.8
    Inline function 'checkUnit' defined at unit-transport.mnd:53:1 cost     9, benefit     7500.0, efficiency      833.3
    Inline function 'moveTo' defined at unit-transport.mnd:60:1  cost     5, benefit      175.0, efficiency       35.0
    Inline function call at unit-transport.mnd:14:5              cost     1, benefit        3.5, efficiency        3.5
    Inline function call at unit-transport.mnd:74:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:75:5              cost     6, benefit       87.5, efficiency       14.6
  * Inline function call at unit-transport.mnd:79:9              cost     1, benefit     2187.5, efficiency     2187.5 (+0 instructions)
    Inline function call at unit-transport.mnd:87:9              cost     5, benefit     1875.0, efficiency      375.0
    Inline function call at unit-transport.mnd:90:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:91:5              cost     6, benefit       87.5, efficiency       14.6
    Inline function call at unit-transport.mnd:95:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:98:9              cost     5, benefit     1875.0, efficiency      375.0
    Inline function call at unit-transport.mnd:65:9              cost     5, benefit     3750.0, efficiency      750.0

Pass 1: speed optimization selection (cost limit 902):
    Inline function 'message' defined at unit-transport.mnd:47:1 cost     2, benefit      266.0, efficiency      133.0
  * Inline function 'checkUnit' defined at unit-transport.mnd:53:1 cost     9, benefit     7500.0, efficiency      833.3 (+4 instructions)
    Inline function 'moveTo' defined at unit-transport.mnd:60:1  cost     5, benefit      175.0, efficiency       35.0
    Inline function call at unit-transport.mnd:14:5              cost     1, benefit        3.5, efficiency        3.5
    Inline function call at unit-transport.mnd:74:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:75:5              cost     6, benefit       87.5, efficiency       14.6
    Inline function call at unit-transport.mnd:87:9              cost     5, benefit     1875.0, efficiency      375.0
    Inline function call at unit-transport.mnd:90:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:91:5              cost     6, benefit       87.5, efficiency       14.6
    Inline function call at unit-transport.mnd:95:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:98:9              cost     5, benefit     1875.0, efficiency      375.0
    Inline function call at unit-transport.mnd:65:9              cost     5, benefit     3750.0, efficiency      750.0

Pass 1: speed optimization selection (cost limit 898):
  * Inline function 'message' defined at unit-transport.mnd:47:1 cost     2, benefit      266.0, efficiency      133.0 (-8 instructions)
    Inline function 'moveTo' defined at unit-transport.mnd:60:1  cost     9, benefit      175.0, efficiency       19.4
    Inline function call at unit-transport.mnd:14:5              cost     1, benefit        3.5, efficiency        3.5
    Inline function call at unit-transport.mnd:74:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:75:5              cost    10, benefit       87.5, efficiency        8.8
    Inline function call at unit-transport.mnd:90:5              cost     1, benefit       87.5, efficiency       87.5
    Inline function call at unit-transport.mnd:91:5              cost    10, benefit       87.5, efficiency        8.8
    Inline function call at unit-transport.mnd:95:5              cost     1, benefit       87.5, efficiency       87.5

Pass 1: speed optimization selection (cost limit 906):
  * Inline function 'moveTo' defined at unit-transport.mnd:60:1  cost     9, benefit      175.0, efficiency       19.4 (+3 instructions)
    Inline function call at unit-transport.mnd:75:5              cost    10, benefit       87.5, efficiency        8.8
    Inline function call at unit-transport.mnd:91:5              cost    10, benefit       87.5, efficiency        8.8

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-6 instructions):
 
    67 op land *tmp16 *tmp13 *tmp15
    68 jump *label26 equal *tmp16 false
    69 ucontrol itemDrop @air :moveItems.0:capacity
-    * set *tmp17 null
    70 jump *label27 always
    71 label *label26
-    * set *tmp17 null
    72 label *label27
    73 ucontrol itemTake .core :moveItems.0:item :moveItems.0:capacity
    74 setaddr :checkUnit.0*retaddr *label28
 
   115 write @unit processor1 ":findUnit:currentUnit"
   116 set :findUnit*finished false
   117 write :findUnit*address processor1 "@counter"
-    * set *tmp25 null
   118 jump *label37 always
   119 label *label36
-    * set *tmp25 null
   120 label *label37
   121 label *label15
   122 jump *label14 always
 
   135 op or *tmp29 *tmp26 *tmp28
   136 jump *label41 equal *tmp29 false
   137 end
-    * set *tmp30 null
   138 jump *label42 always
   139 label *label41
-    * set *tmp30 null
   140 label *label42
   141 label *label40
   142 return :checkUnit.0*retaddr

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
    21 label *label13
    22 wait 1e-15
    23 jump *label13 equal :findUnit*finished false
-    * set *tmp2 :findUnit*retval
-    * set :unit *tmp2
+   24 set :unit :findUnit*retval
    25 ubind :unit
    26 ucontrol flag 1764335678894
-    * ulocate building core false @copper *tmp4 *tmp5 *tmp6 *tmp3
-    * set .core *tmp3
+   27 ulocate building core false @copper 0 0 0 .core
    28 label *label11
    29 op equal *tmp7 .core null
    30 jump *label10 notEqual *tmp7 false
 
    34 write :findUnit*address processor1 "@counter"
    35 label *label14
    36 jump *label16 equal true false
-    * sensor *tmp8 @unit @itemCapacity
-    * set :moveItems.0:capacity *tmp8
+   37 sensor :moveItems.0:capacity @unit @itemCapacity
    38 set :message.0:text "Moving to core"
    39 setaddr :message.0*retaddr *label18
    40 call *label1 :message.0*retval
 
    44 call *label3 :moveTo.0*retval
    45 label *label19
    46 label *label20
-    * sensor *tmp9 sorter1 @config
-    * set :moveItems.0:item *tmp9
+   47 sensor :moveItems.0:item sorter1 @config
    48 op equal *tmp10 :moveItems.0:item null
    49 jump *label23 equal *tmp10 false
    50 set *tmp11 "Please select item to transport"
 
   138 return :checkUnit.0*retaddr
   139 end
   140 label *label3
-    * sensor *tmp31 :moveTo.0:building @x
-    * set :moveTo.0:x *tmp31
-    * sensor *tmp32 :moveTo.0:building @y
-    * set :moveTo.0:y *tmp32
+  141 sensor :moveTo.0:x :moveTo.0:building @x
+  142 sensor :moveTo.0:y :moveTo.0:building @y
   143 label *label44
   144 ucontrol approach :moveTo.0:x :moveTo.0:y 3
   145 setaddr :checkUnit.0*retaddr *label47

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    33 set :findUnit*finished false
    34 write :findUnit*address processor1 "@counter"
    35 label *label14
-    * jump *label16 equal true false
    36 sensor :moveItems.0:capacity @unit @itemCapacity
    37 set :message.0:text "Moving to core"
    38 setaddr :message.0*retaddr *label18

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-4 instructions):
 
    26 ucontrol flag 1764335678894
    27 ulocate building core false @copper 0 0 0 .core
    28 label *label11
-    * op equal *tmp7 .core null
-    * jump *label10 notEqual *tmp7 false
+   29 jump *label10 equal .core null
    30 label *label12
    31 write @unit processor1 ":findUnit:currentUnit"
    32 set :findUnit*finished false
 
    43 label *label19
    44 label *label20
    45 sensor :moveItems.0:item sorter1 @config
-    * op equal *tmp10 :moveItems.0:item null
-    * jump *label23 equal *tmp10 false
+   46 jump *label23 notEqual :moveItems.0:item null
    47 set *tmp11 "Please select item to transport"
    48 jump *label24 always
    49 label *label23
 
    69 label *label28
    70 label *label21
    71 sensor *tmp18 @unit @totalItems
-    * op notEqual *tmp19 *tmp18 :moveItems.0:capacity
-    * jump *label20 notEqual *tmp19 false
+   72 jump *label20 notEqual *tmp18 :moveItems.0:capacity
    73 label *label22
    74 set :message.0:text "Moving to vault"
    75 setaddr :message.0*retaddr *label29
 
   143 label *label47
   144 label *label45
   145 ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp33
-    * op equal *tmp34 *tmp33 false
-    * jump *label44 notEqual *tmp34 false
+  146 jump *label44 equal *tmp33 false
   147 label *label46
   148 label *label43
   149 return :moveTo.0*retaddr

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-3 instructions):
 
    60 op land *tmp16 *tmp13 *tmp15
    61 jump *label26 equal *tmp16 false
    62 ucontrol itemDrop @air :moveItems.0:capacity
-    * jump *label27 always
    63 label *label26
    64 label *label27
    65 ucontrol itemTake .core :moveItems.0:item :moveItems.0:capacity
 
   106 write @unit processor1 ":findUnit:currentUnit"
   107 set :findUnit*finished false
   108 write :findUnit*address processor1 "@counter"
-    * jump *label37 always
   109 label *label36
   110 label *label37
   111 label *label15
 
   125 op or *tmp29 *tmp26 *tmp28
   126 jump *label41 equal *tmp29 false
   127 end
-    * jump *label42 always
   128 label *label41
   129 label *label42
   130 label *label40

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    22 wait 1e-15
    23 jump *label13 equal :findUnit*finished false
    24 set :unit :findUnit*retval
-    * ubind :unit
+   25 ubind :findUnit*retval
    26 ucontrol flag 1764335678894
    27 ulocate building core false @copper 0 0 0 .core
    28 label *label11
 
   101 wait 1e-15
   102 jump *label38 equal :findUnit*finished false
   103 set :unit.1 :findUnit*retval
-    * ubind :unit.1
+  104 ubind :findUnit*retval
   105 ucontrol flag 1764335678894
   106 write @unit processor1 ":findUnit:currentUnit"
   107 set :findUnit*finished false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    21 label *label13
    22 wait 1e-15
    23 jump *label13 equal :findUnit*finished false
-    * set :unit :findUnit*retval
    24 ubind :findUnit*retval
    25 ucontrol flag 1764335678894
    26 ulocate building core false @copper 0 0 0 .core
 
    99 label *label38
   100 wait 1e-15
   101 jump *label38 equal :findUnit*finished false
-    * set :unit.1 :findUnit*retval
   102 ubind :findUnit*retval
   103 ucontrol flag 1764335678894
   104 write @unit processor1 ":findUnit:currentUnit"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    42 label *label19
    43 label *label20
    44 sensor :moveItems.0:item sorter1 @config
-    * jump *label23 notEqual :moveItems.0:item null
-    * set *tmp11 "Please select item to transport"
+   45 set :message.0:text "Taking items"
+   46 jump *label24 notEqual :moveItems.0:item null
+   47 set :message.0:text "Please select item to transport"
    48 jump *label24 always
-    * label *label23
-    * set *tmp11 "Taking items"
    49 label *label24
-    * set :message.0:text *tmp11
    50 setaddr :message.0*retaddr *label25
    51 call *label1 :message.0*retval
    52 label *label25

Modifications by Inline function call at unit-transport.mnd:79:9:
 
    47 set :message.0:text "Please select item to transport"
    48 jump *label24 always
    49 label *label24
-    * setaddr :message.0*retaddr *label25
-    * call *label1 :message.0*retval
-    * label *label25
+   50 label *label48
+   51 print :message.0:text
+   52 printflush message1
+   53 label *label49
    54 sensor *tmp12 @unit @firstItem
    55 op notEqual *tmp13 *tmp12 null
    56 sensor *tmp14 @unit @firstItem

Modifications by Inline function 'checkUnit' defined at unit-transport.mnd:53:1 (+4 instructions):
 
    61 label *label26
    62 label *label27
    63 ucontrol itemTake .core :moveItems.0:item :moveItems.0:capacity
-    * setaddr :checkUnit.0*retaddr *label28
-    * call *label2 :checkUnit.0*retval
-    * label *label28
+   64 label *label50
+   65 sensor *tmp26 @unit @dead
+   66 sensor *tmp27 @unit @controller
+   67 op notEqual *tmp28 *tmp27 @this
+   68 op or *tmp29 *tmp26 *tmp28
+   69 jump *label51 equal *tmp29 false
+   70 end
+   71 label *label51
+   72 label *label52
+   73 label *label53
    74 label *label21
    75 sensor *tmp18 @unit @totalItems
    76 jump *label20 notEqual *tmp18 :moveItems.0:capacity
 
    89 label *label31
    90 label *label32
    91 ucontrol itemDrop vault1 :moveItems.0:capacity
-    * setaddr :checkUnit.0*retaddr *label35
-    * call *label2 :checkUnit.0*retval
-    * label *label35
+   92 label *label54
+   93 sensor *tmp26 @unit @dead
+   94 sensor *tmp27 @unit @controller
+   95 op notEqual *tmp28 *tmp27 @this
+   96 op or *tmp29 *tmp26 *tmp28
+   97 jump *label55 equal *tmp29 false
+   98 end
+   99 label *label55
+  100 label *label56
+  101 label *label57
   102 label *label33
   103 sensor *tmp20 sorter1 @config
   104 op equal *tmp21 :moveItems.0:item *tmp20
 
   129 label *label39
   130 return :message.0*retaddr
   131 end
-    * label *label2
-    * sensor *tmp26 @unit @dead
-    * sensor *tmp27 @unit @controller
-    * op notEqual *tmp28 *tmp27 @this
-    * op or *tmp29 *tmp26 *tmp28
-    * jump *label41 equal *tmp29 false
-    * end
-    * label *label41
-    * label *label42
-    * label *label40
-    * return :checkUnit.0*retaddr
-    * end
   132 label *label3
   133 sensor :moveTo.0:x :moveTo.0:building @x
   134 sensor :moveTo.0:y :moveTo.0:building @y
   135 label *label44
   136 ucontrol approach :moveTo.0:x :moveTo.0:y 3
-    * setaddr :checkUnit.0*retaddr *label47
-    * call *label2 :checkUnit.0*retval
-    * label *label47
+  137 label *label58
+  138 sensor *tmp26 @unit @dead
+  139 sensor *tmp27 @unit @controller
+  140 op notEqual *tmp28 *tmp27 @this
+  141 op or *tmp29 *tmp26 *tmp28
+  142 jump *label59 equal *tmp29 false
+  143 end
+  144 label *label59
+  145 label *label60
+  146 label *label61
   147 label *label45
   148 ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp33
   149 jump *label44 equal *tmp33 false

Modifications by Inline function 'message' defined at unit-transport.mnd:47:1 (-4 instructions):
 
    11 label *label8
    12 jump *label8 equal vault1 null
    13 set :message.0:text "Initializing..."
-    * setaddr :message.0*retaddr *label9
-    * call *label1 :message.0*retval
-    * label *label9
+   14 label *label62
+   15 print :message.0:text
+   16 printflush message1
+   17 label *label63
    18 label *label10
    19 write null processor1 ":findUnit:currentUnit"
    20 set :findUnit*finished false
 
    34 label *label14
    35 sensor :moveItems.0:capacity @unit @itemCapacity
    36 set :message.0:text "Moving to core"
-    * setaddr :message.0*retaddr *label18
-    * call *label1 :message.0*retval
-    * label *label18
+   37 label *label64
+   38 print :message.0:text
+   39 printflush message1
+   40 label *label65
    41 set :moveTo.0:building .core
    42 setaddr :moveTo.0*retaddr *label19
    43 call *label3 :moveTo.0*retval
 
    78 jump *label20 notEqual *tmp18 :moveItems.0:capacity
    79 label *label22
    80 set :message.0:text "Moving to vault"
-    * setaddr :message.0*retaddr *label29
-    * call *label1 :message.0*retval
-    * label *label29
+   81 label *label66
+   82 print :message.0:text
+   83 printflush message1
+   84 label *label67
    85 set :moveTo.0:building vault1
    86 setaddr :moveTo.0*retaddr *label30
    87 call *label3 :moveTo.0*retval
    88 label *label30
    89 set :message.0:text "Dropping items"
-    * setaddr :message.0*retaddr *label31
-    * call *label1 :message.0*retval
-    * label *label31
+   90 label *label68
+   91 print :message.0:text
+   92 printflush message1
+   93 label *label69
    94 label *label32
    95 ucontrol itemDrop vault1 :moveItems.0:capacity
    96 label *label54
 
   127 jump *label14 always
   128 label *label16
   129 end
-    * label *label1
-    * print :message.0:text
-    * printflush message1
-    * label *label39
-    * return :message.0*retaddr
-    * end
   130 label *label3
   131 sensor :moveTo.0:x :moveTo.0:building @x
   132 sensor :moveTo.0:y :moveTo.0:building @y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    12 jump *label8 equal vault1 null
    13 set :message.0:text "Initializing..."
    14 label *label62
-    * print :message.0:text
+   15 print "Initializing..."
    16 printflush message1
    17 label *label63
    18 label *label10
 
    35 sensor :moveItems.0:capacity @unit @itemCapacity
    36 set :message.0:text "Moving to core"
    37 label *label64
-    * print :message.0:text
+   38 print "Moving to core"
    39 printflush message1
    40 label *label65
    41 set :moveTo.0:building .core
 
    79 label *label22
    80 set :message.0:text "Moving to vault"
    81 label *label66
-    * print :message.0:text
+   82 print "Moving to vault"
    83 printflush message1
    84 label *label67
    85 set :moveTo.0:building vault1
 
    88 label *label30
    89 set :message.0:text "Dropping items"
    90 label *label68
-    * print :message.0:text
+   91 print "Dropping items"
    92 printflush message1
    93 label *label69
    94 label *label32

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    10 jump *label7 equal message1 null
    11 label *label8
    12 jump *label8 equal vault1 null
-    * set :message.0:text "Initializing..."
    13 label *label62
    14 print "Initializing..."
    15 printflush message1
 
    32 write :findUnit*address processor1 "@counter"
    33 label *label14
    34 sensor :moveItems.0:capacity @unit @itemCapacity
-    * set :message.0:text "Moving to core"
    35 label *label64
    36 print "Moving to core"
    37 printflush message1
 
    75 sensor *tmp18 @unit @totalItems
    76 jump *label20 notEqual *tmp18 :moveItems.0:capacity
    77 label *label22
-    * set :message.0:text "Moving to vault"
    78 label *label66
    79 print "Moving to vault"
    80 printflush message1
 
    83 setaddr :moveTo.0*retaddr *label30
    84 call *label3 :moveTo.0*retval
    85 label *label30
-    * set :message.0:text "Dropping items"
    86 label *label68
    87 print "Dropping items"
    88 printflush message1

Modifications by Inline function 'moveTo' defined at unit-transport.mnd:60:1 (+5 instructions):
 
    37 printflush message1
    38 label *label65
    39 set :moveTo.0:building .core
-    * setaddr :moveTo.0*retaddr *label19
-    * call *label3 :moveTo.0*retval
-    * label *label19
+   40 label *label70
+   41 sensor :moveTo.0:x :moveTo.0:building @x
+   42 sensor :moveTo.0:y :moveTo.0:building @y
+   43 label *label71
+   44 ucontrol approach :moveTo.0:x :moveTo.0:y 3
+   45 label *label72
+   46 sensor *tmp26 @unit @dead
+   47 sensor *tmp27 @unit @controller
+   48 op notEqual *tmp28 *tmp27 @this
+   49 op or *tmp29 *tmp26 *tmp28
+   50 jump *label73 equal *tmp29 false
+   51 end
+   52 label *label73
+   53 label *label74
+   54 label *label75
+   55 label *label76
+   56 ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp33
+   57 jump *label71 equal *tmp33 false
+   58 label *label77
+   59 label *label78
    60 label *label20
    61 sensor :moveItems.0:item sorter1 @config
    62 set :message.0:text "Taking items"
 
    97 printflush message1
    98 label *label67
    99 set :moveTo.0:building vault1
-    * setaddr :moveTo.0*retaddr *label30
-    * call *label3 :moveTo.0*retval
-    * label *label30
+  100 label *label79
+  101 sensor :moveTo.0:x :moveTo.0:building @x
+  102 sensor :moveTo.0:y :moveTo.0:building @y
+  103 label *label80
+  104 ucontrol approach :moveTo.0:x :moveTo.0:y 3
+  105 label *label81
+  106 sensor *tmp26 @unit @dead
+  107 sensor *tmp27 @unit @controller
+  108 op notEqual *tmp28 *tmp27 @this
+  109 op or *tmp29 *tmp26 *tmp28
+  110 jump *label82 equal *tmp29 false
+  111 end
+  112 label *label82
+  113 label *label83
+  114 label *label84
+  115 label *label85
+  116 ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp33
+  117 jump *label80 equal *tmp33 false
+  118 label *label86
+  119 label *label87
   120 label *label68
   121 print "Dropping items"
   122 printflush message1
 
   157 jump *label14 always
   158 label *label16
   159 end
-    * label *label3
-    * sensor :moveTo.0:x :moveTo.0:building @x
-    * sensor :moveTo.0:y :moveTo.0:building @y
-    * label *label44
-    * ucontrol approach :moveTo.0:x :moveTo.0:y 3
-    * label *label58
-    * sensor *tmp26 @unit @dead
-    * sensor *tmp27 @unit @controller
-    * op notEqual *tmp28 *tmp27 @this
-    * op or *tmp29 *tmp26 *tmp28
-    * jump *label59 equal *tmp29 false
-    * end
-    * label *label59
-    * label *label60
-    * label *label61
-    * label *label45
-    * ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp33
-    * jump *label44 equal *tmp33 false
-    * label *label46
-    * label *label43
-    * return :moveTo.0*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    38 label *label65
    39 set :moveTo.0:building .core
    40 label *label70
-    * sensor :moveTo.0:x :moveTo.0:building @x
-    * sensor :moveTo.0:y :moveTo.0:building @y
+   41 sensor :moveTo.0:x .core @x
+   42 sensor :moveTo.0:y .core @y
    43 label *label71
    44 ucontrol approach :moveTo.0:x :moveTo.0:y 3
    45 label *label72
 
    98 label *label67
    99 set :moveTo.0:building vault1
   100 label *label79
-    * sensor :moveTo.0:x :moveTo.0:building @x
-    * sensor :moveTo.0:y :moveTo.0:building @y
+  101 sensor :moveTo.0:x vault1 @x
+  102 sensor :moveTo.0:y vault1 @y
   103 label *label80
   104 ucontrol approach :moveTo.0:x :moveTo.0:y 3
   105 label *label81

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    36 print "Moving to core"
    37 printflush message1
    38 label *label65
-    * set :moveTo.0:building .core
    39 label *label70
    40 sensor :moveTo.0:x .core @x
    41 sensor :moveTo.0:y .core @y
 
    95 print "Moving to vault"
    96 printflush message1
    97 label *label67
-    * set :moveTo.0:building vault1
    98 label *label79
    99 sensor :moveTo.0:x vault1 @x
   100 sensor :moveTo.0:y vault1 @y

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    61 set :message.0:text "Taking items"
    62 jump *label24 notEqual :moveItems.0:item null
    63 set :message.0:text "Please select item to transport"
-    * jump *label24 always
    64 label *label24
    65 label *label48
    66 print :message.0:text

Modifications by Final phase, Jump Threading, iteration 1:
 
   139 jump *label32 notEqual *tmp24 false
   140 label *label34
   141 label *label17
-    * jump *label36 equal :findUnit*finished false
+  142 jump *label14 equal :findUnit*finished false
   143 label *label38
   144 wait 1e-15
   145 jump *label38 equal :findUnit*finished false

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
   152 label *label37
   153 label *label15
   154 jump *label14 always
-    * label *label16
-    * end

Final code before resolving virtual instructions:

        label *label4                                                unit-transport.mnd: require "unit-monitor.mnd" remote processor1;
    0:  read *tmp0 processor1 "*mainProcessor"                       ...
    1:  jump *label4 equal *tmp0 null                                ...
    2:  write @this processor1 "*mainProcessor"                      ...
    3:  read :findUnit*address processor1 ":findUnit*address"        ...
        label *label5                                                unit-transport.mnd: linked switch1, sorter1, message1;
    4:  jump *label5 equal switch1 null                              ...
        label *label6                                                ...
    5:  jump *label6 equal sorter1 null                              ...
        label *label7                                                ...
    6:  jump *label7 equal message1 null                             ...
        label *label8                                                unit-transport.mnd: linked storage = vault1;
    7:  jump *label8 equal vault1 null                               ...
    8:  print "Initializing..."                                      unit-transport.mnd: print(text);
    9:  printflush message1                                          unit-transport.mnd: printflush(message1);
        label *label10                                               unit-transport.mnd: do
   10:  write null processor1 ":findUnit:currentUnit"                unit-transport.mnd: var unit = findUnit(null);
   11:  set :findUnit*finished false                                 ...
   12:  write :findUnit*address processor1 "@counter"                ...
        label *label13                                               ...
   13:  wait 1e-15                                                   ...
   14:  jump *label13 equal :findUnit*finished false                 ...
   15:  ubind :findUnit*retval                                       unit-transport.mnd: ubind(unit);
   16:  ucontrol flag 1764335678894 0 0 0 0                          unit-transport.mnd: flag(1764335678894);
   17:  ulocate building core false @copper 0 0 0 .core              unit-transport.mnd: core = ulocate(:building, :core, false);
   18:  jump *label10 equal .core null                               unit-transport.mnd: do
   19:  write @unit processor1 ":findUnit:currentUnit"               unit-transport.mnd: async(findUnit(@unit));
   20:  set :findUnit*finished false                                 ...
   21:  write :findUnit*address processor1 "@counter"                ...
        label *label14                                               unit-transport.mnd: while true do
   22:  sensor :moveItems.0:capacity @unit @itemCapacity             unit-transport.mnd: var capacity = @unit.@itemCapacity;
   23:  print "Moving to core"                                       unit-transport.mnd: print(text);
   24:  printflush message1                                          unit-transport.mnd: printflush(message1);
   25:  sensor :moveTo.0:x .core @x                                  unit-transport.mnd: var x = building.@x;
   26:  sensor :moveTo.0:y .core @y                                  unit-transport.mnd: var y = building.@y;
        label *label71                                               unit-transport.mnd: do
   27:  ucontrol approach :moveTo.0:x :moveTo.0:y 3 0 0              unit-transport.mnd: approach(x, y, 3);
   28:  sensor *tmp26 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   29:  sensor *tmp27 @unit @controller                              ...
   30:  op notEqual *tmp28 *tmp27 @this                              ...
   31:  op or *tmp29 *tmp26 *tmp28                                   ...
   32:  jump *label73 equal *tmp29 false                             ...
   33:  end                                                          unit-transport.mnd: end();
        label *label73                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   34:  ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp33 0           unit-transport.mnd: while !within(x, y, 5);
   35:  jump *label71 equal *tmp33 false                             unit-transport.mnd: do
        label *label20                                               unit-transport.mnd: do
   36:  sensor :moveItems.0:item sorter1 @config                     unit-transport.mnd: item = sorter1.@config;
   37:  set :message.0:text "Taking items"                           unit-transport.mnd: message(item == null ? "Please select item to transport" : "Taking items");
   38:  jump *label24 notEqual :moveItems.0:item null                ...
   39:  set :message.0:text "Please select item to transport"        ...
        label *label24                                               ...
   40:  print :message.0:text                                        unit-transport.mnd: print(text);
   41:  printflush message1                                          unit-transport.mnd: printflush(message1);
   42:  sensor *tmp12 @unit @firstItem                               unit-transport.mnd: if @unit.@firstItem != null and @unit.@firstItem != item then
   43:  op notEqual *tmp13 *tmp12 null                               ...
   44:  sensor *tmp14 @unit @firstItem                               ...
   45:  op notEqual *tmp15 *tmp14 :moveItems.0:item                  ...
   46:  op land *tmp16 *tmp13 *tmp15                                 ...
   47:  jump *label26 equal *tmp16 false                             ...
   48:  ucontrol itemDrop @air :moveItems.0:capacity 0 0 0           unit-transport.mnd: itemDrop(@air, capacity);
        label *label26                                               unit-transport.mnd: if @unit.@firstItem != null and @unit.@firstItem != item then
   49:  ucontrol itemTake .core :moveItems.0:item :moveItems.0:capac unit-transport.mnd: itemTake(core, item, capacity);
   50:  sensor *tmp26 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   51:  sensor *tmp27 @unit @controller                              ...
   52:  op notEqual *tmp28 *tmp27 @this                              ...
   53:  op or *tmp29 *tmp26 *tmp28                                   ...
   54:  jump *label51 equal *tmp29 false                             ...
   55:  end                                                          unit-transport.mnd: end();
        label *label51                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   56:  sensor *tmp18 @unit @totalItems                              unit-transport.mnd: while @unit.@totalItems != capacity;
   57:  jump *label20 notEqual *tmp18 :moveItems.0:capacity          unit-transport.mnd: do
   58:  print "Moving to vault"                                      unit-transport.mnd: print(text);
   59:  printflush message1                                          unit-transport.mnd: printflush(message1);
   60:  sensor :moveTo.0:x vault1 @x                                 unit-transport.mnd: var x = building.@x;
   61:  sensor :moveTo.0:y vault1 @y                                 unit-transport.mnd: var y = building.@y;
        label *label80                                               unit-transport.mnd: do
   62:  ucontrol approach :moveTo.0:x :moveTo.0:y 3 0 0              unit-transport.mnd: approach(x, y, 3);
   63:  sensor *tmp26 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   64:  sensor *tmp27 @unit @controller                              ...
   65:  op notEqual *tmp28 *tmp27 @this                              ...
   66:  op or *tmp29 *tmp26 *tmp28                                   ...
   67:  jump *label82 equal *tmp29 false                             ...
   68:  end                                                          unit-transport.mnd: end();
        label *label82                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   69:  ucontrol within :moveTo.0:x :moveTo.0:y 5 *tmp33 0           unit-transport.mnd: while !within(x, y, 5);
   70:  jump *label80 equal *tmp33 false                             unit-transport.mnd: do
   71:  print "Dropping items"                                       unit-transport.mnd: print(text);
   72:  printflush message1                                          unit-transport.mnd: printflush(message1);
        label *label32                                               unit-transport.mnd: do
   73:  ucontrol itemDrop vault1 :moveItems.0:capacity 0 0 0         unit-transport.mnd: itemDrop(storage, capacity);
   74:  sensor *tmp26 @unit @dead                                    unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   75:  sensor *tmp27 @unit @controller                              ...
   76:  op notEqual *tmp28 *tmp27 @this                              ...
   77:  op or *tmp29 *tmp26 *tmp28                                   ...
   78:  jump *label55 equal *tmp29 false                             ...
   79:  end                                                          unit-transport.mnd: end();
        label *label55                                               unit-transport.mnd: if @unit.@dead or @unit.@controller != @this then
   80:  sensor *tmp20 sorter1 @config                                unit-transport.mnd: while item == sorter1.@config and @unit.@totalItems > 0;
   81:  op equal *tmp21 :moveItems.0:item *tmp20                     ...
   82:  sensor *tmp22 @unit @totalItems                              ...
   83:  op greaterThan *tmp23 *tmp22 0                               ...
   84:  op land *tmp24 *tmp21 *tmp23                                 ...
   85:  jump *label32 notEqual *tmp24 false                          unit-transport.mnd: do
   86:  jump *label14 equal :findUnit*finished false                 unit-transport.mnd: if finished(findUnit) then
        label *label38                                               unit-transport.mnd: var unit = await(findUnit);
   87:  wait 1e-15                                                   ...
   88:  jump *label38 equal :findUnit*finished false                 ...
   89:  ubind :findUnit*retval                                       unit-transport.mnd: ubind(unit);
   90:  ucontrol flag 1764335678894 0 0 0 0                          unit-transport.mnd: flag(1764335678894);
   91:  write @unit processor1 ":findUnit:currentUnit"               unit-transport.mnd: async(findUnit(@unit));
   92:  set :findUnit*finished false                                 ...
   93:  write :findUnit*address processor1 "@counter"                ...
   94:  jump *label14 always 0 0                                     unit-transport.mnd: while true do


Performance: parsed in 172 ms, compiled in 230 ms, optimized in 233 ms, run in 3 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (1 steps):
The program didn't generate any output.
Execution exception at instruction 0: read *tmp0 processor1 "*mainProcessor":
Variable 'processor1' is not an object.
(Use the '#set err-not-an-object = false;' directive or the '--err-not-an-object false' command line option to ignore this exception.)
