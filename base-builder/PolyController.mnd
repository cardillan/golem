#set target = 8;
#set syntax = strict;
//#set sort-variables;

// TODO: when the coal spot is built over, find another one!

module PolyController;

require units;

linked message1;

const FLAG_FREE         = 0;
const FLAG_MINE_COAL    = 1;
const FLAG_MINE_SCRAP   = 2;
const FLAG_RETURN_COAL  = 3;
const FLAG_RETURN_SCRAP = 4;

// At this point, we're only using a flare
const CAPACITY          = 30;
const SCRAP_CAPACITY    = 25;
const RADIUS            = 6;

noinit volatile var
    builder, core, coreX, coreY,
    thoriumDrone;

volatile var
    thoriumContainer = null;

volatile var
    thoriumLimit = 100,
    thoriumContainerX = 0, thoriumContainerY = 0;

remote void setThoriumContainer(container)
    thoriumContainer = container;
    thoriumContainerX = container.@x;
    thoriumContainerY = container.@y;
    thoriumLimit = thoriumContainer.@itemCapacity > 10 ? 100 : 0;
end;

volatile noinit var
    container,
    containerX,
    containerY;

remote void setScrapContainer(scrapContainer)
    container = scrapContainer;
    containerX = container.@x;
    containerY = container.@y;
end;

var
    ore = @coal,
    coalX = 0,
    coalY = 0,
    coalDistance = 1e9,
    scrapX = 0,
    scrapY = 0,
    scrapDistance = 1e9;

void backgroundProcess()
    if core == null then return; end;

    while true do
        ubind(@poly);
        if @unit == builder then
            println("Found builder unit.");
            printflush(message1);
        elsif thoriumDrone == null then
            thoriumDrone = @unit;
        else
            if @unit == thoriumDrone and thoriumContainer.@thorium > thoriumLimit then
                serviceThoriumDrill();
                continue;
            end;

            if container then
                var coal = core.@coal;
                ore = coal < 120 ? @coal : coal > 220 ? @scrap : ore;
            end;

            var flag = @unit.@flag;
            println("Unit flag: ", flag);
            case flag
                when FLAG_FREE          then findOreToMine();
                when FLAG_MINE_COAL     then mineCoal();
                when FLAG_MINE_SCRAP    then mineScrap();
                when FLAG_RETURN_COAL   then returnCoal();
                when FLAG_RETURN_SCRAP  then returnScrap();
            end;
        end;
    end;
end;

void findOreToMine()
    // Shouldn't happen here, but...
    if @unit.@firstItem != null then
        itemDrop(@air, CAPACITY);
        if @unit.@firstItem != null then
            println($"Holding wrong item.");
            return;
        end;
    end;

    flag(ore == @coal ? FLAG_MINE_COAL : FLAG_MINE_SCRAP);
    var targetX = ore == @coal ? coreX : containerX;
    var targetY = ore == @coal ? coreY : containerY;
    var distance = ore == @coal ? coalDistance : scrapDistance;

    // Try to find a better ore
    var x, y;
    ulocate(:ore, ore, out x, out y);
    var dist = len(x - targetX, y - targetY);
    if dist < distance then
        if ore == @coal then
            coalX = x;
            coalY = y;
            coalDistance = dist;
        else
            scrapX = x;
            scrapY = y;
            scrapDistance = dist;
        end;
    end;

    approach(x, y, RADIUS);
end;

void mineCoal()
    print("Mining ");
    printchar(@coal);

    if ore != @coal then
        print(", switching");
        approach(coreX, coreY, RADIUS);
        itemDrop(core, CAPACITY);
        flag(FLAG_RETURN_COAL);
    end;

    if @unit.@firstItem != @coal then
        print(" (dropping)");
        itemDrop(@air, CAPACITY);
    end;

    print($" at $coalX, $coalY");
    approach(coalX, coalY, RADIUS);
    mine(coalX, coalY);

    if @unit.@totalItems >= CAPACITY then
        print(", full");
        approach(coreX, coreY, RADIUS);
        itemDrop(core, CAPACITY);
        flag(FLAG_RETURN_COAL);
    elsif within(coalX, coalY, RADIUS + 0.5) then
        if !@unit.@mining then
            // The mining spot was lost (i.e. built over)
            print(", ore lost");
            coalDistance = 1e9;
            approach(coreX, coreY, RADIUS);
            itemDrop(core, CAPACITY);
            flag(FLAG_RETURN_COAL);
        end;
    end;

    println();
end;

void returnCoal()
    println("Returning");
    approach(coreX, coreY, RADIUS);
    itemDrop(core, CAPACITY);

    if @unit.@firstItem == null then
        println("    Finished");
        flag(FLAG_FREE);
    end;
end;

void mineScrap()
    print("Mining ");
    printchar(@scrap);

    if ore != @scrap then
        print(", switching");
        approach(containerX, containerY, RADIUS);
        itemDrop(container, CAPACITY);
        flag(FLAG_RETURN_SCRAP);
    end;

    if @unit.@firstItem != @scrap then
        print(" (dropping)");
        itemDrop(@air, CAPACITY);
    end;

    print($" at $scrapX, $scrapY");
    approach(scrapX, scrapY, RADIUS);
    mine(scrapX, scrapY);

    if @unit.@totalItems >= SCRAP_CAPACITY then
        print(", full");
        approach(containerX, containerY, RADIUS);
        itemDrop(container, CAPACITY);
        flag(FLAG_RETURN_SCRAP);
    elsif within(scrapX, scrapY, RADIUS + 0.5) then
        if !@unit.@mining then
            // The mining spot was lost (i.e. built over)
            print(", ore lost");
            scrapDistance = 1e9;
            approach(containerX, containerY, RADIUS);
            itemDrop(container, CAPACITY);
            flag(FLAG_RETURN_SCRAP);
        end;
    end;

    println();
end;

void returnScrap()
    println("Returning");
    approach(containerX, containerY, RADIUS);
    itemDrop(container, CAPACITY);

    if @unit.@firstItem == null then
        println("    Finished");
        flag(FLAG_FREE);
    end;
end;

void serviceThoriumDrill()
    var item = @unit.@firstItem;

    if item == @thorium then
        approach(coreX, coreY, RADIUS);
        itemDrop(core, CAPACITY);
    elsif item == null then
        // Take titanium
        approach(thoriumContainerX, thoriumContainerY, RADIUS);
        itemTake(thoriumContainer, @thorium, CAPACITY);
    else
        itemDrop(@air, CAPACITY);
    end;
end;

begin
    do
        builder = ubind(@poly);
        core = ulocate(:building, :core, false, out coreX, out coreY);
    while core == null;
end;
