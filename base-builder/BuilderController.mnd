#set target = 8;
#set syntax = strict;
//#set goal = size;
//#set sort-variables;

#set program-name = "Base Builder - Builder Unit Controller";
#set program-version = "v0.4.0";

module Builder;

require "Links.mnd";
require "Common.mnd";
require "Actions.mnd";
require "Display.mnd" remote display;
require "OreLocator.mnd" remote oreLocator;
require "CoreController.mnd" remote processor;
require "FlareController.mnd" remote flareController;
require "MonoController.mnd" remote monoController;

// At this point, we're only using a poly
const capacity = 28;

// Built blocks
noinit var
    core, coreX, coreY, builder;

export noinit var
    powerTarget,
    titaniumDrill,
    thoriumBattery,
    thoriumContainer,
    thoriumGenerator,
    scrap,
    sandContainer;

// Targets to be met for the next build
noinit mlog(@copper.@name)      var targetCopper;
noinit mlog(@lead.@name)        var targetLead;
noinit mlog(@graphite.@name)    var targetGraphite;
noinit mlog(@silicon.@name)     var targetSilicon;
noinit mlog(@titanium.@name)    var targetTitanium;
noinit mlog(@metaglass.@name)   var targetMetaglass;
noinit mlog(@thorium.@name)     var targetThorium;
noinit                          var noTarget;

export var
    leadSurplus = 0,
    graphiteSurplus = 20,
    siliconSurplus = 20,
    siliconMonoSurplus = 0,
    metaglassSurplus = 20;

external(bank1[511]) logPosition = 511;

// SUPPLY OPERATIONS

inline void supplyBase0()
    var supplied = false;

    if unloader1 == null then
        if core.@graphite < targetGraphite then
            if press.@coal < 5 then
                status1("Goal 1: graphite requirement");
                supplyBlock(press, @coal);
                supplied = true;
            end;
        end;

        if battery1.@totalPower < powerTarget then
            if generator.@coal < 2 then
                status1("Goal 4: supplying generator");
                supplyBlock(generator, @coal);
                return;
            end;
        end;

        if core.@silicon < targetSilicon then
            if smelter.@coal < 5 then
                status1("Goal 2: coal for silicon requirement");
                supplyBlock(smelter, @coal);
                supplied = true;
            elsif smelter.@sand < 5 then
                if scrap then
                    if pulverizer1.@scrap < 10 then
                        status1("Goal 3a: scrap for silicon requirement");
                        supplyBlock(pulverizer1, @scrap);
                        supplied = true;
                    end;
                else
                    status1("Goal 3: sand for silicon requirement");
                    supplyBlock(smelter, @sand);
                    supplied = true;
                end;
            end;
        end;
    end;

    var titaniumTrigger = core.@titanium < targetTitanium ? min(5, targetTitanium - core.@titanium) : 100;
    if titaniumDrill.@titanium < titaniumTrigger then
        if !supplied then
            if battery1.@totalPower < unloader1 * powerTarget then
                status1("Goal 5: supplying generator");
                mineOre(@coal);
            elsif core.@silicon < targetSilicon then
                if scrap then
                    status1("Goal 6: silicon requirement");
                    if container_a then
                        var coal = core.@coal;
                        var sand = container_a.@sand;
                        var ore = coal < sand ? @coal : @scrap;
                        var block = coal < sand ? core : container_a;
                        mineOre(ore, block);
                    else
                        mineOre(@coal);
                    end;
                else
                    status1("Goal 6: silicon requirement");
                    var coal = core.@coal;
                    var sand = core.@sand;
                    var ore = coal < sand ? @coal : @sand;
                    mineOre(ore);
                end;
            elsif core.@copper < targetCopper then
                status1("Goal 7: copper requirement");
                mineOre(@copper);
            elsif core.@lead < targetLead then
                status1("Goal 8: lead requirement");
                mineOre(@lead);
            elsif core.@metaglass < targetMetaglass then
                status1("Goal 9: metaglass requirement");
                if scrap then
                    mineOre(@scrap, sandContainer);
                else
                    mineOre(@sand);
                end;
            else
                status1("Goal 10: supplying base");
                if container_a == null then
                    mineOre(scrap or core.@coal <= core.@sand ? @coal : @sand);
                elsif core.@coal <= container_a.@sand + container_a.@scrap then
                    mineOre(@coal);
                else
                    mineOre(@scrap, container_a);
                end;
            end;
        end;
    else
        status1("Goal 11: Fetching titanium");
        fetchBlock(titaniumDrill, @titanium);
    end;
end;

inline void supplyBase1()
    status1("Phase 1: supplying base");
    mineOre(@coal);
end;

inline void supplyBase2()
    status1("Phase 2: servicing thorium drill");

    if thoriumBattery.@totalPower < 2000 then
        if thoriumGenerator.@coal == 0 then
            if core.@coal < 50 then
                supplyBlock(thoriumGenerator, @coal);
            else
                supplyBlockFromCore(thoriumGenerator, @coal);
            end;
        end;
    end;
    fetchBlock(thoriumContainer, @thorium);

    if core.@thorium > 400 then
        setMonoTarget(0);
        setPolyTarget(4);
    end;
end;

export void supplyBase()
    monoController.sandTarget = max(0, siliconMonoSurplus + targetSilicon - core.@silicon);

    if thoriumContainer then
        supplyBase2();
    elsif processor.monos > 1 then
        supplyBase1();
    else
        supplyBase0();
    end;
end;

def targetMet()
    // This is horrible, but Mindcode doesn't do short-circuit evaluation yet.
    if core.@silicon < targetSilicon then display.missing = @silicon; return false; end;
    if core.@copper < targetCopper then display.missing = @copper; return false; end;
    if core.@lead < targetLead then display.missing = @lead; return false; end;
    if core.@metaglass < targetMetaglass then display.missing = @metaglass; return false; end;
    if core.@graphite < targetGraphite then display.missing = @graphite; return false; end;
    if core.@titanium < targetTitanium then display.missing = @titanium; return false; end;
    if core.@thorium < targetThorium then display.missing = @thorium; return false; end;
    //display.missing = false;
    return true;
end;

export void meetTarget(block, copper, lead, graphite, silicon, titanium, metaglass, thorium, forBuild, isNoTarget)
    // Update display
    var count = 0;
    for var t in copper, lead, graphite, silicon, titanium, metaglass, thorium do count += sign(t); end;
    display.totalTargets = count;
    display.nextBlock = block;
    display.targetCopper = copper;
    display.targetLead = lead;
    display.targetGraphite = graphite;
    display.targetSilicon = silicon;
    display.targetTitanium = titanium;
    display.targetMetaglass = metaglass;
    display.targetThorium = thorium;

    targetCopper = copper;
    targetLead = lead + leadSurplus;
    targetGraphite = graphite;
    targetSilicon = silicon;
    targetTitanium = titanium;
    targetMetaglass = metaglass;
    targetThorium = thorium;
    noTarget = isNoTarget;

    processor.pressTarget = graphite + graphiteSurplus;
    processor.smelterTarget = silicon + siliconSurplus;
    processor.kilnTarget = metaglass + metaglassSurplus;
    processor.siliconReserve = silicon + sign(silicon) * 20;
    processor.graphiteReserve = graphite + sign(graphite) * 20;

    monoController.leadTarget = targetLead;
    monoController.copperTarget = targetCopper;

    while !targetMet() do
        supplyBase();
    end;

    if forBuild then
        processor.buildStart();
        while !targetMet() do
            supplyBase();
        end;
    end;
end;

export void meetTargetCfg(cfg, forBuild)
    var type, cu, pb, gr, si, ti, mg, th;
    unpackCfg(cfg, out type, , , out cu, out pb, out gr, out si, out ti, out mg, out th);
    meetTarget(type, cu, pb, gr, si, ti, mg, th, forBuild, false);
end;


// BUILDING OPERATIONS

def buildBlock(block, x, y, copper, lead, graphite, silicon, titanium, metaglass, thorium, rotation, config, index)
    meetTarget(block, copper, lead, graphite, silicon, titanium, metaglass, thorium, processor != null, false);
    var built = buildBlockAt(block, x, y, rotation, config, index);
    async(processor.buildStop());
    return built;
end;

export def buildRemoteBlock(cfg, x, y)
    if x + y > 0 then
        var type, cu, pb, gr, si, ti, mg, th, rotation, index;
        unpackCfg(cfg, out type, , , out cu, out pb, out gr, out si, out ti, out mg, out th, out rotation, , out index);
        return buildBlock(type, x, y, cu, pb, gr, si, ti, mg, th, rotation, null, index);
    end;
    return false;
end;

// Builds a block
export def buildBlockFromCfg(cfg, config)
    var type, x, y, cu, pb, gr, si, ti, mg, th, rotation, index;
    unpackCfg(cfg, out type, out x, out y, out cu, out pb, out gr, out si, out ti, out mg, out th, out rotation, , out index);
    //display.nextBuildIndex = index;
    var building = buildBlock(type, coreX + x, coreY + y, cu, pb, gr, si, ti, mg, th, rotation, config, index);
    //display.nextBuildIndex = 1000;
    @this.write(building, cfg);
    display.write(building, cfg);
    processor.write(building, cfg);
    baseBuilder.write(building, cfg);
    return building;
end;

noinit export var ERROR_FOUND_BLOCK, ERROR_FOUND_TYPE, ERROR_X, ERROR_Y;

inline void log(encodedId)
    bank1[--logPosition] = encodedId + TIME * 1000;
end;

inline void logBlock(block, index)
    log(block.@id);
    if index >= 0 and index < length(BLOCKS) then
        display.blocksBuilt |= (1 << index);
        display.recentBuildIndex = index;
    end;
end;

export def buildBlockAt(block, x, y, rotation, config, index)
    moveTo(x, y);

    var type;
    var building = getBlock(x, y, out type);
    if building != null then
        // The block is already there
        if type == block then return building; end;
        error("Cannot build $block at position ($x, $y): $type is already there.");
    end;

    build(x, y, block, rotation, config);
    wait(0.25);
    var success = false;
    do
        build(x, y, block, rotation, config);
        building = getBlock(x, y, out type);
        if building == null and !success then
            error("Error while building $block at $x, $y: $type was found.");
        else
            success = true;
        end;

        if block == @multiplicative-reconstructor then
            polyController.enabled = false;     // Brutal, but effective :)
            ubind(@poly);
            if @unit != builder then
                approach(x, y, RADIUS);
                build(x, y, block, rotation, config);
            end;
        end;
    while type != block;

    polyController.enabled = true;
    ubind(builder);

    logBlock(block, index);

    return building;
end;

export def buildFirstTitaniumDrillAt(x, y)
    var drill = buildBlockAt(@pneumatic-drill, x, y, 0, null, -1);
    flareController.addTitaniumDrill(drill);
    return drill;
end;


def getFloor(x, y)
    var floor;
    getBlock(x, y, , out floor);
    return floor;
end;

def titaniumDrillScore(x, y, in out positive, in out negative)
    case getFloor(x, y)
        when @ore-titanium then positive++;
        when @ore-copper, @ore-lead, @ore-scrap, @ore-coal then negative++;
    end;
end;

volatile var positive = 0, negative = 0;

var MAX_TILES = 10;
var MAX_COUNT = 6;

def buildTitaniumDrill(x, y, in out count, in out tiles)
    if count < MAX_COUNT then
        if tiles < MAX_TILES then
            moveTo(x, y);
            positive = 0; negative = 0;
            titaniumDrillScore(x - 0.5, y - 0.5, in out positive, in out negative);
            titaniumDrillScore(x - 0.5, y + 0.5, in out positive, in out negative);
            titaniumDrillScore(x + 0.5, y - 0.5, in out positive, in out negative);
            titaniumDrillScore(x + 0.5, y + 0.5, in out positive, in out negative);

            if positive > negative && positive >= 2 then
                meetTargetCfg(PNEUMATIC_DRILL, true);
                var drill = buildBlockAt(@pneumatic-drill, x, y, null, 0, -1);
                if drill != null then
                    flareController.addTitaniumDrill(drill);

                    // Build a flare to service this drill
                    setFlareTarget(++count);

                    tiles += positive;
                    return positive;
                end;
            end;
        end;
    end;

    return 0;
end;

export void buildTitaniumDrills(current)
    // The base is already autonomous. The drill needs copper and graphite.
    // Both are provided in abundance at this moment

    // We know we have one drill
    var count = 1;
    var tiles = 0;

    if scrap then MAX_TILES += 2; end;

    wait(1e-4);
    wait(1e-4);

    do
        while current < oreLocator.locations do
            var index = current * 4;
            var size = bank1[index + 1];
            if size >= 3 then
                var x = bank1[index + 2];
                var y = bank1[index + 3];

                var built = buildTitaniumDrill(x - 1, y - 1, in out count, in out tiles)
                    + buildTitaniumDrill(x + 1, y - 1, in out count, in out tiles)
                    + buildTitaniumDrill(x - 1, y + 1, in out count, in out tiles)
                    + buildTitaniumDrill(x + 1, y + 1, in out count, in out tiles);

                if built == 0 then
                    built = buildTitaniumDrill(x, y, in out count, in out tiles);
                end;
            end;
            current++;
        end;

        if tiles >= MAX_TILES then break; end;
        if count >= MAX_COUNT then break; end;
    while !oreLocator.searchFinished;
end;

inline void setMonoTarget(target)
    processor.monoTarget = target;
end;

inline void setFlareTarget(target)
    processor.flareTarget = min(target, 8);
end;

inline void setPolyTarget(target)
    processor.polyTarget = target;
end;

// Initialization
begin
    do
        builder = ubind(@poly);
        core = ulocate(:building, :core, false, out coreX, out coreY);
    while core == null;
    sandContainer = core;
end;
