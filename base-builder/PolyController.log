   337 instructions before optimizations.
    12 instructions eliminated by Temp Variables Elimination (3 passes, 7 iterations).
     1 instructions eliminated by Case Expression Optimization.
    52 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    27 instructions eliminated by Jump Optimization (5 iterations).
    17 instructions eliminated by Single Step Elimination (6 iterations).
    21 instructions eliminated by If Expression Optimization (5 iterations).
     4 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     6 instructions eliminated by Jump Straightening (2 passes, 5 iterations).
    13 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   180 instructions after optimizations.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   111 print "Unit flag: "
   112 print :backgroundProcess:flag
   113 print "\n"
-    * set *tmp29 :backgroundProcess:flag
-    * jump *label40 equal *tmp29 0
+  114 jump *label40 equal :backgroundProcess:flag 0
   115 jump *label39 always
   116 label *label40
   117 sensor *tmp30 @unit @firstItem
 
   196 set *tmp28 null
   197 jump *label38 always
   198 label *label39
-    * jump *label59 equal *tmp29 1
+  199 jump *label59 equal :backgroundProcess:flag 1
   200 jump *label58 always
   201 label *label59
   202 print "Mining "
 
   266 set *tmp28 null
   267 jump *label38 always
   268 label *label58
-    * jump *label72 equal *tmp29 2
+  269 jump *label72 equal :backgroundProcess:flag 2
   270 jump *label71 always
   271 label *label72
   272 print "Mining "
 
   336 set *tmp28 null
   337 jump *label38 always
   338 label *label71
-    * jump *label85 equal *tmp29 3
+  339 jump *label85 equal :backgroundProcess:flag 3
   340 jump *label84 always
   341 label *label85
   342 print "Returning"
 
   358 set *tmp28 null
   359 jump *label38 always
   360 label *label84
-    * jump *label90 equal *tmp29 4
+  361 jump *label90 equal :backgroundProcess:flag 4
   362 jump *label89 always
   363 label *label90
   364 print "Returning"

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-30 instructions):
 
    27 op equal *tmp4 .core null
    28 jump *label16 equal *tmp4 false
    29 jump *label15 always
-    * set *tmp5 null
    30 jump *label17 always
    31 label *label16
-    * set *tmp5 null
    32 label *label17
    33 label *label18
    34 jump *label20 equal true false
 
    38 print "Found builder unit."
    39 print "\n"
    40 printflush message1
-    * set *tmp7 null
    41 jump *label22 always
    42 label *label21
    43 op equal *tmp8 .thoriumDrone null
 
    58 jump *label28 equal *tmp17 false
    59 ucontrol approach .coreX .coreY 6
    60 ucontrol itemDrop .core 30
-    * set *tmp18 null
    61 jump *label29 always
    62 label *label28
    63 op equal *tmp19 :serviceThoriumDrill:item null
 
    70 ucontrol itemDrop @air 30
    71 set *tmp20 null
    72 label *label31
-    * set *tmp18 *tmp20
    73 label *label29
    74 label *label27
    75 jump *label19 always
-    * set *tmp15 null
    76 jump *label26 always
    77 label *label25
-    * set *tmp15 null
    78 label *label26
    79 jump *label32 equal .container false
    80 sensor *tmp22 .core @coal
 
    94 set *tmp24 *tmp26
    95 label *label35
    96 set .ore *tmp24
-    * set *tmp21 .ore
    97 jump *label33 always
    98 label *label32
-    * set *tmp21 null
    99 label *label33
   100 sensor *tmp27 @unit @flag
   101 set :backgroundProcess:flag *tmp27
 
   120 label *label44
   121 set *tmp35 null
   122 label *label45
-    * set *tmp32 *tmp35
   123 jump *label43 always
   124 label *label42
-    * set *tmp32 null
   125 label *label43
   126 op equal *tmp36 .ore @coal
   127 jump *label46 equal *tmp36 false
 
   175 set .scrapDistance :findOreToMine:dist
   176 set *tmp52 .scrapDistance
   177 label *label57
-    * set *tmp50 *tmp52
   178 jump *label55 always
   179 label *label54
-    * set *tmp50 null
   180 label *label55
   181 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   182 label *label41
 
   194 ucontrol approach .coreX .coreY 6
   195 ucontrol itemDrop .core 30
   196 ucontrol flag 3
-    * set *tmp54 null
   197 jump *label62 always
   198 label *label61
-    * set *tmp54 null
   199 label *label62
   200 sensor *tmp55 @unit @firstItem
   201 op notEqual *tmp56 *tmp55 @coal
   202 jump *label63 equal *tmp56 false
   203 print " (dropping)"
   204 ucontrol itemDrop @air 30
-    * set *tmp57 null
   205 jump *label64 always
   206 label *label63
-    * set *tmp57 null
   207 label *label64
   208 print " at "
   209 print .coalX
 
   219 ucontrol approach .coreX .coreY 6
   220 ucontrol itemDrop .core 30
   221 ucontrol flag 3
-    * set *tmp60 null
   222 jump *label66 always
   223 label *label65
   224 ucontrol within .coalX .coalY 6.5 *tmp61
 
   241 label *label67
   242 set *tmp62 null
   243 label *label68
-    * set *tmp60 *tmp62
   244 label *label66
   245 print "\n"
   246 label *label60
 
   258 ucontrol approach .containerX .containerY 6
   259 ucontrol itemDrop .container 30
   260 ucontrol flag 4
-    * set *tmp67 null
   261 jump *label75 always
   262 label *label74
-    * set *tmp67 null
   263 label *label75
   264 sensor *tmp68 @unit @firstItem
   265 op notEqual *tmp69 *tmp68 @scrap
   266 jump *label76 equal *tmp69 false
   267 print " (dropping)"
   268 ucontrol itemDrop @air 30
-    * set *tmp70 null
   269 jump *label77 always
   270 label *label76
-    * set *tmp70 null
   271 label *label77
   272 print " at "
   273 print .scrapX
 
   283 ucontrol approach .containerX .containerY 6
   284 ucontrol itemDrop .container 30
   285 ucontrol flag 4
-    * set *tmp73 null
   286 jump *label79 always
   287 label *label78
   288 ucontrol within .scrapX .scrapY 6.5 *tmp74
 
   305 label *label80
   306 set *tmp75 null
   307 label *label81
-    * set *tmp73 *tmp75
   308 label *label79
   309 print "\n"
   310 label *label73
 
   324 print "    Finished"
   325 print "\n"
   326 ucontrol flag 0
-    * set *tmp81 null
   327 jump *label88 always
   328 label *label87
-    * set *tmp81 null
   329 label *label88
   330 label *label86
   331 set *tmp28 null
 
   344 print "    Finished"
   345 print "\n"
   346 ucontrol flag 0
-    * set *tmp84 null
   347 jump *label93 always
   348 label *label92
-    * set *tmp84 null
   349 label *label93
   350 label *label91
   351 set *tmp28 null
 
   355 label *label38
   356 set *tmp9 *tmp28
   357 label *label24
-    * set *tmp7 *tmp9
   358 label *label22
   359 label *label19
   360 jump *label18 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-12 instructions):
 
    44 jump *label23 equal *tmp8 false
    45 set *tmp10 @unit
    46 set .thoriumDrone *tmp10
-    * set *tmp9 *tmp10
    47 jump *label24 always
    48 label *label23
    49 op equal *tmp11 @unit .thoriumDrone
 
    63 jump *label30 equal *tmp19 false
    64 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    65 ucontrol itemTake .thoriumContainer @thorium 30
-    * set *tmp20 null
    66 jump *label31 always
    67 label *label30
    68 ucontrol itemDrop @air 30
-    * set *tmp20 null
    69 label *label31
    70 label *label29
    71 label *label27
 
   112 print "Holding wrong item."
   113 print "\n"
   114 jump *label41 always
-    * set *tmp35 null
   115 jump *label45 always
   116 label *label44
-    * set *tmp35 null
   117 label *label45
   118 jump *label43 always
   119 label *label42
 
   162 set .coalX :findOreToMine:x
   163 set .coalY :findOreToMine:y
   164 set .coalDistance :findOreToMine:dist
-    * set *tmp52 .coalDistance
   165 jump *label57 always
   166 label *label56
   167 set .scrapX :findOreToMine:x
   168 set .scrapY :findOreToMine:y
   169 set .scrapDistance :findOreToMine:dist
-    * set *tmp52 .scrapDistance
   170 label *label57
   171 jump *label55 always
   172 label *label54
 
   229 label *label69
   230 set *tmp65 null
   231 label *label70
-    * set *tmp62 *tmp65
   232 jump *label68 always
   233 label *label67
-    * set *tmp62 null
   234 label *label68
   235 label *label66
   236 print "\n"
 
   291 label *label82
   292 set *tmp78 null
   293 label *label83
-    * set *tmp75 *tmp78
   294 jump *label81 always
   295 label *label80
-    * set *tmp75 null
   296 label *label81
   297 label *label79
   298 print "\n"
 
   342 label *label89
   343 set *tmp28 null
   344 label *label38
-    * set *tmp9 *tmp28
   345 label *label24
   346 label *label22
   347 label *label19

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   173 label *label55
   174 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   175 label *label41
-    * set *tmp28 null
   176 jump *label38 always
   177 label *label39
   178 jump *label59 equal :backgroundProcess:flag 1
 
   223 ucontrol approach .coreX .coreY 6
   224 ucontrol itemDrop .core 30
   225 ucontrol flag 3
-    * set *tmp65 null
   226 jump *label70 always
   227 label *label69
-    * set *tmp65 null
   228 label *label70
   229 jump *label68 always
   230 label *label67
 
   232 label *label66
   233 print "\n"
   234 label *label60
-    * set *tmp28 null
   235 jump *label38 always
   236 label *label58
   237 jump *label72 equal :backgroundProcess:flag 2
 
   282 ucontrol approach .containerX .containerY 6
   283 ucontrol itemDrop .container 30
   284 ucontrol flag 4
-    * set *tmp78 null
   285 jump *label83 always
   286 label *label82
-    * set *tmp78 null
   287 label *label83
   288 jump *label81 always
   289 label *label80
 
   291 label *label79
   292 print "\n"
   293 label *label73
-    * set *tmp28 null
   294 jump *label38 always
   295 label *label71
   296 jump *label85 equal :backgroundProcess:flag 3
 
   310 label *label87
   311 label *label88
   312 label *label86
-    * set *tmp28 null
   313 jump *label38 always
   314 label *label84
   315 jump *label90 equal :backgroundProcess:flag 4
 
   329 label *label92
   330 label *label93
   331 label *label91
-    * set *tmp28 null
   332 jump *label38 always
   333 label *label89
-    * set *tmp28 null
   334 label *label38
   335 label *label24
   336 label *label22

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-11 instructions):
 
    14 set .scrapDistance 1000000000
    15 label *label11
    16 ubind @poly
-    * set *tmp0 @unit
-    * set .builder *tmp0
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   17 set .builder @unit
+   18 ulocate building core false @copper .coreX .coreY *tmp2 .core
    19 label *label12
    20 op equal *tmp3 .core null
    21 jump *label11 notEqual *tmp3 false
 
    40 label *label21
    41 op equal *tmp8 .thoriumDrone null
    42 jump *label23 equal *tmp8 false
-    * set *tmp10 @unit
-    * set .thoriumDrone *tmp10
+   43 set .thoriumDrone @unit
    44 jump *label24 always
    45 label *label23
    46 op equal *tmp11 @unit .thoriumDrone
 
    48 op greaterThan *tmp13 *tmp12 .thoriumLimit
    49 op land *tmp14 *tmp11 *tmp13
    50 jump *label25 equal *tmp14 false
-    * sensor *tmp16 @unit @firstItem
-    * set :serviceThoriumDrill:item *tmp16
+   51 sensor :serviceThoriumDrill:item @unit @firstItem
    52 op equal *tmp17 :serviceThoriumDrill:item @thorium
    53 jump *label28 equal *tmp17 false
    54 ucontrol approach .coreX .coreY 6
 
    70 label *label25
    71 label *label26
    72 jump *label32 equal .container false
-    * sensor *tmp22 .core @coal
-    * set :backgroundProcess:coal *tmp22
+   73 sensor :backgroundProcess:coal .core @coal
    74 op lessThan *tmp23 :backgroundProcess:coal 120
    75 jump *label34 equal *tmp23 false
    76 set *tmp24 @coal
 
    89 jump *label33 always
    90 label *label32
    91 label *label33
-    * sensor *tmp27 @unit @flag
-    * set :backgroundProcess:flag *tmp27
+   92 sensor :backgroundProcess:flag @unit @flag
    93 print "Unit flag: "
    94 print :backgroundProcess:flag
    95 print "\n"
 
   147 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
   148 op sub *tmp46 :findOreToMine:x :findOreToMine:targetX
   149 op sub *tmp47 :findOreToMine:y :findOreToMine:targetY
-    * op len *tmp48 *tmp46 *tmp47
-    * set :findOreToMine:dist *tmp48
+  150 op len :findOreToMine:dist *tmp46 *tmp47
   151 op lessThan *tmp49 :findOreToMine:dist :findOreToMine:distance
   152 jump *label54 equal *tmp49 false
   153 op equal *tmp51 .ore @coal
 
   336 end
   337 label *label0
   338 set .thoriumContainer :setThoriumContainer:container
-    * sensor *tmp85 :setThoriumContainer:container @x
-    * set .thoriumContainerX *tmp85
-    * sensor *tmp86 :setThoriumContainer:container @y
-    * set .thoriumContainerY *tmp86
+  339 sensor .thoriumContainerX :setThoriumContainer:container @x
+  340 sensor .thoriumContainerY :setThoriumContainer:container @y
   341 sensor *tmp87 .thoriumContainer @itemCapacity
   342 op greaterThan *tmp88 *tmp87 10
   343 jump *label95 equal *tmp88 false
 
   353 end
   354 label *label2
   355 set .container :setScrapContainer:scrapContainer
-    * sensor *tmp90 .container @x
-    * set .containerX *tmp90
-    * sensor *tmp91 .container @y
-    * set .containerY *tmp91
+  356 sensor .containerX .container @x
+  357 sensor .containerY .container @y
   358 label *label97
   359 set :setScrapContainer*finished true
   360 jump *label14 always

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    29 label *label16
    30 label *label17
    31 label *label18
-    * jump *label20 equal true false
    32 ubind @poly
    33 op equal *tmp6 @unit .builder
    34 jump *label21 equal *tmp6 false

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-5 instructions):
 
    92 print "Unit flag: "
    93 print :backgroundProcess:flag
    94 print "\n"
-    * jump *label40 equal :backgroundProcess:flag 0
-    * jump *label39 always
+   95 jump *label39 notEqual :backgroundProcess:flag 0
    96 label *label40
    97 sensor *tmp30 @unit @firstItem
    98 op notEqual *tmp31 *tmp30 null
 
   166 label *label41
   167 jump *label38 always
   168 label *label39
-    * jump *label59 equal :backgroundProcess:flag 1
-    * jump *label58 always
+  169 jump *label58 notEqual :backgroundProcess:flag 1
   170 label *label59
   171 print "Mining "
   172 printchar @coal
 
   224 label *label60
   225 jump *label38 always
   226 label *label58
-    * jump *label72 equal :backgroundProcess:flag 2
-    * jump *label71 always
+  227 jump *label71 notEqual :backgroundProcess:flag 2
   228 label *label72
   229 print "Mining "
   230 printchar @scrap
 
   282 label *label73
   283 jump *label38 always
   284 label *label71
-    * jump *label85 equal :backgroundProcess:flag 3
-    * jump *label84 always
+  285 jump *label84 notEqual :backgroundProcess:flag 3
   286 label *label85
   287 print "Returning"
   288 print "\n"
 
   300 label *label86
   301 jump *label38 always
   302 label *label84
-    * jump *label90 equal :backgroundProcess:flag 4
-    * jump *label89 always
+  303 jump *label89 notEqual :backgroundProcess:flag 4
   304 label *label90
   305 print "Returning"
   306 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-27 instructions):
 
    17 set .builder @unit
    18 ulocate building core false @copper .coreX .coreY *tmp2 .core
    19 label *label12
-    * op equal *tmp3 .core null
-    * jump *label11 notEqual *tmp3 false
+   20 jump *label11 equal .core null
    21 label *label13
    22 set *signature "2bc8cecff9ae5b38:v1"
    23 label *label14
-    * op equal *tmp4 .core null
-    * jump *label16 equal *tmp4 false
+   24 jump *label16 notEqual .core null
    25 jump *label15 always
    26 jump *label17 always
    27 label *label16
    28 label *label17
    29 label *label18
    30 ubind @poly
-    * op equal *tmp6 @unit .builder
-    * jump *label21 equal *tmp6 false
+   31 jump *label21 notEqual @unit .builder
    32 print "Found builder unit."
    33 print "\n"
    34 printflush message1
    35 jump *label22 always
    36 label *label21
-    * op equal *tmp8 .thoriumDrone null
-    * jump *label23 equal *tmp8 false
+   37 jump *label23 notEqual .thoriumDrone null
    38 set .thoriumDrone @unit
    39 jump *label24 always
    40 label *label23
 
    44 op land *tmp14 *tmp11 *tmp13
    45 jump *label25 equal *tmp14 false
    46 sensor :serviceThoriumDrill:item @unit @firstItem
-    * op equal *tmp17 :serviceThoriumDrill:item @thorium
-    * jump *label28 equal *tmp17 false
+   47 jump *label28 notEqual :serviceThoriumDrill:item @thorium
    48 ucontrol approach .coreX .coreY 6
    49 ucontrol itemDrop .core 30
    50 jump *label29 always
    51 label *label28
-    * op equal *tmp19 :serviceThoriumDrill:item null
-    * jump *label30 equal *tmp19 false
+   52 jump *label30 notEqual :serviceThoriumDrill:item null
    53 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    54 ucontrol itemTake .thoriumContainer @thorium 30
    55 jump *label31 always
 
    64 label *label26
    65 jump *label32 equal .container false
    66 sensor :backgroundProcess:coal .core @coal
-    * op lessThan *tmp23 :backgroundProcess:coal 120
-    * jump *label34 equal *tmp23 false
+   67 jump *label34 greaterThanEq :backgroundProcess:coal 120
    68 set *tmp24 @coal
    69 jump *label35 always
    70 label *label34
-    * op greaterThan *tmp25 :backgroundProcess:coal 220
-    * jump *label36 equal *tmp25 false
+   71 jump *label36 lessThanEq :backgroundProcess:coal 220
    72 set *tmp26 @scrap
    73 jump *label37 always
    74 label *label36
 
    87 jump *label39 notEqual :backgroundProcess:flag 0
    88 label *label40
    89 sensor *tmp30 @unit @firstItem
-    * op notEqual *tmp31 *tmp30 null
-    * jump *label42 equal *tmp31 false
+   90 jump *label42 equal *tmp30 null
    91 ucontrol itemDrop @air 30
    92 sensor *tmp33 @unit @firstItem
-    * op notEqual *tmp34 *tmp33 null
-    * jump *label44 equal *tmp34 false
+   93 jump *label44 equal *tmp33 null
    94 print "Holding wrong item."
    95 print "\n"
    96 jump *label41 always
 
   100 jump *label43 always
   101 label *label42
   102 label *label43
-    * op equal *tmp36 .ore @coal
-    * jump *label46 equal *tmp36 false
+  103 jump *label46 notEqual .ore @coal
   104 set *tmp37 1
   105 jump *label47 always
   106 label *label46
   107 set *tmp37 2
   108 label *label47
   109 ucontrol flag *tmp37
-    * op equal *tmp38 .ore @coal
-    * jump *label48 equal *tmp38 false
+  110 jump *label48 notEqual .ore @coal
   111 set *tmp39 .coreX
   112 jump *label49 always
   113 label *label48
   114 set *tmp39 .containerX
   115 label *label49
   116 set :findOreToMine:targetX *tmp39
-    * op equal *tmp40 .ore @coal
-    * jump *label50 equal *tmp40 false
+  117 jump *label50 notEqual .ore @coal
   118 set *tmp41 .coreY
   119 jump *label51 always
   120 label *label50
   121 set *tmp41 .containerY
   122 label *label51
   123 set :findOreToMine:targetY *tmp41
-    * op equal *tmp42 .ore @coal
-    * jump *label52 equal *tmp42 false
+  124 jump *label52 notEqual .ore @coal
   125 set *tmp43 .coalDistance
   126 jump *label53 always
   127 label *label52
 
   132 op sub *tmp46 :findOreToMine:x :findOreToMine:targetX
   133 op sub *tmp47 :findOreToMine:y :findOreToMine:targetY
   134 op len :findOreToMine:dist *tmp46 *tmp47
-    * op lessThan *tmp49 :findOreToMine:dist :findOreToMine:distance
-    * jump *label54 equal *tmp49 false
-    * op equal *tmp51 .ore @coal
-    * jump *label56 equal *tmp51 false
+  135 jump *label54 greaterThanEq :findOreToMine:dist :findOreToMine:distance
+  136 jump *label56 notEqual .ore @coal
   137 set .coalX :findOreToMine:x
   138 set .coalY :findOreToMine:y
   139 set .coalDistance :findOreToMine:dist
 
   154 label *label59
   155 print "Mining "
   156 printchar @coal
-    * op notEqual *tmp53 .ore @coal
-    * jump *label61 equal *tmp53 false
+  157 jump *label61 equal .ore @coal
   158 print ", switching"
   159 ucontrol approach .coreX .coreY 6
   160 ucontrol itemDrop .core 30
 
   163 label *label61
   164 label *label62
   165 sensor *tmp55 @unit @firstItem
-    * op notEqual *tmp56 *tmp55 @coal
-    * jump *label63 equal *tmp56 false
+  166 jump *label63 equal *tmp55 @coal
   167 print " (dropping)"
   168 ucontrol itemDrop @air 30
   169 jump *label64 always
 
   177 ucontrol approach .coalX .coalY 6
   178 ucontrol mine .coalX .coalY
   179 sensor *tmp58 @unit @totalItems
-    * op greaterThanEq *tmp59 *tmp58 30
-    * jump *label65 equal *tmp59 false
+  180 jump *label65 lessThan *tmp58 30
   181 print ", full"
   182 ucontrol approach .coreX .coreY 6
   183 ucontrol itemDrop .core 30
 
   187 ucontrol within .coalX .coalY 6.5 *tmp61
   188 jump *label67 equal *tmp61 false
   189 sensor *tmp63 @unit @mining
-    * op equal *tmp64 *tmp63 false
-    * jump *label69 equal *tmp64 false
+  190 jump *label69 notEqual *tmp63 false
   191 print ", ore lost"
   192 set .coalDistance 1000000000
   193 ucontrol approach .coreX .coreY 6
 
   208 label *label72
   209 print "Mining "
   210 printchar @scrap
-    * op notEqual *tmp66 .ore @scrap
-    * jump *label74 equal *tmp66 false
+  211 jump *label74 equal .ore @scrap
   212 print ", switching"
   213 ucontrol approach .containerX .containerY 6
   214 ucontrol itemDrop .container 30
 
   217 label *label74
   218 label *label75
   219 sensor *tmp68 @unit @firstItem
-    * op notEqual *tmp69 *tmp68 @scrap
-    * jump *label76 equal *tmp69 false
+  220 jump *label76 equal *tmp68 @scrap
   221 print " (dropping)"
   222 ucontrol itemDrop @air 30
   223 jump *label77 always
 
   231 ucontrol approach .scrapX .scrapY 6
   232 ucontrol mine .scrapX .scrapY
   233 sensor *tmp71 @unit @totalItems
-    * op greaterThanEq *tmp72 *tmp71 25
-    * jump *label78 equal *tmp72 false
+  234 jump *label78 lessThan *tmp71 25
   235 print ", full"
   236 ucontrol approach .containerX .containerY 6
   237 ucontrol itemDrop .container 30
 
   241 ucontrol within .scrapX .scrapY 6.5 *tmp74
   242 jump *label80 equal *tmp74 false
   243 sensor *tmp76 @unit @mining
-    * op equal *tmp77 *tmp76 false
-    * jump *label82 equal *tmp77 false
+  244 jump *label82 notEqual *tmp76 false
   245 print ", ore lost"
   246 set .scrapDistance 1000000000
   247 ucontrol approach .containerX .containerY 6
 
   265 ucontrol approach .coreX .coreY 6
   266 ucontrol itemDrop .core 30
   267 sensor *tmp79 @unit @firstItem
-    * op equal *tmp80 *tmp79 null
-    * jump *label87 equal *tmp80 false
+  268 jump *label87 notEqual *tmp79 null
   269 print "    Finished"
   270 print "\n"
   271 ucontrol flag 0
 
   282 ucontrol approach .containerX .containerY 6
   283 ucontrol itemDrop .container 30
   284 sensor *tmp82 @unit @firstItem
-    * op equal *tmp83 *tmp82 null
-    * jump *label92 equal *tmp83 false
+  285 jump *label92 notEqual *tmp82 null
   286 print "    Finished"
   287 print "\n"
   288 ucontrol flag 0
 
   307 sensor .thoriumContainerX :setThoriumContainer:container @x
   308 sensor .thoriumContainerY :setThoriumContainer:container @y
   309 sensor *tmp87 .thoriumContainer @itemCapacity
-    * op greaterThan *tmp88 *tmp87 10
-    * jump *label95 equal *tmp88 false
+  310 jump *label95 lessThanEq *tmp87 10
   311 set *tmp89 100
   312 jump *label96 always
   313 label *label95

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-17 instructions):
 
    23 label *label14
    24 jump *label16 notEqual .core null
    25 jump *label15 always
-    * jump *label17 always
    26 label *label16
    27 label *label17
    28 label *label18
 
    58 label *label29
    59 label *label27
    60 jump *label19 always
-    * jump *label26 always
    61 label *label25
    62 label *label26
    63 jump *label32 equal .container false
 
    75 set *tmp24 *tmp26
    76 label *label35
    77 set .ore *tmp24
-    * jump *label33 always
    78 label *label32
    79 label *label33
    80 sensor :backgroundProcess:flag @unit @flag
 
    91 print "Holding wrong item."
    92 print "\n"
    93 jump *label41 always
-    * jump *label45 always
    94 label *label44
    95 label *label45
-    * jump *label43 always
    96 label *label42
    97 label *label43
    98 jump *label46 notEqual .ore @coal
 
   138 set .scrapY :findOreToMine:y
   139 set .scrapDistance :findOreToMine:dist
   140 label *label57
-    * jump *label55 always
   141 label *label54
   142 label *label55
   143 ucontrol approach :findOreToMine:x :findOreToMine:y 6
 
   153 ucontrol approach .coreX .coreY 6
   154 ucontrol itemDrop .core 30
   155 ucontrol flag 3
-    * jump *label62 always
   156 label *label61
   157 label *label62
   158 sensor *tmp55 @unit @firstItem
   159 jump *label63 equal *tmp55 @coal
   160 print " (dropping)"
   161 ucontrol itemDrop @air 30
-    * jump *label64 always
   162 label *label63
   163 label *label64
   164 print " at "
 
   185 ucontrol approach .coreX .coreY 6
   186 ucontrol itemDrop .core 30
   187 ucontrol flag 3
-    * jump *label70 always
   188 label *label69
   189 label *label70
-    * jump *label68 always
   190 label *label67
   191 label *label68
   192 label *label66
 
   203 ucontrol approach .containerX .containerY 6
   204 ucontrol itemDrop .container 30
   205 ucontrol flag 4
-    * jump *label75 always
   206 label *label74
   207 label *label75
   208 sensor *tmp68 @unit @firstItem
   209 jump *label76 equal *tmp68 @scrap
   210 print " (dropping)"
   211 ucontrol itemDrop @air 30
-    * jump *label77 always
   212 label *label76
   213 label *label77
   214 print " at "
 
   235 ucontrol approach .containerX .containerY 6
   236 ucontrol itemDrop .container 30
   237 ucontrol flag 4
-    * jump *label83 always
   238 label *label82
   239 label *label83
-    * jump *label81 always
   240 label *label80
   241 label *label81
   242 label *label79
 
   255 print "    Finished"
   256 print "\n"
   257 ucontrol flag 0
-    * jump *label88 always
   258 label *label87
   259 label *label88
   260 label *label86
 
   271 print "    Finished"
   272 print "\n"
   273 ucontrol flag 0
-    * jump *label93 always
   274 label *label92
   275 label *label93
   276 label *label91
-    * jump *label38 always
   277 label *label89
   278 label *label38
   279 label *label24

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   124 label *label53
   125 set :findOreToMine:distance *tmp43
   126 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
-    * op sub *tmp46 :findOreToMine:x :findOreToMine:targetX
-    * op sub *tmp47 :findOreToMine:y :findOreToMine:targetY
+  127 op sub *tmp46 :findOreToMine:x *tmp39
+  128 op sub *tmp47 :findOreToMine:y *tmp41
   129 op len :findOreToMine:dist *tmp46 *tmp47
-    * jump *label54 greaterThanEq :findOreToMine:dist :findOreToMine:distance
+  130 jump *label54 greaterThanEq :findOreToMine:dist *tmp43
   131 jump *label56 notEqual .ore @coal
   132 set .coalX :findOreToMine:x
   133 set .coalY :findOreToMine:y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
   108 label *label48
   109 set *tmp39 .containerX
   110 label *label49
-    * set :findOreToMine:targetX *tmp39
   111 jump *label50 notEqual .ore @coal
   112 set *tmp41 .coreY
   113 jump *label51 always
   114 label *label50
   115 set *tmp41 .containerY
   116 label *label51
-    * set :findOreToMine:targetY *tmp41
   117 jump *label52 notEqual .ore @coal
   118 set *tmp43 .coalDistance
   119 jump *label53 always
   120 label *label52
   121 set *tmp43 .scrapDistance
   122 label *label53
-    * set :findOreToMine:distance *tmp43
   123 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
   124 op sub *tmp46 :findOreToMine:x *tmp39
   125 op sub *tmp47 :findOreToMine:y *tmp41

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-18 instructions):
 
    66 set *tmp24 @coal
    67 jump *label35 always
    68 label *label34
-    * jump *label36 lessThanEq :backgroundProcess:coal 220
-    * set *tmp26 @scrap
-    * jump *label37 always
-    * label *label36
-    * set *tmp26 .ore
-    * label *label37
+   69 select *tmp26 greaterThan :backgroundProcess:coal 220 @scrap .ore
    70 set *tmp24 *tmp26
    71 label *label35
    72 set .ore *tmp24
 
    90 label *label45
    91 label *label42
    92 label *label43
-    * jump *label46 notEqual .ore @coal
-    * set *tmp37 1
-    * jump *label47 always
-    * label *label46
-    * set *tmp37 2
-    * label *label47
+   93 select *tmp37 equal .ore @coal 1 2
    94 ucontrol flag *tmp37
-    * jump *label48 notEqual .ore @coal
-    * set *tmp39 .coreX
-    * jump *label49 always
-    * label *label48
-    * set *tmp39 .containerX
-    * label *label49
-    * jump *label50 notEqual .ore @coal
-    * set *tmp41 .coreY
-    * jump *label51 always
-    * label *label50
-    * set *tmp41 .containerY
-    * label *label51
-    * jump *label52 notEqual .ore @coal
-    * set *tmp43 .coalDistance
-    * jump *label53 always
-    * label *label52
-    * set *tmp43 .scrapDistance
-    * label *label53
+   95 select *tmp39 equal .ore @coal .coreX .containerX
+   96 select *tmp41 equal .ore @coal .coreY .containerY
+   97 select *tmp43 equal .ore @coal .coalDistance .scrapDistance
    98 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
    99 op sub *tmp46 :findOreToMine:x *tmp39
   100 op sub *tmp47 :findOreToMine:y *tmp41
 
   261 set .thoriumContainer :setThoriumContainer:container
   262 sensor .thoriumContainerX :setThoriumContainer:container @x
   263 sensor .thoriumContainerY :setThoriumContainer:container @y
-    * sensor *tmp87 .thoriumContainer @itemCapacity
-    * jump *label95 lessThanEq *tmp87 10
-    * set *tmp89 100
-    * jump *label96 always
-    * label *label95
-    * set *tmp89 0
-    * label *label96
+  264 sensor *tmp87 .thoriumContainer @itemCapacity
+  265 select *tmp89 greaterThan *tmp87 10 100 0
   266 set .thoriumLimit *tmp89
   267 label *label94
   268 set :setThoriumContainer*finished true

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 2 (-3 instructions):
 
    62 label *label26
    63 jump *label32 equal .container false
    64 sensor :backgroundProcess:coal .core @coal
-    * jump *label34 greaterThanEq :backgroundProcess:coal 120
-    * set *tmp24 @coal
-    * jump *label35 always
-    * label *label34
-    * select *tmp26 greaterThan :backgroundProcess:coal 220 @scrap .ore
-    * set *tmp24 *tmp26
-    * label *label35
+   65 select *tmp108 greaterThan :backgroundProcess:coal 220 @scrap .ore
+   66 select *tmp24 lessThan :backgroundProcess:coal 120 @coal *tmp108
    67 set .ore *tmp24
    68 label *label32
    69 label *label33

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   257 sensor .thoriumContainerX :setThoriumContainer:container @x
   258 sensor .thoriumContainerY :setThoriumContainer:container @y
   259 sensor *tmp87 .thoriumContainer @itemCapacity
-    * select *tmp89 greaterThan *tmp87 10 100 0
-    * set .thoriumLimit *tmp89
+  260 select .thoriumLimit greaterThan *tmp87 10 100 0
   261 label *label94
   262 set :setThoriumContainer*finished true
   263 jump *label14 always

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-1 instructions):
 
    63 jump *label32 equal .container false
    64 sensor :backgroundProcess:coal .core @coal
    65 select *tmp108 greaterThan :backgroundProcess:coal 220 @scrap .ore
-    * select *tmp24 lessThan :backgroundProcess:coal 120 @coal *tmp108
-    * set .ore *tmp24
+   66 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp108
    67 label *label32
    68 label *label33
    69 sensor :backgroundProcess:flag @unit @flag

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    16 ubind @poly
    17 set .builder @unit
    18 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label12
    19 jump *label11 equal .core null
-    * label *label13
    20 set *signature "2bc8cecff9ae5b38:v1"
    21 label *label14
    22 jump *label16 notEqual .core null
    23 jump *label15 always
    24 label *label16
-    * label *label17
    25 label *label18
    26 ubind @poly
    27 jump *label21 notEqual @unit .builder
 
    53 ucontrol itemDrop @air 30
    54 label *label31
    55 label *label29
-    * label *label27
    56 jump *label19 always
    57 label *label25
-    * label *label26
    58 jump *label32 equal .container false
    59 sensor :backgroundProcess:coal .core @coal
    60 select *tmp108 greaterThan :backgroundProcess:coal 220 @scrap .ore
    61 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp108
    62 label *label32
-    * label *label33
    63 sensor :backgroundProcess:flag @unit @flag
    64 print "Unit flag: "
    65 print :backgroundProcess:flag
    66 print "\n"
    67 jump *label39 notEqual :backgroundProcess:flag 0
-    * label *label40
    68 sensor *tmp30 @unit @firstItem
    69 jump *label42 equal *tmp30 null
    70 ucontrol itemDrop @air 30
 
    74 print "\n"
    75 jump *label41 always
    76 label *label44
-    * label *label45
    77 label *label42
-    * label *label43
    78 select *tmp37 equal .ore @coal 1 2
    79 ucontrol flag *tmp37
    80 select *tmp39 equal .ore @coal .coreX .containerX
 
    96 set .scrapDistance :findOreToMine:dist
    97 label *label57
    98 label *label54
-    * label *label55
    99 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   100 label *label41
   101 jump *label38 always
   102 label *label39
   103 jump *label58 notEqual :backgroundProcess:flag 1
-    * label *label59
   104 print "Mining "
   105 printchar @coal
   106 jump *label61 equal .ore @coal
 
   109 ucontrol itemDrop .core 30
   110 ucontrol flag 3
   111 label *label61
-    * label *label62
   112 sensor *tmp55 @unit @firstItem
   113 jump *label63 equal *tmp55 @coal
   114 print " (dropping)"
   115 ucontrol itemDrop @air 30
   116 label *label63
-    * label *label64
   117 print " at "
   118 print .coalX
   119 print ","
 
   139 ucontrol itemDrop .core 30
   140 ucontrol flag 3
   141 label *label69
-    * label *label70
   142 label *label67
-    * label *label68
   143 label *label66
   144 print "\n"
-    * label *label60
   145 jump *label38 always
   146 label *label58
   147 jump *label71 notEqual :backgroundProcess:flag 2
-    * label *label72
   148 print "Mining "
   149 printchar @scrap
   150 jump *label74 equal .ore @scrap
 
   153 ucontrol itemDrop .container 30
   154 ucontrol flag 4
   155 label *label74
-    * label *label75
   156 sensor *tmp68 @unit @firstItem
   157 jump *label76 equal *tmp68 @scrap
   158 print " (dropping)"
   159 ucontrol itemDrop @air 30
   160 label *label76
-    * label *label77
   161 print " at "
   162 print .scrapX
   163 print ","
 
   183 ucontrol itemDrop .container 30
   184 ucontrol flag 4
   185 label *label82
-    * label *label83
   186 label *label80
-    * label *label81
   187 label *label79
   188 print "\n"
-    * label *label73
   189 jump *label38 always
   190 label *label71
   191 jump *label84 notEqual :backgroundProcess:flag 3
-    * label *label85
   192 print "Returning"
   193 print "\n"
   194 ucontrol approach .coreX .coreY 6
 
   199 print "\n"
   200 ucontrol flag 0
   201 label *label87
-    * label *label88
-    * label *label86
   202 jump *label38 always
   203 label *label84
   204 jump *label89 notEqual :backgroundProcess:flag 4
-    * label *label90
   205 print "Returning"
   206 print "\n"
   207 ucontrol approach .containerX .containerY 6
 
   212 print "\n"
   213 ucontrol flag 0
   214 label *label92
-    * label *label93
-    * label *label91
   215 label *label89
   216 label *label38
   217 label *label24
   218 label *label22
   219 label *label19
   220 jump *label18 always
-    * label *label20
   221 label *label15
   222 wait 1e12
   223 jump *label14 always
 
   228 sensor .thoriumContainerY :setThoriumContainer:container @y
   229 sensor *tmp87 .thoriumContainer @itemCapacity
   230 select .thoriumLimit greaterThan *tmp87 10 100 0
-    * label *label94
   231 set :setThoriumContainer*finished true
   232 jump *label14 always
   233 end
 
   235 set .container :setScrapContainer:scrapContainer
   236 sensor .containerX .container @x
   237 sensor .containerY .container @y
-    * label *label97
   238 set :setScrapContainer*finished true
   239 jump *label14 always
   240 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    19 jump *label11 equal .core null
    20 set *signature "2bc8cecff9ae5b38:v1"
    21 label *label14
-    * jump *label16 notEqual .core null
-    * jump *label15 always
+   22 jump *label15 equal .core null
    23 label *label16
    24 label *label18
    25 ubind @poly

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    20 set *signature "2bc8cecff9ae5b38:v1"
    21 label *label14
    22 jump *label15 equal .core null
-    * label *label16
    23 label *label18
    24 ubind @poly
    25 jump *label21 notEqual @unit .builder

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    26 print "Found builder unit."
    27 print "\n"
    28 printflush message1
-    * jump *label22 always
+   29 jump *label18 always
    30 label *label21
    31 jump *label23 notEqual .thoriumDrone null
    32 set .thoriumDrone @unit
-    * jump *label24 always
+   33 jump *label18 always
    34 label *label23
    35 op equal *tmp11 @unit .thoriumDrone
    36 sensor *tmp12 .thoriumContainer @thorium
 
    41 jump *label28 notEqual :serviceThoriumDrill:item @thorium
    42 ucontrol approach .coreX .coreY 6
    43 ucontrol itemDrop .core 30
-    * jump *label29 always
+   44 jump *label18 always
    45 label *label28
    46 jump *label30 notEqual :serviceThoriumDrill:item null
    47 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    48 ucontrol itemTake .thoriumContainer @thorium 30
-    * jump *label31 always
+   49 jump *label18 always
    50 label *label30
    51 ucontrol itemDrop @air 30
    52 label *label31
    53 label *label29
-    * jump *label19 always
+   54 jump *label18 always
    55 label *label25
    56 jump *label32 equal .container false
    57 sensor :backgroundProcess:coal .core @coal
 
    70 jump *label44 equal *tmp33 null
    71 print "Holding wrong item."
    72 print "\n"
-    * jump *label41 always
+   73 jump *label18 always
    74 label *label44
    75 label *label42
    76 select *tmp37 equal .ore @coal 1 2
 
    96 label *label54
    97 ucontrol approach :findOreToMine:x :findOreToMine:y 6
    98 label *label41
-    * jump *label38 always
+   99 jump *label18 always
   100 label *label39
   101 jump *label58 notEqual :backgroundProcess:flag 1
   102 print "Mining "
 
   140 label *label67
   141 label *label66
   142 print "\n"
-    * jump *label38 always
+  143 jump *label18 always
   144 label *label58
   145 jump *label71 notEqual :backgroundProcess:flag 2
   146 print "Mining "
 
   184 label *label80
   185 label *label79
   186 print "\n"
-    * jump *label38 always
+  187 jump *label18 always
   188 label *label71
   189 jump *label84 notEqual :backgroundProcess:flag 3
   190 print "Returning"
 
   192 ucontrol approach .coreX .coreY 6
   193 ucontrol itemDrop .core 30
   194 sensor *tmp79 @unit @firstItem
-    * jump *label87 notEqual *tmp79 null
+  195 jump *label18 notEqual *tmp79 null
   196 print "    Finished"
   197 print "\n"
   198 ucontrol flag 0
   199 label *label87
-    * jump *label38 always
+  200 jump *label18 always
   201 label *label84
-    * jump *label89 notEqual :backgroundProcess:flag 4
+  202 jump *label18 notEqual :backgroundProcess:flag 4
   203 print "Returning"
   204 print "\n"
   205 ucontrol approach .containerX .containerY 6
   206 ucontrol itemDrop .container 30
   207 sensor *tmp82 @unit @firstItem
-    * jump *label92 notEqual *tmp82 null
+  208 jump *label18 notEqual *tmp82 null
   209 print "    Finished"
   210 print "\n"
   211 ucontrol flag 0

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    49 jump *label18 always
    50 label *label30
    51 ucontrol itemDrop @air 30
-    * label *label31
-    * label *label29
    52 jump *label18 always
    53 label *label25
    54 jump *label32 equal .container false
 
    93 label *label57
    94 label *label54
    95 ucontrol approach :findOreToMine:x :findOreToMine:y 6
-    * label *label41
    96 jump *label18 always
    97 label *label39
    98 jump *label58 notEqual :backgroundProcess:flag 1
 
   193 print "    Finished"
   194 print "\n"
   195 ucontrol flag 0
-    * label *label87
   196 jump *label18 always
   197 label *label84
   198 jump *label18 notEqual :backgroundProcess:flag 4
 
   205 print "    Finished"
   206 print "\n"
   207 ucontrol flag 0
-    * label *label92
-    * label *label89
-    * label *label38
-    * label *label24
-    * label *label22
-    * label *label19
   208 jump *label18 always
   209 label *label15
   210 wait 1e12
   211 jump *label14 always
-    * end
   212 label *label0
   213 set .thoriumContainer :setThoriumContainer:container
   214 sensor .thoriumContainerX :setThoriumContainer:container @x
 
   217 select .thoriumLimit greaterThan *tmp87 10 100 0
   218 set :setThoriumContainer*finished true
   219 jump *label14 always
-    * end
   220 label *label2
   221 set .container :setScrapContainer:scrapContainer
   222 sensor .containerX .container @x
   223 sensor .containerY .container @y
   224 set :setScrapContainer*finished true
   225 jump *label14 always
-    * end

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
    15 label *label11
    16 ubind @poly
    17 set .builder @unit
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+   18 ulocate building core false @copper .coreX .coreY 0 .core
    19 jump *label11 equal .core null
    20 set *signature "2bc8cecff9ae5b38:v1"
    21 label *label14
 
    76 select *tmp39 equal .ore @coal .coreX .containerX
    77 select *tmp41 equal .ore @coal .coreY .containerY
    78 select *tmp43 equal .ore @coal .coalDistance .scrapDistance
-    * ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
+   79 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y 0 0
    80 op sub *tmp46 :findOreToMine:x *tmp39
    81 op sub *tmp47 :findOreToMine:y *tmp41
    82 op len :findOreToMine:dist *tmp46 *tmp47

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    23 label *label18
    24 ubind @poly
    25 jump *label21 notEqual @unit .builder
-    * print "Found builder unit."
-    * print "\n"
+   26 print "Found builder unit.\n"
    27 printflush message1
    28 jump *label18 always
    29 label *label21
 
    56 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp108
    57 label *label32
    58 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   59 print "Unit flag: {0}\n"
+   60 format :backgroundProcess:flag
    61 jump *label39 notEqual :backgroundProcess:flag 0
    62 sensor *tmp30 @unit @firstItem
    63 jump *label42 equal *tmp30 null
    64 ucontrol itemDrop @air 30
    65 sensor *tmp33 @unit @firstItem
    66 jump *label44 equal *tmp33 null
-    * print "Holding wrong item."
-    * print "\n"
+   67 print "Holding wrong item.\n"
    68 jump *label18 always
    69 label *label44
    70 label *label42
 
    93 jump *label18 always
    94 label *label39
    95 jump *label58 notEqual :backgroundProcess:flag 1
-    * print "Mining "
-    * printchar @coal
+   96 print "Mining "
    97 jump *label61 equal .ore @coal
    98 print ", switching"
    99 ucontrol approach .coreX .coreY 6
 
   105 print " (dropping)"
   106 ucontrol itemDrop @air 30
   107 label *label63
-    * print " at "
-    * print .coalX
-    * print ","
-    * print " "
+  108 print " at {0}, "
+  109 format .coalX
   110 print .coalY
   111 ucontrol approach .coalX .coalY 6
   112 ucontrol mine .coalX .coalY
 
   134 jump *label18 always
   135 label *label58
   136 jump *label71 notEqual :backgroundProcess:flag 2
-    * print "Mining "
-    * printchar @scrap
+  137 print "Mining "
   138 jump *label74 equal .ore @scrap
   139 print ", switching"
   140 ucontrol approach .containerX .containerY 6
 
   146 print " (dropping)"
   147 ucontrol itemDrop @air 30
   148 label *label76
-    * print " at "
-    * print .scrapX
-    * print ","
-    * print " "
+  149 print " at {0}, "
+  150 format .scrapX
   151 print .scrapY
   152 ucontrol approach .scrapX .scrapY 6
   153 ucontrol mine .scrapX .scrapY
 
   175 jump *label18 always
   176 label *label71
   177 jump *label84 notEqual :backgroundProcess:flag 3
-    * print "Returning"
-    * print "\n"
+  178 print "Returning\n"
   179 ucontrol approach .coreX .coreY 6
   180 ucontrol itemDrop .core 30
   181 sensor *tmp79 @unit @firstItem
   182 jump *label18 notEqual *tmp79 null
-    * print "    Finished"
-    * print "\n"
+  183 print "    Finished\n"
   184 ucontrol flag 0
   185 jump *label18 always
   186 label *label84
   187 jump *label18 notEqual :backgroundProcess:flag 4
-    * print "Returning"
-    * print "\n"
+  188 print "Returning\n"
   189 ucontrol approach .containerX .containerY 6
   190 ucontrol itemDrop .container 30
   191 sensor *tmp82 @unit @firstItem
   192 jump *label18 notEqual *tmp82 null
-    * print "    Finished"
-    * print "\n"
+  193 print "    Finished\n"
   194 ucontrol flag 0
   195 jump *label18 always
   196 label *label15

Final code before resolving virtual instructions:

    0:  jump *label10 always 0 0                                     #set target = 8;
    1:  jump *label2 always 0 0                                      ...
    2:  jump *label0 always 0 0                                      ...
        label *label10                                               ...
    3:  set .thoriumContainer null                                   volatile var
    4:  set .thoriumLimit 100                                        volatile var
    5:  set .thoriumContainerX 0                                     ...
    6:  set .thoriumContainerY 0                                     ...
    7:  set .ore @coal                                               var
    8:  set .coalX 0                                                 ...
    9:  set .coalY 0                                                 ...
   10:  set .coalDistance 1000000000                                 ...
   11:  set .scrapX 0                                                ...
   12:  set .scrapY 0                                                ...
   13:  set .scrapDistance 1000000000                                ...
        label *label11                                               do
   14:  ubind @poly                                                  builder = ubind(@poly);
   15:  set .builder @unit                                           ...
   16:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   17:  jump *label11 equal .core null                               do
   18:  set *signature "2bc8cecff9ae5b38:v1"                         #set target = 8;
        label *label14                                               ...
   19:  jump *label15 equal .core null                               if core == null then return; end;
        label *label18                                               while true do
   20:  ubind @poly                                                  ubind(@poly);
   21:  jump *label21 notEqual @unit .builder                        if @unit == builder then
   22:  print "Found builder unit.\n"                                println("Found builder unit.");
   23:  printflush message1                                          printflush(message1);
   24:  jump *label18 always 0 0                                     if @unit == builder then
        label *label21                                               ...
   25:  jump *label23 notEqual .thoriumDrone null                    elsif thoriumDrone == null then
   26:  set .thoriumDrone @unit                                      thoriumDrone = @unit;
   27:  jump *label18 always 0 0                                     elsif thoriumDrone == null then
        label *label23                                               ...
   28:  op equal *tmp11 @unit .thoriumDrone                          if @unit == thoriumDrone and thoriumContainer.@thorium > thoriumLimit then
   29:  sensor *tmp12 .thoriumContainer @thorium                     ...
   30:  op greaterThan *tmp13 *tmp12 .thoriumLimit                   ...
   31:  op land *tmp14 *tmp11 *tmp13                                 ...
   32:  jump *label25 equal *tmp14 false                             ...
   33:  sensor :serviceThoriumDrill:item @unit @firstItem            var item = @unit.@firstItem;
   34:  jump *label28 notEqual :serviceThoriumDrill:item @thorium    if item == @thorium then
   35:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   36:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   37:  jump *label18 always 0 0                                     if item == @thorium then
        label *label28                                               ...
   38:  jump *label30 notEqual :serviceThoriumDrill:item null        elsif item == null then
   39:  ucontrol approach .thoriumContainerX .thoriumContainerY 6 0  approach(thoriumContainerX, thoriumContainerY, RADIUS);
   40:  ucontrol itemTake .thoriumContainer @thorium 30 0 0          itemTake(thoriumContainer, @thorium, CAPACITY);
   41:  jump *label18 always 0 0                                     elsif item == null then
        label *label30                                               ...
   42:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   43:  jump *label18 always 0 0                                     continue;
        label *label25                                               if @unit == thoriumDrone and thoriumContainer.@thorium > thoriumLimit then
   44:  jump *label32 equal .container false                         if container then
   45:  sensor :backgroundProcess:coal .core @coal                   var coal = core.@coal;
   46:  select *tmp108 greaterThan :backgroundProcess:coal 220 @scra ore = coal < 120 ? @coal : coal > 220 ? @scrap : ore;
   47:  select .ore lessThan :backgroundProcess:coal 120 @coal *tmp1 ...
        label *label32                                               if container then
   48:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   49:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   50:  format :backgroundProcess:flag                               ...
   51:  jump *label39 notEqual :backgroundProcess:flag 0             case flag
   52:  sensor *tmp30 @unit @firstItem                               if @unit.@firstItem != null then
   53:  jump *label42 equal *tmp30 null                              ...
   54:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   55:  sensor *tmp33 @unit @firstItem                               if @unit.@firstItem != null then
   56:  jump *label44 equal *tmp33 null                              ...
   57:  print "Holding wrong item.\n"                                println($"Holding wrong item.");
   58:  jump *label18 always 0 0                                     return;
        label *label44                                               if @unit.@firstItem != null then
        label *label42                                               if @unit.@firstItem != null then
   59:  select *tmp37 equal .ore @coal 1 2                           flag(ore == @coal ? FLAG_MINE_COAL : FLAG_MINE_SCRAP);
   60:  ucontrol flag *tmp37 0 0 0 0                                 ...
   61:  select *tmp39 equal .ore @coal .coreX .containerX            var targetX = ore == @coal ? coreX : containerX;
   62:  select *tmp41 equal .ore @coal .coreY .containerY            var targetY = ore == @coal ? coreY : containerY;
   63:  select *tmp43 equal .ore @coal .coalDistance .scrapDistance  var distance = ore == @coal ? coalDistance : scrapDistance;
   64:  ulocate ore core true .ore :findOreToMine:x :findOreToMine:y ulocate(:ore, ore, out x, out y);
   65:  op sub *tmp46 :findOreToMine:x *tmp39                        var dist = len(x - targetX, y - targetY);
   66:  op sub *tmp47 :findOreToMine:y *tmp41                        ...
   67:  op len :findOreToMine:dist *tmp46 *tmp47                     ...
   68:  jump *label54 greaterThanEq :findOreToMine:dist *tmp43       if dist < distance then
   69:  jump *label56 notEqual .ore @coal                            if ore == @coal then
   70:  set .coalX :findOreToMine:x                                  coalX = x;
   71:  set .coalY :findOreToMine:y                                  coalY = y;
   72:  set .coalDistance :findOreToMine:dist                        coalDistance = dist;
   73:  jump *label57 always 0 0                                     if ore == @coal then
        label *label56                                               ...
   74:  set .scrapX :findOreToMine:x                                 scrapX = x;
   75:  set .scrapY :findOreToMine:y                                 scrapY = y;
   76:  set .scrapDistance :findOreToMine:dist                       scrapDistance = dist;
        label *label57                                               if ore == @coal then
        label *label54                                               if dist < distance then
   77:  ucontrol approach :findOreToMine:x :findOreToMine:y 6 0 0    approach(x, y, RADIUS);
   78:  jump *label18 always 0 0                                     case flag
        label *label39                                               ...
   79:  jump *label58 notEqual :backgroundProcess:flag 1             ...
   80:  print "Mining "                                             print("Mining ");
   81:  jump *label61 equal .ore @coal                               if ore != @coal then
   82:  print ", switching"                                          print(", switching");
   83:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   84:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   85:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
        label *label61                                               if ore != @coal then
   86:  sensor *tmp55 @unit @firstItem                               if @unit.@firstItem != @coal then
   87:  jump *label63 equal *tmp55 @coal                             ...
   88:  print " (dropping)"                                          print(" (dropping)");
   89:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label63                                               if @unit.@firstItem != @coal then
   90:  print " at {0}, "                                            print($" at $coalX, $coalY");
   91:  format .coalX                                                ...
   92:  print .coalY                                                 ...
   93:  ucontrol approach .coalX .coalY 6 0 0                        approach(coalX, coalY, RADIUS);
   94:  ucontrol mine .coalX .coalY 0 0 0                            mine(coalX, coalY);
   95:  sensor *tmp58 @unit @totalItems                              if @unit.@totalItems >= CAPACITY then
   96:  jump *label65 lessThan *tmp58 30                             ...
   97:  print ", full"                                               print(", full");
   98:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   99:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  100:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
  101:  jump *label66 always 0 0                                     if @unit.@totalItems >= CAPACITY then
        label *label65                                               ...
  102:  ucontrol within .coalX .coalY 6.5 *tmp61 0                   elsif within(coalX, coalY, RADIUS + 0.5) then
  103:  jump *label67 equal *tmp61 false                             ...
  104:  sensor *tmp63 @unit @mining                                  if !@unit.@mining then
  105:  jump *label69 notEqual *tmp63 false                          ...
  106:  print ", ore lost"                                           print(", ore lost");
  107:  set .coalDistance 1000000000                                 coalDistance = 1e9;
  108:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
  109:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  110:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
        label *label69                                               if !@unit.@mining then
        label *label67                                               elsif within(coalX, coalY, RADIUS + 0.5) then
        label *label66                                               if @unit.@totalItems >= CAPACITY then
  111:  print "\n"                                                   println();
  112:  jump *label18 always 0 0                                     case flag
        label *label58                                               ...
  113:  jump *label71 notEqual :backgroundProcess:flag 2             ...
  114:  print "Mining "                                             print("Mining ");
  115:  jump *label74 equal .ore @scrap                              if ore != @scrap then
  116:  print ", switching"                                          print(", switching");
  117:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  118:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  119:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
        label *label74                                               if ore != @scrap then
  120:  sensor *tmp68 @unit @firstItem                               if @unit.@firstItem != @scrap then
  121:  jump *label76 equal *tmp68 @scrap                            ...
  122:  print " (dropping)"                                          print(" (dropping)");
  123:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label76                                               if @unit.@firstItem != @scrap then
  124:  print " at {0}, "                                            print($" at $scrapX, $scrapY");
  125:  format .scrapX                                               ...
  126:  print .scrapY                                                ...
  127:  ucontrol approach .scrapX .scrapY 6 0 0                      approach(scrapX, scrapY, RADIUS);
  128:  ucontrol mine .scrapX .scrapY 0 0 0                          mine(scrapX, scrapY);
  129:  sensor *tmp71 @unit @totalItems                              if @unit.@totalItems >= SCRAP_CAPACITY then
  130:  jump *label78 lessThan *tmp71 25                             ...
  131:  print ", full"                                               print(", full");
  132:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  133:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  134:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
  135:  jump *label79 always 0 0                                     if @unit.@totalItems >= SCRAP_CAPACITY then
        label *label78                                               ...
  136:  ucontrol within .scrapX .scrapY 6.5 *tmp74 0                 elsif within(scrapX, scrapY, RADIUS + 0.5) then
  137:  jump *label80 equal *tmp74 false                             ...
  138:  sensor *tmp76 @unit @mining                                  if !@unit.@mining then
  139:  jump *label82 notEqual *tmp76 false                          ...
  140:  print ", ore lost"                                           print(", ore lost");
  141:  set .scrapDistance 1000000000                                scrapDistance = 1e9;
  142:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  143:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  144:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
        label *label82                                               if !@unit.@mining then
        label *label80                                               elsif within(scrapX, scrapY, RADIUS + 0.5) then
        label *label79                                               if @unit.@totalItems >= SCRAP_CAPACITY then
  145:  print "\n"                                                   println();
  146:  jump *label18 always 0 0                                     case flag
        label *label71                                               ...
  147:  jump *label84 notEqual :backgroundProcess:flag 3             ...
  148:  print "Returning\n"                                          println("Returning");
  149:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
  150:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  151:  sensor *tmp79 @unit @firstItem                               if @unit.@firstItem == null then
  152:  jump *label18 notEqual *tmp79 null                           ...
  153:  print "    Finished\n"                                       println("    Finished");
  154:  ucontrol flag 0 0 0 0 0                                      flag(FLAG_FREE);
  155:  jump *label18 always 0 0                                     case flag
        label *label84                                               ...
  156:  jump *label18 notEqual :backgroundProcess:flag 4             ...
  157:  print "Returning\n"                                          println("Returning");
  158:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  159:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  160:  sensor *tmp82 @unit @firstItem                               if @unit.@firstItem == null then
  161:  jump *label18 notEqual *tmp82 null                           ...
  162:  print "    Finished\n"                                       println("    Finished");
  163:  ucontrol flag 0 0 0 0 0                                      flag(FLAG_FREE);
  164:  jump *label18 always 0 0                                     while true do
        label *label15                                               void backgroundProcess()
  165:  wait 1e12                                                    #set target = 8;
  166:  jump *label14 always 0 0                                     ...
        label *label0                                                export void setThoriumContainer(container)
  167:  set .thoriumContainer :setThoriumContainer:container         thoriumContainer = container;
  168:  sensor .thoriumContainerX :setThoriumContainer:container @x  thoriumContainerX = container.@x;
  169:  sensor .thoriumContainerY :setThoriumContainer:container @y  thoriumContainerY = container.@y;
  170:  sensor *tmp87 .thoriumContainer @itemCapacity                thoriumLimit = thoriumContainer.@itemCapacity > 10 ? 100 : 0;
  171:  select .thoriumLimit greaterThan *tmp87 10 100 0             ...
  172:  set :setThoriumContainer*finished true                       export void setThoriumContainer(container)
  173:  jump *label14 always 0 0                                     ...
        label *label2                                                export void setScrapContainer(scrapContainer)
  174:  set .container :setScrapContainer:scrapContainer             container = scrapContainer;
  175:  sensor .containerX .container @x                             containerX = container.@x;
  176:  sensor .containerY .container @y                             containerY = container.@y;
  177:  set :setScrapContainer*finished true                         export void setScrapContainer(scrapContainer)
  178:  jump *label14 always 0 0                                     ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    32     1x     32,0  void backgroundProcess()
    32     1x     32,0  void mineCoal()
    32     1x     32,0  void mineScrap()
    26     1x     26,0  void findOreToMine()
    21     1x     21,0  <no function>
    10     1x     10,0  void serviceThoriumDrill()
     7     1x      7,0  export void setThoriumContainer(in container)
     7     1x      7,0  void returnCoal()
     7     1x      7,0  void returnScrap()
     6     1x      6,0  export void setScrapContainer(in scrapContainer)

Performance: parsed in 303 ms, compiled in 264 ms, optimized in 356 ms, run in 10 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (13 steps):
The program didn't generate any output.
Execution exception at instruction 14: ubind @poly:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
