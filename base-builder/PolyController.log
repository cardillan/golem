   339 instructions before optimizations.
    12 instructions eliminated by Temp Variables Elimination (3 passes, 7 iterations).
     1 instructions eliminated by Case Expression Optimization.
    52 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    29 instructions eliminated by Condition Optimization (6 iterations).
    18 instructions eliminated by Single Step Elimination (6 iterations).
    21 instructions eliminated by Boolean Optimization (7 iterations).
       7 fully-evaluated expressions optimized using selects.
     4 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     3 instructions eliminated by Case Switching (4 iterations).
     1 case expressions converted to fast dispatch by Case Switching.
     6 instructions eliminated by Jump Straightening (2 passes, 7 iterations).
    13 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   176 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 802):
  * Fast-dispatch case at line 88:13                             size    -4, benefit       12.5, efficiency   Infinity (-3 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   115 print "Unit flag: "
   116 print :backgroundProcess:flag
   117 print "\n"
-    * set *tmp28 :backgroundProcess:flag
-    * jump *label42 equal *tmp28 0
+  118 jump *label42 equal :backgroundProcess:flag 0
   119 jump *label41 always
   120 label *label42
   121 sensor *tmp29 @unit @firstItem
 
   200 set *tmp27 null
   201 jump *label40 always
   202 label *label41
-    * jump *label61 equal *tmp28 1
+  203 jump *label61 equal :backgroundProcess:flag 1
   204 jump *label60 always
   205 label *label61
   206 print "Mining "
 
   270 set *tmp27 null
   271 jump *label40 always
   272 label *label60
-    * jump *label74 equal *tmp28 2
+  273 jump *label74 equal :backgroundProcess:flag 2
   274 jump *label73 always
   275 label *label74
   276 print "Mining "
 
   340 set *tmp27 null
   341 jump *label40 always
   342 label *label73
-    * jump *label87 equal *tmp28 3
+  343 jump *label87 equal :backgroundProcess:flag 3
   344 jump *label86 always
   345 label *label87
   346 print "Returning"
 
   362 set *tmp27 null
   363 jump *label40 always
   364 label *label86
-    * jump *label92 equal *tmp28 4
+  365 jump *label92 equal :backgroundProcess:flag 4
   366 jump *label91 always
   367 label *label92
   368 print "Returning"

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-30 instructions):
 
    28 op equal *tmp4 .core null
    29 jump *label16 equal *tmp4 false
    30 jump *label15 always
-    * set *tmp5 null
    31 jump *label17 always
    32 label *label16
-    * set *tmp5 null
    33 label *label17
    34 label *label18
    35 jump *label20 equal true false
 
    39 print "Found builder unit."
    40 print "\n"
    41 printflush message1
-    * set *tmp7 null
    42 jump *label22 always
    43 label *label21
    44 op equal *tmp8 .thoriumDrone null
 
    62 jump *label30 equal *tmp16 false
    63 ucontrol approach .coreX .coreY 6
    64 ucontrol itemDrop .core 30
-    * set *tmp17 null
    65 jump *label31 always
    66 label *label30
    67 op equal *tmp18 :serviceThoriumDrill:item null
 
    74 ucontrol itemDrop @air 30
    75 set *tmp19 null
    76 label *label33
-    * set *tmp17 *tmp19
    77 label *label31
    78 label *label29
    79 jump *label19 always
-    * set *tmp14 null
    80 jump *label26 always
    81 label *label25
-    * set *tmp14 null
    82 label *label26
    83 jump *label34 equal .container false
    84 sensor *tmp21 .core @coal
 
    98 set *tmp23 *tmp25
    99 label *label37
   100 set .ore *tmp23
-    * set *tmp20 .ore
   101 jump *label35 always
   102 label *label34
-    * set *tmp20 null
   103 label *label35
   104 sensor *tmp26 @unit @flag
   105 set :backgroundProcess:flag *tmp26
 
   124 label *label46
   125 set *tmp34 null
   126 label *label47
-    * set *tmp31 *tmp34
   127 jump *label45 always
   128 label *label44
-    * set *tmp31 null
   129 label *label45
   130 op equal *tmp35 .ore @coal
   131 jump *label48 equal *tmp35 false
 
   179 set .scrapDistance :findOreToMine:dist
   180 set *tmp51 .scrapDistance
   181 label *label59
-    * set *tmp49 *tmp51
   182 jump *label57 always
   183 label *label56
-    * set *tmp49 null
   184 label *label57
   185 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   186 label *label43
 
   198 ucontrol approach .coreX .coreY 6
   199 ucontrol itemDrop .core 30
   200 ucontrol flag 3
-    * set *tmp53 null
   201 jump *label64 always
   202 label *label63
-    * set *tmp53 null
   203 label *label64
   204 sensor *tmp54 @unit @firstItem
   205 op notEqual *tmp55 *tmp54 @coal
   206 jump *label65 equal *tmp55 false
   207 print " (dropping)"
   208 ucontrol itemDrop @air 30
-    * set *tmp56 null
   209 jump *label66 always
   210 label *label65
-    * set *tmp56 null
   211 label *label66
   212 print " at "
   213 print .coalX
 
   223 ucontrol approach .coreX .coreY 6
   224 ucontrol itemDrop .core 30
   225 ucontrol flag 3
-    * set *tmp59 null
   226 jump *label68 always
   227 label *label67
   228 ucontrol within .coalX .coalY 6.5 *tmp60
 
   245 label *label69
   246 set *tmp61 null
   247 label *label70
-    * set *tmp59 *tmp61
   248 label *label68
   249 print "\n"
   250 label *label62
 
   262 ucontrol approach .containerX .containerY 6
   263 ucontrol itemDrop .container 30
   264 ucontrol flag 4
-    * set *tmp66 null
   265 jump *label77 always
   266 label *label76
-    * set *tmp66 null
   267 label *label77
   268 sensor *tmp67 @unit @firstItem
   269 op notEqual *tmp68 *tmp67 @scrap
   270 jump *label78 equal *tmp68 false
   271 print " (dropping)"
   272 ucontrol itemDrop @air 30
-    * set *tmp69 null
   273 jump *label79 always
   274 label *label78
-    * set *tmp69 null
   275 label *label79
   276 print " at "
   277 print .scrapX
 
   287 ucontrol approach .containerX .containerY 6
   288 ucontrol itemDrop .container 30
   289 ucontrol flag 4
-    * set *tmp72 null
   290 jump *label81 always
   291 label *label80
   292 ucontrol within .scrapX .scrapY 6.5 *tmp73
 
   309 label *label82
   310 set *tmp74 null
   311 label *label83
-    * set *tmp72 *tmp74
   312 label *label81
   313 print "\n"
   314 label *label75
 
   328 print "    Finished"
   329 print "\n"
   330 ucontrol flag 0
-    * set *tmp80 null
   331 jump *label90 always
   332 label *label89
-    * set *tmp80 null
   333 label *label90
   334 label *label88
   335 set *tmp27 null
 
   348 print "    Finished"
   349 print "\n"
   350 ucontrol flag 0
-    * set *tmp83 null
   351 jump *label95 always
   352 label *label94
-    * set *tmp83 null
   353 label *label95
   354 label *label93
   355 set *tmp27 null
 
   359 label *label40
   360 set *tmp9 *tmp27
   361 label *label24
-    * set *tmp7 *tmp9
   362 label *label22
   363 label *label19
   364 jump *label18 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-12 instructions):
 
    45 jump *label23 equal *tmp8 false
    46 set *tmp10 @unit
    47 set .thoriumDrone *tmp10
-    * set *tmp9 *tmp10
    48 jump *label24 always
    49 label *label23
    50 op equal *tmp11 @unit .thoriumDrone
 
    67 jump *label32 equal *tmp18 false
    68 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    69 ucontrol itemTake .thoriumContainer @thorium 30
-    * set *tmp19 null
    70 jump *label33 always
    71 label *label32
    72 ucontrol itemDrop @air 30
-    * set *tmp19 null
    73 label *label33
    74 label *label31
    75 label *label29
 
   116 print "Holding wrong item."
   117 print "\n"
   118 jump *label43 always
-    * set *tmp34 null
   119 jump *label47 always
   120 label *label46
-    * set *tmp34 null
   121 label *label47
   122 jump *label45 always
   123 label *label44
 
   166 set .coalX :findOreToMine:x
   167 set .coalY :findOreToMine:y
   168 set .coalDistance :findOreToMine:dist
-    * set *tmp51 .coalDistance
   169 jump *label59 always
   170 label *label58
   171 set .scrapX :findOreToMine:x
   172 set .scrapY :findOreToMine:y
   173 set .scrapDistance :findOreToMine:dist
-    * set *tmp51 .scrapDistance
   174 label *label59
   175 jump *label57 always
   176 label *label56
 
   233 label *label71
   234 set *tmp64 null
   235 label *label72
-    * set *tmp61 *tmp64
   236 jump *label70 always
   237 label *label69
-    * set *tmp61 null
   238 label *label70
   239 label *label68
   240 print "\n"
 
   295 label *label84
   296 set *tmp77 null
   297 label *label85
-    * set *tmp74 *tmp77
   298 jump *label83 always
   299 label *label82
-    * set *tmp74 null
   300 label *label83
   301 label *label81
   302 print "\n"
 
   346 label *label91
   347 set *tmp27 null
   348 label *label40
-    * set *tmp9 *tmp27
   349 label *label24
   350 label *label22
   351 label *label19

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   177 label *label57
   178 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   179 label *label43
-    * set *tmp27 null
   180 jump *label40 always
   181 label *label41
   182 jump *label61 equal :backgroundProcess:flag 1
 
   227 ucontrol approach .coreX .coreY 6
   228 ucontrol itemDrop .core 30
   229 ucontrol flag 3
-    * set *tmp64 null
   230 jump *label72 always
   231 label *label71
-    * set *tmp64 null
   232 label *label72
   233 jump *label70 always
   234 label *label69
 
   236 label *label68
   237 print "\n"
   238 label *label62
-    * set *tmp27 null
   239 jump *label40 always
   240 label *label60
   241 jump *label74 equal :backgroundProcess:flag 2
 
   286 ucontrol approach .containerX .containerY 6
   287 ucontrol itemDrop .container 30
   288 ucontrol flag 4
-    * set *tmp77 null
   289 jump *label85 always
   290 label *label84
-    * set *tmp77 null
   291 label *label85
   292 jump *label83 always
   293 label *label82
 
   295 label *label81
   296 print "\n"
   297 label *label75
-    * set *tmp27 null
   298 jump *label40 always
   299 label *label73
   300 jump *label87 equal :backgroundProcess:flag 3
 
   314 label *label89
   315 label *label90
   316 label *label88
-    * set *tmp27 null
   317 jump *label40 always
   318 label *label86
   319 jump *label92 equal :backgroundProcess:flag 4
 
   333 label *label94
   334 label *label95
   335 label *label93
-    * set *tmp27 null
   336 jump *label40 always
   337 label *label91
-    * set *tmp27 null
   338 label *label40
   339 label *label24
   340 label *label22

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-11 instructions):
 
    15 set .scrapDistance 1000000000
    16 label *label11
    17 ubind @poly
-    * set *tmp0 @unit
-    * set .builder *tmp0
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   18 set .builder @unit
+   19 ulocate building core false @copper .coreX .coreY *tmp2 .core
    20 label *label12
    21 op equal *tmp3 .core null
    22 jump *label11 notEqual *tmp3 false
 
    41 label *label21
    42 op equal *tmp8 .thoriumDrone null
    43 jump *label23 equal *tmp8 false
-    * set *tmp10 @unit
-    * set .thoriumDrone *tmp10
+   44 set .thoriumDrone @unit
    45 jump *label24 always
    46 label *label23
    47 op equal *tmp11 @unit .thoriumDrone
 
    52 jump *label25 equal *tmp13 false
    53 jump *label27 always
    54 label *label27
-    * sensor *tmp15 @unit @firstItem
-    * set :serviceThoriumDrill:item *tmp15
+   55 sensor :serviceThoriumDrill:item @unit @firstItem
    56 op equal *tmp16 :serviceThoriumDrill:item @thorium
    57 jump *label30 equal *tmp16 false
    58 ucontrol approach .coreX .coreY 6
 
    74 label *label25
    75 label *label26
    76 jump *label34 equal .container false
-    * sensor *tmp21 .core @coal
-    * set :backgroundProcess:coal *tmp21
+   77 sensor :backgroundProcess:coal .core @coal
    78 op lessThan *tmp22 :backgroundProcess:coal 120
    79 jump *label36 equal *tmp22 false
    80 set *tmp23 @coal
 
    93 jump *label35 always
    94 label *label34
    95 label *label35
-    * sensor *tmp26 @unit @flag
-    * set :backgroundProcess:flag *tmp26
+   96 sensor :backgroundProcess:flag @unit @flag
    97 print "Unit flag: "
    98 print :backgroundProcess:flag
    99 print "\n"
 
   151 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
   152 op sub *tmp45 :findOreToMine:x :findOreToMine:targetX
   153 op sub *tmp46 :findOreToMine:y :findOreToMine:targetY
-    * op len *tmp47 *tmp45 *tmp46
-    * set :findOreToMine:dist *tmp47
+  154 op len :findOreToMine:dist *tmp45 *tmp46
   155 op lessThan *tmp48 :findOreToMine:dist :findOreToMine:distance
   156 jump *label56 equal *tmp48 false
   157 op equal *tmp50 .ore @coal
 
   340 end
   341 label *label0
   342 set .thoriumContainer :setThoriumContainer:container
-    * sensor *tmp84 :setThoriumContainer:container @x
-    * set .thoriumContainerX *tmp84
-    * sensor *tmp85 :setThoriumContainer:container @y
-    * set .thoriumContainerY *tmp85
+  343 sensor .thoriumContainerX :setThoriumContainer:container @x
+  344 sensor .thoriumContainerY :setThoriumContainer:container @y
   345 sensor *tmp86 .thoriumContainer @itemCapacity
   346 op greaterThan *tmp87 *tmp86 10
   347 jump *label97 equal *tmp87 false
 
   357 end
   358 label *label2
   359 set .container :setScrapContainer:scrapContainer
-    * sensor *tmp89 .container @x
-    * set .containerX *tmp89
-    * sensor *tmp90 .container @y
-    * set .containerY *tmp90
+  360 sensor .containerX .container @x
+  361 sensor .containerY .container @y
   362 label *label99
   363 set :setScrapContainer*finished true
   364 jump *label14 always

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    30 label *label16
    31 label *label17
    32 label *label18
-    * jump *label20 equal true false
    33 ubind @poly
    34 op equal *tmp6 @unit .builder
    35 jump *label21 equal *tmp6 false

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-5 instructions):
 
    96 print "Unit flag: "
    97 print :backgroundProcess:flag
    98 print "\n"
-    * jump *label42 equal :backgroundProcess:flag 0
-    * jump *label41 always
+   99 jump *label41 notEqual :backgroundProcess:flag 0
   100 label *label42
   101 sensor *tmp29 @unit @firstItem
   102 op notEqual *tmp30 *tmp29 null
 
   170 label *label43
   171 jump *label40 always
   172 label *label41
-    * jump *label61 equal :backgroundProcess:flag 1
-    * jump *label60 always
+  173 jump *label60 notEqual :backgroundProcess:flag 1
   174 label *label61
   175 print "Mining "
   176 printchar @coal
 
   228 label *label62
   229 jump *label40 always
   230 label *label60
-    * jump *label74 equal :backgroundProcess:flag 2
-    * jump *label73 always
+  231 jump *label73 notEqual :backgroundProcess:flag 2
   232 label *label74
   233 print "Mining "
   234 printchar @scrap
 
   286 label *label75
   287 jump *label40 always
   288 label *label73
-    * jump *label87 equal :backgroundProcess:flag 3
-    * jump *label86 always
+  289 jump *label86 notEqual :backgroundProcess:flag 3
   290 label *label87
   291 print "Returning"
   292 print "\n"
 
   304 label *label88
   305 jump *label40 always
   306 label *label86
-    * jump *label92 equal :backgroundProcess:flag 4
-    * jump *label91 always
+  307 jump *label91 notEqual :backgroundProcess:flag 4
   308 label *label92
   309 print "Returning"
   310 print "\n"

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-29 instructions):
 
    18 set .builder @unit
    19 ulocate building core false @copper .coreX .coreY *tmp2 .core
    20 label *label12
-    * op equal *tmp3 .core null
-    * jump *label11 notEqual *tmp3 false
+   21 jump *label11 equal .core null
    22 label *label13
    23 set *signature "2bc8cecff9ae5b38:v1"
    24 label *label14
-    * op equal *tmp4 .core null
-    * jump *label16 equal *tmp4 false
+   25 jump *label16 notEqual .core null
    26 jump *label15 always
    27 jump *label17 always
    28 label *label16
    29 label *label17
    30 label *label18
    31 ubind @poly
-    * op equal *tmp6 @unit .builder
-    * jump *label21 equal *tmp6 false
+   32 jump *label21 notEqual @unit .builder
    33 print "Found builder unit."
    34 print "\n"
    35 printflush message1
    36 jump *label22 always
    37 label *label21
-    * op equal *tmp8 .thoriumDrone null
-    * jump *label23 equal *tmp8 false
+   38 jump *label23 notEqual .thoriumDrone null
    39 set .thoriumDrone @unit
    40 jump *label24 always
    41 label *label23
-    * op equal *tmp11 @unit .thoriumDrone
-    * jump *label25 equal *tmp11 false
+   42 jump *label25 notEqual @unit .thoriumDrone
    43 label *label28
    44 sensor *tmp12 .thoriumContainer @thorium
-    * op greaterThan *tmp13 *tmp12 .thoriumLimit
-    * jump *label25 equal *tmp13 false
+   45 jump *label25 lessThanEq *tmp12 .thoriumLimit
    46 jump *label27 always
    47 label *label27
    48 sensor :serviceThoriumDrill:item @unit @firstItem
-    * op equal *tmp16 :serviceThoriumDrill:item @thorium
-    * jump *label30 equal *tmp16 false
+   49 jump *label30 notEqual :serviceThoriumDrill:item @thorium
    50 ucontrol approach .coreX .coreY 6
    51 ucontrol itemDrop .core 30
    52 jump *label31 always
    53 label *label30
-    * op equal *tmp18 :serviceThoriumDrill:item null
-    * jump *label32 equal *tmp18 false
+   54 jump *label32 notEqual :serviceThoriumDrill:item null
    55 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    56 ucontrol itemTake .thoriumContainer @thorium 30
    57 jump *label33 always
 
    66 label *label26
    67 jump *label34 equal .container false
    68 sensor :backgroundProcess:coal .core @coal
-    * op lessThan *tmp22 :backgroundProcess:coal 120
-    * jump *label36 equal *tmp22 false
+   69 jump *label36 greaterThanEq :backgroundProcess:coal 120
    70 set *tmp23 @coal
    71 jump *label37 always
    72 label *label36
-    * op greaterThan *tmp24 :backgroundProcess:coal 220
-    * jump *label38 equal *tmp24 false
+   73 jump *label38 lessThanEq :backgroundProcess:coal 220
    74 set *tmp25 @scrap
    75 jump *label39 always
    76 label *label38
 
    89 jump *label41 notEqual :backgroundProcess:flag 0
    90 label *label42
    91 sensor *tmp29 @unit @firstItem
-    * op notEqual *tmp30 *tmp29 null
-    * jump *label44 equal *tmp30 false
+   92 jump *label44 equal *tmp29 null
    93 ucontrol itemDrop @air 30
    94 sensor *tmp32 @unit @firstItem
-    * op notEqual *tmp33 *tmp32 null
-    * jump *label46 equal *tmp33 false
+   95 jump *label46 equal *tmp32 null
    96 print "Holding wrong item."
    97 print "\n"
    98 jump *label43 always
 
   102 jump *label45 always
   103 label *label44
   104 label *label45
-    * op equal *tmp35 .ore @coal
-    * jump *label48 equal *tmp35 false
+  105 jump *label48 notEqual .ore @coal
   106 set *tmp36 1
   107 jump *label49 always
   108 label *label48
   109 set *tmp36 2
   110 label *label49
   111 ucontrol flag *tmp36
-    * op equal *tmp37 .ore @coal
-    * jump *label50 equal *tmp37 false
+  112 jump *label50 notEqual .ore @coal
   113 set *tmp38 .coreX
   114 jump *label51 always
   115 label *label50
   116 set *tmp38 .containerX
   117 label *label51
   118 set :findOreToMine:targetX *tmp38
-    * op equal *tmp39 .ore @coal
-    * jump *label52 equal *tmp39 false
+  119 jump *label52 notEqual .ore @coal
   120 set *tmp40 .coreY
   121 jump *label53 always
   122 label *label52
   123 set *tmp40 .containerY
   124 label *label53
   125 set :findOreToMine:targetY *tmp40
-    * op equal *tmp41 .ore @coal
-    * jump *label54 equal *tmp41 false
+  126 jump *label54 notEqual .ore @coal
   127 set *tmp42 .coalDistance
   128 jump *label55 always
   129 label *label54
 
   134 op sub *tmp45 :findOreToMine:x :findOreToMine:targetX
   135 op sub *tmp46 :findOreToMine:y :findOreToMine:targetY
   136 op len :findOreToMine:dist *tmp45 *tmp46
-    * op lessThan *tmp48 :findOreToMine:dist :findOreToMine:distance
-    * jump *label56 equal *tmp48 false
-    * op equal *tmp50 .ore @coal
-    * jump *label58 equal *tmp50 false
+  137 jump *label56 greaterThanEq :findOreToMine:dist :findOreToMine:distance
+  138 jump *label58 notEqual .ore @coal
   139 set .coalX :findOreToMine:x
   140 set .coalY :findOreToMine:y
   141 set .coalDistance :findOreToMine:dist
 
   156 label *label61
   157 print "Mining "
   158 printchar @coal
-    * op notEqual *tmp52 .ore @coal
-    * jump *label63 equal *tmp52 false
+  159 jump *label63 equal .ore @coal
   160 print ", switching"
   161 ucontrol approach .coreX .coreY 6
   162 ucontrol itemDrop .core 30
 
   165 label *label63
   166 label *label64
   167 sensor *tmp54 @unit @firstItem
-    * op notEqual *tmp55 *tmp54 @coal
-    * jump *label65 equal *tmp55 false
+  168 jump *label65 equal *tmp54 @coal
   169 print " (dropping)"
   170 ucontrol itemDrop @air 30
   171 jump *label66 always
 
   179 ucontrol approach .coalX .coalY 6
   180 ucontrol mine .coalX .coalY
   181 sensor *tmp57 @unit @totalItems
-    * op greaterThanEq *tmp58 *tmp57 30
-    * jump *label67 equal *tmp58 false
+  182 jump *label67 lessThan *tmp57 30
   183 print ", full"
   184 ucontrol approach .coreX .coreY 6
   185 ucontrol itemDrop .core 30
 
   189 ucontrol within .coalX .coalY 6.5 *tmp60
   190 jump *label69 equal *tmp60 false
   191 sensor *tmp62 @unit @mining
-    * op equal *tmp63 *tmp62 false
-    * jump *label71 equal *tmp63 false
+  192 jump *label71 notEqual *tmp62 false
   193 print ", ore lost"
   194 set .coalDistance 1000000000
   195 ucontrol approach .coreX .coreY 6
 
   210 label *label74
   211 print "Mining "
   212 printchar @scrap
-    * op notEqual *tmp65 .ore @scrap
-    * jump *label76 equal *tmp65 false
+  213 jump *label76 equal .ore @scrap
   214 print ", switching"
   215 ucontrol approach .containerX .containerY 6
   216 ucontrol itemDrop .container 30
 
   219 label *label76
   220 label *label77
   221 sensor *tmp67 @unit @firstItem
-    * op notEqual *tmp68 *tmp67 @scrap
-    * jump *label78 equal *tmp68 false
+  222 jump *label78 equal *tmp67 @scrap
   223 print " (dropping)"
   224 ucontrol itemDrop @air 30
   225 jump *label79 always
 
   233 ucontrol approach .scrapX .scrapY 6
   234 ucontrol mine .scrapX .scrapY
   235 sensor *tmp70 @unit @totalItems
-    * op greaterThanEq *tmp71 *tmp70 25
-    * jump *label80 equal *tmp71 false
+  236 jump *label80 lessThan *tmp70 25
   237 print ", full"
   238 ucontrol approach .containerX .containerY 6
   239 ucontrol itemDrop .container 30
 
   243 ucontrol within .scrapX .scrapY 6.5 *tmp73
   244 jump *label82 equal *tmp73 false
   245 sensor *tmp75 @unit @mining
-    * op equal *tmp76 *tmp75 false
-    * jump *label84 equal *tmp76 false
+  246 jump *label84 notEqual *tmp75 false
   247 print ", ore lost"
   248 set .scrapDistance 1000000000
   249 ucontrol approach .containerX .containerY 6
 
   267 ucontrol approach .coreX .coreY 6
   268 ucontrol itemDrop .core 30
   269 sensor *tmp78 @unit @firstItem
-    * op equal *tmp79 *tmp78 null
-    * jump *label89 equal *tmp79 false
+  270 jump *label89 notEqual *tmp78 null
   271 print "    Finished"
   272 print "\n"
   273 ucontrol flag 0
 
   284 ucontrol approach .containerX .containerY 6
   285 ucontrol itemDrop .container 30
   286 sensor *tmp81 @unit @firstItem
-    * op equal *tmp82 *tmp81 null
-    * jump *label94 equal *tmp82 false
+  287 jump *label94 notEqual *tmp81 null
   288 print "    Finished"
   289 print "\n"
   290 ucontrol flag 0
 
   309 sensor .thoriumContainerX :setThoriumContainer:container @x
   310 sensor .thoriumContainerY :setThoriumContainer:container @y
   311 sensor *tmp86 .thoriumContainer @itemCapacity
-    * op greaterThan *tmp87 *tmp86 10
-    * jump *label97 equal *tmp87 false
+  312 jump *label97 lessThanEq *tmp86 10
   313 set *tmp88 100
   314 jump *label98 always
   315 label *label97

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-18 instructions):
 
    24 label *label14
    25 jump *label16 notEqual .core null
    26 jump *label15 always
-    * jump *label17 always
    27 label *label16
    28 label *label17
    29 label *label18
 
    42 label *label28
    43 sensor *tmp12 .thoriumContainer @thorium
    44 jump *label25 lessThanEq *tmp12 .thoriumLimit
-    * jump *label27 always
    45 label *label27
    46 sensor :serviceThoriumDrill:item @unit @firstItem
    47 jump *label30 notEqual :serviceThoriumDrill:item @thorium
 
    59 label *label31
    60 label *label29
    61 jump *label19 always
-    * jump *label26 always
    62 label *label25
    63 label *label26
    64 jump *label34 equal .container false
 
    76 set *tmp23 *tmp25
    77 label *label37
    78 set .ore *tmp23
-    * jump *label35 always
    79 label *label34
    80 label *label35
    81 sensor :backgroundProcess:flag @unit @flag
 
    92 print "Holding wrong item."
    93 print "\n"
    94 jump *label43 always
-    * jump *label47 always
    95 label *label46
    96 label *label47
-    * jump *label45 always
    97 label *label44
    98 label *label45
    99 jump *label48 notEqual .ore @coal
 
   139 set .scrapY :findOreToMine:y
   140 set .scrapDistance :findOreToMine:dist
   141 label *label59
-    * jump *label57 always
   142 label *label56
   143 label *label57
   144 ucontrol approach :findOreToMine:x :findOreToMine:y 6
 
   154 ucontrol approach .coreX .coreY 6
   155 ucontrol itemDrop .core 30
   156 ucontrol flag 3
-    * jump *label64 always
   157 label *label63
   158 label *label64
   159 sensor *tmp54 @unit @firstItem
   160 jump *label65 equal *tmp54 @coal
   161 print " (dropping)"
   162 ucontrol itemDrop @air 30
-    * jump *label66 always
   163 label *label65
   164 label *label66
   165 print " at "
 
   186 ucontrol approach .coreX .coreY 6
   187 ucontrol itemDrop .core 30
   188 ucontrol flag 3
-    * jump *label72 always
   189 label *label71
   190 label *label72
-    * jump *label70 always
   191 label *label69
   192 label *label70
   193 label *label68
 
   204 ucontrol approach .containerX .containerY 6
   205 ucontrol itemDrop .container 30
   206 ucontrol flag 4
-    * jump *label77 always
   207 label *label76
   208 label *label77
   209 sensor *tmp67 @unit @firstItem
   210 jump *label78 equal *tmp67 @scrap
   211 print " (dropping)"
   212 ucontrol itemDrop @air 30
-    * jump *label79 always
   213 label *label78
   214 label *label79
   215 print " at "
 
   236 ucontrol approach .containerX .containerY 6
   237 ucontrol itemDrop .container 30
   238 ucontrol flag 4
-    * jump *label85 always
   239 label *label84
   240 label *label85
-    * jump *label83 always
   241 label *label82
   242 label *label83
   243 label *label81
 
   256 print "    Finished"
   257 print "\n"
   258 ucontrol flag 0
-    * jump *label90 always
   259 label *label89
   260 label *label90
   261 label *label88
 
   272 print "    Finished"
   273 print "\n"
   274 ucontrol flag 0
-    * jump *label95 always
   275 label *label94
   276 label *label95
   277 label *label93
-    * jump *label40 always
   278 label *label91
   279 label *label40
   280 label *label24

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   125 label *label55
   126 set :findOreToMine:distance *tmp42
   127 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
-    * op sub *tmp45 :findOreToMine:x :findOreToMine:targetX
-    * op sub *tmp46 :findOreToMine:y :findOreToMine:targetY
+  128 op sub *tmp45 :findOreToMine:x *tmp38
+  129 op sub *tmp46 :findOreToMine:y *tmp40
   130 op len :findOreToMine:dist *tmp45 *tmp46
-    * jump *label56 greaterThanEq :findOreToMine:dist :findOreToMine:distance
+  131 jump *label56 greaterThanEq :findOreToMine:dist *tmp42
   132 jump *label58 notEqual .ore @coal
   133 set .coalX :findOreToMine:x
   134 set .coalY :findOreToMine:y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
   109 label *label50
   110 set *tmp38 .containerX
   111 label *label51
-    * set :findOreToMine:targetX *tmp38
   112 jump *label52 notEqual .ore @coal
   113 set *tmp40 .coreY
   114 jump *label53 always
   115 label *label52
   116 set *tmp40 .containerY
   117 label *label53
-    * set :findOreToMine:targetY *tmp40
   118 jump *label54 notEqual .ore @coal
   119 set *tmp42 .coalDistance
   120 jump *label55 always
   121 label *label54
   122 set *tmp42 .scrapDistance
   123 label *label55
-    * set :findOreToMine:distance *tmp42
   124 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
   125 op sub *tmp45 :findOreToMine:x *tmp38
   126 op sub *tmp46 :findOreToMine:y *tmp40

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-18 instructions):
 
    39 jump *label24 always
    40 label *label23
    41 jump *label25 notEqual @unit .thoriumDrone
-    * label *label28
    42 sensor *tmp12 .thoriumContainer @thorium
    43 jump *label25 lessThanEq *tmp12 .thoriumLimit
-    * label *label27
    44 sensor :serviceThoriumDrill:item @unit @firstItem
    45 jump *label30 notEqual :serviceThoriumDrill:item @thorium
    46 ucontrol approach .coreX .coreY 6
 
    65 set *tmp23 @coal
    66 jump *label37 always
    67 label *label36
-    * jump *label38 lessThanEq :backgroundProcess:coal 220
-    * set *tmp25 @scrap
-    * jump *label39 always
-    * label *label38
-    * set *tmp25 .ore
-    * label *label39
+   68 select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
    69 set *tmp23 *tmp25
    70 label *label37
    71 set .ore *tmp23
 
    89 label *label47
    90 label *label44
    91 label *label45
-    * jump *label48 notEqual .ore @coal
-    * set *tmp36 1
-    * jump *label49 always
-    * label *label48
-    * set *tmp36 2
-    * label *label49
+   92 select *tmp36 equal .ore @coal 1 2
    93 ucontrol flag *tmp36
-    * jump *label50 notEqual .ore @coal
-    * set *tmp38 .coreX
-    * jump *label51 always
-    * label *label50
-    * set *tmp38 .containerX
-    * label *label51
-    * jump *label52 notEqual .ore @coal
-    * set *tmp40 .coreY
-    * jump *label53 always
-    * label *label52
-    * set *tmp40 .containerY
-    * label *label53
-    * jump *label54 notEqual .ore @coal
-    * set *tmp42 .coalDistance
-    * jump *label55 always
-    * label *label54
-    * set *tmp42 .scrapDistance
-    * label *label55
+   94 select *tmp38 equal .ore @coal .coreX .containerX
+   95 select *tmp40 equal .ore @coal .coreY .containerY
+   96 select *tmp42 equal .ore @coal .coalDistance .scrapDistance
    97 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
    98 op sub *tmp45 :findOreToMine:x *tmp38
    99 op sub *tmp46 :findOreToMine:y *tmp40
 
   260 set .thoriumContainer :setThoriumContainer:container
   261 sensor .thoriumContainerX :setThoriumContainer:container @x
   262 sensor .thoriumContainerY :setThoriumContainer:container @y
-    * sensor *tmp86 .thoriumContainer @itemCapacity
-    * jump *label97 lessThanEq *tmp86 10
-    * set *tmp88 100
-    * jump *label98 always
-    * label *label97
-    * set *tmp88 0
-    * label *label98
+  263 sensor *tmp86 .thoriumContainer @itemCapacity
+  264 select *tmp88 greaterThan *tmp86 10 100 0
   265 set .thoriumLimit *tmp88
   266 label *label96
   267 set :setThoriumContainer*finished true

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 2 (-3 instructions):
 
    61 label *label26
    62 jump *label34 equal .container false
    63 sensor :backgroundProcess:coal .core @coal
-    * jump *label36 greaterThanEq :backgroundProcess:coal 120
-    * set *tmp23 @coal
-    * jump *label37 always
-    * label *label36
-    * select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
-    * set *tmp23 *tmp25
-    * label *label37
+   64 select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
+   65 select *tmp23 lessThan :backgroundProcess:coal 120 @coal *tmp25
    66 set .ore *tmp23
    67 label *label34
    68 label *label35

Modifications by Fast-dispatch case at line 88:13 (-3 instructions):
 
    70 print "Unit flag: "
    71 print :backgroundProcess:flag
    72 print "\n"
-    * jump *label41 notEqual :backgroundProcess:flag 0
+   73 multijump :backgroundProcess:flag 0 0 (m:*label101)
+   74 multilabel *label107 (m:*label101)
+   75 label *label100
+   76 jump *label40 always
+   77 multilabel *label102 (m:*label101)
    78 label *label42
    79 sensor *tmp29 @unit @firstItem
    80 jump *label44 equal *tmp29 null
 
   114 label *label43
   115 jump *label40 always
   116 label *label41
-    * jump *label60 notEqual :backgroundProcess:flag 1
+  117 multilabel *label103 (m:*label101)
   118 label *label61
   119 print "Mining "
   120 printchar @coal
 
   164 label *label62
   165 jump *label40 always
   166 label *label60
-    * jump *label73 notEqual :backgroundProcess:flag 2
+  167 multilabel *label104 (m:*label101)
   168 label *label74
   169 print "Mining "
   170 printchar @scrap
 
   214 label *label75
   215 jump *label40 always
   216 label *label73
-    * jump *label86 notEqual :backgroundProcess:flag 3
+  217 multilabel *label105 (m:*label101)
   218 label *label87
   219 print "Returning"
   220 print "\n"
 
   230 label *label88
   231 jump *label40 always
   232 label *label86
-    * jump *label91 notEqual :backgroundProcess:flag 4
+  233 multilabel *label106 (m:*label101)
   234 label *label92
   235 print "Returning"
   236 print "\n"
 
   244 label *label94
   245 label *label95
   246 label *label93
-    * label *label91
   247 label *label40
   248 label *label24
   249 label *label22

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   259 sensor .thoriumContainerX :setThoriumContainer:container @x
   260 sensor .thoriumContainerY :setThoriumContainer:container @y
   261 sensor *tmp86 .thoriumContainer @itemCapacity
-    * select *tmp88 greaterThan *tmp86 10 100 0
-    * set .thoriumLimit *tmp88
+  262 select .thoriumLimit greaterThan *tmp86 10 100 0
   263 label *label96
   264 set :setThoriumContainer*finished true
   265 jump *label14 always

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-1 instructions):
 
    62 jump *label34 equal .container false
    63 sensor :backgroundProcess:coal .core @coal
    64 select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
-    * select *tmp23 lessThan :backgroundProcess:coal 120 @coal *tmp25
-    * set .ore *tmp23
+   65 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp25
    66 label *label34
    67 label *label35
    68 sensor :backgroundProcess:flag @unit @flag

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    17 ubind @poly
    18 set .builder @unit
    19 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label12
    20 jump *label11 equal .core null
-    * label *label13
    21 set *signature "2bc8cecff9ae5b38:v1"
    22 label *label14
    23 jump *label16 notEqual .core null
    24 jump *label15 always
    25 label *label16
-    * label *label17
    26 label *label18
    27 ubind @poly
    28 jump *label21 notEqual @unit .builder
 
    52 ucontrol itemDrop @air 30
    53 label *label33
    54 label *label31
-    * label *label29
    55 jump *label19 always
    56 label *label25
-    * label *label26
    57 jump *label34 equal .container false
    58 sensor :backgroundProcess:coal .core @coal
    59 select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
    60 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp25
    61 label *label34
-    * label *label35
    62 sensor :backgroundProcess:flag @unit @flag
    63 print "Unit flag: "
    64 print :backgroundProcess:flag
    65 print "\n"
    66 multijump :backgroundProcess:flag 0 0 (m:*label101)
    67 multilabel *label107 (m:*label101)
-    * label *label100
    68 jump *label40 always
    69 multilabel *label102 (m:*label101)
-    * label *label42
    70 sensor *tmp29 @unit @firstItem
    71 jump *label44 equal *tmp29 null
    72 ucontrol itemDrop @air 30
 
    76 print "\n"
    77 jump *label43 always
    78 label *label46
-    * label *label47
    79 label *label44
-    * label *label45
    80 select *tmp36 equal .ore @coal 1 2
    81 ucontrol flag *tmp36
    82 select *tmp38 equal .ore @coal .coreX .containerX
 
    98 set .scrapDistance :findOreToMine:dist
    99 label *label59
   100 label *label56
-    * label *label57
   101 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   102 label *label43
   103 jump *label40 always
-    * label *label41
   104 multilabel *label103 (m:*label101)
-    * label *label61
   105 print "Mining "
   106 printchar @coal
   107 jump *label63 equal .ore @coal
 
   110 ucontrol itemDrop .core 30
   111 ucontrol flag 3
   112 label *label63
-    * label *label64
   113 sensor *tmp54 @unit @firstItem
   114 jump *label65 equal *tmp54 @coal
   115 print " (dropping)"
   116 ucontrol itemDrop @air 30
   117 label *label65
-    * label *label66
   118 print " at "
   119 print .coalX
   120 print ","
 
   140 ucontrol itemDrop .core 30
   141 ucontrol flag 3
   142 label *label71
-    * label *label72
   143 label *label69
-    * label *label70
   144 label *label68
   145 print "\n"
-    * label *label62
   146 jump *label40 always
-    * label *label60
   147 multilabel *label104 (m:*label101)
-    * label *label74
   148 print "Mining "
   149 printchar @scrap
   150 jump *label76 equal .ore @scrap
 
   153 ucontrol itemDrop .container 30
   154 ucontrol flag 4
   155 label *label76
-    * label *label77
   156 sensor *tmp67 @unit @firstItem
   157 jump *label78 equal *tmp67 @scrap
   158 print " (dropping)"
   159 ucontrol itemDrop @air 30
   160 label *label78
-    * label *label79
   161 print " at "
   162 print .scrapX
   163 print ","
 
   183 ucontrol itemDrop .container 30
   184 ucontrol flag 4
   185 label *label84
-    * label *label85
   186 label *label82
-    * label *label83
   187 label *label81
   188 print "\n"
-    * label *label75
   189 jump *label40 always
-    * label *label73
   190 multilabel *label105 (m:*label101)
-    * label *label87
   191 print "Returning"
   192 print "\n"
   193 ucontrol approach .coreX .coreY 6
 
   198 print "\n"
   199 ucontrol flag 0
   200 label *label89
-    * label *label90
-    * label *label88
   201 jump *label40 always
-    * label *label86
   202 multilabel *label106 (m:*label101)
-    * label *label92
   203 print "Returning"
   204 print "\n"
   205 ucontrol approach .containerX .containerY 6
 
   210 print "\n"
   211 ucontrol flag 0
   212 label *label94
-    * label *label95
-    * label *label93
   213 label *label40
   214 label *label24
   215 label *label22
   216 label *label19
   217 jump *label18 always
-    * label *label20
   218 label *label15
   219 wait 1e12
   220 jump *label14 always
-    * end
   221 label *label0
   222 set .thoriumContainer :setThoriumContainer:container
   223 sensor .thoriumContainerX :setThoriumContainer:container @x
   224 sensor .thoriumContainerY :setThoriumContainer:container @y
   225 sensor *tmp86 .thoriumContainer @itemCapacity
   226 select .thoriumLimit greaterThan *tmp86 10 100 0
-    * label *label96
   227 set :setThoriumContainer*finished true
   228 jump *label14 always
-    * end
   229 label *label2
   230 set .container :setScrapContainer:scrapContainer
   231 sensor .containerX .container @x
   232 sensor .containerY .container @y
-    * label *label99
   233 set :setScrapContainer*finished true
   234 jump *label14 always
-    * end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    20 jump *label11 equal .core null
    21 set *signature "2bc8cecff9ae5b38:v1"
    22 label *label14
-    * jump *label16 notEqual .core null
-    * jump *label15 always
+   23 jump *label15 equal .core null
    24 label *label16
    25 label *label18
    26 ubind @poly

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    27 print "Found builder unit."
    28 print "\n"
    29 printflush message1
-    * jump *label22 always
+   30 jump *label18 always
    31 label *label21
    32 jump *label23 notEqual .thoriumDrone null
    33 set .thoriumDrone @unit
-    * jump *label24 always
+   34 jump *label18 always
    35 label *label23
    36 jump *label25 notEqual @unit .thoriumDrone
    37 sensor *tmp12 .thoriumContainer @thorium
 
    40 jump *label30 notEqual :serviceThoriumDrill:item @thorium
    41 ucontrol approach .coreX .coreY 6
    42 ucontrol itemDrop .core 30
-    * jump *label31 always
+   43 jump *label18 always
    44 label *label30
    45 jump *label32 notEqual :serviceThoriumDrill:item null
    46 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    47 ucontrol itemTake .thoriumContainer @thorium 30
-    * jump *label33 always
+   48 jump *label18 always
    49 label *label32
    50 ucontrol itemDrop @air 30
    51 label *label33
    52 label *label31
-    * jump *label19 always
+   53 jump *label18 always
    54 label *label25
    55 jump *label34 equal .container false
    56 sensor :backgroundProcess:coal .core @coal
 
    63 print "\n"
    64 multijump :backgroundProcess:flag 0 0 (m:*label101)
    65 multilabel *label107 (m:*label101)
-    * jump *label40 always
+   66 jump *label18 always
    67 multilabel *label102 (m:*label101)
    68 sensor *tmp29 @unit @firstItem
    69 jump *label44 equal *tmp29 null
 
    72 jump *label46 equal *tmp32 null
    73 print "Holding wrong item."
    74 print "\n"
-    * jump *label43 always
+   75 jump *label18 always
    76 label *label46
    77 label *label44
    78 select *tmp36 equal .ore @coal 1 2
 
    98 label *label56
    99 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   100 label *label43
-    * jump *label40 always
+  101 jump *label18 always
   102 multilabel *label103 (m:*label101)
   103 print "Mining "
   104 printchar @coal
 
   141 label *label69
   142 label *label68
   143 print "\n"
-    * jump *label40 always
+  144 jump *label18 always
   145 multilabel *label104 (m:*label101)
   146 print "Mining "
   147 printchar @scrap
 
   184 label *label82
   185 label *label81
   186 print "\n"
-    * jump *label40 always
+  187 jump *label18 always
   188 multilabel *label105 (m:*label101)
   189 print "Returning"
   190 print "\n"
   191 ucontrol approach .coreX .coreY 6
   192 ucontrol itemDrop .core 30
   193 sensor *tmp78 @unit @firstItem
-    * jump *label89 notEqual *tmp78 null
+  194 jump *label18 notEqual *tmp78 null
   195 print "    Finished"
   196 print "\n"
   197 ucontrol flag 0
   198 label *label89
-    * jump *label40 always
+  199 jump *label18 always
   200 multilabel *label106 (m:*label101)
   201 print "Returning"
   202 print "\n"
   203 ucontrol approach .containerX .containerY 6
   204 ucontrol itemDrop .container 30
   205 sensor *tmp81 @unit @firstItem
-    * jump *label94 notEqual *tmp81 null
+  206 jump *label18 notEqual *tmp81 null
   207 print "    Finished"
   208 print "\n"
   209 ucontrol flag 0

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
    16 label *label11
    17 ubind @poly
    18 set .builder @unit
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+   19 ulocate building core false @copper .coreX .coreY 0 .core
    20 jump *label11 equal .core null
    21 set *signature "2bc8cecff9ae5b38:v1"
    22 label *label14
 
    78 select *tmp38 equal .ore @coal .coreX .containerX
    79 select *tmp40 equal .ore @coal .coreY .containerY
    80 select *tmp42 equal .ore @coal .coalDistance .scrapDistance
-    * ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
+   81 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y 0 0
    82 op sub *tmp45 :findOreToMine:x *tmp38
    83 op sub *tmp46 :findOreToMine:y *tmp40
    84 op len :findOreToMine:dist *tmp45 *tmp46

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    24 label *label18
    25 ubind @poly
    26 jump *label21 notEqual @unit .builder
-    * print "Found builder unit."
-    * print "\n"
+   27 print "Found builder unit.\n"
    28 printflush message1
    29 jump *label18 always
    30 label *label21
 
    55 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp25
    56 label *label34
    57 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   58 print "Unit flag: {0}\n"
+   59 format :backgroundProcess:flag
    60 multijump :backgroundProcess:flag 0 0 (m:*label101)
    61 multilabel *label107 (m:*label101)
    62 jump *label18 always
 
    66 ucontrol itemDrop @air 30
    67 sensor *tmp32 @unit @firstItem
    68 jump *label46 equal *tmp32 null
-    * print "Holding wrong item."
-    * print "\n"
+   69 print "Holding wrong item.\n"
    70 jump *label18 always
    71 label *label46
    72 label *label44
 
    94 ucontrol approach :findOreToMine:x :findOreToMine:y 6
    95 jump *label18 always
    96 multilabel *label103 (m:*label101)
-    * print "Mining "
-    * printchar @coal
+   97 print "Mining "
    98 jump *label63 equal .ore @coal
    99 print ", switching"
   100 ucontrol approach .coreX .coreY 6
 
   106 print " (dropping)"
   107 ucontrol itemDrop @air 30
   108 label *label65
-    * print " at "
-    * print .coalX
-    * print ","
-    * print " "
+  109 print " at {0}, "
+  110 format .coalX
   111 print .coalY
   112 ucontrol approach .coalX .coalY 6
   113 ucontrol mine .coalX .coalY
 
   134 print "\n"
   135 jump *label18 always
   136 multilabel *label104 (m:*label101)
-    * print "Mining "
-    * printchar @scrap
+  137 print "Mining "
   138 jump *label76 equal .ore @scrap
   139 print ", switching"
   140 ucontrol approach .containerX .containerY 6
 
   146 print " (dropping)"
   147 ucontrol itemDrop @air 30
   148 label *label78
-    * print " at "
-    * print .scrapX
-    * print ","
-    * print " "
+  149 print " at {0}, "
+  150 format .scrapX
   151 print .scrapY
   152 ucontrol approach .scrapX .scrapY 6
   153 ucontrol mine .scrapX .scrapY
 
   174 print "\n"
   175 jump *label18 always
   176 multilabel *label105 (m:*label101)
-    * print "Returning"
-    * print "\n"
+  177 print "Returning\n"
   178 ucontrol approach .coreX .coreY 6
   179 ucontrol itemDrop .core 30
   180 sensor *tmp78 @unit @firstItem
   181 jump *label18 notEqual *tmp78 null
-    * print "    Finished"
-    * print "\n"
+  182 print "    Finished\n"
   183 ucontrol flag 0
   184 jump *label18 always
   185 multilabel *label106 (m:*label101)
-    * print "Returning"
-    * print "\n"
+  186 print "Returning\n"
   187 ucontrol approach .containerX .containerY 6
   188 ucontrol itemDrop .container 30
   189 sensor *tmp81 @unit @firstItem
   190 jump *label18 notEqual *tmp81 null
-    * print "    Finished"
-    * print "\n"
+  191 print "    Finished\n"
   192 ucontrol flag 0
   193 jump *label18 always
   194 label *label15

Final code before resolving virtual instructions:

    0:  jump *label10 always 0 0                                     #set target = 8;
    1:  jump *label2 always 0 0                                      ...
    2:  jump *label0 always 0 0                                      ...
        label *label10                                               ...
    3:  set *id "name: Base Builder - Poly Controller\nversion: v0.4 ...
    4:  set .thoriumContainer null                                   volatile var
    5:  set .thoriumLimit 100                                        volatile var
    6:  set .thoriumContainerX 0                                     ...
    7:  set .thoriumContainerY 0                                     ...
    8:  set .ore @coal                                               var
    9:  set .coalX 0                                                 ...
   10:  set .coalY 0                                                 ...
   11:  set .coalDistance 1000000000                                 ...
   12:  set .scrapX 0                                                ...
   13:  set .scrapY 0                                                ...
   14:  set .scrapDistance 1000000000                                ...
        label *label11                                               do
   15:  ubind @poly                                                  builder = ubind(@poly);
   16:  set .builder @unit                                           ...
   17:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   18:  jump *label11 equal .core null                               do
   19:  set *signature "2bc8cecff9ae5b38:v1"                         #set target = 8;
        label *label14                                               ...
   20:  jump *label15 equal .core null                               if core == null then return; end;
        label *label18                                               while true do
   21:  ubind @poly                                                  ubind(@poly);
   22:  jump *label21 notEqual @unit .builder                        if @unit == builder then
   23:  print "Found builder unit.\n"                                println("Found builder unit.");
   24:  printflush message1                                          printflush(message1);
   25:  jump *label18 always 0 0                                     if @unit == builder then
        label *label21                                               ...
   26:  jump *label23 notEqual .thoriumDrone null                    elsif thoriumDrone == null then
   27:  set .thoriumDrone @unit                                      thoriumDrone = @unit;
   28:  jump *label18 always 0 0                                     elsif thoriumDrone == null then
        label *label23                                               ...
   29:  jump *label25 notEqual @unit .thoriumDrone                   if @unit == thoriumDrone and thoriumContainer.@thorium > thoriumLimit then
   30:  sensor *tmp12 .thoriumContainer @thorium                     ...
   31:  jump *label25 lessThanEq *tmp12 .thoriumLimit                ...
   32:  sensor :serviceThoriumDrill:item @unit @firstItem            var item = @unit.@firstItem;
   33:  jump *label30 notEqual :serviceThoriumDrill:item @thorium    if item == @thorium then
   34:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   35:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   36:  jump *label18 always 0 0                                     if item == @thorium then
        label *label30                                               ...
   37:  jump *label32 notEqual :serviceThoriumDrill:item null        elsif item == null then
   38:  ucontrol approach .thoriumContainerX .thoriumContainerY 6 0  approach(thoriumContainerX, thoriumContainerY, RADIUS);
   39:  ucontrol itemTake .thoriumContainer @thorium 30 0 0          itemTake(thoriumContainer, @thorium, CAPACITY);
   40:  jump *label18 always 0 0                                     elsif item == null then
        label *label32                                               ...
   41:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   42:  jump *label18 always 0 0                                     continue;
        label *label25                                               if @unit == thoriumDrone and thoriumContainer.@thorium > thoriumLimit then
   43:  jump *label34 equal .container false                         if container then
   44:  sensor :backgroundProcess:coal .core @coal                   var coal = core.@coal;
   45:  select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap ore = coal < 120 ? @coal : coal > 220 ? @scrap : ore;
   46:  select .ore lessThan :backgroundProcess:coal 120 @coal *tmp2 ...
        label *label34                                               if container then
   47:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   48:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   49:  format :backgroundProcess:flag                               ...
   50:  multijump :backgroundProcess:flag 0 0                        case flag
        multilabel *label107                                         ...
   51:  jump *label18 always 0 0                                     ...
        multilabel *label102                                         ...
   52:  sensor *tmp29 @unit @firstItem                               if @unit.@firstItem != null then
   53:  jump *label44 equal *tmp29 null                              ...
   54:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   55:  sensor *tmp32 @unit @firstItem                               if @unit.@firstItem != null then
   56:  jump *label46 equal *tmp32 null                              ...
   57:  print "Holding wrong item.\n"                                println($"Holding wrong item.");
   58:  jump *label18 always 0 0                                     return;
        label *label46                                               if @unit.@firstItem != null then
        label *label44                                               if @unit.@firstItem != null then
   59:  select *tmp36 equal .ore @coal 1 2                           flag(ore == @coal ? FLAG_MINE_COAL : FLAG_MINE_SCRAP);
   60:  ucontrol flag *tmp36 0 0 0 0                                 ...
   61:  select *tmp38 equal .ore @coal .coreX .containerX            var targetX = ore == @coal ? coreX : containerX;
   62:  select *tmp40 equal .ore @coal .coreY .containerY            var targetY = ore == @coal ? coreY : containerY;
   63:  select *tmp42 equal .ore @coal .coalDistance .scrapDistance  var distance = ore == @coal ? coalDistance : scrapDistance;
   64:  ulocate ore core true .ore :findOreToMine:x :findOreToMine:y ulocate(:ore, ore, out x, out y);
   65:  op sub *tmp45 :findOreToMine:x *tmp38                        var dist = len(x - targetX, y - targetY);
   66:  op sub *tmp46 :findOreToMine:y *tmp40                        ...
   67:  op len :findOreToMine:dist *tmp45 *tmp46                     ...
   68:  jump *label56 greaterThanEq :findOreToMine:dist *tmp42       if dist < distance then
   69:  jump *label58 notEqual .ore @coal                            if ore == @coal then
   70:  set .coalX :findOreToMine:x                                  coalX = x;
   71:  set .coalY :findOreToMine:y                                  coalY = y;
   72:  set .coalDistance :findOreToMine:dist                        coalDistance = dist;
   73:  jump *label59 always 0 0                                     if ore == @coal then
        label *label58                                               ...
   74:  set .scrapX :findOreToMine:x                                 scrapX = x;
   75:  set .scrapY :findOreToMine:y                                 scrapY = y;
   76:  set .scrapDistance :findOreToMine:dist                       scrapDistance = dist;
        label *label59                                               if ore == @coal then
        label *label56                                               if dist < distance then
   77:  ucontrol approach :findOreToMine:x :findOreToMine:y 6 0 0    approach(x, y, RADIUS);
   78:  jump *label18 always 0 0                                     case flag
        multilabel *label103                                         ...
   79:  print "Mining "                                             print("Mining ");
   80:  jump *label63 equal .ore @coal                               if ore != @coal then
   81:  print ", switching"                                          print(", switching");
   82:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   83:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   84:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
        label *label63                                               if ore != @coal then
   85:  sensor *tmp54 @unit @firstItem                               if @unit.@firstItem != @coal then
   86:  jump *label65 equal *tmp54 @coal                             ...
   87:  print " (dropping)"                                          print(" (dropping)");
   88:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label65                                               if @unit.@firstItem != @coal then
   89:  print " at {0}, "                                            print($" at $coalX, $coalY");
   90:  format .coalX                                                ...
   91:  print .coalY                                                 ...
   92:  ucontrol approach .coalX .coalY 6 0 0                        approach(coalX, coalY, RADIUS);
   93:  ucontrol mine .coalX .coalY 0 0 0                            mine(coalX, coalY);
   94:  sensor *tmp57 @unit @totalItems                              if @unit.@totalItems >= CAPACITY then
   95:  jump *label67 lessThan *tmp57 30                             ...
   96:  print ", full"                                               print(", full");
   97:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   98:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   99:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
  100:  jump *label68 always 0 0                                     if @unit.@totalItems >= CAPACITY then
        label *label67                                               ...
  101:  ucontrol within .coalX .coalY 6.5 *tmp60 0                   elsif within(coalX, coalY, RADIUS + 0.5) then
  102:  jump *label69 equal *tmp60 false                             ...
  103:  sensor *tmp62 @unit @mining                                  if !@unit.@mining then
  104:  jump *label71 notEqual *tmp62 false                          ...
  105:  print ", ore lost"                                           print(", ore lost");
  106:  set .coalDistance 1000000000                                 coalDistance = 1e9;
  107:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
  108:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  109:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
        label *label71                                               if !@unit.@mining then
        label *label69                                               elsif within(coalX, coalY, RADIUS + 0.5) then
        label *label68                                               if @unit.@totalItems >= CAPACITY then
  110:  print "\n"                                                   println();
  111:  jump *label18 always 0 0                                     case flag
        multilabel *label104                                         ...
  112:  print "Mining "                                             print("Mining ");
  113:  jump *label76 equal .ore @scrap                              if ore != @scrap then
  114:  print ", switching"                                          print(", switching");
  115:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  116:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  117:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
        label *label76                                               if ore != @scrap then
  118:  sensor *tmp67 @unit @firstItem                               if @unit.@firstItem != @scrap then
  119:  jump *label78 equal *tmp67 @scrap                            ...
  120:  print " (dropping)"                                          print(" (dropping)");
  121:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label78                                               if @unit.@firstItem != @scrap then
  122:  print " at {0}, "                                            print($" at $scrapX, $scrapY");
  123:  format .scrapX                                               ...
  124:  print .scrapY                                                ...
  125:  ucontrol approach .scrapX .scrapY 6 0 0                      approach(scrapX, scrapY, RADIUS);
  126:  ucontrol mine .scrapX .scrapY 0 0 0                          mine(scrapX, scrapY);
  127:  sensor *tmp70 @unit @totalItems                              if @unit.@totalItems >= SCRAP_CAPACITY then
  128:  jump *label80 lessThan *tmp70 25                             ...
  129:  print ", full"                                               print(", full");
  130:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  131:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  132:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
  133:  jump *label81 always 0 0                                     if @unit.@totalItems >= SCRAP_CAPACITY then
        label *label80                                               ...
  134:  ucontrol within .scrapX .scrapY 6.5 *tmp73 0                 elsif within(scrapX, scrapY, RADIUS + 0.5) then
  135:  jump *label82 equal *tmp73 false                             ...
  136:  sensor *tmp75 @unit @mining                                  if !@unit.@mining then
  137:  jump *label84 notEqual *tmp75 false                          ...
  138:  print ", ore lost"                                           print(", ore lost");
  139:  set .scrapDistance 1000000000                                scrapDistance = 1e9;
  140:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  141:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  142:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
        label *label84                                               if !@unit.@mining then
        label *label82                                               elsif within(scrapX, scrapY, RADIUS + 0.5) then
        label *label81                                               if @unit.@totalItems >= SCRAP_CAPACITY then
  143:  print "\n"                                                   println();
  144:  jump *label18 always 0 0                                     case flag
        multilabel *label105                                         ...
  145:  print "Returning\n"                                          println("Returning");
  146:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
  147:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  148:  sensor *tmp78 @unit @firstItem                               if @unit.@firstItem == null then
  149:  jump *label18 notEqual *tmp78 null                           ...
  150:  print "    Finished\n"                                       println("    Finished");
  151:  ucontrol flag 0 0 0 0 0                                      flag(FLAG_FREE);
  152:  jump *label18 always 0 0                                     case flag
        multilabel *label106                                         ...
  153:  print "Returning\n"                                          println("Returning");
  154:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  155:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  156:  sensor *tmp81 @unit @firstItem                               if @unit.@firstItem == null then
  157:  jump *label18 notEqual *tmp81 null                           ...
  158:  print "    Finished\n"                                       println("    Finished");
  159:  ucontrol flag 0 0 0 0 0                                      flag(FLAG_FREE);
  160:  jump *label18 always 0 0                                     while true do
        label *label15                                               void backgroundProcess()
  161:  wait 1e12                                                    #set target = 8;
  162:  jump *label14 always 0 0                                     ...
        label *label0                                                export void setThoriumContainer(container)
  163:  set .thoriumContainer :setThoriumContainer:container         thoriumContainer = container;
  164:  sensor .thoriumContainerX :setThoriumContainer:container @x  thoriumContainerX = container.@x;
  165:  sensor .thoriumContainerY :setThoriumContainer:container @y  thoriumContainerY = container.@y;
  166:  sensor *tmp86 .thoriumContainer @itemCapacity                thoriumLimit = thoriumContainer.@itemCapacity > 10 ? 100 : 0;
  167:  select .thoriumLimit greaterThan *tmp86 10 100 0             ...
  168:  set :setThoriumContainer*finished true                       export void setThoriumContainer(container)
  169:  jump *label14 always 0 0                                     ...
        label *label2                                                export void setScrapContainer(scrapContainer)
  170:  set .container :setScrapContainer:scrapContainer             container = scrapContainer;
  171:  sensor .containerX .container @x                             containerX = container.@x;
  172:  sensor .containerY .container @y                             containerY = container.@y;
  173:  set :setScrapContainer*finished true                         export void setScrapContainer(scrapContainer)
  174:  jump *label14 always 0 0                                     ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    32     1x     32,0  void mineCoal()
    32     1x     32,0  void mineScrap()
    27     1x     27,0  void backgroundProcess()
    26     1x     26,0  void findOreToMine()
    22     1x     22,0  <no function>
    10     1x     10,0  void serviceThoriumDrill()
     7     1x      7,0  export void setThoriumContainer(in container)
     7     1x      7,0  void returnCoal()
     7     1x      7,0  void returnScrap()
     6     1x      6,0  export void setScrapContainer(in scrapContainer)
