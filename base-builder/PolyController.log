   336 instructions before optimizations.
    12 instructions eliminated by Temp Variables Elimination (3 passes, 7 iterations).
     1 instructions eliminated by Case Expression Optimization.
    52 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    27 instructions eliminated by Jump Optimization (5 iterations).
    17 instructions eliminated by Single Step Elimination (6 iterations).
    21 instructions eliminated by If Expression Optimization (5 iterations).
     4 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     6 instructions eliminated by Jump Straightening (2 passes, 5 iterations).
    13 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   179 instructions after optimizations.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   111 print "Unit flag: "
   112 print :backgroundProcess:flag
   113 print "\n"
-    * set *tmp29 :backgroundProcess:flag
-    * jump *label38 equal *tmp29 0
+  114 jump *label38 equal :backgroundProcess:flag 0
   115 jump *label37 always
   116 label *label38
   117 sensor *tmp30 @unit @firstItem
 
   196 set *tmp28 null
   197 jump *label36 always
   198 label *label37
-    * jump *label57 equal *tmp29 1
+  199 jump *label57 equal :backgroundProcess:flag 1
   200 jump *label56 always
   201 label *label57
   202 print "Mining "
 
   266 set *tmp28 null
   267 jump *label36 always
   268 label *label56
-    * jump *label70 equal *tmp29 2
+  269 jump *label70 equal :backgroundProcess:flag 2
   270 jump *label69 always
   271 label *label70
   272 print "Mining "
 
   336 set *tmp28 null
   337 jump *label36 always
   338 label *label69
-    * jump *label83 equal *tmp29 3
+  339 jump *label83 equal :backgroundProcess:flag 3
   340 jump *label82 always
   341 label *label83
   342 print "Returning"
 
   358 set *tmp28 null
   359 jump *label36 always
   360 label *label82
-    * jump *label88 equal *tmp29 4
+  361 jump *label88 equal :backgroundProcess:flag 4
   362 jump *label87 always
   363 label *label88
   364 print "Returning"

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-30 instructions):
 
    27 op equal *tmp4 .core null
    28 jump *label14 equal *tmp4 false
    29 jump *label13 always
-    * set *tmp5 null
    30 jump *label15 always
    31 label *label14
-    * set *tmp5 null
    32 label *label15
    33 label *label16
    34 jump *label18 equal true false
 
    38 print "Found builder unit."
    39 print "\n"
    40 printflush message1
-    * set *tmp7 null
    41 jump *label20 always
    42 label *label19
    43 op equal *tmp8 .thoriumDrone null
 
    58 jump *label26 equal *tmp17 false
    59 ucontrol approach .coreX .coreY 6
    60 ucontrol itemDrop .core 30
-    * set *tmp18 null
    61 jump *label27 always
    62 label *label26
    63 op equal *tmp19 :serviceThoriumDrill:item null
 
    70 ucontrol itemDrop @air 30
    71 set *tmp20 null
    72 label *label29
-    * set *tmp18 *tmp20
    73 label *label27
    74 label *label25
    75 jump *label17 always
-    * set *tmp15 null
    76 jump *label24 always
    77 label *label23
-    * set *tmp15 null
    78 label *label24
    79 jump *label30 equal .container false
    80 sensor *tmp22 .core @coal
 
    94 set *tmp24 *tmp26
    95 label *label33
    96 set .ore *tmp24
-    * set *tmp21 .ore
    97 jump *label31 always
    98 label *label30
-    * set *tmp21 null
    99 label *label31
   100 sensor *tmp27 @unit @flag
   101 set :backgroundProcess:flag *tmp27
 
   120 label *label42
   121 set *tmp35 null
   122 label *label43
-    * set *tmp32 *tmp35
   123 jump *label41 always
   124 label *label40
-    * set *tmp32 null
   125 label *label41
   126 op equal *tmp36 .ore @coal
   127 jump *label44 equal *tmp36 false
 
   175 set .scrapDistance :findOreToMine:dist
   176 set *tmp52 .scrapDistance
   177 label *label55
-    * set *tmp50 *tmp52
   178 jump *label53 always
   179 label *label52
-    * set *tmp50 null
   180 label *label53
   181 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   182 label *label39
 
   194 ucontrol approach .coreX .coreY 6
   195 ucontrol itemDrop .core 30
   196 ucontrol flag 3
-    * set *tmp54 null
   197 jump *label60 always
   198 label *label59
-    * set *tmp54 null
   199 label *label60
   200 sensor *tmp55 @unit @firstItem
   201 op notEqual *tmp56 *tmp55 @coal
   202 jump *label61 equal *tmp56 false
   203 print " (dropping)"
   204 ucontrol itemDrop @air 30
-    * set *tmp57 null
   205 jump *label62 always
   206 label *label61
-    * set *tmp57 null
   207 label *label62
   208 print " at "
   209 print .coalX
 
   219 ucontrol approach .coreX .coreY 6
   220 ucontrol itemDrop .core 30
   221 ucontrol flag 3
-    * set *tmp60 null
   222 jump *label64 always
   223 label *label63
   224 ucontrol within .coalX .coalY 6.5 *tmp61
 
   241 label *label65
   242 set *tmp62 null
   243 label *label66
-    * set *tmp60 *tmp62
   244 label *label64
   245 print "\n"
   246 label *label58
 
   258 ucontrol approach .containerX .containerY 6
   259 ucontrol itemDrop .container 30
   260 ucontrol flag 4
-    * set *tmp67 null
   261 jump *label73 always
   262 label *label72
-    * set *tmp67 null
   263 label *label73
   264 sensor *tmp68 @unit @firstItem
   265 op notEqual *tmp69 *tmp68 @scrap
   266 jump *label74 equal *tmp69 false
   267 print " (dropping)"
   268 ucontrol itemDrop @air 30
-    * set *tmp70 null
   269 jump *label75 always
   270 label *label74
-    * set *tmp70 null
   271 label *label75
   272 print " at "
   273 print .scrapX
 
   283 ucontrol approach .containerX .containerY 6
   284 ucontrol itemDrop .container 30
   285 ucontrol flag 4
-    * set *tmp73 null
   286 jump *label77 always
   287 label *label76
   288 ucontrol within .scrapX .scrapY 6.5 *tmp74
 
   305 label *label78
   306 set *tmp75 null
   307 label *label79
-    * set *tmp73 *tmp75
   308 label *label77
   309 print "\n"
   310 label *label71
 
   324 print "    Finished"
   325 print "\n"
   326 ucontrol flag 0
-    * set *tmp81 null
   327 jump *label86 always
   328 label *label85
-    * set *tmp81 null
   329 label *label86
   330 label *label84
   331 set *tmp28 null
 
   344 print "    Finished"
   345 print "\n"
   346 ucontrol flag 0
-    * set *tmp84 null
   347 jump *label91 always
   348 label *label90
-    * set *tmp84 null
   349 label *label91
   350 label *label89
   351 set *tmp28 null
 
   355 label *label36
   356 set *tmp9 *tmp28
   357 label *label22
-    * set *tmp7 *tmp9
   358 label *label20
   359 label *label17
   360 jump *label16 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-12 instructions):
 
    44 jump *label21 equal *tmp8 false
    45 set *tmp10 @unit
    46 set .thoriumDrone *tmp10
-    * set *tmp9 *tmp10
    47 jump *label22 always
    48 label *label21
    49 op equal *tmp11 @unit .thoriumDrone
 
    63 jump *label28 equal *tmp19 false
    64 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    65 ucontrol itemTake .thoriumContainer @thorium 30
-    * set *tmp20 null
    66 jump *label29 always
    67 label *label28
    68 ucontrol itemDrop @air 30
-    * set *tmp20 null
    69 label *label29
    70 label *label27
    71 label *label25
 
   112 print "Holding wrong item."
   113 print "\n"
   114 jump *label39 always
-    * set *tmp35 null
   115 jump *label43 always
   116 label *label42
-    * set *tmp35 null
   117 label *label43
   118 jump *label41 always
   119 label *label40
 
   162 set .coalX :findOreToMine:x
   163 set .coalY :findOreToMine:y
   164 set .coalDistance :findOreToMine:dist
-    * set *tmp52 .coalDistance
   165 jump *label55 always
   166 label *label54
   167 set .scrapX :findOreToMine:x
   168 set .scrapY :findOreToMine:y
   169 set .scrapDistance :findOreToMine:dist
-    * set *tmp52 .scrapDistance
   170 label *label55
   171 jump *label53 always
   172 label *label52
 
   229 label *label67
   230 set *tmp65 null
   231 label *label68
-    * set *tmp62 *tmp65
   232 jump *label66 always
   233 label *label65
-    * set *tmp62 null
   234 label *label66
   235 label *label64
   236 print "\n"
 
   291 label *label80
   292 set *tmp78 null
   293 label *label81
-    * set *tmp75 *tmp78
   294 jump *label79 always
   295 label *label78
-    * set *tmp75 null
   296 label *label79
   297 label *label77
   298 print "\n"
 
   342 label *label87
   343 set *tmp28 null
   344 label *label36
-    * set *tmp9 *tmp28
   345 label *label22
   346 label *label20
   347 label *label17

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   173 label *label53
   174 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   175 label *label39
-    * set *tmp28 null
   176 jump *label36 always
   177 label *label37
   178 jump *label57 equal :backgroundProcess:flag 1
 
   223 ucontrol approach .coreX .coreY 6
   224 ucontrol itemDrop .core 30
   225 ucontrol flag 3
-    * set *tmp65 null
   226 jump *label68 always
   227 label *label67
-    * set *tmp65 null
   228 label *label68
   229 jump *label66 always
   230 label *label65
 
   232 label *label64
   233 print "\n"
   234 label *label58
-    * set *tmp28 null
   235 jump *label36 always
   236 label *label56
   237 jump *label70 equal :backgroundProcess:flag 2
 
   282 ucontrol approach .containerX .containerY 6
   283 ucontrol itemDrop .container 30
   284 ucontrol flag 4
-    * set *tmp78 null
   285 jump *label81 always
   286 label *label80
-    * set *tmp78 null
   287 label *label81
   288 jump *label79 always
   289 label *label78
 
   291 label *label77
   292 print "\n"
   293 label *label71
-    * set *tmp28 null
   294 jump *label36 always
   295 label *label69
   296 jump *label83 equal :backgroundProcess:flag 3
 
   310 label *label85
   311 label *label86
   312 label *label84
-    * set *tmp28 null
   313 jump *label36 always
   314 label *label82
   315 jump *label88 equal :backgroundProcess:flag 4
 
   329 label *label90
   330 label *label91
   331 label *label89
-    * set *tmp28 null
   332 jump *label36 always
   333 label *label87
-    * set *tmp28 null
   334 label *label36
   335 label *label22
   336 label *label20

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-11 instructions):
 
    14 set .scrapDistance 1000000000
    15 label *label9
    16 ubind @poly
-    * set *tmp0 @unit
-    * set .builder *tmp0
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   17 set .builder @unit
+   18 ulocate building core false @copper .coreX .coreY *tmp2 .core
    19 label *label10
    20 op equal *tmp3 .core null
    21 jump *label9 notEqual *tmp3 false
 
    40 label *label19
    41 op equal *tmp8 .thoriumDrone null
    42 jump *label21 equal *tmp8 false
-    * set *tmp10 @unit
-    * set .thoriumDrone *tmp10
+   43 set .thoriumDrone @unit
    44 jump *label22 always
    45 label *label21
    46 op equal *tmp11 @unit .thoriumDrone
 
    48 op greaterThan *tmp13 *tmp12 .thoriumLimit
    49 op land *tmp14 *tmp11 *tmp13
    50 jump *label23 equal *tmp14 false
-    * sensor *tmp16 @unit @firstItem
-    * set :serviceThoriumDrill:item *tmp16
+   51 sensor :serviceThoriumDrill:item @unit @firstItem
    52 op equal *tmp17 :serviceThoriumDrill:item @thorium
    53 jump *label26 equal *tmp17 false
    54 ucontrol approach .coreX .coreY 6
 
    70 label *label23
    71 label *label24
    72 jump *label30 equal .container false
-    * sensor *tmp22 .core @coal
-    * set :backgroundProcess:coal *tmp22
+   73 sensor :backgroundProcess:coal .core @coal
    74 op lessThan *tmp23 :backgroundProcess:coal 120
    75 jump *label32 equal *tmp23 false
    76 set *tmp24 @coal
 
    89 jump *label31 always
    90 label *label30
    91 label *label31
-    * sensor *tmp27 @unit @flag
-    * set :backgroundProcess:flag *tmp27
+   92 sensor :backgroundProcess:flag @unit @flag
    93 print "Unit flag: "
    94 print :backgroundProcess:flag
    95 print "\n"
 
   147 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
   148 op sub *tmp46 :findOreToMine:x :findOreToMine:targetX
   149 op sub *tmp47 :findOreToMine:y :findOreToMine:targetY
-    * op len *tmp48 *tmp46 *tmp47
-    * set :findOreToMine:dist *tmp48
+  150 op len :findOreToMine:dist *tmp46 *tmp47
   151 op lessThan *tmp49 :findOreToMine:dist :findOreToMine:distance
   152 jump *label52 equal *tmp49 false
   153 op equal *tmp51 .ore @coal
 
   336 end
   337 label *label0
   338 set .thoriumContainer :setThoriumContainer:container
-    * sensor *tmp85 :setThoriumContainer:container @x
-    * set .thoriumContainerX *tmp85
-    * sensor *tmp86 :setThoriumContainer:container @y
-    * set .thoriumContainerY *tmp86
+  339 sensor .thoriumContainerX :setThoriumContainer:container @x
+  340 sensor .thoriumContainerY :setThoriumContainer:container @y
   341 sensor *tmp87 .thoriumContainer @itemCapacity
   342 op greaterThan *tmp88 *tmp87 10
   343 jump *label93 equal *tmp88 false
 
   353 end
   354 label *label1
   355 set .container :setScrapContainer:scrapContainer
-    * sensor *tmp90 .container @x
-    * set .containerX *tmp90
-    * sensor *tmp91 .container @y
-    * set .containerY *tmp91
+  356 sensor .containerX .container @x
+  357 sensor .containerY .container @y
   358 label *label95
   359 set :setScrapContainer*finished true
   360 jump *label12 always

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    29 label *label14
    30 label *label15
    31 label *label16
-    * jump *label18 equal true false
    32 ubind @poly
    33 op equal *tmp6 @unit .builder
    34 jump *label19 equal *tmp6 false

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-5 instructions):
 
    92 print "Unit flag: "
    93 print :backgroundProcess:flag
    94 print "\n"
-    * jump *label38 equal :backgroundProcess:flag 0
-    * jump *label37 always
+   95 jump *label37 notEqual :backgroundProcess:flag 0
    96 label *label38
    97 sensor *tmp30 @unit @firstItem
    98 op notEqual *tmp31 *tmp30 null
 
   166 label *label39
   167 jump *label36 always
   168 label *label37
-    * jump *label57 equal :backgroundProcess:flag 1
-    * jump *label56 always
+  169 jump *label56 notEqual :backgroundProcess:flag 1
   170 label *label57
   171 print "Mining "
   172 printchar @coal
 
   224 label *label58
   225 jump *label36 always
   226 label *label56
-    * jump *label70 equal :backgroundProcess:flag 2
-    * jump *label69 always
+  227 jump *label69 notEqual :backgroundProcess:flag 2
   228 label *label70
   229 print "Mining "
   230 printchar @scrap
 
   282 label *label71
   283 jump *label36 always
   284 label *label69
-    * jump *label83 equal :backgroundProcess:flag 3
-    * jump *label82 always
+  285 jump *label82 notEqual :backgroundProcess:flag 3
   286 label *label83
   287 print "Returning"
   288 print "\n"
 
   300 label *label84
   301 jump *label36 always
   302 label *label82
-    * jump *label88 equal :backgroundProcess:flag 4
-    * jump *label87 always
+  303 jump *label87 notEqual :backgroundProcess:flag 4
   304 label *label88
   305 print "Returning"
   306 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-27 instructions):
 
    17 set .builder @unit
    18 ulocate building core false @copper .coreX .coreY *tmp2 .core
    19 label *label10
-    * op equal *tmp3 .core null
-    * jump *label9 notEqual *tmp3 false
+   20 jump *label9 equal .core null
    21 label *label11
    22 set *signature "c7cc7825e82cc574:v1"
    23 label *label12
-    * op equal *tmp4 .core null
-    * jump *label14 equal *tmp4 false
+   24 jump *label14 notEqual .core null
    25 jump *label13 always
    26 jump *label15 always
    27 label *label14
    28 label *label15
    29 label *label16
    30 ubind @poly
-    * op equal *tmp6 @unit .builder
-    * jump *label19 equal *tmp6 false
+   31 jump *label19 notEqual @unit .builder
    32 print "Found builder unit."
    33 print "\n"
    34 printflush message1
    35 jump *label20 always
    36 label *label19
-    * op equal *tmp8 .thoriumDrone null
-    * jump *label21 equal *tmp8 false
+   37 jump *label21 notEqual .thoriumDrone null
    38 set .thoriumDrone @unit
    39 jump *label22 always
    40 label *label21
 
    44 op land *tmp14 *tmp11 *tmp13
    45 jump *label23 equal *tmp14 false
    46 sensor :serviceThoriumDrill:item @unit @firstItem
-    * op equal *tmp17 :serviceThoriumDrill:item @thorium
-    * jump *label26 equal *tmp17 false
+   47 jump *label26 notEqual :serviceThoriumDrill:item @thorium
    48 ucontrol approach .coreX .coreY 6
    49 ucontrol itemDrop .core 30
    50 jump *label27 always
    51 label *label26
-    * op equal *tmp19 :serviceThoriumDrill:item null
-    * jump *label28 equal *tmp19 false
+   52 jump *label28 notEqual :serviceThoriumDrill:item null
    53 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    54 ucontrol itemTake .thoriumContainer @thorium 30
    55 jump *label29 always
 
    64 label *label24
    65 jump *label30 equal .container false
    66 sensor :backgroundProcess:coal .core @coal
-    * op lessThan *tmp23 :backgroundProcess:coal 120
-    * jump *label32 equal *tmp23 false
+   67 jump *label32 greaterThanEq :backgroundProcess:coal 120
    68 set *tmp24 @coal
    69 jump *label33 always
    70 label *label32
-    * op greaterThan *tmp25 :backgroundProcess:coal 220
-    * jump *label34 equal *tmp25 false
+   71 jump *label34 lessThanEq :backgroundProcess:coal 220
    72 set *tmp26 @scrap
    73 jump *label35 always
    74 label *label34
 
    87 jump *label37 notEqual :backgroundProcess:flag 0
    88 label *label38
    89 sensor *tmp30 @unit @firstItem
-    * op notEqual *tmp31 *tmp30 null
-    * jump *label40 equal *tmp31 false
+   90 jump *label40 equal *tmp30 null
    91 ucontrol itemDrop @air 30
    92 sensor *tmp33 @unit @firstItem
-    * op notEqual *tmp34 *tmp33 null
-    * jump *label42 equal *tmp34 false
+   93 jump *label42 equal *tmp33 null
    94 print "Holding wrong item."
    95 print "\n"
    96 jump *label39 always
 
   100 jump *label41 always
   101 label *label40
   102 label *label41
-    * op equal *tmp36 .ore @coal
-    * jump *label44 equal *tmp36 false
+  103 jump *label44 notEqual .ore @coal
   104 set *tmp37 1
   105 jump *label45 always
   106 label *label44
   107 set *tmp37 2
   108 label *label45
   109 ucontrol flag *tmp37
-    * op equal *tmp38 .ore @coal
-    * jump *label46 equal *tmp38 false
+  110 jump *label46 notEqual .ore @coal
   111 set *tmp39 .coreX
   112 jump *label47 always
   113 label *label46
   114 set *tmp39 .containerX
   115 label *label47
   116 set :findOreToMine:targetX *tmp39
-    * op equal *tmp40 .ore @coal
-    * jump *label48 equal *tmp40 false
+  117 jump *label48 notEqual .ore @coal
   118 set *tmp41 .coreY
   119 jump *label49 always
   120 label *label48
   121 set *tmp41 .containerY
   122 label *label49
   123 set :findOreToMine:targetY *tmp41
-    * op equal *tmp42 .ore @coal
-    * jump *label50 equal *tmp42 false
+  124 jump *label50 notEqual .ore @coal
   125 set *tmp43 .coalDistance
   126 jump *label51 always
   127 label *label50
 
   132 op sub *tmp46 :findOreToMine:x :findOreToMine:targetX
   133 op sub *tmp47 :findOreToMine:y :findOreToMine:targetY
   134 op len :findOreToMine:dist *tmp46 *tmp47
-    * op lessThan *tmp49 :findOreToMine:dist :findOreToMine:distance
-    * jump *label52 equal *tmp49 false
-    * op equal *tmp51 .ore @coal
-    * jump *label54 equal *tmp51 false
+  135 jump *label52 greaterThanEq :findOreToMine:dist :findOreToMine:distance
+  136 jump *label54 notEqual .ore @coal
   137 set .coalX :findOreToMine:x
   138 set .coalY :findOreToMine:y
   139 set .coalDistance :findOreToMine:dist
 
   154 label *label57
   155 print "Mining "
   156 printchar @coal
-    * op notEqual *tmp53 .ore @coal
-    * jump *label59 equal *tmp53 false
+  157 jump *label59 equal .ore @coal
   158 print ", switching"
   159 ucontrol approach .coreX .coreY 6
   160 ucontrol itemDrop .core 30
 
   163 label *label59
   164 label *label60
   165 sensor *tmp55 @unit @firstItem
-    * op notEqual *tmp56 *tmp55 @coal
-    * jump *label61 equal *tmp56 false
+  166 jump *label61 equal *tmp55 @coal
   167 print " (dropping)"
   168 ucontrol itemDrop @air 30
   169 jump *label62 always
 
   177 ucontrol approach .coalX .coalY 6
   178 ucontrol mine .coalX .coalY
   179 sensor *tmp58 @unit @totalItems
-    * op greaterThanEq *tmp59 *tmp58 30
-    * jump *label63 equal *tmp59 false
+  180 jump *label63 lessThan *tmp58 30
   181 print ", full"
   182 ucontrol approach .coreX .coreY 6
   183 ucontrol itemDrop .core 30
 
   187 ucontrol within .coalX .coalY 6.5 *tmp61
   188 jump *label65 equal *tmp61 false
   189 sensor *tmp63 @unit @mining
-    * op equal *tmp64 *tmp63 false
-    * jump *label67 equal *tmp64 false
+  190 jump *label67 notEqual *tmp63 false
   191 print ", ore lost"
   192 set .coalDistance 1000000000
   193 ucontrol approach .coreX .coreY 6
 
   208 label *label70
   209 print "Mining "
   210 printchar @scrap
-    * op notEqual *tmp66 .ore @scrap
-    * jump *label72 equal *tmp66 false
+  211 jump *label72 equal .ore @scrap
   212 print ", switching"
   213 ucontrol approach .containerX .containerY 6
   214 ucontrol itemDrop .container 30
 
   217 label *label72
   218 label *label73
   219 sensor *tmp68 @unit @firstItem
-    * op notEqual *tmp69 *tmp68 @scrap
-    * jump *label74 equal *tmp69 false
+  220 jump *label74 equal *tmp68 @scrap
   221 print " (dropping)"
   222 ucontrol itemDrop @air 30
   223 jump *label75 always
 
   231 ucontrol approach .scrapX .scrapY 6
   232 ucontrol mine .scrapX .scrapY
   233 sensor *tmp71 @unit @totalItems
-    * op greaterThanEq *tmp72 *tmp71 25
-    * jump *label76 equal *tmp72 false
+  234 jump *label76 lessThan *tmp71 25
   235 print ", full"
   236 ucontrol approach .containerX .containerY 6
   237 ucontrol itemDrop .container 30
 
   241 ucontrol within .scrapX .scrapY 6.5 *tmp74
   242 jump *label78 equal *tmp74 false
   243 sensor *tmp76 @unit @mining
-    * op equal *tmp77 *tmp76 false
-    * jump *label80 equal *tmp77 false
+  244 jump *label80 notEqual *tmp76 false
   245 print ", ore lost"
   246 set .scrapDistance 1000000000
   247 ucontrol approach .containerX .containerY 6
 
   265 ucontrol approach .coreX .coreY 6
   266 ucontrol itemDrop .core 30
   267 sensor *tmp79 @unit @firstItem
-    * op equal *tmp80 *tmp79 null
-    * jump *label85 equal *tmp80 false
+  268 jump *label85 notEqual *tmp79 null
   269 print "    Finished"
   270 print "\n"
   271 ucontrol flag 0
 
   282 ucontrol approach .containerX .containerY 6
   283 ucontrol itemDrop .container 30
   284 sensor *tmp82 @unit @firstItem
-    * op equal *tmp83 *tmp82 null
-    * jump *label90 equal *tmp83 false
+  285 jump *label90 notEqual *tmp82 null
   286 print "    Finished"
   287 print "\n"
   288 ucontrol flag 0
 
   307 sensor .thoriumContainerX :setThoriumContainer:container @x
   308 sensor .thoriumContainerY :setThoriumContainer:container @y
   309 sensor *tmp87 .thoriumContainer @itemCapacity
-    * op greaterThan *tmp88 *tmp87 10
-    * jump *label93 equal *tmp88 false
+  310 jump *label93 lessThanEq *tmp87 10
   311 set *tmp89 100
   312 jump *label94 always
   313 label *label93

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-17 instructions):
 
    23 label *label12
    24 jump *label14 notEqual .core null
    25 jump *label13 always
-    * jump *label15 always
    26 label *label14
    27 label *label15
    28 label *label16
 
    58 label *label27
    59 label *label25
    60 jump *label17 always
-    * jump *label24 always
    61 label *label23
    62 label *label24
    63 jump *label30 equal .container false
 
    75 set *tmp24 *tmp26
    76 label *label33
    77 set .ore *tmp24
-    * jump *label31 always
    78 label *label30
    79 label *label31
    80 sensor :backgroundProcess:flag @unit @flag
 
    91 print "Holding wrong item."
    92 print "\n"
    93 jump *label39 always
-    * jump *label43 always
    94 label *label42
    95 label *label43
-    * jump *label41 always
    96 label *label40
    97 label *label41
    98 jump *label44 notEqual .ore @coal
 
   138 set .scrapY :findOreToMine:y
   139 set .scrapDistance :findOreToMine:dist
   140 label *label55
-    * jump *label53 always
   141 label *label52
   142 label *label53
   143 ucontrol approach :findOreToMine:x :findOreToMine:y 6
 
   153 ucontrol approach .coreX .coreY 6
   154 ucontrol itemDrop .core 30
   155 ucontrol flag 3
-    * jump *label60 always
   156 label *label59
   157 label *label60
   158 sensor *tmp55 @unit @firstItem
   159 jump *label61 equal *tmp55 @coal
   160 print " (dropping)"
   161 ucontrol itemDrop @air 30
-    * jump *label62 always
   162 label *label61
   163 label *label62
   164 print " at "
 
   185 ucontrol approach .coreX .coreY 6
   186 ucontrol itemDrop .core 30
   187 ucontrol flag 3
-    * jump *label68 always
   188 label *label67
   189 label *label68
-    * jump *label66 always
   190 label *label65
   191 label *label66
   192 label *label64
 
   203 ucontrol approach .containerX .containerY 6
   204 ucontrol itemDrop .container 30
   205 ucontrol flag 4
-    * jump *label73 always
   206 label *label72
   207 label *label73
   208 sensor *tmp68 @unit @firstItem
   209 jump *label74 equal *tmp68 @scrap
   210 print " (dropping)"
   211 ucontrol itemDrop @air 30
-    * jump *label75 always
   212 label *label74
   213 label *label75
   214 print " at "
 
   235 ucontrol approach .containerX .containerY 6
   236 ucontrol itemDrop .container 30
   237 ucontrol flag 4
-    * jump *label81 always
   238 label *label80
   239 label *label81
-    * jump *label79 always
   240 label *label78
   241 label *label79
   242 label *label77
 
   255 print "    Finished"
   256 print "\n"
   257 ucontrol flag 0
-    * jump *label86 always
   258 label *label85
   259 label *label86
   260 label *label84
 
   271 print "    Finished"
   272 print "\n"
   273 ucontrol flag 0
-    * jump *label91 always
   274 label *label90
   275 label *label91
   276 label *label89
-    * jump *label36 always
   277 label *label87
   278 label *label36
   279 label *label22

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   124 label *label51
   125 set :findOreToMine:distance *tmp43
   126 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
-    * op sub *tmp46 :findOreToMine:x :findOreToMine:targetX
-    * op sub *tmp47 :findOreToMine:y :findOreToMine:targetY
+  127 op sub *tmp46 :findOreToMine:x *tmp39
+  128 op sub *tmp47 :findOreToMine:y *tmp41
   129 op len :findOreToMine:dist *tmp46 *tmp47
-    * jump *label52 greaterThanEq :findOreToMine:dist :findOreToMine:distance
+  130 jump *label52 greaterThanEq :findOreToMine:dist *tmp43
   131 jump *label54 notEqual .ore @coal
   132 set .coalX :findOreToMine:x
   133 set .coalY :findOreToMine:y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
   108 label *label46
   109 set *tmp39 .containerX
   110 label *label47
-    * set :findOreToMine:targetX *tmp39
   111 jump *label48 notEqual .ore @coal
   112 set *tmp41 .coreY
   113 jump *label49 always
   114 label *label48
   115 set *tmp41 .containerY
   116 label *label49
-    * set :findOreToMine:targetY *tmp41
   117 jump *label50 notEqual .ore @coal
   118 set *tmp43 .coalDistance
   119 jump *label51 always
   120 label *label50
   121 set *tmp43 .scrapDistance
   122 label *label51
-    * set :findOreToMine:distance *tmp43
   123 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
   124 op sub *tmp46 :findOreToMine:x *tmp39
   125 op sub *tmp47 :findOreToMine:y *tmp41

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-18 instructions):
 
    66 set *tmp24 @coal
    67 jump *label33 always
    68 label *label32
-    * jump *label34 lessThanEq :backgroundProcess:coal 220
-    * set *tmp26 @scrap
-    * jump *label35 always
-    * label *label34
-    * set *tmp26 .ore
-    * label *label35
+   69 select *tmp26 greaterThan :backgroundProcess:coal 220 @scrap .ore
    70 set *tmp24 *tmp26
    71 label *label33
    72 set .ore *tmp24
 
    90 label *label43
    91 label *label40
    92 label *label41
-    * jump *label44 notEqual .ore @coal
-    * set *tmp37 1
-    * jump *label45 always
-    * label *label44
-    * set *tmp37 2
-    * label *label45
+   93 select *tmp37 equal .ore @coal 1 2
    94 ucontrol flag *tmp37
-    * jump *label46 notEqual .ore @coal
-    * set *tmp39 .coreX
-    * jump *label47 always
-    * label *label46
-    * set *tmp39 .containerX
-    * label *label47
-    * jump *label48 notEqual .ore @coal
-    * set *tmp41 .coreY
-    * jump *label49 always
-    * label *label48
-    * set *tmp41 .containerY
-    * label *label49
-    * jump *label50 notEqual .ore @coal
-    * set *tmp43 .coalDistance
-    * jump *label51 always
-    * label *label50
-    * set *tmp43 .scrapDistance
-    * label *label51
+   95 select *tmp39 equal .ore @coal .coreX .containerX
+   96 select *tmp41 equal .ore @coal .coreY .containerY
+   97 select *tmp43 equal .ore @coal .coalDistance .scrapDistance
    98 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
    99 op sub *tmp46 :findOreToMine:x *tmp39
   100 op sub *tmp47 :findOreToMine:y *tmp41
 
   261 set .thoriumContainer :setThoriumContainer:container
   262 sensor .thoriumContainerX :setThoriumContainer:container @x
   263 sensor .thoriumContainerY :setThoriumContainer:container @y
-    * sensor *tmp87 .thoriumContainer @itemCapacity
-    * jump *label93 lessThanEq *tmp87 10
-    * set *tmp89 100
-    * jump *label94 always
-    * label *label93
-    * set *tmp89 0
-    * label *label94
+  264 sensor *tmp87 .thoriumContainer @itemCapacity
+  265 select *tmp89 greaterThan *tmp87 10 100 0
   266 set .thoriumLimit *tmp89
   267 label *label92
   268 set :setThoriumContainer*finished true

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 2 (-3 instructions):
 
    62 label *label24
    63 jump *label30 equal .container false
    64 sensor :backgroundProcess:coal .core @coal
-    * jump *label32 greaterThanEq :backgroundProcess:coal 120
-    * set *tmp24 @coal
-    * jump *label33 always
-    * label *label32
-    * select *tmp26 greaterThan :backgroundProcess:coal 220 @scrap .ore
-    * set *tmp24 *tmp26
-    * label *label33
+   65 select *tmp108 greaterThan :backgroundProcess:coal 220 @scrap .ore
+   66 select *tmp24 lessThan :backgroundProcess:coal 120 @coal *tmp108
    67 set .ore *tmp24
    68 label *label30
    69 label *label31

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   257 sensor .thoriumContainerX :setThoriumContainer:container @x
   258 sensor .thoriumContainerY :setThoriumContainer:container @y
   259 sensor *tmp87 .thoriumContainer @itemCapacity
-    * select *tmp89 greaterThan *tmp87 10 100 0
-    * set .thoriumLimit *tmp89
+  260 select .thoriumLimit greaterThan *tmp87 10 100 0
   261 label *label92
   262 set :setThoriumContainer*finished true
   263 jump *label12 always

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-1 instructions):
 
    63 jump *label30 equal .container false
    64 sensor :backgroundProcess:coal .core @coal
    65 select *tmp108 greaterThan :backgroundProcess:coal 220 @scrap .ore
-    * select *tmp24 lessThan :backgroundProcess:coal 120 @coal *tmp108
-    * set .ore *tmp24
+   66 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp108
    67 label *label30
    68 label *label31
    69 sensor :backgroundProcess:flag @unit @flag

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    16 ubind @poly
    17 set .builder @unit
    18 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label10
    19 jump *label9 equal .core null
-    * label *label11
    20 set *signature "c7cc7825e82cc574:v1"
    21 label *label12
    22 jump *label14 notEqual .core null
    23 jump *label13 always
    24 label *label14
-    * label *label15
    25 label *label16
    26 ubind @poly
    27 jump *label19 notEqual @unit .builder
 
    53 ucontrol itemDrop @air 30
    54 label *label29
    55 label *label27
-    * label *label25
    56 jump *label17 always
    57 label *label23
-    * label *label24
    58 jump *label30 equal .container false
    59 sensor :backgroundProcess:coal .core @coal
    60 select *tmp108 greaterThan :backgroundProcess:coal 220 @scrap .ore
    61 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp108
    62 label *label30
-    * label *label31
    63 sensor :backgroundProcess:flag @unit @flag
    64 print "Unit flag: "
    65 print :backgroundProcess:flag
    66 print "\n"
    67 jump *label37 notEqual :backgroundProcess:flag 0
-    * label *label38
    68 sensor *tmp30 @unit @firstItem
    69 jump *label40 equal *tmp30 null
    70 ucontrol itemDrop @air 30
 
    74 print "\n"
    75 jump *label39 always
    76 label *label42
-    * label *label43
    77 label *label40
-    * label *label41
    78 select *tmp37 equal .ore @coal 1 2
    79 ucontrol flag *tmp37
    80 select *tmp39 equal .ore @coal .coreX .containerX
 
    96 set .scrapDistance :findOreToMine:dist
    97 label *label55
    98 label *label52
-    * label *label53
    99 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   100 label *label39
   101 jump *label36 always
   102 label *label37
   103 jump *label56 notEqual :backgroundProcess:flag 1
-    * label *label57
   104 print "Mining "
   105 printchar @coal
   106 jump *label59 equal .ore @coal
 
   109 ucontrol itemDrop .core 30
   110 ucontrol flag 3
   111 label *label59
-    * label *label60
   112 sensor *tmp55 @unit @firstItem
   113 jump *label61 equal *tmp55 @coal
   114 print " (dropping)"
   115 ucontrol itemDrop @air 30
   116 label *label61
-    * label *label62
   117 print " at "
   118 print .coalX
   119 print ","
 
   139 ucontrol itemDrop .core 30
   140 ucontrol flag 3
   141 label *label67
-    * label *label68
   142 label *label65
-    * label *label66
   143 label *label64
   144 print "\n"
-    * label *label58
   145 jump *label36 always
   146 label *label56
   147 jump *label69 notEqual :backgroundProcess:flag 2
-    * label *label70
   148 print "Mining "
   149 printchar @scrap
   150 jump *label72 equal .ore @scrap
 
   153 ucontrol itemDrop .container 30
   154 ucontrol flag 4
   155 label *label72
-    * label *label73
   156 sensor *tmp68 @unit @firstItem
   157 jump *label74 equal *tmp68 @scrap
   158 print " (dropping)"
   159 ucontrol itemDrop @air 30
   160 label *label74
-    * label *label75
   161 print " at "
   162 print .scrapX
   163 print ","
 
   183 ucontrol itemDrop .container 30
   184 ucontrol flag 4
   185 label *label80
-    * label *label81
   186 label *label78
-    * label *label79
   187 label *label77
   188 print "\n"
-    * label *label71
   189 jump *label36 always
   190 label *label69
   191 jump *label82 notEqual :backgroundProcess:flag 3
-    * label *label83
   192 print "Returning"
   193 print "\n"
   194 ucontrol approach .coreX .coreY 6
 
   199 print "\n"
   200 ucontrol flag 0
   201 label *label85
-    * label *label86
-    * label *label84
   202 jump *label36 always
   203 label *label82
   204 jump *label87 notEqual :backgroundProcess:flag 4
-    * label *label88
   205 print "Returning"
   206 print "\n"
   207 ucontrol approach .containerX .containerY 6
 
   212 print "\n"
   213 ucontrol flag 0
   214 label *label90
-    * label *label91
-    * label *label89
   215 label *label87
   216 label *label36
   217 label *label22
   218 label *label20
   219 label *label17
   220 jump *label16 always
-    * label *label18
   221 label *label13
   222 wait 1e12
   223 jump *label12 always
 
   228 sensor .thoriumContainerY :setThoriumContainer:container @y
   229 sensor *tmp87 .thoriumContainer @itemCapacity
   230 select .thoriumLimit greaterThan *tmp87 10 100 0
-    * label *label92
   231 set :setThoriumContainer*finished true
   232 jump *label12 always
   233 end
 
   235 set .container :setScrapContainer:scrapContainer
   236 sensor .containerX .container @x
   237 sensor .containerY .container @y
-    * label *label95
   238 set :setScrapContainer*finished true
   239 jump *label12 always
   240 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    19 jump *label9 equal .core null
    20 set *signature "c7cc7825e82cc574:v1"
    21 label *label12
-    * jump *label14 notEqual .core null
-    * jump *label13 always
+   22 jump *label13 equal .core null
    23 label *label14
    24 label *label16
    25 ubind @poly

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    20 set *signature "c7cc7825e82cc574:v1"
    21 label *label12
    22 jump *label13 equal .core null
-    * label *label14
    23 label *label16
    24 ubind @poly
    25 jump *label19 notEqual @unit .builder

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    26 print "Found builder unit."
    27 print "\n"
    28 printflush message1
-    * jump *label20 always
+   29 jump *label16 always
    30 label *label19
    31 jump *label21 notEqual .thoriumDrone null
    32 set .thoriumDrone @unit
-    * jump *label22 always
+   33 jump *label16 always
    34 label *label21
    35 op equal *tmp11 @unit .thoriumDrone
    36 sensor *tmp12 .thoriumContainer @thorium
 
    41 jump *label26 notEqual :serviceThoriumDrill:item @thorium
    42 ucontrol approach .coreX .coreY 6
    43 ucontrol itemDrop .core 30
-    * jump *label27 always
+   44 jump *label16 always
    45 label *label26
    46 jump *label28 notEqual :serviceThoriumDrill:item null
    47 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    48 ucontrol itemTake .thoriumContainer @thorium 30
-    * jump *label29 always
+   49 jump *label16 always
    50 label *label28
    51 ucontrol itemDrop @air 30
    52 label *label29
    53 label *label27
-    * jump *label17 always
+   54 jump *label16 always
    55 label *label23
    56 jump *label30 equal .container false
    57 sensor :backgroundProcess:coal .core @coal
 
    70 jump *label42 equal *tmp33 null
    71 print "Holding wrong item."
    72 print "\n"
-    * jump *label39 always
+   73 jump *label16 always
    74 label *label42
    75 label *label40
    76 select *tmp37 equal .ore @coal 1 2
 
    96 label *label52
    97 ucontrol approach :findOreToMine:x :findOreToMine:y 6
    98 label *label39
-    * jump *label36 always
+   99 jump *label16 always
   100 label *label37
   101 jump *label56 notEqual :backgroundProcess:flag 1
   102 print "Mining "
 
   140 label *label65
   141 label *label64
   142 print "\n"
-    * jump *label36 always
+  143 jump *label16 always
   144 label *label56
   145 jump *label69 notEqual :backgroundProcess:flag 2
   146 print "Mining "
 
   184 label *label78
   185 label *label77
   186 print "\n"
-    * jump *label36 always
+  187 jump *label16 always
   188 label *label69
   189 jump *label82 notEqual :backgroundProcess:flag 3
   190 print "Returning"
 
   192 ucontrol approach .coreX .coreY 6
   193 ucontrol itemDrop .core 30
   194 sensor *tmp79 @unit @firstItem
-    * jump *label85 notEqual *tmp79 null
+  195 jump *label16 notEqual *tmp79 null
   196 print "    Finished"
   197 print "\n"
   198 ucontrol flag 0
   199 label *label85
-    * jump *label36 always
+  200 jump *label16 always
   201 label *label82
-    * jump *label87 notEqual :backgroundProcess:flag 4
+  202 jump *label16 notEqual :backgroundProcess:flag 4
   203 print "Returning"
   204 print "\n"
   205 ucontrol approach .containerX .containerY 6
   206 ucontrol itemDrop .container 30
   207 sensor *tmp82 @unit @firstItem
-    * jump *label90 notEqual *tmp82 null
+  208 jump *label16 notEqual *tmp82 null
   209 print "    Finished"
   210 print "\n"
   211 ucontrol flag 0

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    49 jump *label16 always
    50 label *label28
    51 ucontrol itemDrop @air 30
-    * label *label29
-    * label *label27
    52 jump *label16 always
    53 label *label23
    54 jump *label30 equal .container false
 
    93 label *label55
    94 label *label52
    95 ucontrol approach :findOreToMine:x :findOreToMine:y 6
-    * label *label39
    96 jump *label16 always
    97 label *label37
    98 jump *label56 notEqual :backgroundProcess:flag 1
 
   193 print "    Finished"
   194 print "\n"
   195 ucontrol flag 0
-    * label *label85
   196 jump *label16 always
   197 label *label82
   198 jump *label16 notEqual :backgroundProcess:flag 4
 
   205 print "    Finished"
   206 print "\n"
   207 ucontrol flag 0
-    * label *label90
-    * label *label87
-    * label *label36
-    * label *label22
-    * label *label20
-    * label *label17
   208 jump *label16 always
   209 label *label13
   210 wait 1e12
   211 jump *label12 always
-    * end
   212 label *label0
   213 set .thoriumContainer :setThoriumContainer:container
   214 sensor .thoriumContainerX :setThoriumContainer:container @x
 
   217 select .thoriumLimit greaterThan *tmp87 10 100 0
   218 set :setThoriumContainer*finished true
   219 jump *label12 always
-    * end
   220 label *label1
   221 set .container :setScrapContainer:scrapContainer
   222 sensor .containerX .container @x
   223 sensor .containerY .container @y
   224 set :setScrapContainer*finished true
   225 jump *label12 always
-    * end

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
    15 label *label9
    16 ubind @poly
    17 set .builder @unit
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+   18 ulocate building core false @copper .coreX .coreY 0 .core
    19 jump *label9 equal .core null
    20 set *signature "c7cc7825e82cc574:v1"
    21 label *label12
 
    76 select *tmp39 equal .ore @coal .coreX .containerX
    77 select *tmp41 equal .ore @coal .coreY .containerY
    78 select *tmp43 equal .ore @coal .coalDistance .scrapDistance
-    * ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp44 *tmp45
+   79 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y 0 0
    80 op sub *tmp46 :findOreToMine:x *tmp39
    81 op sub *tmp47 :findOreToMine:y *tmp41
    82 op len :findOreToMine:dist *tmp46 *tmp47

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    23 label *label16
    24 ubind @poly
    25 jump *label19 notEqual @unit .builder
-    * print "Found builder unit."
-    * print "\n"
+   26 print "Found builder unit.\n"
    27 printflush message1
    28 jump *label16 always
    29 label *label19
 
    56 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp108
    57 label *label30
    58 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   59 print "Unit flag: {0}\n"
+   60 format :backgroundProcess:flag
    61 jump *label37 notEqual :backgroundProcess:flag 0
    62 sensor *tmp30 @unit @firstItem
    63 jump *label40 equal *tmp30 null
    64 ucontrol itemDrop @air 30
    65 sensor *tmp33 @unit @firstItem
    66 jump *label42 equal *tmp33 null
-    * print "Holding wrong item."
-    * print "\n"
+   67 print "Holding wrong item.\n"
    68 jump *label16 always
    69 label *label42
    70 label *label40
 
    93 jump *label16 always
    94 label *label37
    95 jump *label56 notEqual :backgroundProcess:flag 1
-    * print "Mining "
-    * printchar @coal
+   96 print "Mining "
    97 jump *label59 equal .ore @coal
    98 print ", switching"
    99 ucontrol approach .coreX .coreY 6
 
   105 print " (dropping)"
   106 ucontrol itemDrop @air 30
   107 label *label61
-    * print " at "
-    * print .coalX
-    * print ","
-    * print " "
+  108 print " at {0}, "
+  109 format .coalX
   110 print .coalY
   111 ucontrol approach .coalX .coalY 6
   112 ucontrol mine .coalX .coalY
 
   134 jump *label16 always
   135 label *label56
   136 jump *label69 notEqual :backgroundProcess:flag 2
-    * print "Mining "
-    * printchar @scrap
+  137 print "Mining "
   138 jump *label72 equal .ore @scrap
   139 print ", switching"
   140 ucontrol approach .containerX .containerY 6
 
   146 print " (dropping)"
   147 ucontrol itemDrop @air 30
   148 label *label74
-    * print " at "
-    * print .scrapX
-    * print ","
-    * print " "
+  149 print " at {0}, "
+  150 format .scrapX
   151 print .scrapY
   152 ucontrol approach .scrapX .scrapY 6
   153 ucontrol mine .scrapX .scrapY
 
   175 jump *label16 always
   176 label *label69
   177 jump *label82 notEqual :backgroundProcess:flag 3
-    * print "Returning"
-    * print "\n"
+  178 print "Returning\n"
   179 ucontrol approach .coreX .coreY 6
   180 ucontrol itemDrop .core 30
   181 sensor *tmp79 @unit @firstItem
   182 jump *label16 notEqual *tmp79 null
-    * print "    Finished"
-    * print "\n"
+  183 print "    Finished\n"
   184 ucontrol flag 0
   185 jump *label16 always
   186 label *label82
   187 jump *label16 notEqual :backgroundProcess:flag 4
-    * print "Returning"
-    * print "\n"
+  188 print "Returning\n"
   189 ucontrol approach .containerX .containerY 6
   190 ucontrol itemDrop .container 30
   191 sensor *tmp82 @unit @firstItem
   192 jump *label16 notEqual *tmp82 null
-    * print "    Finished"
-    * print "\n"
+  193 print "    Finished\n"
   194 ucontrol flag 0
   195 jump *label16 always
   196 label *label13

Final code before resolving virtual instructions:

    0:  jump *label8 always 0 0                                      #set target = 8;
    1:  jump *label1 always 0 0                                      ...
    2:  jump *label0 always 0 0                                      ...
        label *label8                                                ...
    3:  set .thoriumContainer null                                   volatile var
    4:  set .thoriumLimit 100                                        volatile var
    5:  set .thoriumContainerX 0                                     ...
    6:  set .thoriumContainerY 0                                     ...
    7:  set .ore @coal                                               var
    8:  set .coalX 0                                                 ...
    9:  set .coalY 0                                                 ...
   10:  set .coalDistance 1000000000                                 ...
   11:  set .scrapX 0                                                ...
   12:  set .scrapY 0                                                ...
   13:  set .scrapDistance 1000000000                                ...
        label *label9                                                do
   14:  ubind @poly                                                  builder = ubind(@poly);
   15:  set .builder @unit                                           ...
   16:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   17:  jump *label9 equal .core null                                do
   18:  set *signature "c7cc7825e82cc574:v1"                         #set target = 8;
        label *label12                                               ...
   19:  jump *label13 equal .core null                               if core == null then return; end;
        label *label16                                               while true do
   20:  ubind @poly                                                  ubind(@poly);
   21:  jump *label19 notEqual @unit .builder                        if @unit == builder then
   22:  print "Found builder unit.\n"                                println("Found builder unit.");
   23:  printflush message1                                          printflush(message1);
   24:  jump *label16 always 0 0                                     if @unit == builder then
        label *label19                                               ...
   25:  jump *label21 notEqual .thoriumDrone null                    elsif thoriumDrone == null then
   26:  set .thoriumDrone @unit                                      thoriumDrone = @unit;
   27:  jump *label16 always 0 0                                     elsif thoriumDrone == null then
        label *label21                                               ...
   28:  op equal *tmp11 @unit .thoriumDrone                          if @unit == thoriumDrone and thoriumContainer.@thorium > thoriumLimit then
   29:  sensor *tmp12 .thoriumContainer @thorium                     ...
   30:  op greaterThan *tmp13 *tmp12 .thoriumLimit                   ...
   31:  op land *tmp14 *tmp11 *tmp13                                 ...
   32:  jump *label23 equal *tmp14 false                             ...
   33:  sensor :serviceThoriumDrill:item @unit @firstItem            var item = @unit.@firstItem;
   34:  jump *label26 notEqual :serviceThoriumDrill:item @thorium    if item == @thorium then
   35:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   36:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   37:  jump *label16 always 0 0                                     if item == @thorium then
        label *label26                                               ...
   38:  jump *label28 notEqual :serviceThoriumDrill:item null        elsif item == null then
   39:  ucontrol approach .thoriumContainerX .thoriumContainerY 6 0  approach(thoriumContainerX, thoriumContainerY, RADIUS);
   40:  ucontrol itemTake .thoriumContainer @thorium 30 0 0          itemTake(thoriumContainer, @thorium, CAPACITY);
   41:  jump *label16 always 0 0                                     elsif item == null then
        label *label28                                               ...
   42:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   43:  jump *label16 always 0 0                                     continue;
        label *label23                                               if @unit == thoriumDrone and thoriumContainer.@thorium > thoriumLimit then
   44:  jump *label30 equal .container false                         if container then
   45:  sensor :backgroundProcess:coal .core @coal                   var coal = core.@coal;
   46:  select *tmp108 greaterThan :backgroundProcess:coal 220 @scra ore = coal < 120 ? @coal : coal > 220 ? @scrap : ore;
   47:  select .ore lessThan :backgroundProcess:coal 120 @coal *tmp1 ...
        label *label30                                               if container then
   48:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   49:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   50:  format :backgroundProcess:flag                               ...
   51:  jump *label37 notEqual :backgroundProcess:flag 0             case flag
   52:  sensor *tmp30 @unit @firstItem                               if @unit.@firstItem != null then
   53:  jump *label40 equal *tmp30 null                              ...
   54:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   55:  sensor *tmp33 @unit @firstItem                               if @unit.@firstItem != null then
   56:  jump *label42 equal *tmp33 null                              ...
   57:  print "Holding wrong item.\n"                                println($"Holding wrong item.");
   58:  jump *label16 always 0 0                                     return;
        label *label42                                               if @unit.@firstItem != null then
        label *label40                                               if @unit.@firstItem != null then
   59:  select *tmp37 equal .ore @coal 1 2                           flag(ore == @coal ? FLAG_MINE_COAL : FLAG_MINE_SCRAP);
   60:  ucontrol flag *tmp37 0 0 0 0                                 ...
   61:  select *tmp39 equal .ore @coal .coreX .containerX            var targetX = ore == @coal ? coreX : containerX;
   62:  select *tmp41 equal .ore @coal .coreY .containerY            var targetY = ore == @coal ? coreY : containerY;
   63:  select *tmp43 equal .ore @coal .coalDistance .scrapDistance  var distance = ore == @coal ? coalDistance : scrapDistance;
   64:  ulocate ore core true .ore :findOreToMine:x :findOreToMine:y ulocate(:ore, ore, out x, out y);
   65:  op sub *tmp46 :findOreToMine:x *tmp39                        var dist = len(x - targetX, y - targetY);
   66:  op sub *tmp47 :findOreToMine:y *tmp41                        ...
   67:  op len :findOreToMine:dist *tmp46 *tmp47                     ...
   68:  jump *label52 greaterThanEq :findOreToMine:dist *tmp43       if dist < distance then
   69:  jump *label54 notEqual .ore @coal                            if ore == @coal then
   70:  set .coalX :findOreToMine:x                                  coalX = x;
   71:  set .coalY :findOreToMine:y                                  coalY = y;
   72:  set .coalDistance :findOreToMine:dist                        coalDistance = dist;
   73:  jump *label55 always 0 0                                     if ore == @coal then
        label *label54                                               ...
   74:  set .scrapX :findOreToMine:x                                 scrapX = x;
   75:  set .scrapY :findOreToMine:y                                 scrapY = y;
   76:  set .scrapDistance :findOreToMine:dist                       scrapDistance = dist;
        label *label55                                               if ore == @coal then
        label *label52                                               if dist < distance then
   77:  ucontrol approach :findOreToMine:x :findOreToMine:y 6 0 0    approach(x, y, RADIUS);
   78:  jump *label16 always 0 0                                     case flag
        label *label37                                               ...
   79:  jump *label56 notEqual :backgroundProcess:flag 1             ...
   80:  print "Mining "                                             print("Mining ");
   81:  jump *label59 equal .ore @coal                               if ore != @coal then
   82:  print ", switching"                                          print(", switching");
   83:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   84:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   85:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
        label *label59                                               if ore != @coal then
   86:  sensor *tmp55 @unit @firstItem                               if @unit.@firstItem != @coal then
   87:  jump *label61 equal *tmp55 @coal                             ...
   88:  print " (dropping)"                                          print(" (dropping)");
   89:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label61                                               if @unit.@firstItem != @coal then
   90:  print " at {0}, "                                            print($" at $coalX, $coalY");
   91:  format .coalX                                                ...
   92:  print .coalY                                                 ...
   93:  ucontrol approach .coalX .coalY 6 0 0                        approach(coalX, coalY, RADIUS);
   94:  ucontrol mine .coalX .coalY 0 0 0                            mine(coalX, coalY);
   95:  sensor *tmp58 @unit @totalItems                              if @unit.@totalItems >= CAPACITY then
   96:  jump *label63 lessThan *tmp58 30                             ...
   97:  print ", full"                                               print(", full");
   98:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   99:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  100:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
  101:  jump *label64 always 0 0                                     if @unit.@totalItems >= CAPACITY then
        label *label63                                               ...
  102:  ucontrol within .coalX .coalY 6.5 *tmp61 0                   elsif within(coalX, coalY, RADIUS + 0.5) then
  103:  jump *label65 equal *tmp61 false                             ...
  104:  sensor *tmp63 @unit @mining                                  if !@unit.@mining then
  105:  jump *label67 notEqual *tmp63 false                          ...
  106:  print ", ore lost"                                           print(", ore lost");
  107:  set .coalDistance 1000000000                                 coalDistance = 1e9;
  108:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
  109:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  110:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
        label *label67                                               if !@unit.@mining then
        label *label65                                               elsif within(coalX, coalY, RADIUS + 0.5) then
        label *label64                                               if @unit.@totalItems >= CAPACITY then
  111:  print "\n"                                                   println();
  112:  jump *label16 always 0 0                                     case flag
        label *label56                                               ...
  113:  jump *label69 notEqual :backgroundProcess:flag 2             ...
  114:  print "Mining "                                             print("Mining ");
  115:  jump *label72 equal .ore @scrap                              if ore != @scrap then
  116:  print ", switching"                                          print(", switching");
  117:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  118:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  119:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
        label *label72                                               if ore != @scrap then
  120:  sensor *tmp68 @unit @firstItem                               if @unit.@firstItem != @scrap then
  121:  jump *label74 equal *tmp68 @scrap                            ...
  122:  print " (dropping)"                                          print(" (dropping)");
  123:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label74                                               if @unit.@firstItem != @scrap then
  124:  print " at {0}, "                                            print($" at $scrapX, $scrapY");
  125:  format .scrapX                                               ...
  126:  print .scrapY                                                ...
  127:  ucontrol approach .scrapX .scrapY 6 0 0                      approach(scrapX, scrapY, RADIUS);
  128:  ucontrol mine .scrapX .scrapY 0 0 0                          mine(scrapX, scrapY);
  129:  sensor *tmp71 @unit @totalItems                              if @unit.@totalItems >= SCRAP_CAPACITY then
  130:  jump *label76 lessThan *tmp71 25                             ...
  131:  print ", full"                                               print(", full");
  132:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  133:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  134:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
  135:  jump *label77 always 0 0                                     if @unit.@totalItems >= SCRAP_CAPACITY then
        label *label76                                               ...
  136:  ucontrol within .scrapX .scrapY 6.5 *tmp74 0                 elsif within(scrapX, scrapY, RADIUS + 0.5) then
  137:  jump *label78 equal *tmp74 false                             ...
  138:  sensor *tmp76 @unit @mining                                  if !@unit.@mining then
  139:  jump *label80 notEqual *tmp76 false                          ...
  140:  print ", ore lost"                                           print(", ore lost");
  141:  set .scrapDistance 1000000000                                scrapDistance = 1e9;
  142:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  143:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  144:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
        label *label80                                               if !@unit.@mining then
        label *label78                                               elsif within(scrapX, scrapY, RADIUS + 0.5) then
        label *label77                                               if @unit.@totalItems >= SCRAP_CAPACITY then
  145:  print "\n"                                                   println();
  146:  jump *label16 always 0 0                                     case flag
        label *label69                                               ...
  147:  jump *label82 notEqual :backgroundProcess:flag 3             ...
  148:  print "Returning\n"                                          println("Returning");
  149:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
  150:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  151:  sensor *tmp79 @unit @firstItem                               if @unit.@firstItem == null then
  152:  jump *label16 notEqual *tmp79 null                           ...
  153:  print "    Finished\n"                                       println("    Finished");
  154:  ucontrol flag 0 0 0 0 0                                      flag(FLAG_FREE);
  155:  jump *label16 always 0 0                                     case flag
        label *label82                                               ...
  156:  jump *label16 notEqual :backgroundProcess:flag 4             ...
  157:  print "Returning\n"                                          println("Returning");
  158:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  159:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  160:  sensor *tmp82 @unit @firstItem                               if @unit.@firstItem == null then
  161:  jump *label16 notEqual *tmp82 null                           ...
  162:  print "    Finished\n"                                       println("    Finished");
  163:  ucontrol flag 0 0 0 0 0                                      flag(FLAG_FREE);
  164:  jump *label16 always 0 0                                     while true do
        label *label13                                               #set target = 8;
  165:  wait 1e12                                                    ...
  166:  jump *label12 always 0 0                                     ...
        label *label0                                                remote void setThoriumContainer(container)
  167:  set .thoriumContainer :setThoriumContainer:container         thoriumContainer = container;
  168:  sensor .thoriumContainerX :setThoriumContainer:container @x  thoriumContainerX = container.@x;
  169:  sensor .thoriumContainerY :setThoriumContainer:container @y  thoriumContainerY = container.@y;
  170:  sensor *tmp87 .thoriumContainer @itemCapacity                thoriumLimit = thoriumContainer.@itemCapacity > 10 ? 100 : 0;
  171:  select .thoriumLimit greaterThan *tmp87 10 100 0             ...
  172:  set :setThoriumContainer*finished true                       remote void setThoriumContainer(container)
  173:  jump *label12 always 0 0                                     ...
        label *label1                                                remote void setScrapContainer(scrapContainer)
  174:  set .container :setScrapContainer:scrapContainer             container = scrapContainer;
  175:  sensor .containerX .container @x                             containerX = container.@x;
  176:  sensor .containerY .container @y                             containerY = container.@y;
  177:  set :setScrapContainer*finished true                         remote void setScrapContainer(scrapContainer)
  178:  jump *label12 always 0 0                                     ...


Performance: parsed in 327 ms, compiled in 346 ms, optimized in 463 ms, run in 5 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (13 steps):
The program didn't generate any output.
Execution exception at instruction 14: ubind @poly:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
