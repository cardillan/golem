   338 instructions before optimizations.
    12 instructions eliminated by Temp Variables Elimination (3 passes, 7 iterations).
     1 instructions eliminated by Case Expression Optimization.
    52 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    29 instructions eliminated by Condition Optimization (6 iterations).
    18 instructions eliminated by Single Step Elimination (6 iterations).
    21 instructions eliminated by Boolean Optimization (7 iterations).
       7 fully-evaluated expressions optimized using selects.
     4 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     3 instructions eliminated by Case Switching (4 iterations).
     1 case expressions converted to fast dispatch by Case Switching.
     6 instructions eliminated by Jump Straightening (2 passes, 7 iterations).
    13 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   175 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 803):
  * Fast-dispatch case at line 85:13                             size    -4, benefit       12.5, efficiency   Infinity (-3 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   114 print "Unit flag: "
   115 print :backgroundProcess:flag
   116 print "\n"
-    * set *tmp28 :backgroundProcess:flag
-    * jump *label42 equal *tmp28 0
+  117 jump *label42 equal :backgroundProcess:flag 0
   118 jump *label41 always
   119 label *label42
   120 sensor *tmp29 @unit @firstItem
 
   199 set *tmp27 null
   200 jump *label40 always
   201 label *label41
-    * jump *label61 equal *tmp28 1
+  202 jump *label61 equal :backgroundProcess:flag 1
   203 jump *label60 always
   204 label *label61
   205 print "Mining "
 
   269 set *tmp27 null
   270 jump *label40 always
   271 label *label60
-    * jump *label74 equal *tmp28 2
+  272 jump *label74 equal :backgroundProcess:flag 2
   273 jump *label73 always
   274 label *label74
   275 print "Mining "
 
   339 set *tmp27 null
   340 jump *label40 always
   341 label *label73
-    * jump *label87 equal *tmp28 3
+  342 jump *label87 equal :backgroundProcess:flag 3
   343 jump *label86 always
   344 label *label87
   345 print "Returning"
 
   361 set *tmp27 null
   362 jump *label40 always
   363 label *label86
-    * jump *label92 equal *tmp28 4
+  364 jump *label92 equal :backgroundProcess:flag 4
   365 jump *label91 always
   366 label *label92
   367 print "Returning"

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-30 instructions):
 
    27 op equal *tmp4 .core null
    28 jump *label16 equal *tmp4 false
    29 jump *label15 always
-    * set *tmp5 null
    30 jump *label17 always
    31 label *label16
-    * set *tmp5 null
    32 label *label17
    33 label *label18
    34 jump *label20 equal true false
 
    38 print "Found builder unit."
    39 print "\n"
    40 printflush message1
-    * set *tmp7 null
    41 jump *label22 always
    42 label *label21
    43 op equal *tmp8 .thoriumDrone null
 
    61 jump *label30 equal *tmp16 false
    62 ucontrol approach .coreX .coreY 6
    63 ucontrol itemDrop .core 30
-    * set *tmp17 null
    64 jump *label31 always
    65 label *label30
    66 op equal *tmp18 :serviceThoriumDrill:item null
 
    73 ucontrol itemDrop @air 30
    74 set *tmp19 null
    75 label *label33
-    * set *tmp17 *tmp19
    76 label *label31
    77 label *label29
    78 jump *label19 always
-    * set *tmp14 null
    79 jump *label26 always
    80 label *label25
-    * set *tmp14 null
    81 label *label26
    82 jump *label34 equal .container false
    83 sensor *tmp21 .core @coal
 
    97 set *tmp23 *tmp25
    98 label *label37
    99 set .ore *tmp23
-    * set *tmp20 .ore
   100 jump *label35 always
   101 label *label34
-    * set *tmp20 null
   102 label *label35
   103 sensor *tmp26 @unit @flag
   104 set :backgroundProcess:flag *tmp26
 
   123 label *label46
   124 set *tmp34 null
   125 label *label47
-    * set *tmp31 *tmp34
   126 jump *label45 always
   127 label *label44
-    * set *tmp31 null
   128 label *label45
   129 op equal *tmp35 .ore @coal
   130 jump *label48 equal *tmp35 false
 
   178 set .scrapDistance :findOreToMine:dist
   179 set *tmp51 .scrapDistance
   180 label *label59
-    * set *tmp49 *tmp51
   181 jump *label57 always
   182 label *label56
-    * set *tmp49 null
   183 label *label57
   184 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   185 label *label43
 
   197 ucontrol approach .coreX .coreY 6
   198 ucontrol itemDrop .core 30
   199 ucontrol flag 3
-    * set *tmp53 null
   200 jump *label64 always
   201 label *label63
-    * set *tmp53 null
   202 label *label64
   203 sensor *tmp54 @unit @firstItem
   204 op notEqual *tmp55 *tmp54 @coal
   205 jump *label65 equal *tmp55 false
   206 print " (dropping)"
   207 ucontrol itemDrop @air 30
-    * set *tmp56 null
   208 jump *label66 always
   209 label *label65
-    * set *tmp56 null
   210 label *label66
   211 print " at "
   212 print .coalX
 
   222 ucontrol approach .coreX .coreY 6
   223 ucontrol itemDrop .core 30
   224 ucontrol flag 3
-    * set *tmp59 null
   225 jump *label68 always
   226 label *label67
   227 ucontrol within .coalX .coalY 6.5 *tmp60
 
   244 label *label69
   245 set *tmp61 null
   246 label *label70
-    * set *tmp59 *tmp61
   247 label *label68
   248 print "\n"
   249 label *label62
 
   261 ucontrol approach .containerX .containerY 6
   262 ucontrol itemDrop .container 30
   263 ucontrol flag 4
-    * set *tmp66 null
   264 jump *label77 always
   265 label *label76
-    * set *tmp66 null
   266 label *label77
   267 sensor *tmp67 @unit @firstItem
   268 op notEqual *tmp68 *tmp67 @scrap
   269 jump *label78 equal *tmp68 false
   270 print " (dropping)"
   271 ucontrol itemDrop @air 30
-    * set *tmp69 null
   272 jump *label79 always
   273 label *label78
-    * set *tmp69 null
   274 label *label79
   275 print " at "
   276 print .scrapX
 
   286 ucontrol approach .containerX .containerY 6
   287 ucontrol itemDrop .container 30
   288 ucontrol flag 4
-    * set *tmp72 null
   289 jump *label81 always
   290 label *label80
   291 ucontrol within .scrapX .scrapY 6.5 *tmp73
 
   308 label *label82
   309 set *tmp74 null
   310 label *label83
-    * set *tmp72 *tmp74
   311 label *label81
   312 print "\n"
   313 label *label75
 
   327 print "    Finished"
   328 print "\n"
   329 ucontrol flag 0
-    * set *tmp80 null
   330 jump *label90 always
   331 label *label89
-    * set *tmp80 null
   332 label *label90
   333 label *label88
   334 set *tmp27 null
 
   347 print "    Finished"
   348 print "\n"
   349 ucontrol flag 0
-    * set *tmp83 null
   350 jump *label95 always
   351 label *label94
-    * set *tmp83 null
   352 label *label95
   353 label *label93
   354 set *tmp27 null
 
   358 label *label40
   359 set *tmp9 *tmp27
   360 label *label24
-    * set *tmp7 *tmp9
   361 label *label22
   362 label *label19
   363 jump *label18 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-12 instructions):
 
    44 jump *label23 equal *tmp8 false
    45 set *tmp10 @unit
    46 set .thoriumDrone *tmp10
-    * set *tmp9 *tmp10
    47 jump *label24 always
    48 label *label23
    49 op equal *tmp11 @unit .thoriumDrone
 
    66 jump *label32 equal *tmp18 false
    67 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    68 ucontrol itemTake .thoriumContainer @thorium 30
-    * set *tmp19 null
    69 jump *label33 always
    70 label *label32
    71 ucontrol itemDrop @air 30
-    * set *tmp19 null
    72 label *label33
    73 label *label31
    74 label *label29
 
   115 print "Holding wrong item."
   116 print "\n"
   117 jump *label43 always
-    * set *tmp34 null
   118 jump *label47 always
   119 label *label46
-    * set *tmp34 null
   120 label *label47
   121 jump *label45 always
   122 label *label44
 
   165 set .coalX :findOreToMine:x
   166 set .coalY :findOreToMine:y
   167 set .coalDistance :findOreToMine:dist
-    * set *tmp51 .coalDistance
   168 jump *label59 always
   169 label *label58
   170 set .scrapX :findOreToMine:x
   171 set .scrapY :findOreToMine:y
   172 set .scrapDistance :findOreToMine:dist
-    * set *tmp51 .scrapDistance
   173 label *label59
   174 jump *label57 always
   175 label *label56
 
   232 label *label71
   233 set *tmp64 null
   234 label *label72
-    * set *tmp61 *tmp64
   235 jump *label70 always
   236 label *label69
-    * set *tmp61 null
   237 label *label70
   238 label *label68
   239 print "\n"
 
   294 label *label84
   295 set *tmp77 null
   296 label *label85
-    * set *tmp74 *tmp77
   297 jump *label83 always
   298 label *label82
-    * set *tmp74 null
   299 label *label83
   300 label *label81
   301 print "\n"
 
   345 label *label91
   346 set *tmp27 null
   347 label *label40
-    * set *tmp9 *tmp27
   348 label *label24
   349 label *label22
   350 label *label19

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   176 label *label57
   177 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   178 label *label43
-    * set *tmp27 null
   179 jump *label40 always
   180 label *label41
   181 jump *label61 equal :backgroundProcess:flag 1
 
   226 ucontrol approach .coreX .coreY 6
   227 ucontrol itemDrop .core 30
   228 ucontrol flag 3
-    * set *tmp64 null
   229 jump *label72 always
   230 label *label71
-    * set *tmp64 null
   231 label *label72
   232 jump *label70 always
   233 label *label69
 
   235 label *label68
   236 print "\n"
   237 label *label62
-    * set *tmp27 null
   238 jump *label40 always
   239 label *label60
   240 jump *label74 equal :backgroundProcess:flag 2
 
   285 ucontrol approach .containerX .containerY 6
   286 ucontrol itemDrop .container 30
   287 ucontrol flag 4
-    * set *tmp77 null
   288 jump *label85 always
   289 label *label84
-    * set *tmp77 null
   290 label *label85
   291 jump *label83 always
   292 label *label82
 
   294 label *label81
   295 print "\n"
   296 label *label75
-    * set *tmp27 null
   297 jump *label40 always
   298 label *label73
   299 jump *label87 equal :backgroundProcess:flag 3
 
   313 label *label89
   314 label *label90
   315 label *label88
-    * set *tmp27 null
   316 jump *label40 always
   317 label *label86
   318 jump *label92 equal :backgroundProcess:flag 4
 
   332 label *label94
   333 label *label95
   334 label *label93
-    * set *tmp27 null
   335 jump *label40 always
   336 label *label91
-    * set *tmp27 null
   337 label *label40
   338 label *label24
   339 label *label22

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-11 instructions):
 
    14 set .scrapDistance 1000000000
    15 label *label11
    16 ubind @poly
-    * set *tmp0 @unit
-    * set .builder *tmp0
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   17 set .builder @unit
+   18 ulocate building core false @copper .coreX .coreY *tmp2 .core
    19 label *label12
    20 op equal *tmp3 .core null
    21 jump *label11 notEqual *tmp3 false
 
    40 label *label21
    41 op equal *tmp8 .thoriumDrone null
    42 jump *label23 equal *tmp8 false
-    * set *tmp10 @unit
-    * set .thoriumDrone *tmp10
+   43 set .thoriumDrone @unit
    44 jump *label24 always
    45 label *label23
    46 op equal *tmp11 @unit .thoriumDrone
 
    51 jump *label25 equal *tmp13 false
    52 jump *label27 always
    53 label *label27
-    * sensor *tmp15 @unit @firstItem
-    * set :serviceThoriumDrill:item *tmp15
+   54 sensor :serviceThoriumDrill:item @unit @firstItem
    55 op equal *tmp16 :serviceThoriumDrill:item @thorium
    56 jump *label30 equal *tmp16 false
    57 ucontrol approach .coreX .coreY 6
 
    73 label *label25
    74 label *label26
    75 jump *label34 equal .container false
-    * sensor *tmp21 .core @coal
-    * set :backgroundProcess:coal *tmp21
+   76 sensor :backgroundProcess:coal .core @coal
    77 op lessThan *tmp22 :backgroundProcess:coal 120
    78 jump *label36 equal *tmp22 false
    79 set *tmp23 @coal
 
    92 jump *label35 always
    93 label *label34
    94 label *label35
-    * sensor *tmp26 @unit @flag
-    * set :backgroundProcess:flag *tmp26
+   95 sensor :backgroundProcess:flag @unit @flag
    96 print "Unit flag: "
    97 print :backgroundProcess:flag
    98 print "\n"
 
   150 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
   151 op sub *tmp45 :findOreToMine:x :findOreToMine:targetX
   152 op sub *tmp46 :findOreToMine:y :findOreToMine:targetY
-    * op len *tmp47 *tmp45 *tmp46
-    * set :findOreToMine:dist *tmp47
+  153 op len :findOreToMine:dist *tmp45 *tmp46
   154 op lessThan *tmp48 :findOreToMine:dist :findOreToMine:distance
   155 jump *label56 equal *tmp48 false
   156 op equal *tmp50 .ore @coal
 
   339 end
   340 label *label0
   341 set .thoriumContainer :setThoriumContainer:container
-    * sensor *tmp84 :setThoriumContainer:container @x
-    * set .thoriumContainerX *tmp84
-    * sensor *tmp85 :setThoriumContainer:container @y
-    * set .thoriumContainerY *tmp85
+  342 sensor .thoriumContainerX :setThoriumContainer:container @x
+  343 sensor .thoriumContainerY :setThoriumContainer:container @y
   344 sensor *tmp86 .thoriumContainer @itemCapacity
   345 op greaterThan *tmp87 *tmp86 10
   346 jump *label97 equal *tmp87 false
 
   356 end
   357 label *label2
   358 set .container :setScrapContainer:scrapContainer
-    * sensor *tmp89 .container @x
-    * set .containerX *tmp89
-    * sensor *tmp90 .container @y
-    * set .containerY *tmp90
+  359 sensor .containerX .container @x
+  360 sensor .containerY .container @y
   361 label *label99
   362 set :setScrapContainer*finished true
   363 jump *label14 always

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    29 label *label16
    30 label *label17
    31 label *label18
-    * jump *label20 equal true false
    32 ubind @poly
    33 op equal *tmp6 @unit .builder
    34 jump *label21 equal *tmp6 false

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-5 instructions):
 
    95 print "Unit flag: "
    96 print :backgroundProcess:flag
    97 print "\n"
-    * jump *label42 equal :backgroundProcess:flag 0
-    * jump *label41 always
+   98 jump *label41 notEqual :backgroundProcess:flag 0
    99 label *label42
   100 sensor *tmp29 @unit @firstItem
   101 op notEqual *tmp30 *tmp29 null
 
   169 label *label43
   170 jump *label40 always
   171 label *label41
-    * jump *label61 equal :backgroundProcess:flag 1
-    * jump *label60 always
+  172 jump *label60 notEqual :backgroundProcess:flag 1
   173 label *label61
   174 print "Mining "
   175 printchar @coal
 
   227 label *label62
   228 jump *label40 always
   229 label *label60
-    * jump *label74 equal :backgroundProcess:flag 2
-    * jump *label73 always
+  230 jump *label73 notEqual :backgroundProcess:flag 2
   231 label *label74
   232 print "Mining "
   233 printchar @scrap
 
   285 label *label75
   286 jump *label40 always
   287 label *label73
-    * jump *label87 equal :backgroundProcess:flag 3
-    * jump *label86 always
+  288 jump *label86 notEqual :backgroundProcess:flag 3
   289 label *label87
   290 print "Returning"
   291 print "\n"
 
   303 label *label88
   304 jump *label40 always
   305 label *label86
-    * jump *label92 equal :backgroundProcess:flag 4
-    * jump *label91 always
+  306 jump *label91 notEqual :backgroundProcess:flag 4
   307 label *label92
   308 print "Returning"
   309 print "\n"

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-29 instructions):
 
    17 set .builder @unit
    18 ulocate building core false @copper .coreX .coreY *tmp2 .core
    19 label *label12
-    * op equal *tmp3 .core null
-    * jump *label11 notEqual *tmp3 false
+   20 jump *label11 equal .core null
    21 label *label13
    22 set *signature "2bc8cecff9ae5b38:v1"
    23 label *label14
-    * op equal *tmp4 .core null
-    * jump *label16 equal *tmp4 false
+   24 jump *label16 notEqual .core null
    25 jump *label15 always
    26 jump *label17 always
    27 label *label16
    28 label *label17
    29 label *label18
    30 ubind @poly
-    * op equal *tmp6 @unit .builder
-    * jump *label21 equal *tmp6 false
+   31 jump *label21 notEqual @unit .builder
    32 print "Found builder unit."
    33 print "\n"
    34 printflush message1
    35 jump *label22 always
    36 label *label21
-    * op equal *tmp8 .thoriumDrone null
-    * jump *label23 equal *tmp8 false
+   37 jump *label23 notEqual .thoriumDrone null
    38 set .thoriumDrone @unit
    39 jump *label24 always
    40 label *label23
-    * op equal *tmp11 @unit .thoriumDrone
-    * jump *label25 equal *tmp11 false
+   41 jump *label25 notEqual @unit .thoriumDrone
    42 label *label28
    43 sensor *tmp12 .thoriumContainer @thorium
-    * op greaterThan *tmp13 *tmp12 .thoriumLimit
-    * jump *label25 equal *tmp13 false
+   44 jump *label25 lessThanEq *tmp12 .thoriumLimit
    45 jump *label27 always
    46 label *label27
    47 sensor :serviceThoriumDrill:item @unit @firstItem
-    * op equal *tmp16 :serviceThoriumDrill:item @thorium
-    * jump *label30 equal *tmp16 false
+   48 jump *label30 notEqual :serviceThoriumDrill:item @thorium
    49 ucontrol approach .coreX .coreY 6
    50 ucontrol itemDrop .core 30
    51 jump *label31 always
    52 label *label30
-    * op equal *tmp18 :serviceThoriumDrill:item null
-    * jump *label32 equal *tmp18 false
+   53 jump *label32 notEqual :serviceThoriumDrill:item null
    54 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    55 ucontrol itemTake .thoriumContainer @thorium 30
    56 jump *label33 always
 
    65 label *label26
    66 jump *label34 equal .container false
    67 sensor :backgroundProcess:coal .core @coal
-    * op lessThan *tmp22 :backgroundProcess:coal 120
-    * jump *label36 equal *tmp22 false
+   68 jump *label36 greaterThanEq :backgroundProcess:coal 120
    69 set *tmp23 @coal
    70 jump *label37 always
    71 label *label36
-    * op greaterThan *tmp24 :backgroundProcess:coal 220
-    * jump *label38 equal *tmp24 false
+   72 jump *label38 lessThanEq :backgroundProcess:coal 220
    73 set *tmp25 @scrap
    74 jump *label39 always
    75 label *label38
 
    88 jump *label41 notEqual :backgroundProcess:flag 0
    89 label *label42
    90 sensor *tmp29 @unit @firstItem
-    * op notEqual *tmp30 *tmp29 null
-    * jump *label44 equal *tmp30 false
+   91 jump *label44 equal *tmp29 null
    92 ucontrol itemDrop @air 30
    93 sensor *tmp32 @unit @firstItem
-    * op notEqual *tmp33 *tmp32 null
-    * jump *label46 equal *tmp33 false
+   94 jump *label46 equal *tmp32 null
    95 print "Holding wrong item."
    96 print "\n"
    97 jump *label43 always
 
   101 jump *label45 always
   102 label *label44
   103 label *label45
-    * op equal *tmp35 .ore @coal
-    * jump *label48 equal *tmp35 false
+  104 jump *label48 notEqual .ore @coal
   105 set *tmp36 1
   106 jump *label49 always
   107 label *label48
   108 set *tmp36 2
   109 label *label49
   110 ucontrol flag *tmp36
-    * op equal *tmp37 .ore @coal
-    * jump *label50 equal *tmp37 false
+  111 jump *label50 notEqual .ore @coal
   112 set *tmp38 .coreX
   113 jump *label51 always
   114 label *label50
   115 set *tmp38 .containerX
   116 label *label51
   117 set :findOreToMine:targetX *tmp38
-    * op equal *tmp39 .ore @coal
-    * jump *label52 equal *tmp39 false
+  118 jump *label52 notEqual .ore @coal
   119 set *tmp40 .coreY
   120 jump *label53 always
   121 label *label52
   122 set *tmp40 .containerY
   123 label *label53
   124 set :findOreToMine:targetY *tmp40
-    * op equal *tmp41 .ore @coal
-    * jump *label54 equal *tmp41 false
+  125 jump *label54 notEqual .ore @coal
   126 set *tmp42 .coalDistance
   127 jump *label55 always
   128 label *label54
 
   133 op sub *tmp45 :findOreToMine:x :findOreToMine:targetX
   134 op sub *tmp46 :findOreToMine:y :findOreToMine:targetY
   135 op len :findOreToMine:dist *tmp45 *tmp46
-    * op lessThan *tmp48 :findOreToMine:dist :findOreToMine:distance
-    * jump *label56 equal *tmp48 false
-    * op equal *tmp50 .ore @coal
-    * jump *label58 equal *tmp50 false
+  136 jump *label56 greaterThanEq :findOreToMine:dist :findOreToMine:distance
+  137 jump *label58 notEqual .ore @coal
   138 set .coalX :findOreToMine:x
   139 set .coalY :findOreToMine:y
   140 set .coalDistance :findOreToMine:dist
 
   155 label *label61
   156 print "Mining "
   157 printchar @coal
-    * op notEqual *tmp52 .ore @coal
-    * jump *label63 equal *tmp52 false
+  158 jump *label63 equal .ore @coal
   159 print ", switching"
   160 ucontrol approach .coreX .coreY 6
   161 ucontrol itemDrop .core 30
 
   164 label *label63
   165 label *label64
   166 sensor *tmp54 @unit @firstItem
-    * op notEqual *tmp55 *tmp54 @coal
-    * jump *label65 equal *tmp55 false
+  167 jump *label65 equal *tmp54 @coal
   168 print " (dropping)"
   169 ucontrol itemDrop @air 30
   170 jump *label66 always
 
   178 ucontrol approach .coalX .coalY 6
   179 ucontrol mine .coalX .coalY
   180 sensor *tmp57 @unit @totalItems
-    * op greaterThanEq *tmp58 *tmp57 30
-    * jump *label67 equal *tmp58 false
+  181 jump *label67 lessThan *tmp57 30
   182 print ", full"
   183 ucontrol approach .coreX .coreY 6
   184 ucontrol itemDrop .core 30
 
   188 ucontrol within .coalX .coalY 6.5 *tmp60
   189 jump *label69 equal *tmp60 false
   190 sensor *tmp62 @unit @mining
-    * op equal *tmp63 *tmp62 false
-    * jump *label71 equal *tmp63 false
+  191 jump *label71 notEqual *tmp62 false
   192 print ", ore lost"
   193 set .coalDistance 1000000000
   194 ucontrol approach .coreX .coreY 6
 
   209 label *label74
   210 print "Mining "
   211 printchar @scrap
-    * op notEqual *tmp65 .ore @scrap
-    * jump *label76 equal *tmp65 false
+  212 jump *label76 equal .ore @scrap
   213 print ", switching"
   214 ucontrol approach .containerX .containerY 6
   215 ucontrol itemDrop .container 30
 
   218 label *label76
   219 label *label77
   220 sensor *tmp67 @unit @firstItem
-    * op notEqual *tmp68 *tmp67 @scrap
-    * jump *label78 equal *tmp68 false
+  221 jump *label78 equal *tmp67 @scrap
   222 print " (dropping)"
   223 ucontrol itemDrop @air 30
   224 jump *label79 always
 
   232 ucontrol approach .scrapX .scrapY 6
   233 ucontrol mine .scrapX .scrapY
   234 sensor *tmp70 @unit @totalItems
-    * op greaterThanEq *tmp71 *tmp70 25
-    * jump *label80 equal *tmp71 false
+  235 jump *label80 lessThan *tmp70 25
   236 print ", full"
   237 ucontrol approach .containerX .containerY 6
   238 ucontrol itemDrop .container 30
 
   242 ucontrol within .scrapX .scrapY 6.5 *tmp73
   243 jump *label82 equal *tmp73 false
   244 sensor *tmp75 @unit @mining
-    * op equal *tmp76 *tmp75 false
-    * jump *label84 equal *tmp76 false
+  245 jump *label84 notEqual *tmp75 false
   246 print ", ore lost"
   247 set .scrapDistance 1000000000
   248 ucontrol approach .containerX .containerY 6
 
   266 ucontrol approach .coreX .coreY 6
   267 ucontrol itemDrop .core 30
   268 sensor *tmp78 @unit @firstItem
-    * op equal *tmp79 *tmp78 null
-    * jump *label89 equal *tmp79 false
+  269 jump *label89 notEqual *tmp78 null
   270 print "    Finished"
   271 print "\n"
   272 ucontrol flag 0
 
   283 ucontrol approach .containerX .containerY 6
   284 ucontrol itemDrop .container 30
   285 sensor *tmp81 @unit @firstItem
-    * op equal *tmp82 *tmp81 null
-    * jump *label94 equal *tmp82 false
+  286 jump *label94 notEqual *tmp81 null
   287 print "    Finished"
   288 print "\n"
   289 ucontrol flag 0
 
   308 sensor .thoriumContainerX :setThoriumContainer:container @x
   309 sensor .thoriumContainerY :setThoriumContainer:container @y
   310 sensor *tmp86 .thoriumContainer @itemCapacity
-    * op greaterThan *tmp87 *tmp86 10
-    * jump *label97 equal *tmp87 false
+  311 jump *label97 lessThanEq *tmp86 10
   312 set *tmp88 100
   313 jump *label98 always
   314 label *label97

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-18 instructions):
 
    23 label *label14
    24 jump *label16 notEqual .core null
    25 jump *label15 always
-    * jump *label17 always
    26 label *label16
    27 label *label17
    28 label *label18
 
    41 label *label28
    42 sensor *tmp12 .thoriumContainer @thorium
    43 jump *label25 lessThanEq *tmp12 .thoriumLimit
-    * jump *label27 always
    44 label *label27
    45 sensor :serviceThoriumDrill:item @unit @firstItem
    46 jump *label30 notEqual :serviceThoriumDrill:item @thorium
 
    58 label *label31
    59 label *label29
    60 jump *label19 always
-    * jump *label26 always
    61 label *label25
    62 label *label26
    63 jump *label34 equal .container false
 
    75 set *tmp23 *tmp25
    76 label *label37
    77 set .ore *tmp23
-    * jump *label35 always
    78 label *label34
    79 label *label35
    80 sensor :backgroundProcess:flag @unit @flag
 
    91 print "Holding wrong item."
    92 print "\n"
    93 jump *label43 always
-    * jump *label47 always
    94 label *label46
    95 label *label47
-    * jump *label45 always
    96 label *label44
    97 label *label45
    98 jump *label48 notEqual .ore @coal
 
   138 set .scrapY :findOreToMine:y
   139 set .scrapDistance :findOreToMine:dist
   140 label *label59
-    * jump *label57 always
   141 label *label56
   142 label *label57
   143 ucontrol approach :findOreToMine:x :findOreToMine:y 6
 
   153 ucontrol approach .coreX .coreY 6
   154 ucontrol itemDrop .core 30
   155 ucontrol flag 3
-    * jump *label64 always
   156 label *label63
   157 label *label64
   158 sensor *tmp54 @unit @firstItem
   159 jump *label65 equal *tmp54 @coal
   160 print " (dropping)"
   161 ucontrol itemDrop @air 30
-    * jump *label66 always
   162 label *label65
   163 label *label66
   164 print " at "
 
   185 ucontrol approach .coreX .coreY 6
   186 ucontrol itemDrop .core 30
   187 ucontrol flag 3
-    * jump *label72 always
   188 label *label71
   189 label *label72
-    * jump *label70 always
   190 label *label69
   191 label *label70
   192 label *label68
 
   203 ucontrol approach .containerX .containerY 6
   204 ucontrol itemDrop .container 30
   205 ucontrol flag 4
-    * jump *label77 always
   206 label *label76
   207 label *label77
   208 sensor *tmp67 @unit @firstItem
   209 jump *label78 equal *tmp67 @scrap
   210 print " (dropping)"
   211 ucontrol itemDrop @air 30
-    * jump *label79 always
   212 label *label78
   213 label *label79
   214 print " at "
 
   235 ucontrol approach .containerX .containerY 6
   236 ucontrol itemDrop .container 30
   237 ucontrol flag 4
-    * jump *label85 always
   238 label *label84
   239 label *label85
-    * jump *label83 always
   240 label *label82
   241 label *label83
   242 label *label81
 
   255 print "    Finished"
   256 print "\n"
   257 ucontrol flag 0
-    * jump *label90 always
   258 label *label89
   259 label *label90
   260 label *label88
 
   271 print "    Finished"
   272 print "\n"
   273 ucontrol flag 0
-    * jump *label95 always
   274 label *label94
   275 label *label95
   276 label *label93
-    * jump *label40 always
   277 label *label91
   278 label *label40
   279 label *label24

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   124 label *label55
   125 set :findOreToMine:distance *tmp42
   126 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
-    * op sub *tmp45 :findOreToMine:x :findOreToMine:targetX
-    * op sub *tmp46 :findOreToMine:y :findOreToMine:targetY
+  127 op sub *tmp45 :findOreToMine:x *tmp38
+  128 op sub *tmp46 :findOreToMine:y *tmp40
   129 op len :findOreToMine:dist *tmp45 *tmp46
-    * jump *label56 greaterThanEq :findOreToMine:dist :findOreToMine:distance
+  130 jump *label56 greaterThanEq :findOreToMine:dist *tmp42
   131 jump *label58 notEqual .ore @coal
   132 set .coalX :findOreToMine:x
   133 set .coalY :findOreToMine:y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
   108 label *label50
   109 set *tmp38 .containerX
   110 label *label51
-    * set :findOreToMine:targetX *tmp38
   111 jump *label52 notEqual .ore @coal
   112 set *tmp40 .coreY
   113 jump *label53 always
   114 label *label52
   115 set *tmp40 .containerY
   116 label *label53
-    * set :findOreToMine:targetY *tmp40
   117 jump *label54 notEqual .ore @coal
   118 set *tmp42 .coalDistance
   119 jump *label55 always
   120 label *label54
   121 set *tmp42 .scrapDistance
   122 label *label55
-    * set :findOreToMine:distance *tmp42
   123 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
   124 op sub *tmp45 :findOreToMine:x *tmp38
   125 op sub *tmp46 :findOreToMine:y *tmp40

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-18 instructions):
 
    38 jump *label24 always
    39 label *label23
    40 jump *label25 notEqual @unit .thoriumDrone
-    * label *label28
    41 sensor *tmp12 .thoriumContainer @thorium
    42 jump *label25 lessThanEq *tmp12 .thoriumLimit
-    * label *label27
    43 sensor :serviceThoriumDrill:item @unit @firstItem
    44 jump *label30 notEqual :serviceThoriumDrill:item @thorium
    45 ucontrol approach .coreX .coreY 6
 
    64 set *tmp23 @coal
    65 jump *label37 always
    66 label *label36
-    * jump *label38 lessThanEq :backgroundProcess:coal 220
-    * set *tmp25 @scrap
-    * jump *label39 always
-    * label *label38
-    * set *tmp25 .ore
-    * label *label39
+   67 select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
    68 set *tmp23 *tmp25
    69 label *label37
    70 set .ore *tmp23
 
    88 label *label47
    89 label *label44
    90 label *label45
-    * jump *label48 notEqual .ore @coal
-    * set *tmp36 1
-    * jump *label49 always
-    * label *label48
-    * set *tmp36 2
-    * label *label49
+   91 select *tmp36 equal .ore @coal 1 2
    92 ucontrol flag *tmp36
-    * jump *label50 notEqual .ore @coal
-    * set *tmp38 .coreX
-    * jump *label51 always
-    * label *label50
-    * set *tmp38 .containerX
-    * label *label51
-    * jump *label52 notEqual .ore @coal
-    * set *tmp40 .coreY
-    * jump *label53 always
-    * label *label52
-    * set *tmp40 .containerY
-    * label *label53
-    * jump *label54 notEqual .ore @coal
-    * set *tmp42 .coalDistance
-    * jump *label55 always
-    * label *label54
-    * set *tmp42 .scrapDistance
-    * label *label55
+   93 select *tmp38 equal .ore @coal .coreX .containerX
+   94 select *tmp40 equal .ore @coal .coreY .containerY
+   95 select *tmp42 equal .ore @coal .coalDistance .scrapDistance
    96 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
    97 op sub *tmp45 :findOreToMine:x *tmp38
    98 op sub *tmp46 :findOreToMine:y *tmp40
 
   259 set .thoriumContainer :setThoriumContainer:container
   260 sensor .thoriumContainerX :setThoriumContainer:container @x
   261 sensor .thoriumContainerY :setThoriumContainer:container @y
-    * sensor *tmp86 .thoriumContainer @itemCapacity
-    * jump *label97 lessThanEq *tmp86 10
-    * set *tmp88 100
-    * jump *label98 always
-    * label *label97
-    * set *tmp88 0
-    * label *label98
+  262 sensor *tmp86 .thoriumContainer @itemCapacity
+  263 select *tmp88 greaterThan *tmp86 10 100 0
   264 set .thoriumLimit *tmp88
   265 label *label96
   266 set :setThoriumContainer*finished true

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 2 (-3 instructions):
 
    60 label *label26
    61 jump *label34 equal .container false
    62 sensor :backgroundProcess:coal .core @coal
-    * jump *label36 greaterThanEq :backgroundProcess:coal 120
-    * set *tmp23 @coal
-    * jump *label37 always
-    * label *label36
-    * select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
-    * set *tmp23 *tmp25
-    * label *label37
+   63 select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
+   64 select *tmp23 lessThan :backgroundProcess:coal 120 @coal *tmp25
    65 set .ore *tmp23
    66 label *label34
    67 label *label35

Modifications by Fast-dispatch case at line 85:13 (-3 instructions):
 
    69 print "Unit flag: "
    70 print :backgroundProcess:flag
    71 print "\n"
-    * jump *label41 notEqual :backgroundProcess:flag 0
+   72 multijump :backgroundProcess:flag 0 0 (m:*label101)
+   73 multilabel *label107 (m:*label101)
+   74 label *label100
+   75 jump *label40 always
+   76 multilabel *label102 (m:*label101)
    77 label *label42
    78 sensor *tmp29 @unit @firstItem
    79 jump *label44 equal *tmp29 null
 
   113 label *label43
   114 jump *label40 always
   115 label *label41
-    * jump *label60 notEqual :backgroundProcess:flag 1
+  116 multilabel *label103 (m:*label101)
   117 label *label61
   118 print "Mining "
   119 printchar @coal
 
   163 label *label62
   164 jump *label40 always
   165 label *label60
-    * jump *label73 notEqual :backgroundProcess:flag 2
+  166 multilabel *label104 (m:*label101)
   167 label *label74
   168 print "Mining "
   169 printchar @scrap
 
   213 label *label75
   214 jump *label40 always
   215 label *label73
-    * jump *label86 notEqual :backgroundProcess:flag 3
+  216 multilabel *label105 (m:*label101)
   217 label *label87
   218 print "Returning"
   219 print "\n"
 
   229 label *label88
   230 jump *label40 always
   231 label *label86
-    * jump *label91 notEqual :backgroundProcess:flag 4
+  232 multilabel *label106 (m:*label101)
   233 label *label92
   234 print "Returning"
   235 print "\n"
 
   243 label *label94
   244 label *label95
   245 label *label93
-    * label *label91
   246 label *label40
   247 label *label24
   248 label *label22

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   258 sensor .thoriumContainerX :setThoriumContainer:container @x
   259 sensor .thoriumContainerY :setThoriumContainer:container @y
   260 sensor *tmp86 .thoriumContainer @itemCapacity
-    * select *tmp88 greaterThan *tmp86 10 100 0
-    * set .thoriumLimit *tmp88
+  261 select .thoriumLimit greaterThan *tmp86 10 100 0
   262 label *label96
   263 set :setThoriumContainer*finished true
   264 jump *label14 always

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-1 instructions):
 
    61 jump *label34 equal .container false
    62 sensor :backgroundProcess:coal .core @coal
    63 select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
-    * select *tmp23 lessThan :backgroundProcess:coal 120 @coal *tmp25
-    * set .ore *tmp23
+   64 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp25
    65 label *label34
    66 label *label35
    67 sensor :backgroundProcess:flag @unit @flag

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    16 ubind @poly
    17 set .builder @unit
    18 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label12
    19 jump *label11 equal .core null
-    * label *label13
    20 set *signature "2bc8cecff9ae5b38:v1"
    21 label *label14
    22 jump *label16 notEqual .core null
    23 jump *label15 always
    24 label *label16
-    * label *label17
    25 label *label18
    26 ubind @poly
    27 jump *label21 notEqual @unit .builder
 
    51 ucontrol itemDrop @air 30
    52 label *label33
    53 label *label31
-    * label *label29
    54 jump *label19 always
    55 label *label25
-    * label *label26
    56 jump *label34 equal .container false
    57 sensor :backgroundProcess:coal .core @coal
    58 select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap .ore
    59 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp25
    60 label *label34
-    * label *label35
    61 sensor :backgroundProcess:flag @unit @flag
    62 print "Unit flag: "
    63 print :backgroundProcess:flag
    64 print "\n"
    65 multijump :backgroundProcess:flag 0 0 (m:*label101)
    66 multilabel *label107 (m:*label101)
-    * label *label100
    67 jump *label40 always
    68 multilabel *label102 (m:*label101)
-    * label *label42
    69 sensor *tmp29 @unit @firstItem
    70 jump *label44 equal *tmp29 null
    71 ucontrol itemDrop @air 30
 
    75 print "\n"
    76 jump *label43 always
    77 label *label46
-    * label *label47
    78 label *label44
-    * label *label45
    79 select *tmp36 equal .ore @coal 1 2
    80 ucontrol flag *tmp36
    81 select *tmp38 equal .ore @coal .coreX .containerX
 
    97 set .scrapDistance :findOreToMine:dist
    98 label *label59
    99 label *label56
-    * label *label57
   100 ucontrol approach :findOreToMine:x :findOreToMine:y 6
   101 label *label43
   102 jump *label40 always
-    * label *label41
   103 multilabel *label103 (m:*label101)
-    * label *label61
   104 print "Mining "
   105 printchar @coal
   106 jump *label63 equal .ore @coal
 
   109 ucontrol itemDrop .core 30
   110 ucontrol flag 3
   111 label *label63
-    * label *label64
   112 sensor *tmp54 @unit @firstItem
   113 jump *label65 equal *tmp54 @coal
   114 print " (dropping)"
   115 ucontrol itemDrop @air 30
   116 label *label65
-    * label *label66
   117 print " at "
   118 print .coalX
   119 print ","
 
   139 ucontrol itemDrop .core 30
   140 ucontrol flag 3
   141 label *label71
-    * label *label72
   142 label *label69
-    * label *label70
   143 label *label68
   144 print "\n"
-    * label *label62
   145 jump *label40 always
-    * label *label60
   146 multilabel *label104 (m:*label101)
-    * label *label74
   147 print "Mining "
   148 printchar @scrap
   149 jump *label76 equal .ore @scrap
 
   152 ucontrol itemDrop .container 30
   153 ucontrol flag 4
   154 label *label76
-    * label *label77
   155 sensor *tmp67 @unit @firstItem
   156 jump *label78 equal *tmp67 @scrap
   157 print " (dropping)"
   158 ucontrol itemDrop @air 30
   159 label *label78
-    * label *label79
   160 print " at "
   161 print .scrapX
   162 print ","
 
   182 ucontrol itemDrop .container 30
   183 ucontrol flag 4
   184 label *label84
-    * label *label85
   185 label *label82
-    * label *label83
   186 label *label81
   187 print "\n"
-    * label *label75
   188 jump *label40 always
-    * label *label73
   189 multilabel *label105 (m:*label101)
-    * label *label87
   190 print "Returning"
   191 print "\n"
   192 ucontrol approach .coreX .coreY 6
 
   197 print "\n"
   198 ucontrol flag 0
   199 label *label89
-    * label *label90
-    * label *label88
   200 jump *label40 always
-    * label *label86
   201 multilabel *label106 (m:*label101)
-    * label *label92
   202 print "Returning"
   203 print "\n"
   204 ucontrol approach .containerX .containerY 6
 
   209 print "\n"
   210 ucontrol flag 0
   211 label *label94
-    * label *label95
-    * label *label93
   212 label *label40
   213 label *label24
   214 label *label22
   215 label *label19
   216 jump *label18 always
-    * label *label20
   217 label *label15
   218 wait 1e12
   219 jump *label14 always
-    * end
   220 label *label0
   221 set .thoriumContainer :setThoriumContainer:container
   222 sensor .thoriumContainerX :setThoriumContainer:container @x
   223 sensor .thoriumContainerY :setThoriumContainer:container @y
   224 sensor *tmp86 .thoriumContainer @itemCapacity
   225 select .thoriumLimit greaterThan *tmp86 10 100 0
-    * label *label96
   226 set :setThoriumContainer*finished true
   227 jump *label14 always
-    * end
   228 label *label2
   229 set .container :setScrapContainer:scrapContainer
   230 sensor .containerX .container @x
   231 sensor .containerY .container @y
-    * label *label99
   232 set :setScrapContainer*finished true
   233 jump *label14 always
-    * end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    19 jump *label11 equal .core null
    20 set *signature "2bc8cecff9ae5b38:v1"
    21 label *label14
-    * jump *label16 notEqual .core null
-    * jump *label15 always
+   22 jump *label15 equal .core null
    23 label *label16
    24 label *label18
    25 ubind @poly

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    26 print "Found builder unit."
    27 print "\n"
    28 printflush message1
-    * jump *label22 always
+   29 jump *label18 always
    30 label *label21
    31 jump *label23 notEqual .thoriumDrone null
    32 set .thoriumDrone @unit
-    * jump *label24 always
+   33 jump *label18 always
    34 label *label23
    35 jump *label25 notEqual @unit .thoriumDrone
    36 sensor *tmp12 .thoriumContainer @thorium
 
    39 jump *label30 notEqual :serviceThoriumDrill:item @thorium
    40 ucontrol approach .coreX .coreY 6
    41 ucontrol itemDrop .core 30
-    * jump *label31 always
+   42 jump *label18 always
    43 label *label30
    44 jump *label32 notEqual :serviceThoriumDrill:item null
    45 ucontrol approach .thoriumContainerX .thoriumContainerY 6
    46 ucontrol itemTake .thoriumContainer @thorium 30
-    * jump *label33 always
+   47 jump *label18 always
    48 label *label32
    49 ucontrol itemDrop @air 30
    50 label *label33
    51 label *label31
-    * jump *label19 always
+   52 jump *label18 always
    53 label *label25
    54 jump *label34 equal .container false
    55 sensor :backgroundProcess:coal .core @coal
 
    62 print "\n"
    63 multijump :backgroundProcess:flag 0 0 (m:*label101)
    64 multilabel *label107 (m:*label101)
-    * jump *label40 always
+   65 jump *label18 always
    66 multilabel *label102 (m:*label101)
    67 sensor *tmp29 @unit @firstItem
    68 jump *label44 equal *tmp29 null
 
    71 jump *label46 equal *tmp32 null
    72 print "Holding wrong item."
    73 print "\n"
-    * jump *label43 always
+   74 jump *label18 always
    75 label *label46
    76 label *label44
    77 select *tmp36 equal .ore @coal 1 2
 
    97 label *label56
    98 ucontrol approach :findOreToMine:x :findOreToMine:y 6
    99 label *label43
-    * jump *label40 always
+  100 jump *label18 always
   101 multilabel *label103 (m:*label101)
   102 print "Mining "
   103 printchar @coal
 
   140 label *label69
   141 label *label68
   142 print "\n"
-    * jump *label40 always
+  143 jump *label18 always
   144 multilabel *label104 (m:*label101)
   145 print "Mining "
   146 printchar @scrap
 
   183 label *label82
   184 label *label81
   185 print "\n"
-    * jump *label40 always
+  186 jump *label18 always
   187 multilabel *label105 (m:*label101)
   188 print "Returning"
   189 print "\n"
   190 ucontrol approach .coreX .coreY 6
   191 ucontrol itemDrop .core 30
   192 sensor *tmp78 @unit @firstItem
-    * jump *label89 notEqual *tmp78 null
+  193 jump *label18 notEqual *tmp78 null
   194 print "    Finished"
   195 print "\n"
   196 ucontrol flag 0
   197 label *label89
-    * jump *label40 always
+  198 jump *label18 always
   199 multilabel *label106 (m:*label101)
   200 print "Returning"
   201 print "\n"
   202 ucontrol approach .containerX .containerY 6
   203 ucontrol itemDrop .container 30
   204 sensor *tmp81 @unit @firstItem
-    * jump *label94 notEqual *tmp81 null
+  205 jump *label18 notEqual *tmp81 null
   206 print "    Finished"
   207 print "\n"
   208 ucontrol flag 0

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
    15 label *label11
    16 ubind @poly
    17 set .builder @unit
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+   18 ulocate building core false @copper .coreX .coreY 0 .core
    19 jump *label11 equal .core null
    20 set *signature "2bc8cecff9ae5b38:v1"
    21 label *label14
 
    77 select *tmp38 equal .ore @coal .coreX .containerX
    78 select *tmp40 equal .ore @coal .coreY .containerY
    79 select *tmp42 equal .ore @coal .coalDistance .scrapDistance
-    * ulocate ore core true .ore :findOreToMine:x :findOreToMine:y *tmp43 *tmp44
+   80 ulocate ore core true .ore :findOreToMine:x :findOreToMine:y 0 0
    81 op sub *tmp45 :findOreToMine:x *tmp38
    82 op sub *tmp46 :findOreToMine:y *tmp40
    83 op len :findOreToMine:dist *tmp45 *tmp46

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    23 label *label18
    24 ubind @poly
    25 jump *label21 notEqual @unit .builder
-    * print "Found builder unit."
-    * print "\n"
+   26 print "Found builder unit.\n"
    27 printflush message1
    28 jump *label18 always
    29 label *label21
 
    54 select .ore lessThan :backgroundProcess:coal 120 @coal *tmp25
    55 label *label34
    56 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   57 print "Unit flag: {0}\n"
+   58 format :backgroundProcess:flag
    59 multijump :backgroundProcess:flag 0 0 (m:*label101)
    60 multilabel *label107 (m:*label101)
    61 jump *label18 always
 
    65 ucontrol itemDrop @air 30
    66 sensor *tmp32 @unit @firstItem
    67 jump *label46 equal *tmp32 null
-    * print "Holding wrong item."
-    * print "\n"
+   68 print "Holding wrong item.\n"
    69 jump *label18 always
    70 label *label46
    71 label *label44
 
    93 ucontrol approach :findOreToMine:x :findOreToMine:y 6
    94 jump *label18 always
    95 multilabel *label103 (m:*label101)
-    * print "Mining "
-    * printchar @coal
+   96 print "Mining "
    97 jump *label63 equal .ore @coal
    98 print ", switching"
    99 ucontrol approach .coreX .coreY 6
 
   105 print " (dropping)"
   106 ucontrol itemDrop @air 30
   107 label *label65
-    * print " at "
-    * print .coalX
-    * print ","
-    * print " "
+  108 print " at {0}, "
+  109 format .coalX
   110 print .coalY
   111 ucontrol approach .coalX .coalY 6
   112 ucontrol mine .coalX .coalY
 
   133 print "\n"
   134 jump *label18 always
   135 multilabel *label104 (m:*label101)
-    * print "Mining "
-    * printchar @scrap
+  136 print "Mining "
   137 jump *label76 equal .ore @scrap
   138 print ", switching"
   139 ucontrol approach .containerX .containerY 6
 
   145 print " (dropping)"
   146 ucontrol itemDrop @air 30
   147 label *label78
-    * print " at "
-    * print .scrapX
-    * print ","
-    * print " "
+  148 print " at {0}, "
+  149 format .scrapX
   150 print .scrapY
   151 ucontrol approach .scrapX .scrapY 6
   152 ucontrol mine .scrapX .scrapY
 
   173 print "\n"
   174 jump *label18 always
   175 multilabel *label105 (m:*label101)
-    * print "Returning"
-    * print "\n"
+  176 print "Returning\n"
   177 ucontrol approach .coreX .coreY 6
   178 ucontrol itemDrop .core 30
   179 sensor *tmp78 @unit @firstItem
   180 jump *label18 notEqual *tmp78 null
-    * print "    Finished"
-    * print "\n"
+  181 print "    Finished\n"
   182 ucontrol flag 0
   183 jump *label18 always
   184 multilabel *label106 (m:*label101)
-    * print "Returning"
-    * print "\n"
+  185 print "Returning\n"
   186 ucontrol approach .containerX .containerY 6
   187 ucontrol itemDrop .container 30
   188 sensor *tmp81 @unit @firstItem
   189 jump *label18 notEqual *tmp81 null
-    * print "    Finished"
-    * print "\n"
+  190 print "    Finished\n"
   191 ucontrol flag 0
   192 jump *label18 always
   193 label *label15

Final code before resolving virtual instructions:

    0:  jump *label10 always 0 0                                     #set target = 8;
    1:  jump *label2 always 0 0                                      ...
    2:  jump *label0 always 0 0                                      ...
        label *label10                                               ...
    3:  set .thoriumContainer null                                   volatile var
    4:  set .thoriumLimit 100                                        volatile var
    5:  set .thoriumContainerX 0                                     ...
    6:  set .thoriumContainerY 0                                     ...
    7:  set .ore @coal                                               var
    8:  set .coalX 0                                                 ...
    9:  set .coalY 0                                                 ...
   10:  set .coalDistance 1000000000                                 ...
   11:  set .scrapX 0                                                ...
   12:  set .scrapY 0                                                ...
   13:  set .scrapDistance 1000000000                                ...
        label *label11                                               do
   14:  ubind @poly                                                  builder = ubind(@poly);
   15:  set .builder @unit                                           ...
   16:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   17:  jump *label11 equal .core null                               do
   18:  set *signature "2bc8cecff9ae5b38:v1"                         #set target = 8;
        label *label14                                               ...
   19:  jump *label15 equal .core null                               if core == null then return; end;
        label *label18                                               while true do
   20:  ubind @poly                                                  ubind(@poly);
   21:  jump *label21 notEqual @unit .builder                        if @unit == builder then
   22:  print "Found builder unit.\n"                                println("Found builder unit.");
   23:  printflush message1                                          printflush(message1);
   24:  jump *label18 always 0 0                                     if @unit == builder then
        label *label21                                               ...
   25:  jump *label23 notEqual .thoriumDrone null                    elsif thoriumDrone == null then
   26:  set .thoriumDrone @unit                                      thoriumDrone = @unit;
   27:  jump *label18 always 0 0                                     elsif thoriumDrone == null then
        label *label23                                               ...
   28:  jump *label25 notEqual @unit .thoriumDrone                   if @unit == thoriumDrone and thoriumContainer.@thorium > thoriumLimit then
   29:  sensor *tmp12 .thoriumContainer @thorium                     ...
   30:  jump *label25 lessThanEq *tmp12 .thoriumLimit                ...
   31:  sensor :serviceThoriumDrill:item @unit @firstItem            var item = @unit.@firstItem;
   32:  jump *label30 notEqual :serviceThoriumDrill:item @thorium    if item == @thorium then
   33:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   34:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   35:  jump *label18 always 0 0                                     if item == @thorium then
        label *label30                                               ...
   36:  jump *label32 notEqual :serviceThoriumDrill:item null        elsif item == null then
   37:  ucontrol approach .thoriumContainerX .thoriumContainerY 6 0  approach(thoriumContainerX, thoriumContainerY, RADIUS);
   38:  ucontrol itemTake .thoriumContainer @thorium 30 0 0          itemTake(thoriumContainer, @thorium, CAPACITY);
   39:  jump *label18 always 0 0                                     elsif item == null then
        label *label32                                               ...
   40:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   41:  jump *label18 always 0 0                                     continue;
        label *label25                                               if @unit == thoriumDrone and thoriumContainer.@thorium > thoriumLimit then
   42:  jump *label34 equal .container false                         if container then
   43:  sensor :backgroundProcess:coal .core @coal                   var coal = core.@coal;
   44:  select *tmp25 greaterThan :backgroundProcess:coal 220 @scrap ore = coal < 120 ? @coal : coal > 220 ? @scrap : ore;
   45:  select .ore lessThan :backgroundProcess:coal 120 @coal *tmp2 ...
        label *label34                                               if container then
   46:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   47:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   48:  format :backgroundProcess:flag                               ...
   49:  multijump :backgroundProcess:flag 0 0                        case flag
        multilabel *label107                                         ...
   50:  jump *label18 always 0 0                                     ...
        multilabel *label102                                         ...
   51:  sensor *tmp29 @unit @firstItem                               if @unit.@firstItem != null then
   52:  jump *label44 equal *tmp29 null                              ...
   53:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   54:  sensor *tmp32 @unit @firstItem                               if @unit.@firstItem != null then
   55:  jump *label46 equal *tmp32 null                              ...
   56:  print "Holding wrong item.\n"                                println($"Holding wrong item.");
   57:  jump *label18 always 0 0                                     return;
        label *label46                                               if @unit.@firstItem != null then
        label *label44                                               if @unit.@firstItem != null then
   58:  select *tmp36 equal .ore @coal 1 2                           flag(ore == @coal ? FLAG_MINE_COAL : FLAG_MINE_SCRAP);
   59:  ucontrol flag *tmp36 0 0 0 0                                 ...
   60:  select *tmp38 equal .ore @coal .coreX .containerX            var targetX = ore == @coal ? coreX : containerX;
   61:  select *tmp40 equal .ore @coal .coreY .containerY            var targetY = ore == @coal ? coreY : containerY;
   62:  select *tmp42 equal .ore @coal .coalDistance .scrapDistance  var distance = ore == @coal ? coalDistance : scrapDistance;
   63:  ulocate ore core true .ore :findOreToMine:x :findOreToMine:y ulocate(:ore, ore, out x, out y);
   64:  op sub *tmp45 :findOreToMine:x *tmp38                        var dist = len(x - targetX, y - targetY);
   65:  op sub *tmp46 :findOreToMine:y *tmp40                        ...
   66:  op len :findOreToMine:dist *tmp45 *tmp46                     ...
   67:  jump *label56 greaterThanEq :findOreToMine:dist *tmp42       if dist < distance then
   68:  jump *label58 notEqual .ore @coal                            if ore == @coal then
   69:  set .coalX :findOreToMine:x                                  coalX = x;
   70:  set .coalY :findOreToMine:y                                  coalY = y;
   71:  set .coalDistance :findOreToMine:dist                        coalDistance = dist;
   72:  jump *label59 always 0 0                                     if ore == @coal then
        label *label58                                               ...
   73:  set .scrapX :findOreToMine:x                                 scrapX = x;
   74:  set .scrapY :findOreToMine:y                                 scrapY = y;
   75:  set .scrapDistance :findOreToMine:dist                       scrapDistance = dist;
        label *label59                                               if ore == @coal then
        label *label56                                               if dist < distance then
   76:  ucontrol approach :findOreToMine:x :findOreToMine:y 6 0 0    approach(x, y, RADIUS);
   77:  jump *label18 always 0 0                                     case flag
        multilabel *label103                                         ...
   78:  print "Mining "                                             print("Mining ");
   79:  jump *label63 equal .ore @coal                               if ore != @coal then
   80:  print ", switching"                                          print(", switching");
   81:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   82:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   83:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
        label *label63                                               if ore != @coal then
   84:  sensor *tmp54 @unit @firstItem                               if @unit.@firstItem != @coal then
   85:  jump *label65 equal *tmp54 @coal                             ...
   86:  print " (dropping)"                                          print(" (dropping)");
   87:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label65                                               if @unit.@firstItem != @coal then
   88:  print " at {0}, "                                            print($" at $coalX, $coalY");
   89:  format .coalX                                                ...
   90:  print .coalY                                                 ...
   91:  ucontrol approach .coalX .coalY 6 0 0                        approach(coalX, coalY, RADIUS);
   92:  ucontrol mine .coalX .coalY 0 0 0                            mine(coalX, coalY);
   93:  sensor *tmp57 @unit @totalItems                              if @unit.@totalItems >= CAPACITY then
   94:  jump *label67 lessThan *tmp57 30                             ...
   95:  print ", full"                                               print(", full");
   96:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   97:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   98:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
   99:  jump *label68 always 0 0                                     if @unit.@totalItems >= CAPACITY then
        label *label67                                               ...
  100:  ucontrol within .coalX .coalY 6.5 *tmp60 0                   elsif within(coalX, coalY, RADIUS + 0.5) then
  101:  jump *label69 equal *tmp60 false                             ...
  102:  sensor *tmp62 @unit @mining                                  if !@unit.@mining then
  103:  jump *label71 notEqual *tmp62 false                          ...
  104:  print ", ore lost"                                           print(", ore lost");
  105:  set .coalDistance 1000000000                                 coalDistance = 1e9;
  106:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
  107:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  108:  ucontrol flag 3 0 0 0 0                                      flag(FLAG_RETURN_COAL);
        label *label71                                               if !@unit.@mining then
        label *label69                                               elsif within(coalX, coalY, RADIUS + 0.5) then
        label *label68                                               if @unit.@totalItems >= CAPACITY then
  109:  print "\n"                                                   println();
  110:  jump *label18 always 0 0                                     case flag
        multilabel *label104                                         ...
  111:  print "Mining "                                             print("Mining ");
  112:  jump *label76 equal .ore @scrap                              if ore != @scrap then
  113:  print ", switching"                                          print(", switching");
  114:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  115:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  116:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
        label *label76                                               if ore != @scrap then
  117:  sensor *tmp67 @unit @firstItem                               if @unit.@firstItem != @scrap then
  118:  jump *label78 equal *tmp67 @scrap                            ...
  119:  print " (dropping)"                                          print(" (dropping)");
  120:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label78                                               if @unit.@firstItem != @scrap then
  121:  print " at {0}, "                                            print($" at $scrapX, $scrapY");
  122:  format .scrapX                                               ...
  123:  print .scrapY                                                ...
  124:  ucontrol approach .scrapX .scrapY 6 0 0                      approach(scrapX, scrapY, RADIUS);
  125:  ucontrol mine .scrapX .scrapY 0 0 0                          mine(scrapX, scrapY);
  126:  sensor *tmp70 @unit @totalItems                              if @unit.@totalItems >= SCRAP_CAPACITY then
  127:  jump *label80 lessThan *tmp70 25                             ...
  128:  print ", full"                                               print(", full");
  129:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  130:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  131:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
  132:  jump *label81 always 0 0                                     if @unit.@totalItems >= SCRAP_CAPACITY then
        label *label80                                               ...
  133:  ucontrol within .scrapX .scrapY 6.5 *tmp73 0                 elsif within(scrapX, scrapY, RADIUS + 0.5) then
  134:  jump *label82 equal *tmp73 false                             ...
  135:  sensor *tmp75 @unit @mining                                  if !@unit.@mining then
  136:  jump *label84 notEqual *tmp75 false                          ...
  137:  print ", ore lost"                                           print(", ore lost");
  138:  set .scrapDistance 1000000000                                scrapDistance = 1e9;
  139:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  140:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  141:  ucontrol flag 4 0 0 0 0                                      flag(FLAG_RETURN_SCRAP);
        label *label84                                               if !@unit.@mining then
        label *label82                                               elsif within(scrapX, scrapY, RADIUS + 0.5) then
        label *label81                                               if @unit.@totalItems >= SCRAP_CAPACITY then
  142:  print "\n"                                                   println();
  143:  jump *label18 always 0 0                                     case flag
        multilabel *label105                                         ...
  144:  print "Returning\n"                                          println("Returning");
  145:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
  146:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
  147:  sensor *tmp78 @unit @firstItem                               if @unit.@firstItem == null then
  148:  jump *label18 notEqual *tmp78 null                           ...
  149:  print "    Finished\n"                                       println("    Finished");
  150:  ucontrol flag 0 0 0 0 0                                      flag(FLAG_FREE);
  151:  jump *label18 always 0 0                                     case flag
        multilabel *label106                                         ...
  152:  print "Returning\n"                                          println("Returning");
  153:  ucontrol approach .containerX .containerY 6 0 0              approach(containerX, containerY, RADIUS);
  154:  ucontrol itemDrop .container 30 0 0 0                        itemDrop(container, CAPACITY);
  155:  sensor *tmp81 @unit @firstItem                               if @unit.@firstItem == null then
  156:  jump *label18 notEqual *tmp81 null                           ...
  157:  print "    Finished\n"                                       println("    Finished");
  158:  ucontrol flag 0 0 0 0 0                                      flag(FLAG_FREE);
  159:  jump *label18 always 0 0                                     while true do
        label *label15                                               void backgroundProcess()
  160:  wait 1e12                                                    #set target = 8;
  161:  jump *label14 always 0 0                                     ...
        label *label0                                                export void setThoriumContainer(container)
  162:  set .thoriumContainer :setThoriumContainer:container         thoriumContainer = container;
  163:  sensor .thoriumContainerX :setThoriumContainer:container @x  thoriumContainerX = container.@x;
  164:  sensor .thoriumContainerY :setThoriumContainer:container @y  thoriumContainerY = container.@y;
  165:  sensor *tmp86 .thoriumContainer @itemCapacity                thoriumLimit = thoriumContainer.@itemCapacity > 10 ? 100 : 0;
  166:  select .thoriumLimit greaterThan *tmp86 10 100 0             ...
  167:  set :setThoriumContainer*finished true                       export void setThoriumContainer(container)
  168:  jump *label14 always 0 0                                     ...
        label *label2                                                export void setScrapContainer(scrapContainer)
  169:  set .container :setScrapContainer:scrapContainer             container = scrapContainer;
  170:  sensor .containerX .container @x                             containerX = container.@x;
  171:  sensor .containerY .container @y                             containerY = container.@y;
  172:  set :setScrapContainer*finished true                         export void setScrapContainer(scrapContainer)
  173:  jump *label14 always 0 0                                     ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    32     1x     32,0  void mineCoal()
    32     1x     32,0  void mineScrap()
    27     1x     27,0  void backgroundProcess()
    26     1x     26,0  void findOreToMine()
    21     1x     21,0  <no function>
    10     1x     10,0  void serviceThoriumDrill()
     7     1x      7,0  export void setThoriumContainer(in container)
     7     1x      7,0  void returnCoal()
     7     1x      7,0  void returnScrap()
     6     1x      6,0  export void setScrapContainer(in scrapContainer)

Performance: parsed in 282 ms, compiled in 264 ms, optimized in 353 ms, run in 15 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (13 steps):
The program didn't generate any output.
Execution exception at instruction 14: ubind @poly:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
