#set target = 8;
#set syntax = strict;
//#set boundary-checks = assert;
//#set sort-variables;

module Display;

require "Links.mnd";
require "Common.mnd";
require "OreLocator.mnd" remote oreLocator;

var
    core = null,
    page = 0,
    numPages = 4;

noinit export var
    missing,
    scrap,
    nextBlock,
    nextFactory,
    nextAddReco,
    nextMultiReco,
    blocksBuilt,
    targetCopper,
    targetLead,
    targetGraphite,
    targetSilicon,
    targetTitanium,
    targetMetaglass,
    targetThorium,
    totalTargets,
    transportTarget,
    transportItem,
    status1,
    status2, item2, block2,
    status3,
    titaniumDrill,
    titaniumDrillCount,
    thoriumDrill,
    thoriumContainer;

export volatile var
    recentBuildIndex = -1,
    //nextBuildIndex = 1000,
    monos = 0,
    flares = 0,
    polys = 1,
    megas = 0;

void unpackCfg2(cfg, out type, out x, out y, out rotation, out size, out index)
    unpackCfg(cfg, out type, out x, out y, , , , , , , , out rotation, out size, out index);
end;

const SEPARATOR_Y = 5;
const ROW_HEIGHT = 15;
const BAR_HEIGHT = 10;
const BAR_X = 22;

const ICON_SIZE = 16;
const ICON_X = 11;
const ICON_Y = +5;

const BAR_LENGTH = 126;
const BAR_LENGTH2 = 37;

const HEADER_X = 176 / 4 - 2;
const HEADER1_Y = 276 - 15;
const HEADER1_Y1 = HEADER1_Y - 44;
const HEADER2_Y = HEADER1_Y - 60;

inline void drawText(x, y, alignment)
    drawPrint(x, y, alignment);
end;

inline void drawText(x, y, alignment, text...)
    print(text);
    drawPrint(x, y, alignment);
end;

inline void drawBold(x, y, alignment, text...)
    drawText(x, y, alignment, text);
    drawText(x + 1, y, alignment, text);
end;

inline void drawTitleRow(in out y, alignment, text...)
    drawText(BAR_X, y, alignment, text);
    drawText(BAR_X + 1, y, alignment, text);
    y -= ROW_HEIGHT;
end;

var animation = -15;

inline def lerp(from, to, ratio)
    (1 - ratio) * from + ratio * to;
end;

inline void animate()
    if animation < 0 then
        color(0, 0, 32, 80);
        rect(0, 0, 176, 176);
    else
        reset();
        clear(0, 0, 32);
    end;

    col(%[white]);
    var ratio = max(0, min(animation / 30, 1));
    var x = lerp(HEADER_X, 180 / 2, ratio);
    var y = lerp(HEADER1_Y - 24, 280 / 2 - 20, ratio);
    var size = lerp(32, 168, ratio);
    image(x, y, @mega, size, 0);
    if ratio == 1 then drawHeader(); end;
    drawflush(display1);
    animation++;
end;

void drawHeader()
    reset();
    color(0, 0, 32, 255);
    rect(0, HEADER1_Y1, 200, 300);

    if megas > 0 then
        col(%[gold]);
        scale(3.5, 3.5);
        var t = floor(TIME / 120);
        var m = t \ 60;
        var s = t % 60;
        var zero = s < 10 ? "0" : "";
        drawBold(25, 71, @center, m, ":", zero, s);
        col(%[white]);
        reset();
    else
        col(%[gold]);
        drawBold(HEADER_X, HEADER1_Y, @bottom, "Goal");

        col(%[white]);
        if missing then
            image(16, 264, missing, 12, 0);
            missing = false;
        end;

        if nextMultiReco then
            // There can't be any other active goal now
            image(HEADER_X, HEADER1_Y - 24, nextMultiReco, 32, 0);
        else
            var count = nextBlock + nextFactory + nextAddReco;
            if count == 3 then
                image(HEADER_X - 20, HEADER1_Y - 17, nextBlock, 18, 0);
                image(HEADER_X +  0, HEADER1_Y - 17, nextFactory, 18, 0);
                image(HEADER_X + 20, HEADER1_Y - 17, nextAddReco, 18, 0);
            elsif count == 2 then
                var x = HEADER_X - 15;
                for var goal in nextBlock, nextFactory, nextAddReco do
                    if goal != null then
                        image(x, HEADER1_Y - 21, goal, 25, 0);
                        x += 30;
                    end;
                end;
            elsif count == 1 then
                for var goal in nextBlock, nextFactory, nextAddReco do
                    if goal != null then
                        image(HEADER_X, HEADER1_Y - 24, goal, 32, 0);
                        break;
                    end;
                end;
            end;
        end;

        var tt = @second;
        var t = floor(TIME / 120);
        var m = t \ 60;
        var s = t % 60;
        print(m, ":", s < 10 ? "0" : "", s);

        var ratio = round(10 * t / tt);
        print(" (x", ratio \ 10, ".", ratio % 10);

        drawText(174, 272, @topRight, ")");

        if container_a != null then
            var count = container_a.@scrap;
            var x = 174;
            var len = floor(log10(count));
            drawText(x, 255, @topRight, "x", count);
            image(x - 20 - 7 * len, 246, @scrap, 12, 0);

            count = container_a.@sand;
            x = 124;
            len = floor(log10(count));
            drawText(x, 255, @topRight, "x", count);
            image(x - 20 - 7 * len, 246, @sand, 12, 0);
        else
            if titaniumDrill then
                var count = max(titaniumDrillCount, titaniumDrill.@titanium);
                var x = 174;
                var len = floor(log10(count));
                drawText(x, 255, @topRight, "x", count);
                image(x - 20 - 7 * len, 246, @titanium, 12, 0);
            end;

            if thoriumContainer then
                var count = thoriumContainer.@thorium;
                var x = 124;
                var len = floor(log10(count));
                drawText(x, 255, @topRight, "x", count);
                image(x - 20 - 7 * len, 246, @thorium, 12, 0);
            end;
        end;

        var x = 174;
        col(%[white]);
        drawUnitCount(@poly, polys, ref x);
        drawUnitCount(@mono, monos, ref x);
        drawUnitCount(@flare, flares, ref x);
    end;
end;

inline void drawUnitCount(type, count, ref x)
    if count > 0 then
        image(x - 20, HEADER1_Y - 34, type, 12, 0);
        drawText(x, HEADER1_Y - 32, @right, "x", count);
        x -= 30;
    end;
end;

void updateDisplay()
    clear(0, 0, 32);
    drawHeader();

    var y = HEADER2_Y;
    drawMaterials(ref y);
    drawAirFactory(ref y);
    drawAddReco(ref y);
    drawMultiReco(ref y);
    drawBuilder(ref y);
    drawPower(ref y);
    drawflush(display1);
end;

inline void drawMaterials(ref y)
    var count, col = 0;

    if nextBlock == @ore-thorium or nextBlock == @ore-titanium then
        drawTitleRow(in out y, @bottomLeft, "Locating ore...");
        drawItem(in 0, in out y, 1, nextBlock, oreLocator.mapProgress, oreLocator.mapTotal, "x", oreLocator.mapSpots);
        y -= 2 * ROW_HEIGHT + SEPARATOR_Y;
    elsif nextBlock != null then
        count = totalTargets;
        drawTitleRow(in out y, @bottomLeft, "Materials");
        var columns = 1;

        if count then
            for var item, target in
                @copper,    targetCopper,
                @lead,      targetLead,
                @graphite,  targetGraphite,
                @silicon,   targetSilicon,
                @titanium,  targetTitanium,
                @metaglass, targetMetaglass,
                @thorium,   targetThorium
            do
                if target > 0 then
                    drawItem(in out col, in out y, columns, item, core.sensor(item), target, target);
                    if --count <= 0 then break; end;
                end;
            end;
        end;
        if totalTargets < 3 then
            y -= (3 - totalTargets) * ROW_HEIGHT;
        end;
        y -= SEPARATOR_Y;
    end;
end;

inline void drawAirFactory(ref y)
    if nextFactory == null then return; end;

    col(%[white]);
    drawTitleRow(in out y, @bottomLeft, "Air Factory");
    var progress = air_factory.@progress;
    if progress == 0 then
        if nextFactory == @flare then
            drawItem(in 0, in out y, 1, @silicon, air_factory.@silicon, 15, 15);
            y -= ROW_HEIGHT;
        else
            drawItem(in 0, in out y, 1, @lead, air_factory.@lead, 15, 15);
            drawItem(in 0, in out y, 1, @silicon, air_factory.@silicon, 30, 30);
        end;
    else
        drawItem(in 0, in out y, 1, nextFactory, progress, 1.0, floor(100 * progress), "%");
        y -= ROW_HEIGHT;
    end;

    y -= SEPARATOR_Y;
end;

inline void drawAddReco(ref y)
    if nextAddReco == null then return; end;

    col(%[white]);
    drawTitleRow(in out y, @bottomLeft, "Reconstructor");
    var progress = additive_rec.@progress;
    if progress == 0 then
        drawItem(in 0, in out y, 1, @graphite, additive_rec.@graphite, 40, 40);
        drawItem(in 0, in out y, 1, @silicon, additive_rec.@silicon, 40, 40);
    else
        drawItem(in 0, in out y, 1, @poly, progress, 1.0, floor(100 * progress), "%");
        y -= ROW_HEIGHT;
    end;

    y -= SEPARATOR_Y;
end;

inline void drawMultiReco(ref y)
    if nextMultiReco == null then return; end;

    col(%[white]);
    y = min(y, HEADER1_Y1 - 5 * ROW_HEIGHT);
    drawTitleRow(in out y, @bottomLeft, "Reconstructor");
    var progress = multiplicative_rec.@progress;
    if progress == 0 then
        drawItem(in 0, in out y, 1, @metaglass, multiplicative_rec.@metaglass, 40, 40);
        drawItem(in 0, in out y, 1, @titanium, multiplicative_rec.@titanium, 80, 80);
        drawItem(in 0, in out y, 1, @silicon, multiplicative_rec.@silicon, 130, 130);
    else
        drawItem(in 0, in out y, 1, @mega, progress, 1.0, floor(100 * progress), "%");
        y -= 2 * ROW_HEIGHT;
    end;

    y -= SEPARATOR_Y;
end;

inline void drawBuilder(ref y)
    if @unit.@dead then return; end;

    col(%[white]);
    drawTitleRow(in out y, @bottomLeft, "Builder");

    if transportItem == null then
        drawUnit(@poly, 0, in out y);
    else
        var unitItem = @unit.@firstItem;
        drawUnit(transportItem, @unit.@totalItems * (unitItem == transportItem), in out y);
    end;
end;

inline void drawPower(ref y)
    if battery1 == null then return; end;
    var pos = liquid_container ? 2 * ROW_HEIGHT + SEPARATOR_Y : ROW_HEIGHT + SEPARATOR_Y;
    if y < pos then return; end;

    col(%[white]);
    drawTitleRow(in out pos, @bottomLeft, liquid_container ? "Power / Water" : "Power");
    var power = battery1.@totalPower;
    drawItemColor(%808000FF, %FFFF00FF, in 0, in out pos, 1, @battery, power, 4000, floor(power * 100 / 4000), "%");
    if liquid_container then
        var water = liquid_container.@totalLiquids;
        drawItemColor(%5A5AAAFF, %AFAFFFFF, in 0, in out pos, 1, @liquid-container, water, 700, floor(water * 100 / 700), "%");
    end;
end;

inline void drawUnit(item, items, in out y)
     drawItem(in 0, in out y, 1, item, items, transportTarget, transportTarget);
end;

inline void drawItem(in out col, in out y, columns, item, current, target, text...)
    drawItemColor(%008000FF, %00FF00FF, in out col, in out y, columns, item, current, target, text);
end;

inline void drawItemColor(color1, color2, in out col, in out y, columns, item, current, target, text...)
    var barLength = BAR_LENGTH + 176 / 2 - (columns * 176 / 2);
    var textEnd = 174 - BAR_LENGTH + barLength;
    var length = min(barLength, barLength * current / target);

    var iconX = ICON_X + col * 176 / 2;
    var barX = BAR_X + col * 176 / 2;
    var textX = textEnd + col * 176 / 2;

    col(%[white]);
    image(iconX, y + ICON_Y, item, 14, 0);

    col(color1);
    rect(barX, y, length, BAR_HEIGHT);

    col(color2);
    lineRect(barX, y, barLength, BAR_HEIGHT);
    drawBold(textX, y + ICON_Y + 2, @right, text);

    if ++col >= columns then
        col = 0;
        y -= ROW_HEIGHT;
    end;
end;

void updateMessage()
    println($"[gold]Building $nextBlock");
    println("==================================[]");
    println(status1);
    println($"$status2$item2 ($block2)");
    println(status3);
    printflush(message1);
end;

const RECORDS_PER_COLUMN = 13;
const RECORDS_PER_PAGE = 3 * RECORDS_PER_COLUMN;
noinit var lastRecord;

inline void displayRecord(record, index)
    var col = index \ RECORDS_PER_COLUMN;
    var row = index % RECORDS_PER_COLUMN;
    var x = 11 + 58 * col;
    var y = HEADER1_Y1 - 13 - 15 - 15 * row;

    var id = record % 1000;
    var icon = id > @blockCount ? lookup(:unit, id - @blockCount) : lookup(:block, id);
    var t = floor(record / 1000 / 120);
    var m = t \ 60;
    var s = t % 60;
    print(m, ":", s < 10 ? "0" : "");

    image(x, y, icon, 14, 0);
    drawText(x + 56 - 12, y + 2, @right, s);
end;

void displayLog(page)
    var logPosition = bank1[511];
    var records = (511 - logPosition);
    var pages = max(1, (records - 1) \ RECORDS_PER_PAGE + 1);
    numPages = pages + 3;
    var start = 511 - RECORDS_PER_PAGE * page;
    var stop = max(logPosition, start - RECORDS_PER_PAGE);

    if pageSwitched then
        col(%[gold]);
        drawBold(4, HEADER1_Y1 - 11, @left, "Build records");
        print(page + 1, "/");
        drawText(172, HEADER1_Y1 - 11, @right, pages);
        lastRecord = start;
    end;

    drawHeader();

    for var position in stop ... lastRecord descending do
        var record = bank1[position];
        displayRecord(record, start - position - 1);
        drawflush(display1);
        if switch1.enabled then break; end;
    end;

    lastRecord = stop + 1;
    drawflush(display1);
end;

//external bank1[0 ... 4] var minX, minY, maxX, maxY;

//var mapw = @mapw, maph = @maph;

//void displayOreMap()
//    reset();
//    clear(0, 0, 32);
//
//    col(%[gold]);
//    drawText(4, 172, @topLeft, "Map");
//
//    col(%[white]);
//    scale(176 / mapw, 176 / maph);
//    var imgSize = ceil(mapw / 176);
//    //stroke(max(width, height));
//
//    image(coreX, coreY, @core-shard, 7 * imgSize, 0);
//
//    var index = -1, count = oreLocator.locations;
//    for var i in 0 ... count do
//        var id = bank1[++index];
//        var img = id > 0 ? lookup(:item, id) : lookup(:block, -id);
//        var size = 4 + sqrt(bank1[++index]);
//        var x = bank1[++index];
//        var y = bank1[++index];
//        image(x, y, img, size * imgSize, 0);
//    end;
//
//    image(titaniumDrill.@x, titaniumDrill.@y, @pneumatic-drill, 4 * imgSize, 0);
//    image(thoriumDrill.@x, thoriumDrill.@y, @laser-drill, 5 * imgSize, 0);
//
//    reset();
//    col(%[white]);
//    drawText(175, 172, @topRight, index);
//
//    drawflush(display1);
//end;

inline void setBaseMapScale()
    var size = 220;
    reset();
    translate(90, 105);
    scale(size / 15 / 2, size / 15 / 2);
end;

void drawBlock(cfg)
    var type, x, y, rotation, size, index;
    unpackCfg2(cfg, out type, out x, out y, out rotation, out size, out index);
//    if index == nextBuildIndex then
//        col(%80ffffff);
//    else
        var built = blocksBuilt & (1 << index);
        if built + pageSwitched == 0 then return; end;

        col(built ? %[white] : %408040ff);
//    end;
    image(2 * x, 2 * y, type, 2 * size, 90 * rotation);
end;

void displayBaseMap()
    // Sets color to white
    drawHeader();

    var limit = 0;
    setBaseMapScale();

    if pageSwitched then
        image(0, 0, @core-shard, 6, 0);
        reset();
        col(%[gold]);
        drawBold(90, HEADER1_Y1 - 11, @center, "Base map");
        setBaseMapScale();
        col(%[white]);
        drawflush(display1);
        limit = 5;
    end;

    var counter = 0;
    for var cfg in BLOCKS do
        if cfg == PULVERIZER1 then
            if not scrap then break; end;
        end;

        if ++counter > limit then
            drawHeader();
            setBaseMapScale();
            counter = 0;
        end;

        drawBlock(cfg);

        var index = recentBuildIndex;
        if index >= 0 then
            recentBuildIndex = -1;
            drawBlock(BLOCKS[index]);
//            index = nextBuildIndex;
//            if index < length(BLOCKS) then
//                drawBlock(BLOCKS[index]);
//            end;
        end;

        if switch1.enabled then
            clear(0, 0, 32);
            drawflush(display1);
            break;
        end;
        drawflush(display1);
    end;
end;

noinit var lastTail;

void displayStorage()
    var tail = bank2[510];
    var START = HEADER1_Y1 - 11 - 16;

    if pageSwitched then
        lastTail = bank2[511];
        col(%[gold]);
        drawBold(11, HEADER1_Y1 - 11, @left, "Resources");
        col(%[white]);
        var y = START - 8;
        for var item in @copper, @lead, @sand, @coal, @graphite, @silicon, @titanium, @metaglass, @thorium do
            image(12, y, item, 15, 0);
            y -= 21;
        end;
    end;

    drawHeader();
    drawflush(display1);

    if lastTail > tail then return; end;

    var accumulator = bank2[lastTail];
    var x = 25 + lastTail;
    var y = START - 8;

    for var i in 0 ... 9 do
        var value = (accumulator & 0b11111) - 8;
        col(value >= 0 ? %[green] : %[red]);
        rect(x, y, 1, value);
        y -= 21;
        accumulator >>= 5;
    end;

    drawflush(display1);
    lastTail++;
end;

var pageSwitched = false;

void backgroundProcess()
    do
        ubind(@poly);
        core = ulocate(:building, :core, false);
    while core == null;

    while true do
        if display.@bufferSize < 200 then
            if page == 0 then
                if megas > 0 then
                    animate();
                else
                    updateDisplay();
                end;
            elsif page == 1 then
                displayStorage();
            elsif page == 2 then
                //displayOreMap();
                displayBaseMap();
            else
                displayLog(page - 3);
            end;
        end;

        if megas > 0 then
            println("[gold]All done.[]\nNothing more to see here.\nGo home.");
            printflush(message1);
        else
            updateMessage();
        end;

        pageSwitched = switch1.enabled;
        if pageSwitched then
            switch1.enabled = false;
            page = (page + 1) % numPages;
            drawflush(null);
            reset();
            clear(0, 0, 32);
        end;
    end;
end;
