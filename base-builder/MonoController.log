   253 instructions before optimizations.
    16 instructions eliminated by Temp Variables Elimination (2 passes, 6 iterations).
    39 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    21 instructions eliminated by Condition Optimization (6 iterations).
    11 instructions eliminated by Single Step Elimination (6 iterations).
    10 instructions eliminated by Boolean Optimization (7 iterations).
       5 fully-evaluated expressions optimized using selects.
     4 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     1 instructions eliminated by Jump Straightening (6 iterations).
     6 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   134 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-21 instructions):
 
    24 jump *label9 equal *tmp4 false
    25 set *tmp6 @unit
    26 set :backgroundProcess:firstUnit *tmp6
-    * set *tmp5 :backgroundProcess:firstUnit
    27 jump *label10 always
    28 label *label9
-    * set *tmp5 null
    29 label *label10
    30 op equal *tmp7 @unit :backgroundProcess:firstUnit
    31 jump *label11 equal *tmp7 false
 
    68 label *label19
    69 set *tmp24 null
    70 label *label20
-    * set *tmp22 *tmp24
    71 jump *label18 always
    72 label *label17
-    * set *tmp22 null
    73 label *label18
    74 print "minOre:"
    75 print .minOre
 
    82 set .sandX *tmp26
    83 sensor *tmp27 .sandContainer @y
    84 set .sandY *tmp27
-    * set *tmp8 .sandY
    85 jump *label12 always
    86 label *label11
-    * set *tmp8 null
    87 label *label12
-    * set *tmp28 :backgroundProcess:runningCount
    88 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
    89 sensor *tmp29 @unit @flag
    90 set :backgroundProcess:flag *tmp29
 
   107 label *label26
   108 set *tmp37 null
   109 label *label27
-    * set *tmp34 *tmp37
   110 jump *label25 always
   111 label *label24
-    * set *tmp34 null
   112 label *label25
   113 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
   114 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
   129 print :findOreToMine:y
   130 print "\n"
   131 label *label23
-    * set *tmp31 null
   132 jump *label22 always
   133 label *label21
   134 op equal *tmp45 :backgroundProcess:flag 1
 
   139 jump *label31 equal *tmp48 false
   140 ucontrol approach .sandX .sandY 7
   141 ucontrol itemDrop .sandContainer 20
-    * set *tmp49 null
   142 jump *label32 always
   143 label *label31
   144 ucontrol approach .coreX .coreY 7
   145 ucontrol itemDrop .core 20
-    * set *tmp49 null
   146 label *label32
   147 sensor *tmp50 @unit @firstItem
   148 op equal *tmp51 *tmp50 null
 
   150 print " (finished)"
   151 print "\n"
   152 ucontrol flag 0
-    * set *tmp52 null
   153 jump *label34 always
   154 label *label33
-    * set *tmp52 null
   155 label *label34
   156 print "\n"
   157 label *label30
 
   201 label *label40
   202 set *tmp65 null
   203 label *label41
-    * set *tmp63 *tmp65
   204 jump *label39 always
   205 label *label38
-    * set *tmp63 null
   206 label *label39
   207 sensor *tmp69 @unit @totalItems
   208 set :mine:items *tmp69
 
   212 jump *label44 equal *tmp71 false
   213 print " (dropping)"
   214 ucontrol itemDrop @air 20
-    * set *tmp72 null
   215 jump *label45 always
   216 label *label44
-    * set *tmp72 null
   217 label *label45
   218 op greaterThanEq *tmp73 :mine:items :mine:oreCapacity
   219 jump *label46 equal *tmp73 false
 
   230 ucontrol itemDrop .core 20
   231 set *tmp76 null
   232 label *label49
-    * set *tmp74 *tmp76
   233 jump *label47 always
   234 label *label46
   235 print " at "
 
   270 label *label55
   271 set *tmp80 *tmp84
   272 label *label51
-    * set *tmp74 *tmp80
   273 label *label47
   274 print "\n"
   275 label *label35
   276 set *tmp46 null
   277 label *label29
-    * set *tmp31 *tmp46
   278 label *label22
   279 label *label7
   280 jump *label6 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-12 instructions):
 
    63 op equal *tmp23 .minOre @sand
    64 jump *label19 equal *tmp23 false
    65 set .minOre @scrap
-    * set *tmp24 .minOre
    66 jump *label20 always
    67 label *label19
-    * set *tmp24 null
    68 label *label20
    69 jump *label18 always
    70 label *label17
 
   100 op notEqual *tmp36 *tmp35 null
   101 jump *label26 equal *tmp36 false
   102 jump *label23 always
-    * set *tmp37 null
   103 jump *label27 always
   104 label *label26
-    * set *tmp37 null
   105 label *label27
   106 jump *label25 always
   107 label *label24
 
   151 label *label34
   152 print "\n"
   153 label *label30
-    * set *tmp46 null
   154 jump *label29 always
   155 label *label28
   156 set :mine:flag :backgroundProcess:flag
 
   191 label *label42
   192 set *tmp68 null
   193 label *label43
-    * set *tmp65 *tmp68
   194 jump *label41 always
   195 label *label40
-    * set *tmp65 null
   196 label *label41
   197 jump *label39 always
   198 label *label38
 
   216 jump *label48 equal *tmp75 false
   217 ucontrol approach .sandX .sandY 7
   218 ucontrol itemDrop .sandContainer 20
-    * set *tmp76 null
   219 jump *label49 always
   220 label *label48
   221 ucontrol approach .coreX .coreY 7
   222 ucontrol itemDrop .core 20
-    * set *tmp76 null
   223 label *label49
   224 jump *label47 always
   225 label *label46
 
   245 print "\n"
   246 set *tmp82 ": no ore!"
   247 label *label53
-    * set *tmp80 *tmp82
   248 jump *label51 always
   249 label *label50
   250 op equal *tmp83 :mine:block null
 
   258 print "\n"
   259 set *tmp84 ": blocked!"
   260 label *label55
-    * set *tmp80 *tmp84
   261 label *label51
   262 label *label47
   263 print "\n"
   264 label *label35
-    * set *tmp46 null
   265 label *label29
   266 label *label22
   267 label *label7

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-6 instructions):
 
   186 print ", switching to a more needed ore"
   187 ucontrol flag 1
   188 jump *label35 always
-    * set *tmp68 null
   189 jump *label43 always
   190 label *label42
-    * set *tmp68 null
   191 label *label43
   192 jump *label41 always
   193 label *label40
 
   235 jump *label52 equal *tmp81 false
   236 print ": too far"
   237 print "\n"
-    * set *tmp82 ": too far"
   238 jump *label53 always
   239 label *label52
   240 ucontrol flag 1
   241 print ": no ore!"
   242 print "\n"
-    * set *tmp82 ": no ore!"
   243 label *label53
   244 jump *label51 always
   245 label *label50
   246 op equal *tmp83 :mine:block null
   247 jump *label54 equal *tmp83 false
   248 ucontrol mine :mine:x :mine:y
-    * set *tmp84 null
   249 jump *label55 always
   250 label *label54
   251 ucontrol flag 1
   252 print ": blocked!"
   253 print "\n"
-    * set *tmp84 ": blocked!"
   254 label *label55
   255 label *label51
   256 label *label47

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-16 instructions):
 
     8 label *label1
     9 label *label3
    10 ubind @mono
-    * set *tmp0 @unit
-    * set :backgroundProcess:firstUnit *tmp0
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   11 set :backgroundProcess:firstUnit @unit
+   12 ulocate building core false @copper .coreX .coreY *tmp2 .core
    13 label *label4
    14 op equal *tmp3 .core null
    15 jump *label3 notEqual *tmp3 false
 
    20 ubind @mono
    21 sensor *tmp4 :backgroundProcess:firstUnit @dead
    22 jump *label9 equal *tmp4 false
-    * set *tmp6 @unit
-    * set :backgroundProcess:firstUnit *tmp6
+   23 set :backgroundProcess:firstUnit @unit
    24 jump *label10 always
    25 label *label9
    26 label *label10
 
    28 jump *label11 equal *tmp7 false
    29 printflush message1
    30 sensor *tmp9 .core @lead
-    * op sub *tmp10 *tmp9 .leadTarget
-    * set :backgroundProcess:lead *tmp10
+   31 op sub :backgroundProcess:lead *tmp9 .leadTarget
    32 sensor *tmp11 .sandContainer @sand
    33 sensor *tmp12 .sandContainer @scrap
    34 op add *tmp13 *tmp11 *tmp12
-    * op sub *tmp14 *tmp13 .sandTarget
-    * set :backgroundProcess:sand *tmp14
+   35 op sub :backgroundProcess:sand *tmp13 .sandTarget
    36 sensor *tmp15 .core @copper
-    * op sub *tmp16 *tmp15 .copperTarget
-    * set :backgroundProcess:copper *tmp16
+   37 op sub :backgroundProcess:copper *tmp15 .copperTarget
    38 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    39 op min *tmp17 *tmp17 :backgroundProcess:copper
    40 set .min *tmp17
 
    70 op add .min .min *tmp25
    71 set .count :backgroundProcess:runningCount
    72 set :backgroundProcess:runningCount 2
-    * sensor *tmp26 .sandContainer @x
-    * set .sandX *tmp26
-    * sensor *tmp27 .sandContainer @y
-    * set .sandY *tmp27
+   73 sensor .sandX .sandContainer @x
+   74 sensor .sandY .sandContainer @y
    75 jump *label12 always
    76 label *label11
    77 label *label12
    78 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
-    * sensor *tmp29 @unit @flag
-    * set :backgroundProcess:flag *tmp29
+   79 sensor :backgroundProcess:flag @unit @flag
    80 print "Unit flag: "
    81 print :backgroundProcess:flag
    82 print "\n"
 
   147 set :mine:flag :backgroundProcess:flag
   148 print "Mining "
   149 op mod *tmp53 :mine:flag 16
-    * lookup item *tmp54 *tmp53
-    * set :mine:ore *tmp54
+  150 lookup item :mine:ore *tmp53
   151 printchar :mine:ore
   152 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp55 :mine:flag 1000
-    * set :mine:y *tmp55
-    * op idiv *tmp56 :mine:flag 1000
-    * set :mine:x *tmp56
+  153 op mod :mine:y :mine:flag 1000
+  154 op idiv :mine:x :mine:flag 1000
   155 sensor *tmp57 :mine:ore @name
-    * read *tmp58 @this *tmp57
-    * set :mine:floorOre *tmp58
+  156 read :mine:floorOre @this *tmp57
   157 op equal *tmp59 :mine:ore @scrap
   158 jump *label36 equal *tmp59 false
-    * op sub *tmp61 20 .count
-    * set *tmp60 *tmp61
+  159 op sub *tmp60 20 .count
   160 jump *label37 always
   161 label *label36
   162 set *tmp60 20
 
   181 jump *label39 always
   182 label *label38
   183 label *label39
-    * sensor *tmp69 @unit @totalItems
-    * set :mine:items *tmp69
+  184 sensor :mine:items @unit @totalItems
   185 print :mine:items
   186 sensor *tmp70 @unit @firstItem
   187 op notEqual *tmp71 *tmp70 :mine:ore
 
   212 print " "
   213 print :mine:y
   214 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp78 *tmp77 :mine:floor
-    * set :mine:block *tmp77
+  215 ucontrol getBlock :mine:x :mine:y *tmp78 :mine:block :mine:floor
   216 op notEqual *tmp79 :mine:floor :mine:floorOre
   217 jump *label50 equal *tmp79 false
   218 op equal *tmp81 :mine:floor null

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    16 label *label5
    17 set :backgroundProcess:runningCount 0
    18 label *label6
-    * jump *label8 equal true false
    19 ubind @mono
    20 sensor *tmp4 :backgroundProcess:firstUnit @dead
    21 jump *label9 equal *tmp4 false

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-21 instructions):
 
    11 set :backgroundProcess:firstUnit @unit
    12 ulocate building core false @copper .coreX .coreY *tmp2 .core
    13 label *label4
-    * op equal *tmp3 .core null
-    * jump *label3 notEqual *tmp3 false
+   14 jump *label3 equal .core null
    15 label *label5
    16 set :backgroundProcess:runningCount 0
    17 label *label6
 
    22 jump *label10 always
    23 label *label9
    24 label *label10
-    * op equal *tmp7 @unit :backgroundProcess:firstUnit
-    * jump *label11 equal *tmp7 false
+   25 jump *label11 notEqual @unit :backgroundProcess:firstUnit
    26 printflush message1
    27 sensor *tmp9 .core @lead
    28 op sub :backgroundProcess:lead *tmp9 .leadTarget
 
    35 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    36 op min *tmp17 *tmp17 :backgroundProcess:copper
    37 set .min *tmp17
-    * op equal *tmp18 .min :backgroundProcess:sand
-    * jump *label13 equal *tmp18 false
+   38 jump *label13 notEqual .min :backgroundProcess:sand
    39 set *tmp19 @sand
    40 jump *label14 always
    41 label *label13
-    * op equal *tmp20 .min :backgroundProcess:lead
-    * jump *label15 equal *tmp20 false
+   42 jump *label15 notEqual .min :backgroundProcess:lead
    43 set *tmp21 @lead
    44 jump *label16 always
    45 label *label15
 
    49 label *label14
    50 set .minOre *tmp19
    51 jump *label17 equal .scrap false
-    * op equal *tmp23 .minOre @sand
-    * jump *label19 equal *tmp23 false
+   52 jump *label19 notEqual .minOre @sand
    53 set .minOre @scrap
    54 jump *label20 always
    55 label *label19
 
    74 print "Unit flag: "
    75 print :backgroundProcess:flag
    76 print "\n"
-    * op equal *tmp30 :backgroundProcess:flag 0
-    * jump *label21 equal *tmp30 false
+   77 jump *label21 notEqual :backgroundProcess:flag 0
    78 set :findOreToMine:ore .minOre
    79 sensor *tmp32 @unit @firstItem
-    * op notEqual *tmp33 *tmp32 null
-    * jump *label24 equal *tmp33 false
+   80 jump *label24 equal *tmp32 null
    81 ucontrol itemDrop @air 20
    82 sensor *tmp35 @unit @firstItem
-    * op notEqual *tmp36 *tmp35 null
-    * jump *label26 equal *tmp36 false
+   83 jump *label26 equal *tmp35 null
    84 jump *label23 always
    85 jump *label27 always
    86 label *label26
 
   109 label *label23
   110 jump *label22 always
   111 label *label21
-    * op equal *tmp45 :backgroundProcess:flag 1
-    * jump *label28 equal *tmp45 false
+  112 jump *label28 notEqual :backgroundProcess:flag 1
   113 print "Returning ore"
   114 sensor *tmp47 @unit @firstItem
-    * op equal *tmp48 *tmp47 @scrap
-    * jump *label31 equal *tmp48 false
+  115 jump *label31 notEqual *tmp47 @scrap
   116 ucontrol approach .sandX .sandY 7
   117 ucontrol itemDrop .sandContainer 20
   118 jump *label32 always
 
   121 ucontrol itemDrop .core 20
   122 label *label32
   123 sensor *tmp50 @unit @firstItem
-    * op equal *tmp51 *tmp50 null
-    * jump *label33 equal *tmp51 false
+  124 jump *label33 notEqual *tmp50 null
   125 print " (finished)"
   126 print "\n"
   127 ucontrol flag 0
 
   142 op idiv :mine:x :mine:flag 1000
   143 sensor *tmp57 :mine:ore @name
   144 read :mine:floorOre @this *tmp57
-    * op equal *tmp59 :mine:ore @scrap
-    * jump *label36 equal *tmp59 false
+  145 jump *label36 notEqual :mine:ore @scrap
   146 op sub *tmp60 20 .count
   147 jump *label37 always
   148 label *label36
   149 set *tmp60 20
   150 label *label37
   151 set :mine:oreCapacity *tmp60
-    * op notEqual *tmp62 :mine:ore .minOre
-    * jump *label38 equal *tmp62 false
-    * op notEqual *tmp64 :mine:ore @scrap
-    * jump *label40 equal *tmp64 false
+  152 jump *label38 equal :mine:ore .minOre
+  153 jump *label40 equal :mine:ore @scrap
   154 sensor *tmp66 .core :mine:ore
-    * op greaterThan *tmp67 *tmp66 .min
-    * jump *label42 equal *tmp67 false
+  155 jump *label42 lessThanEq *tmp66 .min
   156 print ", switching to a more needed ore"
   157 ucontrol flag 1
   158 jump *label35 always
 
   168 sensor :mine:items @unit @totalItems
   169 print :mine:items
   170 sensor *tmp70 @unit @firstItem
-    * op notEqual *tmp71 *tmp70 :mine:ore
-    * jump *label44 equal *tmp71 false
+  171 jump *label44 equal *tmp70 :mine:ore
   172 print " (dropping)"
   173 ucontrol itemDrop @air 20
   174 jump *label45 always
   175 label *label44
   176 label *label45
-    * op greaterThanEq *tmp73 :mine:items :mine:oreCapacity
-    * jump *label46 equal *tmp73 false
+  177 jump *label46 lessThan :mine:items :mine:oreCapacity
   178 print ", full"
   179 ucontrol flag 1
-    * op equal *tmp75 :mine:ore @scrap
-    * jump *label48 equal *tmp75 false
+  180 jump *label48 notEqual :mine:ore @scrap
   181 ucontrol approach .sandX .sandY 7
   182 ucontrol itemDrop .sandContainer 20
   183 jump *label49 always
 
   194 print :mine:y
   195 ucontrol approach :mine:x :mine:y 7
   196 ucontrol getBlock :mine:x :mine:y *tmp78 :mine:block :mine:floor
-    * op notEqual *tmp79 :mine:floor :mine:floorOre
-    * jump *label50 equal *tmp79 false
-    * op equal *tmp81 :mine:floor null
-    * jump *label52 equal *tmp81 false
+  197 jump *label50 equal :mine:floor :mine:floorOre
+  198 jump *label52 notEqual :mine:floor null
   199 print ": too far"
   200 print "\n"
   201 jump *label53 always
 
   206 label *label53
   207 jump *label51 always
   208 label *label50
-    * op equal *tmp83 :mine:block null
-    * jump *label54 equal *tmp83 false
+  209 jump *label54 notEqual :mine:block null
   210 ucontrol mine :mine:x :mine:y
   211 jump *label55 always
   212 label *label54

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-11 instructions):
 
    19 sensor *tmp4 :backgroundProcess:firstUnit @dead
    20 jump *label9 equal *tmp4 false
    21 set :backgroundProcess:firstUnit @unit
-    * jump *label10 always
    22 label *label9
    23 label *label10
    24 jump *label11 notEqual @unit :backgroundProcess:firstUnit
 
    50 jump *label17 equal .scrap false
    51 jump *label19 notEqual .minOre @sand
    52 set .minOre @scrap
-    * jump *label20 always
    53 label *label19
    54 label *label20
-    * jump *label18 always
    55 label *label17
    56 label *label18
    57 print "minOre:"
 
    63 set :backgroundProcess:runningCount 2
    64 sensor .sandX .sandContainer @x
    65 sensor .sandY .sandContainer @y
-    * jump *label12 always
    66 label *label11
    67 label *label12
    68 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
 
    78 sensor *tmp35 @unit @firstItem
    79 jump *label26 equal *tmp35 null
    80 jump *label23 always
-    * jump *label27 always
    81 label *label26
    82 label *label27
-    * jump *label25 always
    83 label *label24
    84 label *label25
    85 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
 
   119 print " (finished)"
   120 print "\n"
   121 ucontrol flag 0
-    * jump *label34 always
   122 label *label33
   123 label *label34
   124 print "\n"
 
   149 print ", switching to a more needed ore"
   150 ucontrol flag 1
   151 jump *label35 always
-    * jump *label43 always
   152 label *label42
   153 label *label43
-    * jump *label41 always
   154 label *label40
   155 label *label41
-    * jump *label39 always
   156 label *label38
   157 label *label39
   158 sensor :mine:items @unit @totalItems
 
   161 jump *label44 equal *tmp70 :mine:ore
   162 print " (dropping)"
   163 ucontrol itemDrop @air 20
-    * jump *label45 always
   164 label *label44
   165 label *label45
   166 jump *label46 lessThan :mine:items :mine:oreCapacity

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    34 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    35 op min *tmp17 *tmp17 :backgroundProcess:copper
    36 set .min *tmp17
-    * jump *label13 notEqual .min :backgroundProcess:sand
+   37 jump *label13 notEqual *tmp17 :backgroundProcess:sand
    38 set *tmp19 @sand
    39 jump *label14 always
    40 label *label13
-    * jump *label15 notEqual .min :backgroundProcess:lead
+   41 jump *label15 notEqual *tmp17 :backgroundProcess:lead
    42 set *tmp21 @lead
    43 jump *label16 always
    44 label *label15
 
    48 label *label14
    49 set .minOre *tmp19
    50 jump *label17 equal .scrap false
-    * jump *label19 notEqual .minOre @sand
+   51 jump *label19 notEqual *tmp19 @sand
    52 set .minOre @scrap
    53 label *label19
    54 label *label20
 
    58 print .minOre
    59 print "\n"
    60 op mul *tmp25 10 :backgroundProcess:runningCount
-    * op add .min .min *tmp25
+   61 op add .min *tmp17 *tmp25
    62 set .count :backgroundProcess:runningCount
    63 set :backgroundProcess:runningCount 2
    64 sensor .sandX .sandContainer @x
 
    82 label *label27
    83 label *label24
    84 label *label25
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
+   85 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
    86 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    87 ucontrol mine :findOreToMine:x :findOreToMine:y
    88 op mul *tmp40 :findOreToMine:x 1000
    89 op add *tmp41 *tmp40 :findOreToMine:y
    90 op mul *tmp42 *tmp41 16
-    * sensor *tmp43 :findOreToMine:ore @id
+   91 sensor *tmp43 .minOre @id
    92 op add *tmp44 *tmp42 *tmp43
    93 ucontrol flag *tmp44
    94 print "Found "
-    * print :findOreToMine:ore
+   95 print .minOre
    96 print " "
    97 print "at "
    98 print :findOreToMine:x
 
   127 label *label28
   128 set :mine:flag :backgroundProcess:flag
   129 print "Mining "
-    * op mod *tmp53 :mine:flag 16
+  130 op mod *tmp53 :backgroundProcess:flag 16
   131 lookup item :mine:ore *tmp53
   132 printchar :mine:ore
-    * op idiv :mine:flag :mine:flag 16
+  133 op idiv :mine:flag :backgroundProcess:flag 16
   134 op mod :mine:y :mine:flag 1000
   135 op idiv :mine:x :mine:flag 1000
   136 sensor *tmp57 :mine:ore @name
 
   163 ucontrol itemDrop @air 20
   164 label *label44
   165 label *label45
-    * jump *label46 lessThan :mine:items :mine:oreCapacity
+  166 jump *label46 lessThan :mine:items *tmp60
   167 print ", full"
   168 ucontrol flag 1
   169 jump *label48 notEqual :mine:ore @scrap

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    33 op sub :backgroundProcess:copper *tmp15 .copperTarget
    34 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    35 op min *tmp17 *tmp17 :backgroundProcess:copper
-    * set .min *tmp17
    36 jump *label13 notEqual *tmp17 :backgroundProcess:sand
    37 set *tmp19 @sand
    38 jump *label14 always
 
    70 print :backgroundProcess:flag
    71 print "\n"
    72 jump *label21 notEqual :backgroundProcess:flag 0
-    * set :findOreToMine:ore .minOre
    73 sensor *tmp32 @unit @firstItem
    74 jump *label24 equal *tmp32 null
    75 ucontrol itemDrop @air 20
 
   123 label *label30
   124 jump *label29 always
   125 label *label28
-    * set :mine:flag :backgroundProcess:flag
   126 print "Mining "
   127 op mod *tmp53 :backgroundProcess:flag 16
   128 lookup item :mine:ore *tmp53
 
   138 label *label36
   139 set *tmp60 20
   140 label *label37
-    * set :mine:oreCapacity *tmp60
   141 jump *label38 equal :mine:ore .minOre
   142 jump *label40 equal :mine:ore @scrap
   143 sensor *tmp66 .core :mine:ore

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-7 instructions):
 
    16 set :backgroundProcess:runningCount 0
    17 label *label6
    18 ubind @mono
-    * sensor *tmp4 :backgroundProcess:firstUnit @dead
-    * jump *label9 equal *tmp4 false
-    * set :backgroundProcess:firstUnit @unit
-    * label *label9
-    * label *label10
+   19 sensor *tmp4 :backgroundProcess:firstUnit @dead
+   20 select :backgroundProcess:firstUnit notEqual *tmp4 false @unit :backgroundProcess:firstUnit
    21 jump *label11 notEqual @unit :backgroundProcess:firstUnit
    22 printflush message1
    23 sensor *tmp9 .core @lead
 
    34 set *tmp19 @sand
    35 jump *label14 always
    36 label *label13
-    * jump *label15 notEqual *tmp17 :backgroundProcess:lead
-    * set *tmp21 @lead
-    * jump *label16 always
-    * label *label15
-    * set *tmp21 @copper
-    * label *label16
+   37 select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @copper
    38 set *tmp19 *tmp21
    39 label *label14
    40 set .minOre *tmp19
    41 jump *label17 equal .scrap false
-    * jump *label19 notEqual *tmp19 @sand
-    * set .minOre @scrap
-    * label *label19
-    * label *label20
+   42 select .minOre equal *tmp19 @sand @scrap .minOre
    43 label *label17
    44 label *label18
    45 print "minOre:"
 
   121 op idiv :mine:x :mine:flag 1000
   122 sensor *tmp57 :mine:ore @name
   123 read :mine:floorOre @this *tmp57
-    * jump *label36 notEqual :mine:ore @scrap
-    * op sub *tmp60 20 .count
-    * jump *label37 always
-    * label *label36
-    * set *tmp60 20
-    * label *label37
+  124 op sub *tmp85 20 .count
+  125 select *tmp60 equal :mine:ore @scrap *tmp85 20
   126 jump *label38 equal :mine:ore .minOre
   127 jump *label40 equal :mine:ore @scrap
   128 sensor *tmp66 .core :mine:ore

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 2 (-3 instructions):
 
    30 op sub :backgroundProcess:copper *tmp15 .copperTarget
    31 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    32 op min *tmp17 *tmp17 :backgroundProcess:copper
-    * jump *label13 notEqual *tmp17 :backgroundProcess:sand
-    * set *tmp19 @sand
-    * jump *label14 always
-    * label *label13
-    * select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @copper
-    * set *tmp19 *tmp21
-    * label *label14
+   33 select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @copper
+   34 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp21
    35 set .minOre *tmp19
    36 jump *label17 equal .scrap false
    37 select .minOre equal *tmp19 @sand @scrap .minOre

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    34 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp21
    35 set .minOre *tmp19
    36 jump *label17 equal .scrap false
-    * select .minOre equal *tmp19 @sand @scrap .minOre
+   37 select .minOre equal *tmp19 @sand @scrap *tmp19
    38 label *label17
    39 label *label18
    40 print "minOre:"

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    10 ubind @mono
    11 set :backgroundProcess:firstUnit @unit
    12 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label4
    13 jump *label3 equal .core null
-    * label *label5
    14 set :backgroundProcess:runningCount 0
    15 label *label6
    16 ubind @mono
 
    34 jump *label17 equal .scrap false
    35 select .minOre equal *tmp19 @sand @scrap *tmp19
    36 label *label17
-    * label *label18
    37 print "minOre:"
    38 print .minOre
    39 print "\n"
 
    44 sensor .sandX .sandContainer @x
    45 sensor .sandY .sandContainer @y
    46 label *label11
-    * label *label12
    47 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
    48 sensor :backgroundProcess:flag @unit @flag
    49 print "Unit flag: "
 
    57 jump *label26 equal *tmp35 null
    58 jump *label23 always
    59 label *label26
-    * label *label27
    60 label *label24
-    * label *label25
    61 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
    62 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    63 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    96 print "\n"
    97 ucontrol flag 0
    98 label *label33
-    * label *label34
    99 print "\n"
-    * label *label30
   100 jump *label29 always
   101 label *label28
   102 print "Mining "
 
   118 ucontrol flag 1
   119 jump *label35 always
   120 label *label42
-    * label *label43
   121 label *label40
-    * label *label41
   122 label *label38
-    * label *label39
   123 sensor :mine:items @unit @totalItems
   124 print :mine:items
   125 sensor *tmp70 @unit @firstItem
 
   127 print " (dropping)"
   128 ucontrol itemDrop @air 20
   129 label *label44
-    * label *label45
   130 jump *label46 lessThan :mine:items *tmp60
   131 print ", full"
   132 ucontrol flag 1
 
   173 label *label35
   174 label *label29
   175 label *label22
-    * label *label7
   176 jump *label6 always
-    * label *label8
-    * label *label2
-    * wait 1e12
-    * jump *label1 always
-    * end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    53 jump *label24 equal *tmp32 null
    54 ucontrol itemDrop @air 20
    55 sensor *tmp35 @unit @firstItem
-    * jump *label26 equal *tmp35 null
-    * jump *label23 always
+   56 jump *label23 notEqual *tmp35 null
    57 label *label26
    58 label *label24
    59 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    53 jump *label24 equal *tmp32 null
    54 ucontrol itemDrop @air 20
    55 sensor *tmp35 @unit @firstItem
-    * jump *label23 notEqual *tmp35 null
+   56 jump *label6 notEqual *tmp35 null
    57 label *label24
    58 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
    59 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    74 print :findOreToMine:y
    75 print "\n"
    76 label *label23
-    * jump *label22 always
+   77 jump *label6 always
    78 label *label21
    79 jump *label28 notEqual :backgroundProcess:flag 1
    80 print "Returning ore"
 
    94 ucontrol flag 0
    95 label *label33
    96 print "\n"
-    * jump *label29 always
+   97 jump *label6 always
    98 label *label28
    99 print "Mining "
   100 op mod *tmp53 :backgroundProcess:flag 16
 
   113 jump *label42 lessThanEq *tmp66 .min
   114 print ", switching to a more needed ore"
   115 ucontrol flag 1
-    * jump *label35 always
+  116 jump *label6 always
   117 label *label42
   118 label *label40
   119 label *label38
 
   130 jump *label48 notEqual :mine:ore @scrap
   131 ucontrol approach .sandX .sandY 7
   132 ucontrol itemDrop .sandContainer 20
-    * jump *label49 always
+  133 jump *label47 always
   134 label *label48
   135 ucontrol approach .coreX .coreY 7
   136 ucontrol itemDrop .core 20
 
   148 jump *label52 notEqual :mine:floor null
   149 print ": too far"
   150 print "\n"
-    * jump *label53 always
+  151 jump *label51 always
   152 label *label52
   153 ucontrol flag 1
   154 print ": no ore!"

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
     8 label *label3
     9 ubind @mono
    10 set :backgroundProcess:firstUnit @unit
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+   11 ulocate building core false @copper .coreX .coreY 0 .core
    12 jump *label3 equal .core null
    13 set :backgroundProcess:runningCount 0
    14 label *label6
 
    55 sensor *tmp35 @unit @firstItem
    56 jump *label6 notEqual *tmp35 null
    57 label *label24
-    * ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
+   58 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    59 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    60 ucontrol mine :findOreToMine:x :findOreToMine:y
    61 op mul *tmp40 :findOreToMine:x 1000
 
   141 print " "
   142 print :mine:y
   143 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp78 :mine:block :mine:floor
+  144 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   145 jump *label50 equal :mine:floor :mine:floorOre
   146 jump *label52 notEqual :mine:floor null
   147 print ": too far"

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    33 jump *label17 equal .scrap false
    34 select .minOre equal *tmp19 @sand @scrap *tmp19
    35 label *label17
-    * print "minOre:"
-    * print .minOre
-    * print "\n"
+   36 print "minOre:{0}\n"
+   37 format .minOre
    38 op mul *tmp25 10 :backgroundProcess:runningCount
    39 op add .min *tmp17 *tmp25
    40 set .count :backgroundProcess:runningCount
 
    44 label *label11
    45 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
    46 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   47 print "Unit flag: {0}\n"
+   48 format :backgroundProcess:flag
    49 jump *label21 notEqual :backgroundProcess:flag 0
    50 sensor *tmp32 @unit @firstItem
    51 jump *label24 equal *tmp32 null
 
    62 sensor *tmp43 .minOre @id
    63 op add *tmp44 *tmp42 *tmp43
    64 ucontrol flag *tmp44
-    * print "Found "
-    * print .minOre
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   65 print "Found {0} at {0}, {0}\n"
+   66 format .minOre
+   67 format :findOreToMine:x
+   68 format :findOreToMine:y
    69 jump *label6 always
    70 label *label21
    71 jump *label28 notEqual :backgroundProcess:flag 1
 
    81 label *label32
    82 sensor *tmp50 @unit @firstItem
    83 jump *label33 notEqual *tmp50 null
-    * print " (finished)"
-    * print "\n"
+   84 print " (finished)\n"
    85 ucontrol flag 0
    86 label *label33
    87 print "\n"
 
   127 ucontrol itemDrop .core 20
   128 jump *label47 always
   129 label *label46
-    * print " at "
-    * print :mine:x
-    * print ","
-    * print " "
+  130 print " at {0}, "
+  131 format :mine:x
   132 print :mine:y
   133 ucontrol approach :mine:x :mine:y 7
   134 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   135 jump *label50 equal :mine:floor :mine:floorOre
   136 jump *label52 notEqual :mine:floor null
-    * print ": too far"
-    * print "\n"
+  137 print ": too far\n"
   138 jump *label51 always
   139 label *label52
   140 ucontrol flag 1
-    * print ": no ore!"
-    * print "\n"
+  141 print ": no ore!\n"
   142 jump *label51 always
   143 label *label50
   144 jump *label54 notEqual :mine:block null
 
   146 jump *label55 always
   147 label *label54
   148 ucontrol flag 1
-    * print ": blocked!"
-    * print "\n"
+  149 print ": blocked!\n"
   150 label *label55
   151 label *label51
   152 label *label47

Final code before resolving virtual instructions:

    0:  set *id "name: Base Builder - Mono Controller\nversion: v0.4 #set target = 8;
    1:  set .min 0                                                   var min = 0, minOre = null;
    2:  set .minOre null                                             ...
    3:  set copper @ore-copper                                       volatile mlog(@copper.@name)  var oreCopper = @ore-copper;
    4:  set scrap @ore-scrap                                         volatile mlog(@scrap.@name)   var oreScrap = @ore-scrap;
    5:  set lead @ore-lead                                           volatile mlog(@lead.@name)    var oreLead = @ore-lead;
    6:  set sand @sand-floor                                         volatile mlog(@sand.@name)    var oreSand = @sand-floor;
    7:  set *signature "0:v1"                                        #set target = 8;
        label *label3                                                do
    8:  ubind @mono                                                  firstUnit = ubind(@mono);
    9:  set :backgroundProcess:firstUnit @unit                       ...
   10:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   11:  jump *label3 equal .core null                                do
   12:  set :backgroundProcess:runningCount 0                        var runningCount = 0;
        label *label6                                                while true do
   13:  ubind @mono                                                  ubind(@mono);
   14:  sensor *tmp4 :backgroundProcess:firstUnit @dead              if firstUnit.@dead then firstUnit = @unit; end;
   15:  select :backgroundProcess:firstUnit notEqual *tmp4 false @un ...
   16:  jump *label11 notEqual @unit :backgroundProcess:firstUnit    if @unit == firstUnit then
   17:  printflush message1                                          printflush(message1);
   18:  sensor *tmp9 .core @lead                                     var lead = core.@lead - leadTarget;
   19:  op sub :backgroundProcess:lead *tmp9 .leadTarget             ...
   20:  sensor *tmp11 .sandContainer @sand                           var sand = sandContainer.@sand + sandContainer.@scrap - sandTarget;
   21:  sensor *tmp12 .sandContainer @scrap                          ...
   22:  op add *tmp13 *tmp11 *tmp12                                  ...
   23:  op sub :backgroundProcess:sand *tmp13 .sandTarget            ...
   24:  sensor *tmp15 .core @copper                                  var copper = core.@copper - copperTarget;
   25:  op sub :backgroundProcess:copper *tmp15 .copperTarget        ...
   26:  op min *tmp17 :backgroundProcess:lead :backgroundProcess:san min = min(lead, sand, copper);
   27:  op min *tmp17 *tmp17 :backgroundProcess:copper               ...
   28:  select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @co minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   29:  select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tm ...
   30:  set .minOre *tmp19                                           ...
   31:  jump *label17 equal .scrap false                             if scrap then
   32:  select .minOre equal *tmp19 @sand @scrap *tmp19              if minOre == @sand then minOre = @scrap; end;
        label *label17                                               if scrap then
   33:  print "minOre:{0}\n"                                         println("minOre:", minOre);
   34:  format .minOre                                               ...
   35:  op mul *tmp25 10 :backgroundProcess:runningCount             min += 10 * runningCount;
   36:  op add .min *tmp17 *tmp25                                    ...
   37:  set .count :backgroundProcess:runningCount                   count = runningCount;
   38:  set :backgroundProcess:runningCount 2                        runningCount = 2;
   39:  sensor .sandX .sandContainer @x                              sandX = sandContainer.@x;
   40:  sensor .sandY .sandContainer @y                              sandY = sandContainer.@y;
        label *label11                                               if @unit == firstUnit then
   41:  op add :backgroundProcess:runningCount :backgroundProcess:ru while true do
   42:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   43:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   44:  format :backgroundProcess:flag                               ...
   45:  jump *label21 notEqual :backgroundProcess:flag 0             if flag == 0 then
   46:  sensor *tmp32 @unit @firstItem                               if @unit.@firstItem != null then
   47:  jump *label24 equal *tmp32 null                              ...
   48:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   49:  sensor *tmp35 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   50:  jump *label6 notEqual *tmp35 null                            ...
        label *label24                                               if @unit.@firstItem != null then
   51:  ulocate ore core true .minOre :findOreToMine:x :findOreToMin ulocate(:ore, ore, out x, out y);
   52:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   53:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   54:  op mul *tmp40 :findOreToMine:x 1000                          flag((x * 1000 + y) * 16 + ore.@id);
   55:  op add *tmp41 *tmp40 :findOreToMine:y                        ...
   56:  op mul *tmp42 *tmp41 16                                      ...
   57:  sensor *tmp43 .minOre @id                                    ...
   58:  op add *tmp44 *tmp42 *tmp43                                  ...
   59:  ucontrol flag *tmp44 0 0 0 0                                 ...
   60:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   61:  format .minOre                                               ...
   62:  format :findOreToMine:x                                      ...
   63:  format :findOreToMine:y                                      ...
   64:  jump *label6 always 0 0                                      if flag == 0 then
        label *label21                                               ...
   65:  jump *label28 notEqual :backgroundProcess:flag 1             elsif flag == 1 then
   66:  print "Returning ore"                                        print("Returning ore");
   67:  sensor *tmp47 @unit @firstItem                               if @unit.@firstItem == @scrap then
   68:  jump *label31 notEqual *tmp47 @scrap                         ...
   69:  ucontrol approach .sandX .sandY 7 0 0                        approach(sandX, sandY, RADIUS);
   70:  ucontrol itemDrop .sandContainer 20 0 0 0                    itemDrop(sandContainer, capacity);
   71:  jump *label32 always 0 0                                     if @unit.@firstItem == @scrap then
        label *label31                                               ...
   72:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   73:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
        label *label32                                               if @unit.@firstItem == @scrap then
   74:  sensor *tmp50 @unit @firstItem                               if @unit.@firstItem == null then
   75:  jump *label33 notEqual *tmp50 null                           ...
   76:  print " (finished)\n"                                        println(" (finished)");
   77:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label33                                               if @unit.@firstItem == null then
   78:  print "\n"                                                   println();
   79:  jump *label6 always 0 0                                      elsif flag == 1 then
        label *label28                                               ...
   80:  print "Mining "                                              print("Mining ");
   81:  op mod *tmp53 :backgroundProcess:flag 16                     var ore = lookup(:item, flag % 16);
   82:  lookup item :mine:ore *tmp53                                 ...
   83:  printchar :mine:ore                                          printchar(ore);
   84:  op idiv :mine:flag :backgroundProcess:flag 16                flag \= 16;
   85:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   86:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   87:  sensor *tmp57 :mine:ore @name                                var floorOre = @this.read(ore.@name);
   88:  read :mine:floorOre @this *tmp57                             ...
   89:  op sub *tmp85 20 .count                                      var oreCapacity = ore == @scrap ? capacity - count : capacity;
   90:  select *tmp60 equal :mine:ore @scrap *tmp85 20               ...
   91:  jump *label38 equal :mine:ore .minOre                        if ore != minOre then
   92:  jump *label40 equal :mine:ore @scrap                         if ore != @scrap then
   93:  sensor *tmp66 .core :mine:ore                                if core.sensor(ore) > min then
   94:  jump *label42 lessThanEq *tmp66 .min                         ...
   95:  print ", switching to a more needed ore"                     print(", switching to a more needed ore");
   96:  ucontrol flag 1 0 0 0 0                                      flag(1);
   97:  jump *label6 always 0 0                                      return;
        label *label42                                               if core.sensor(ore) > min then
        label *label40                                               if ore != @scrap then
        label *label38                                               if ore != minOre then
   98:  sensor :mine:items @unit @totalItems                         var items = @unit.@totalItems;
   99:  print :mine:items                                            print(items);
  100:  sensor *tmp70 @unit @firstItem                               if @unit.@firstItem != ore then
  101:  jump *label44 equal *tmp70 :mine:ore                         ...
  102:  print " (dropping)"                                          print(" (dropping)");
  103:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label44                                               if @unit.@firstItem != ore then
  104:  jump *label46 lessThan :mine:items *tmp60                    if items >= oreCapacity then
  105:  print ", full"                                               print(", full");
  106:  ucontrol flag 1 0 0 0 0                                      flag(1);
  107:  jump *label48 notEqual :mine:ore @scrap                      if ore == @scrap then
  108:  ucontrol approach .sandX .sandY 7 0 0                        approach(sandX, sandY, RADIUS);
  109:  ucontrol itemDrop .sandContainer 20 0 0 0                    itemDrop(sandContainer, capacity);
  110:  jump *label47 always 0 0                                     if ore == @scrap then
        label *label48                                               ...
  111:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
  112:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
  113:  jump *label47 always 0 0                                     if items >= oreCapacity then
        label *label46                                               ...
  114:  print " at {0}, "                                            print($" at $x, $y");
  115:  format :mine:x                                               ...
  116:  print :mine:y                                                ...
  117:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
  118:  ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor  var block = getBlock(x, y, , out floor);
  119:  jump *label50 equal :mine:floor :mine:floorOre               if floor != floorOre then
  120:  jump *label52 notEqual :mine:floor null                      if floor == null then
  121:  print ": too far\n"                                          println(": too far");
  122:  jump *label51 always 0 0                                     if floor == null then
        label *label52                                               ...
  123:  ucontrol flag 1 0 0 0 0                                      flag(1);
  124:  print ": no ore!\n"                                          println(": no ore!");
  125:  jump *label51 always 0 0                                     if floor != floorOre then
        label *label50                                               ...
  126:  jump *label54 notEqual :mine:block null                      elsif block == null then
  127:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
  128:  jump *label55 always 0 0                                     elsif block == null then
        label *label54                                               ...
  129:  ucontrol flag 1 0 0 0 0                                      flag(1);
  130:  print ": blocked!\n"                                         println(": blocked!");
        label *label55                                               elsif block == null then
        label *label51                                               if floor != floorOre then
        label *label47                                               if items >= oreCapacity then
  131:  print "\n"                                                   println();
  132:  jump *label6 always 0 0                                      while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    52     1x     52,0  void mine(in flag)
    43     1x     43,0  void backgroundProcess()
    18     1x     18,0  void findOreToMine(in ore)
    13     1x     13,0  void returnItems()
     8     1x      8,0  <no function>
