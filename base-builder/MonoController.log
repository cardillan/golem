   252 instructions before optimizations.
    16 instructions eliminated by Temp Variables Elimination (2 passes, 6 iterations).
    39 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    21 instructions eliminated by Jump Optimization (5 iterations).
    11 instructions eliminated by Single Step Elimination (6 iterations).
    10 instructions eliminated by If Expression Optimization (5 iterations).
     5 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     1 instructions eliminated by Jump Straightening (5 iterations).
     6 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   132 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-21 instructions):
 
    23 jump *label9 equal *tmp4 false
    24 set *tmp6 @unit
    25 set :backgroundProcess:firstUnit *tmp6
-    * set *tmp5 :backgroundProcess:firstUnit
    26 jump *label10 always
    27 label *label9
-    * set *tmp5 null
    28 label *label10
    29 op equal *tmp7 @unit :backgroundProcess:firstUnit
    30 jump *label11 equal *tmp7 false
 
    67 label *label19
    68 set *tmp24 null
    69 label *label20
-    * set *tmp22 *tmp24
    70 jump *label18 always
    71 label *label17
-    * set *tmp22 null
    72 label *label18
    73 print "minOre:"
    74 print .minOre
 
    81 set .sandX *tmp26
    82 sensor *tmp27 .sandContainer @y
    83 set .sandY *tmp27
-    * set *tmp8 .sandY
    84 jump *label12 always
    85 label *label11
-    * set *tmp8 null
    86 label *label12
-    * set *tmp28 :backgroundProcess:runningCount
    87 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
    88 sensor *tmp29 @unit @flag
    89 set :backgroundProcess:flag *tmp29
 
   106 label *label26
   107 set *tmp37 null
   108 label *label27
-    * set *tmp34 *tmp37
   109 jump *label25 always
   110 label *label24
-    * set *tmp34 null
   111 label *label25
   112 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
   113 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
   128 print :findOreToMine:y
   129 print "\n"
   130 label *label23
-    * set *tmp31 null
   131 jump *label22 always
   132 label *label21
   133 op equal *tmp45 :backgroundProcess:flag 1
 
   138 jump *label31 equal *tmp48 false
   139 ucontrol approach .sandX .sandY 7
   140 ucontrol itemDrop .sandContainer 20
-    * set *tmp49 null
   141 jump *label32 always
   142 label *label31
   143 ucontrol approach .coreX .coreY 7
   144 ucontrol itemDrop .core 20
-    * set *tmp49 null
   145 label *label32
   146 sensor *tmp50 @unit @firstItem
   147 op equal *tmp51 *tmp50 null
 
   149 print " (finished)"
   150 print "\n"
   151 ucontrol flag 0
-    * set *tmp52 null
   152 jump *label34 always
   153 label *label33
-    * set *tmp52 null
   154 label *label34
   155 print "\n"
   156 label *label30
 
   200 label *label40
   201 set *tmp65 null
   202 label *label41
-    * set *tmp63 *tmp65
   203 jump *label39 always
   204 label *label38
-    * set *tmp63 null
   205 label *label39
   206 sensor *tmp69 @unit @totalItems
   207 set :mine:items *tmp69
 
   211 jump *label44 equal *tmp71 false
   212 print " (dropping)"
   213 ucontrol itemDrop @air 20
-    * set *tmp72 null
   214 jump *label45 always
   215 label *label44
-    * set *tmp72 null
   216 label *label45
   217 op greaterThanEq *tmp73 :mine:items :mine:oreCapacity
   218 jump *label46 equal *tmp73 false
 
   229 ucontrol itemDrop .core 20
   230 set *tmp76 null
   231 label *label49
-    * set *tmp74 *tmp76
   232 jump *label47 always
   233 label *label46
   234 print " at "
 
   269 label *label55
   270 set *tmp80 *tmp84
   271 label *label51
-    * set *tmp74 *tmp80
   272 label *label47
   273 print "\n"
   274 label *label35
   275 set *tmp46 null
   276 label *label29
-    * set *tmp31 *tmp46
   277 label *label22
   278 label *label7
   279 jump *label6 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-12 instructions):
 
    62 op equal *tmp23 .minOre @sand
    63 jump *label19 equal *tmp23 false
    64 set .minOre @scrap
-    * set *tmp24 .minOre
    65 jump *label20 always
    66 label *label19
-    * set *tmp24 null
    67 label *label20
    68 jump *label18 always
    69 label *label17
 
    99 op notEqual *tmp36 *tmp35 null
   100 jump *label26 equal *tmp36 false
   101 jump *label23 always
-    * set *tmp37 null
   102 jump *label27 always
   103 label *label26
-    * set *tmp37 null
   104 label *label27
   105 jump *label25 always
   106 label *label24
 
   150 label *label34
   151 print "\n"
   152 label *label30
-    * set *tmp46 null
   153 jump *label29 always
   154 label *label28
   155 set :mine:flag :backgroundProcess:flag
 
   190 label *label42
   191 set *tmp68 null
   192 label *label43
-    * set *tmp65 *tmp68
   193 jump *label41 always
   194 label *label40
-    * set *tmp65 null
   195 label *label41
   196 jump *label39 always
   197 label *label38
 
   215 jump *label48 equal *tmp75 false
   216 ucontrol approach .sandX .sandY 7
   217 ucontrol itemDrop .sandContainer 20
-    * set *tmp76 null
   218 jump *label49 always
   219 label *label48
   220 ucontrol approach .coreX .coreY 7
   221 ucontrol itemDrop .core 20
-    * set *tmp76 null
   222 label *label49
   223 jump *label47 always
   224 label *label46
 
   244 print "\n"
   245 set *tmp82 ": no ore!"
   246 label *label53
-    * set *tmp80 *tmp82
   247 jump *label51 always
   248 label *label50
   249 op equal *tmp83 :mine:block null
 
   257 print "\n"
   258 set *tmp84 ": blocked!"
   259 label *label55
-    * set *tmp80 *tmp84
   260 label *label51
   261 label *label47
   262 print "\n"
   263 label *label35
-    * set *tmp46 null
   264 label *label29
   265 label *label22
   266 label *label7

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-6 instructions):
 
   185 print ", switching to a more needed ore"
   186 ucontrol flag 1
   187 jump *label35 always
-    * set *tmp68 null
   188 jump *label43 always
   189 label *label42
-    * set *tmp68 null
   190 label *label43
   191 jump *label41 always
   192 label *label40
 
   234 jump *label52 equal *tmp81 false
   235 print ": too far"
   236 print "\n"
-    * set *tmp82 ": too far"
   237 jump *label53 always
   238 label *label52
   239 ucontrol flag 1
   240 print ": no ore!"
   241 print "\n"
-    * set *tmp82 ": no ore!"
   242 label *label53
   243 jump *label51 always
   244 label *label50
   245 op equal *tmp83 :mine:block null
   246 jump *label54 equal *tmp83 false
   247 ucontrol mine :mine:x :mine:y
-    * set *tmp84 null
   248 jump *label55 always
   249 label *label54
   250 ucontrol flag 1
   251 print ": blocked!"
   252 print "\n"
-    * set *tmp84 ": blocked!"
   253 label *label55
   254 label *label51
   255 label *label47

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-16 instructions):
 
     7 label *label1
     8 label *label3
     9 ubind @mono
-    * set *tmp0 @unit
-    * set :backgroundProcess:firstUnit *tmp0
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   10 set :backgroundProcess:firstUnit @unit
+   11 ulocate building core false @copper .coreX .coreY *tmp2 .core
    12 label *label4
    13 op equal *tmp3 .core null
    14 jump *label3 notEqual *tmp3 false
 
    19 ubind @mono
    20 sensor *tmp4 :backgroundProcess:firstUnit @dead
    21 jump *label9 equal *tmp4 false
-    * set *tmp6 @unit
-    * set :backgroundProcess:firstUnit *tmp6
+   22 set :backgroundProcess:firstUnit @unit
    23 jump *label10 always
    24 label *label9
    25 label *label10
 
    27 jump *label11 equal *tmp7 false
    28 printflush message1
    29 sensor *tmp9 .core @lead
-    * op sub *tmp10 *tmp9 .leadTarget
-    * set :backgroundProcess:lead *tmp10
+   30 op sub :backgroundProcess:lead *tmp9 .leadTarget
    31 sensor *tmp11 .sandContainer @sand
    32 sensor *tmp12 .sandContainer @scrap
    33 op add *tmp13 *tmp11 *tmp12
-    * op sub *tmp14 *tmp13 .sandTarget
-    * set :backgroundProcess:sand *tmp14
+   34 op sub :backgroundProcess:sand *tmp13 .sandTarget
    35 sensor *tmp15 .core @copper
-    * op sub *tmp16 *tmp15 .copperTarget
-    * set :backgroundProcess:copper *tmp16
+   36 op sub :backgroundProcess:copper *tmp15 .copperTarget
    37 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    38 op min *tmp17 *tmp17 :backgroundProcess:copper
    39 set .min *tmp17
 
    69 op add .min .min *tmp25
    70 set .count :backgroundProcess:runningCount
    71 set :backgroundProcess:runningCount 2
-    * sensor *tmp26 .sandContainer @x
-    * set .sandX *tmp26
-    * sensor *tmp27 .sandContainer @y
-    * set .sandY *tmp27
+   72 sensor .sandX .sandContainer @x
+   73 sensor .sandY .sandContainer @y
    74 jump *label12 always
    75 label *label11
    76 label *label12
    77 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
-    * sensor *tmp29 @unit @flag
-    * set :backgroundProcess:flag *tmp29
+   78 sensor :backgroundProcess:flag @unit @flag
    79 print "Unit flag: "
    80 print :backgroundProcess:flag
    81 print "\n"
 
   146 set :mine:flag :backgroundProcess:flag
   147 print "Mining "
   148 op mod *tmp53 :mine:flag 16
-    * lookup item *tmp54 *tmp53
-    * set :mine:ore *tmp54
+  149 lookup item :mine:ore *tmp53
   150 printchar :mine:ore
   151 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp55 :mine:flag 1000
-    * set :mine:y *tmp55
-    * op idiv *tmp56 :mine:flag 1000
-    * set :mine:x *tmp56
+  152 op mod :mine:y :mine:flag 1000
+  153 op idiv :mine:x :mine:flag 1000
   154 sensor *tmp57 :mine:ore @name
-    * read *tmp58 @this *tmp57
-    * set :mine:floorOre *tmp58
+  155 read :mine:floorOre @this *tmp57
   156 op equal *tmp59 :mine:ore @scrap
   157 jump *label36 equal *tmp59 false
-    * op sub *tmp61 20 .count
-    * set *tmp60 *tmp61
+  158 op sub *tmp60 20 .count
   159 jump *label37 always
   160 label *label36
   161 set *tmp60 20
 
   180 jump *label39 always
   181 label *label38
   182 label *label39
-    * sensor *tmp69 @unit @totalItems
-    * set :mine:items *tmp69
+  183 sensor :mine:items @unit @totalItems
   184 print :mine:items
   185 sensor *tmp70 @unit @firstItem
   186 op notEqual *tmp71 *tmp70 :mine:ore
 
   211 print " "
   212 print :mine:y
   213 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp78 *tmp77 :mine:floor
-    * set :mine:block *tmp77
+  214 ucontrol getBlock :mine:x :mine:y *tmp78 :mine:block :mine:floor
   215 op notEqual *tmp79 :mine:floor :mine:floorOre
   216 jump *label50 equal *tmp79 false
   217 op equal *tmp81 :mine:floor null

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    15 label *label5
    16 set :backgroundProcess:runningCount 0
    17 label *label6
-    * jump *label8 equal true false
    18 ubind @mono
    19 sensor *tmp4 :backgroundProcess:firstUnit @dead
    20 jump *label9 equal *tmp4 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-21 instructions):
 
    10 set :backgroundProcess:firstUnit @unit
    11 ulocate building core false @copper .coreX .coreY *tmp2 .core
    12 label *label4
-    * op equal *tmp3 .core null
-    * jump *label3 notEqual *tmp3 false
+   13 jump *label3 equal .core null
    14 label *label5
    15 set :backgroundProcess:runningCount 0
    16 label *label6
 
    21 jump *label10 always
    22 label *label9
    23 label *label10
-    * op equal *tmp7 @unit :backgroundProcess:firstUnit
-    * jump *label11 equal *tmp7 false
+   24 jump *label11 notEqual @unit :backgroundProcess:firstUnit
    25 printflush message1
    26 sensor *tmp9 .core @lead
    27 op sub :backgroundProcess:lead *tmp9 .leadTarget
 
    34 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    35 op min *tmp17 *tmp17 :backgroundProcess:copper
    36 set .min *tmp17
-    * op equal *tmp18 .min :backgroundProcess:sand
-    * jump *label13 equal *tmp18 false
+   37 jump *label13 notEqual .min :backgroundProcess:sand
    38 set *tmp19 @sand
    39 jump *label14 always
    40 label *label13
-    * op equal *tmp20 .min :backgroundProcess:lead
-    * jump *label15 equal *tmp20 false
+   41 jump *label15 notEqual .min :backgroundProcess:lead
    42 set *tmp21 @lead
    43 jump *label16 always
    44 label *label15
 
    48 label *label14
    49 set .minOre *tmp19
    50 jump *label17 equal .scrap false
-    * op equal *tmp23 .minOre @sand
-    * jump *label19 equal *tmp23 false
+   51 jump *label19 notEqual .minOre @sand
    52 set .minOre @scrap
    53 jump *label20 always
    54 label *label19
 
    73 print "Unit flag: "
    74 print :backgroundProcess:flag
    75 print "\n"
-    * op equal *tmp30 :backgroundProcess:flag 0
-    * jump *label21 equal *tmp30 false
+   76 jump *label21 notEqual :backgroundProcess:flag 0
    77 set :findOreToMine:ore .minOre
    78 sensor *tmp32 @unit @firstItem
-    * op notEqual *tmp33 *tmp32 null
-    * jump *label24 equal *tmp33 false
+   79 jump *label24 equal *tmp32 null
    80 ucontrol itemDrop @air 20
    81 sensor *tmp35 @unit @firstItem
-    * op notEqual *tmp36 *tmp35 null
-    * jump *label26 equal *tmp36 false
+   82 jump *label26 equal *tmp35 null
    83 jump *label23 always
    84 jump *label27 always
    85 label *label26
 
   108 label *label23
   109 jump *label22 always
   110 label *label21
-    * op equal *tmp45 :backgroundProcess:flag 1
-    * jump *label28 equal *tmp45 false
+  111 jump *label28 notEqual :backgroundProcess:flag 1
   112 print "Returning ore"
   113 sensor *tmp47 @unit @firstItem
-    * op equal *tmp48 *tmp47 @scrap
-    * jump *label31 equal *tmp48 false
+  114 jump *label31 notEqual *tmp47 @scrap
   115 ucontrol approach .sandX .sandY 7
   116 ucontrol itemDrop .sandContainer 20
   117 jump *label32 always
 
   120 ucontrol itemDrop .core 20
   121 label *label32
   122 sensor *tmp50 @unit @firstItem
-    * op equal *tmp51 *tmp50 null
-    * jump *label33 equal *tmp51 false
+  123 jump *label33 notEqual *tmp50 null
   124 print " (finished)"
   125 print "\n"
   126 ucontrol flag 0
 
   141 op idiv :mine:x :mine:flag 1000
   142 sensor *tmp57 :mine:ore @name
   143 read :mine:floorOre @this *tmp57
-    * op equal *tmp59 :mine:ore @scrap
-    * jump *label36 equal *tmp59 false
+  144 jump *label36 notEqual :mine:ore @scrap
   145 op sub *tmp60 20 .count
   146 jump *label37 always
   147 label *label36
   148 set *tmp60 20
   149 label *label37
   150 set :mine:oreCapacity *tmp60
-    * op notEqual *tmp62 :mine:ore .minOre
-    * jump *label38 equal *tmp62 false
-    * op notEqual *tmp64 :mine:ore @scrap
-    * jump *label40 equal *tmp64 false
+  151 jump *label38 equal :mine:ore .minOre
+  152 jump *label40 equal :mine:ore @scrap
   153 sensor *tmp66 .core :mine:ore
-    * op greaterThan *tmp67 *tmp66 .min
-    * jump *label42 equal *tmp67 false
+  154 jump *label42 lessThanEq *tmp66 .min
   155 print ", switching to a more needed ore"
   156 ucontrol flag 1
   157 jump *label35 always
 
   167 sensor :mine:items @unit @totalItems
   168 print :mine:items
   169 sensor *tmp70 @unit @firstItem
-    * op notEqual *tmp71 *tmp70 :mine:ore
-    * jump *label44 equal *tmp71 false
+  170 jump *label44 equal *tmp70 :mine:ore
   171 print " (dropping)"
   172 ucontrol itemDrop @air 20
   173 jump *label45 always
   174 label *label44
   175 label *label45
-    * op greaterThanEq *tmp73 :mine:items :mine:oreCapacity
-    * jump *label46 equal *tmp73 false
+  176 jump *label46 lessThan :mine:items :mine:oreCapacity
   177 print ", full"
   178 ucontrol flag 1
-    * op equal *tmp75 :mine:ore @scrap
-    * jump *label48 equal *tmp75 false
+  179 jump *label48 notEqual :mine:ore @scrap
   180 ucontrol approach .sandX .sandY 7
   181 ucontrol itemDrop .sandContainer 20
   182 jump *label49 always
 
   193 print :mine:y
   194 ucontrol approach :mine:x :mine:y 7
   195 ucontrol getBlock :mine:x :mine:y *tmp78 :mine:block :mine:floor
-    * op notEqual *tmp79 :mine:floor :mine:floorOre
-    * jump *label50 equal *tmp79 false
-    * op equal *tmp81 :mine:floor null
-    * jump *label52 equal *tmp81 false
+  196 jump *label50 equal :mine:floor :mine:floorOre
+  197 jump *label52 notEqual :mine:floor null
   198 print ": too far"
   199 print "\n"
   200 jump *label53 always
 
   205 label *label53
   206 jump *label51 always
   207 label *label50
-    * op equal *tmp83 :mine:block null
-    * jump *label54 equal *tmp83 false
+  208 jump *label54 notEqual :mine:block null
   209 ucontrol mine :mine:x :mine:y
   210 jump *label55 always
   211 label *label54

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-11 instructions):
 
    18 sensor *tmp4 :backgroundProcess:firstUnit @dead
    19 jump *label9 equal *tmp4 false
    20 set :backgroundProcess:firstUnit @unit
-    * jump *label10 always
    21 label *label9
    22 label *label10
    23 jump *label11 notEqual @unit :backgroundProcess:firstUnit
 
    49 jump *label17 equal .scrap false
    50 jump *label19 notEqual .minOre @sand
    51 set .minOre @scrap
-    * jump *label20 always
    52 label *label19
    53 label *label20
-    * jump *label18 always
    54 label *label17
    55 label *label18
    56 print "minOre:"
 
    62 set :backgroundProcess:runningCount 2
    63 sensor .sandX .sandContainer @x
    64 sensor .sandY .sandContainer @y
-    * jump *label12 always
    65 label *label11
    66 label *label12
    67 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
 
    77 sensor *tmp35 @unit @firstItem
    78 jump *label26 equal *tmp35 null
    79 jump *label23 always
-    * jump *label27 always
    80 label *label26
    81 label *label27
-    * jump *label25 always
    82 label *label24
    83 label *label25
    84 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
 
   118 print " (finished)"
   119 print "\n"
   120 ucontrol flag 0
-    * jump *label34 always
   121 label *label33
   122 label *label34
   123 print "\n"
 
   148 print ", switching to a more needed ore"
   149 ucontrol flag 1
   150 jump *label35 always
-    * jump *label43 always
   151 label *label42
   152 label *label43
-    * jump *label41 always
   153 label *label40
   154 label *label41
-    * jump *label39 always
   155 label *label38
   156 label *label39
   157 sensor :mine:items @unit @totalItems
 
   160 jump *label44 equal *tmp70 :mine:ore
   161 print " (dropping)"
   162 ucontrol itemDrop @air 20
-    * jump *label45 always
   163 label *label44
   164 label *label45
   165 jump *label46 lessThan :mine:items :mine:oreCapacity

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    33 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    34 op min *tmp17 *tmp17 :backgroundProcess:copper
    35 set .min *tmp17
-    * jump *label13 notEqual .min :backgroundProcess:sand
+   36 jump *label13 notEqual *tmp17 :backgroundProcess:sand
    37 set *tmp19 @sand
    38 jump *label14 always
    39 label *label13
-    * jump *label15 notEqual .min :backgroundProcess:lead
+   40 jump *label15 notEqual *tmp17 :backgroundProcess:lead
    41 set *tmp21 @lead
    42 jump *label16 always
    43 label *label15
 
    47 label *label14
    48 set .minOre *tmp19
    49 jump *label17 equal .scrap false
-    * jump *label19 notEqual .minOre @sand
+   50 jump *label19 notEqual *tmp19 @sand
    51 set .minOre @scrap
    52 label *label19
    53 label *label20
 
    57 print .minOre
    58 print "\n"
    59 op mul *tmp25 10 :backgroundProcess:runningCount
-    * op add .min .min *tmp25
+   60 op add .min *tmp17 *tmp25
    61 set .count :backgroundProcess:runningCount
    62 set :backgroundProcess:runningCount 2
    63 sensor .sandX .sandContainer @x
 
    81 label *label27
    82 label *label24
    83 label *label25
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
+   84 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
    85 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    86 ucontrol mine :findOreToMine:x :findOreToMine:y
    87 op mul *tmp40 :findOreToMine:x 1000
    88 op add *tmp41 *tmp40 :findOreToMine:y
    89 op mul *tmp42 *tmp41 16
-    * sensor *tmp43 :findOreToMine:ore @id
+   90 sensor *tmp43 .minOre @id
    91 op add *tmp44 *tmp42 *tmp43
    92 ucontrol flag *tmp44
    93 print "Found "
-    * print :findOreToMine:ore
+   94 print .minOre
    95 print " "
    96 print "at "
    97 print :findOreToMine:x
 
   126 label *label28
   127 set :mine:flag :backgroundProcess:flag
   128 print "Mining "
-    * op mod *tmp53 :mine:flag 16
+  129 op mod *tmp53 :backgroundProcess:flag 16
   130 lookup item :mine:ore *tmp53
   131 printchar :mine:ore
-    * op idiv :mine:flag :mine:flag 16
+  132 op idiv :mine:flag :backgroundProcess:flag 16
   133 op mod :mine:y :mine:flag 1000
   134 op idiv :mine:x :mine:flag 1000
   135 sensor *tmp57 :mine:ore @name
 
   162 ucontrol itemDrop @air 20
   163 label *label44
   164 label *label45
-    * jump *label46 lessThan :mine:items :mine:oreCapacity
+  165 jump *label46 lessThan :mine:items *tmp60
   166 print ", full"
   167 ucontrol flag 1
   168 jump *label48 notEqual :mine:ore @scrap

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    32 op sub :backgroundProcess:copper *tmp15 .copperTarget
    33 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    34 op min *tmp17 *tmp17 :backgroundProcess:copper
-    * set .min *tmp17
    35 jump *label13 notEqual *tmp17 :backgroundProcess:sand
    36 set *tmp19 @sand
    37 jump *label14 always
 
    69 print :backgroundProcess:flag
    70 print "\n"
    71 jump *label21 notEqual :backgroundProcess:flag 0
-    * set :findOreToMine:ore .minOre
    72 sensor *tmp32 @unit @firstItem
    73 jump *label24 equal *tmp32 null
    74 ucontrol itemDrop @air 20
 
   122 label *label30
   123 jump *label29 always
   124 label *label28
-    * set :mine:flag :backgroundProcess:flag
   125 print "Mining "
   126 op mod *tmp53 :backgroundProcess:flag 16
   127 lookup item :mine:ore *tmp53
 
   137 label *label36
   138 set *tmp60 20
   139 label *label37
-    * set :mine:oreCapacity *tmp60
   140 jump *label38 equal :mine:ore .minOre
   141 jump *label40 equal :mine:ore @scrap
   142 sensor *tmp66 .core :mine:ore

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-7 instructions):
 
    15 set :backgroundProcess:runningCount 0
    16 label *label6
    17 ubind @mono
-    * sensor *tmp4 :backgroundProcess:firstUnit @dead
-    * jump *label9 equal *tmp4 false
-    * set :backgroundProcess:firstUnit @unit
-    * label *label9
-    * label *label10
+   18 sensor *tmp4 :backgroundProcess:firstUnit @dead
+   19 select :backgroundProcess:firstUnit notEqual *tmp4 false @unit :backgroundProcess:firstUnit
    20 jump *label11 notEqual @unit :backgroundProcess:firstUnit
    21 printflush message1
    22 sensor *tmp9 .core @lead
 
    33 set *tmp19 @sand
    34 jump *label14 always
    35 label *label13
-    * jump *label15 notEqual *tmp17 :backgroundProcess:lead
-    * set *tmp21 @lead
-    * jump *label16 always
-    * label *label15
-    * set *tmp21 @copper
-    * label *label16
+   36 select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @copper
    37 set *tmp19 *tmp21
    38 label *label14
    39 set .minOre *tmp19
    40 jump *label17 equal .scrap false
-    * jump *label19 notEqual *tmp19 @sand
-    * set .minOre @scrap
-    * label *label19
-    * label *label20
+   41 select .minOre equal *tmp19 @sand @scrap .minOre
    42 label *label17
    43 label *label18
    44 print "minOre:"
 
   120 op idiv :mine:x :mine:flag 1000
   121 sensor *tmp57 :mine:ore @name
   122 read :mine:floorOre @this *tmp57
-    * jump *label36 notEqual :mine:ore @scrap
-    * op sub *tmp60 20 .count
-    * jump *label37 always
-    * label *label36
-    * set *tmp60 20
-    * label *label37
+  123 op sub *tmp86 20 .count
+  124 select *tmp60 equal :mine:ore @scrap *tmp86 20
   125 jump *label38 equal :mine:ore .minOre
   126 jump *label40 equal :mine:ore @scrap
   127 sensor *tmp66 .core :mine:ore

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 2 (-3 instructions):
 
    29 op sub :backgroundProcess:copper *tmp15 .copperTarget
    30 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    31 op min *tmp17 *tmp17 :backgroundProcess:copper
-    * jump *label13 notEqual *tmp17 :backgroundProcess:sand
-    * set *tmp19 @sand
-    * jump *label14 always
-    * label *label13
-    * select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @copper
-    * set *tmp19 *tmp21
-    * label *label14
+   32 select *tmp88 equal *tmp17 :backgroundProcess:lead @lead @copper
+   33 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp88
    34 set .minOre *tmp19
-    * jump *label17 equal .scrap false
-    * select .minOre equal *tmp19 @sand @scrap .minOre
-    * label *label17
-    * label *label18
+   35 select *tmp89 equal *tmp19 @sand @scrap .minOre
+   36 select .minOre notEqual .scrap false *tmp89 .minOre
    37 print "minOre:"
    38 print .minOre
    39 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    32 select *tmp88 equal *tmp17 :backgroundProcess:lead @lead @copper
    33 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp88
    34 set .minOre *tmp19
-    * select *tmp89 equal *tmp19 @sand @scrap .minOre
-    * select .minOre notEqual .scrap false *tmp89 .minOre
+   35 select *tmp89 equal *tmp19 @sand @scrap *tmp19
+   36 select .minOre notEqual .scrap false *tmp89 *tmp19
    37 print "minOre:"
    38 print .minOre
    39 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
    31 op min *tmp17 *tmp17 :backgroundProcess:copper
    32 select *tmp88 equal *tmp17 :backgroundProcess:lead @lead @copper
    33 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp88
-    * set .minOre *tmp19
    34 select *tmp89 equal *tmp19 @sand @scrap *tmp19
    35 select .minOre notEqual .scrap false *tmp89 *tmp19
    36 print "minOre:"

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     9 ubind @mono
    10 set :backgroundProcess:firstUnit @unit
    11 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label4
    12 jump *label3 equal .core null
-    * label *label5
    13 set :backgroundProcess:runningCount 0
    14 label *label6
    15 ubind @mono
 
    41 sensor .sandX .sandContainer @x
    42 sensor .sandY .sandContainer @y
    43 label *label11
-    * label *label12
    44 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
    45 sensor :backgroundProcess:flag @unit @flag
    46 print "Unit flag: "
 
    54 jump *label26 equal *tmp35 null
    55 jump *label23 always
    56 label *label26
-    * label *label27
    57 label *label24
-    * label *label25
    58 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
    59 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    60 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    93 print "\n"
    94 ucontrol flag 0
    95 label *label33
-    * label *label34
    96 print "\n"
-    * label *label30
    97 jump *label29 always
    98 label *label28
    99 print "Mining "
 
   115 ucontrol flag 1
   116 jump *label35 always
   117 label *label42
-    * label *label43
   118 label *label40
-    * label *label41
   119 label *label38
-    * label *label39
   120 sensor :mine:items @unit @totalItems
   121 print :mine:items
   122 sensor *tmp70 @unit @firstItem
 
   124 print " (dropping)"
   125 ucontrol itemDrop @air 20
   126 label *label44
-    * label *label45
   127 jump *label46 lessThan :mine:items *tmp60
   128 print ", full"
   129 ucontrol flag 1
 
   170 label *label35
   171 label *label29
   172 label *label22
-    * label *label7
   173 jump *label6 always
-    * label *label8
-    * label *label2
   174 wait 1e12
   175 jump *label1 always
   176 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    51 jump *label24 equal *tmp32 null
    52 ucontrol itemDrop @air 20
    53 sensor *tmp35 @unit @firstItem
-    * jump *label26 equal *tmp35 null
-    * jump *label23 always
+   54 jump *label23 notEqual *tmp35 null
    55 label *label26
    56 label *label24
    57 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    52 ucontrol itemDrop @air 20
    53 sensor *tmp35 @unit @firstItem
    54 jump *label23 notEqual *tmp35 null
-    * label *label26
    55 label *label24
    56 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
    57 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    51 jump *label24 equal *tmp32 null
    52 ucontrol itemDrop @air 20
    53 sensor *tmp35 @unit @firstItem
-    * jump *label23 notEqual *tmp35 null
+   54 jump *label6 notEqual *tmp35 null
    55 label *label24
    56 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
    57 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    72 print :findOreToMine:y
    73 print "\n"
    74 label *label23
-    * jump *label22 always
+   75 jump *label6 always
    76 label *label21
    77 jump *label28 notEqual :backgroundProcess:flag 1
    78 print "Returning ore"
 
    92 ucontrol flag 0
    93 label *label33
    94 print "\n"
-    * jump *label29 always
+   95 jump *label6 always
    96 label *label28
    97 print "Mining "
    98 op mod *tmp53 :backgroundProcess:flag 16
 
   111 jump *label42 lessThanEq *tmp66 .min
   112 print ", switching to a more needed ore"
   113 ucontrol flag 1
-    * jump *label35 always
+  114 jump *label6 always
   115 label *label42
   116 label *label40
   117 label *label38
 
   128 jump *label48 notEqual :mine:ore @scrap
   129 ucontrol approach .sandX .sandY 7
   130 ucontrol itemDrop .sandContainer 20
-    * jump *label49 always
+  131 jump *label47 always
   132 label *label48
   133 ucontrol approach .coreX .coreY 7
   134 ucontrol itemDrop .core 20
 
   146 jump *label52 notEqual :mine:floor null
   147 print ": too far"
   148 print "\n"
-    * jump *label53 always
+  149 jump *label51 always
   150 label *label52
   151 ucontrol flag 1
   152 print ": no ore!"

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    71 print " "
    72 print :findOreToMine:y
    73 print "\n"
-    * label *label23
    74 jump *label6 always
    75 label *label21
    76 jump *label28 notEqual :backgroundProcess:flag 1
 
   131 label *label48
   132 ucontrol approach .coreX .coreY 7
   133 ucontrol itemDrop .core 20
-    * label *label49
   134 jump *label47 always
   135 label *label46
   136 print " at "
 
   149 ucontrol flag 1
   150 print ": no ore!"
   151 print "\n"
-    * label *label53
   152 jump *label51 always
   153 label *label50
   154 jump *label54 notEqual :mine:block null
 
   162 label *label51
   163 label *label47
   164 print "\n"
-    * label *label35
-    * label *label29
-    * label *label22
   165 jump *label6 always
-    * wait 1e12
-    * jump *label1 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
 
     4 set lead @ore-lead
     5 set sand @sand-floor
     6 set *signature "0:v1"
-    * label *label1
     7 label *label3
     8 ubind @mono
     9 set :backgroundProcess:firstUnit @unit

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
     7 label *label3
     8 ubind @mono
     9 set :backgroundProcess:firstUnit @unit
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+   10 ulocate building core false @copper .coreX .coreY 0 .core
    11 jump *label3 equal .core null
    12 set :backgroundProcess:runningCount 0
    13 label *label6
 
    52 sensor *tmp35 @unit @firstItem
    53 jump *label6 notEqual *tmp35 null
    54 label *label24
-    * ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp38 *tmp39
+   55 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    56 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    57 ucontrol mine :findOreToMine:x :findOreToMine:y
    58 op mul *tmp40 :findOreToMine:x 1000
 
   138 print " "
   139 print :mine:y
   140 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp78 :mine:block :mine:floor
+  141 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   142 jump *label50 equal :mine:floor :mine:floorOre
   143 jump *label52 notEqual :mine:floor null
   144 print ": too far"

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    30 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp88
    31 select *tmp89 equal *tmp19 @sand @scrap *tmp19
    32 select .minOre notEqual .scrap false *tmp89 *tmp19
-    * print "minOre:"
-    * print .minOre
-    * print "\n"
+   33 print "minOre:{0}\n"
+   34 format .minOre
    35 op mul *tmp25 10 :backgroundProcess:runningCount
    36 op add .min *tmp17 *tmp25
    37 set .count :backgroundProcess:runningCount
 
    41 label *label11
    42 op add :backgroundProcess:runningCount :backgroundProcess:runningCount 1
    43 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   44 print "Unit flag: {0}\n"
+   45 format :backgroundProcess:flag
    46 jump *label21 notEqual :backgroundProcess:flag 0
    47 sensor *tmp32 @unit @firstItem
    48 jump *label24 equal *tmp32 null
 
    59 sensor *tmp43 .minOre @id
    60 op add *tmp44 *tmp42 *tmp43
    61 ucontrol flag *tmp44
-    * print "Found "
-    * print .minOre
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   62 print "Found {0} at {0}, {0}\n"
+   63 format .minOre
+   64 format :findOreToMine:x
+   65 format :findOreToMine:y
    66 jump *label6 always
    67 label *label21
    68 jump *label28 notEqual :backgroundProcess:flag 1
 
    78 label *label32
    79 sensor *tmp50 @unit @firstItem
    80 jump *label33 notEqual *tmp50 null
-    * print " (finished)"
-    * print "\n"
+   81 print " (finished)\n"
    82 ucontrol flag 0
    83 label *label33
    84 print "\n"
 
   124 ucontrol itemDrop .core 20
   125 jump *label47 always
   126 label *label46
-    * print " at "
-    * print :mine:x
-    * print ","
-    * print " "
+  127 print " at {0}, "
+  128 format :mine:x
   129 print :mine:y
   130 ucontrol approach :mine:x :mine:y 7
   131 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   132 jump *label50 equal :mine:floor :mine:floorOre
   133 jump *label52 notEqual :mine:floor null
-    * print ": too far"
-    * print "\n"
+  134 print ": too far\n"
   135 jump *label51 always
   136 label *label52
   137 ucontrol flag 1
-    * print ": no ore!"
-    * print "\n"
+  138 print ": no ore!\n"
   139 jump *label51 always
   140 label *label50
   141 jump *label54 notEqual :mine:block null
 
   143 jump *label55 always
   144 label *label54
   145 ucontrol flag 1
-    * print ": blocked!"
-    * print "\n"
+  146 print ": blocked!\n"
   147 label *label55
   148 label *label51
   149 label *label47

Final code before resolving virtual instructions:

    0:  set .min 0                                                   var min = 0, minOre = null;
    1:  set .minOre null                                             ...
    2:  set copper @ore-copper                                       volatile mlog(@copper.@name)  var oreCopper = @ore-copper;
    3:  set scrap @ore-scrap                                         volatile mlog(@scrap.@name)   var oreScrap = @ore-scrap;
    4:  set lead @ore-lead                                           volatile mlog(@lead.@name)    var oreLead = @ore-lead;
    5:  set sand @sand-floor                                         volatile mlog(@sand.@name)    var oreSand = @sand-floor;
    6:  set *signature "0:v1"                                        #set target = 8;
        label *label3                                                do
    7:  ubind @mono                                                  firstUnit = ubind(@mono);
    8:  set :backgroundProcess:firstUnit @unit                       ...
    9:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   10:  jump *label3 equal .core null                                do
   11:  set :backgroundProcess:runningCount 0                        var runningCount = 0;
        label *label6                                                while true do
   12:  ubind @mono                                                  ubind(@mono);
   13:  sensor *tmp4 :backgroundProcess:firstUnit @dead              if firstUnit.@dead then firstUnit = @unit; end;
   14:  select :backgroundProcess:firstUnit notEqual *tmp4 false @un ...
   15:  jump *label11 notEqual @unit :backgroundProcess:firstUnit    if @unit == firstUnit then
   16:  printflush message1                                          printflush(message1);
   17:  sensor *tmp9 .core @lead                                     var lead = core.@lead - leadTarget;
   18:  op sub :backgroundProcess:lead *tmp9 .leadTarget             ...
   19:  sensor *tmp11 .sandContainer @sand                           var sand = sandContainer.@sand + sandContainer.@scrap - sandTarget;
   20:  sensor *tmp12 .sandContainer @scrap                          ...
   21:  op add *tmp13 *tmp11 *tmp12                                  ...
   22:  op sub :backgroundProcess:sand *tmp13 .sandTarget            ...
   23:  sensor *tmp15 .core @copper                                  var copper = core.@copper - copperTarget;
   24:  op sub :backgroundProcess:copper *tmp15 .copperTarget        ...
   25:  op min *tmp17 :backgroundProcess:lead :backgroundProcess:san min = min(lead, sand, copper);
   26:  op min *tmp17 *tmp17 :backgroundProcess:copper               ...
   27:  select *tmp88 equal *tmp17 :backgroundProcess:lead @lead @co minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   28:  select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tm ...
   29:  select *tmp89 equal *tmp19 @sand @scrap *tmp19               if scrap then
   30:  select .minOre notEqual .scrap false *tmp89 *tmp19           ...
   31:  print "minOre:{0}\n"                                         println("minOre:", minOre);
   32:  format .minOre                                               ...
   33:  op mul *tmp25 10 :backgroundProcess:runningCount             min += 10 * runningCount;
   34:  op add .min *tmp17 *tmp25                                    ...
   35:  set .count :backgroundProcess:runningCount                   count = runningCount;
   36:  set :backgroundProcess:runningCount 2                        runningCount = 2;
   37:  sensor .sandX .sandContainer @x                              sandX = sandContainer.@x;
   38:  sensor .sandY .sandContainer @y                              sandY = sandContainer.@y;
        label *label11                                               if @unit == firstUnit then
   39:  op add :backgroundProcess:runningCount :backgroundProcess:ru while true do
   40:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   41:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   42:  format :backgroundProcess:flag                               ...
   43:  jump *label21 notEqual :backgroundProcess:flag 0             if flag == 0 then
   44:  sensor *tmp32 @unit @firstItem                               if @unit.@firstItem != null then
   45:  jump *label24 equal *tmp32 null                              ...
   46:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   47:  sensor *tmp35 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   48:  jump *label6 notEqual *tmp35 null                            ...
        label *label24                                               if @unit.@firstItem != null then
   49:  ulocate ore core true .minOre :findOreToMine:x :findOreToMin ulocate(:ore, ore, out x, out y);
   50:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   51:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   52:  op mul *tmp40 :findOreToMine:x 1000                          flag((x * 1000 + y) * 16 + ore.@id);
   53:  op add *tmp41 *tmp40 :findOreToMine:y                        ...
   54:  op mul *tmp42 *tmp41 16                                      ...
   55:  sensor *tmp43 .minOre @id                                    ...
   56:  op add *tmp44 *tmp42 *tmp43                                  ...
   57:  ucontrol flag *tmp44 0 0 0 0                                 ...
   58:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   59:  format .minOre                                               ...
   60:  format :findOreToMine:x                                      ...
   61:  format :findOreToMine:y                                      ...
   62:  jump *label6 always 0 0                                      if flag == 0 then
        label *label21                                               ...
   63:  jump *label28 notEqual :backgroundProcess:flag 1             elsif flag == 1 then
   64:  print "Returning ore"                                        print("Returning ore");
   65:  sensor *tmp47 @unit @firstItem                               if @unit.@firstItem == @scrap then
   66:  jump *label31 notEqual *tmp47 @scrap                         ...
   67:  ucontrol approach .sandX .sandY 7 0 0                        approach(sandX, sandY, RADIUS);
   68:  ucontrol itemDrop .sandContainer 20 0 0 0                    itemDrop(sandContainer, capacity);
   69:  jump *label32 always 0 0                                     if @unit.@firstItem == @scrap then
        label *label31                                               ...
   70:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   71:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
        label *label32                                               if @unit.@firstItem == @scrap then
   72:  sensor *tmp50 @unit @firstItem                               if @unit.@firstItem == null then
   73:  jump *label33 notEqual *tmp50 null                           ...
   74:  print " (finished)\n"                                        println(" (finished)");
   75:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label33                                               if @unit.@firstItem == null then
   76:  print "\n"                                                   println();
   77:  jump *label6 always 0 0                                      elsif flag == 1 then
        label *label28                                               ...
   78:  print "Mining "                                              print("Mining ");
   79:  op mod *tmp53 :backgroundProcess:flag 16                     var ore = lookup(:item, flag % 16);
   80:  lookup item :mine:ore *tmp53                                 ...
   81:  printchar :mine:ore                                          printchar(ore);
   82:  op idiv :mine:flag :backgroundProcess:flag 16                flag \= 16;
   83:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   84:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   85:  sensor *tmp57 :mine:ore @name                                var floorOre = @this.read(ore.@name);
   86:  read :mine:floorOre @this *tmp57                             ...
   87:  op sub *tmp86 20 .count                                      var oreCapacity = ore == @scrap ? capacity - count : capacity;
   88:  select *tmp60 equal :mine:ore @scrap *tmp86 20               ...
   89:  jump *label38 equal :mine:ore .minOre                        if ore != minOre then
   90:  jump *label40 equal :mine:ore @scrap                         if ore != @scrap then
   91:  sensor *tmp66 .core :mine:ore                                if core.sensor(ore) > min then
   92:  jump *label42 lessThanEq *tmp66 .min                         ...
   93:  print ", switching to a more needed ore"                     print(", switching to a more needed ore");
   94:  ucontrol flag 1 0 0 0 0                                      flag(1);
   95:  jump *label6 always 0 0                                      return;
        label *label42                                               if core.sensor(ore) > min then
        label *label40                                               if ore != @scrap then
        label *label38                                               if ore != minOre then
   96:  sensor :mine:items @unit @totalItems                         var items = @unit.@totalItems;
   97:  print :mine:items                                            print(items);
   98:  sensor *tmp70 @unit @firstItem                               if @unit.@firstItem != ore then
   99:  jump *label44 equal *tmp70 :mine:ore                         ...
  100:  print " (dropping)"                                          print(" (dropping)");
  101:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label44                                               if @unit.@firstItem != ore then
  102:  jump *label46 lessThan :mine:items *tmp60                    if items >= oreCapacity then
  103:  print ", full"                                               print(", full");
  104:  ucontrol flag 1 0 0 0 0                                      flag(1);
  105:  jump *label48 notEqual :mine:ore @scrap                      if ore == @scrap then
  106:  ucontrol approach .sandX .sandY 7 0 0                        approach(sandX, sandY, RADIUS);
  107:  ucontrol itemDrop .sandContainer 20 0 0 0                    itemDrop(sandContainer, capacity);
  108:  jump *label47 always 0 0                                     if ore == @scrap then
        label *label48                                               ...
  109:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
  110:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
  111:  jump *label47 always 0 0                                     if items >= oreCapacity then
        label *label46                                               ...
  112:  print " at {0}, "                                            print($" at $x, $y");
  113:  format :mine:x                                               ...
  114:  print :mine:y                                                ...
  115:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
  116:  ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor  var block = getBlock(x, y, , out floor);
  117:  jump *label50 equal :mine:floor :mine:floorOre               if floor != floorOre then
  118:  jump *label52 notEqual :mine:floor null                      if floor == null then
  119:  print ": too far\n"                                          println(": too far");
  120:  jump *label51 always 0 0                                     if floor == null then
        label *label52                                               ...
  121:  ucontrol flag 1 0 0 0 0                                      flag(1);
  122:  print ": no ore!\n"                                          println(": no ore!");
  123:  jump *label51 always 0 0                                     if floor != floorOre then
        label *label50                                               ...
  124:  jump *label54 notEqual :mine:block null                      elsif block == null then
  125:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
  126:  jump *label55 always 0 0                                     elsif block == null then
        label *label54                                               ...
  127:  ucontrol flag 1 0 0 0 0                                      flag(1);
  128:  print ": blocked!\n"                                         println(": blocked!");
        label *label55                                               elsif block == null then
        label *label51                                               if floor != floorOre then
        label *label47                                               if items >= oreCapacity then
  129:  print "\n"                                                   println();
  130:  jump *label6 always 0 0                                      while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    52     1x     52,0  void mine(in flag)
    42     1x     42,0  void backgroundProcess()
    18     1x     18,0  void findOreToMine(in ore)
    13     1x     13,0  void returnItems()
     7     1x      7,0  <no function>

Performance: parsed in 229 ms, compiled in 213 ms, optimized in 282 ms, run in 5 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (8 steps):
The program didn't generate any output.
Execution exception at instruction 7: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
