   690 instructions before optimizations.
    30 instructions eliminated by Temp Variables Elimination (2 passes, 6 iterations).
   104 instructions eliminated by Dead Code Elimination (5 iterations).
    54 instructions eliminated by Jump Optimization (5 iterations).
    57 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
    11 instructions modified by Expression Optimization (2 passes, 3 iterations).
   217 instructions eliminated by Data Flow Optimization (9 passes, 30 iterations).
     1 loops improved by Loop Hoisting.
     2 instructions eliminated by Loop Optimization (3 iterations).
     2 loops improved by Loop Optimization.
   400 instructions added by Loop Unrolling (10 iterations).
     2 loops unrolled by Loop Unrolling.
   389 instructions added by Function Inlining (10 iterations).
     5 function calls inlined by Function Inlining.
     6 instructions updated by Jump Threading.
    16 instructions eliminated by Unreachable Code Elimination (2 iterations).
   999 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 693):
    Unroll loop at line 29:5                                     size   +69, benefit      350.0, efficiency      5.072
  * Unroll loop at line 30:9                                     size   +44, benefit     8750.0, efficiency    198.864 (+45 instructions)
    Inline function 'computeRowValues' defined at line 61:1      size  +473, benefit       27.5, efficiency      0.058
    Inline function call at line 138:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 139:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 140:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 141:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 142:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 169:22                          size   +79, benefit        1.3, efficiency      0.016
    Inline function call at line 170:22                          size   +79, benefit        1.3, efficiency      0.016

Pass 1: speed optimization selection (cost limit 648):
  * Unroll loop at line 29:5                                     size  +339, benefit      350.0, efficiency      1.032 (+337 instructions)
    Inline function 'computeRowValues' defined at line 61:1      size  +473, benefit       27.5, efficiency      0.058
    Inline function call at line 138:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 139:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 140:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 141:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 142:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 169:22                          size   +79, benefit        1.3, efficiency      0.016
    Inline function call at line 170:22                          size   +79, benefit        1.3, efficiency      0.016

Pass 1: speed optimization selection (cost limit 311):
  ! Inline function 'computeRowValues' defined at line 61:1      size  +473, benefit       27.5, efficiency      0.058
  * Inline function call at line 138:14                          size   +79, benefit        5.0, efficiency      0.063 (+74 instructions)
    Inline function call at line 139:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 140:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 141:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 142:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 169:22                          size   +79, benefit        1.3, efficiency      0.016
    Inline function call at line 170:22                          size   +79, benefit        1.3, efficiency      0.016

Pass 1: speed optimization selection (cost limit 237):
  ! Inline function 'computeRowValues' defined at line 61:1      size  +394, benefit       22.5, efficiency      0.057
  * Inline function call at line 139:14                          size   +79, benefit        5.0, efficiency      0.063 (+74 instructions)
    Inline function call at line 140:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 141:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 142:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 169:22                          size   +79, benefit        1.3, efficiency      0.016
    Inline function call at line 170:22                          size   +79, benefit        1.3, efficiency      0.016

Pass 1: speed optimization selection (cost limit 163):
  ! Inline function 'computeRowValues' defined at line 61:1      size  +315, benefit       17.5, efficiency      0.056
  * Inline function call at line 140:14                          size   +79, benefit        5.0, efficiency      0.063 (+74 instructions)
    Inline function call at line 141:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 142:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 169:22                          size   +79, benefit        1.3, efficiency      0.016
    Inline function call at line 170:22                          size   +79, benefit        1.3, efficiency      0.016

Pass 1: speed optimization selection (cost limit 89):
  ! Inline function 'computeRowValues' defined at line 61:1      size  +236, benefit       12.5, efficiency      0.053
  * Inline function call at line 141:14                          size   +79, benefit        5.0, efficiency      0.063 (+74 instructions)
    Inline function call at line 142:14                          size   +79, benefit        5.0, efficiency      0.063
    Inline function call at line 169:22                          size   +79, benefit        1.3, efficiency      0.016
    Inline function call at line 170:22                          size   +79, benefit        1.3, efficiency      0.016

Pass 1: speed optimization selection (cost limit 15):
  ! Inline function 'computeRowValues' defined at line 61:1      size  +157, benefit        7.5, efficiency      0.048
  ! Inline function call at line 142:14                          size   +79, benefit        5.0, efficiency      0.063
  ! Inline function call at line 169:22                          size   +79, benefit        1.3, efficiency      0.016
  ! Inline function call at line 170:22                          size   +79, benefit        1.3, efficiency      0.016

Pass 2: speed optimization selection (cost limit 78):
  ! Inline function 'computeRowValues' defined at line 61:1      size  +155, benefit        7.5, efficiency      0.048
  * Inline function call at line 142:14                          size   +78, benefit        5.0, efficiency      0.064 (+73 instructions)
    Inline function call at line 169:22                          size   +78, benefit        1.3, efficiency      0.016
    Inline function call at line 170:22                          size   +78, benefit        1.3, efficiency      0.016

Pass 2: speed optimization selection (cost limit 5):
  ! Inline function 'computeRowValues' defined at line 61:1      size   +77, benefit        2.5, efficiency      0.032
  ! Inline function call at line 169:22                          size   +78, benefit        1.3, efficiency      0.016
  ! Inline function call at line 170:22                          size   +78, benefit        1.3, efficiency      0.016

Pass 3: speed optimization selection (cost limit 5):
  ! Inline function 'computeRowValues' defined at line 61:1      size   +77, benefit        2.5, efficiency      0.032
  ! Inline function call at line 169:22                          size   +78, benefit        1.3, efficiency      0.016
  ! Inline function call at line 170:22                          size   +78, benefit        1.3, efficiency      0.016

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-54 instructions):
 
   257 label *label37
   258 set *tmp74 null
   259 label *label38
-    * set *tmp72 *tmp74
   260 jump *label36 always
   261 label *label35
-    * set *tmp72 null
   262 label *label36
   263 label *label34
   264 set :updatePosition.1:dx 0
 
   276 label *label42
   277 set *tmp78 null
   278 label *label43
-    * set *tmp76 *tmp78
   279 jump *label41 always
   280 label *label40
-    * set *tmp76 null
   281 label *label41
   282 label *label39
   283 set :updatePosition.2:dx 1
 
   295 label *label47
   296 set *tmp82 null
   297 label *label48
-    * set *tmp80 *tmp82
   298 jump *label46 always
   299 label *label45
-    * set *tmp80 null
   300 label *label46
   301 label *label44
   302 label *label33
 
   318 label *label53
   319 set *tmp87 null
   320 label *label54
-    * set *tmp85 *tmp87
   321 jump *label52 always
   322 label *label51
-    * set *tmp85 null
   323 label *label52
   324 label *label50
   325 set :updatePosition.4:dx 0
 
   337 label *label58
   338 set *tmp91 null
   339 label *label59
-    * set *tmp89 *tmp91
   340 jump *label57 always
   341 label *label56
-    * set *tmp89 null
   342 label *label57
   343 label *label55
   344 set :updatePosition.5:dx 1
 
   356 label *label63
   357 set *tmp95 null
   358 label *label64
-    * set *tmp93 *tmp95
   359 jump *label62 always
   360 label *label61
-    * set *tmp93 null
   361 label *label62
   362 label *label60
   363 label *label49
 
   379 label *label69
   380 set *tmp100 null
   381 label *label70
-    * set *tmp98 *tmp100
   382 jump *label68 always
   383 label *label67
-    * set *tmp98 null
   384 label *label68
   385 label *label66
   386 set :updatePosition.7:dx 0
 
   398 label *label74
   399 set *tmp104 null
   400 label *label75
-    * set *tmp102 *tmp104
   401 jump *label73 always
   402 label *label72
-    * set *tmp102 null
   403 label *label73
   404 label *label71
   405 set :updatePosition.8:dx 1
 
   417 label *label79
   418 set *tmp108 null
   419 label *label80
-    * set *tmp106 *tmp108
   420 jump *label78 always
   421 label *label77
-    * set *tmp106 null
   422 label *label78
   423 label *label76
   424 label *label65
-    * set *tmp63 null
   425 jump *label32 always
   426 label *label31
   427 op equal *tmp109 :findBestPosition:size 2
 
   434 set :findBestPosition:row3 *tmp113
   435 op add *tmp114 :findBestPosition:y4 :findBestPosition:y5
   436 set :findBestPosition:row4 *tmp114
-    * set *tmp110 :findBestPosition:row4
   437 jump *label82 always
   438 label *label81
   439 op sub *tmp115 :findBestPosition:y 3
 
   472 op add *tmp129 *tmp128 :findBestPosition:y5
   473 op add *tmp130 *tmp129 :findBestPosition:y6
   474 set :findBestPosition:row4 *tmp130
-    * set *tmp110 :findBestPosition:row4
   475 label *label82
   476 set :updateRowPositionsEven:dy -1.5
   477 set :updateRowPositionsEven:rowSum :findBestPosition:row1
 
   491 label *label89
   492 set *tmp134 null
   493 label *label90
-    * set *tmp132 *tmp134
   494 jump *label88 always
   495 label *label87
-    * set *tmp132 null
   496 label *label88
   497 label *label86
   498 set :updatePosition.10:dx -0.5
 
   510 label *label94
   511 set *tmp138 null
   512 label *label95
-    * set *tmp136 *tmp138
   513 jump *label93 always
   514 label *label92
-    * set *tmp136 null
   515 label *label93
   516 label *label91
   517 set :updatePosition.11:dx 0.5
 
   529 label *label99
   530 set *tmp142 null
   531 label *label100
-    * set *tmp140 *tmp142
   532 jump *label98 always
   533 label *label97
-    * set *tmp140 null
   534 label *label98
   535 label *label96
   536 set :updatePosition.12:dx 1.5
 
   548 label *label104
   549 set *tmp146 null
   550 label *label105
-    * set *tmp144 *tmp146
   551 jump *label103 always
   552 label *label102
-    * set *tmp144 null
   553 label *label103
   554 label *label101
   555 label *label85
 
   571 label *label110
   572 set *tmp150 null
   573 label *label111
-    * set *tmp148 *tmp150
   574 jump *label109 always
   575 label *label108
-    * set *tmp148 null
   576 label *label109
   577 label *label107
   578 set :updatePosition.14:dx -0.5
 
   590 label *label115
   591 set *tmp154 null
   592 label *label116
-    * set *tmp152 *tmp154
   593 jump *label114 always
   594 label *label113
-    * set *tmp152 null
   595 label *label114
   596 label *label112
   597 set :updatePosition.15:dx 0.5
 
   609 label *label120
   610 set *tmp158 null
   611 label *label121
-    * set *tmp156 *tmp158
   612 jump *label119 always
   613 label *label118
-    * set *tmp156 null
   614 label *label119
   615 label *label117
   616 set :updatePosition.16:dx 1.5
 
   628 label *label125
   629 set *tmp162 null
   630 label *label126
-    * set *tmp160 *tmp162
   631 jump *label124 always
   632 label *label123
-    * set *tmp160 null
   633 label *label124
   634 label *label122
   635 label *label106
 
   651 label *label131
   652 set *tmp166 null
   653 label *label132
-    * set *tmp164 *tmp166
   654 jump *label130 always
   655 label *label129
-    * set *tmp164 null
   656 label *label130
   657 label *label128
   658 set :updatePosition.18:dx -0.5
 
   670 label *label136
   671 set *tmp170 null
   672 label *label137
-    * set *tmp168 *tmp170
   673 jump *label135 always
   674 label *label134
-    * set *tmp168 null
   675 label *label135
   676 label *label133
   677 set :updatePosition.19:dx 0.5
 
   689 label *label141
   690 set *tmp174 null
   691 label *label142
-    * set *tmp172 *tmp174
   692 jump *label140 always
   693 label *label139
-    * set *tmp172 null
   694 label *label140
   695 label *label138
   696 set :updatePosition.20:dx 1.5
 
   708 label *label146
   709 set *tmp178 null
   710 label *label147
-    * set *tmp176 *tmp178
   711 jump *label145 always
   712 label *label144
-    * set *tmp176 null
   713 label *label145
   714 label *label143
   715 label *label127
 
   731 label *label152
   732 set *tmp182 null
   733 label *label153
-    * set *tmp180 *tmp182
   734 jump *label151 always
   735 label *label150
-    * set *tmp180 null
   736 label *label151
   737 label *label149
   738 set :updatePosition.22:dx -0.5
 
   750 label *label157
   751 set *tmp186 null
   752 label *label158
-    * set *tmp184 *tmp186
   753 jump *label156 always
   754 label *label155
-    * set *tmp184 null
   755 label *label156
   756 label *label154
   757 set :updatePosition.23:dx 0.5
 
   769 label *label162
   770 set *tmp190 null
   771 label *label163
-    * set *tmp188 *tmp190
   772 jump *label161 always
   773 label *label160
-    * set *tmp188 null
   774 label *label161
   775 label *label159
   776 set :updatePosition.24:dx 1.5
 
   788 label *label167
   789 set *tmp194 null
   790 label *label168
-    * set *tmp192 *tmp194
   791 jump *label166 always
   792 label *label165
-    * set *tmp192 null
   793 label *label166
   794 label *label164
   795 label *label148
-    * set *tmp63 null
   796 label *label32
   797 op mul *tmp195 :findBestPosition:best 255
   798 set :findBestPosition*retval *tmp195

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-50 instructions):
 
   252 set :findBestPosition:bestX :updatePosition:dx
   253 set :findBestPosition:bestY :updatePosition:dy
   254 set :findBestPosition:best :updatePosition:value
-    * set *tmp74 :findBestPosition:best
   255 jump *label38 always
   256 label *label37
-    * set *tmp74 null
   257 label *label38
   258 jump *label36 always
   259 label *label35
 
   269 set :findBestPosition:bestX :updatePosition.1:dx
   270 set :findBestPosition:bestY :updatePosition.1:dy
   271 set :findBestPosition:best :updatePosition.1:value
-    * set *tmp78 :findBestPosition:best
   272 jump *label43 always
   273 label *label42
-    * set *tmp78 null
   274 label *label43
   275 jump *label41 always
   276 label *label40
 
   286 set :findBestPosition:bestX :updatePosition.2:dx
   287 set :findBestPosition:bestY :updatePosition.2:dy
   288 set :findBestPosition:best :updatePosition.2:value
-    * set *tmp82 :findBestPosition:best
   289 jump *label48 always
   290 label *label47
-    * set *tmp82 null
   291 label *label48
   292 jump *label46 always
   293 label *label45
 
   307 set :findBestPosition:bestX :updatePosition.3:dx
   308 set :findBestPosition:bestY :updatePosition.3:dy
   309 set :findBestPosition:best :updatePosition.3:value
-    * set *tmp87 :findBestPosition:best
   310 jump *label54 always
   311 label *label53
-    * set *tmp87 null
   312 label *label54
   313 jump *label52 always
   314 label *label51
 
   324 set :findBestPosition:bestX :updatePosition.4:dx
   325 set :findBestPosition:bestY :updatePosition.4:dy
   326 set :findBestPosition:best :updatePosition.4:value
-    * set *tmp91 :findBestPosition:best
   327 jump *label59 always
   328 label *label58
-    * set *tmp91 null
   329 label *label59
   330 jump *label57 always
   331 label *label56
 
   341 set :findBestPosition:bestX :updatePosition.5:dx
   342 set :findBestPosition:bestY :updatePosition.5:dy
   343 set :findBestPosition:best :updatePosition.5:value
-    * set *tmp95 :findBestPosition:best
   344 jump *label64 always
   345 label *label63
-    * set *tmp95 null
   346 label *label64
   347 jump *label62 always
   348 label *label61
 
   362 set :findBestPosition:bestX :updatePosition.6:dx
   363 set :findBestPosition:bestY :updatePosition.6:dy
   364 set :findBestPosition:best :updatePosition.6:value
-    * set *tmp100 :findBestPosition:best
   365 jump *label70 always
   366 label *label69
-    * set *tmp100 null
   367 label *label70
   368 jump *label68 always
   369 label *label67
 
   379 set :findBestPosition:bestX :updatePosition.7:dx
   380 set :findBestPosition:bestY :updatePosition.7:dy
   381 set :findBestPosition:best :updatePosition.7:value
-    * set *tmp104 :findBestPosition:best
   382 jump *label75 always
   383 label *label74
-    * set *tmp104 null
   384 label *label75
   385 jump *label73 always
   386 label *label72
 
   396 set :findBestPosition:bestX :updatePosition.8:dx
   397 set :findBestPosition:bestY :updatePosition.8:dy
   398 set :findBestPosition:best :updatePosition.8:value
-    * set *tmp108 :findBestPosition:best
   399 jump *label80 always
   400 label *label79
-    * set *tmp108 null
   401 label *label80
   402 jump *label78 always
   403 label *label77
 
   468 set :findBestPosition:bestX :updatePosition.9:dx
   469 set :findBestPosition:bestY :updatePosition.9:dy
   470 set :findBestPosition:best :updatePosition.9:value
-    * set *tmp134 :findBestPosition:best
   471 jump *label90 always
   472 label *label89
-    * set *tmp134 null
   473 label *label90
   474 jump *label88 always
   475 label *label87
 
   485 set :findBestPosition:bestX :updatePosition.10:dx
   486 set :findBestPosition:bestY :updatePosition.10:dy
   487 set :findBestPosition:best :updatePosition.10:value
-    * set *tmp138 :findBestPosition:best
   488 jump *label95 always
   489 label *label94
-    * set *tmp138 null
   490 label *label95
   491 jump *label93 always
   492 label *label92
 
   502 set :findBestPosition:bestX :updatePosition.11:dx
   503 set :findBestPosition:bestY :updatePosition.11:dy
   504 set :findBestPosition:best :updatePosition.11:value
-    * set *tmp142 :findBestPosition:best
   505 jump *label100 always
   506 label *label99
-    * set *tmp142 null
   507 label *label100
   508 jump *label98 always
   509 label *label97
 
   519 set :findBestPosition:bestX :updatePosition.12:dx
   520 set :findBestPosition:bestY :updatePosition.12:dy
   521 set :findBestPosition:best :updatePosition.12:value
-    * set *tmp146 :findBestPosition:best
   522 jump *label105 always
   523 label *label104
-    * set *tmp146 null
   524 label *label105
   525 jump *label103 always
   526 label *label102
 
   540 set :findBestPosition:bestX :updatePosition.13:dx
   541 set :findBestPosition:bestY :updatePosition.13:dy
   542 set :findBestPosition:best :updatePosition.13:value
-    * set *tmp150 :findBestPosition:best
   543 jump *label111 always
   544 label *label110
-    * set *tmp150 null
   545 label *label111
   546 jump *label109 always
   547 label *label108
 
   557 set :findBestPosition:bestX :updatePosition.14:dx
   558 set :findBestPosition:bestY :updatePosition.14:dy
   559 set :findBestPosition:best :updatePosition.14:value
-    * set *tmp154 :findBestPosition:best
   560 jump *label116 always
   561 label *label115
-    * set *tmp154 null
   562 label *label116
   563 jump *label114 always
   564 label *label113
 
   574 set :findBestPosition:bestX :updatePosition.15:dx
   575 set :findBestPosition:bestY :updatePosition.15:dy
   576 set :findBestPosition:best :updatePosition.15:value
-    * set *tmp158 :findBestPosition:best
   577 jump *label121 always
   578 label *label120
-    * set *tmp158 null
   579 label *label121
   580 jump *label119 always
   581 label *label118
 
   591 set :findBestPosition:bestX :updatePosition.16:dx
   592 set :findBestPosition:bestY :updatePosition.16:dy
   593 set :findBestPosition:best :updatePosition.16:value
-    * set *tmp162 :findBestPosition:best
   594 jump *label126 always
   595 label *label125
-    * set *tmp162 null
   596 label *label126
   597 jump *label124 always
   598 label *label123
 
   612 set :findBestPosition:bestX :updatePosition.17:dx
   613 set :findBestPosition:bestY :updatePosition.17:dy
   614 set :findBestPosition:best :updatePosition.17:value
-    * set *tmp166 :findBestPosition:best
   615 jump *label132 always
   616 label *label131
-    * set *tmp166 null
   617 label *label132
   618 jump *label130 always
   619 label *label129
 
   629 set :findBestPosition:bestX :updatePosition.18:dx
   630 set :findBestPosition:bestY :updatePosition.18:dy
   631 set :findBestPosition:best :updatePosition.18:value
-    * set *tmp170 :findBestPosition:best
   632 jump *label137 always
   633 label *label136
-    * set *tmp170 null
   634 label *label137
   635 jump *label135 always
   636 label *label134
 
   646 set :findBestPosition:bestX :updatePosition.19:dx
   647 set :findBestPosition:bestY :updatePosition.19:dy
   648 set :findBestPosition:best :updatePosition.19:value
-    * set *tmp174 :findBestPosition:best
   649 jump *label142 always
   650 label *label141
-    * set *tmp174 null
   651 label *label142
   652 jump *label140 always
   653 label *label139
 
   663 set :findBestPosition:bestX :updatePosition.20:dx
   664 set :findBestPosition:bestY :updatePosition.20:dy
   665 set :findBestPosition:best :updatePosition.20:value
-    * set *tmp178 :findBestPosition:best
   666 jump *label147 always
   667 label *label146
-    * set *tmp178 null
   668 label *label147
   669 jump *label145 always
   670 label *label144
 
   684 set :findBestPosition:bestX :updatePosition.21:dx
   685 set :findBestPosition:bestY :updatePosition.21:dy
   686 set :findBestPosition:best :updatePosition.21:value
-    * set *tmp182 :findBestPosition:best
   687 jump *label153 always
   688 label *label152
-    * set *tmp182 null
   689 label *label153
   690 jump *label151 always
   691 label *label150
 
   701 set :findBestPosition:bestX :updatePosition.22:dx
   702 set :findBestPosition:bestY :updatePosition.22:dy
   703 set :findBestPosition:best :updatePosition.22:value
-    * set *tmp186 :findBestPosition:best
   704 jump *label158 always
   705 label *label157
-    * set *tmp186 null
   706 label *label158
   707 jump *label156 always
   708 label *label155
 
   718 set :findBestPosition:bestX :updatePosition.23:dx
   719 set :findBestPosition:bestY :updatePosition.23:dy
   720 set :findBestPosition:best :updatePosition.23:value
-    * set *tmp190 :findBestPosition:best
   721 jump *label163 always
   722 label *label162
-    * set *tmp190 null
   723 label *label163
   724 jump *label161 always
   725 label *label160
 
   735 set :findBestPosition:bestX :updatePosition.24:dx
   736 set :findBestPosition:bestY :updatePosition.24:dy
   737 set :findBestPosition:best :updatePosition.24:value
-    * set *tmp194 :findBestPosition:best
   738 jump *label168 always
   739 label *label167
-    * set *tmp194 null
   740 label *label168
   741 jump *label166 always
   742 label *label165

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-30 instructions):
 
    25 select :isSolid:result notEqual solid false 1 0
    26 set *tmp3 :isSolid:result
    27 label *label12
-    * op or *tmp4 *tmp0 *tmp3
-    * set :createTerrainMask:result *tmp4
+   28 op or :createTerrainMask:result *tmp0 *tmp3
    29 label *label10
    30 op sub :createTerrainMask:c :createTerrainMask:c 1
    31 jump *label9 always
 
    42 jump *label4 always
    43 end
    44 label *label2
-    * op sub *tmp5 :computeRowValues:x 2
-    * set :tileValue:x *tmp5
+   45 op sub :tileValue:x :computeRowValues:x 2
    46 set :tileValue:y :computeRowValues:y
    47 set :tileValue:ore :computeRowValues:ore
    48 ucontrol getBlock :tileValue:x :tileValue:y type building floor
 
    52 set *tmp6 :tileValue:result
    53 label *label14
    54 set :computeRowValues:x1 *tmp6
-    * op sub *tmp7 :computeRowValues:x 1
-    * set :tileValue.1:x *tmp7
+   55 op sub :tileValue.1:x :computeRowValues:x 1
    56 set :tileValue.1:y :computeRowValues:y
    57 set :tileValue.1:ore :computeRowValues:ore
    58 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
 
    62 set *tmp8 :tileValue.1:result
    63 label *label15
    64 set :computeRowValues:x2 *tmp8
-    * op add *tmp9 :computeRowValues:x 0
-    * set :tileValue.2:x *tmp9
+   65 op add :tileValue.2:x :computeRowValues:x 0
    66 set :tileValue.2:y :computeRowValues:y
    67 set :tileValue.2:ore :computeRowValues:ore
    68 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
 
    72 set *tmp10 :tileValue.2:result
    73 label *label16
    74 set :computeRowValues:x3 *tmp10
-    * op add *tmp11 :computeRowValues:x 1
-    * set :tileValue.3:x *tmp11
+   75 op add :tileValue.3:x :computeRowValues:x 1
    76 set :tileValue.3:y :computeRowValues:y
    77 set :tileValue.3:ore :computeRowValues:ore
    78 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
 
    82 set *tmp12 :tileValue.3:result
    83 label *label17
    84 set :computeRowValues:x4 *tmp12
-    * op add *tmp13 :computeRowValues:x 2
-    * set :tileValue.4:x *tmp13
+   85 op add :tileValue.4:x :computeRowValues:x 2
    86 set :tileValue.4:y :computeRowValues:y
    87 set :tileValue.4:ore :computeRowValues:ore
    88 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
 
    98 op add *tmp18 :computeRowValues:x2 :computeRowValues:x3
    99 op add *tmp19 :computeRowValues:x3 :computeRowValues:x4
   100 op add *tmp20 :computeRowValues:x4 :computeRowValues:x5
-    * packcolor *tmp21 *tmp17 *tmp18 *tmp19 *tmp20
-    * set :computeRowValues*retval *tmp21
+  101 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
   102 jump *label13 always
   103 set *tmp16 null
   104 jump *label20 always
 
   111 op add *tmp27 *tmp26 :computeRowValues:x4
   112 op add *tmp28 :computeRowValues:x3 :computeRowValues:x4
   113 op add *tmp29 *tmp28 :computeRowValues:x5
-    * packcolor *tmp30 *tmp25 *tmp27 *tmp29 0
-    * set :computeRowValues*retval *tmp30
+  114 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
   115 jump *label13 always
   116 set *tmp23 null
   117 jump *label22 always
   118 label *label21
-    * op sub *tmp31 :computeRowValues:x 3
-    * set :tileValue.5:x *tmp31
+  119 op sub :tileValue.5:x :computeRowValues:x 3
   120 set :tileValue.5:y :computeRowValues:y
   121 set :tileValue.5:ore :computeRowValues:ore
   122 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
 
   126 set *tmp32 :tileValue.5:result
   127 label *label23
   128 set :computeRowValues:x0 *tmp32
-    * op add *tmp33 :computeRowValues:x 3
-    * set :tileValue.6:x *tmp33
+  129 op add :tileValue.6:x :computeRowValues:x 3
   130 set :tileValue.6:y :computeRowValues:y
   131 set :tileValue.6:ore :computeRowValues:ore
   132 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
 
   152 op add *tmp48 *tmp47 :computeRowValues:x5
   153 op add *tmp49 *tmp48 :computeRowValues:x6
   154 op min *tmp50 0.09803921568627451 *tmp49
-    * packcolor *tmp51 *tmp38 *tmp42 *tmp46 *tmp50
-    * set :computeRowValues*retval *tmp51
+  155 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
   156 jump *label13 always
   157 set *tmp23 null
   158 label *label22
 
   172 setaddr :computeRowValues*retaddr *label26 (h:*label26)
   173 call *label2 *invalid :computeRowValues*retval (m:*label26) (h:*label26)
   174 label *label26
-    * set *tmp53 :computeRowValues*retval
-    * set :findBestPosition:y1 *tmp53
+  175 set :findBestPosition:y1 :computeRowValues*retval
   176 op sub *tmp54 :findBestPosition:y 1
   177 set :computeRowValues:x :findBestPosition:x
   178 set :computeRowValues:y *tmp54
 
   181 setaddr :computeRowValues*retaddr *label27 (h:*label27)
   182 call *label2 *invalid :computeRowValues*retval (m:*label27) (h:*label27)
   183 label *label27
-    * set *tmp55 :computeRowValues*retval
-    * set :findBestPosition:y2 *tmp55
+  184 set :findBestPosition:y2 :computeRowValues*retval
   185 op add *tmp56 :findBestPosition:y 0
   186 set :computeRowValues:x :findBestPosition:x
   187 set :computeRowValues:y *tmp56
 
   190 setaddr :computeRowValues*retaddr *label28 (h:*label28)
   191 call *label2 *invalid :computeRowValues*retval (m:*label28) (h:*label28)
   192 label *label28
-    * set *tmp57 :computeRowValues*retval
-    * set :findBestPosition:y3 *tmp57
+  193 set :findBestPosition:y3 :computeRowValues*retval
   194 op add *tmp58 :findBestPosition:y 1
   195 set :computeRowValues:x :findBestPosition:x
   196 set :computeRowValues:y *tmp58
 
   199 setaddr :computeRowValues*retaddr *label29 (h:*label29)
   200 call *label2 *invalid :computeRowValues*retval (m:*label29) (h:*label29)
   201 label *label29
-    * set *tmp59 :computeRowValues*retval
-    * set :findBestPosition:y4 *tmp59
+  202 set :findBestPosition:y4 :computeRowValues*retval
   203 op add *tmp60 :findBestPosition:y 2
   204 set :computeRowValues:x :findBestPosition:x
   205 set :computeRowValues:y *tmp60
 
   208 setaddr :computeRowValues*retaddr *label30 (h:*label30)
   209 call *label2 *invalid :computeRowValues*retval (m:*label30) (h:*label30)
   210 label *label30
-    * set *tmp61 :computeRowValues*retval
-    * set :findBestPosition:y5 *tmp61
+  211 set :findBestPosition:y5 :computeRowValues*retval
   212 set :findBestPosition:best 0
   213 set :findBestPosition:bestX 0
   214 set :findBestPosition:bestY 0
   215 op equal *tmp62 :findBestPosition:size 3
   216 jump *label31 equal *tmp62 false
   217 op add *tmp64 :findBestPosition:y2 :findBestPosition:y3
-    * op add *tmp65 :findBestPosition:y1 *tmp64
-    * set :findBestPosition:row1 *tmp65
+  218 op add :findBestPosition:row1 :findBestPosition:y1 *tmp64
   219 op add *tmp66 :findBestPosition:y2 :findBestPosition:y3
-    * op add *tmp67 *tmp66 :findBestPosition:y4
-    * set :findBestPosition:row2 *tmp67
+  220 op add :findBestPosition:row2 *tmp66 :findBestPosition:y4
   221 op add *tmp68 :findBestPosition:y3 :findBestPosition:y4
-    * op add *tmp69 *tmp68 :findBestPosition:y5
-    * set :findBestPosition:row3 *tmp69
+  222 op add :findBestPosition:row3 *tmp68 :findBestPosition:y5
   223 set :updateRowPositionsOdd:dy -1
   224 set :updateRowPositionsOdd:rowSum :findBestPosition:row1
   225 unpackcolor :updateRowPositionsOdd:col1 :updateRowPositionsOdd:col2 :updateRowPositionsOdd:col3 *tmp70 :updateRowPositionsOdd:rowSum
 
   389 label *label31
   390 op equal *tmp109 :findBestPosition:size 2
   391 jump *label81 equal *tmp109 false
-    * op add *tmp111 :findBestPosition:y1 :findBestPosition:y2
-    * set :findBestPosition:row1 *tmp111
-    * op add *tmp112 :findBestPosition:y2 :findBestPosition:y3
-    * set :findBestPosition:row2 *tmp112
-    * op add *tmp113 :findBestPosition:y3 :findBestPosition:y4
-    * set :findBestPosition:row3 *tmp113
-    * op add *tmp114 :findBestPosition:y4 :findBestPosition:y5
-    * set :findBestPosition:row4 *tmp114
+  392 op add :findBestPosition:row1 :findBestPosition:y1 :findBestPosition:y2
+  393 op add :findBestPosition:row2 :findBestPosition:y2 :findBestPosition:y3
+  394 op add :findBestPosition:row3 :findBestPosition:y3 :findBestPosition:y4
+  395 op add :findBestPosition:row4 :findBestPosition:y4 :findBestPosition:y5
   396 jump *label82 always
   397 label *label81
   398 op sub *tmp115 :findBestPosition:y 3
 
   403 setaddr :computeRowValues*retaddr *label83 (h:*label83)
   404 call *label2 *invalid :computeRowValues*retval (m:*label83) (h:*label83)
   405 label *label83
-    * set *tmp116 :computeRowValues*retval
-    * set :findBestPosition:y0 *tmp116
+  406 set :findBestPosition:y0 :computeRowValues*retval
   407 op add *tmp117 :findBestPosition:y 3
   408 set :computeRowValues:x :findBestPosition:x
   409 set :computeRowValues:y *tmp117
 
   412 setaddr :computeRowValues*retaddr *label84 (h:*label84)
   413 call *label2 *invalid :computeRowValues*retval (m:*label84) (h:*label84)
   414 label *label84
-    * set *tmp118 :computeRowValues*retval
-    * set :findBestPosition:y6 *tmp118
+  415 set :findBestPosition:y6 :computeRowValues*retval
   416 op add *tmp119 :findBestPosition:y1 :findBestPosition:y2
   417 op add *tmp120 *tmp119 :findBestPosition:y3
-    * op add *tmp121 :findBestPosition:y0 *tmp120
-    * set :findBestPosition:row1 *tmp121
+  418 op add :findBestPosition:row1 :findBestPosition:y0 *tmp120
   419 op add *tmp122 :findBestPosition:y1 :findBestPosition:y2
   420 op add *tmp123 *tmp122 :findBestPosition:y3
-    * op add *tmp124 *tmp123 :findBestPosition:y4
-    * set :findBestPosition:row2 *tmp124
+  421 op add :findBestPosition:row2 *tmp123 :findBestPosition:y4
   422 op add *tmp125 :findBestPosition:y3 :findBestPosition:y4
   423 op add *tmp126 *tmp125 :findBestPosition:y5
-    * op add *tmp127 :findBestPosition:y2 *tmp126
-    * set :findBestPosition:row3 *tmp127
+  424 op add :findBestPosition:row3 :findBestPosition:y2 *tmp126
   425 op add *tmp128 :findBestPosition:y3 :findBestPosition:y4
   426 op add *tmp129 *tmp128 :findBestPosition:y5
-    * op add *tmp130 *tmp129 :findBestPosition:y6
-    * set :findBestPosition:row4 *tmp130
+  427 op add :findBestPosition:row4 *tmp129 :findBestPosition:y6
   428 label *label82
   429 set :updateRowPositionsEven:dy -1.5
   430 set :updateRowPositionsEven:rowSum :findBestPosition:row1
 
   715 label *label164
   716 label *label148
   717 label *label32
-    * op mul *tmp195 :findBestPosition:best 255
-    * set :findBestPosition*retval *tmp195
+  718 op mul :findBestPosition*retval :findBestPosition:best 255
   719 jump *label25 always
   720 set :findBestPosition*retval null
   721 label *label25

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-54 instructions):
 
    92 set *tmp14 :tileValue.4:result
    93 label *label18
    94 set :computeRowValues:x5 *tmp14
-    * op equal *tmp15 :computeRowValues:size 2
-    * jump *label19 equal *tmp15 false
+   95 jump *label19 notEqual :computeRowValues:size 2
    96 op add *tmp17 :computeRowValues:x1 :computeRowValues:x2
    97 op add *tmp18 :computeRowValues:x2 :computeRowValues:x3
    98 op add *tmp19 :computeRowValues:x3 :computeRowValues:x4
 
   102 set *tmp16 null
   103 jump *label20 always
   104 label *label19
-    * op equal *tmp22 :computeRowValues:size 3
-    * jump *label21 equal *tmp22 false
+  105 jump *label21 notEqual :computeRowValues:size 3
   106 op add *tmp24 :computeRowValues:x2 :computeRowValues:x3
   107 op add *tmp25 :computeRowValues:x1 *tmp24
   108 op add *tmp26 :computeRowValues:x2 :computeRowValues:x3
 
   210 set :findBestPosition:best 0
   211 set :findBestPosition:bestX 0
   212 set :findBestPosition:bestY 0
-    * op equal *tmp62 :findBestPosition:size 3
-    * jump *label31 equal *tmp62 false
+  213 jump *label31 notEqual :findBestPosition:size 3
   214 op add *tmp64 :findBestPosition:y2 :findBestPosition:y3
   215 op add :findBestPosition:row1 :findBestPosition:y1 *tmp64
   216 op add *tmp66 :findBestPosition:y2 :findBestPosition:y3
 
   223 set :updatePosition:dx -1
   224 set :updatePosition:dy :updateRowPositionsOdd:dy
   225 set :updatePosition:value :updateRowPositionsOdd:col1
-    * op greaterThan *tmp71 :updatePosition:value :findBestPosition:best
-    * jump *label35 equal *tmp71 false
-    * op lessThan *tmp73 :updatePosition:value 0.0784313725490196
-    * jump *label37 equal *tmp73 false
+  226 jump *label35 lessThanEq :updatePosition:value :findBestPosition:best
+  227 jump *label37 greaterThanEq :updatePosition:value 0.0784313725490196
   228 set :findBestPosition:bestX :updatePosition:dx
   229 set :findBestPosition:bestY :updatePosition:dy
   230 set :findBestPosition:best :updatePosition:value
 
   238 set :updatePosition.1:dx 0
   239 set :updatePosition.1:dy :updateRowPositionsOdd:dy
   240 set :updatePosition.1:value :updateRowPositionsOdd:col2
-    * op greaterThan *tmp75 :updatePosition.1:value :findBestPosition:best
-    * jump *label40 equal *tmp75 false
-    * op lessThan *tmp77 :updatePosition.1:value 0.0784313725490196
-    * jump *label42 equal *tmp77 false
+  241 jump *label40 lessThanEq :updatePosition.1:value :findBestPosition:best
+  242 jump *label42 greaterThanEq :updatePosition.1:value 0.0784313725490196
   243 set :findBestPosition:bestX :updatePosition.1:dx
   244 set :findBestPosition:bestY :updatePosition.1:dy
   245 set :findBestPosition:best :updatePosition.1:value
 
   253 set :updatePosition.2:dx 1
   254 set :updatePosition.2:dy :updateRowPositionsOdd:dy
   255 set :updatePosition.2:value :updateRowPositionsOdd:col3
-    * op greaterThan *tmp79 :updatePosition.2:value :findBestPosition:best
-    * jump *label45 equal *tmp79 false
-    * op lessThan *tmp81 :updatePosition.2:value 0.0784313725490196
-    * jump *label47 equal *tmp81 false
+  256 jump *label45 lessThanEq :updatePosition.2:value :findBestPosition:best
+  257 jump *label47 greaterThanEq :updatePosition.2:value 0.0784313725490196
   258 set :findBestPosition:bestX :updatePosition.2:dx
   259 set :findBestPosition:bestY :updatePosition.2:dy
   260 set :findBestPosition:best :updatePosition.2:value
 
   272 set :updatePosition.3:dx -1
   273 set :updatePosition.3:dy :updateRowPositionsOdd.1:dy
   274 set :updatePosition.3:value :updateRowPositionsOdd.1:col1
-    * op greaterThan *tmp84 :updatePosition.3:value :findBestPosition:best
-    * jump *label51 equal *tmp84 false
-    * op lessThan *tmp86 :updatePosition.3:value 0.0784313725490196
-    * jump *label53 equal *tmp86 false
+  275 jump *label51 lessThanEq :updatePosition.3:value :findBestPosition:best
+  276 jump *label53 greaterThanEq :updatePosition.3:value 0.0784313725490196
   277 set :findBestPosition:bestX :updatePosition.3:dx
   278 set :findBestPosition:bestY :updatePosition.3:dy
   279 set :findBestPosition:best :updatePosition.3:value
 
   287 set :updatePosition.4:dx 0
   288 set :updatePosition.4:dy :updateRowPositionsOdd.1:dy
   289 set :updatePosition.4:value :updateRowPositionsOdd.1:col2
-    * op greaterThan *tmp88 :updatePosition.4:value :findBestPosition:best
-    * jump *label56 equal *tmp88 false
-    * op lessThan *tmp90 :updatePosition.4:value 0.0784313725490196
-    * jump *label58 equal *tmp90 false
+  290 jump *label56 lessThanEq :updatePosition.4:value :findBestPosition:best
+  291 jump *label58 greaterThanEq :updatePosition.4:value 0.0784313725490196
   292 set :findBestPosition:bestX :updatePosition.4:dx
   293 set :findBestPosition:bestY :updatePosition.4:dy
   294 set :findBestPosition:best :updatePosition.4:value
 
   302 set :updatePosition.5:dx 1
   303 set :updatePosition.5:dy :updateRowPositionsOdd.1:dy
   304 set :updatePosition.5:value :updateRowPositionsOdd.1:col3
-    * op greaterThan *tmp92 :updatePosition.5:value :findBestPosition:best
-    * jump *label61 equal *tmp92 false
-    * op lessThan *tmp94 :updatePosition.5:value 0.0784313725490196
-    * jump *label63 equal *tmp94 false
+  305 jump *label61 lessThanEq :updatePosition.5:value :findBestPosition:best
+  306 jump *label63 greaterThanEq :updatePosition.5:value 0.0784313725490196
   307 set :findBestPosition:bestX :updatePosition.5:dx
   308 set :findBestPosition:bestY :updatePosition.5:dy
   309 set :findBestPosition:best :updatePosition.5:value
 
   321 set :updatePosition.6:dx -1
   322 set :updatePosition.6:dy :updateRowPositionsOdd.2:dy
   323 set :updatePosition.6:value :updateRowPositionsOdd.2:col1
-    * op greaterThan *tmp97 :updatePosition.6:value :findBestPosition:best
-    * jump *label67 equal *tmp97 false
-    * op lessThan *tmp99 :updatePosition.6:value 0.0784313725490196
-    * jump *label69 equal *tmp99 false
+  324 jump *label67 lessThanEq :updatePosition.6:value :findBestPosition:best
+  325 jump *label69 greaterThanEq :updatePosition.6:value 0.0784313725490196
   326 set :findBestPosition:bestX :updatePosition.6:dx
   327 set :findBestPosition:bestY :updatePosition.6:dy
   328 set :findBestPosition:best :updatePosition.6:value
 
   336 set :updatePosition.7:dx 0
   337 set :updatePosition.7:dy :updateRowPositionsOdd.2:dy
   338 set :updatePosition.7:value :updateRowPositionsOdd.2:col2
-    * op greaterThan *tmp101 :updatePosition.7:value :findBestPosition:best
-    * jump *label72 equal *tmp101 false
-    * op lessThan *tmp103 :updatePosition.7:value 0.0784313725490196
-    * jump *label74 equal *tmp103 false
+  339 jump *label72 lessThanEq :updatePosition.7:value :findBestPosition:best
+  340 jump *label74 greaterThanEq :updatePosition.7:value 0.0784313725490196
   341 set :findBestPosition:bestX :updatePosition.7:dx
   342 set :findBestPosition:bestY :updatePosition.7:dy
   343 set :findBestPosition:best :updatePosition.7:value
 
   351 set :updatePosition.8:dx 1
   352 set :updatePosition.8:dy :updateRowPositionsOdd.2:dy
   353 set :updatePosition.8:value :updateRowPositionsOdd.2:col3
-    * op greaterThan *tmp105 :updatePosition.8:value :findBestPosition:best
-    * jump *label77 equal *tmp105 false
-    * op lessThan *tmp107 :updatePosition.8:value 0.0784313725490196
-    * jump *label79 equal *tmp107 false
+  354 jump *label77 lessThanEq :updatePosition.8:value :findBestPosition:best
+  355 jump *label79 greaterThanEq :updatePosition.8:value 0.0784313725490196
   356 set :findBestPosition:bestX :updatePosition.8:dx
   357 set :findBestPosition:bestY :updatePosition.8:dy
   358 set :findBestPosition:best :updatePosition.8:value
 
   366 label *label65
   367 jump *label32 always
   368 label *label31
-    * op equal *tmp109 :findBestPosition:size 2
-    * jump *label81 equal *tmp109 false
+  369 jump *label81 notEqual :findBestPosition:size 2
   370 op add :findBestPosition:row1 :findBestPosition:y1 :findBestPosition:y2
   371 op add :findBestPosition:row2 :findBestPosition:y2 :findBestPosition:y3
   372 op add :findBestPosition:row3 :findBestPosition:y3 :findBestPosition:y4
 
   410 set :updatePosition.9:dx -1.5
   411 set :updatePosition.9:dy :updateRowPositionsEven:dy
   412 set :updatePosition.9:value :updateRowPositionsEven:col1
-    * op greaterThan *tmp131 :updatePosition.9:value :findBestPosition:best
-    * jump *label87 equal *tmp131 false
-    * op lessThan *tmp133 :updatePosition.9:value 0.0784313725490196
-    * jump *label89 equal *tmp133 false
+  413 jump *label87 lessThanEq :updatePosition.9:value :findBestPosition:best
+  414 jump *label89 greaterThanEq :updatePosition.9:value 0.0784313725490196
   415 set :findBestPosition:bestX :updatePosition.9:dx
   416 set :findBestPosition:bestY :updatePosition.9:dy
   417 set :findBestPosition:best :updatePosition.9:value
 
   425 set :updatePosition.10:dx -0.5
   426 set :updatePosition.10:dy :updateRowPositionsEven:dy
   427 set :updatePosition.10:value :updateRowPositionsEven:col2
-    * op greaterThan *tmp135 :updatePosition.10:value :findBestPosition:best
-    * jump *label92 equal *tmp135 false
-    * op lessThan *tmp137 :updatePosition.10:value 0.0784313725490196
-    * jump *label94 equal *tmp137 false
+  428 jump *label92 lessThanEq :updatePosition.10:value :findBestPosition:best
+  429 jump *label94 greaterThanEq :updatePosition.10:value 0.0784313725490196
   430 set :findBestPosition:bestX :updatePosition.10:dx
   431 set :findBestPosition:bestY :updatePosition.10:dy
   432 set :findBestPosition:best :updatePosition.10:value
 
   440 set :updatePosition.11:dx 0.5
   441 set :updatePosition.11:dy :updateRowPositionsEven:dy
   442 set :updatePosition.11:value :updateRowPositionsEven:col3
-    * op greaterThan *tmp139 :updatePosition.11:value :findBestPosition:best
-    * jump *label97 equal *tmp139 false
-    * op lessThan *tmp141 :updatePosition.11:value 0.0784313725490196
-    * jump *label99 equal *tmp141 false
+  443 jump *label97 lessThanEq :updatePosition.11:value :findBestPosition:best
+  444 jump *label99 greaterThanEq :updatePosition.11:value 0.0784313725490196
   445 set :findBestPosition:bestX :updatePosition.11:dx
   446 set :findBestPosition:bestY :updatePosition.11:dy
   447 set :findBestPosition:best :updatePosition.11:value
 
   455 set :updatePosition.12:dx 1.5
   456 set :updatePosition.12:dy :updateRowPositionsEven:dy
   457 set :updatePosition.12:value :updateRowPositionsEven:col4
-    * op greaterThan *tmp143 :updatePosition.12:value :findBestPosition:best
-    * jump *label102 equal *tmp143 false
-    * op lessThan *tmp145 :updatePosition.12:value 0.0784313725490196
-    * jump *label104 equal *tmp145 false
+  458 jump *label102 lessThanEq :updatePosition.12:value :findBestPosition:best
+  459 jump *label104 greaterThanEq :updatePosition.12:value 0.0784313725490196
   460 set :findBestPosition:bestX :updatePosition.12:dx
   461 set :findBestPosition:bestY :updatePosition.12:dy
   462 set :findBestPosition:best :updatePosition.12:value
 
   474 set :updatePosition.13:dx -1.5
   475 set :updatePosition.13:dy :updateRowPositionsEven.1:dy
   476 set :updatePosition.13:value :updateRowPositionsEven.1:col1
-    * op greaterThan *tmp147 :updatePosition.13:value :findBestPosition:best
-    * jump *label108 equal *tmp147 false
-    * op lessThan *tmp149 :updatePosition.13:value 0.0784313725490196
-    * jump *label110 equal *tmp149 false
+  477 jump *label108 lessThanEq :updatePosition.13:value :findBestPosition:best
+  478 jump *label110 greaterThanEq :updatePosition.13:value 0.0784313725490196
   479 set :findBestPosition:bestX :updatePosition.13:dx
   480 set :findBestPosition:bestY :updatePosition.13:dy
   481 set :findBestPosition:best :updatePosition.13:value
 
   489 set :updatePosition.14:dx -0.5
   490 set :updatePosition.14:dy :updateRowPositionsEven.1:dy
   491 set :updatePosition.14:value :updateRowPositionsEven.1:col2
-    * op greaterThan *tmp151 :updatePosition.14:value :findBestPosition:best
-    * jump *label113 equal *tmp151 false
-    * op lessThan *tmp153 :updatePosition.14:value 0.0784313725490196
-    * jump *label115 equal *tmp153 false
+  492 jump *label113 lessThanEq :updatePosition.14:value :findBestPosition:best
+  493 jump *label115 greaterThanEq :updatePosition.14:value 0.0784313725490196
   494 set :findBestPosition:bestX :updatePosition.14:dx
   495 set :findBestPosition:bestY :updatePosition.14:dy
   496 set :findBestPosition:best :updatePosition.14:value
 
   504 set :updatePosition.15:dx 0.5
   505 set :updatePosition.15:dy :updateRowPositionsEven.1:dy
   506 set :updatePosition.15:value :updateRowPositionsEven.1:col3
-    * op greaterThan *tmp155 :updatePosition.15:value :findBestPosition:best
-    * jump *label118 equal *tmp155 false
-    * op lessThan *tmp157 :updatePosition.15:value 0.0784313725490196
-    * jump *label120 equal *tmp157 false
+  507 jump *label118 lessThanEq :updatePosition.15:value :findBestPosition:best
+  508 jump *label120 greaterThanEq :updatePosition.15:value 0.0784313725490196
   509 set :findBestPosition:bestX :updatePosition.15:dx
   510 set :findBestPosition:bestY :updatePosition.15:dy
   511 set :findBestPosition:best :updatePosition.15:value
 
   519 set :updatePosition.16:dx 1.5
   520 set :updatePosition.16:dy :updateRowPositionsEven.1:dy
   521 set :updatePosition.16:value :updateRowPositionsEven.1:col4
-    * op greaterThan *tmp159 :updatePosition.16:value :findBestPosition:best
-    * jump *label123 equal *tmp159 false
-    * op lessThan *tmp161 :updatePosition.16:value 0.0784313725490196
-    * jump *label125 equal *tmp161 false
+  522 jump *label123 lessThanEq :updatePosition.16:value :findBestPosition:best
+  523 jump *label125 greaterThanEq :updatePosition.16:value 0.0784313725490196
   524 set :findBestPosition:bestX :updatePosition.16:dx
   525 set :findBestPosition:bestY :updatePosition.16:dy
   526 set :findBestPosition:best :updatePosition.16:value
 
   538 set :updatePosition.17:dx -1.5
   539 set :updatePosition.17:dy :updateRowPositionsEven.2:dy
   540 set :updatePosition.17:value :updateRowPositionsEven.2:col1
-    * op greaterThan *tmp163 :updatePosition.17:value :findBestPosition:best
-    * jump *label129 equal *tmp163 false
-    * op lessThan *tmp165 :updatePosition.17:value 0.0784313725490196
-    * jump *label131 equal *tmp165 false
+  541 jump *label129 lessThanEq :updatePosition.17:value :findBestPosition:best
+  542 jump *label131 greaterThanEq :updatePosition.17:value 0.0784313725490196
   543 set :findBestPosition:bestX :updatePosition.17:dx
   544 set :findBestPosition:bestY :updatePosition.17:dy
   545 set :findBestPosition:best :updatePosition.17:value
 
   553 set :updatePosition.18:dx -0.5
   554 set :updatePosition.18:dy :updateRowPositionsEven.2:dy
   555 set :updatePosition.18:value :updateRowPositionsEven.2:col2
-    * op greaterThan *tmp167 :updatePosition.18:value :findBestPosition:best
-    * jump *label134 equal *tmp167 false
-    * op lessThan *tmp169 :updatePosition.18:value 0.0784313725490196
-    * jump *label136 equal *tmp169 false
+  556 jump *label134 lessThanEq :updatePosition.18:value :findBestPosition:best
+  557 jump *label136 greaterThanEq :updatePosition.18:value 0.0784313725490196
   558 set :findBestPosition:bestX :updatePosition.18:dx
   559 set :findBestPosition:bestY :updatePosition.18:dy
   560 set :findBestPosition:best :updatePosition.18:value
 
   568 set :updatePosition.19:dx 0.5
   569 set :updatePosition.19:dy :updateRowPositionsEven.2:dy
   570 set :updatePosition.19:value :updateRowPositionsEven.2:col3
-    * op greaterThan *tmp171 :updatePosition.19:value :findBestPosition:best
-    * jump *label139 equal *tmp171 false
-    * op lessThan *tmp173 :updatePosition.19:value 0.0784313725490196
-    * jump *label141 equal *tmp173 false
+  571 jump *label139 lessThanEq :updatePosition.19:value :findBestPosition:best
+  572 jump *label141 greaterThanEq :updatePosition.19:value 0.0784313725490196
   573 set :findBestPosition:bestX :updatePosition.19:dx
   574 set :findBestPosition:bestY :updatePosition.19:dy
   575 set :findBestPosition:best :updatePosition.19:value
 
   583 set :updatePosition.20:dx 1.5
   584 set :updatePosition.20:dy :updateRowPositionsEven.2:dy
   585 set :updatePosition.20:value :updateRowPositionsEven.2:col4
-    * op greaterThan *tmp175 :updatePosition.20:value :findBestPosition:best
-    * jump *label144 equal *tmp175 false
-    * op lessThan *tmp177 :updatePosition.20:value 0.0784313725490196
-    * jump *label146 equal *tmp177 false
+  586 jump *label144 lessThanEq :updatePosition.20:value :findBestPosition:best
+  587 jump *label146 greaterThanEq :updatePosition.20:value 0.0784313725490196
   588 set :findBestPosition:bestX :updatePosition.20:dx
   589 set :findBestPosition:bestY :updatePosition.20:dy
   590 set :findBestPosition:best :updatePosition.20:value
 
   602 set :updatePosition.21:dx -1.5
   603 set :updatePosition.21:dy :updateRowPositionsEven.3:dy
   604 set :updatePosition.21:value :updateRowPositionsEven.3:col1
-    * op greaterThan *tmp179 :updatePosition.21:value :findBestPosition:best
-    * jump *label150 equal *tmp179 false
-    * op lessThan *tmp181 :updatePosition.21:value 0.0784313725490196
-    * jump *label152 equal *tmp181 false
+  605 jump *label150 lessThanEq :updatePosition.21:value :findBestPosition:best
+  606 jump *label152 greaterThanEq :updatePosition.21:value 0.0784313725490196
   607 set :findBestPosition:bestX :updatePosition.21:dx
   608 set :findBestPosition:bestY :updatePosition.21:dy
   609 set :findBestPosition:best :updatePosition.21:value
 
   617 set :updatePosition.22:dx -0.5
   618 set :updatePosition.22:dy :updateRowPositionsEven.3:dy
   619 set :updatePosition.22:value :updateRowPositionsEven.3:col2
-    * op greaterThan *tmp183 :updatePosition.22:value :findBestPosition:best
-    * jump *label155 equal *tmp183 false
-    * op lessThan *tmp185 :updatePosition.22:value 0.0784313725490196
-    * jump *label157 equal *tmp185 false
+  620 jump *label155 lessThanEq :updatePosition.22:value :findBestPosition:best
+  621 jump *label157 greaterThanEq :updatePosition.22:value 0.0784313725490196
   622 set :findBestPosition:bestX :updatePosition.22:dx
   623 set :findBestPosition:bestY :updatePosition.22:dy
   624 set :findBestPosition:best :updatePosition.22:value
 
   632 set :updatePosition.23:dx 0.5
   633 set :updatePosition.23:dy :updateRowPositionsEven.3:dy
   634 set :updatePosition.23:value :updateRowPositionsEven.3:col3
-    * op greaterThan *tmp187 :updatePosition.23:value :findBestPosition:best
-    * jump *label160 equal *tmp187 false
-    * op lessThan *tmp189 :updatePosition.23:value 0.0784313725490196
-    * jump *label162 equal *tmp189 false
+  635 jump *label160 lessThanEq :updatePosition.23:value :findBestPosition:best
+  636 jump *label162 greaterThanEq :updatePosition.23:value 0.0784313725490196
   637 set :findBestPosition:bestX :updatePosition.23:dx
   638 set :findBestPosition:bestY :updatePosition.23:dy
   639 set :findBestPosition:best :updatePosition.23:value
 
   647 set :updatePosition.24:dx 1.5
   648 set :updatePosition.24:dy :updateRowPositionsEven.3:dy
   649 set :updatePosition.24:value :updateRowPositionsEven.3:col4
-    * op greaterThan *tmp191 :updatePosition.24:value :findBestPosition:best
-    * jump *label165 equal *tmp191 false
-    * op lessThan *tmp193 :updatePosition.24:value 0.0784313725490196
-    * jump *label167 equal *tmp193 false
+  650 jump *label165 lessThanEq :updatePosition.24:value :findBestPosition:best
+  651 jump *label167 greaterThanEq :updatePosition.24:value 0.0784313725490196
   652 set :findBestPosition:bestX :updatePosition.24:dx
   653 set :findBestPosition:bestY :updatePosition.24:dy
   654 set :findBestPosition:best :updatePosition.24:value

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-50 instructions):
 
   228 set :findBestPosition:bestX :updatePosition:dx
   229 set :findBestPosition:bestY :updatePosition:dy
   230 set :findBestPosition:best :updatePosition:value
-    * jump *label38 always
   231 label *label37
   232 label *label38
-    * jump *label36 always
   233 label *label35
   234 label *label36
   235 label *label34
 
   241 set :findBestPosition:bestX :updatePosition.1:dx
   242 set :findBestPosition:bestY :updatePosition.1:dy
   243 set :findBestPosition:best :updatePosition.1:value
-    * jump *label43 always
   244 label *label42
   245 label *label43
-    * jump *label41 always
   246 label *label40
   247 label *label41
   248 label *label39
 
   254 set :findBestPosition:bestX :updatePosition.2:dx
   255 set :findBestPosition:bestY :updatePosition.2:dy
   256 set :findBestPosition:best :updatePosition.2:value
-    * jump *label48 always
   257 label *label47
   258 label *label48
-    * jump *label46 always
   259 label *label45
   260 label *label46
   261 label *label44
 
   271 set :findBestPosition:bestX :updatePosition.3:dx
   272 set :findBestPosition:bestY :updatePosition.3:dy
   273 set :findBestPosition:best :updatePosition.3:value
-    * jump *label54 always
   274 label *label53
   275 label *label54
-    * jump *label52 always
   276 label *label51
   277 label *label52
   278 label *label50
 
   284 set :findBestPosition:bestX :updatePosition.4:dx
   285 set :findBestPosition:bestY :updatePosition.4:dy
   286 set :findBestPosition:best :updatePosition.4:value
-    * jump *label59 always
   287 label *label58
   288 label *label59
-    * jump *label57 always
   289 label *label56
   290 label *label57
   291 label *label55
 
   297 set :findBestPosition:bestX :updatePosition.5:dx
   298 set :findBestPosition:bestY :updatePosition.5:dy
   299 set :findBestPosition:best :updatePosition.5:value
-    * jump *label64 always
   300 label *label63
   301 label *label64
-    * jump *label62 always
   302 label *label61
   303 label *label62
   304 label *label60
 
   314 set :findBestPosition:bestX :updatePosition.6:dx
   315 set :findBestPosition:bestY :updatePosition.6:dy
   316 set :findBestPosition:best :updatePosition.6:value
-    * jump *label70 always
   317 label *label69
   318 label *label70
-    * jump *label68 always
   319 label *label67
   320 label *label68
   321 label *label66
 
   327 set :findBestPosition:bestX :updatePosition.7:dx
   328 set :findBestPosition:bestY :updatePosition.7:dy
   329 set :findBestPosition:best :updatePosition.7:value
-    * jump *label75 always
   330 label *label74
   331 label *label75
-    * jump *label73 always
   332 label *label72
   333 label *label73
   334 label *label71
 
   340 set :findBestPosition:bestX :updatePosition.8:dx
   341 set :findBestPosition:bestY :updatePosition.8:dy
   342 set :findBestPosition:best :updatePosition.8:value
-    * jump *label80 always
   343 label *label79
   344 label *label80
-    * jump *label78 always
   345 label *label77
   346 label *label78
   347 label *label76
 
   397 set :findBestPosition:bestX :updatePosition.9:dx
   398 set :findBestPosition:bestY :updatePosition.9:dy
   399 set :findBestPosition:best :updatePosition.9:value
-    * jump *label90 always
   400 label *label89
   401 label *label90
-    * jump *label88 always
   402 label *label87
   403 label *label88
   404 label *label86
 
   410 set :findBestPosition:bestX :updatePosition.10:dx
   411 set :findBestPosition:bestY :updatePosition.10:dy
   412 set :findBestPosition:best :updatePosition.10:value
-    * jump *label95 always
   413 label *label94
   414 label *label95
-    * jump *label93 always
   415 label *label92
   416 label *label93
   417 label *label91
 
   423 set :findBestPosition:bestX :updatePosition.11:dx
   424 set :findBestPosition:bestY :updatePosition.11:dy
   425 set :findBestPosition:best :updatePosition.11:value
-    * jump *label100 always
   426 label *label99
   427 label *label100
-    * jump *label98 always
   428 label *label97
   429 label *label98
   430 label *label96
 
   436 set :findBestPosition:bestX :updatePosition.12:dx
   437 set :findBestPosition:bestY :updatePosition.12:dy
   438 set :findBestPosition:best :updatePosition.12:value
-    * jump *label105 always
   439 label *label104
   440 label *label105
-    * jump *label103 always
   441 label *label102
   442 label *label103
   443 label *label101
 
   453 set :findBestPosition:bestX :updatePosition.13:dx
   454 set :findBestPosition:bestY :updatePosition.13:dy
   455 set :findBestPosition:best :updatePosition.13:value
-    * jump *label111 always
   456 label *label110
   457 label *label111
-    * jump *label109 always
   458 label *label108
   459 label *label109
   460 label *label107
 
   466 set :findBestPosition:bestX :updatePosition.14:dx
   467 set :findBestPosition:bestY :updatePosition.14:dy
   468 set :findBestPosition:best :updatePosition.14:value
-    * jump *label116 always
   469 label *label115
   470 label *label116
-    * jump *label114 always
   471 label *label113
   472 label *label114
   473 label *label112
 
   479 set :findBestPosition:bestX :updatePosition.15:dx
   480 set :findBestPosition:bestY :updatePosition.15:dy
   481 set :findBestPosition:best :updatePosition.15:value
-    * jump *label121 always
   482 label *label120
   483 label *label121
-    * jump *label119 always
   484 label *label118
   485 label *label119
   486 label *label117
 
   492 set :findBestPosition:bestX :updatePosition.16:dx
   493 set :findBestPosition:bestY :updatePosition.16:dy
   494 set :findBestPosition:best :updatePosition.16:value
-    * jump *label126 always
   495 label *label125
   496 label *label126
-    * jump *label124 always
   497 label *label123
   498 label *label124
   499 label *label122
 
   509 set :findBestPosition:bestX :updatePosition.17:dx
   510 set :findBestPosition:bestY :updatePosition.17:dy
   511 set :findBestPosition:best :updatePosition.17:value
-    * jump *label132 always
   512 label *label131
   513 label *label132
-    * jump *label130 always
   514 label *label129
   515 label *label130
   516 label *label128
 
   522 set :findBestPosition:bestX :updatePosition.18:dx
   523 set :findBestPosition:bestY :updatePosition.18:dy
   524 set :findBestPosition:best :updatePosition.18:value
-    * jump *label137 always
   525 label *label136
   526 label *label137
-    * jump *label135 always
   527 label *label134
   528 label *label135
   529 label *label133
 
   535 set :findBestPosition:bestX :updatePosition.19:dx
   536 set :findBestPosition:bestY :updatePosition.19:dy
   537 set :findBestPosition:best :updatePosition.19:value
-    * jump *label142 always
   538 label *label141
   539 label *label142
-    * jump *label140 always
   540 label *label139
   541 label *label140
   542 label *label138
 
   548 set :findBestPosition:bestX :updatePosition.20:dx
   549 set :findBestPosition:bestY :updatePosition.20:dy
   550 set :findBestPosition:best :updatePosition.20:value
-    * jump *label147 always
   551 label *label146
   552 label *label147
-    * jump *label145 always
   553 label *label144
   554 label *label145
   555 label *label143
 
   565 set :findBestPosition:bestX :updatePosition.21:dx
   566 set :findBestPosition:bestY :updatePosition.21:dy
   567 set :findBestPosition:best :updatePosition.21:value
-    * jump *label153 always
   568 label *label152
   569 label *label153
-    * jump *label151 always
   570 label *label150
   571 label *label151
   572 label *label149
 
   578 set :findBestPosition:bestX :updatePosition.22:dx
   579 set :findBestPosition:bestY :updatePosition.22:dy
   580 set :findBestPosition:best :updatePosition.22:value
-    * jump *label158 always
   581 label *label157
   582 label *label158
-    * jump *label156 always
   583 label *label155
   584 label *label156
   585 label *label154
 
   591 set :findBestPosition:bestX :updatePosition.23:dx
   592 set :findBestPosition:bestY :updatePosition.23:dy
   593 set :findBestPosition:best :updatePosition.23:value
-    * jump *label163 always
   594 label *label162
   595 label *label163
-    * jump *label161 always
   596 label *label160
   597 label *label161
   598 label *label159
 
   604 set :findBestPosition:bestX :updatePosition.24:dx
   605 set :findBestPosition:bestY :updatePosition.24:dy
   606 set :findBestPosition:best :updatePosition.24:value
-    * jump *label168 always
   607 label *label167
   608 label *label168
-    * jump *label166 always
   609 label *label165
   610 label *label166
   611 label *label164

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
 
    62 set *tmp8 :tileValue.1:result
    63 label *label15
    64 set :computeRowValues:x2 *tmp8
-    * op add :tileValue.2:x :computeRowValues:x 0
+   65 set :tileValue.2:x :computeRowValues:x
    66 set :tileValue.2:y :computeRowValues:y
    67 set :tileValue.2:ore :computeRowValues:ore
    68 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
 
   180 call *label2 *invalid :computeRowValues*retval (m:*label27) (h:*label27)
   181 label *label27
   182 set :findBestPosition:y2 :computeRowValues*retval
-    * op add *tmp56 :findBestPosition:y 0
+  183 set *tmp56 :findBestPosition:y
   184 set :computeRowValues:x :findBestPosition:x
   185 set :computeRowValues:y *tmp56
   186 set :computeRowValues:ore :findBestPosition:ore

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-5 instructions):
 
    25 select :isSolid:result notEqual solid false 1 0
    26 set *tmp3 :isSolid:result
    27 label *label12
-    * op or :createTerrainMask:result *tmp0 *tmp3
+   28 op or :createTerrainMask:result *tmp0 :isSolid:result
    29 label *label10
    30 op sub :createTerrainMask:c :createTerrainMask:c 1
    31 jump *label9 always
 
    36 label *label8
    37 set :createTerrainMask*retval :createTerrainMask:result
    38 jump *label5 always
-    * set :createTerrainMask*retval null
    39 label *label5
    40 set :createTerrainMask*finished true
    41 jump *label4 always
 
    50 select :tileValue:result notEqual solid false 0.09803921568627451 value
    51 set *tmp6 :tileValue:result
    52 label *label14
-    * set :computeRowValues:x1 *tmp6
+   53 set :computeRowValues:x1 :tileValue:result
    54 op sub :tileValue.1:x :computeRowValues:x 1
    55 set :tileValue.1:y :computeRowValues:y
    56 set :tileValue.1:ore :computeRowValues:ore
 
    60 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
    61 set *tmp8 :tileValue.1:result
    62 label *label15
-    * set :computeRowValues:x2 *tmp8
+   63 set :computeRowValues:x2 :tileValue.1:result
    64 set :tileValue.2:x :computeRowValues:x
    65 set :tileValue.2:y :computeRowValues:y
    66 set :tileValue.2:ore :computeRowValues:ore
 
    70 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
    71 set *tmp10 :tileValue.2:result
    72 label *label16
-    * set :computeRowValues:x3 *tmp10
+   73 set :computeRowValues:x3 :tileValue.2:result
    74 op add :tileValue.3:x :computeRowValues:x 1
    75 set :tileValue.3:y :computeRowValues:y
    76 set :tileValue.3:ore :computeRowValues:ore
 
    80 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
    81 set *tmp12 :tileValue.3:result
    82 label *label17
-    * set :computeRowValues:x4 *tmp12
+   83 set :computeRowValues:x4 :tileValue.3:result
    84 op add :tileValue.4:x :computeRowValues:x 2
    85 set :tileValue.4:y :computeRowValues:y
    86 set :tileValue.4:ore :computeRowValues:ore
 
    90 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
    91 set *tmp14 :tileValue.4:result
    92 label *label18
-    * set :computeRowValues:x5 *tmp14
+   93 set :computeRowValues:x5 :tileValue.4:result
    94 jump *label19 notEqual :computeRowValues:size 2
-    * op add *tmp17 :computeRowValues:x1 :computeRowValues:x2
-    * op add *tmp18 :computeRowValues:x2 :computeRowValues:x3
-    * op add *tmp19 :computeRowValues:x3 :computeRowValues:x4
-    * op add *tmp20 :computeRowValues:x4 :computeRowValues:x5
+   95 op add *tmp17 *tmp6 *tmp8
+   96 op add *tmp18 *tmp8 *tmp10
+   97 op add *tmp19 *tmp10 *tmp12
+   98 op add *tmp20 *tmp12 *tmp14
    99 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
   100 jump *label13 always
-    * set *tmp16 null
   101 jump *label20 always
   102 label *label19
   103 jump *label21 notEqual :computeRowValues:size 3
-    * op add *tmp24 :computeRowValues:x2 :computeRowValues:x3
-    * op add *tmp25 :computeRowValues:x1 *tmp24
-    * op add *tmp26 :computeRowValues:x2 :computeRowValues:x3
-    * op add *tmp27 *tmp26 :computeRowValues:x4
-    * op add *tmp28 :computeRowValues:x3 :computeRowValues:x4
-    * op add *tmp29 *tmp28 :computeRowValues:x5
+  104 op add *tmp24 *tmp8 *tmp10
+  105 op add *tmp25 *tmp6 *tmp24
+  106 op add *tmp26 *tmp8 *tmp10
+  107 op add *tmp27 *tmp24 *tmp12
+  108 op add *tmp28 *tmp10 *tmp12
+  109 op add *tmp29 *tmp28 *tmp14
   110 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
   111 jump *label13 always
-    * set *tmp23 null
   112 jump *label22 always
   113 label *label21
   114 op sub :tileValue.5:x :computeRowValues:x 3
 
   120 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
   121 set *tmp32 :tileValue.5:result
   122 label *label23
-    * set :computeRowValues:x0 *tmp32
+  123 set :computeRowValues:x0 :tileValue.5:result
   124 op add :tileValue.6:x :computeRowValues:x 3
   125 set :tileValue.6:y :computeRowValues:y
   126 set :tileValue.6:ore :computeRowValues:ore
 
   130 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
   131 set *tmp34 :tileValue.6:result
   132 label *label24
-    * set :computeRowValues:x6 *tmp34
-    * op add *tmp35 :computeRowValues:x1 :computeRowValues:x2
-    * op add *tmp36 *tmp35 :computeRowValues:x3
-    * op add *tmp37 :computeRowValues:x0 *tmp36
+  133 set :computeRowValues:x6 :tileValue.6:result
+  134 op add *tmp35 *tmp6 *tmp8
+  135 op add *tmp36 *tmp35 *tmp10
+  136 op add *tmp37 *tmp32 *tmp36
   137 op min *tmp38 0.09803921568627451 *tmp37
-    * op add *tmp39 :computeRowValues:x1 :computeRowValues:x2
-    * op add *tmp40 *tmp39 :computeRowValues:x3
-    * op add *tmp41 *tmp40 :computeRowValues:x4
+  138 op add *tmp39 *tmp6 *tmp8
+  139 op add *tmp40 *tmp35 *tmp10
+  140 op add *tmp41 *tmp36 *tmp12
   141 op min *tmp42 0.09803921568627451 *tmp41
-    * op add *tmp43 :computeRowValues:x3 :computeRowValues:x4
-    * op add *tmp44 *tmp43 :computeRowValues:x5
-    * op add *tmp45 :computeRowValues:x2 *tmp44
+  142 op add *tmp43 *tmp10 *tmp12
+  143 op add *tmp44 *tmp43 *tmp14
+  144 op add *tmp45 *tmp8 *tmp44
   145 op min *tmp46 0.09803921568627451 *tmp45
-    * op add *tmp47 :computeRowValues:x3 :computeRowValues:x4
-    * op add *tmp48 *tmp47 :computeRowValues:x5
-    * op add *tmp49 *tmp48 :computeRowValues:x6
+  146 op add *tmp47 *tmp10 *tmp12
+  147 op add *tmp48 *tmp43 *tmp14
+  148 op add *tmp49 *tmp44 *tmp34
   149 op min *tmp50 0.09803921568627451 *tmp49
   150 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
   151 jump *label13 always
-    * set *tmp23 null
   152 label *label22
-    * set *tmp16 *tmp23
+  153 set *tmp16 null
   154 label *label20
-    * set :computeRowValues*retval *tmp16
+  155 set :computeRowValues*retval null
   156 label *label13
   157 return :computeRowValues*retaddr
   158 end
 
   178 set :findBestPosition:y2 :computeRowValues*retval
   179 set *tmp56 :findBestPosition:y
   180 set :computeRowValues:x :findBestPosition:x
-    * set :computeRowValues:y *tmp56
+  181 set :computeRowValues:y :findBestPosition:y
   182 set :computeRowValues:ore :findBestPosition:ore
   183 set :computeRowValues:size :findBestPosition:size
   184 setaddr :computeRowValues*retaddr *label28 (h:*label28)
 
   210 op add *tmp64 :findBestPosition:y2 :findBestPosition:y3
   211 op add :findBestPosition:row1 :findBestPosition:y1 *tmp64
   212 op add *tmp66 :findBestPosition:y2 :findBestPosition:y3
-    * op add :findBestPosition:row2 *tmp66 :findBestPosition:y4
+  213 op add :findBestPosition:row2 *tmp64 :findBestPosition:y4
   214 op add *tmp68 :findBestPosition:y3 :findBestPosition:y4
-    * op add :findBestPosition:row3 *tmp68 :findBestPosition:y5
+  215 op add :findBestPosition:row3 *tmp68 :computeRowValues*retval
   216 set :updateRowPositionsOdd:dy -1
   217 set :updateRowPositionsOdd:rowSum :findBestPosition:row1
-    * unpackcolor :updateRowPositionsOdd:col1 :updateRowPositionsOdd:col2 :updateRowPositionsOdd:col3 *tmp70 :updateRowPositionsOdd:rowSum
+  218 unpackcolor :updateRowPositionsOdd:col1 :updateRowPositionsOdd:col2 :updateRowPositionsOdd:col3 *tmp70 :findBestPosition:row1
   219 set :updatePosition:dx -1
-    * set :updatePosition:dy :updateRowPositionsOdd:dy
+  220 set :updatePosition:dy -1
   221 set :updatePosition:value :updateRowPositionsOdd:col1
-    * jump *label35 lessThanEq :updatePosition:value :findBestPosition:best
-    * jump *label37 greaterThanEq :updatePosition:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition:dx
-    * set :findBestPosition:bestY :updatePosition:dy
-    * set :findBestPosition:best :updatePosition:value
+  222 jump *label35 lessThanEq :updateRowPositionsOdd:col1 0
+  223 jump *label37 greaterThanEq :updateRowPositionsOdd:col1 0.0784313725490196
+  224 set :findBestPosition:bestX -1
+  225 set :findBestPosition:bestY :updateRowPositionsOdd:dy
+  226 set :findBestPosition:best :updateRowPositionsOdd:col1
   227 label *label37
   228 label *label38
   229 label *label35
   230 label *label36
   231 label *label34
   232 set :updatePosition.1:dx 0
-    * set :updatePosition.1:dy :updateRowPositionsOdd:dy
+  233 set :updatePosition.1:dy -1
   234 set :updatePosition.1:value :updateRowPositionsOdd:col2
-    * jump *label40 lessThanEq :updatePosition.1:value :findBestPosition:best
-    * jump *label42 greaterThanEq :updatePosition.1:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.1:dx
-    * set :findBestPosition:bestY :updatePosition.1:dy
-    * set :findBestPosition:best :updatePosition.1:value
+  235 jump *label40 lessThanEq :updateRowPositionsOdd:col2 :findBestPosition:best
+  236 jump *label42 greaterThanEq :updateRowPositionsOdd:col2 0.0784313725490196
+  237 set :findBestPosition:bestX 0
+  238 set :findBestPosition:bestY :updateRowPositionsOdd:dy
+  239 set :findBestPosition:best :updateRowPositionsOdd:col2
   240 label *label42
   241 label *label43
   242 label *label40
   243 label *label41
   244 label *label39
   245 set :updatePosition.2:dx 1
-    * set :updatePosition.2:dy :updateRowPositionsOdd:dy
+  246 set :updatePosition.2:dy -1
   247 set :updatePosition.2:value :updateRowPositionsOdd:col3
-    * jump *label45 lessThanEq :updatePosition.2:value :findBestPosition:best
-    * jump *label47 greaterThanEq :updatePosition.2:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.2:dx
-    * set :findBestPosition:bestY :updatePosition.2:dy
-    * set :findBestPosition:best :updatePosition.2:value
+  248 jump *label45 lessThanEq :updateRowPositionsOdd:col3 :findBestPosition:best
+  249 jump *label47 greaterThanEq :updateRowPositionsOdd:col3 0.0784313725490196
+  250 set :findBestPosition:bestX 1
+  251 set :findBestPosition:bestY :updateRowPositionsOdd:dy
+  252 set :findBestPosition:best :updateRowPositionsOdd:col3
   253 label *label47
   254 label *label48
   255 label *label45
 
   258 label *label33
   259 set :updateRowPositionsOdd.1:dy 0
   260 set :updateRowPositionsOdd.1:rowSum :findBestPosition:row2
-    * unpackcolor :updateRowPositionsOdd.1:col1 :updateRowPositionsOdd.1:col2 :updateRowPositionsOdd.1:col3 *tmp83 :updateRowPositionsOdd.1:rowSum
+  261 unpackcolor :updateRowPositionsOdd.1:col1 :updateRowPositionsOdd.1:col2 :updateRowPositionsOdd.1:col3 *tmp83 :findBestPosition:row2
   262 set :updatePosition.3:dx -1
-    * set :updatePosition.3:dy :updateRowPositionsOdd.1:dy
+  263 set :updatePosition.3:dy 0
   264 set :updatePosition.3:value :updateRowPositionsOdd.1:col1
-    * jump *label51 lessThanEq :updatePosition.3:value :findBestPosition:best
-    * jump *label53 greaterThanEq :updatePosition.3:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.3:dx
-    * set :findBestPosition:bestY :updatePosition.3:dy
-    * set :findBestPosition:best :updatePosition.3:value
+  265 jump *label51 lessThanEq :updateRowPositionsOdd.1:col1 :findBestPosition:best
+  266 jump *label53 greaterThanEq :updateRowPositionsOdd.1:col1 0.0784313725490196
+  267 set :findBestPosition:bestX -1
+  268 set :findBestPosition:bestY :updateRowPositionsOdd.1:dy
+  269 set :findBestPosition:best :updateRowPositionsOdd.1:col1
   270 label *label53
   271 label *label54
   272 label *label51
   273 label *label52
   274 label *label50
   275 set :updatePosition.4:dx 0
-    * set :updatePosition.4:dy :updateRowPositionsOdd.1:dy
+  276 set :updatePosition.4:dy 0
   277 set :updatePosition.4:value :updateRowPositionsOdd.1:col2
-    * jump *label56 lessThanEq :updatePosition.4:value :findBestPosition:best
-    * jump *label58 greaterThanEq :updatePosition.4:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.4:dx
-    * set :findBestPosition:bestY :updatePosition.4:dy
-    * set :findBestPosition:best :updatePosition.4:value
+  278 jump *label56 lessThanEq :updateRowPositionsOdd.1:col2 :findBestPosition:best
+  279 jump *label58 greaterThanEq :updateRowPositionsOdd.1:col2 0.0784313725490196
+  280 set :findBestPosition:bestX 0
+  281 set :findBestPosition:bestY :updateRowPositionsOdd.1:dy
+  282 set :findBestPosition:best :updateRowPositionsOdd.1:col2
   283 label *label58
   284 label *label59
   285 label *label56
   286 label *label57
   287 label *label55
   288 set :updatePosition.5:dx 1
-    * set :updatePosition.5:dy :updateRowPositionsOdd.1:dy
+  289 set :updatePosition.5:dy 0
   290 set :updatePosition.5:value :updateRowPositionsOdd.1:col3
-    * jump *label61 lessThanEq :updatePosition.5:value :findBestPosition:best
-    * jump *label63 greaterThanEq :updatePosition.5:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.5:dx
-    * set :findBestPosition:bestY :updatePosition.5:dy
-    * set :findBestPosition:best :updatePosition.5:value
+  291 jump *label61 lessThanEq :updateRowPositionsOdd.1:col3 :findBestPosition:best
+  292 jump *label63 greaterThanEq :updateRowPositionsOdd.1:col3 0.0784313725490196
+  293 set :findBestPosition:bestX 1
+  294 set :findBestPosition:bestY :updateRowPositionsOdd.1:dy
+  295 set :findBestPosition:best :updateRowPositionsOdd.1:col3
   296 label *label63
   297 label *label64
   298 label *label61
 
   301 label *label49
   302 set :updateRowPositionsOdd.2:dy 1
   303 set :updateRowPositionsOdd.2:rowSum :findBestPosition:row3
-    * unpackcolor :updateRowPositionsOdd.2:col1 :updateRowPositionsOdd.2:col2 :updateRowPositionsOdd.2:col3 *tmp96 :updateRowPositionsOdd.2:rowSum
+  304 unpackcolor :updateRowPositionsOdd.2:col1 :updateRowPositionsOdd.2:col2 :updateRowPositionsOdd.2:col3 *tmp96 :findBestPosition:row3
   305 set :updatePosition.6:dx -1
-    * set :updatePosition.6:dy :updateRowPositionsOdd.2:dy
+  306 set :updatePosition.6:dy 1
   307 set :updatePosition.6:value :updateRowPositionsOdd.2:col1
-    * jump *label67 lessThanEq :updatePosition.6:value :findBestPosition:best
-    * jump *label69 greaterThanEq :updatePosition.6:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.6:dx
-    * set :findBestPosition:bestY :updatePosition.6:dy
-    * set :findBestPosition:best :updatePosition.6:value
+  308 jump *label67 lessThanEq :updateRowPositionsOdd.2:col1 :findBestPosition:best
+  309 jump *label69 greaterThanEq :updateRowPositionsOdd.2:col1 0.0784313725490196
+  310 set :findBestPosition:bestX -1
+  311 set :findBestPosition:bestY :updateRowPositionsOdd.2:dy
+  312 set :findBestPosition:best :updateRowPositionsOdd.2:col1
   313 label *label69
   314 label *label70
   315 label *label67
   316 label *label68
   317 label *label66
   318 set :updatePosition.7:dx 0
-    * set :updatePosition.7:dy :updateRowPositionsOdd.2:dy
+  319 set :updatePosition.7:dy 1
   320 set :updatePosition.7:value :updateRowPositionsOdd.2:col2
-    * jump *label72 lessThanEq :updatePosition.7:value :findBestPosition:best
-    * jump *label74 greaterThanEq :updatePosition.7:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.7:dx
-    * set :findBestPosition:bestY :updatePosition.7:dy
-    * set :findBestPosition:best :updatePosition.7:value
+  321 jump *label72 lessThanEq :updateRowPositionsOdd.2:col2 :findBestPosition:best
+  322 jump *label74 greaterThanEq :updateRowPositionsOdd.2:col2 0.0784313725490196
+  323 set :findBestPosition:bestX 0
+  324 set :findBestPosition:bestY :updateRowPositionsOdd.2:dy
+  325 set :findBestPosition:best :updateRowPositionsOdd.2:col2
   326 label *label74
   327 label *label75
   328 label *label72
   329 label *label73
   330 label *label71
   331 set :updatePosition.8:dx 1
-    * set :updatePosition.8:dy :updateRowPositionsOdd.2:dy
+  332 set :updatePosition.8:dy 1
   333 set :updatePosition.8:value :updateRowPositionsOdd.2:col3
-    * jump *label77 lessThanEq :updatePosition.8:value :findBestPosition:best
-    * jump *label79 greaterThanEq :updatePosition.8:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.8:dx
-    * set :findBestPosition:bestY :updatePosition.8:dy
-    * set :findBestPosition:best :updatePosition.8:value
+  334 jump *label77 lessThanEq :updateRowPositionsOdd.2:col3 :findBestPosition:best
+  335 jump *label79 greaterThanEq :updateRowPositionsOdd.2:col3 0.0784313725490196
+  336 set :findBestPosition:bestX 1
+  337 set :findBestPosition:bestY :updateRowPositionsOdd.2:dy
+  338 set :findBestPosition:best :updateRowPositionsOdd.2:col3
   339 label *label79
   340 label *label80
   341 label *label77
 
   348 op add :findBestPosition:row1 :findBestPosition:y1 :findBestPosition:y2
   349 op add :findBestPosition:row2 :findBestPosition:y2 :findBestPosition:y3
   350 op add :findBestPosition:row3 :findBestPosition:y3 :findBestPosition:y4
-    * op add :findBestPosition:row4 :findBestPosition:y4 :findBestPosition:y5
+  351 op add :findBestPosition:row4 :findBestPosition:y4 :computeRowValues*retval
   352 jump *label82 always
   353 label *label81
   354 op sub *tmp115 :findBestPosition:y 3
 
   373 op add *tmp120 *tmp119 :findBestPosition:y3
   374 op add :findBestPosition:row1 :findBestPosition:y0 *tmp120
   375 op add *tmp122 :findBestPosition:y1 :findBestPosition:y2
-    * op add *tmp123 *tmp122 :findBestPosition:y3
-    * op add :findBestPosition:row2 *tmp123 :findBestPosition:y4
+  376 op add *tmp123 *tmp119 :findBestPosition:y3
+  377 op add :findBestPosition:row2 *tmp120 :findBestPosition:y4
   378 op add *tmp125 :findBestPosition:y3 :findBestPosition:y4
   379 op add *tmp126 *tmp125 :findBestPosition:y5
   380 op add :findBestPosition:row3 :findBestPosition:y2 *tmp126
   381 op add *tmp128 :findBestPosition:y3 :findBestPosition:y4
-    * op add *tmp129 *tmp128 :findBestPosition:y5
-    * op add :findBestPosition:row4 *tmp129 :findBestPosition:y6
+  382 op add *tmp129 *tmp125 :findBestPosition:y5
+  383 op add :findBestPosition:row4 *tmp126 :computeRowValues*retval
   384 label *label82
   385 set :updateRowPositionsEven:dy -1.5
   386 set :updateRowPositionsEven:rowSum :findBestPosition:row1
-    * unpackcolor :updateRowPositionsEven:col1 :updateRowPositionsEven:col2 :updateRowPositionsEven:col3 :updateRowPositionsEven:col4 :updateRowPositionsEven:rowSum
+  387 unpackcolor :updateRowPositionsEven:col1 :updateRowPositionsEven:col2 :updateRowPositionsEven:col3 :updateRowPositionsEven:col4 :findBestPosition:row1
   388 set :updatePosition.9:dx -1.5
-    * set :updatePosition.9:dy :updateRowPositionsEven:dy
+  389 set :updatePosition.9:dy -1.5
   390 set :updatePosition.9:value :updateRowPositionsEven:col1
-    * jump *label87 lessThanEq :updatePosition.9:value :findBestPosition:best
-    * jump *label89 greaterThanEq :updatePosition.9:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.9:dx
-    * set :findBestPosition:bestY :updatePosition.9:dy
-    * set :findBestPosition:best :updatePosition.9:value
+  391 jump *label87 lessThanEq :updateRowPositionsEven:col1 :findBestPosition:best
+  392 jump *label89 greaterThanEq :updateRowPositionsEven:col1 0.0784313725490196
+  393 set :findBestPosition:bestX -1.5
+  394 set :findBestPosition:bestY :updateRowPositionsEven:dy
+  395 set :findBestPosition:best :updateRowPositionsEven:col1
   396 label *label89
   397 label *label90
   398 label *label87
   399 label *label88
   400 label *label86
   401 set :updatePosition.10:dx -0.5
-    * set :updatePosition.10:dy :updateRowPositionsEven:dy
+  402 set :updatePosition.10:dy -1.5
   403 set :updatePosition.10:value :updateRowPositionsEven:col2
-    * jump *label92 lessThanEq :updatePosition.10:value :findBestPosition:best
-    * jump *label94 greaterThanEq :updatePosition.10:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.10:dx
-    * set :findBestPosition:bestY :updatePosition.10:dy
-    * set :findBestPosition:best :updatePosition.10:value
+  404 jump *label92 lessThanEq :updateRowPositionsEven:col2 :findBestPosition:best
+  405 jump *label94 greaterThanEq :updateRowPositionsEven:col2 0.0784313725490196
+  406 set :findBestPosition:bestX -0.5
+  407 set :findBestPosition:bestY :updateRowPositionsEven:dy
+  408 set :findBestPosition:best :updateRowPositionsEven:col2
   409 label *label94
   410 label *label95
   411 label *label92
   412 label *label93
   413 label *label91
   414 set :updatePosition.11:dx 0.5
-    * set :updatePosition.11:dy :updateRowPositionsEven:dy
+  415 set :updatePosition.11:dy -1.5
   416 set :updatePosition.11:value :updateRowPositionsEven:col3
-    * jump *label97 lessThanEq :updatePosition.11:value :findBestPosition:best
-    * jump *label99 greaterThanEq :updatePosition.11:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.11:dx
-    * set :findBestPosition:bestY :updatePosition.11:dy
-    * set :findBestPosition:best :updatePosition.11:value
+  417 jump *label97 lessThanEq :updateRowPositionsEven:col3 :findBestPosition:best
+  418 jump *label99 greaterThanEq :updateRowPositionsEven:col3 0.0784313725490196
+  419 set :findBestPosition:bestX 0.5
+  420 set :findBestPosition:bestY :updateRowPositionsEven:dy
+  421 set :findBestPosition:best :updateRowPositionsEven:col3
   422 label *label99
   423 label *label100
   424 label *label97
   425 label *label98
   426 label *label96
   427 set :updatePosition.12:dx 1.5
-    * set :updatePosition.12:dy :updateRowPositionsEven:dy
+  428 set :updatePosition.12:dy -1.5
   429 set :updatePosition.12:value :updateRowPositionsEven:col4
-    * jump *label102 lessThanEq :updatePosition.12:value :findBestPosition:best
-    * jump *label104 greaterThanEq :updatePosition.12:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.12:dx
-    * set :findBestPosition:bestY :updatePosition.12:dy
-    * set :findBestPosition:best :updatePosition.12:value
+  430 jump *label102 lessThanEq :updateRowPositionsEven:col4 :findBestPosition:best
+  431 jump *label104 greaterThanEq :updateRowPositionsEven:col4 0.0784313725490196
+  432 set :findBestPosition:bestX 1.5
+  433 set :findBestPosition:bestY :updateRowPositionsEven:dy
+  434 set :findBestPosition:best :updateRowPositionsEven:col4
   435 label *label104
   436 label *label105
   437 label *label102
 
   440 label *label85
   441 set :updateRowPositionsEven.1:dy -0.5
   442 set :updateRowPositionsEven.1:rowSum :findBestPosition:row2
-    * unpackcolor :updateRowPositionsEven.1:col1 :updateRowPositionsEven.1:col2 :updateRowPositionsEven.1:col3 :updateRowPositionsEven.1:col4 :updateRowPositionsEven.1:rowSum
+  443 unpackcolor :updateRowPositionsEven.1:col1 :updateRowPositionsEven.1:col2 :updateRowPositionsEven.1:col3 :updateRowPositionsEven.1:col4 :findBestPosition:row2
   444 set :updatePosition.13:dx -1.5
-    * set :updatePosition.13:dy :updateRowPositionsEven.1:dy
+  445 set :updatePosition.13:dy -0.5
   446 set :updatePosition.13:value :updateRowPositionsEven.1:col1
-    * jump *label108 lessThanEq :updatePosition.13:value :findBestPosition:best
-    * jump *label110 greaterThanEq :updatePosition.13:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.13:dx
-    * set :findBestPosition:bestY :updatePosition.13:dy
-    * set :findBestPosition:best :updatePosition.13:value
+  447 jump *label108 lessThanEq :updateRowPositionsEven.1:col1 :findBestPosition:best
+  448 jump *label110 greaterThanEq :updateRowPositionsEven.1:col1 0.0784313725490196
+  449 set :findBestPosition:bestX -1.5
+  450 set :findBestPosition:bestY :updateRowPositionsEven.1:dy
+  451 set :findBestPosition:best :updateRowPositionsEven.1:col1
   452 label *label110
   453 label *label111
   454 label *label108
   455 label *label109
   456 label *label107
   457 set :updatePosition.14:dx -0.5
-    * set :updatePosition.14:dy :updateRowPositionsEven.1:dy
+  458 set :updatePosition.14:dy -0.5
   459 set :updatePosition.14:value :updateRowPositionsEven.1:col2
-    * jump *label113 lessThanEq :updatePosition.14:value :findBestPosition:best
-    * jump *label115 greaterThanEq :updatePosition.14:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.14:dx
-    * set :findBestPosition:bestY :updatePosition.14:dy
-    * set :findBestPosition:best :updatePosition.14:value
+  460 jump *label113 lessThanEq :updateRowPositionsEven.1:col2 :findBestPosition:best
+  461 jump *label115 greaterThanEq :updateRowPositionsEven.1:col2 0.0784313725490196
+  462 set :findBestPosition:bestX -0.5
+  463 set :findBestPosition:bestY :updateRowPositionsEven.1:dy
+  464 set :findBestPosition:best :updateRowPositionsEven.1:col2
   465 label *label115
   466 label *label116
   467 label *label113
   468 label *label114
   469 label *label112
   470 set :updatePosition.15:dx 0.5
-    * set :updatePosition.15:dy :updateRowPositionsEven.1:dy
+  471 set :updatePosition.15:dy -0.5
   472 set :updatePosition.15:value :updateRowPositionsEven.1:col3
-    * jump *label118 lessThanEq :updatePosition.15:value :findBestPosition:best
-    * jump *label120 greaterThanEq :updatePosition.15:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.15:dx
-    * set :findBestPosition:bestY :updatePosition.15:dy
-    * set :findBestPosition:best :updatePosition.15:value
+  473 jump *label118 lessThanEq :updateRowPositionsEven.1:col3 :findBestPosition:best
+  474 jump *label120 greaterThanEq :updateRowPositionsEven.1:col3 0.0784313725490196
+  475 set :findBestPosition:bestX 0.5
+  476 set :findBestPosition:bestY :updateRowPositionsEven.1:dy
+  477 set :findBestPosition:best :updateRowPositionsEven.1:col3
   478 label *label120
   479 label *label121
   480 label *label118
   481 label *label119
   482 label *label117
   483 set :updatePosition.16:dx 1.5
-    * set :updatePosition.16:dy :updateRowPositionsEven.1:dy
+  484 set :updatePosition.16:dy -0.5
   485 set :updatePosition.16:value :updateRowPositionsEven.1:col4
-    * jump *label123 lessThanEq :updatePosition.16:value :findBestPosition:best
-    * jump *label125 greaterThanEq :updatePosition.16:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.16:dx
-    * set :findBestPosition:bestY :updatePosition.16:dy
-    * set :findBestPosition:best :updatePosition.16:value
+  486 jump *label123 lessThanEq :updateRowPositionsEven.1:col4 :findBestPosition:best
+  487 jump *label125 greaterThanEq :updateRowPositionsEven.1:col4 0.0784313725490196
+  488 set :findBestPosition:bestX 1.5
+  489 set :findBestPosition:bestY :updateRowPositionsEven.1:dy
+  490 set :findBestPosition:best :updateRowPositionsEven.1:col4
   491 label *label125
   492 label *label126
   493 label *label123
 
   496 label *label106
   497 set :updateRowPositionsEven.2:dy 0.5
   498 set :updateRowPositionsEven.2:rowSum :findBestPosition:row3
-    * unpackcolor :updateRowPositionsEven.2:col1 :updateRowPositionsEven.2:col2 :updateRowPositionsEven.2:col3 :updateRowPositionsEven.2:col4 :updateRowPositionsEven.2:rowSum
+  499 unpackcolor :updateRowPositionsEven.2:col1 :updateRowPositionsEven.2:col2 :updateRowPositionsEven.2:col3 :updateRowPositionsEven.2:col4 :findBestPosition:row3
   500 set :updatePosition.17:dx -1.5
-    * set :updatePosition.17:dy :updateRowPositionsEven.2:dy
+  501 set :updatePosition.17:dy 0.5
   502 set :updatePosition.17:value :updateRowPositionsEven.2:col1
-    * jump *label129 lessThanEq :updatePosition.17:value :findBestPosition:best
-    * jump *label131 greaterThanEq :updatePosition.17:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.17:dx
-    * set :findBestPosition:bestY :updatePosition.17:dy
-    * set :findBestPosition:best :updatePosition.17:value
+  503 jump *label129 lessThanEq :updateRowPositionsEven.2:col1 :findBestPosition:best
+  504 jump *label131 greaterThanEq :updateRowPositionsEven.2:col1 0.0784313725490196
+  505 set :findBestPosition:bestX -1.5
+  506 set :findBestPosition:bestY :updateRowPositionsEven.2:dy
+  507 set :findBestPosition:best :updateRowPositionsEven.2:col1
   508 label *label131
   509 label *label132
   510 label *label129
   511 label *label130
   512 label *label128
   513 set :updatePosition.18:dx -0.5
-    * set :updatePosition.18:dy :updateRowPositionsEven.2:dy
+  514 set :updatePosition.18:dy 0.5
   515 set :updatePosition.18:value :updateRowPositionsEven.2:col2
-    * jump *label134 lessThanEq :updatePosition.18:value :findBestPosition:best
-    * jump *label136 greaterThanEq :updatePosition.18:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.18:dx
-    * set :findBestPosition:bestY :updatePosition.18:dy
-    * set :findBestPosition:best :updatePosition.18:value
+  516 jump *label134 lessThanEq :updateRowPositionsEven.2:col2 :findBestPosition:best
+  517 jump *label136 greaterThanEq :updateRowPositionsEven.2:col2 0.0784313725490196
+  518 set :findBestPosition:bestX -0.5
+  519 set :findBestPosition:bestY :updateRowPositionsEven.2:dy
+  520 set :findBestPosition:best :updateRowPositionsEven.2:col2
   521 label *label136
   522 label *label137
   523 label *label134
   524 label *label135
   525 label *label133
   526 set :updatePosition.19:dx 0.5
-    * set :updatePosition.19:dy :updateRowPositionsEven.2:dy
+  527 set :updatePosition.19:dy 0.5
   528 set :updatePosition.19:value :updateRowPositionsEven.2:col3
-    * jump *label139 lessThanEq :updatePosition.19:value :findBestPosition:best
-    * jump *label141 greaterThanEq :updatePosition.19:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.19:dx
-    * set :findBestPosition:bestY :updatePosition.19:dy
-    * set :findBestPosition:best :updatePosition.19:value
+  529 jump *label139 lessThanEq :updateRowPositionsEven.2:col3 :findBestPosition:best
+  530 jump *label141 greaterThanEq :updateRowPositionsEven.2:col3 0.0784313725490196
+  531 set :findBestPosition:bestX 0.5
+  532 set :findBestPosition:bestY :updateRowPositionsEven.2:dy
+  533 set :findBestPosition:best :updateRowPositionsEven.2:col3
   534 label *label141
   535 label *label142
   536 label *label139
   537 label *label140
   538 label *label138
   539 set :updatePosition.20:dx 1.5
-    * set :updatePosition.20:dy :updateRowPositionsEven.2:dy
+  540 set :updatePosition.20:dy 0.5
   541 set :updatePosition.20:value :updateRowPositionsEven.2:col4
-    * jump *label144 lessThanEq :updatePosition.20:value :findBestPosition:best
-    * jump *label146 greaterThanEq :updatePosition.20:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.20:dx
-    * set :findBestPosition:bestY :updatePosition.20:dy
-    * set :findBestPosition:best :updatePosition.20:value
+  542 jump *label144 lessThanEq :updateRowPositionsEven.2:col4 :findBestPosition:best
+  543 jump *label146 greaterThanEq :updateRowPositionsEven.2:col4 0.0784313725490196
+  544 set :findBestPosition:bestX 1.5
+  545 set :findBestPosition:bestY :updateRowPositionsEven.2:dy
+  546 set :findBestPosition:best :updateRowPositionsEven.2:col4
   547 label *label146
   548 label *label147
   549 label *label144
 
   552 label *label127
   553 set :updateRowPositionsEven.3:dy 1.5
   554 set :updateRowPositionsEven.3:rowSum :findBestPosition:row4
-    * unpackcolor :updateRowPositionsEven.3:col1 :updateRowPositionsEven.3:col2 :updateRowPositionsEven.3:col3 :updateRowPositionsEven.3:col4 :updateRowPositionsEven.3:rowSum
+  555 unpackcolor :updateRowPositionsEven.3:col1 :updateRowPositionsEven.3:col2 :updateRowPositionsEven.3:col3 :updateRowPositionsEven.3:col4 :findBestPosition:row4
   556 set :updatePosition.21:dx -1.5
-    * set :updatePosition.21:dy :updateRowPositionsEven.3:dy
+  557 set :updatePosition.21:dy 1.5
   558 set :updatePosition.21:value :updateRowPositionsEven.3:col1
-    * jump *label150 lessThanEq :updatePosition.21:value :findBestPosition:best
-    * jump *label152 greaterThanEq :updatePosition.21:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.21:dx
-    * set :findBestPosition:bestY :updatePosition.21:dy
-    * set :findBestPosition:best :updatePosition.21:value
+  559 jump *label150 lessThanEq :updateRowPositionsEven.3:col1 :findBestPosition:best
+  560 jump *label152 greaterThanEq :updateRowPositionsEven.3:col1 0.0784313725490196
+  561 set :findBestPosition:bestX -1.5
+  562 set :findBestPosition:bestY :updateRowPositionsEven.3:dy
+  563 set :findBestPosition:best :updateRowPositionsEven.3:col1
   564 label *label152
   565 label *label153
   566 label *label150
   567 label *label151
   568 label *label149
   569 set :updatePosition.22:dx -0.5
-    * set :updatePosition.22:dy :updateRowPositionsEven.3:dy
+  570 set :updatePosition.22:dy 1.5
   571 set :updatePosition.22:value :updateRowPositionsEven.3:col2
-    * jump *label155 lessThanEq :updatePosition.22:value :findBestPosition:best
-    * jump *label157 greaterThanEq :updatePosition.22:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.22:dx
-    * set :findBestPosition:bestY :updatePosition.22:dy
-    * set :findBestPosition:best :updatePosition.22:value
+  572 jump *label155 lessThanEq :updateRowPositionsEven.3:col2 :findBestPosition:best
+  573 jump *label157 greaterThanEq :updateRowPositionsEven.3:col2 0.0784313725490196
+  574 set :findBestPosition:bestX -0.5
+  575 set :findBestPosition:bestY :updateRowPositionsEven.3:dy
+  576 set :findBestPosition:best :updateRowPositionsEven.3:col2
   577 label *label157
   578 label *label158
   579 label *label155
   580 label *label156
   581 label *label154
   582 set :updatePosition.23:dx 0.5
-    * set :updatePosition.23:dy :updateRowPositionsEven.3:dy
+  583 set :updatePosition.23:dy 1.5
   584 set :updatePosition.23:value :updateRowPositionsEven.3:col3
-    * jump *label160 lessThanEq :updatePosition.23:value :findBestPosition:best
-    * jump *label162 greaterThanEq :updatePosition.23:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.23:dx
-    * set :findBestPosition:bestY :updatePosition.23:dy
-    * set :findBestPosition:best :updatePosition.23:value
+  585 jump *label160 lessThanEq :updateRowPositionsEven.3:col3 :findBestPosition:best
+  586 jump *label162 greaterThanEq :updateRowPositionsEven.3:col3 0.0784313725490196
+  587 set :findBestPosition:bestX 0.5
+  588 set :findBestPosition:bestY :updateRowPositionsEven.3:dy
+  589 set :findBestPosition:best :updateRowPositionsEven.3:col3
   590 label *label162
   591 label *label163
   592 label *label160
   593 label *label161
   594 label *label159
   595 set :updatePosition.24:dx 1.5
-    * set :updatePosition.24:dy :updateRowPositionsEven.3:dy
+  596 set :updatePosition.24:dy 1.5
   597 set :updatePosition.24:value :updateRowPositionsEven.3:col4
-    * jump *label165 lessThanEq :updatePosition.24:value :findBestPosition:best
-    * jump *label167 greaterThanEq :updatePosition.24:value 0.0784313725490196
-    * set :findBestPosition:bestX :updatePosition.24:dx
-    * set :findBestPosition:bestY :updatePosition.24:dy
-    * set :findBestPosition:best :updatePosition.24:value
+  598 jump *label165 lessThanEq :updateRowPositionsEven.3:col4 :findBestPosition:best
+  599 jump *label167 greaterThanEq :updateRowPositionsEven.3:col4 0.0784313725490196
+  600 set :findBestPosition:bestX 1.5
+  601 set :findBestPosition:bestY :updateRowPositionsEven.3:dy
+  602 set :findBestPosition:best :updateRowPositionsEven.3:col4
   603 label *label167
   604 label *label168
   605 label *label165
 
   609 label *label32
   610 op mul :findBestPosition*retval :findBestPosition:best 255
   611 jump *label25 always
-    * set :findBestPosition*retval null
   612 label *label25
   613 set :findBestPosition*finished true
   614 jump *label4 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-99 instructions):
 
    23 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    24 sensor solid type @solid
    25 select :isSolid:result notEqual solid false 1 0
-    * set *tmp3 :isSolid:result
    26 label *label12
    27 op or :createTerrainMask:result *tmp0 :isSolid:result
    28 label *label10
 
    49 select :tileValue:result notEqual solid false 0.09803921568627451 value
    50 set *tmp6 :tileValue:result
    51 label *label14
-    * set :computeRowValues:x1 :tileValue:result
    52 op sub :tileValue.1:x :computeRowValues:x 1
    53 set :tileValue.1:y :computeRowValues:y
    54 set :tileValue.1:ore :computeRowValues:ore
 
    58 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
    59 set *tmp8 :tileValue.1:result
    60 label *label15
-    * set :computeRowValues:x2 :tileValue.1:result
    61 set :tileValue.2:x :computeRowValues:x
    62 set :tileValue.2:y :computeRowValues:y
    63 set :tileValue.2:ore :computeRowValues:ore
 
    67 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
    68 set *tmp10 :tileValue.2:result
    69 label *label16
-    * set :computeRowValues:x3 :tileValue.2:result
    70 op add :tileValue.3:x :computeRowValues:x 1
    71 set :tileValue.3:y :computeRowValues:y
    72 set :tileValue.3:ore :computeRowValues:ore
 
    76 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
    77 set *tmp12 :tileValue.3:result
    78 label *label17
-    * set :computeRowValues:x4 :tileValue.3:result
    79 op add :tileValue.4:x :computeRowValues:x 2
    80 set :tileValue.4:y :computeRowValues:y
    81 set :tileValue.4:ore :computeRowValues:ore
 
    85 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
    86 set *tmp14 :tileValue.4:result
    87 label *label18
-    * set :computeRowValues:x5 :tileValue.4:result
    88 jump *label19 notEqual :computeRowValues:size 2
-    * op add *tmp17 *tmp6 *tmp8
-    * op add *tmp18 *tmp8 *tmp10
-    * op add *tmp19 *tmp10 *tmp12
-    * op add *tmp20 *tmp12 *tmp14
+   89 op add *tmp17 :tileValue:result :tileValue.1:result
+   90 op add *tmp18 :tileValue.1:result :tileValue.2:result
+   91 op add *tmp19 :tileValue.2:result :tileValue.3:result
+   92 op add *tmp20 :tileValue.3:result :tileValue.4:result
    93 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
    94 jump *label13 always
    95 jump *label20 always
    96 label *label19
    97 jump *label21 notEqual :computeRowValues:size 3
-    * op add *tmp24 *tmp8 *tmp10
-    * op add *tmp25 *tmp6 *tmp24
-    * op add *tmp26 *tmp8 *tmp10
-    * op add *tmp27 *tmp24 *tmp12
-    * op add *tmp28 *tmp10 *tmp12
-    * op add *tmp29 *tmp28 *tmp14
+   98 op add *tmp24 :tileValue.1:result :tileValue.2:result
+   99 op add *tmp25 :tileValue:result *tmp24
+  100 op add *tmp26 :tileValue.1:result :tileValue.2:result
+  101 op add *tmp27 *tmp24 :tileValue.3:result
+  102 op add *tmp28 :tileValue.2:result :tileValue.3:result
+  103 op add *tmp29 *tmp28 :tileValue.4:result
   104 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
   105 jump *label13 always
   106 jump *label22 always
 
   114 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
   115 set *tmp32 :tileValue.5:result
   116 label *label23
-    * set :computeRowValues:x0 :tileValue.5:result
   117 op add :tileValue.6:x :computeRowValues:x 3
   118 set :tileValue.6:y :computeRowValues:y
   119 set :tileValue.6:ore :computeRowValues:ore
 
   123 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
   124 set *tmp34 :tileValue.6:result
   125 label *label24
-    * set :computeRowValues:x6 :tileValue.6:result
-    * op add *tmp35 *tmp6 *tmp8
-    * op add *tmp36 *tmp35 *tmp10
-    * op add *tmp37 *tmp32 *tmp36
+  126 op add *tmp35 :tileValue:result :tileValue.1:result
+  127 op add *tmp36 *tmp35 :tileValue.2:result
+  128 op add *tmp37 :tileValue.5:result *tmp36
   129 op min *tmp38 0.09803921568627451 *tmp37
-    * op add *tmp39 *tmp6 *tmp8
-    * op add *tmp40 *tmp35 *tmp10
-    * op add *tmp41 *tmp36 *tmp12
+  130 op add *tmp39 :tileValue:result :tileValue.1:result
+  131 op add *tmp40 *tmp35 :tileValue.2:result
+  132 op add *tmp41 *tmp36 :tileValue.3:result
   133 op min *tmp42 0.09803921568627451 *tmp41
-    * op add *tmp43 *tmp10 *tmp12
-    * op add *tmp44 *tmp43 *tmp14
-    * op add *tmp45 *tmp8 *tmp44
+  134 op add *tmp43 :tileValue.2:result :tileValue.3:result
+  135 op add *tmp44 *tmp43 :tileValue.4:result
+  136 op add *tmp45 :tileValue.1:result *tmp44
   137 op min *tmp46 0.09803921568627451 *tmp45
-    * op add *tmp47 *tmp10 *tmp12
-    * op add *tmp48 *tmp43 *tmp14
-    * op add *tmp49 *tmp44 *tmp34
+  138 op add *tmp47 :tileValue.2:result :tileValue.3:result
+  139 op add *tmp48 *tmp43 :tileValue.4:result
+  140 op add *tmp49 *tmp44 :tileValue.6:result
   141 op min *tmp50 0.09803921568627451 *tmp49
   142 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
   143 jump *label13 always
   144 label *label22
-    * set *tmp16 null
   145 label *label20
-    * set :computeRowValues*retval null
   146 label *label13
   147 return :computeRowValues*retaddr
   148 end
 
   166 call *label2 *invalid :computeRowValues*retval (m:*label27) (h:*label27)
   167 label *label27
   168 set :findBestPosition:y2 :computeRowValues*retval
-    * set *tmp56 :findBestPosition:y
   169 set :computeRowValues:x :findBestPosition:x
   170 set :computeRowValues:y :findBestPosition:y
   171 set :computeRowValues:ore :findBestPosition:ore
 
   198 jump *label31 notEqual :findBestPosition:size 3
   199 op add *tmp64 :findBestPosition:y2 :findBestPosition:y3
   200 op add :findBestPosition:row1 :findBestPosition:y1 *tmp64
-    * op add *tmp66 :findBestPosition:y2 :findBestPosition:y3
   201 op add :findBestPosition:row2 *tmp64 :findBestPosition:y4
   202 op add *tmp68 :findBestPosition:y3 :findBestPosition:y4
   203 op add :findBestPosition:row3 *tmp68 :computeRowValues*retval
   204 set :updateRowPositionsOdd:dy -1
-    * set :updateRowPositionsOdd:rowSum :findBestPosition:row1
   205 unpackcolor :updateRowPositionsOdd:col1 :updateRowPositionsOdd:col2 :updateRowPositionsOdd:col3 *tmp70 :findBestPosition:row1
-    * set :updatePosition:dx -1
-    * set :updatePosition:dy -1
-    * set :updatePosition:value :updateRowPositionsOdd:col1
   206 jump *label35 lessThanEq :updateRowPositionsOdd:col1 0
   207 jump *label37 greaterThanEq :updateRowPositionsOdd:col1 0.0784313725490196
   208 set :findBestPosition:bestX -1
-    * set :findBestPosition:bestY :updateRowPositionsOdd:dy
+  209 set :findBestPosition:bestY -1
   210 set :findBestPosition:best :updateRowPositionsOdd:col1
   211 label *label37
   212 label *label38
   213 label *label35
   214 label *label36
   215 label *label34
-    * set :updatePosition.1:dx 0
-    * set :updatePosition.1:dy -1
-    * set :updatePosition.1:value :updateRowPositionsOdd:col2
   216 jump *label40 lessThanEq :updateRowPositionsOdd:col2 :findBestPosition:best
   217 jump *label42 greaterThanEq :updateRowPositionsOdd:col2 0.0784313725490196
   218 set :findBestPosition:bestX 0
-    * set :findBestPosition:bestY :updateRowPositionsOdd:dy
+  219 set :findBestPosition:bestY -1
   220 set :findBestPosition:best :updateRowPositionsOdd:col2
   221 label *label42
   222 label *label43
   223 label *label40
   224 label *label41
   225 label *label39
-    * set :updatePosition.2:dx 1
-    * set :updatePosition.2:dy -1
-    * set :updatePosition.2:value :updateRowPositionsOdd:col3
   226 jump *label45 lessThanEq :updateRowPositionsOdd:col3 :findBestPosition:best
   227 jump *label47 greaterThanEq :updateRowPositionsOdd:col3 0.0784313725490196
   228 set :findBestPosition:bestX 1
-    * set :findBestPosition:bestY :updateRowPositionsOdd:dy
+  229 set :findBestPosition:bestY -1
   230 set :findBestPosition:best :updateRowPositionsOdd:col3
   231 label *label47
   232 label *label48
 
   235 label *label44
   236 label *label33
   237 set :updateRowPositionsOdd.1:dy 0
-    * set :updateRowPositionsOdd.1:rowSum :findBestPosition:row2
   238 unpackcolor :updateRowPositionsOdd.1:col1 :updateRowPositionsOdd.1:col2 :updateRowPositionsOdd.1:col3 *tmp83 :findBestPosition:row2
-    * set :updatePosition.3:dx -1
-    * set :updatePosition.3:dy 0
-    * set :updatePosition.3:value :updateRowPositionsOdd.1:col1
   239 jump *label51 lessThanEq :updateRowPositionsOdd.1:col1 :findBestPosition:best
   240 jump *label53 greaterThanEq :updateRowPositionsOdd.1:col1 0.0784313725490196
   241 set :findBestPosition:bestX -1
-    * set :findBestPosition:bestY :updateRowPositionsOdd.1:dy
+  242 set :findBestPosition:bestY 0
   243 set :findBestPosition:best :updateRowPositionsOdd.1:col1
   244 label *label53
   245 label *label54
   246 label *label51
   247 label *label52
   248 label *label50
-    * set :updatePosition.4:dx 0
-    * set :updatePosition.4:dy 0
-    * set :updatePosition.4:value :updateRowPositionsOdd.1:col2
   249 jump *label56 lessThanEq :updateRowPositionsOdd.1:col2 :findBestPosition:best
   250 jump *label58 greaterThanEq :updateRowPositionsOdd.1:col2 0.0784313725490196
   251 set :findBestPosition:bestX 0
-    * set :findBestPosition:bestY :updateRowPositionsOdd.1:dy
+  252 set :findBestPosition:bestY 0
   253 set :findBestPosition:best :updateRowPositionsOdd.1:col2
   254 label *label58
   255 label *label59
   256 label *label56
   257 label *label57
   258 label *label55
-    * set :updatePosition.5:dx 1
-    * set :updatePosition.5:dy 0
-    * set :updatePosition.5:value :updateRowPositionsOdd.1:col3
   259 jump *label61 lessThanEq :updateRowPositionsOdd.1:col3 :findBestPosition:best
   260 jump *label63 greaterThanEq :updateRowPositionsOdd.1:col3 0.0784313725490196
   261 set :findBestPosition:bestX 1
-    * set :findBestPosition:bestY :updateRowPositionsOdd.1:dy
+  262 set :findBestPosition:bestY 0
   263 set :findBestPosition:best :updateRowPositionsOdd.1:col3
   264 label *label63
   265 label *label64
 
   268 label *label60
   269 label *label49
   270 set :updateRowPositionsOdd.2:dy 1
-    * set :updateRowPositionsOdd.2:rowSum :findBestPosition:row3
   271 unpackcolor :updateRowPositionsOdd.2:col1 :updateRowPositionsOdd.2:col2 :updateRowPositionsOdd.2:col3 *tmp96 :findBestPosition:row3
-    * set :updatePosition.6:dx -1
-    * set :updatePosition.6:dy 1
-    * set :updatePosition.6:value :updateRowPositionsOdd.2:col1
   272 jump *label67 lessThanEq :updateRowPositionsOdd.2:col1 :findBestPosition:best
   273 jump *label69 greaterThanEq :updateRowPositionsOdd.2:col1 0.0784313725490196
   274 set :findBestPosition:bestX -1
-    * set :findBestPosition:bestY :updateRowPositionsOdd.2:dy
+  275 set :findBestPosition:bestY 1
   276 set :findBestPosition:best :updateRowPositionsOdd.2:col1
   277 label *label69
   278 label *label70
   279 label *label67
   280 label *label68
   281 label *label66
-    * set :updatePosition.7:dx 0
-    * set :updatePosition.7:dy 1
-    * set :updatePosition.7:value :updateRowPositionsOdd.2:col2
   282 jump *label72 lessThanEq :updateRowPositionsOdd.2:col2 :findBestPosition:best
   283 jump *label74 greaterThanEq :updateRowPositionsOdd.2:col2 0.0784313725490196
   284 set :findBestPosition:bestX 0
-    * set :findBestPosition:bestY :updateRowPositionsOdd.2:dy
+  285 set :findBestPosition:bestY 1
   286 set :findBestPosition:best :updateRowPositionsOdd.2:col2
   287 label *label74
   288 label *label75
   289 label *label72
   290 label *label73
   291 label *label71
-    * set :updatePosition.8:dx 1
-    * set :updatePosition.8:dy 1
-    * set :updatePosition.8:value :updateRowPositionsOdd.2:col3
   292 jump *label77 lessThanEq :updateRowPositionsOdd.2:col3 :findBestPosition:best
   293 jump *label79 greaterThanEq :updateRowPositionsOdd.2:col3 0.0784313725490196
   294 set :findBestPosition:bestX 1
-    * set :findBestPosition:bestY :updateRowPositionsOdd.2:dy
+  295 set :findBestPosition:bestY 1
   296 set :findBestPosition:best :updateRowPositionsOdd.2:col3
   297 label *label79
   298 label *label80
 
   326 setaddr :computeRowValues*retaddr *label84 (h:*label84)
   327 call *label2 *invalid :computeRowValues*retval (m:*label84) (h:*label84)
   328 label *label84
-    * set :findBestPosition:y6 :computeRowValues*retval
   329 op add *tmp119 :findBestPosition:y1 :findBestPosition:y2
   330 op add *tmp120 *tmp119 :findBestPosition:y3
   331 op add :findBestPosition:row1 :findBestPosition:y0 *tmp120
-    * op add *tmp122 :findBestPosition:y1 :findBestPosition:y2
-    * op add *tmp123 *tmp119 :findBestPosition:y3
   332 op add :findBestPosition:row2 *tmp120 :findBestPosition:y4
   333 op add *tmp125 :findBestPosition:y3 :findBestPosition:y4
   334 op add *tmp126 *tmp125 :findBestPosition:y5
   335 op add :findBestPosition:row3 :findBestPosition:y2 *tmp126
-    * op add *tmp128 :findBestPosition:y3 :findBestPosition:y4
-    * op add *tmp129 *tmp125 :findBestPosition:y5
   336 op add :findBestPosition:row4 *tmp126 :computeRowValues*retval
   337 label *label82
   338 set :updateRowPositionsEven:dy -1.5
-    * set :updateRowPositionsEven:rowSum :findBestPosition:row1
   339 unpackcolor :updateRowPositionsEven:col1 :updateRowPositionsEven:col2 :updateRowPositionsEven:col3 :updateRowPositionsEven:col4 :findBestPosition:row1
-    * set :updatePosition.9:dx -1.5
-    * set :updatePosition.9:dy -1.5
-    * set :updatePosition.9:value :updateRowPositionsEven:col1
   340 jump *label87 lessThanEq :updateRowPositionsEven:col1 :findBestPosition:best
   341 jump *label89 greaterThanEq :updateRowPositionsEven:col1 0.0784313725490196
   342 set :findBestPosition:bestX -1.5
-    * set :findBestPosition:bestY :updateRowPositionsEven:dy
+  343 set :findBestPosition:bestY -1.5
   344 set :findBestPosition:best :updateRowPositionsEven:col1
   345 label *label89
   346 label *label90
   347 label *label87
   348 label *label88
   349 label *label86
-    * set :updatePosition.10:dx -0.5
-    * set :updatePosition.10:dy -1.5
-    * set :updatePosition.10:value :updateRowPositionsEven:col2
   350 jump *label92 lessThanEq :updateRowPositionsEven:col2 :findBestPosition:best
   351 jump *label94 greaterThanEq :updateRowPositionsEven:col2 0.0784313725490196
   352 set :findBestPosition:bestX -0.5
-    * set :findBestPosition:bestY :updateRowPositionsEven:dy
+  353 set :findBestPosition:bestY -1.5
   354 set :findBestPosition:best :updateRowPositionsEven:col2
   355 label *label94
   356 label *label95
   357 label *label92
   358 label *label93
   359 label *label91
-    * set :updatePosition.11:dx 0.5
-    * set :updatePosition.11:dy -1.5
-    * set :updatePosition.11:value :updateRowPositionsEven:col3
   360 jump *label97 lessThanEq :updateRowPositionsEven:col3 :findBestPosition:best
   361 jump *label99 greaterThanEq :updateRowPositionsEven:col3 0.0784313725490196
   362 set :findBestPosition:bestX 0.5
-    * set :findBestPosition:bestY :updateRowPositionsEven:dy
+  363 set :findBestPosition:bestY -1.5
   364 set :findBestPosition:best :updateRowPositionsEven:col3
   365 label *label99
   366 label *label100
   367 label *label97
   368 label *label98
   369 label *label96
-    * set :updatePosition.12:dx 1.5
-    * set :updatePosition.12:dy -1.5
-    * set :updatePosition.12:value :updateRowPositionsEven:col4
   370 jump *label102 lessThanEq :updateRowPositionsEven:col4 :findBestPosition:best
   371 jump *label104 greaterThanEq :updateRowPositionsEven:col4 0.0784313725490196
   372 set :findBestPosition:bestX 1.5
-    * set :findBestPosition:bestY :updateRowPositionsEven:dy
+  373 set :findBestPosition:bestY -1.5
   374 set :findBestPosition:best :updateRowPositionsEven:col4
   375 label *label104
   376 label *label105
 
   379 label *label101
   380 label *label85
   381 set :updateRowPositionsEven.1:dy -0.5
-    * set :updateRowPositionsEven.1:rowSum :findBestPosition:row2
   382 unpackcolor :updateRowPositionsEven.1:col1 :updateRowPositionsEven.1:col2 :updateRowPositionsEven.1:col3 :updateRowPositionsEven.1:col4 :findBestPosition:row2
-    * set :updatePosition.13:dx -1.5
-    * set :updatePosition.13:dy -0.5
-    * set :updatePosition.13:value :updateRowPositionsEven.1:col1
   383 jump *label108 lessThanEq :updateRowPositionsEven.1:col1 :findBestPosition:best
   384 jump *label110 greaterThanEq :updateRowPositionsEven.1:col1 0.0784313725490196
   385 set :findBestPosition:bestX -1.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.1:dy
+  386 set :findBestPosition:bestY -0.5
   387 set :findBestPosition:best :updateRowPositionsEven.1:col1
   388 label *label110
   389 label *label111
   390 label *label108
   391 label *label109
   392 label *label107
-    * set :updatePosition.14:dx -0.5
-    * set :updatePosition.14:dy -0.5
-    * set :updatePosition.14:value :updateRowPositionsEven.1:col2
   393 jump *label113 lessThanEq :updateRowPositionsEven.1:col2 :findBestPosition:best
   394 jump *label115 greaterThanEq :updateRowPositionsEven.1:col2 0.0784313725490196
   395 set :findBestPosition:bestX -0.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.1:dy
+  396 set :findBestPosition:bestY -0.5
   397 set :findBestPosition:best :updateRowPositionsEven.1:col2
   398 label *label115
   399 label *label116
   400 label *label113
   401 label *label114
   402 label *label112
-    * set :updatePosition.15:dx 0.5
-    * set :updatePosition.15:dy -0.5
-    * set :updatePosition.15:value :updateRowPositionsEven.1:col3
   403 jump *label118 lessThanEq :updateRowPositionsEven.1:col3 :findBestPosition:best
   404 jump *label120 greaterThanEq :updateRowPositionsEven.1:col3 0.0784313725490196
   405 set :findBestPosition:bestX 0.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.1:dy
+  406 set :findBestPosition:bestY -0.5
   407 set :findBestPosition:best :updateRowPositionsEven.1:col3
   408 label *label120
   409 label *label121
   410 label *label118
   411 label *label119
   412 label *label117
-    * set :updatePosition.16:dx 1.5
-    * set :updatePosition.16:dy -0.5
-    * set :updatePosition.16:value :updateRowPositionsEven.1:col4
   413 jump *label123 lessThanEq :updateRowPositionsEven.1:col4 :findBestPosition:best
   414 jump *label125 greaterThanEq :updateRowPositionsEven.1:col4 0.0784313725490196
   415 set :findBestPosition:bestX 1.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.1:dy
+  416 set :findBestPosition:bestY -0.5
   417 set :findBestPosition:best :updateRowPositionsEven.1:col4
   418 label *label125
   419 label *label126
 
   422 label *label122
   423 label *label106
   424 set :updateRowPositionsEven.2:dy 0.5
-    * set :updateRowPositionsEven.2:rowSum :findBestPosition:row3
   425 unpackcolor :updateRowPositionsEven.2:col1 :updateRowPositionsEven.2:col2 :updateRowPositionsEven.2:col3 :updateRowPositionsEven.2:col4 :findBestPosition:row3
-    * set :updatePosition.17:dx -1.5
-    * set :updatePosition.17:dy 0.5
-    * set :updatePosition.17:value :updateRowPositionsEven.2:col1
   426 jump *label129 lessThanEq :updateRowPositionsEven.2:col1 :findBestPosition:best
   427 jump *label131 greaterThanEq :updateRowPositionsEven.2:col1 0.0784313725490196
   428 set :findBestPosition:bestX -1.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.2:dy
+  429 set :findBestPosition:bestY 0.5
   430 set :findBestPosition:best :updateRowPositionsEven.2:col1
   431 label *label131
   432 label *label132
   433 label *label129
   434 label *label130
   435 label *label128
-    * set :updatePosition.18:dx -0.5
-    * set :updatePosition.18:dy 0.5
-    * set :updatePosition.18:value :updateRowPositionsEven.2:col2
   436 jump *label134 lessThanEq :updateRowPositionsEven.2:col2 :findBestPosition:best
   437 jump *label136 greaterThanEq :updateRowPositionsEven.2:col2 0.0784313725490196
   438 set :findBestPosition:bestX -0.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.2:dy
+  439 set :findBestPosition:bestY 0.5
   440 set :findBestPosition:best :updateRowPositionsEven.2:col2
   441 label *label136
   442 label *label137
   443 label *label134
   444 label *label135
   445 label *label133
-    * set :updatePosition.19:dx 0.5
-    * set :updatePosition.19:dy 0.5
-    * set :updatePosition.19:value :updateRowPositionsEven.2:col3
   446 jump *label139 lessThanEq :updateRowPositionsEven.2:col3 :findBestPosition:best
   447 jump *label141 greaterThanEq :updateRowPositionsEven.2:col3 0.0784313725490196
   448 set :findBestPosition:bestX 0.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.2:dy
+  449 set :findBestPosition:bestY 0.5
   450 set :findBestPosition:best :updateRowPositionsEven.2:col3
   451 label *label141
   452 label *label142
   453 label *label139
   454 label *label140
   455 label *label138
-    * set :updatePosition.20:dx 1.5
-    * set :updatePosition.20:dy 0.5
-    * set :updatePosition.20:value :updateRowPositionsEven.2:col4
   456 jump *label144 lessThanEq :updateRowPositionsEven.2:col4 :findBestPosition:best
   457 jump *label146 greaterThanEq :updateRowPositionsEven.2:col4 0.0784313725490196
   458 set :findBestPosition:bestX 1.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.2:dy
+  459 set :findBestPosition:bestY 0.5
   460 set :findBestPosition:best :updateRowPositionsEven.2:col4
   461 label *label146
   462 label *label147
 
   465 label *label143
   466 label *label127
   467 set :updateRowPositionsEven.3:dy 1.5
-    * set :updateRowPositionsEven.3:rowSum :findBestPosition:row4
   468 unpackcolor :updateRowPositionsEven.3:col1 :updateRowPositionsEven.3:col2 :updateRowPositionsEven.3:col3 :updateRowPositionsEven.3:col4 :findBestPosition:row4
-    * set :updatePosition.21:dx -1.5
-    * set :updatePosition.21:dy 1.5
-    * set :updatePosition.21:value :updateRowPositionsEven.3:col1
   469 jump *label150 lessThanEq :updateRowPositionsEven.3:col1 :findBestPosition:best
   470 jump *label152 greaterThanEq :updateRowPositionsEven.3:col1 0.0784313725490196
   471 set :findBestPosition:bestX -1.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.3:dy
+  472 set :findBestPosition:bestY 1.5
   473 set :findBestPosition:best :updateRowPositionsEven.3:col1
   474 label *label152
   475 label *label153
   476 label *label150
   477 label *label151
   478 label *label149
-    * set :updatePosition.22:dx -0.5
-    * set :updatePosition.22:dy 1.5
-    * set :updatePosition.22:value :updateRowPositionsEven.3:col2
   479 jump *label155 lessThanEq :updateRowPositionsEven.3:col2 :findBestPosition:best
   480 jump *label157 greaterThanEq :updateRowPositionsEven.3:col2 0.0784313725490196
   481 set :findBestPosition:bestX -0.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.3:dy
+  482 set :findBestPosition:bestY 1.5
   483 set :findBestPosition:best :updateRowPositionsEven.3:col2
   484 label *label157
   485 label *label158
   486 label *label155
   487 label *label156
   488 label *label154
-    * set :updatePosition.23:dx 0.5
-    * set :updatePosition.23:dy 1.5
-    * set :updatePosition.23:value :updateRowPositionsEven.3:col3
   489 jump *label160 lessThanEq :updateRowPositionsEven.3:col3 :findBestPosition:best
   490 jump *label162 greaterThanEq :updateRowPositionsEven.3:col3 0.0784313725490196
   491 set :findBestPosition:bestX 0.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.3:dy
+  492 set :findBestPosition:bestY 1.5
   493 set :findBestPosition:best :updateRowPositionsEven.3:col3
   494 label *label162
   495 label *label163
   496 label *label160
   497 label *label161
   498 label *label159
-    * set :updatePosition.24:dx 1.5
-    * set :updatePosition.24:dy 1.5
-    * set :updatePosition.24:value :updateRowPositionsEven.3:col4
   499 jump *label165 lessThanEq :updateRowPositionsEven.3:col4 :findBestPosition:best
   500 jump *label167 greaterThanEq :updateRowPositionsEven.3:col4 0.0784313725490196
   501 set :findBestPosition:bestX 1.5
-    * set :findBestPosition:bestY :updateRowPositionsEven.3:dy
+  502 set :findBestPosition:bestY 1.5
   503 set :findBestPosition:best :updateRowPositionsEven.3:col4
   504 label *label167
   505 label *label168

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-19 instructions):
 
    47 select value equal floor :tileValue:ore 0.00392156862745098 0
    48 sensor solid type @solid
    49 select :tileValue:result notEqual solid false 0.09803921568627451 value
-    * set *tmp6 :tileValue:result
    50 label *label14
    51 op sub :tileValue.1:x :computeRowValues:x 1
    52 set :tileValue.1:y :computeRowValues:y
 
    55 select value equal floor :tileValue.1:ore 0.00392156862745098 0
    56 sensor solid type @solid
    57 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
-    * set *tmp8 :tileValue.1:result
    58 label *label15
    59 set :tileValue.2:x :computeRowValues:x
    60 set :tileValue.2:y :computeRowValues:y
 
    63 select value equal floor :tileValue.2:ore 0.00392156862745098 0
    64 sensor solid type @solid
    65 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
-    * set *tmp10 :tileValue.2:result
    66 label *label16
    67 op add :tileValue.3:x :computeRowValues:x 1
    68 set :tileValue.3:y :computeRowValues:y
 
    71 select value equal floor :tileValue.3:ore 0.00392156862745098 0
    72 sensor solid type @solid
    73 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
-    * set *tmp12 :tileValue.3:result
    74 label *label17
    75 op add :tileValue.4:x :computeRowValues:x 2
    76 set :tileValue.4:y :computeRowValues:y
 
    79 select value equal floor :tileValue.4:ore 0.00392156862745098 0
    80 sensor solid type @solid
    81 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
-    * set *tmp14 :tileValue.4:result
    82 label *label18
    83 jump *label19 notEqual :computeRowValues:size 2
    84 op add *tmp17 :tileValue:result :tileValue.1:result
 
    92 jump *label21 notEqual :computeRowValues:size 3
    93 op add *tmp24 :tileValue.1:result :tileValue.2:result
    94 op add *tmp25 :tileValue:result *tmp24
-    * op add *tmp26 :tileValue.1:result :tileValue.2:result
    95 op add *tmp27 *tmp24 :tileValue.3:result
    96 op add *tmp28 :tileValue.2:result :tileValue.3:result
    97 op add *tmp29 *tmp28 :tileValue.4:result
 
   106 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   107 sensor solid type @solid
   108 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
-    * set *tmp32 :tileValue.5:result
   109 label *label23
   110 op add :tileValue.6:x :computeRowValues:x 3
   111 set :tileValue.6:y :computeRowValues:y
 
   114 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   115 sensor solid type @solid
   116 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
-    * set *tmp34 :tileValue.6:result
   117 label *label24
   118 op add *tmp35 :tileValue:result :tileValue.1:result
   119 op add *tmp36 *tmp35 :tileValue.2:result
   120 op add *tmp37 :tileValue.5:result *tmp36
   121 op min *tmp38 0.09803921568627451 *tmp37
-    * op add *tmp39 :tileValue:result :tileValue.1:result
-    * op add *tmp40 *tmp35 :tileValue.2:result
   122 op add *tmp41 *tmp36 :tileValue.3:result
   123 op min *tmp42 0.09803921568627451 *tmp41
   124 op add *tmp43 :tileValue.2:result :tileValue.3:result
   125 op add *tmp44 *tmp43 :tileValue.4:result
   126 op add *tmp45 :tileValue.1:result *tmp44
   127 op min *tmp46 0.09803921568627451 *tmp45
-    * op add *tmp47 :tileValue.2:result :tileValue.3:result
-    * op add *tmp48 *tmp43 :tileValue.4:result
   128 op add *tmp49 *tmp44 :tileValue.6:result
   129 op min *tmp50 0.09803921568627451 *tmp49
   130 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
 
   189 op add :findBestPosition:row2 *tmp64 :findBestPosition:y4
   190 op add *tmp68 :findBestPosition:y3 :findBestPosition:y4
   191 op add :findBestPosition:row3 *tmp68 :computeRowValues*retval
-    * set :updateRowPositionsOdd:dy -1
   192 unpackcolor :updateRowPositionsOdd:col1 :updateRowPositionsOdd:col2 :updateRowPositionsOdd:col3 *tmp70 :findBestPosition:row1
   193 jump *label35 lessThanEq :updateRowPositionsOdd:col1 0
   194 jump *label37 greaterThanEq :updateRowPositionsOdd:col1 0.0784313725490196
 
   221 label *label46
   222 label *label44
   223 label *label33
-    * set :updateRowPositionsOdd.1:dy 0
   224 unpackcolor :updateRowPositionsOdd.1:col1 :updateRowPositionsOdd.1:col2 :updateRowPositionsOdd.1:col3 *tmp83 :findBestPosition:row2
   225 jump *label51 lessThanEq :updateRowPositionsOdd.1:col1 :findBestPosition:best
   226 jump *label53 greaterThanEq :updateRowPositionsOdd.1:col1 0.0784313725490196
 
   253 label *label62
   254 label *label60
   255 label *label49
-    * set :updateRowPositionsOdd.2:dy 1
   256 unpackcolor :updateRowPositionsOdd.2:col1 :updateRowPositionsOdd.2:col2 :updateRowPositionsOdd.2:col3 *tmp96 :findBestPosition:row3
   257 jump *label67 lessThanEq :updateRowPositionsOdd.2:col1 :findBestPosition:best
   258 jump *label69 greaterThanEq :updateRowPositionsOdd.2:col1 0.0784313725490196
 
   320 op add :findBestPosition:row3 :findBestPosition:y2 *tmp126
   321 op add :findBestPosition:row4 *tmp126 :computeRowValues*retval
   322 label *label82
-    * set :updateRowPositionsEven:dy -1.5
   323 unpackcolor :updateRowPositionsEven:col1 :updateRowPositionsEven:col2 :updateRowPositionsEven:col3 :updateRowPositionsEven:col4 :findBestPosition:row1
   324 jump *label87 lessThanEq :updateRowPositionsEven:col1 :findBestPosition:best
   325 jump *label89 greaterThanEq :updateRowPositionsEven:col1 0.0784313725490196
 
   362 label *label103
   363 label *label101
   364 label *label85
-    * set :updateRowPositionsEven.1:dy -0.5
   365 unpackcolor :updateRowPositionsEven.1:col1 :updateRowPositionsEven.1:col2 :updateRowPositionsEven.1:col3 :updateRowPositionsEven.1:col4 :findBestPosition:row2
   366 jump *label108 lessThanEq :updateRowPositionsEven.1:col1 :findBestPosition:best
   367 jump *label110 greaterThanEq :updateRowPositionsEven.1:col1 0.0784313725490196
 
   404 label *label124
   405 label *label122
   406 label *label106
-    * set :updateRowPositionsEven.2:dy 0.5
   407 unpackcolor :updateRowPositionsEven.2:col1 :updateRowPositionsEven.2:col2 :updateRowPositionsEven.2:col3 :updateRowPositionsEven.2:col4 :findBestPosition:row3
   408 jump *label129 lessThanEq :updateRowPositionsEven.2:col1 :findBestPosition:best
   409 jump *label131 greaterThanEq :updateRowPositionsEven.2:col1 0.0784313725490196
 
   446 label *label145
   447 label *label143
   448 label *label127
-    * set :updateRowPositionsEven.3:dy 1.5
   449 unpackcolor :updateRowPositionsEven.3:col1 :updateRowPositionsEven.3:col2 :updateRowPositionsEven.3:col3 :updateRowPositionsEven.3:col4 :findBestPosition:row4
   450 jump *label150 lessThanEq :updateRowPositionsEven.3:col1 :findBestPosition:best
   451 jump *label152 greaterThanEq :updateRowPositionsEven.3:col1 0.0784313725490196

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    13 label *label6
    14 jump *label8 lessThan :createTerrainMask:r -3
    15 set :createTerrainMask:c 3
+   16 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
    17 label *label9
    18 jump *label11 lessThan :createTerrainMask:c -3
    19 op shl *tmp0 :createTerrainMask:result 1
    20 op add *tmp1 :createTerrainMask:x :createTerrainMask:c
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
    21 set :isSolid:x *tmp1
    22 set :isSolid:y *tmp2
    23 ucontrol getBlock :isSolid:x :isSolid:y type building floor

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-2 instructions):
 
    11 set :createTerrainMask:result 0
    12 set :createTerrainMask:r 3
    13 label *label6
-    * jump *label8 lessThan :createTerrainMask:r -3
+   14 label *label169
    15 set :createTerrainMask:c 3
    16 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
    17 label *label9
-    * jump *label11 lessThan :createTerrainMask:c -3
+   18 label *label170
    19 op shl *tmp0 :createTerrainMask:result 1
    20 op add *tmp1 :createTerrainMask:x :createTerrainMask:c
    21 set :isSolid:x *tmp1
 
    27 op or :createTerrainMask:result *tmp0 :isSolid:result
    28 label *label10
    29 op sub :createTerrainMask:c :createTerrainMask:c 1
-    * jump *label9 always
+   30 jump *label170 greaterThanEq :createTerrainMask:c -3
    31 label *label11
    32 label *label7
    33 op sub :createTerrainMask:r :createTerrainMask:r 1
-    * jump *label6 always
+   34 jump *label169 greaterThanEq :createTerrainMask:r -3
    35 label *label8
    36 set :createTerrainMask*retval :createTerrainMask:result
    37 jump *label5 always

Modifications by Unroll loop at line 30:9 (+53 instructions):
 
    12 set :createTerrainMask:r 3
    13 label *label6
    14 label *label169
-    * set :createTerrainMask:c 3
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
-    * label *label9
-    * label *label170
-    * op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x :createTerrainMask:c
-    * set :isSolid:x *tmp1
-    * set :isSolid:y *tmp2
-    * ucontrol getBlock :isSolid:x :isSolid:y type building floor
-    * sensor solid type @solid
-    * select :isSolid:result notEqual solid false 1 0
-    * label *label12
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label10
-    * op sub :createTerrainMask:c :createTerrainMask:c 1
-    * jump *label170 greaterThanEq :createTerrainMask:c -3
-    * label *label11
+   15 set :createTerrainMask:c 3
+   16 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+   17 label *label171
+   18 label *label172
+   19 op shl *tmp0 :createTerrainMask:result 1
+   20 op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   21 set :isSolid:x *tmp1
+   22 set :isSolid:y *tmp2
+   23 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   24 sensor solid type @solid
+   25 select :isSolid:result notEqual solid false 1 0
+   26 label *label173
+   27 op or :createTerrainMask:result *tmp0 :isSolid:result
+   28 label *label174
+   29 op sub :createTerrainMask:c :createTerrainMask:c 1
+   30 label *label175
+   31 op shl *tmp0 :createTerrainMask:result 1
+   32 op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   33 set :isSolid:x *tmp1
+   34 set :isSolid:y *tmp2
+   35 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   36 sensor solid type @solid
+   37 select :isSolid:result notEqual solid false 1 0
+   38 label *label176
+   39 op or :createTerrainMask:result *tmp0 :isSolid:result
+   40 label *label177
+   41 op sub :createTerrainMask:c :createTerrainMask:c 1
+   42 label *label178
+   43 op shl *tmp0 :createTerrainMask:result 1
+   44 op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   45 set :isSolid:x *tmp1
+   46 set :isSolid:y *tmp2
+   47 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   48 sensor solid type @solid
+   49 select :isSolid:result notEqual solid false 1 0
+   50 label *label179
+   51 op or :createTerrainMask:result *tmp0 :isSolid:result
+   52 label *label180
+   53 op sub :createTerrainMask:c :createTerrainMask:c 1
+   54 label *label181
+   55 op shl *tmp0 :createTerrainMask:result 1
+   56 op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   57 set :isSolid:x *tmp1
+   58 set :isSolid:y *tmp2
+   59 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   60 sensor solid type @solid
+   61 select :isSolid:result notEqual solid false 1 0
+   62 label *label182
+   63 op or :createTerrainMask:result *tmp0 :isSolid:result
+   64 label *label183
+   65 op sub :createTerrainMask:c :createTerrainMask:c 1
+   66 label *label184
+   67 op shl *tmp0 :createTerrainMask:result 1
+   68 op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   69 set :isSolid:x *tmp1
+   70 set :isSolid:y *tmp2
+   71 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   72 sensor solid type @solid
+   73 select :isSolid:result notEqual solid false 1 0
+   74 label *label185
+   75 op or :createTerrainMask:result *tmp0 :isSolid:result
+   76 label *label186
+   77 op sub :createTerrainMask:c :createTerrainMask:c 1
+   78 label *label187
+   79 op shl *tmp0 :createTerrainMask:result 1
+   80 op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   81 set :isSolid:x *tmp1
+   82 set :isSolid:y *tmp2
+   83 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   84 sensor solid type @solid
+   85 select :isSolid:result notEqual solid false 1 0
+   86 label *label188
+   87 op or :createTerrainMask:result *tmp0 :isSolid:result
+   88 label *label189
+   89 op sub :createTerrainMask:c :createTerrainMask:c 1
+   90 label *label190
+   91 op shl *tmp0 :createTerrainMask:result 1
+   92 op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   93 set :isSolid:x *tmp1
+   94 set :isSolid:y *tmp2
+   95 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   96 sensor solid type @solid
+   97 select :isSolid:result notEqual solid false 1 0
+   98 label *label191
+   99 op or :createTerrainMask:result *tmp0 :isSolid:result
+  100 label *label192
+  101 op sub :createTerrainMask:c :createTerrainMask:c 1
+  102 label *label11
   103 label *label7
   104 op sub :createTerrainMask:r :createTerrainMask:r 1
   105 jump *label169 greaterThanEq :createTerrainMask:r -3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    17 label *label171
    18 label *label172
    19 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   20 op add *tmp1 :createTerrainMask:x 3
    21 set :isSolid:x *tmp1
    22 set :isSolid:y *tmp2
    23 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
    26 label *label173
    27 op or :createTerrainMask:result *tmp0 :isSolid:result
    28 label *label174
-    * op sub :createTerrainMask:c :createTerrainMask:c 1
+   29 op sub :createTerrainMask:c 3 1
    30 label *label175
    31 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   32 op add *tmp1 :createTerrainMask:x 2
    33 set :isSolid:x *tmp1
    34 set :isSolid:y *tmp2
    35 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
    38 label *label176
    39 op or :createTerrainMask:result *tmp0 :isSolid:result
    40 label *label177
-    * op sub :createTerrainMask:c :createTerrainMask:c 1
+   41 op sub :createTerrainMask:c 2 1
    42 label *label178
    43 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   44 op add *tmp1 :createTerrainMask:x 1
    45 set :isSolid:x *tmp1
    46 set :isSolid:y *tmp2
    47 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
    50 label *label179
    51 op or :createTerrainMask:result *tmp0 :isSolid:result
    52 label *label180
-    * op sub :createTerrainMask:c :createTerrainMask:c 1
+   53 op sub :createTerrainMask:c 1 1
    54 label *label181
    55 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   56 op add *tmp1 :createTerrainMask:x 0
    57 set :isSolid:x *tmp1
    58 set :isSolid:y *tmp2
    59 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
    62 label *label182
    63 op or :createTerrainMask:result *tmp0 :isSolid:result
    64 label *label183
-    * op sub :createTerrainMask:c :createTerrainMask:c 1
+   65 op sub :createTerrainMask:c 0 1
    66 label *label184
    67 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   68 op add *tmp1 :createTerrainMask:x -1
    69 set :isSolid:x *tmp1
    70 set :isSolid:y *tmp2
    71 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
    74 label *label185
    75 op or :createTerrainMask:result *tmp0 :isSolid:result
    76 label *label186
-    * op sub :createTerrainMask:c :createTerrainMask:c 1
+   77 op sub :createTerrainMask:c -1 1
    78 label *label187
    79 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   80 op add *tmp1 :createTerrainMask:x -2
    81 set :isSolid:x *tmp1
    82 set :isSolid:y *tmp2
    83 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
    86 label *label188
    87 op or :createTerrainMask:result *tmp0 :isSolid:result
    88 label *label189
-    * op sub :createTerrainMask:c :createTerrainMask:c 1
+   89 op sub :createTerrainMask:c -2 1
    90 label *label190
    91 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x :createTerrainMask:c
+   92 op add *tmp1 :createTerrainMask:x -3
    93 set :isSolid:x *tmp1
    94 set :isSolid:y *tmp2
    95 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
    98 label *label191
    99 op or :createTerrainMask:result *tmp0 :isSolid:result
   100 label *label192
-    * op sub :createTerrainMask:c :createTerrainMask:c 1
+  101 op sub :createTerrainMask:c -3 1
   102 label *label11
   103 label *label7
   104 op sub :createTerrainMask:r :createTerrainMask:r 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-8 instructions):
 
    12 set :createTerrainMask:r 3
    13 label *label6
    14 label *label169
-    * set :createTerrainMask:c 3
    15 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
    16 label *label171
    17 label *label172
 
    25 label *label173
    26 op or :createTerrainMask:result *tmp0 :isSolid:result
    27 label *label174
-    * op sub :createTerrainMask:c 3 1
    28 label *label175
    29 op shl *tmp0 :createTerrainMask:result 1
    30 op add *tmp1 :createTerrainMask:x 2
 
    36 label *label176
    37 op or :createTerrainMask:result *tmp0 :isSolid:result
    38 label *label177
-    * op sub :createTerrainMask:c 2 1
    39 label *label178
    40 op shl *tmp0 :createTerrainMask:result 1
    41 op add *tmp1 :createTerrainMask:x 1
 
    47 label *label179
    48 op or :createTerrainMask:result *tmp0 :isSolid:result
    49 label *label180
-    * op sub :createTerrainMask:c 1 1
    50 label *label181
    51 op shl *tmp0 :createTerrainMask:result 1
    52 op add *tmp1 :createTerrainMask:x 0
 
    58 label *label182
    59 op or :createTerrainMask:result *tmp0 :isSolid:result
    60 label *label183
-    * op sub :createTerrainMask:c 0 1
    61 label *label184
    62 op shl *tmp0 :createTerrainMask:result 1
    63 op add *tmp1 :createTerrainMask:x -1
 
    69 label *label185
    70 op or :createTerrainMask:result *tmp0 :isSolid:result
    71 label *label186
-    * op sub :createTerrainMask:c -1 1
    72 label *label187
    73 op shl *tmp0 :createTerrainMask:result 1
    74 op add *tmp1 :createTerrainMask:x -2
 
    80 label *label188
    81 op or :createTerrainMask:result *tmp0 :isSolid:result
    82 label *label189
-    * op sub :createTerrainMask:c -2 1
    83 label *label190
    84 op shl *tmp0 :createTerrainMask:result 1
    85 op add *tmp1 :createTerrainMask:x -3
 
    91 label *label191
    92 op or :createTerrainMask:result *tmp0 :isSolid:result
    93 label *label192
-    * op sub :createTerrainMask:c -3 1
    94 label *label11
    95 label *label7
    96 op sub :createTerrainMask:r :createTerrainMask:r 1

Modifications by Unroll loop at line 29:5 (+347 instructions):
 
     9 label *label0
    10 ubind :createTerrainMask:unit
    11 set :createTerrainMask:result 0
-    * set :createTerrainMask:r 3
-    * label *label6
-    * label *label169
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
-    * label *label171
-    * label *label172
-    * op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 3
-    * set :isSolid:x *tmp1
-    * set :isSolid:y *tmp2
-    * ucontrol getBlock :isSolid:x :isSolid:y type building floor
-    * sensor solid type @solid
-    * select :isSolid:result notEqual solid false 1 0
-    * label *label173
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label174
-    * label *label175
-    * op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 2
-    * set :isSolid:x *tmp1
-    * set :isSolid:y *tmp2
-    * ucontrol getBlock :isSolid:x :isSolid:y type building floor
-    * sensor solid type @solid
-    * select :isSolid:result notEqual solid false 1 0
-    * label *label176
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label177
-    * label *label178
-    * op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 1
-    * set :isSolid:x *tmp1
-    * set :isSolid:y *tmp2
-    * ucontrol getBlock :isSolid:x :isSolid:y type building floor
-    * sensor solid type @solid
-    * select :isSolid:result notEqual solid false 1 0
-    * label *label179
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label180
-    * label *label181
-    * op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 0
-    * set :isSolid:x *tmp1
-    * set :isSolid:y *tmp2
-    * ucontrol getBlock :isSolid:x :isSolid:y type building floor
-    * sensor solid type @solid
-    * select :isSolid:result notEqual solid false 1 0
-    * label *label182
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label183
-    * label *label184
-    * op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -1
-    * set :isSolid:x *tmp1
-    * set :isSolid:y *tmp2
-    * ucontrol getBlock :isSolid:x :isSolid:y type building floor
-    * sensor solid type @solid
-    * select :isSolid:result notEqual solid false 1 0
-    * label *label185
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label186
-    * label *label187
-    * op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -2
-    * set :isSolid:x *tmp1
-    * set :isSolid:y *tmp2
-    * ucontrol getBlock :isSolid:x :isSolid:y type building floor
-    * sensor solid type @solid
-    * select :isSolid:result notEqual solid false 1 0
-    * label *label188
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label189
-    * label *label190
-    * op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -3
-    * set :isSolid:x *tmp1
-    * set :isSolid:y *tmp2
-    * ucontrol getBlock :isSolid:x :isSolid:y type building floor
-    * sensor solid type @solid
-    * select :isSolid:result notEqual solid false 1 0
-    * label *label191
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label192
-    * label *label11
-    * label *label7
-    * op sub :createTerrainMask:r :createTerrainMask:r 1
-    * jump *label169 greaterThanEq :createTerrainMask:r -3
-    * label *label8
+   12 set :createTerrainMask:r 3
+   13 label *label193
+   14 label *label194
+   15 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+   16 label *label195
+   17 label *label196
+   18 op shl *tmp0 :createTerrainMask:result 1
+   19 op add *tmp1 :createTerrainMask:x 3
+   20 set :isSolid:x *tmp1
+   21 set :isSolid:y *tmp2
+   22 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   23 sensor solid type @solid
+   24 select :isSolid:result notEqual solid false 1 0
+   25 label *label197
+   26 op or :createTerrainMask:result *tmp0 :isSolid:result
+   27 label *label198
+   28 label *label199
+   29 op shl *tmp0 :createTerrainMask:result 1
+   30 op add *tmp1 :createTerrainMask:x 2
+   31 set :isSolid:x *tmp1
+   32 set :isSolid:y *tmp2
+   33 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   34 sensor solid type @solid
+   35 select :isSolid:result notEqual solid false 1 0
+   36 label *label200
+   37 op or :createTerrainMask:result *tmp0 :isSolid:result
+   38 label *label201
+   39 label *label202
+   40 op shl *tmp0 :createTerrainMask:result 1
+   41 op add *tmp1 :createTerrainMask:x 1
+   42 set :isSolid:x *tmp1
+   43 set :isSolid:y *tmp2
+   44 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   45 sensor solid type @solid
+   46 select :isSolid:result notEqual solid false 1 0
+   47 label *label203
+   48 op or :createTerrainMask:result *tmp0 :isSolid:result
+   49 label *label204
+   50 label *label205
+   51 op shl *tmp0 :createTerrainMask:result 1
+   52 op add *tmp1 :createTerrainMask:x 0
+   53 set :isSolid:x *tmp1
+   54 set :isSolid:y *tmp2
+   55 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   56 sensor solid type @solid
+   57 select :isSolid:result notEqual solid false 1 0
+   58 label *label206
+   59 op or :createTerrainMask:result *tmp0 :isSolid:result
+   60 label *label207
+   61 label *label208
+   62 op shl *tmp0 :createTerrainMask:result 1
+   63 op add *tmp1 :createTerrainMask:x -1
+   64 set :isSolid:x *tmp1
+   65 set :isSolid:y *tmp2
+   66 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   67 sensor solid type @solid
+   68 select :isSolid:result notEqual solid false 1 0
+   69 label *label209
+   70 op or :createTerrainMask:result *tmp0 :isSolid:result
+   71 label *label210
+   72 label *label211
+   73 op shl *tmp0 :createTerrainMask:result 1
+   74 op add *tmp1 :createTerrainMask:x -2
+   75 set :isSolid:x *tmp1
+   76 set :isSolid:y *tmp2
+   77 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   78 sensor solid type @solid
+   79 select :isSolid:result notEqual solid false 1 0
+   80 label *label212
+   81 op or :createTerrainMask:result *tmp0 :isSolid:result
+   82 label *label213
+   83 label *label214
+   84 op shl *tmp0 :createTerrainMask:result 1
+   85 op add *tmp1 :createTerrainMask:x -3
+   86 set :isSolid:x *tmp1
+   87 set :isSolid:y *tmp2
+   88 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+   89 sensor solid type @solid
+   90 select :isSolid:result notEqual solid false 1 0
+   91 label *label215
+   92 op or :createTerrainMask:result *tmp0 :isSolid:result
+   93 label *label216
+   94 label *label217
+   95 label *label218
+   96 op sub :createTerrainMask:r :createTerrainMask:r 1
+   97 label *label219
+   98 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+   99 label *label220
+  100 label *label221
+  101 op shl *tmp0 :createTerrainMask:result 1
+  102 op add *tmp1 :createTerrainMask:x 3
+  103 set :isSolid:x *tmp1
+  104 set :isSolid:y *tmp2
+  105 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  106 sensor solid type @solid
+  107 select :isSolid:result notEqual solid false 1 0
+  108 label *label222
+  109 op or :createTerrainMask:result *tmp0 :isSolid:result
+  110 label *label223
+  111 label *label224
+  112 op shl *tmp0 :createTerrainMask:result 1
+  113 op add *tmp1 :createTerrainMask:x 2
+  114 set :isSolid:x *tmp1
+  115 set :isSolid:y *tmp2
+  116 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  117 sensor solid type @solid
+  118 select :isSolid:result notEqual solid false 1 0
+  119 label *label225
+  120 op or :createTerrainMask:result *tmp0 :isSolid:result
+  121 label *label226
+  122 label *label227
+  123 op shl *tmp0 :createTerrainMask:result 1
+  124 op add *tmp1 :createTerrainMask:x 1
+  125 set :isSolid:x *tmp1
+  126 set :isSolid:y *tmp2
+  127 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  128 sensor solid type @solid
+  129 select :isSolid:result notEqual solid false 1 0
+  130 label *label228
+  131 op or :createTerrainMask:result *tmp0 :isSolid:result
+  132 label *label229
+  133 label *label230
+  134 op shl *tmp0 :createTerrainMask:result 1
+  135 op add *tmp1 :createTerrainMask:x 0
+  136 set :isSolid:x *tmp1
+  137 set :isSolid:y *tmp2
+  138 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  139 sensor solid type @solid
+  140 select :isSolid:result notEqual solid false 1 0
+  141 label *label231
+  142 op or :createTerrainMask:result *tmp0 :isSolid:result
+  143 label *label232
+  144 label *label233
+  145 op shl *tmp0 :createTerrainMask:result 1
+  146 op add *tmp1 :createTerrainMask:x -1
+  147 set :isSolid:x *tmp1
+  148 set :isSolid:y *tmp2
+  149 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  150 sensor solid type @solid
+  151 select :isSolid:result notEqual solid false 1 0
+  152 label *label234
+  153 op or :createTerrainMask:result *tmp0 :isSolid:result
+  154 label *label235
+  155 label *label236
+  156 op shl *tmp0 :createTerrainMask:result 1
+  157 op add *tmp1 :createTerrainMask:x -2
+  158 set :isSolid:x *tmp1
+  159 set :isSolid:y *tmp2
+  160 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  161 sensor solid type @solid
+  162 select :isSolid:result notEqual solid false 1 0
+  163 label *label237
+  164 op or :createTerrainMask:result *tmp0 :isSolid:result
+  165 label *label238
+  166 label *label239
+  167 op shl *tmp0 :createTerrainMask:result 1
+  168 op add *tmp1 :createTerrainMask:x -3
+  169 set :isSolid:x *tmp1
+  170 set :isSolid:y *tmp2
+  171 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  172 sensor solid type @solid
+  173 select :isSolid:result notEqual solid false 1 0
+  174 label *label240
+  175 op or :createTerrainMask:result *tmp0 :isSolid:result
+  176 label *label241
+  177 label *label242
+  178 label *label243
+  179 op sub :createTerrainMask:r :createTerrainMask:r 1
+  180 label *label244
+  181 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  182 label *label245
+  183 label *label246
+  184 op shl *tmp0 :createTerrainMask:result 1
+  185 op add *tmp1 :createTerrainMask:x 3
+  186 set :isSolid:x *tmp1
+  187 set :isSolid:y *tmp2
+  188 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  189 sensor solid type @solid
+  190 select :isSolid:result notEqual solid false 1 0
+  191 label *label247
+  192 op or :createTerrainMask:result *tmp0 :isSolid:result
+  193 label *label248
+  194 label *label249
+  195 op shl *tmp0 :createTerrainMask:result 1
+  196 op add *tmp1 :createTerrainMask:x 2
+  197 set :isSolid:x *tmp1
+  198 set :isSolid:y *tmp2
+  199 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  200 sensor solid type @solid
+  201 select :isSolid:result notEqual solid false 1 0
+  202 label *label250
+  203 op or :createTerrainMask:result *tmp0 :isSolid:result
+  204 label *label251
+  205 label *label252
+  206 op shl *tmp0 :createTerrainMask:result 1
+  207 op add *tmp1 :createTerrainMask:x 1
+  208 set :isSolid:x *tmp1
+  209 set :isSolid:y *tmp2
+  210 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  211 sensor solid type @solid
+  212 select :isSolid:result notEqual solid false 1 0
+  213 label *label253
+  214 op or :createTerrainMask:result *tmp0 :isSolid:result
+  215 label *label254
+  216 label *label255
+  217 op shl *tmp0 :createTerrainMask:result 1
+  218 op add *tmp1 :createTerrainMask:x 0
+  219 set :isSolid:x *tmp1
+  220 set :isSolid:y *tmp2
+  221 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  222 sensor solid type @solid
+  223 select :isSolid:result notEqual solid false 1 0
+  224 label *label256
+  225 op or :createTerrainMask:result *tmp0 :isSolid:result
+  226 label *label257
+  227 label *label258
+  228 op shl *tmp0 :createTerrainMask:result 1
+  229 op add *tmp1 :createTerrainMask:x -1
+  230 set :isSolid:x *tmp1
+  231 set :isSolid:y *tmp2
+  232 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  233 sensor solid type @solid
+  234 select :isSolid:result notEqual solid false 1 0
+  235 label *label259
+  236 op or :createTerrainMask:result *tmp0 :isSolid:result
+  237 label *label260
+  238 label *label261
+  239 op shl *tmp0 :createTerrainMask:result 1
+  240 op add *tmp1 :createTerrainMask:x -2
+  241 set :isSolid:x *tmp1
+  242 set :isSolid:y *tmp2
+  243 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  244 sensor solid type @solid
+  245 select :isSolid:result notEqual solid false 1 0
+  246 label *label262
+  247 op or :createTerrainMask:result *tmp0 :isSolid:result
+  248 label *label263
+  249 label *label264
+  250 op shl *tmp0 :createTerrainMask:result 1
+  251 op add *tmp1 :createTerrainMask:x -3
+  252 set :isSolid:x *tmp1
+  253 set :isSolid:y *tmp2
+  254 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  255 sensor solid type @solid
+  256 select :isSolid:result notEqual solid false 1 0
+  257 label *label265
+  258 op or :createTerrainMask:result *tmp0 :isSolid:result
+  259 label *label266
+  260 label *label267
+  261 label *label268
+  262 op sub :createTerrainMask:r :createTerrainMask:r 1
+  263 label *label269
+  264 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  265 label *label270
+  266 label *label271
+  267 op shl *tmp0 :createTerrainMask:result 1
+  268 op add *tmp1 :createTerrainMask:x 3
+  269 set :isSolid:x *tmp1
+  270 set :isSolid:y *tmp2
+  271 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  272 sensor solid type @solid
+  273 select :isSolid:result notEqual solid false 1 0
+  274 label *label272
+  275 op or :createTerrainMask:result *tmp0 :isSolid:result
+  276 label *label273
+  277 label *label274
+  278 op shl *tmp0 :createTerrainMask:result 1
+  279 op add *tmp1 :createTerrainMask:x 2
+  280 set :isSolid:x *tmp1
+  281 set :isSolid:y *tmp2
+  282 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  283 sensor solid type @solid
+  284 select :isSolid:result notEqual solid false 1 0
+  285 label *label275
+  286 op or :createTerrainMask:result *tmp0 :isSolid:result
+  287 label *label276
+  288 label *label277
+  289 op shl *tmp0 :createTerrainMask:result 1
+  290 op add *tmp1 :createTerrainMask:x 1
+  291 set :isSolid:x *tmp1
+  292 set :isSolid:y *tmp2
+  293 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  294 sensor solid type @solid
+  295 select :isSolid:result notEqual solid false 1 0
+  296 label *label278
+  297 op or :createTerrainMask:result *tmp0 :isSolid:result
+  298 label *label279
+  299 label *label280
+  300 op shl *tmp0 :createTerrainMask:result 1
+  301 op add *tmp1 :createTerrainMask:x 0
+  302 set :isSolid:x *tmp1
+  303 set :isSolid:y *tmp2
+  304 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  305 sensor solid type @solid
+  306 select :isSolid:result notEqual solid false 1 0
+  307 label *label281
+  308 op or :createTerrainMask:result *tmp0 :isSolid:result
+  309 label *label282
+  310 label *label283
+  311 op shl *tmp0 :createTerrainMask:result 1
+  312 op add *tmp1 :createTerrainMask:x -1
+  313 set :isSolid:x *tmp1
+  314 set :isSolid:y *tmp2
+  315 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  316 sensor solid type @solid
+  317 select :isSolid:result notEqual solid false 1 0
+  318 label *label284
+  319 op or :createTerrainMask:result *tmp0 :isSolid:result
+  320 label *label285
+  321 label *label286
+  322 op shl *tmp0 :createTerrainMask:result 1
+  323 op add *tmp1 :createTerrainMask:x -2
+  324 set :isSolid:x *tmp1
+  325 set :isSolid:y *tmp2
+  326 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  327 sensor solid type @solid
+  328 select :isSolid:result notEqual solid false 1 0
+  329 label *label287
+  330 op or :createTerrainMask:result *tmp0 :isSolid:result
+  331 label *label288
+  332 label *label289
+  333 op shl *tmp0 :createTerrainMask:result 1
+  334 op add *tmp1 :createTerrainMask:x -3
+  335 set :isSolid:x *tmp1
+  336 set :isSolid:y *tmp2
+  337 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  338 sensor solid type @solid
+  339 select :isSolid:result notEqual solid false 1 0
+  340 label *label290
+  341 op or :createTerrainMask:result *tmp0 :isSolid:result
+  342 label *label291
+  343 label *label292
+  344 label *label293
+  345 op sub :createTerrainMask:r :createTerrainMask:r 1
+  346 label *label294
+  347 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  348 label *label295
+  349 label *label296
+  350 op shl *tmp0 :createTerrainMask:result 1
+  351 op add *tmp1 :createTerrainMask:x 3
+  352 set :isSolid:x *tmp1
+  353 set :isSolid:y *tmp2
+  354 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  355 sensor solid type @solid
+  356 select :isSolid:result notEqual solid false 1 0
+  357 label *label297
+  358 op or :createTerrainMask:result *tmp0 :isSolid:result
+  359 label *label298
+  360 label *label299
+  361 op shl *tmp0 :createTerrainMask:result 1
+  362 op add *tmp1 :createTerrainMask:x 2
+  363 set :isSolid:x *tmp1
+  364 set :isSolid:y *tmp2
+  365 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  366 sensor solid type @solid
+  367 select :isSolid:result notEqual solid false 1 0
+  368 label *label300
+  369 op or :createTerrainMask:result *tmp0 :isSolid:result
+  370 label *label301
+  371 label *label302
+  372 op shl *tmp0 :createTerrainMask:result 1
+  373 op add *tmp1 :createTerrainMask:x 1
+  374 set :isSolid:x *tmp1
+  375 set :isSolid:y *tmp2
+  376 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  377 sensor solid type @solid
+  378 select :isSolid:result notEqual solid false 1 0
+  379 label *label303
+  380 op or :createTerrainMask:result *tmp0 :isSolid:result
+  381 label *label304
+  382 label *label305
+  383 op shl *tmp0 :createTerrainMask:result 1
+  384 op add *tmp1 :createTerrainMask:x 0
+  385 set :isSolid:x *tmp1
+  386 set :isSolid:y *tmp2
+  387 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  388 sensor solid type @solid
+  389 select :isSolid:result notEqual solid false 1 0
+  390 label *label306
+  391 op or :createTerrainMask:result *tmp0 :isSolid:result
+  392 label *label307
+  393 label *label308
+  394 op shl *tmp0 :createTerrainMask:result 1
+  395 op add *tmp1 :createTerrainMask:x -1
+  396 set :isSolid:x *tmp1
+  397 set :isSolid:y *tmp2
+  398 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  399 sensor solid type @solid
+  400 select :isSolid:result notEqual solid false 1 0
+  401 label *label309
+  402 op or :createTerrainMask:result *tmp0 :isSolid:result
+  403 label *label310
+  404 label *label311
+  405 op shl *tmp0 :createTerrainMask:result 1
+  406 op add *tmp1 :createTerrainMask:x -2
+  407 set :isSolid:x *tmp1
+  408 set :isSolid:y *tmp2
+  409 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  410 sensor solid type @solid
+  411 select :isSolid:result notEqual solid false 1 0
+  412 label *label312
+  413 op or :createTerrainMask:result *tmp0 :isSolid:result
+  414 label *label313
+  415 label *label314
+  416 op shl *tmp0 :createTerrainMask:result 1
+  417 op add *tmp1 :createTerrainMask:x -3
+  418 set :isSolid:x *tmp1
+  419 set :isSolid:y *tmp2
+  420 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  421 sensor solid type @solid
+  422 select :isSolid:result notEqual solid false 1 0
+  423 label *label315
+  424 op or :createTerrainMask:result *tmp0 :isSolid:result
+  425 label *label316
+  426 label *label317
+  427 label *label318
+  428 op sub :createTerrainMask:r :createTerrainMask:r 1
+  429 label *label319
+  430 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  431 label *label320
+  432 label *label321
+  433 op shl *tmp0 :createTerrainMask:result 1
+  434 op add *tmp1 :createTerrainMask:x 3
+  435 set :isSolid:x *tmp1
+  436 set :isSolid:y *tmp2
+  437 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  438 sensor solid type @solid
+  439 select :isSolid:result notEqual solid false 1 0
+  440 label *label322
+  441 op or :createTerrainMask:result *tmp0 :isSolid:result
+  442 label *label323
+  443 label *label324
+  444 op shl *tmp0 :createTerrainMask:result 1
+  445 op add *tmp1 :createTerrainMask:x 2
+  446 set :isSolid:x *tmp1
+  447 set :isSolid:y *tmp2
+  448 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  449 sensor solid type @solid
+  450 select :isSolid:result notEqual solid false 1 0
+  451 label *label325
+  452 op or :createTerrainMask:result *tmp0 :isSolid:result
+  453 label *label326
+  454 label *label327
+  455 op shl *tmp0 :createTerrainMask:result 1
+  456 op add *tmp1 :createTerrainMask:x 1
+  457 set :isSolid:x *tmp1
+  458 set :isSolid:y *tmp2
+  459 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  460 sensor solid type @solid
+  461 select :isSolid:result notEqual solid false 1 0
+  462 label *label328
+  463 op or :createTerrainMask:result *tmp0 :isSolid:result
+  464 label *label329
+  465 label *label330
+  466 op shl *tmp0 :createTerrainMask:result 1
+  467 op add *tmp1 :createTerrainMask:x 0
+  468 set :isSolid:x *tmp1
+  469 set :isSolid:y *tmp2
+  470 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  471 sensor solid type @solid
+  472 select :isSolid:result notEqual solid false 1 0
+  473 label *label331
+  474 op or :createTerrainMask:result *tmp0 :isSolid:result
+  475 label *label332
+  476 label *label333
+  477 op shl *tmp0 :createTerrainMask:result 1
+  478 op add *tmp1 :createTerrainMask:x -1
+  479 set :isSolid:x *tmp1
+  480 set :isSolid:y *tmp2
+  481 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  482 sensor solid type @solid
+  483 select :isSolid:result notEqual solid false 1 0
+  484 label *label334
+  485 op or :createTerrainMask:result *tmp0 :isSolid:result
+  486 label *label335
+  487 label *label336
+  488 op shl *tmp0 :createTerrainMask:result 1
+  489 op add *tmp1 :createTerrainMask:x -2
+  490 set :isSolid:x *tmp1
+  491 set :isSolid:y *tmp2
+  492 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  493 sensor solid type @solid
+  494 select :isSolid:result notEqual solid false 1 0
+  495 label *label337
+  496 op or :createTerrainMask:result *tmp0 :isSolid:result
+  497 label *label338
+  498 label *label339
+  499 op shl *tmp0 :createTerrainMask:result 1
+  500 op add *tmp1 :createTerrainMask:x -3
+  501 set :isSolid:x *tmp1
+  502 set :isSolid:y *tmp2
+  503 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  504 sensor solid type @solid
+  505 select :isSolid:result notEqual solid false 1 0
+  506 label *label340
+  507 op or :createTerrainMask:result *tmp0 :isSolid:result
+  508 label *label341
+  509 label *label342
+  510 label *label343
+  511 op sub :createTerrainMask:r :createTerrainMask:r 1
+  512 label *label344
+  513 op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  514 label *label345
+  515 label *label346
+  516 op shl *tmp0 :createTerrainMask:result 1
+  517 op add *tmp1 :createTerrainMask:x 3
+  518 set :isSolid:x *tmp1
+  519 set :isSolid:y *tmp2
+  520 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  521 sensor solid type @solid
+  522 select :isSolid:result notEqual solid false 1 0
+  523 label *label347
+  524 op or :createTerrainMask:result *tmp0 :isSolid:result
+  525 label *label348
+  526 label *label349
+  527 op shl *tmp0 :createTerrainMask:result 1
+  528 op add *tmp1 :createTerrainMask:x 2
+  529 set :isSolid:x *tmp1
+  530 set :isSolid:y *tmp2
+  531 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  532 sensor solid type @solid
+  533 select :isSolid:result notEqual solid false 1 0
+  534 label *label350
+  535 op or :createTerrainMask:result *tmp0 :isSolid:result
+  536 label *label351
+  537 label *label352
+  538 op shl *tmp0 :createTerrainMask:result 1
+  539 op add *tmp1 :createTerrainMask:x 1
+  540 set :isSolid:x *tmp1
+  541 set :isSolid:y *tmp2
+  542 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  543 sensor solid type @solid
+  544 select :isSolid:result notEqual solid false 1 0
+  545 label *label353
+  546 op or :createTerrainMask:result *tmp0 :isSolid:result
+  547 label *label354
+  548 label *label355
+  549 op shl *tmp0 :createTerrainMask:result 1
+  550 op add *tmp1 :createTerrainMask:x 0
+  551 set :isSolid:x *tmp1
+  552 set :isSolid:y *tmp2
+  553 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  554 sensor solid type @solid
+  555 select :isSolid:result notEqual solid false 1 0
+  556 label *label356
+  557 op or :createTerrainMask:result *tmp0 :isSolid:result
+  558 label *label357
+  559 label *label358
+  560 op shl *tmp0 :createTerrainMask:result 1
+  561 op add *tmp1 :createTerrainMask:x -1
+  562 set :isSolid:x *tmp1
+  563 set :isSolid:y *tmp2
+  564 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  565 sensor solid type @solid
+  566 select :isSolid:result notEqual solid false 1 0
+  567 label *label359
+  568 op or :createTerrainMask:result *tmp0 :isSolid:result
+  569 label *label360
+  570 label *label361
+  571 op shl *tmp0 :createTerrainMask:result 1
+  572 op add *tmp1 :createTerrainMask:x -2
+  573 set :isSolid:x *tmp1
+  574 set :isSolid:y *tmp2
+  575 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  576 sensor solid type @solid
+  577 select :isSolid:result notEqual solid false 1 0
+  578 label *label362
+  579 op or :createTerrainMask:result *tmp0 :isSolid:result
+  580 label *label363
+  581 label *label364
+  582 op shl *tmp0 :createTerrainMask:result 1
+  583 op add *tmp1 :createTerrainMask:x -3
+  584 set :isSolid:x *tmp1
+  585 set :isSolid:y *tmp2
+  586 ucontrol getBlock :isSolid:x :isSolid:y type building floor
+  587 sensor solid type @solid
+  588 select :isSolid:result notEqual solid false 1 0
+  589 label *label365
+  590 op or :createTerrainMask:result *tmp0 :isSolid:result
+  591 label *label366
+  592 label *label367
+  593 label *label368
+  594 op sub :createTerrainMask:r :createTerrainMask:r 1
+  595 label *label8
   596 set :createTerrainMask*retval :createTerrainMask:result
   597 jump *label5 always
   598 label *label5

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    12 set :createTerrainMask:r 3
    13 label *label193
    14 label *label194
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+   15 op add *tmp2 :createTerrainMask:y 3
    16 label *label195
    17 label *label196
-    * op shl *tmp0 :createTerrainMask:result 1
+   18 op shl *tmp0 0 1
    19 op add *tmp1 :createTerrainMask:x 3
    20 set :isSolid:x *tmp1
    21 set :isSolid:y *tmp2
 
    23 sensor solid type @solid
    24 select :isSolid:result notEqual solid false 1 0
    25 label *label197
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
+   26 op or :createTerrainMask:result 0 :isSolid:result
    27 label *label198
    28 label *label199
    29 op shl *tmp0 :createTerrainMask:result 1
 
    93 label *label216
    94 label *label217
    95 label *label218
-    * op sub :createTerrainMask:r :createTerrainMask:r 1
+   96 op sub :createTerrainMask:r 3 1
    97 label *label219
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+   98 op add *tmp2 :createTerrainMask:y 2
    99 label *label220
   100 label *label221
   101 op shl *tmp0 :createTerrainMask:result 1
 
   176 label *label241
   177 label *label242
   178 label *label243
-    * op sub :createTerrainMask:r :createTerrainMask:r 1
+  179 op sub :createTerrainMask:r 2 1
   180 label *label244
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  181 op add *tmp2 :createTerrainMask:y 1
   182 label *label245
   183 label *label246
   184 op shl *tmp0 :createTerrainMask:result 1
 
   259 label *label266
   260 label *label267
   261 label *label268
-    * op sub :createTerrainMask:r :createTerrainMask:r 1
+  262 op sub :createTerrainMask:r 1 1
   263 label *label269
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  264 op add *tmp2 :createTerrainMask:y 0
   265 label *label270
   266 label *label271
   267 op shl *tmp0 :createTerrainMask:result 1
 
   342 label *label291
   343 label *label292
   344 label *label293
-    * op sub :createTerrainMask:r :createTerrainMask:r 1
+  345 op sub :createTerrainMask:r 0 1
   346 label *label294
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  347 op add *tmp2 :createTerrainMask:y -1
   348 label *label295
   349 label *label296
   350 op shl *tmp0 :createTerrainMask:result 1
 
   425 label *label316
   426 label *label317
   427 label *label318
-    * op sub :createTerrainMask:r :createTerrainMask:r 1
+  428 op sub :createTerrainMask:r -1 1
   429 label *label319
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  430 op add *tmp2 :createTerrainMask:y -2
   431 label *label320
   432 label *label321
   433 op shl *tmp0 :createTerrainMask:result 1
 
   508 label *label341
   509 label *label342
   510 label *label343
-    * op sub :createTerrainMask:r :createTerrainMask:r 1
+  511 op sub :createTerrainMask:r -2 1
   512 label *label344
-    * op add *tmp2 :createTerrainMask:y :createTerrainMask:r
+  513 op add *tmp2 :createTerrainMask:y -3
   514 label *label345
   515 label *label346
   516 op shl *tmp0 :createTerrainMask:result 1
 
   591 label *label366
   592 label *label367
   593 label *label368
-    * op sub :createTerrainMask:r :createTerrainMask:r 1
+  594 op sub :createTerrainMask:r -3 1
   595 label *label8
   596 set :createTerrainMask*retval :createTerrainMask:result
   597 jump *label5 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-10 instructions):
 
     8 end
     9 label *label0
    10 ubind :createTerrainMask:unit
-    * set :createTerrainMask:result 0
-    * set :createTerrainMask:r 3
    11 label *label193
    12 label *label194
    13 op add *tmp2 :createTerrainMask:y 3
    14 label *label195
    15 label *label196
-    * op shl *tmp0 0 1
    16 op add *tmp1 :createTerrainMask:x 3
    17 set :isSolid:x *tmp1
    18 set :isSolid:y *tmp2
 
    90 label *label216
    91 label *label217
    92 label *label218
-    * op sub :createTerrainMask:r 3 1
    93 label *label219
    94 op add *tmp2 :createTerrainMask:y 2
    95 label *label220
 
   172 label *label241
   173 label *label242
   174 label *label243
-    * op sub :createTerrainMask:r 2 1
   175 label *label244
   176 op add *tmp2 :createTerrainMask:y 1
   177 label *label245
 
   254 label *label266
   255 label *label267
   256 label *label268
-    * op sub :createTerrainMask:r 1 1
   257 label *label269
   258 op add *tmp2 :createTerrainMask:y 0
   259 label *label270
 
   336 label *label291
   337 label *label292
   338 label *label293
-    * op sub :createTerrainMask:r 0 1
   339 label *label294
   340 op add *tmp2 :createTerrainMask:y -1
   341 label *label295
 
   418 label *label316
   419 label *label317
   420 label *label318
-    * op sub :createTerrainMask:r -1 1
   421 label *label319
   422 op add *tmp2 :createTerrainMask:y -2
   423 label *label320
 
   500 label *label341
   501 label *label342
   502 label *label343
-    * op sub :createTerrainMask:r -2 1
   503 label *label344
   504 op add *tmp2 :createTerrainMask:y -3
   505 label *label345
 
   582 label *label366
   583 label *label367
   584 label *label368
-    * op sub :createTerrainMask:r -3 1
   585 label *label8
   586 set :createTerrainMask*retval :createTerrainMask:result
   587 jump *label5 always

Modifications by Inline function call at line 138:14 (+78 instructions):
 
   691 set :computeRowValues:y *tmp52
   692 set :computeRowValues:ore :findBestPosition:ore
   693 set :computeRowValues:size :findBestPosition:size
-    * setaddr :computeRowValues*retaddr *label26 (h:*label26)
-    * call *label2 *invalid :computeRowValues*retval (m:*label26) (h:*label26)
-    * label *label26
+  694 label *label369
+  695 op sub :tileValue:x :computeRowValues:x 2
+  696 set :tileValue:y :computeRowValues:y
+  697 set :tileValue:ore :computeRowValues:ore
+  698 ucontrol getBlock :tileValue:x :tileValue:y type building floor
+  699 select value equal floor :tileValue:ore 0.00392156862745098 0
+  700 sensor solid type @solid
+  701 select :tileValue:result notEqual solid false 0.09803921568627451 value
+  702 label *label370
+  703 op sub :tileValue.1:x :computeRowValues:x 1
+  704 set :tileValue.1:y :computeRowValues:y
+  705 set :tileValue.1:ore :computeRowValues:ore
+  706 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
+  707 select value equal floor :tileValue.1:ore 0.00392156862745098 0
+  708 sensor solid type @solid
+  709 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
+  710 label *label371
+  711 set :tileValue.2:x :computeRowValues:x
+  712 set :tileValue.2:y :computeRowValues:y
+  713 set :tileValue.2:ore :computeRowValues:ore
+  714 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
+  715 select value equal floor :tileValue.2:ore 0.00392156862745098 0
+  716 sensor solid type @solid
+  717 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
+  718 label *label372
+  719 op add :tileValue.3:x :computeRowValues:x 1
+  720 set :tileValue.3:y :computeRowValues:y
+  721 set :tileValue.3:ore :computeRowValues:ore
+  722 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
+  723 select value equal floor :tileValue.3:ore 0.00392156862745098 0
+  724 sensor solid type @solid
+  725 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
+  726 label *label373
+  727 op add :tileValue.4:x :computeRowValues:x 2
+  728 set :tileValue.4:y :computeRowValues:y
+  729 set :tileValue.4:ore :computeRowValues:ore
+  730 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
+  731 select value equal floor :tileValue.4:ore 0.00392156862745098 0
+  732 sensor solid type @solid
+  733 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
+  734 label *label374
+  735 jump *label375 notEqual :computeRowValues:size 2
+  736 op add *tmp17 :tileValue:result :tileValue.1:result
+  737 op add *tmp18 :tileValue.1:result :tileValue.2:result
+  738 op add *tmp19 :tileValue.2:result :tileValue.3:result
+  739 op add *tmp20 :tileValue.3:result :tileValue.4:result
+  740 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
+  741 jump *label381 always
+  742 jump *label380 always
+  743 label *label375
+  744 jump *label376 notEqual :computeRowValues:size 3
+  745 op add *tmp24 :tileValue.1:result :tileValue.2:result
+  746 op add *tmp25 :tileValue:result *tmp24
+  747 op add *tmp27 *tmp24 :tileValue.3:result
+  748 op add *tmp28 :tileValue.2:result :tileValue.3:result
+  749 op add *tmp29 *tmp28 :tileValue.4:result
+  750 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
+  751 jump *label381 always
+  752 jump *label379 always
+  753 label *label376
+  754 op sub :tileValue.5:x :computeRowValues:x 3
+  755 set :tileValue.5:y :computeRowValues:y
+  756 set :tileValue.5:ore :computeRowValues:ore
+  757 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
+  758 select value equal floor :tileValue.5:ore 0.00392156862745098 0
+  759 sensor solid type @solid
+  760 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
+  761 label *label377
+  762 op add :tileValue.6:x :computeRowValues:x 3
+  763 set :tileValue.6:y :computeRowValues:y
+  764 set :tileValue.6:ore :computeRowValues:ore
+  765 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
+  766 select value equal floor :tileValue.6:ore 0.00392156862745098 0
+  767 sensor solid type @solid
+  768 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
+  769 label *label378
+  770 op add *tmp35 :tileValue:result :tileValue.1:result
+  771 op add *tmp36 *tmp35 :tileValue.2:result
+  772 op add *tmp37 :tileValue.5:result *tmp36
+  773 op min *tmp38 0.09803921568627451 *tmp37
+  774 op add *tmp41 *tmp36 :tileValue.3:result
+  775 op min *tmp42 0.09803921568627451 *tmp41
+  776 op add *tmp43 :tileValue.2:result :tileValue.3:result
+  777 op add *tmp44 *tmp43 :tileValue.4:result
+  778 op add *tmp45 :tileValue.1:result *tmp44
+  779 op min *tmp46 0.09803921568627451 *tmp45
+  780 op add *tmp49 *tmp44 :tileValue.6:result
+  781 op min *tmp50 0.09803921568627451 *tmp49
+  782 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
+  783 jump *label381 always
+  784 label *label379
+  785 label *label380
+  786 label *label381
   787 set :findBestPosition:y1 :computeRowValues*retval
   788 op sub *tmp54 :findBestPosition:y 1
   789 set :computeRowValues:x :findBestPosition:x

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   692 set :computeRowValues:ore :findBestPosition:ore
   693 set :computeRowValues:size :findBestPosition:size
   694 label *label369
-    * op sub :tileValue:x :computeRowValues:x 2
-    * set :tileValue:y :computeRowValues:y
-    * set :tileValue:ore :computeRowValues:ore
+  695 op sub :tileValue:x :findBestPosition:x 2
+  696 set :tileValue:y *tmp52
+  697 set :tileValue:ore :findBestPosition:ore
   698 ucontrol getBlock :tileValue:x :tileValue:y type building floor
   699 select value equal floor :tileValue:ore 0.00392156862745098 0
   700 sensor solid type @solid
   701 select :tileValue:result notEqual solid false 0.09803921568627451 value
   702 label *label370
-    * op sub :tileValue.1:x :computeRowValues:x 1
-    * set :tileValue.1:y :computeRowValues:y
-    * set :tileValue.1:ore :computeRowValues:ore
+  703 op sub :tileValue.1:x :findBestPosition:x 1
+  704 set :tileValue.1:y *tmp52
+  705 set :tileValue.1:ore :findBestPosition:ore
   706 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
   707 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   708 sensor solid type @solid
   709 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
   710 label *label371
-    * set :tileValue.2:x :computeRowValues:x
-    * set :tileValue.2:y :computeRowValues:y
-    * set :tileValue.2:ore :computeRowValues:ore
+  711 set :tileValue.2:x :findBestPosition:x
+  712 set :tileValue.2:y *tmp52
+  713 set :tileValue.2:ore :findBestPosition:ore
   714 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
   715 select value equal floor :tileValue.2:ore 0.00392156862745098 0
   716 sensor solid type @solid
   717 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
   718 label *label372
-    * op add :tileValue.3:x :computeRowValues:x 1
-    * set :tileValue.3:y :computeRowValues:y
-    * set :tileValue.3:ore :computeRowValues:ore
+  719 op add :tileValue.3:x :findBestPosition:x 1
+  720 set :tileValue.3:y *tmp52
+  721 set :tileValue.3:ore :findBestPosition:ore
   722 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
   723 select value equal floor :tileValue.3:ore 0.00392156862745098 0
   724 sensor solid type @solid
   725 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
   726 label *label373
-    * op add :tileValue.4:x :computeRowValues:x 2
-    * set :tileValue.4:y :computeRowValues:y
-    * set :tileValue.4:ore :computeRowValues:ore
+  727 op add :tileValue.4:x :findBestPosition:x 2
+  728 set :tileValue.4:y *tmp52
+  729 set :tileValue.4:ore :findBestPosition:ore
   730 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
   731 select value equal floor :tileValue.4:ore 0.00392156862745098 0
   732 sensor solid type @solid
   733 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
   734 label *label374
-    * jump *label375 notEqual :computeRowValues:size 2
+  735 jump *label375 notEqual :findBestPosition:size 2
   736 op add *tmp17 :tileValue:result :tileValue.1:result
   737 op add *tmp18 :tileValue.1:result :tileValue.2:result
   738 op add *tmp19 :tileValue.2:result :tileValue.3:result
 
   741 jump *label381 always
   742 jump *label380 always
   743 label *label375
-    * jump *label376 notEqual :computeRowValues:size 3
+  744 jump *label376 notEqual :findBestPosition:size 3
   745 op add *tmp24 :tileValue.1:result :tileValue.2:result
   746 op add *tmp25 :tileValue:result *tmp24
   747 op add *tmp27 *tmp24 :tileValue.3:result
 
   751 jump *label381 always
   752 jump *label379 always
   753 label *label376
-    * op sub :tileValue.5:x :computeRowValues:x 3
-    * set :tileValue.5:y :computeRowValues:y
-    * set :tileValue.5:ore :computeRowValues:ore
+  754 op sub :tileValue.5:x :findBestPosition:x 3
+  755 set :tileValue.5:y *tmp52
+  756 set :tileValue.5:ore :findBestPosition:ore
   757 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
   758 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   759 sensor solid type @solid
   760 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
   761 label *label377
-    * op add :tileValue.6:x :computeRowValues:x 3
-    * set :tileValue.6:y :computeRowValues:y
-    * set :tileValue.6:ore :computeRowValues:ore
+  762 op add :tileValue.6:x :findBestPosition:x 3
+  763 set :tileValue.6:y *tmp52
+  764 set :tileValue.6:ore :findBestPosition:ore
   765 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
   766 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   767 sensor solid type @solid

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
   687 label *label1
   688 ubind :findBestPosition:unit
   689 op sub *tmp52 :findBestPosition:y 2
-    * set :computeRowValues:x :findBestPosition:x
-    * set :computeRowValues:y *tmp52
-    * set :computeRowValues:ore :findBestPosition:ore
-    * set :computeRowValues:size :findBestPosition:size
   690 label *label369
   691 op sub :tileValue:x :findBestPosition:x 2
   692 set :tileValue:y *tmp52

Modifications by Inline function call at line 139:14 (+78 instructions):
 
   786 set :computeRowValues:y *tmp54
   787 set :computeRowValues:ore :findBestPosition:ore
   788 set :computeRowValues:size :findBestPosition:size
-    * setaddr :computeRowValues*retaddr *label27 (h:*label27)
-    * call *label2 *invalid :computeRowValues*retval (m:*label27) (h:*label27)
-    * label *label27
+  789 label *label382
+  790 op sub :tileValue:x :computeRowValues:x 2
+  791 set :tileValue:y :computeRowValues:y
+  792 set :tileValue:ore :computeRowValues:ore
+  793 ucontrol getBlock :tileValue:x :tileValue:y type building floor
+  794 select value equal floor :tileValue:ore 0.00392156862745098 0
+  795 sensor solid type @solid
+  796 select :tileValue:result notEqual solid false 0.09803921568627451 value
+  797 label *label383
+  798 op sub :tileValue.1:x :computeRowValues:x 1
+  799 set :tileValue.1:y :computeRowValues:y
+  800 set :tileValue.1:ore :computeRowValues:ore
+  801 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
+  802 select value equal floor :tileValue.1:ore 0.00392156862745098 0
+  803 sensor solid type @solid
+  804 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
+  805 label *label384
+  806 set :tileValue.2:x :computeRowValues:x
+  807 set :tileValue.2:y :computeRowValues:y
+  808 set :tileValue.2:ore :computeRowValues:ore
+  809 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
+  810 select value equal floor :tileValue.2:ore 0.00392156862745098 0
+  811 sensor solid type @solid
+  812 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
+  813 label *label385
+  814 op add :tileValue.3:x :computeRowValues:x 1
+  815 set :tileValue.3:y :computeRowValues:y
+  816 set :tileValue.3:ore :computeRowValues:ore
+  817 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
+  818 select value equal floor :tileValue.3:ore 0.00392156862745098 0
+  819 sensor solid type @solid
+  820 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
+  821 label *label386
+  822 op add :tileValue.4:x :computeRowValues:x 2
+  823 set :tileValue.4:y :computeRowValues:y
+  824 set :tileValue.4:ore :computeRowValues:ore
+  825 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
+  826 select value equal floor :tileValue.4:ore 0.00392156862745098 0
+  827 sensor solid type @solid
+  828 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
+  829 label *label387
+  830 jump *label388 notEqual :computeRowValues:size 2
+  831 op add *tmp17 :tileValue:result :tileValue.1:result
+  832 op add *tmp18 :tileValue.1:result :tileValue.2:result
+  833 op add *tmp19 :tileValue.2:result :tileValue.3:result
+  834 op add *tmp20 :tileValue.3:result :tileValue.4:result
+  835 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
+  836 jump *label394 always
+  837 jump *label393 always
+  838 label *label388
+  839 jump *label389 notEqual :computeRowValues:size 3
+  840 op add *tmp24 :tileValue.1:result :tileValue.2:result
+  841 op add *tmp25 :tileValue:result *tmp24
+  842 op add *tmp27 *tmp24 :tileValue.3:result
+  843 op add *tmp28 :tileValue.2:result :tileValue.3:result
+  844 op add *tmp29 *tmp28 :tileValue.4:result
+  845 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
+  846 jump *label394 always
+  847 jump *label392 always
+  848 label *label389
+  849 op sub :tileValue.5:x :computeRowValues:x 3
+  850 set :tileValue.5:y :computeRowValues:y
+  851 set :tileValue.5:ore :computeRowValues:ore
+  852 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
+  853 select value equal floor :tileValue.5:ore 0.00392156862745098 0
+  854 sensor solid type @solid
+  855 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
+  856 label *label390
+  857 op add :tileValue.6:x :computeRowValues:x 3
+  858 set :tileValue.6:y :computeRowValues:y
+  859 set :tileValue.6:ore :computeRowValues:ore
+  860 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
+  861 select value equal floor :tileValue.6:ore 0.00392156862745098 0
+  862 sensor solid type @solid
+  863 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
+  864 label *label391
+  865 op add *tmp35 :tileValue:result :tileValue.1:result
+  866 op add *tmp36 *tmp35 :tileValue.2:result
+  867 op add *tmp37 :tileValue.5:result *tmp36
+  868 op min *tmp38 0.09803921568627451 *tmp37
+  869 op add *tmp41 *tmp36 :tileValue.3:result
+  870 op min *tmp42 0.09803921568627451 *tmp41
+  871 op add *tmp43 :tileValue.2:result :tileValue.3:result
+  872 op add *tmp44 *tmp43 :tileValue.4:result
+  873 op add *tmp45 :tileValue.1:result *tmp44
+  874 op min *tmp46 0.09803921568627451 *tmp45
+  875 op add *tmp49 *tmp44 :tileValue.6:result
+  876 op min *tmp50 0.09803921568627451 *tmp49
+  877 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
+  878 jump *label394 always
+  879 label *label392
+  880 label *label393
+  881 label *label394
   882 set :findBestPosition:y2 :computeRowValues*retval
   883 set :computeRowValues:x :findBestPosition:x
   884 set :computeRowValues:y :findBestPosition:y

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   787 set :computeRowValues:ore :findBestPosition:ore
   788 set :computeRowValues:size :findBestPosition:size
   789 label *label382
-    * op sub :tileValue:x :computeRowValues:x 2
-    * set :tileValue:y :computeRowValues:y
-    * set :tileValue:ore :computeRowValues:ore
+  790 op sub :tileValue:x :findBestPosition:x 2
+  791 set :tileValue:y *tmp54
+  792 set :tileValue:ore :findBestPosition:ore
   793 ucontrol getBlock :tileValue:x :tileValue:y type building floor
   794 select value equal floor :tileValue:ore 0.00392156862745098 0
   795 sensor solid type @solid
   796 select :tileValue:result notEqual solid false 0.09803921568627451 value
   797 label *label383
-    * op sub :tileValue.1:x :computeRowValues:x 1
-    * set :tileValue.1:y :computeRowValues:y
-    * set :tileValue.1:ore :computeRowValues:ore
+  798 op sub :tileValue.1:x :findBestPosition:x 1
+  799 set :tileValue.1:y *tmp54
+  800 set :tileValue.1:ore :findBestPosition:ore
   801 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
   802 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   803 sensor solid type @solid
   804 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
   805 label *label384
-    * set :tileValue.2:x :computeRowValues:x
-    * set :tileValue.2:y :computeRowValues:y
-    * set :tileValue.2:ore :computeRowValues:ore
+  806 set :tileValue.2:x :findBestPosition:x
+  807 set :tileValue.2:y *tmp54
+  808 set :tileValue.2:ore :findBestPosition:ore
   809 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
   810 select value equal floor :tileValue.2:ore 0.00392156862745098 0
   811 sensor solid type @solid
   812 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
   813 label *label385
-    * op add :tileValue.3:x :computeRowValues:x 1
-    * set :tileValue.3:y :computeRowValues:y
-    * set :tileValue.3:ore :computeRowValues:ore
+  814 op add :tileValue.3:x :findBestPosition:x 1
+  815 set :tileValue.3:y *tmp54
+  816 set :tileValue.3:ore :findBestPosition:ore
   817 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
   818 select value equal floor :tileValue.3:ore 0.00392156862745098 0
   819 sensor solid type @solid
   820 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
   821 label *label386
-    * op add :tileValue.4:x :computeRowValues:x 2
-    * set :tileValue.4:y :computeRowValues:y
-    * set :tileValue.4:ore :computeRowValues:ore
+  822 op add :tileValue.4:x :findBestPosition:x 2
+  823 set :tileValue.4:y *tmp54
+  824 set :tileValue.4:ore :findBestPosition:ore
   825 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
   826 select value equal floor :tileValue.4:ore 0.00392156862745098 0
   827 sensor solid type @solid
   828 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
   829 label *label387
-    * jump *label388 notEqual :computeRowValues:size 2
+  830 jump *label388 notEqual :findBestPosition:size 2
   831 op add *tmp17 :tileValue:result :tileValue.1:result
   832 op add *tmp18 :tileValue.1:result :tileValue.2:result
   833 op add *tmp19 :tileValue.2:result :tileValue.3:result
 
   836 jump *label394 always
   837 jump *label393 always
   838 label *label388
-    * jump *label389 notEqual :computeRowValues:size 3
+  839 jump *label389 notEqual :findBestPosition:size 3
   840 op add *tmp24 :tileValue.1:result :tileValue.2:result
   841 op add *tmp25 :tileValue:result *tmp24
   842 op add *tmp27 *tmp24 :tileValue.3:result
 
   846 jump *label394 always
   847 jump *label392 always
   848 label *label389
-    * op sub :tileValue.5:x :computeRowValues:x 3
-    * set :tileValue.5:y :computeRowValues:y
-    * set :tileValue.5:ore :computeRowValues:ore
+  849 op sub :tileValue.5:x :findBestPosition:x 3
+  850 set :tileValue.5:y *tmp54
+  851 set :tileValue.5:ore :findBestPosition:ore
   852 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
   853 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   854 sensor solid type @solid
   855 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
   856 label *label390
-    * op add :tileValue.6:x :computeRowValues:x 3
-    * set :tileValue.6:y :computeRowValues:y
-    * set :tileValue.6:ore :computeRowValues:ore
+  857 op add :tileValue.6:x :findBestPosition:x 3
+  858 set :tileValue.6:y *tmp54
+  859 set :tileValue.6:ore :findBestPosition:ore
   860 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
   861 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   862 sensor solid type @solid

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
   782 label *label381
   783 set :findBestPosition:y1 :computeRowValues*retval
   784 op sub *tmp54 :findBestPosition:y 1
-    * set :computeRowValues:x :findBestPosition:x
-    * set :computeRowValues:y *tmp54
-    * set :computeRowValues:ore :findBestPosition:ore
-    * set :computeRowValues:size :findBestPosition:size
   785 label *label382
   786 op sub :tileValue:x :findBestPosition:x 2
   787 set :tileValue:y *tmp54

Modifications by Inline function call at line 140:14 (+78 instructions):
 
   880 set :computeRowValues:y :findBestPosition:y
   881 set :computeRowValues:ore :findBestPosition:ore
   882 set :computeRowValues:size :findBestPosition:size
-    * setaddr :computeRowValues*retaddr *label28 (h:*label28)
-    * call *label2 *invalid :computeRowValues*retval (m:*label28) (h:*label28)
-    * label *label28
+  883 label *label395
+  884 op sub :tileValue:x :computeRowValues:x 2
+  885 set :tileValue:y :computeRowValues:y
+  886 set :tileValue:ore :computeRowValues:ore
+  887 ucontrol getBlock :tileValue:x :tileValue:y type building floor
+  888 select value equal floor :tileValue:ore 0.00392156862745098 0
+  889 sensor solid type @solid
+  890 select :tileValue:result notEqual solid false 0.09803921568627451 value
+  891 label *label396
+  892 op sub :tileValue.1:x :computeRowValues:x 1
+  893 set :tileValue.1:y :computeRowValues:y
+  894 set :tileValue.1:ore :computeRowValues:ore
+  895 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
+  896 select value equal floor :tileValue.1:ore 0.00392156862745098 0
+  897 sensor solid type @solid
+  898 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
+  899 label *label397
+  900 set :tileValue.2:x :computeRowValues:x
+  901 set :tileValue.2:y :computeRowValues:y
+  902 set :tileValue.2:ore :computeRowValues:ore
+  903 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
+  904 select value equal floor :tileValue.2:ore 0.00392156862745098 0
+  905 sensor solid type @solid
+  906 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
+  907 label *label398
+  908 op add :tileValue.3:x :computeRowValues:x 1
+  909 set :tileValue.3:y :computeRowValues:y
+  910 set :tileValue.3:ore :computeRowValues:ore
+  911 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
+  912 select value equal floor :tileValue.3:ore 0.00392156862745098 0
+  913 sensor solid type @solid
+  914 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
+  915 label *label399
+  916 op add :tileValue.4:x :computeRowValues:x 2
+  917 set :tileValue.4:y :computeRowValues:y
+  918 set :tileValue.4:ore :computeRowValues:ore
+  919 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
+  920 select value equal floor :tileValue.4:ore 0.00392156862745098 0
+  921 sensor solid type @solid
+  922 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
+  923 label *label400
+  924 jump *label401 notEqual :computeRowValues:size 2
+  925 op add *tmp17 :tileValue:result :tileValue.1:result
+  926 op add *tmp18 :tileValue.1:result :tileValue.2:result
+  927 op add *tmp19 :tileValue.2:result :tileValue.3:result
+  928 op add *tmp20 :tileValue.3:result :tileValue.4:result
+  929 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
+  930 jump *label407 always
+  931 jump *label406 always
+  932 label *label401
+  933 jump *label402 notEqual :computeRowValues:size 3
+  934 op add *tmp24 :tileValue.1:result :tileValue.2:result
+  935 op add *tmp25 :tileValue:result *tmp24
+  936 op add *tmp27 *tmp24 :tileValue.3:result
+  937 op add *tmp28 :tileValue.2:result :tileValue.3:result
+  938 op add *tmp29 *tmp28 :tileValue.4:result
+  939 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
+  940 jump *label407 always
+  941 jump *label405 always
+  942 label *label402
+  943 op sub :tileValue.5:x :computeRowValues:x 3
+  944 set :tileValue.5:y :computeRowValues:y
+  945 set :tileValue.5:ore :computeRowValues:ore
+  946 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
+  947 select value equal floor :tileValue.5:ore 0.00392156862745098 0
+  948 sensor solid type @solid
+  949 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
+  950 label *label403
+  951 op add :tileValue.6:x :computeRowValues:x 3
+  952 set :tileValue.6:y :computeRowValues:y
+  953 set :tileValue.6:ore :computeRowValues:ore
+  954 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
+  955 select value equal floor :tileValue.6:ore 0.00392156862745098 0
+  956 sensor solid type @solid
+  957 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
+  958 label *label404
+  959 op add *tmp35 :tileValue:result :tileValue.1:result
+  960 op add *tmp36 *tmp35 :tileValue.2:result
+  961 op add *tmp37 :tileValue.5:result *tmp36
+  962 op min *tmp38 0.09803921568627451 *tmp37
+  963 op add *tmp41 *tmp36 :tileValue.3:result
+  964 op min *tmp42 0.09803921568627451 *tmp41
+  965 op add *tmp43 :tileValue.2:result :tileValue.3:result
+  966 op add *tmp44 *tmp43 :tileValue.4:result
+  967 op add *tmp45 :tileValue.1:result *tmp44
+  968 op min *tmp46 0.09803921568627451 *tmp45
+  969 op add *tmp49 *tmp44 :tileValue.6:result
+  970 op min *tmp50 0.09803921568627451 *tmp49
+  971 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
+  972 jump *label407 always
+  973 label *label405
+  974 label *label406
+  975 label *label407
   976 set :findBestPosition:y3 :computeRowValues*retval
   977 op add *tmp58 :findBestPosition:y 1
   978 set :computeRowValues:x :findBestPosition:x

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   881 set :computeRowValues:ore :findBestPosition:ore
   882 set :computeRowValues:size :findBestPosition:size
   883 label *label395
-    * op sub :tileValue:x :computeRowValues:x 2
-    * set :tileValue:y :computeRowValues:y
-    * set :tileValue:ore :computeRowValues:ore
+  884 op sub :tileValue:x :findBestPosition:x 2
+  885 set :tileValue:y :findBestPosition:y
+  886 set :tileValue:ore :findBestPosition:ore
   887 ucontrol getBlock :tileValue:x :tileValue:y type building floor
   888 select value equal floor :tileValue:ore 0.00392156862745098 0
   889 sensor solid type @solid
   890 select :tileValue:result notEqual solid false 0.09803921568627451 value
   891 label *label396
-    * op sub :tileValue.1:x :computeRowValues:x 1
-    * set :tileValue.1:y :computeRowValues:y
-    * set :tileValue.1:ore :computeRowValues:ore
+  892 op sub :tileValue.1:x :findBestPosition:x 1
+  893 set :tileValue.1:y :findBestPosition:y
+  894 set :tileValue.1:ore :findBestPosition:ore
   895 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
   896 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   897 sensor solid type @solid
   898 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
   899 label *label397
-    * set :tileValue.2:x :computeRowValues:x
-    * set :tileValue.2:y :computeRowValues:y
-    * set :tileValue.2:ore :computeRowValues:ore
+  900 set :tileValue.2:x :findBestPosition:x
+  901 set :tileValue.2:y :findBestPosition:y
+  902 set :tileValue.2:ore :findBestPosition:ore
   903 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
   904 select value equal floor :tileValue.2:ore 0.00392156862745098 0
   905 sensor solid type @solid
   906 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
   907 label *label398
-    * op add :tileValue.3:x :computeRowValues:x 1
-    * set :tileValue.3:y :computeRowValues:y
-    * set :tileValue.3:ore :computeRowValues:ore
+  908 op add :tileValue.3:x :findBestPosition:x 1
+  909 set :tileValue.3:y :findBestPosition:y
+  910 set :tileValue.3:ore :findBestPosition:ore
   911 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
   912 select value equal floor :tileValue.3:ore 0.00392156862745098 0
   913 sensor solid type @solid
   914 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
   915 label *label399
-    * op add :tileValue.4:x :computeRowValues:x 2
-    * set :tileValue.4:y :computeRowValues:y
-    * set :tileValue.4:ore :computeRowValues:ore
+  916 op add :tileValue.4:x :findBestPosition:x 2
+  917 set :tileValue.4:y :findBestPosition:y
+  918 set :tileValue.4:ore :findBestPosition:ore
   919 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
   920 select value equal floor :tileValue.4:ore 0.00392156862745098 0
   921 sensor solid type @solid
   922 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
   923 label *label400
-    * jump *label401 notEqual :computeRowValues:size 2
+  924 jump *label401 notEqual :findBestPosition:size 2
   925 op add *tmp17 :tileValue:result :tileValue.1:result
   926 op add *tmp18 :tileValue.1:result :tileValue.2:result
   927 op add *tmp19 :tileValue.2:result :tileValue.3:result
 
   930 jump *label407 always
   931 jump *label406 always
   932 label *label401
-    * jump *label402 notEqual :computeRowValues:size 3
+  933 jump *label402 notEqual :findBestPosition:size 3
   934 op add *tmp24 :tileValue.1:result :tileValue.2:result
   935 op add *tmp25 :tileValue:result *tmp24
   936 op add *tmp27 *tmp24 :tileValue.3:result
 
   940 jump *label407 always
   941 jump *label405 always
   942 label *label402
-    * op sub :tileValue.5:x :computeRowValues:x 3
-    * set :tileValue.5:y :computeRowValues:y
-    * set :tileValue.5:ore :computeRowValues:ore
+  943 op sub :tileValue.5:x :findBestPosition:x 3
+  944 set :tileValue.5:y :findBestPosition:y
+  945 set :tileValue.5:ore :findBestPosition:ore
   946 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
   947 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   948 sensor solid type @solid
   949 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
   950 label *label403
-    * op add :tileValue.6:x :computeRowValues:x 3
-    * set :tileValue.6:y :computeRowValues:y
-    * set :tileValue.6:ore :computeRowValues:ore
+  951 op add :tileValue.6:x :findBestPosition:x 3
+  952 set :tileValue.6:y :findBestPosition:y
+  953 set :tileValue.6:ore :findBestPosition:ore
   954 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
   955 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   956 sensor solid type @solid

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
   876 label *label393
   877 label *label394
   878 set :findBestPosition:y2 :computeRowValues*retval
-    * set :computeRowValues:x :findBestPosition:x
-    * set :computeRowValues:y :findBestPosition:y
-    * set :computeRowValues:ore :findBestPosition:ore
-    * set :computeRowValues:size :findBestPosition:size
   879 label *label395
   880 op sub :tileValue:x :findBestPosition:x 2
   881 set :tileValue:y :findBestPosition:y

Modifications by Inline function call at line 141:14 (+78 instructions):
 
   975 set :computeRowValues:y *tmp58
   976 set :computeRowValues:ore :findBestPosition:ore
   977 set :computeRowValues:size :findBestPosition:size
-    * setaddr :computeRowValues*retaddr *label29 (h:*label29)
-    * call *label2 *invalid :computeRowValues*retval (m:*label29) (h:*label29)
-    * label *label29
+  978 label *label408
+  979 op sub :tileValue:x :computeRowValues:x 2
+  980 set :tileValue:y :computeRowValues:y
+  981 set :tileValue:ore :computeRowValues:ore
+  982 ucontrol getBlock :tileValue:x :tileValue:y type building floor
+  983 select value equal floor :tileValue:ore 0.00392156862745098 0
+  984 sensor solid type @solid
+  985 select :tileValue:result notEqual solid false 0.09803921568627451 value
+  986 label *label409
+  987 op sub :tileValue.1:x :computeRowValues:x 1
+  988 set :tileValue.1:y :computeRowValues:y
+  989 set :tileValue.1:ore :computeRowValues:ore
+  990 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
+  991 select value equal floor :tileValue.1:ore 0.00392156862745098 0
+  992 sensor solid type @solid
+  993 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
+  994 label *label410
+  995 set :tileValue.2:x :computeRowValues:x
+  996 set :tileValue.2:y :computeRowValues:y
+  997 set :tileValue.2:ore :computeRowValues:ore
+  998 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
+  999 select value equal floor :tileValue.2:ore 0.00392156862745098 0
+ 1000 sensor solid type @solid
+ 1001 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
+ 1002 label *label411
+ 1003 op add :tileValue.3:x :computeRowValues:x 1
+ 1004 set :tileValue.3:y :computeRowValues:y
+ 1005 set :tileValue.3:ore :computeRowValues:ore
+ 1006 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
+ 1007 select value equal floor :tileValue.3:ore 0.00392156862745098 0
+ 1008 sensor solid type @solid
+ 1009 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
+ 1010 label *label412
+ 1011 op add :tileValue.4:x :computeRowValues:x 2
+ 1012 set :tileValue.4:y :computeRowValues:y
+ 1013 set :tileValue.4:ore :computeRowValues:ore
+ 1014 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
+ 1015 select value equal floor :tileValue.4:ore 0.00392156862745098 0
+ 1016 sensor solid type @solid
+ 1017 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
+ 1018 label *label413
+ 1019 jump *label414 notEqual :computeRowValues:size 2
+ 1020 op add *tmp17 :tileValue:result :tileValue.1:result
+ 1021 op add *tmp18 :tileValue.1:result :tileValue.2:result
+ 1022 op add *tmp19 :tileValue.2:result :tileValue.3:result
+ 1023 op add *tmp20 :tileValue.3:result :tileValue.4:result
+ 1024 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
+ 1025 jump *label420 always
+ 1026 jump *label419 always
+ 1027 label *label414
+ 1028 jump *label415 notEqual :computeRowValues:size 3
+ 1029 op add *tmp24 :tileValue.1:result :tileValue.2:result
+ 1030 op add *tmp25 :tileValue:result *tmp24
+ 1031 op add *tmp27 *tmp24 :tileValue.3:result
+ 1032 op add *tmp28 :tileValue.2:result :tileValue.3:result
+ 1033 op add *tmp29 *tmp28 :tileValue.4:result
+ 1034 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
+ 1035 jump *label420 always
+ 1036 jump *label418 always
+ 1037 label *label415
+ 1038 op sub :tileValue.5:x :computeRowValues:x 3
+ 1039 set :tileValue.5:y :computeRowValues:y
+ 1040 set :tileValue.5:ore :computeRowValues:ore
+ 1041 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
+ 1042 select value equal floor :tileValue.5:ore 0.00392156862745098 0
+ 1043 sensor solid type @solid
+ 1044 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
+ 1045 label *label416
+ 1046 op add :tileValue.6:x :computeRowValues:x 3
+ 1047 set :tileValue.6:y :computeRowValues:y
+ 1048 set :tileValue.6:ore :computeRowValues:ore
+ 1049 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
+ 1050 select value equal floor :tileValue.6:ore 0.00392156862745098 0
+ 1051 sensor solid type @solid
+ 1052 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
+ 1053 label *label417
+ 1054 op add *tmp35 :tileValue:result :tileValue.1:result
+ 1055 op add *tmp36 *tmp35 :tileValue.2:result
+ 1056 op add *tmp37 :tileValue.5:result *tmp36
+ 1057 op min *tmp38 0.09803921568627451 *tmp37
+ 1058 op add *tmp41 *tmp36 :tileValue.3:result
+ 1059 op min *tmp42 0.09803921568627451 *tmp41
+ 1060 op add *tmp43 :tileValue.2:result :tileValue.3:result
+ 1061 op add *tmp44 *tmp43 :tileValue.4:result
+ 1062 op add *tmp45 :tileValue.1:result *tmp44
+ 1063 op min *tmp46 0.09803921568627451 *tmp45
+ 1064 op add *tmp49 *tmp44 :tileValue.6:result
+ 1065 op min *tmp50 0.09803921568627451 *tmp49
+ 1066 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
+ 1067 jump *label420 always
+ 1068 label *label418
+ 1069 label *label419
+ 1070 label *label420
  1071 set :findBestPosition:y4 :computeRowValues*retval
  1072 op add *tmp60 :findBestPosition:y 2
  1073 set :computeRowValues:x :findBestPosition:x

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   976 set :computeRowValues:ore :findBestPosition:ore
   977 set :computeRowValues:size :findBestPosition:size
   978 label *label408
-    * op sub :tileValue:x :computeRowValues:x 2
-    * set :tileValue:y :computeRowValues:y
-    * set :tileValue:ore :computeRowValues:ore
+  979 op sub :tileValue:x :findBestPosition:x 2
+  980 set :tileValue:y *tmp58
+  981 set :tileValue:ore :findBestPosition:ore
   982 ucontrol getBlock :tileValue:x :tileValue:y type building floor
   983 select value equal floor :tileValue:ore 0.00392156862745098 0
   984 sensor solid type @solid
   985 select :tileValue:result notEqual solid false 0.09803921568627451 value
   986 label *label409
-    * op sub :tileValue.1:x :computeRowValues:x 1
-    * set :tileValue.1:y :computeRowValues:y
-    * set :tileValue.1:ore :computeRowValues:ore
+  987 op sub :tileValue.1:x :findBestPosition:x 1
+  988 set :tileValue.1:y *tmp58
+  989 set :tileValue.1:ore :findBestPosition:ore
   990 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
   991 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   992 sensor solid type @solid
   993 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
   994 label *label410
-    * set :tileValue.2:x :computeRowValues:x
-    * set :tileValue.2:y :computeRowValues:y
-    * set :tileValue.2:ore :computeRowValues:ore
+  995 set :tileValue.2:x :findBestPosition:x
+  996 set :tileValue.2:y *tmp58
+  997 set :tileValue.2:ore :findBestPosition:ore
   998 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
   999 select value equal floor :tileValue.2:ore 0.00392156862745098 0
  1000 sensor solid type @solid
  1001 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
  1002 label *label411
-    * op add :tileValue.3:x :computeRowValues:x 1
-    * set :tileValue.3:y :computeRowValues:y
-    * set :tileValue.3:ore :computeRowValues:ore
+ 1003 op add :tileValue.3:x :findBestPosition:x 1
+ 1004 set :tileValue.3:y *tmp58
+ 1005 set :tileValue.3:ore :findBestPosition:ore
  1006 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
  1007 select value equal floor :tileValue.3:ore 0.00392156862745098 0
  1008 sensor solid type @solid
  1009 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
  1010 label *label412
-    * op add :tileValue.4:x :computeRowValues:x 2
-    * set :tileValue.4:y :computeRowValues:y
-    * set :tileValue.4:ore :computeRowValues:ore
+ 1011 op add :tileValue.4:x :findBestPosition:x 2
+ 1012 set :tileValue.4:y *tmp58
+ 1013 set :tileValue.4:ore :findBestPosition:ore
  1014 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
  1015 select value equal floor :tileValue.4:ore 0.00392156862745098 0
  1016 sensor solid type @solid
  1017 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
  1018 label *label413
-    * jump *label414 notEqual :computeRowValues:size 2
+ 1019 jump *label414 notEqual :findBestPosition:size 2
  1020 op add *tmp17 :tileValue:result :tileValue.1:result
  1021 op add *tmp18 :tileValue.1:result :tileValue.2:result
  1022 op add *tmp19 :tileValue.2:result :tileValue.3:result
 
  1025 jump *label420 always
  1026 jump *label419 always
  1027 label *label414
-    * jump *label415 notEqual :computeRowValues:size 3
+ 1028 jump *label415 notEqual :findBestPosition:size 3
  1029 op add *tmp24 :tileValue.1:result :tileValue.2:result
  1030 op add *tmp25 :tileValue:result *tmp24
  1031 op add *tmp27 *tmp24 :tileValue.3:result
 
  1035 jump *label420 always
  1036 jump *label418 always
  1037 label *label415
-    * op sub :tileValue.5:x :computeRowValues:x 3
-    * set :tileValue.5:y :computeRowValues:y
-    * set :tileValue.5:ore :computeRowValues:ore
+ 1038 op sub :tileValue.5:x :findBestPosition:x 3
+ 1039 set :tileValue.5:y *tmp58
+ 1040 set :tileValue.5:ore :findBestPosition:ore
  1041 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
  1042 select value equal floor :tileValue.5:ore 0.00392156862745098 0
  1043 sensor solid type @solid
  1044 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
  1045 label *label416
-    * op add :tileValue.6:x :computeRowValues:x 3
-    * set :tileValue.6:y :computeRowValues:y
-    * set :tileValue.6:ore :computeRowValues:ore
+ 1046 op add :tileValue.6:x :findBestPosition:x 3
+ 1047 set :tileValue.6:y *tmp58
+ 1048 set :tileValue.6:ore :findBestPosition:ore
  1049 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
  1050 select value equal floor :tileValue.6:ore 0.00392156862745098 0
  1051 sensor solid type @solid

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
   971 label *label407
   972 set :findBestPosition:y3 :computeRowValues*retval
   973 op add *tmp58 :findBestPosition:y 1
-    * set :computeRowValues:x :findBestPosition:x
-    * set :computeRowValues:y *tmp58
-    * set :computeRowValues:ore :findBestPosition:ore
-    * set :computeRowValues:size :findBestPosition:size
   974 label *label408
   975 op sub :tileValue:x :findBestPosition:x 2
   976 set :tileValue:y *tmp58

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-7 instructions):
 
   584 label *label368
   585 label *label8
   586 set :createTerrainMask*retval :createTerrainMask:result
-    * jump *label5 always
   587 label *label5
   588 set :createTerrainMask*finished true
   589 jump *label4 always
 
   677 op add *tmp49 *tmp44 :tileValue.6:result
   678 op min *tmp50 0.09803921568627451 *tmp49
   679 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
-    * jump *label13 always
   680 label *label22
   681 label *label20
   682 label *label13
 
   774 op add *tmp49 *tmp44 :tileValue.6:result
   775 op min *tmp50 0.09803921568627451 *tmp49
   776 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
-    * jump *label381 always
   777 label *label379
   778 label *label380
   779 label *label381
 
   868 op add *tmp49 *tmp44 :tileValue.6:result
   869 op min *tmp50 0.09803921568627451 *tmp49
   870 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
-    * jump *label394 always
   871 label *label392
   872 label *label393
   873 label *label394
 
   961 op add *tmp49 *tmp44 :tileValue.6:result
   962 op min *tmp50 0.09803921568627451 *tmp49
   963 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
-    * jump *label407 always
   964 label *label405
   965 label *label406
   966 label *label407
 
  1055 op add *tmp49 *tmp44 :tileValue.6:result
  1056 op min *tmp50 0.09803921568627451 *tmp49
  1057 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
-    * jump *label420 always
  1058 label *label418
  1059 label *label419
  1060 label *label420
 
  1378 label *label148
  1379 label *label32
  1380 op mul :findBestPosition*retval :findBestPosition:best 255
-    * jump *label25 always
  1381 label *label25
  1382 set :findBestPosition*finished true
  1383 jump *label4 always

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    20 sensor solid type @solid
    21 select :isSolid:result notEqual solid false 1 0
    22 label *label197
-    * op or :createTerrainMask:result 0 :isSolid:result
+   23 set :createTerrainMask:result :isSolid:result
    24 label *label198
    25 label *label199
    26 op shl *tmp0 :createTerrainMask:result 1
 
    46 label *label204
    47 label *label205
    48 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 0
+   49 set *tmp1 :createTerrainMask:x
    50 set :isSolid:x *tmp1
    51 set :isSolid:y *tmp2
    52 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
   128 label *label229
   129 label *label230
   130 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 0
+  131 set *tmp1 :createTerrainMask:x
   132 set :isSolid:x *tmp1
   133 set :isSolid:y *tmp2
   134 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
   210 label *label254
   211 label *label255
   212 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 0
+  213 set *tmp1 :createTerrainMask:x
   214 set :isSolid:x *tmp1
   215 set :isSolid:y *tmp2
   216 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
   255 label *label267
   256 label *label268
   257 label *label269
-    * op add *tmp2 :createTerrainMask:y 0
+  258 set *tmp2 :createTerrainMask:y
   259 label *label270
   260 label *label271
   261 op shl *tmp0 :createTerrainMask:result 1
 
   292 label *label279
   293 label *label280
   294 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 0
+  295 set *tmp1 :createTerrainMask:x
   296 set :isSolid:x *tmp1
   297 set :isSolid:y *tmp2
   298 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
   374 label *label304
   375 label *label305
   376 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 0
+  377 set *tmp1 :createTerrainMask:x
   378 set :isSolid:x *tmp1
   379 set :isSolid:y *tmp2
   380 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
   456 label *label329
   457 label *label330
   458 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 0
+  459 set *tmp1 :createTerrainMask:x
   460 set :isSolid:x *tmp1
   461 set :isSolid:y *tmp2
   462 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
   538 label *label354
   539 label *label355
   540 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 0
+  541 set *tmp1 :createTerrainMask:x
   542 set :isSolid:x *tmp1
   543 set :isSolid:y *tmp2
   544 ucontrol getBlock :isSolid:x :isSolid:y type building floor

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-54 instructions):
 
    13 op add *tmp2 :createTerrainMask:y 3
    14 label *label195
    15 label *label196
-    * op add *tmp1 :createTerrainMask:x 3
-    * set :isSolid:x *tmp1
+   16 op add :isSolid:x :createTerrainMask:x 3
    17 set :isSolid:y *tmp2
    18 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    19 sensor solid type @solid
 
    23 label *label198
    24 label *label199
    25 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 2
-    * set :isSolid:x *tmp1
+   26 op add :isSolid:x :createTerrainMask:x 2
    27 set :isSolid:y *tmp2
    28 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    29 sensor solid type @solid
 
    33 label *label201
    34 label *label202
    35 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 1
-    * set :isSolid:x *tmp1
+   36 op add :isSolid:x :createTerrainMask:x 1
    37 set :isSolid:y *tmp2
    38 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    39 sensor solid type @solid
 
    43 label *label204
    44 label *label205
    45 op shl *tmp0 :createTerrainMask:result 1
-    * set *tmp1 :createTerrainMask:x
-    * set :isSolid:x *tmp1
+   46 set :isSolid:x :createTerrainMask:x
    47 set :isSolid:y *tmp2
    48 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    49 sensor solid type @solid
 
    53 label *label207
    54 label *label208
    55 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -1
-    * set :isSolid:x *tmp1
+   56 op add :isSolid:x :createTerrainMask:x -1
    57 set :isSolid:y *tmp2
    58 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    59 sensor solid type @solid
 
    63 label *label210
    64 label *label211
    65 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -2
-    * set :isSolid:x *tmp1
+   66 op add :isSolid:x :createTerrainMask:x -2
    67 set :isSolid:y *tmp2
    68 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    69 sensor solid type @solid
 
    73 label *label213
    74 label *label214
    75 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -3
-    * set :isSolid:x *tmp1
+   76 op add :isSolid:x :createTerrainMask:x -3
    77 set :isSolid:y *tmp2
    78 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    79 sensor solid type @solid
 
    88 label *label220
    89 label *label221
    90 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 3
-    * set :isSolid:x *tmp1
+   91 op add :isSolid:x :createTerrainMask:x 3
    92 set :isSolid:y *tmp2
    93 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    94 sensor solid type @solid
 
    98 label *label223
    99 label *label224
   100 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 2
-    * set :isSolid:x *tmp1
+  101 op add :isSolid:x :createTerrainMask:x 2
   102 set :isSolid:y *tmp2
   103 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   104 sensor solid type @solid
 
   108 label *label226
   109 label *label227
   110 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 1
-    * set :isSolid:x *tmp1
+  111 op add :isSolid:x :createTerrainMask:x 1
   112 set :isSolid:y *tmp2
   113 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   114 sensor solid type @solid
 
   118 label *label229
   119 label *label230
   120 op shl *tmp0 :createTerrainMask:result 1
-    * set *tmp1 :createTerrainMask:x
-    * set :isSolid:x *tmp1
+  121 set :isSolid:x :createTerrainMask:x
   122 set :isSolid:y *tmp2
   123 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   124 sensor solid type @solid
 
   128 label *label232
   129 label *label233
   130 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -1
-    * set :isSolid:x *tmp1
+  131 op add :isSolid:x :createTerrainMask:x -1
   132 set :isSolid:y *tmp2
   133 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   134 sensor solid type @solid
 
   138 label *label235
   139 label *label236
   140 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -2
-    * set :isSolid:x *tmp1
+  141 op add :isSolid:x :createTerrainMask:x -2
   142 set :isSolid:y *tmp2
   143 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   144 sensor solid type @solid
 
   148 label *label238
   149 label *label239
   150 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -3
-    * set :isSolid:x *tmp1
+  151 op add :isSolid:x :createTerrainMask:x -3
   152 set :isSolid:y *tmp2
   153 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   154 sensor solid type @solid
 
   163 label *label245
   164 label *label246
   165 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 3
-    * set :isSolid:x *tmp1
+  166 op add :isSolid:x :createTerrainMask:x 3
   167 set :isSolid:y *tmp2
   168 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   169 sensor solid type @solid
 
   173 label *label248
   174 label *label249
   175 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 2
-    * set :isSolid:x *tmp1
+  176 op add :isSolid:x :createTerrainMask:x 2
   177 set :isSolid:y *tmp2
   178 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   179 sensor solid type @solid
 
   183 label *label251
   184 label *label252
   185 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 1
-    * set :isSolid:x *tmp1
+  186 op add :isSolid:x :createTerrainMask:x 1
   187 set :isSolid:y *tmp2
   188 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   189 sensor solid type @solid
 
   193 label *label254
   194 label *label255
   195 op shl *tmp0 :createTerrainMask:result 1
-    * set *tmp1 :createTerrainMask:x
-    * set :isSolid:x *tmp1
+  196 set :isSolid:x :createTerrainMask:x
   197 set :isSolid:y *tmp2
   198 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   199 sensor solid type @solid
 
   203 label *label257
   204 label *label258
   205 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -1
-    * set :isSolid:x *tmp1
+  206 op add :isSolid:x :createTerrainMask:x -1
   207 set :isSolid:y *tmp2
   208 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   209 sensor solid type @solid
 
   213 label *label260
   214 label *label261
   215 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -2
-    * set :isSolid:x *tmp1
+  216 op add :isSolid:x :createTerrainMask:x -2
   217 set :isSolid:y *tmp2
   218 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   219 sensor solid type @solid
 
   223 label *label263
   224 label *label264
   225 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -3
-    * set :isSolid:x *tmp1
+  226 op add :isSolid:x :createTerrainMask:x -3
   227 set :isSolid:y *tmp2
   228 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   229 sensor solid type @solid
 
   238 label *label270
   239 label *label271
   240 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 3
-    * set :isSolid:x *tmp1
+  241 op add :isSolid:x :createTerrainMask:x 3
   242 set :isSolid:y *tmp2
   243 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   244 sensor solid type @solid
 
   248 label *label273
   249 label *label274
   250 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 2
-    * set :isSolid:x *tmp1
+  251 op add :isSolid:x :createTerrainMask:x 2
   252 set :isSolid:y *tmp2
   253 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   254 sensor solid type @solid
 
   258 label *label276
   259 label *label277
   260 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 1
-    * set :isSolid:x *tmp1
+  261 op add :isSolid:x :createTerrainMask:x 1
   262 set :isSolid:y *tmp2
   263 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   264 sensor solid type @solid
 
   268 label *label279
   269 label *label280
   270 op shl *tmp0 :createTerrainMask:result 1
-    * set *tmp1 :createTerrainMask:x
-    * set :isSolid:x *tmp1
+  271 set :isSolid:x :createTerrainMask:x
   272 set :isSolid:y *tmp2
   273 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   274 sensor solid type @solid
 
   278 label *label282
   279 label *label283
   280 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -1
-    * set :isSolid:x *tmp1
+  281 op add :isSolid:x :createTerrainMask:x -1
   282 set :isSolid:y *tmp2
   283 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   284 sensor solid type @solid
 
   288 label *label285
   289 label *label286
   290 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -2
-    * set :isSolid:x *tmp1
+  291 op add :isSolid:x :createTerrainMask:x -2
   292 set :isSolid:y *tmp2
   293 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   294 sensor solid type @solid
 
   298 label *label288
   299 label *label289
   300 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -3
-    * set :isSolid:x *tmp1
+  301 op add :isSolid:x :createTerrainMask:x -3
   302 set :isSolid:y *tmp2
   303 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   304 sensor solid type @solid
 
   313 label *label295
   314 label *label296
   315 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 3
-    * set :isSolid:x *tmp1
+  316 op add :isSolid:x :createTerrainMask:x 3
   317 set :isSolid:y *tmp2
   318 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   319 sensor solid type @solid
 
   323 label *label298
   324 label *label299
   325 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 2
-    * set :isSolid:x *tmp1
+  326 op add :isSolid:x :createTerrainMask:x 2
   327 set :isSolid:y *tmp2
   328 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   329 sensor solid type @solid
 
   333 label *label301
   334 label *label302
   335 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 1
-    * set :isSolid:x *tmp1
+  336 op add :isSolid:x :createTerrainMask:x 1
   337 set :isSolid:y *tmp2
   338 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   339 sensor solid type @solid
 
   343 label *label304
   344 label *label305
   345 op shl *tmp0 :createTerrainMask:result 1
-    * set *tmp1 :createTerrainMask:x
-    * set :isSolid:x *tmp1
+  346 set :isSolid:x :createTerrainMask:x
   347 set :isSolid:y *tmp2
   348 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   349 sensor solid type @solid
 
   353 label *label307
   354 label *label308
   355 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -1
-    * set :isSolid:x *tmp1
+  356 op add :isSolid:x :createTerrainMask:x -1
   357 set :isSolid:y *tmp2
   358 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   359 sensor solid type @solid
 
   363 label *label310
   364 label *label311
   365 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -2
-    * set :isSolid:x *tmp1
+  366 op add :isSolid:x :createTerrainMask:x -2
   367 set :isSolid:y *tmp2
   368 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   369 sensor solid type @solid
 
   373 label *label313
   374 label *label314
   375 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -3
-    * set :isSolid:x *tmp1
+  376 op add :isSolid:x :createTerrainMask:x -3
   377 set :isSolid:y *tmp2
   378 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   379 sensor solid type @solid
 
   388 label *label320
   389 label *label321
   390 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 3
-    * set :isSolid:x *tmp1
+  391 op add :isSolid:x :createTerrainMask:x 3
   392 set :isSolid:y *tmp2
   393 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   394 sensor solid type @solid
 
   398 label *label323
   399 label *label324
   400 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 2
-    * set :isSolid:x *tmp1
+  401 op add :isSolid:x :createTerrainMask:x 2
   402 set :isSolid:y *tmp2
   403 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   404 sensor solid type @solid
 
   408 label *label326
   409 label *label327
   410 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 1
-    * set :isSolid:x *tmp1
+  411 op add :isSolid:x :createTerrainMask:x 1
   412 set :isSolid:y *tmp2
   413 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   414 sensor solid type @solid
 
   418 label *label329
   419 label *label330
   420 op shl *tmp0 :createTerrainMask:result 1
-    * set *tmp1 :createTerrainMask:x
-    * set :isSolid:x *tmp1
+  421 set :isSolid:x :createTerrainMask:x
   422 set :isSolid:y *tmp2
   423 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   424 sensor solid type @solid
 
   428 label *label332
   429 label *label333
   430 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -1
-    * set :isSolid:x *tmp1
+  431 op add :isSolid:x :createTerrainMask:x -1
   432 set :isSolid:y *tmp2
   433 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   434 sensor solid type @solid
 
   438 label *label335
   439 label *label336
   440 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -2
-    * set :isSolid:x *tmp1
+  441 op add :isSolid:x :createTerrainMask:x -2
   442 set :isSolid:y *tmp2
   443 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   444 sensor solid type @solid
 
   448 label *label338
   449 label *label339
   450 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -3
-    * set :isSolid:x *tmp1
+  451 op add :isSolid:x :createTerrainMask:x -3
   452 set :isSolid:y *tmp2
   453 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   454 sensor solid type @solid
 
   463 label *label345
   464 label *label346
   465 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 3
-    * set :isSolid:x *tmp1
+  466 op add :isSolid:x :createTerrainMask:x 3
   467 set :isSolid:y *tmp2
   468 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   469 sensor solid type @solid
 
   473 label *label348
   474 label *label349
   475 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 2
-    * set :isSolid:x *tmp1
+  476 op add :isSolid:x :createTerrainMask:x 2
   477 set :isSolid:y *tmp2
   478 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   479 sensor solid type @solid
 
   483 label *label351
   484 label *label352
   485 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x 1
-    * set :isSolid:x *tmp1
+  486 op add :isSolid:x :createTerrainMask:x 1
   487 set :isSolid:y *tmp2
   488 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   489 sensor solid type @solid
 
   493 label *label354
   494 label *label355
   495 op shl *tmp0 :createTerrainMask:result 1
-    * set *tmp1 :createTerrainMask:x
-    * set :isSolid:x *tmp1
+  496 set :isSolid:x :createTerrainMask:x
   497 set :isSolid:y *tmp2
   498 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   499 sensor solid type @solid
 
   503 label *label357
   504 label *label358
   505 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -1
-    * set :isSolid:x *tmp1
+  506 op add :isSolid:x :createTerrainMask:x -1
   507 set :isSolid:y *tmp2
   508 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   509 sensor solid type @solid
 
   513 label *label360
   514 label *label361
   515 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -2
-    * set :isSolid:x *tmp1
+  516 op add :isSolid:x :createTerrainMask:x -2
   517 set :isSolid:y *tmp2
   518 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   519 sensor solid type @solid
 
   523 label *label363
   524 label *label364
   525 op shl *tmp0 :createTerrainMask:result 1
-    * op add *tmp1 :createTerrainMask:x -3
-    * set :isSolid:x *tmp1
+  526 op add :isSolid:x :createTerrainMask:x -3
   527 set :isSolid:y *tmp2
   528 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   529 sensor solid type @solid
   530 select :isSolid:result notEqual solid false 1 0
   531 label *label365
-    * op or :createTerrainMask:result *tmp0 :isSolid:result
+  532 op or :createTerrainMask*retval *tmp0 :isSolid:result
   533 label *label366
   534 label *label367
   535 label *label368
   536 label *label8
-    * set :createTerrainMask*retval :createTerrainMask:result
   537 label *label5
   538 set :createTerrainMask*finished true
   539 jump *label4 always
 
   681 op add *tmp18 :tileValue.1:result :tileValue.2:result
   682 op add *tmp19 :tileValue.2:result :tileValue.3:result
   683 op add *tmp20 :tileValue.3:result :tileValue.4:result
-    * packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
+  684 packcolor :findBestPosition:y1 *tmp17 *tmp18 *tmp19 *tmp20
   685 jump *label381 always
   686 jump *label380 always
   687 label *label375
 
   691 op add *tmp27 *tmp24 :tileValue.3:result
   692 op add *tmp28 :tileValue.2:result :tileValue.3:result
   693 op add *tmp29 *tmp28 :tileValue.4:result
-    * packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
+  694 packcolor :findBestPosition:y1 *tmp25 *tmp27 *tmp29 0
   695 jump *label381 always
   696 jump *label379 always
   697 label *label376
 
   723 op min *tmp46 0.09803921568627451 *tmp45
   724 op add *tmp49 *tmp44 :tileValue.6:result
   725 op min *tmp50 0.09803921568627451 *tmp49
-    * packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
+  726 packcolor :findBestPosition:y1 *tmp38 *tmp42 *tmp46 *tmp50
   727 label *label379
   728 label *label380
   729 label *label381
-    * set :findBestPosition:y1 :computeRowValues*retval
   730 op sub *tmp54 :findBestPosition:y 1
   731 label *label382
   732 op sub :tileValue:x :findBestPosition:x 2
 
   774 op add *tmp18 :tileValue.1:result :tileValue.2:result
   775 op add *tmp19 :tileValue.2:result :tileValue.3:result
   776 op add *tmp20 :tileValue.3:result :tileValue.4:result
-    * packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
+  777 packcolor :findBestPosition:y2 *tmp17 *tmp18 *tmp19 *tmp20
   778 jump *label394 always
   779 jump *label393 always
   780 label *label388
 
   784 op add *tmp27 *tmp24 :tileValue.3:result
   785 op add *tmp28 :tileValue.2:result :tileValue.3:result
   786 op add *tmp29 *tmp28 :tileValue.4:result
-    * packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
+  787 packcolor :findBestPosition:y2 *tmp25 *tmp27 *tmp29 0
   788 jump *label394 always
   789 jump *label392 always
   790 label *label389
 
   816 op min *tmp46 0.09803921568627451 *tmp45
   817 op add *tmp49 *tmp44 :tileValue.6:result
   818 op min *tmp50 0.09803921568627451 *tmp49
-    * packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
+  819 packcolor :findBestPosition:y2 *tmp38 *tmp42 *tmp46 *tmp50
   820 label *label392
   821 label *label393
   822 label *label394
-    * set :findBestPosition:y2 :computeRowValues*retval
   823 label *label395
   824 op sub :tileValue:x :findBestPosition:x 2
   825 set :tileValue:y :findBestPosition:y
 
   866 op add *tmp18 :tileValue.1:result :tileValue.2:result
   867 op add *tmp19 :tileValue.2:result :tileValue.3:result
   868 op add *tmp20 :tileValue.3:result :tileValue.4:result
-    * packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
+  869 packcolor :findBestPosition:y3 *tmp17 *tmp18 *tmp19 *tmp20
   870 jump *label407 always
   871 jump *label406 always
   872 label *label401
 
   876 op add *tmp27 *tmp24 :tileValue.3:result
   877 op add *tmp28 :tileValue.2:result :tileValue.3:result
   878 op add *tmp29 *tmp28 :tileValue.4:result
-    * packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
+  879 packcolor :findBestPosition:y3 *tmp25 *tmp27 *tmp29 0
   880 jump *label407 always
   881 jump *label405 always
   882 label *label402
 
   908 op min *tmp46 0.09803921568627451 *tmp45
   909 op add *tmp49 *tmp44 :tileValue.6:result
   910 op min *tmp50 0.09803921568627451 *tmp49
-    * packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
+  911 packcolor :findBestPosition:y3 *tmp38 *tmp42 *tmp46 *tmp50
   912 label *label405
   913 label *label406
   914 label *label407
-    * set :findBestPosition:y3 :computeRowValues*retval
   915 op add *tmp58 :findBestPosition:y 1
   916 label *label408
   917 op sub :tileValue:x :findBestPosition:x 2
 
   959 op add *tmp18 :tileValue.1:result :tileValue.2:result
   960 op add *tmp19 :tileValue.2:result :tileValue.3:result
   961 op add *tmp20 :tileValue.3:result :tileValue.4:result
-    * packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
+  962 packcolor :findBestPosition:y4 *tmp17 *tmp18 *tmp19 *tmp20
   963 jump *label420 always
   964 jump *label419 always
   965 label *label414
 
   969 op add *tmp27 *tmp24 :tileValue.3:result
   970 op add *tmp28 :tileValue.2:result :tileValue.3:result
   971 op add *tmp29 *tmp28 :tileValue.4:result
-    * packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
+  972 packcolor :findBestPosition:y4 *tmp25 *tmp27 *tmp29 0
   973 jump *label420 always
   974 jump *label418 always
   975 label *label415
 
  1001 op min *tmp46 0.09803921568627451 *tmp45
  1002 op add *tmp49 *tmp44 :tileValue.6:result
  1003 op min *tmp50 0.09803921568627451 *tmp49
-    * packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
+ 1004 packcolor :findBestPosition:y4 *tmp38 *tmp42 *tmp46 *tmp50
  1005 label *label418
  1006 label *label419
  1007 label *label420
-    * set :findBestPosition:y4 :computeRowValues*retval
  1008 op add *tmp60 :findBestPosition:y 2
  1009 set :computeRowValues:x :findBestPosition:x
  1010 set :computeRowValues:y *tmp60

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2:
 
    22 set :createTerrainMask:result :isSolid:result
    23 label *label198
    24 label *label199
-    * op shl *tmp0 :createTerrainMask:result 1
+   25 op shl *tmp0 :isSolid:result 1
    26 op add :isSolid:x :createTerrainMask:x 2
    27 set :isSolid:y *tmp2
    28 ucontrol getBlock :isSolid:x :isSolid:y type building floor
 
   239 label *label271
   240 op shl *tmp0 :createTerrainMask:result 1
   241 op add :isSolid:x :createTerrainMask:x 3
-    * set :isSolid:y *tmp2
+  242 set :isSolid:y :createTerrainMask:y
   243 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   244 sensor solid type @solid
   245 select :isSolid:result notEqual solid false 1 0
 
   249 label *label274
   250 op shl *tmp0 :createTerrainMask:result 1
   251 op add :isSolid:x :createTerrainMask:x 2
-    * set :isSolid:y *tmp2
+  252 set :isSolid:y :createTerrainMask:y
   253 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   254 sensor solid type @solid
   255 select :isSolid:result notEqual solid false 1 0
 
   259 label *label277
   260 op shl *tmp0 :createTerrainMask:result 1
   261 op add :isSolid:x :createTerrainMask:x 1
-    * set :isSolid:y *tmp2
+  262 set :isSolid:y :createTerrainMask:y
   263 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   264 sensor solid type @solid
   265 select :isSolid:result notEqual solid false 1 0
 
   269 label *label280
   270 op shl *tmp0 :createTerrainMask:result 1
   271 set :isSolid:x :createTerrainMask:x
-    * set :isSolid:y *tmp2
+  272 set :isSolid:y :createTerrainMask:y
   273 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   274 sensor solid type @solid
   275 select :isSolid:result notEqual solid false 1 0
 
   279 label *label283
   280 op shl *tmp0 :createTerrainMask:result 1
   281 op add :isSolid:x :createTerrainMask:x -1
-    * set :isSolid:y *tmp2
+  282 set :isSolid:y :createTerrainMask:y
   283 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   284 sensor solid type @solid
   285 select :isSolid:result notEqual solid false 1 0
 
   289 label *label286
   290 op shl *tmp0 :createTerrainMask:result 1
   291 op add :isSolid:x :createTerrainMask:x -2
-    * set :isSolid:y *tmp2
+  292 set :isSolid:y :createTerrainMask:y
   293 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   294 sensor solid type @solid
   295 select :isSolid:result notEqual solid false 1 0
 
   299 label *label289
   300 op shl *tmp0 :createTerrainMask:result 1
   301 op add :isSolid:x :createTerrainMask:x -3
-    * set :isSolid:y *tmp2
+  302 set :isSolid:y :createTerrainMask:y
   303 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   304 sensor solid type @solid
   305 select :isSolid:result notEqual solid false 1 0

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-2 instructions):
 
    19 sensor solid type @solid
    20 select :isSolid:result notEqual solid false 1 0
    21 label *label197
-    * set :createTerrainMask:result :isSolid:result
    22 label *label198
    23 label *label199
    24 op shl *tmp0 :isSolid:result 1
 
   233 label *label267
   234 label *label268
   235 label *label269
-    * set *tmp2 :createTerrainMask:y
   236 label *label270
   237 label *label271
   238 op shl *tmp0 :createTerrainMask:result 1

Modifications by Inline function call at line 142:14 (+77 instructions):
 
  1008 set :computeRowValues:y *tmp60
  1009 set :computeRowValues:ore :findBestPosition:ore
  1010 set :computeRowValues:size :findBestPosition:size
-    * setaddr :computeRowValues*retaddr *label30 (h:*label30)
-    * call *label2 *invalid :computeRowValues*retval (m:*label30) (h:*label30)
-    * label *label30
+ 1011 label *label421
+ 1012 op sub :tileValue:x :computeRowValues:x 2
+ 1013 set :tileValue:y :computeRowValues:y
+ 1014 set :tileValue:ore :computeRowValues:ore
+ 1015 ucontrol getBlock :tileValue:x :tileValue:y type building floor
+ 1016 select value equal floor :tileValue:ore 0.00392156862745098 0
+ 1017 sensor solid type @solid
+ 1018 select :tileValue:result notEqual solid false 0.09803921568627451 value
+ 1019 label *label422
+ 1020 op sub :tileValue.1:x :computeRowValues:x 1
+ 1021 set :tileValue.1:y :computeRowValues:y
+ 1022 set :tileValue.1:ore :computeRowValues:ore
+ 1023 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
+ 1024 select value equal floor :tileValue.1:ore 0.00392156862745098 0
+ 1025 sensor solid type @solid
+ 1026 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
+ 1027 label *label423
+ 1028 set :tileValue.2:x :computeRowValues:x
+ 1029 set :tileValue.2:y :computeRowValues:y
+ 1030 set :tileValue.2:ore :computeRowValues:ore
+ 1031 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
+ 1032 select value equal floor :tileValue.2:ore 0.00392156862745098 0
+ 1033 sensor solid type @solid
+ 1034 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
+ 1035 label *label424
+ 1036 op add :tileValue.3:x :computeRowValues:x 1
+ 1037 set :tileValue.3:y :computeRowValues:y
+ 1038 set :tileValue.3:ore :computeRowValues:ore
+ 1039 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
+ 1040 select value equal floor :tileValue.3:ore 0.00392156862745098 0
+ 1041 sensor solid type @solid
+ 1042 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
+ 1043 label *label425
+ 1044 op add :tileValue.4:x :computeRowValues:x 2
+ 1045 set :tileValue.4:y :computeRowValues:y
+ 1046 set :tileValue.4:ore :computeRowValues:ore
+ 1047 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
+ 1048 select value equal floor :tileValue.4:ore 0.00392156862745098 0
+ 1049 sensor solid type @solid
+ 1050 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
+ 1051 label *label426
+ 1052 jump *label427 notEqual :computeRowValues:size 2
+ 1053 op add *tmp17 :tileValue:result :tileValue.1:result
+ 1054 op add *tmp18 :tileValue.1:result :tileValue.2:result
+ 1055 op add *tmp19 :tileValue.2:result :tileValue.3:result
+ 1056 op add *tmp20 :tileValue.3:result :tileValue.4:result
+ 1057 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
+ 1058 jump *label433 always
+ 1059 jump *label432 always
+ 1060 label *label427
+ 1061 jump *label428 notEqual :computeRowValues:size 3
+ 1062 op add *tmp24 :tileValue.1:result :tileValue.2:result
+ 1063 op add *tmp25 :tileValue:result *tmp24
+ 1064 op add *tmp27 *tmp24 :tileValue.3:result
+ 1065 op add *tmp28 :tileValue.2:result :tileValue.3:result
+ 1066 op add *tmp29 *tmp28 :tileValue.4:result
+ 1067 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
+ 1068 jump *label433 always
+ 1069 jump *label431 always
+ 1070 label *label428
+ 1071 op sub :tileValue.5:x :computeRowValues:x 3
+ 1072 set :tileValue.5:y :computeRowValues:y
+ 1073 set :tileValue.5:ore :computeRowValues:ore
+ 1074 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
+ 1075 select value equal floor :tileValue.5:ore 0.00392156862745098 0
+ 1076 sensor solid type @solid
+ 1077 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
+ 1078 label *label429
+ 1079 op add :tileValue.6:x :computeRowValues:x 3
+ 1080 set :tileValue.6:y :computeRowValues:y
+ 1081 set :tileValue.6:ore :computeRowValues:ore
+ 1082 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
+ 1083 select value equal floor :tileValue.6:ore 0.00392156862745098 0
+ 1084 sensor solid type @solid
+ 1085 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
+ 1086 label *label430
+ 1087 op add *tmp35 :tileValue:result :tileValue.1:result
+ 1088 op add *tmp36 *tmp35 :tileValue.2:result
+ 1089 op add *tmp37 :tileValue.5:result *tmp36
+ 1090 op min *tmp38 0.09803921568627451 *tmp37
+ 1091 op add *tmp41 *tmp36 :tileValue.3:result
+ 1092 op min *tmp42 0.09803921568627451 *tmp41
+ 1093 op add *tmp43 :tileValue.2:result :tileValue.3:result
+ 1094 op add *tmp44 *tmp43 :tileValue.4:result
+ 1095 op add *tmp45 :tileValue.1:result *tmp44
+ 1096 op min *tmp46 0.09803921568627451 *tmp45
+ 1097 op add *tmp49 *tmp44 :tileValue.6:result
+ 1098 op min *tmp50 0.09803921568627451 *tmp49
+ 1099 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
+ 1100 label *label431
+ 1101 label *label432
+ 1102 label *label433
  1103 set :findBestPosition:y5 :computeRowValues*retval
  1104 set :findBestPosition:best 0
  1105 set :findBestPosition:bestX 0

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
  1009 set :computeRowValues:ore :findBestPosition:ore
  1010 set :computeRowValues:size :findBestPosition:size
  1011 label *label421
-    * op sub :tileValue:x :computeRowValues:x 2
-    * set :tileValue:y :computeRowValues:y
-    * set :tileValue:ore :computeRowValues:ore
+ 1012 op sub :tileValue:x :findBestPosition:x 2
+ 1013 set :tileValue:y *tmp60
+ 1014 set :tileValue:ore :findBestPosition:ore
  1015 ucontrol getBlock :tileValue:x :tileValue:y type building floor
  1016 select value equal floor :tileValue:ore 0.00392156862745098 0
  1017 sensor solid type @solid
  1018 select :tileValue:result notEqual solid false 0.09803921568627451 value
  1019 label *label422
-    * op sub :tileValue.1:x :computeRowValues:x 1
-    * set :tileValue.1:y :computeRowValues:y
-    * set :tileValue.1:ore :computeRowValues:ore
+ 1020 op sub :tileValue.1:x :findBestPosition:x 1
+ 1021 set :tileValue.1:y *tmp60
+ 1022 set :tileValue.1:ore :findBestPosition:ore
  1023 ucontrol getBlock :tileValue.1:x :tileValue.1:y type building floor
  1024 select value equal floor :tileValue.1:ore 0.00392156862745098 0
  1025 sensor solid type @solid
  1026 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
  1027 label *label423
-    * set :tileValue.2:x :computeRowValues:x
-    * set :tileValue.2:y :computeRowValues:y
-    * set :tileValue.2:ore :computeRowValues:ore
+ 1028 set :tileValue.2:x :findBestPosition:x
+ 1029 set :tileValue.2:y *tmp60
+ 1030 set :tileValue.2:ore :findBestPosition:ore
  1031 ucontrol getBlock :tileValue.2:x :tileValue.2:y type building floor
  1032 select value equal floor :tileValue.2:ore 0.00392156862745098 0
  1033 sensor solid type @solid
  1034 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
  1035 label *label424
-    * op add :tileValue.3:x :computeRowValues:x 1
-    * set :tileValue.3:y :computeRowValues:y
-    * set :tileValue.3:ore :computeRowValues:ore
+ 1036 op add :tileValue.3:x :findBestPosition:x 1
+ 1037 set :tileValue.3:y *tmp60
+ 1038 set :tileValue.3:ore :findBestPosition:ore
  1039 ucontrol getBlock :tileValue.3:x :tileValue.3:y type building floor
  1040 select value equal floor :tileValue.3:ore 0.00392156862745098 0
  1041 sensor solid type @solid
  1042 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
  1043 label *label425
-    * op add :tileValue.4:x :computeRowValues:x 2
-    * set :tileValue.4:y :computeRowValues:y
-    * set :tileValue.4:ore :computeRowValues:ore
+ 1044 op add :tileValue.4:x :findBestPosition:x 2
+ 1045 set :tileValue.4:y *tmp60
+ 1046 set :tileValue.4:ore :findBestPosition:ore
  1047 ucontrol getBlock :tileValue.4:x :tileValue.4:y type building floor
  1048 select value equal floor :tileValue.4:ore 0.00392156862745098 0
  1049 sensor solid type @solid
  1050 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
  1051 label *label426
-    * jump *label427 notEqual :computeRowValues:size 2
+ 1052 jump *label427 notEqual :findBestPosition:size 2
  1053 op add *tmp17 :tileValue:result :tileValue.1:result
  1054 op add *tmp18 :tileValue.1:result :tileValue.2:result
  1055 op add *tmp19 :tileValue.2:result :tileValue.3:result
 
  1058 jump *label433 always
  1059 jump *label432 always
  1060 label *label427
-    * jump *label428 notEqual :computeRowValues:size 3
+ 1061 jump *label428 notEqual :findBestPosition:size 3
  1062 op add *tmp24 :tileValue.1:result :tileValue.2:result
  1063 op add *tmp25 :tileValue:result *tmp24
  1064 op add *tmp27 *tmp24 :tileValue.3:result
 
  1068 jump *label433 always
  1069 jump *label431 always
  1070 label *label428
-    * op sub :tileValue.5:x :computeRowValues:x 3
-    * set :tileValue.5:y :computeRowValues:y
-    * set :tileValue.5:ore :computeRowValues:ore
+ 1071 op sub :tileValue.5:x :findBestPosition:x 3
+ 1072 set :tileValue.5:y *tmp60
+ 1073 set :tileValue.5:ore :findBestPosition:ore
  1074 ucontrol getBlock :tileValue.5:x :tileValue.5:y type building floor
  1075 select value equal floor :tileValue.5:ore 0.00392156862745098 0
  1076 sensor solid type @solid
  1077 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
  1078 label *label429
-    * op add :tileValue.6:x :computeRowValues:x 3
-    * set :tileValue.6:y :computeRowValues:y
-    * set :tileValue.6:ore :computeRowValues:ore
+ 1079 op add :tileValue.6:x :findBestPosition:x 3
+ 1080 set :tileValue.6:y *tmp60
+ 1081 set :tileValue.6:ore :findBestPosition:ore
  1082 ucontrol getBlock :tileValue.6:x :tileValue.6:y type building floor
  1083 select value equal floor :tileValue.6:ore 0.00392156862745098 0
  1084 sensor solid type @solid

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-4 instructions):
 
  1004 label *label419
  1005 label *label420
  1006 op add *tmp60 :findBestPosition:y 2
-    * set :computeRowValues:x :findBestPosition:x
-    * set :computeRowValues:y *tmp60
-    * set :computeRowValues:ore :findBestPosition:ore
-    * set :computeRowValues:size :findBestPosition:size
  1007 label *label421
  1008 op sub :tileValue:x :findBestPosition:x 2
  1009 set :tileValue:y *tmp60

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     8 end
     9 label *label0
    10 ubind :createTerrainMask:unit
-    * label *label193
-    * label *label194
    11 op add *tmp2 :createTerrainMask:y 3
-    * label *label195
-    * label *label196
    12 op add :isSolid:x :createTerrainMask:x 3
    13 set :isSolid:y *tmp2
    14 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    15 sensor solid type @solid
    16 select :isSolid:result notEqual solid false 1 0
-    * label *label197
-    * label *label198
-    * label *label199
    17 op shl *tmp0 :isSolid:result 1
    18 op add :isSolid:x :createTerrainMask:x 2
    19 set :isSolid:y *tmp2
    20 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    21 sensor solid type @solid
    22 select :isSolid:result notEqual solid false 1 0
-    * label *label200
    23 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label201
-    * label *label202
    24 op shl *tmp0 :createTerrainMask:result 1
    25 op add :isSolid:x :createTerrainMask:x 1
    26 set :isSolid:y *tmp2
    27 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    28 sensor solid type @solid
    29 select :isSolid:result notEqual solid false 1 0
-    * label *label203
    30 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label204
-    * label *label205
    31 op shl *tmp0 :createTerrainMask:result 1
    32 set :isSolid:x :createTerrainMask:x
    33 set :isSolid:y *tmp2
    34 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    35 sensor solid type @solid
    36 select :isSolid:result notEqual solid false 1 0
-    * label *label206
    37 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label207
-    * label *label208
    38 op shl *tmp0 :createTerrainMask:result 1
    39 op add :isSolid:x :createTerrainMask:x -1
    40 set :isSolid:y *tmp2
    41 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    42 sensor solid type @solid
    43 select :isSolid:result notEqual solid false 1 0
-    * label *label209
    44 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label210
-    * label *label211
    45 op shl *tmp0 :createTerrainMask:result 1
    46 op add :isSolid:x :createTerrainMask:x -2
    47 set :isSolid:y *tmp2
    48 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    49 sensor solid type @solid
    50 select :isSolid:result notEqual solid false 1 0
-    * label *label212
    51 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label213
-    * label *label214
    52 op shl *tmp0 :createTerrainMask:result 1
    53 op add :isSolid:x :createTerrainMask:x -3
    54 set :isSolid:y *tmp2
    55 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    56 sensor solid type @solid
    57 select :isSolid:result notEqual solid false 1 0
-    * label *label215
    58 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label216
-    * label *label217
-    * label *label218
-    * label *label219
    59 op add *tmp2 :createTerrainMask:y 2
-    * label *label220
-    * label *label221
    60 op shl *tmp0 :createTerrainMask:result 1
    61 op add :isSolid:x :createTerrainMask:x 3
    62 set :isSolid:y *tmp2
    63 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    64 sensor solid type @solid
    65 select :isSolid:result notEqual solid false 1 0
-    * label *label222
    66 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label223
-    * label *label224
    67 op shl *tmp0 :createTerrainMask:result 1
    68 op add :isSolid:x :createTerrainMask:x 2
    69 set :isSolid:y *tmp2
    70 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    71 sensor solid type @solid
    72 select :isSolid:result notEqual solid false 1 0
-    * label *label225
    73 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label226
-    * label *label227
    74 op shl *tmp0 :createTerrainMask:result 1
    75 op add :isSolid:x :createTerrainMask:x 1
    76 set :isSolid:y *tmp2
    77 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    78 sensor solid type @solid
    79 select :isSolid:result notEqual solid false 1 0
-    * label *label228
    80 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label229
-    * label *label230
    81 op shl *tmp0 :createTerrainMask:result 1
    82 set :isSolid:x :createTerrainMask:x
    83 set :isSolid:y *tmp2
    84 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    85 sensor solid type @solid
    86 select :isSolid:result notEqual solid false 1 0
-    * label *label231
    87 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label232
-    * label *label233
    88 op shl *tmp0 :createTerrainMask:result 1
    89 op add :isSolid:x :createTerrainMask:x -1
    90 set :isSolid:y *tmp2
    91 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    92 sensor solid type @solid
    93 select :isSolid:result notEqual solid false 1 0
-    * label *label234
    94 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label235
-    * label *label236
    95 op shl *tmp0 :createTerrainMask:result 1
    96 op add :isSolid:x :createTerrainMask:x -2
    97 set :isSolid:y *tmp2
    98 ucontrol getBlock :isSolid:x :isSolid:y type building floor
    99 sensor solid type @solid
   100 select :isSolid:result notEqual solid false 1 0
-    * label *label237
   101 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label238
-    * label *label239
   102 op shl *tmp0 :createTerrainMask:result 1
   103 op add :isSolid:x :createTerrainMask:x -3
   104 set :isSolid:y *tmp2
   105 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   106 sensor solid type @solid
   107 select :isSolid:result notEqual solid false 1 0
-    * label *label240
   108 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label241
-    * label *label242
-    * label *label243
-    * label *label244
   109 op add *tmp2 :createTerrainMask:y 1
-    * label *label245
-    * label *label246
   110 op shl *tmp0 :createTerrainMask:result 1
   111 op add :isSolid:x :createTerrainMask:x 3
   112 set :isSolid:y *tmp2
   113 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   114 sensor solid type @solid
   115 select :isSolid:result notEqual solid false 1 0
-    * label *label247
   116 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label248
-    * label *label249
   117 op shl *tmp0 :createTerrainMask:result 1
   118 op add :isSolid:x :createTerrainMask:x 2
   119 set :isSolid:y *tmp2
   120 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   121 sensor solid type @solid
   122 select :isSolid:result notEqual solid false 1 0
-    * label *label250
   123 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label251
-    * label *label252
   124 op shl *tmp0 :createTerrainMask:result 1
   125 op add :isSolid:x :createTerrainMask:x 1
   126 set :isSolid:y *tmp2
   127 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   128 sensor solid type @solid
   129 select :isSolid:result notEqual solid false 1 0
-    * label *label253
   130 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label254
-    * label *label255
   131 op shl *tmp0 :createTerrainMask:result 1
   132 set :isSolid:x :createTerrainMask:x
   133 set :isSolid:y *tmp2
   134 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   135 sensor solid type @solid
   136 select :isSolid:result notEqual solid false 1 0
-    * label *label256
   137 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label257
-    * label *label258
   138 op shl *tmp0 :createTerrainMask:result 1
   139 op add :isSolid:x :createTerrainMask:x -1
   140 set :isSolid:y *tmp2
   141 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   142 sensor solid type @solid
   143 select :isSolid:result notEqual solid false 1 0
-    * label *label259
   144 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label260
-    * label *label261
   145 op shl *tmp0 :createTerrainMask:result 1
   146 op add :isSolid:x :createTerrainMask:x -2
   147 set :isSolid:y *tmp2
   148 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   149 sensor solid type @solid
   150 select :isSolid:result notEqual solid false 1 0
-    * label *label262
   151 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label263
-    * label *label264
   152 op shl *tmp0 :createTerrainMask:result 1
   153 op add :isSolid:x :createTerrainMask:x -3
   154 set :isSolid:y *tmp2
   155 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   156 sensor solid type @solid
   157 select :isSolid:result notEqual solid false 1 0
-    * label *label265
   158 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label266
-    * label *label267
-    * label *label268
-    * label *label269
-    * label *label270
-    * label *label271
   159 op shl *tmp0 :createTerrainMask:result 1
   160 op add :isSolid:x :createTerrainMask:x 3
   161 set :isSolid:y :createTerrainMask:y
   162 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   163 sensor solid type @solid
   164 select :isSolid:result notEqual solid false 1 0
-    * label *label272
   165 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label273
-    * label *label274
   166 op shl *tmp0 :createTerrainMask:result 1
   167 op add :isSolid:x :createTerrainMask:x 2
   168 set :isSolid:y :createTerrainMask:y
   169 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   170 sensor solid type @solid
   171 select :isSolid:result notEqual solid false 1 0
-    * label *label275
   172 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label276
-    * label *label277
   173 op shl *tmp0 :createTerrainMask:result 1
   174 op add :isSolid:x :createTerrainMask:x 1
   175 set :isSolid:y :createTerrainMask:y
   176 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   177 sensor solid type @solid
   178 select :isSolid:result notEqual solid false 1 0
-    * label *label278
   179 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label279
-    * label *label280
   180 op shl *tmp0 :createTerrainMask:result 1
   181 set :isSolid:x :createTerrainMask:x
   182 set :isSolid:y :createTerrainMask:y
   183 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   184 sensor solid type @solid
   185 select :isSolid:result notEqual solid false 1 0
-    * label *label281
   186 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label282
-    * label *label283
   187 op shl *tmp0 :createTerrainMask:result 1
   188 op add :isSolid:x :createTerrainMask:x -1
   189 set :isSolid:y :createTerrainMask:y
   190 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   191 sensor solid type @solid
   192 select :isSolid:result notEqual solid false 1 0
-    * label *label284
   193 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label285
-    * label *label286
   194 op shl *tmp0 :createTerrainMask:result 1
   195 op add :isSolid:x :createTerrainMask:x -2
   196 set :isSolid:y :createTerrainMask:y
   197 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   198 sensor solid type @solid
   199 select :isSolid:result notEqual solid false 1 0
-    * label *label287
   200 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label288
-    * label *label289
   201 op shl *tmp0 :createTerrainMask:result 1
   202 op add :isSolid:x :createTerrainMask:x -3
   203 set :isSolid:y :createTerrainMask:y
   204 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   205 sensor solid type @solid
   206 select :isSolid:result notEqual solid false 1 0
-    * label *label290
   207 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label291
-    * label *label292
-    * label *label293
-    * label *label294
   208 op add *tmp2 :createTerrainMask:y -1
-    * label *label295
-    * label *label296
   209 op shl *tmp0 :createTerrainMask:result 1
   210 op add :isSolid:x :createTerrainMask:x 3
   211 set :isSolid:y *tmp2
   212 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   213 sensor solid type @solid
   214 select :isSolid:result notEqual solid false 1 0
-    * label *label297
   215 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label298
-    * label *label299
   216 op shl *tmp0 :createTerrainMask:result 1
   217 op add :isSolid:x :createTerrainMask:x 2
   218 set :isSolid:y *tmp2
   219 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   220 sensor solid type @solid
   221 select :isSolid:result notEqual solid false 1 0
-    * label *label300
   222 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label301
-    * label *label302
   223 op shl *tmp0 :createTerrainMask:result 1
   224 op add :isSolid:x :createTerrainMask:x 1
   225 set :isSolid:y *tmp2
   226 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   227 sensor solid type @solid
   228 select :isSolid:result notEqual solid false 1 0
-    * label *label303
   229 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label304
-    * label *label305
   230 op shl *tmp0 :createTerrainMask:result 1
   231 set :isSolid:x :createTerrainMask:x
   232 set :isSolid:y *tmp2
   233 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   234 sensor solid type @solid
   235 select :isSolid:result notEqual solid false 1 0
-    * label *label306
   236 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label307
-    * label *label308
   237 op shl *tmp0 :createTerrainMask:result 1
   238 op add :isSolid:x :createTerrainMask:x -1
   239 set :isSolid:y *tmp2
   240 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   241 sensor solid type @solid
   242 select :isSolid:result notEqual solid false 1 0
-    * label *label309
   243 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label310
-    * label *label311
   244 op shl *tmp0 :createTerrainMask:result 1
   245 op add :isSolid:x :createTerrainMask:x -2
   246 set :isSolid:y *tmp2
   247 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   248 sensor solid type @solid
   249 select :isSolid:result notEqual solid false 1 0
-    * label *label312
   250 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label313
-    * label *label314
   251 op shl *tmp0 :createTerrainMask:result 1
   252 op add :isSolid:x :createTerrainMask:x -3
   253 set :isSolid:y *tmp2
   254 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   255 sensor solid type @solid
   256 select :isSolid:result notEqual solid false 1 0
-    * label *label315
   257 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label316
-    * label *label317
-    * label *label318
-    * label *label319
   258 op add *tmp2 :createTerrainMask:y -2
-    * label *label320
-    * label *label321
   259 op shl *tmp0 :createTerrainMask:result 1
   260 op add :isSolid:x :createTerrainMask:x 3
   261 set :isSolid:y *tmp2
   262 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   263 sensor solid type @solid
   264 select :isSolid:result notEqual solid false 1 0
-    * label *label322
   265 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label323
-    * label *label324
   266 op shl *tmp0 :createTerrainMask:result 1
   267 op add :isSolid:x :createTerrainMask:x 2
   268 set :isSolid:y *tmp2
   269 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   270 sensor solid type @solid
   271 select :isSolid:result notEqual solid false 1 0
-    * label *label325
   272 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label326
-    * label *label327
   273 op shl *tmp0 :createTerrainMask:result 1
   274 op add :isSolid:x :createTerrainMask:x 1
   275 set :isSolid:y *tmp2
   276 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   277 sensor solid type @solid
   278 select :isSolid:result notEqual solid false 1 0
-    * label *label328
   279 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label329
-    * label *label330
   280 op shl *tmp0 :createTerrainMask:result 1
   281 set :isSolid:x :createTerrainMask:x
   282 set :isSolid:y *tmp2
   283 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   284 sensor solid type @solid
   285 select :isSolid:result notEqual solid false 1 0
-    * label *label331
   286 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label332
-    * label *label333
   287 op shl *tmp0 :createTerrainMask:result 1
   288 op add :isSolid:x :createTerrainMask:x -1
   289 set :isSolid:y *tmp2
   290 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   291 sensor solid type @solid
   292 select :isSolid:result notEqual solid false 1 0
-    * label *label334
   293 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label335
-    * label *label336
   294 op shl *tmp0 :createTerrainMask:result 1
   295 op add :isSolid:x :createTerrainMask:x -2
   296 set :isSolid:y *tmp2
   297 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   298 sensor solid type @solid
   299 select :isSolid:result notEqual solid false 1 0
-    * label *label337
   300 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label338
-    * label *label339
   301 op shl *tmp0 :createTerrainMask:result 1
   302 op add :isSolid:x :createTerrainMask:x -3
   303 set :isSolid:y *tmp2
   304 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   305 sensor solid type @solid
   306 select :isSolid:result notEqual solid false 1 0
-    * label *label340
   307 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label341
-    * label *label342
-    * label *label343
-    * label *label344
   308 op add *tmp2 :createTerrainMask:y -3
-    * label *label345
-    * label *label346
   309 op shl *tmp0 :createTerrainMask:result 1
   310 op add :isSolid:x :createTerrainMask:x 3
   311 set :isSolid:y *tmp2
   312 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   313 sensor solid type @solid
   314 select :isSolid:result notEqual solid false 1 0
-    * label *label347
   315 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label348
-    * label *label349
   316 op shl *tmp0 :createTerrainMask:result 1
   317 op add :isSolid:x :createTerrainMask:x 2
   318 set :isSolid:y *tmp2
   319 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   320 sensor solid type @solid
   321 select :isSolid:result notEqual solid false 1 0
-    * label *label350
   322 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label351
-    * label *label352
   323 op shl *tmp0 :createTerrainMask:result 1
   324 op add :isSolid:x :createTerrainMask:x 1
   325 set :isSolid:y *tmp2
   326 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   327 sensor solid type @solid
   328 select :isSolid:result notEqual solid false 1 0
-    * label *label353
   329 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label354
-    * label *label355
   330 op shl *tmp0 :createTerrainMask:result 1
   331 set :isSolid:x :createTerrainMask:x
   332 set :isSolid:y *tmp2
   333 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   334 sensor solid type @solid
   335 select :isSolid:result notEqual solid false 1 0
-    * label *label356
   336 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label357
-    * label *label358
   337 op shl *tmp0 :createTerrainMask:result 1
   338 op add :isSolid:x :createTerrainMask:x -1
   339 set :isSolid:y *tmp2
   340 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   341 sensor solid type @solid
   342 select :isSolid:result notEqual solid false 1 0
-    * label *label359
   343 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label360
-    * label *label361
   344 op shl *tmp0 :createTerrainMask:result 1
   345 op add :isSolid:x :createTerrainMask:x -2
   346 set :isSolid:y *tmp2
   347 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   348 sensor solid type @solid
   349 select :isSolid:result notEqual solid false 1 0
-    * label *label362
   350 op or :createTerrainMask:result *tmp0 :isSolid:result
-    * label *label363
-    * label *label364
   351 op shl *tmp0 :createTerrainMask:result 1
   352 op add :isSolid:x :createTerrainMask:x -3
   353 set :isSolid:y *tmp2
   354 ucontrol getBlock :isSolid:x :isSolid:y type building floor
   355 sensor solid type @solid
   356 select :isSolid:result notEqual solid false 1 0
-    * label *label365
   357 op or :createTerrainMask*retval *tmp0 :isSolid:result
-    * label *label366
-    * label *label367
-    * label *label368
-    * label *label8
-    * label *label5
   358 set :createTerrainMask*finished true
   359 jump *label4 always
   360 end
 
   366 select value equal floor :tileValue:ore 0.00392156862745098 0
   367 sensor solid type @solid
   368 select :tileValue:result notEqual solid false 0.09803921568627451 value
-    * label *label14
   369 op sub :tileValue.1:x :computeRowValues:x 1
   370 set :tileValue.1:y :computeRowValues:y
   371 set :tileValue.1:ore :computeRowValues:ore
 
   373 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   374 sensor solid type @solid
   375 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
-    * label *label15
   376 set :tileValue.2:x :computeRowValues:x
   377 set :tileValue.2:y :computeRowValues:y
   378 set :tileValue.2:ore :computeRowValues:ore
 
   380 select value equal floor :tileValue.2:ore 0.00392156862745098 0
   381 sensor solid type @solid
   382 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
-    * label *label16
   383 op add :tileValue.3:x :computeRowValues:x 1
   384 set :tileValue.3:y :computeRowValues:y
   385 set :tileValue.3:ore :computeRowValues:ore
 
   387 select value equal floor :tileValue.3:ore 0.00392156862745098 0
   388 sensor solid type @solid
   389 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
-    * label *label17
   390 op add :tileValue.4:x :computeRowValues:x 2
   391 set :tileValue.4:y :computeRowValues:y
   392 set :tileValue.4:ore :computeRowValues:ore
 
   394 select value equal floor :tileValue.4:ore 0.00392156862745098 0
   395 sensor solid type @solid
   396 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
-    * label *label18
   397 jump *label19 notEqual :computeRowValues:size 2
   398 op add *tmp17 :tileValue:result :tileValue.1:result
   399 op add *tmp18 :tileValue.1:result :tileValue.2:result
 
   420 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   421 sensor solid type @solid
   422 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
-    * label *label23
   423 op add :tileValue.6:x :computeRowValues:x 3
   424 set :tileValue.6:y :computeRowValues:y
   425 set :tileValue.6:ore :computeRowValues:ore
 
   427 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   428 sensor solid type @solid
   429 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
-    * label *label24
   430 op add *tmp35 :tileValue:result :tileValue.1:result
   431 op add *tmp36 *tmp35 :tileValue.2:result
   432 op add *tmp37 :tileValue.5:result *tmp36
 
   448 label *label1
   449 ubind :findBestPosition:unit
   450 op sub *tmp52 :findBestPosition:y 2
-    * label *label369
   451 op sub :tileValue:x :findBestPosition:x 2
   452 set :tileValue:y *tmp52
   453 set :tileValue:ore :findBestPosition:ore
 
   455 select value equal floor :tileValue:ore 0.00392156862745098 0
   456 sensor solid type @solid
   457 select :tileValue:result notEqual solid false 0.09803921568627451 value
-    * label *label370
   458 op sub :tileValue.1:x :findBestPosition:x 1
   459 set :tileValue.1:y *tmp52
   460 set :tileValue.1:ore :findBestPosition:ore
 
   462 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   463 sensor solid type @solid
   464 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
-    * label *label371
   465 set :tileValue.2:x :findBestPosition:x
   466 set :tileValue.2:y *tmp52
   467 set :tileValue.2:ore :findBestPosition:ore
 
   469 select value equal floor :tileValue.2:ore 0.00392156862745098 0
   470 sensor solid type @solid
   471 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
-    * label *label372
   472 op add :tileValue.3:x :findBestPosition:x 1
   473 set :tileValue.3:y *tmp52
   474 set :tileValue.3:ore :findBestPosition:ore
 
   476 select value equal floor :tileValue.3:ore 0.00392156862745098 0
   477 sensor solid type @solid
   478 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
-    * label *label373
   479 op add :tileValue.4:x :findBestPosition:x 2
   480 set :tileValue.4:y *tmp52
   481 set :tileValue.4:ore :findBestPosition:ore
 
   483 select value equal floor :tileValue.4:ore 0.00392156862745098 0
   484 sensor solid type @solid
   485 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
-    * label *label374
   486 jump *label375 notEqual :findBestPosition:size 2
   487 op add *tmp17 :tileValue:result :tileValue.1:result
   488 op add *tmp18 :tileValue.1:result :tileValue.2:result
 
   509 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   510 sensor solid type @solid
   511 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
-    * label *label377
   512 op add :tileValue.6:x :findBestPosition:x 3
   513 set :tileValue.6:y *tmp52
   514 set :tileValue.6:ore :findBestPosition:ore
 
   516 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   517 sensor solid type @solid
   518 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
-    * label *label378
   519 op add *tmp35 :tileValue:result :tileValue.1:result
   520 op add *tmp36 *tmp35 :tileValue.2:result
   521 op add *tmp37 :tileValue.5:result *tmp36
 
   533 label *label380
   534 label *label381
   535 op sub *tmp54 :findBestPosition:y 1
-    * label *label382
   536 op sub :tileValue:x :findBestPosition:x 2
   537 set :tileValue:y *tmp54
   538 set :tileValue:ore :findBestPosition:ore
 
   540 select value equal floor :tileValue:ore 0.00392156862745098 0
   541 sensor solid type @solid
   542 select :tileValue:result notEqual solid false 0.09803921568627451 value
-    * label *label383
   543 op sub :tileValue.1:x :findBestPosition:x 1
   544 set :tileValue.1:y *tmp54
   545 set :tileValue.1:ore :findBestPosition:ore
 
   547 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   548 sensor solid type @solid
   549 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
-    * label *label384
   550 set :tileValue.2:x :findBestPosition:x
   551 set :tileValue.2:y *tmp54
   552 set :tileValue.2:ore :findBestPosition:ore
 
   554 select value equal floor :tileValue.2:ore 0.00392156862745098 0
   555 sensor solid type @solid
   556 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
-    * label *label385
   557 op add :tileValue.3:x :findBestPosition:x 1
   558 set :tileValue.3:y *tmp54
   559 set :tileValue.3:ore :findBestPosition:ore
 
   561 select value equal floor :tileValue.3:ore 0.00392156862745098 0
   562 sensor solid type @solid
   563 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
-    * label *label386
   564 op add :tileValue.4:x :findBestPosition:x 2
   565 set :tileValue.4:y *tmp54
   566 set :tileValue.4:ore :findBestPosition:ore
 
   568 select value equal floor :tileValue.4:ore 0.00392156862745098 0
   569 sensor solid type @solid
   570 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
-    * label *label387
   571 jump *label388 notEqual :findBestPosition:size 2
   572 op add *tmp17 :tileValue:result :tileValue.1:result
   573 op add *tmp18 :tileValue.1:result :tileValue.2:result
 
   594 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   595 sensor solid type @solid
   596 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
-    * label *label390
   597 op add :tileValue.6:x :findBestPosition:x 3
   598 set :tileValue.6:y *tmp54
   599 set :tileValue.6:ore :findBestPosition:ore
 
   601 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   602 sensor solid type @solid
   603 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
-    * label *label391
   604 op add *tmp35 :tileValue:result :tileValue.1:result
   605 op add *tmp36 *tmp35 :tileValue.2:result
   606 op add *tmp37 :tileValue.5:result *tmp36
 
   617 label *label392
   618 label *label393
   619 label *label394
-    * label *label395
   620 op sub :tileValue:x :findBestPosition:x 2
   621 set :tileValue:y :findBestPosition:y
   622 set :tileValue:ore :findBestPosition:ore
 
   624 select value equal floor :tileValue:ore 0.00392156862745098 0
   625 sensor solid type @solid
   626 select :tileValue:result notEqual solid false 0.09803921568627451 value
-    * label *label396
   627 op sub :tileValue.1:x :findBestPosition:x 1
   628 set :tileValue.1:y :findBestPosition:y
   629 set :tileValue.1:ore :findBestPosition:ore
 
   631 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   632 sensor solid type @solid
   633 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
-    * label *label397
   634 set :tileValue.2:x :findBestPosition:x
   635 set :tileValue.2:y :findBestPosition:y
   636 set :tileValue.2:ore :findBestPosition:ore
 
   638 select value equal floor :tileValue.2:ore 0.00392156862745098 0
   639 sensor solid type @solid
   640 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
-    * label *label398
   641 op add :tileValue.3:x :findBestPosition:x 1
   642 set :tileValue.3:y :findBestPosition:y
   643 set :tileValue.3:ore :findBestPosition:ore
 
   645 select value equal floor :tileValue.3:ore 0.00392156862745098 0
   646 sensor solid type @solid
   647 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
-    * label *label399
   648 op add :tileValue.4:x :findBestPosition:x 2
   649 set :tileValue.4:y :findBestPosition:y
   650 set :tileValue.4:ore :findBestPosition:ore
 
   652 select value equal floor :tileValue.4:ore 0.00392156862745098 0
   653 sensor solid type @solid
   654 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
-    * label *label400
   655 jump *label401 notEqual :findBestPosition:size 2
   656 op add *tmp17 :tileValue:result :tileValue.1:result
   657 op add *tmp18 :tileValue.1:result :tileValue.2:result
 
   678 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   679 sensor solid type @solid
   680 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
-    * label *label403
   681 op add :tileValue.6:x :findBestPosition:x 3
   682 set :tileValue.6:y :findBestPosition:y
   683 set :tileValue.6:ore :findBestPosition:ore
 
   685 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   686 sensor solid type @solid
   687 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
-    * label *label404
   688 op add *tmp35 :tileValue:result :tileValue.1:result
   689 op add *tmp36 *tmp35 :tileValue.2:result
   690 op add *tmp37 :tileValue.5:result *tmp36
 
   702 label *label406
   703 label *label407
   704 op add *tmp58 :findBestPosition:y 1
-    * label *label408
   705 op sub :tileValue:x :findBestPosition:x 2
   706 set :tileValue:y *tmp58
   707 set :tileValue:ore :findBestPosition:ore
 
   709 select value equal floor :tileValue:ore 0.00392156862745098 0
   710 sensor solid type @solid
   711 select :tileValue:result notEqual solid false 0.09803921568627451 value
-    * label *label409
   712 op sub :tileValue.1:x :findBestPosition:x 1
   713 set :tileValue.1:y *tmp58
   714 set :tileValue.1:ore :findBestPosition:ore
 
   716 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   717 sensor solid type @solid
   718 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
-    * label *label410
   719 set :tileValue.2:x :findBestPosition:x
   720 set :tileValue.2:y *tmp58
   721 set :tileValue.2:ore :findBestPosition:ore
 
   723 select value equal floor :tileValue.2:ore 0.00392156862745098 0
   724 sensor solid type @solid
   725 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
-    * label *label411
   726 op add :tileValue.3:x :findBestPosition:x 1
   727 set :tileValue.3:y *tmp58
   728 set :tileValue.3:ore :findBestPosition:ore
 
   730 select value equal floor :tileValue.3:ore 0.00392156862745098 0
   731 sensor solid type @solid
   732 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
-    * label *label412
   733 op add :tileValue.4:x :findBestPosition:x 2
   734 set :tileValue.4:y *tmp58
   735 set :tileValue.4:ore :findBestPosition:ore
 
   737 select value equal floor :tileValue.4:ore 0.00392156862745098 0
   738 sensor solid type @solid
   739 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
-    * label *label413
   740 jump *label414 notEqual :findBestPosition:size 2
   741 op add *tmp17 :tileValue:result :tileValue.1:result
   742 op add *tmp18 :tileValue.1:result :tileValue.2:result
 
   763 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   764 sensor solid type @solid
   765 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
-    * label *label416
   766 op add :tileValue.6:x :findBestPosition:x 3
   767 set :tileValue.6:y *tmp58
   768 set :tileValue.6:ore :findBestPosition:ore
 
   770 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   771 sensor solid type @solid
   772 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
-    * label *label417
   773 op add *tmp35 :tileValue:result :tileValue.1:result
   774 op add *tmp36 *tmp35 :tileValue.2:result
   775 op add *tmp37 :tileValue.5:result *tmp36
 
   787 label *label419
   788 label *label420
   789 op add *tmp60 :findBestPosition:y 2
-    * label *label421
   790 op sub :tileValue:x :findBestPosition:x 2
   791 set :tileValue:y *tmp60
   792 set :tileValue:ore :findBestPosition:ore
 
   794 select value equal floor :tileValue:ore 0.00392156862745098 0
   795 sensor solid type @solid
   796 select :tileValue:result notEqual solid false 0.09803921568627451 value
-    * label *label422
   797 op sub :tileValue.1:x :findBestPosition:x 1
   798 set :tileValue.1:y *tmp60
   799 set :tileValue.1:ore :findBestPosition:ore
 
   801 select value equal floor :tileValue.1:ore 0.00392156862745098 0
   802 sensor solid type @solid
   803 select :tileValue.1:result notEqual solid false 0.09803921568627451 value
-    * label *label423
   804 set :tileValue.2:x :findBestPosition:x
   805 set :tileValue.2:y *tmp60
   806 set :tileValue.2:ore :findBestPosition:ore
 
   808 select value equal floor :tileValue.2:ore 0.00392156862745098 0
   809 sensor solid type @solid
   810 select :tileValue.2:result notEqual solid false 0.09803921568627451 value
-    * label *label424
   811 op add :tileValue.3:x :findBestPosition:x 1
   812 set :tileValue.3:y *tmp60
   813 set :tileValue.3:ore :findBestPosition:ore
 
   815 select value equal floor :tileValue.3:ore 0.00392156862745098 0
   816 sensor solid type @solid
   817 select :tileValue.3:result notEqual solid false 0.09803921568627451 value
-    * label *label425
   818 op add :tileValue.4:x :findBestPosition:x 2
   819 set :tileValue.4:y *tmp60
   820 set :tileValue.4:ore :findBestPosition:ore
 
   822 select value equal floor :tileValue.4:ore 0.00392156862745098 0
   823 sensor solid type @solid
   824 select :tileValue.4:result notEqual solid false 0.09803921568627451 value
-    * label *label426
   825 jump *label427 notEqual :findBestPosition:size 2
   826 op add *tmp17 :tileValue:result :tileValue.1:result
   827 op add *tmp18 :tileValue.1:result :tileValue.2:result
 
   848 select value equal floor :tileValue.5:ore 0.00392156862745098 0
   849 sensor solid type @solid
   850 select :tileValue.5:result notEqual solid false 0.09803921568627451 value
-    * label *label429
   851 op add :tileValue.6:x :findBestPosition:x 3
   852 set :tileValue.6:y *tmp60
   853 set :tileValue.6:ore :findBestPosition:ore
 
   855 select value equal floor :tileValue.6:ore 0.00392156862745098 0
   856 sensor solid type @solid
   857 select :tileValue.6:result notEqual solid false 0.09803921568627451 value
-    * label *label430
   858 op add *tmp35 :tileValue:result :tileValue.1:result
   859 op add *tmp36 *tmp35 :tileValue.2:result
   860 op add *tmp37 :tileValue.5:result *tmp36
 
   888 set :findBestPosition:bestY -1
   889 set :findBestPosition:best :updateRowPositionsOdd:col1
   890 label *label37
-    * label *label38
   891 label *label35
-    * label *label36
-    * label *label34
   892 jump *label40 lessThanEq :updateRowPositionsOdd:col2 :findBestPosition:best
   893 jump *label42 greaterThanEq :updateRowPositionsOdd:col2 0.0784313725490196
   894 set :findBestPosition:bestX 0
   895 set :findBestPosition:bestY -1
   896 set :findBestPosition:best :updateRowPositionsOdd:col2
   897 label *label42
-    * label *label43
   898 label *label40
-    * label *label41
-    * label *label39
   899 jump *label45 lessThanEq :updateRowPositionsOdd:col3 :findBestPosition:best
   900 jump *label47 greaterThanEq :updateRowPositionsOdd:col3 0.0784313725490196
   901 set :findBestPosition:bestX 1
   902 set :findBestPosition:bestY -1
   903 set :findBestPosition:best :updateRowPositionsOdd:col3
   904 label *label47
-    * label *label48
   905 label *label45
-    * label *label46
-    * label *label44
-    * label *label33
   906 unpackcolor :updateRowPositionsOdd.1:col1 :updateRowPositionsOdd.1:col2 :updateRowPositionsOdd.1:col3 *tmp83 :findBestPosition:row2
   907 jump *label51 lessThanEq :updateRowPositionsOdd.1:col1 :findBestPosition:best
   908 jump *label53 greaterThanEq :updateRowPositionsOdd.1:col1 0.0784313725490196
 
   910 set :findBestPosition:bestY 0
   911 set :findBestPosition:best :updateRowPositionsOdd.1:col1
   912 label *label53
-    * label *label54
   913 label *label51
-    * label *label52
-    * label *label50
   914 jump *label56 lessThanEq :updateRowPositionsOdd.1:col2 :findBestPosition:best
   915 jump *label58 greaterThanEq :updateRowPositionsOdd.1:col2 0.0784313725490196
   916 set :findBestPosition:bestX 0
   917 set :findBestPosition:bestY 0
   918 set :findBestPosition:best :updateRowPositionsOdd.1:col2
   919 label *label58
-    * label *label59
   920 label *label56
-    * label *label57
-    * label *label55
   921 jump *label61 lessThanEq :updateRowPositionsOdd.1:col3 :findBestPosition:best
   922 jump *label63 greaterThanEq :updateRowPositionsOdd.1:col3 0.0784313725490196
   923 set :findBestPosition:bestX 1
   924 set :findBestPosition:bestY 0
   925 set :findBestPosition:best :updateRowPositionsOdd.1:col3
   926 label *label63
-    * label *label64
   927 label *label61
-    * label *label62
-    * label *label60
-    * label *label49
   928 unpackcolor :updateRowPositionsOdd.2:col1 :updateRowPositionsOdd.2:col2 :updateRowPositionsOdd.2:col3 *tmp96 :findBestPosition:row3
   929 jump *label67 lessThanEq :updateRowPositionsOdd.2:col1 :findBestPosition:best
   930 jump *label69 greaterThanEq :updateRowPositionsOdd.2:col1 0.0784313725490196
 
   932 set :findBestPosition:bestY 1
   933 set :findBestPosition:best :updateRowPositionsOdd.2:col1
   934 label *label69
-    * label *label70
   935 label *label67
-    * label *label68
-    * label *label66
   936 jump *label72 lessThanEq :updateRowPositionsOdd.2:col2 :findBestPosition:best
   937 jump *label74 greaterThanEq :updateRowPositionsOdd.2:col2 0.0784313725490196
   938 set :findBestPosition:bestX 0
   939 set :findBestPosition:bestY 1
   940 set :findBestPosition:best :updateRowPositionsOdd.2:col2
   941 label *label74
-    * label *label75
   942 label *label72
-    * label *label73
-    * label *label71
   943 jump *label77 lessThanEq :updateRowPositionsOdd.2:col3 :findBestPosition:best
   944 jump *label79 greaterThanEq :updateRowPositionsOdd.2:col3 0.0784313725490196
   945 set :findBestPosition:bestX 1
   946 set :findBestPosition:bestY 1
   947 set :findBestPosition:best :updateRowPositionsOdd.2:col3
   948 label *label79
-    * label *label80
   949 label *label77
-    * label *label78
-    * label *label76
-    * label *label65
   950 jump *label32 always
   951 label *label31
   952 jump *label81 notEqual :findBestPosition:size 2
 
   989 set :findBestPosition:bestY -1.5
   990 set :findBestPosition:best :updateRowPositionsEven:col1
   991 label *label89
-    * label *label90
   992 label *label87
-    * label *label88
-    * label *label86
   993 jump *label92 lessThanEq :updateRowPositionsEven:col2 :findBestPosition:best
   994 jump *label94 greaterThanEq :updateRowPositionsEven:col2 0.0784313725490196
   995 set :findBestPosition:bestX -0.5
   996 set :findBestPosition:bestY -1.5
   997 set :findBestPosition:best :updateRowPositionsEven:col2
   998 label *label94
-    * label *label95
   999 label *label92
-    * label *label93
-    * label *label91
  1000 jump *label97 lessThanEq :updateRowPositionsEven:col3 :findBestPosition:best
  1001 jump *label99 greaterThanEq :updateRowPositionsEven:col3 0.0784313725490196
  1002 set :findBestPosition:bestX 0.5
  1003 set :findBestPosition:bestY -1.5
  1004 set :findBestPosition:best :updateRowPositionsEven:col3
  1005 label *label99
-    * label *label100
  1006 label *label97
-    * label *label98
-    * label *label96
  1007 jump *label102 lessThanEq :updateRowPositionsEven:col4 :findBestPosition:best
  1008 jump *label104 greaterThanEq :updateRowPositionsEven:col4 0.0784313725490196
  1009 set :findBestPosition:bestX 1.5
  1010 set :findBestPosition:bestY -1.5
  1011 set :findBestPosition:best :updateRowPositionsEven:col4
  1012 label *label104
-    * label *label105
  1013 label *label102
-    * label *label103
-    * label *label101
-    * label *label85
  1014 unpackcolor :updateRowPositionsEven.1:col1 :updateRowPositionsEven.1:col2 :updateRowPositionsEven.1:col3 :updateRowPositionsEven.1:col4 :findBestPosition:row2
  1015 jump *label108 lessThanEq :updateRowPositionsEven.1:col1 :findBestPosition:best
  1016 jump *label110 greaterThanEq :updateRowPositionsEven.1:col1 0.0784313725490196
 
  1018 set :findBestPosition:bestY -0.5
  1019 set :findBestPosition:best :updateRowPositionsEven.1:col1
  1020 label *label110
-    * label *label111
  1021 label *label108
-    * label *label109
-    * label *label107
  1022 jump *label113 lessThanEq :updateRowPositionsEven.1:col2 :findBestPosition:best
  1023 jump *label115 greaterThanEq :updateRowPositionsEven.1:col2 0.0784313725490196
  1024 set :findBestPosition:bestX -0.5
  1025 set :findBestPosition:bestY -0.5
  1026 set :findBestPosition:best :updateRowPositionsEven.1:col2
  1027 label *label115
-    * label *label116
  1028 label *label113
-    * label *label114
-    * label *label112
  1029 jump *label118 lessThanEq :updateRowPositionsEven.1:col3 :findBestPosition:best
  1030 jump *label120 greaterThanEq :updateRowPositionsEven.1:col3 0.0784313725490196
  1031 set :findBestPosition:bestX 0.5
  1032 set :findBestPosition:bestY -0.5
  1033 set :findBestPosition:best :updateRowPositionsEven.1:col3
  1034 label *label120
-    * label *label121
  1035 label *label118
-    * label *label119
-    * label *label117
  1036 jump *label123 lessThanEq :updateRowPositionsEven.1:col4 :findBestPosition:best
  1037 jump *label125 greaterThanEq :updateRowPositionsEven.1:col4 0.0784313725490196
  1038 set :findBestPosition:bestX 1.5
  1039 set :findBestPosition:bestY -0.5
  1040 set :findBestPosition:best :updateRowPositionsEven.1:col4
  1041 label *label125
-    * label *label126
  1042 label *label123
-    * label *label124
-    * label *label122
-    * label *label106
  1043 unpackcolor :updateRowPositionsEven.2:col1 :updateRowPositionsEven.2:col2 :updateRowPositionsEven.2:col3 :updateRowPositionsEven.2:col4 :findBestPosition:row3
  1044 jump *label129 lessThanEq :updateRowPositionsEven.2:col1 :findBestPosition:best
  1045 jump *label131 greaterThanEq :updateRowPositionsEven.2:col1 0.0784313725490196
 
  1047 set :findBestPosition:bestY 0.5
  1048 set :findBestPosition:best :updateRowPositionsEven.2:col1
  1049 label *label131
-    * label *label132
  1050 label *label129
-    * label *label130
-    * label *label128
  1051 jump *label134 lessThanEq :updateRowPositionsEven.2:col2 :findBestPosition:best
  1052 jump *label136 greaterThanEq :updateRowPositionsEven.2:col2 0.0784313725490196
  1053 set :findBestPosition:bestX -0.5
  1054 set :findBestPosition:bestY 0.5
  1055 set :findBestPosition:best :updateRowPositionsEven.2:col2
  1056 label *label136
-    * label *label137
  1057 label *label134
-    * label *label135
-    * label *label133
  1058 jump *label139 lessThanEq :updateRowPositionsEven.2:col3 :findBestPosition:best
  1059 jump *label141 greaterThanEq :updateRowPositionsEven.2:col3 0.0784313725490196
  1060 set :findBestPosition:bestX 0.5
  1061 set :findBestPosition:bestY 0.5
  1062 set :findBestPosition:best :updateRowPositionsEven.2:col3
  1063 label *label141
-    * label *label142
  1064 label *label139
-    * label *label140
-    * label *label138
  1065 jump *label144 lessThanEq :updateRowPositionsEven.2:col4 :findBestPosition:best
  1066 jump *label146 greaterThanEq :updateRowPositionsEven.2:col4 0.0784313725490196
  1067 set :findBestPosition:bestX 1.5
  1068 set :findBestPosition:bestY 0.5
  1069 set :findBestPosition:best :updateRowPositionsEven.2:col4
  1070 label *label146
-    * label *label147
  1071 label *label144
-    * label *label145
-    * label *label143
-    * label *label127
  1072 unpackcolor :updateRowPositionsEven.3:col1 :updateRowPositionsEven.3:col2 :updateRowPositionsEven.3:col3 :updateRowPositionsEven.3:col4 :findBestPosition:row4
  1073 jump *label150 lessThanEq :updateRowPositionsEven.3:col1 :findBestPosition:best
  1074 jump *label152 greaterThanEq :updateRowPositionsEven.3:col1 0.0784313725490196
 
  1076 set :findBestPosition:bestY 1.5
  1077 set :findBestPosition:best :updateRowPositionsEven.3:col1
  1078 label *label152
-    * label *label153
  1079 label *label150
-    * label *label151
-    * label *label149
  1080 jump *label155 lessThanEq :updateRowPositionsEven.3:col2 :findBestPosition:best
  1081 jump *label157 greaterThanEq :updateRowPositionsEven.3:col2 0.0784313725490196
  1082 set :findBestPosition:bestX -0.5
  1083 set :findBestPosition:bestY 1.5
  1084 set :findBestPosition:best :updateRowPositionsEven.3:col2
  1085 label *label157
-    * label *label158
  1086 label *label155
-    * label *label156
-    * label *label154
  1087 jump *label160 lessThanEq :updateRowPositionsEven.3:col3 :findBestPosition:best
  1088 jump *label162 greaterThanEq :updateRowPositionsEven.3:col3 0.0784313725490196
  1089 set :findBestPosition:bestX 0.5
  1090 set :findBestPosition:bestY 1.5
  1091 set :findBestPosition:best :updateRowPositionsEven.3:col3
  1092 label *label162
-    * label *label163
  1093 label *label160
-    * label *label161
-    * label *label159
  1094 jump *label165 lessThanEq :updateRowPositionsEven.3:col4 :findBestPosition:best
  1095 jump *label167 greaterThanEq :updateRowPositionsEven.3:col4 0.0784313725490196
  1096 set :findBestPosition:bestX 1.5
  1097 set :findBestPosition:bestY 1.5
  1098 set :findBestPosition:best :updateRowPositionsEven.3:col4
  1099 label *label167
-    * label *label168
  1100 label *label165
-    * label *label166
-    * label *label164
-    * label *label148
  1101 label *label32
  1102 op mul :findBestPosition*retval :findBestPosition:best 255
-    * label *label25
  1103 set :findBestPosition*finished true
  1104 jump *label4 always
  1105 end

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
   400 op add *tmp19 :tileValue.2:result :tileValue.3:result
   401 op add *tmp20 :tileValue.3:result :tileValue.4:result
   402 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
-    * jump *label13 always
-    * jump *label20 always
+  403 return :computeRowValues*retaddr
+  404 return :computeRowValues*retaddr
   405 label *label19
   406 jump *label21 notEqual :computeRowValues:size 3
   407 op add *tmp24 :tileValue.1:result :tileValue.2:result
 
   410 op add *tmp28 :tileValue.2:result :tileValue.3:result
   411 op add *tmp29 *tmp28 :tileValue.4:result
   412 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
-    * jump *label13 always
-    * jump *label22 always
+  413 return :computeRowValues*retaddr
+  414 return :computeRowValues*retaddr
   415 label *label21
   416 op sub :tileValue.5:x :computeRowValues:x 3
   417 set :tileValue.5:y :computeRowValues:y
 
   940 set :findBestPosition:best :updateRowPositionsOdd.2:col2
   941 label *label74
   942 label *label72
-    * jump *label77 lessThanEq :updateRowPositionsOdd.2:col3 :findBestPosition:best
-    * jump *label79 greaterThanEq :updateRowPositionsOdd.2:col3 0.0784313725490196
+  943 jump *label32 lessThanEq :updateRowPositionsOdd.2:col3 :findBestPosition:best
+  944 jump *label32 greaterThanEq :updateRowPositionsOdd.2:col3 0.0784313725490196
   945 set :findBestPosition:bestX 1
   946 set :findBestPosition:bestY 1
   947 set :findBestPosition:best :updateRowPositionsOdd.2:col3

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-16 instructions):
 
     5 label *label4
     6 wait 1e12
     7 jump *label4 always
-    * end
     8 label *label0
     9 ubind :createTerrainMask:unit
    10 op add *tmp2 :createTerrainMask:y 3
 
   356 op or :createTerrainMask*retval *tmp0 :isSolid:result
   357 set :createTerrainMask*finished true
   358 jump *label4 always
-    * end
   359 label *label2
   360 op sub :tileValue:x :computeRowValues:x 2
   361 set :tileValue:y :computeRowValues:y
 
   399 op add *tmp20 :tileValue.3:result :tileValue.4:result
   400 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
   401 return :computeRowValues*retaddr
-    * return :computeRowValues*retaddr
   402 label *label19
   403 jump *label21 notEqual :computeRowValues:size 3
   404 op add *tmp24 :tileValue.1:result :tileValue.2:result
 
   408 op add *tmp29 *tmp28 :tileValue.4:result
   409 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
   410 return :computeRowValues*retaddr
-    * return :computeRowValues*retaddr
   411 label *label21
   412 op sub :tileValue.5:x :computeRowValues:x 3
   413 set :tileValue.5:y :computeRowValues:y
 
   436 op add *tmp49 *tmp44 :tileValue.6:result
   437 op min *tmp50 0.09803921568627451 *tmp49
   438 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
-    * label *label22
-    * label *label20
-    * label *label13
   439 return :computeRowValues*retaddr
-    * end
   440 label *label1
   441 ubind :findBestPosition:unit
   442 op sub *tmp52 :findBestPosition:y 2
 
   482 op add *tmp20 :tileValue.3:result :tileValue.4:result
   483 packcolor :findBestPosition:y1 *tmp17 *tmp18 *tmp19 *tmp20
   484 jump *label381 always
-    * jump *label380 always
   485 label *label375
   486 jump *label376 notEqual :findBestPosition:size 3
   487 op add *tmp24 :tileValue.1:result :tileValue.2:result
 
   491 op add *tmp29 *tmp28 :tileValue.4:result
   492 packcolor :findBestPosition:y1 *tmp25 *tmp27 *tmp29 0
   493 jump *label381 always
-    * jump *label379 always
   494 label *label376
   495 op sub :tileValue.5:x :findBestPosition:x 3
   496 set :tileValue.5:y *tmp52
 
   565 op add *tmp20 :tileValue.3:result :tileValue.4:result
   566 packcolor :findBestPosition:y2 *tmp17 *tmp18 *tmp19 *tmp20
   567 jump *label394 always
-    * jump *label393 always
   568 label *label388
   569 jump *label389 notEqual :findBestPosition:size 3
   570 op add *tmp24 :tileValue.1:result :tileValue.2:result
 
   574 op add *tmp29 *tmp28 :tileValue.4:result
   575 packcolor :findBestPosition:y2 *tmp25 *tmp27 *tmp29 0
   576 jump *label394 always
-    * jump *label392 always
   577 label *label389
   578 op sub :tileValue.5:x :findBestPosition:x 3
   579 set :tileValue.5:y *tmp54
 
   647 op add *tmp20 :tileValue.3:result :tileValue.4:result
   648 packcolor :findBestPosition:y3 *tmp17 *tmp18 *tmp19 *tmp20
   649 jump *label407 always
-    * jump *label406 always
   650 label *label401
   651 jump *label402 notEqual :findBestPosition:size 3
   652 op add *tmp24 :tileValue.1:result :tileValue.2:result
 
   656 op add *tmp29 *tmp28 :tileValue.4:result
   657 packcolor :findBestPosition:y3 *tmp25 *tmp27 *tmp29 0
   658 jump *label407 always
-    * jump *label405 always
   659 label *label402
   660 op sub :tileValue.5:x :findBestPosition:x 3
   661 set :tileValue.5:y :findBestPosition:y
 
   730 op add *tmp20 :tileValue.3:result :tileValue.4:result
   731 packcolor :findBestPosition:y4 *tmp17 *tmp18 *tmp19 *tmp20
   732 jump *label420 always
-    * jump *label419 always
   733 label *label414
   734 jump *label415 notEqual :findBestPosition:size 3
   735 op add *tmp24 :tileValue.1:result :tileValue.2:result
 
   739 op add *tmp29 *tmp28 :tileValue.4:result
   740 packcolor :findBestPosition:y4 *tmp25 *tmp27 *tmp29 0
   741 jump *label420 always
-    * jump *label418 always
   742 label *label415
   743 op sub :tileValue.5:x :findBestPosition:x 3
   744 set :tileValue.5:y *tmp58
 
   813 op add *tmp20 :tileValue.3:result :tileValue.4:result
   814 packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp20
   815 jump *label433 always
-    * jump *label432 always
   816 label *label427
   817 jump *label428 notEqual :findBestPosition:size 3
   818 op add *tmp24 :tileValue.1:result :tileValue.2:result
 
   822 op add *tmp29 *tmp28 :tileValue.4:result
   823 packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0
   824 jump *label433 always
-    * jump *label431 always
   825 label *label428
   826 op sub :tileValue.5:x :findBestPosition:x 3
   827 set :tileValue.5:y *tmp60
 
   927 set :findBestPosition:bestX 1
   928 set :findBestPosition:bestY 1
   929 set :findBestPosition:best :updateRowPositionsOdd.2:col3
-    * label *label79
-    * label *label77
   930 jump *label32 always
   931 label *label31
   932 jump *label81 notEqual :findBestPosition:size 2
 
  1082 op mul :findBestPosition*retval :findBestPosition:best 255
  1083 set :findBestPosition*finished true
  1084 jump *label4 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
 
   519 op add *tmp49 *tmp44 :tileValue.6:result
   520 op min *tmp50 0.09803921568627451 *tmp49
   521 packcolor :findBestPosition:y1 *tmp38 *tmp42 *tmp46 *tmp50
-    * label *label379
-    * label *label380
   522 label *label381
   523 op sub *tmp54 :findBestPosition:y 1
   524 op sub :tileValue:x :findBestPosition:x 2
 
   600 op add *tmp49 *tmp44 :tileValue.6:result
   601 op min *tmp50 0.09803921568627451 *tmp49
   602 packcolor :findBestPosition:y2 *tmp38 *tmp42 *tmp46 *tmp50
-    * label *label392
-    * label *label393
   603 label *label394
   604 op sub :tileValue:x :findBestPosition:x 2
   605 set :tileValue:y :findBestPosition:y
 
   680 op add *tmp49 *tmp44 :tileValue.6:result
   681 op min *tmp50 0.09803921568627451 *tmp49
   682 packcolor :findBestPosition:y3 *tmp38 *tmp42 *tmp46 *tmp50
-    * label *label405
-    * label *label406
   683 label *label407
   684 op add *tmp58 :findBestPosition:y 1
   685 op sub :tileValue:x :findBestPosition:x 2
 
   761 op add *tmp49 *tmp44 :tileValue.6:result
   762 op min *tmp50 0.09803921568627451 *tmp49
   763 packcolor :findBestPosition:y4 *tmp38 *tmp42 *tmp46 *tmp50
-    * label *label418
-    * label *label419
   764 label *label420
   765 op add *tmp60 :findBestPosition:y 2
   766 op sub :tileValue:x :findBestPosition:x 2
 
   842 op add *tmp49 *tmp44 :tileValue.6:result
   843 op min *tmp50 0.09803921568627451 *tmp49
   844 packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp50
-    * label *label431
-    * label *label432
   845 label *label433
   846 set :findBestPosition:y5 :computeRowValues*retval
   847 set :findBestPosition:best 0

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
   853 op add :findBestPosition:row2 *tmp64 :findBestPosition:y4
   854 op add *tmp68 :findBestPosition:y3 :findBestPosition:y4
   855 op add :findBestPosition:row3 *tmp68 :computeRowValues*retval
-    * unpackcolor :updateRowPositionsOdd:col1 :updateRowPositionsOdd:col2 :updateRowPositionsOdd:col3 *tmp70 :findBestPosition:row1
+  856 unpackcolor :updateRowPositionsOdd:col1 :updateRowPositionsOdd:col2 :updateRowPositionsOdd:col3 0 :findBestPosition:row1
   857 jump *label35 lessThanEq :updateRowPositionsOdd:col1 0
   858 jump *label37 greaterThanEq :updateRowPositionsOdd:col1 0.0784313725490196
   859 set :findBestPosition:bestX -1
 
   875 set :findBestPosition:best :updateRowPositionsOdd:col3
   876 label *label47
   877 label *label45
-    * unpackcolor :updateRowPositionsOdd.1:col1 :updateRowPositionsOdd.1:col2 :updateRowPositionsOdd.1:col3 *tmp83 :findBestPosition:row2
+  878 unpackcolor :updateRowPositionsOdd.1:col1 :updateRowPositionsOdd.1:col2 :updateRowPositionsOdd.1:col3 0 :findBestPosition:row2
   879 jump *label51 lessThanEq :updateRowPositionsOdd.1:col1 :findBestPosition:best
   880 jump *label53 greaterThanEq :updateRowPositionsOdd.1:col1 0.0784313725490196
   881 set :findBestPosition:bestX -1
 
   897 set :findBestPosition:best :updateRowPositionsOdd.1:col3
   898 label *label63
   899 label *label61
-    * unpackcolor :updateRowPositionsOdd.2:col1 :updateRowPositionsOdd.2:col2 :updateRowPositionsOdd.2:col3 *tmp96 :findBestPosition:row3
+  900 unpackcolor :updateRowPositionsOdd.2:col1 :updateRowPositionsOdd.2:col2 :updateRowPositionsOdd.2:col3 0 :findBestPosition:row3
   901 jump *label67 lessThanEq :updateRowPositionsOdd.2:col1 :findBestPosition:best
   902 jump *label69 greaterThanEq :updateRowPositionsOdd.2:col1 0.0784313725490196
   903 set :findBestPosition:bestX -1

Final code before resolving virtual instructions:

    0:  jump *label3 always 0 0                                      #set target = 8;
    1:  jump *label0 always 0 0                                      ...
    2:  jump *label1 always 0 0                                      ...
        label *label3                                                ...
    3:  set *signature "385702d66f725e74:v1"                         ...
        label *label4                                                ...
    4:  wait 1e12                                                    ...
    5:  jump *label4 always 0 0                                      ...
        label *label0                                                remote def createTerrainMask(unit, x, y)
    6:  ubind :createTerrainMask:unit                                ubind(unit);
    7:  op add *tmp2 :createTerrainMask:y 3                          for var c in -3 .. 3 descending do
    8:  op add :isSolid:x :createTerrainMask:x 3                     result = (result << 1) | isSolid(x + c, y + r);
    9:  set :isSolid:y *tmp2                                         ...
   10:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   11:  sensor solid type @solid                                     ...
   12:  select :isSolid:result notEqual solid false 1 0              ...
   13:  op shl *tmp0 :isSolid:result 1                               result = (result << 1) | isSolid(x + c, y + r);
   14:  op add :isSolid:x :createTerrainMask:x 2                     ...
   15:  set :isSolid:y *tmp2                                         ...
   16:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   17:  sensor solid type @solid                                     ...
   18:  select :isSolid:result notEqual solid false 1 0              ...
   19:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   20:  op shl *tmp0 :createTerrainMask:result 1                     ...
   21:  op add :isSolid:x :createTerrainMask:x 1                     ...
   22:  set :isSolid:y *tmp2                                         ...
   23:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   24:  sensor solid type @solid                                     ...
   25:  select :isSolid:result notEqual solid false 1 0              ...
   26:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   27:  op shl *tmp0 :createTerrainMask:result 1                     ...
   28:  set :isSolid:x :createTerrainMask:x                          ...
   29:  set :isSolid:y *tmp2                                         ...
   30:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   31:  sensor solid type @solid                                     ...
   32:  select :isSolid:result notEqual solid false 1 0              ...
   33:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   34:  op shl *tmp0 :createTerrainMask:result 1                     ...
   35:  op add :isSolid:x :createTerrainMask:x -1                    ...
   36:  set :isSolid:y *tmp2                                         ...
   37:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   38:  sensor solid type @solid                                     ...
   39:  select :isSolid:result notEqual solid false 1 0              ...
   40:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   41:  op shl *tmp0 :createTerrainMask:result 1                     ...
   42:  op add :isSolid:x :createTerrainMask:x -2                    ...
   43:  set :isSolid:y *tmp2                                         ...
   44:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   45:  sensor solid type @solid                                     ...
   46:  select :isSolid:result notEqual solid false 1 0              ...
   47:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   48:  op shl *tmp0 :createTerrainMask:result 1                     ...
   49:  op add :isSolid:x :createTerrainMask:x -3                    ...
   50:  set :isSolid:y *tmp2                                         ...
   51:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   52:  sensor solid type @solid                                     ...
   53:  select :isSolid:result notEqual solid false 1 0              ...
   54:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   55:  op add *tmp2 :createTerrainMask:y 2                          for var c in -3 .. 3 descending do
   56:  op shl *tmp0 :createTerrainMask:result 1                     result = (result << 1) | isSolid(x + c, y + r);
   57:  op add :isSolid:x :createTerrainMask:x 3                     ...
   58:  set :isSolid:y *tmp2                                         ...
   59:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   60:  sensor solid type @solid                                     ...
   61:  select :isSolid:result notEqual solid false 1 0              ...
   62:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   63:  op shl *tmp0 :createTerrainMask:result 1                     ...
   64:  op add :isSolid:x :createTerrainMask:x 2                     ...
   65:  set :isSolid:y *tmp2                                         ...
   66:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   67:  sensor solid type @solid                                     ...
   68:  select :isSolid:result notEqual solid false 1 0              ...
   69:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   70:  op shl *tmp0 :createTerrainMask:result 1                     ...
   71:  op add :isSolid:x :createTerrainMask:x 1                     ...
   72:  set :isSolid:y *tmp2                                         ...
   73:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   74:  sensor solid type @solid                                     ...
   75:  select :isSolid:result notEqual solid false 1 0              ...
   76:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   77:  op shl *tmp0 :createTerrainMask:result 1                     ...
   78:  set :isSolid:x :createTerrainMask:x                          ...
   79:  set :isSolid:y *tmp2                                         ...
   80:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   81:  sensor solid type @solid                                     ...
   82:  select :isSolid:result notEqual solid false 1 0              ...
   83:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   84:  op shl *tmp0 :createTerrainMask:result 1                     ...
   85:  op add :isSolid:x :createTerrainMask:x -1                    ...
   86:  set :isSolid:y *tmp2                                         ...
   87:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   88:  sensor solid type @solid                                     ...
   89:  select :isSolid:result notEqual solid false 1 0              ...
   90:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   91:  op shl *tmp0 :createTerrainMask:result 1                     ...
   92:  op add :isSolid:x :createTerrainMask:x -2                    ...
   93:  set :isSolid:y *tmp2                                         ...
   94:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
   95:  sensor solid type @solid                                     ...
   96:  select :isSolid:result notEqual solid false 1 0              ...
   97:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
   98:  op shl *tmp0 :createTerrainMask:result 1                     ...
   99:  op add :isSolid:x :createTerrainMask:x -3                    ...
  100:  set :isSolid:y *tmp2                                         ...
  101:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  102:  sensor solid type @solid                                     ...
  103:  select :isSolid:result notEqual solid false 1 0              ...
  104:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  105:  op add *tmp2 :createTerrainMask:y 1                          for var c in -3 .. 3 descending do
  106:  op shl *tmp0 :createTerrainMask:result 1                     result = (result << 1) | isSolid(x + c, y + r);
  107:  op add :isSolid:x :createTerrainMask:x 3                     ...
  108:  set :isSolid:y *tmp2                                         ...
  109:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  110:  sensor solid type @solid                                     ...
  111:  select :isSolid:result notEqual solid false 1 0              ...
  112:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  113:  op shl *tmp0 :createTerrainMask:result 1                     ...
  114:  op add :isSolid:x :createTerrainMask:x 2                     ...
  115:  set :isSolid:y *tmp2                                         ...
  116:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  117:  sensor solid type @solid                                     ...
  118:  select :isSolid:result notEqual solid false 1 0              ...
  119:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  120:  op shl *tmp0 :createTerrainMask:result 1                     ...
  121:  op add :isSolid:x :createTerrainMask:x 1                     ...
  122:  set :isSolid:y *tmp2                                         ...
  123:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  124:  sensor solid type @solid                                     ...
  125:  select :isSolid:result notEqual solid false 1 0              ...
  126:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  127:  op shl *tmp0 :createTerrainMask:result 1                     ...
  128:  set :isSolid:x :createTerrainMask:x                          ...
  129:  set :isSolid:y *tmp2                                         ...
  130:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  131:  sensor solid type @solid                                     ...
  132:  select :isSolid:result notEqual solid false 1 0              ...
  133:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  134:  op shl *tmp0 :createTerrainMask:result 1                     ...
  135:  op add :isSolid:x :createTerrainMask:x -1                    ...
  136:  set :isSolid:y *tmp2                                         ...
  137:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  138:  sensor solid type @solid                                     ...
  139:  select :isSolid:result notEqual solid false 1 0              ...
  140:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  141:  op shl *tmp0 :createTerrainMask:result 1                     ...
  142:  op add :isSolid:x :createTerrainMask:x -2                    ...
  143:  set :isSolid:y *tmp2                                         ...
  144:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  145:  sensor solid type @solid                                     ...
  146:  select :isSolid:result notEqual solid false 1 0              ...
  147:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  148:  op shl *tmp0 :createTerrainMask:result 1                     ...
  149:  op add :isSolid:x :createTerrainMask:x -3                    ...
  150:  set :isSolid:y *tmp2                                         ...
  151:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  152:  sensor solid type @solid                                     ...
  153:  select :isSolid:result notEqual solid false 1 0              ...
  154:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  155:  op shl *tmp0 :createTerrainMask:result 1                     ...
  156:  op add :isSolid:x :createTerrainMask:x 3                     ...
  157:  set :isSolid:y :createTerrainMask:y                          ...
  158:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  159:  sensor solid type @solid                                     ...
  160:  select :isSolid:result notEqual solid false 1 0              ...
  161:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  162:  op shl *tmp0 :createTerrainMask:result 1                     ...
  163:  op add :isSolid:x :createTerrainMask:x 2                     ...
  164:  set :isSolid:y :createTerrainMask:y                          ...
  165:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  166:  sensor solid type @solid                                     ...
  167:  select :isSolid:result notEqual solid false 1 0              ...
  168:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  169:  op shl *tmp0 :createTerrainMask:result 1                     ...
  170:  op add :isSolid:x :createTerrainMask:x 1                     ...
  171:  set :isSolid:y :createTerrainMask:y                          ...
  172:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  173:  sensor solid type @solid                                     ...
  174:  select :isSolid:result notEqual solid false 1 0              ...
  175:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  176:  op shl *tmp0 :createTerrainMask:result 1                     ...
  177:  set :isSolid:x :createTerrainMask:x                          ...
  178:  set :isSolid:y :createTerrainMask:y                          ...
  179:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  180:  sensor solid type @solid                                     ...
  181:  select :isSolid:result notEqual solid false 1 0              ...
  182:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  183:  op shl *tmp0 :createTerrainMask:result 1                     ...
  184:  op add :isSolid:x :createTerrainMask:x -1                    ...
  185:  set :isSolid:y :createTerrainMask:y                          ...
  186:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  187:  sensor solid type @solid                                     ...
  188:  select :isSolid:result notEqual solid false 1 0              ...
  189:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  190:  op shl *tmp0 :createTerrainMask:result 1                     ...
  191:  op add :isSolid:x :createTerrainMask:x -2                    ...
  192:  set :isSolid:y :createTerrainMask:y                          ...
  193:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  194:  sensor solid type @solid                                     ...
  195:  select :isSolid:result notEqual solid false 1 0              ...
  196:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  197:  op shl *tmp0 :createTerrainMask:result 1                     ...
  198:  op add :isSolid:x :createTerrainMask:x -3                    ...
  199:  set :isSolid:y :createTerrainMask:y                          ...
  200:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  201:  sensor solid type @solid                                     ...
  202:  select :isSolid:result notEqual solid false 1 0              ...
  203:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  204:  op add *tmp2 :createTerrainMask:y -1                         for var c in -3 .. 3 descending do
  205:  op shl *tmp0 :createTerrainMask:result 1                     result = (result << 1) | isSolid(x + c, y + r);
  206:  op add :isSolid:x :createTerrainMask:x 3                     ...
  207:  set :isSolid:y *tmp2                                         ...
  208:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  209:  sensor solid type @solid                                     ...
  210:  select :isSolid:result notEqual solid false 1 0              ...
  211:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  212:  op shl *tmp0 :createTerrainMask:result 1                     ...
  213:  op add :isSolid:x :createTerrainMask:x 2                     ...
  214:  set :isSolid:y *tmp2                                         ...
  215:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  216:  sensor solid type @solid                                     ...
  217:  select :isSolid:result notEqual solid false 1 0              ...
  218:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  219:  op shl *tmp0 :createTerrainMask:result 1                     ...
  220:  op add :isSolid:x :createTerrainMask:x 1                     ...
  221:  set :isSolid:y *tmp2                                         ...
  222:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  223:  sensor solid type @solid                                     ...
  224:  select :isSolid:result notEqual solid false 1 0              ...
  225:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  226:  op shl *tmp0 :createTerrainMask:result 1                     ...
  227:  set :isSolid:x :createTerrainMask:x                          ...
  228:  set :isSolid:y *tmp2                                         ...
  229:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  230:  sensor solid type @solid                                     ...
  231:  select :isSolid:result notEqual solid false 1 0              ...
  232:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  233:  op shl *tmp0 :createTerrainMask:result 1                     ...
  234:  op add :isSolid:x :createTerrainMask:x -1                    ...
  235:  set :isSolid:y *tmp2                                         ...
  236:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  237:  sensor solid type @solid                                     ...
  238:  select :isSolid:result notEqual solid false 1 0              ...
  239:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  240:  op shl *tmp0 :createTerrainMask:result 1                     ...
  241:  op add :isSolid:x :createTerrainMask:x -2                    ...
  242:  set :isSolid:y *tmp2                                         ...
  243:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  244:  sensor solid type @solid                                     ...
  245:  select :isSolid:result notEqual solid false 1 0              ...
  246:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  247:  op shl *tmp0 :createTerrainMask:result 1                     ...
  248:  op add :isSolid:x :createTerrainMask:x -3                    ...
  249:  set :isSolid:y *tmp2                                         ...
  250:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  251:  sensor solid type @solid                                     ...
  252:  select :isSolid:result notEqual solid false 1 0              ...
  253:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  254:  op add *tmp2 :createTerrainMask:y -2                         for var c in -3 .. 3 descending do
  255:  op shl *tmp0 :createTerrainMask:result 1                     result = (result << 1) | isSolid(x + c, y + r);
  256:  op add :isSolid:x :createTerrainMask:x 3                     ...
  257:  set :isSolid:y *tmp2                                         ...
  258:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  259:  sensor solid type @solid                                     ...
  260:  select :isSolid:result notEqual solid false 1 0              ...
  261:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  262:  op shl *tmp0 :createTerrainMask:result 1                     ...
  263:  op add :isSolid:x :createTerrainMask:x 2                     ...
  264:  set :isSolid:y *tmp2                                         ...
  265:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  266:  sensor solid type @solid                                     ...
  267:  select :isSolid:result notEqual solid false 1 0              ...
  268:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  269:  op shl *tmp0 :createTerrainMask:result 1                     ...
  270:  op add :isSolid:x :createTerrainMask:x 1                     ...
  271:  set :isSolid:y *tmp2                                         ...
  272:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  273:  sensor solid type @solid                                     ...
  274:  select :isSolid:result notEqual solid false 1 0              ...
  275:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  276:  op shl *tmp0 :createTerrainMask:result 1                     ...
  277:  set :isSolid:x :createTerrainMask:x                          ...
  278:  set :isSolid:y *tmp2                                         ...
  279:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  280:  sensor solid type @solid                                     ...
  281:  select :isSolid:result notEqual solid false 1 0              ...
  282:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  283:  op shl *tmp0 :createTerrainMask:result 1                     ...
  284:  op add :isSolid:x :createTerrainMask:x -1                    ...
  285:  set :isSolid:y *tmp2                                         ...
  286:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  287:  sensor solid type @solid                                     ...
  288:  select :isSolid:result notEqual solid false 1 0              ...
  289:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  290:  op shl *tmp0 :createTerrainMask:result 1                     ...
  291:  op add :isSolid:x :createTerrainMask:x -2                    ...
  292:  set :isSolid:y *tmp2                                         ...
  293:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  294:  sensor solid type @solid                                     ...
  295:  select :isSolid:result notEqual solid false 1 0              ...
  296:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  297:  op shl *tmp0 :createTerrainMask:result 1                     ...
  298:  op add :isSolid:x :createTerrainMask:x -3                    ...
  299:  set :isSolid:y *tmp2                                         ...
  300:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  301:  sensor solid type @solid                                     ...
  302:  select :isSolid:result notEqual solid false 1 0              ...
  303:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  304:  op add *tmp2 :createTerrainMask:y -3                         for var c in -3 .. 3 descending do
  305:  op shl *tmp0 :createTerrainMask:result 1                     result = (result << 1) | isSolid(x + c, y + r);
  306:  op add :isSolid:x :createTerrainMask:x 3                     ...
  307:  set :isSolid:y *tmp2                                         ...
  308:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  309:  sensor solid type @solid                                     ...
  310:  select :isSolid:result notEqual solid false 1 0              ...
  311:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  312:  op shl *tmp0 :createTerrainMask:result 1                     ...
  313:  op add :isSolid:x :createTerrainMask:x 2                     ...
  314:  set :isSolid:y *tmp2                                         ...
  315:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  316:  sensor solid type @solid                                     ...
  317:  select :isSolid:result notEqual solid false 1 0              ...
  318:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  319:  op shl *tmp0 :createTerrainMask:result 1                     ...
  320:  op add :isSolid:x :createTerrainMask:x 1                     ...
  321:  set :isSolid:y *tmp2                                         ...
  322:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  323:  sensor solid type @solid                                     ...
  324:  select :isSolid:result notEqual solid false 1 0              ...
  325:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  326:  op shl *tmp0 :createTerrainMask:result 1                     ...
  327:  set :isSolid:x :createTerrainMask:x                          ...
  328:  set :isSolid:y *tmp2                                         ...
  329:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  330:  sensor solid type @solid                                     ...
  331:  select :isSolid:result notEqual solid false 1 0              ...
  332:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  333:  op shl *tmp0 :createTerrainMask:result 1                     ...
  334:  op add :isSolid:x :createTerrainMask:x -1                    ...
  335:  set :isSolid:y *tmp2                                         ...
  336:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  337:  sensor solid type @solid                                     ...
  338:  select :isSolid:result notEqual solid false 1 0              ...
  339:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  340:  op shl *tmp0 :createTerrainMask:result 1                     ...
  341:  op add :isSolid:x :createTerrainMask:x -2                    ...
  342:  set :isSolid:y *tmp2                                         ...
  343:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  344:  sensor solid type @solid                                     ...
  345:  select :isSolid:result notEqual solid false 1 0              ...
  346:  op or :createTerrainMask:result *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  347:  op shl *tmp0 :createTerrainMask:result 1                     ...
  348:  op add :isSolid:x :createTerrainMask:x -3                    ...
  349:  set :isSolid:y *tmp2                                         ...
  350:  ucontrol getBlock :isSolid:x :isSolid:y type building floor  mlog(in x, in y, out result) {
  351:  sensor solid type @solid                                     ...
  352:  select :isSolid:result notEqual solid false 1 0              ...
  353:  op or :createTerrainMask*retval *tmp0 :isSolid:result        result = (result << 1) | isSolid(x + c, y + r);
  354:  set :createTerrainMask*finished true                         remote def createTerrainMask(unit, x, y)
  355:  jump *label4 always 0 0                                      ...
        label *label2                                                def computeRowValues(x, y, ore, size)
  356:  op sub :tileValue:x :computeRowValues:x 2                    var x1 = tileValue(x - 2, y, ore);
  357:  set :tileValue:y :computeRowValues:y                         ...
  358:  set :tileValue:ore :computeRowValues:ore                     ...
  359:  ucontrol getBlock :tileValue:x :tileValue:y type building fl mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  360:  select value equal floor :tileValue:ore 0.00392156862745098  ...
  361:  sensor solid type @solid                                     ...
  362:  select :tileValue:result notEqual solid false 0.098039215686 ...
  363:  op sub :tileValue.1:x :computeRowValues:x 1                  var x2 = tileValue(x - 1, y, ore);
  364:  set :tileValue.1:y :computeRowValues:y                       ...
  365:  set :tileValue.1:ore :computeRowValues:ore                   ...
  366:  ucontrol getBlock :tileValue.1:x :tileValue.1:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  367:  select value equal floor :tileValue.1:ore 0.0039215686274509 ...
  368:  sensor solid type @solid                                     ...
  369:  select :tileValue.1:result notEqual solid false 0.0980392156 ...
  370:  set :tileValue.2:x :computeRowValues:x                       var x3 = tileValue(x + 0, y, ore);
  371:  set :tileValue.2:y :computeRowValues:y                       ...
  372:  set :tileValue.2:ore :computeRowValues:ore                   ...
  373:  ucontrol getBlock :tileValue.2:x :tileValue.2:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  374:  select value equal floor :tileValue.2:ore 0.0039215686274509 ...
  375:  sensor solid type @solid                                     ...
  376:  select :tileValue.2:result notEqual solid false 0.0980392156 ...
  377:  op add :tileValue.3:x :computeRowValues:x 1                  var x4 = tileValue(x + 1, y, ore);
  378:  set :tileValue.3:y :computeRowValues:y                       ...
  379:  set :tileValue.3:ore :computeRowValues:ore                   ...
  380:  ucontrol getBlock :tileValue.3:x :tileValue.3:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  381:  select value equal floor :tileValue.3:ore 0.0039215686274509 ...
  382:  sensor solid type @solid                                     ...
  383:  select :tileValue.3:result notEqual solid false 0.0980392156 ...
  384:  op add :tileValue.4:x :computeRowValues:x 2                  var x5 = tileValue(x + 2, y, ore);
  385:  set :tileValue.4:y :computeRowValues:y                       ...
  386:  set :tileValue.4:ore :computeRowValues:ore                   ...
  387:  ucontrol getBlock :tileValue.4:x :tileValue.4:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  388:  select value equal floor :tileValue.4:ore 0.0039215686274509 ...
  389:  sensor solid type @solid                                     ...
  390:  select :tileValue.4:result notEqual solid false 0.0980392156 ...
  391:  jump *label19 notEqual :computeRowValues:size 2              if size == 2 then
  392:  op add *tmp17 :tileValue:result :tileValue.1:result          x1 + x2,        // drill at x - 1.5
  393:  op add *tmp18 :tileValue.1:result :tileValue.2:result        x2 + x3,        // drill at x - 0.5
  394:  op add *tmp19 :tileValue.2:result :tileValue.3:result        x3 + x4,        // drill at x + 0.5
  395:  op add *tmp20 :tileValue.3:result :tileValue.4:result        x4 + x5         // drill at x + 1.5
  396:  packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp return packcolor(
  397:  return :computeRowValues*retaddr                             ...
        label *label19                                               if size == 2 then
  398:  jump *label21 notEqual :computeRowValues:size 3              elsif size == 3 then
  399:  op add *tmp24 :tileValue.1:result :tileValue.2:result        x1 + (x2 + x3),   // drill at x - 1
  400:  op add *tmp25 :tileValue:result *tmp24                       ...
  401:  op add *tmp27 *tmp24 :tileValue.3:result                     (x2 + x3) + x4,   // drill at x
  402:  op add *tmp28 :tileValue.2:result :tileValue.3:result        x3 + x4 + x5,   // drill at x + 1
  403:  op add *tmp29 *tmp28 :tileValue.4:result                     ...
  404:  packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0    return packcolor(
  405:  return :computeRowValues*retaddr                             ...
        label *label21                                               elsif size == 3 then
  406:  op sub :tileValue.5:x :computeRowValues:x 3                  var x0 = tileValue(x - 3, y, ore);
  407:  set :tileValue.5:y :computeRowValues:y                       ...
  408:  set :tileValue.5:ore :computeRowValues:ore                   ...
  409:  ucontrol getBlock :tileValue.5:x :tileValue.5:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  410:  select value equal floor :tileValue.5:ore 0.0039215686274509 ...
  411:  sensor solid type @solid                                     ...
  412:  select :tileValue.5:result notEqual solid false 0.0980392156 ...
  413:  op add :tileValue.6:x :computeRowValues:x 3                  var x6 = tileValue(x + 3, y, ore);
  414:  set :tileValue.6:y :computeRowValues:y                       ...
  415:  set :tileValue.6:ore :computeRowValues:ore                   ...
  416:  ucontrol getBlock :tileValue.6:x :tileValue.6:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  417:  select value equal floor :tileValue.6:ore 0.0039215686274509 ...
  418:  sensor solid type @solid                                     ...
  419:  select :tileValue.6:result notEqual solid false 0.0980392156 ...
  420:  op add *tmp35 :tileValue:result :tileValue.1:result          min(WALL, x0 + (x1 + x2 + x3)),   // drill at x - 1.5
  421:  op add *tmp36 *tmp35 :tileValue.2:result                     ...
  422:  op add *tmp37 :tileValue.5:result *tmp36                     ...
  423:  op min *tmp38 0.09803921568627451 *tmp37                     ...
  424:  op add *tmp41 *tmp36 :tileValue.3:result                     min(WALL, (x1 + x2 + x3) + x4),   // drill at x - 0.5
  425:  op min *tmp42 0.09803921568627451 *tmp41                     ...
  426:  op add *tmp43 :tileValue.2:result :tileValue.3:result        min(WALL, x2 + (x3 + x4 + x5)),   // drill at x + 0.5
  427:  op add *tmp44 *tmp43 :tileValue.4:result                     ...
  428:  op add *tmp45 :tileValue.1:result *tmp44                     ...
  429:  op min *tmp46 0.09803921568627451 *tmp45                     ...
  430:  op add *tmp49 *tmp44 :tileValue.6:result                     min(WALL, (x3 + x4 + x5) + x6)    // drill at x + 1.5
  431:  op min *tmp50 0.09803921568627451 *tmp49                     ...
  432:  packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp return packcolor(
  433:  return :computeRowValues*retaddr                             def computeRowValues(x, y, ore, size)
        label *label1                                                remote def findBestPosition(unit, x, y, ore, size, out bestX, out bestY)
  434:  ubind :findBestPosition:unit                                 ubind(unit);
  435:  op sub *tmp52 :findBestPosition:y 2                          var y1 = computeRowValues(x, y - 2, ore, size);
  436:  op sub :tileValue:x :findBestPosition:x 2                    var x1 = tileValue(x - 2, y, ore);
  437:  set :tileValue:y *tmp52                                      ...
  438:  set :tileValue:ore :findBestPosition:ore                     ...
  439:  ucontrol getBlock :tileValue:x :tileValue:y type building fl mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  440:  select value equal floor :tileValue:ore 0.00392156862745098  ...
  441:  sensor solid type @solid                                     ...
  442:  select :tileValue:result notEqual solid false 0.098039215686 ...
  443:  op sub :tileValue.1:x :findBestPosition:x 1                  var x2 = tileValue(x - 1, y, ore);
  444:  set :tileValue.1:y *tmp52                                    ...
  445:  set :tileValue.1:ore :findBestPosition:ore                   ...
  446:  ucontrol getBlock :tileValue.1:x :tileValue.1:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  447:  select value equal floor :tileValue.1:ore 0.0039215686274509 ...
  448:  sensor solid type @solid                                     ...
  449:  select :tileValue.1:result notEqual solid false 0.0980392156 ...
  450:  set :tileValue.2:x :findBestPosition:x                       var x3 = tileValue(x + 0, y, ore);
  451:  set :tileValue.2:y *tmp52                                    ...
  452:  set :tileValue.2:ore :findBestPosition:ore                   ...
  453:  ucontrol getBlock :tileValue.2:x :tileValue.2:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  454:  select value equal floor :tileValue.2:ore 0.0039215686274509 ...
  455:  sensor solid type @solid                                     ...
  456:  select :tileValue.2:result notEqual solid false 0.0980392156 ...
  457:  op add :tileValue.3:x :findBestPosition:x 1                  var x4 = tileValue(x + 1, y, ore);
  458:  set :tileValue.3:y *tmp52                                    ...
  459:  set :tileValue.3:ore :findBestPosition:ore                   ...
  460:  ucontrol getBlock :tileValue.3:x :tileValue.3:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  461:  select value equal floor :tileValue.3:ore 0.0039215686274509 ...
  462:  sensor solid type @solid                                     ...
  463:  select :tileValue.3:result notEqual solid false 0.0980392156 ...
  464:  op add :tileValue.4:x :findBestPosition:x 2                  var x5 = tileValue(x + 2, y, ore);
  465:  set :tileValue.4:y *tmp52                                    ...
  466:  set :tileValue.4:ore :findBestPosition:ore                   ...
  467:  ucontrol getBlock :tileValue.4:x :tileValue.4:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  468:  select value equal floor :tileValue.4:ore 0.0039215686274509 ...
  469:  sensor solid type @solid                                     ...
  470:  select :tileValue.4:result notEqual solid false 0.0980392156 ...
  471:  jump *label375 notEqual :findBestPosition:size 2             if size == 2 then
  472:  op add *tmp17 :tileValue:result :tileValue.1:result          x1 + x2,        // drill at x - 1.5
  473:  op add *tmp18 :tileValue.1:result :tileValue.2:result        x2 + x3,        // drill at x - 0.5
  474:  op add *tmp19 :tileValue.2:result :tileValue.3:result        x3 + x4,        // drill at x + 0.5
  475:  op add *tmp20 :tileValue.3:result :tileValue.4:result        x4 + x5         // drill at x + 1.5
  476:  packcolor :findBestPosition:y1 *tmp17 *tmp18 *tmp19 *tmp20   return packcolor(
  477:  jump *label381 always 0 0                                    ...
        label *label375                                              if size == 2 then
  478:  jump *label376 notEqual :findBestPosition:size 3             elsif size == 3 then
  479:  op add *tmp24 :tileValue.1:result :tileValue.2:result        x1 + (x2 + x3),   // drill at x - 1
  480:  op add *tmp25 :tileValue:result *tmp24                       ...
  481:  op add *tmp27 *tmp24 :tileValue.3:result                     (x2 + x3) + x4,   // drill at x
  482:  op add *tmp28 :tileValue.2:result :tileValue.3:result        x3 + x4 + x5,   // drill at x + 1
  483:  op add *tmp29 *tmp28 :tileValue.4:result                     ...
  484:  packcolor :findBestPosition:y1 *tmp25 *tmp27 *tmp29 0        return packcolor(
  485:  jump *label381 always 0 0                                    ...
        label *label376                                              elsif size == 3 then
  486:  op sub :tileValue.5:x :findBestPosition:x 3                  var x0 = tileValue(x - 3, y, ore);
  487:  set :tileValue.5:y *tmp52                                    ...
  488:  set :tileValue.5:ore :findBestPosition:ore                   ...
  489:  ucontrol getBlock :tileValue.5:x :tileValue.5:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  490:  select value equal floor :tileValue.5:ore 0.0039215686274509 ...
  491:  sensor solid type @solid                                     ...
  492:  select :tileValue.5:result notEqual solid false 0.0980392156 ...
  493:  op add :tileValue.6:x :findBestPosition:x 3                  var x6 = tileValue(x + 3, y, ore);
  494:  set :tileValue.6:y *tmp52                                    ...
  495:  set :tileValue.6:ore :findBestPosition:ore                   ...
  496:  ucontrol getBlock :tileValue.6:x :tileValue.6:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  497:  select value equal floor :tileValue.6:ore 0.0039215686274509 ...
  498:  sensor solid type @solid                                     ...
  499:  select :tileValue.6:result notEqual solid false 0.0980392156 ...
  500:  op add *tmp35 :tileValue:result :tileValue.1:result          min(WALL, x0 + (x1 + x2 + x3)),   // drill at x - 1.5
  501:  op add *tmp36 *tmp35 :tileValue.2:result                     ...
  502:  op add *tmp37 :tileValue.5:result *tmp36                     ...
  503:  op min *tmp38 0.09803921568627451 *tmp37                     ...
  504:  op add *tmp41 *tmp36 :tileValue.3:result                     min(WALL, (x1 + x2 + x3) + x4),   // drill at x - 0.5
  505:  op min *tmp42 0.09803921568627451 *tmp41                     ...
  506:  op add *tmp43 :tileValue.2:result :tileValue.3:result        min(WALL, x2 + (x3 + x4 + x5)),   // drill at x + 0.5
  507:  op add *tmp44 *tmp43 :tileValue.4:result                     ...
  508:  op add *tmp45 :tileValue.1:result *tmp44                     ...
  509:  op min *tmp46 0.09803921568627451 *tmp45                     ...
  510:  op add *tmp49 *tmp44 :tileValue.6:result                     min(WALL, (x3 + x4 + x5) + x6)    // drill at x + 1.5
  511:  op min *tmp50 0.09803921568627451 *tmp49                     ...
  512:  packcolor :findBestPosition:y1 *tmp38 *tmp42 *tmp46 *tmp50   return packcolor(
        label *label381                                              var y1 = computeRowValues(x, y - 2, ore, size);
  513:  op sub *tmp54 :findBestPosition:y 1                          var y2 = computeRowValues(x, y - 1, ore, size);
  514:  op sub :tileValue:x :findBestPosition:x 2                    var x1 = tileValue(x - 2, y, ore);
  515:  set :tileValue:y *tmp54                                      ...
  516:  set :tileValue:ore :findBestPosition:ore                     ...
  517:  ucontrol getBlock :tileValue:x :tileValue:y type building fl mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  518:  select value equal floor :tileValue:ore 0.00392156862745098  ...
  519:  sensor solid type @solid                                     ...
  520:  select :tileValue:result notEqual solid false 0.098039215686 ...
  521:  op sub :tileValue.1:x :findBestPosition:x 1                  var x2 = tileValue(x - 1, y, ore);
  522:  set :tileValue.1:y *tmp54                                    ...
  523:  set :tileValue.1:ore :findBestPosition:ore                   ...
  524:  ucontrol getBlock :tileValue.1:x :tileValue.1:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  525:  select value equal floor :tileValue.1:ore 0.0039215686274509 ...
  526:  sensor solid type @solid                                     ...
  527:  select :tileValue.1:result notEqual solid false 0.0980392156 ...
  528:  set :tileValue.2:x :findBestPosition:x                       var x3 = tileValue(x + 0, y, ore);
  529:  set :tileValue.2:y *tmp54                                    ...
  530:  set :tileValue.2:ore :findBestPosition:ore                   ...
  531:  ucontrol getBlock :tileValue.2:x :tileValue.2:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  532:  select value equal floor :tileValue.2:ore 0.0039215686274509 ...
  533:  sensor solid type @solid                                     ...
  534:  select :tileValue.2:result notEqual solid false 0.0980392156 ...
  535:  op add :tileValue.3:x :findBestPosition:x 1                  var x4 = tileValue(x + 1, y, ore);
  536:  set :tileValue.3:y *tmp54                                    ...
  537:  set :tileValue.3:ore :findBestPosition:ore                   ...
  538:  ucontrol getBlock :tileValue.3:x :tileValue.3:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  539:  select value equal floor :tileValue.3:ore 0.0039215686274509 ...
  540:  sensor solid type @solid                                     ...
  541:  select :tileValue.3:result notEqual solid false 0.0980392156 ...
  542:  op add :tileValue.4:x :findBestPosition:x 2                  var x5 = tileValue(x + 2, y, ore);
  543:  set :tileValue.4:y *tmp54                                    ...
  544:  set :tileValue.4:ore :findBestPosition:ore                   ...
  545:  ucontrol getBlock :tileValue.4:x :tileValue.4:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  546:  select value equal floor :tileValue.4:ore 0.0039215686274509 ...
  547:  sensor solid type @solid                                     ...
  548:  select :tileValue.4:result notEqual solid false 0.0980392156 ...
  549:  jump *label388 notEqual :findBestPosition:size 2             if size == 2 then
  550:  op add *tmp17 :tileValue:result :tileValue.1:result          x1 + x2,        // drill at x - 1.5
  551:  op add *tmp18 :tileValue.1:result :tileValue.2:result        x2 + x3,        // drill at x - 0.5
  552:  op add *tmp19 :tileValue.2:result :tileValue.3:result        x3 + x4,        // drill at x + 0.5
  553:  op add *tmp20 :tileValue.3:result :tileValue.4:result        x4 + x5         // drill at x + 1.5
  554:  packcolor :findBestPosition:y2 *tmp17 *tmp18 *tmp19 *tmp20   return packcolor(
  555:  jump *label394 always 0 0                                    ...
        label *label388                                              if size == 2 then
  556:  jump *label389 notEqual :findBestPosition:size 3             elsif size == 3 then
  557:  op add *tmp24 :tileValue.1:result :tileValue.2:result        x1 + (x2 + x3),   // drill at x - 1
  558:  op add *tmp25 :tileValue:result *tmp24                       ...
  559:  op add *tmp27 *tmp24 :tileValue.3:result                     (x2 + x3) + x4,   // drill at x
  560:  op add *tmp28 :tileValue.2:result :tileValue.3:result        x3 + x4 + x5,   // drill at x + 1
  561:  op add *tmp29 *tmp28 :tileValue.4:result                     ...
  562:  packcolor :findBestPosition:y2 *tmp25 *tmp27 *tmp29 0        return packcolor(
  563:  jump *label394 always 0 0                                    ...
        label *label389                                              elsif size == 3 then
  564:  op sub :tileValue.5:x :findBestPosition:x 3                  var x0 = tileValue(x - 3, y, ore);
  565:  set :tileValue.5:y *tmp54                                    ...
  566:  set :tileValue.5:ore :findBestPosition:ore                   ...
  567:  ucontrol getBlock :tileValue.5:x :tileValue.5:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  568:  select value equal floor :tileValue.5:ore 0.0039215686274509 ...
  569:  sensor solid type @solid                                     ...
  570:  select :tileValue.5:result notEqual solid false 0.0980392156 ...
  571:  op add :tileValue.6:x :findBestPosition:x 3                  var x6 = tileValue(x + 3, y, ore);
  572:  set :tileValue.6:y *tmp54                                    ...
  573:  set :tileValue.6:ore :findBestPosition:ore                   ...
  574:  ucontrol getBlock :tileValue.6:x :tileValue.6:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  575:  select value equal floor :tileValue.6:ore 0.0039215686274509 ...
  576:  sensor solid type @solid                                     ...
  577:  select :tileValue.6:result notEqual solid false 0.0980392156 ...
  578:  op add *tmp35 :tileValue:result :tileValue.1:result          min(WALL, x0 + (x1 + x2 + x3)),   // drill at x - 1.5
  579:  op add *tmp36 *tmp35 :tileValue.2:result                     ...
  580:  op add *tmp37 :tileValue.5:result *tmp36                     ...
  581:  op min *tmp38 0.09803921568627451 *tmp37                     ...
  582:  op add *tmp41 *tmp36 :tileValue.3:result                     min(WALL, (x1 + x2 + x3) + x4),   // drill at x - 0.5
  583:  op min *tmp42 0.09803921568627451 *tmp41                     ...
  584:  op add *tmp43 :tileValue.2:result :tileValue.3:result        min(WALL, x2 + (x3 + x4 + x5)),   // drill at x + 0.5
  585:  op add *tmp44 *tmp43 :tileValue.4:result                     ...
  586:  op add *tmp45 :tileValue.1:result *tmp44                     ...
  587:  op min *tmp46 0.09803921568627451 *tmp45                     ...
  588:  op add *tmp49 *tmp44 :tileValue.6:result                     min(WALL, (x3 + x4 + x5) + x6)    // drill at x + 1.5
  589:  op min *tmp50 0.09803921568627451 *tmp49                     ...
  590:  packcolor :findBestPosition:y2 *tmp38 *tmp42 *tmp46 *tmp50   return packcolor(
        label *label394                                              var y2 = computeRowValues(x, y - 1, ore, size);
  591:  op sub :tileValue:x :findBestPosition:x 2                    var x1 = tileValue(x - 2, y, ore);
  592:  set :tileValue:y :findBestPosition:y                         ...
  593:  set :tileValue:ore :findBestPosition:ore                     ...
  594:  ucontrol getBlock :tileValue:x :tileValue:y type building fl mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  595:  select value equal floor :tileValue:ore 0.00392156862745098  ...
  596:  sensor solid type @solid                                     ...
  597:  select :tileValue:result notEqual solid false 0.098039215686 ...
  598:  op sub :tileValue.1:x :findBestPosition:x 1                  var x2 = tileValue(x - 1, y, ore);
  599:  set :tileValue.1:y :findBestPosition:y                       ...
  600:  set :tileValue.1:ore :findBestPosition:ore                   ...
  601:  ucontrol getBlock :tileValue.1:x :tileValue.1:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  602:  select value equal floor :tileValue.1:ore 0.0039215686274509 ...
  603:  sensor solid type @solid                                     ...
  604:  select :tileValue.1:result notEqual solid false 0.0980392156 ...
  605:  set :tileValue.2:x :findBestPosition:x                       var x3 = tileValue(x + 0, y, ore);
  606:  set :tileValue.2:y :findBestPosition:y                       ...
  607:  set :tileValue.2:ore :findBestPosition:ore                   ...
  608:  ucontrol getBlock :tileValue.2:x :tileValue.2:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  609:  select value equal floor :tileValue.2:ore 0.0039215686274509 ...
  610:  sensor solid type @solid                                     ...
  611:  select :tileValue.2:result notEqual solid false 0.0980392156 ...
  612:  op add :tileValue.3:x :findBestPosition:x 1                  var x4 = tileValue(x + 1, y, ore);
  613:  set :tileValue.3:y :findBestPosition:y                       ...
  614:  set :tileValue.3:ore :findBestPosition:ore                   ...
  615:  ucontrol getBlock :tileValue.3:x :tileValue.3:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  616:  select value equal floor :tileValue.3:ore 0.0039215686274509 ...
  617:  sensor solid type @solid                                     ...
  618:  select :tileValue.3:result notEqual solid false 0.0980392156 ...
  619:  op add :tileValue.4:x :findBestPosition:x 2                  var x5 = tileValue(x + 2, y, ore);
  620:  set :tileValue.4:y :findBestPosition:y                       ...
  621:  set :tileValue.4:ore :findBestPosition:ore                   ...
  622:  ucontrol getBlock :tileValue.4:x :tileValue.4:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  623:  select value equal floor :tileValue.4:ore 0.0039215686274509 ...
  624:  sensor solid type @solid                                     ...
  625:  select :tileValue.4:result notEqual solid false 0.0980392156 ...
  626:  jump *label401 notEqual :findBestPosition:size 2             if size == 2 then
  627:  op add *tmp17 :tileValue:result :tileValue.1:result          x1 + x2,        // drill at x - 1.5
  628:  op add *tmp18 :tileValue.1:result :tileValue.2:result        x2 + x3,        // drill at x - 0.5
  629:  op add *tmp19 :tileValue.2:result :tileValue.3:result        x3 + x4,        // drill at x + 0.5
  630:  op add *tmp20 :tileValue.3:result :tileValue.4:result        x4 + x5         // drill at x + 1.5
  631:  packcolor :findBestPosition:y3 *tmp17 *tmp18 *tmp19 *tmp20   return packcolor(
  632:  jump *label407 always 0 0                                    ...
        label *label401                                              if size == 2 then
  633:  jump *label402 notEqual :findBestPosition:size 3             elsif size == 3 then
  634:  op add *tmp24 :tileValue.1:result :tileValue.2:result        x1 + (x2 + x3),   // drill at x - 1
  635:  op add *tmp25 :tileValue:result *tmp24                       ...
  636:  op add *tmp27 *tmp24 :tileValue.3:result                     (x2 + x3) + x4,   // drill at x
  637:  op add *tmp28 :tileValue.2:result :tileValue.3:result        x3 + x4 + x5,   // drill at x + 1
  638:  op add *tmp29 *tmp28 :tileValue.4:result                     ...
  639:  packcolor :findBestPosition:y3 *tmp25 *tmp27 *tmp29 0        return packcolor(
  640:  jump *label407 always 0 0                                    ...
        label *label402                                              elsif size == 3 then
  641:  op sub :tileValue.5:x :findBestPosition:x 3                  var x0 = tileValue(x - 3, y, ore);
  642:  set :tileValue.5:y :findBestPosition:y                       ...
  643:  set :tileValue.5:ore :findBestPosition:ore                   ...
  644:  ucontrol getBlock :tileValue.5:x :tileValue.5:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  645:  select value equal floor :tileValue.5:ore 0.0039215686274509 ...
  646:  sensor solid type @solid                                     ...
  647:  select :tileValue.5:result notEqual solid false 0.0980392156 ...
  648:  op add :tileValue.6:x :findBestPosition:x 3                  var x6 = tileValue(x + 3, y, ore);
  649:  set :tileValue.6:y :findBestPosition:y                       ...
  650:  set :tileValue.6:ore :findBestPosition:ore                   ...
  651:  ucontrol getBlock :tileValue.6:x :tileValue.6:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  652:  select value equal floor :tileValue.6:ore 0.0039215686274509 ...
  653:  sensor solid type @solid                                     ...
  654:  select :tileValue.6:result notEqual solid false 0.0980392156 ...
  655:  op add *tmp35 :tileValue:result :tileValue.1:result          min(WALL, x0 + (x1 + x2 + x3)),   // drill at x - 1.5
  656:  op add *tmp36 *tmp35 :tileValue.2:result                     ...
  657:  op add *tmp37 :tileValue.5:result *tmp36                     ...
  658:  op min *tmp38 0.09803921568627451 *tmp37                     ...
  659:  op add *tmp41 *tmp36 :tileValue.3:result                     min(WALL, (x1 + x2 + x3) + x4),   // drill at x - 0.5
  660:  op min *tmp42 0.09803921568627451 *tmp41                     ...
  661:  op add *tmp43 :tileValue.2:result :tileValue.3:result        min(WALL, x2 + (x3 + x4 + x5)),   // drill at x + 0.5
  662:  op add *tmp44 *tmp43 :tileValue.4:result                     ...
  663:  op add *tmp45 :tileValue.1:result *tmp44                     ...
  664:  op min *tmp46 0.09803921568627451 *tmp45                     ...
  665:  op add *tmp49 *tmp44 :tileValue.6:result                     min(WALL, (x3 + x4 + x5) + x6)    // drill at x + 1.5
  666:  op min *tmp50 0.09803921568627451 *tmp49                     ...
  667:  packcolor :findBestPosition:y3 *tmp38 *tmp42 *tmp46 *tmp50   return packcolor(
        label *label407                                              var y3 = computeRowValues(x, y + 0, ore, size);
  668:  op add *tmp58 :findBestPosition:y 1                          var y4 = computeRowValues(x, y + 1, ore, size);
  669:  op sub :tileValue:x :findBestPosition:x 2                    var x1 = tileValue(x - 2, y, ore);
  670:  set :tileValue:y *tmp58                                      ...
  671:  set :tileValue:ore :findBestPosition:ore                     ...
  672:  ucontrol getBlock :tileValue:x :tileValue:y type building fl mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  673:  select value equal floor :tileValue:ore 0.00392156862745098  ...
  674:  sensor solid type @solid                                     ...
  675:  select :tileValue:result notEqual solid false 0.098039215686 ...
  676:  op sub :tileValue.1:x :findBestPosition:x 1                  var x2 = tileValue(x - 1, y, ore);
  677:  set :tileValue.1:y *tmp58                                    ...
  678:  set :tileValue.1:ore :findBestPosition:ore                   ...
  679:  ucontrol getBlock :tileValue.1:x :tileValue.1:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  680:  select value equal floor :tileValue.1:ore 0.0039215686274509 ...
  681:  sensor solid type @solid                                     ...
  682:  select :tileValue.1:result notEqual solid false 0.0980392156 ...
  683:  set :tileValue.2:x :findBestPosition:x                       var x3 = tileValue(x + 0, y, ore);
  684:  set :tileValue.2:y *tmp58                                    ...
  685:  set :tileValue.2:ore :findBestPosition:ore                   ...
  686:  ucontrol getBlock :tileValue.2:x :tileValue.2:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  687:  select value equal floor :tileValue.2:ore 0.0039215686274509 ...
  688:  sensor solid type @solid                                     ...
  689:  select :tileValue.2:result notEqual solid false 0.0980392156 ...
  690:  op add :tileValue.3:x :findBestPosition:x 1                  var x4 = tileValue(x + 1, y, ore);
  691:  set :tileValue.3:y *tmp58                                    ...
  692:  set :tileValue.3:ore :findBestPosition:ore                   ...
  693:  ucontrol getBlock :tileValue.3:x :tileValue.3:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  694:  select value equal floor :tileValue.3:ore 0.0039215686274509 ...
  695:  sensor solid type @solid                                     ...
  696:  select :tileValue.3:result notEqual solid false 0.0980392156 ...
  697:  op add :tileValue.4:x :findBestPosition:x 2                  var x5 = tileValue(x + 2, y, ore);
  698:  set :tileValue.4:y *tmp58                                    ...
  699:  set :tileValue.4:ore :findBestPosition:ore                   ...
  700:  ucontrol getBlock :tileValue.4:x :tileValue.4:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  701:  select value equal floor :tileValue.4:ore 0.0039215686274509 ...
  702:  sensor solid type @solid                                     ...
  703:  select :tileValue.4:result notEqual solid false 0.0980392156 ...
  704:  jump *label414 notEqual :findBestPosition:size 2             if size == 2 then
  705:  op add *tmp17 :tileValue:result :tileValue.1:result          x1 + x2,        // drill at x - 1.5
  706:  op add *tmp18 :tileValue.1:result :tileValue.2:result        x2 + x3,        // drill at x - 0.5
  707:  op add *tmp19 :tileValue.2:result :tileValue.3:result        x3 + x4,        // drill at x + 0.5
  708:  op add *tmp20 :tileValue.3:result :tileValue.4:result        x4 + x5         // drill at x + 1.5
  709:  packcolor :findBestPosition:y4 *tmp17 *tmp18 *tmp19 *tmp20   return packcolor(
  710:  jump *label420 always 0 0                                    ...
        label *label414                                              if size == 2 then
  711:  jump *label415 notEqual :findBestPosition:size 3             elsif size == 3 then
  712:  op add *tmp24 :tileValue.1:result :tileValue.2:result        x1 + (x2 + x3),   // drill at x - 1
  713:  op add *tmp25 :tileValue:result *tmp24                       ...
  714:  op add *tmp27 *tmp24 :tileValue.3:result                     (x2 + x3) + x4,   // drill at x
  715:  op add *tmp28 :tileValue.2:result :tileValue.3:result        x3 + x4 + x5,   // drill at x + 1
  716:  op add *tmp29 *tmp28 :tileValue.4:result                     ...
  717:  packcolor :findBestPosition:y4 *tmp25 *tmp27 *tmp29 0        return packcolor(
  718:  jump *label420 always 0 0                                    ...
        label *label415                                              elsif size == 3 then
  719:  op sub :tileValue.5:x :findBestPosition:x 3                  var x0 = tileValue(x - 3, y, ore);
  720:  set :tileValue.5:y *tmp58                                    ...
  721:  set :tileValue.5:ore :findBestPosition:ore                   ...
  722:  ucontrol getBlock :tileValue.5:x :tileValue.5:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  723:  select value equal floor :tileValue.5:ore 0.0039215686274509 ...
  724:  sensor solid type @solid                                     ...
  725:  select :tileValue.5:result notEqual solid false 0.0980392156 ...
  726:  op add :tileValue.6:x :findBestPosition:x 3                  var x6 = tileValue(x + 3, y, ore);
  727:  set :tileValue.6:y *tmp58                                    ...
  728:  set :tileValue.6:ore :findBestPosition:ore                   ...
  729:  ucontrol getBlock :tileValue.6:x :tileValue.6:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  730:  select value equal floor :tileValue.6:ore 0.0039215686274509 ...
  731:  sensor solid type @solid                                     ...
  732:  select :tileValue.6:result notEqual solid false 0.0980392156 ...
  733:  op add *tmp35 :tileValue:result :tileValue.1:result          min(WALL, x0 + (x1 + x2 + x3)),   // drill at x - 1.5
  734:  op add *tmp36 *tmp35 :tileValue.2:result                     ...
  735:  op add *tmp37 :tileValue.5:result *tmp36                     ...
  736:  op min *tmp38 0.09803921568627451 *tmp37                     ...
  737:  op add *tmp41 *tmp36 :tileValue.3:result                     min(WALL, (x1 + x2 + x3) + x4),   // drill at x - 0.5
  738:  op min *tmp42 0.09803921568627451 *tmp41                     ...
  739:  op add *tmp43 :tileValue.2:result :tileValue.3:result        min(WALL, x2 + (x3 + x4 + x5)),   // drill at x + 0.5
  740:  op add *tmp44 *tmp43 :tileValue.4:result                     ...
  741:  op add *tmp45 :tileValue.1:result *tmp44                     ...
  742:  op min *tmp46 0.09803921568627451 *tmp45                     ...
  743:  op add *tmp49 *tmp44 :tileValue.6:result                     min(WALL, (x3 + x4 + x5) + x6)    // drill at x + 1.5
  744:  op min *tmp50 0.09803921568627451 *tmp49                     ...
  745:  packcolor :findBestPosition:y4 *tmp38 *tmp42 *tmp46 *tmp50   return packcolor(
        label *label420                                              var y4 = computeRowValues(x, y + 1, ore, size);
  746:  op add *tmp60 :findBestPosition:y 2                          var y5 = computeRowValues(x, y + 2, ore, size);
  747:  op sub :tileValue:x :findBestPosition:x 2                    var x1 = tileValue(x - 2, y, ore);
  748:  set :tileValue:y *tmp60                                      ...
  749:  set :tileValue:ore :findBestPosition:ore                     ...
  750:  ucontrol getBlock :tileValue:x :tileValue:y type building fl mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  751:  select value equal floor :tileValue:ore 0.00392156862745098  ...
  752:  sensor solid type @solid                                     ...
  753:  select :tileValue:result notEqual solid false 0.098039215686 ...
  754:  op sub :tileValue.1:x :findBestPosition:x 1                  var x2 = tileValue(x - 1, y, ore);
  755:  set :tileValue.1:y *tmp60                                    ...
  756:  set :tileValue.1:ore :findBestPosition:ore                   ...
  757:  ucontrol getBlock :tileValue.1:x :tileValue.1:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  758:  select value equal floor :tileValue.1:ore 0.0039215686274509 ...
  759:  sensor solid type @solid                                     ...
  760:  select :tileValue.1:result notEqual solid false 0.0980392156 ...
  761:  set :tileValue.2:x :findBestPosition:x                       var x3 = tileValue(x + 0, y, ore);
  762:  set :tileValue.2:y *tmp60                                    ...
  763:  set :tileValue.2:ore :findBestPosition:ore                   ...
  764:  ucontrol getBlock :tileValue.2:x :tileValue.2:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  765:  select value equal floor :tileValue.2:ore 0.0039215686274509 ...
  766:  sensor solid type @solid                                     ...
  767:  select :tileValue.2:result notEqual solid false 0.0980392156 ...
  768:  op add :tileValue.3:x :findBestPosition:x 1                  var x4 = tileValue(x + 1, y, ore);
  769:  set :tileValue.3:y *tmp60                                    ...
  770:  set :tileValue.3:ore :findBestPosition:ore                   ...
  771:  ucontrol getBlock :tileValue.3:x :tileValue.3:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  772:  select value equal floor :tileValue.3:ore 0.0039215686274509 ...
  773:  sensor solid type @solid                                     ...
  774:  select :tileValue.3:result notEqual solid false 0.0980392156 ...
  775:  op add :tileValue.4:x :findBestPosition:x 2                  var x5 = tileValue(x + 2, y, ore);
  776:  set :tileValue.4:y *tmp60                                    ...
  777:  set :tileValue.4:ore :findBestPosition:ore                   ...
  778:  ucontrol getBlock :tileValue.4:x :tileValue.4:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  779:  select value equal floor :tileValue.4:ore 0.0039215686274509 ...
  780:  sensor solid type @solid                                     ...
  781:  select :tileValue.4:result notEqual solid false 0.0980392156 ...
  782:  jump *label427 notEqual :findBestPosition:size 2             if size == 2 then
  783:  op add *tmp17 :tileValue:result :tileValue.1:result          x1 + x2,        // drill at x - 1.5
  784:  op add *tmp18 :tileValue.1:result :tileValue.2:result        x2 + x3,        // drill at x - 0.5
  785:  op add *tmp19 :tileValue.2:result :tileValue.3:result        x3 + x4,        // drill at x + 0.5
  786:  op add *tmp20 :tileValue.3:result :tileValue.4:result        x4 + x5         // drill at x + 1.5
  787:  packcolor :computeRowValues*retval *tmp17 *tmp18 *tmp19 *tmp return packcolor(
  788:  jump *label433 always 0 0                                    ...
        label *label427                                              if size == 2 then
  789:  jump *label428 notEqual :findBestPosition:size 3             elsif size == 3 then
  790:  op add *tmp24 :tileValue.1:result :tileValue.2:result        x1 + (x2 + x3),   // drill at x - 1
  791:  op add *tmp25 :tileValue:result *tmp24                       ...
  792:  op add *tmp27 *tmp24 :tileValue.3:result                     (x2 + x3) + x4,   // drill at x
  793:  op add *tmp28 :tileValue.2:result :tileValue.3:result        x3 + x4 + x5,   // drill at x + 1
  794:  op add *tmp29 *tmp28 :tileValue.4:result                     ...
  795:  packcolor :computeRowValues*retval *tmp25 *tmp27 *tmp29 0    return packcolor(
  796:  jump *label433 always 0 0                                    ...
        label *label428                                              elsif size == 3 then
  797:  op sub :tileValue.5:x :findBestPosition:x 3                  var x0 = tileValue(x - 3, y, ore);
  798:  set :tileValue.5:y *tmp60                                    ...
  799:  set :tileValue.5:ore :findBestPosition:ore                   ...
  800:  ucontrol getBlock :tileValue.5:x :tileValue.5:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  801:  select value equal floor :tileValue.5:ore 0.0039215686274509 ...
  802:  sensor solid type @solid                                     ...
  803:  select :tileValue.5:result notEqual solid false 0.0980392156 ...
  804:  op add :tileValue.6:x :findBestPosition:x 3                  var x6 = tileValue(x + 3, y, ore);
  805:  set :tileValue.6:y *tmp60                                    ...
  806:  set :tileValue.6:ore :findBestPosition:ore                   ...
  807:  ucontrol getBlock :tileValue.6:x :tileValue.6:y type buildin mlog(in x, in y, in ore, in ORE, in WALL, out result) {
  808:  select value equal floor :tileValue.6:ore 0.0039215686274509 ...
  809:  sensor solid type @solid                                     ...
  810:  select :tileValue.6:result notEqual solid false 0.0980392156 ...
  811:  op add *tmp35 :tileValue:result :tileValue.1:result          min(WALL, x0 + (x1 + x2 + x3)),   // drill at x - 1.5
  812:  op add *tmp36 *tmp35 :tileValue.2:result                     ...
  813:  op add *tmp37 :tileValue.5:result *tmp36                     ...
  814:  op min *tmp38 0.09803921568627451 *tmp37                     ...
  815:  op add *tmp41 *tmp36 :tileValue.3:result                     min(WALL, (x1 + x2 + x3) + x4),   // drill at x - 0.5
  816:  op min *tmp42 0.09803921568627451 *tmp41                     ...
  817:  op add *tmp43 :tileValue.2:result :tileValue.3:result        min(WALL, x2 + (x3 + x4 + x5)),   // drill at x + 0.5
  818:  op add *tmp44 *tmp43 :tileValue.4:result                     ...
  819:  op add *tmp45 :tileValue.1:result *tmp44                     ...
  820:  op min *tmp46 0.09803921568627451 *tmp45                     ...
  821:  op add *tmp49 *tmp44 :tileValue.6:result                     min(WALL, (x3 + x4 + x5) + x6)    // drill at x + 1.5
  822:  op min *tmp50 0.09803921568627451 *tmp49                     ...
  823:  packcolor :computeRowValues*retval *tmp38 *tmp42 *tmp46 *tmp return packcolor(
        label *label433                                              var y5 = computeRowValues(x, y + 2, ore, size);
  824:  set :findBestPosition:y5 :computeRowValues*retval            ...
  825:  set :findBestPosition:best 0                                 var best = 0;
  826:  set :findBestPosition:bestX 0                                bestX = 0;
  827:  set :findBestPosition:bestY 0                                bestY = 0;
  828:  jump *label31 notEqual :findBestPosition:size 3              if size == 3 then
  829:  op add *tmp64 :findBestPosition:y2 :findBestPosition:y3      row1 = y1 + (y2 + y3);  // drill at y - 1
  830:  op add :findBestPosition:row1 :findBestPosition:y1 *tmp64    ...
  831:  op add :findBestPosition:row2 *tmp64 :findBestPosition:y4    row2 = (y2 + y3) + y4;  // drill at y
  832:  op add *tmp68 :findBestPosition:y3 :findBestPosition:y4      row3 = y3 + y4 + y5;    // drill at y + 1
  833:  op add :findBestPosition:row3 *tmp68 :computeRowValues*retva ...
  834:  unpackcolor :updateRowPositionsOdd:col1 :updateRowPositionsO unpackcolor(out col1, out col2, out col3, , rowSum);
  835:  jump *label35 lessThanEq :updateRowPositionsOdd:col1 0       if value > best then
  836:  jump *label37 greaterThanEq :updateRowPositionsOdd:col1 0.07 if value < LIMIT then
  837:  set :findBestPosition:bestX -1                               bestX = dx;
  838:  set :findBestPosition:bestY -1                               bestY = dy;
  839:  set :findBestPosition:best :updateRowPositionsOdd:col1       best = value;
        label *label37                                               if value < LIMIT then
        label *label35                                               if value > best then
  840:  jump *label40 lessThanEq :updateRowPositionsOdd:col2 :findBe ...
  841:  jump *label42 greaterThanEq :updateRowPositionsOdd:col2 0.07 if value < LIMIT then
  842:  set :findBestPosition:bestX 0                                bestX = dx;
  843:  set :findBestPosition:bestY -1                               bestY = dy;
  844:  set :findBestPosition:best :updateRowPositionsOdd:col2       best = value;
        label *label42                                               if value < LIMIT then
        label *label40                                               if value > best then
  845:  jump *label45 lessThanEq :updateRowPositionsOdd:col3 :findBe ...
  846:  jump *label47 greaterThanEq :updateRowPositionsOdd:col3 0.07 if value < LIMIT then
  847:  set :findBestPosition:bestX 1                                bestX = dx;
  848:  set :findBestPosition:bestY -1                               bestY = dy;
  849:  set :findBestPosition:best :updateRowPositionsOdd:col3       best = value;
        label *label47                                               if value < LIMIT then
        label *label45                                               if value > best then
  850:  unpackcolor :updateRowPositionsOdd.1:col1 :updateRowPosition unpackcolor(out col1, out col2, out col3, , rowSum);
  851:  jump *label51 lessThanEq :updateRowPositionsOdd.1:col1 :find if value > best then
  852:  jump *label53 greaterThanEq :updateRowPositionsOdd.1:col1 0. if value < LIMIT then
  853:  set :findBestPosition:bestX -1                               bestX = dx;
  854:  set :findBestPosition:bestY 0                                bestY = dy;
  855:  set :findBestPosition:best :updateRowPositionsOdd.1:col1     best = value;
        label *label53                                               if value < LIMIT then
        label *label51                                               if value > best then
  856:  jump *label56 lessThanEq :updateRowPositionsOdd.1:col2 :find ...
  857:  jump *label58 greaterThanEq :updateRowPositionsOdd.1:col2 0. if value < LIMIT then
  858:  set :findBestPosition:bestX 0                                bestX = dx;
  859:  set :findBestPosition:bestY 0                                bestY = dy;
  860:  set :findBestPosition:best :updateRowPositionsOdd.1:col2     best = value;
        label *label58                                               if value < LIMIT then
        label *label56                                               if value > best then
  861:  jump *label61 lessThanEq :updateRowPositionsOdd.1:col3 :find ...
  862:  jump *label63 greaterThanEq :updateRowPositionsOdd.1:col3 0. if value < LIMIT then
  863:  set :findBestPosition:bestX 1                                bestX = dx;
  864:  set :findBestPosition:bestY 0                                bestY = dy;
  865:  set :findBestPosition:best :updateRowPositionsOdd.1:col3     best = value;
        label *label63                                               if value < LIMIT then
        label *label61                                               if value > best then
  866:  unpackcolor :updateRowPositionsOdd.2:col1 :updateRowPosition unpackcolor(out col1, out col2, out col3, , rowSum);
  867:  jump *label67 lessThanEq :updateRowPositionsOdd.2:col1 :find if value > best then
  868:  jump *label69 greaterThanEq :updateRowPositionsOdd.2:col1 0. if value < LIMIT then
  869:  set :findBestPosition:bestX -1                               bestX = dx;
  870:  set :findBestPosition:bestY 1                                bestY = dy;
  871:  set :findBestPosition:best :updateRowPositionsOdd.2:col1     best = value;
        label *label69                                               if value < LIMIT then
        label *label67                                               if value > best then
  872:  jump *label72 lessThanEq :updateRowPositionsOdd.2:col2 :find ...
  873:  jump *label74 greaterThanEq :updateRowPositionsOdd.2:col2 0. if value < LIMIT then
  874:  set :findBestPosition:bestX 0                                bestX = dx;
  875:  set :findBestPosition:bestY 1                                bestY = dy;
  876:  set :findBestPosition:best :updateRowPositionsOdd.2:col2     best = value;
        label *label74                                               if value < LIMIT then
        label *label72                                               if value > best then
  877:  jump *label32 lessThanEq :updateRowPositionsOdd.2:col3 :find ...
  878:  jump *label32 greaterThanEq :updateRowPositionsOdd.2:col3 0. if value < LIMIT then
  879:  set :findBestPosition:bestX 1                                bestX = dx;
  880:  set :findBestPosition:bestY 1                                bestY = dy;
  881:  set :findBestPosition:best :updateRowPositionsOdd.2:col3     best = value;
  882:  jump *label32 always 0 0                                     if size == 3 then
        label *label31                                               ...
  883:  jump *label81 notEqual :findBestPosition:size 2              if size == 2 then
  884:  op add :findBestPosition:row1 :findBestPosition:y1 :findBest row1 = y1 + y2;         // drill at y - 1.5
  885:  op add :findBestPosition:row2 :findBestPosition:y2 :findBest row2 = y2 + y3;         // drill at y - 0.5
  886:  op add :findBestPosition:row3 :findBestPosition:y3 :findBest row3 = y3 + y4;         // drill at y + 0.5
  887:  op add :findBestPosition:row4 :findBestPosition:y4 :computeR row4 = y4 + y5;         // drill at y + 1.5
  888:  jump *label82 always 0 0                                     if size == 2 then
        label *label81                                               ...
  889:  op sub *tmp115 :findBestPosition:y 3                         var y0 = computeRowValues(x, y - 3, ore, size);
  890:  set :computeRowValues:x :findBestPosition:x                  ...
  891:  set :computeRowValues:y *tmp115                              ...
  892:  set :computeRowValues:ore :findBestPosition:ore              ...
  893:  set :computeRowValues:size :findBestPosition:size            ...
  894:  setaddr :computeRowValues*retaddr *label83                   ...
  895:  call *label2 *invalid :computeRowValues*retval               ...
        label *label83                                               ...
  896:  set :findBestPosition:y0 :computeRowValues*retval            ...
  897:  op add *tmp117 :findBestPosition:y 3                         var y6 = computeRowValues(x, y + 3, ore, size);
  898:  set :computeRowValues:x :findBestPosition:x                  ...
  899:  set :computeRowValues:y *tmp117                              ...
  900:  set :computeRowValues:ore :findBestPosition:ore              ...
  901:  set :computeRowValues:size :findBestPosition:size            ...
  902:  setaddr :computeRowValues*retaddr *label84                   ...
  903:  call *label2 *invalid :computeRowValues*retval               ...
        label *label84                                               ...
  904:  op add *tmp119 :findBestPosition:y1 :findBestPosition:y2     row1 = y0 + (y1 + y2 + y3);     // drill at y - 1.5
  905:  op add *tmp120 *tmp119 :findBestPosition:y3                  ...
  906:  op add :findBestPosition:row1 :findBestPosition:y0 *tmp120   ...
  907:  op add :findBestPosition:row2 *tmp120 :findBestPosition:y4   row2 = (y1 + y2 + y3) + y4;     // drill at y - 0.5
  908:  op add *tmp125 :findBestPosition:y3 :findBestPosition:y4     row3 = y2 + (y3 + y4 + y5);     // drill at y + 0.5
  909:  op add *tmp126 *tmp125 :findBestPosition:y5                  ...
  910:  op add :findBestPosition:row3 :findBestPosition:y2 *tmp126   ...
  911:  op add :findBestPosition:row4 *tmp126 :computeRowValues*retv row4 = (y3 + y4 + y5) + y6;     // drill at y + 1.5
        label *label82                                               if size == 2 then
  912:  unpackcolor :updateRowPositionsEven:col1 :updateRowPositions unpackcolor(out col1, out col2, out col3, out col4, rowSum);
  913:  jump *label87 lessThanEq :updateRowPositionsEven:col1 :findB if value > best then
  914:  jump *label89 greaterThanEq :updateRowPositionsEven:col1 0.0 if value < LIMIT then
  915:  set :findBestPosition:bestX -1.5                             bestX = dx;
  916:  set :findBestPosition:bestY -1.5                             bestY = dy;
  917:  set :findBestPosition:best :updateRowPositionsEven:col1      best = value;
        label *label89                                               if value < LIMIT then
        label *label87                                               if value > best then
  918:  jump *label92 lessThanEq :updateRowPositionsEven:col2 :findB ...
  919:  jump *label94 greaterThanEq :updateRowPositionsEven:col2 0.0 if value < LIMIT then
  920:  set :findBestPosition:bestX -0.5                             bestX = dx;
  921:  set :findBestPosition:bestY -1.5                             bestY = dy;
  922:  set :findBestPosition:best :updateRowPositionsEven:col2      best = value;
        label *label94                                               if value < LIMIT then
        label *label92                                               if value > best then
  923:  jump *label97 lessThanEq :updateRowPositionsEven:col3 :findB ...
  924:  jump *label99 greaterThanEq :updateRowPositionsEven:col3 0.0 if value < LIMIT then
  925:  set :findBestPosition:bestX 0.5                              bestX = dx;
  926:  set :findBestPosition:bestY -1.5                             bestY = dy;
  927:  set :findBestPosition:best :updateRowPositionsEven:col3      best = value;
        label *label99                                               if value < LIMIT then
        label *label97                                               if value > best then
  928:  jump *label102 lessThanEq :updateRowPositionsEven:col4 :find ...
  929:  jump *label104 greaterThanEq :updateRowPositionsEven:col4 0. if value < LIMIT then
  930:  set :findBestPosition:bestX 1.5                              bestX = dx;
  931:  set :findBestPosition:bestY -1.5                             bestY = dy;
  932:  set :findBestPosition:best :updateRowPositionsEven:col4      best = value;
        label *label104                                              if value < LIMIT then
        label *label102                                              if value > best then
  933:  unpackcolor :updateRowPositionsEven.1:col1 :updateRowPositio unpackcolor(out col1, out col2, out col3, out col4, rowSum);
  934:  jump *label108 lessThanEq :updateRowPositionsEven.1:col1 :fi if value > best then
  935:  jump *label110 greaterThanEq :updateRowPositionsEven.1:col1  if value < LIMIT then
  936:  set :findBestPosition:bestX -1.5                             bestX = dx;
  937:  set :findBestPosition:bestY -0.5                             bestY = dy;
  938:  set :findBestPosition:best :updateRowPositionsEven.1:col1    best = value;
        label *label110                                              if value < LIMIT then
        label *label108                                              if value > best then
  939:  jump *label113 lessThanEq :updateRowPositionsEven.1:col2 :fi ...
  940:  jump *label115 greaterThanEq :updateRowPositionsEven.1:col2  if value < LIMIT then
  941:  set :findBestPosition:bestX -0.5                             bestX = dx;
  942:  set :findBestPosition:bestY -0.5                             bestY = dy;
  943:  set :findBestPosition:best :updateRowPositionsEven.1:col2    best = value;
        label *label115                                              if value < LIMIT then
        label *label113                                              if value > best then
  944:  jump *label118 lessThanEq :updateRowPositionsEven.1:col3 :fi ...
  945:  jump *label120 greaterThanEq :updateRowPositionsEven.1:col3  if value < LIMIT then
  946:  set :findBestPosition:bestX 0.5                              bestX = dx;
  947:  set :findBestPosition:bestY -0.5                             bestY = dy;
  948:  set :findBestPosition:best :updateRowPositionsEven.1:col3    best = value;
        label *label120                                              if value < LIMIT then
        label *label118                                              if value > best then
  949:  jump *label123 lessThanEq :updateRowPositionsEven.1:col4 :fi ...
  950:  jump *label125 greaterThanEq :updateRowPositionsEven.1:col4  if value < LIMIT then
  951:  set :findBestPosition:bestX 1.5                              bestX = dx;
  952:  set :findBestPosition:bestY -0.5                             bestY = dy;
  953:  set :findBestPosition:best :updateRowPositionsEven.1:col4    best = value;
        label *label125                                              if value < LIMIT then
        label *label123                                              if value > best then
  954:  unpackcolor :updateRowPositionsEven.2:col1 :updateRowPositio unpackcolor(out col1, out col2, out col3, out col4, rowSum);
  955:  jump *label129 lessThanEq :updateRowPositionsEven.2:col1 :fi if value > best then
  956:  jump *label131 greaterThanEq :updateRowPositionsEven.2:col1  if value < LIMIT then
  957:  set :findBestPosition:bestX -1.5                             bestX = dx;
  958:  set :findBestPosition:bestY 0.5                              bestY = dy;
  959:  set :findBestPosition:best :updateRowPositionsEven.2:col1    best = value;
        label *label131                                              if value < LIMIT then
        label *label129                                              if value > best then
  960:  jump *label134 lessThanEq :updateRowPositionsEven.2:col2 :fi ...
  961:  jump *label136 greaterThanEq :updateRowPositionsEven.2:col2  if value < LIMIT then
  962:  set :findBestPosition:bestX -0.5                             bestX = dx;
  963:  set :findBestPosition:bestY 0.5                              bestY = dy;
  964:  set :findBestPosition:best :updateRowPositionsEven.2:col2    best = value;
        label *label136                                              if value < LIMIT then
        label *label134                                              if value > best then
  965:  jump *label139 lessThanEq :updateRowPositionsEven.2:col3 :fi ...
  966:  jump *label141 greaterThanEq :updateRowPositionsEven.2:col3  if value < LIMIT then
  967:  set :findBestPosition:bestX 0.5                              bestX = dx;
  968:  set :findBestPosition:bestY 0.5                              bestY = dy;
  969:  set :findBestPosition:best :updateRowPositionsEven.2:col3    best = value;
        label *label141                                              if value < LIMIT then
        label *label139                                              if value > best then
  970:  jump *label144 lessThanEq :updateRowPositionsEven.2:col4 :fi ...
  971:  jump *label146 greaterThanEq :updateRowPositionsEven.2:col4  if value < LIMIT then
  972:  set :findBestPosition:bestX 1.5                              bestX = dx;
  973:  set :findBestPosition:bestY 0.5                              bestY = dy;
  974:  set :findBestPosition:best :updateRowPositionsEven.2:col4    best = value;
        label *label146                                              if value < LIMIT then
        label *label144                                              if value > best then
  975:  unpackcolor :updateRowPositionsEven.3:col1 :updateRowPositio unpackcolor(out col1, out col2, out col3, out col4, rowSum);
  976:  jump *label150 lessThanEq :updateRowPositionsEven.3:col1 :fi if value > best then
  977:  jump *label152 greaterThanEq :updateRowPositionsEven.3:col1  if value < LIMIT then
  978:  set :findBestPosition:bestX -1.5                             bestX = dx;
  979:  set :findBestPosition:bestY 1.5                              bestY = dy;
  980:  set :findBestPosition:best :updateRowPositionsEven.3:col1    best = value;
        label *label152                                              if value < LIMIT then
        label *label150                                              if value > best then
  981:  jump *label155 lessThanEq :updateRowPositionsEven.3:col2 :fi ...
  982:  jump *label157 greaterThanEq :updateRowPositionsEven.3:col2  if value < LIMIT then
  983:  set :findBestPosition:bestX -0.5                             bestX = dx;
  984:  set :findBestPosition:bestY 1.5                              bestY = dy;
  985:  set :findBestPosition:best :updateRowPositionsEven.3:col2    best = value;
        label *label157                                              if value < LIMIT then
        label *label155                                              if value > best then
  986:  jump *label160 lessThanEq :updateRowPositionsEven.3:col3 :fi ...
  987:  jump *label162 greaterThanEq :updateRowPositionsEven.3:col3  if value < LIMIT then
  988:  set :findBestPosition:bestX 0.5                              bestX = dx;
  989:  set :findBestPosition:bestY 1.5                              bestY = dy;
  990:  set :findBestPosition:best :updateRowPositionsEven.3:col3    best = value;
        label *label162                                              if value < LIMIT then
        label *label160                                              if value > best then
  991:  jump *label165 lessThanEq :updateRowPositionsEven.3:col4 :fi ...
  992:  jump *label167 greaterThanEq :updateRowPositionsEven.3:col4  if value < LIMIT then
  993:  set :findBestPosition:bestX 1.5                              bestX = dx;
  994:  set :findBestPosition:bestY 1.5                              bestY = dy;
  995:  set :findBestPosition:best :updateRowPositionsEven.3:col4    best = value;
        label *label167                                              if value < LIMIT then
        label *label165                                              if value > best then
        label *label32                                               if size == 3 then
  996:  op mul :findBestPosition*retval :findBestPosition:best 255   return best * 255;
  997:  set :findBestPosition*finished true                          remote def findBestPosition(unit, x, y, ore, size, out bestX, out bestY)
  998:  jump *label4 always 0 0                                      ...


Performance: parsed in 303 ms, compiled in 338 ms, optimized in 1,031 ms, run in 20 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (3 steps):
The program didn't generate any output.
Execution exception at instruction 4: wait 1e12:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
