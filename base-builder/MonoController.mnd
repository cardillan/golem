#set target = 8;
#set syntax = strict;
//#set sort-variables;

#set program-name = "Base Builder - Mono Controller";
#set program-version = "v0.4.0";

module MonoController;

// At this point, we're only using a poly
const RADIUS = 7;
const capacity = 20;

linked message1;

noinit var core, coreX, coreY, sandX, sandY, count;

var min = 0, minOre = null;

noinit export var
    scrap,
    sandContainer,
    copperTarget,
    sandTarget,
    leadTarget;

volatile mlog(@copper.@name)  var oreCopper = @ore-copper;
volatile mlog(@scrap.@name)   var oreScrap = @ore-scrap;
volatile mlog(@lead.@name)    var oreLead = @ore-lead;
volatile mlog(@sand.@name)    var oreSand = @sand-floor;

void backgroundProcess()
    var firstUnit;
    do
        firstUnit = ubind(@mono);
        core = ulocate(:building, :core, false, out coreX, out coreY);
    while core == null;

    var runningCount = 0;

    while true do
        ubind(@mono);
        if firstUnit.@dead then firstUnit = @unit; end;

        if @unit == firstUnit then
            printflush(message1);

            var lead = core.@lead - leadTarget;
            var sand = sandContainer.@sand + sandContainer.@scrap - sandTarget;
            var copper = core.@copper - copperTarget;
            min = min(lead, sand, copper);
            minOre = min == sand ? @sand : min == lead ? @lead : @copper;
            if scrap then
                if minOre == @sand then minOre = @scrap; end;
            end;

            println("minOre:", minOre);
            min += 10 * runningCount;

            count = runningCount;
            runningCount = 2;
            sandX = sandContainer.@x;
            sandY = sandContainer.@y;
        end;
        runningCount++;

        var flag = @unit.@flag;
        println("Unit flag: ", flag);
        if flag == 0 then
            findOreToMine(minOre);
        elsif flag == 1 then
            returnItems();
        else
            mine(flag);
        end;
    end;
end;

void findOreToMine(ore)
    if @unit.@firstItem != null then
        itemDrop(@air, capacity);
        if @unit.@firstItem != null then return; end;
    end;

    var x, y;
    ulocate(:ore, ore, out x, out y);
    approach(x, y, RADIUS);
    mine(x, y);
    flag((x * 1000 + y) * 16 + ore.@id);
    println($"Found $ore at $x, $y");
end;

void mine(flag)
    print("Mining ");

    var ore = lookup(:item, flag % 16);
    printchar(ore);
    flag \= 16;
    var y = flag % 1000;
    var x = flag \ 1000;

    var floorOre = @this.read(ore.@name);
    var oreCapacity = ore == @scrap ? capacity - count : capacity;

    if ore != minOre then
        if ore != @scrap then
            // We aren't mining the most needed ore
            if core.sensor(ore) > min then
                print(", switching to a more needed ore");
                flag(1);
                return;
            end;
        end;
    end;

    var items = @unit.@totalItems;
    print(items);

    if @unit.@firstItem != ore then
        print(" (dropping)");
        itemDrop(@air, capacity);
    end;

    if items >= oreCapacity then
        print(", full");
        flag(1);
        if ore == @scrap then
            approach(sandX, sandY, RADIUS);
            itemDrop(sandContainer, capacity);
        else
            approach(coreX, coreY, RADIUS);
            itemDrop(core, capacity);
        end;
    else
        print($" at $x, $y");
        approach(x, y, RADIUS);

        var floor;
        var block = getBlock(x, y, , out floor);
        if floor != floorOre then
            if floor == null then
                println(": too far");
            else
                flag(1);
                println(": no ore!");
            end;
        elsif block == null then
            mine(x, y);
        else
            // The spot got built over!
            flag(1);
            println(": blocked!");
        end;
    end;

    println();
end;

void returnItems()
    print("Returning ore");
    if @unit.@firstItem == @scrap then
        approach(sandX, sandY, RADIUS);
        itemDrop(sandContainer, capacity);
    else
        approach(coreX, coreY, RADIUS);
        itemDrop(core, capacity);
    end;

    if @unit.@firstItem == null then
        println(" (finished)");
        flag(0);
    end;

    println();
end;
