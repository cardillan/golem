   190 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (2 passes, 8 iterations).
    21 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (7 iterations).
    12 instructions eliminated by Jump Optimization (7 iterations).
    18 instructions eliminated by Single Step Elimination (3 passes, 10 iterations).
     1 instructions modified by Expression Optimization (5 iterations).
     1 instructions eliminated by If Expression Optimization (6 iterations).
     5 instructions eliminated by Data Flow Optimization (2 passes, 10 iterations).
   331 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
     1 jump tables inlined by Array Optimization.
    20 instructions eliminated by Jump Straightening (7 iterations).
    14 instructions eliminated by Unreachable Code Elimination (2 iterations).
   420 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 863):
    Unroll iteration loop at FlareController.mnd:63:9            size  +331, benefit     1475.0, efficiency      4.456
  * Inline write jump table of array 'titaniumDrills'            size    -4, benefit        1.0, efficiency   Infinity (-4 instructions)
    Inline 'titaniumDrills' write access at FlareController.mnd:29:9 size   +17, benefit        1.0, efficiency      0.059

Pass 1: speed optimization selection (cost limit 867):
  * Unroll iteration loop at FlareController.mnd:63:9            size  +331, benefit     1475.0, efficiency      4.456 (+331 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-14 instructions):
 
    21 set .coreX *tmp38
    22 sensor *tmp39 .core @y
    23 set .coreY *tmp39
-    * set *tmp34 *tmp39
    24 jump *label11 always
    25 label *label10
-    * set *tmp34 null
    26 label *label11
    27 label *label15
    28 jump *label17 equal true false
 
    88 op equal *tmp41 :backgroundProcess:drill null
    89 jump *label31 equal *tmp41 false
    90 jump *label20 always
-    * set *tmp42 null
    91 jump *label32 always
    92 label *label31
-    * set *tmp42 null
    93 label *label32
    94 sensor *tmp43 :backgroundProcess:drill @titanium
    95 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   104 jump *label36 equal *tmp48 false
   105 set *tmp47 null
   106 jump *label35 always
-    * set *tmp49 null
   107 jump *label37 always
   108 label *label36
-    * set *tmp49 null
   109 label *label37
   110 set :findFreeUnit:first_unit @unit
   111 label *label38
 
   115 ucontrol flag :findFreeUnit:initial_flag
   116 set *tmp47 @unit
   117 jump *label35 always
-    * set *tmp52 null
   118 jump *label42 always
   119 label *label41
   120 sensor *tmp53 :findFreeUnit:first_unit @dead
 
   127 label *label43
   128 set *tmp55 null
   129 label *label44
-    * set *tmp52 *tmp55
   130 label *label42
   131 ubind :findFreeUnit:unit_type
   132 label *label39
 
   146 label *label45
   147 set *tmp59 null
   148 label *label46
-    * set *tmp46 *tmp59
   149 jump *label34 always
   150 label *label33
-    * set *tmp46 null
   151 label *label34
   152 # "Function: void serviceDrill(in drill, in unit)"
   153 set :serviceDrill:drill :backgroundProcess:drill
 
   159 jump *label48 equal *tmp61 false
   160 ucontrol approach .coreX .coreY 4
   161 ucontrol itemDrop .core 10
-    * set *tmp62 null
   162 jump *label49 always
   163 label *label48
   164 op equal *tmp63 :serviceDrill:item null
 
   173 ucontrol itemDrop @air 10
   174 set *tmp64 null
   175 label *label51
-    * set *tmp62 *tmp64
   176 label *label49
   177 label *label47
   178 label *label19
 
   196 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp69
   197 set *tmp71 .drills
   198 op add .drills .drills 1
-    * set *tmp68 *tmp71
   199 jump *label54 always
   200 label *label53
-    * set *tmp68 null
   201 label *label54
   202 label *label52
   203 set :addTitaniumDrill*finished true

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-7 instructions):
 
   122 jump *label43 equal *tmp54 false
   123 set *tmp56 @unit
   124 set :findFreeUnit:first_unit *tmp56
-    * set *tmp55 :findFreeUnit:first_unit
   125 jump *label44 always
   126 label *label43
-    * set *tmp55 null
   127 label *label44
   128 label *label42
   129 ubind :findFreeUnit:unit_type
 
   139 op equal *tmp58 :backgroundProcess:unit null
   140 jump *label45 equal *tmp58 false
   141 jump *label19 always
-    * set *tmp59 null
   142 jump *label46 always
   143 label *label45
-    * set *tmp59 null
   144 label *label46
   145 jump *label34 always
   146 label *label33
 
   163 sensor *tmp66 :serviceDrill:drill @y
   164 ucontrol approach *tmp65 *tmp66 4
   165 ucontrol itemTake :serviceDrill:drill @titanium 10
-    * set *tmp64 null
   166 jump *label51 always
   167 label *label50
   168 ucontrol itemDrop @air 10
-    * set *tmp64 null
   169 label *label51
   170 label *label49
   171 label *label47
 
   188 jump *label53 equal *tmp67 false
   189 set *tmp69 .drills
   190 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp69
-    * set *tmp71 .drills
   191 op add .drills .drills 1
   192 jump *label54 always
   193 label *label53

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
    11 jump *label10 equal *tmp33 false
    12 label *label12
    13 ubind @flare
-    * ulocate building core false @copper .coreX .coreY *tmp36 *tmp35
-    * set .core *tmp35
+   14 ulocate building core false @copper .coreX .coreY *tmp36 .core
    15 label *label13
    16 op equal *tmp37 .core null
    17 jump *label12 notEqual *tmp37 false
    18 label *label14
-    * sensor *tmp38 .core @x
-    * set .coreX *tmp38
-    * sensor *tmp39 .core @y
-    * set .coreY *tmp39
+   19 sensor .coreX .core @x
+   20 sensor .coreY .core @y
    21 jump *label11 always
    22 label *label10
    23 label *label11
 
   117 sensor *tmp53 :findFreeUnit:first_unit @dead
   118 op equal *tmp54 *tmp53 1
   119 jump *label43 equal *tmp54 false
-    * set *tmp56 @unit
-    * set :findFreeUnit:first_unit *tmp56
+  120 set :findFreeUnit:first_unit @unit
   121 jump *label44 always
   122 label *label43
   123 label *label44
 
   145 set :serviceDrill:drill :backgroundProcess:drill
   146 set :serviceDrill:unit :backgroundProcess:unit
   147 ubind :serviceDrill:unit
-    * sensor *tmp60 @unit @firstItem
-    * set :serviceDrill:item *tmp60
+  148 sensor :serviceDrill:item @unit @firstItem
   149 op equal *tmp61 :serviceDrill:item @titanium
   150 jump *label48 equal *tmp61 false
   151 ucontrol approach .coreX .coreY 4
 
   181 # "Function: remote void addTitaniumDrill(in drill)"
   182 op lessThan *tmp67 .drills 9
   183 jump *label53 equal *tmp67 false
-    * set *tmp69 .drills
-    * writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp69
+  184 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   185 op add .drills .drills 1
   186 jump *label54 always
   187 label *label53

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    22 label *label10
    23 label *label11
    24 label *label15
-    * jump *label17 equal true false
    25 set :backgroundProcess:count 0
    26 set :backgroundProcess:drill .titaniumDrills*0
    27 set :backgroundProcess:unit .units*0

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-12 instructions):
 
     7 set *signature "881dde114374c003:v1"
     8 label *label8
     9 # "Function: void backgroundProcess()"
-    * op equal *tmp33 .core null
-    * jump *label10 equal *tmp33 false
+   10 jump *label10 notEqual .core null
    11 label *label12
    12 ubind @flare
    13 ulocate building core false @copper .coreX .coreY *tmp36 .core
    14 label *label13
-    * op equal *tmp37 .core null
-    * jump *label12 notEqual *tmp37 false
+   15 jump *label12 equal .core null
    16 label *label14
    17 sensor .coreX .core @x
    18 sensor .coreY .core @y
 
    79 set :backgroundProcess:unit .units*9
    80 set *tmp40 null
    81 label *label18
-    * op equal *tmp41 :backgroundProcess:drill null
-    * jump *label31 equal *tmp41 false
+   82 jump *label31 notEqual :backgroundProcess:drill null
    83 jump *label20 always
    84 jump *label32 always
    85 label *label31
 
    87 sensor *tmp43 :backgroundProcess:drill @titanium
    88 op add :backgroundProcess:count :backgroundProcess:count *tmp43
    89 sensor *tmp44 :backgroundProcess:unit @controller
-    * op notEqual *tmp45 *tmp44 @this
-    * jump *label33 equal *tmp45 false
+   90 jump *label33 equal *tmp44 @this
    91 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    92 set :findFreeUnit:unit_type @flare
    93 set :findFreeUnit:initial_flag 0
    94 ubind :findFreeUnit:unit_type
-    * op equal *tmp48 @unit null
-    * jump *label36 equal *tmp48 false
+   95 jump *label36 notEqual @unit null
    96 set *tmp47 null
    97 jump *label35 always
    98 jump *label37 always
 
   101 set :findFreeUnit:first_unit @unit
   102 label *label38
   103 sensor *tmp50 @unit @controlled
-    * op equal *tmp51 *tmp50 0
-    * jump *label41 equal *tmp51 false
+  104 jump *label41 notEqual *tmp50 0
   105 ucontrol flag :findFreeUnit:initial_flag
   106 set *tmp47 @unit
   107 jump *label35 always
   108 jump *label42 always
   109 label *label41
   110 sensor *tmp53 :findFreeUnit:first_unit @dead
-    * op equal *tmp54 *tmp53 1
-    * jump *label43 equal *tmp54 false
+  111 jump *label43 notEqual *tmp53 1
   112 set :findFreeUnit:first_unit @unit
   113 jump *label44 always
   114 label *label43
 
   116 label *label42
   117 ubind :findFreeUnit:unit_type
   118 label *label39
-    * op notEqual *tmp57 :findFreeUnit:first_unit @unit
-    * jump *label38 notEqual *tmp57 false
+  119 jump *label38 notEqual :findFreeUnit:first_unit @unit
   120 label *label40
   121 set *tmp47 null
   122 jump *label35 always
   123 set *tmp47 null
   124 label *label35
   125 set :backgroundProcess:unit *tmp47
-    * op equal *tmp58 :backgroundProcess:unit null
-    * jump *label45 equal *tmp58 false
+  126 jump *label45 notEqual :backgroundProcess:unit null
   127 jump *label19 always
   128 jump *label46 always
   129 label *label45
 
   136 set :serviceDrill:unit :backgroundProcess:unit
   137 ubind :serviceDrill:unit
   138 sensor :serviceDrill:item @unit @firstItem
-    * op equal *tmp61 :serviceDrill:item @titanium
-    * jump *label48 equal *tmp61 false
+  139 jump *label48 notEqual :serviceDrill:item @titanium
   140 ucontrol approach .coreX .coreY 4
   141 ucontrol itemDrop .core 10
   142 jump *label49 always
   143 label *label48
-    * op equal *tmp63 :serviceDrill:item null
-    * jump *label50 equal *tmp63 false
+  144 jump *label50 notEqual :serviceDrill:item null
   145 sensor *tmp65 :serviceDrill:drill @x
   146 sensor *tmp66 :serviceDrill:drill @y
   147 ucontrol approach *tmp65 *tmp66 4
 
   167 end
   168 label *label0
   169 # "Function: remote void addTitaniumDrill(in drill)"
-    * op lessThan *tmp67 .drills 9
-    * jump *label53 equal *tmp67 false
+  170 jump *label53 greaterThanEq .drills 9
   171 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   172 op add .drills .drills 1
   173 jump *label54 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    16 label *label14
    17 sensor .coreX .core @x
    18 sensor .coreY .core @y
-    * jump *label11 always
    19 label *label10
    20 label *label11
    21 label *label15
 
    80 label *label18
    81 jump *label31 notEqual :backgroundProcess:drill null
    82 jump *label20 always
-    * jump *label32 always
    83 label *label31
    84 label *label32
    85 sensor *tmp43 :backgroundProcess:drill @titanium
 
    93 jump *label36 notEqual @unit null
    94 set *tmp47 null
    95 jump *label35 always
-    * jump *label37 always
    96 label *label36
    97 label *label37
    98 set :findFreeUnit:first_unit @unit
 
   107 sensor *tmp53 :findFreeUnit:first_unit @dead
   108 jump *label43 notEqual *tmp53 1
   109 set :findFreeUnit:first_unit @unit
-    * jump *label44 always
   110 label *label43
   111 label *label44
   112 label *label42
 
   121 set :backgroundProcess:unit *tmp47
   122 jump *label45 notEqual :backgroundProcess:unit null
   123 jump *label19 always
-    * jump *label46 always
   124 label *label45
   125 label *label46
-    * jump *label34 always
   126 label *label33
   127 label *label34
   128 # "Function: void serviceDrill(in drill, in unit)"
 
   164 jump *label53 greaterThanEq .drills 9
   165 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   166 op add .drills .drills 1
-    * jump *label54 always
   167 label *label53
   168 label *label54
   169 label *label52

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    89 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    90 set :findFreeUnit:unit_type @flare
    91 set :findFreeUnit:initial_flag 0
-    * ubind :findFreeUnit:unit_type
+   92 ubind @flare
    93 jump *label36 notEqual @unit null
    94 set *tmp47 null
    95 jump *label35 always
 
    99 label *label38
   100 sensor *tmp50 @unit @controlled
   101 jump *label41 notEqual *tmp50 0
-    * ucontrol flag :findFreeUnit:initial_flag
+  102 ucontrol flag 0
   103 set *tmp47 @unit
   104 jump *label35 always
   105 jump *label42 always
 
   110 label *label43
   111 label *label44
   112 label *label42
-    * ubind :findFreeUnit:unit_type
+  113 ubind @flare
   114 label *label39
   115 jump *label38 notEqual :findFreeUnit:first_unit @unit
   116 label *label40
   117 set *tmp47 null
   118 jump *label35 always
-    * set *tmp47 null
   119 label *label35
   120 set :backgroundProcess:unit *tmp47
-    * jump *label45 notEqual :backgroundProcess:unit null
+  121 jump *label45 notEqual *tmp47 null
   122 jump *label19 always
   123 label *label45
   124 label *label46
 
   127 # "Function: void serviceDrill(in drill, in unit)"
   128 set :serviceDrill:drill :backgroundProcess:drill
   129 set :serviceDrill:unit :backgroundProcess:unit
-    * ubind :serviceDrill:unit
+  130 ubind :backgroundProcess:unit
   131 sensor :serviceDrill:item @unit @firstItem
   132 jump *label48 notEqual :serviceDrill:item @titanium
   133 ucontrol approach .coreX .coreY 4
 
   135 jump *label49 always
   136 label *label48
   137 jump *label50 notEqual :serviceDrill:item null
-    * sensor *tmp65 :serviceDrill:drill @x
-    * sensor *tmp66 :serviceDrill:drill @y
+  138 sensor *tmp65 :backgroundProcess:drill @x
+  139 sensor *tmp66 :backgroundProcess:drill @y
   140 ucontrol approach *tmp65 *tmp66 4
-    * ucontrol itemTake :serviceDrill:drill @titanium 10
+  141 ucontrol itemTake :backgroundProcess:drill @titanium 10
   142 jump *label51 always
   143 label *label50
   144 ucontrol itemDrop @air 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    87 sensor *tmp44 :backgroundProcess:unit @controller
    88 jump *label33 equal *tmp44 @this
    89 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * set :findFreeUnit:unit_type @flare
-    * set :findFreeUnit:initial_flag 0
    90 ubind @flare
    91 jump *label36 notEqual @unit null
    92 set *tmp47 null
 
   123 label *label33
   124 label *label34
   125 # "Function: void serviceDrill(in drill, in unit)"
-    * set :serviceDrill:drill :backgroundProcess:drill
-    * set :serviceDrill:unit :backgroundProcess:unit
   126 ubind :backgroundProcess:unit
   127 sensor :serviceDrill:item @unit @firstItem
   128 jump *label48 notEqual :serviceDrill:item @titanium

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   102 jump *label35 always
   103 jump *label42 always
   104 label *label41
-    * sensor *tmp53 :findFreeUnit:first_unit @dead
-    * jump *label43 notEqual *tmp53 1
-    * set :findFreeUnit:first_unit @unit
-    * label *label43
-    * label *label44
+  105 sensor *tmp53 :findFreeUnit:first_unit @dead
+  106 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   107 label *label42
   108 ubind @flare
   109 label *label39

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
 
   154 label *label0
   155 # "Function: remote void addTitaniumDrill(in drill)"
   156 jump *label53 greaterThanEq .drills 9
-    * writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  157 writearr<inlined> :addTitaniumDrill:drill .titaniumDrills[] .drills
   158 op add .drills .drills 1
   159 label *label53
   160 label *label54

Modifications by Unroll iteration loop at FlareController.mnd:63:9 (+331 instructions):
 
    20 label *label11
    21 label *label15
    22 set :backgroundProcess:count 0
-    * set :backgroundProcess:drill .titaniumDrills*0
-    * set :backgroundProcess:unit .units*0
-    * op add *tmp40 @counter 1
-    * jump *label18 always
-    * multilabel *label21 (m:marker0)
-    * set .units*0 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*1
-    * set :backgroundProcess:unit .units*1
-    * op add *tmp40 @counter 1
-    * jump *label18 always
-    * multilabel *label22 (m:marker0)
-    * set .units*1 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*2
-    * set :backgroundProcess:unit .units*2
-    * op add *tmp40 @counter 1
-    * jump *label18 always
-    * multilabel *label23 (m:marker0)
-    * set .units*2 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*3
-    * set :backgroundProcess:unit .units*3
-    * op add *tmp40 @counter 1
-    * jump *label18 always
-    * multilabel *label24 (m:marker0)
-    * set .units*3 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*4
-    * set :backgroundProcess:unit .units*4
-    * op add *tmp40 @counter 1
-    * jump *label18 always
-    * multilabel *label25 (m:marker0)
-    * set .units*4 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*5
-    * set :backgroundProcess:unit .units*5
-    * op add *tmp40 @counter 1
-    * jump *label18 always
-    * multilabel *label26 (m:marker0)
-    * set .units*5 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*6
-    * set :backgroundProcess:unit .units*6
-    * op add *tmp40 @counter 1
-    * jump *label18 always
-    * multilabel *label27 (m:marker0)
-    * set .units*6 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*7
-    * set :backgroundProcess:unit .units*7
-    * op add *tmp40 @counter 1
-    * jump *label18 always
-    * multilabel *label28 (m:marker0)
-    * set .units*7 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*8
-    * set :backgroundProcess:unit .units*8
-    * op add *tmp40 @counter 1
-    * jump *label18 always
-    * multilabel *label29 (m:marker0)
-    * set .units*8 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*9
-    * set :backgroundProcess:unit .units*9
-    * set *tmp40 null
-    * label *label18
-    * jump *label31 notEqual :backgroundProcess:drill null
-    * jump *label20 always
-    * label *label31
-    * label *label32
-    * sensor *tmp43 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count :backgroundProcess:count *tmp43
-    * sensor *tmp44 :backgroundProcess:unit @controller
-    * jump *label33 equal *tmp44 @this
-    * # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * ubind @flare
-    * jump *label36 notEqual @unit null
-    * set *tmp47 null
-    * jump *label35 always
-    * label *label36
-    * label *label37
-    * set :findFreeUnit:first_unit @unit
-    * label *label38
-    * sensor *tmp50 @unit @controlled
-    * jump *label41 notEqual *tmp50 0
-    * ucontrol flag 0
-    * set *tmp47 @unit
-    * jump *label35 always
-    * jump *label42 always
-    * label *label41
-    * sensor *tmp53 :findFreeUnit:first_unit @dead
-    * select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label42
-    * ubind @flare
-    * label *label39
-    * jump *label38 notEqual :findFreeUnit:first_unit @unit
-    * label *label40
-    * set *tmp47 null
-    * jump *label35 always
-    * label *label35
-    * set :backgroundProcess:unit *tmp47
-    * jump *label45 notEqual *tmp47 null
-    * jump *label19 always
-    * label *label45
-    * label *label46
-    * label *label33
-    * label *label34
-    * # "Function: void serviceDrill(in drill, in unit)"
-    * ubind :backgroundProcess:unit
-    * sensor :serviceDrill:item @unit @firstItem
-    * jump *label48 notEqual :serviceDrill:item @titanium
-    * ucontrol approach .coreX .coreY 4
-    * ucontrol itemDrop .core 10
-    * jump *label49 always
-    * label *label48
-    * jump *label50 notEqual :serviceDrill:item null
-    * sensor *tmp65 :backgroundProcess:drill @x
-    * sensor *tmp66 :backgroundProcess:drill @y
-    * ucontrol approach *tmp65 *tmp66 4
-    * ucontrol itemTake :backgroundProcess:drill @titanium 10
-    * jump *label51 always
-    * label *label50
-    * ucontrol itemDrop @air 10
-    * label *label51
-    * label *label49
-    * label *label47
-    * label *label19
-    * multijump *tmp40 0 0 (m:marker0)
-    * multilabel *label30 (m:marker0)
-    * set .units*9 :backgroundProcess:unit
-    * label *label20
+   23 set :backgroundProcess:drill .titaniumDrills*0
+   24 set :backgroundProcess:unit .units*0
+   25 label *label55
+   26 jump *label56 notEqual :backgroundProcess:drill null
+   27 jump *label20 always
+   28 label *label56
+   29 label *label57
+   30 sensor *tmp43 :backgroundProcess:drill @titanium
+   31 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+   32 sensor *tmp44 :backgroundProcess:unit @controller
+   33 jump *label68 equal *tmp44 @this
+   34 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+   35 ubind @flare
+   36 jump *label58 notEqual @unit null
+   37 set *tmp47 null
+   38 jump *label65 always
+   39 label *label58
+   40 label *label59
+   41 set :findFreeUnit:first_unit @unit
+   42 label *label60
+   43 sensor *tmp50 @unit @controlled
+   44 jump *label61 notEqual *tmp50 0
+   45 ucontrol flag 0
+   46 set *tmp47 @unit
+   47 jump *label65 always
+   48 jump *label62 always
+   49 label *label61
+   50 sensor *tmp53 :findFreeUnit:first_unit @dead
+   51 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+   52 label *label62
+   53 ubind @flare
+   54 label *label63
+   55 jump *label60 notEqual :findFreeUnit:first_unit @unit
+   56 label *label64
+   57 set *tmp47 null
+   58 jump *label65 always
+   59 label *label65
+   60 set :backgroundProcess:unit *tmp47
+   61 jump *label66 notEqual *tmp47 null
+   62 jump *label75 always
+   63 label *label66
+   64 label *label67
+   65 label *label68
+   66 label *label69
+   67 # "Function: void serviceDrill(in drill, in unit)"
+   68 ubind :backgroundProcess:unit
+   69 sensor :serviceDrill:item @unit @firstItem
+   70 jump *label70 notEqual :serviceDrill:item @titanium
+   71 ucontrol approach .coreX .coreY 4
+   72 ucontrol itemDrop .core 10
+   73 jump *label73 always
+   74 label *label70
+   75 jump *label71 notEqual :serviceDrill:item null
+   76 sensor *tmp65 :backgroundProcess:drill @x
+   77 sensor *tmp66 :backgroundProcess:drill @y
+   78 ucontrol approach *tmp65 *tmp66 4
+   79 ucontrol itemTake :backgroundProcess:drill @titanium 10
+   80 jump *label72 always
+   81 label *label71
+   82 ucontrol itemDrop @air 10
+   83 label *label72
+   84 label *label73
+   85 label *label74
+   86 label *label75
+   87 set .units*0 :backgroundProcess:unit
+   88 set :backgroundProcess:drill .titaniumDrills*1
+   89 set :backgroundProcess:unit .units*1
+   90 label *label78
+   91 jump *label79 notEqual :backgroundProcess:drill null
+   92 jump *label20 always
+   93 label *label79
+   94 label *label80
+   95 sensor *tmp43 :backgroundProcess:drill @titanium
+   96 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+   97 sensor *tmp44 :backgroundProcess:unit @controller
+   98 jump *label91 equal *tmp44 @this
+   99 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  100 ubind @flare
+  101 jump *label81 notEqual @unit null
+  102 set *tmp47 null
+  103 jump *label88 always
+  104 label *label81
+  105 label *label82
+  106 set :findFreeUnit:first_unit @unit
+  107 label *label83
+  108 sensor *tmp50 @unit @controlled
+  109 jump *label84 notEqual *tmp50 0
+  110 ucontrol flag 0
+  111 set *tmp47 @unit
+  112 jump *label88 always
+  113 jump *label85 always
+  114 label *label84
+  115 sensor *tmp53 :findFreeUnit:first_unit @dead
+  116 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  117 label *label85
+  118 ubind @flare
+  119 label *label86
+  120 jump *label83 notEqual :findFreeUnit:first_unit @unit
+  121 label *label87
+  122 set *tmp47 null
+  123 jump *label88 always
+  124 label *label88
+  125 set :backgroundProcess:unit *tmp47
+  126 jump *label89 notEqual *tmp47 null
+  127 jump *label98 always
+  128 label *label89
+  129 label *label90
+  130 label *label91
+  131 label *label92
+  132 # "Function: void serviceDrill(in drill, in unit)"
+  133 ubind :backgroundProcess:unit
+  134 sensor :serviceDrill:item @unit @firstItem
+  135 jump *label93 notEqual :serviceDrill:item @titanium
+  136 ucontrol approach .coreX .coreY 4
+  137 ucontrol itemDrop .core 10
+  138 jump *label96 always
+  139 label *label93
+  140 jump *label94 notEqual :serviceDrill:item null
+  141 sensor *tmp65 :backgroundProcess:drill @x
+  142 sensor *tmp66 :backgroundProcess:drill @y
+  143 ucontrol approach *tmp65 *tmp66 4
+  144 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  145 jump *label95 always
+  146 label *label94
+  147 ucontrol itemDrop @air 10
+  148 label *label95
+  149 label *label96
+  150 label *label97
+  151 label *label98
+  152 set .units*1 :backgroundProcess:unit
+  153 set :backgroundProcess:drill .titaniumDrills*2
+  154 set :backgroundProcess:unit .units*2
+  155 label *label101
+  156 jump *label102 notEqual :backgroundProcess:drill null
+  157 jump *label20 always
+  158 label *label102
+  159 label *label103
+  160 sensor *tmp43 :backgroundProcess:drill @titanium
+  161 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  162 sensor *tmp44 :backgroundProcess:unit @controller
+  163 jump *label114 equal *tmp44 @this
+  164 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  165 ubind @flare
+  166 jump *label104 notEqual @unit null
+  167 set *tmp47 null
+  168 jump *label111 always
+  169 label *label104
+  170 label *label105
+  171 set :findFreeUnit:first_unit @unit
+  172 label *label106
+  173 sensor *tmp50 @unit @controlled
+  174 jump *label107 notEqual *tmp50 0
+  175 ucontrol flag 0
+  176 set *tmp47 @unit
+  177 jump *label111 always
+  178 jump *label108 always
+  179 label *label107
+  180 sensor *tmp53 :findFreeUnit:first_unit @dead
+  181 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  182 label *label108
+  183 ubind @flare
+  184 label *label109
+  185 jump *label106 notEqual :findFreeUnit:first_unit @unit
+  186 label *label110
+  187 set *tmp47 null
+  188 jump *label111 always
+  189 label *label111
+  190 set :backgroundProcess:unit *tmp47
+  191 jump *label112 notEqual *tmp47 null
+  192 jump *label121 always
+  193 label *label112
+  194 label *label113
+  195 label *label114
+  196 label *label115
+  197 # "Function: void serviceDrill(in drill, in unit)"
+  198 ubind :backgroundProcess:unit
+  199 sensor :serviceDrill:item @unit @firstItem
+  200 jump *label116 notEqual :serviceDrill:item @titanium
+  201 ucontrol approach .coreX .coreY 4
+  202 ucontrol itemDrop .core 10
+  203 jump *label119 always
+  204 label *label116
+  205 jump *label117 notEqual :serviceDrill:item null
+  206 sensor *tmp65 :backgroundProcess:drill @x
+  207 sensor *tmp66 :backgroundProcess:drill @y
+  208 ucontrol approach *tmp65 *tmp66 4
+  209 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  210 jump *label118 always
+  211 label *label117
+  212 ucontrol itemDrop @air 10
+  213 label *label118
+  214 label *label119
+  215 label *label120
+  216 label *label121
+  217 set .units*2 :backgroundProcess:unit
+  218 set :backgroundProcess:drill .titaniumDrills*3
+  219 set :backgroundProcess:unit .units*3
+  220 label *label124
+  221 jump *label125 notEqual :backgroundProcess:drill null
+  222 jump *label20 always
+  223 label *label125
+  224 label *label126
+  225 sensor *tmp43 :backgroundProcess:drill @titanium
+  226 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  227 sensor *tmp44 :backgroundProcess:unit @controller
+  228 jump *label137 equal *tmp44 @this
+  229 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  230 ubind @flare
+  231 jump *label127 notEqual @unit null
+  232 set *tmp47 null
+  233 jump *label134 always
+  234 label *label127
+  235 label *label128
+  236 set :findFreeUnit:first_unit @unit
+  237 label *label129
+  238 sensor *tmp50 @unit @controlled
+  239 jump *label130 notEqual *tmp50 0
+  240 ucontrol flag 0
+  241 set *tmp47 @unit
+  242 jump *label134 always
+  243 jump *label131 always
+  244 label *label130
+  245 sensor *tmp53 :findFreeUnit:first_unit @dead
+  246 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  247 label *label131
+  248 ubind @flare
+  249 label *label132
+  250 jump *label129 notEqual :findFreeUnit:first_unit @unit
+  251 label *label133
+  252 set *tmp47 null
+  253 jump *label134 always
+  254 label *label134
+  255 set :backgroundProcess:unit *tmp47
+  256 jump *label135 notEqual *tmp47 null
+  257 jump *label144 always
+  258 label *label135
+  259 label *label136
+  260 label *label137
+  261 label *label138
+  262 # "Function: void serviceDrill(in drill, in unit)"
+  263 ubind :backgroundProcess:unit
+  264 sensor :serviceDrill:item @unit @firstItem
+  265 jump *label139 notEqual :serviceDrill:item @titanium
+  266 ucontrol approach .coreX .coreY 4
+  267 ucontrol itemDrop .core 10
+  268 jump *label142 always
+  269 label *label139
+  270 jump *label140 notEqual :serviceDrill:item null
+  271 sensor *tmp65 :backgroundProcess:drill @x
+  272 sensor *tmp66 :backgroundProcess:drill @y
+  273 ucontrol approach *tmp65 *tmp66 4
+  274 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  275 jump *label141 always
+  276 label *label140
+  277 ucontrol itemDrop @air 10
+  278 label *label141
+  279 label *label142
+  280 label *label143
+  281 label *label144
+  282 set .units*3 :backgroundProcess:unit
+  283 set :backgroundProcess:drill .titaniumDrills*4
+  284 set :backgroundProcess:unit .units*4
+  285 label *label147
+  286 jump *label148 notEqual :backgroundProcess:drill null
+  287 jump *label20 always
+  288 label *label148
+  289 label *label149
+  290 sensor *tmp43 :backgroundProcess:drill @titanium
+  291 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  292 sensor *tmp44 :backgroundProcess:unit @controller
+  293 jump *label160 equal *tmp44 @this
+  294 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  295 ubind @flare
+  296 jump *label150 notEqual @unit null
+  297 set *tmp47 null
+  298 jump *label157 always
+  299 label *label150
+  300 label *label151
+  301 set :findFreeUnit:first_unit @unit
+  302 label *label152
+  303 sensor *tmp50 @unit @controlled
+  304 jump *label153 notEqual *tmp50 0
+  305 ucontrol flag 0
+  306 set *tmp47 @unit
+  307 jump *label157 always
+  308 jump *label154 always
+  309 label *label153
+  310 sensor *tmp53 :findFreeUnit:first_unit @dead
+  311 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  312 label *label154
+  313 ubind @flare
+  314 label *label155
+  315 jump *label152 notEqual :findFreeUnit:first_unit @unit
+  316 label *label156
+  317 set *tmp47 null
+  318 jump *label157 always
+  319 label *label157
+  320 set :backgroundProcess:unit *tmp47
+  321 jump *label158 notEqual *tmp47 null
+  322 jump *label167 always
+  323 label *label158
+  324 label *label159
+  325 label *label160
+  326 label *label161
+  327 # "Function: void serviceDrill(in drill, in unit)"
+  328 ubind :backgroundProcess:unit
+  329 sensor :serviceDrill:item @unit @firstItem
+  330 jump *label162 notEqual :serviceDrill:item @titanium
+  331 ucontrol approach .coreX .coreY 4
+  332 ucontrol itemDrop .core 10
+  333 jump *label165 always
+  334 label *label162
+  335 jump *label163 notEqual :serviceDrill:item null
+  336 sensor *tmp65 :backgroundProcess:drill @x
+  337 sensor *tmp66 :backgroundProcess:drill @y
+  338 ucontrol approach *tmp65 *tmp66 4
+  339 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  340 jump *label164 always
+  341 label *label163
+  342 ucontrol itemDrop @air 10
+  343 label *label164
+  344 label *label165
+  345 label *label166
+  346 label *label167
+  347 set .units*4 :backgroundProcess:unit
+  348 set :backgroundProcess:drill .titaniumDrills*5
+  349 set :backgroundProcess:unit .units*5
+  350 label *label170
+  351 jump *label171 notEqual :backgroundProcess:drill null
+  352 jump *label20 always
+  353 label *label171
+  354 label *label172
+  355 sensor *tmp43 :backgroundProcess:drill @titanium
+  356 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  357 sensor *tmp44 :backgroundProcess:unit @controller
+  358 jump *label183 equal *tmp44 @this
+  359 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  360 ubind @flare
+  361 jump *label173 notEqual @unit null
+  362 set *tmp47 null
+  363 jump *label180 always
+  364 label *label173
+  365 label *label174
+  366 set :findFreeUnit:first_unit @unit
+  367 label *label175
+  368 sensor *tmp50 @unit @controlled
+  369 jump *label176 notEqual *tmp50 0
+  370 ucontrol flag 0
+  371 set *tmp47 @unit
+  372 jump *label180 always
+  373 jump *label177 always
+  374 label *label176
+  375 sensor *tmp53 :findFreeUnit:first_unit @dead
+  376 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  377 label *label177
+  378 ubind @flare
+  379 label *label178
+  380 jump *label175 notEqual :findFreeUnit:first_unit @unit
+  381 label *label179
+  382 set *tmp47 null
+  383 jump *label180 always
+  384 label *label180
+  385 set :backgroundProcess:unit *tmp47
+  386 jump *label181 notEqual *tmp47 null
+  387 jump *label190 always
+  388 label *label181
+  389 label *label182
+  390 label *label183
+  391 label *label184
+  392 # "Function: void serviceDrill(in drill, in unit)"
+  393 ubind :backgroundProcess:unit
+  394 sensor :serviceDrill:item @unit @firstItem
+  395 jump *label185 notEqual :serviceDrill:item @titanium
+  396 ucontrol approach .coreX .coreY 4
+  397 ucontrol itemDrop .core 10
+  398 jump *label188 always
+  399 label *label185
+  400 jump *label186 notEqual :serviceDrill:item null
+  401 sensor *tmp65 :backgroundProcess:drill @x
+  402 sensor *tmp66 :backgroundProcess:drill @y
+  403 ucontrol approach *tmp65 *tmp66 4
+  404 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  405 jump *label187 always
+  406 label *label186
+  407 ucontrol itemDrop @air 10
+  408 label *label187
+  409 label *label188
+  410 label *label189
+  411 label *label190
+  412 set .units*5 :backgroundProcess:unit
+  413 set :backgroundProcess:drill .titaniumDrills*6
+  414 set :backgroundProcess:unit .units*6
+  415 label *label193
+  416 jump *label194 notEqual :backgroundProcess:drill null
+  417 jump *label20 always
+  418 label *label194
+  419 label *label195
+  420 sensor *tmp43 :backgroundProcess:drill @titanium
+  421 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  422 sensor *tmp44 :backgroundProcess:unit @controller
+  423 jump *label206 equal *tmp44 @this
+  424 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  425 ubind @flare
+  426 jump *label196 notEqual @unit null
+  427 set *tmp47 null
+  428 jump *label203 always
+  429 label *label196
+  430 label *label197
+  431 set :findFreeUnit:first_unit @unit
+  432 label *label198
+  433 sensor *tmp50 @unit @controlled
+  434 jump *label199 notEqual *tmp50 0
+  435 ucontrol flag 0
+  436 set *tmp47 @unit
+  437 jump *label203 always
+  438 jump *label200 always
+  439 label *label199
+  440 sensor *tmp53 :findFreeUnit:first_unit @dead
+  441 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  442 label *label200
+  443 ubind @flare
+  444 label *label201
+  445 jump *label198 notEqual :findFreeUnit:first_unit @unit
+  446 label *label202
+  447 set *tmp47 null
+  448 jump *label203 always
+  449 label *label203
+  450 set :backgroundProcess:unit *tmp47
+  451 jump *label204 notEqual *tmp47 null
+  452 jump *label213 always
+  453 label *label204
+  454 label *label205
+  455 label *label206
+  456 label *label207
+  457 # "Function: void serviceDrill(in drill, in unit)"
+  458 ubind :backgroundProcess:unit
+  459 sensor :serviceDrill:item @unit @firstItem
+  460 jump *label208 notEqual :serviceDrill:item @titanium
+  461 ucontrol approach .coreX .coreY 4
+  462 ucontrol itemDrop .core 10
+  463 jump *label211 always
+  464 label *label208
+  465 jump *label209 notEqual :serviceDrill:item null
+  466 sensor *tmp65 :backgroundProcess:drill @x
+  467 sensor *tmp66 :backgroundProcess:drill @y
+  468 ucontrol approach *tmp65 *tmp66 4
+  469 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  470 jump *label210 always
+  471 label *label209
+  472 ucontrol itemDrop @air 10
+  473 label *label210
+  474 label *label211
+  475 label *label212
+  476 label *label213
+  477 set .units*6 :backgroundProcess:unit
+  478 set :backgroundProcess:drill .titaniumDrills*7
+  479 set :backgroundProcess:unit .units*7
+  480 label *label216
+  481 jump *label217 notEqual :backgroundProcess:drill null
+  482 jump *label20 always
+  483 label *label217
+  484 label *label218
+  485 sensor *tmp43 :backgroundProcess:drill @titanium
+  486 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  487 sensor *tmp44 :backgroundProcess:unit @controller
+  488 jump *label229 equal *tmp44 @this
+  489 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  490 ubind @flare
+  491 jump *label219 notEqual @unit null
+  492 set *tmp47 null
+  493 jump *label226 always
+  494 label *label219
+  495 label *label220
+  496 set :findFreeUnit:first_unit @unit
+  497 label *label221
+  498 sensor *tmp50 @unit @controlled
+  499 jump *label222 notEqual *tmp50 0
+  500 ucontrol flag 0
+  501 set *tmp47 @unit
+  502 jump *label226 always
+  503 jump *label223 always
+  504 label *label222
+  505 sensor *tmp53 :findFreeUnit:first_unit @dead
+  506 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  507 label *label223
+  508 ubind @flare
+  509 label *label224
+  510 jump *label221 notEqual :findFreeUnit:first_unit @unit
+  511 label *label225
+  512 set *tmp47 null
+  513 jump *label226 always
+  514 label *label226
+  515 set :backgroundProcess:unit *tmp47
+  516 jump *label227 notEqual *tmp47 null
+  517 jump *label236 always
+  518 label *label227
+  519 label *label228
+  520 label *label229
+  521 label *label230
+  522 # "Function: void serviceDrill(in drill, in unit)"
+  523 ubind :backgroundProcess:unit
+  524 sensor :serviceDrill:item @unit @firstItem
+  525 jump *label231 notEqual :serviceDrill:item @titanium
+  526 ucontrol approach .coreX .coreY 4
+  527 ucontrol itemDrop .core 10
+  528 jump *label234 always
+  529 label *label231
+  530 jump *label232 notEqual :serviceDrill:item null
+  531 sensor *tmp65 :backgroundProcess:drill @x
+  532 sensor *tmp66 :backgroundProcess:drill @y
+  533 ucontrol approach *tmp65 *tmp66 4
+  534 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  535 jump *label233 always
+  536 label *label232
+  537 ucontrol itemDrop @air 10
+  538 label *label233
+  539 label *label234
+  540 label *label235
+  541 label *label236
+  542 set .units*7 :backgroundProcess:unit
+  543 set :backgroundProcess:drill .titaniumDrills*8
+  544 set :backgroundProcess:unit .units*8
+  545 label *label239
+  546 jump *label240 notEqual :backgroundProcess:drill null
+  547 jump *label20 always
+  548 label *label240
+  549 label *label241
+  550 sensor *tmp43 :backgroundProcess:drill @titanium
+  551 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  552 sensor *tmp44 :backgroundProcess:unit @controller
+  553 jump *label252 equal *tmp44 @this
+  554 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  555 ubind @flare
+  556 jump *label242 notEqual @unit null
+  557 set *tmp47 null
+  558 jump *label249 always
+  559 label *label242
+  560 label *label243
+  561 set :findFreeUnit:first_unit @unit
+  562 label *label244
+  563 sensor *tmp50 @unit @controlled
+  564 jump *label245 notEqual *tmp50 0
+  565 ucontrol flag 0
+  566 set *tmp47 @unit
+  567 jump *label249 always
+  568 jump *label246 always
+  569 label *label245
+  570 sensor *tmp53 :findFreeUnit:first_unit @dead
+  571 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  572 label *label246
+  573 ubind @flare
+  574 label *label247
+  575 jump *label244 notEqual :findFreeUnit:first_unit @unit
+  576 label *label248
+  577 set *tmp47 null
+  578 jump *label249 always
+  579 label *label249
+  580 set :backgroundProcess:unit *tmp47
+  581 jump *label250 notEqual *tmp47 null
+  582 jump *label259 always
+  583 label *label250
+  584 label *label251
+  585 label *label252
+  586 label *label253
+  587 # "Function: void serviceDrill(in drill, in unit)"
+  588 ubind :backgroundProcess:unit
+  589 sensor :serviceDrill:item @unit @firstItem
+  590 jump *label254 notEqual :serviceDrill:item @titanium
+  591 ucontrol approach .coreX .coreY 4
+  592 ucontrol itemDrop .core 10
+  593 jump *label257 always
+  594 label *label254
+  595 jump *label255 notEqual :serviceDrill:item null
+  596 sensor *tmp65 :backgroundProcess:drill @x
+  597 sensor *tmp66 :backgroundProcess:drill @y
+  598 ucontrol approach *tmp65 *tmp66 4
+  599 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  600 jump *label256 always
+  601 label *label255
+  602 ucontrol itemDrop @air 10
+  603 label *label256
+  604 label *label257
+  605 label *label258
+  606 label *label259
+  607 set .units*8 :backgroundProcess:unit
+  608 set :backgroundProcess:drill .titaniumDrills*9
+  609 set :backgroundProcess:unit .units*9
+  610 label *label262
+  611 jump *label263 notEqual :backgroundProcess:drill null
+  612 jump *label20 always
+  613 label *label263
+  614 label *label264
+  615 sensor *tmp43 :backgroundProcess:drill @titanium
+  616 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  617 sensor *tmp44 :backgroundProcess:unit @controller
+  618 jump *label275 equal *tmp44 @this
+  619 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  620 ubind @flare
+  621 jump *label265 notEqual @unit null
+  622 set *tmp47 null
+  623 jump *label272 always
+  624 label *label265
+  625 label *label266
+  626 set :findFreeUnit:first_unit @unit
+  627 label *label267
+  628 sensor *tmp50 @unit @controlled
+  629 jump *label268 notEqual *tmp50 0
+  630 ucontrol flag 0
+  631 set *tmp47 @unit
+  632 jump *label272 always
+  633 jump *label269 always
+  634 label *label268
+  635 sensor *tmp53 :findFreeUnit:first_unit @dead
+  636 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  637 label *label269
+  638 ubind @flare
+  639 label *label270
+  640 jump *label267 notEqual :findFreeUnit:first_unit @unit
+  641 label *label271
+  642 set *tmp47 null
+  643 jump *label272 always
+  644 label *label272
+  645 set :backgroundProcess:unit *tmp47
+  646 jump *label273 notEqual *tmp47 null
+  647 jump *label282 always
+  648 label *label273
+  649 label *label274
+  650 label *label275
+  651 label *label276
+  652 # "Function: void serviceDrill(in drill, in unit)"
+  653 ubind :backgroundProcess:unit
+  654 sensor :serviceDrill:item @unit @firstItem
+  655 jump *label277 notEqual :serviceDrill:item @titanium
+  656 ucontrol approach .coreX .coreY 4
+  657 ucontrol itemDrop .core 10
+  658 jump *label280 always
+  659 label *label277
+  660 jump *label278 notEqual :serviceDrill:item null
+  661 sensor *tmp65 :backgroundProcess:drill @x
+  662 sensor *tmp66 :backgroundProcess:drill @y
+  663 ucontrol approach *tmp65 *tmp66 4
+  664 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  665 jump *label279 always
+  666 label *label278
+  667 ucontrol itemDrop @air 10
+  668 label *label279
+  669 label *label280
+  670 label *label281
+  671 label *label282
+  672 set .units*9 :backgroundProcess:unit
+  673 label *label20
   674 write :backgroundProcess:count processor2 ".titaniumDrillCount"
   675 label *label16
   676 jump *label15 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    28 label *label56
    29 label *label57
    30 sensor *tmp43 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count :backgroundProcess:count *tmp43
+   31 op add :backgroundProcess:count 0 *tmp43
    32 sensor *tmp44 :backgroundProcess:unit @controller
    33 jump *label68 equal *tmp44 @this
    34 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-10 instructions):
 
    55 jump *label60 notEqual :findFreeUnit:first_unit @unit
    56 label *label64
    57 set *tmp47 null
-    * jump *label65 always
    58 label *label65
    59 set :backgroundProcess:unit *tmp47
    60 jump *label66 notEqual *tmp47 null
 
   119 jump *label83 notEqual :findFreeUnit:first_unit @unit
   120 label *label87
   121 set *tmp47 null
-    * jump *label88 always
   122 label *label88
   123 set :backgroundProcess:unit *tmp47
   124 jump *label89 notEqual *tmp47 null
 
   183 jump *label106 notEqual :findFreeUnit:first_unit @unit
   184 label *label110
   185 set *tmp47 null
-    * jump *label111 always
   186 label *label111
   187 set :backgroundProcess:unit *tmp47
   188 jump *label112 notEqual *tmp47 null
 
   247 jump *label129 notEqual :findFreeUnit:first_unit @unit
   248 label *label133
   249 set *tmp47 null
-    * jump *label134 always
   250 label *label134
   251 set :backgroundProcess:unit *tmp47
   252 jump *label135 notEqual *tmp47 null
 
   311 jump *label152 notEqual :findFreeUnit:first_unit @unit
   312 label *label156
   313 set *tmp47 null
-    * jump *label157 always
   314 label *label157
   315 set :backgroundProcess:unit *tmp47
   316 jump *label158 notEqual *tmp47 null
 
   375 jump *label175 notEqual :findFreeUnit:first_unit @unit
   376 label *label179
   377 set *tmp47 null
-    * jump *label180 always
   378 label *label180
   379 set :backgroundProcess:unit *tmp47
   380 jump *label181 notEqual *tmp47 null
 
   439 jump *label198 notEqual :findFreeUnit:first_unit @unit
   440 label *label202
   441 set *tmp47 null
-    * jump *label203 always
   442 label *label203
   443 set :backgroundProcess:unit *tmp47
   444 jump *label204 notEqual *tmp47 null
 
   503 jump *label221 notEqual :findFreeUnit:first_unit @unit
   504 label *label225
   505 set *tmp47 null
-    * jump *label226 always
   506 label *label226
   507 set :backgroundProcess:unit *tmp47
   508 jump *label227 notEqual *tmp47 null
 
   567 jump *label244 notEqual :findFreeUnit:first_unit @unit
   568 label *label248
   569 set *tmp47 null
-    * jump *label249 always
   570 label *label249
   571 set :backgroundProcess:unit *tmp47
   572 jump *label250 notEqual *tmp47 null
 
   631 jump *label267 notEqual :findFreeUnit:first_unit @unit
   632 label *label271
   633 set *tmp47 null
-    * jump *label272 always
   634 label *label272
   635 set :backgroundProcess:unit *tmp47
   636 jump *label273 notEqual *tmp47 null

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    28 label *label56
    29 label *label57
    30 sensor *tmp43 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count 0 *tmp43
+   31 set :backgroundProcess:count *tmp43
    32 sensor *tmp44 :backgroundProcess:unit @controller
    33 jump *label68 equal *tmp44 @this
    34 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Virtual Instruction Expansion (+1 instructions):
 
   672 label *label0
   673 # "Function: remote void addTitaniumDrill(in drill)"
   674 jump *label53 greaterThanEq .drills 9
-    * writearr<inlined> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  675 op mul *tmp159 .drills 2
+  676 multijump *label287 *tmp159 0 (m:marker1)
+  677 multilabel *label287 (m:marker1)
+  678 set .titaniumDrills*0 :addTitaniumDrill:drill
+  679 jump *label286 always
+  680 multilabel *label288 (m:marker1)
+  681 set .titaniumDrills*1 :addTitaniumDrill:drill
+  682 jump *label286 always
+  683 multilabel *label289 (m:marker1)
+  684 set .titaniumDrills*2 :addTitaniumDrill:drill
+  685 jump *label286 always
+  686 multilabel *label290 (m:marker1)
+  687 set .titaniumDrills*3 :addTitaniumDrill:drill
+  688 jump *label286 always
+  689 multilabel *label291 (m:marker1)
+  690 set .titaniumDrills*4 :addTitaniumDrill:drill
+  691 jump *label286 always
+  692 multilabel *label292 (m:marker1)
+  693 set .titaniumDrills*5 :addTitaniumDrill:drill
+  694 jump *label286 always
+  695 multilabel *label293 (m:marker1)
+  696 set .titaniumDrills*6 :addTitaniumDrill:drill
+  697 jump *label286 always
+  698 multilabel *label294 (m:marker1)
+  699 set .titaniumDrills*7 :addTitaniumDrill:drill
+  700 jump *label286 always
+  701 multilabel *label295 (m:marker1)
+  702 set .titaniumDrills*8 :addTitaniumDrill:drill
+  703 jump *label286 always
+  704 multilabel *label296 (m:marker1)
+  705 set .titaniumDrills*9 :addTitaniumDrill:drill
+  706 jump *label286 always
+  707 label *label286
   708 op add .drills .drills 1
   709 label *label53
   710 label *label54

Modifications by Iterated phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   703 jump *label286 always
   704 multilabel *label296 (m:marker1)
   705 set .titaniumDrills*9 :addTitaniumDrill:drill
-    * jump *label286 always
   706 label *label286
   707 op add .drills .drills 1
   708 label *label53

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
    11 label *label12
    12 ubind @flare
    13 ulocate building core false @copper .coreX .coreY *tmp36 .core
-    * label *label13
    14 jump *label12 equal .core null
-    * label *label14
    15 sensor .coreX .core @x
    16 sensor .coreY .core @y
    17 label *label10
-    * label *label11
    18 label *label15
    19 set :backgroundProcess:count 0
    20 set :backgroundProcess:drill .titaniumDrills*0
    21 set :backgroundProcess:unit .units*0
-    * label *label55
    22 jump *label56 notEqual :backgroundProcess:drill null
    23 jump *label20 always
    24 label *label56
-    * label *label57
    25 sensor *tmp43 :backgroundProcess:drill @titanium
    26 set :backgroundProcess:count *tmp43
    27 sensor *tmp44 :backgroundProcess:unit @controller
 
    32 set *tmp47 null
    33 jump *label65 always
    34 label *label58
-    * label *label59
    35 set :findFreeUnit:first_unit @unit
    36 label *label60
    37 sensor *tmp50 @unit @controlled
 
    45 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
    46 label *label62
    47 ubind @flare
-    * label *label63
    48 jump *label60 notEqual :findFreeUnit:first_unit @unit
-    * label *label64
    49 set *tmp47 null
    50 label *label65
    51 set :backgroundProcess:unit *tmp47
    52 jump *label66 notEqual *tmp47 null
    53 jump *label75 always
    54 label *label66
-    * label *label67
    55 label *label68
-    * label *label69
    56 # "Function: void serviceDrill(in drill, in unit)"
    57 ubind :backgroundProcess:unit
    58 sensor :serviceDrill:item @unit @firstItem
 
    71 ucontrol itemDrop @air 10
    72 label *label72
    73 label *label73
-    * label *label74
    74 label *label75
    75 set .units*0 :backgroundProcess:unit
    76 set :backgroundProcess:drill .titaniumDrills*1
    77 set :backgroundProcess:unit .units*1
-    * label *label78
    78 jump *label79 notEqual :backgroundProcess:drill null
    79 jump *label20 always
    80 label *label79
-    * label *label80
    81 sensor *tmp43 :backgroundProcess:drill @titanium
    82 op add :backgroundProcess:count :backgroundProcess:count *tmp43
    83 sensor *tmp44 :backgroundProcess:unit @controller
 
    88 set *tmp47 null
    89 jump *label88 always
    90 label *label81
-    * label *label82
    91 set :findFreeUnit:first_unit @unit
    92 label *label83
    93 sensor *tmp50 @unit @controlled
 
   101 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   102 label *label85
   103 ubind @flare
-    * label *label86
   104 jump *label83 notEqual :findFreeUnit:first_unit @unit
-    * label *label87
   105 set *tmp47 null
   106 label *label88
   107 set :backgroundProcess:unit *tmp47
   108 jump *label89 notEqual *tmp47 null
   109 jump *label98 always
   110 label *label89
-    * label *label90
   111 label *label91
-    * label *label92
   112 # "Function: void serviceDrill(in drill, in unit)"
   113 ubind :backgroundProcess:unit
   114 sensor :serviceDrill:item @unit @firstItem
 
   127 ucontrol itemDrop @air 10
   128 label *label95
   129 label *label96
-    * label *label97
   130 label *label98
   131 set .units*1 :backgroundProcess:unit
   132 set :backgroundProcess:drill .titaniumDrills*2
   133 set :backgroundProcess:unit .units*2
-    * label *label101
   134 jump *label102 notEqual :backgroundProcess:drill null
   135 jump *label20 always
   136 label *label102
-    * label *label103
   137 sensor *tmp43 :backgroundProcess:drill @titanium
   138 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   139 sensor *tmp44 :backgroundProcess:unit @controller
 
   144 set *tmp47 null
   145 jump *label111 always
   146 label *label104
-    * label *label105
   147 set :findFreeUnit:first_unit @unit
   148 label *label106
   149 sensor *tmp50 @unit @controlled
 
   157 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   158 label *label108
   159 ubind @flare
-    * label *label109
   160 jump *label106 notEqual :findFreeUnit:first_unit @unit
-    * label *label110
   161 set *tmp47 null
   162 label *label111
   163 set :backgroundProcess:unit *tmp47
   164 jump *label112 notEqual *tmp47 null
   165 jump *label121 always
   166 label *label112
-    * label *label113
   167 label *label114
-    * label *label115
   168 # "Function: void serviceDrill(in drill, in unit)"
   169 ubind :backgroundProcess:unit
   170 sensor :serviceDrill:item @unit @firstItem
 
   183 ucontrol itemDrop @air 10
   184 label *label118
   185 label *label119
-    * label *label120
   186 label *label121
   187 set .units*2 :backgroundProcess:unit
   188 set :backgroundProcess:drill .titaniumDrills*3
   189 set :backgroundProcess:unit .units*3
-    * label *label124
   190 jump *label125 notEqual :backgroundProcess:drill null
   191 jump *label20 always
   192 label *label125
-    * label *label126
   193 sensor *tmp43 :backgroundProcess:drill @titanium
   194 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   195 sensor *tmp44 :backgroundProcess:unit @controller
 
   200 set *tmp47 null
   201 jump *label134 always
   202 label *label127
-    * label *label128
   203 set :findFreeUnit:first_unit @unit
   204 label *label129
   205 sensor *tmp50 @unit @controlled
 
   213 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   214 label *label131
   215 ubind @flare
-    * label *label132
   216 jump *label129 notEqual :findFreeUnit:first_unit @unit
-    * label *label133
   217 set *tmp47 null
   218 label *label134
   219 set :backgroundProcess:unit *tmp47
   220 jump *label135 notEqual *tmp47 null
   221 jump *label144 always
   222 label *label135
-    * label *label136
   223 label *label137
-    * label *label138
   224 # "Function: void serviceDrill(in drill, in unit)"
   225 ubind :backgroundProcess:unit
   226 sensor :serviceDrill:item @unit @firstItem
 
   239 ucontrol itemDrop @air 10
   240 label *label141
   241 label *label142
-    * label *label143
   242 label *label144
   243 set .units*3 :backgroundProcess:unit
   244 set :backgroundProcess:drill .titaniumDrills*4
   245 set :backgroundProcess:unit .units*4
-    * label *label147
   246 jump *label148 notEqual :backgroundProcess:drill null
   247 jump *label20 always
   248 label *label148
-    * label *label149
   249 sensor *tmp43 :backgroundProcess:drill @titanium
   250 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   251 sensor *tmp44 :backgroundProcess:unit @controller
 
   256 set *tmp47 null
   257 jump *label157 always
   258 label *label150
-    * label *label151
   259 set :findFreeUnit:first_unit @unit
   260 label *label152
   261 sensor *tmp50 @unit @controlled
 
   269 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   270 label *label154
   271 ubind @flare
-    * label *label155
   272 jump *label152 notEqual :findFreeUnit:first_unit @unit
-    * label *label156
   273 set *tmp47 null
   274 label *label157
   275 set :backgroundProcess:unit *tmp47
   276 jump *label158 notEqual *tmp47 null
   277 jump *label167 always
   278 label *label158
-    * label *label159
   279 label *label160
-    * label *label161
   280 # "Function: void serviceDrill(in drill, in unit)"
   281 ubind :backgroundProcess:unit
   282 sensor :serviceDrill:item @unit @firstItem
 
   295 ucontrol itemDrop @air 10
   296 label *label164
   297 label *label165
-    * label *label166
   298 label *label167
   299 set .units*4 :backgroundProcess:unit
   300 set :backgroundProcess:drill .titaniumDrills*5
   301 set :backgroundProcess:unit .units*5
-    * label *label170
   302 jump *label171 notEqual :backgroundProcess:drill null
   303 jump *label20 always
   304 label *label171
-    * label *label172
   305 sensor *tmp43 :backgroundProcess:drill @titanium
   306 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   307 sensor *tmp44 :backgroundProcess:unit @controller
 
   312 set *tmp47 null
   313 jump *label180 always
   314 label *label173
-    * label *label174
   315 set :findFreeUnit:first_unit @unit
   316 label *label175
   317 sensor *tmp50 @unit @controlled
 
   325 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   326 label *label177
   327 ubind @flare
-    * label *label178
   328 jump *label175 notEqual :findFreeUnit:first_unit @unit
-    * label *label179
   329 set *tmp47 null
   330 label *label180
   331 set :backgroundProcess:unit *tmp47
   332 jump *label181 notEqual *tmp47 null
   333 jump *label190 always
   334 label *label181
-    * label *label182
   335 label *label183
-    * label *label184
   336 # "Function: void serviceDrill(in drill, in unit)"
   337 ubind :backgroundProcess:unit
   338 sensor :serviceDrill:item @unit @firstItem
 
   351 ucontrol itemDrop @air 10
   352 label *label187
   353 label *label188
-    * label *label189
   354 label *label190
   355 set .units*5 :backgroundProcess:unit
   356 set :backgroundProcess:drill .titaniumDrills*6
   357 set :backgroundProcess:unit .units*6
-    * label *label193
   358 jump *label194 notEqual :backgroundProcess:drill null
   359 jump *label20 always
   360 label *label194
-    * label *label195
   361 sensor *tmp43 :backgroundProcess:drill @titanium
   362 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   363 sensor *tmp44 :backgroundProcess:unit @controller
 
   368 set *tmp47 null
   369 jump *label203 always
   370 label *label196
-    * label *label197
   371 set :findFreeUnit:first_unit @unit
   372 label *label198
   373 sensor *tmp50 @unit @controlled
 
   381 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   382 label *label200
   383 ubind @flare
-    * label *label201
   384 jump *label198 notEqual :findFreeUnit:first_unit @unit
-    * label *label202
   385 set *tmp47 null
   386 label *label203
   387 set :backgroundProcess:unit *tmp47
   388 jump *label204 notEqual *tmp47 null
   389 jump *label213 always
   390 label *label204
-    * label *label205
   391 label *label206
-    * label *label207
   392 # "Function: void serviceDrill(in drill, in unit)"
   393 ubind :backgroundProcess:unit
   394 sensor :serviceDrill:item @unit @firstItem
 
   407 ucontrol itemDrop @air 10
   408 label *label210
   409 label *label211
-    * label *label212
   410 label *label213
   411 set .units*6 :backgroundProcess:unit
   412 set :backgroundProcess:drill .titaniumDrills*7
   413 set :backgroundProcess:unit .units*7
-    * label *label216
   414 jump *label217 notEqual :backgroundProcess:drill null
   415 jump *label20 always
   416 label *label217
-    * label *label218
   417 sensor *tmp43 :backgroundProcess:drill @titanium
   418 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   419 sensor *tmp44 :backgroundProcess:unit @controller
 
   424 set *tmp47 null
   425 jump *label226 always
   426 label *label219
-    * label *label220
   427 set :findFreeUnit:first_unit @unit
   428 label *label221
   429 sensor *tmp50 @unit @controlled
 
   437 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   438 label *label223
   439 ubind @flare
-    * label *label224
   440 jump *label221 notEqual :findFreeUnit:first_unit @unit
-    * label *label225
   441 set *tmp47 null
   442 label *label226
   443 set :backgroundProcess:unit *tmp47
   444 jump *label227 notEqual *tmp47 null
   445 jump *label236 always
   446 label *label227
-    * label *label228
   447 label *label229
-    * label *label230
   448 # "Function: void serviceDrill(in drill, in unit)"
   449 ubind :backgroundProcess:unit
   450 sensor :serviceDrill:item @unit @firstItem
 
   463 ucontrol itemDrop @air 10
   464 label *label233
   465 label *label234
-    * label *label235
   466 label *label236
   467 set .units*7 :backgroundProcess:unit
   468 set :backgroundProcess:drill .titaniumDrills*8
   469 set :backgroundProcess:unit .units*8
-    * label *label239
   470 jump *label240 notEqual :backgroundProcess:drill null
   471 jump *label20 always
   472 label *label240
-    * label *label241
   473 sensor *tmp43 :backgroundProcess:drill @titanium
   474 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   475 sensor *tmp44 :backgroundProcess:unit @controller
 
   480 set *tmp47 null
   481 jump *label249 always
   482 label *label242
-    * label *label243
   483 set :findFreeUnit:first_unit @unit
   484 label *label244
   485 sensor *tmp50 @unit @controlled
 
   493 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   494 label *label246
   495 ubind @flare
-    * label *label247
   496 jump *label244 notEqual :findFreeUnit:first_unit @unit
-    * label *label248
   497 set *tmp47 null
   498 label *label249
   499 set :backgroundProcess:unit *tmp47
   500 jump *label250 notEqual *tmp47 null
   501 jump *label259 always
   502 label *label250
-    * label *label251
   503 label *label252
-    * label *label253
   504 # "Function: void serviceDrill(in drill, in unit)"
   505 ubind :backgroundProcess:unit
   506 sensor :serviceDrill:item @unit @firstItem
 
   519 ucontrol itemDrop @air 10
   520 label *label256
   521 label *label257
-    * label *label258
   522 label *label259
   523 set .units*8 :backgroundProcess:unit
   524 set :backgroundProcess:drill .titaniumDrills*9
   525 set :backgroundProcess:unit .units*9
-    * label *label262
   526 jump *label263 notEqual :backgroundProcess:drill null
   527 jump *label20 always
   528 label *label263
-    * label *label264
   529 sensor *tmp43 :backgroundProcess:drill @titanium
   530 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   531 sensor *tmp44 :backgroundProcess:unit @controller
 
   536 set *tmp47 null
   537 jump *label272 always
   538 label *label265
-    * label *label266
   539 set :findFreeUnit:first_unit @unit
   540 label *label267
   541 sensor *tmp50 @unit @controlled
 
   549 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   550 label *label269
   551 ubind @flare
-    * label *label270
   552 jump *label267 notEqual :findFreeUnit:first_unit @unit
-    * label *label271
   553 set *tmp47 null
   554 label *label272
   555 set :backgroundProcess:unit *tmp47
   556 jump *label273 notEqual *tmp47 null
   557 jump *label282 always
   558 label *label273
-    * label *label274
   559 label *label275
-    * label *label276
   560 # "Function: void serviceDrill(in drill, in unit)"
   561 ubind :backgroundProcess:unit
   562 sensor :serviceDrill:item @unit @firstItem
 
   575 ucontrol itemDrop @air 10
   576 label *label279
   577 label *label280
-    * label *label281
   578 label *label282
   579 set .units*9 :backgroundProcess:unit
   580 label *label20
   581 write :backgroundProcess:count processor2 ".titaniumDrillCount"
-    * label *label16
   582 jump *label15 always
-    * label *label17
-    * label *label9
   583 wait 1e12
   584 jump *label8 always
   585 end
 
   620 label *label286
   621 op add .drills .drills 1
   622 label *label53
-    * label *label54
-    * label *label52
   623 set :addTitaniumDrill*finished true
   624 jump *label8 always
   625 end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-20 instructions):
 
    19 set :backgroundProcess:count 0
    20 set :backgroundProcess:drill .titaniumDrills*0
    21 set :backgroundProcess:unit .units*0
-    * jump *label56 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+   22 jump *label20 equal :backgroundProcess:drill null
    23 label *label56
    24 sensor *tmp43 :backgroundProcess:drill @titanium
    25 set :backgroundProcess:count *tmp43
 
    48 set *tmp47 null
    49 label *label65
    50 set :backgroundProcess:unit *tmp47
-    * jump *label66 notEqual *tmp47 null
-    * jump *label75 always
+   51 jump *label75 equal *tmp47 null
    52 label *label66
    53 label *label68
    54 # "Function: void serviceDrill(in drill, in unit)"
 
    73 set .units*0 :backgroundProcess:unit
    74 set :backgroundProcess:drill .titaniumDrills*1
    75 set :backgroundProcess:unit .units*1
-    * jump *label79 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+   76 jump *label20 equal :backgroundProcess:drill null
    77 label *label79
    78 sensor *tmp43 :backgroundProcess:drill @titanium
    79 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   102 set *tmp47 null
   103 label *label88
   104 set :backgroundProcess:unit *tmp47
-    * jump *label89 notEqual *tmp47 null
-    * jump *label98 always
+  105 jump *label98 equal *tmp47 null
   106 label *label89
   107 label *label91
   108 # "Function: void serviceDrill(in drill, in unit)"
 
   127 set .units*1 :backgroundProcess:unit
   128 set :backgroundProcess:drill .titaniumDrills*2
   129 set :backgroundProcess:unit .units*2
-    * jump *label102 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+  130 jump *label20 equal :backgroundProcess:drill null
   131 label *label102
   132 sensor *tmp43 :backgroundProcess:drill @titanium
   133 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   156 set *tmp47 null
   157 label *label111
   158 set :backgroundProcess:unit *tmp47
-    * jump *label112 notEqual *tmp47 null
-    * jump *label121 always
+  159 jump *label121 equal *tmp47 null
   160 label *label112
   161 label *label114
   162 # "Function: void serviceDrill(in drill, in unit)"
 
   181 set .units*2 :backgroundProcess:unit
   182 set :backgroundProcess:drill .titaniumDrills*3
   183 set :backgroundProcess:unit .units*3
-    * jump *label125 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+  184 jump *label20 equal :backgroundProcess:drill null
   185 label *label125
   186 sensor *tmp43 :backgroundProcess:drill @titanium
   187 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   210 set *tmp47 null
   211 label *label134
   212 set :backgroundProcess:unit *tmp47
-    * jump *label135 notEqual *tmp47 null
-    * jump *label144 always
+  213 jump *label144 equal *tmp47 null
   214 label *label135
   215 label *label137
   216 # "Function: void serviceDrill(in drill, in unit)"
 
   235 set .units*3 :backgroundProcess:unit
   236 set :backgroundProcess:drill .titaniumDrills*4
   237 set :backgroundProcess:unit .units*4
-    * jump *label148 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+  238 jump *label20 equal :backgroundProcess:drill null
   239 label *label148
   240 sensor *tmp43 :backgroundProcess:drill @titanium
   241 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   264 set *tmp47 null
   265 label *label157
   266 set :backgroundProcess:unit *tmp47
-    * jump *label158 notEqual *tmp47 null
-    * jump *label167 always
+  267 jump *label167 equal *tmp47 null
   268 label *label158
   269 label *label160
   270 # "Function: void serviceDrill(in drill, in unit)"
 
   289 set .units*4 :backgroundProcess:unit
   290 set :backgroundProcess:drill .titaniumDrills*5
   291 set :backgroundProcess:unit .units*5
-    * jump *label171 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+  292 jump *label20 equal :backgroundProcess:drill null
   293 label *label171
   294 sensor *tmp43 :backgroundProcess:drill @titanium
   295 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   318 set *tmp47 null
   319 label *label180
   320 set :backgroundProcess:unit *tmp47
-    * jump *label181 notEqual *tmp47 null
-    * jump *label190 always
+  321 jump *label190 equal *tmp47 null
   322 label *label181
   323 label *label183
   324 # "Function: void serviceDrill(in drill, in unit)"
 
   343 set .units*5 :backgroundProcess:unit
   344 set :backgroundProcess:drill .titaniumDrills*6
   345 set :backgroundProcess:unit .units*6
-    * jump *label194 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+  346 jump *label20 equal :backgroundProcess:drill null
   347 label *label194
   348 sensor *tmp43 :backgroundProcess:drill @titanium
   349 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   372 set *tmp47 null
   373 label *label203
   374 set :backgroundProcess:unit *tmp47
-    * jump *label204 notEqual *tmp47 null
-    * jump *label213 always
+  375 jump *label213 equal *tmp47 null
   376 label *label204
   377 label *label206
   378 # "Function: void serviceDrill(in drill, in unit)"
 
   397 set .units*6 :backgroundProcess:unit
   398 set :backgroundProcess:drill .titaniumDrills*7
   399 set :backgroundProcess:unit .units*7
-    * jump *label217 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+  400 jump *label20 equal :backgroundProcess:drill null
   401 label *label217
   402 sensor *tmp43 :backgroundProcess:drill @titanium
   403 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   426 set *tmp47 null
   427 label *label226
   428 set :backgroundProcess:unit *tmp47
-    * jump *label227 notEqual *tmp47 null
-    * jump *label236 always
+  429 jump *label236 equal *tmp47 null
   430 label *label227
   431 label *label229
   432 # "Function: void serviceDrill(in drill, in unit)"
 
   451 set .units*7 :backgroundProcess:unit
   452 set :backgroundProcess:drill .titaniumDrills*8
   453 set :backgroundProcess:unit .units*8
-    * jump *label240 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+  454 jump *label20 equal :backgroundProcess:drill null
   455 label *label240
   456 sensor *tmp43 :backgroundProcess:drill @titanium
   457 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   480 set *tmp47 null
   481 label *label249
   482 set :backgroundProcess:unit *tmp47
-    * jump *label250 notEqual *tmp47 null
-    * jump *label259 always
+  483 jump *label259 equal *tmp47 null
   484 label *label250
   485 label *label252
   486 # "Function: void serviceDrill(in drill, in unit)"
 
   505 set .units*8 :backgroundProcess:unit
   506 set :backgroundProcess:drill .titaniumDrills*9
   507 set :backgroundProcess:unit .units*9
-    * jump *label263 notEqual :backgroundProcess:drill null
-    * jump *label20 always
+  508 jump *label20 equal :backgroundProcess:drill null
   509 label *label263
   510 sensor *tmp43 :backgroundProcess:drill @titanium
   511 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   534 set *tmp47 null
   535 label *label272
   536 set :backgroundProcess:unit *tmp47
-    * jump *label273 notEqual *tmp47 null
-    * jump *label282 always
+  537 jump *label282 equal *tmp47 null
   538 label *label273
   539 label *label275
   540 # "Function: void serviceDrill(in drill, in unit)"

Modifications by Jumps phase, Jump Optimization, pass 6, iteration 1:
 
    20 set :backgroundProcess:drill .titaniumDrills*0
    21 set :backgroundProcess:unit .units*0
    22 jump *label20 equal :backgroundProcess:drill null
-    * label *label56
    23 sensor *tmp43 :backgroundProcess:drill @titanium
    24 set :backgroundProcess:count *tmp43
    25 sensor *tmp44 :backgroundProcess:unit @controller
 
    48 label *label65
    49 set :backgroundProcess:unit *tmp47
    50 jump *label75 equal *tmp47 null
-    * label *label66
    51 label *label68
    52 # "Function: void serviceDrill(in drill, in unit)"
    53 ubind :backgroundProcess:unit
 
    72 set :backgroundProcess:drill .titaniumDrills*1
    73 set :backgroundProcess:unit .units*1
    74 jump *label20 equal :backgroundProcess:drill null
-    * label *label79
    75 sensor *tmp43 :backgroundProcess:drill @titanium
    76 op add :backgroundProcess:count :backgroundProcess:count *tmp43
    77 sensor *tmp44 :backgroundProcess:unit @controller
 
   100 label *label88
   101 set :backgroundProcess:unit *tmp47
   102 jump *label98 equal *tmp47 null
-    * label *label89
   103 label *label91
   104 # "Function: void serviceDrill(in drill, in unit)"
   105 ubind :backgroundProcess:unit
 
   124 set :backgroundProcess:drill .titaniumDrills*2
   125 set :backgroundProcess:unit .units*2
   126 jump *label20 equal :backgroundProcess:drill null
-    * label *label102
   127 sensor *tmp43 :backgroundProcess:drill @titanium
   128 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   129 sensor *tmp44 :backgroundProcess:unit @controller
 
   152 label *label111
   153 set :backgroundProcess:unit *tmp47
   154 jump *label121 equal *tmp47 null
-    * label *label112
   155 label *label114
   156 # "Function: void serviceDrill(in drill, in unit)"
   157 ubind :backgroundProcess:unit
 
   176 set :backgroundProcess:drill .titaniumDrills*3
   177 set :backgroundProcess:unit .units*3
   178 jump *label20 equal :backgroundProcess:drill null
-    * label *label125
   179 sensor *tmp43 :backgroundProcess:drill @titanium
   180 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   181 sensor *tmp44 :backgroundProcess:unit @controller
 
   204 label *label134
   205 set :backgroundProcess:unit *tmp47
   206 jump *label144 equal *tmp47 null
-    * label *label135
   207 label *label137
   208 # "Function: void serviceDrill(in drill, in unit)"
   209 ubind :backgroundProcess:unit
 
   228 set :backgroundProcess:drill .titaniumDrills*4
   229 set :backgroundProcess:unit .units*4
   230 jump *label20 equal :backgroundProcess:drill null
-    * label *label148
   231 sensor *tmp43 :backgroundProcess:drill @titanium
   232 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   233 sensor *tmp44 :backgroundProcess:unit @controller
 
   256 label *label157
   257 set :backgroundProcess:unit *tmp47
   258 jump *label167 equal *tmp47 null
-    * label *label158
   259 label *label160
   260 # "Function: void serviceDrill(in drill, in unit)"
   261 ubind :backgroundProcess:unit
 
   280 set :backgroundProcess:drill .titaniumDrills*5
   281 set :backgroundProcess:unit .units*5
   282 jump *label20 equal :backgroundProcess:drill null
-    * label *label171
   283 sensor *tmp43 :backgroundProcess:drill @titanium
   284 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   285 sensor *tmp44 :backgroundProcess:unit @controller
 
   308 label *label180
   309 set :backgroundProcess:unit *tmp47
   310 jump *label190 equal *tmp47 null
-    * label *label181
   311 label *label183
   312 # "Function: void serviceDrill(in drill, in unit)"
   313 ubind :backgroundProcess:unit
 
   332 set :backgroundProcess:drill .titaniumDrills*6
   333 set :backgroundProcess:unit .units*6
   334 jump *label20 equal :backgroundProcess:drill null
-    * label *label194
   335 sensor *tmp43 :backgroundProcess:drill @titanium
   336 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   337 sensor *tmp44 :backgroundProcess:unit @controller
 
   360 label *label203
   361 set :backgroundProcess:unit *tmp47
   362 jump *label213 equal *tmp47 null
-    * label *label204
   363 label *label206
   364 # "Function: void serviceDrill(in drill, in unit)"
   365 ubind :backgroundProcess:unit
 
   384 set :backgroundProcess:drill .titaniumDrills*7
   385 set :backgroundProcess:unit .units*7
   386 jump *label20 equal :backgroundProcess:drill null
-    * label *label217
   387 sensor *tmp43 :backgroundProcess:drill @titanium
   388 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   389 sensor *tmp44 :backgroundProcess:unit @controller
 
   412 label *label226
   413 set :backgroundProcess:unit *tmp47
   414 jump *label236 equal *tmp47 null
-    * label *label227
   415 label *label229
   416 # "Function: void serviceDrill(in drill, in unit)"
   417 ubind :backgroundProcess:unit
 
   436 set :backgroundProcess:drill .titaniumDrills*8
   437 set :backgroundProcess:unit .units*8
   438 jump *label20 equal :backgroundProcess:drill null
-    * label *label240
   439 sensor *tmp43 :backgroundProcess:drill @titanium
   440 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   441 sensor *tmp44 :backgroundProcess:unit @controller
 
   464 label *label249
   465 set :backgroundProcess:unit *tmp47
   466 jump *label259 equal *tmp47 null
-    * label *label250
   467 label *label252
   468 # "Function: void serviceDrill(in drill, in unit)"
   469 ubind :backgroundProcess:unit
 
   488 set :backgroundProcess:drill .titaniumDrills*9
   489 set :backgroundProcess:unit .units*9
   490 jump *label20 equal :backgroundProcess:drill null
-    * label *label263
   491 sensor *tmp43 :backgroundProcess:drill @titanium
   492 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   493 sensor *tmp44 :backgroundProcess:unit @controller
 
   516 label *label272
   517 set :backgroundProcess:unit *tmp47
   518 jump *label282 equal *tmp47 null
-    * label *label273
   519 label *label275
   520 # "Function: void serviceDrill(in drill, in unit)"
   521 ubind :backgroundProcess:unit

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-14 instructions):
 
    37 ucontrol flag 0
    38 set *tmp47 @unit
    39 jump *label65 always
-    * jump *label62 always
    40 label *label61
    41 sensor *tmp53 :findFreeUnit:first_unit @dead
    42 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
    88 ucontrol flag 0
    89 set *tmp47 @unit
    90 jump *label88 always
-    * jump *label85 always
    91 label *label84
    92 sensor *tmp53 :findFreeUnit:first_unit @dead
    93 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
   139 ucontrol flag 0
   140 set *tmp47 @unit
   141 jump *label111 always
-    * jump *label108 always
   142 label *label107
   143 sensor *tmp53 :findFreeUnit:first_unit @dead
   144 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
   190 ucontrol flag 0
   191 set *tmp47 @unit
   192 jump *label134 always
-    * jump *label131 always
   193 label *label130
   194 sensor *tmp53 :findFreeUnit:first_unit @dead
   195 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
   241 ucontrol flag 0
   242 set *tmp47 @unit
   243 jump *label157 always
-    * jump *label154 always
   244 label *label153
   245 sensor *tmp53 :findFreeUnit:first_unit @dead
   246 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
   292 ucontrol flag 0
   293 set *tmp47 @unit
   294 jump *label180 always
-    * jump *label177 always
   295 label *label176
   296 sensor *tmp53 :findFreeUnit:first_unit @dead
   297 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
   343 ucontrol flag 0
   344 set *tmp47 @unit
   345 jump *label203 always
-    * jump *label200 always
   346 label *label199
   347 sensor *tmp53 :findFreeUnit:first_unit @dead
   348 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
   394 ucontrol flag 0
   395 set *tmp47 @unit
   396 jump *label226 always
-    * jump *label223 always
   397 label *label222
   398 sensor *tmp53 :findFreeUnit:first_unit @dead
   399 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
   445 ucontrol flag 0
   446 set *tmp47 @unit
   447 jump *label249 always
-    * jump *label246 always
   448 label *label245
   449 sensor *tmp53 :findFreeUnit:first_unit @dead
   450 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
   496 ucontrol flag 0
   497 set *tmp47 @unit
   498 jump *label272 always
-    * jump *label269 always
   499 label *label268
   500 sensor *tmp53 :findFreeUnit:first_unit @dead
   501 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
 
   530 label *label20
   531 write :backgroundProcess:count processor2 ".titaniumDrillCount"
   532 jump *label15 always
-    * wait 1e12
-    * jump *label8 always
-    * end
   533 label *label0
   534 # "Function: remote void addTitaniumDrill(in drill)"
   535 jump *label53 greaterThanEq .drills 9
 
   569 label *label53
   570 set :addTitaniumDrill*finished true
   571 jump *label8 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 6, iteration 1:
 
    40 label *label61
    41 sensor *tmp53 :findFreeUnit:first_unit @dead
    42 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label62
    43 ubind @flare
    44 jump *label60 notEqual :findFreeUnit:first_unit @unit
    45 set *tmp47 null
 
    90 label *label84
    91 sensor *tmp53 :findFreeUnit:first_unit @dead
    92 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label85
    93 ubind @flare
    94 jump *label83 notEqual :findFreeUnit:first_unit @unit
    95 set *tmp47 null
 
   140 label *label107
   141 sensor *tmp53 :findFreeUnit:first_unit @dead
   142 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label108
   143 ubind @flare
   144 jump *label106 notEqual :findFreeUnit:first_unit @unit
   145 set *tmp47 null
 
   190 label *label130
   191 sensor *tmp53 :findFreeUnit:first_unit @dead
   192 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label131
   193 ubind @flare
   194 jump *label129 notEqual :findFreeUnit:first_unit @unit
   195 set *tmp47 null
 
   240 label *label153
   241 sensor *tmp53 :findFreeUnit:first_unit @dead
   242 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label154
   243 ubind @flare
   244 jump *label152 notEqual :findFreeUnit:first_unit @unit
   245 set *tmp47 null
 
   290 label *label176
   291 sensor *tmp53 :findFreeUnit:first_unit @dead
   292 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label177
   293 ubind @flare
   294 jump *label175 notEqual :findFreeUnit:first_unit @unit
   295 set *tmp47 null
 
   340 label *label199
   341 sensor *tmp53 :findFreeUnit:first_unit @dead
   342 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label200
   343 ubind @flare
   344 jump *label198 notEqual :findFreeUnit:first_unit @unit
   345 set *tmp47 null
 
   390 label *label222
   391 sensor *tmp53 :findFreeUnit:first_unit @dead
   392 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label223
   393 ubind @flare
   394 jump *label221 notEqual :findFreeUnit:first_unit @unit
   395 set *tmp47 null
 
   440 label *label245
   441 sensor *tmp53 :findFreeUnit:first_unit @dead
   442 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label246
   443 ubind @flare
   444 jump *label244 notEqual :findFreeUnit:first_unit @unit
   445 set *tmp47 null
 
   490 label *label268
   491 sensor *tmp53 :findFreeUnit:first_unit @dead
   492 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label269
   493 ubind @flare
   494 jump *label267 notEqual :findFreeUnit:first_unit @unit
   495 set *tmp47 null

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
    10 jump *label10 notEqual .core null
    11 label *label12
    12 ubind @flare
-    * ulocate building core false @copper .coreX .coreY *tmp36 .core
+   13 ulocate building core false @copper .coreX .coreY 0 .core
    14 jump *label12 equal .core null
    15 sensor .coreX .core @x
    16 sensor .coreY .core @y

Final code before resolving virtual instructions:

    0:  jump *label6 always 0 0                                      FlareController.mnd: #set target = 8;
    1:  jump *label0 always 0 0                                      ...
        label *label6                                                ...
        label *label7                                                FlareController.mnd: require "Display.mnd" remote display;
    2:  read *tmp32 processor2 "*signature"                          ...
    3:  jump *label7 notEqual *tmp32 "0:v1"                          ...
    4:  set .drills 0                                                FlareController.mnd: volatile var drills = 0;
    5:  set *signature "881dde114374c003:v1"                         FlareController.mnd: #set target = 8;
        label *label8                                                ...
        # "Function: void backgroundProcess()"                       ...
    6:  jump *label10 notEqual .core null                            FlareController.mnd: if core == null then
        label *label12                                               FlareController.mnd: do
    7:  ubind @flare                                                 FlareController.mnd: ubind(@flare);
    8:  ulocate building core false @copper .coreX .coreY 0 .core    FlareController.mnd: core = ulocate(:building, :core, false, out coreX, out coreY);
    9:  jump *label12 equal .core null                               FlareController.mnd: do
   10:  sensor .coreX .core @x                                       FlareController.mnd: coreX = core.@x;
   11:  sensor .coreY .core @y                                       FlareController.mnd: coreY = core.@y;
        label *label10                                               FlareController.mnd: if core == null then
        label *label15                                               FlareController.mnd: while true do
   12:  set :backgroundProcess:count 0                               FlareController.mnd: var count = 0;
   13:  set :backgroundProcess:drill .titaniumDrills*0               FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
   14:  set :backgroundProcess:unit .units*0                         ...
   15:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
   16:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
   17:  set :backgroundProcess:count *tmp43                          ...
   18:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
   19:  jump *label68 equal *tmp44 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
   20:  ubind @flare                                                 *units: ubind(unit_type);
   21:  jump *label58 notEqual @unit null                            *units: if @unit == null then return null; end;
   22:  set *tmp47 null                                              ...
   23:  jump *label65 always 0 0                                     ...
        label *label58                                               ...
   24:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label60                                               *units: do
   25:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
   26:  jump *label61 notEqual *tmp50 0                              ...
   27:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   28:  set *tmp47 @unit                                             *units: return @unit;
   29:  jump *label65 always 0 0                                     ...
        label *label61                                               *units: if @unit.@controlled == 0 then
   30:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   31:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
   32:  ubind @flare                                                 *units: ubind(unit_type);
   33:  jump *label60 notEqual :findFreeUnit:first_unit @unit        *units: do
   34:  set *tmp47 null                                              *units: return null;
        label *label65                                               FlareController.mnd: unit = findFreeUnit(@flare, 0);
   35:  set :backgroundProcess:unit *tmp47                           ...
   36:  jump *label75 equal *tmp47 null                              FlareController.mnd: if unit == null then continue; end;
        label *label68                                               FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
   37:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
   38:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
   39:  jump *label70 notEqual :serviceDrill:item @titanium          FlareController.mnd: if item == @titanium then
   40:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
   41:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
   42:  jump *label73 always 0 0                                     FlareController.mnd: if item == @titanium then
        label *label70                                               ...
   43:  jump *label71 notEqual :serviceDrill:item null               FlareController.mnd: elsif item == null then
   44:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
   45:  sensor *tmp66 :backgroundProcess:drill @y                    ...
   46:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
   47:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
   48:  jump *label72 always 0 0                                     FlareController.mnd: elsif item == null then
        label *label71                                               ...
   49:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label72                                               FlareController.mnd: elsif item == null then
        label *label73                                               FlareController.mnd: if item == @titanium then
        label *label75                                               FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
   50:  set .units*0 :backgroundProcess:unit                         ...
   51:  set :backgroundProcess:drill .titaniumDrills*1               ...
   52:  set :backgroundProcess:unit .units*1                         ...
   53:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
   54:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
   55:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
   56:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
   57:  jump *label91 equal *tmp44 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
   58:  ubind @flare                                                 *units: ubind(unit_type);
   59:  jump *label81 notEqual @unit null                            *units: if @unit == null then return null; end;
   60:  set *tmp47 null                                              ...
   61:  jump *label88 always 0 0                                     ...
        label *label81                                               ...
   62:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label83                                               *units: do
   63:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
   64:  jump *label84 notEqual *tmp50 0                              ...
   65:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   66:  set *tmp47 @unit                                             *units: return @unit;
   67:  jump *label88 always 0 0                                     ...
        label *label84                                               *units: if @unit.@controlled == 0 then
   68:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   69:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
   70:  ubind @flare                                                 *units: ubind(unit_type);
   71:  jump *label83 notEqual :findFreeUnit:first_unit @unit        *units: do
   72:  set *tmp47 null                                              *units: return null;
        label *label88                                               FlareController.mnd: unit = findFreeUnit(@flare, 0);
   73:  set :backgroundProcess:unit *tmp47                           ...
   74:  jump *label98 equal *tmp47 null                              FlareController.mnd: if unit == null then continue; end;
        label *label91                                               FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
   75:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
   76:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
   77:  jump *label93 notEqual :serviceDrill:item @titanium          FlareController.mnd: if item == @titanium then
   78:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
   79:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
   80:  jump *label96 always 0 0                                     FlareController.mnd: if item == @titanium then
        label *label93                                               ...
   81:  jump *label94 notEqual :serviceDrill:item null               FlareController.mnd: elsif item == null then
   82:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
   83:  sensor *tmp66 :backgroundProcess:drill @y                    ...
   84:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
   85:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
   86:  jump *label95 always 0 0                                     FlareController.mnd: elsif item == null then
        label *label94                                               ...
   87:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label95                                               FlareController.mnd: elsif item == null then
        label *label96                                               FlareController.mnd: if item == @titanium then
        label *label98                                               FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
   88:  set .units*1 :backgroundProcess:unit                         ...
   89:  set :backgroundProcess:drill .titaniumDrills*2               ...
   90:  set :backgroundProcess:unit .units*2                         ...
   91:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
   92:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
   93:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
   94:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
   95:  jump *label114 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
   96:  ubind @flare                                                 *units: ubind(unit_type);
   97:  jump *label104 notEqual @unit null                           *units: if @unit == null then return null; end;
   98:  set *tmp47 null                                              ...
   99:  jump *label111 always 0 0                                    ...
        label *label104                                              ...
  100:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label106                                              *units: do
  101:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  102:  jump *label107 notEqual *tmp50 0                             ...
  103:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  104:  set *tmp47 @unit                                             *units: return @unit;
  105:  jump *label111 always 0 0                                    ...
        label *label107                                              *units: if @unit.@controlled == 0 then
  106:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  107:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  108:  ubind @flare                                                 *units: ubind(unit_type);
  109:  jump *label106 notEqual :findFreeUnit:first_unit @unit       *units: do
  110:  set *tmp47 null                                              *units: return null;
        label *label111                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  111:  set :backgroundProcess:unit *tmp47                           ...
  112:  jump *label121 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label114                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  113:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  114:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  115:  jump *label116 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  116:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  117:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  118:  jump *label119 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label116                                              ...
  119:  jump *label117 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  120:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  121:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  122:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  123:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  124:  jump *label118 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label117                                              ...
  125:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label118                                              FlareController.mnd: elsif item == null then
        label *label119                                              FlareController.mnd: if item == @titanium then
        label *label121                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  126:  set .units*2 :backgroundProcess:unit                         ...
  127:  set :backgroundProcess:drill .titaniumDrills*3               ...
  128:  set :backgroundProcess:unit .units*3                         ...
  129:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  130:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  131:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  132:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  133:  jump *label137 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  134:  ubind @flare                                                 *units: ubind(unit_type);
  135:  jump *label127 notEqual @unit null                           *units: if @unit == null then return null; end;
  136:  set *tmp47 null                                              ...
  137:  jump *label134 always 0 0                                    ...
        label *label127                                              ...
  138:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label129                                              *units: do
  139:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  140:  jump *label130 notEqual *tmp50 0                             ...
  141:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  142:  set *tmp47 @unit                                             *units: return @unit;
  143:  jump *label134 always 0 0                                    ...
        label *label130                                              *units: if @unit.@controlled == 0 then
  144:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  145:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  146:  ubind @flare                                                 *units: ubind(unit_type);
  147:  jump *label129 notEqual :findFreeUnit:first_unit @unit       *units: do
  148:  set *tmp47 null                                              *units: return null;
        label *label134                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  149:  set :backgroundProcess:unit *tmp47                           ...
  150:  jump *label144 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label137                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  151:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  152:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  153:  jump *label139 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  154:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  155:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  156:  jump *label142 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label139                                              ...
  157:  jump *label140 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  158:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  159:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  160:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  161:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  162:  jump *label141 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label140                                              ...
  163:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label141                                              FlareController.mnd: elsif item == null then
        label *label142                                              FlareController.mnd: if item == @titanium then
        label *label144                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  164:  set .units*3 :backgroundProcess:unit                         ...
  165:  set :backgroundProcess:drill .titaniumDrills*4               ...
  166:  set :backgroundProcess:unit .units*4                         ...
  167:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  168:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  169:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  170:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  171:  jump *label160 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  172:  ubind @flare                                                 *units: ubind(unit_type);
  173:  jump *label150 notEqual @unit null                           *units: if @unit == null then return null; end;
  174:  set *tmp47 null                                              ...
  175:  jump *label157 always 0 0                                    ...
        label *label150                                              ...
  176:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label152                                              *units: do
  177:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  178:  jump *label153 notEqual *tmp50 0                             ...
  179:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  180:  set *tmp47 @unit                                             *units: return @unit;
  181:  jump *label157 always 0 0                                    ...
        label *label153                                              *units: if @unit.@controlled == 0 then
  182:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  183:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  184:  ubind @flare                                                 *units: ubind(unit_type);
  185:  jump *label152 notEqual :findFreeUnit:first_unit @unit       *units: do
  186:  set *tmp47 null                                              *units: return null;
        label *label157                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  187:  set :backgroundProcess:unit *tmp47                           ...
  188:  jump *label167 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label160                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  189:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  190:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  191:  jump *label162 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  192:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  193:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  194:  jump *label165 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label162                                              ...
  195:  jump *label163 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  196:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  197:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  198:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  199:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  200:  jump *label164 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label163                                              ...
  201:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label164                                              FlareController.mnd: elsif item == null then
        label *label165                                              FlareController.mnd: if item == @titanium then
        label *label167                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  202:  set .units*4 :backgroundProcess:unit                         ...
  203:  set :backgroundProcess:drill .titaniumDrills*5               ...
  204:  set :backgroundProcess:unit .units*5                         ...
  205:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  206:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  207:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  208:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  209:  jump *label183 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  210:  ubind @flare                                                 *units: ubind(unit_type);
  211:  jump *label173 notEqual @unit null                           *units: if @unit == null then return null; end;
  212:  set *tmp47 null                                              ...
  213:  jump *label180 always 0 0                                    ...
        label *label173                                              ...
  214:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label175                                              *units: do
  215:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  216:  jump *label176 notEqual *tmp50 0                             ...
  217:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  218:  set *tmp47 @unit                                             *units: return @unit;
  219:  jump *label180 always 0 0                                    ...
        label *label176                                              *units: if @unit.@controlled == 0 then
  220:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  221:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  222:  ubind @flare                                                 *units: ubind(unit_type);
  223:  jump *label175 notEqual :findFreeUnit:first_unit @unit       *units: do
  224:  set *tmp47 null                                              *units: return null;
        label *label180                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  225:  set :backgroundProcess:unit *tmp47                           ...
  226:  jump *label190 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label183                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  227:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  228:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  229:  jump *label185 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  230:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  231:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  232:  jump *label188 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label185                                              ...
  233:  jump *label186 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  234:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  235:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  236:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  237:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  238:  jump *label187 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label186                                              ...
  239:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label187                                              FlareController.mnd: elsif item == null then
        label *label188                                              FlareController.mnd: if item == @titanium then
        label *label190                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  240:  set .units*5 :backgroundProcess:unit                         ...
  241:  set :backgroundProcess:drill .titaniumDrills*6               ...
  242:  set :backgroundProcess:unit .units*6                         ...
  243:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  244:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  245:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  246:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  247:  jump *label206 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  248:  ubind @flare                                                 *units: ubind(unit_type);
  249:  jump *label196 notEqual @unit null                           *units: if @unit == null then return null; end;
  250:  set *tmp47 null                                              ...
  251:  jump *label203 always 0 0                                    ...
        label *label196                                              ...
  252:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label198                                              *units: do
  253:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  254:  jump *label199 notEqual *tmp50 0                             ...
  255:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  256:  set *tmp47 @unit                                             *units: return @unit;
  257:  jump *label203 always 0 0                                    ...
        label *label199                                              *units: if @unit.@controlled == 0 then
  258:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  259:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  260:  ubind @flare                                                 *units: ubind(unit_type);
  261:  jump *label198 notEqual :findFreeUnit:first_unit @unit       *units: do
  262:  set *tmp47 null                                              *units: return null;
        label *label203                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  263:  set :backgroundProcess:unit *tmp47                           ...
  264:  jump *label213 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label206                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  265:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  266:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  267:  jump *label208 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  268:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  269:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  270:  jump *label211 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label208                                              ...
  271:  jump *label209 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  272:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  273:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  274:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  275:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  276:  jump *label210 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label209                                              ...
  277:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label210                                              FlareController.mnd: elsif item == null then
        label *label211                                              FlareController.mnd: if item == @titanium then
        label *label213                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  278:  set .units*6 :backgroundProcess:unit                         ...
  279:  set :backgroundProcess:drill .titaniumDrills*7               ...
  280:  set :backgroundProcess:unit .units*7                         ...
  281:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  282:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  283:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  284:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  285:  jump *label229 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  286:  ubind @flare                                                 *units: ubind(unit_type);
  287:  jump *label219 notEqual @unit null                           *units: if @unit == null then return null; end;
  288:  set *tmp47 null                                              ...
  289:  jump *label226 always 0 0                                    ...
        label *label219                                              ...
  290:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label221                                              *units: do
  291:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  292:  jump *label222 notEqual *tmp50 0                             ...
  293:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  294:  set *tmp47 @unit                                             *units: return @unit;
  295:  jump *label226 always 0 0                                    ...
        label *label222                                              *units: if @unit.@controlled == 0 then
  296:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  297:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  298:  ubind @flare                                                 *units: ubind(unit_type);
  299:  jump *label221 notEqual :findFreeUnit:first_unit @unit       *units: do
  300:  set *tmp47 null                                              *units: return null;
        label *label226                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  301:  set :backgroundProcess:unit *tmp47                           ...
  302:  jump *label236 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label229                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  303:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  304:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  305:  jump *label231 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  306:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  307:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  308:  jump *label234 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label231                                              ...
  309:  jump *label232 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  310:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  311:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  312:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  313:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  314:  jump *label233 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label232                                              ...
  315:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label233                                              FlareController.mnd: elsif item == null then
        label *label234                                              FlareController.mnd: if item == @titanium then
        label *label236                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  316:  set .units*7 :backgroundProcess:unit                         ...
  317:  set :backgroundProcess:drill .titaniumDrills*8               ...
  318:  set :backgroundProcess:unit .units*8                         ...
  319:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  320:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  321:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  322:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  323:  jump *label252 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  324:  ubind @flare                                                 *units: ubind(unit_type);
  325:  jump *label242 notEqual @unit null                           *units: if @unit == null then return null; end;
  326:  set *tmp47 null                                              ...
  327:  jump *label249 always 0 0                                    ...
        label *label242                                              ...
  328:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label244                                              *units: do
  329:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  330:  jump *label245 notEqual *tmp50 0                             ...
  331:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  332:  set *tmp47 @unit                                             *units: return @unit;
  333:  jump *label249 always 0 0                                    ...
        label *label245                                              *units: if @unit.@controlled == 0 then
  334:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  335:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  336:  ubind @flare                                                 *units: ubind(unit_type);
  337:  jump *label244 notEqual :findFreeUnit:first_unit @unit       *units: do
  338:  set *tmp47 null                                              *units: return null;
        label *label249                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  339:  set :backgroundProcess:unit *tmp47                           ...
  340:  jump *label259 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label252                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  341:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  342:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  343:  jump *label254 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  344:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  345:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  346:  jump *label257 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label254                                              ...
  347:  jump *label255 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  348:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  349:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  350:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  351:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  352:  jump *label256 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label255                                              ...
  353:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label256                                              FlareController.mnd: elsif item == null then
        label *label257                                              FlareController.mnd: if item == @titanium then
        label *label259                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  354:  set .units*8 :backgroundProcess:unit                         ...
  355:  set :backgroundProcess:drill .titaniumDrills*9               ...
  356:  set :backgroundProcess:unit .units*9                         ...
  357:  jump *label20 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  358:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  359:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  360:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  361:  jump *label275 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  362:  ubind @flare                                                 *units: ubind(unit_type);
  363:  jump *label265 notEqual @unit null                           *units: if @unit == null then return null; end;
  364:  set *tmp47 null                                              ...
  365:  jump *label272 always 0 0                                    ...
        label *label265                                              ...
  366:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label267                                              *units: do
  367:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  368:  jump *label268 notEqual *tmp50 0                             ...
  369:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  370:  set *tmp47 @unit                                             *units: return @unit;
  371:  jump *label272 always 0 0                                    ...
        label *label268                                              *units: if @unit.@controlled == 0 then
  372:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  373:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  374:  ubind @flare                                                 *units: ubind(unit_type);
  375:  jump *label267 notEqual :findFreeUnit:first_unit @unit       *units: do
  376:  set *tmp47 null                                              *units: return null;
        label *label272                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  377:  set :backgroundProcess:unit *tmp47                           ...
  378:  jump *label282 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label275                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  379:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  380:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  381:  jump *label277 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  382:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  383:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  384:  jump *label280 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label277                                              ...
  385:  jump *label278 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  386:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  387:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  388:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  389:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  390:  jump *label279 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label278                                              ...
  391:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label279                                              FlareController.mnd: elsif item == null then
        label *label280                                              FlareController.mnd: if item == @titanium then
        label *label282                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  392:  set .units*9 :backgroundProcess:unit                         ...
        label *label20                                               ...
  393:  write :backgroundProcess:count processor2 ".titaniumDrillCou FlareController.mnd: display.titaniumDrillCount = count;
  394:  jump *label15 always 0 0                                     FlareController.mnd: while true do
        label *label0                                                FlareController.mnd: remote void addTitaniumDrill(drill)
        # "Function: remote void addTitaniumDrill(in drill)"         ...
  395:  jump *label53 greaterThanEq .drills 9                        FlareController.mnd: if drills < length(titaniumDrills) - 1 then
  396:  op mul *tmp159 .drills 2                                     FlareController.mnd: titaniumDrills[drills] = drill;
  397:  multijump *label287 *tmp159 0                                ...
        multilabel *label287                                         ...
  398:  set .titaniumDrills*0 :addTitaniumDrill:drill                ...
  399:  jump *label286 always 0 0                                    ...
        multilabel *label288                                         ...
  400:  set .titaniumDrills*1 :addTitaniumDrill:drill                ...
  401:  jump *label286 always 0 0                                    ...
        multilabel *label289                                         ...
  402:  set .titaniumDrills*2 :addTitaniumDrill:drill                ...
  403:  jump *label286 always 0 0                                    ...
        multilabel *label290                                         ...
  404:  set .titaniumDrills*3 :addTitaniumDrill:drill                ...
  405:  jump *label286 always 0 0                                    ...
        multilabel *label291                                         ...
  406:  set .titaniumDrills*4 :addTitaniumDrill:drill                ...
  407:  jump *label286 always 0 0                                    ...
        multilabel *label292                                         ...
  408:  set .titaniumDrills*5 :addTitaniumDrill:drill                ...
  409:  jump *label286 always 0 0                                    ...
        multilabel *label293                                         ...
  410:  set .titaniumDrills*6 :addTitaniumDrill:drill                ...
  411:  jump *label286 always 0 0                                    ...
        multilabel *label294                                         ...
  412:  set .titaniumDrills*7 :addTitaniumDrill:drill                ...
  413:  jump *label286 always 0 0                                    ...
        multilabel *label295                                         ...
  414:  set .titaniumDrills*8 :addTitaniumDrill:drill                ...
  415:  jump *label286 always 0 0                                    ...
        multilabel *label296                                         ...
  416:  set .titaniumDrills*9 :addTitaniumDrill:drill                ...
        label *label286                                              ...
  417:  op add .drills .drills 1                                     FlareController.mnd: if drills < length(titaniumDrills) - 1 then
        label *label53                                               ...
  418:  set :addTitaniumDrill*finished true                          FlareController.mnd: remote void addTitaniumDrill(drill)
  419:  jump *label8 always 0 0                                      ...


Performance: parsed in 635 ms, compiled in 462 ms, optimized in 727 ms, run in 27 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (2 steps):
The program didn't generate any output.
Execution exception at instruction 2: read *tmp32 processor2 "*signature":
Variable 'processor2' is not an object.
(Use the '#set err-not-an-object = false;' directive or the '--err-not-an-object false' command line option to ignore this exception.)
