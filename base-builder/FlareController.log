   184 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
    22 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (6 iterations).
    12 instructions eliminated by Condition Optimization (7 iterations).
    17 instructions eliminated by Single Step Elimination (2 passes, 8 iterations).
     1 instructions modified by Expression Optimization (4 iterations).
     1 instructions eliminated by Boolean Optimization (7 iterations).
       1 fully-evaluated expressions optimized using selects.
     5 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
   331 instructions added by Loop Unrolling (5 iterations).
     1 loops unrolled by Loop Unrolling.
     1 instructions eliminated by Array Optimization (5 iterations).
    20 instructions eliminated by Jump Straightening (7 iterations).
    14 instructions eliminated by Unreachable Code Elimination (2 iterations).
   404 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 883):
  * Unroll iteration loop at FlareController.mnd:66:9            size  +331, benefit     1475.0, efficiency      4.456 (+331 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-15 instructions):
 
     6 jump *label8 notEqual *tmp32 "0:v1"
     7 set .drills 0
     8 set *signature "880295ee1d8ade1d:v1"
-    * set *waitaddr @counter
     9 label *label9
    10 # "Function: void backgroundProcess()"
    11 op equal *tmp33 .core null
 
    22 set .coreX *tmp38
    23 sensor *tmp39 .core @y
    24 set .coreY *tmp39
-    * set *tmp34 *tmp39
    25 jump *label12 always
    26 label *label11
-    * set *tmp34 null
    27 label *label12
    28 label *label16
    29 jump *label18 equal true false
 
    89 op equal *tmp41 :backgroundProcess:drill null
    90 jump *label32 equal *tmp41 false
    91 jump *label21 always
-    * set *tmp42 null
    92 jump *label33 always
    93 label *label32
-    * set *tmp42 null
    94 label *label33
    95 sensor *tmp43 :backgroundProcess:drill @titanium
    96 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   105 jump *label37 equal *tmp48 false
   106 set *tmp47 null
   107 jump *label36 always
-    * set *tmp49 null
   108 jump *label38 always
   109 label *label37
-    * set *tmp49 null
   110 label *label38
   111 set :findFreeUnit:first_unit @unit
   112 label *label39
 
   116 ucontrol flag :findFreeUnit:initial_flag
   117 set *tmp47 @unit
   118 jump *label36 always
-    * set *tmp52 null
   119 jump *label43 always
   120 label *label42
   121 sensor *tmp53 :findFreeUnit:first_unit @dead
 
   128 label *label44
   129 set *tmp55 null
   130 label *label45
-    * set *tmp52 *tmp55
   131 label *label43
   132 ubind :findFreeUnit:unit_type
   133 label *label40
 
   147 label *label46
   148 set *tmp59 null
   149 label *label47
-    * set *tmp46 *tmp59
   150 jump *label35 always
   151 label *label34
-    * set *tmp46 null
   152 label *label35
   153 # "Function: void serviceDrill(in drill, in unit)"
   154 set :serviceDrill:drill :backgroundProcess:drill
 
   160 jump *label49 equal *tmp61 false
   161 ucontrol approach .coreX .coreY 4
   162 ucontrol itemDrop .core 10
-    * set *tmp62 null
   163 jump *label50 always
   164 label *label49
   165 op equal *tmp63 :serviceDrill:item null
 
   174 ucontrol itemDrop @air 10
   175 set *tmp64 null
   176 label *label52
-    * set *tmp62 *tmp64
   177 label *label50
   178 label *label48
   179 label *label20
 
   197 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] *tmp69
   198 set *tmp71 .drills
   199 op add .drills .drills 1
-    * set *tmp68 *tmp71
   200 jump *label55 always
   201 label *label54
-    * set *tmp68 null
   202 label *label55
   203 label *label53
   204 set :addTitaniumDrill*finished true

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-7 instructions):
 
   123 jump *label44 equal *tmp54 false
   124 set *tmp56 @unit
   125 set :findFreeUnit:first_unit *tmp56
-    * set *tmp55 :findFreeUnit:first_unit
   126 jump *label45 always
   127 label *label44
-    * set *tmp55 null
   128 label *label45
   129 label *label43
   130 ubind :findFreeUnit:unit_type
 
   140 op equal *tmp58 :backgroundProcess:unit null
   141 jump *label46 equal *tmp58 false
   142 jump *label20 always
-    * set *tmp59 null
   143 jump *label47 always
   144 label *label46
-    * set *tmp59 null
   145 label *label47
   146 jump *label35 always
   147 label *label34
 
   164 sensor *tmp66 :serviceDrill:drill @y
   165 ucontrol approach *tmp65 *tmp66 4
   166 ucontrol itemTake :serviceDrill:drill @titanium 10
-    * set *tmp64 null
   167 jump *label52 always
   168 label *label51
   169 ucontrol itemDrop @air 10
-    * set *tmp64 null
   170 label *label52
   171 label *label50
   172 label *label48
 
   189 jump *label54 equal *tmp67 false
   190 set *tmp69 .drills
   191 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] *tmp69
-    * set *tmp71 .drills
   192 op add .drills .drills 1
   193 jump *label55 always
   194 label *label54

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
    12 jump *label11 equal *tmp33 false
    13 label *label13
    14 ubind @flare
-    * ulocate building core false @copper .coreX .coreY *tmp36 *tmp35
-    * set .core *tmp35
+   15 ulocate building core false @copper .coreX .coreY *tmp36 .core
    16 label *label14
    17 op equal *tmp37 .core null
    18 jump *label13 notEqual *tmp37 false
    19 label *label15
-    * sensor *tmp38 .core @x
-    * set .coreX *tmp38
-    * sensor *tmp39 .core @y
-    * set .coreY *tmp39
+   20 sensor .coreX .core @x
+   21 sensor .coreY .core @y
    22 jump *label12 always
    23 label *label11
    24 label *label12
 
   118 sensor *tmp53 :findFreeUnit:first_unit @dead
   119 op equal *tmp54 *tmp53 1
   120 jump *label44 equal *tmp54 false
-    * set *tmp56 @unit
-    * set :findFreeUnit:first_unit *tmp56
+  121 set :findFreeUnit:first_unit @unit
   122 jump *label45 always
   123 label *label44
   124 label *label45
 
   146 set :serviceDrill:drill :backgroundProcess:drill
   147 set :serviceDrill:unit :backgroundProcess:unit
   148 ubind :serviceDrill:unit
-    * sensor *tmp60 @unit @firstItem
-    * set :serviceDrill:item *tmp60
+  149 sensor :serviceDrill:item @unit @firstItem
   150 op equal *tmp61 :serviceDrill:item @titanium
   151 jump *label49 equal *tmp61 false
   152 ucontrol approach .coreX .coreY 4
 
   182 # "Function: export void addTitaniumDrill(in drill)"
   183 op lessThan *tmp67 .drills 9
   184 jump *label54 equal *tmp67 false
-    * set *tmp69 .drills
-    * writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] *tmp69
+  185 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] .drills
   186 op add .drills .drills 1
   187 jump *label55 always
   188 label *label54

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    23 label *label11
    24 label *label12
    25 label *label16
-    * jump *label18 equal true false
    26 set :backgroundProcess:count 0
    27 set :backgroundProcess:drill water
    28 set :backgroundProcess:unit .units*0

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-12 instructions):
 
     8 set *signature "880295ee1d8ade1d:v1"
     9 label *label9
    10 # "Function: void backgroundProcess()"
-    * op equal *tmp33 .core null
-    * jump *label11 equal *tmp33 false
+   11 jump *label11 notEqual .core null
    12 label *label13
    13 ubind @flare
    14 ulocate building core false @copper .coreX .coreY *tmp36 .core
    15 label *label14
-    * op equal *tmp37 .core null
-    * jump *label13 notEqual *tmp37 false
+   16 jump *label13 equal .core null
    17 label *label15
    18 sensor .coreX .core @x
    19 sensor .coreY .core @y
 
    80 set :backgroundProcess:unit .units*9
    81 set *tmp40 null
    82 label *label19
-    * op equal *tmp41 :backgroundProcess:drill null
-    * jump *label32 equal *tmp41 false
+   83 jump *label32 notEqual :backgroundProcess:drill null
    84 jump *label21 always
    85 jump *label33 always
    86 label *label32
 
    88 sensor *tmp43 :backgroundProcess:drill @titanium
    89 op add :backgroundProcess:count :backgroundProcess:count *tmp43
    90 sensor *tmp44 :backgroundProcess:unit @controller
-    * op notEqual *tmp45 *tmp44 @this
-    * jump *label34 equal *tmp45 false
+   91 jump *label34 equal *tmp44 @this
    92 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    93 set :findFreeUnit:unit_type @flare
    94 set :findFreeUnit:initial_flag 0
    95 ubind :findFreeUnit:unit_type
-    * op equal *tmp48 @unit null
-    * jump *label37 equal *tmp48 false
+   96 jump *label37 notEqual @unit null
    97 set *tmp47 null
    98 jump *label36 always
    99 jump *label38 always
 
   102 set :findFreeUnit:first_unit @unit
   103 label *label39
   104 sensor *tmp50 @unit @controlled
-    * op equal *tmp51 *tmp50 0
-    * jump *label42 equal *tmp51 false
+  105 jump *label42 notEqual *tmp50 0
   106 ucontrol flag :findFreeUnit:initial_flag
   107 set *tmp47 @unit
   108 jump *label36 always
   109 jump *label43 always
   110 label *label42
   111 sensor *tmp53 :findFreeUnit:first_unit @dead
-    * op equal *tmp54 *tmp53 1
-    * jump *label44 equal *tmp54 false
+  112 jump *label44 notEqual *tmp53 1
   113 set :findFreeUnit:first_unit @unit
   114 jump *label45 always
   115 label *label44
 
   117 label *label43
   118 ubind :findFreeUnit:unit_type
   119 label *label40
-    * op notEqual *tmp57 :findFreeUnit:first_unit @unit
-    * jump *label39 notEqual *tmp57 false
+  120 jump *label39 notEqual :findFreeUnit:first_unit @unit
   121 label *label41
   122 set *tmp47 null
   123 jump *label36 always
   124 set *tmp47 null
   125 label *label36
   126 set :backgroundProcess:unit *tmp47
-    * op equal *tmp58 :backgroundProcess:unit null
-    * jump *label46 equal *tmp58 false
+  127 jump *label46 notEqual :backgroundProcess:unit null
   128 jump *label20 always
   129 jump *label47 always
   130 label *label46
 
   137 set :serviceDrill:unit :backgroundProcess:unit
   138 ubind :serviceDrill:unit
   139 sensor :serviceDrill:item @unit @firstItem
-    * op equal *tmp61 :serviceDrill:item @titanium
-    * jump *label49 equal *tmp61 false
+  140 jump *label49 notEqual :serviceDrill:item @titanium
   141 ucontrol approach .coreX .coreY 4
   142 ucontrol itemDrop .core 10
   143 jump *label50 always
   144 label *label49
-    * op equal *tmp63 :serviceDrill:item null
-    * jump *label51 equal *tmp63 false
+  145 jump *label51 notEqual :serviceDrill:item null
   146 sensor *tmp65 :serviceDrill:drill @x
   147 sensor *tmp66 :serviceDrill:drill @y
   148 ucontrol approach *tmp65 *tmp66 4
 
   168 end
   169 label *label0
   170 # "Function: export void addTitaniumDrill(in drill)"
-    * op lessThan *tmp67 .drills 9
-    * jump *label54 equal *tmp67 false
+  171 jump *label54 greaterThanEq .drills 9
   172 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] .drills
   173 op add .drills .drills 1
   174 jump *label55 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    17 label *label15
    18 sensor .coreX .core @x
    19 sensor .coreY .core @y
-    * jump *label12 always
    20 label *label11
    21 label *label12
    22 label *label16
 
    81 label *label19
    82 jump *label32 notEqual :backgroundProcess:drill null
    83 jump *label21 always
-    * jump *label33 always
    84 label *label32
    85 label *label33
    86 sensor *tmp43 :backgroundProcess:drill @titanium
 
    94 jump *label37 notEqual @unit null
    95 set *tmp47 null
    96 jump *label36 always
-    * jump *label38 always
    97 label *label37
    98 label *label38
    99 set :findFreeUnit:first_unit @unit
 
   108 sensor *tmp53 :findFreeUnit:first_unit @dead
   109 jump *label44 notEqual *tmp53 1
   110 set :findFreeUnit:first_unit @unit
-    * jump *label45 always
   111 label *label44
   112 label *label45
   113 label *label43
 
   122 set :backgroundProcess:unit *tmp47
   123 jump *label46 notEqual :backgroundProcess:unit null
   124 jump *label20 always
-    * jump *label47 always
   125 label *label46
   126 label *label47
-    * jump *label35 always
   127 label *label34
   128 label *label35
   129 # "Function: void serviceDrill(in drill, in unit)"
 
   165 jump *label54 greaterThanEq .drills 9
   166 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] .drills
   167 op add .drills .drills 1
-    * jump *label55 always
   168 label *label54
   169 label *label55
   170 label *label53

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    90 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    91 set :findFreeUnit:unit_type @flare
    92 set :findFreeUnit:initial_flag 0
-    * ubind :findFreeUnit:unit_type
+   93 ubind @flare
    94 jump *label37 notEqual @unit null
    95 set *tmp47 null
    96 jump *label36 always
 
   100 label *label39
   101 sensor *tmp50 @unit @controlled
   102 jump *label42 notEqual *tmp50 0
-    * ucontrol flag :findFreeUnit:initial_flag
+  103 ucontrol flag 0
   104 set *tmp47 @unit
   105 jump *label36 always
   106 jump *label43 always
 
   111 label *label44
   112 label *label45
   113 label *label43
-    * ubind :findFreeUnit:unit_type
+  114 ubind @flare
   115 label *label40
   116 jump *label39 notEqual :findFreeUnit:first_unit @unit
   117 label *label41
   118 set *tmp47 null
   119 jump *label36 always
-    * set *tmp47 null
   120 label *label36
   121 set :backgroundProcess:unit *tmp47
-    * jump *label46 notEqual :backgroundProcess:unit null
+  122 jump *label46 notEqual *tmp47 null
   123 jump *label20 always
   124 label *label46
   125 label *label47
 
   128 # "Function: void serviceDrill(in drill, in unit)"
   129 set :serviceDrill:drill :backgroundProcess:drill
   130 set :serviceDrill:unit :backgroundProcess:unit
-    * ubind :serviceDrill:unit
+  131 ubind :backgroundProcess:unit
   132 sensor :serviceDrill:item @unit @firstItem
   133 jump *label49 notEqual :serviceDrill:item @titanium
   134 ucontrol approach .coreX .coreY 4
 
   136 jump *label50 always
   137 label *label49
   138 jump *label51 notEqual :serviceDrill:item null
-    * sensor *tmp65 :serviceDrill:drill @x
-    * sensor *tmp66 :serviceDrill:drill @y
+  139 sensor *tmp65 :backgroundProcess:drill @x
+  140 sensor *tmp66 :backgroundProcess:drill @y
   141 ucontrol approach *tmp65 *tmp66 4
-    * ucontrol itemTake :serviceDrill:drill @titanium 10
+  142 ucontrol itemTake :backgroundProcess:drill @titanium 10
   143 jump *label52 always
   144 label *label51
   145 ucontrol itemDrop @air 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    88 sensor *tmp44 :backgroundProcess:unit @controller
    89 jump *label34 equal *tmp44 @this
    90 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * set :findFreeUnit:unit_type @flare
-    * set :findFreeUnit:initial_flag 0
    91 ubind @flare
    92 jump *label37 notEqual @unit null
    93 set *tmp47 null
 
   124 label *label34
   125 label *label35
   126 # "Function: void serviceDrill(in drill, in unit)"
-    * set :serviceDrill:drill :backgroundProcess:drill
-    * set :serviceDrill:unit :backgroundProcess:unit
   127 ubind :backgroundProcess:unit
   128 sensor :serviceDrill:item @unit @firstItem
   129 jump *label49 notEqual :serviceDrill:item @titanium

Modifications by Iterated phase, Array Optimization, pass 1, iteration 1 (-13 instructions):
 
   158 label *label0
   159 # "Function: export void addTitaniumDrill(in drill)"
   160 jump *label54 greaterThanEq .drills 9
-    * writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  161 writearr<lookup:liquid> :addTitaniumDrill:drill .titaniumDrills[] .drills
   162 op add .drills .drills 1
   163 label *label54
   164 label *label55

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
   103 jump *label36 always
   104 jump *label43 always
   105 label *label42
-    * sensor *tmp53 :findFreeUnit:first_unit @dead
-    * jump *label44 notEqual *tmp53 1
-    * set :findFreeUnit:first_unit @unit
-    * label *label44
-    * label *label45
+  106 sensor *tmp53 :findFreeUnit:first_unit @dead
+  107 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   108 label *label43
   109 ubind @flare
   110 label *label40

Modifications by Unroll iteration loop at FlareController.mnd:66:9 (+331 instructions):
 
    21 label *label12
    22 label *label16
    23 set :backgroundProcess:count 0
-    * set :backgroundProcess:drill water
-    * set :backgroundProcess:unit .units*0
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label22 (m:marker0)
-    * set .units*0 :backgroundProcess:unit
-    * set :backgroundProcess:drill slag
-    * set :backgroundProcess:unit .units*1
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label23 (m:marker0)
-    * set .units*1 :backgroundProcess:unit
-    * set :backgroundProcess:drill oil
-    * set :backgroundProcess:unit .units*2
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label24 (m:marker0)
-    * set .units*2 :backgroundProcess:unit
-    * set :backgroundProcess:drill cryofluid
-    * set :backgroundProcess:unit .units*3
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label25 (m:marker0)
-    * set .units*3 :backgroundProcess:unit
-    * set :backgroundProcess:drill neoplasm
-    * set :backgroundProcess:unit .units*4
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label26 (m:marker0)
-    * set .units*4 :backgroundProcess:unit
-    * set :backgroundProcess:drill hydrogen
-    * set :backgroundProcess:unit .units*5
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label27 (m:marker0)
-    * set .units*5 :backgroundProcess:unit
-    * set :backgroundProcess:drill ozone
-    * set :backgroundProcess:unit .units*6
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label28 (m:marker0)
-    * set .units*6 :backgroundProcess:unit
-    * set :backgroundProcess:drill cyanogen
-    * set :backgroundProcess:unit .units*7
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label29 (m:marker0)
-    * set .units*7 :backgroundProcess:unit
-    * set :backgroundProcess:drill gallium
-    * set :backgroundProcess:unit .units*8
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label30 (m:marker0)
-    * set .units*8 :backgroundProcess:unit
-    * set :backgroundProcess:drill nitrogen
-    * set :backgroundProcess:unit .units*9
-    * set *tmp40 null
-    * label *label19
-    * jump *label32 notEqual :backgroundProcess:drill null
-    * jump *label21 always
-    * label *label32
-    * label *label33
-    * sensor *tmp43 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count :backgroundProcess:count *tmp43
-    * sensor *tmp44 :backgroundProcess:unit @controller
-    * jump *label34 equal *tmp44 @this
-    * # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * ubind @flare
-    * jump *label37 notEqual @unit null
-    * set *tmp47 null
-    * jump *label36 always
-    * label *label37
-    * label *label38
-    * set :findFreeUnit:first_unit @unit
-    * label *label39
-    * sensor *tmp50 @unit @controlled
-    * jump *label42 notEqual *tmp50 0
-    * ucontrol flag 0
-    * set *tmp47 @unit
-    * jump *label36 always
-    * jump *label43 always
-    * label *label42
-    * sensor *tmp53 :findFreeUnit:first_unit @dead
-    * select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label43
-    * ubind @flare
-    * label *label40
-    * jump *label39 notEqual :findFreeUnit:first_unit @unit
-    * label *label41
-    * set *tmp47 null
-    * jump *label36 always
-    * label *label36
-    * set :backgroundProcess:unit *tmp47
-    * jump *label46 notEqual *tmp47 null
-    * jump *label20 always
-    * label *label46
-    * label *label47
-    * label *label34
-    * label *label35
-    * # "Function: void serviceDrill(in drill, in unit)"
-    * ubind :backgroundProcess:unit
-    * sensor :serviceDrill:item @unit @firstItem
-    * jump *label49 notEqual :serviceDrill:item @titanium
-    * ucontrol approach .coreX .coreY 4
-    * ucontrol itemDrop .core 10
-    * jump *label50 always
-    * label *label49
-    * jump *label51 notEqual :serviceDrill:item null
-    * sensor *tmp65 :backgroundProcess:drill @x
-    * sensor *tmp66 :backgroundProcess:drill @y
-    * ucontrol approach *tmp65 *tmp66 4
-    * ucontrol itemTake :backgroundProcess:drill @titanium 10
-    * jump *label52 always
-    * label *label51
-    * ucontrol itemDrop @air 10
-    * label *label52
-    * label *label50
-    * label *label48
-    * label *label20
-    * multijump *tmp40 0 0 (m:marker0)
-    * multilabel *label31 (m:marker0)
-    * set .units*9 :backgroundProcess:unit
-    * label *label21
+   24 set :backgroundProcess:drill water
+   25 set :backgroundProcess:unit .units*0
+   26 label *label56
+   27 jump *label57 notEqual :backgroundProcess:drill null
+   28 jump *label21 always
+   29 label *label57
+   30 label *label58
+   31 sensor *tmp43 :backgroundProcess:drill @titanium
+   32 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+   33 sensor *tmp44 :backgroundProcess:unit @controller
+   34 jump *label69 equal *tmp44 @this
+   35 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+   36 ubind @flare
+   37 jump *label59 notEqual @unit null
+   38 set *tmp47 null
+   39 jump *label66 always
+   40 label *label59
+   41 label *label60
+   42 set :findFreeUnit:first_unit @unit
+   43 label *label61
+   44 sensor *tmp50 @unit @controlled
+   45 jump *label62 notEqual *tmp50 0
+   46 ucontrol flag 0
+   47 set *tmp47 @unit
+   48 jump *label66 always
+   49 jump *label63 always
+   50 label *label62
+   51 sensor *tmp53 :findFreeUnit:first_unit @dead
+   52 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+   53 label *label63
+   54 ubind @flare
+   55 label *label64
+   56 jump *label61 notEqual :findFreeUnit:first_unit @unit
+   57 label *label65
+   58 set *tmp47 null
+   59 jump *label66 always
+   60 label *label66
+   61 set :backgroundProcess:unit *tmp47
+   62 jump *label67 notEqual *tmp47 null
+   63 jump *label76 always
+   64 label *label67
+   65 label *label68
+   66 label *label69
+   67 label *label70
+   68 # "Function: void serviceDrill(in drill, in unit)"
+   69 ubind :backgroundProcess:unit
+   70 sensor :serviceDrill:item @unit @firstItem
+   71 jump *label71 notEqual :serviceDrill:item @titanium
+   72 ucontrol approach .coreX .coreY 4
+   73 ucontrol itemDrop .core 10
+   74 jump *label74 always
+   75 label *label71
+   76 jump *label72 notEqual :serviceDrill:item null
+   77 sensor *tmp65 :backgroundProcess:drill @x
+   78 sensor *tmp66 :backgroundProcess:drill @y
+   79 ucontrol approach *tmp65 *tmp66 4
+   80 ucontrol itemTake :backgroundProcess:drill @titanium 10
+   81 jump *label73 always
+   82 label *label72
+   83 ucontrol itemDrop @air 10
+   84 label *label73
+   85 label *label74
+   86 label *label75
+   87 label *label76
+   88 set .units*0 :backgroundProcess:unit
+   89 set :backgroundProcess:drill slag
+   90 set :backgroundProcess:unit .units*1
+   91 label *label79
+   92 jump *label80 notEqual :backgroundProcess:drill null
+   93 jump *label21 always
+   94 label *label80
+   95 label *label81
+   96 sensor *tmp43 :backgroundProcess:drill @titanium
+   97 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+   98 sensor *tmp44 :backgroundProcess:unit @controller
+   99 jump *label92 equal *tmp44 @this
+  100 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  101 ubind @flare
+  102 jump *label82 notEqual @unit null
+  103 set *tmp47 null
+  104 jump *label89 always
+  105 label *label82
+  106 label *label83
+  107 set :findFreeUnit:first_unit @unit
+  108 label *label84
+  109 sensor *tmp50 @unit @controlled
+  110 jump *label85 notEqual *tmp50 0
+  111 ucontrol flag 0
+  112 set *tmp47 @unit
+  113 jump *label89 always
+  114 jump *label86 always
+  115 label *label85
+  116 sensor *tmp53 :findFreeUnit:first_unit @dead
+  117 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  118 label *label86
+  119 ubind @flare
+  120 label *label87
+  121 jump *label84 notEqual :findFreeUnit:first_unit @unit
+  122 label *label88
+  123 set *tmp47 null
+  124 jump *label89 always
+  125 label *label89
+  126 set :backgroundProcess:unit *tmp47
+  127 jump *label90 notEqual *tmp47 null
+  128 jump *label99 always
+  129 label *label90
+  130 label *label91
+  131 label *label92
+  132 label *label93
+  133 # "Function: void serviceDrill(in drill, in unit)"
+  134 ubind :backgroundProcess:unit
+  135 sensor :serviceDrill:item @unit @firstItem
+  136 jump *label94 notEqual :serviceDrill:item @titanium
+  137 ucontrol approach .coreX .coreY 4
+  138 ucontrol itemDrop .core 10
+  139 jump *label97 always
+  140 label *label94
+  141 jump *label95 notEqual :serviceDrill:item null
+  142 sensor *tmp65 :backgroundProcess:drill @x
+  143 sensor *tmp66 :backgroundProcess:drill @y
+  144 ucontrol approach *tmp65 *tmp66 4
+  145 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  146 jump *label96 always
+  147 label *label95
+  148 ucontrol itemDrop @air 10
+  149 label *label96
+  150 label *label97
+  151 label *label98
+  152 label *label99
+  153 set .units*1 :backgroundProcess:unit
+  154 set :backgroundProcess:drill oil
+  155 set :backgroundProcess:unit .units*2
+  156 label *label102
+  157 jump *label103 notEqual :backgroundProcess:drill null
+  158 jump *label21 always
+  159 label *label103
+  160 label *label104
+  161 sensor *tmp43 :backgroundProcess:drill @titanium
+  162 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  163 sensor *tmp44 :backgroundProcess:unit @controller
+  164 jump *label115 equal *tmp44 @this
+  165 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  166 ubind @flare
+  167 jump *label105 notEqual @unit null
+  168 set *tmp47 null
+  169 jump *label112 always
+  170 label *label105
+  171 label *label106
+  172 set :findFreeUnit:first_unit @unit
+  173 label *label107
+  174 sensor *tmp50 @unit @controlled
+  175 jump *label108 notEqual *tmp50 0
+  176 ucontrol flag 0
+  177 set *tmp47 @unit
+  178 jump *label112 always
+  179 jump *label109 always
+  180 label *label108
+  181 sensor *tmp53 :findFreeUnit:first_unit @dead
+  182 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  183 label *label109
+  184 ubind @flare
+  185 label *label110
+  186 jump *label107 notEqual :findFreeUnit:first_unit @unit
+  187 label *label111
+  188 set *tmp47 null
+  189 jump *label112 always
+  190 label *label112
+  191 set :backgroundProcess:unit *tmp47
+  192 jump *label113 notEqual *tmp47 null
+  193 jump *label122 always
+  194 label *label113
+  195 label *label114
+  196 label *label115
+  197 label *label116
+  198 # "Function: void serviceDrill(in drill, in unit)"
+  199 ubind :backgroundProcess:unit
+  200 sensor :serviceDrill:item @unit @firstItem
+  201 jump *label117 notEqual :serviceDrill:item @titanium
+  202 ucontrol approach .coreX .coreY 4
+  203 ucontrol itemDrop .core 10
+  204 jump *label120 always
+  205 label *label117
+  206 jump *label118 notEqual :serviceDrill:item null
+  207 sensor *tmp65 :backgroundProcess:drill @x
+  208 sensor *tmp66 :backgroundProcess:drill @y
+  209 ucontrol approach *tmp65 *tmp66 4
+  210 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  211 jump *label119 always
+  212 label *label118
+  213 ucontrol itemDrop @air 10
+  214 label *label119
+  215 label *label120
+  216 label *label121
+  217 label *label122
+  218 set .units*2 :backgroundProcess:unit
+  219 set :backgroundProcess:drill cryofluid
+  220 set :backgroundProcess:unit .units*3
+  221 label *label125
+  222 jump *label126 notEqual :backgroundProcess:drill null
+  223 jump *label21 always
+  224 label *label126
+  225 label *label127
+  226 sensor *tmp43 :backgroundProcess:drill @titanium
+  227 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  228 sensor *tmp44 :backgroundProcess:unit @controller
+  229 jump *label138 equal *tmp44 @this
+  230 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  231 ubind @flare
+  232 jump *label128 notEqual @unit null
+  233 set *tmp47 null
+  234 jump *label135 always
+  235 label *label128
+  236 label *label129
+  237 set :findFreeUnit:first_unit @unit
+  238 label *label130
+  239 sensor *tmp50 @unit @controlled
+  240 jump *label131 notEqual *tmp50 0
+  241 ucontrol flag 0
+  242 set *tmp47 @unit
+  243 jump *label135 always
+  244 jump *label132 always
+  245 label *label131
+  246 sensor *tmp53 :findFreeUnit:first_unit @dead
+  247 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  248 label *label132
+  249 ubind @flare
+  250 label *label133
+  251 jump *label130 notEqual :findFreeUnit:first_unit @unit
+  252 label *label134
+  253 set *tmp47 null
+  254 jump *label135 always
+  255 label *label135
+  256 set :backgroundProcess:unit *tmp47
+  257 jump *label136 notEqual *tmp47 null
+  258 jump *label145 always
+  259 label *label136
+  260 label *label137
+  261 label *label138
+  262 label *label139
+  263 # "Function: void serviceDrill(in drill, in unit)"
+  264 ubind :backgroundProcess:unit
+  265 sensor :serviceDrill:item @unit @firstItem
+  266 jump *label140 notEqual :serviceDrill:item @titanium
+  267 ucontrol approach .coreX .coreY 4
+  268 ucontrol itemDrop .core 10
+  269 jump *label143 always
+  270 label *label140
+  271 jump *label141 notEqual :serviceDrill:item null
+  272 sensor *tmp65 :backgroundProcess:drill @x
+  273 sensor *tmp66 :backgroundProcess:drill @y
+  274 ucontrol approach *tmp65 *tmp66 4
+  275 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  276 jump *label142 always
+  277 label *label141
+  278 ucontrol itemDrop @air 10
+  279 label *label142
+  280 label *label143
+  281 label *label144
+  282 label *label145
+  283 set .units*3 :backgroundProcess:unit
+  284 set :backgroundProcess:drill neoplasm
+  285 set :backgroundProcess:unit .units*4
+  286 label *label148
+  287 jump *label149 notEqual :backgroundProcess:drill null
+  288 jump *label21 always
+  289 label *label149
+  290 label *label150
+  291 sensor *tmp43 :backgroundProcess:drill @titanium
+  292 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  293 sensor *tmp44 :backgroundProcess:unit @controller
+  294 jump *label161 equal *tmp44 @this
+  295 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  296 ubind @flare
+  297 jump *label151 notEqual @unit null
+  298 set *tmp47 null
+  299 jump *label158 always
+  300 label *label151
+  301 label *label152
+  302 set :findFreeUnit:first_unit @unit
+  303 label *label153
+  304 sensor *tmp50 @unit @controlled
+  305 jump *label154 notEqual *tmp50 0
+  306 ucontrol flag 0
+  307 set *tmp47 @unit
+  308 jump *label158 always
+  309 jump *label155 always
+  310 label *label154
+  311 sensor *tmp53 :findFreeUnit:first_unit @dead
+  312 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  313 label *label155
+  314 ubind @flare
+  315 label *label156
+  316 jump *label153 notEqual :findFreeUnit:first_unit @unit
+  317 label *label157
+  318 set *tmp47 null
+  319 jump *label158 always
+  320 label *label158
+  321 set :backgroundProcess:unit *tmp47
+  322 jump *label159 notEqual *tmp47 null
+  323 jump *label168 always
+  324 label *label159
+  325 label *label160
+  326 label *label161
+  327 label *label162
+  328 # "Function: void serviceDrill(in drill, in unit)"
+  329 ubind :backgroundProcess:unit
+  330 sensor :serviceDrill:item @unit @firstItem
+  331 jump *label163 notEqual :serviceDrill:item @titanium
+  332 ucontrol approach .coreX .coreY 4
+  333 ucontrol itemDrop .core 10
+  334 jump *label166 always
+  335 label *label163
+  336 jump *label164 notEqual :serviceDrill:item null
+  337 sensor *tmp65 :backgroundProcess:drill @x
+  338 sensor *tmp66 :backgroundProcess:drill @y
+  339 ucontrol approach *tmp65 *tmp66 4
+  340 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  341 jump *label165 always
+  342 label *label164
+  343 ucontrol itemDrop @air 10
+  344 label *label165
+  345 label *label166
+  346 label *label167
+  347 label *label168
+  348 set .units*4 :backgroundProcess:unit
+  349 set :backgroundProcess:drill hydrogen
+  350 set :backgroundProcess:unit .units*5
+  351 label *label171
+  352 jump *label172 notEqual :backgroundProcess:drill null
+  353 jump *label21 always
+  354 label *label172
+  355 label *label173
+  356 sensor *tmp43 :backgroundProcess:drill @titanium
+  357 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  358 sensor *tmp44 :backgroundProcess:unit @controller
+  359 jump *label184 equal *tmp44 @this
+  360 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  361 ubind @flare
+  362 jump *label174 notEqual @unit null
+  363 set *tmp47 null
+  364 jump *label181 always
+  365 label *label174
+  366 label *label175
+  367 set :findFreeUnit:first_unit @unit
+  368 label *label176
+  369 sensor *tmp50 @unit @controlled
+  370 jump *label177 notEqual *tmp50 0
+  371 ucontrol flag 0
+  372 set *tmp47 @unit
+  373 jump *label181 always
+  374 jump *label178 always
+  375 label *label177
+  376 sensor *tmp53 :findFreeUnit:first_unit @dead
+  377 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  378 label *label178
+  379 ubind @flare
+  380 label *label179
+  381 jump *label176 notEqual :findFreeUnit:first_unit @unit
+  382 label *label180
+  383 set *tmp47 null
+  384 jump *label181 always
+  385 label *label181
+  386 set :backgroundProcess:unit *tmp47
+  387 jump *label182 notEqual *tmp47 null
+  388 jump *label191 always
+  389 label *label182
+  390 label *label183
+  391 label *label184
+  392 label *label185
+  393 # "Function: void serviceDrill(in drill, in unit)"
+  394 ubind :backgroundProcess:unit
+  395 sensor :serviceDrill:item @unit @firstItem
+  396 jump *label186 notEqual :serviceDrill:item @titanium
+  397 ucontrol approach .coreX .coreY 4
+  398 ucontrol itemDrop .core 10
+  399 jump *label189 always
+  400 label *label186
+  401 jump *label187 notEqual :serviceDrill:item null
+  402 sensor *tmp65 :backgroundProcess:drill @x
+  403 sensor *tmp66 :backgroundProcess:drill @y
+  404 ucontrol approach *tmp65 *tmp66 4
+  405 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  406 jump *label188 always
+  407 label *label187
+  408 ucontrol itemDrop @air 10
+  409 label *label188
+  410 label *label189
+  411 label *label190
+  412 label *label191
+  413 set .units*5 :backgroundProcess:unit
+  414 set :backgroundProcess:drill ozone
+  415 set :backgroundProcess:unit .units*6
+  416 label *label194
+  417 jump *label195 notEqual :backgroundProcess:drill null
+  418 jump *label21 always
+  419 label *label195
+  420 label *label196
+  421 sensor *tmp43 :backgroundProcess:drill @titanium
+  422 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  423 sensor *tmp44 :backgroundProcess:unit @controller
+  424 jump *label207 equal *tmp44 @this
+  425 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  426 ubind @flare
+  427 jump *label197 notEqual @unit null
+  428 set *tmp47 null
+  429 jump *label204 always
+  430 label *label197
+  431 label *label198
+  432 set :findFreeUnit:first_unit @unit
+  433 label *label199
+  434 sensor *tmp50 @unit @controlled
+  435 jump *label200 notEqual *tmp50 0
+  436 ucontrol flag 0
+  437 set *tmp47 @unit
+  438 jump *label204 always
+  439 jump *label201 always
+  440 label *label200
+  441 sensor *tmp53 :findFreeUnit:first_unit @dead
+  442 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  443 label *label201
+  444 ubind @flare
+  445 label *label202
+  446 jump *label199 notEqual :findFreeUnit:first_unit @unit
+  447 label *label203
+  448 set *tmp47 null
+  449 jump *label204 always
+  450 label *label204
+  451 set :backgroundProcess:unit *tmp47
+  452 jump *label205 notEqual *tmp47 null
+  453 jump *label214 always
+  454 label *label205
+  455 label *label206
+  456 label *label207
+  457 label *label208
+  458 # "Function: void serviceDrill(in drill, in unit)"
+  459 ubind :backgroundProcess:unit
+  460 sensor :serviceDrill:item @unit @firstItem
+  461 jump *label209 notEqual :serviceDrill:item @titanium
+  462 ucontrol approach .coreX .coreY 4
+  463 ucontrol itemDrop .core 10
+  464 jump *label212 always
+  465 label *label209
+  466 jump *label210 notEqual :serviceDrill:item null
+  467 sensor *tmp65 :backgroundProcess:drill @x
+  468 sensor *tmp66 :backgroundProcess:drill @y
+  469 ucontrol approach *tmp65 *tmp66 4
+  470 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  471 jump *label211 always
+  472 label *label210
+  473 ucontrol itemDrop @air 10
+  474 label *label211
+  475 label *label212
+  476 label *label213
+  477 label *label214
+  478 set .units*6 :backgroundProcess:unit
+  479 set :backgroundProcess:drill cyanogen
+  480 set :backgroundProcess:unit .units*7
+  481 label *label217
+  482 jump *label218 notEqual :backgroundProcess:drill null
+  483 jump *label21 always
+  484 label *label218
+  485 label *label219
+  486 sensor *tmp43 :backgroundProcess:drill @titanium
+  487 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  488 sensor *tmp44 :backgroundProcess:unit @controller
+  489 jump *label230 equal *tmp44 @this
+  490 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  491 ubind @flare
+  492 jump *label220 notEqual @unit null
+  493 set *tmp47 null
+  494 jump *label227 always
+  495 label *label220
+  496 label *label221
+  497 set :findFreeUnit:first_unit @unit
+  498 label *label222
+  499 sensor *tmp50 @unit @controlled
+  500 jump *label223 notEqual *tmp50 0
+  501 ucontrol flag 0
+  502 set *tmp47 @unit
+  503 jump *label227 always
+  504 jump *label224 always
+  505 label *label223
+  506 sensor *tmp53 :findFreeUnit:first_unit @dead
+  507 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  508 label *label224
+  509 ubind @flare
+  510 label *label225
+  511 jump *label222 notEqual :findFreeUnit:first_unit @unit
+  512 label *label226
+  513 set *tmp47 null
+  514 jump *label227 always
+  515 label *label227
+  516 set :backgroundProcess:unit *tmp47
+  517 jump *label228 notEqual *tmp47 null
+  518 jump *label237 always
+  519 label *label228
+  520 label *label229
+  521 label *label230
+  522 label *label231
+  523 # "Function: void serviceDrill(in drill, in unit)"
+  524 ubind :backgroundProcess:unit
+  525 sensor :serviceDrill:item @unit @firstItem
+  526 jump *label232 notEqual :serviceDrill:item @titanium
+  527 ucontrol approach .coreX .coreY 4
+  528 ucontrol itemDrop .core 10
+  529 jump *label235 always
+  530 label *label232
+  531 jump *label233 notEqual :serviceDrill:item null
+  532 sensor *tmp65 :backgroundProcess:drill @x
+  533 sensor *tmp66 :backgroundProcess:drill @y
+  534 ucontrol approach *tmp65 *tmp66 4
+  535 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  536 jump *label234 always
+  537 label *label233
+  538 ucontrol itemDrop @air 10
+  539 label *label234
+  540 label *label235
+  541 label *label236
+  542 label *label237
+  543 set .units*7 :backgroundProcess:unit
+  544 set :backgroundProcess:drill gallium
+  545 set :backgroundProcess:unit .units*8
+  546 label *label240
+  547 jump *label241 notEqual :backgroundProcess:drill null
+  548 jump *label21 always
+  549 label *label241
+  550 label *label242
+  551 sensor *tmp43 :backgroundProcess:drill @titanium
+  552 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  553 sensor *tmp44 :backgroundProcess:unit @controller
+  554 jump *label253 equal *tmp44 @this
+  555 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  556 ubind @flare
+  557 jump *label243 notEqual @unit null
+  558 set *tmp47 null
+  559 jump *label250 always
+  560 label *label243
+  561 label *label244
+  562 set :findFreeUnit:first_unit @unit
+  563 label *label245
+  564 sensor *tmp50 @unit @controlled
+  565 jump *label246 notEqual *tmp50 0
+  566 ucontrol flag 0
+  567 set *tmp47 @unit
+  568 jump *label250 always
+  569 jump *label247 always
+  570 label *label246
+  571 sensor *tmp53 :findFreeUnit:first_unit @dead
+  572 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  573 label *label247
+  574 ubind @flare
+  575 label *label248
+  576 jump *label245 notEqual :findFreeUnit:first_unit @unit
+  577 label *label249
+  578 set *tmp47 null
+  579 jump *label250 always
+  580 label *label250
+  581 set :backgroundProcess:unit *tmp47
+  582 jump *label251 notEqual *tmp47 null
+  583 jump *label260 always
+  584 label *label251
+  585 label *label252
+  586 label *label253
+  587 label *label254
+  588 # "Function: void serviceDrill(in drill, in unit)"
+  589 ubind :backgroundProcess:unit
+  590 sensor :serviceDrill:item @unit @firstItem
+  591 jump *label255 notEqual :serviceDrill:item @titanium
+  592 ucontrol approach .coreX .coreY 4
+  593 ucontrol itemDrop .core 10
+  594 jump *label258 always
+  595 label *label255
+  596 jump *label256 notEqual :serviceDrill:item null
+  597 sensor *tmp65 :backgroundProcess:drill @x
+  598 sensor *tmp66 :backgroundProcess:drill @y
+  599 ucontrol approach *tmp65 *tmp66 4
+  600 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  601 jump *label257 always
+  602 label *label256
+  603 ucontrol itemDrop @air 10
+  604 label *label257
+  605 label *label258
+  606 label *label259
+  607 label *label260
+  608 set .units*8 :backgroundProcess:unit
+  609 set :backgroundProcess:drill nitrogen
+  610 set :backgroundProcess:unit .units*9
+  611 label *label263
+  612 jump *label264 notEqual :backgroundProcess:drill null
+  613 jump *label21 always
+  614 label *label264
+  615 label *label265
+  616 sensor *tmp43 :backgroundProcess:drill @titanium
+  617 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  618 sensor *tmp44 :backgroundProcess:unit @controller
+  619 jump *label276 equal *tmp44 @this
+  620 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  621 ubind @flare
+  622 jump *label266 notEqual @unit null
+  623 set *tmp47 null
+  624 jump *label273 always
+  625 label *label266
+  626 label *label267
+  627 set :findFreeUnit:first_unit @unit
+  628 label *label268
+  629 sensor *tmp50 @unit @controlled
+  630 jump *label269 notEqual *tmp50 0
+  631 ucontrol flag 0
+  632 set *tmp47 @unit
+  633 jump *label273 always
+  634 jump *label270 always
+  635 label *label269
+  636 sensor *tmp53 :findFreeUnit:first_unit @dead
+  637 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  638 label *label270
+  639 ubind @flare
+  640 label *label271
+  641 jump *label268 notEqual :findFreeUnit:first_unit @unit
+  642 label *label272
+  643 set *tmp47 null
+  644 jump *label273 always
+  645 label *label273
+  646 set :backgroundProcess:unit *tmp47
+  647 jump *label274 notEqual *tmp47 null
+  648 jump *label283 always
+  649 label *label274
+  650 label *label275
+  651 label *label276
+  652 label *label277
+  653 # "Function: void serviceDrill(in drill, in unit)"
+  654 ubind :backgroundProcess:unit
+  655 sensor :serviceDrill:item @unit @firstItem
+  656 jump *label278 notEqual :serviceDrill:item @titanium
+  657 ucontrol approach .coreX .coreY 4
+  658 ucontrol itemDrop .core 10
+  659 jump *label281 always
+  660 label *label278
+  661 jump *label279 notEqual :serviceDrill:item null
+  662 sensor *tmp65 :backgroundProcess:drill @x
+  663 sensor *tmp66 :backgroundProcess:drill @y
+  664 ucontrol approach *tmp65 *tmp66 4
+  665 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  666 jump *label280 always
+  667 label *label279
+  668 ucontrol itemDrop @air 10
+  669 label *label280
+  670 label *label281
+  671 label *label282
+  672 label *label283
+  673 set .units*9 :backgroundProcess:unit
+  674 label *label21
   675 write :backgroundProcess:count processor2 ".titaniumDrillCount"
   676 label *label17
   677 jump *label16 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    29 label *label57
    30 label *label58
    31 sensor *tmp43 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count :backgroundProcess:count *tmp43
+   32 op add :backgroundProcess:count 0 *tmp43
    33 sensor *tmp44 :backgroundProcess:unit @controller
    34 jump *label69 equal *tmp44 @this
    35 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-10 instructions):
 
    56 jump *label61 notEqual :findFreeUnit:first_unit @unit
    57 label *label65
    58 set *tmp47 null
-    * jump *label66 always
    59 label *label66
    60 set :backgroundProcess:unit *tmp47
    61 jump *label67 notEqual *tmp47 null
 
   120 jump *label84 notEqual :findFreeUnit:first_unit @unit
   121 label *label88
   122 set *tmp47 null
-    * jump *label89 always
   123 label *label89
   124 set :backgroundProcess:unit *tmp47
   125 jump *label90 notEqual *tmp47 null
 
   184 jump *label107 notEqual :findFreeUnit:first_unit @unit
   185 label *label111
   186 set *tmp47 null
-    * jump *label112 always
   187 label *label112
   188 set :backgroundProcess:unit *tmp47
   189 jump *label113 notEqual *tmp47 null
 
   248 jump *label130 notEqual :findFreeUnit:first_unit @unit
   249 label *label134
   250 set *tmp47 null
-    * jump *label135 always
   251 label *label135
   252 set :backgroundProcess:unit *tmp47
   253 jump *label136 notEqual *tmp47 null
 
   312 jump *label153 notEqual :findFreeUnit:first_unit @unit
   313 label *label157
   314 set *tmp47 null
-    * jump *label158 always
   315 label *label158
   316 set :backgroundProcess:unit *tmp47
   317 jump *label159 notEqual *tmp47 null
 
   376 jump *label176 notEqual :findFreeUnit:first_unit @unit
   377 label *label180
   378 set *tmp47 null
-    * jump *label181 always
   379 label *label181
   380 set :backgroundProcess:unit *tmp47
   381 jump *label182 notEqual *tmp47 null
 
   440 jump *label199 notEqual :findFreeUnit:first_unit @unit
   441 label *label203
   442 set *tmp47 null
-    * jump *label204 always
   443 label *label204
   444 set :backgroundProcess:unit *tmp47
   445 jump *label205 notEqual *tmp47 null
 
   504 jump *label222 notEqual :findFreeUnit:first_unit @unit
   505 label *label226
   506 set *tmp47 null
-    * jump *label227 always
   507 label *label227
   508 set :backgroundProcess:unit *tmp47
   509 jump *label228 notEqual *tmp47 null
 
   568 jump *label245 notEqual :findFreeUnit:first_unit @unit
   569 label *label249
   570 set *tmp47 null
-    * jump *label250 always
   571 label *label250
   572 set :backgroundProcess:unit *tmp47
   573 jump *label251 notEqual *tmp47 null
 
   632 jump *label268 notEqual :findFreeUnit:first_unit @unit
   633 label *label272
   634 set *tmp47 null
-    * jump *label273 always
   635 label *label273
   636 set :backgroundProcess:unit *tmp47
   637 jump *label274 notEqual *tmp47 null

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    29 label *label57
    30 label *label58
    31 sensor *tmp43 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count 0 *tmp43
+   32 set :backgroundProcess:count *tmp43
    33 sensor *tmp44 :backgroundProcess:unit @controller
    34 jump *label69 equal *tmp44 @this
    35 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Virtual Instruction Expansion:
 
   673 label *label0
   674 # "Function: export void addTitaniumDrill(in drill)"
   675 jump *label54 greaterThanEq .drills 9
-    * writearr<lookup:liquid> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  676 lookup liquid *tmp72 .drills
+  677 sensor .titaniumDrills*elem *tmp72 @name
+  678 write :addTitaniumDrill:drill @this .titaniumDrills*elem
   679 op add .drills .drills 1
   680 label *label54
   681 label *label55

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-14 instructions):
 
    12 label *label13
    13 ubind @flare
    14 ulocate building core false @copper .coreX .coreY *tmp36 .core
-    * label *label14
    15 jump *label13 equal .core null
-    * label *label15
    16 sensor .coreX .core @x
    17 sensor .coreY .core @y
    18 label *label11
-    * label *label12
    19 label *label16
    20 set :backgroundProcess:count 0
    21 set :backgroundProcess:drill water
    22 set :backgroundProcess:unit .units*0
-    * label *label56
    23 jump *label57 notEqual :backgroundProcess:drill null
    24 jump *label21 always
    25 label *label57
-    * label *label58
    26 sensor *tmp43 :backgroundProcess:drill @titanium
    27 set :backgroundProcess:count *tmp43
    28 sensor *tmp44 :backgroundProcess:unit @controller
 
    33 set *tmp47 null
    34 jump *label66 always
    35 label *label59
-    * label *label60
    36 set :findFreeUnit:first_unit @unit
    37 label *label61
    38 sensor *tmp50 @unit @controlled
 
    40 ucontrol flag 0
    41 set *tmp47 @unit
    42 jump *label66 always
-    * jump *label63 always
    43 label *label62
    44 sensor *tmp53 :findFreeUnit:first_unit @dead
    45 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
    46 label *label63
    47 ubind @flare
-    * label *label64
    48 jump *label61 notEqual :findFreeUnit:first_unit @unit
-    * label *label65
    49 set *tmp47 null
    50 label *label66
    51 set :backgroundProcess:unit *tmp47
    52 jump *label67 notEqual *tmp47 null
    53 jump *label76 always
    54 label *label67
-    * label *label68
    55 label *label69
-    * label *label70
    56 # "Function: void serviceDrill(in drill, in unit)"
    57 ubind :backgroundProcess:unit
    58 sensor :serviceDrill:item @unit @firstItem
 
    71 ucontrol itemDrop @air 10
    72 label *label73
    73 label *label74
-    * label *label75
    74 label *label76
    75 set .units*0 :backgroundProcess:unit
    76 set :backgroundProcess:drill slag
    77 set :backgroundProcess:unit .units*1
-    * label *label79
    78 jump *label80 notEqual :backgroundProcess:drill null
    79 jump *label21 always
    80 label *label80
-    * label *label81
    81 sensor *tmp43 :backgroundProcess:drill @titanium
    82 op add :backgroundProcess:count :backgroundProcess:count *tmp43
    83 sensor *tmp44 :backgroundProcess:unit @controller
 
    88 set *tmp47 null
    89 jump *label89 always
    90 label *label82
-    * label *label83
    91 set :findFreeUnit:first_unit @unit
    92 label *label84
    93 sensor *tmp50 @unit @controlled
 
    95 ucontrol flag 0
    96 set *tmp47 @unit
    97 jump *label89 always
-    * jump *label86 always
    98 label *label85
    99 sensor *tmp53 :findFreeUnit:first_unit @dead
   100 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   101 label *label86
   102 ubind @flare
-    * label *label87
   103 jump *label84 notEqual :findFreeUnit:first_unit @unit
-    * label *label88
   104 set *tmp47 null
   105 label *label89
   106 set :backgroundProcess:unit *tmp47
   107 jump *label90 notEqual *tmp47 null
   108 jump *label99 always
   109 label *label90
-    * label *label91
   110 label *label92
-    * label *label93
   111 # "Function: void serviceDrill(in drill, in unit)"
   112 ubind :backgroundProcess:unit
   113 sensor :serviceDrill:item @unit @firstItem
 
   126 ucontrol itemDrop @air 10
   127 label *label96
   128 label *label97
-    * label *label98
   129 label *label99
   130 set .units*1 :backgroundProcess:unit
   131 set :backgroundProcess:drill oil
   132 set :backgroundProcess:unit .units*2
-    * label *label102
   133 jump *label103 notEqual :backgroundProcess:drill null
   134 jump *label21 always
   135 label *label103
-    * label *label104
   136 sensor *tmp43 :backgroundProcess:drill @titanium
   137 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   138 sensor *tmp44 :backgroundProcess:unit @controller
 
   143 set *tmp47 null
   144 jump *label112 always
   145 label *label105
-    * label *label106
   146 set :findFreeUnit:first_unit @unit
   147 label *label107
   148 sensor *tmp50 @unit @controlled
 
   150 ucontrol flag 0
   151 set *tmp47 @unit
   152 jump *label112 always
-    * jump *label109 always
   153 label *label108
   154 sensor *tmp53 :findFreeUnit:first_unit @dead
   155 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   156 label *label109
   157 ubind @flare
-    * label *label110
   158 jump *label107 notEqual :findFreeUnit:first_unit @unit
-    * label *label111
   159 set *tmp47 null
   160 label *label112
   161 set :backgroundProcess:unit *tmp47
   162 jump *label113 notEqual *tmp47 null
   163 jump *label122 always
   164 label *label113
-    * label *label114
   165 label *label115
-    * label *label116
   166 # "Function: void serviceDrill(in drill, in unit)"
   167 ubind :backgroundProcess:unit
   168 sensor :serviceDrill:item @unit @firstItem
 
   181 ucontrol itemDrop @air 10
   182 label *label119
   183 label *label120
-    * label *label121
   184 label *label122
   185 set .units*2 :backgroundProcess:unit
   186 set :backgroundProcess:drill cryofluid
   187 set :backgroundProcess:unit .units*3
-    * label *label125
   188 jump *label126 notEqual :backgroundProcess:drill null
   189 jump *label21 always
   190 label *label126
-    * label *label127
   191 sensor *tmp43 :backgroundProcess:drill @titanium
   192 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   193 sensor *tmp44 :backgroundProcess:unit @controller
 
   198 set *tmp47 null
   199 jump *label135 always
   200 label *label128
-    * label *label129
   201 set :findFreeUnit:first_unit @unit
   202 label *label130
   203 sensor *tmp50 @unit @controlled
 
   205 ucontrol flag 0
   206 set *tmp47 @unit
   207 jump *label135 always
-    * jump *label132 always
   208 label *label131
   209 sensor *tmp53 :findFreeUnit:first_unit @dead
   210 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   211 label *label132
   212 ubind @flare
-    * label *label133
   213 jump *label130 notEqual :findFreeUnit:first_unit @unit
-    * label *label134
   214 set *tmp47 null
   215 label *label135
   216 set :backgroundProcess:unit *tmp47
   217 jump *label136 notEqual *tmp47 null
   218 jump *label145 always
   219 label *label136
-    * label *label137
   220 label *label138
-    * label *label139
   221 # "Function: void serviceDrill(in drill, in unit)"
   222 ubind :backgroundProcess:unit
   223 sensor :serviceDrill:item @unit @firstItem
 
   236 ucontrol itemDrop @air 10
   237 label *label142
   238 label *label143
-    * label *label144
   239 label *label145
   240 set .units*3 :backgroundProcess:unit
   241 set :backgroundProcess:drill neoplasm
   242 set :backgroundProcess:unit .units*4
-    * label *label148
   243 jump *label149 notEqual :backgroundProcess:drill null
   244 jump *label21 always
   245 label *label149
-    * label *label150
   246 sensor *tmp43 :backgroundProcess:drill @titanium
   247 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   248 sensor *tmp44 :backgroundProcess:unit @controller
 
   253 set *tmp47 null
   254 jump *label158 always
   255 label *label151
-    * label *label152
   256 set :findFreeUnit:first_unit @unit
   257 label *label153
   258 sensor *tmp50 @unit @controlled
 
   260 ucontrol flag 0
   261 set *tmp47 @unit
   262 jump *label158 always
-    * jump *label155 always
   263 label *label154
   264 sensor *tmp53 :findFreeUnit:first_unit @dead
   265 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   266 label *label155
   267 ubind @flare
-    * label *label156
   268 jump *label153 notEqual :findFreeUnit:first_unit @unit
-    * label *label157
   269 set *tmp47 null
   270 label *label158
   271 set :backgroundProcess:unit *tmp47
   272 jump *label159 notEqual *tmp47 null
   273 jump *label168 always
   274 label *label159
-    * label *label160
   275 label *label161
-    * label *label162
   276 # "Function: void serviceDrill(in drill, in unit)"
   277 ubind :backgroundProcess:unit
   278 sensor :serviceDrill:item @unit @firstItem
 
   291 ucontrol itemDrop @air 10
   292 label *label165
   293 label *label166
-    * label *label167
   294 label *label168
   295 set .units*4 :backgroundProcess:unit
   296 set :backgroundProcess:drill hydrogen
   297 set :backgroundProcess:unit .units*5
-    * label *label171
   298 jump *label172 notEqual :backgroundProcess:drill null
   299 jump *label21 always
   300 label *label172
-    * label *label173
   301 sensor *tmp43 :backgroundProcess:drill @titanium
   302 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   303 sensor *tmp44 :backgroundProcess:unit @controller
 
   308 set *tmp47 null
   309 jump *label181 always
   310 label *label174
-    * label *label175
   311 set :findFreeUnit:first_unit @unit
   312 label *label176
   313 sensor *tmp50 @unit @controlled
 
   315 ucontrol flag 0
   316 set *tmp47 @unit
   317 jump *label181 always
-    * jump *label178 always
   318 label *label177
   319 sensor *tmp53 :findFreeUnit:first_unit @dead
   320 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   321 label *label178
   322 ubind @flare
-    * label *label179
   323 jump *label176 notEqual :findFreeUnit:first_unit @unit
-    * label *label180
   324 set *tmp47 null
   325 label *label181
   326 set :backgroundProcess:unit *tmp47
   327 jump *label182 notEqual *tmp47 null
   328 jump *label191 always
   329 label *label182
-    * label *label183
   330 label *label184
-    * label *label185
   331 # "Function: void serviceDrill(in drill, in unit)"
   332 ubind :backgroundProcess:unit
   333 sensor :serviceDrill:item @unit @firstItem
 
   346 ucontrol itemDrop @air 10
   347 label *label188
   348 label *label189
-    * label *label190
   349 label *label191
   350 set .units*5 :backgroundProcess:unit
   351 set :backgroundProcess:drill ozone
   352 set :backgroundProcess:unit .units*6
-    * label *label194
   353 jump *label195 notEqual :backgroundProcess:drill null
   354 jump *label21 always
   355 label *label195
-    * label *label196
   356 sensor *tmp43 :backgroundProcess:drill @titanium
   357 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   358 sensor *tmp44 :backgroundProcess:unit @controller
 
   363 set *tmp47 null
   364 jump *label204 always
   365 label *label197
-    * label *label198
   366 set :findFreeUnit:first_unit @unit
   367 label *label199
   368 sensor *tmp50 @unit @controlled
 
   370 ucontrol flag 0
   371 set *tmp47 @unit
   372 jump *label204 always
-    * jump *label201 always
   373 label *label200
   374 sensor *tmp53 :findFreeUnit:first_unit @dead
   375 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   376 label *label201
   377 ubind @flare
-    * label *label202
   378 jump *label199 notEqual :findFreeUnit:first_unit @unit
-    * label *label203
   379 set *tmp47 null
   380 label *label204
   381 set :backgroundProcess:unit *tmp47
   382 jump *label205 notEqual *tmp47 null
   383 jump *label214 always
   384 label *label205
-    * label *label206
   385 label *label207
-    * label *label208
   386 # "Function: void serviceDrill(in drill, in unit)"
   387 ubind :backgroundProcess:unit
   388 sensor :serviceDrill:item @unit @firstItem
 
   401 ucontrol itemDrop @air 10
   402 label *label211
   403 label *label212
-    * label *label213
   404 label *label214
   405 set .units*6 :backgroundProcess:unit
   406 set :backgroundProcess:drill cyanogen
   407 set :backgroundProcess:unit .units*7
-    * label *label217
   408 jump *label218 notEqual :backgroundProcess:drill null
   409 jump *label21 always
   410 label *label218
-    * label *label219
   411 sensor *tmp43 :backgroundProcess:drill @titanium
   412 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   413 sensor *tmp44 :backgroundProcess:unit @controller
 
   418 set *tmp47 null
   419 jump *label227 always
   420 label *label220
-    * label *label221
   421 set :findFreeUnit:first_unit @unit
   422 label *label222
   423 sensor *tmp50 @unit @controlled
 
   425 ucontrol flag 0
   426 set *tmp47 @unit
   427 jump *label227 always
-    * jump *label224 always
   428 label *label223
   429 sensor *tmp53 :findFreeUnit:first_unit @dead
   430 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   431 label *label224
   432 ubind @flare
-    * label *label225
   433 jump *label222 notEqual :findFreeUnit:first_unit @unit
-    * label *label226
   434 set *tmp47 null
   435 label *label227
   436 set :backgroundProcess:unit *tmp47
   437 jump *label228 notEqual *tmp47 null
   438 jump *label237 always
   439 label *label228
-    * label *label229
   440 label *label230
-    * label *label231
   441 # "Function: void serviceDrill(in drill, in unit)"
   442 ubind :backgroundProcess:unit
   443 sensor :serviceDrill:item @unit @firstItem
 
   456 ucontrol itemDrop @air 10
   457 label *label234
   458 label *label235
-    * label *label236
   459 label *label237
   460 set .units*7 :backgroundProcess:unit
   461 set :backgroundProcess:drill gallium
   462 set :backgroundProcess:unit .units*8
-    * label *label240
   463 jump *label241 notEqual :backgroundProcess:drill null
   464 jump *label21 always
   465 label *label241
-    * label *label242
   466 sensor *tmp43 :backgroundProcess:drill @titanium
   467 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   468 sensor *tmp44 :backgroundProcess:unit @controller
 
   473 set *tmp47 null
   474 jump *label250 always
   475 label *label243
-    * label *label244
   476 set :findFreeUnit:first_unit @unit
   477 label *label245
   478 sensor *tmp50 @unit @controlled
 
   480 ucontrol flag 0
   481 set *tmp47 @unit
   482 jump *label250 always
-    * jump *label247 always
   483 label *label246
   484 sensor *tmp53 :findFreeUnit:first_unit @dead
   485 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   486 label *label247
   487 ubind @flare
-    * label *label248
   488 jump *label245 notEqual :findFreeUnit:first_unit @unit
-    * label *label249
   489 set *tmp47 null
   490 label *label250
   491 set :backgroundProcess:unit *tmp47
   492 jump *label251 notEqual *tmp47 null
   493 jump *label260 always
   494 label *label251
-    * label *label252
   495 label *label253
-    * label *label254
   496 # "Function: void serviceDrill(in drill, in unit)"
   497 ubind :backgroundProcess:unit
   498 sensor :serviceDrill:item @unit @firstItem
 
   511 ucontrol itemDrop @air 10
   512 label *label257
   513 label *label258
-    * label *label259
   514 label *label260
   515 set .units*8 :backgroundProcess:unit
   516 set :backgroundProcess:drill nitrogen
   517 set :backgroundProcess:unit .units*9
-    * label *label263
   518 jump *label264 notEqual :backgroundProcess:drill null
   519 jump *label21 always
   520 label *label264
-    * label *label265
   521 sensor *tmp43 :backgroundProcess:drill @titanium
   522 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   523 sensor *tmp44 :backgroundProcess:unit @controller
 
   528 set *tmp47 null
   529 jump *label273 always
   530 label *label266
-    * label *label267
   531 set :findFreeUnit:first_unit @unit
   532 label *label268
   533 sensor *tmp50 @unit @controlled
 
   535 ucontrol flag 0
   536 set *tmp47 @unit
   537 jump *label273 always
-    * jump *label270 always
   538 label *label269
   539 sensor *tmp53 :findFreeUnit:first_unit @dead
   540 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   541 label *label270
   542 ubind @flare
-    * label *label271
   543 jump *label268 notEqual :findFreeUnit:first_unit @unit
-    * label *label272
   544 set *tmp47 null
   545 label *label273
   546 set :backgroundProcess:unit *tmp47
   547 jump *label274 notEqual *tmp47 null
   548 jump *label283 always
   549 label *label274
-    * label *label275
   550 label *label276
-    * label *label277
   551 # "Function: void serviceDrill(in drill, in unit)"
   552 ubind :backgroundProcess:unit
   553 sensor :serviceDrill:item @unit @firstItem
 
   566 ucontrol itemDrop @air 10
   567 label *label280
   568 label *label281
-    * label *label282
   569 label *label283
   570 set .units*9 :backgroundProcess:unit
   571 label *label21
   572 write :backgroundProcess:count processor2 ".titaniumDrillCount"
-    * label *label17
   573 jump *label16 always
-    * label *label18
-    * label *label10
-    * wait 1e12
-    * jump *label9 always
-    * end
   574 label *label0
   575 # "Function: export void addTitaniumDrill(in drill)"
   576 jump *label54 greaterThanEq .drills 9
 
   579 write :addTitaniumDrill:drill @this .titaniumDrills*elem
   580 op add .drills .drills 1
   581 label *label54
-    * label *label55
-    * label *label53
   582 set :addTitaniumDrill*finished true
   583 jump *label9 always
-    * end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-20 instructions):
 
    20 set :backgroundProcess:count 0
    21 set :backgroundProcess:drill water
    22 set :backgroundProcess:unit .units*0
-    * jump *label57 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+   23 jump *label21 equal :backgroundProcess:drill null
    24 label *label57
    25 sensor *tmp43 :backgroundProcess:drill @titanium
    26 set :backgroundProcess:count *tmp43
 
    47 set *tmp47 null
    48 label *label66
    49 set :backgroundProcess:unit *tmp47
-    * jump *label67 notEqual *tmp47 null
-    * jump *label76 always
+   50 jump *label76 equal *tmp47 null
    51 label *label67
    52 label *label69
    53 # "Function: void serviceDrill(in drill, in unit)"
 
    72 set .units*0 :backgroundProcess:unit
    73 set :backgroundProcess:drill slag
    74 set :backgroundProcess:unit .units*1
-    * jump *label80 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+   75 jump *label21 equal :backgroundProcess:drill null
    76 label *label80
    77 sensor *tmp43 :backgroundProcess:drill @titanium
    78 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
    99 set *tmp47 null
   100 label *label89
   101 set :backgroundProcess:unit *tmp47
-    * jump *label90 notEqual *tmp47 null
-    * jump *label99 always
+  102 jump *label99 equal *tmp47 null
   103 label *label90
   104 label *label92
   105 # "Function: void serviceDrill(in drill, in unit)"
 
   124 set .units*1 :backgroundProcess:unit
   125 set :backgroundProcess:drill oil
   126 set :backgroundProcess:unit .units*2
-    * jump *label103 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  127 jump *label21 equal :backgroundProcess:drill null
   128 label *label103
   129 sensor *tmp43 :backgroundProcess:drill @titanium
   130 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   151 set *tmp47 null
   152 label *label112
   153 set :backgroundProcess:unit *tmp47
-    * jump *label113 notEqual *tmp47 null
-    * jump *label122 always
+  154 jump *label122 equal *tmp47 null
   155 label *label113
   156 label *label115
   157 # "Function: void serviceDrill(in drill, in unit)"
 
   176 set .units*2 :backgroundProcess:unit
   177 set :backgroundProcess:drill cryofluid
   178 set :backgroundProcess:unit .units*3
-    * jump *label126 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  179 jump *label21 equal :backgroundProcess:drill null
   180 label *label126
   181 sensor *tmp43 :backgroundProcess:drill @titanium
   182 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   203 set *tmp47 null
   204 label *label135
   205 set :backgroundProcess:unit *tmp47
-    * jump *label136 notEqual *tmp47 null
-    * jump *label145 always
+  206 jump *label145 equal *tmp47 null
   207 label *label136
   208 label *label138
   209 # "Function: void serviceDrill(in drill, in unit)"
 
   228 set .units*3 :backgroundProcess:unit
   229 set :backgroundProcess:drill neoplasm
   230 set :backgroundProcess:unit .units*4
-    * jump *label149 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  231 jump *label21 equal :backgroundProcess:drill null
   232 label *label149
   233 sensor *tmp43 :backgroundProcess:drill @titanium
   234 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   255 set *tmp47 null
   256 label *label158
   257 set :backgroundProcess:unit *tmp47
-    * jump *label159 notEqual *tmp47 null
-    * jump *label168 always
+  258 jump *label168 equal *tmp47 null
   259 label *label159
   260 label *label161
   261 # "Function: void serviceDrill(in drill, in unit)"
 
   280 set .units*4 :backgroundProcess:unit
   281 set :backgroundProcess:drill hydrogen
   282 set :backgroundProcess:unit .units*5
-    * jump *label172 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  283 jump *label21 equal :backgroundProcess:drill null
   284 label *label172
   285 sensor *tmp43 :backgroundProcess:drill @titanium
   286 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   307 set *tmp47 null
   308 label *label181
   309 set :backgroundProcess:unit *tmp47
-    * jump *label182 notEqual *tmp47 null
-    * jump *label191 always
+  310 jump *label191 equal *tmp47 null
   311 label *label182
   312 label *label184
   313 # "Function: void serviceDrill(in drill, in unit)"
 
   332 set .units*5 :backgroundProcess:unit
   333 set :backgroundProcess:drill ozone
   334 set :backgroundProcess:unit .units*6
-    * jump *label195 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  335 jump *label21 equal :backgroundProcess:drill null
   336 label *label195
   337 sensor *tmp43 :backgroundProcess:drill @titanium
   338 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   359 set *tmp47 null
   360 label *label204
   361 set :backgroundProcess:unit *tmp47
-    * jump *label205 notEqual *tmp47 null
-    * jump *label214 always
+  362 jump *label214 equal *tmp47 null
   363 label *label205
   364 label *label207
   365 # "Function: void serviceDrill(in drill, in unit)"
 
   384 set .units*6 :backgroundProcess:unit
   385 set :backgroundProcess:drill cyanogen
   386 set :backgroundProcess:unit .units*7
-    * jump *label218 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  387 jump *label21 equal :backgroundProcess:drill null
   388 label *label218
   389 sensor *tmp43 :backgroundProcess:drill @titanium
   390 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   411 set *tmp47 null
   412 label *label227
   413 set :backgroundProcess:unit *tmp47
-    * jump *label228 notEqual *tmp47 null
-    * jump *label237 always
+  414 jump *label237 equal *tmp47 null
   415 label *label228
   416 label *label230
   417 # "Function: void serviceDrill(in drill, in unit)"
 
   436 set .units*7 :backgroundProcess:unit
   437 set :backgroundProcess:drill gallium
   438 set :backgroundProcess:unit .units*8
-    * jump *label241 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  439 jump *label21 equal :backgroundProcess:drill null
   440 label *label241
   441 sensor *tmp43 :backgroundProcess:drill @titanium
   442 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   463 set *tmp47 null
   464 label *label250
   465 set :backgroundProcess:unit *tmp47
-    * jump *label251 notEqual *tmp47 null
-    * jump *label260 always
+  466 jump *label260 equal *tmp47 null
   467 label *label251
   468 label *label253
   469 # "Function: void serviceDrill(in drill, in unit)"
 
   488 set .units*8 :backgroundProcess:unit
   489 set :backgroundProcess:drill nitrogen
   490 set :backgroundProcess:unit .units*9
-    * jump *label264 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  491 jump *label21 equal :backgroundProcess:drill null
   492 label *label264
   493 sensor *tmp43 :backgroundProcess:drill @titanium
   494 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   515 set *tmp47 null
   516 label *label273
   517 set :backgroundProcess:unit *tmp47
-    * jump *label274 notEqual *tmp47 null
-    * jump *label283 always
+  518 jump *label283 equal *tmp47 null
   519 label *label274
   520 label *label276
   521 # "Function: void serviceDrill(in drill, in unit)"

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
    11 jump *label11 notEqual .core null
    12 label *label13
    13 ubind @flare
-    * ulocate building core false @copper .coreX .coreY *tmp36 .core
+   14 ulocate building core false @copper .coreX .coreY 0 .core
    15 jump *label13 equal .core null
    16 sensor .coreX .core @x
    17 sensor .coreY .core @y

Final code before resolving virtual instructions:

    0:  jump *label7 always 0 0                                      FlareController.mnd: #set target = 8;
    1:  jump *label0 always 0 0                                      ...
        label *label7                                                ...
    2:  set *id "name: Base Builder - Flare Controller\nversion: v0. ...
        label *label8                                                FlareController.mnd: require "Display.mnd" remote display;
    3:  read *tmp32 processor2 "*signature"                          ...
    4:  jump *label8 notEqual *tmp32 "0:v1"                          ...
    5:  set .drills 0                                                FlareController.mnd: volatile var drills = 0;
    6:  set *signature "880295ee1d8ade1d:v1"                         FlareController.mnd: #set target = 8;
        label *label9                                                ...
        # "Function: void backgroundProcess()"                       FlareController.mnd: void backgroundProcess()
    7:  jump *label11 notEqual .core null                            FlareController.mnd: if core == null then
        label *label13                                               FlareController.mnd: do
    8:  ubind @flare                                                 FlareController.mnd: ubind(@flare);
    9:  ulocate building core false @copper .coreX .coreY 0 .core    FlareController.mnd: core = ulocate(:building, :core, false, out coreX, out coreY);
   10:  jump *label13 equal .core null                               FlareController.mnd: do
   11:  sensor .coreX .core @x                                       FlareController.mnd: coreX = core.@x;
   12:  sensor .coreY .core @y                                       FlareController.mnd: coreY = core.@y;
        label *label11                                               FlareController.mnd: if core == null then
        label *label16                                               FlareController.mnd: while true do
   13:  set :backgroundProcess:count 0                               FlareController.mnd: var count = 0;
   14:  set :backgroundProcess:drill water                           FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
   15:  set :backgroundProcess:unit .units*0                         ...
   16:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
   17:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
   18:  set :backgroundProcess:count *tmp43                          ...
   19:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
   20:  jump *label69 equal *tmp44 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
   21:  ubind @flare                                                 *units: ubind(unit_type);
   22:  jump *label59 notEqual @unit null                            *units: if @unit == null then return null; end;
   23:  set *tmp47 null                                              ...
   24:  jump *label66 always 0 0                                     ...
        label *label59                                               ...
   25:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label61                                               *units: do
   26:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
   27:  jump *label62 notEqual *tmp50 0                              ...
   28:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   29:  set *tmp47 @unit                                             *units: return @unit;
   30:  jump *label66 always 0 0                                     ...
        label *label62                                               *units: if @unit.@controlled == 0 then
   31:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   32:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
   33:  ubind @flare                                                 *units: ubind(unit_type);
   34:  jump *label61 notEqual :findFreeUnit:first_unit @unit        *units: do
   35:  set *tmp47 null                                              *units: return null;
        label *label66                                               FlareController.mnd: unit = findFreeUnit(@flare, 0);
   36:  set :backgroundProcess:unit *tmp47                           ...
   37:  jump *label76 equal *tmp47 null                              FlareController.mnd: if unit == null then continue; end;
        label *label69                                               FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
   38:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
   39:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
   40:  jump *label71 notEqual :serviceDrill:item @titanium          FlareController.mnd: if item == @titanium then
   41:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
   42:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
   43:  jump *label74 always 0 0                                     FlareController.mnd: if item == @titanium then
        label *label71                                               ...
   44:  jump *label72 notEqual :serviceDrill:item null               FlareController.mnd: elsif item == null then
   45:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
   46:  sensor *tmp66 :backgroundProcess:drill @y                    ...
   47:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
   48:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
   49:  jump *label73 always 0 0                                     FlareController.mnd: elsif item == null then
        label *label72                                               ...
   50:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label73                                               FlareController.mnd: elsif item == null then
        label *label74                                               FlareController.mnd: if item == @titanium then
        label *label76                                               FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
   51:  set .units*0 :backgroundProcess:unit                         ...
   52:  set :backgroundProcess:drill slag                            ...
   53:  set :backgroundProcess:unit .units*1                         ...
   54:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
   55:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
   56:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
   57:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
   58:  jump *label92 equal *tmp44 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
   59:  ubind @flare                                                 *units: ubind(unit_type);
   60:  jump *label82 notEqual @unit null                            *units: if @unit == null then return null; end;
   61:  set *tmp47 null                                              ...
   62:  jump *label89 always 0 0                                     ...
        label *label82                                               ...
   63:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label84                                               *units: do
   64:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
   65:  jump *label85 notEqual *tmp50 0                              ...
   66:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   67:  set *tmp47 @unit                                             *units: return @unit;
   68:  jump *label89 always 0 0                                     ...
        label *label85                                               *units: if @unit.@controlled == 0 then
   69:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   70:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
   71:  ubind @flare                                                 *units: ubind(unit_type);
   72:  jump *label84 notEqual :findFreeUnit:first_unit @unit        *units: do
   73:  set *tmp47 null                                              *units: return null;
        label *label89                                               FlareController.mnd: unit = findFreeUnit(@flare, 0);
   74:  set :backgroundProcess:unit *tmp47                           ...
   75:  jump *label99 equal *tmp47 null                              FlareController.mnd: if unit == null then continue; end;
        label *label92                                               FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
   76:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
   77:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
   78:  jump *label94 notEqual :serviceDrill:item @titanium          FlareController.mnd: if item == @titanium then
   79:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
   80:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
   81:  jump *label97 always 0 0                                     FlareController.mnd: if item == @titanium then
        label *label94                                               ...
   82:  jump *label95 notEqual :serviceDrill:item null               FlareController.mnd: elsif item == null then
   83:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
   84:  sensor *tmp66 :backgroundProcess:drill @y                    ...
   85:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
   86:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
   87:  jump *label96 always 0 0                                     FlareController.mnd: elsif item == null then
        label *label95                                               ...
   88:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label96                                               FlareController.mnd: elsif item == null then
        label *label97                                               FlareController.mnd: if item == @titanium then
        label *label99                                               FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
   89:  set .units*1 :backgroundProcess:unit                         ...
   90:  set :backgroundProcess:drill oil                             ...
   91:  set :backgroundProcess:unit .units*2                         ...
   92:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
   93:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
   94:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
   95:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
   96:  jump *label115 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
   97:  ubind @flare                                                 *units: ubind(unit_type);
   98:  jump *label105 notEqual @unit null                           *units: if @unit == null then return null; end;
   99:  set *tmp47 null                                              ...
  100:  jump *label112 always 0 0                                    ...
        label *label105                                              ...
  101:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label107                                              *units: do
  102:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  103:  jump *label108 notEqual *tmp50 0                             ...
  104:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  105:  set *tmp47 @unit                                             *units: return @unit;
  106:  jump *label112 always 0 0                                    ...
        label *label108                                              *units: if @unit.@controlled == 0 then
  107:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  108:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  109:  ubind @flare                                                 *units: ubind(unit_type);
  110:  jump *label107 notEqual :findFreeUnit:first_unit @unit       *units: do
  111:  set *tmp47 null                                              *units: return null;
        label *label112                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  112:  set :backgroundProcess:unit *tmp47                           ...
  113:  jump *label122 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label115                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  114:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  115:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  116:  jump *label117 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  117:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  118:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  119:  jump *label120 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label117                                              ...
  120:  jump *label118 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  121:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  122:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  123:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  124:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  125:  jump *label119 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label118                                              ...
  126:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label119                                              FlareController.mnd: elsif item == null then
        label *label120                                              FlareController.mnd: if item == @titanium then
        label *label122                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  127:  set .units*2 :backgroundProcess:unit                         ...
  128:  set :backgroundProcess:drill cryofluid                       ...
  129:  set :backgroundProcess:unit .units*3                         ...
  130:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  131:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  132:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  133:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  134:  jump *label138 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  135:  ubind @flare                                                 *units: ubind(unit_type);
  136:  jump *label128 notEqual @unit null                           *units: if @unit == null then return null; end;
  137:  set *tmp47 null                                              ...
  138:  jump *label135 always 0 0                                    ...
        label *label128                                              ...
  139:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label130                                              *units: do
  140:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  141:  jump *label131 notEqual *tmp50 0                             ...
  142:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  143:  set *tmp47 @unit                                             *units: return @unit;
  144:  jump *label135 always 0 0                                    ...
        label *label131                                              *units: if @unit.@controlled == 0 then
  145:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  146:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  147:  ubind @flare                                                 *units: ubind(unit_type);
  148:  jump *label130 notEqual :findFreeUnit:first_unit @unit       *units: do
  149:  set *tmp47 null                                              *units: return null;
        label *label135                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  150:  set :backgroundProcess:unit *tmp47                           ...
  151:  jump *label145 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label138                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  152:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  153:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  154:  jump *label140 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  155:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  156:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  157:  jump *label143 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label140                                              ...
  158:  jump *label141 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  159:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  160:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  161:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  162:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  163:  jump *label142 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label141                                              ...
  164:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label142                                              FlareController.mnd: elsif item == null then
        label *label143                                              FlareController.mnd: if item == @titanium then
        label *label145                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  165:  set .units*3 :backgroundProcess:unit                         ...
  166:  set :backgroundProcess:drill neoplasm                        ...
  167:  set :backgroundProcess:unit .units*4                         ...
  168:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  169:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  170:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  171:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  172:  jump *label161 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  173:  ubind @flare                                                 *units: ubind(unit_type);
  174:  jump *label151 notEqual @unit null                           *units: if @unit == null then return null; end;
  175:  set *tmp47 null                                              ...
  176:  jump *label158 always 0 0                                    ...
        label *label151                                              ...
  177:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label153                                              *units: do
  178:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  179:  jump *label154 notEqual *tmp50 0                             ...
  180:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  181:  set *tmp47 @unit                                             *units: return @unit;
  182:  jump *label158 always 0 0                                    ...
        label *label154                                              *units: if @unit.@controlled == 0 then
  183:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  184:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  185:  ubind @flare                                                 *units: ubind(unit_type);
  186:  jump *label153 notEqual :findFreeUnit:first_unit @unit       *units: do
  187:  set *tmp47 null                                              *units: return null;
        label *label158                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  188:  set :backgroundProcess:unit *tmp47                           ...
  189:  jump *label168 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label161                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  190:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  191:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  192:  jump *label163 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  193:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  194:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  195:  jump *label166 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label163                                              ...
  196:  jump *label164 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  197:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  198:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  199:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  200:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  201:  jump *label165 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label164                                              ...
  202:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label165                                              FlareController.mnd: elsif item == null then
        label *label166                                              FlareController.mnd: if item == @titanium then
        label *label168                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  203:  set .units*4 :backgroundProcess:unit                         ...
  204:  set :backgroundProcess:drill hydrogen                        ...
  205:  set :backgroundProcess:unit .units*5                         ...
  206:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  207:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  208:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  209:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  210:  jump *label184 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  211:  ubind @flare                                                 *units: ubind(unit_type);
  212:  jump *label174 notEqual @unit null                           *units: if @unit == null then return null; end;
  213:  set *tmp47 null                                              ...
  214:  jump *label181 always 0 0                                    ...
        label *label174                                              ...
  215:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label176                                              *units: do
  216:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  217:  jump *label177 notEqual *tmp50 0                             ...
  218:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  219:  set *tmp47 @unit                                             *units: return @unit;
  220:  jump *label181 always 0 0                                    ...
        label *label177                                              *units: if @unit.@controlled == 0 then
  221:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  222:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  223:  ubind @flare                                                 *units: ubind(unit_type);
  224:  jump *label176 notEqual :findFreeUnit:first_unit @unit       *units: do
  225:  set *tmp47 null                                              *units: return null;
        label *label181                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  226:  set :backgroundProcess:unit *tmp47                           ...
  227:  jump *label191 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label184                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  228:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  229:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  230:  jump *label186 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  231:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  232:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  233:  jump *label189 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label186                                              ...
  234:  jump *label187 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  235:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  236:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  237:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  238:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  239:  jump *label188 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label187                                              ...
  240:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label188                                              FlareController.mnd: elsif item == null then
        label *label189                                              FlareController.mnd: if item == @titanium then
        label *label191                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  241:  set .units*5 :backgroundProcess:unit                         ...
  242:  set :backgroundProcess:drill ozone                           ...
  243:  set :backgroundProcess:unit .units*6                         ...
  244:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  245:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  246:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  247:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  248:  jump *label207 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  249:  ubind @flare                                                 *units: ubind(unit_type);
  250:  jump *label197 notEqual @unit null                           *units: if @unit == null then return null; end;
  251:  set *tmp47 null                                              ...
  252:  jump *label204 always 0 0                                    ...
        label *label197                                              ...
  253:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label199                                              *units: do
  254:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  255:  jump *label200 notEqual *tmp50 0                             ...
  256:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  257:  set *tmp47 @unit                                             *units: return @unit;
  258:  jump *label204 always 0 0                                    ...
        label *label200                                              *units: if @unit.@controlled == 0 then
  259:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  260:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  261:  ubind @flare                                                 *units: ubind(unit_type);
  262:  jump *label199 notEqual :findFreeUnit:first_unit @unit       *units: do
  263:  set *tmp47 null                                              *units: return null;
        label *label204                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  264:  set :backgroundProcess:unit *tmp47                           ...
  265:  jump *label214 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label207                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  266:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  267:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  268:  jump *label209 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  269:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  270:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  271:  jump *label212 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label209                                              ...
  272:  jump *label210 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  273:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  274:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  275:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  276:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  277:  jump *label211 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label210                                              ...
  278:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label211                                              FlareController.mnd: elsif item == null then
        label *label212                                              FlareController.mnd: if item == @titanium then
        label *label214                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  279:  set .units*6 :backgroundProcess:unit                         ...
  280:  set :backgroundProcess:drill cyanogen                        ...
  281:  set :backgroundProcess:unit .units*7                         ...
  282:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  283:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  284:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  285:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  286:  jump *label230 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  287:  ubind @flare                                                 *units: ubind(unit_type);
  288:  jump *label220 notEqual @unit null                           *units: if @unit == null then return null; end;
  289:  set *tmp47 null                                              ...
  290:  jump *label227 always 0 0                                    ...
        label *label220                                              ...
  291:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label222                                              *units: do
  292:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  293:  jump *label223 notEqual *tmp50 0                             ...
  294:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  295:  set *tmp47 @unit                                             *units: return @unit;
  296:  jump *label227 always 0 0                                    ...
        label *label223                                              *units: if @unit.@controlled == 0 then
  297:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  298:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  299:  ubind @flare                                                 *units: ubind(unit_type);
  300:  jump *label222 notEqual :findFreeUnit:first_unit @unit       *units: do
  301:  set *tmp47 null                                              *units: return null;
        label *label227                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  302:  set :backgroundProcess:unit *tmp47                           ...
  303:  jump *label237 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label230                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  304:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  305:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  306:  jump *label232 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  307:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  308:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  309:  jump *label235 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label232                                              ...
  310:  jump *label233 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  311:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  312:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  313:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  314:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  315:  jump *label234 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label233                                              ...
  316:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label234                                              FlareController.mnd: elsif item == null then
        label *label235                                              FlareController.mnd: if item == @titanium then
        label *label237                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  317:  set .units*7 :backgroundProcess:unit                         ...
  318:  set :backgroundProcess:drill gallium                         ...
  319:  set :backgroundProcess:unit .units*8                         ...
  320:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  321:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  322:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  323:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  324:  jump *label253 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  325:  ubind @flare                                                 *units: ubind(unit_type);
  326:  jump *label243 notEqual @unit null                           *units: if @unit == null then return null; end;
  327:  set *tmp47 null                                              ...
  328:  jump *label250 always 0 0                                    ...
        label *label243                                              ...
  329:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label245                                              *units: do
  330:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  331:  jump *label246 notEqual *tmp50 0                             ...
  332:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  333:  set *tmp47 @unit                                             *units: return @unit;
  334:  jump *label250 always 0 0                                    ...
        label *label246                                              *units: if @unit.@controlled == 0 then
  335:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  336:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  337:  ubind @flare                                                 *units: ubind(unit_type);
  338:  jump *label245 notEqual :findFreeUnit:first_unit @unit       *units: do
  339:  set *tmp47 null                                              *units: return null;
        label *label250                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  340:  set :backgroundProcess:unit *tmp47                           ...
  341:  jump *label260 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label253                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  342:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  343:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  344:  jump *label255 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  345:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  346:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  347:  jump *label258 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label255                                              ...
  348:  jump *label256 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  349:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  350:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  351:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  352:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  353:  jump *label257 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label256                                              ...
  354:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label257                                              FlareController.mnd: elsif item == null then
        label *label258                                              FlareController.mnd: if item == @titanium then
        label *label260                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  355:  set .units*8 :backgroundProcess:unit                         ...
  356:  set :backgroundProcess:drill nitrogen                        ...
  357:  set :backgroundProcess:unit .units*9                         ...
  358:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  359:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  360:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  361:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  362:  jump *label276 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  363:  ubind @flare                                                 *units: ubind(unit_type);
  364:  jump *label266 notEqual @unit null                           *units: if @unit == null then return null; end;
  365:  set *tmp47 null                                              ...
  366:  jump *label273 always 0 0                                    ...
        label *label266                                              ...
  367:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label268                                              *units: do
  368:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  369:  jump *label269 notEqual *tmp50 0                             ...
  370:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  371:  set *tmp47 @unit                                             *units: return @unit;
  372:  jump *label273 always 0 0                                    ...
        label *label269                                              *units: if @unit.@controlled == 0 then
  373:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  374:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  375:  ubind @flare                                                 *units: ubind(unit_type);
  376:  jump *label268 notEqual :findFreeUnit:first_unit @unit       *units: do
  377:  set *tmp47 null                                              *units: return null;
        label *label273                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  378:  set :backgroundProcess:unit *tmp47                           ...
  379:  jump *label283 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label276                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  380:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  381:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  382:  jump *label278 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  383:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  384:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  385:  jump *label281 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label278                                              ...
  386:  jump *label279 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  387:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  388:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  389:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  390:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  391:  jump *label280 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label279                                              ...
  392:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label280                                              FlareController.mnd: elsif item == null then
        label *label281                                              FlareController.mnd: if item == @titanium then
        label *label283                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  393:  set .units*9 :backgroundProcess:unit                         ...
        label *label21                                               ...
  394:  write :backgroundProcess:count processor2 ".titaniumDrillCou FlareController.mnd: display.titaniumDrillCount = count;
  395:  jump *label16 always 0 0                                     FlareController.mnd: while true do
        label *label0                                                FlareController.mnd: export void addTitaniumDrill(drill)
        # "Function: export void addTitaniumDrill(in drill)"         ...
  396:  jump *label54 greaterThanEq .drills 9                        FlareController.mnd: if drills < length(titaniumDrills) - 1 then
  397:  lookup liquid *tmp72 .drills                                 FlareController.mnd: titaniumDrills[drills] = drill;
  398:  sensor .titaniumDrills*elem *tmp72 @name                     ...
  399:  write :addTitaniumDrill:drill @this .titaniumDrills*elem     ...
  400:  op add .drills .drills 1                                     FlareController.mnd: if drills < length(titaniumDrills) - 1 then
        label *label54                                               ...
  401:  set :addTitaniumDrill*finished true                          FlareController.mnd: export void addTitaniumDrill(drill)
  402:  jump *label9 always 0 0                                      ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   150    10x     15,0  def findFreeUnit(in unit_type, in initial_flag)
   130    10x     13,0  void serviceDrill(in drill, in unit)
   109     1x    109,0  void backgroundProcess()
     8     1x      8,0  export void addTitaniumDrill(in drill)
     7     1x      7,0  <no function>
