   183 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
    22 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (6 iterations).
    12 instructions eliminated by Condition Optimization (7 iterations).
    17 instructions eliminated by Single Step Elimination (2 passes, 8 iterations).
     1 instructions modified by Expression Optimization (4 iterations).
     1 instructions eliminated by Boolean Optimization (7 iterations).
       1 fully-evaluated expressions optimized using selects.
     5 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
   331 instructions added by Loop Unrolling (5 iterations).
     1 loops unrolled by Loop Unrolling.
     1 instructions eliminated by Array Optimization (5 iterations).
    20 instructions eliminated by Jump Straightening (7 iterations).
    14 instructions eliminated by Unreachable Code Elimination (2 iterations).
   403 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 884):
  * Unroll iteration loop at FlareController.mnd:63:9            size  +331, benefit     1475.0, efficiency      4.456 (+331 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-15 instructions):
 
     5 jump *label8 notEqual *tmp32 "0:v1"
     6 set .drills 0
     7 set *signature "880295ee1d8ade1d:v1"
-    * set *waitaddr @counter
     8 label *label9
     9 # "Function: void backgroundProcess()"
    10 op equal *tmp33 .core null
 
    21 set .coreX *tmp38
    22 sensor *tmp39 .core @y
    23 set .coreY *tmp39
-    * set *tmp34 *tmp39
    24 jump *label12 always
    25 label *label11
-    * set *tmp34 null
    26 label *label12
    27 label *label16
    28 jump *label18 equal true false
 
    88 op equal *tmp41 :backgroundProcess:drill null
    89 jump *label32 equal *tmp41 false
    90 jump *label21 always
-    * set *tmp42 null
    91 jump *label33 always
    92 label *label32
-    * set *tmp42 null
    93 label *label33
    94 sensor *tmp43 :backgroundProcess:drill @titanium
    95 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   104 jump *label37 equal *tmp48 false
   105 set *tmp47 null
   106 jump *label36 always
-    * set *tmp49 null
   107 jump *label38 always
   108 label *label37
-    * set *tmp49 null
   109 label *label38
   110 set :findFreeUnit:first_unit @unit
   111 label *label39
 
   115 ucontrol flag :findFreeUnit:initial_flag
   116 set *tmp47 @unit
   117 jump *label36 always
-    * set *tmp52 null
   118 jump *label43 always
   119 label *label42
   120 sensor *tmp53 :findFreeUnit:first_unit @dead
 
   127 label *label44
   128 set *tmp55 null
   129 label *label45
-    * set *tmp52 *tmp55
   130 label *label43
   131 ubind :findFreeUnit:unit_type
   132 label *label40
 
   146 label *label46
   147 set *tmp59 null
   148 label *label47
-    * set *tmp46 *tmp59
   149 jump *label35 always
   150 label *label34
-    * set *tmp46 null
   151 label *label35
   152 # "Function: void serviceDrill(in drill, in unit)"
   153 set :serviceDrill:drill :backgroundProcess:drill
 
   159 jump *label49 equal *tmp61 false
   160 ucontrol approach .coreX .coreY 4
   161 ucontrol itemDrop .core 10
-    * set *tmp62 null
   162 jump *label50 always
   163 label *label49
   164 op equal *tmp63 :serviceDrill:item null
 
   173 ucontrol itemDrop @air 10
   174 set *tmp64 null
   175 label *label52
-    * set *tmp62 *tmp64
   176 label *label50
   177 label *label48
   178 label *label20
 
   196 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] *tmp69
   197 set *tmp71 .drills
   198 op add .drills .drills 1
-    * set *tmp68 *tmp71
   199 jump *label55 always
   200 label *label54
-    * set *tmp68 null
   201 label *label55
   202 label *label53
   203 set :addTitaniumDrill*finished true

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-7 instructions):
 
   122 jump *label44 equal *tmp54 false
   123 set *tmp56 @unit
   124 set :findFreeUnit:first_unit *tmp56
-    * set *tmp55 :findFreeUnit:first_unit
   125 jump *label45 always
   126 label *label44
-    * set *tmp55 null
   127 label *label45
   128 label *label43
   129 ubind :findFreeUnit:unit_type
 
   139 op equal *tmp58 :backgroundProcess:unit null
   140 jump *label46 equal *tmp58 false
   141 jump *label20 always
-    * set *tmp59 null
   142 jump *label47 always
   143 label *label46
-    * set *tmp59 null
   144 label *label47
   145 jump *label35 always
   146 label *label34
 
   163 sensor *tmp66 :serviceDrill:drill @y
   164 ucontrol approach *tmp65 *tmp66 4
   165 ucontrol itemTake :serviceDrill:drill @titanium 10
-    * set *tmp64 null
   166 jump *label52 always
   167 label *label51
   168 ucontrol itemDrop @air 10
-    * set *tmp64 null
   169 label *label52
   170 label *label50
   171 label *label48
 
   188 jump *label54 equal *tmp67 false
   189 set *tmp69 .drills
   190 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] *tmp69
-    * set *tmp71 .drills
   191 op add .drills .drills 1
   192 jump *label55 always
   193 label *label54

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
    11 jump *label11 equal *tmp33 false
    12 label *label13
    13 ubind @flare
-    * ulocate building core false @copper .coreX .coreY *tmp36 *tmp35
-    * set .core *tmp35
+   14 ulocate building core false @copper .coreX .coreY *tmp36 .core
    15 label *label14
    16 op equal *tmp37 .core null
    17 jump *label13 notEqual *tmp37 false
    18 label *label15
-    * sensor *tmp38 .core @x
-    * set .coreX *tmp38
-    * sensor *tmp39 .core @y
-    * set .coreY *tmp39
+   19 sensor .coreX .core @x
+   20 sensor .coreY .core @y
    21 jump *label12 always
    22 label *label11
    23 label *label12
 
   117 sensor *tmp53 :findFreeUnit:first_unit @dead
   118 op equal *tmp54 *tmp53 1
   119 jump *label44 equal *tmp54 false
-    * set *tmp56 @unit
-    * set :findFreeUnit:first_unit *tmp56
+  120 set :findFreeUnit:first_unit @unit
   121 jump *label45 always
   122 label *label44
   123 label *label45
 
   145 set :serviceDrill:drill :backgroundProcess:drill
   146 set :serviceDrill:unit :backgroundProcess:unit
   147 ubind :serviceDrill:unit
-    * sensor *tmp60 @unit @firstItem
-    * set :serviceDrill:item *tmp60
+  148 sensor :serviceDrill:item @unit @firstItem
   149 op equal *tmp61 :serviceDrill:item @titanium
   150 jump *label49 equal *tmp61 false
   151 ucontrol approach .coreX .coreY 4
 
   181 # "Function: export void addTitaniumDrill(in drill)"
   182 op lessThan *tmp67 .drills 9
   183 jump *label54 equal *tmp67 false
-    * set *tmp69 .drills
-    * writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] *tmp69
+  184 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] .drills
   185 op add .drills .drills 1
   186 jump *label55 always
   187 label *label54

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    22 label *label11
    23 label *label12
    24 label *label16
-    * jump *label18 equal true false
    25 set :backgroundProcess:count 0
    26 set :backgroundProcess:drill water
    27 set :backgroundProcess:unit .units*0

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-12 instructions):
 
     7 set *signature "880295ee1d8ade1d:v1"
     8 label *label9
     9 # "Function: void backgroundProcess()"
-    * op equal *tmp33 .core null
-    * jump *label11 equal *tmp33 false
+   10 jump *label11 notEqual .core null
    11 label *label13
    12 ubind @flare
    13 ulocate building core false @copper .coreX .coreY *tmp36 .core
    14 label *label14
-    * op equal *tmp37 .core null
-    * jump *label13 notEqual *tmp37 false
+   15 jump *label13 equal .core null
    16 label *label15
    17 sensor .coreX .core @x
    18 sensor .coreY .core @y
 
    79 set :backgroundProcess:unit .units*9
    80 set *tmp40 null
    81 label *label19
-    * op equal *tmp41 :backgroundProcess:drill null
-    * jump *label32 equal *tmp41 false
+   82 jump *label32 notEqual :backgroundProcess:drill null
    83 jump *label21 always
    84 jump *label33 always
    85 label *label32
 
    87 sensor *tmp43 :backgroundProcess:drill @titanium
    88 op add :backgroundProcess:count :backgroundProcess:count *tmp43
    89 sensor *tmp44 :backgroundProcess:unit @controller
-    * op notEqual *tmp45 *tmp44 @this
-    * jump *label34 equal *tmp45 false
+   90 jump *label34 equal *tmp44 @this
    91 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    92 set :findFreeUnit:unit_type @flare
    93 set :findFreeUnit:initial_flag 0
    94 ubind :findFreeUnit:unit_type
-    * op equal *tmp48 @unit null
-    * jump *label37 equal *tmp48 false
+   95 jump *label37 notEqual @unit null
    96 set *tmp47 null
    97 jump *label36 always
    98 jump *label38 always
 
   101 set :findFreeUnit:first_unit @unit
   102 label *label39
   103 sensor *tmp50 @unit @controlled
-    * op equal *tmp51 *tmp50 0
-    * jump *label42 equal *tmp51 false
+  104 jump *label42 notEqual *tmp50 0
   105 ucontrol flag :findFreeUnit:initial_flag
   106 set *tmp47 @unit
   107 jump *label36 always
   108 jump *label43 always
   109 label *label42
   110 sensor *tmp53 :findFreeUnit:first_unit @dead
-    * op equal *tmp54 *tmp53 1
-    * jump *label44 equal *tmp54 false
+  111 jump *label44 notEqual *tmp53 1
   112 set :findFreeUnit:first_unit @unit
   113 jump *label45 always
   114 label *label44
 
   116 label *label43
   117 ubind :findFreeUnit:unit_type
   118 label *label40
-    * op notEqual *tmp57 :findFreeUnit:first_unit @unit
-    * jump *label39 notEqual *tmp57 false
+  119 jump *label39 notEqual :findFreeUnit:first_unit @unit
   120 label *label41
   121 set *tmp47 null
   122 jump *label36 always
   123 set *tmp47 null
   124 label *label36
   125 set :backgroundProcess:unit *tmp47
-    * op equal *tmp58 :backgroundProcess:unit null
-    * jump *label46 equal *tmp58 false
+  126 jump *label46 notEqual :backgroundProcess:unit null
   127 jump *label20 always
   128 jump *label47 always
   129 label *label46
 
   136 set :serviceDrill:unit :backgroundProcess:unit
   137 ubind :serviceDrill:unit
   138 sensor :serviceDrill:item @unit @firstItem
-    * op equal *tmp61 :serviceDrill:item @titanium
-    * jump *label49 equal *tmp61 false
+  139 jump *label49 notEqual :serviceDrill:item @titanium
   140 ucontrol approach .coreX .coreY 4
   141 ucontrol itemDrop .core 10
   142 jump *label50 always
   143 label *label49
-    * op equal *tmp63 :serviceDrill:item null
-    * jump *label51 equal *tmp63 false
+  144 jump *label51 notEqual :serviceDrill:item null
   145 sensor *tmp65 :serviceDrill:drill @x
   146 sensor *tmp66 :serviceDrill:drill @y
   147 ucontrol approach *tmp65 *tmp66 4
 
   167 end
   168 label *label0
   169 # "Function: export void addTitaniumDrill(in drill)"
-    * op lessThan *tmp67 .drills 9
-    * jump *label54 equal *tmp67 false
+  170 jump *label54 greaterThanEq .drills 9
   171 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] .drills
   172 op add .drills .drills 1
   173 jump *label55 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    16 label *label15
    17 sensor .coreX .core @x
    18 sensor .coreY .core @y
-    * jump *label12 always
    19 label *label11
    20 label *label12
    21 label *label16
 
    80 label *label19
    81 jump *label32 notEqual :backgroundProcess:drill null
    82 jump *label21 always
-    * jump *label33 always
    83 label *label32
    84 label *label33
    85 sensor *tmp43 :backgroundProcess:drill @titanium
 
    93 jump *label37 notEqual @unit null
    94 set *tmp47 null
    95 jump *label36 always
-    * jump *label38 always
    96 label *label37
    97 label *label38
    98 set :findFreeUnit:first_unit @unit
 
   107 sensor *tmp53 :findFreeUnit:first_unit @dead
   108 jump *label44 notEqual *tmp53 1
   109 set :findFreeUnit:first_unit @unit
-    * jump *label45 always
   110 label *label44
   111 label *label45
   112 label *label43
 
   121 set :backgroundProcess:unit *tmp47
   122 jump *label46 notEqual :backgroundProcess:unit null
   123 jump *label20 always
-    * jump *label47 always
   124 label *label46
   125 label *label47
-    * jump *label35 always
   126 label *label34
   127 label *label35
   128 # "Function: void serviceDrill(in drill, in unit)"
 
   164 jump *label54 greaterThanEq .drills 9
   165 writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] .drills
   166 op add .drills .drills 1
-    * jump *label55 always
   167 label *label54
   168 label *label55
   169 label *label53

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    89 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    90 set :findFreeUnit:unit_type @flare
    91 set :findFreeUnit:initial_flag 0
-    * ubind :findFreeUnit:unit_type
+   92 ubind @flare
    93 jump *label37 notEqual @unit null
    94 set *tmp47 null
    95 jump *label36 always
 
    99 label *label39
   100 sensor *tmp50 @unit @controlled
   101 jump *label42 notEqual *tmp50 0
-    * ucontrol flag :findFreeUnit:initial_flag
+  102 ucontrol flag 0
   103 set *tmp47 @unit
   104 jump *label36 always
   105 jump *label43 always
 
   110 label *label44
   111 label *label45
   112 label *label43
-    * ubind :findFreeUnit:unit_type
+  113 ubind @flare
   114 label *label40
   115 jump *label39 notEqual :findFreeUnit:first_unit @unit
   116 label *label41
   117 set *tmp47 null
   118 jump *label36 always
-    * set *tmp47 null
   119 label *label36
   120 set :backgroundProcess:unit *tmp47
-    * jump *label46 notEqual :backgroundProcess:unit null
+  121 jump *label46 notEqual *tmp47 null
   122 jump *label20 always
   123 label *label46
   124 label *label47
 
   127 # "Function: void serviceDrill(in drill, in unit)"
   128 set :serviceDrill:drill :backgroundProcess:drill
   129 set :serviceDrill:unit :backgroundProcess:unit
-    * ubind :serviceDrill:unit
+  130 ubind :backgroundProcess:unit
   131 sensor :serviceDrill:item @unit @firstItem
   132 jump *label49 notEqual :serviceDrill:item @titanium
   133 ucontrol approach .coreX .coreY 4
 
   135 jump *label50 always
   136 label *label49
   137 jump *label51 notEqual :serviceDrill:item null
-    * sensor *tmp65 :serviceDrill:drill @x
-    * sensor *tmp66 :serviceDrill:drill @y
+  138 sensor *tmp65 :backgroundProcess:drill @x
+  139 sensor *tmp66 :backgroundProcess:drill @y
   140 ucontrol approach *tmp65 *tmp66 4
-    * ucontrol itemTake :serviceDrill:drill @titanium 10
+  141 ucontrol itemTake :backgroundProcess:drill @titanium 10
   142 jump *label52 always
   143 label *label51
   144 ucontrol itemDrop @air 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    87 sensor *tmp44 :backgroundProcess:unit @controller
    88 jump *label34 equal *tmp44 @this
    89 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * set :findFreeUnit:unit_type @flare
-    * set :findFreeUnit:initial_flag 0
    90 ubind @flare
    91 jump *label37 notEqual @unit null
    92 set *tmp47 null
 
   123 label *label34
   124 label *label35
   125 # "Function: void serviceDrill(in drill, in unit)"
-    * set :serviceDrill:drill :backgroundProcess:drill
-    * set :serviceDrill:unit :backgroundProcess:unit
   126 ubind :backgroundProcess:unit
   127 sensor :serviceDrill:item @unit @firstItem
   128 jump *label49 notEqual :serviceDrill:item @titanium

Modifications by Iterated phase, Array Optimization, pass 1, iteration 1 (-13 instructions):
 
   157 label *label0
   158 # "Function: export void addTitaniumDrill(in drill)"
   159 jump *label54 greaterThanEq .drills 9
-    * writearr<internal:folded:compact> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  160 writearr<lookup:liquid> :addTitaniumDrill:drill .titaniumDrills[] .drills
   161 op add .drills .drills 1
   162 label *label54
   163 label *label55

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
   102 jump *label36 always
   103 jump *label43 always
   104 label *label42
-    * sensor *tmp53 :findFreeUnit:first_unit @dead
-    * jump *label44 notEqual *tmp53 1
-    * set :findFreeUnit:first_unit @unit
-    * label *label44
-    * label *label45
+  105 sensor *tmp53 :findFreeUnit:first_unit @dead
+  106 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   107 label *label43
   108 ubind @flare
   109 label *label40

Modifications by Unroll iteration loop at FlareController.mnd:63:9 (+331 instructions):
 
    20 label *label12
    21 label *label16
    22 set :backgroundProcess:count 0
-    * set :backgroundProcess:drill water
-    * set :backgroundProcess:unit .units*0
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label22 (m:marker0)
-    * set .units*0 :backgroundProcess:unit
-    * set :backgroundProcess:drill slag
-    * set :backgroundProcess:unit .units*1
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label23 (m:marker0)
-    * set .units*1 :backgroundProcess:unit
-    * set :backgroundProcess:drill oil
-    * set :backgroundProcess:unit .units*2
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label24 (m:marker0)
-    * set .units*2 :backgroundProcess:unit
-    * set :backgroundProcess:drill cryofluid
-    * set :backgroundProcess:unit .units*3
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label25 (m:marker0)
-    * set .units*3 :backgroundProcess:unit
-    * set :backgroundProcess:drill neoplasm
-    * set :backgroundProcess:unit .units*4
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label26 (m:marker0)
-    * set .units*4 :backgroundProcess:unit
-    * set :backgroundProcess:drill hydrogen
-    * set :backgroundProcess:unit .units*5
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label27 (m:marker0)
-    * set .units*5 :backgroundProcess:unit
-    * set :backgroundProcess:drill ozone
-    * set :backgroundProcess:unit .units*6
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label28 (m:marker0)
-    * set .units*6 :backgroundProcess:unit
-    * set :backgroundProcess:drill cyanogen
-    * set :backgroundProcess:unit .units*7
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label29 (m:marker0)
-    * set .units*7 :backgroundProcess:unit
-    * set :backgroundProcess:drill gallium
-    * set :backgroundProcess:unit .units*8
-    * op add *tmp40 @counter 1
-    * jump *label19 always
-    * multilabel *label30 (m:marker0)
-    * set .units*8 :backgroundProcess:unit
-    * set :backgroundProcess:drill nitrogen
-    * set :backgroundProcess:unit .units*9
-    * set *tmp40 null
-    * label *label19
-    * jump *label32 notEqual :backgroundProcess:drill null
-    * jump *label21 always
-    * label *label32
-    * label *label33
-    * sensor *tmp43 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count :backgroundProcess:count *tmp43
-    * sensor *tmp44 :backgroundProcess:unit @controller
-    * jump *label34 equal *tmp44 @this
-    * # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * ubind @flare
-    * jump *label37 notEqual @unit null
-    * set *tmp47 null
-    * jump *label36 always
-    * label *label37
-    * label *label38
-    * set :findFreeUnit:first_unit @unit
-    * label *label39
-    * sensor *tmp50 @unit @controlled
-    * jump *label42 notEqual *tmp50 0
-    * ucontrol flag 0
-    * set *tmp47 @unit
-    * jump *label36 always
-    * jump *label43 always
-    * label *label42
-    * sensor *tmp53 :findFreeUnit:first_unit @dead
-    * select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
-    * label *label43
-    * ubind @flare
-    * label *label40
-    * jump *label39 notEqual :findFreeUnit:first_unit @unit
-    * label *label41
-    * set *tmp47 null
-    * jump *label36 always
-    * label *label36
-    * set :backgroundProcess:unit *tmp47
-    * jump *label46 notEqual *tmp47 null
-    * jump *label20 always
-    * label *label46
-    * label *label47
-    * label *label34
-    * label *label35
-    * # "Function: void serviceDrill(in drill, in unit)"
-    * ubind :backgroundProcess:unit
-    * sensor :serviceDrill:item @unit @firstItem
-    * jump *label49 notEqual :serviceDrill:item @titanium
-    * ucontrol approach .coreX .coreY 4
-    * ucontrol itemDrop .core 10
-    * jump *label50 always
-    * label *label49
-    * jump *label51 notEqual :serviceDrill:item null
-    * sensor *tmp65 :backgroundProcess:drill @x
-    * sensor *tmp66 :backgroundProcess:drill @y
-    * ucontrol approach *tmp65 *tmp66 4
-    * ucontrol itemTake :backgroundProcess:drill @titanium 10
-    * jump *label52 always
-    * label *label51
-    * ucontrol itemDrop @air 10
-    * label *label52
-    * label *label50
-    * label *label48
-    * label *label20
-    * multijump *tmp40 0 0 (m:marker0)
-    * multilabel *label31 (m:marker0)
-    * set .units*9 :backgroundProcess:unit
-    * label *label21
+   23 set :backgroundProcess:drill water
+   24 set :backgroundProcess:unit .units*0
+   25 label *label56
+   26 jump *label57 notEqual :backgroundProcess:drill null
+   27 jump *label21 always
+   28 label *label57
+   29 label *label58
+   30 sensor *tmp43 :backgroundProcess:drill @titanium
+   31 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+   32 sensor *tmp44 :backgroundProcess:unit @controller
+   33 jump *label69 equal *tmp44 @this
+   34 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+   35 ubind @flare
+   36 jump *label59 notEqual @unit null
+   37 set *tmp47 null
+   38 jump *label66 always
+   39 label *label59
+   40 label *label60
+   41 set :findFreeUnit:first_unit @unit
+   42 label *label61
+   43 sensor *tmp50 @unit @controlled
+   44 jump *label62 notEqual *tmp50 0
+   45 ucontrol flag 0
+   46 set *tmp47 @unit
+   47 jump *label66 always
+   48 jump *label63 always
+   49 label *label62
+   50 sensor *tmp53 :findFreeUnit:first_unit @dead
+   51 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+   52 label *label63
+   53 ubind @flare
+   54 label *label64
+   55 jump *label61 notEqual :findFreeUnit:first_unit @unit
+   56 label *label65
+   57 set *tmp47 null
+   58 jump *label66 always
+   59 label *label66
+   60 set :backgroundProcess:unit *tmp47
+   61 jump *label67 notEqual *tmp47 null
+   62 jump *label76 always
+   63 label *label67
+   64 label *label68
+   65 label *label69
+   66 label *label70
+   67 # "Function: void serviceDrill(in drill, in unit)"
+   68 ubind :backgroundProcess:unit
+   69 sensor :serviceDrill:item @unit @firstItem
+   70 jump *label71 notEqual :serviceDrill:item @titanium
+   71 ucontrol approach .coreX .coreY 4
+   72 ucontrol itemDrop .core 10
+   73 jump *label74 always
+   74 label *label71
+   75 jump *label72 notEqual :serviceDrill:item null
+   76 sensor *tmp65 :backgroundProcess:drill @x
+   77 sensor *tmp66 :backgroundProcess:drill @y
+   78 ucontrol approach *tmp65 *tmp66 4
+   79 ucontrol itemTake :backgroundProcess:drill @titanium 10
+   80 jump *label73 always
+   81 label *label72
+   82 ucontrol itemDrop @air 10
+   83 label *label73
+   84 label *label74
+   85 label *label75
+   86 label *label76
+   87 set .units*0 :backgroundProcess:unit
+   88 set :backgroundProcess:drill slag
+   89 set :backgroundProcess:unit .units*1
+   90 label *label79
+   91 jump *label80 notEqual :backgroundProcess:drill null
+   92 jump *label21 always
+   93 label *label80
+   94 label *label81
+   95 sensor *tmp43 :backgroundProcess:drill @titanium
+   96 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+   97 sensor *tmp44 :backgroundProcess:unit @controller
+   98 jump *label92 equal *tmp44 @this
+   99 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  100 ubind @flare
+  101 jump *label82 notEqual @unit null
+  102 set *tmp47 null
+  103 jump *label89 always
+  104 label *label82
+  105 label *label83
+  106 set :findFreeUnit:first_unit @unit
+  107 label *label84
+  108 sensor *tmp50 @unit @controlled
+  109 jump *label85 notEqual *tmp50 0
+  110 ucontrol flag 0
+  111 set *tmp47 @unit
+  112 jump *label89 always
+  113 jump *label86 always
+  114 label *label85
+  115 sensor *tmp53 :findFreeUnit:first_unit @dead
+  116 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  117 label *label86
+  118 ubind @flare
+  119 label *label87
+  120 jump *label84 notEqual :findFreeUnit:first_unit @unit
+  121 label *label88
+  122 set *tmp47 null
+  123 jump *label89 always
+  124 label *label89
+  125 set :backgroundProcess:unit *tmp47
+  126 jump *label90 notEqual *tmp47 null
+  127 jump *label99 always
+  128 label *label90
+  129 label *label91
+  130 label *label92
+  131 label *label93
+  132 # "Function: void serviceDrill(in drill, in unit)"
+  133 ubind :backgroundProcess:unit
+  134 sensor :serviceDrill:item @unit @firstItem
+  135 jump *label94 notEqual :serviceDrill:item @titanium
+  136 ucontrol approach .coreX .coreY 4
+  137 ucontrol itemDrop .core 10
+  138 jump *label97 always
+  139 label *label94
+  140 jump *label95 notEqual :serviceDrill:item null
+  141 sensor *tmp65 :backgroundProcess:drill @x
+  142 sensor *tmp66 :backgroundProcess:drill @y
+  143 ucontrol approach *tmp65 *tmp66 4
+  144 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  145 jump *label96 always
+  146 label *label95
+  147 ucontrol itemDrop @air 10
+  148 label *label96
+  149 label *label97
+  150 label *label98
+  151 label *label99
+  152 set .units*1 :backgroundProcess:unit
+  153 set :backgroundProcess:drill oil
+  154 set :backgroundProcess:unit .units*2
+  155 label *label102
+  156 jump *label103 notEqual :backgroundProcess:drill null
+  157 jump *label21 always
+  158 label *label103
+  159 label *label104
+  160 sensor *tmp43 :backgroundProcess:drill @titanium
+  161 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  162 sensor *tmp44 :backgroundProcess:unit @controller
+  163 jump *label115 equal *tmp44 @this
+  164 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  165 ubind @flare
+  166 jump *label105 notEqual @unit null
+  167 set *tmp47 null
+  168 jump *label112 always
+  169 label *label105
+  170 label *label106
+  171 set :findFreeUnit:first_unit @unit
+  172 label *label107
+  173 sensor *tmp50 @unit @controlled
+  174 jump *label108 notEqual *tmp50 0
+  175 ucontrol flag 0
+  176 set *tmp47 @unit
+  177 jump *label112 always
+  178 jump *label109 always
+  179 label *label108
+  180 sensor *tmp53 :findFreeUnit:first_unit @dead
+  181 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  182 label *label109
+  183 ubind @flare
+  184 label *label110
+  185 jump *label107 notEqual :findFreeUnit:first_unit @unit
+  186 label *label111
+  187 set *tmp47 null
+  188 jump *label112 always
+  189 label *label112
+  190 set :backgroundProcess:unit *tmp47
+  191 jump *label113 notEqual *tmp47 null
+  192 jump *label122 always
+  193 label *label113
+  194 label *label114
+  195 label *label115
+  196 label *label116
+  197 # "Function: void serviceDrill(in drill, in unit)"
+  198 ubind :backgroundProcess:unit
+  199 sensor :serviceDrill:item @unit @firstItem
+  200 jump *label117 notEqual :serviceDrill:item @titanium
+  201 ucontrol approach .coreX .coreY 4
+  202 ucontrol itemDrop .core 10
+  203 jump *label120 always
+  204 label *label117
+  205 jump *label118 notEqual :serviceDrill:item null
+  206 sensor *tmp65 :backgroundProcess:drill @x
+  207 sensor *tmp66 :backgroundProcess:drill @y
+  208 ucontrol approach *tmp65 *tmp66 4
+  209 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  210 jump *label119 always
+  211 label *label118
+  212 ucontrol itemDrop @air 10
+  213 label *label119
+  214 label *label120
+  215 label *label121
+  216 label *label122
+  217 set .units*2 :backgroundProcess:unit
+  218 set :backgroundProcess:drill cryofluid
+  219 set :backgroundProcess:unit .units*3
+  220 label *label125
+  221 jump *label126 notEqual :backgroundProcess:drill null
+  222 jump *label21 always
+  223 label *label126
+  224 label *label127
+  225 sensor *tmp43 :backgroundProcess:drill @titanium
+  226 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  227 sensor *tmp44 :backgroundProcess:unit @controller
+  228 jump *label138 equal *tmp44 @this
+  229 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  230 ubind @flare
+  231 jump *label128 notEqual @unit null
+  232 set *tmp47 null
+  233 jump *label135 always
+  234 label *label128
+  235 label *label129
+  236 set :findFreeUnit:first_unit @unit
+  237 label *label130
+  238 sensor *tmp50 @unit @controlled
+  239 jump *label131 notEqual *tmp50 0
+  240 ucontrol flag 0
+  241 set *tmp47 @unit
+  242 jump *label135 always
+  243 jump *label132 always
+  244 label *label131
+  245 sensor *tmp53 :findFreeUnit:first_unit @dead
+  246 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  247 label *label132
+  248 ubind @flare
+  249 label *label133
+  250 jump *label130 notEqual :findFreeUnit:first_unit @unit
+  251 label *label134
+  252 set *tmp47 null
+  253 jump *label135 always
+  254 label *label135
+  255 set :backgroundProcess:unit *tmp47
+  256 jump *label136 notEqual *tmp47 null
+  257 jump *label145 always
+  258 label *label136
+  259 label *label137
+  260 label *label138
+  261 label *label139
+  262 # "Function: void serviceDrill(in drill, in unit)"
+  263 ubind :backgroundProcess:unit
+  264 sensor :serviceDrill:item @unit @firstItem
+  265 jump *label140 notEqual :serviceDrill:item @titanium
+  266 ucontrol approach .coreX .coreY 4
+  267 ucontrol itemDrop .core 10
+  268 jump *label143 always
+  269 label *label140
+  270 jump *label141 notEqual :serviceDrill:item null
+  271 sensor *tmp65 :backgroundProcess:drill @x
+  272 sensor *tmp66 :backgroundProcess:drill @y
+  273 ucontrol approach *tmp65 *tmp66 4
+  274 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  275 jump *label142 always
+  276 label *label141
+  277 ucontrol itemDrop @air 10
+  278 label *label142
+  279 label *label143
+  280 label *label144
+  281 label *label145
+  282 set .units*3 :backgroundProcess:unit
+  283 set :backgroundProcess:drill neoplasm
+  284 set :backgroundProcess:unit .units*4
+  285 label *label148
+  286 jump *label149 notEqual :backgroundProcess:drill null
+  287 jump *label21 always
+  288 label *label149
+  289 label *label150
+  290 sensor *tmp43 :backgroundProcess:drill @titanium
+  291 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  292 sensor *tmp44 :backgroundProcess:unit @controller
+  293 jump *label161 equal *tmp44 @this
+  294 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  295 ubind @flare
+  296 jump *label151 notEqual @unit null
+  297 set *tmp47 null
+  298 jump *label158 always
+  299 label *label151
+  300 label *label152
+  301 set :findFreeUnit:first_unit @unit
+  302 label *label153
+  303 sensor *tmp50 @unit @controlled
+  304 jump *label154 notEqual *tmp50 0
+  305 ucontrol flag 0
+  306 set *tmp47 @unit
+  307 jump *label158 always
+  308 jump *label155 always
+  309 label *label154
+  310 sensor *tmp53 :findFreeUnit:first_unit @dead
+  311 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  312 label *label155
+  313 ubind @flare
+  314 label *label156
+  315 jump *label153 notEqual :findFreeUnit:first_unit @unit
+  316 label *label157
+  317 set *tmp47 null
+  318 jump *label158 always
+  319 label *label158
+  320 set :backgroundProcess:unit *tmp47
+  321 jump *label159 notEqual *tmp47 null
+  322 jump *label168 always
+  323 label *label159
+  324 label *label160
+  325 label *label161
+  326 label *label162
+  327 # "Function: void serviceDrill(in drill, in unit)"
+  328 ubind :backgroundProcess:unit
+  329 sensor :serviceDrill:item @unit @firstItem
+  330 jump *label163 notEqual :serviceDrill:item @titanium
+  331 ucontrol approach .coreX .coreY 4
+  332 ucontrol itemDrop .core 10
+  333 jump *label166 always
+  334 label *label163
+  335 jump *label164 notEqual :serviceDrill:item null
+  336 sensor *tmp65 :backgroundProcess:drill @x
+  337 sensor *tmp66 :backgroundProcess:drill @y
+  338 ucontrol approach *tmp65 *tmp66 4
+  339 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  340 jump *label165 always
+  341 label *label164
+  342 ucontrol itemDrop @air 10
+  343 label *label165
+  344 label *label166
+  345 label *label167
+  346 label *label168
+  347 set .units*4 :backgroundProcess:unit
+  348 set :backgroundProcess:drill hydrogen
+  349 set :backgroundProcess:unit .units*5
+  350 label *label171
+  351 jump *label172 notEqual :backgroundProcess:drill null
+  352 jump *label21 always
+  353 label *label172
+  354 label *label173
+  355 sensor *tmp43 :backgroundProcess:drill @titanium
+  356 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  357 sensor *tmp44 :backgroundProcess:unit @controller
+  358 jump *label184 equal *tmp44 @this
+  359 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  360 ubind @flare
+  361 jump *label174 notEqual @unit null
+  362 set *tmp47 null
+  363 jump *label181 always
+  364 label *label174
+  365 label *label175
+  366 set :findFreeUnit:first_unit @unit
+  367 label *label176
+  368 sensor *tmp50 @unit @controlled
+  369 jump *label177 notEqual *tmp50 0
+  370 ucontrol flag 0
+  371 set *tmp47 @unit
+  372 jump *label181 always
+  373 jump *label178 always
+  374 label *label177
+  375 sensor *tmp53 :findFreeUnit:first_unit @dead
+  376 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  377 label *label178
+  378 ubind @flare
+  379 label *label179
+  380 jump *label176 notEqual :findFreeUnit:first_unit @unit
+  381 label *label180
+  382 set *tmp47 null
+  383 jump *label181 always
+  384 label *label181
+  385 set :backgroundProcess:unit *tmp47
+  386 jump *label182 notEqual *tmp47 null
+  387 jump *label191 always
+  388 label *label182
+  389 label *label183
+  390 label *label184
+  391 label *label185
+  392 # "Function: void serviceDrill(in drill, in unit)"
+  393 ubind :backgroundProcess:unit
+  394 sensor :serviceDrill:item @unit @firstItem
+  395 jump *label186 notEqual :serviceDrill:item @titanium
+  396 ucontrol approach .coreX .coreY 4
+  397 ucontrol itemDrop .core 10
+  398 jump *label189 always
+  399 label *label186
+  400 jump *label187 notEqual :serviceDrill:item null
+  401 sensor *tmp65 :backgroundProcess:drill @x
+  402 sensor *tmp66 :backgroundProcess:drill @y
+  403 ucontrol approach *tmp65 *tmp66 4
+  404 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  405 jump *label188 always
+  406 label *label187
+  407 ucontrol itemDrop @air 10
+  408 label *label188
+  409 label *label189
+  410 label *label190
+  411 label *label191
+  412 set .units*5 :backgroundProcess:unit
+  413 set :backgroundProcess:drill ozone
+  414 set :backgroundProcess:unit .units*6
+  415 label *label194
+  416 jump *label195 notEqual :backgroundProcess:drill null
+  417 jump *label21 always
+  418 label *label195
+  419 label *label196
+  420 sensor *tmp43 :backgroundProcess:drill @titanium
+  421 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  422 sensor *tmp44 :backgroundProcess:unit @controller
+  423 jump *label207 equal *tmp44 @this
+  424 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  425 ubind @flare
+  426 jump *label197 notEqual @unit null
+  427 set *tmp47 null
+  428 jump *label204 always
+  429 label *label197
+  430 label *label198
+  431 set :findFreeUnit:first_unit @unit
+  432 label *label199
+  433 sensor *tmp50 @unit @controlled
+  434 jump *label200 notEqual *tmp50 0
+  435 ucontrol flag 0
+  436 set *tmp47 @unit
+  437 jump *label204 always
+  438 jump *label201 always
+  439 label *label200
+  440 sensor *tmp53 :findFreeUnit:first_unit @dead
+  441 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  442 label *label201
+  443 ubind @flare
+  444 label *label202
+  445 jump *label199 notEqual :findFreeUnit:first_unit @unit
+  446 label *label203
+  447 set *tmp47 null
+  448 jump *label204 always
+  449 label *label204
+  450 set :backgroundProcess:unit *tmp47
+  451 jump *label205 notEqual *tmp47 null
+  452 jump *label214 always
+  453 label *label205
+  454 label *label206
+  455 label *label207
+  456 label *label208
+  457 # "Function: void serviceDrill(in drill, in unit)"
+  458 ubind :backgroundProcess:unit
+  459 sensor :serviceDrill:item @unit @firstItem
+  460 jump *label209 notEqual :serviceDrill:item @titanium
+  461 ucontrol approach .coreX .coreY 4
+  462 ucontrol itemDrop .core 10
+  463 jump *label212 always
+  464 label *label209
+  465 jump *label210 notEqual :serviceDrill:item null
+  466 sensor *tmp65 :backgroundProcess:drill @x
+  467 sensor *tmp66 :backgroundProcess:drill @y
+  468 ucontrol approach *tmp65 *tmp66 4
+  469 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  470 jump *label211 always
+  471 label *label210
+  472 ucontrol itemDrop @air 10
+  473 label *label211
+  474 label *label212
+  475 label *label213
+  476 label *label214
+  477 set .units*6 :backgroundProcess:unit
+  478 set :backgroundProcess:drill cyanogen
+  479 set :backgroundProcess:unit .units*7
+  480 label *label217
+  481 jump *label218 notEqual :backgroundProcess:drill null
+  482 jump *label21 always
+  483 label *label218
+  484 label *label219
+  485 sensor *tmp43 :backgroundProcess:drill @titanium
+  486 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  487 sensor *tmp44 :backgroundProcess:unit @controller
+  488 jump *label230 equal *tmp44 @this
+  489 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  490 ubind @flare
+  491 jump *label220 notEqual @unit null
+  492 set *tmp47 null
+  493 jump *label227 always
+  494 label *label220
+  495 label *label221
+  496 set :findFreeUnit:first_unit @unit
+  497 label *label222
+  498 sensor *tmp50 @unit @controlled
+  499 jump *label223 notEqual *tmp50 0
+  500 ucontrol flag 0
+  501 set *tmp47 @unit
+  502 jump *label227 always
+  503 jump *label224 always
+  504 label *label223
+  505 sensor *tmp53 :findFreeUnit:first_unit @dead
+  506 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  507 label *label224
+  508 ubind @flare
+  509 label *label225
+  510 jump *label222 notEqual :findFreeUnit:first_unit @unit
+  511 label *label226
+  512 set *tmp47 null
+  513 jump *label227 always
+  514 label *label227
+  515 set :backgroundProcess:unit *tmp47
+  516 jump *label228 notEqual *tmp47 null
+  517 jump *label237 always
+  518 label *label228
+  519 label *label229
+  520 label *label230
+  521 label *label231
+  522 # "Function: void serviceDrill(in drill, in unit)"
+  523 ubind :backgroundProcess:unit
+  524 sensor :serviceDrill:item @unit @firstItem
+  525 jump *label232 notEqual :serviceDrill:item @titanium
+  526 ucontrol approach .coreX .coreY 4
+  527 ucontrol itemDrop .core 10
+  528 jump *label235 always
+  529 label *label232
+  530 jump *label233 notEqual :serviceDrill:item null
+  531 sensor *tmp65 :backgroundProcess:drill @x
+  532 sensor *tmp66 :backgroundProcess:drill @y
+  533 ucontrol approach *tmp65 *tmp66 4
+  534 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  535 jump *label234 always
+  536 label *label233
+  537 ucontrol itemDrop @air 10
+  538 label *label234
+  539 label *label235
+  540 label *label236
+  541 label *label237
+  542 set .units*7 :backgroundProcess:unit
+  543 set :backgroundProcess:drill gallium
+  544 set :backgroundProcess:unit .units*8
+  545 label *label240
+  546 jump *label241 notEqual :backgroundProcess:drill null
+  547 jump *label21 always
+  548 label *label241
+  549 label *label242
+  550 sensor *tmp43 :backgroundProcess:drill @titanium
+  551 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  552 sensor *tmp44 :backgroundProcess:unit @controller
+  553 jump *label253 equal *tmp44 @this
+  554 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  555 ubind @flare
+  556 jump *label243 notEqual @unit null
+  557 set *tmp47 null
+  558 jump *label250 always
+  559 label *label243
+  560 label *label244
+  561 set :findFreeUnit:first_unit @unit
+  562 label *label245
+  563 sensor *tmp50 @unit @controlled
+  564 jump *label246 notEqual *tmp50 0
+  565 ucontrol flag 0
+  566 set *tmp47 @unit
+  567 jump *label250 always
+  568 jump *label247 always
+  569 label *label246
+  570 sensor *tmp53 :findFreeUnit:first_unit @dead
+  571 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  572 label *label247
+  573 ubind @flare
+  574 label *label248
+  575 jump *label245 notEqual :findFreeUnit:first_unit @unit
+  576 label *label249
+  577 set *tmp47 null
+  578 jump *label250 always
+  579 label *label250
+  580 set :backgroundProcess:unit *tmp47
+  581 jump *label251 notEqual *tmp47 null
+  582 jump *label260 always
+  583 label *label251
+  584 label *label252
+  585 label *label253
+  586 label *label254
+  587 # "Function: void serviceDrill(in drill, in unit)"
+  588 ubind :backgroundProcess:unit
+  589 sensor :serviceDrill:item @unit @firstItem
+  590 jump *label255 notEqual :serviceDrill:item @titanium
+  591 ucontrol approach .coreX .coreY 4
+  592 ucontrol itemDrop .core 10
+  593 jump *label258 always
+  594 label *label255
+  595 jump *label256 notEqual :serviceDrill:item null
+  596 sensor *tmp65 :backgroundProcess:drill @x
+  597 sensor *tmp66 :backgroundProcess:drill @y
+  598 ucontrol approach *tmp65 *tmp66 4
+  599 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  600 jump *label257 always
+  601 label *label256
+  602 ucontrol itemDrop @air 10
+  603 label *label257
+  604 label *label258
+  605 label *label259
+  606 label *label260
+  607 set .units*8 :backgroundProcess:unit
+  608 set :backgroundProcess:drill nitrogen
+  609 set :backgroundProcess:unit .units*9
+  610 label *label263
+  611 jump *label264 notEqual :backgroundProcess:drill null
+  612 jump *label21 always
+  613 label *label264
+  614 label *label265
+  615 sensor *tmp43 :backgroundProcess:drill @titanium
+  616 op add :backgroundProcess:count :backgroundProcess:count *tmp43
+  617 sensor *tmp44 :backgroundProcess:unit @controller
+  618 jump *label276 equal *tmp44 @this
+  619 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  620 ubind @flare
+  621 jump *label266 notEqual @unit null
+  622 set *tmp47 null
+  623 jump *label273 always
+  624 label *label266
+  625 label *label267
+  626 set :findFreeUnit:first_unit @unit
+  627 label *label268
+  628 sensor *tmp50 @unit @controlled
+  629 jump *label269 notEqual *tmp50 0
+  630 ucontrol flag 0
+  631 set *tmp47 @unit
+  632 jump *label273 always
+  633 jump *label270 always
+  634 label *label269
+  635 sensor *tmp53 :findFreeUnit:first_unit @dead
+  636 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
+  637 label *label270
+  638 ubind @flare
+  639 label *label271
+  640 jump *label268 notEqual :findFreeUnit:first_unit @unit
+  641 label *label272
+  642 set *tmp47 null
+  643 jump *label273 always
+  644 label *label273
+  645 set :backgroundProcess:unit *tmp47
+  646 jump *label274 notEqual *tmp47 null
+  647 jump *label283 always
+  648 label *label274
+  649 label *label275
+  650 label *label276
+  651 label *label277
+  652 # "Function: void serviceDrill(in drill, in unit)"
+  653 ubind :backgroundProcess:unit
+  654 sensor :serviceDrill:item @unit @firstItem
+  655 jump *label278 notEqual :serviceDrill:item @titanium
+  656 ucontrol approach .coreX .coreY 4
+  657 ucontrol itemDrop .core 10
+  658 jump *label281 always
+  659 label *label278
+  660 jump *label279 notEqual :serviceDrill:item null
+  661 sensor *tmp65 :backgroundProcess:drill @x
+  662 sensor *tmp66 :backgroundProcess:drill @y
+  663 ucontrol approach *tmp65 *tmp66 4
+  664 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  665 jump *label280 always
+  666 label *label279
+  667 ucontrol itemDrop @air 10
+  668 label *label280
+  669 label *label281
+  670 label *label282
+  671 label *label283
+  672 set .units*9 :backgroundProcess:unit
+  673 label *label21
   674 write :backgroundProcess:count processor2 ".titaniumDrillCount"
   675 label *label17
   676 jump *label16 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    28 label *label57
    29 label *label58
    30 sensor *tmp43 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count :backgroundProcess:count *tmp43
+   31 op add :backgroundProcess:count 0 *tmp43
    32 sensor *tmp44 :backgroundProcess:unit @controller
    33 jump *label69 equal *tmp44 @this
    34 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-10 instructions):
 
    55 jump *label61 notEqual :findFreeUnit:first_unit @unit
    56 label *label65
    57 set *tmp47 null
-    * jump *label66 always
    58 label *label66
    59 set :backgroundProcess:unit *tmp47
    60 jump *label67 notEqual *tmp47 null
 
   119 jump *label84 notEqual :findFreeUnit:first_unit @unit
   120 label *label88
   121 set *tmp47 null
-    * jump *label89 always
   122 label *label89
   123 set :backgroundProcess:unit *tmp47
   124 jump *label90 notEqual *tmp47 null
 
   183 jump *label107 notEqual :findFreeUnit:first_unit @unit
   184 label *label111
   185 set *tmp47 null
-    * jump *label112 always
   186 label *label112
   187 set :backgroundProcess:unit *tmp47
   188 jump *label113 notEqual *tmp47 null
 
   247 jump *label130 notEqual :findFreeUnit:first_unit @unit
   248 label *label134
   249 set *tmp47 null
-    * jump *label135 always
   250 label *label135
   251 set :backgroundProcess:unit *tmp47
   252 jump *label136 notEqual *tmp47 null
 
   311 jump *label153 notEqual :findFreeUnit:first_unit @unit
   312 label *label157
   313 set *tmp47 null
-    * jump *label158 always
   314 label *label158
   315 set :backgroundProcess:unit *tmp47
   316 jump *label159 notEqual *tmp47 null
 
   375 jump *label176 notEqual :findFreeUnit:first_unit @unit
   376 label *label180
   377 set *tmp47 null
-    * jump *label181 always
   378 label *label181
   379 set :backgroundProcess:unit *tmp47
   380 jump *label182 notEqual *tmp47 null
 
   439 jump *label199 notEqual :findFreeUnit:first_unit @unit
   440 label *label203
   441 set *tmp47 null
-    * jump *label204 always
   442 label *label204
   443 set :backgroundProcess:unit *tmp47
   444 jump *label205 notEqual *tmp47 null
 
   503 jump *label222 notEqual :findFreeUnit:first_unit @unit
   504 label *label226
   505 set *tmp47 null
-    * jump *label227 always
   506 label *label227
   507 set :backgroundProcess:unit *tmp47
   508 jump *label228 notEqual *tmp47 null
 
   567 jump *label245 notEqual :findFreeUnit:first_unit @unit
   568 label *label249
   569 set *tmp47 null
-    * jump *label250 always
   570 label *label250
   571 set :backgroundProcess:unit *tmp47
   572 jump *label251 notEqual *tmp47 null
 
   631 jump *label268 notEqual :findFreeUnit:first_unit @unit
   632 label *label272
   633 set *tmp47 null
-    * jump *label273 always
   634 label *label273
   635 set :backgroundProcess:unit *tmp47
   636 jump *label274 notEqual *tmp47 null

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    28 label *label57
    29 label *label58
    30 sensor *tmp43 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count 0 *tmp43
+   31 set :backgroundProcess:count *tmp43
    32 sensor *tmp44 :backgroundProcess:unit @controller
    33 jump *label69 equal *tmp44 @this
    34 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Virtual Instruction Expansion:
 
   672 label *label0
   673 # "Function: export void addTitaniumDrill(in drill)"
   674 jump *label54 greaterThanEq .drills 9
-    * writearr<lookup:liquid> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  675 lookup liquid *tmp72 .drills
+  676 sensor .titaniumDrills*elem *tmp72 @name
+  677 write :addTitaniumDrill:drill @this .titaniumDrills*elem
   678 op add .drills .drills 1
   679 label *label54
   680 label *label55

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-14 instructions):
 
    11 label *label13
    12 ubind @flare
    13 ulocate building core false @copper .coreX .coreY *tmp36 .core
-    * label *label14
    14 jump *label13 equal .core null
-    * label *label15
    15 sensor .coreX .core @x
    16 sensor .coreY .core @y
    17 label *label11
-    * label *label12
    18 label *label16
    19 set :backgroundProcess:count 0
    20 set :backgroundProcess:drill water
    21 set :backgroundProcess:unit .units*0
-    * label *label56
    22 jump *label57 notEqual :backgroundProcess:drill null
    23 jump *label21 always
    24 label *label57
-    * label *label58
    25 sensor *tmp43 :backgroundProcess:drill @titanium
    26 set :backgroundProcess:count *tmp43
    27 sensor *tmp44 :backgroundProcess:unit @controller
 
    32 set *tmp47 null
    33 jump *label66 always
    34 label *label59
-    * label *label60
    35 set :findFreeUnit:first_unit @unit
    36 label *label61
    37 sensor *tmp50 @unit @controlled
 
    39 ucontrol flag 0
    40 set *tmp47 @unit
    41 jump *label66 always
-    * jump *label63 always
    42 label *label62
    43 sensor *tmp53 :findFreeUnit:first_unit @dead
    44 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
    45 label *label63
    46 ubind @flare
-    * label *label64
    47 jump *label61 notEqual :findFreeUnit:first_unit @unit
-    * label *label65
    48 set *tmp47 null
    49 label *label66
    50 set :backgroundProcess:unit *tmp47
    51 jump *label67 notEqual *tmp47 null
    52 jump *label76 always
    53 label *label67
-    * label *label68
    54 label *label69
-    * label *label70
    55 # "Function: void serviceDrill(in drill, in unit)"
    56 ubind :backgroundProcess:unit
    57 sensor :serviceDrill:item @unit @firstItem
 
    70 ucontrol itemDrop @air 10
    71 label *label73
    72 label *label74
-    * label *label75
    73 label *label76
    74 set .units*0 :backgroundProcess:unit
    75 set :backgroundProcess:drill slag
    76 set :backgroundProcess:unit .units*1
-    * label *label79
    77 jump *label80 notEqual :backgroundProcess:drill null
    78 jump *label21 always
    79 label *label80
-    * label *label81
    80 sensor *tmp43 :backgroundProcess:drill @titanium
    81 op add :backgroundProcess:count :backgroundProcess:count *tmp43
    82 sensor *tmp44 :backgroundProcess:unit @controller
 
    87 set *tmp47 null
    88 jump *label89 always
    89 label *label82
-    * label *label83
    90 set :findFreeUnit:first_unit @unit
    91 label *label84
    92 sensor *tmp50 @unit @controlled
 
    94 ucontrol flag 0
    95 set *tmp47 @unit
    96 jump *label89 always
-    * jump *label86 always
    97 label *label85
    98 sensor *tmp53 :findFreeUnit:first_unit @dead
    99 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   100 label *label86
   101 ubind @flare
-    * label *label87
   102 jump *label84 notEqual :findFreeUnit:first_unit @unit
-    * label *label88
   103 set *tmp47 null
   104 label *label89
   105 set :backgroundProcess:unit *tmp47
   106 jump *label90 notEqual *tmp47 null
   107 jump *label99 always
   108 label *label90
-    * label *label91
   109 label *label92
-    * label *label93
   110 # "Function: void serviceDrill(in drill, in unit)"
   111 ubind :backgroundProcess:unit
   112 sensor :serviceDrill:item @unit @firstItem
 
   125 ucontrol itemDrop @air 10
   126 label *label96
   127 label *label97
-    * label *label98
   128 label *label99
   129 set .units*1 :backgroundProcess:unit
   130 set :backgroundProcess:drill oil
   131 set :backgroundProcess:unit .units*2
-    * label *label102
   132 jump *label103 notEqual :backgroundProcess:drill null
   133 jump *label21 always
   134 label *label103
-    * label *label104
   135 sensor *tmp43 :backgroundProcess:drill @titanium
   136 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   137 sensor *tmp44 :backgroundProcess:unit @controller
 
   142 set *tmp47 null
   143 jump *label112 always
   144 label *label105
-    * label *label106
   145 set :findFreeUnit:first_unit @unit
   146 label *label107
   147 sensor *tmp50 @unit @controlled
 
   149 ucontrol flag 0
   150 set *tmp47 @unit
   151 jump *label112 always
-    * jump *label109 always
   152 label *label108
   153 sensor *tmp53 :findFreeUnit:first_unit @dead
   154 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   155 label *label109
   156 ubind @flare
-    * label *label110
   157 jump *label107 notEqual :findFreeUnit:first_unit @unit
-    * label *label111
   158 set *tmp47 null
   159 label *label112
   160 set :backgroundProcess:unit *tmp47
   161 jump *label113 notEqual *tmp47 null
   162 jump *label122 always
   163 label *label113
-    * label *label114
   164 label *label115
-    * label *label116
   165 # "Function: void serviceDrill(in drill, in unit)"
   166 ubind :backgroundProcess:unit
   167 sensor :serviceDrill:item @unit @firstItem
 
   180 ucontrol itemDrop @air 10
   181 label *label119
   182 label *label120
-    * label *label121
   183 label *label122
   184 set .units*2 :backgroundProcess:unit
   185 set :backgroundProcess:drill cryofluid
   186 set :backgroundProcess:unit .units*3
-    * label *label125
   187 jump *label126 notEqual :backgroundProcess:drill null
   188 jump *label21 always
   189 label *label126
-    * label *label127
   190 sensor *tmp43 :backgroundProcess:drill @titanium
   191 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   192 sensor *tmp44 :backgroundProcess:unit @controller
 
   197 set *tmp47 null
   198 jump *label135 always
   199 label *label128
-    * label *label129
   200 set :findFreeUnit:first_unit @unit
   201 label *label130
   202 sensor *tmp50 @unit @controlled
 
   204 ucontrol flag 0
   205 set *tmp47 @unit
   206 jump *label135 always
-    * jump *label132 always
   207 label *label131
   208 sensor *tmp53 :findFreeUnit:first_unit @dead
   209 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   210 label *label132
   211 ubind @flare
-    * label *label133
   212 jump *label130 notEqual :findFreeUnit:first_unit @unit
-    * label *label134
   213 set *tmp47 null
   214 label *label135
   215 set :backgroundProcess:unit *tmp47
   216 jump *label136 notEqual *tmp47 null
   217 jump *label145 always
   218 label *label136
-    * label *label137
   219 label *label138
-    * label *label139
   220 # "Function: void serviceDrill(in drill, in unit)"
   221 ubind :backgroundProcess:unit
   222 sensor :serviceDrill:item @unit @firstItem
 
   235 ucontrol itemDrop @air 10
   236 label *label142
   237 label *label143
-    * label *label144
   238 label *label145
   239 set .units*3 :backgroundProcess:unit
   240 set :backgroundProcess:drill neoplasm
   241 set :backgroundProcess:unit .units*4
-    * label *label148
   242 jump *label149 notEqual :backgroundProcess:drill null
   243 jump *label21 always
   244 label *label149
-    * label *label150
   245 sensor *tmp43 :backgroundProcess:drill @titanium
   246 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   247 sensor *tmp44 :backgroundProcess:unit @controller
 
   252 set *tmp47 null
   253 jump *label158 always
   254 label *label151
-    * label *label152
   255 set :findFreeUnit:first_unit @unit
   256 label *label153
   257 sensor *tmp50 @unit @controlled
 
   259 ucontrol flag 0
   260 set *tmp47 @unit
   261 jump *label158 always
-    * jump *label155 always
   262 label *label154
   263 sensor *tmp53 :findFreeUnit:first_unit @dead
   264 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   265 label *label155
   266 ubind @flare
-    * label *label156
   267 jump *label153 notEqual :findFreeUnit:first_unit @unit
-    * label *label157
   268 set *tmp47 null
   269 label *label158
   270 set :backgroundProcess:unit *tmp47
   271 jump *label159 notEqual *tmp47 null
   272 jump *label168 always
   273 label *label159
-    * label *label160
   274 label *label161
-    * label *label162
   275 # "Function: void serviceDrill(in drill, in unit)"
   276 ubind :backgroundProcess:unit
   277 sensor :serviceDrill:item @unit @firstItem
 
   290 ucontrol itemDrop @air 10
   291 label *label165
   292 label *label166
-    * label *label167
   293 label *label168
   294 set .units*4 :backgroundProcess:unit
   295 set :backgroundProcess:drill hydrogen
   296 set :backgroundProcess:unit .units*5
-    * label *label171
   297 jump *label172 notEqual :backgroundProcess:drill null
   298 jump *label21 always
   299 label *label172
-    * label *label173
   300 sensor *tmp43 :backgroundProcess:drill @titanium
   301 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   302 sensor *tmp44 :backgroundProcess:unit @controller
 
   307 set *tmp47 null
   308 jump *label181 always
   309 label *label174
-    * label *label175
   310 set :findFreeUnit:first_unit @unit
   311 label *label176
   312 sensor *tmp50 @unit @controlled
 
   314 ucontrol flag 0
   315 set *tmp47 @unit
   316 jump *label181 always
-    * jump *label178 always
   317 label *label177
   318 sensor *tmp53 :findFreeUnit:first_unit @dead
   319 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   320 label *label178
   321 ubind @flare
-    * label *label179
   322 jump *label176 notEqual :findFreeUnit:first_unit @unit
-    * label *label180
   323 set *tmp47 null
   324 label *label181
   325 set :backgroundProcess:unit *tmp47
   326 jump *label182 notEqual *tmp47 null
   327 jump *label191 always
   328 label *label182
-    * label *label183
   329 label *label184
-    * label *label185
   330 # "Function: void serviceDrill(in drill, in unit)"
   331 ubind :backgroundProcess:unit
   332 sensor :serviceDrill:item @unit @firstItem
 
   345 ucontrol itemDrop @air 10
   346 label *label188
   347 label *label189
-    * label *label190
   348 label *label191
   349 set .units*5 :backgroundProcess:unit
   350 set :backgroundProcess:drill ozone
   351 set :backgroundProcess:unit .units*6
-    * label *label194
   352 jump *label195 notEqual :backgroundProcess:drill null
   353 jump *label21 always
   354 label *label195
-    * label *label196
   355 sensor *tmp43 :backgroundProcess:drill @titanium
   356 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   357 sensor *tmp44 :backgroundProcess:unit @controller
 
   362 set *tmp47 null
   363 jump *label204 always
   364 label *label197
-    * label *label198
   365 set :findFreeUnit:first_unit @unit
   366 label *label199
   367 sensor *tmp50 @unit @controlled
 
   369 ucontrol flag 0
   370 set *tmp47 @unit
   371 jump *label204 always
-    * jump *label201 always
   372 label *label200
   373 sensor *tmp53 :findFreeUnit:first_unit @dead
   374 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   375 label *label201
   376 ubind @flare
-    * label *label202
   377 jump *label199 notEqual :findFreeUnit:first_unit @unit
-    * label *label203
   378 set *tmp47 null
   379 label *label204
   380 set :backgroundProcess:unit *tmp47
   381 jump *label205 notEqual *tmp47 null
   382 jump *label214 always
   383 label *label205
-    * label *label206
   384 label *label207
-    * label *label208
   385 # "Function: void serviceDrill(in drill, in unit)"
   386 ubind :backgroundProcess:unit
   387 sensor :serviceDrill:item @unit @firstItem
 
   400 ucontrol itemDrop @air 10
   401 label *label211
   402 label *label212
-    * label *label213
   403 label *label214
   404 set .units*6 :backgroundProcess:unit
   405 set :backgroundProcess:drill cyanogen
   406 set :backgroundProcess:unit .units*7
-    * label *label217
   407 jump *label218 notEqual :backgroundProcess:drill null
   408 jump *label21 always
   409 label *label218
-    * label *label219
   410 sensor *tmp43 :backgroundProcess:drill @titanium
   411 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   412 sensor *tmp44 :backgroundProcess:unit @controller
 
   417 set *tmp47 null
   418 jump *label227 always
   419 label *label220
-    * label *label221
   420 set :findFreeUnit:first_unit @unit
   421 label *label222
   422 sensor *tmp50 @unit @controlled
 
   424 ucontrol flag 0
   425 set *tmp47 @unit
   426 jump *label227 always
-    * jump *label224 always
   427 label *label223
   428 sensor *tmp53 :findFreeUnit:first_unit @dead
   429 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   430 label *label224
   431 ubind @flare
-    * label *label225
   432 jump *label222 notEqual :findFreeUnit:first_unit @unit
-    * label *label226
   433 set *tmp47 null
   434 label *label227
   435 set :backgroundProcess:unit *tmp47
   436 jump *label228 notEqual *tmp47 null
   437 jump *label237 always
   438 label *label228
-    * label *label229
   439 label *label230
-    * label *label231
   440 # "Function: void serviceDrill(in drill, in unit)"
   441 ubind :backgroundProcess:unit
   442 sensor :serviceDrill:item @unit @firstItem
 
   455 ucontrol itemDrop @air 10
   456 label *label234
   457 label *label235
-    * label *label236
   458 label *label237
   459 set .units*7 :backgroundProcess:unit
   460 set :backgroundProcess:drill gallium
   461 set :backgroundProcess:unit .units*8
-    * label *label240
   462 jump *label241 notEqual :backgroundProcess:drill null
   463 jump *label21 always
   464 label *label241
-    * label *label242
   465 sensor *tmp43 :backgroundProcess:drill @titanium
   466 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   467 sensor *tmp44 :backgroundProcess:unit @controller
 
   472 set *tmp47 null
   473 jump *label250 always
   474 label *label243
-    * label *label244
   475 set :findFreeUnit:first_unit @unit
   476 label *label245
   477 sensor *tmp50 @unit @controlled
 
   479 ucontrol flag 0
   480 set *tmp47 @unit
   481 jump *label250 always
-    * jump *label247 always
   482 label *label246
   483 sensor *tmp53 :findFreeUnit:first_unit @dead
   484 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   485 label *label247
   486 ubind @flare
-    * label *label248
   487 jump *label245 notEqual :findFreeUnit:first_unit @unit
-    * label *label249
   488 set *tmp47 null
   489 label *label250
   490 set :backgroundProcess:unit *tmp47
   491 jump *label251 notEqual *tmp47 null
   492 jump *label260 always
   493 label *label251
-    * label *label252
   494 label *label253
-    * label *label254
   495 # "Function: void serviceDrill(in drill, in unit)"
   496 ubind :backgroundProcess:unit
   497 sensor :serviceDrill:item @unit @firstItem
 
   510 ucontrol itemDrop @air 10
   511 label *label257
   512 label *label258
-    * label *label259
   513 label *label260
   514 set .units*8 :backgroundProcess:unit
   515 set :backgroundProcess:drill nitrogen
   516 set :backgroundProcess:unit .units*9
-    * label *label263
   517 jump *label264 notEqual :backgroundProcess:drill null
   518 jump *label21 always
   519 label *label264
-    * label *label265
   520 sensor *tmp43 :backgroundProcess:drill @titanium
   521 op add :backgroundProcess:count :backgroundProcess:count *tmp43
   522 sensor *tmp44 :backgroundProcess:unit @controller
 
   527 set *tmp47 null
   528 jump *label273 always
   529 label *label266
-    * label *label267
   530 set :findFreeUnit:first_unit @unit
   531 label *label268
   532 sensor *tmp50 @unit @controlled
 
   534 ucontrol flag 0
   535 set *tmp47 @unit
   536 jump *label273 always
-    * jump *label270 always
   537 label *label269
   538 sensor *tmp53 :findFreeUnit:first_unit @dead
   539 select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFreeUnit:first_unit
   540 label *label270
   541 ubind @flare
-    * label *label271
   542 jump *label268 notEqual :findFreeUnit:first_unit @unit
-    * label *label272
   543 set *tmp47 null
   544 label *label273
   545 set :backgroundProcess:unit *tmp47
   546 jump *label274 notEqual *tmp47 null
   547 jump *label283 always
   548 label *label274
-    * label *label275
   549 label *label276
-    * label *label277
   550 # "Function: void serviceDrill(in drill, in unit)"
   551 ubind :backgroundProcess:unit
   552 sensor :serviceDrill:item @unit @firstItem
 
   565 ucontrol itemDrop @air 10
   566 label *label280
   567 label *label281
-    * label *label282
   568 label *label283
   569 set .units*9 :backgroundProcess:unit
   570 label *label21
   571 write :backgroundProcess:count processor2 ".titaniumDrillCount"
-    * label *label17
   572 jump *label16 always
-    * label *label18
-    * label *label10
-    * wait 1e12
-    * jump *label9 always
-    * end
   573 label *label0
   574 # "Function: export void addTitaniumDrill(in drill)"
   575 jump *label54 greaterThanEq .drills 9
 
   578 write :addTitaniumDrill:drill @this .titaniumDrills*elem
   579 op add .drills .drills 1
   580 label *label54
-    * label *label55
-    * label *label53
   581 set :addTitaniumDrill*finished true
   582 jump *label9 always
-    * end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-20 instructions):
 
    19 set :backgroundProcess:count 0
    20 set :backgroundProcess:drill water
    21 set :backgroundProcess:unit .units*0
-    * jump *label57 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+   22 jump *label21 equal :backgroundProcess:drill null
    23 label *label57
    24 sensor *tmp43 :backgroundProcess:drill @titanium
    25 set :backgroundProcess:count *tmp43
 
    46 set *tmp47 null
    47 label *label66
    48 set :backgroundProcess:unit *tmp47
-    * jump *label67 notEqual *tmp47 null
-    * jump *label76 always
+   49 jump *label76 equal *tmp47 null
    50 label *label67
    51 label *label69
    52 # "Function: void serviceDrill(in drill, in unit)"
 
    71 set .units*0 :backgroundProcess:unit
    72 set :backgroundProcess:drill slag
    73 set :backgroundProcess:unit .units*1
-    * jump *label80 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+   74 jump *label21 equal :backgroundProcess:drill null
    75 label *label80
    76 sensor *tmp43 :backgroundProcess:drill @titanium
    77 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
    98 set *tmp47 null
    99 label *label89
   100 set :backgroundProcess:unit *tmp47
-    * jump *label90 notEqual *tmp47 null
-    * jump *label99 always
+  101 jump *label99 equal *tmp47 null
   102 label *label90
   103 label *label92
   104 # "Function: void serviceDrill(in drill, in unit)"
 
   123 set .units*1 :backgroundProcess:unit
   124 set :backgroundProcess:drill oil
   125 set :backgroundProcess:unit .units*2
-    * jump *label103 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  126 jump *label21 equal :backgroundProcess:drill null
   127 label *label103
   128 sensor *tmp43 :backgroundProcess:drill @titanium
   129 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   150 set *tmp47 null
   151 label *label112
   152 set :backgroundProcess:unit *tmp47
-    * jump *label113 notEqual *tmp47 null
-    * jump *label122 always
+  153 jump *label122 equal *tmp47 null
   154 label *label113
   155 label *label115
   156 # "Function: void serviceDrill(in drill, in unit)"
 
   175 set .units*2 :backgroundProcess:unit
   176 set :backgroundProcess:drill cryofluid
   177 set :backgroundProcess:unit .units*3
-    * jump *label126 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  178 jump *label21 equal :backgroundProcess:drill null
   179 label *label126
   180 sensor *tmp43 :backgroundProcess:drill @titanium
   181 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   202 set *tmp47 null
   203 label *label135
   204 set :backgroundProcess:unit *tmp47
-    * jump *label136 notEqual *tmp47 null
-    * jump *label145 always
+  205 jump *label145 equal *tmp47 null
   206 label *label136
   207 label *label138
   208 # "Function: void serviceDrill(in drill, in unit)"
 
   227 set .units*3 :backgroundProcess:unit
   228 set :backgroundProcess:drill neoplasm
   229 set :backgroundProcess:unit .units*4
-    * jump *label149 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  230 jump *label21 equal :backgroundProcess:drill null
   231 label *label149
   232 sensor *tmp43 :backgroundProcess:drill @titanium
   233 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   254 set *tmp47 null
   255 label *label158
   256 set :backgroundProcess:unit *tmp47
-    * jump *label159 notEqual *tmp47 null
-    * jump *label168 always
+  257 jump *label168 equal *tmp47 null
   258 label *label159
   259 label *label161
   260 # "Function: void serviceDrill(in drill, in unit)"
 
   279 set .units*4 :backgroundProcess:unit
   280 set :backgroundProcess:drill hydrogen
   281 set :backgroundProcess:unit .units*5
-    * jump *label172 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  282 jump *label21 equal :backgroundProcess:drill null
   283 label *label172
   284 sensor *tmp43 :backgroundProcess:drill @titanium
   285 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   306 set *tmp47 null
   307 label *label181
   308 set :backgroundProcess:unit *tmp47
-    * jump *label182 notEqual *tmp47 null
-    * jump *label191 always
+  309 jump *label191 equal *tmp47 null
   310 label *label182
   311 label *label184
   312 # "Function: void serviceDrill(in drill, in unit)"
 
   331 set .units*5 :backgroundProcess:unit
   332 set :backgroundProcess:drill ozone
   333 set :backgroundProcess:unit .units*6
-    * jump *label195 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  334 jump *label21 equal :backgroundProcess:drill null
   335 label *label195
   336 sensor *tmp43 :backgroundProcess:drill @titanium
   337 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   358 set *tmp47 null
   359 label *label204
   360 set :backgroundProcess:unit *tmp47
-    * jump *label205 notEqual *tmp47 null
-    * jump *label214 always
+  361 jump *label214 equal *tmp47 null
   362 label *label205
   363 label *label207
   364 # "Function: void serviceDrill(in drill, in unit)"
 
   383 set .units*6 :backgroundProcess:unit
   384 set :backgroundProcess:drill cyanogen
   385 set :backgroundProcess:unit .units*7
-    * jump *label218 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  386 jump *label21 equal :backgroundProcess:drill null
   387 label *label218
   388 sensor *tmp43 :backgroundProcess:drill @titanium
   389 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   410 set *tmp47 null
   411 label *label227
   412 set :backgroundProcess:unit *tmp47
-    * jump *label228 notEqual *tmp47 null
-    * jump *label237 always
+  413 jump *label237 equal *tmp47 null
   414 label *label228
   415 label *label230
   416 # "Function: void serviceDrill(in drill, in unit)"
 
   435 set .units*7 :backgroundProcess:unit
   436 set :backgroundProcess:drill gallium
   437 set :backgroundProcess:unit .units*8
-    * jump *label241 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  438 jump *label21 equal :backgroundProcess:drill null
   439 label *label241
   440 sensor *tmp43 :backgroundProcess:drill @titanium
   441 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   462 set *tmp47 null
   463 label *label250
   464 set :backgroundProcess:unit *tmp47
-    * jump *label251 notEqual *tmp47 null
-    * jump *label260 always
+  465 jump *label260 equal *tmp47 null
   466 label *label251
   467 label *label253
   468 # "Function: void serviceDrill(in drill, in unit)"
 
   487 set .units*8 :backgroundProcess:unit
   488 set :backgroundProcess:drill nitrogen
   489 set :backgroundProcess:unit .units*9
-    * jump *label264 notEqual :backgroundProcess:drill null
-    * jump *label21 always
+  490 jump *label21 equal :backgroundProcess:drill null
   491 label *label264
   492 sensor *tmp43 :backgroundProcess:drill @titanium
   493 op add :backgroundProcess:count :backgroundProcess:count *tmp43
 
   514 set *tmp47 null
   515 label *label273
   516 set :backgroundProcess:unit *tmp47
-    * jump *label274 notEqual *tmp47 null
-    * jump *label283 always
+  517 jump *label283 equal *tmp47 null
   518 label *label274
   519 label *label276
   520 # "Function: void serviceDrill(in drill, in unit)"

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
    10 jump *label11 notEqual .core null
    11 label *label13
    12 ubind @flare
-    * ulocate building core false @copper .coreX .coreY *tmp36 .core
+   13 ulocate building core false @copper .coreX .coreY 0 .core
    14 jump *label13 equal .core null
    15 sensor .coreX .core @x
    16 sensor .coreY .core @y

Final code before resolving virtual instructions:

    0:  jump *label7 always 0 0                                      FlareController.mnd: #set target = 8;
    1:  jump *label0 always 0 0                                      ...
        label *label7                                                ...
        label *label8                                                FlareController.mnd: require "Display.mnd" remote display;
    2:  read *tmp32 processor2 "*signature"                          ...
    3:  jump *label8 notEqual *tmp32 "0:v1"                          ...
    4:  set .drills 0                                                FlareController.mnd: volatile var drills = 0;
    5:  set *signature "880295ee1d8ade1d:v1"                         FlareController.mnd: #set target = 8;
        label *label9                                                ...
        # "Function: void backgroundProcess()"                       FlareController.mnd: void backgroundProcess()
    6:  jump *label11 notEqual .core null                            FlareController.mnd: if core == null then
        label *label13                                               FlareController.mnd: do
    7:  ubind @flare                                                 FlareController.mnd: ubind(@flare);
    8:  ulocate building core false @copper .coreX .coreY 0 .core    FlareController.mnd: core = ulocate(:building, :core, false, out coreX, out coreY);
    9:  jump *label13 equal .core null                               FlareController.mnd: do
   10:  sensor .coreX .core @x                                       FlareController.mnd: coreX = core.@x;
   11:  sensor .coreY .core @y                                       FlareController.mnd: coreY = core.@y;
        label *label11                                               FlareController.mnd: if core == null then
        label *label16                                               FlareController.mnd: while true do
   12:  set :backgroundProcess:count 0                               FlareController.mnd: var count = 0;
   13:  set :backgroundProcess:drill water                           FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
   14:  set :backgroundProcess:unit .units*0                         ...
   15:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
   16:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
   17:  set :backgroundProcess:count *tmp43                          ...
   18:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
   19:  jump *label69 equal *tmp44 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
   20:  ubind @flare                                                 *units: ubind(unit_type);
   21:  jump *label59 notEqual @unit null                            *units: if @unit == null then return null; end;
   22:  set *tmp47 null                                              ...
   23:  jump *label66 always 0 0                                     ...
        label *label59                                               ...
   24:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label61                                               *units: do
   25:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
   26:  jump *label62 notEqual *tmp50 0                              ...
   27:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   28:  set *tmp47 @unit                                             *units: return @unit;
   29:  jump *label66 always 0 0                                     ...
        label *label62                                               *units: if @unit.@controlled == 0 then
   30:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   31:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
   32:  ubind @flare                                                 *units: ubind(unit_type);
   33:  jump *label61 notEqual :findFreeUnit:first_unit @unit        *units: do
   34:  set *tmp47 null                                              *units: return null;
        label *label66                                               FlareController.mnd: unit = findFreeUnit(@flare, 0);
   35:  set :backgroundProcess:unit *tmp47                           ...
   36:  jump *label76 equal *tmp47 null                              FlareController.mnd: if unit == null then continue; end;
        label *label69                                               FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
   37:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
   38:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
   39:  jump *label71 notEqual :serviceDrill:item @titanium          FlareController.mnd: if item == @titanium then
   40:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
   41:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
   42:  jump *label74 always 0 0                                     FlareController.mnd: if item == @titanium then
        label *label71                                               ...
   43:  jump *label72 notEqual :serviceDrill:item null               FlareController.mnd: elsif item == null then
   44:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
   45:  sensor *tmp66 :backgroundProcess:drill @y                    ...
   46:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
   47:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
   48:  jump *label73 always 0 0                                     FlareController.mnd: elsif item == null then
        label *label72                                               ...
   49:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label73                                               FlareController.mnd: elsif item == null then
        label *label74                                               FlareController.mnd: if item == @titanium then
        label *label76                                               FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
   50:  set .units*0 :backgroundProcess:unit                         ...
   51:  set :backgroundProcess:drill slag                            ...
   52:  set :backgroundProcess:unit .units*1                         ...
   53:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
   54:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
   55:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
   56:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
   57:  jump *label92 equal *tmp44 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
   58:  ubind @flare                                                 *units: ubind(unit_type);
   59:  jump *label82 notEqual @unit null                            *units: if @unit == null then return null; end;
   60:  set *tmp47 null                                              ...
   61:  jump *label89 always 0 0                                     ...
        label *label82                                               ...
   62:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label84                                               *units: do
   63:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
   64:  jump *label85 notEqual *tmp50 0                              ...
   65:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   66:  set *tmp47 @unit                                             *units: return @unit;
   67:  jump *label89 always 0 0                                     ...
        label *label85                                               *units: if @unit.@controlled == 0 then
   68:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   69:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
   70:  ubind @flare                                                 *units: ubind(unit_type);
   71:  jump *label84 notEqual :findFreeUnit:first_unit @unit        *units: do
   72:  set *tmp47 null                                              *units: return null;
        label *label89                                               FlareController.mnd: unit = findFreeUnit(@flare, 0);
   73:  set :backgroundProcess:unit *tmp47                           ...
   74:  jump *label99 equal *tmp47 null                              FlareController.mnd: if unit == null then continue; end;
        label *label92                                               FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
   75:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
   76:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
   77:  jump *label94 notEqual :serviceDrill:item @titanium          FlareController.mnd: if item == @titanium then
   78:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
   79:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
   80:  jump *label97 always 0 0                                     FlareController.mnd: if item == @titanium then
        label *label94                                               ...
   81:  jump *label95 notEqual :serviceDrill:item null               FlareController.mnd: elsif item == null then
   82:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
   83:  sensor *tmp66 :backgroundProcess:drill @y                    ...
   84:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
   85:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
   86:  jump *label96 always 0 0                                     FlareController.mnd: elsif item == null then
        label *label95                                               ...
   87:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label96                                               FlareController.mnd: elsif item == null then
        label *label97                                               FlareController.mnd: if item == @titanium then
        label *label99                                               FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
   88:  set .units*1 :backgroundProcess:unit                         ...
   89:  set :backgroundProcess:drill oil                             ...
   90:  set :backgroundProcess:unit .units*2                         ...
   91:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
   92:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
   93:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
   94:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
   95:  jump *label115 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
   96:  ubind @flare                                                 *units: ubind(unit_type);
   97:  jump *label105 notEqual @unit null                           *units: if @unit == null then return null; end;
   98:  set *tmp47 null                                              ...
   99:  jump *label112 always 0 0                                    ...
        label *label105                                              ...
  100:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label107                                              *units: do
  101:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  102:  jump *label108 notEqual *tmp50 0                             ...
  103:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  104:  set *tmp47 @unit                                             *units: return @unit;
  105:  jump *label112 always 0 0                                    ...
        label *label108                                              *units: if @unit.@controlled == 0 then
  106:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  107:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  108:  ubind @flare                                                 *units: ubind(unit_type);
  109:  jump *label107 notEqual :findFreeUnit:first_unit @unit       *units: do
  110:  set *tmp47 null                                              *units: return null;
        label *label112                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  111:  set :backgroundProcess:unit *tmp47                           ...
  112:  jump *label122 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label115                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  113:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  114:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  115:  jump *label117 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  116:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  117:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  118:  jump *label120 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label117                                              ...
  119:  jump *label118 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  120:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  121:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  122:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  123:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  124:  jump *label119 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label118                                              ...
  125:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label119                                              FlareController.mnd: elsif item == null then
        label *label120                                              FlareController.mnd: if item == @titanium then
        label *label122                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  126:  set .units*2 :backgroundProcess:unit                         ...
  127:  set :backgroundProcess:drill cryofluid                       ...
  128:  set :backgroundProcess:unit .units*3                         ...
  129:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  130:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  131:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  132:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  133:  jump *label138 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  134:  ubind @flare                                                 *units: ubind(unit_type);
  135:  jump *label128 notEqual @unit null                           *units: if @unit == null then return null; end;
  136:  set *tmp47 null                                              ...
  137:  jump *label135 always 0 0                                    ...
        label *label128                                              ...
  138:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label130                                              *units: do
  139:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  140:  jump *label131 notEqual *tmp50 0                             ...
  141:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  142:  set *tmp47 @unit                                             *units: return @unit;
  143:  jump *label135 always 0 0                                    ...
        label *label131                                              *units: if @unit.@controlled == 0 then
  144:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  145:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  146:  ubind @flare                                                 *units: ubind(unit_type);
  147:  jump *label130 notEqual :findFreeUnit:first_unit @unit       *units: do
  148:  set *tmp47 null                                              *units: return null;
        label *label135                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  149:  set :backgroundProcess:unit *tmp47                           ...
  150:  jump *label145 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label138                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  151:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  152:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  153:  jump *label140 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  154:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  155:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  156:  jump *label143 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label140                                              ...
  157:  jump *label141 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  158:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  159:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  160:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  161:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  162:  jump *label142 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label141                                              ...
  163:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label142                                              FlareController.mnd: elsif item == null then
        label *label143                                              FlareController.mnd: if item == @titanium then
        label *label145                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  164:  set .units*3 :backgroundProcess:unit                         ...
  165:  set :backgroundProcess:drill neoplasm                        ...
  166:  set :backgroundProcess:unit .units*4                         ...
  167:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  168:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  169:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  170:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  171:  jump *label161 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  172:  ubind @flare                                                 *units: ubind(unit_type);
  173:  jump *label151 notEqual @unit null                           *units: if @unit == null then return null; end;
  174:  set *tmp47 null                                              ...
  175:  jump *label158 always 0 0                                    ...
        label *label151                                              ...
  176:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label153                                              *units: do
  177:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  178:  jump *label154 notEqual *tmp50 0                             ...
  179:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  180:  set *tmp47 @unit                                             *units: return @unit;
  181:  jump *label158 always 0 0                                    ...
        label *label154                                              *units: if @unit.@controlled == 0 then
  182:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  183:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  184:  ubind @flare                                                 *units: ubind(unit_type);
  185:  jump *label153 notEqual :findFreeUnit:first_unit @unit       *units: do
  186:  set *tmp47 null                                              *units: return null;
        label *label158                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  187:  set :backgroundProcess:unit *tmp47                           ...
  188:  jump *label168 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label161                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  189:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  190:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  191:  jump *label163 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  192:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  193:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  194:  jump *label166 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label163                                              ...
  195:  jump *label164 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  196:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  197:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  198:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  199:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  200:  jump *label165 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label164                                              ...
  201:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label165                                              FlareController.mnd: elsif item == null then
        label *label166                                              FlareController.mnd: if item == @titanium then
        label *label168                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  202:  set .units*4 :backgroundProcess:unit                         ...
  203:  set :backgroundProcess:drill hydrogen                        ...
  204:  set :backgroundProcess:unit .units*5                         ...
  205:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  206:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  207:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  208:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  209:  jump *label184 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  210:  ubind @flare                                                 *units: ubind(unit_type);
  211:  jump *label174 notEqual @unit null                           *units: if @unit == null then return null; end;
  212:  set *tmp47 null                                              ...
  213:  jump *label181 always 0 0                                    ...
        label *label174                                              ...
  214:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label176                                              *units: do
  215:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  216:  jump *label177 notEqual *tmp50 0                             ...
  217:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  218:  set *tmp47 @unit                                             *units: return @unit;
  219:  jump *label181 always 0 0                                    ...
        label *label177                                              *units: if @unit.@controlled == 0 then
  220:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  221:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  222:  ubind @flare                                                 *units: ubind(unit_type);
  223:  jump *label176 notEqual :findFreeUnit:first_unit @unit       *units: do
  224:  set *tmp47 null                                              *units: return null;
        label *label181                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  225:  set :backgroundProcess:unit *tmp47                           ...
  226:  jump *label191 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label184                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  227:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  228:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  229:  jump *label186 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  230:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  231:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  232:  jump *label189 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label186                                              ...
  233:  jump *label187 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  234:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  235:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  236:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  237:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  238:  jump *label188 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label187                                              ...
  239:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label188                                              FlareController.mnd: elsif item == null then
        label *label189                                              FlareController.mnd: if item == @titanium then
        label *label191                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  240:  set .units*5 :backgroundProcess:unit                         ...
  241:  set :backgroundProcess:drill ozone                           ...
  242:  set :backgroundProcess:unit .units*6                         ...
  243:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  244:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  245:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  246:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  247:  jump *label207 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  248:  ubind @flare                                                 *units: ubind(unit_type);
  249:  jump *label197 notEqual @unit null                           *units: if @unit == null then return null; end;
  250:  set *tmp47 null                                              ...
  251:  jump *label204 always 0 0                                    ...
        label *label197                                              ...
  252:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label199                                              *units: do
  253:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  254:  jump *label200 notEqual *tmp50 0                             ...
  255:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  256:  set *tmp47 @unit                                             *units: return @unit;
  257:  jump *label204 always 0 0                                    ...
        label *label200                                              *units: if @unit.@controlled == 0 then
  258:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  259:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  260:  ubind @flare                                                 *units: ubind(unit_type);
  261:  jump *label199 notEqual :findFreeUnit:first_unit @unit       *units: do
  262:  set *tmp47 null                                              *units: return null;
        label *label204                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  263:  set :backgroundProcess:unit *tmp47                           ...
  264:  jump *label214 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label207                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  265:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  266:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  267:  jump *label209 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  268:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  269:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  270:  jump *label212 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label209                                              ...
  271:  jump *label210 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  272:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  273:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  274:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  275:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  276:  jump *label211 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label210                                              ...
  277:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label211                                              FlareController.mnd: elsif item == null then
        label *label212                                              FlareController.mnd: if item == @titanium then
        label *label214                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  278:  set .units*6 :backgroundProcess:unit                         ...
  279:  set :backgroundProcess:drill cyanogen                        ...
  280:  set :backgroundProcess:unit .units*7                         ...
  281:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  282:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  283:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  284:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  285:  jump *label230 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  286:  ubind @flare                                                 *units: ubind(unit_type);
  287:  jump *label220 notEqual @unit null                           *units: if @unit == null then return null; end;
  288:  set *tmp47 null                                              ...
  289:  jump *label227 always 0 0                                    ...
        label *label220                                              ...
  290:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label222                                              *units: do
  291:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  292:  jump *label223 notEqual *tmp50 0                             ...
  293:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  294:  set *tmp47 @unit                                             *units: return @unit;
  295:  jump *label227 always 0 0                                    ...
        label *label223                                              *units: if @unit.@controlled == 0 then
  296:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  297:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  298:  ubind @flare                                                 *units: ubind(unit_type);
  299:  jump *label222 notEqual :findFreeUnit:first_unit @unit       *units: do
  300:  set *tmp47 null                                              *units: return null;
        label *label227                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  301:  set :backgroundProcess:unit *tmp47                           ...
  302:  jump *label237 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label230                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  303:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  304:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  305:  jump *label232 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  306:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  307:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  308:  jump *label235 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label232                                              ...
  309:  jump *label233 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  310:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  311:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  312:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  313:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  314:  jump *label234 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label233                                              ...
  315:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label234                                              FlareController.mnd: elsif item == null then
        label *label235                                              FlareController.mnd: if item == @titanium then
        label *label237                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  316:  set .units*7 :backgroundProcess:unit                         ...
  317:  set :backgroundProcess:drill gallium                         ...
  318:  set :backgroundProcess:unit .units*8                         ...
  319:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  320:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  321:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  322:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  323:  jump *label253 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  324:  ubind @flare                                                 *units: ubind(unit_type);
  325:  jump *label243 notEqual @unit null                           *units: if @unit == null then return null; end;
  326:  set *tmp47 null                                              ...
  327:  jump *label250 always 0 0                                    ...
        label *label243                                              ...
  328:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label245                                              *units: do
  329:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  330:  jump *label246 notEqual *tmp50 0                             ...
  331:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  332:  set *tmp47 @unit                                             *units: return @unit;
  333:  jump *label250 always 0 0                                    ...
        label *label246                                              *units: if @unit.@controlled == 0 then
  334:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  335:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  336:  ubind @flare                                                 *units: ubind(unit_type);
  337:  jump *label245 notEqual :findFreeUnit:first_unit @unit       *units: do
  338:  set *tmp47 null                                              *units: return null;
        label *label250                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  339:  set :backgroundProcess:unit *tmp47                           ...
  340:  jump *label260 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label253                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  341:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  342:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  343:  jump *label255 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  344:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  345:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  346:  jump *label258 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label255                                              ...
  347:  jump *label256 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  348:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  349:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  350:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  351:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  352:  jump *label257 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label256                                              ...
  353:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label257                                              FlareController.mnd: elsif item == null then
        label *label258                                              FlareController.mnd: if item == @titanium then
        label *label260                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  354:  set .units*8 :backgroundProcess:unit                         ...
  355:  set :backgroundProcess:drill nitrogen                        ...
  356:  set :backgroundProcess:unit .units*9                         ...
  357:  jump *label21 equal :backgroundProcess:drill null            FlareController.mnd: if drill == null then break; end;
  358:  sensor *tmp43 :backgroundProcess:drill @titanium             FlareController.mnd: count += drill.@titanium;
  359:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  360:  sensor *tmp44 :backgroundProcess:unit @controller            FlareController.mnd: if unit.@controller != @this then
  361:  jump *label276 equal *tmp44 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) FlareController.mnd: unit = findFreeUnit(@flare, 0);
  362:  ubind @flare                                                 *units: ubind(unit_type);
  363:  jump *label266 notEqual @unit null                           *units: if @unit == null then return null; end;
  364:  set *tmp47 null                                              ...
  365:  jump *label273 always 0 0                                    ...
        label *label266                                              ...
  366:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label268                                              *units: do
  367:  sensor *tmp50 @unit @controlled                              *units: if @unit.@controlled == 0 then
  368:  jump *label269 notEqual *tmp50 0                             ...
  369:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  370:  set *tmp47 @unit                                             *units: return @unit;
  371:  jump *label273 always 0 0                                    ...
        label *label269                                              *units: if @unit.@controlled == 0 then
  372:  sensor *tmp53 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  373:  select :findFreeUnit:first_unit equal *tmp53 1 @unit :findFr ...
  374:  ubind @flare                                                 *units: ubind(unit_type);
  375:  jump *label268 notEqual :findFreeUnit:first_unit @unit       *units: do
  376:  set *tmp47 null                                              *units: return null;
        label *label273                                              FlareController.mnd: unit = findFreeUnit(@flare, 0);
  377:  set :backgroundProcess:unit *tmp47                           ...
  378:  jump *label283 equal *tmp47 null                             FlareController.mnd: if unit == null then continue; end;
        label *label276                                              FlareController.mnd: if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           FlareController.mnd: serviceDrill(drill, unit);
  379:  ubind :backgroundProcess:unit                                FlareController.mnd: ubind(unit);
  380:  sensor :serviceDrill:item @unit @firstItem                   FlareController.mnd: var item = @unit.@firstItem;
  381:  jump *label278 notEqual :serviceDrill:item @titanium         FlareController.mnd: if item == @titanium then
  382:  ucontrol approach .coreX .coreY 4 0 0                        FlareController.mnd: approach(coreX, coreY, RADIUS);
  383:  ucontrol itemDrop .core 10 0 0 0                             FlareController.mnd: itemDrop(core, CAPACITY);
  384:  jump *label281 always 0 0                                    FlareController.mnd: if item == @titanium then
        label *label278                                              ...
  385:  jump *label279 notEqual :serviceDrill:item null              FlareController.mnd: elsif item == null then
  386:  sensor *tmp65 :backgroundProcess:drill @x                    FlareController.mnd: approach(drill.@x, drill.@y, RADIUS);
  387:  sensor *tmp66 :backgroundProcess:drill @y                    ...
  388:  ucontrol approach *tmp65 *tmp66 4 0 0                        ...
  389:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  FlareController.mnd: itemTake(drill, @titanium, CAPACITY);
  390:  jump *label280 always 0 0                                    FlareController.mnd: elsif item == null then
        label *label279                                              ...
  391:  ucontrol itemDrop @air 10 0 0 0                              FlareController.mnd: itemDrop(@air, CAPACITY);
        label *label280                                              FlareController.mnd: elsif item == null then
        label *label281                                              FlareController.mnd: if item == @titanium then
        label *label283                                              FlareController.mnd: for var drill in titaniumDrills; var out unit in units do
  392:  set .units*9 :backgroundProcess:unit                         ...
        label *label21                                               ...
  393:  write :backgroundProcess:count processor2 ".titaniumDrillCou FlareController.mnd: display.titaniumDrillCount = count;
  394:  jump *label16 always 0 0                                     FlareController.mnd: while true do
        label *label0                                                FlareController.mnd: export void addTitaniumDrill(drill)
        # "Function: export void addTitaniumDrill(in drill)"         ...
  395:  jump *label54 greaterThanEq .drills 9                        FlareController.mnd: if drills < length(titaniumDrills) - 1 then
  396:  lookup liquid *tmp72 .drills                                 FlareController.mnd: titaniumDrills[drills] = drill;
  397:  sensor .titaniumDrills*elem *tmp72 @name                     ...
  398:  write :addTitaniumDrill:drill @this .titaniumDrills*elem     ...
  399:  op add .drills .drills 1                                     FlareController.mnd: if drills < length(titaniumDrills) - 1 then
        label *label54                                               ...
  400:  set :addTitaniumDrill*finished true                          FlareController.mnd: export void addTitaniumDrill(drill)
  401:  jump *label9 always 0 0                                      ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   150    10x     15,0  def findFreeUnit(in unit_type, in initial_flag)
   130    10x     13,0  void serviceDrill(in drill, in unit)
   109     1x    109,0  void backgroundProcess()
     8     1x      8,0  export void addTitaniumDrill(in drill)
     6     1x      6,0  <no function>
Runtime error at instruction #2: 'read *tmp32 processor2 "*signature"':
Variable is not an object: processor2 = null
Use the '#set err-not-an-object = false;' directive to ignore this error.

Performance: parsed in 505 ms, compiled in 297 ms, optimized in 478 ms, run in 118 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (3 steps):
The program didn't generate any output.
