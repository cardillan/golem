#set target = 8;
#set syntax = strict;
#set sort-variables;
#set remarks = none;

#set loop-unrolling = none;

module OreLocator;

require math;

const RADIUS =  6;

linked bank1, message1, switch1;

// For each attenuationRate multiple of the distance between the unit position on the spiral and the core, the
// requested amount of ore tiles under the drill gets decreased by one (i.e. the farther the unit has to go
// to find the spot, the worse spot gets accepted)
remote var attenuationRate = 50;

noinit remote var mapProgress, mapTotal, mapAction, mapSpots;
remote var locations = 0;

// Drill infrastructure positions
noinit remote var
    drillX, drillY,
    water1X, water1Y,
    containerX, containerY,
    water2X, water2Y,
    generatorX, generatorY,
    nodeX, nodeY,
    panelX, panelY,
    batteryX, batteryY;

var coreX, coreY;
var count = -1, locationsStart, start;

// Moves the unit to a given distance from the location
inline void moveTo(x, y, radius)
    while !within(x, y, radius) do
        approach(x, y, radius - 0.5);
    end;
end;

// Moves the unit to a mining distance from the location
inline void moveTo(x, y)
    moveTo(x, y, RADIUS);
end;

const ORE = 1 / 255;
const WALL = 25 / 255;

// Values >= WALL represent walls, regular values should all be less or equal to 16 / 255.
// For 2x2 drills, the highest possible value is 4*25.
// For 3x3 drills, the highest possible value is 9*25 (225).
// For 4x4 drills, the highest possible value would be 16*25, which wouldn't fit in 8 bits.
// For those, the summed column values need to be clamped, resulting in a highest possible value 4*25.
const LIMIT = 20 / 255;

inline def spotValue(x, y, ore)
    var result;
    // Written in pure mlog for speed.
    // Will be rewritten to Mindcode when native support for select gets implemented.
    mlog(in x, in y, in ore, in ORE, in WALL, out result) {
        ucontrol getBlock x y type building floor
        select value equal floor ore ORE 0
        sensor solid type @solid
        select result notEqual solid false WALL value
    }
    result;
end;

def computeRowValues(x, y, ore, size)
    var x1 = spotValue(x - 2, y, ore);
    var x2 = spotValue(x - 1, y, ore);
    var x3 = spotValue(x + 0, y, ore);
    var x4 = spotValue(x + 1, y, ore);
    var x5 = spotValue(x + 2, y, ore);

//    remark($"Spot values for row $y: $, $, $, $, $\n", x1 * 255, x2 * 255, x3 * 255, x4 * 255, x5 * 255);

    if size == 2 then
        // 2x2 drill
        return packcolor(
            x1 + x2,        // drill at x - 1.5
            x2 + x3,        // drill at x - 0.5
            x3 + x4,        // drill at x + 0.5
            x4 + x5         // drill at x + 1.5
        );
    elsif size == 3 then
        // 3x3 drill
        // Using parentheses to help the optimizer
        return packcolor(
            x1 + (x2 + x3),   // drill at x - 1
            (x2 + x3) + x4,   // drill at x
            x3 + x4 + x5,   // drill at x + 1
            0);
    else
        // 4x4 drill
        // Using parentheses to help the optimizer
        var x0 = spotValue(x - 3, y, ore);
        var x6 = spotValue(x + 3, y, ore);
        return packcolor(
            min(WALL, x0 + (x1 + x2 + x3)),   // drill at x - 1.5
            min(WALL, (x1 + x2 + x3) + x4),   // drill at x - 0.5
            min(WALL, x2 + (x3 + x4 + x5)),   // drill at x + 0.5
            min(WALL, (x3 + x4 + x5) + x6)    // drill at x + 1.5
        );
    end;
end;

inline void updatePosition(dx, dy, value, ref bestX, ref bestY, ref best)
//    remark($"${value * 255} at $dx, $dy ($bestX, $bestY)");
    if value < LIMIT then
        if value > best then
            bestX = dx;
            bestY = dy;
            best = value;
//            remark(" ***");
        end;
    end;

//    remark("\n");
end;

// Finds the best possible column position over a sum of row values
inline void updateRowPositions2x2(dy, rowSum, ref bestX, ref bestY, ref best)
    var col1, col2, col3, col4;
    unpackcolor(out col1, out col2, out col3, out col4, rowSum);
    updatePosition(-1.5, dy, col1, ref bestX, ref bestY, ref best);
    updatePosition(-0.5, dy, col2, ref bestX, ref bestY, ref best);
    updatePosition(+0.5, dy, col3, ref bestX, ref bestY, ref best);
    updatePosition(+1.5, dy, col4, ref bestX, ref bestY, ref best);
//    remark($"updateRowPositions2x2: $bestX, $bestY: ${best * 255}\n");
end;

// Finds the best possible column position over a sum of row values
inline void updateRowPositions3x3(dy, rowSum, ref bestX, ref bestY, ref best)
    var col1, col2, col3;
    unpackcolor(out col1, out col2, out col3, , rowSum);
    updatePosition(-1, dy, col1, ref bestX, ref bestY, ref best);
    updatePosition( 0, dy, col2, ref bestX, ref bestY, ref best);
    updatePosition(+1, dy, col3, ref bestX, ref bestY, ref best);
//    remark($"updateRowPositions3x3: $bestX, $bestY: ${best * 255}\n");
end;

// Finds the best possible column position over a sum of row values
inline void updateRowPositions4x4(dy, rowSum, ref bestX, ref bestY, ref best)
    var col1, col2, col3, col4;
    unpackcolor(out col1, out col2, out col3, out col4, rowSum);
    updatePosition(-1.5, dy, col1, ref bestX, ref bestY, ref best);
    updatePosition(-0.5, dy, col2, ref bestX, ref bestY, ref best);
    updatePosition(+0.5, dy, col3, ref bestX, ref bestY, ref best);
    updatePosition(+1.5, dy, col4, ref bestX, ref bestY, ref best);
//    remark($"updateRowPositions4x4: $bestX, $bestY: ${best * 255}\n");
end;

inline def findBestPosition(x, y, ore, size, ref bestX, ref bestY)
    var y1 = computeRowValues(x, y - 2, ore, size);
    var y2 = computeRowValues(x, y - 1, ore, size);
    var y3 = computeRowValues(x, y + 0, ore, size);
    var y4 = computeRowValues(x, y + 1, ore, size);
    var y5 = computeRowValues(x, y + 2, ore, size);

    var best = 0;
    bestX = 0;
    bestY = 0;

    if size == 2 then
        // 2x2 drill
        var row1 = y1 + y2;         // drill at y - 1.5
        var row2 = y2 + y3;         // drill at y - 0.5
        var row3 = y3 + y4;         // drill at y + 0.5
        var row4 = y4 + y5;         // drill at y + 1.5

        updateRowPositions2x2(-1.5, row1, ref bestX, ref bestY, ref best);
        updateRowPositions2x2(-0.5, row2, ref bestX, ref bestY, ref best);
        updateRowPositions2x2( 0.5, row3, ref bestX, ref bestY, ref best);
        updateRowPositions2x2( 1.5, row4, ref bestX, ref bestY, ref best);
//        remark($"findBestPosition: $bestX, $bestY: ${best * 255}\n");
    elsif size == 3 then
        // 3x3 drill
        var row1 = y1 + (y2 + y3);  // drill at y - 1
        var row2 = (y2 + y3) + y4;  // drill at y
        var row3 = y3 + y4 + y5;    // drill at y + 1

        updateRowPositions3x3(-1, row1, ref bestX, ref bestY, ref best);
        updateRowPositions3x3( 0, row2, ref bestX, ref bestY, ref best);
        updateRowPositions3x3( 1, row3, ref bestX, ref bestY, ref best);
//        remark($"findBestPosition: $bestX, $bestY: ${best * 255}\n");
    else
        // 4x4 drill
        var y0 = computeRowValues(x, y - 3, ore, size);
        var y6 = computeRowValues(x, y + 3, ore, size);
        var row1 = y0 + (y1 + y2 + y3);     // drill at y - 1.5
        var row2 = (y1 + y2 + y3) + y4;     // drill at y - 0.5
        var row3 = y2 + (y3 + y4 + y5);     // drill at y + 0.5
        var row4 = (y3 + y4 + y5) + y6;     // drill at y + 1.5

        updateRowPositions4x4(-1.5, row1, ref bestX, ref bestY, ref best);
        updateRowPositions4x4(-0.5, row2, ref bestX, ref bestY, ref best);
        updateRowPositions4x4(+0.5, row3, ref bestX, ref bestY, ref best);
        updateRowPositions4x4(+1.5, row4, ref bestX, ref bestY, ref best);
//        remark($"findBestPosition: $bestX, $bestY: ${best * 255}\n");
    end;

//    debugPause();

    return best * 255;
end;

inline def limit(value, low, high)
    min(max(value, low), high);
end;

// The width of the spiral per rotation
// Also the distance between two stops on the spiral
const SPIRAL_WIDTH = 24 / (2 * @pi);

inline def locateOreAway(ore, in out x, in out y, in distanceLimit)
    var distance = SPIRAL_WIDTH * angle;
    var lastX = -1, lastY = -1;
    angle = max(angle, @pi);
    mapProgress = angle * angle;

    while distance < distanceLimit do
        var a = angle / @degToRad;
        var lx = limit(coreX + sin(a) * distance, 5, @mapw - 5);
        var ly = limit(coreY + cos(a) * distance, 5, @maph - 5);
        moveTo(lx, ly, 5);

        // Compute the next position on the spiral
        angle += SPIRAL_WIDTH / distance;
        mapProgress = angle * angle;
        distance = SPIRAL_WIDTH * angle;

        if !ulocate(:ore, ore, out x, out y) then
            return false;
        end;

        var coreDist = max(abs(x - coreX), abs(y - coreY));
        var unitDist = len(x - lx, y - ly);

        // We can get the same spot repeatedly
//        remark($"x: $x, y: $y, lastX: $lastX, lastY: $lastY\n");
//        debugPause();
        if lastX == x then if lastY == y then continue; end; end;

//        remark($"Distance: ${round(distance)}\n");
//        remark($"Ore: $x, $y; core: $coreX, $coreY\n");
//        remark($"Core dist: $coreDist\n");
//        remark($"Unit dist: ${round(unitDist)}\n");
//        debugPrintSpot("");
//        debugPause();

        if coreDist >= 7 then
            if unitDist < distance then
                lastX = x;
                lastY = y;

                if !visited(x, y) then
                    // The spot we've found is probably in the direction of our travel.
                    // Advance two more steps on the spiral
                    angle += 2 * SPIRAL_WIDTH / distance;
                    mapProgress = angle * angle;
                    printflush(message1);
                    return true;
                end;

//                remark("Already visited.");
//                debugPause();
            end;
        end;

    end;

    // Search exhausted
    return false;
end;

var angle, cornerDistance, x0, y0, x1, y1;

void trace(ore, x, y)
    do
        move(x, y);

        mapProgress = cornerDistance - len(x - @unit.@x, y - @unit.@y);

        var oreX, oreY;
        if ulocate(:ore, ore, out oreX, out oreY) then
            x0 = min(x0, oreX);
            y0 = min(y0, oreY);
            x1 = max(x1, oreX);
            y1 = max(y1, oreY);
        end;
    while !within(x, y, 5);
end;

def findMaxOreDistance(ore)
    mapAction = "Scanning map...";
    mapProgress = 0;
    mapTotal = 2 * (@mapw + @maph);

    cornerDistance = 0;
    x0 = @mapw;
    y0 = @maph;
    x1 = 0;
    y1 = 0;

    moveTo(0, 0);
    cornerDistance += @mapw; trace(ore, @mapw, 0);
    cornerDistance += @maph; trace(ore, @mapw, @maph);
    cornerDistance += @mapw; trace(ore, 0, @maph);
    cornerDistance += @maph; trace(ore, 0, 0);

    var d0 = len(coreX - x0, coreY - y0);
    var d1 = len(coreX - x0, coreY - y1);
    var d2 = len(coreX - x1, coreY - y0);
    var d3 = len(coreX - x1, coreY - y1);

    return max(d0, d1, d2, d3);
end;

// Tries to find the best location for given ore, using the given unit.
// x, y: core coordinates
// unit: unit to use (must not be stolen)
// item: item type to search (e.g., @titanium)
// ore: ore type to search (e.g., @ore-titanium)
// large: true fox 3x3 drill, false for 2x2 drill
// limit: if the number of tiles under the drill is equal to this, don't search for better
//        Setting limit to 10 means we'll try it all over the map
// Returns true if something was found
noinline def findDrillLocationLocal(x, y, unit, item, ore, size, limit, out dx, out dy, out capacity)
    ubind(unit);

    locationsStart = locations;
    coreX = x;
    coreY = y;

    mapSpots = dx = dy = capacity = 0;

//    var distanceLimit = limit >= 1000
//        ? findMaxOreDistance(item)           // Scanning the whole map
//        : max(coreX, coreY, @mapw - coreX, @maph - coreY);

    var distanceLimit = max(coreX, coreY, @mapw - coreX, @maph - coreY);

    mapAction = "Locating ore...";
    mapProgress = angle = 0;
    moveTo(coreX, coreY);
    mapTotal = (distanceLimit / SPIRAL_WIDTH) ** 2;

    var oreX = 0, oreY = 0;

    while true do
        var best = -1, bestX = x, bestY = y;

        // Recompute maximum distance
        var maxDistance = (limit - capacity) * attenuationRate;
        distanceLimit = min(distanceLimit, maxDistance);
        mapTotal = (distanceLimit / SPIRAL_WIDTH) ** 2;

        if !locateOreAway(item, in out oreX, in out oreY, in distanceLimit) then
            return capacity > 0;
        end;

        if limit >= 1000 then mapSpots++; end;

        moveTo(oreX, oreY);
//        remark($"Found at $oreX, $oreY\n");
//        debugPause();

        var last = 0;
        while true do
            var diffX, diffY;
            var score = findBestPosition(oreX, oreY, ore, size, ref diffX, ref diffY);
//            remark($"Ore at $oreX, $oreY: score $score, best $best, dx $diffX, dy $diffY\n");
//            debugPause();

            // Global best
            if score > capacity then
                dx = oreX + diffX;
                dy = oreY + diffY;
                capacity = score;
                if limit < 1000 then mapSpots = score; end;
                if capacity >= limit then
                    saveLocation(item, score, dx, dy);
                    unbind();
                    return true;
                end;
            end;

            if score > best then
                bestX = oreX + diffX;
                bestY = oreY + diffY;
                best = score;
//                remark($"Stored best: $best, $bestX, $bestY (last $last)\n");
            end;

            // Did it improve the score since last time?
            // This should also prevent oscillation
            if score <= last then break; end;

            // Center the grid on the new position and try again
            // Repeat for as long as we're finding a better position
            last = score;
            oreX += round(diffX * 1.1);    // Rounds halves to higher absolute values
            oreY += round(diffY * 1.1);

            // We got too close to the core
            if min(abs(oreX - coreX), abs(oreY - coreY)) < 7 then break; end;
        end;

//        remark($"Storing best to memory: $best, $bestX, $bestY\n");

        if best >= 0 then
            saveLocation(item, best, bestX, bestY);
//            debugPrintSpot("");
        end;
    end;
end;

inline def visited(in x, in y)
//    remark($"Testing $x, $y:\n");
    for var i in locationsStart ... locations do
        var index = 4 * i;
        var lx = bank1[index + 2];
        var ly = bank1[index + 3];

//        remark($"Loc $i, ind $index: $lx, $ly\n");

        if len(x - lx, y - ly) < 7 then
//            remark("visited\n");
            return true;
        end;
    end;

//    remark("Not visited\n");
    return false;
end;

inline void saveLocation(item, value, x, y)
//    remark($"Saving spot #${count+1}:\nValue: $value at $x, $y\n");
    bank1[++count] = item.@id;
    bank1[++count] = value;
    bank1[++count] = x;
    bank1[++count] = y;
    locations++;
//    remark($"Locations: $locations");
    debugPause();
end;

inline void debugPrintSpot(text)
    if debug then
//        remark("Time: ", round(@second - start), " s\n");
        var index = 4 * locationsStart;
        for var i in locationsStart ... locations do
            // We skipped the first index
            var size = bank1[++index];
            var x = bank1[++index];
            var y = bank1[++index];
            index++;
//            remark($"$x, $y: $size\n");
        end;
        print(text);
        printflush(message1);
    end;
end;

def isBlocked(x, y)
    var result;
    // Written in pure mlog for speed.
    // Will be rewritten to Mindcode when native support for select gets implemented.
    mlog(in x, in y, out result) {
        ucontrol getBlock x y type building floor
        select type equal type @boulder @air type
        select result equal type @air 0 1
    }
    result;
end;

// Creates a 7x7 terrain mask centered around x and y
noinline def createTerrainMask(x, y)
    moveTo(x, y);
    var result = 0;
    for var r in -3 .. 3 descending do
        for var c in -3 .. 3 descending do
            result = (result << 1) | isBlocked(x + c, y + r);
        end;
    end;

    return result;
end;

// Shifts the mask in the given direction
// Makes sure parts of the mask shifted away are properly cleared
def shiftMask(mask, shiftX, shiftY)
    // If shifted all the way, the mask becomes empty
    if abs(shiftX) > 6 or abs(shiftY) > 6 then return 0; end;

    var shift = shiftX + 7 * shiftY;
    if shift > 0 then
        // We might run into precision issues. Need to clear the top part first
        var clearMask = ((1 << 49) - 1) >> shift;
        mask = (mask & clearMask) << shift;
    else
        mask >>= -shift;
    end;

    // Need to clear columns?
    if shiftX != 0 then
        var keep = 0b1111111 >> (7 - abs(shiftX));          // The bits we need to keep
        if shiftX > 0 then keep <<= 7 - abs(shiftX); end;   // Shift to the proper side
        keep |= keep << 7;
        keep |= keep << 14;
        keep |= keep << 21;
        mask &= keep;
    end;

    return mask;
end;

// Could be implemented as a loop, but this is easier on the optimizer
inline def createFixedMatrix(row0, row1, row2, row3, row4, row5, row6)
    row0 << 7 * 0 |
    row1 << 7 * 1 |
    row2 << 7 * 2 |
    row3 << 7 * 3 |
    row4 << 7 * 4 |
    row5 << 7 * 5 |
    row6 << 7 * 6;
end;

inline def createFixedMatrix(row0, row1, row2, row3)
    row0 << 7 * 0 |
    row1 << 7 * 1 |
    row2 << 7 * 2 |
    row3 << 7 * 3;
end;

inline def createFixedMatrix(row0, row1)
    row0 << 7 * 0 |
    row1 << 7 * 1;
end;

// r and c will contain the lower-left corner of the placement mask
// returns the shift applied, or -1 if it doesn't fit
noinline def findPossiblePlacement(terrainMask, placementMask, width, height, out x, out y)
    // May get unrolled, but the loops are large
    for y in -3 .. 3 do
        var mask = placementMask << 7 * (y + 3);
        for x in -3 .. 3 do
//            remark($"Position $x $y\n");
//            printMask("Shifted mask", mask);
//            debugPause();

            if (terrainMask & mask) == 0 then return 3 * 8 + y * 7 + x; end;

            // We're testing before x gets incremented, thus 6 instead of 7
            if x > 3 - width then break; end;
            mask <<= 1;
        end;
        // We're testing before y gets incremented, thus 6 instead of 7
        if y > 3 - height then break; end;
    end;

    return -1;
end;

def tryPlaceGenerator(centerX, centerY, terrainMask, generatorHorizontal, generatorVertical)
    var c, r;

    var shift = findPossiblePlacement(terrainMask, generatorHorizontal, 4, 2, out c, out r);

    if shift >= 0 then
        water2X = centerX + 0.5 + c;
        water2Y = centerY + 0.5 + r;
        generatorX = centerX + 2.5 + c;
        generatorY = centerY + 0.5 + r;

//        printMask("terrainMask:", terrainMask);

        terrainMask |= (generatorHorizontal << shift);

//        printMask("generatorShifted:", generatorHorizontal << shift);
//        remark($"Shift: $shift, r: $r, c: $c\n");
//        remark($"centerX: $centerX, centerY: $centerY\n");
//        remark($"water1X: $water1X, water1Y: $water1Y\n");
//        remark($"water2X: $water2X, water2Y: $water2Y\n");
//        remark($"generatorX: $generatorX, generatorY: $generatorY\n");
//        debugPause();
    else
        shift = findPossiblePlacement(terrainMask, generatorVertical, 2, 4, out c, out r);
        if shift < 0 then return false; end;
        water2X = centerX + 0.5 + c;
        water2Y = centerY + 0.5 + r;
        generatorX = centerX + 0.5 + c;
        generatorY = centerY + 2.5 + r;

//        printMask("terrainMask:", terrainMask);

        terrainMask |= (generatorVertical << shift);

//        printMask("generatorShifted:", generatorVertical << shift);
//        remark($"Shift: $shift, r: $r, c: $c\n");
//        remark($"centerX: $centerX, centerY: $centerY\n");
//        remark($"water1X: $water1X, water1Y: $water1Y\n");
//        remark($"water2X: $water2X, water2Y: $water2Y\n");
//        remark($"generatorX: $generatorX, generatorY: $generatorY\n");
//        debugPause();
    end;

    // If it succeeded, we assume we can squeeze in the power node and the solar panel as well
    // TODO: maybe re-center the position around the middle of the generator combo to get more space
    //       But maybe not? If it fails, we'll try other areas around the drill
    // It's a 1x1 block, so it's mask is `1`
    shift = findPossiblePlacement(terrainMask, 1, 1, 1, out c, out r);
    if shift < 0 then return false; end;
    nodeX = centerX + c;
    nodeY = centerY + r;
    terrainMask |= (1 << shift);

    shift = findPossiblePlacement(terrainMask, 1, 1, 1, out c, out r);
    if shift < 0 then return false; end;
    panelX = centerX + c;
    panelY = centerY + r;
    terrainMask |= (1 << shift);

    shift = findPossiblePlacement(terrainMask, 1, 1, 1, out c, out r);
    if shift < 0 then return false; end;
    batteryX = centerX + c;
    batteryY = centerY + r;
    terrainMask |= (1 << shift);

    return true;
end;

noinline def layoutThoriumDrillAtLocation()
    water1X = water1Y = water2X = water2Y = generatorX = generatorY = panelX = panelY = -1;

    // Create a 7x7 matrix around drill center, patch in the drill itself (it's not yet built)
    var plainTerrainMask = createTerrainMask(drillX, drillY);

    var terrainMask = plainTerrainMask | createFixedMatrix(
            0b0000000,
            0b0000000,
            0b0011100,
            0b0011100,
            0b0011100,
            0b0000000,
            0b0000000);

    // Block corners - we want the water extractor to touch the side of the drill
    // The drill is included in the mask for clarity
    var cornersMask = terrainMask | createFixedMatrix(
            0b1000001,
            0b0000000,
            0b0011100,
            0b0011100,
            0b0011100,
            0b0000000,
            0b1000001);

    // The extractor mask
    var mask2x2 = createFixedMatrix(0b11, 0b11);

    printMask("terrainMask:", terrainMask);
    printMask("cornersMask:", cornersMask);
    printMask("mask2x2:", mask2x2);
    debugStop("");

    var r, c;
    var shift = findPossiblePlacement(cornersMask, mask2x2, 2, 2, out c, out r);

    // When the water extractor can't be built, we'll do without.
    if shift >= 0 then
        // Obtain water extractor position
        water1X = drillX + 0.5 + c;
        water1Y = drillY + 0.5 + r;

        // Add it to the terrain masks
        terrainMask |= (mask2x2 << shift);
        cornersMask |= (mask2x2 << shift);
    end;

    // Secondly, reserve space for a container. The same constrains as for the water extractor apply
    shift = findPossiblePlacement(cornersMask, mask2x2, 2, 2, out c, out r);
    if shift >= 0 then
        // Obtain water extractor position
        containerX = drillX + 0.5 + c;
        containerY = drillY + 0.5 + r;

        // Add it to the terrain mask
        terrainMask |= (mask2x2 << shift);
    end;

//    printMask("new terrain mask:", terrainMask);
//    remark($"Shift: $shift, r: $r, c: $c\n");
//    remark($"water1X: $water1X, water1Y: $water1Y\n");
//    debugStop("");

    // Try to patch in the water extractor/generator combo.
    // Both orientations
    var generatorHorizontal = createFixedMatrix(0b1111, 0b1111);
    var generatorVertical = createFixedMatrix(0b11, 0b11, 0b11, 0b11);

    if tryPlaceGenerator(drillX, drillY, terrainMask, generatorHorizontal, generatorVertical) then return true; end;

    // Try four more areas, each shifted by 3 in both directions
    for var sx in 3, 3, -3, -3; var sy in 3, -3, 3, -3 do
        // Create the new terrain mask
        // Shift the terrain mask in the opposite direction!
        var newX = drillX - sx;
        var newY = drillY - sy;

        var newTerrainMask = createTerrainMask(newX, newY);

        var shiftedMask = shiftMask(terrainMask, sx, sy);
        var combinedMask = newTerrainMask | shiftedMask;

//        printMask("shiftedMask:", shiftedMask);
//        printMask("newTerrainMask:", newTerrainMask);
//        printMask("combinedMask:", combinedMask);
//        remark($"Shifted by -$sx, -$sy\n");
//        remark($"Old center: $drillX, $drillY\n");
//        remark($"New center: ${drillX + sx}, ${drillY + sy}\n");
//        debugPause();

        if tryPlaceGenerator(drillX - sx, drillY - sy, combinedMask, generatorHorizontal, generatorVertical) then return true; end;
    end;

    // We can't place the accessories, but we can place the drill
    return true;
end;

remote def findDrillLocation(x, y, unit, item, ore, size, limit, out dx, out dy, out capacity)
    findDrillLocationLocal(x, y, unit, item, ore, size, limit, out dx, out dy, out capacity);
end;

remote def layoutThoriumDrill(x, y, unit, limit)
    if !findDrillLocationLocal(x, y, unit, @thorium, @ore-thorium, 3, limit, out drillX, out drillY) then
        return false;
    end;

    layoutThoriumDrillAtLocation();
end;

remote void stopLocation()
    mapProgress = mapTotal = mapAction = mapSpots = 0;
    unbind();
end;

// DEBUG

void printMask(text, mask)
    if debugMask then
        println(text);
        for var r in 0 ... 7 descending do
            for var c in 0 ... 7 do
                print((mask & (1 << (7 * r + c))) ? "x" : "o");
            end;
            println();
        end;
    end;
end;

inline void debugStop(format, params...)
    if debug then
        print(format, params);
        debugPause();
        end();
    end;
end;

inline void debugPause()
    if debug then
        printflush(message1);
        switch1.enabled = true;
        do while switch1.enabled;
    end;
end;

const debug = false;
const debugMask = false;

//#set remarks = active;
//
//begin
//    printflush(message1);
//    printflush(message1);
//    var core, x, y;
//    do
//        ubind(@poly);
//        core = ulocate(:building, :core, false, out x, out y);
//    while core == null;
//
//    moveTo(x, y, 1);
//
//    start = @second;
////    if true then
//        var dx, dy, capacity;
//        var ox = 131;
//        var oy = 118;
//        moveTo(ox, oy);
//        var score = findBestPosition(ox, oy, @ore-titanium, 4, ref dx, ref dy);
//        moveTo(x, y);
//        println($"$score at $, $", ox + dx, oy + dy);
//        printflush(message1);
//        stop();
//
//////        findDrillLocationLocal(x, y, @unit, @titanium, @ore-titanium, 4, 2, out dx, out dy, out capacity);
//////        println($"Found $capacity at $dx, $dy.");
//////        printflush(message1);
//////        debugPause();
//////        ubind(@poly);
//////        buildAt(dx, dy, @blast-drill);
//////        wait(1);
//////        ubind(@flare);
////
////        //findDrillLocationLocal(x, y, @unit, @titanium, @ore-titanium, 4, 1e9, out dx, out dy, out capacity);
////    else
////        drillX = 129;
////        drillY = 96;
////        layoutThoriumDrillAtLocation();
////
////        buildAt(drillX, drillY, @laser-drill);
////        buildAt(water1X, water1Y, @water-extractor);
////        buildAt(water2X, water2Y, @water-extractor);
////        buildAt(generatorX, generatorY, @steam-generator);
////        buildAt(nodeX, nodeY, @power-node);
////        buildAt(panelX, panelY, @solar-panel);
////    end;
////
////    debugStop("Finished.");
//end;
//
//inline void buildAt(x, y, block)
//    if x >= 0 then
//        moveTo(x, y);
//        build(x, y, block, 0, null);
//        wait(0.1);
//    end;
//end;
