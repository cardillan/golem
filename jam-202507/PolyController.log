   159 instructions before optimizations.
     4 instructions eliminated by Temp Variables Elimination (2 iterations).
    24 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
    12 instructions eliminated by Jump Optimization (4 iterations).
     7 instructions eliminated by Single Step Elimination (5 iterations).
     1 instructions eliminated by Data Flow Optimization (3 iterations).
     1 instructions eliminated by Jump Straightening (4 iterations).
     7 instructions updated by JumpThreading.
     2 instructions eliminated by Unreachable Code Elimination (2 iterations).
    18 instructions eliminated by Print Merging.
    89 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-16 instructions):
 
     8 op equal *tmp0 .core null
     9 jump *label10 equal *tmp0 false
    10 jump *label9 always
-    * set *tmp1 null
    11 jump *label11 always
    12 label *label10
-    * set *tmp1 null
    13 label *label11
    14 label *label12
    15 ubind @poly
 
    27 print "Found builder unit."
    28 print "\n"
    29 printflush message1
-    * set *tmp6 null
    30 jump *label19 always
    31 label *label18
    32 sensor *tmp7 @unit @flag
 
    51 label *label25
    52 set *tmp15 null
    53 label *label26
-    * set *tmp12 *tmp15
    54 jump *label24 always
    55 label *label23
-    * set *tmp12 null
    56 label *label24
    57 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y *tmp16 *tmp17
    58 op sub *tmp18 :findOreToMine:x .coreX
 
    64 set .coalX :findOreToMine:x
    65 set .coalY :findOreToMine:y
    66 set .distance :findOreToMine:dist
-    * set *tmp22 .distance
    67 jump *label28 always
    68 label *label27
-    * set *tmp22 null
    69 label *label28
    70 ucontrol approach .coalX .coalY 6
    71 set :findOreToMine:floor null
 
    80 print .coalY
    81 print "\n"
    82 ucontrol flag 2
-    * set *tmp26 null
    83 jump *label30 always
    84 label *label29
    85 op notEqual *tmp27 :findOreToMine:floor null
 
   104 print "\n"
   105 set *tmp28 null
   106 label *label32
-    * set *tmp26 *tmp28
   107 label *label30
   108 label *label22
   109 set *tmp9 null
 
   121 print "    Finished"
   122 print "\n"
   123 ucontrol flag 0
-    * set *tmp33 null
   124 jump *label37 always
   125 label *label36
-    * set *tmp33 null
   126 label *label37
   127 label *label35
   128 set *tmp30 null
 
   134 jump *label39 equal *tmp35 false
   135 print " (dropping)"
   136 ucontrol itemDrop @air 30
-    * set *tmp36 null
   137 jump *label40 always
   138 label *label39
-    * set *tmp36 null
   139 label *label40
   140 print " at "
   141 print .coalX
 
   150 print ", full"
   151 ucontrol approach .coreX .coreY 6
   152 ucontrol flag 1
-    * set *tmp39 null
   153 jump *label42 always
   154 label *label41
-    * set *tmp39 null
   155 label *label42
   156 print "\n"
   157 label *label38
 
   159 label *label34
   160 set *tmp9 *tmp30
   161 label *label21
-    * set *tmp6 *tmp9
   162 label *label19
   163 label *label16
   164 jump *label15 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-6 instructions):
 
    46 print "Holding wrong item."
    47 print "\n"
    48 jump *label22 always
-    * set *tmp15 null
    49 jump *label26 always
    50 label *label25
-    * set *tmp15 null
    51 label *label26
    52 jump *label24 always
    53 label *label23
 
    91 print " "
    92 print "disappeared"
    93 print "\n"
-    * set *tmp28 null
    94 jump *label32 always
    95 label *label31
    96 print "Not close enough to "
 
    99 print " "
   100 print .coalY
   101 print "\n"
-    * set *tmp28 null
   102 label *label32
   103 label *label30
   104 label *label22
-    * set *tmp9 null
   105 jump *label21 always
   106 label *label20
   107 op equal *tmp29 :backgroundProcess:flag 1
 
   152 label *label38
   153 set *tmp30 null
   154 label *label34
-    * set *tmp9 *tmp30
   155 label *label21
   156 label *label19
   157 label *label16

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
   120 label *label36
   121 label *label37
   122 label *label35
-    * set *tmp30 null
   123 jump *label34 always
   124 label *label33
   125 print "Mining"
 
   149 label *label42
   150 print "\n"
   151 label *label38
-    * set *tmp30 null
   152 label *label34
   153 label *label21
   154 label *label19

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-4 instructions):
 
    29 printflush message1
    30 jump *label19 always
    31 label *label18
-    * sensor *tmp7 @unit @flag
-    * set :backgroundProcess:flag *tmp7
+   32 sensor :backgroundProcess:flag @unit @flag
    33 print "Unit flag: "
    34 print :backgroundProcess:flag
    35 print "\n"
 
    51 jump *label24 always
    52 label *label23
    53 label *label24
-    * ulocate ore core true @coal :findOreToMine:x :findOreToMine:y *tmp16 *tmp17
+   54 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y 0 0
    55 op sub *tmp18 :findOreToMine:x .coreX
    56 op sub *tmp19 :findOreToMine:y .coreY
-    * op len *tmp20 *tmp18 *tmp19
-    * set :findOreToMine:dist *tmp20
+   57 op len :findOreToMine:dist *tmp18 *tmp19
    58 op lessThan *tmp21 :findOreToMine:dist .distance
    59 jump *label27 equal *tmp21 false
    60 set .coalX :findOreToMine:x
 
    65 label *label28
    66 ucontrol approach .coalX .coalY 6
    67 set :findOreToMine:floor null
-    * ucontrol getBlock .coalX .coalY *tmp24 *tmp23 :findOreToMine:floor
+   68 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
    69 op equal *tmp25 :findOreToMine:floor @ore-coal
    70 jump *label29 equal *tmp25 false
    71 ucontrol mine :findOreToMine:x :findOreToMine:y
 
   160 label *label0
   161 set .builder :start:aBuilder
   162 set .core :start:aCore
-    * sensor *tmp40 .core @x
-    * set .coreX *tmp40
-    * sensor *tmp41 .core @y
-    * set .coreY *tmp41
+  163 sensor .coreX .core @x
+  164 sensor .coreY .core @y
   165 label *label43
   166 set :start*finished true
   167 jump *label8 always

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    20 jump *label12 notEqual *tmp4 false
    21 label *label14
    22 label *label15
-    * jump *label17 equal true false
    23 ubind @poly
    24 op equal *tmp5 @unit .builder
    25 jump *label18 equal *tmp5 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-12 instructions):
 
     5 set .distance 1000000000
     6 set *signature "ee6acc9f28f0b123:v1"
     7 label *label8
-    * op equal *tmp0 .core null
-    * jump *label10 equal *tmp0 false
+    8 jump *label10 notEqual .core null
     9 jump *label9 always
    10 jump *label11 always
    11 label *label10
 
    20 label *label14
    21 label *label15
    22 ubind @poly
-    * op equal *tmp5 @unit .builder
-    * jump *label18 equal *tmp5 false
+   23 jump *label18 notEqual @unit .builder
    24 print "Found builder unit."
    25 print "\n"
    26 printflush message1
 
    30 print "Unit flag: "
    31 print :backgroundProcess:flag
    32 print "\n"
-    * op equal *tmp8 :backgroundProcess:flag 0
-    * jump *label20 equal *tmp8 false
+   33 jump *label20 notEqual :backgroundProcess:flag 0
    34 sensor *tmp10 @unit @firstItem
-    * op notEqual *tmp11 *tmp10 null
-    * jump *label23 equal *tmp11 false
+   35 jump *label23 equal *tmp10 null
    36 ucontrol itemDrop @air 30
    37 sensor *tmp13 @unit @firstItem
-    * op notEqual *tmp14 *tmp13 null
-    * jump *label25 equal *tmp14 false
+   38 jump *label25 equal *tmp13 null
    39 print "Holding wrong item."
    40 print "\n"
    41 jump *label22 always
 
    49 op sub *tmp18 :findOreToMine:x .coreX
    50 op sub *tmp19 :findOreToMine:y .coreY
    51 op len :findOreToMine:dist *tmp18 *tmp19
-    * op lessThan *tmp21 :findOreToMine:dist .distance
-    * jump *label27 equal *tmp21 false
+   52 jump *label27 greaterThanEq :findOreToMine:dist .distance
    53 set .coalX :findOreToMine:x
    54 set .coalY :findOreToMine:y
    55 set .distance :findOreToMine:dist
 
    59 ucontrol approach .coalX .coalY 6
    60 set :findOreToMine:floor null
    61 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
-    * op equal *tmp25 :findOreToMine:floor @ore-coal
-    * jump *label29 equal *tmp25 false
+   62 jump *label29 notEqual :findOreToMine:floor @ore-coal
    63 ucontrol mine :findOreToMine:x :findOreToMine:y
    64 print "Found coal at "
    65 print .coalX
 
    70 ucontrol flag 2
    71 jump *label30 always
    72 label *label29
-    * op notEqual *tmp27 :findOreToMine:floor null
-    * jump *label31 equal *tmp27 false
+   73 jump *label31 equal :findOreToMine:floor null
    74 set .distance 1000000000
    75 print "Coal at "
    76 print .coalX
 
    93 label *label22
    94 jump *label21 always
    95 label *label20
-    * op equal *tmp29 :backgroundProcess:flag 1
-    * jump *label33 equal *tmp29 false
+   96 jump *label33 notEqual :backgroundProcess:flag 1
    97 print "Returning"
    98 print "\n"
    99 ucontrol approach .coreX .coreY 6
   100 ucontrol itemDrop .core 30
   101 sensor *tmp31 @unit @firstItem
-    * op equal *tmp32 *tmp31 null
-    * jump *label36 equal *tmp32 false
+  102 jump *label36 notEqual *tmp31 null
   103 print "    Finished"
   104 print "\n"
   105 ucontrol flag 0
 
   111 label *label33
   112 print "Mining"
   113 sensor *tmp34 @unit @firstItem
-    * op notEqual *tmp35 *tmp34 @coal
-    * jump *label39 equal *tmp35 false
+  114 jump *label39 equal *tmp34 @coal
   115 print " (dropping)"
   116 ucontrol itemDrop @air 30
   117 jump *label40 always
 
   125 ucontrol approach .coalX .coalY 6
   126 ucontrol mine .coalX .coalY
   127 sensor *tmp37 @unit @totalItems
-    * op greaterThanEq *tmp38 *tmp37 30
-    * jump *label41 equal *tmp38 false
+  128 jump *label41 lessThan *tmp37 30
   129 print ", full"
   130 ucontrol approach .coreX .coreY 6
   131 ucontrol flag 1

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
     7 label *label8
     8 jump *label10 notEqual .core null
     9 jump *label9 always
-    * jump *label11 always
    10 label *label10
    11 label *label11
    12 label *label12
 
    38 print "Holding wrong item."
    39 print "\n"
    40 jump *label22 always
-    * jump *label26 always
    41 label *label25
    42 label *label26
-    * jump *label24 always
    43 label *label23
    44 label *label24
    45 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y 0 0
 
    50 set .coalX :findOreToMine:x
    51 set .coalY :findOreToMine:y
    52 set .distance :findOreToMine:dist
-    * jump *label28 always
    53 label *label27
    54 label *label28
    55 ucontrol approach .coalX .coalY 6
 
    99 print "    Finished"
   100 print "\n"
   101 ucontrol flag 0
-    * jump *label37 always
   102 label *label36
   103 label *label37
   104 label *label35
 
   109 jump *label39 equal *tmp34 @coal
   110 print " (dropping)"
   111 ucontrol itemDrop @air 30
-    * jump *label40 always
   112 label *label39
   113 label *label40
   114 print " at "
 
   123 print ", full"
   124 ucontrol approach .coreX .coreY 6
   125 ucontrol flag 1
-    * jump *label42 always
   126 label *label41
   127 label *label42
   128 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    53 label *label27
    54 label *label28
    55 ucontrol approach .coalX .coalY 6
-    * set :findOreToMine:floor null
    56 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
    57 jump *label29 notEqual :findOreToMine:floor @ore-coal
    58 ucontrol mine :findOreToMine:x :findOreToMine:y

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
     8 jump *label10 notEqual .core null
     9 jump *label9 always
    10 label *label10
-    * label *label11
    11 label *label12
    12 ubind @poly
-    * label *label13
    13 op equal *tmp2 @unit null
    14 op equal *tmp3 @unit .builder
    15 op or *tmp4 *tmp2 *tmp3
    16 jump *label12 notEqual *tmp4 false
-    * label *label14
    17 label *label15
    18 ubind @poly
    19 jump *label18 notEqual @unit .builder
 
    36 print "\n"
    37 jump *label22 always
    38 label *label25
-    * label *label26
    39 label *label23
-    * label *label24
    40 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y 0 0
    41 op sub *tmp18 :findOreToMine:x .coreX
    42 op sub *tmp19 :findOreToMine:y .coreY
 
    46 set .coalY :findOreToMine:y
    47 set .distance :findOreToMine:dist
    48 label *label27
-    * label *label28
    49 ucontrol approach .coalX .coalY 6
    50 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
    51 jump *label29 notEqual :findOreToMine:floor @ore-coal
 
    93 print "\n"
    94 ucontrol flag 0
    95 label *label36
-    * label *label37
-    * label *label35
    96 jump *label34 always
    97 label *label33
    98 print "Mining"
 
   101 print " (dropping)"
   102 ucontrol itemDrop @air 30
   103 label *label39
-    * label *label40
   104 print " at "
   105 print .coalX
   106 print ","
 
   114 ucontrol approach .coreX .coreY 6
   115 ucontrol flag 1
   116 label *label41
-    * label *label42
   117 print "\n"
-    * label *label38
   118 label *label34
   119 label *label21
   120 label *label19
-    * label *label16
   121 jump *label15 always
-    * label *label17
   122 label *label9
   123 wait 1e12
   124 jump *label8 always
 
   128 set .core :start:aCore
   129 sensor .coreX .core @x
   130 sensor .coreY .core @y
-    * label *label43
   131 set :start*finished true
   132 jump *label8 always
   133 end

Modifications by Jumps phase, Jump Straightening, pass 3, iteration 1 (-1 instructions):
 
     5 set .distance 1000000000
     6 set *signature "ee6acc9f28f0b123:v1"
     7 label *label8
-    * jump *label10 notEqual .core null
-    * jump *label9 always
+    8 jump *label9 equal .core null
     9 label *label10
    10 label *label12
    11 ubind @poly

Modifications by Jumps phase, Jump Optimization, pass 3, iteration 1:
 
     6 set *signature "ee6acc9f28f0b123:v1"
     7 label *label8
     8 jump *label9 equal .core null
-    * label *label10
     9 label *label12
    10 ubind @poly
    11 op equal *tmp2 @unit null

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
 
    18 print "Found builder unit."
    19 print "\n"
    20 printflush message1
-    * jump *label19 always
+   21 jump *label15 always
    22 label *label18
    23 sensor :backgroundProcess:flag @unit @flag
    24 print "Unit flag: "
 
    32 jump *label25 equal *tmp13 null
    33 print "Holding wrong item."
    34 print "\n"
-    * jump *label22 always
+   35 jump *label15 always
    36 label *label25
    37 label *label23
    38 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y 0 0
 
    55 print .coalY
    56 print "\n"
    57 ucontrol flag 2
-    * jump *label30 always
+   58 jump *label15 always
    59 label *label29
    60 jump *label31 equal :findOreToMine:floor null
    61 set .distance 1000000000
 
    67 print " "
    68 print "disappeared"
    69 print "\n"
-    * jump *label32 always
+   70 jump *label15 always
    71 label *label31
    72 print "Not close enough to "
    73 print .coalX
 
    78 label *label32
    79 label *label30
    80 label *label22
-    * jump *label21 always
+   81 jump *label15 always
    82 label *label20
    83 jump *label33 notEqual :backgroundProcess:flag 1
    84 print "Returning"
 
    86 ucontrol approach .coreX .coreY 6
    87 ucontrol itemDrop .core 30
    88 sensor *tmp31 @unit @firstItem
-    * jump *label36 notEqual *tmp31 null
+   89 jump *label15 notEqual *tmp31 null
    90 print "    Finished"
    91 print "\n"
    92 ucontrol flag 0
    93 label *label36
-    * jump *label34 always
+   94 jump *label15 always
    95 label *label33
    96 print "Mining"
    97 sensor *tmp34 @unit @firstItem

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-2 instructions):
 
    75 print " "
    76 print .coalY
    77 print "\n"
-    * label *label32
-    * label *label30
-    * label *label22
    78 jump *label15 always
    79 label *label20
    80 jump *label33 notEqual :backgroundProcess:flag 1
 
    87 print "    Finished"
    88 print "\n"
    89 ucontrol flag 0
-    * label *label36
    90 jump *label15 always
    91 label *label33
    92 print "Mining"
 
   109 ucontrol flag 1
   110 label *label41
   111 print "\n"
-    * label *label34
-    * label *label21
-    * label *label19
   112 jump *label15 always
   113 label *label9
   114 wait 1e12
   115 jump *label8 always
-    * end
   116 label *label0
   117 set .builder :start:aBuilder
   118 set .core :start:aCore
 
   120 sensor .coreY .core @y
   121 set :start*finished true
   122 jump *label8 always
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-18 instructions):
 
    15 label *label15
    16 ubind @poly
    17 jump *label18 notEqual @unit .builder
-    * print "Found builder unit."
-    * print "\n"
+   18 print "Found builder unit.\n"
    19 printflush message1
    20 jump *label15 always
    21 label *label18
    22 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   23 print "Unit flag: {0}\n"
+   24 format :backgroundProcess:flag
    25 jump *label20 notEqual :backgroundProcess:flag 0
    26 sensor *tmp10 @unit @firstItem
    27 jump *label23 equal *tmp10 null
    28 ucontrol itemDrop @air 30
    29 sensor *tmp13 @unit @firstItem
    30 jump *label25 equal *tmp13 null
-    * print "Holding wrong item."
-    * print "\n"
+   31 print "Holding wrong item.\n"
    32 jump *label15 always
    33 label *label25
    34 label *label23
 
    45 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
    46 jump *label29 notEqual :findOreToMine:floor @ore-coal
    47 ucontrol mine :findOreToMine:x :findOreToMine:y
-    * print "Found coal at "
-    * print .coalX
-    * print ","
-    * print " "
-    * print .coalY
-    * print "\n"
+   48 print "Found coal at {0}, {0}\n"
+   49 format .coalX
+   50 format .coalY
    51 ucontrol flag 2
    52 jump *label15 always
    53 label *label29
    54 jump *label31 equal :findOreToMine:floor null
    55 set .distance 1000000000
-    * print "Coal at "
-    * print .coalX
-    * print ","
-    * print " "
-    * print .coalY
-    * print " "
-    * print "disappeared"
-    * print "\n"
+   56 print "Coal at {0}, {0} disappeared\n"
+   57 format .coalX
+   58 format .coalY
    59 jump *label15 always
    60 label *label31
-    * print "Not close enough to "
-    * print .coalX
-    * print ","
-    * print " "
-    * print .coalY
-    * print "\n"
+   61 print "Not close enough to {0}, {0}\n"
+   62 format .coalX
+   63 format .coalY
    64 jump *label15 always
    65 label *label20
    66 jump *label33 notEqual :backgroundProcess:flag 1
-    * print "Returning"
-    * print "\n"
+   67 print "Returning\n"
    68 ucontrol approach .coreX .coreY 6
    69 ucontrol itemDrop .core 30
    70 sensor *tmp31 @unit @firstItem
    71 jump *label15 notEqual *tmp31 null
-    * print "    Finished"
-    * print "\n"
+   72 print "    Finished\n"
    73 ucontrol flag 0
    74 jump *label15 always
    75 label *label33
 
    79 print " (dropping)"
    80 ucontrol itemDrop @air 30
    81 label *label39
-    * print " at "
-    * print .coalX
-    * print ","
-    * print " "
+   82 print " at {0}, "
+   83 format .coalX
    84 print .coalY
    85 ucontrol approach .coalX .coalY 6
    86 ucontrol mine .coalX .coalY

Final code before resolving virtual instructions:

    0:  jump *label7 always 0 0                                      #set target = 8;
    1:  jump *label0 always 0 0                                      ...
    2:  draw triangle message1 .builder .coalX .coalY .core .coreX
    3:  draw triangle .coreY .distance :backgroundProcess:flag :findOreToMine:dist :findOreToMine:floor :findOreToMine:x
    4:  draw triangle :findOreToMine:y :start:aBuilder :start:aCore 0 0 0
        label *label7                                                ...
    5:  set .coalX 0                                                 var
    6:  set .coalY 0                                                 ...
    7:  set .distance 1000000000                                     ...
    8:  set *signature "ee6acc9f28f0b123:v1"                         #set target = 8;
        label *label8                                                ...
    9:  jump *label9 equal .core null                                if core == null then return; end;
        label *label12                                               do
   10:  ubind @poly                                                  ubind(@poly);
   11:  op equal *tmp2 @unit null                                    while @unit == null or @unit == builder;
   12:  op equal *tmp3 @unit .builder                                ...
   13:  op or *tmp4 *tmp2 *tmp3                                      ...
   14:  jump *label12 notEqual *tmp4 false                           do
        label *label15                                               while true do
   15:  ubind @poly                                                  ubind(@poly);
   16:  jump *label18 notEqual @unit .builder                        if @unit == builder then
   17:  print "Found builder unit.\n"                                println("Found builder unit.");
   18:  printflush message1                                          printflush(message1);
   19:  jump *label15 always 0 0                                     if @unit == builder then
        label *label18                                               ...
   20:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   21:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   22:  format :backgroundProcess:flag                               ...
   23:  jump *label20 notEqual :backgroundProcess:flag 0             if flag == 0 then
   24:  sensor *tmp10 @unit @firstItem                               if @unit.@firstItem != null then
   25:  jump *label23 equal *tmp10 null                              ...
   26:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   27:  sensor *tmp13 @unit @firstItem                               if @unit.@firstItem != null then
   28:  jump *label25 equal *tmp13 null                              ...
   29:  print "Holding wrong item.\n"                                println($"Holding wrong item.");
   30:  jump *label15 always 0 0                                     return;
        label *label25                                               if @unit.@firstItem != null then
        label *label23                                               if @unit.@firstItem != null then
   31:  ulocate ore core true @coal :findOreToMine:x :findOreToMine: ulocate(:ore, @coal, out x, out y);
   32:  op sub *tmp18 :findOreToMine:x .coreX                        var dist = len(x - coreX, y - coreY);
   33:  op sub *tmp19 :findOreToMine:y .coreY                        ...
   34:  op len :findOreToMine:dist *tmp18 *tmp19                     ...
   35:  jump *label27 greaterThanEq :findOreToMine:dist .distance    if dist < distance then
   36:  set .coalX :findOreToMine:x                                  coalX = x;
   37:  set .coalY :findOreToMine:y                                  coalY = y;
   38:  set .distance :findOreToMine:dist                            distance = dist;
        label *label27                                               if dist < distance then
   39:  ucontrol approach .coalX .coalY 6 0 0                        approach(coalX, coalY, RADIUS);
   40:  ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor     getBlock(coalX, coalY, , out floor);
   41:  jump *label29 notEqual :findOreToMine:floor @ore-coal        if floor == @ore-coal then
   42:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   43:  print "Found coal at {0}, {0}\n"                             println($"Found coal at $coalX, $coalY");
   44:  format .coalX                                                ...
   45:  format .coalY                                                ...
   46:  ucontrol flag 2 0 0 0 0                                      flag(2);
   47:  jump *label15 always 0 0                                     if floor == @ore-coal then
        label *label29                                               ...
   48:  jump *label31 equal :findOreToMine:floor null                elsif floor != null
   49:  set .distance 1000000000                                     then distance = 1e9;
   50:  print "Coal at {0}, {0} disappeared\n"                       println($"Coal at $coalX, $coalY disappeared");
   51:  format .coalX                                                ...
   52:  format .coalY                                                ...
   53:  jump *label15 always 0 0                                     elsif floor != null
        label *label31                                               ...
   54:  print "Not close enough to {0}, {0}\n"                       println($"Not close enough to $coalX, $coalY");
   55:  format .coalX                                                ...
   56:  format .coalY                                                ...
   57:  jump *label15 always 0 0                                     if flag == 0 then
        label *label20                                               ...
   58:  jump *label33 notEqual :backgroundProcess:flag 1             elsif flag == 1 then
   59:  print "Returning\n"                                          println("Returning");
   60:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   61:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   62:  sensor *tmp31 @unit @firstItem                               if @unit.@firstItem == null then
   63:  jump *label15 notEqual *tmp31 null                           ...
   64:  print "    Finished\n"                                       println("    Finished");
   65:  ucontrol flag 0 0 0 0 0                                      flag(0);
   66:  jump *label15 always 0 0                                     elsif flag == 1 then
        label *label33                                               ...
   67:  print "Mining"                                               print("Mining");
   68:  sensor *tmp34 @unit @firstItem                               if @unit.@firstItem != @coal then
   69:  jump *label39 equal *tmp34 @coal                             ...
   70:  print " (dropping)"                                          print(" (dropping)");
   71:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label39                                               if @unit.@firstItem != @coal then
   72:  print " at {0}, "                                            print($" at $coalX, $coalY");
   73:  format .coalX                                                ...
   74:  print .coalY                                                 ...
   75:  ucontrol approach .coalX .coalY 6 0 0                        approach(coalX, coalY, RADIUS);
   76:  ucontrol mine .coalX .coalY 0 0 0                            mine(coalX, coalY);
   77:  sensor *tmp37 @unit @totalItems                              if @unit.@totalItems >= CAPACITY then
   78:  jump *label41 lessThan *tmp37 30                             ...
   79:  print ", full"                                               print(", full");
   80:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   81:  ucontrol flag 1 0 0 0 0                                      flag(1);
        label *label41                                               if @unit.@totalItems >= CAPACITY then
   82:  print "\n"                                                   println();
   83:  jump *label15 always 0 0                                     while true do
        label *label9                                                #set target = 8;
   84:  wait 1e12                                                    ...
   85:  jump *label8 always 0 0                                      ...
        label *label0                                                remote void start(aCore, aBuilder)
   86:  set .builder :start:aBuilder                                 builder = aBuilder;
   87:  set .core :start:aCore                                       core = aCore;
   88:  sensor .coreX .core @x                                       coreX = core.@x;
   89:  sensor .coreY .core @y                                       coreY = core.@y;
   90:  set :start*finished true                                     remote void start(aCore, aBuilder)
   91:  jump *label8 always 0 0                                      ...


Performance: parsed in 244 ms, compiled in 334 ms, optimized in 177 ms, run in 3 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (7 steps):
The program didn't generate any output.
Execution exception at instruction 84: wait 1e12:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
