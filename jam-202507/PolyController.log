   150 instructions before optimizations.
     4 instructions eliminated by Temp Variables Elimination (2 iterations).
    24 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
    13 instructions eliminated by Jump Optimization (4 iterations).
     7 instructions eliminated by Single Step Elimination (5 iterations).
     1 instructions eliminated by Data Flow Optimization (3 iterations).
     1 instructions eliminated by Jump Straightening (4 iterations).
     7 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    18 instructions eliminated by Print Merging.
    80 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-16 instructions):
 
    15 op equal *tmp4 .core null
    16 jump *label11 equal *tmp4 false
    17 jump *label10 always
-    * set *tmp5 null
    18 jump *label12 always
    19 label *label11
-    * set *tmp5 null
    20 label *label12
    21 label *label13
    22 jump *label15 equal true false
 
    26 print "Found builder unit."
    27 print "\n"
    28 printflush message1
-    * set *tmp7 null
    29 jump *label17 always
    30 label *label16
    31 sensor *tmp8 @unit @flag
 
    50 label *label23
    51 set *tmp16 null
    52 label *label24
-    * set *tmp13 *tmp16
    53 jump *label22 always
    54 label *label21
-    * set *tmp13 null
    55 label *label22
    56 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y *tmp17 *tmp18
    57 op sub *tmp19 :findOreToMine:x .coreX
 
    63 set .coalX :findOreToMine:x
    64 set .coalY :findOreToMine:y
    65 set .distance :findOreToMine:dist
-    * set *tmp23 .distance
    66 jump *label26 always
    67 label *label25
-    * set *tmp23 null
    68 label *label26
    69 ucontrol approach .coalX .coalY 6
    70 set :findOreToMine:floor null
 
    79 print .coalY
    80 print "\n"
    81 ucontrol flag 2
-    * set *tmp27 null
    82 jump *label28 always
    83 label *label27
    84 op notEqual *tmp28 :findOreToMine:floor null
 
   103 print "\n"
   104 set *tmp29 null
   105 label *label30
-    * set *tmp27 *tmp29
   106 label *label28
   107 label *label20
   108 set *tmp10 null
 
   120 print "    Finished"
   121 print "\n"
   122 ucontrol flag 0
-    * set *tmp34 null
   123 jump *label35 always
   124 label *label34
-    * set *tmp34 null
   125 label *label35
   126 label *label33
   127 set *tmp31 null
 
   133 jump *label37 equal *tmp36 false
   134 print " (dropping)"
   135 ucontrol itemDrop @air 30
-    * set *tmp37 null
   136 jump *label38 always
   137 label *label37
-    * set *tmp37 null
   138 label *label38
   139 print " at "
   140 print .coalX
 
   149 print ", full"
   150 ucontrol approach .coreX .coreY 6
   151 ucontrol flag 1
-    * set *tmp40 null
   152 jump *label40 always
   153 label *label39
-    * set *tmp40 null
   154 label *label40
   155 print "\n"
   156 label *label36
 
   158 label *label32
   159 set *tmp10 *tmp31
   160 label *label19
-    * set *tmp7 *tmp10
   161 label *label17
   162 label *label14
   163 jump *label13 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-6 instructions):
 
    45 print "Holding wrong item."
    46 print "\n"
    47 jump *label20 always
-    * set *tmp16 null
    48 jump *label24 always
    49 label *label23
-    * set *tmp16 null
    50 label *label24
    51 jump *label22 always
    52 label *label21
 
    90 print " "
    91 print "disappeared"
    92 print "\n"
-    * set *tmp29 null
    93 jump *label30 always
    94 label *label29
    95 print "Not close enough to "
 
    98 print " "
    99 print .coalY
   100 print "\n"
-    * set *tmp29 null
   101 label *label30
   102 label *label28
   103 label *label20
-    * set *tmp10 null
   104 jump *label19 always
   105 label *label18
   106 op equal *tmp30 :backgroundProcess:flag 1
 
   151 label *label36
   152 set *tmp31 null
   153 label *label32
-    * set *tmp10 *tmp31
   154 label *label19
   155 label *label17
   156 label *label14

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
   119 label *label34
   120 label *label35
   121 label *label33
-    * set *tmp31 null
   122 jump *label32 always
   123 label *label31
   124 print "Mining"
 
   148 label *label40
   149 print "\n"
   150 label *label36
-    * set *tmp31 null
   151 label *label32
   152 label *label19
   153 label *label17

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-4 instructions):
 
     2 set .distance 1000000000
     3 label *label6
     4 ubind @poly
-    * set *tmp0 @unit
-    * set .builder *tmp0
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+    5 set .builder @unit
+    6 ulocate building core false @copper .coreX .coreY 0 .core
     7 label *label7
     8 op equal *tmp3 .core null
     9 jump *label6 notEqual *tmp3 false
 
    26 printflush message1
    27 jump *label17 always
    28 label *label16
-    * sensor *tmp8 @unit @flag
-    * set :backgroundProcess:flag *tmp8
+   29 sensor :backgroundProcess:flag @unit @flag
    30 print "Unit flag: "
    31 print :backgroundProcess:flag
    32 print "\n"
 
    48 jump *label22 always
    49 label *label21
    50 label *label22
-    * ulocate ore core true @coal :findOreToMine:x :findOreToMine:y *tmp17 *tmp18
+   51 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y 0 0
    52 op sub *tmp19 :findOreToMine:x .coreX
    53 op sub *tmp20 :findOreToMine:y .coreY
-    * op len *tmp21 *tmp19 *tmp20
-    * set :findOreToMine:dist *tmp21
+   54 op len :findOreToMine:dist *tmp19 *tmp20
    55 op lessThan *tmp22 :findOreToMine:dist .distance
    56 jump *label25 equal *tmp22 false
    57 set .coalX :findOreToMine:x
 
    62 label *label26
    63 ucontrol approach .coalX .coalY 6
    64 set :findOreToMine:floor null
-    * ucontrol getBlock .coalX .coalY *tmp25 *tmp24 :findOreToMine:floor
+   65 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
    66 op equal *tmp26 :findOreToMine:floor @ore-coal
    67 jump *label27 equal *tmp26 false
    68 ucontrol mine :findOreToMine:x :findOreToMine:y

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    17 label *label11
    18 label *label12
    19 label *label13
-    * jump *label15 equal true false
    20 ubind @poly
    21 op equal *tmp6 @unit .builder
    22 jump *label16 equal *tmp6 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-13 instructions):
 
     5 set .builder @unit
     6 ulocate building core false @copper .coreX .coreY 0 .core
     7 label *label7
-    * op equal *tmp3 .core null
-    * jump *label6 notEqual *tmp3 false
+    8 jump *label6 equal .core null
     9 label *label8
    10 set *signature "0:v1"
    11 label *label9
-    * op equal *tmp4 .core null
-    * jump *label11 equal *tmp4 false
+   12 jump *label11 notEqual .core null
    13 jump *label10 always
    14 jump *label12 always
    15 label *label11
    16 label *label12
    17 label *label13
    18 ubind @poly
-    * op equal *tmp6 @unit .builder
-    * jump *label16 equal *tmp6 false
+   19 jump *label16 notEqual @unit .builder
    20 print "Found builder unit."
    21 print "\n"
    22 printflush message1
 
    26 print "Unit flag: "
    27 print :backgroundProcess:flag
    28 print "\n"
-    * op equal *tmp9 :backgroundProcess:flag 0
-    * jump *label18 equal *tmp9 false
+   29 jump *label18 notEqual :backgroundProcess:flag 0
    30 sensor *tmp11 @unit @firstItem
-    * op notEqual *tmp12 *tmp11 null
-    * jump *label21 equal *tmp12 false
+   31 jump *label21 equal *tmp11 null
    32 ucontrol itemDrop @air 30
    33 sensor *tmp14 @unit @firstItem
-    * op notEqual *tmp15 *tmp14 null
-    * jump *label23 equal *tmp15 false
+   34 jump *label23 equal *tmp14 null
    35 print "Holding wrong item."
    36 print "\n"
    37 jump *label20 always
 
    45 op sub *tmp19 :findOreToMine:x .coreX
    46 op sub *tmp20 :findOreToMine:y .coreY
    47 op len :findOreToMine:dist *tmp19 *tmp20
-    * op lessThan *tmp22 :findOreToMine:dist .distance
-    * jump *label25 equal *tmp22 false
+   48 jump *label25 greaterThanEq :findOreToMine:dist .distance
    49 set .coalX :findOreToMine:x
    50 set .coalY :findOreToMine:y
    51 set .distance :findOreToMine:dist
 
    55 ucontrol approach .coalX .coalY 6
    56 set :findOreToMine:floor null
    57 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
-    * op equal *tmp26 :findOreToMine:floor @ore-coal
-    * jump *label27 equal *tmp26 false
+   58 jump *label27 notEqual :findOreToMine:floor @ore-coal
    59 ucontrol mine :findOreToMine:x :findOreToMine:y
    60 print "Found coal at "
    61 print .coalX
 
    66 ucontrol flag 2
    67 jump *label28 always
    68 label *label27
-    * op notEqual *tmp28 :findOreToMine:floor null
-    * jump *label29 equal *tmp28 false
+   69 jump *label29 equal :findOreToMine:floor null
    70 set .distance 1000000000
    71 print "Coal at "
    72 print .coalX
 
    89 label *label20
    90 jump *label19 always
    91 label *label18
-    * op equal *tmp30 :backgroundProcess:flag 1
-    * jump *label31 equal *tmp30 false
+   92 jump *label31 notEqual :backgroundProcess:flag 1
    93 print "Returning"
    94 print "\n"
    95 ucontrol approach .coreX .coreY 6
    96 ucontrol itemDrop .core 30
    97 sensor *tmp32 @unit @firstItem
-    * op equal *tmp33 *tmp32 null
-    * jump *label34 equal *tmp33 false
+   98 jump *label34 notEqual *tmp32 null
    99 print "    Finished"
   100 print "\n"
   101 ucontrol flag 0
 
   107 label *label31
   108 print "Mining"
   109 sensor *tmp35 @unit @firstItem
-    * op notEqual *tmp36 *tmp35 @coal
-    * jump *label37 equal *tmp36 false
+  110 jump *label37 equal *tmp35 @coal
   111 print " (dropping)"
   112 ucontrol itemDrop @air 30
   113 jump *label38 always
 
   121 ucontrol approach .coalX .coalY 6
   122 ucontrol mine .coalX .coalY
   123 sensor *tmp38 @unit @totalItems
-    * op greaterThanEq *tmp39 *tmp38 30
-    * jump *label39 equal *tmp39 false
+  124 jump *label39 lessThan *tmp38 30
   125 print ", full"
   126 ucontrol approach .coreX .coreY 6
   127 ucontrol flag 1

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    11 label *label9
    12 jump *label11 notEqual .core null
    13 jump *label10 always
-    * jump *label12 always
    14 label *label11
    15 label *label12
    16 label *label13
 
    34 print "Holding wrong item."
    35 print "\n"
    36 jump *label20 always
-    * jump *label24 always
    37 label *label23
    38 label *label24
-    * jump *label22 always
    39 label *label21
    40 label *label22
    41 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y 0 0
 
    46 set .coalX :findOreToMine:x
    47 set .coalY :findOreToMine:y
    48 set .distance :findOreToMine:dist
-    * jump *label26 always
    49 label *label25
    50 label *label26
    51 ucontrol approach .coalX .coalY 6
 
    95 print "    Finished"
    96 print "\n"
    97 ucontrol flag 0
-    * jump *label35 always
    98 label *label34
    99 label *label35
   100 label *label33
 
   105 jump *label37 equal *tmp35 @coal
   106 print " (dropping)"
   107 ucontrol itemDrop @air 30
-    * jump *label38 always
   108 label *label37
   109 label *label38
   110 print " at "
 
   119 print ", full"
   120 ucontrol approach .coreX .coreY 6
   121 ucontrol flag 1
-    * jump *label40 always
   122 label *label39
   123 label *label40
   124 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    49 label *label25
    50 label *label26
    51 ucontrol approach .coalX .coalY 6
-    * set :findOreToMine:floor null
    52 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
    53 jump *label27 notEqual :findOreToMine:floor @ore-coal
    54 ucontrol mine :findOreToMine:x :findOreToMine:y

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
     4 ubind @poly
     5 set .builder @unit
     6 ulocate building core false @copper .coreX .coreY 0 .core
-    * label *label7
     7 jump *label6 equal .core null
-    * label *label8
     8 set *signature "0:v1"
     9 label *label9
    10 jump *label11 notEqual .core null
    11 jump *label10 always
    12 label *label11
-    * label *label12
    13 label *label13
    14 ubind @poly
    15 jump *label16 notEqual @unit .builder
 
    32 print "\n"
    33 jump *label20 always
    34 label *label23
-    * label *label24
    35 label *label21
-    * label *label22
    36 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y 0 0
    37 op sub *tmp19 :findOreToMine:x .coreX
    38 op sub *tmp20 :findOreToMine:y .coreY
 
    42 set .coalY :findOreToMine:y
    43 set .distance :findOreToMine:dist
    44 label *label25
-    * label *label26
    45 ucontrol approach .coalX .coalY 6
    46 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
    47 jump *label27 notEqual :findOreToMine:floor @ore-coal
 
    89 print "\n"
    90 ucontrol flag 0
    91 label *label34
-    * label *label35
-    * label *label33
    92 jump *label32 always
    93 label *label31
    94 print "Mining"
 
    97 print " (dropping)"
    98 ucontrol itemDrop @air 30
    99 label *label37
-    * label *label38
   100 print " at "
   101 print .coalX
   102 print ","
 
   110 ucontrol approach .coreX .coreY 6
   111 ucontrol flag 1
   112 label *label39
-    * label *label40
   113 print "\n"
-    * label *label36
   114 label *label32
   115 label *label19
   116 label *label17
-    * label *label14
   117 jump *label13 always
-    * label *label15
   118 label *label10
   119 wait 1e12
   120 jump *label9 always

Modifications by Jumps phase, Jump Straightening, pass 3, iteration 1 (-1 instructions):
 
     7 jump *label6 equal .core null
     8 set *signature "0:v1"
     9 label *label9
-    * jump *label11 notEqual .core null
-    * jump *label10 always
+   10 jump *label10 equal .core null
    11 label *label11
    12 label *label13
    13 ubind @poly

Modifications by Jumps phase, Jump Optimization, pass 3, iteration 1:
 
     8 set *signature "0:v1"
     9 label *label9
    10 jump *label10 equal .core null
-    * label *label11
    11 label *label13
    12 ubind @poly
    13 jump *label16 notEqual @unit .builder

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
 
    14 print "Found builder unit."
    15 print "\n"
    16 printflush message1
-    * jump *label17 always
+   17 jump *label13 always
    18 label *label16
    19 sensor :backgroundProcess:flag @unit @flag
    20 print "Unit flag: "
 
    28 jump *label23 equal *tmp14 null
    29 print "Holding wrong item."
    30 print "\n"
-    * jump *label20 always
+   31 jump *label13 always
    32 label *label23
    33 label *label21
    34 ulocate ore core true @coal :findOreToMine:x :findOreToMine:y 0 0
 
    51 print .coalY
    52 print "\n"
    53 ucontrol flag 2
-    * jump *label28 always
+   54 jump *label13 always
    55 label *label27
    56 jump *label29 equal :findOreToMine:floor null
    57 set .distance 1000000000
 
    63 print " "
    64 print "disappeared"
    65 print "\n"
-    * jump *label30 always
+   66 jump *label13 always
    67 label *label29
    68 print "Not close enough to "
    69 print .coalX
 
    74 label *label30
    75 label *label28
    76 label *label20
-    * jump *label19 always
+   77 jump *label13 always
    78 label *label18
    79 jump *label31 notEqual :backgroundProcess:flag 1
    80 print "Returning"
 
    82 ucontrol approach .coreX .coreY 6
    83 ucontrol itemDrop .core 30
    84 sensor *tmp32 @unit @firstItem
-    * jump *label34 notEqual *tmp32 null
+   85 jump *label13 notEqual *tmp32 null
    86 print "    Finished"
    87 print "\n"
    88 ucontrol flag 0
    89 label *label34
-    * jump *label32 always
+   90 jump *label13 always
    91 label *label31
    92 print "Mining"
    93 sensor *tmp35 @unit @firstItem

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-1 instructions):
 
    71 print " "
    72 print .coalY
    73 print "\n"
-    * label *label30
-    * label *label28
-    * label *label20
    74 jump *label13 always
    75 label *label18
    76 jump *label31 notEqual :backgroundProcess:flag 1
 
    83 print "    Finished"
    84 print "\n"
    85 ucontrol flag 0
-    * label *label34
    86 jump *label13 always
    87 label *label31
    88 print "Mining"
 
   105 ucontrol flag 1
   106 label *label39
   107 print "\n"
-    * label *label32
-    * label *label19
-    * label *label17
   108 jump *label13 always
   109 label *label10
   110 wait 1e12
   111 jump *label9 always
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-18 instructions):
 
    11 label *label13
    12 ubind @poly
    13 jump *label16 notEqual @unit .builder
-    * print "Found builder unit."
-    * print "\n"
+   14 print "Found builder unit.\n"
    15 printflush message1
    16 jump *label13 always
    17 label *label16
    18 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   19 print "Unit flag: {0}\n"
+   20 format :backgroundProcess:flag
    21 jump *label18 notEqual :backgroundProcess:flag 0
    22 sensor *tmp11 @unit @firstItem
    23 jump *label21 equal *tmp11 null
    24 ucontrol itemDrop @air 30
    25 sensor *tmp14 @unit @firstItem
    26 jump *label23 equal *tmp14 null
-    * print "Holding wrong item."
-    * print "\n"
+   27 print "Holding wrong item.\n"
    28 jump *label13 always
    29 label *label23
    30 label *label21
 
    41 ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor
    42 jump *label27 notEqual :findOreToMine:floor @ore-coal
    43 ucontrol mine :findOreToMine:x :findOreToMine:y
-    * print "Found coal at "
-    * print .coalX
-    * print ","
-    * print " "
-    * print .coalY
-    * print "\n"
+   44 print "Found coal at {0}, {0}\n"
+   45 format .coalX
+   46 format .coalY
    47 ucontrol flag 2
    48 jump *label13 always
    49 label *label27
    50 jump *label29 equal :findOreToMine:floor null
    51 set .distance 1000000000
-    * print "Coal at "
-    * print .coalX
-    * print ","
-    * print " "
-    * print .coalY
-    * print " "
-    * print "disappeared"
-    * print "\n"
+   52 print "Coal at {0}, {0} disappeared\n"
+   53 format .coalX
+   54 format .coalY
    55 jump *label13 always
    56 label *label29
-    * print "Not close enough to "
-    * print .coalX
-    * print ","
-    * print " "
-    * print .coalY
-    * print "\n"
+   57 print "Not close enough to {0}, {0}\n"
+   58 format .coalX
+   59 format .coalY
    60 jump *label13 always
    61 label *label18
    62 jump *label31 notEqual :backgroundProcess:flag 1
-    * print "Returning"
-    * print "\n"
+   63 print "Returning\n"
    64 ucontrol approach .coreX .coreY 6
    65 ucontrol itemDrop .core 30
    66 sensor *tmp32 @unit @firstItem
    67 jump *label13 notEqual *tmp32 null
-    * print "    Finished"
-    * print "\n"
+   68 print "    Finished\n"
    69 ucontrol flag 0
    70 jump *label13 always
    71 label *label31
 
    75 print " (dropping)"
    76 ucontrol itemDrop @air 30
    77 label *label37
-    * print " at "
-    * print .coalX
-    * print ","
-    * print " "
+   78 print " at {0}, "
+   79 format .coalX
    80 print .coalY
    81 ucontrol approach .coalX .coalY 6
    82 ucontrol mine .coalX .coalY

Final code before resolving virtual instructions:

    0:  jump *label41 always 0 0
    1:  draw triangle message1 .builder .coalX .coalY .core .coreX
    2:  draw triangle .coreY .distance :backgroundProcess:flag :findOreToMine:dist :findOreToMine:floor :findOreToMine:x
    3:  draw triangle :findOreToMine:y 0 0 0 0 0
        label *label41
    4:  set .coalX 0                                                 var
    5:  set .coalY 0                                                 ...
    6:  set .distance 1000000000                                     ...
        label *label6                                                do
    7:  ubind @poly                                                  builder = ubind(@poly);
    8:  set .builder @unit                                           ...
    9:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   10:  jump *label6 equal .core null                                do
   11:  set *signature "0:v1"                                        #set target = 8;
        label *label9                                                ...
   12:  jump *label10 equal .core null                               if core == null then return; end;
        label *label13                                               while true do
   13:  ubind @poly                                                  ubind(@poly);
   14:  jump *label16 notEqual @unit .builder                        if @unit == builder then
   15:  print "Found builder unit.\n"                                println("Found builder unit.");
   16:  printflush message1                                          printflush(message1);
   17:  jump *label13 always 0 0                                     if @unit == builder then
        label *label16                                               ...
   18:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   19:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   20:  format :backgroundProcess:flag                               ...
   21:  jump *label18 notEqual :backgroundProcess:flag 0             if flag == 0 then
   22:  sensor *tmp11 @unit @firstItem                               if @unit.@firstItem != null then
   23:  jump *label21 equal *tmp11 null                              ...
   24:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
   25:  sensor *tmp14 @unit @firstItem                               if @unit.@firstItem != null then
   26:  jump *label23 equal *tmp14 null                              ...
   27:  print "Holding wrong item.\n"                                println($"Holding wrong item.");
   28:  jump *label13 always 0 0                                     return;
        label *label23                                               if @unit.@firstItem != null then
        label *label21                                               if @unit.@firstItem != null then
   29:  ulocate ore core true @coal :findOreToMine:x :findOreToMine: ulocate(:ore, @coal, out x, out y);
   30:  op sub *tmp19 :findOreToMine:x .coreX                        var dist = len(x - coreX, y - coreY);
   31:  op sub *tmp20 :findOreToMine:y .coreY                        ...
   32:  op len :findOreToMine:dist *tmp19 *tmp20                     ...
   33:  jump *label25 greaterThanEq :findOreToMine:dist .distance    if dist < distance then
   34:  set .coalX :findOreToMine:x                                  coalX = x;
   35:  set .coalY :findOreToMine:y                                  coalY = y;
   36:  set .distance :findOreToMine:dist                            distance = dist;
        label *label25                                               if dist < distance then
   37:  ucontrol approach .coalX .coalY 6 0 0                        approach(coalX, coalY, RADIUS);
   38:  ucontrol getBlock .coalX .coalY 0 0 :findOreToMine:floor     getBlock(coalX, coalY, , out floor);
   39:  jump *label27 notEqual :findOreToMine:floor @ore-coal        if floor == @ore-coal then
   40:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   41:  print "Found coal at {0}, {0}\n"                             println($"Found coal at $coalX, $coalY");
   42:  format .coalX                                                ...
   43:  format .coalY                                                ...
   44:  ucontrol flag 2 0 0 0 0                                      flag(2);
   45:  jump *label13 always 0 0                                     if floor == @ore-coal then
        label *label27                                               ...
   46:  jump *label29 equal :findOreToMine:floor null                elsif floor != null
   47:  set .distance 1000000000                                     then distance = 1e9;
   48:  print "Coal at {0}, {0} disappeared\n"                       println($"Coal at $coalX, $coalY disappeared");
   49:  format .coalX                                                ...
   50:  format .coalY                                                ...
   51:  jump *label13 always 0 0                                     elsif floor != null
        label *label29                                               ...
   52:  print "Not close enough to {0}, {0}\n"                       println($"Not close enough to $coalX, $coalY");
   53:  format .coalX                                                ...
   54:  format .coalY                                                ...
   55:  jump *label13 always 0 0                                     if flag == 0 then
        label *label18                                               ...
   56:  jump *label31 notEqual :backgroundProcess:flag 1             elsif flag == 1 then
   57:  print "Returning\n"                                          println("Returning");
   58:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   59:  ucontrol itemDrop .core 30 0 0 0                             itemDrop(core, CAPACITY);
   60:  sensor *tmp32 @unit @firstItem                               if @unit.@firstItem == null then
   61:  jump *label13 notEqual *tmp32 null                           ...
   62:  print "    Finished\n"                                       println("    Finished");
   63:  ucontrol flag 0 0 0 0 0                                      flag(0);
   64:  jump *label13 always 0 0                                     elsif flag == 1 then
        label *label31                                               ...
   65:  print "Mining"                                               print("Mining");
   66:  sensor *tmp35 @unit @firstItem                               if @unit.@firstItem != @coal then
   67:  jump *label37 equal *tmp35 @coal                             ...
   68:  print " (dropping)"                                          print(" (dropping)");
   69:  ucontrol itemDrop @air 30 0 0 0                              itemDrop(@air, CAPACITY);
        label *label37                                               if @unit.@firstItem != @coal then
   70:  print " at {0}, "                                            print($" at $coalX, $coalY");
   71:  format .coalX                                                ...
   72:  print .coalY                                                 ...
   73:  ucontrol approach .coalX .coalY 6 0 0                        approach(coalX, coalY, RADIUS);
   74:  ucontrol mine .coalX .coalY 0 0 0                            mine(coalX, coalY);
   75:  sensor *tmp38 @unit @totalItems                              if @unit.@totalItems >= CAPACITY then
   76:  jump *label39 lessThan *tmp38 30                             ...
   77:  print ", full"                                               print(", full");
   78:  ucontrol approach .coreX .coreY 6 0 0                        approach(coreX, coreY, RADIUS);
   79:  ucontrol flag 1 0 0 0 0                                      flag(1);
        label *label39                                               if @unit.@totalItems >= CAPACITY then
   80:  print "\n"                                                   println();
   81:  jump *label13 always 0 0                                     while true do
        label *label10                                               #set target = 8;
   82:  wait 1e12                                                    ...
   83:  jump *label9 always 0 0                                      ...


Performance: parsed in 230 ms, compiled in 313 ms, optimized in 157 ms, run in 4 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (5 steps):
The program didn't generate any output.
Execution exception at instruction 7: ubind @poly:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
