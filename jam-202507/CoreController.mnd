#set target = 8;
#set syntax = strict;
//#set sort-variables;

// Note: remake this so that status gets updated via remote calls

module CoreController;

noinit remote var display;

require "Common.mnd";
require "Display.mnd" remote display;

noinit remote var
    timer,
    core,
    bank,

    // Lead and/or silicone will only be sent to the Air Factory
    // if they are above these limits
    leadReserve,
    siliconReserve,
    graphiteReserve,

    factoryUnit,
    targetUnit,
    loopTicks;

remote var
    flares = 0,
    monos = 0,
    polys= 1,
    megas = 0,

    pressTarget = 20,
    smelterTarget = 20,
    kilnTarget = 20,
    flareTarget = 0,
    monoTarget = 0,
    polyTarget = 0,
    megaTarget = 0;

external bank[511] var logPosition;

void log(encodedId)
    bank[--logPosition] = encodedId + timer.read("time") * 1000;
end;

void logUnit(unit)
    log(@blockCount + unit.@id);
end;

var factoryDone = 0;

void factoryUnitFinished(unit)
    // Do not announce when the
    if unit == targetUnit then
        logUnit(unit);
        case unit
            when @flare then display.flares = ++flares;
            when @mono  then display.monos = ++monos;
            when @poly  then display.polys = ++polys;
            when @mega  then display.megas = ++megas;
        end;
        display.unitReset = true;
        factoryDone = 0;
    else
        case unit
            when @flare, @mono then factoryDone = 1;
        end;
    end;
end;

inline def updateIfSmaller(ref value, in a, in b, in newValue)
    mlogSafe("select", out value, "lessThan", in a, in b, in newValue, in value);
end;

inline def fuzzyUpdate(ref state, in value, in limitLow, in limitHigh)
    updateIfSmaller(ref state, value, limitLow, false);
    updateIfSmaller(ref state, limitHigh, value, true);
end;

void backgroundProcess()
    var lastProgress = 0, factoryProgress = 0;
    var lastRecoProgress = 0, reconstructorProgress = 0;
    var lastMultiProgress = 0, multiReconstructorProgress = 0;
    var enableFactory = true, blockFactory = false;

    while true do
        var ticks = @tick;
        var coreSilicon = core.@silicon;
        var coreGraphite = core.@graphite;
        smelter2.enabled = smelter.enabled = coreSilicon < smelterTarget;
        press.enabled = !multipress and coreGraphite < pressTarget;
        multipress.enabled = coreGraphite < pressTarget;
        kiln.enabled = core.@metaglass < kilnTarget;

        var power = battery1.@totalPower;
        if steam_gen then
            generator.enabled = power < 10;
            steam_gen.enabled = power < 3800;
        else
            generator.enabled = power < 800;
        end;

        factoryProgress = air_factory.@progress;
        reconstructorProgress = additive_rec.@progress;
        multiReconstructorProgress = multiplicative_rec.@progress;

        if flares < flareTarget then
            display.nextUnit = targetUnit = factoryUnit = @flare;
            payload_router.config = targetUnit;
            blockFactory = false;
        elsif monos < monoTarget then
            display.nextUnit = targetUnit = factoryUnit = @mono;
            payload_router.config = targetUnit;
            blockFactory = false;
        elsif polys < polyTarget then
            factoryUnit = factoryDone + polys < polyTarget ? @mono : null;
            display.nextUnit = targetUnit = @poly;
            additive_rec.enabled = true;
            payload_router.config = targetUnit;
            blockFactory = additive_rec.@payloadCount * factoryProgress > reconstructorProgress;
        elsif megas < megaTarget then
            factoryUnit = factoryDone + megas < megaTarget ? @mono : null;
            display.nextUnit = targetUnit = @mega;
            additive_rec.enabled = multiplicative_rec or reconstructorProgress < 0.75;
            payload_router.config = targetUnit;
            blockFactory = false;
        else
            display.nextUnit = targetUnit = factoryUnit = null;
            blockFactory = false;
        end;

        fuzzyUpdate(ref enableFactory, power, 200, 500);

        if factoryUnit == null then
            air_factory.enabled = false;
            air_factory.config = @mono;
            lastProgress = 0;
        elsif lastProgress > factoryProgress + 0.1 then
            air_factory.enabled = enableFactory and not blockFactory;
            factoryUnitFinished(factoryUnit);
            lastProgress = 0;
        elsif air_factory.config != factoryUnit then
            air_factory.enabled = enableFactory and not blockFactory;
            air_factory.config = factoryUnit;
            lastProgress = 0;
        else
            air_factory.enabled = enableFactory and not blockFactory;
            lastProgress = factoryProgress;
        end;

        if lastRecoProgress > reconstructorProgress + 0.1 then
            factoryUnitFinished(@poly);
            lastRecoProgress = 0;
        else
            lastRecoProgress = reconstructorProgress;
        end;

        if lastMultiProgress > multiReconstructorProgress + 0.1 then
            factoryUnitFinished(@mega);
            lastMultiProgress = 0;
        else
            lastMultiProgress = multiReconstructorProgress;
        end;

        if steam_gen.@coal < 5 * steam_gen then
            unloader2.config = @coal;
            continue;
        end;

        unloader4.enabled = coreSilicon > siliconReserve and coreGraphite > graphiteReserve;

        var leadLimit = (factoryUnit == @mono) * 30;
        if air_factory.@lead < leadLimit and core.@lead > leadReserve then
            unloader2.config = @lead;
        elsif coreSilicon > siliconReserve then
            unloader2.config = @silicon;
        else
            unloader2.config = @coal;
        end;

        unloader6.config = multiplicative_rec.@silicon >= 130 and multiplicative_rec.@titanium < 80 ? @titanium : @silicon;

        loopTicks = @tick - ticks;
    end;
end;
