#set target = 8;
#set syntax = strict;
//#set sort-variables;

// Note: remake this so that status gets updated via remote calls

module CoreController;

noinit remote var display;

require "Common.mnd";
require "Display.mnd" remote display;

noinit remote var
    timer,
    core,
    bank,

    // Lead and/or silicone will only be sent to the Air Factory
    // if they are above these limits
    leadReserve,
    siliconReserve,
    graphiteReserve,
    loopTicks;

remote var
    finished = false,
    flares = 0,
    monos = 0,
    polys= 1,
    megas = 0,

    pressTarget = 20,
    smelterTarget = 20,
    kilnTarget = 20,
    flareTarget = 0,
    monoTarget = 0,
    polyTarget = 0,
    megaTarget = 0,
    powerTarget = 1009;

external bank[511] var logPosition;

void log(encodedId)
    bank[--logPosition] = encodedId + timer.read("time") * 1000;
end;

void logUnit(unit)
    log(@blockCount + unit.@id);
end;

void factoryUnitFinished(unit)
    logUnit(unit);
    case unit
        when @flare then display.flares = ++flares;
        when @mono  then display.monos = ++monos;
        when @poly  then display.polys = ++polys;
        when @mega  then display.megas = ++megas;
    end;
end;

inline void handleAirFactory(unit, power, silicon, lead, ref lastProgress)
    if !canConsume then
        unloader2.config = @coal;
        return;
    end;

    if steam_gen.@coal < 5 * steam_gen then
        unloader2.config = @coal;
        return;
    end;

    if power < 200 then
        air_factory.enabled = false;
    elsif power > 500 then
        air_factory.enabled = true;
    end;

    air_factory.config = unit;

    var factoryProgress = air_factory.@progress;
    if lastProgress > factoryProgress then
        factoryUnitFinished(unit);
        lastProgress = 0;
        unloader2.config = @coal;
        return;
    end;

    lastProgress = factoryProgress;

    if lead then
        var leadLimit = core.@lead > 0 ? lead : 0;
        if air_factory.@lead < leadLimit then
            unloader2.config = @lead;
            return;
        end;
    end;

    var siliconLimit = core.@silicon > 0 ? silicon : 0;
    unloader2.config = air_factory.@silicon < siliconLimit ? @silicon : @coal;
end;

volatile var lastProgress = 0, lastRecoProgress = 0, lastMultiProgress = 0;
volatile var recoEntered = false;
volatile var canConsume = true;

remote void buildStart()
    unloader2.config = @coal;
    inverted_sort4.enabled = false;
    canConsume = false;
end;

remote void buildStop()
    canConsume = true;
end;

var airFactoryTarget = null;

void backgroundProcess()
    while !finished do
        var ticks = @tick;
        var coreSilicon = core.@silicon;
        var coreGraphite = core.@graphite;
        smelter2.enabled = smelter.enabled = coreSilicon < smelterTarget;
        press.enabled = !multipress and coreGraphite < pressTarget;
        multipress.enabled = coreGraphite < pressTarget;
        kiln.enabled = core.@metaglass < kilnTarget;

        var power = battery1.@totalPower;
        if steam_gen then
            generator.enabled = power < 9;
            steam_gen.enabled = power < powerTarget;
        else
            generator.enabled = power < 809;
        end;

        if flares < flareTarget and airFactoryTarget != @mono then
            display.nextFactory = airFactoryTarget = @flare;
            handleAirFactory(@flare, power, 15, 0, ref lastProgress);
        elsif monos < monoTarget and airFactoryTarget != @flare then
            display.nextFactory = airFactoryTarget = @mono;
            handleAirFactory(@mono, power, 30, 15, ref lastProgress);
        else
            display.nextFactory = airFactoryTarget = null;
            air_factory.config = @flare;
            unloader2.config = @coal;
        end;

        if polys < polyTarget then
            display.nextAddReco = @poly;

            var recoProgress = additive_rec.@progress;
            if lastRecoProgress > recoProgress then
                factoryUnitFinished(@poly);
                recoEntered = false;
                lastRecoProgress = 0;
            else
                lastRecoProgress = recoProgress;
            end;

            var s = additive_rec.@silicon;
            var g = additive_rec.@graphite;
            if s >= 40 and g >= 40 then
                if not recoEntered then
                    var x = additive_rec.@x;
                    var y = additive_rec.@y;
                    ubind(@mono);
                    do
                        move(x, y);
                        payEnter();
                    while !@unit.@dead;
                    display.monos = --monos;
                    recoEntered = true;
                end;
                inverted_sort4.enabled = false;
            elsif s < 40 * (coreSilicon > siliconReserve) then
                unloader4.config = @silicon;
                inverted_sort4.enabled = canConsume;
            elsif g < 40 * (coreGraphite > graphiteReserve) then
                unloader4.config = @graphite;
                inverted_sort4.enabled = canConsume;
            else
                inverted_sort4.enabled = false;
            end;
        else
            display.nextAddReco = null;
            inverted_sort4.enabled = false;
        end;

        if multiplicative_rec then
            display.nextMultiReco = @mega;
            var c = null;
            if multiplicative_rec.@metaglass < 40 then
                c = @metaglass;
            elsif core.@titanium and multiplicative_rec.@titanium < 80 then
                c = @titanium;
            else
                c = @silicon;
            end;
            unloader3.config = c;
            unloader4.config = c;

            var multiProgress = multiplicative_rec.@progress;
            if lastMultiProgress > multiProgress then
                display.nextMultiReco = null;
                factoryUnitFinished(@mega);
                lastMultiProgress = 0;
            else
                lastMultiProgress = multiProgress;
            end;
        end;

        loopTicks = @tick - ticks;
    end;
end;
