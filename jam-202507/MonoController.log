   257 instructions before optimizations.
    14 instructions eliminated by Temp Variables Elimination (2 passes, 6 iterations).
    37 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    24 instructions eliminated by Jump Optimization (5 iterations).
    10 instructions eliminated by Single Step Elimination (6 iterations).
    21 instructions eliminated by If Expression Optimization (6 iterations).
     7 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     1 instructions eliminated by Jump Straightening (5 iterations).
     5 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   126 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-23 instructions):
 
    23 jump *label12 equal *tmp4 false
    24 set *tmp6 @unit
    25 set :backgroundProcess:firstItem *tmp6
-    * set *tmp5 :backgroundProcess:firstItem
    26 jump *label13 always
    27 label *label12
-    * set *tmp5 null
    28 label *label13
    29 op equal *tmp7 @unit :backgroundProcess:firstItem
    30 jump *label14 equal *tmp7 false
 
    62 op land *tmp23 *tmp22 .scrap
    63 jump *label20 equal *tmp23 false
    64 set .minOre @scrap
-    * set *tmp24 .minOre
    65 jump *label21 always
    66 label *label20
-    * set *tmp24 null
    67 label *label21
    68 print "minOre:"
    69 print .minOre
 
    71 op lessThan *tmp25 .min 10
    72 jump *label22 equal *tmp25 false
    73 set .min -100
-    * set *tmp26 .min
    74 jump *label23 always
    75 label *label22
    76 op add .min .min 100
-    * set *tmp26 .min
    77 label *label23
    78 set .count :backgroundProcess:newCount
    79 set :backgroundProcess:newCount 2
 
    81 set .sandX *tmp27
    82 sensor *tmp28 .sandContainer @y
    83 set .sandY *tmp28
-    * set *tmp8 .sandY
    84 jump *label15 always
    85 label *label14
-    * set *tmp8 null
    86 label *label15
-    * set *tmp29 :backgroundProcess:newCount
    87 op add :backgroundProcess:newCount :backgroundProcess:newCount 1
    88 sensor *tmp30 @unit @flag
    89 set :backgroundProcess:flag *tmp30
 
   106 label *label29
   107 set *tmp38 null
   108 label *label30
-    * set *tmp35 *tmp38
   109 jump *label28 always
   110 label *label27
-    * set *tmp35 null
   111 label *label28
   112 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp39 *tmp40
   113 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
   129 print :findOreToMine:y
   130 print "\n"
   131 label *label26
-    * set *tmp32 null
   132 jump *label25 always
   133 label *label24
   134 op equal *tmp47 :backgroundProcess:flag 1
 
   139 jump *label34 equal *tmp50 false
   140 ucontrol approach .sandX .sandY 7
   141 ucontrol itemDrop .sandContainer 20
-    * set *tmp51 null
   142 jump *label35 always
   143 label *label34
   144 ucontrol approach .coreX .coreY 7
   145 ucontrol itemDrop .core 20
-    * set *tmp51 null
   146 label *label35
   147 sensor *tmp52 @unit @firstItem
   148 op equal *tmp53 *tmp52 null
 
   150 print " (finished)"
   151 print "\n"
   152 ucontrol flag 0
-    * set *tmp54 null
   153 jump *label37 always
   154 label *label36
-    * set *tmp54 null
   155 label *label37
   156 print "\n"
   157 label *label33
 
   220 label *label49
   221 set *tmp71 null
   222 label *label50
-    * set *tmp69 *tmp71
   223 jump *label48 always
   224 label *label47
-    * set *tmp69 null
   225 label *label48
   226 sensor *tmp75 @unit @totalItems
   227 set :mine:items *tmp75
 
   231 jump *label53 equal *tmp77 false
   232 print " (dropping)"
   233 ucontrol itemDrop @air 20
-    * set *tmp78 null
   234 jump *label54 always
   235 label *label53
-    * set *tmp78 null
   236 label *label54
   237 op greaterThanEq *tmp79 :mine:items :mine:oreCapacity
   238 jump *label55 equal *tmp79 false
   239 print ", full"
   240 ucontrol approach .coreX .coreY 7
   241 ucontrol flag 1
-    * set *tmp80 null
   242 jump *label56 always
   243 label *label55
   244 set :mine:floor null
 
   280 label *label62
   281 set *tmp84 *tmp88
   282 label *label58
-    * set *tmp80 *tmp84
   283 label *label56
   284 print "\n"
   285 label *label38
   286 set *tmp48 null
   287 label *label32
-    * set *tmp32 *tmp48
   288 label *label25
   289 label *label10
   290 jump *label9 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-8 instructions):
 
   101 op notEqual *tmp37 *tmp36 null
   102 jump *label29 equal *tmp37 false
   103 jump *label26 always
-    * set *tmp38 null
   104 jump *label30 always
   105 label *label29
-    * set *tmp38 null
   106 label *label30
   107 jump *label28 always
   108 label *label27
 
   153 label *label37
   154 print "\n"
   155 label *label33
-    * set *tmp48 null
   156 jump *label32 always
   157 label *label31
   158 set :mine:flag :backgroundProcess:flag
 
   212 label *label51
   213 set *tmp74 null
   214 label *label52
-    * set *tmp71 *tmp74
   215 jump *label50 always
   216 label *label49
-    * set *tmp71 null
   217 label *label50
   218 jump *label48 always
   219 label *label47
 
   259 print "\n"
   260 set *tmp86 ": no ore!"
   261 label *label60
-    * set *tmp84 *tmp86
   262 jump *label58 always
   263 label *label57
   264 op equal *tmp87 :mine:block null
 
   272 print "\n"
   273 set *tmp88 ": blocked!"
   274 label *label62
-    * set *tmp84 *tmp88
   275 label *label58
   276 label *label56
   277 print "\n"
   278 label *label38
-    * set *tmp48 null
   279 label *label32
   280 label *label25
   281 label *label10

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-6 instructions):
 
   207 print ", switching to a more needed ore"
   208 ucontrol flag 1
   209 jump *label38 always
-    * set *tmp74 null
   210 jump *label52 always
   211 label *label51
-    * set *tmp74 null
   212 label *label52
   213 jump *label50 always
   214 label *label49
 
   249 jump *label59 equal *tmp85 false
   250 print ": too far"
   251 print "\n"
-    * set *tmp86 ": too far"
   252 jump *label60 always
   253 label *label59
   254 ucontrol flag 1
   255 print ": no ore!"
   256 print "\n"
-    * set *tmp86 ": no ore!"
   257 label *label60
   258 jump *label58 always
   259 label *label57
   260 op equal *tmp87 :mine:block null
   261 jump *label61 equal *tmp87 false
   262 ucontrol mine :mine:x :mine:y
-    * set *tmp88 null
   263 jump *label62 always
   264 label *label61
   265 ucontrol flag 1
   266 print ": blocked!"
   267 print "\n"
-    * set *tmp88 ": blocked!"
   268 label *label62
   269 label *label58
   270 label *label56

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-14 instructions):
 
     9 label *label5
    10 set :backgroundProcess:firstItem @unit
    11 label *label6
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   12 ulocate building core false @copper .coreX .coreY *tmp2 .core
    13 label *label7
    14 op equal *tmp3 .core null
    15 jump *label6 notEqual *tmp3 false
 
    20 ubind @mono
    21 sensor *tmp4 :backgroundProcess:firstItem @dead
    22 jump *label12 equal *tmp4 false
-    * set *tmp6 @unit
-    * set :backgroundProcess:firstItem *tmp6
+   23 set :backgroundProcess:firstItem @unit
    24 jump *label13 always
    25 label *label12
    26 label *label13
 
    28 jump *label14 equal *tmp7 false
    29 printflush message1
    30 sensor *tmp9 .core @lead
-    * op sub *tmp10 *tmp9 .leadTarget
-    * set :backgroundProcess:lead *tmp10
+   31 op sub :backgroundProcess:lead *tmp9 .leadTarget
    32 sensor *tmp11 .sandContainer @sand
    33 sensor *tmp12 .sandContainer @scrap
    34 op add *tmp13 *tmp11 *tmp12
-    * op sub *tmp14 *tmp13 .sandTarget
-    * set :backgroundProcess:sand *tmp14
+   35 op sub :backgroundProcess:sand *tmp13 .sandTarget
    36 sensor *tmp15 .core @copper
-    * op sub *tmp16 *tmp15 .copperTarget
-    * set :backgroundProcess:copper *tmp16
+   37 op sub :backgroundProcess:copper *tmp15 .copperTarget
    38 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    39 op min *tmp17 *tmp17 :backgroundProcess:copper
    40 set .min *tmp17
 
    72 label *label23
    73 set .count :backgroundProcess:newCount
    74 set :backgroundProcess:newCount 2
-    * sensor *tmp27 .sandContainer @x
-    * set .sandX *tmp27
-    * sensor *tmp28 .sandContainer @y
-    * set .sandY *tmp28
+   75 sensor .sandX .sandContainer @x
+   76 sensor .sandY .sandContainer @y
    77 jump *label15 always
    78 label *label14
    79 label *label15
    80 op add :backgroundProcess:newCount :backgroundProcess:newCount 1
-    * sensor *tmp30 @unit @flag
-    * set :backgroundProcess:flag *tmp30
+   81 sensor :backgroundProcess:flag @unit @flag
    82 print "Unit flag: "
    83 print :backgroundProcess:flag
    84 print "\n"
 
   151 print "Mining x"
   152 op idiv :mine:flag :mine:flag 2
   153 op mod *tmp55 :mine:flag 16
-    * lookup item *tmp56 *tmp55
-    * set :mine:ore *tmp56
+  154 lookup item :mine:ore *tmp55
   155 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp57 :mine:flag 1000
-    * set :mine:y *tmp57
-    * op idiv *tmp58 :mine:flag 1000
-    * set :mine:x *tmp58
+  156 op mod :mine:y :mine:flag 1000
+  157 op idiv :mine:x :mine:flag 1000
   158 op equal *tmp59 :mine:ore @copper
   159 jump *label39 equal *tmp59 false
   160 set *tmp60 @ore-copper
 
   179 set :mine:floorOre *tmp60
   180 op equal *tmp65 :mine:ore @scrap
   181 jump *label45 equal *tmp65 false
-    * op sub *tmp67 20 .count
-    * set *tmp66 *tmp67
+  182 op sub *tmp66 20 .count
   183 jump *label46 always
   184 label *label45
   185 set *tmp66 20
 
   204 jump *label48 always
   205 label *label47
   206 label *label48
-    * sensor *tmp75 @unit @totalItems
-    * set :mine:items *tmp75
+  207 sensor :mine:items @unit @totalItems
   208 print :mine:items
   209 sensor *tmp76 @unit @firstItem
   210 op notEqual *tmp77 *tmp76 :mine:ore
 
   228 print " "
   229 print :mine:y
   230 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp82 *tmp81 :mine:floor
-    * set :mine:block *tmp81
+  231 ucontrol getBlock :mine:x :mine:y *tmp82 :mine:block :mine:floor
   232 op notEqual *tmp83 :mine:floor :mine:floorOre
   233 jump *label57 equal *tmp83 false
   234 op equal *tmp85 :mine:floor null

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    16 label *label8
    17 set :backgroundProcess:newCount 0
    18 label *label9
-    * jump *label11 equal true false
    19 ubind @mono
    20 sensor *tmp4 :backgroundProcess:firstItem @dead
    21 jump *label12 equal *tmp4 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-24 instructions):
 
     4 label *label3
     5 ubind @mono
     6 label *label4
-    * op equal *tmp0 @unit null
-    * jump *label3 notEqual *tmp0 false
+    7 jump *label3 equal @unit null
     8 label *label5
     9 set :backgroundProcess:firstItem @unit
    10 label *label6
    11 ulocate building core false @copper .coreX .coreY *tmp2 .core
    12 label *label7
-    * op equal *tmp3 .core null
-    * jump *label6 notEqual *tmp3 false
+   13 jump *label6 equal .core null
    14 label *label8
    15 set :backgroundProcess:newCount 0
    16 label *label9
 
    21 jump *label13 always
    22 label *label12
    23 label *label13
-    * op equal *tmp7 @unit :backgroundProcess:firstItem
-    * jump *label14 equal *tmp7 false
+   24 jump *label14 notEqual @unit :backgroundProcess:firstItem
    25 printflush message1
    26 sensor *tmp9 .core @lead
    27 op sub :backgroundProcess:lead *tmp9 .leadTarget
 
    34 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    35 op min *tmp17 *tmp17 :backgroundProcess:copper
    36 set .min *tmp17
-    * op equal *tmp18 .min :backgroundProcess:sand
-    * jump *label16 equal *tmp18 false
+   37 jump *label16 notEqual .min :backgroundProcess:sand
    38 set *tmp19 @sand
    39 jump *label17 always
    40 label *label16
-    * op equal *tmp20 .min :backgroundProcess:lead
-    * jump *label18 equal *tmp20 false
+   41 jump *label18 notEqual .min :backgroundProcess:lead
    42 set *tmp21 @lead
    43 jump *label19 always
    44 label *label18
 
    57 print "minOre:"
    58 print .minOre
    59 print "\n"
-    * op lessThan *tmp25 .min 10
-    * jump *label22 equal *tmp25 false
+   60 jump *label22 greaterThanEq .min 10
    61 set .min -100
    62 jump *label23 always
    63 label *label22
 
    75 print "Unit flag: "
    76 print :backgroundProcess:flag
    77 print "\n"
-    * op equal *tmp31 :backgroundProcess:flag 0
-    * jump *label24 equal *tmp31 false
+   78 jump *label24 notEqual :backgroundProcess:flag 0
    79 set :findOreToMine:ore .minOre
    80 sensor *tmp33 @unit @firstItem
-    * op notEqual *tmp34 *tmp33 null
-    * jump *label27 equal *tmp34 false
+   81 jump *label27 equal *tmp33 null
    82 ucontrol itemDrop @air 20
    83 sensor *tmp36 @unit @firstItem
-    * op notEqual *tmp37 *tmp36 null
-    * jump *label29 equal *tmp37 false
+   84 jump *label29 equal *tmp36 null
    85 jump *label26 always
    86 jump *label30 always
    87 label *label29
 
   111 label *label26
   112 jump *label25 always
   113 label *label24
-    * op equal *tmp47 :backgroundProcess:flag 1
-    * jump *label31 equal *tmp47 false
+  114 jump *label31 notEqual :backgroundProcess:flag 1
   115 print "Returning ore"
   116 sensor *tmp49 @unit @firstItem
-    * op equal *tmp50 *tmp49 @scrap
-    * jump *label34 equal *tmp50 false
+  117 jump *label34 notEqual *tmp49 @scrap
   118 ucontrol approach .sandX .sandY 7
   119 ucontrol itemDrop .sandContainer 20
   120 jump *label35 always
 
   123 ucontrol itemDrop .core 20
   124 label *label35
   125 sensor *tmp52 @unit @firstItem
-    * op equal *tmp53 *tmp52 null
-    * jump *label36 equal *tmp53 false
+  126 jump *label36 notEqual *tmp52 null
   127 print " (finished)"
   128 print "\n"
   129 ucontrol flag 0
 
   142 op idiv :mine:flag :mine:flag 16
   143 op mod :mine:y :mine:flag 1000
   144 op idiv :mine:x :mine:flag 1000
-    * op equal *tmp59 :mine:ore @copper
-    * jump *label39 equal *tmp59 false
+  145 jump *label39 notEqual :mine:ore @copper
   146 set *tmp60 @ore-copper
   147 jump *label40 always
   148 label *label39
-    * op equal *tmp61 :mine:ore @scrap
-    * jump *label41 equal *tmp61 false
+  149 jump *label41 notEqual :mine:ore @scrap
   150 set *tmp62 @ore-scrap
   151 jump *label42 always
   152 label *label41
-    * op equal *tmp63 :mine:ore @lead
-    * jump *label43 equal *tmp63 false
+  153 jump *label43 notEqual :mine:ore @lead
   154 set *tmp64 @ore-lead
   155 jump *label44 always
   156 label *label43
 
   161 set *tmp60 *tmp62
   162 label *label40
   163 set :mine:floorOre *tmp60
-    * op equal *tmp65 :mine:ore @scrap
-    * jump *label45 equal *tmp65 false
+  164 jump *label45 notEqual :mine:ore @scrap
   165 op sub *tmp66 20 .count
   166 jump *label46 always
   167 label *label45
   168 set *tmp66 20
   169 label *label46
   170 set :mine:oreCapacity *tmp66
-    * op notEqual *tmp68 :mine:ore @scrap
-    * jump *label47 equal *tmp68 false
-    * op notEqual *tmp70 :mine:ore .minOre
-    * jump *label49 equal *tmp70 false
+  171 jump *label47 equal :mine:ore @scrap
+  172 jump *label49 equal :mine:ore .minOre
   173 sensor *tmp72 .core :mine:ore
-    * op greaterThan *tmp73 *tmp72 .min
-    * jump *label51 equal *tmp73 false
+  174 jump *label51 lessThanEq *tmp72 .min
   175 print ", switching to a more needed ore"
   176 ucontrol flag 1
   177 jump *label38 always
 
   187 sensor :mine:items @unit @totalItems
   188 print :mine:items
   189 sensor *tmp76 @unit @firstItem
-    * op notEqual *tmp77 *tmp76 :mine:ore
-    * jump *label53 equal *tmp77 false
+  190 jump *label53 equal *tmp76 :mine:ore
   191 print " (dropping)"
   192 ucontrol itemDrop @air 20
   193 jump *label54 always
   194 label *label53
   195 label *label54
-    * op greaterThanEq *tmp79 :mine:items :mine:oreCapacity
-    * jump *label55 equal *tmp79 false
+  196 jump *label55 lessThan :mine:items :mine:oreCapacity
   197 print ", full"
   198 ucontrol approach .coreX .coreY 7
   199 ucontrol flag 1
 
   207 print :mine:y
   208 ucontrol approach :mine:x :mine:y 7
   209 ucontrol getBlock :mine:x :mine:y *tmp82 :mine:block :mine:floor
-    * op notEqual *tmp83 :mine:floor :mine:floorOre
-    * jump *label57 equal *tmp83 false
-    * op equal *tmp85 :mine:floor null
-    * jump *label59 equal *tmp85 false
+  210 jump *label57 equal :mine:floor :mine:floorOre
+  211 jump *label59 notEqual :mine:floor null
   212 print ": too far"
   213 print "\n"
   214 jump *label60 always
 
   219 label *label60
   220 jump *label58 always
   221 label *label57
-    * op equal *tmp87 :mine:block null
-    * jump *label61 equal *tmp87 false
+  222 jump *label61 notEqual :mine:block null
   223 ucontrol mine :mine:x :mine:y
   224 jump *label62 always
   225 label *label61

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-10 instructions):
 
    18 sensor *tmp4 :backgroundProcess:firstItem @dead
    19 jump *label12 equal *tmp4 false
    20 set :backgroundProcess:firstItem @unit
-    * jump *label13 always
    21 label *label12
    22 label *label13
    23 jump *label14 notEqual @unit :backgroundProcess:firstItem
 
    50 op land *tmp23 *tmp22 .scrap
    51 jump *label20 equal *tmp23 false
    52 set .minOre @scrap
-    * jump *label21 always
    53 label *label20
    54 label *label21
    55 print "minOre:"
 
    65 set :backgroundProcess:newCount 2
    66 sensor .sandX .sandContainer @x
    67 sensor .sandY .sandContainer @y
-    * jump *label15 always
    68 label *label14
    69 label *label15
    70 op add :backgroundProcess:newCount :backgroundProcess:newCount 1
 
    80 sensor *tmp36 @unit @firstItem
    81 jump *label29 equal *tmp36 null
    82 jump *label26 always
-    * jump *label30 always
    83 label *label29
    84 label *label30
-    * jump *label28 always
    85 label *label27
    86 label *label28
    87 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp39 *tmp40
 
   122 print " (finished)"
   123 print "\n"
   124 ucontrol flag 0
-    * jump *label37 always
   125 label *label36
   126 label *label37
   127 print "\n"
 
   169 print ", switching to a more needed ore"
   170 ucontrol flag 1
   171 jump *label38 always
-    * jump *label52 always
   172 label *label51
   173 label *label52
-    * jump *label50 always
   174 label *label49
   175 label *label50
-    * jump *label48 always
   176 label *label47
   177 label *label48
   178 sensor :mine:items @unit @totalItems
 
   181 jump *label53 equal *tmp76 :mine:ore
   182 print " (dropping)"
   183 ucontrol itemDrop @air 20
-    * jump *label54 always
   184 label *label53
   185 label *label54
   186 jump *label55 lessThan :mine:items :mine:oreCapacity

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    33 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    34 op min *tmp17 *tmp17 :backgroundProcess:copper
    35 set .min *tmp17
-    * jump *label16 notEqual .min :backgroundProcess:sand
+   36 jump *label16 notEqual *tmp17 :backgroundProcess:sand
    37 set *tmp19 @sand
    38 jump *label17 always
    39 label *label16
-    * jump *label18 notEqual .min :backgroundProcess:lead
+   40 jump *label18 notEqual *tmp17 :backgroundProcess:lead
    41 set *tmp21 @lead
    42 jump *label19 always
    43 label *label18
 
    46 set *tmp19 *tmp21
    47 label *label17
    48 set .minOre *tmp19
-    * op equal *tmp22 .minOre @sand
+   49 op equal *tmp22 *tmp19 @sand
    50 op land *tmp23 *tmp22 .scrap
    51 jump *label20 equal *tmp23 false
    52 set .minOre @scrap
 
    55 print "minOre:"
    56 print .minOre
    57 print "\n"
-    * jump *label22 greaterThanEq .min 10
+   58 jump *label22 greaterThanEq *tmp17 10
    59 set .min -100
    60 jump *label23 always
    61 label *label22
-    * op add .min .min 100
+   62 op add .min *tmp17 100
    63 label *label23
    64 set .count :backgroundProcess:newCount
    65 set :backgroundProcess:newCount 2
 
    84 label *label30
    85 label *label27
    86 label *label28
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp39 *tmp40
+   87 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp39 *tmp40
    88 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    89 ucontrol mine :findOreToMine:x :findOreToMine:y
    90 op mul *tmp41 :findOreToMine:x 1000
    91 op add *tmp42 *tmp41 :findOreToMine:y
    92 op mul *tmp43 *tmp42 32
-    * sensor *tmp44 :findOreToMine:ore @id
+   93 sensor *tmp44 .minOre @id
    94 op mul *tmp45 *tmp44 2
    95 op add *tmp46 *tmp43 *tmp45
    96 ucontrol flag *tmp46
    97 print "Found "
-    * print :findOreToMine:ore
+   98 print .minOre
    99 print " "
   100 print "at "
   101 print :findOreToMine:x
 
   130 label *label31
   131 set :mine:flag :backgroundProcess:flag
   132 print "Mining x"
-    * op idiv :mine:flag :mine:flag 2
+  133 op idiv :mine:flag :backgroundProcess:flag 2
   134 op mod *tmp55 :mine:flag 16
   135 lookup item :mine:ore *tmp55
   136 op idiv :mine:flag :mine:flag 16
 
   183 ucontrol itemDrop @air 20
   184 label *label53
   185 label *label54
-    * jump *label55 lessThan :mine:items :mine:oreCapacity
+  186 jump *label55 lessThan :mine:items *tmp66
   187 print ", full"
   188 ucontrol approach .coreX .coreY 7
   189 ucontrol flag 1
   190 jump *label56 always
   191 label *label55
-    * set :mine:floor null
   192 print " at "
   193 print :mine:x
   194 print ","
 
   196 print :mine:y
   197 ucontrol approach :mine:x :mine:y 7
   198 ucontrol getBlock :mine:x :mine:y *tmp82 :mine:block :mine:floor
-    * jump *label57 equal :mine:floor :mine:floorOre
+  199 jump *label57 equal :mine:floor *tmp60
   200 jump *label59 notEqual :mine:floor null
   201 print ": too far"
   202 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    32 op sub :backgroundProcess:copper *tmp15 .copperTarget
    33 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    34 op min *tmp17 *tmp17 :backgroundProcess:copper
-    * set .min *tmp17
    35 jump *label16 notEqual *tmp17 :backgroundProcess:sand
    36 set *tmp19 @sand
    37 jump *label17 always
 
    72 print :backgroundProcess:flag
    73 print "\n"
    74 jump *label24 notEqual :backgroundProcess:flag 0
-    * set :findOreToMine:ore .minOre
    75 sensor *tmp33 @unit @firstItem
    76 jump *label27 equal *tmp33 null
    77 ucontrol itemDrop @air 20
 
   126 label *label33
   127 jump *label32 always
   128 label *label31
-    * set :mine:flag :backgroundProcess:flag
   129 print "Mining x"
   130 op idiv :mine:flag :backgroundProcess:flag 2
   131 op mod *tmp55 :mine:flag 16
 
   151 label *label42
   152 set *tmp60 *tmp62
   153 label *label40
-    * set :mine:floorOre *tmp60
   154 jump *label45 notEqual :mine:ore @scrap
   155 op sub *tmp66 20 .count
   156 jump *label46 always
   157 label *label45
   158 set *tmp66 20
   159 label *label46
-    * set :mine:oreCapacity *tmp66
   160 jump *label47 equal :mine:ore @scrap
   161 jump *label49 equal :mine:ore .minOre
   162 sensor *tmp72 .core :mine:ore

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-12 instructions):
 
    15 set :backgroundProcess:newCount 0
    16 label *label9
    17 ubind @mono
-    * sensor *tmp4 :backgroundProcess:firstItem @dead
-    * jump *label12 equal *tmp4 false
-    * set :backgroundProcess:firstItem @unit
-    * label *label12
-    * label *label13
+   18 sensor *tmp4 :backgroundProcess:firstItem @dead
+   19 select :backgroundProcess:firstItem notEqual *tmp4 false @unit :backgroundProcess:firstItem
    20 jump *label14 notEqual @unit :backgroundProcess:firstItem
    21 printflush message1
    22 sensor *tmp9 .core @lead
 
    33 set *tmp19 @sand
    34 jump *label17 always
    35 label *label16
-    * jump *label18 notEqual *tmp17 :backgroundProcess:lead
-    * set *tmp21 @lead
-    * jump *label19 always
-    * label *label18
-    * set *tmp21 @copper
-    * label *label19
+   36 select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @copper
    37 set *tmp19 *tmp21
    38 label *label17
    39 set .minOre *tmp19
-    * op equal *tmp22 *tmp19 @sand
-    * op land *tmp23 *tmp22 .scrap
-    * jump *label20 equal *tmp23 false
-    * set .minOre @scrap
-    * label *label20
-    * label *label21
+   40 op equal *tmp22 *tmp19 @sand
+   41 op land *tmp23 *tmp22 .scrap
+   42 select .minOre notEqual *tmp23 false @scrap .minOre
    43 print "minOre:"
    44 print .minOre
    45 print "\n"
-    * jump *label22 greaterThanEq *tmp17 10
-    * set .min -100
-    * jump *label23 always
-    * label *label22
-    * op add .min *tmp17 100
-    * label *label23
+   46 op add *tmp89 *tmp17 100
+   47 select .min lessThan *tmp17 10 -100 *tmp89
    48 set .count :backgroundProcess:newCount
    49 set :backgroundProcess:newCount 2
    50 sensor .sandX .sandContainer @x
 
   126 set *tmp62 @ore-scrap
   127 jump *label42 always
   128 label *label41
-    * jump *label43 notEqual :mine:ore @lead
-    * set *tmp64 @ore-lead
-    * jump *label44 always
-    * label *label43
-    * set *tmp64 @sand-floor
-    * label *label44
+  129 select *tmp64 equal :mine:ore @lead @ore-lead @sand-floor
   130 set *tmp62 *tmp64
   131 label *label42
   132 set *tmp60 *tmp62
   133 label *label40
-    * jump *label45 notEqual :mine:ore @scrap
-    * op sub *tmp66 20 .count
-    * jump *label46 always
-    * label *label45
-    * set *tmp66 20
-    * label *label46
+  134 op sub *tmp91 20 .count
+  135 select *tmp66 equal :mine:ore @scrap *tmp91 20
   136 jump *label47 equal :mine:ore @scrap
   137 jump *label49 equal :mine:ore .minOre
   138 sensor *tmp72 .core :mine:ore

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 2 (-6 instructions):
 
    29 op sub :backgroundProcess:copper *tmp15 .copperTarget
    30 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    31 op min *tmp17 *tmp17 :backgroundProcess:copper
-    * jump *label16 notEqual *tmp17 :backgroundProcess:sand
-    * set *tmp19 @sand
-    * jump *label17 always
-    * label *label16
-    * select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @copper
-    * set *tmp19 *tmp21
-    * label *label17
+   32 select *tmp93 equal *tmp17 :backgroundProcess:lead @lead @copper
+   33 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp93
    34 set .minOre *tmp19
    35 op equal *tmp22 *tmp19 @sand
    36 op land *tmp23 *tmp22 .scrap
 
   117 set *tmp60 @ore-copper
   118 jump *label40 always
   119 label *label39
-    * jump *label41 notEqual :mine:ore @scrap
-    * set *tmp62 @ore-scrap
-    * jump *label42 always
-    * label *label41
-    * select *tmp64 equal :mine:ore @lead @ore-lead @sand-floor
-    * set *tmp62 *tmp64
-    * label *label42
+  120 select *tmp95 equal :mine:ore @lead @ore-lead @sand-floor
+  121 select *tmp62 equal :mine:ore @scrap @ore-scrap *tmp95
   122 set *tmp60 *tmp62
   123 label *label40
   124 op sub *tmp91 20 .count

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 3 (-3 instructions):
 
   113 op idiv :mine:flag :mine:flag 16
   114 op mod :mine:y :mine:flag 1000
   115 op idiv :mine:x :mine:flag 1000
-    * jump *label39 notEqual :mine:ore @copper
-    * set *tmp60 @ore-copper
-    * jump *label40 always
-    * label *label39
-    * select *tmp95 equal :mine:ore @lead @ore-lead @sand-floor
-    * select *tmp62 equal :mine:ore @scrap @ore-scrap *tmp95
-    * set *tmp60 *tmp62
-    * label *label40
+  116 select *tmp95 equal :mine:ore @lead @ore-lead @sand-floor
+  117 select *tmp98 equal :mine:ore @scrap @ore-scrap *tmp95
+  118 select *tmp60 equal :mine:ore @copper @ore-copper *tmp98
   119 op sub *tmp91 20 .count
   120 select *tmp66 equal :mine:ore @scrap *tmp91 20
   121 jump *label47 equal :mine:ore @scrap

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    34 set .minOre *tmp19
    35 op equal *tmp22 *tmp19 @sand
    36 op land *tmp23 *tmp22 .scrap
-    * select .minOre notEqual *tmp23 false @scrap .minOre
+   37 select .minOre notEqual *tmp23 false @scrap *tmp19
    38 print "minOre:"
    39 print .minOre
    40 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
    31 op min *tmp17 *tmp17 :backgroundProcess:copper
    32 select *tmp93 equal *tmp17 :backgroundProcess:lead @lead @copper
    33 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp93
-    * set .minOre *tmp19
    34 op equal *tmp22 *tmp19 @sand
    35 op land *tmp23 *tmp22 .scrap
    36 select .minOre notEqual *tmp23 false @scrap *tmp19

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     3 label *label1
     4 label *label3
     5 ubind @mono
-    * label *label4
     6 jump *label3 equal @unit null
-    * label *label5
     7 set :backgroundProcess:firstItem @unit
     8 label *label6
     9 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label7
    10 jump *label6 equal .core null
-    * label *label8
    11 set :backgroundProcess:newCount 0
    12 label *label9
    13 ubind @mono
 
    40 sensor .sandX .sandContainer @x
    41 sensor .sandY .sandContainer @y
    42 label *label14
-    * label *label15
    43 op add :backgroundProcess:newCount :backgroundProcess:newCount 1
    44 sensor :backgroundProcess:flag @unit @flag
    45 print "Unit flag: "
 
    53 jump *label29 equal *tmp36 null
    54 jump *label26 always
    55 label *label29
-    * label *label30
    56 label *label27
-    * label *label28
    57 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp39 *tmp40
    58 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    59 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    93 print "\n"
    94 ucontrol flag 0
    95 label *label36
-    * label *label37
    96 print "\n"
-    * label *label33
    97 jump *label32 always
    98 label *label31
    99 print "Mining x"
 
   116 ucontrol flag 1
   117 jump *label38 always
   118 label *label51
-    * label *label52
   119 label *label49
-    * label *label50
   120 label *label47
-    * label *label48
   121 sensor :mine:items @unit @totalItems
   122 print :mine:items
   123 sensor *tmp76 @unit @firstItem
 
   125 print " (dropping)"
   126 ucontrol itemDrop @air 20
   127 label *label53
-    * label *label54
   128 jump *label55 lessThan :mine:items *tmp66
   129 print ", full"
   130 ucontrol approach .coreX .coreY 7
 
   164 label *label38
   165 label *label32
   166 label *label25
-    * label *label10
   167 jump *label9 always
-    * label *label11
-    * label *label2
   168 wait 1e12
   169 jump *label1 always
   170 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    50 jump *label27 equal *tmp33 null
    51 ucontrol itemDrop @air 20
    52 sensor *tmp36 @unit @firstItem
-    * jump *label29 equal *tmp36 null
-    * jump *label26 always
+   53 jump *label26 notEqual *tmp36 null
    54 label *label29
    55 label *label27
    56 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp39 *tmp40

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    51 ucontrol itemDrop @air 20
    52 sensor *tmp36 @unit @firstItem
    53 jump *label26 notEqual *tmp36 null
-    * label *label29
    54 label *label27
    55 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp39 *tmp40
    56 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    50 jump *label27 equal *tmp33 null
    51 ucontrol itemDrop @air 20
    52 sensor *tmp36 @unit @firstItem
-    * jump *label26 notEqual *tmp36 null
+   53 jump *label9 notEqual *tmp36 null
    54 label *label27
    55 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp39 *tmp40
    56 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    72 print :findOreToMine:y
    73 print "\n"
    74 label *label26
-    * jump *label25 always
+   75 jump *label9 always
    76 label *label24
    77 jump *label31 notEqual :backgroundProcess:flag 1
    78 print "Returning ore"
 
    92 ucontrol flag 0
    93 label *label36
    94 print "\n"
-    * jump *label32 always
+   95 jump *label9 always
    96 label *label31
    97 print "Mining x"
    98 op idiv :mine:flag :backgroundProcess:flag 2
 
   112 jump *label51 lessThanEq *tmp72 .min
   113 print ", switching to a more needed ore"
   114 ucontrol flag 1
-    * jump *label38 always
+  115 jump *label9 always
   116 label *label51
   117 label *label49
   118 label *label47
 
   140 jump *label59 notEqual :mine:floor null
   141 print ": too far"
   142 print "\n"
-    * jump *label60 always
+  143 jump *label58 always
   144 label *label59
   145 ucontrol flag 1
   146 print ": no ore!"

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    71 print " "
    72 print :findOreToMine:y
    73 print "\n"
-    * label *label26
    74 jump *label9 always
    75 label *label24
    76 jump *label31 notEqual :backgroundProcess:flag 1
 
   144 ucontrol flag 1
   145 print ": no ore!"
   146 print "\n"
-    * label *label60
   147 jump *label58 always
   148 label *label57
   149 jump *label61 notEqual :mine:block null
 
   157 label *label58
   158 label *label56
   159 print "\n"
-    * label *label38
-    * label *label32
-    * label *label25
   160 jump *label9 always
-    * wait 1e12
-    * jump *label1 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
     0 set .min 0
     1 set .minOre null
     2 set *signature "0:v1"
-    * label *label1
     3 label *label3
     4 ubind @mono
     5 jump *label3 equal @unit null

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
     5 jump *label3 equal @unit null
     6 set :backgroundProcess:firstItem @unit
     7 label *label6
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+    8 ulocate building core false @copper .coreX .coreY 0 .core
     9 jump *label6 equal .core null
    10 set :backgroundProcess:newCount 0
    11 label *label9
 
    51 sensor *tmp36 @unit @firstItem
    52 jump *label9 notEqual *tmp36 null
    53 label *label27
-    * ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp39 *tmp40
+   54 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    55 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    56 ucontrol mine :findOreToMine:x :findOreToMine:y
    57 op mul *tmp41 :findOreToMine:x 1000
 
   133 print " "
   134 print :mine:y
   135 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp82 :mine:block :mine:floor
+  136 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   137 jump *label57 equal :mine:floor *tmp60
   138 jump *label59 notEqual :mine:floor null
   139 print ": too far"

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    29 op equal *tmp22 *tmp19 @sand
    30 op land *tmp23 *tmp22 .scrap
    31 select .minOre notEqual *tmp23 false @scrap *tmp19
-    * print "minOre:"
-    * print .minOre
-    * print "\n"
+   32 print "minOre:{0}\n"
+   33 format .minOre
    34 op add *tmp89 *tmp17 100
    35 select .min lessThan *tmp17 10 -100 *tmp89
    36 set .count :backgroundProcess:newCount
 
    40 label *label14
    41 op add :backgroundProcess:newCount :backgroundProcess:newCount 1
    42 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   43 print "Unit flag: {0}\n"
+   44 format :backgroundProcess:flag
    45 jump *label24 notEqual :backgroundProcess:flag 0
    46 sensor *tmp33 @unit @firstItem
    47 jump *label27 equal *tmp33 null
 
    59 op mul *tmp45 *tmp44 2
    60 op add *tmp46 *tmp43 *tmp45
    61 ucontrol flag *tmp46
-    * print "Found "
-    * print .minOre
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   62 print "Found {0} at {0}, {0}\n"
+   63 format .minOre
+   64 format :findOreToMine:x
+   65 format :findOreToMine:y
    66 jump *label9 always
    67 label *label24
    68 jump *label31 notEqual :backgroundProcess:flag 1
 
    78 label *label35
    79 sensor *tmp52 @unit @firstItem
    80 jump *label36 notEqual *tmp52 null
-    * print " (finished)"
-    * print "\n"
+   81 print " (finished)\n"
    82 ucontrol flag 0
    83 label *label36
    84 print "\n"
 
   119 ucontrol flag 1
   120 jump *label56 always
   121 label *label55
-    * print " at "
-    * print :mine:x
-    * print ","
-    * print " "
+  122 print " at {0}, "
+  123 format :mine:x
   124 print :mine:y
   125 ucontrol approach :mine:x :mine:y 7
   126 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   127 jump *label57 equal :mine:floor *tmp60
   128 jump *label59 notEqual :mine:floor null
-    * print ": too far"
-    * print "\n"
+  129 print ": too far\n"
   130 jump *label58 always
   131 label *label59
   132 ucontrol flag 1
-    * print ": no ore!"
-    * print "\n"
+  133 print ": no ore!\n"
   134 jump *label58 always
   135 label *label57
   136 jump *label61 notEqual :mine:block null
 
   138 jump *label62 always
   139 label *label61
   140 ucontrol flag 1
-    * print ": blocked!"
-    * print "\n"
+  141 print ": blocked!\n"
   142 label *label62
   143 label *label58
   144 label *label56

Final code before resolving virtual instructions:

    0:  set .min 0                                                   var min = 0, minOre = null;
    1:  set .minOre null                                             ...
    2:  set *signature "0:v1"                                        #set target = 8;
        label *label3                                                do
    3:  ubind @mono                                                  ubind(@mono);
    4:  jump *label3 equal @unit null                                do
    5:  set :backgroundProcess:firstItem @unit                       var firstItem = @unit;
        label *label6                                                do
    6:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
    7:  jump *label6 equal .core null                                do
    8:  set :backgroundProcess:newCount 0                            var newCount = 0;
        label *label9                                                while true do
    9:  ubind @mono                                                  ubind(@mono);
   10:  sensor *tmp4 :backgroundProcess:firstItem @dead              if firstItem.@dead then firstItem = @unit; end;
   11:  select :backgroundProcess:firstItem notEqual *tmp4 false @un ...
   12:  jump *label14 notEqual @unit :backgroundProcess:firstItem    if @unit == firstItem then
   13:  printflush message1                                          printflush(message1);
   14:  sensor *tmp9 .core @lead                                     var lead = core.@lead - leadTarget;
   15:  op sub :backgroundProcess:lead *tmp9 .leadTarget             ...
   16:  sensor *tmp11 .sandContainer @sand                           var sand = sandContainer.@sand + sandContainer.@scrap - sandTarget;
   17:  sensor *tmp12 .sandContainer @scrap                          ...
   18:  op add *tmp13 *tmp11 *tmp12                                  ...
   19:  op sub :backgroundProcess:sand *tmp13 .sandTarget            ...
   20:  sensor *tmp15 .core @copper                                  var copper = core.@copper - copperTarget;
   21:  op sub :backgroundProcess:copper *tmp15 .copperTarget        ...
   22:  op min *tmp17 :backgroundProcess:lead :backgroundProcess:san min = min(lead, sand, copper);
   23:  op min *tmp17 *tmp17 :backgroundProcess:copper               ...
   24:  select *tmp93 equal *tmp17 :backgroundProcess:lead @lead @co minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   25:  select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tm ...
   26:  op equal *tmp22 *tmp19 @sand                                 if minOre == @sand and scrap then minOre = @scrap; end;
   27:  op land *tmp23 *tmp22 .scrap                                 ...
   28:  select .minOre notEqual *tmp23 false @scrap *tmp19           ...
   29:  print "minOre:{0}\n"                                         println("minOre:", minOre);
   30:  format .minOre                                               ...
   31:  op add *tmp89 *tmp17 100                                     if min < 10 then min = -100; else min += 100; end;
   32:  select .min lessThan *tmp17 10 -100 *tmp89                   ...
   33:  set .count :backgroundProcess:newCount                       count = newCount;
   34:  set :backgroundProcess:newCount 2                            newCount = 2;
   35:  sensor .sandX .sandContainer @x                              sandX = sandContainer.@x;
   36:  sensor .sandY .sandContainer @y                              sandY = sandContainer.@y;
        label *label14                                               if @unit == firstItem then
   37:  op add :backgroundProcess:newCount :backgroundProcess:newCou while true do
   38:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   39:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   40:  format :backgroundProcess:flag                               ...
   41:  jump *label24 notEqual :backgroundProcess:flag 0             if flag == 0 then
   42:  sensor *tmp33 @unit @firstItem                               if @unit.@firstItem != null then
   43:  jump *label27 equal *tmp33 null                              ...
   44:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   45:  sensor *tmp36 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   46:  jump *label9 notEqual *tmp36 null                            ...
        label *label27                                               if @unit.@firstItem != null then
   47:  ulocate ore core true .minOre :findOreToMine:x :findOreToMin ulocate(:ore, ore, out x, out y);
   48:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   49:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   50:  op mul *tmp41 :findOreToMine:x 1000                          flag((x * 1000 + y) * 32 + ore.@id * 2);
   51:  op add *tmp42 *tmp41 :findOreToMine:y                        ...
   52:  op mul *tmp43 *tmp42 32                                      ...
   53:  sensor *tmp44 .minOre @id                                    ...
   54:  op mul *tmp45 *tmp44 2                                       ...
   55:  op add *tmp46 *tmp43 *tmp45                                  ...
   56:  ucontrol flag *tmp46 0 0 0 0                                 ...
   57:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   58:  format .minOre                                               ...
   59:  format :findOreToMine:x                                      ...
   60:  format :findOreToMine:y                                      ...
   61:  jump *label9 always 0 0                                      if flag == 0 then
        label *label24                                               ...
   62:  jump *label31 notEqual :backgroundProcess:flag 1             elsif flag == 1 then
   63:  print "Returning ore"                                        print("Returning ore");
   64:  sensor *tmp49 @unit @firstItem                               if @unit.@firstItem == @scrap then
   65:  jump *label34 notEqual *tmp49 @scrap                         ...
   66:  ucontrol approach .sandX .sandY 7 0 0                        approach(sandX, sandY, RADIUS);
   67:  ucontrol itemDrop .sandContainer 20 0 0 0                    itemDrop(sandContainer, capacity);
   68:  jump *label35 always 0 0                                     if @unit.@firstItem == @scrap then
        label *label34                                               ...
   69:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   70:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
        label *label35                                               if @unit.@firstItem == @scrap then
   71:  sensor *tmp52 @unit @firstItem                               if @unit.@firstItem == null then
   72:  jump *label36 notEqual *tmp52 null                           ...
   73:  print " (finished)\n"                                        println(" (finished)");
   74:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label36                                               if @unit.@firstItem == null then
   75:  print "\n"                                                   println();
   76:  jump *label9 always 0 0                                      elsif flag == 1 then
        label *label31                                               ...
   77:  print "Mining x"                                             print("Mining x");
   78:  op idiv :mine:flag :backgroundProcess:flag 2                 flag \= 2;
   79:  op mod *tmp55 :mine:flag 16                                  var ore = lookup(:item, flag % 16);
   80:  lookup item :mine:ore *tmp55                                 ...
   81:  op idiv :mine:flag :mine:flag 16                             flag \= 16;
   82:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   83:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   84:  select *tmp95 equal :mine:ore @lead @ore-lead @sand-floor    ore == @copper ? @ore-copper :
   85:  select *tmp98 equal :mine:ore @scrap @ore-scrap *tmp95       ...
   86:  select *tmp60 equal :mine:ore @copper @ore-copper *tmp98     ...
   87:  op sub *tmp91 20 .count                                      var oreCapacity = ore == @scrap ? capacity - count : capacity;
   88:  select *tmp66 equal :mine:ore @scrap *tmp91 20               ...
   89:  jump *label47 equal :mine:ore @scrap                         if ore != @scrap then
   90:  jump *label49 equal :mine:ore .minOre                        if ore != minOre then
   91:  sensor *tmp72 .core :mine:ore                                if core.sensor(ore) > min then
   92:  jump *label51 lessThanEq *tmp72 .min                         ...
   93:  print ", switching to a more needed ore"                     print(", switching to a more needed ore");
   94:  ucontrol flag 1 0 0 0 0                                      flag(1);
   95:  jump *label9 always 0 0                                      return;
        label *label51                                               if core.sensor(ore) > min then
        label *label49                                               if ore != minOre then
        label *label47                                               if ore != @scrap then
   96:  sensor :mine:items @unit @totalItems                         var items = @unit.@totalItems;
   97:  print :mine:items                                            print(items);
   98:  sensor *tmp76 @unit @firstItem                               if @unit.@firstItem != ore then
   99:  jump *label53 equal *tmp76 :mine:ore                         ...
  100:  print " (dropping)"                                          print(" (dropping)");
  101:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label53                                               if @unit.@firstItem != ore then
  102:  jump *label55 lessThan :mine:items *tmp66                    if items >= oreCapacity then
  103:  print ", full"                                               print(", full");
  104:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
  105:  ucontrol flag 1 0 0 0 0                                      flag(1);
  106:  jump *label56 always 0 0                                     if items >= oreCapacity then
        label *label55                                               ...
  107:  print " at {0}, "                                            print($" at $x, $y");
  108:  format :mine:x                                               ...
  109:  print :mine:y                                                ...
  110:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
  111:  ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor  var block = getBlock(x, y, , out floor);
  112:  jump *label57 equal :mine:floor *tmp60                       if floor != floorOre then
  113:  jump *label59 notEqual :mine:floor null                      if floor == null then
  114:  print ": too far\n"                                          println(": too far");
  115:  jump *label58 always 0 0                                     if floor == null then
        label *label59                                               ...
  116:  ucontrol flag 1 0 0 0 0                                      flag(1);
  117:  print ": no ore!\n"                                          println(": no ore!");
  118:  jump *label58 always 0 0                                     if floor != floorOre then
        label *label57                                               ...
  119:  jump *label61 notEqual :mine:block null                      elsif block == null then
  120:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
  121:  jump *label62 always 0 0                                     elsif block == null then
        label *label61                                               ...
  122:  ucontrol flag 1 0 0 0 0                                      flag(1);
  123:  print ": blocked!\n"                                         println(": blocked!");
        label *label62                                               elsif block == null then
        label *label58                                               if floor != floorOre then
        label *label56                                               if items >= oreCapacity then
  124:  print "\n"                                                   println();
  125:  jump *label9 always 0 0                                      while true do


Performance: parsed in 347 ms, compiled in 354 ms, optimized in 439 ms, run in 16 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (4 steps):
The program didn't generate any output.
Execution exception at instruction 3: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
