   231 instructions before optimizations.
    10 instructions eliminated by Temp Variables Elimination (2 passes, 6 iterations).
    34 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    21 instructions eliminated by Jump Optimization (5 iterations).
     9 instructions eliminated by Single Step Elimination (6 iterations).
    16 instructions eliminated by If Expression Optimization (5 iterations).
     6 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     1 instructions eliminated by Jump Straightening (5 iterations).
     5 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   117 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-20 instructions):
 
    22 jump *label12 equal *tmp4 false
    23 set *tmp6 @unit
    24 set :backgroundProcess:firstItem *tmp6
-    * set *tmp5 :backgroundProcess:firstItem
    25 jump *label13 always
    26 label *label12
-    * set *tmp5 null
    27 label *label13
    28 op equal *tmp7 @unit :backgroundProcess:firstItem
    29 jump *label14 equal *tmp7 false
 
    61 op land *tmp23 *tmp22 .scrap
    62 jump *label20 equal *tmp23 false
    63 set .minOre @scrap
-    * set *tmp24 .minOre
    64 jump *label21 always
    65 label *label20
-    * set *tmp24 null
    66 label *label21
    67 print "minOre:"
    68 print .minOre
 
    76 op add .min .min 100
    77 set *tmp26 .min
    78 label *label23
-    * set *tmp8 *tmp26
    79 jump *label15 always
    80 label *label14
-    * set *tmp8 null
    81 label *label15
    82 sensor *tmp27 @unit @flag
    83 set :backgroundProcess:flag *tmp27
 
   100 label *label29
   101 set *tmp35 null
   102 label *label30
-    * set *tmp32 *tmp35
   103 jump *label28 always
   104 label *label27
-    * set *tmp32 null
   105 label *label28
   106 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp36 *tmp37
   107 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
   123 print :findOreToMine:y
   124 print "\n"
   125 label *label26
-    * set *tmp29 null
   126 jump *label25 always
   127 label *label24
   128 op equal *tmp44 :backgroundProcess:flag 1
 
   135 sensor *tmp50 .sandContainer @y
   136 ucontrol approach *tmp49 *tmp50 7
   137 ucontrol itemDrop .sandContainer 20
-    * set *tmp48 null
   138 jump *label35 always
   139 label *label34
   140 ucontrol approach .coreX .coreY 7
   141 ucontrol itemDrop .core 20
-    * set *tmp48 null
   142 label *label35
   143 sensor *tmp51 @unit @firstItem
   144 op equal *tmp52 *tmp51 null
 
   146 print " (finished)"
   147 print "\n"
   148 ucontrol flag 0
-    * set *tmp53 null
   149 jump *label37 always
   150 label *label36
-    * set *tmp53 null
   151 label *label37
   152 print "\n"
   153 label *label33
 
   193 label *label45
   194 set *tmp66 null
   195 label *label46
-    * set *tmp63 *tmp66
   196 jump *label44 always
   197 label *label43
-    * set *tmp63 null
   198 label *label44
   199 sensor *tmp67 @unit @firstItem
   200 op notEqual *tmp68 *tmp67 :mine:ore
   201 jump *label47 equal *tmp68 false
   202 print " (dropping)"
   203 ucontrol itemDrop @air 20
-    * set *tmp69 null
   204 jump *label48 always
   205 label *label47
-    * set *tmp69 null
   206 label *label48
   207 sensor *tmp70 @unit @totalItems
   208 op greaterThanEq *tmp71 *tmp70 20
 
   210 print ", full"
   211 ucontrol approach .coreX .coreY 7
   212 ucontrol flag 1
-    * set *tmp72 null
   213 jump *label50 always
   214 label *label49
   215 set :mine:floor null
 
   251 label *label56
   252 set *tmp76 *tmp80
   253 label *label52
-    * set *tmp72 *tmp76
   254 label *label50
   255 print "\n"
   256 label *label38
   257 set *tmp45 null
   258 label *label32
-    * set *tmp29 *tmp45
   259 label *label25
   260 label *label10
   261 jump *label9 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-10 instructions):
 
    70 op lessThan *tmp25 .min 10
    71 jump *label22 equal *tmp25 false
    72 set .min -100
-    * set *tmp26 .min
    73 jump *label23 always
    74 label *label22
    75 op add .min .min 100
-    * set *tmp26 .min
    76 label *label23
    77 jump *label15 always
    78 label *label14
 
    93 op notEqual *tmp34 *tmp33 null
    94 jump *label29 equal *tmp34 false
    95 jump *label26 always
-    * set *tmp35 null
    96 jump *label30 always
    97 label *label29
-    * set *tmp35 null
    98 label *label30
    99 jump *label28 always
   100 label *label27
 
   147 label *label37
   148 print "\n"
   149 label *label33
-    * set *tmp45 null
   150 jump *label32 always
   151 label *label31
   152 set :mine:flag :backgroundProcess:flag
 
   183 print ", switching to a more needed ore"
   184 ucontrol flag 1
   185 jump *label38 always
-    * set *tmp66 null
   186 jump *label46 always
   187 label *label45
-    * set *tmp66 null
   188 label *label46
   189 jump *label44 always
   190 label *label43
 
   228 print "\n"
   229 set *tmp78 ": no ore!"
   230 label *label54
-    * set *tmp76 *tmp78
   231 jump *label52 always
   232 label *label51
   233 op equal *tmp79 :mine:block null
 
   241 print "\n"
   242 set *tmp80 ": blocked!"
   243 label *label56
-    * set *tmp76 *tmp80
   244 label *label52
   245 label *label50
   246 print "\n"
   247 label *label38
-    * set *tmp45 null
   248 label *label32
   249 label *label25
   250 label *label10

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   220 jump *label53 equal *tmp77 false
   221 print ": too far"
   222 print "\n"
-    * set *tmp78 ": too far"
   223 jump *label54 always
   224 label *label53
   225 ucontrol flag 1
   226 print ": no ore!"
   227 print "\n"
-    * set *tmp78 ": no ore!"
   228 label *label54
   229 jump *label52 always
   230 label *label51
   231 op equal *tmp79 :mine:block null
   232 jump *label55 equal *tmp79 false
   233 ucontrol mine :mine:x :mine:y
-    * set *tmp80 null
   234 jump *label56 always
   235 label *label55
   236 ucontrol flag 1
   237 print ": blocked!"
   238 print "\n"
-    * set *tmp80 ": blocked!"
   239 label *label56
   240 label *label52
   241 label *label50

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-10 instructions):
 
     9 label *label5
    10 set :backgroundProcess:firstItem @unit
    11 label *label6
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   12 ulocate building core false @copper .coreX .coreY *tmp2 .core
    13 label *label7
    14 op equal *tmp3 .core null
    15 jump *label6 notEqual *tmp3 false
 
    19 ubind @mono
    20 sensor *tmp4 :backgroundProcess:firstItem @dead
    21 jump *label12 equal *tmp4 false
-    * set *tmp6 @unit
-    * set :backgroundProcess:firstItem *tmp6
+   22 set :backgroundProcess:firstItem @unit
    23 jump *label13 always
    24 label *label12
    25 label *label13
 
    27 jump *label14 equal *tmp7 false
    28 printflush message1
    29 sensor *tmp9 .core @lead
-    * op sub *tmp10 *tmp9 .leadTarget
-    * set :backgroundProcess:lead *tmp10
+   30 op sub :backgroundProcess:lead *tmp9 .leadTarget
    31 sensor *tmp11 .sandContainer @sand
    32 sensor *tmp12 .sandContainer @scrap
    33 op add *tmp13 *tmp11 *tmp12
-    * op sub *tmp14 *tmp13 .sandTarget
-    * set :backgroundProcess:sand *tmp14
+   34 op sub :backgroundProcess:sand *tmp13 .sandTarget
    35 sensor *tmp15 .core @copper
-    * op sub *tmp16 *tmp15 .copperTarget
-    * set :backgroundProcess:copper *tmp16
+   36 op sub :backgroundProcess:copper *tmp15 .copperTarget
    37 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    38 op min *tmp17 *tmp17 :backgroundProcess:copper
    39 set .min *tmp17
 
    72 jump *label15 always
    73 label *label14
    74 label *label15
-    * sensor *tmp27 @unit @flag
-    * set :backgroundProcess:flag *tmp27
+   75 sensor :backgroundProcess:flag @unit @flag
    76 print "Unit flag: "
    77 print :backgroundProcess:flag
    78 print "\n"
 
   147 print "Mining"
   148 op idiv :mine:flag :mine:flag 2
   149 op mod *tmp54 :mine:flag 16
-    * lookup item *tmp55 *tmp54
-    * set :mine:ore *tmp55
+  150 lookup item :mine:ore *tmp54
   151 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp56 :mine:flag 1000
-    * set :mine:y *tmp56
-    * op idiv *tmp57 :mine:flag 1000
-    * set :mine:x *tmp57
+  152 op mod :mine:y :mine:flag 1000
+  153 op idiv :mine:x :mine:flag 1000
   154 op equal *tmp58 :mine:ore @copper
   155 jump *label39 equal *tmp58 false
   156 set *tmp59 @ore-copper
 
   203 print " "
   204 print :mine:y
   205 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp74 *tmp73 :mine:floor
-    * set :mine:block *tmp73
+  206 ucontrol getBlock :mine:x :mine:y *tmp74 :mine:block :mine:floor
   207 op notEqual *tmp75 :mine:floor :mine:floorOre
   208 jump *label51 equal *tmp75 false
   209 op equal *tmp77 :mine:floor null

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    15 jump *label6 notEqual *tmp3 false
    16 label *label8
    17 label *label9
-    * jump *label11 equal true false
    18 ubind @mono
    19 sensor *tmp4 :backgroundProcess:firstItem @dead
    20 jump *label12 equal *tmp4 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-21 instructions):
 
     4 label *label3
     5 ubind @mono
     6 label *label4
-    * op equal *tmp0 @unit null
-    * jump *label3 notEqual *tmp0 false
+    7 jump *label3 equal @unit null
     8 label *label5
     9 set :backgroundProcess:firstItem @unit
    10 label *label6
    11 ulocate building core false @copper .coreX .coreY *tmp2 .core
    12 label *label7
-    * op equal *tmp3 .core null
-    * jump *label6 notEqual *tmp3 false
+   13 jump *label6 equal .core null
    14 label *label8
    15 label *label9
    16 ubind @mono
 
    20 jump *label13 always
    21 label *label12
    22 label *label13
-    * op equal *tmp7 @unit :backgroundProcess:firstItem
-    * jump *label14 equal *tmp7 false
+   23 jump *label14 notEqual @unit :backgroundProcess:firstItem
    24 printflush message1
    25 sensor *tmp9 .core @lead
    26 op sub :backgroundProcess:lead *tmp9 .leadTarget
 
    33 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    34 op min *tmp17 *tmp17 :backgroundProcess:copper
    35 set .min *tmp17
-    * op equal *tmp18 .min :backgroundProcess:sand
-    * jump *label16 equal *tmp18 false
+   36 jump *label16 notEqual .min :backgroundProcess:sand
    37 set *tmp19 @sand
    38 jump *label17 always
    39 label *label16
-    * op equal *tmp20 .min :backgroundProcess:lead
-    * jump *label18 equal *tmp20 false
+   40 jump *label18 notEqual .min :backgroundProcess:lead
    41 set *tmp21 @lead
    42 jump *label19 always
    43 label *label18
 
    56 print "minOre:"
    57 print .minOre
    58 print "\n"
-    * op lessThan *tmp25 .min 10
-    * jump *label22 equal *tmp25 false
+   59 jump *label22 greaterThanEq .min 10
    60 set .min -100
    61 jump *label23 always
    62 label *label22
 
    69 print "Unit flag: "
    70 print :backgroundProcess:flag
    71 print "\n"
-    * op equal *tmp28 :backgroundProcess:flag 0
-    * jump *label24 equal *tmp28 false
+   72 jump *label24 notEqual :backgroundProcess:flag 0
    73 set :findOreToMine:ore .minOre
    74 sensor *tmp30 @unit @firstItem
-    * op notEqual *tmp31 *tmp30 null
-    * jump *label27 equal *tmp31 false
+   75 jump *label27 equal *tmp30 null
    76 ucontrol itemDrop @air 20
    77 sensor *tmp33 @unit @firstItem
-    * op notEqual *tmp34 *tmp33 null
-    * jump *label29 equal *tmp34 false
+   78 jump *label29 equal *tmp33 null
    79 jump *label26 always
    80 jump *label30 always
    81 label *label29
 
   105 label *label26
   106 jump *label25 always
   107 label *label24
-    * op equal *tmp44 :backgroundProcess:flag 1
-    * jump *label31 equal *tmp44 false
+  108 jump *label31 notEqual :backgroundProcess:flag 1
   109 print "Returning ore"
   110 sensor *tmp46 @unit @firstItem
-    * op equal *tmp47 *tmp46 @scrap
-    * jump *label34 equal *tmp47 false
+  111 jump *label34 notEqual *tmp46 @scrap
   112 sensor *tmp49 .sandContainer @x
   113 sensor *tmp50 .sandContainer @y
   114 ucontrol approach *tmp49 *tmp50 7
 
   119 ucontrol itemDrop .core 20
   120 label *label35
   121 sensor *tmp51 @unit @firstItem
-    * op equal *tmp52 *tmp51 null
-    * jump *label36 equal *tmp52 false
+  122 jump *label36 notEqual *tmp51 null
   123 print " (finished)"
   124 print "\n"
   125 ucontrol flag 0
 
   138 op idiv :mine:flag :mine:flag 16
   139 op mod :mine:y :mine:flag 1000
   140 op idiv :mine:x :mine:flag 1000
-    * op equal *tmp58 :mine:ore @copper
-    * jump *label39 equal *tmp58 false
+  141 jump *label39 notEqual :mine:ore @copper
   142 set *tmp59 @ore-copper
   143 jump *label40 always
   144 label *label39
-    * op equal *tmp60 :mine:ore @lead
-    * jump *label41 equal *tmp60 false
+  145 jump *label41 notEqual :mine:ore @lead
   146 set *tmp61 @ore-lead
   147 jump *label42 always
   148 label *label41
 
   151 set *tmp59 *tmp61
   152 label *label40
   153 set :mine:floorOre *tmp59
-    * op notEqual *tmp62 :mine:ore .minOre
-    * jump *label43 equal *tmp62 false
+  154 jump *label43 equal :mine:ore .minOre
   155 sensor *tmp64 .core :mine:ore
-    * op greaterThan *tmp65 *tmp64 .min
-    * jump *label45 equal *tmp65 false
+  156 jump *label45 lessThanEq *tmp64 .min
   157 print ", switching to a more needed ore"
   158 ucontrol flag 1
   159 jump *label38 always
 
   164 label *label43
   165 label *label44
   166 sensor *tmp67 @unit @firstItem
-    * op notEqual *tmp68 *tmp67 :mine:ore
-    * jump *label47 equal *tmp68 false
+  167 jump *label47 equal *tmp67 :mine:ore
   168 print " (dropping)"
   169 ucontrol itemDrop @air 20
   170 jump *label48 always
   171 label *label47
   172 label *label48
   173 sensor *tmp70 @unit @totalItems
-    * op greaterThanEq *tmp71 *tmp70 20
-    * jump *label49 equal *tmp71 false
+  174 jump *label49 lessThan *tmp70 20
   175 print ", full"
   176 ucontrol approach .coreX .coreY 7
   177 ucontrol flag 1
 
   185 print :mine:y
   186 ucontrol approach :mine:x :mine:y 7
   187 ucontrol getBlock :mine:x :mine:y *tmp74 :mine:block :mine:floor
-    * op notEqual *tmp75 :mine:floor :mine:floorOre
-    * jump *label51 equal *tmp75 false
-    * op equal *tmp77 :mine:floor null
-    * jump *label53 equal *tmp77 false
+  188 jump *label51 equal :mine:floor :mine:floorOre
+  189 jump *label53 notEqual :mine:floor null
   190 print ": too far"
   191 print "\n"
   192 jump *label54 always
 
   197 label *label54
   198 jump *label52 always
   199 label *label51
-    * op equal *tmp79 :mine:block null
-    * jump *label55 equal *tmp79 false
+  200 jump *label55 notEqual :mine:block null
   201 ucontrol mine :mine:x :mine:y
   202 jump *label56 always
   203 label *label55

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-9 instructions):
 
    17 sensor *tmp4 :backgroundProcess:firstItem @dead
    18 jump *label12 equal *tmp4 false
    19 set :backgroundProcess:firstItem @unit
-    * jump *label13 always
    20 label *label12
    21 label *label13
    22 jump *label14 notEqual @unit :backgroundProcess:firstItem
 
    49 op land *tmp23 *tmp22 .scrap
    50 jump *label20 equal *tmp23 false
    51 set .minOre @scrap
-    * jump *label21 always
    52 label *label20
    53 label *label21
    54 print "minOre:"
 
    60 label *label22
    61 op add .min .min 100
    62 label *label23
-    * jump *label15 always
    63 label *label14
    64 label *label15
    65 sensor :backgroundProcess:flag @unit @flag
 
    74 sensor *tmp33 @unit @firstItem
    75 jump *label29 equal *tmp33 null
    76 jump *label26 always
-    * jump *label30 always
    77 label *label29
    78 label *label30
-    * jump *label28 always
    79 label *label27
    80 label *label28
    81 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp36 *tmp37
 
   118 print " (finished)"
   119 print "\n"
   120 ucontrol flag 0
-    * jump *label37 always
   121 label *label36
   122 label *label37
   123 print "\n"
 
   151 print ", switching to a more needed ore"
   152 ucontrol flag 1
   153 jump *label38 always
-    * jump *label46 always
   154 label *label45
   155 label *label46
-    * jump *label44 always
   156 label *label43
   157 label *label44
   158 sensor *tmp67 @unit @firstItem
   159 jump *label47 equal *tmp67 :mine:ore
   160 print " (dropping)"
   161 ucontrol itemDrop @air 20
-    * jump *label48 always
   162 label *label47
   163 label *label48
   164 sensor *tmp70 @unit @totalItems

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    32 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    33 op min *tmp17 *tmp17 :backgroundProcess:copper
    34 set .min *tmp17
-    * jump *label16 notEqual .min :backgroundProcess:sand
+   35 jump *label16 notEqual *tmp17 :backgroundProcess:sand
    36 set *tmp19 @sand
    37 jump *label17 always
    38 label *label16
-    * jump *label18 notEqual .min :backgroundProcess:lead
+   39 jump *label18 notEqual *tmp17 :backgroundProcess:lead
    40 set *tmp21 @lead
    41 jump *label19 always
    42 label *label18
 
    45 set *tmp19 *tmp21
    46 label *label17
    47 set .minOre *tmp19
-    * op equal *tmp22 .minOre @sand
+   48 op equal *tmp22 *tmp19 @sand
    49 op land *tmp23 *tmp22 .scrap
    50 jump *label20 equal *tmp23 false
    51 set .minOre @scrap
 
    54 print "minOre:"
    55 print .minOre
    56 print "\n"
-    * jump *label22 greaterThanEq .min 10
+   57 jump *label22 greaterThanEq *tmp17 10
    58 set .min -100
    59 jump *label23 always
    60 label *label22
-    * op add .min .min 100
+   61 op add .min *tmp17 100
    62 label *label23
    63 label *label14
    64 label *label15
 
    78 label *label30
    79 label *label27
    80 label *label28
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp36 *tmp37
+   81 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp36 *tmp37
    82 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    83 ucontrol mine :findOreToMine:x :findOreToMine:y
    84 op mul *tmp38 :findOreToMine:x 1000
    85 op add *tmp39 *tmp38 :findOreToMine:y
    86 op mul *tmp40 *tmp39 32
-    * sensor *tmp41 :findOreToMine:ore @id
+   87 sensor *tmp41 .minOre @id
    88 op mul *tmp42 *tmp41 2
    89 op add *tmp43 *tmp40 *tmp42
    90 ucontrol flag *tmp43
    91 print "Found "
-    * print :findOreToMine:ore
+   92 print .minOre
    93 print " "
    94 print "at "
    95 print :findOreToMine:x
 
   126 label *label31
   127 set :mine:flag :backgroundProcess:flag
   128 print "Mining"
-    * op idiv :mine:flag :mine:flag 2
+  129 op idiv :mine:flag :backgroundProcess:flag 2
   130 op mod *tmp54 :mine:flag 16
   131 lookup item :mine:ore *tmp54
   132 op idiv :mine:flag :mine:flag 16
 
   168 ucontrol flag 1
   169 jump *label50 always
   170 label *label49
-    * set :mine:floor null
   171 print " at "
   172 print :mine:x
   173 print ","
 
   175 print :mine:y
   176 ucontrol approach :mine:x :mine:y 7
   177 ucontrol getBlock :mine:x :mine:y *tmp74 :mine:block :mine:floor
-    * jump *label51 equal :mine:floor :mine:floorOre
+  178 jump *label51 equal :mine:floor *tmp59
   179 jump *label53 notEqual :mine:floor null
   180 print ": too far"
   181 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    31 op sub :backgroundProcess:copper *tmp15 .copperTarget
    32 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    33 op min *tmp17 *tmp17 :backgroundProcess:copper
-    * set .min *tmp17
    34 jump *label16 notEqual *tmp17 :backgroundProcess:sand
    35 set *tmp19 @sand
    36 jump *label17 always
 
    66 print :backgroundProcess:flag
    67 print "\n"
    68 jump *label24 notEqual :backgroundProcess:flag 0
-    * set :findOreToMine:ore .minOre
    69 sensor *tmp30 @unit @firstItem
    70 jump *label27 equal *tmp30 null
    71 ucontrol itemDrop @air 20
 
   122 label *label33
   123 jump *label32 always
   124 label *label31
-    * set :mine:flag :backgroundProcess:flag
   125 print "Mining"
   126 op idiv :mine:flag :backgroundProcess:flag 2
   127 op mod *tmp54 :mine:flag 16
 
   141 label *label42
   142 set *tmp59 *tmp61
   143 label *label40
-    * set :mine:floorOre *tmp59
   144 jump *label43 equal :mine:ore .minOre
   145 sensor *tmp64 .core :mine:ore
   146 jump *label45 lessThanEq *tmp64 .min

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-10 instructions):
 
    14 label *label8
    15 label *label9
    16 ubind @mono
-    * sensor *tmp4 :backgroundProcess:firstItem @dead
-    * jump *label12 equal *tmp4 false
-    * set :backgroundProcess:firstItem @unit
-    * label *label12
-    * label *label13
+   17 sensor *tmp4 :backgroundProcess:firstItem @dead
+   18 select :backgroundProcess:firstItem notEqual *tmp4 false @unit :backgroundProcess:firstItem
    19 jump *label14 notEqual @unit :backgroundProcess:firstItem
    20 printflush message1
    21 sensor *tmp9 .core @lead
 
    32 set *tmp19 @sand
    33 jump *label17 always
    34 label *label16
-    * jump *label18 notEqual *tmp17 :backgroundProcess:lead
-    * set *tmp21 @lead
-    * jump *label19 always
-    * label *label18
-    * set *tmp21 @copper
-    * label *label19
+   35 select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @copper
    36 set *tmp19 *tmp21
    37 label *label17
    38 set .minOre *tmp19
-    * op equal *tmp22 *tmp19 @sand
-    * op land *tmp23 *tmp22 .scrap
-    * jump *label20 equal *tmp23 false
-    * set .minOre @scrap
-    * label *label20
-    * label *label21
+   39 op equal *tmp22 *tmp19 @sand
+   40 op land *tmp23 *tmp22 .scrap
+   41 select .minOre notEqual *tmp23 false @scrap .minOre
    42 print "minOre:"
    43 print .minOre
    44 print "\n"
-    * jump *label22 greaterThanEq *tmp17 10
-    * set .min -100
-    * jump *label23 always
-    * label *label22
-    * op add .min *tmp17 100
-    * label *label23
+   45 op add *tmp81 *tmp17 100
+   46 select .min lessThan *tmp17 10 -100 *tmp81
    47 label *label14
    48 label *label15
    49 sensor :backgroundProcess:flag @unit @flag
 
   118 set *tmp59 @ore-copper
   119 jump *label40 always
   120 label *label39
-    * jump *label41 notEqual :mine:ore @lead
-    * set *tmp61 @ore-lead
-    * jump *label42 always
-    * label *label41
-    * set *tmp61 @sand-floor
-    * label *label42
+  121 select *tmp61 equal :mine:ore @lead @ore-lead @sand-floor
   122 set *tmp59 *tmp61
   123 label *label40
   124 jump *label43 equal :mine:ore .minOre

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 2 (-6 instructions):
 
    28 op sub :backgroundProcess:copper *tmp15 .copperTarget
    29 op min *tmp17 :backgroundProcess:lead :backgroundProcess:sand
    30 op min *tmp17 *tmp17 :backgroundProcess:copper
-    * jump *label16 notEqual *tmp17 :backgroundProcess:sand
-    * set *tmp19 @sand
-    * jump *label17 always
-    * label *label16
-    * select *tmp21 equal *tmp17 :backgroundProcess:lead @lead @copper
-    * set *tmp19 *tmp21
-    * label *label17
+   31 select *tmp86 equal *tmp17 :backgroundProcess:lead @lead @copper
+   32 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp86
    33 set .minOre *tmp19
    34 op equal *tmp22 *tmp19 @sand
    35 op land *tmp23 *tmp22 .scrap
 
   109 op idiv :mine:flag :mine:flag 16
   110 op mod :mine:y :mine:flag 1000
   111 op idiv :mine:x :mine:flag 1000
-    * jump *label39 notEqual :mine:ore @copper
-    * set *tmp59 @ore-copper
-    * jump *label40 always
-    * label *label39
-    * select *tmp61 equal :mine:ore @lead @ore-lead @sand-floor
-    * set *tmp59 *tmp61
-    * label *label40
+  112 select *tmp90 equal :mine:ore @lead @ore-lead @sand-floor
+  113 select *tmp59 equal :mine:ore @copper @ore-copper *tmp90
   114 jump *label43 equal :mine:ore .minOre
   115 sensor *tmp64 .core :mine:ore
   116 jump *label45 lessThanEq *tmp64 .min

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    33 set .minOre *tmp19
    34 op equal *tmp22 *tmp19 @sand
    35 op land *tmp23 *tmp22 .scrap
-    * select .minOre notEqual *tmp23 false @scrap .minOre
+   36 select .minOre notEqual *tmp23 false @scrap *tmp19
    37 print "minOre:"
    38 print .minOre
    39 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
    30 op min *tmp17 *tmp17 :backgroundProcess:copper
    31 select *tmp86 equal *tmp17 :backgroundProcess:lead @lead @copper
    32 select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tmp86
-    * set .minOre *tmp19
    33 op equal *tmp22 *tmp19 @sand
    34 op land *tmp23 *tmp22 .scrap
    35 select .minOre notEqual *tmp23 false @scrap *tmp19

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     3 label *label1
     4 label *label3
     5 ubind @mono
-    * label *label4
     6 jump *label3 equal @unit null
-    * label *label5
     7 set :backgroundProcess:firstItem @unit
     8 label *label6
     9 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label7
    10 jump *label6 equal .core null
-    * label *label8
    11 label *label9
    12 ubind @mono
    13 sensor *tmp4 :backgroundProcess:firstItem @dead
 
    35 op add *tmp81 *tmp17 100
    36 select .min lessThan *tmp17 10 -100 *tmp81
    37 label *label14
-    * label *label15
    38 sensor :backgroundProcess:flag @unit @flag
    39 print "Unit flag: "
    40 print :backgroundProcess:flag
 
    47 jump *label29 equal *tmp33 null
    48 jump *label26 always
    49 label *label29
-    * label *label30
    50 label *label27
-    * label *label28
    51 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp36 *tmp37
    52 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    53 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    89 print "\n"
    90 ucontrol flag 0
    91 label *label36
-    * label *label37
    92 print "\n"
-    * label *label33
    93 jump *label32 always
    94 label *label31
    95 print "Mining"
 
   108 ucontrol flag 1
   109 jump *label38 always
   110 label *label45
-    * label *label46
   111 label *label43
-    * label *label44
   112 sensor *tmp67 @unit @firstItem
   113 jump *label47 equal *tmp67 :mine:ore
   114 print " (dropping)"
   115 ucontrol itemDrop @air 20
   116 label *label47
-    * label *label48
   117 sensor *tmp70 @unit @totalItems
   118 jump *label49 lessThan *tmp70 20
   119 print ", full"
 
   154 label *label38
   155 label *label32
   156 label *label25
-    * label *label10
   157 jump *label9 always
-    * label *label11
-    * label *label2
   158 wait 1e12
   159 jump *label1 always
   160 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    44 jump *label27 equal *tmp30 null
    45 ucontrol itemDrop @air 20
    46 sensor *tmp33 @unit @firstItem
-    * jump *label29 equal *tmp33 null
-    * jump *label26 always
+   47 jump *label26 notEqual *tmp33 null
    48 label *label29
    49 label *label27
    50 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp36 *tmp37

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    45 ucontrol itemDrop @air 20
    46 sensor *tmp33 @unit @firstItem
    47 jump *label26 notEqual *tmp33 null
-    * label *label29
    48 label *label27
    49 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp36 *tmp37
    50 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    44 jump *label27 equal *tmp30 null
    45 ucontrol itemDrop @air 20
    46 sensor *tmp33 @unit @firstItem
-    * jump *label26 notEqual *tmp33 null
+   47 jump *label9 notEqual *tmp33 null
    48 label *label27
    49 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp36 *tmp37
    50 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    66 print :findOreToMine:y
    67 print "\n"
    68 label *label26
-    * jump *label25 always
+   69 jump *label9 always
    70 label *label24
    71 jump *label31 notEqual :backgroundProcess:flag 1
    72 print "Returning ore"
 
    88 ucontrol flag 0
    89 label *label36
    90 print "\n"
-    * jump *label32 always
+   91 jump *label9 always
    92 label *label31
    93 print "Mining"
    94 op idiv :mine:flag :backgroundProcess:flag 2
 
   104 jump *label45 lessThanEq *tmp64 .min
   105 print ", switching to a more needed ore"
   106 ucontrol flag 1
-    * jump *label38 always
+  107 jump *label9 always
   108 label *label45
   109 label *label43
   110 sensor *tmp67 @unit @firstItem
 
   130 jump *label53 notEqual :mine:floor null
   131 print ": too far"
   132 print "\n"
-    * jump *label54 always
+  133 jump *label52 always
   134 label *label53
   135 ucontrol flag 1
   136 print ": no ore!"

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    65 print " "
    66 print :findOreToMine:y
    67 print "\n"
-    * label *label26
    68 jump *label9 always
    69 label *label24
    70 jump *label31 notEqual :backgroundProcess:flag 1
 
   134 ucontrol flag 1
   135 print ": no ore!"
   136 print "\n"
-    * label *label54
   137 jump *label52 always
   138 label *label51
   139 jump *label55 notEqual :mine:block null
 
   147 label *label52
   148 label *label50
   149 print "\n"
-    * label *label38
-    * label *label32
-    * label *label25
   150 jump *label9 always
-    * wait 1e12
-    * jump *label1 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
     0 set .min 0
     1 set .minOre null
     2 set *signature "0:v1"
-    * label *label1
     3 label *label3
     4 ubind @mono
     5 jump *label3 equal @unit null

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
     5 jump *label3 equal @unit null
     6 set :backgroundProcess:firstItem @unit
     7 label *label6
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+    8 ulocate building core false @copper .coreX .coreY 0 .core
     9 jump *label6 equal .core null
    10 label *label9
    11 ubind @mono
 
    45 sensor *tmp33 @unit @firstItem
    46 jump *label9 notEqual *tmp33 null
    47 label *label27
-    * ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp36 *tmp37
+   48 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    49 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    50 ucontrol mine :findOreToMine:x :findOreToMine:y
    51 op mul *tmp38 :findOreToMine:x 1000
 
   123 print " "
   124 print :mine:y
   125 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp74 :mine:block :mine:floor
+  126 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   127 jump *label51 equal :mine:floor *tmp59
   128 jump *label53 notEqual :mine:floor null
   129 print ": too far"

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    28 op equal *tmp22 *tmp19 @sand
    29 op land *tmp23 *tmp22 .scrap
    30 select .minOre notEqual *tmp23 false @scrap *tmp19
-    * print "minOre:"
-    * print .minOre
-    * print "\n"
+   31 print "minOre:{0}\n"
+   32 format .minOre
    33 op add *tmp81 *tmp17 100
    34 select .min lessThan *tmp17 10 -100 *tmp81
    35 label *label14
    36 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   37 print "Unit flag: {0}\n"
+   38 format :backgroundProcess:flag
    39 jump *label24 notEqual :backgroundProcess:flag 0
    40 sensor *tmp30 @unit @firstItem
    41 jump *label27 equal *tmp30 null
 
    53 op mul *tmp42 *tmp41 2
    54 op add *tmp43 *tmp40 *tmp42
    55 ucontrol flag *tmp43
-    * print "Found "
-    * print .minOre
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   56 print "Found {0} at {0}, {0}\n"
+   57 format .minOre
+   58 format :findOreToMine:x
+   59 format :findOreToMine:y
    60 jump *label9 always
    61 label *label24
    62 jump *label31 notEqual :backgroundProcess:flag 1
 
    74 label *label35
    75 sensor *tmp51 @unit @firstItem
    76 jump *label36 notEqual *tmp51 null
-    * print " (finished)"
-    * print "\n"
+   77 print " (finished)\n"
    78 ucontrol flag 0
    79 label *label36
    80 print "\n"
 
   109 ucontrol flag 1
   110 jump *label50 always
   111 label *label49
-    * print " at "
-    * print :mine:x
-    * print ","
-    * print " "
+  112 print " at {0}, "
+  113 format :mine:x
   114 print :mine:y
   115 ucontrol approach :mine:x :mine:y 7
   116 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   117 jump *label51 equal :mine:floor *tmp59
   118 jump *label53 notEqual :mine:floor null
-    * print ": too far"
-    * print "\n"
+  119 print ": too far\n"
   120 jump *label52 always
   121 label *label53
   122 ucontrol flag 1
-    * print ": no ore!"
-    * print "\n"
+  123 print ": no ore!\n"
   124 jump *label52 always
   125 label *label51
   126 jump *label55 notEqual :mine:block null
 
   128 jump *label56 always
   129 label *label55
   130 ucontrol flag 1
-    * print ": blocked!"
-    * print "\n"
+  131 print ": blocked!\n"
   132 label *label56
   133 label *label52
   134 label *label50

Final code before resolving virtual instructions:

    0:  set .min 0                                                   var min = 0, minOre = null;
    1:  set .minOre null                                             ...
    2:  set *signature "0:v1"                                        #set target = 8;
        label *label3                                                do
    3:  ubind @mono                                                  ubind(@mono);
    4:  jump *label3 equal @unit null                                do
    5:  set :backgroundProcess:firstItem @unit                       var firstItem = @unit;
        label *label6                                                do
    6:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
    7:  jump *label6 equal .core null                                do
        label *label9                                                while true do
    8:  ubind @mono                                                  ubind(@mono);
    9:  sensor *tmp4 :backgroundProcess:firstItem @dead              if firstItem.@dead then firstItem = @unit; end;
   10:  select :backgroundProcess:firstItem notEqual *tmp4 false @un ...
   11:  jump *label14 notEqual @unit :backgroundProcess:firstItem    if @unit == firstItem then
   12:  printflush message1                                          printflush(message1);
   13:  sensor *tmp9 .core @lead                                     var lead = core.@lead - leadTarget;
   14:  op sub :backgroundProcess:lead *tmp9 .leadTarget             ...
   15:  sensor *tmp11 .sandContainer @sand                           var sand = sandContainer.@sand + sandContainer.@scrap - sandTarget;
   16:  sensor *tmp12 .sandContainer @scrap                          ...
   17:  op add *tmp13 *tmp11 *tmp12                                  ...
   18:  op sub :backgroundProcess:sand *tmp13 .sandTarget            ...
   19:  sensor *tmp15 .core @copper                                  var copper = core.@copper - copperTarget;
   20:  op sub :backgroundProcess:copper *tmp15 .copperTarget        ...
   21:  op min *tmp17 :backgroundProcess:lead :backgroundProcess:san min = min(lead, sand, copper);
   22:  op min *tmp17 *tmp17 :backgroundProcess:copper               ...
   23:  select *tmp86 equal *tmp17 :backgroundProcess:lead @lead @co minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   24:  select *tmp19 equal *tmp17 :backgroundProcess:sand @sand *tm ...
   25:  op equal *tmp22 *tmp19 @sand                                 if minOre == @sand and scrap then minOre = @scrap; end;
   26:  op land *tmp23 *tmp22 .scrap                                 ...
   27:  select .minOre notEqual *tmp23 false @scrap *tmp19           ...
   28:  print "minOre:{0}\n"                                         println("minOre:", minOre);
   29:  format .minOre                                               ...
   30:  op add *tmp81 *tmp17 100                                     if min < 10 then min = -100; else min += 100; end;
   31:  select .min lessThan *tmp17 10 -100 *tmp81                   ...
        label *label14                                               if @unit == firstItem then
   32:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   33:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   34:  format :backgroundProcess:flag                               ...
   35:  jump *label24 notEqual :backgroundProcess:flag 0             if flag == 0 then
   36:  sensor *tmp30 @unit @firstItem                               if @unit.@firstItem != null then
   37:  jump *label27 equal *tmp30 null                              ...
   38:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   39:  sensor *tmp33 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   40:  jump *label9 notEqual *tmp33 null                            ...
        label *label27                                               if @unit.@firstItem != null then
   41:  ulocate ore core true .minOre :findOreToMine:x :findOreToMin ulocate(:ore, ore, out x, out y);
   42:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   43:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   44:  op mul *tmp38 :findOreToMine:x 1000                          flag((x * 1000 + y) * 32 + ore.@id * 2);
   45:  op add *tmp39 *tmp38 :findOreToMine:y                        ...
   46:  op mul *tmp40 *tmp39 32                                      ...
   47:  sensor *tmp41 .minOre @id                                    ...
   48:  op mul *tmp42 *tmp41 2                                       ...
   49:  op add *tmp43 *tmp40 *tmp42                                  ...
   50:  ucontrol flag *tmp43 0 0 0 0                                 ...
   51:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   52:  format .minOre                                               ...
   53:  format :findOreToMine:x                                      ...
   54:  format :findOreToMine:y                                      ...
   55:  jump *label9 always 0 0                                      if flag == 0 then
        label *label24                                               ...
   56:  jump *label31 notEqual :backgroundProcess:flag 1             elsif flag == 1 then
   57:  print "Returning ore"                                        print("Returning ore");
   58:  sensor *tmp46 @unit @firstItem                               if @unit.@firstItem == @scrap then
   59:  jump *label34 notEqual *tmp46 @scrap                         ...
   60:  sensor *tmp49 .sandContainer @x                              approach(sandContainer.@x, sandContainer.@y, RADIUS);
   61:  sensor *tmp50 .sandContainer @y                              ...
   62:  ucontrol approach *tmp49 *tmp50 7 0 0                        ...
   63:  ucontrol itemDrop .sandContainer 20 0 0 0                    itemDrop(sandContainer, capacity);
   64:  jump *label35 always 0 0                                     if @unit.@firstItem == @scrap then
        label *label34                                               ...
   65:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   66:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
        label *label35                                               if @unit.@firstItem == @scrap then
   67:  sensor *tmp51 @unit @firstItem                               if @unit.@firstItem == null then
   68:  jump *label36 notEqual *tmp51 null                           ...
   69:  print " (finished)\n"                                        println(" (finished)");
   70:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label36                                               if @unit.@firstItem == null then
   71:  print "\n"                                                   println();
   72:  jump *label9 always 0 0                                      elsif flag == 1 then
        label *label31                                               ...
   73:  print "Mining"                                               print("Mining");
   74:  op idiv :mine:flag :backgroundProcess:flag 2                 flag \= 2;
   75:  op mod *tmp54 :mine:flag 16                                  var ore = lookup(:item, flag % 16);
   76:  lookup item :mine:ore *tmp54                                 ...
   77:  op idiv :mine:flag :mine:flag 16                             flag \= 16;
   78:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   79:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   80:  select *tmp90 equal :mine:ore @lead @ore-lead @sand-floor    ore == @copper ? @ore-copper :
   81:  select *tmp59 equal :mine:ore @copper @ore-copper *tmp90     ...
   82:  jump *label43 equal :mine:ore .minOre                        if ore != minOre then
   83:  sensor *tmp64 .core :mine:ore                                if core.sensor(ore) > min then
   84:  jump *label45 lessThanEq *tmp64 .min                         ...
   85:  print ", switching to a more needed ore"                     print(", switching to a more needed ore");
   86:  ucontrol flag 1 0 0 0 0                                      flag(1);
   87:  jump *label9 always 0 0                                      return;
        label *label45                                               if core.sensor(ore) > min then
        label *label43                                               if ore != minOre then
   88:  sensor *tmp67 @unit @firstItem                               if @unit.@firstItem != ore then
   89:  jump *label47 equal *tmp67 :mine:ore                         ...
   90:  print " (dropping)"                                          print(" (dropping)");
   91:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label47                                               if @unit.@firstItem != ore then
   92:  sensor *tmp70 @unit @totalItems                              if @unit.@totalItems >= capacity then
   93:  jump *label49 lessThan *tmp70 20                             ...
   94:  print ", full"                                               print(", full");
   95:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   96:  ucontrol flag 1 0 0 0 0                                      flag(1);
   97:  jump *label50 always 0 0                                     if @unit.@totalItems >= capacity then
        label *label49                                               ...
   98:  print " at {0}, "                                            print($" at $x, $y");
   99:  format :mine:x                                               ...
  100:  print :mine:y                                                ...
  101:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
  102:  ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor  var block = getBlock(x, y, , out floor);
  103:  jump *label51 equal :mine:floor *tmp59                       if floor != floorOre then
  104:  jump *label53 notEqual :mine:floor null                      if floor == null then
  105:  print ": too far\n"                                          println(": too far");
  106:  jump *label52 always 0 0                                     if floor == null then
        label *label53                                               ...
  107:  ucontrol flag 1 0 0 0 0                                      flag(1);
  108:  print ": no ore!\n"                                          println(": no ore!");
  109:  jump *label52 always 0 0                                     if floor != floorOre then
        label *label51                                               ...
  110:  jump *label55 notEqual :mine:block null                      elsif block == null then
  111:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
  112:  jump *label56 always 0 0                                     elsif block == null then
        label *label55                                               ...
  113:  ucontrol flag 1 0 0 0 0                                      flag(1);
  114:  print ": blocked!\n"                                         println(": blocked!");
        label *label56                                               elsif block == null then
        label *label52                                               if floor != floorOre then
        label *label50                                               if @unit.@totalItems >= capacity then
  115:  print "\n"                                                   println();
  116:  jump *label9 always 0 0                                      while true do


Performance: parsed in 218 ms, compiled in 272 ms, optimized in 269 ms, run in 5 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (4 steps):
The program didn't generate any output.
Execution exception at instruction 3: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
