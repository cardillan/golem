   151 instructions before optimizations.
     8 instructions eliminated by Temp Variables Elimination (2 iterations).
    18 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    13 instructions eliminated by Jump Optimization (5 iterations).
     8 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     2 instructions eliminated by If Expression Optimization (3 iterations).
     6 instructions eliminated by Data Flow Optimization (6 iterations).
     1 instructions eliminated by Jump Straightening (5 iterations).
     5 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    12 instructions eliminated by Print Merging.
    81 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-14 instructions):
 
    19 op equal *tmp4 @unit :firstItem
    20 jump *label9 equal *tmp4 false
    21 printflush message1
-    * set *tmp5 null
    22 jump *label10 always
    23 label *label9
-    * set *tmp5 null
    24 label *label10
    25 sensor *tmp6 .core @lead
    26 set :lead *tmp6
 
    70 label *label20
    71 set *tmp22 null
    72 label *label21
-    * set *tmp19 *tmp22
    73 jump *label19 always
    74 label *label18
-    * set *tmp19 null
    75 label *label19
    76 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp23 *tmp24
    77 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    93 print :findOreToMine:y
    94 print "\n"
    95 label *label17
-    * set *tmp16 null
    96 jump *label16 always
    97 label *label15
    98 op equal *tmp31 :flag 1
 
   107 print "    Finished"
   108 print "\n"
   109 ucontrol flag 0
-    * set *tmp35 null
   110 jump *label26 always
   111 label *label25
-    * set *tmp35 null
   112 label *label26
   113 label *label24
   114 set *tmp32 null
 
   132 print ", switching"
   133 ucontrol flag 1
   134 jump *label27 always
-    * set *tmp43 null
   135 jump *label29 always
   136 label *label28
-    * set *tmp43 null
   137 label *label29
   138 sensor *tmp44 @unit @firstItem
   139 op notEqual *tmp45 *tmp44 :mine:ore
   140 jump *label30 equal *tmp45 false
   141 print ", dropping"
   142 ucontrol itemDrop @air 20
-    * set *tmp46 null
   143 jump *label31 always
   144 label *label30
-    * set *tmp46 null
   145 label *label31
   146 print ", mining at "
   147 print :mine:x
 
   156 print ", full"
   157 ucontrol approach .coreX .coreY 7
   158 ucontrol flag 1
-    * set *tmp49 null
   159 jump *label33 always
   160 label *label32
-    * set *tmp49 null
   161 label *label33
   162 print "\n"
   163 label *label27
   164 set *tmp32 null
   165 label *label23
-    * set *tmp16 *tmp32
   166 label *label16
   167 label *label7
   168 jump *label6 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-4 instructions):
 
    65 op notEqual *tmp21 *tmp20 null
    66 jump *label20 equal *tmp21 false
    67 jump *label17 always
-    * set *tmp22 null
    68 jump *label21 always
    69 label *label20
-    * set *tmp22 null
    70 label *label21
    71 jump *label19 always
    72 label *label18
 
   109 label *label25
   110 label *label26
   111 label *label24
-    * set *tmp32 null
   112 jump *label23 always
   113 label *label22
   114 set :mine:flag :flag
 
   158 label *label33
   159 print "\n"
   160 label *label27
-    * set *tmp32 null
   161 label *label23
   162 label *label16
   163 label *label7

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-8 instructions):
 
     7 label *label2
     8 set :firstItem @unit
     9 label *label3
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   10 ulocate building core false @copper .coreX .coreY 0 .core
    11 label *label4
    12 op equal *tmp3 .core null
    13 jump *label3 notEqual *tmp3 false
 
    21 jump *label10 always
    22 label *label9
    23 label *label10
-    * sensor *tmp6 .core @lead
-    * set :lead *tmp6
-    * sensor *tmp7 .core @sand
-    * set :sand *tmp7
-    * sensor *tmp8 .core @copper
-    * set :copper *tmp8
+   24 sensor :lead .core @lead
+   25 sensor :sand .core @sand
+   26 sensor :copper .core @copper
    27 op min *tmp9 :lead :sand
    28 op min *tmp9 *tmp9 :copper
    29 set .min *tmp9
 
    45 print "minOre:"
    46 print .minOre
    47 print "\n"
-    * sensor *tmp14 @unit @flag
-    * set :flag *tmp14
+   48 sensor :flag @unit @flag
    49 print "Unit flag: "
    50 print :flag
    51 print "\n"
 
    66 jump *label19 always
    67 label *label18
    68 label *label19
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp23 *tmp24
+   69 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
    70 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    71 ucontrol mine :findOreToMine:x :findOreToMine:y
    72 op mul *tmp25 :findOreToMine:x 1000
 
   110 print "Mining: "
   111 op idiv :mine:flag :mine:flag 2
   112 op mod *tmp36 :mine:flag 16
-    * lookup item *tmp37 *tmp36
-    * set :mine:ore *tmp37
+  113 lookup item :mine:ore *tmp36
   114 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp38 :mine:flag 1000
-    * set :mine:y *tmp38
-    * op idiv *tmp39 :mine:flag 1000
-    * set :mine:x *tmp39
+  115 op mod :mine:y :mine:flag 1000
+  116 op idiv :mine:x :mine:flag 1000
   117 sensor *tmp40 .core :mine:ore
   118 op add *tmp41 .min 500
   119 op greaterThan *tmp42 *tmp40 *tmp41

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    13 jump *label3 notEqual *tmp3 false
    14 label *label5
    15 label *label6
-    * jump *label8 equal true false
    16 ubind @mono
    17 op equal *tmp4 @unit :firstItem
    18 jump *label9 equal *tmp4 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-13 instructions):
 
     2 label *label0
     3 ubind @mono
     4 label *label1
-    * op equal *tmp0 @unit null
-    * jump *label0 notEqual *tmp0 false
+    5 jump *label0 equal @unit null
     6 label *label2
     7 set :firstItem @unit
     8 label *label3
     9 ulocate building core false @copper .coreX .coreY 0 .core
    10 label *label4
-    * op equal *tmp3 .core null
-    * jump *label3 notEqual *tmp3 false
+   11 jump *label3 equal .core null
    12 label *label5
    13 label *label6
    14 ubind @mono
-    * op equal *tmp4 @unit :firstItem
-    * jump *label9 equal *tmp4 false
+   15 jump *label9 notEqual @unit :firstItem
    16 printflush message1
    17 jump *label10 always
    18 label *label9
 
    23 op min *tmp9 :lead :sand
    24 op min *tmp9 *tmp9 :copper
    25 set .min *tmp9
-    * op equal *tmp10 .min :sand
-    * jump *label11 equal *tmp10 false
+   26 jump *label11 notEqual .min :sand
    27 set *tmp11 @sand
    28 jump *label12 always
    29 label *label11
-    * op equal *tmp12 .min :lead
-    * jump *label13 equal *tmp12 false
+   30 jump *label13 notEqual .min :lead
    31 set *tmp13 @lead
    32 jump *label14 always
    33 label *label13
 
    43 print "Unit flag: "
    44 print :flag
    45 print "\n"
-    * op equal *tmp15 :flag 0
-    * jump *label15 equal *tmp15 false
+   46 jump *label15 notEqual :flag 0
    47 set :findOreToMine:ore .minOre
    48 sensor *tmp17 @unit @firstItem
-    * op notEqual *tmp18 *tmp17 null
-    * jump *label18 equal *tmp18 false
+   49 jump *label18 equal *tmp17 null
    50 ucontrol itemDrop @air 20
    51 sensor *tmp20 @unit @firstItem
-    * op notEqual *tmp21 *tmp20 null
-    * jump *label20 equal *tmp21 false
+   52 jump *label20 equal *tmp20 null
    53 jump *label17 always
    54 jump *label21 always
    55 label *label20
 
    79 label *label17
    80 jump *label16 always
    81 label *label15
-    * op equal *tmp31 :flag 1
-    * jump *label22 equal *tmp31 false
+   82 jump *label22 notEqual :flag 1
    83 print "Returning"
    84 print "\n"
    85 ucontrol approach .coreX .coreY 7
    86 ucontrol itemDrop .core 20
    87 sensor *tmp33 @unit @firstItem
-    * op equal *tmp34 *tmp33 null
-    * jump *label25 equal *tmp34 false
+   88 jump *label25 notEqual *tmp33 null
    89 print "    Finished"
    90 print "\n"
    91 ucontrol flag 0
 
   105 op idiv :mine:x :mine:flag 1000
   106 sensor *tmp40 .core :mine:ore
   107 op add *tmp41 .min 500
-    * op greaterThan *tmp42 *tmp40 *tmp41
-    * jump *label28 equal *tmp42 false
+  108 jump *label28 lessThanEq *tmp40 *tmp41
   109 print ", switching"
   110 ucontrol flag 1
   111 jump *label27 always
 
   113 label *label28
   114 label *label29
   115 sensor *tmp44 @unit @firstItem
-    * op notEqual *tmp45 *tmp44 :mine:ore
-    * jump *label30 equal *tmp45 false
+  116 jump *label30 equal *tmp44 :mine:ore
   117 print ", dropping"
   118 ucontrol itemDrop @air 20
   119 jump *label31 always
 
   127 ucontrol approach :mine:x :mine:y 7
   128 ucontrol mine :mine:x :mine:y
   129 sensor *tmp47 @unit @totalItems
-    * op greaterThanEq *tmp48 *tmp47 20
-    * jump *label32 equal *tmp48 false
+  130 jump *label32 lessThan *tmp47 20
   131 print ", full"
   132 ucontrol approach .coreX .coreY 7
   133 ucontrol flag 1

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    14 ubind @mono
    15 jump *label9 notEqual @unit :firstItem
    16 printflush message1
-    * jump *label10 always
    17 label *label9
    18 label *label10
    19 sensor :lead .core @lead
 
    50 sensor *tmp20 @unit @firstItem
    51 jump *label20 equal *tmp20 null
    52 jump *label17 always
-    * jump *label21 always
    53 label *label20
    54 label *label21
-    * jump *label19 always
    55 label *label18
    56 label *label19
    57 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
 
    86 print "    Finished"
    87 print "\n"
    88 ucontrol flag 0
-    * jump *label26 always
    89 label *label25
    90 label *label26
    91 label *label24
 
   105 print ", switching"
   106 ucontrol flag 1
   107 jump *label27 always
-    * jump *label29 always
   108 label *label28
   109 label *label29
   110 sensor *tmp44 @unit @firstItem
   111 jump *label30 equal *tmp44 :mine:ore
   112 print ", dropping"
   113 ucontrol itemDrop @air 20
-    * jump *label31 always
   114 label *label30
   115 label *label31
   116 print ", mining at "
 
   125 print ", full"
   126 ucontrol approach .coreX .coreY 7
   127 ucontrol flag 1
-    * jump *label33 always
   128 label *label32
   129 label *label33
   130 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
-    * set .min 0
-    * set .minOre null
     0 label *label0
     1 ubind @mono
     2 label *label1
 
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
    22 set .min *tmp9
-    * jump *label11 notEqual .min :sand
+   23 jump *label11 notEqual *tmp9 :sand
    24 set *tmp11 @sand
    25 jump *label12 always
    26 label *label11
-    * jump *label13 notEqual .min :lead
+   27 jump *label13 notEqual *tmp9 :lead
    28 set *tmp13 @lead
    29 jump *label14 always
    30 label *label13
 
    34 label *label12
    35 set .minOre *tmp11
    36 print "minOre:"
-    * print .minOre
+   37 print *tmp11
    38 print "\n"
    39 sensor :flag @unit @flag
    40 print "Unit flag: "
    41 print :flag
    42 print "\n"
    43 jump *label15 notEqual :flag 0
-    * set :findOreToMine:ore .minOre
+   44 set :findOreToMine:ore *tmp11
    45 sensor *tmp17 @unit @firstItem
    46 jump *label18 equal *tmp17 null
    47 ucontrol itemDrop @air 20
 
    52 label *label21
    53 label *label18
    54 label *label19
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
+   55 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    56 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    57 ucontrol mine :findOreToMine:x :findOreToMine:y
    58 op mul *tmp25 :findOreToMine:x 1000
    59 op add *tmp26 *tmp25 :findOreToMine:y
    60 op mul *tmp27 *tmp26 32
-    * sensor *tmp28 :findOreToMine:ore @id
+   61 sensor *tmp28 .minOre @id
    62 op mul *tmp29 *tmp28 2
    63 op add *tmp30 *tmp27 *tmp29
    64 ucontrol flag *tmp30
    65 print "Found "
-    * print :findOreToMine:ore
+   66 print .minOre
    67 print " "
    68 print "at "
    69 print :findOreToMine:x
 
    91 label *label22
    92 set :mine:flag :flag
    93 print "Mining: "
-    * op idiv :mine:flag :mine:flag 2
+   94 op idiv :mine:flag :flag 2
    95 op mod *tmp36 :mine:flag 16
    96 lookup item :mine:ore *tmp36
    97 op idiv :mine:flag :mine:flag 16
    98 op mod :mine:y :mine:flag 1000
    99 op idiv :mine:x :mine:flag 1000
   100 sensor *tmp40 .core :mine:ore
-    * op add *tmp41 .min 500
+  101 op add *tmp41 *tmp9 500
   102 jump *label28 lessThanEq *tmp40 *tmp41
   103 print ", switching"
   104 ucontrol flag 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    19 sensor :copper .core @copper
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
-    * set .min *tmp9
    22 jump *label11 notEqual *tmp9 :sand
    23 set *tmp11 @sand
    24 jump *label12 always
 
    40 print :flag
    41 print "\n"
    42 jump *label15 notEqual :flag 0
-    * set :findOreToMine:ore *tmp11
    43 sensor *tmp17 @unit @firstItem
    44 jump *label18 equal *tmp17 null
    45 ucontrol itemDrop @air 20
 
    50 label *label21
    51 label *label18
    52 label *label19
-    * ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
+   53 ulocate ore core true *tmp11 :findOreToMine:x :findOreToMine:y 0 0
    54 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    55 ucontrol mine :findOreToMine:x :findOreToMine:y
    56 op mul *tmp25 :findOreToMine:x 1000
    57 op add *tmp26 *tmp25 :findOreToMine:y
    58 op mul *tmp27 *tmp26 32
-    * sensor *tmp28 .minOre @id
+   59 sensor *tmp28 *tmp11 @id
    60 op mul *tmp29 *tmp28 2
    61 op add *tmp30 *tmp27 *tmp29
    62 ucontrol flag *tmp30
    63 print "Found "
-    * print .minOre
+   64 print *tmp11
    65 print " "
    66 print "at "
    67 print :findOreToMine:x
 
    87 label *label24
    88 jump *label23 always
    89 label *label22
-    * set :mine:flag :flag
    90 print "Mining: "
    91 op idiv :mine:flag :flag 2
    92 op mod *tmp36 :mine:flag 16

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
    31 label *label14
    32 set *tmp11 *tmp13
    33 label *label12
-    * set .minOre *tmp11
    34 print "minOre:"
    35 print *tmp11
    36 print "\n"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    19 sensor :copper .core @copper
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
-    * jump *label11 notEqual *tmp9 :sand
    22 set *tmp11 @sand
-    * jump *label12 always
+   23 jump *label12 equal *tmp9 :sand
    24 label *label11
-    * jump *label13 notEqual *tmp9 :lead
-    * set *tmp13 @lead
+   25 set *tmp11 @copper
+   26 jump *label14 notEqual *tmp9 :lead
+   27 set *tmp11 @lead
    28 jump *label14 always
-    * label *label13
-    * set *tmp13 @copper
    29 label *label14
-    * set *tmp11 *tmp13
    30 label *label12
    31 print "minOre:"
    32 print *tmp11

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    25 set *tmp11 @copper
    26 jump *label14 notEqual *tmp9 :lead
    27 set *tmp11 @lead
-    * jump *label14 always
    28 label *label14
    29 label *label12
    30 print "minOre:"

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
     0 label *label0
     1 ubind @mono
-    * label *label1
     2 jump *label0 equal @unit null
-    * label *label2
     3 set :firstItem @unit
     4 label *label3
     5 ulocate building core false @copper .coreX .coreY 0 .core
-    * label *label4
     6 jump *label3 equal .core null
-    * label *label5
     7 label *label6
     8 ubind @mono
     9 jump *label9 notEqual @unit :firstItem
    10 printflush message1
    11 label *label9
-    * label *label10
    12 sensor :lead .core @lead
    13 sensor :sand .core @sand
    14 sensor :copper .core @copper
 
    16 op min *tmp9 *tmp9 :copper
    17 set *tmp11 @sand
    18 jump *label12 equal *tmp9 :sand
-    * label *label11
    19 set *tmp11 @copper
    20 jump *label14 notEqual *tmp9 :lead
    21 set *tmp11 @lead
 
    36 jump *label20 equal *tmp20 null
    37 jump *label17 always
    38 label *label20
-    * label *label21
    39 label *label18
-    * label *label19
    40 ulocate ore core true *tmp11 :findOreToMine:x :findOreToMine:y 0 0
    41 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    42 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    70 print "\n"
    71 ucontrol flag 0
    72 label *label25
-    * label *label26
-    * label *label24
    73 jump *label23 always
    74 label *label22
    75 print "Mining: "
 
    86 ucontrol flag 1
    87 jump *label27 always
    88 label *label28
-    * label *label29
    89 sensor *tmp44 @unit @firstItem
    90 jump *label30 equal *tmp44 :mine:ore
    91 print ", dropping"
    92 ucontrol itemDrop @air 20
    93 label *label30
-    * label *label31
    94 print ", mining at "
    95 print :mine:x
    96 print ","
 
   104 ucontrol approach .coreX .coreY 7
   105 ucontrol flag 1
   106 label *label32
-    * label *label33
   107 print "\n"
   108 label *label27
   109 label *label23
   110 label *label16
-    * label *label7
   111 jump *label6 always
-    * label *label8
   112 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    33 jump *label18 equal *tmp17 null
    34 ucontrol itemDrop @air 20
    35 sensor *tmp20 @unit @firstItem
-    * jump *label20 equal *tmp20 null
-    * jump *label17 always
+   36 jump *label17 notEqual *tmp20 null
    37 label *label20
    38 label *label18
    39 ulocate ore core true *tmp11 :findOreToMine:x :findOreToMine:y 0 0

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    34 ucontrol itemDrop @air 20
    35 sensor *tmp20 @unit @firstItem
    36 jump *label17 notEqual *tmp20 null
-    * label *label20
    37 label *label18
    38 ulocate ore core true *tmp11 :findOreToMine:x :findOreToMine:y 0 0
    39 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    33 jump *label18 equal *tmp17 null
    34 ucontrol itemDrop @air 20
    35 sensor *tmp20 @unit @firstItem
-    * jump *label17 notEqual *tmp20 null
+   36 jump *label6 notEqual *tmp20 null
    37 label *label18
    38 ulocate ore core true *tmp11 :findOreToMine:x :findOreToMine:y 0 0
    39 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    55 print :findOreToMine:y
    56 print "\n"
    57 label *label17
-    * jump *label16 always
+   58 jump *label6 always
    59 label *label15
    60 jump *label22 notEqual :flag 1
    61 print "Returning"
 
    63 ucontrol approach .coreX .coreY 7
    64 ucontrol itemDrop .core 20
    65 sensor *tmp33 @unit @firstItem
-    * jump *label25 notEqual *tmp33 null
+   66 jump *label6 notEqual *tmp33 null
    67 print "    Finished"
    68 print "\n"
    69 ucontrol flag 0
    70 label *label25
-    * jump *label23 always
+   71 jump *label6 always
    72 label *label22
    73 print "Mining: "
    74 op idiv :mine:flag :flag 2
 
    82 jump *label28 lessThanEq *tmp40 *tmp41
    83 print ", switching"
    84 ucontrol flag 1
-    * jump *label27 always
+   85 jump *label6 always
    86 label *label28
    87 sensor *tmp44 @unit @firstItem
    88 jump *label30 equal *tmp44 :mine:ore

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-1 instructions):
 
    54 print " "
    55 print :findOreToMine:y
    56 print "\n"
-    * label *label17
    57 jump *label6 always
    58 label *label15
    59 jump *label22 notEqual :flag 1
 
    66 print "    Finished"
    67 print "\n"
    68 ucontrol flag 0
-    * label *label25
    69 jump *label6 always
    70 label *label22
    71 print "Mining: "
 
   101 ucontrol flag 1
   102 label *label32
   103 print "\n"
-    * label *label27
-    * label *label23
-    * label *label16
   104 jump *label6 always
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-12 instructions):
 
    21 set *tmp11 @lead
    22 label *label14
    23 label *label12
-    * print "minOre:"
-    * print *tmp11
-    * print "\n"
+   24 print "minOre:{0}\nUnit flag: {0}\n"
+   25 format *tmp11
    26 sensor :flag @unit @flag
-    * print "Unit flag: "
-    * print :flag
-    * print "\n"
+   27 format :flag
    28 jump *label15 notEqual :flag 0
    29 sensor *tmp17 @unit @firstItem
    30 jump *label18 equal *tmp17 null
 
    42 op mul *tmp29 *tmp28 2
    43 op add *tmp30 *tmp27 *tmp29
    44 ucontrol flag *tmp30
-    * print "Found "
-    * print *tmp11
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   45 print "Found {0} at {0}, {0}\n"
+   46 format *tmp11
+   47 format :findOreToMine:x
+   48 format :findOreToMine:y
    49 jump *label6 always
    50 label *label15
    51 jump *label22 notEqual :flag 1
-    * print "Returning"
-    * print "\n"
+   52 print "Returning\n"
    53 ucontrol approach .coreX .coreY 7
    54 ucontrol itemDrop .core 20
    55 sensor *tmp33 @unit @firstItem
    56 jump *label6 notEqual *tmp33 null
-    * print "    Finished"
-    * print "\n"
+   57 print "    Finished\n"
    58 ucontrol flag 0
    59 jump *label6 always
    60 label *label22
 
    77 print ", dropping"
    78 ucontrol itemDrop @air 20
    79 label *label30
-    * print ", mining at "
-    * print :mine:x
-    * print ","
-    * print " "
+   80 print ", mining at {0}, "
+   81 format :mine:x
    82 print :mine:y
    83 ucontrol approach :mine:x :mine:y 7
    84 ucontrol mine :mine:x :mine:y

Final code before resolving virtual instructions:

    0:  jump *label34 always 0 0
    1:  draw triangle message1 .core .coreX .coreY :copper :firstItem
    2:  draw triangle :flag :lead :sand :findOreToMine:x :findOreToMine:y :mine:flag
    3:  draw triangle :mine:ore :mine:x :mine:y 0 0 0
        label *label34
        label *label0                                                do
    4:  ubind @mono                                                  ubind(@mono);
    5:  jump *label0 equal @unit null                                do
    6:  set :firstItem @unit                                         var firstItem = @unit;
        label *label3                                                do
    7:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
    8:  jump *label3 equal .core null                                do
        label *label6                                                while true do
    9:  ubind @mono                                                  ubind(@mono);
   10:  jump *label9 notEqual @unit :firstItem                       if @unit == firstItem then printflush(message1); end;
   11:  printflush message1                                          ...
        label *label9                                                ...
   12:  sensor :lead .core @lead                                     var lead = core.@lead;
   13:  sensor :sand .core @sand                                     var sand = core.@sand;
   14:  sensor :copper .core @copper                                 var copper = core.@copper;
   15:  op min *tmp9 :lead :sand                                     min = min(lead, sand, copper);
   16:  op min *tmp9 *tmp9 :copper                                   ...
   17:  set *tmp11 @sand                                             minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   18:  jump *label12 equal *tmp9 :sand                              ...
   19:  set *tmp11 @copper                                           ...
   20:  jump *label14 notEqual *tmp9 :lead                           ...
   21:  set *tmp11 @lead                                             ...
        label *label14                                               ...
        label *label12                                               ...
   22:  print "minOre:{0}\nUnit flag: {0}\n"                         println("minOre:", minOre);
   23:  format *tmp11                                                ...
   24:  sensor :flag @unit @flag                                     var flag = @unit.@flag;
   25:  format :flag                                                 println("Unit flag: ", flag);
   26:  jump *label15 notEqual :flag 0                               if flag == 0 then
   27:  sensor *tmp17 @unit @firstItem                               if @unit.@firstItem != null then
   28:  jump *label18 equal *tmp17 null                              ...
   29:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   30:  sensor *tmp20 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   31:  jump *label6 notEqual *tmp20 null                            ...
        label *label18                                               if @unit.@firstItem != null then
   32:  ulocate ore core true *tmp11 :findOreToMine:x :findOreToMine ulocate(:ore, ore, out x, out y);
   33:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   34:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   35:  op mul *tmp25 :findOreToMine:x 1000                          flag((x * 1000 + y) * 32 + ore.@id * 2);
   36:  op add *tmp26 *tmp25 :findOreToMine:y                        ...
   37:  op mul *tmp27 *tmp26 32                                      ...
   38:  sensor *tmp28 *tmp11 @id                                     ...
   39:  op mul *tmp29 *tmp28 2                                       ...
   40:  op add *tmp30 *tmp27 *tmp29                                  ...
   41:  ucontrol flag *tmp30 0 0 0 0                                 ...
   42:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   43:  format *tmp11                                                ...
   44:  format :findOreToMine:x                                      ...
   45:  format :findOreToMine:y                                      ...
   46:  jump *label6 always 0 0                                      if flag == 0 then
        label *label15                                               ...
   47:  jump *label22 notEqual :flag 1                               elsif flag == 1 then
   48:  print "Returning\n"                                          println("Returning");
   49:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   50:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
   51:  sensor *tmp33 @unit @firstItem                               if @unit.@firstItem == null then
   52:  jump *label6 notEqual *tmp33 null                            ...
   53:  print "    Finished\n"                                       println("    Finished");
   54:  ucontrol flag 0 0 0 0 0                                      flag(0);
   55:  jump *label6 always 0 0                                      elsif flag == 1 then
        label *label22                                               ...
   56:  print "Mining: "                                             print("Mining: ");
   57:  op idiv :mine:flag :flag 2                                   flag \= 2;
   58:  op mod *tmp36 :mine:flag 16                                  var ore = lookup(:item, flag % 16);
   59:  lookup item :mine:ore *tmp36                                 ...
   60:  op idiv :mine:flag :mine:flag 16                             flag \= 16;
   61:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   62:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   63:  sensor *tmp40 .core :mine:ore                                if core.sensor(ore) > min + 500 then
   64:  op add *tmp41 *tmp9 500                                      ...
   65:  jump *label28 lessThanEq *tmp40 *tmp41                       ...
   66:  print ", switching"                                          print(", switching");
   67:  ucontrol flag 1 0 0 0 0                                      flag(1);
   68:  jump *label6 always 0 0                                      return;
        label *label28                                               if core.sensor(ore) > min + 500 then
   69:  sensor *tmp44 @unit @firstItem                               if @unit.@firstItem != ore then
   70:  jump *label30 equal *tmp44 :mine:ore                         ...
   71:  print ", dropping"                                           print(", dropping");
   72:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label30                                               if @unit.@firstItem != ore then
   73:  print ", mining at {0}, "                                    print($", mining at $x, $y");
   74:  format :mine:x                                               ...
   75:  print :mine:y                                                ...
   76:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
   77:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
   78:  sensor *tmp47 @unit @totalItems                              if @unit.@totalItems >= capacity then
   79:  jump *label32 lessThan *tmp47 20                             ...
   80:  print ", full"                                               print(", full");
   81:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   82:  ucontrol flag 1 0 0 0 0                                      flag(1);
        label *label32                                               if @unit.@totalItems >= capacity then
   83:  print "\n"                                                   println();
   84:  jump *label6 always 0 0                                      while true do


Performance: parsed in 204 ms, compiled in 278 ms, optimized in 205 ms, run in 3 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: success.

Program output (2 steps):
The program didn't generate any output.
Execution exception at instruction 4: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
