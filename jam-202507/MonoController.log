   212 instructions before optimizations.
    10 instructions eliminated by Temp Variables Elimination (2 passes, 5 iterations).
    30 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
    20 instructions eliminated by Jump Optimization (4 iterations).
     8 instructions eliminated by Single Step Elimination (5 iterations).
    15 instructions eliminated by If Expression Optimization (4 iterations).
     5 instructions eliminated by Data Flow Optimization (4 iterations).
     1 instructions eliminated by Jump Straightening (4 iterations).
     5 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   106 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-16 instructions):
 
    22 jump *label12 equal *tmp4 false
    23 set *tmp6 @unit
    24 set :backgroundProcess:firstItem *tmp6
-    * set *tmp5 :backgroundProcess:firstItem
    25 jump *label13 always
    26 label *label12
-    * set *tmp5 null
    27 label *label13
    28 op equal *tmp7 @unit :backgroundProcess:firstItem
    29 jump *label14 equal *tmp7 false
 
    67 op add .min .min 100
    68 set *tmp21 .min
    69 label *label21
-    * set *tmp8 *tmp21
    70 jump *label15 always
    71 label *label14
-    * set *tmp8 null
    72 label *label15
    73 sensor *tmp22 @unit @flag
    74 set :backgroundProcess:flag *tmp22
 
    91 label *label27
    92 set *tmp30 null
    93 label *label28
-    * set *tmp27 *tmp30
    94 jump *label26 always
    95 label *label25
-    * set *tmp27 null
    96 label *label26
    97 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp31 *tmp32
    98 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
   114 print :findOreToMine:y
   115 print "\n"
   116 label *label24
-    * set *tmp24 null
   117 jump *label23 always
   118 label *label22
   119 op equal *tmp39 :backgroundProcess:flag 1
 
   127 print " (finished)"
   128 print "\n"
   129 ucontrol flag 0
-    * set *tmp43 null
   130 jump *label33 always
   131 label *label32
-    * set *tmp43 null
   132 label *label33
   133 print "\n"
   134 label *label31
 
   174 label *label41
   175 set *tmp56 null
   176 label *label42
-    * set *tmp53 *tmp56
   177 jump *label40 always
   178 label *label39
-    * set *tmp53 null
   179 label *label40
   180 sensor *tmp57 @unit @firstItem
   181 op notEqual *tmp58 *tmp57 :mine:ore
   182 jump *label43 equal *tmp58 false
   183 print " (dropping)"
   184 ucontrol itemDrop @air 20
-    * set *tmp59 null
   185 jump *label44 always
   186 label *label43
-    * set *tmp59 null
   187 label *label44
   188 sensor *tmp60 @unit @totalItems
   189 op greaterThanEq *tmp61 *tmp60 20
 
   191 print ", full"
   192 ucontrol approach .coreX .coreY 7
   193 ucontrol flag 1
-    * set *tmp62 null
   194 jump *label46 always
   195 label *label45
   196 set :mine:floor null
 
   232 label *label52
   233 set *tmp66 *tmp70
   234 label *label48
-    * set *tmp62 *tmp66
   235 label *label46
   236 print "\n"
   237 label *label34
   238 set *tmp40 null
   239 label *label30
-    * set *tmp24 *tmp40
   240 label *label23
   241 label *label10
   242 jump *label9 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-10 instructions):
 
    61 op lessThan *tmp20 .min 10
    62 jump *label20 equal *tmp20 false
    63 set .min -100
-    * set *tmp21 .min
    64 jump *label21 always
    65 label *label20
    66 op add .min .min 100
-    * set *tmp21 .min
    67 label *label21
    68 jump *label15 always
    69 label *label14
 
    84 op notEqual *tmp29 *tmp28 null
    85 jump *label27 equal *tmp29 false
    86 jump *label24 always
-    * set *tmp30 null
    87 jump *label28 always
    88 label *label27
-    * set *tmp30 null
    89 label *label28
    90 jump *label26 always
    91 label *label25
 
   128 label *label33
   129 print "\n"
   130 label *label31
-    * set *tmp40 null
   131 jump *label30 always
   132 label *label29
   133 set :mine:flag :backgroundProcess:flag
 
   164 print ", switching to a more needed ore"
   165 ucontrol flag 1
   166 jump *label34 always
-    * set *tmp56 null
   167 jump *label42 always
   168 label *label41
-    * set *tmp56 null
   169 label *label42
   170 jump *label40 always
   171 label *label39
 
   209 print "\n"
   210 set *tmp68 ": no ore!"
   211 label *label50
-    * set *tmp66 *tmp68
   212 jump *label48 always
   213 label *label47
   214 op equal *tmp69 :mine:block null
 
   222 print "\n"
   223 set *tmp70 ": blocked!"
   224 label *label52
-    * set *tmp66 *tmp70
   225 label *label48
   226 label *label46
   227 print "\n"
   228 label *label34
-    * set *tmp40 null
   229 label *label30
   230 label *label23
   231 label *label10

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   201 jump *label49 equal *tmp67 false
   202 print ": too far"
   203 print "\n"
-    * set *tmp68 ": too far"
   204 jump *label50 always
   205 label *label49
   206 ucontrol flag 1
   207 print ": no ore!"
   208 print "\n"
-    * set *tmp68 ": no ore!"
   209 label *label50
   210 jump *label48 always
   211 label *label47
   212 op equal *tmp69 :mine:block null
   213 jump *label51 equal *tmp69 false
   214 ucontrol mine :mine:x :mine:y
-    * set *tmp70 null
   215 jump *label52 always
   216 label *label51
   217 ucontrol flag 1
   218 print ": blocked!"
   219 print "\n"
-    * set *tmp70 ": blocked!"
   220 label *label52
   221 label *label48
   222 label *label46

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-10 instructions):
 
     9 label *label5
    10 set :backgroundProcess:firstItem @unit
    11 label *label6
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   12 ulocate building core false @copper .coreX .coreY *tmp2 .core
    13 label *label7
    14 op equal *tmp3 .core null
    15 jump *label6 notEqual *tmp3 false
 
    19 ubind @mono
    20 sensor *tmp4 :backgroundProcess:firstItem @dead
    21 jump *label12 equal *tmp4 false
-    * set *tmp6 @unit
-    * set :backgroundProcess:firstItem *tmp6
+   22 set :backgroundProcess:firstItem @unit
    23 jump *label13 always
    24 label *label12
    25 label *label13
 
    27 jump *label14 equal *tmp7 false
    28 printflush message1
    29 sensor *tmp9 .core @lead
-    * op sub *tmp10 *tmp9 .leadTarget
-    * set :backgroundProcess:lead *tmp10
+   30 op sub :backgroundProcess:lead *tmp9 .leadTarget
    31 sensor *tmp11 .core @sand
-    * op sub *tmp12 *tmp11 .sandTarget
-    * set :backgroundProcess:sand *tmp12
+   32 op sub :backgroundProcess:sand *tmp11 .sandTarget
    33 sensor *tmp13 .core @copper
-    * op sub *tmp14 *tmp13 .copperTarget
-    * set :backgroundProcess:copper *tmp14
+   34 op sub :backgroundProcess:copper *tmp13 .copperTarget
    35 op min *tmp15 :backgroundProcess:lead :backgroundProcess:sand
    36 op min *tmp15 *tmp15 :backgroundProcess:copper
    37 set .min *tmp15
 
    63 jump *label15 always
    64 label *label14
    65 label *label15
-    * sensor *tmp22 @unit @flag
-    * set :backgroundProcess:flag *tmp22
+   66 sensor :backgroundProcess:flag @unit @flag
    67 print "Unit flag: "
    68 print :backgroundProcess:flag
    69 print "\n"
 
   128 print "Mining"
   129 op idiv :mine:flag :mine:flag 2
   130 op mod *tmp44 :mine:flag 16
-    * lookup item *tmp45 *tmp44
-    * set :mine:ore *tmp45
+  131 lookup item :mine:ore *tmp44
   132 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp46 :mine:flag 1000
-    * set :mine:y *tmp46
-    * op idiv *tmp47 :mine:flag 1000
-    * set :mine:x *tmp47
+  133 op mod :mine:y :mine:flag 1000
+  134 op idiv :mine:x :mine:flag 1000
   135 op equal *tmp48 :mine:ore @copper
   136 jump *label35 equal *tmp48 false
   137 set *tmp49 @ore-copper
 
   184 print " "
   185 print :mine:y
   186 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp64 *tmp63 :mine:floor
-    * set :mine:block *tmp63
+  187 ucontrol getBlock :mine:x :mine:y *tmp64 :mine:block :mine:floor
   188 op notEqual *tmp65 :mine:floor :mine:floorOre
   189 jump *label47 equal *tmp65 false
   190 op equal *tmp67 :mine:floor null

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    15 jump *label6 notEqual *tmp3 false
    16 label *label8
    17 label *label9
-    * jump *label11 equal true false
    18 ubind @mono
    19 sensor *tmp4 :backgroundProcess:firstItem @dead
    20 jump *label12 equal *tmp4 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-20 instructions):
 
     4 label *label3
     5 ubind @mono
     6 label *label4
-    * op equal *tmp0 @unit null
-    * jump *label3 notEqual *tmp0 false
+    7 jump *label3 equal @unit null
     8 label *label5
     9 set :backgroundProcess:firstItem @unit
    10 label *label6
    11 ulocate building core false @copper .coreX .coreY *tmp2 .core
    12 label *label7
-    * op equal *tmp3 .core null
-    * jump *label6 notEqual *tmp3 false
+   13 jump *label6 equal .core null
    14 label *label8
    15 label *label9
    16 ubind @mono
 
    20 jump *label13 always
    21 label *label12
    22 label *label13
-    * op equal *tmp7 @unit :backgroundProcess:firstItem
-    * jump *label14 equal *tmp7 false
+   23 jump *label14 notEqual @unit :backgroundProcess:firstItem
    24 printflush message1
    25 sensor *tmp9 .core @lead
    26 op sub :backgroundProcess:lead *tmp9 .leadTarget
 
    31 op min *tmp15 :backgroundProcess:lead :backgroundProcess:sand
    32 op min *tmp15 *tmp15 :backgroundProcess:copper
    33 set .min *tmp15
-    * op equal *tmp16 .min :backgroundProcess:sand
-    * jump *label16 equal *tmp16 false
+   34 jump *label16 notEqual .min :backgroundProcess:sand
    35 set *tmp17 @sand
    36 jump *label17 always
    37 label *label16
-    * op equal *tmp18 .min :backgroundProcess:lead
-    * jump *label18 equal *tmp18 false
+   38 jump *label18 notEqual .min :backgroundProcess:lead
    39 set *tmp19 @lead
    40 jump *label19 always
    41 label *label18
 
    47 print "minOre:"
    48 print .minOre
    49 print "\n"
-    * op lessThan *tmp20 .min 10
-    * jump *label20 equal *tmp20 false
+   50 jump *label20 greaterThanEq .min 10
    51 set .min -100
    52 jump *label21 always
    53 label *label20
 
    60 print "Unit flag: "
    61 print :backgroundProcess:flag
    62 print "\n"
-    * op equal *tmp23 :backgroundProcess:flag 0
-    * jump *label22 equal *tmp23 false
+   63 jump *label22 notEqual :backgroundProcess:flag 0
    64 set :findOreToMine:ore .minOre
    65 sensor *tmp25 @unit @firstItem
-    * op notEqual *tmp26 *tmp25 null
-    * jump *label25 equal *tmp26 false
+   66 jump *label25 equal *tmp25 null
    67 ucontrol itemDrop @air 20
    68 sensor *tmp28 @unit @firstItem
-    * op notEqual *tmp29 *tmp28 null
-    * jump *label27 equal *tmp29 false
+   69 jump *label27 equal *tmp28 null
    70 jump *label24 always
    71 jump *label28 always
    72 label *label27
 
    96 label *label24
    97 jump *label23 always
    98 label *label22
-    * op equal *tmp39 :backgroundProcess:flag 1
-    * jump *label29 equal *tmp39 false
+   99 jump *label29 notEqual :backgroundProcess:flag 1
   100 print "Returning ore"
   101 ucontrol approach .coreX .coreY 7
   102 ucontrol itemDrop .core 20
   103 sensor *tmp41 @unit @firstItem
-    * op equal *tmp42 *tmp41 null
-    * jump *label32 equal *tmp42 false
+  104 jump *label32 notEqual *tmp41 null
   105 print " (finished)"
   106 print "\n"
   107 ucontrol flag 0
 
   120 op idiv :mine:flag :mine:flag 16
   121 op mod :mine:y :mine:flag 1000
   122 op idiv :mine:x :mine:flag 1000
-    * op equal *tmp48 :mine:ore @copper
-    * jump *label35 equal *tmp48 false
+  123 jump *label35 notEqual :mine:ore @copper
   124 set *tmp49 @ore-copper
   125 jump *label36 always
   126 label *label35
-    * op equal *tmp50 :mine:ore @lead
-    * jump *label37 equal *tmp50 false
+  127 jump *label37 notEqual :mine:ore @lead
   128 set *tmp51 @ore-lead
   129 jump *label38 always
   130 label *label37
 
   133 set *tmp49 *tmp51
   134 label *label36
   135 set :mine:floorOre *tmp49
-    * op notEqual *tmp52 :mine:ore .minOre
-    * jump *label39 equal *tmp52 false
+  136 jump *label39 equal :mine:ore .minOre
   137 sensor *tmp54 .core :mine:ore
-    * op greaterThan *tmp55 *tmp54 .min
-    * jump *label41 equal *tmp55 false
+  138 jump *label41 lessThanEq *tmp54 .min
   139 print ", switching to a more needed ore"
   140 ucontrol flag 1
   141 jump *label34 always
 
   146 label *label39
   147 label *label40
   148 sensor *tmp57 @unit @firstItem
-    * op notEqual *tmp58 *tmp57 :mine:ore
-    * jump *label43 equal *tmp58 false
+  149 jump *label43 equal *tmp57 :mine:ore
   150 print " (dropping)"
   151 ucontrol itemDrop @air 20
   152 jump *label44 always
   153 label *label43
   154 label *label44
   155 sensor *tmp60 @unit @totalItems
-    * op greaterThanEq *tmp61 *tmp60 20
-    * jump *label45 equal *tmp61 false
+  156 jump *label45 lessThan *tmp60 20
   157 print ", full"
   158 ucontrol approach .coreX .coreY 7
   159 ucontrol flag 1
 
   167 print :mine:y
   168 ucontrol approach :mine:x :mine:y 7
   169 ucontrol getBlock :mine:x :mine:y *tmp64 :mine:block :mine:floor
-    * op notEqual *tmp65 :mine:floor :mine:floorOre
-    * jump *label47 equal *tmp65 false
-    * op equal *tmp67 :mine:floor null
-    * jump *label49 equal *tmp67 false
+  170 jump *label47 equal :mine:floor :mine:floorOre
+  171 jump *label49 notEqual :mine:floor null
   172 print ": too far"
   173 print "\n"
   174 jump *label50 always
 
   179 label *label50
   180 jump *label48 always
   181 label *label47
-    * op equal *tmp69 :mine:block null
-    * jump *label51 equal *tmp69 false
+  182 jump *label51 notEqual :mine:block null
   183 ucontrol mine :mine:x :mine:y
   184 jump *label52 always
   185 label *label51

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-8 instructions):
 
    17 sensor *tmp4 :backgroundProcess:firstItem @dead
    18 jump *label12 equal *tmp4 false
    19 set :backgroundProcess:firstItem @unit
-    * jump *label13 always
    20 label *label12
    21 label *label13
    22 jump *label14 notEqual @unit :backgroundProcess:firstItem
 
    52 label *label20
    53 op add .min .min 100
    54 label *label21
-    * jump *label15 always
    55 label *label14
    56 label *label15
    57 sensor :backgroundProcess:flag @unit @flag
 
    66 sensor *tmp28 @unit @firstItem
    67 jump *label27 equal *tmp28 null
    68 jump *label24 always
-    * jump *label28 always
    69 label *label27
    70 label *label28
-    * jump *label26 always
    71 label *label25
    72 label *label26
    73 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp31 *tmp32
 
   101 print " (finished)"
   102 print "\n"
   103 ucontrol flag 0
-    * jump *label33 always
   104 label *label32
   105 label *label33
   106 print "\n"
 
   134 print ", switching to a more needed ore"
   135 ucontrol flag 1
   136 jump *label34 always
-    * jump *label42 always
   137 label *label41
   138 label *label42
-    * jump *label40 always
   139 label *label39
   140 label *label40
   141 sensor *tmp57 @unit @firstItem
   142 jump *label43 equal *tmp57 :mine:ore
   143 print " (dropping)"
   144 ucontrol itemDrop @air 20
-    * jump *label44 always
   145 label *label43
   146 label *label44
   147 sensor *tmp60 @unit @totalItems

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    30 op min *tmp15 :backgroundProcess:lead :backgroundProcess:sand
    31 op min *tmp15 *tmp15 :backgroundProcess:copper
    32 set .min *tmp15
-    * jump *label16 notEqual .min :backgroundProcess:sand
+   33 jump *label16 notEqual *tmp15 :backgroundProcess:sand
    34 set *tmp17 @sand
    35 jump *label17 always
    36 label *label16
-    * jump *label18 notEqual .min :backgroundProcess:lead
+   37 jump *label18 notEqual *tmp15 :backgroundProcess:lead
    38 set *tmp19 @lead
    39 jump *label19 always
    40 label *label18
 
    44 label *label17
    45 set .minOre *tmp17
    46 print "minOre:"
-    * print .minOre
+   47 print *tmp17
    48 print "\n"
-    * jump *label20 greaterThanEq .min 10
+   49 jump *label20 greaterThanEq *tmp15 10
    50 set .min -100
    51 jump *label21 always
    52 label *label20
-    * op add .min .min 100
+   53 op add .min *tmp15 100
    54 label *label21
    55 label *label14
    56 label *label15
 
    70 label *label28
    71 label *label25
    72 label *label26
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp31 *tmp32
+   73 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp31 *tmp32
    74 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    75 ucontrol mine :findOreToMine:x :findOreToMine:y
    76 op mul *tmp33 :findOreToMine:x 1000
    77 op add *tmp34 *tmp33 :findOreToMine:y
    78 op mul *tmp35 *tmp34 32
-    * sensor *tmp36 :findOreToMine:ore @id
+   79 sensor *tmp36 .minOre @id
    80 op mul *tmp37 *tmp36 2
    81 op add *tmp38 *tmp35 *tmp37
    82 ucontrol flag *tmp38
    83 print "Found "
-    * print :findOreToMine:ore
+   84 print .minOre
    85 print " "
    86 print "at "
    87 print :findOreToMine:x
 
   109 label *label29
   110 set :mine:flag :backgroundProcess:flag
   111 print "Mining"
-    * op idiv :mine:flag :mine:flag 2
+  112 op idiv :mine:flag :backgroundProcess:flag 2
   113 op mod *tmp44 :mine:flag 16
   114 lookup item :mine:ore *tmp44
   115 op idiv :mine:flag :mine:flag 16
 
   151 ucontrol flag 1
   152 jump *label46 always
   153 label *label45
-    * set :mine:floor null
   154 print " at "
   155 print :mine:x
   156 print ","
 
   158 print :mine:y
   159 ucontrol approach :mine:x :mine:y 7
   160 ucontrol getBlock :mine:x :mine:y *tmp64 :mine:block :mine:floor
-    * jump *label47 equal :mine:floor :mine:floorOre
+  161 jump *label47 equal :mine:floor *tmp49
   162 jump *label49 notEqual :mine:floor null
   163 print ": too far"
   164 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    29 op sub :backgroundProcess:copper *tmp13 .copperTarget
    30 op min *tmp15 :backgroundProcess:lead :backgroundProcess:sand
    31 op min *tmp15 *tmp15 :backgroundProcess:copper
-    * set .min *tmp15
    32 jump *label16 notEqual *tmp15 :backgroundProcess:sand
    33 set *tmp17 @sand
    34 jump *label17 always
 
    58 print :backgroundProcess:flag
    59 print "\n"
    60 jump *label22 notEqual :backgroundProcess:flag 0
-    * set :findOreToMine:ore .minOre
    61 sensor *tmp25 @unit @firstItem
    62 jump *label25 equal *tmp25 null
    63 ucontrol itemDrop @air 20
 
   105 label *label31
   106 jump *label30 always
   107 label *label29
-    * set :mine:flag :backgroundProcess:flag
   108 print "Mining"
   109 op idiv :mine:flag :backgroundProcess:flag 2
   110 op mod *tmp44 :mine:flag 16
 
   124 label *label38
   125 set *tmp49 *tmp51
   126 label *label36
-    * set :mine:floorOre *tmp49
   127 jump *label39 equal :mine:ore .minOre
   128 sensor *tmp54 .core :mine:ore
   129 jump *label41 lessThanEq *tmp54 .min

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-9 instructions):
 
    14 label *label8
    15 label *label9
    16 ubind @mono
-    * sensor *tmp4 :backgroundProcess:firstItem @dead
-    * jump *label12 equal *tmp4 false
-    * set :backgroundProcess:firstItem @unit
-    * label *label12
-    * label *label13
+   17 sensor *tmp4 :backgroundProcess:firstItem @dead
+   18 select :backgroundProcess:firstItem notEqual *tmp4 false @unit :backgroundProcess:firstItem
    19 jump *label14 notEqual @unit :backgroundProcess:firstItem
    20 printflush message1
    21 sensor *tmp9 .core @lead
 
    30 set *tmp17 @sand
    31 jump *label17 always
    32 label *label16
-    * jump *label18 notEqual *tmp15 :backgroundProcess:lead
-    * set *tmp19 @lead
-    * jump *label19 always
-    * label *label18
-    * set *tmp19 @copper
-    * label *label19
+   33 select *tmp19 equal *tmp15 :backgroundProcess:lead @lead @copper
    34 set *tmp17 *tmp19
    35 label *label17
    36 set .minOre *tmp17
    37 print "minOre:"
    38 print *tmp17
    39 print "\n"
-    * jump *label20 greaterThanEq *tmp15 10
-    * set .min -100
-    * jump *label21 always
-    * label *label20
-    * op add .min *tmp15 100
-    * label *label21
+   40 op add *tmp71 *tmp15 100
+   41 select .min lessThan *tmp15 10 -100 *tmp71
    42 label *label14
    43 label *label15
    44 sensor :backgroundProcess:flag @unit @flag
 
   104 set *tmp49 @ore-copper
   105 jump *label36 always
   106 label *label35
-    * jump *label37 notEqual :mine:ore @lead
-    * set *tmp51 @ore-lead
-    * jump *label38 always
-    * label *label37
-    * set *tmp51 @sand-floor
-    * label *label38
+  107 select *tmp51 equal :mine:ore @lead @ore-lead @sand-floor
   108 set *tmp49 *tmp51
   109 label *label36
   110 jump *label39 equal :mine:ore .minOre

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 2 (-6 instructions):
 
    26 op sub :backgroundProcess:copper *tmp13 .copperTarget
    27 op min *tmp15 :backgroundProcess:lead :backgroundProcess:sand
    28 op min *tmp15 *tmp15 :backgroundProcess:copper
-    * jump *label16 notEqual *tmp15 :backgroundProcess:sand
-    * set *tmp17 @sand
-    * jump *label17 always
-    * label *label16
-    * select *tmp19 equal *tmp15 :backgroundProcess:lead @lead @copper
-    * set *tmp17 *tmp19
-    * label *label17
+   29 select *tmp74 equal *tmp15 :backgroundProcess:lead @lead @copper
+   30 select *tmp17 equal *tmp15 :backgroundProcess:sand @sand *tmp74
    31 set .minOre *tmp17
    32 print "minOre:"
    33 print *tmp17
 
    95 op idiv :mine:flag :mine:flag 16
    96 op mod :mine:y :mine:flag 1000
    97 op idiv :mine:x :mine:flag 1000
-    * jump *label35 notEqual :mine:ore @copper
-    * set *tmp49 @ore-copper
-    * jump *label36 always
-    * label *label35
-    * select *tmp51 equal :mine:ore @lead @ore-lead @sand-floor
-    * set *tmp49 *tmp51
-    * label *label36
+   98 select *tmp76 equal :mine:ore @lead @ore-lead @sand-floor
+   99 select *tmp49 equal :mine:ore @copper @ore-copper *tmp76
   100 jump *label39 equal :mine:ore .minOre
   101 sensor *tmp54 .core :mine:ore
   102 jump *label41 lessThanEq *tmp54 .min

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
     3 label *label1
     4 label *label3
     5 ubind @mono
-    * label *label4
     6 jump *label3 equal @unit null
-    * label *label5
     7 set :backgroundProcess:firstItem @unit
     8 label *label6
     9 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label7
    10 jump *label6 equal .core null
-    * label *label8
    11 label *label9
    12 ubind @mono
    13 sensor *tmp4 :backgroundProcess:firstItem @dead
 
    31 op add *tmp71 *tmp15 100
    32 select .min lessThan *tmp15 10 -100 *tmp71
    33 label *label14
-    * label *label15
    34 sensor :backgroundProcess:flag @unit @flag
    35 print "Unit flag: "
    36 print :backgroundProcess:flag
 
    43 jump *label27 equal *tmp28 null
    44 jump *label24 always
    45 label *label27
-    * label *label28
    46 label *label25
-    * label *label26
    47 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp31 *tmp32
    48 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    49 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    76 print "\n"
    77 ucontrol flag 0
    78 label *label32
-    * label *label33
    79 print "\n"
-    * label *label31
    80 jump *label30 always
    81 label *label29
    82 print "Mining"
 
    95 ucontrol flag 1
    96 jump *label34 always
    97 label *label41
-    * label *label42
    98 label *label39
-    * label *label40
    99 sensor *tmp57 @unit @firstItem
   100 jump *label43 equal *tmp57 :mine:ore
   101 print " (dropping)"
   102 ucontrol itemDrop @air 20
   103 label *label43
-    * label *label44
   104 sensor *tmp60 @unit @totalItems
   105 jump *label45 lessThan *tmp60 20
   106 print ", full"
 
   141 label *label34
   142 label *label30
   143 label *label23
-    * label *label10
   144 jump *label9 always
-    * label *label11
-    * label *label2
   145 wait 1e12
   146 jump *label1 always
   147 end

Modifications by Jumps phase, Jump Straightening, pass 3, iteration 1 (-1 instructions):
 
    40 jump *label25 equal *tmp25 null
    41 ucontrol itemDrop @air 20
    42 sensor *tmp28 @unit @firstItem
-    * jump *label27 equal *tmp28 null
-    * jump *label24 always
+   43 jump *label24 notEqual *tmp28 null
    44 label *label27
    45 label *label25
    46 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp31 *tmp32

Modifications by Jumps phase, Jump Optimization, pass 3, iteration 1:
 
    41 ucontrol itemDrop @air 20
    42 sensor *tmp28 @unit @firstItem
    43 jump *label24 notEqual *tmp28 null
-    * label *label27
    44 label *label25
    45 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp31 *tmp32
    46 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
 
    40 jump *label25 equal *tmp25 null
    41 ucontrol itemDrop @air 20
    42 sensor *tmp28 @unit @firstItem
-    * jump *label24 notEqual *tmp28 null
+   43 jump *label9 notEqual *tmp28 null
    44 label *label25
    45 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp31 *tmp32
    46 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    62 print :findOreToMine:y
    63 print "\n"
    64 label *label24
-    * jump *label23 always
+   65 jump *label9 always
    66 label *label22
    67 jump *label29 notEqual :backgroundProcess:flag 1
    68 print "Returning ore"
 
    75 ucontrol flag 0
    76 label *label32
    77 print "\n"
-    * jump *label30 always
+   78 jump *label9 always
    79 label *label29
    80 print "Mining"
    81 op idiv :mine:flag :backgroundProcess:flag 2
 
    91 jump *label41 lessThanEq *tmp54 .min
    92 print ", switching to a more needed ore"
    93 ucontrol flag 1
-    * jump *label34 always
+   94 jump *label9 always
    95 label *label41
    96 label *label39
    97 sensor *tmp57 @unit @firstItem
 
   117 jump *label49 notEqual :mine:floor null
   118 print ": too far"
   119 print "\n"
-    * jump *label50 always
+  120 jump *label48 always
   121 label *label49
   122 ucontrol flag 1
   123 print ": no ore!"

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-3 instructions):
 
    61 print " "
    62 print :findOreToMine:y
    63 print "\n"
-    * label *label24
    64 jump *label9 always
    65 label *label22
    66 jump *label29 notEqual :backgroundProcess:flag 1
 
   121 ucontrol flag 1
   122 print ": no ore!"
   123 print "\n"
-    * label *label50
   124 jump *label48 always
   125 label *label47
   126 jump *label51 notEqual :mine:block null
 
   134 label *label48
   135 label *label46
   136 print "\n"
-    * label *label34
-    * label *label30
-    * label *label23
   137 jump *label9 always
-    * wait 1e12
-    * jump *label1 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 3, iteration 1:
     0 set .min 0
     1 set .minOre null
     2 set *signature "0:v1"
-    * label *label1
     3 label *label3
     4 ubind @mono
     5 jump *label3 equal @unit null

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
     5 jump *label3 equal @unit null
     6 set :backgroundProcess:firstItem @unit
     7 label *label6
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+    8 ulocate building core false @copper .coreX .coreY 0 .core
     9 jump *label6 equal .core null
    10 label *label9
    11 ubind @mono
 
    41 sensor *tmp28 @unit @firstItem
    42 jump *label9 notEqual *tmp28 null
    43 label *label25
-    * ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp31 *tmp32
+   44 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    45 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    46 ucontrol mine :findOreToMine:x :findOreToMine:y
    47 op mul *tmp33 :findOreToMine:x 1000
 
   110 print " "
   111 print :mine:y
   112 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp64 :mine:block :mine:floor
+  113 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   114 jump *label47 equal :mine:floor *tmp49
   115 jump *label49 notEqual :mine:floor null
   116 print ": too far"

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    24 select *tmp74 equal *tmp15 :backgroundProcess:lead @lead @copper
    25 select *tmp17 equal *tmp15 :backgroundProcess:sand @sand *tmp74
    26 set .minOre *tmp17
-    * print "minOre:"
-    * print *tmp17
-    * print "\n"
+   27 print "minOre:{0}\n"
+   28 format *tmp17
    29 op add *tmp71 *tmp15 100
    30 select .min lessThan *tmp15 10 -100 *tmp71
    31 label *label14
    32 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   33 print "Unit flag: {0}\n"
+   34 format :backgroundProcess:flag
    35 jump *label22 notEqual :backgroundProcess:flag 0
    36 sensor *tmp25 @unit @firstItem
    37 jump *label25 equal *tmp25 null
 
    49 op mul *tmp37 *tmp36 2
    50 op add *tmp38 *tmp35 *tmp37
    51 ucontrol flag *tmp38
-    * print "Found "
-    * print .minOre
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   52 print "Found {0} at {0}, {0}\n"
+   53 format .minOre
+   54 format :findOreToMine:x
+   55 format :findOreToMine:y
    56 jump *label9 always
    57 label *label22
    58 jump *label29 notEqual :backgroundProcess:flag 1
 
    61 ucontrol itemDrop .core 20
    62 sensor *tmp41 @unit @firstItem
    63 jump *label32 notEqual *tmp41 null
-    * print " (finished)"
-    * print "\n"
+   64 print " (finished)\n"
    65 ucontrol flag 0
    66 label *label32
    67 print "\n"
 
    96 ucontrol flag 1
    97 jump *label46 always
    98 label *label45
-    * print " at "
-    * print :mine:x
-    * print ","
-    * print " "
+   99 print " at {0}, "
+  100 format :mine:x
   101 print :mine:y
   102 ucontrol approach :mine:x :mine:y 7
   103 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   104 jump *label47 equal :mine:floor *tmp49
   105 jump *label49 notEqual :mine:floor null
-    * print ": too far"
-    * print "\n"
+  106 print ": too far\n"
   107 jump *label48 always
   108 label *label49
   109 ucontrol flag 1
-    * print ": no ore!"
-    * print "\n"
+  110 print ": no ore!\n"
   111 jump *label48 always
   112 label *label47
   113 jump *label51 notEqual :mine:block null
 
   115 jump *label52 always
   116 label *label51
   117 ucontrol flag 1
-    * print ": blocked!"
-    * print "\n"
+  118 print ": blocked!\n"
   119 label *label52
   120 label *label48
   121 label *label46

Final code before resolving virtual instructions:

    0:  set .min 0                                                   var min = 0, minOre = null;
    1:  set .minOre null                                             ...
    2:  set *signature "0:v1"                                        #set target = 8;
        label *label3                                                do
    3:  ubind @mono                                                  ubind(@mono);
    4:  jump *label3 equal @unit null                                do
    5:  set :backgroundProcess:firstItem @unit                       var firstItem = @unit;
        label *label6                                                do
    6:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
    7:  jump *label6 equal .core null                                do
        label *label9                                                while true do
    8:  ubind @mono                                                  ubind(@mono);
    9:  sensor *tmp4 :backgroundProcess:firstItem @dead              if firstItem.@dead then firstItem = @unit; end;
   10:  select :backgroundProcess:firstItem notEqual *tmp4 false @un ...
   11:  jump *label14 notEqual @unit :backgroundProcess:firstItem    if @unit == firstItem then
   12:  printflush message1                                          printflush(message1);
   13:  sensor *tmp9 .core @lead                                     var lead = core.@lead - leadTarget;
   14:  op sub :backgroundProcess:lead *tmp9 .leadTarget             ...
   15:  sensor *tmp11 .core @sand                                    var sand = core.@sand - sandTarget;
   16:  op sub :backgroundProcess:sand *tmp11 .sandTarget            ...
   17:  sensor *tmp13 .core @copper                                  var copper = core.@copper - copperTarget;
   18:  op sub :backgroundProcess:copper *tmp13 .copperTarget        ...
   19:  op min *tmp15 :backgroundProcess:lead :backgroundProcess:san min = min(lead, sand, copper);
   20:  op min *tmp15 *tmp15 :backgroundProcess:copper               ...
   21:  select *tmp74 equal *tmp15 :backgroundProcess:lead @lead @co minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   22:  select *tmp17 equal *tmp15 :backgroundProcess:sand @sand *tm ...
   23:  set .minOre *tmp17                                           ...
   24:  print "minOre:{0}\n"                                         println("minOre:", minOre);
   25:  format *tmp17                                                ...
   26:  op add *tmp71 *tmp15 100                                     if min < 10 then min = -100; else min += 100; end;
   27:  select .min lessThan *tmp15 10 -100 *tmp71                   ...
        label *label14                                               if @unit == firstItem then
   28:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   29:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   30:  format :backgroundProcess:flag                               ...
   31:  jump *label22 notEqual :backgroundProcess:flag 0             if flag == 0 then
   32:  sensor *tmp25 @unit @firstItem                               if @unit.@firstItem != null then
   33:  jump *label25 equal *tmp25 null                              ...
   34:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   35:  sensor *tmp28 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   36:  jump *label9 notEqual *tmp28 null                            ...
        label *label25                                               if @unit.@firstItem != null then
   37:  ulocate ore core true .minOre :findOreToMine:x :findOreToMin ulocate(:ore, ore, out x, out y);
   38:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   39:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   40:  op mul *tmp33 :findOreToMine:x 1000                          flag((x * 1000 + y) * 32 + ore.@id * 2);
   41:  op add *tmp34 *tmp33 :findOreToMine:y                        ...
   42:  op mul *tmp35 *tmp34 32                                      ...
   43:  sensor *tmp36 .minOre @id                                    ...
   44:  op mul *tmp37 *tmp36 2                                       ...
   45:  op add *tmp38 *tmp35 *tmp37                                  ...
   46:  ucontrol flag *tmp38 0 0 0 0                                 ...
   47:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   48:  format .minOre                                               ...
   49:  format :findOreToMine:x                                      ...
   50:  format :findOreToMine:y                                      ...
   51:  jump *label9 always 0 0                                      if flag == 0 then
        label *label22                                               ...
   52:  jump *label29 notEqual :backgroundProcess:flag 1             elsif flag == 1 then
   53:  print "Returning ore"                                        print("Returning ore");
   54:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   55:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
   56:  sensor *tmp41 @unit @firstItem                               if @unit.@firstItem == null then
   57:  jump *label32 notEqual *tmp41 null                           ...
   58:  print " (finished)\n"                                        println(" (finished)");
   59:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label32                                               if @unit.@firstItem == null then
   60:  print "\n"                                                   println();
   61:  jump *label9 always 0 0                                      elsif flag == 1 then
        label *label29                                               ...
   62:  print "Mining"                                               print("Mining");
   63:  op idiv :mine:flag :backgroundProcess:flag 2                 flag \= 2;
   64:  op mod *tmp44 :mine:flag 16                                  var ore = lookup(:item, flag % 16);
   65:  lookup item :mine:ore *tmp44                                 ...
   66:  op idiv :mine:flag :mine:flag 16                             flag \= 16;
   67:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   68:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   69:  select *tmp76 equal :mine:ore @lead @ore-lead @sand-floor    ore == @copper ? @ore-copper :
   70:  select *tmp49 equal :mine:ore @copper @ore-copper *tmp76     ...
   71:  jump *label39 equal :mine:ore .minOre                        if ore != minOre then
   72:  sensor *tmp54 .core :mine:ore                                if core.sensor(ore) > min then
   73:  jump *label41 lessThanEq *tmp54 .min                         ...
   74:  print ", switching to a more needed ore"                     print(", switching to a more needed ore");
   75:  ucontrol flag 1 0 0 0 0                                      flag(1);
   76:  jump *label9 always 0 0                                      return;
        label *label41                                               if core.sensor(ore) > min then
        label *label39                                               if ore != minOre then
   77:  sensor *tmp57 @unit @firstItem                               if @unit.@firstItem != ore then
   78:  jump *label43 equal *tmp57 :mine:ore                         ...
   79:  print " (dropping)"                                          print(" (dropping)");
   80:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label43                                               if @unit.@firstItem != ore then
   81:  sensor *tmp60 @unit @totalItems                              if @unit.@totalItems >= capacity then
   82:  jump *label45 lessThan *tmp60 20                             ...
   83:  print ", full"                                               print(", full");
   84:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   85:  ucontrol flag 1 0 0 0 0                                      flag(1);
   86:  jump *label46 always 0 0                                     if @unit.@totalItems >= capacity then
        label *label45                                               ...
   87:  print " at {0}, "                                            print($" at $x, $y");
   88:  format :mine:x                                               ...
   89:  print :mine:y                                                ...
   90:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
   91:  ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor  var block = getBlock(x, y, , out floor);
   92:  jump *label47 equal :mine:floor *tmp49                       if floor != floorOre then
   93:  jump *label49 notEqual :mine:floor null                      if floor == null then
   94:  print ": too far\n"                                          println(": too far");
   95:  jump *label48 always 0 0                                     if floor == null then
        label *label49                                               ...
   96:  ucontrol flag 1 0 0 0 0                                      flag(1);
   97:  print ": no ore!\n"                                          println(": no ore!");
   98:  jump *label48 always 0 0                                     if floor != floorOre then
        label *label47                                               ...
   99:  jump *label51 notEqual :mine:block null                      elsif block == null then
  100:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
  101:  jump *label52 always 0 0                                     elsif block == null then
        label *label51                                               ...
  102:  ucontrol flag 1 0 0 0 0                                      flag(1);
  103:  print ": blocked!\n"                                         println(": blocked!");
        label *label52                                               elsif block == null then
        label *label48                                               if floor != floorOre then
        label *label46                                               if @unit.@totalItems >= capacity then
  104:  print "\n"                                                   println();
  105:  jump *label9 always 0 0                                      while true do


Performance: parsed in 344 ms, compiled in 390 ms, optimized in 402 ms, run in 4 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: success.

Program output (4 steps):
The program didn't generate any output.
Execution exception at instruction 3: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
