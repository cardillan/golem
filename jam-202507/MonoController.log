   190 instructions before optimizations.
     8 instructions eliminated by Temp Variables Elimination (2 iterations).
    26 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    19 instructions eliminated by Jump Optimization (5 iterations).
    10 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     4 instructions eliminated by If Expression Optimization (3 iterations).
     5 instructions eliminated by Data Flow Optimization (5 iterations).
     1 instructions eliminated by Jump Straightening (5 iterations).
     4 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    12 instructions eliminated by Print Merging.
   103 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-14 instructions):
 
    55 op add .min .min 100
    56 set *tmp15 .min
    57 label *label16
-    * set *tmp5 *tmp15
    58 jump *label10 always
    59 label *label9
-    * set *tmp5 null
    60 label *label10
    61 sensor *tmp16 @unit @flag
    62 set :flag *tmp16
 
    79 label *label22
    80 set *tmp24 null
    81 label *label23
-    * set *tmp21 *tmp24
    82 jump *label21 always
    83 label *label20
-    * set *tmp21 null
    84 label *label21
    85 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp25 *tmp26
    86 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
   102 print :findOreToMine:y
   103 print "\n"
   104 label *label19
-    * set *tmp18 null
   105 jump *label18 always
   106 label *label17
   107 op equal *tmp33 :flag 1
 
   115 print " (finished)"
   116 print "\n"
   117 ucontrol flag 0
-    * set *tmp37 null
   118 jump *label28 always
   119 label *label27
-    * set *tmp37 null
   120 label *label28
   121 print "\n"
   122 label *label26
 
   147 label *label32
   148 set *tmp46 null
   149 label *label33
-    * set *tmp43 *tmp46
   150 jump *label31 always
   151 label *label30
-    * set *tmp43 null
   152 label *label31
   153 sensor *tmp47 @unit @firstItem
   154 op notEqual *tmp48 *tmp47 :mine:ore
   155 jump *label34 equal *tmp48 false
   156 print " (dropping)"
   157 ucontrol itemDrop @air 20
-    * set *tmp49 null
   158 jump *label35 always
   159 label *label34
-    * set *tmp49 null
   160 label *label35
   161 sensor *tmp50 @unit @totalItems
   162 op greaterThanEq *tmp51 *tmp50 20
 
   164 print ", full"
   165 ucontrol approach .coreX .coreY 7
   166 ucontrol flag 1
-    * set *tmp52 null
   167 jump *label37 always
   168 label *label36
   169 op equal *tmp53 :mine:ore @lead
 
   209 label *label45
   210 set *tmp60 *tmp62
   211 label *label43
-    * set *tmp52 *tmp60
   212 label *label37
   213 print "\n"
   214 label *label29
   215 set *tmp34 null
   216 label *label25
-    * set *tmp18 *tmp34
   217 label *label18
   218 label *label7
   219 jump *label6 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-10 instructions):
 
    49 op lessThan *tmp14 .min 10
    50 jump *label15 equal *tmp14 false
    51 set .min -100
-    * set *tmp15 .min
    52 jump *label16 always
    53 label *label15
    54 op add .min .min 100
-    * set *tmp15 .min
    55 label *label16
    56 jump *label10 always
    57 label *label9
 
    72 op notEqual *tmp23 *tmp22 null
    73 jump *label22 equal *tmp23 false
    74 jump *label19 always
-    * set *tmp24 null
    75 jump *label23 always
    76 label *label22
-    * set *tmp24 null
    77 label *label23
    78 jump *label21 always
    79 label *label20
 
   116 label *label28
   117 print "\n"
   118 label *label26
-    * set *tmp34 null
   119 jump *label25 always
   120 label *label24
   121 set :mine:flag :flag
 
   137 print ", switching to a more needed ore"
   138 ucontrol flag 1
   139 jump *label29 always
-    * set *tmp46 null
   140 jump *label33 always
   141 label *label32
-    * set *tmp46 null
   142 label *label33
   143 jump *label31 always
   144 label *label30
 
   185 op equal *tmp59 :mine:floor :mine:oreFloor
   186 jump *label42 equal *tmp59 false
   187 ucontrol mine :mine:x :mine:y
-    * set *tmp60 null
   188 jump *label43 always
   189 label *label42
   190 op notEqual *tmp61 :mine:floor null
 
   199 print "\n"
   200 set *tmp62 ": too far away"
   201 label *label45
-    * set *tmp60 *tmp62
   202 label *label43
   203 label *label37
   204 print "\n"
   205 label *label29
-    * set *tmp34 null
   206 label *label25
   207 label *label18
   208 label *label7

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
   192 ucontrol flag 1
   193 print ": ore disappeared!"
   194 print "\n"
-    * set *tmp62 ": ore disappeared!"
   195 jump *label45 always
   196 label *label44
   197 print ": too far away"
   198 print "\n"
-    * set *tmp62 ": too far away"
   199 label *label45
   200 label *label43
   201 label *label37

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-8 instructions):
 
     7 label *label2
     8 set :firstItem @unit
     9 label *label3
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   10 ulocate building core false @copper .coreX .coreY 0 .core
    11 label *label4
    12 op equal *tmp3 .core null
    13 jump *label3 notEqual *tmp3 false
 
    18 op equal *tmp4 @unit :firstItem
    19 jump *label9 equal *tmp4 false
    20 printflush message1
-    * sensor *tmp6 .core @lead
-    * set :lead *tmp6
-    * sensor *tmp7 .core @sand
-    * set :sand *tmp7
-    * sensor *tmp8 .core @copper
-    * set :copper *tmp8
+   21 sensor :lead .core @lead
+   22 sensor :sand .core @sand
+   23 sensor :copper .core @copper
    24 op min *tmp9 :lead :sand
    25 op min *tmp9 *tmp9 :copper
    26 set .min *tmp9
 
    52 jump *label10 always
    53 label *label9
    54 label *label10
-    * sensor *tmp16 @unit @flag
-    * set :flag *tmp16
+   55 sensor :flag @unit @flag
    56 print "Unit flag: "
    57 print :flag
    58 print "\n"
 
    73 jump *label21 always
    74 label *label20
    75 label *label21
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp25 *tmp26
+   76 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
    77 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    78 ucontrol mine :findOreToMine:x :findOreToMine:y
    79 op mul *tmp27 :findOreToMine:x 1000
 
   117 print "Mining"
   118 op idiv :mine:flag :mine:flag 2
   119 op mod *tmp38 :mine:flag 16
-    * lookup item *tmp39 *tmp38
-    * set :mine:ore *tmp39
+  120 lookup item :mine:ore *tmp38
   121 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp40 :mine:flag 1000
-    * set :mine:y *tmp40
-    * op idiv *tmp41 :mine:flag 1000
-    * set :mine:x *tmp41
+  122 op mod :mine:y :mine:flag 1000
+  123 op idiv :mine:x :mine:flag 1000
   124 op notEqual *tmp42 :mine:ore .minOre
   125 jump *label30 equal *tmp42 false
   126 sensor *tmp44 .core :mine:ore
 
   173 print " "
   174 print :mine:y
   175 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:x *tmp58 *tmp57 :mine:floor
+  176 ucontrol getBlock :mine:x :mine:x 0 0 :mine:floor
   177 op equal *tmp59 :mine:floor :mine:oreFloor
   178 jump *label42 equal *tmp59 false
   179 ucontrol mine :mine:x :mine:y

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    13 jump *label3 notEqual *tmp3 false
    14 label *label5
    15 label *label6
-    * jump *label8 equal true false
    16 ubind @mono
    17 op equal *tmp4 @unit :firstItem
    18 jump *label9 equal *tmp4 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-19 instructions):
 
     2 label *label0
     3 ubind @mono
     4 label *label1
-    * op equal *tmp0 @unit null
-    * jump *label0 notEqual *tmp0 false
+    5 jump *label0 equal @unit null
     6 label *label2
     7 set :firstItem @unit
     8 label *label3
     9 ulocate building core false @copper .coreX .coreY 0 .core
    10 label *label4
-    * op equal *tmp3 .core null
-    * jump *label3 notEqual *tmp3 false
+   11 jump *label3 equal .core null
    12 label *label5
    13 label *label6
    14 ubind @mono
-    * op equal *tmp4 @unit :firstItem
-    * jump *label9 equal *tmp4 false
+   15 jump *label9 notEqual @unit :firstItem
    16 printflush message1
    17 sensor :lead .core @lead
    18 sensor :sand .core @sand
 
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
    22 set .min *tmp9
-    * op equal *tmp10 .min :sand
-    * jump *label11 equal *tmp10 false
+   23 jump *label11 notEqual .min :sand
    24 set *tmp11 @sand
    25 jump *label12 always
    26 label *label11
-    * op equal *tmp12 .min :lead
-    * jump *label13 equal *tmp12 false
+   27 jump *label13 notEqual .min :lead
    28 set *tmp13 @lead
    29 jump *label14 always
    30 label *label13
 
    36 print "minOre:"
    37 print .minOre
    38 print "\n"
-    * op lessThan *tmp14 .min 10
-    * jump *label15 equal *tmp14 false
+   39 jump *label15 greaterThanEq .min 10
    40 set .min -100
    41 jump *label16 always
    42 label *label15
 
    49 print "Unit flag: "
    50 print :flag
    51 print "\n"
-    * op equal *tmp17 :flag 0
-    * jump *label17 equal *tmp17 false
+   52 jump *label17 notEqual :flag 0
    53 set :findOreToMine:ore .minOre
    54 sensor *tmp19 @unit @firstItem
-    * op notEqual *tmp20 *tmp19 null
-    * jump *label20 equal *tmp20 false
+   55 jump *label20 equal *tmp19 null
    56 ucontrol itemDrop @air 20
    57 sensor *tmp22 @unit @firstItem
-    * op notEqual *tmp23 *tmp22 null
-    * jump *label22 equal *tmp23 false
+   58 jump *label22 equal *tmp22 null
    59 jump *label19 always
    60 jump *label23 always
    61 label *label22
 
    85 label *label19
    86 jump *label18 always
    87 label *label17
-    * op equal *tmp33 :flag 1
-    * jump *label24 equal *tmp33 false
+   88 jump *label24 notEqual :flag 1
    89 print "Returning ore"
    90 ucontrol approach .coreX .coreY 7
    91 ucontrol itemDrop .core 20
    92 sensor *tmp35 @unit @firstItem
-    * op equal *tmp36 *tmp35 null
-    * jump *label27 equal *tmp36 false
+   93 jump *label27 notEqual *tmp35 null
    94 print " (finished)"
    95 print "\n"
    96 ucontrol flag 0
 
   109 op idiv :mine:flag :mine:flag 16
   110 op mod :mine:y :mine:flag 1000
   111 op idiv :mine:x :mine:flag 1000
-    * op notEqual *tmp42 :mine:ore .minOre
-    * jump *label30 equal *tmp42 false
+  112 jump *label30 equal :mine:ore .minOre
   113 sensor *tmp44 .core :mine:ore
-    * op greaterThan *tmp45 *tmp44 .min
-    * jump *label32 equal *tmp45 false
+  114 jump *label32 lessThanEq *tmp44 .min
   115 print ", switching to a more needed ore"
   116 ucontrol flag 1
   117 jump *label29 always
 
   122 label *label30
   123 label *label31
   124 sensor *tmp47 @unit @firstItem
-    * op notEqual *tmp48 *tmp47 :mine:ore
-    * jump *label34 equal *tmp48 false
+  125 jump *label34 equal *tmp47 :mine:ore
   126 print " (dropping)"
   127 ucontrol itemDrop @air 20
   128 jump *label35 always
   129 label *label34
   130 label *label35
   131 sensor *tmp50 @unit @totalItems
-    * op greaterThanEq *tmp51 *tmp50 20
-    * jump *label36 equal *tmp51 false
+  132 jump *label36 lessThan *tmp50 20
   133 print ", full"
   134 ucontrol approach .coreX .coreY 7
   135 ucontrol flag 1
   136 jump *label37 always
   137 label *label36
-    * op equal *tmp53 :mine:ore @lead
-    * jump *label38 equal *tmp53 false
+  138 jump *label38 notEqual :mine:ore @lead
   139 set *tmp54 @ore-lead
   140 jump *label39 always
   141 label *label38
-    * op equal *tmp55 :mine:ore @copper
-    * jump *label40 equal *tmp55 false
+  142 jump *label40 notEqual :mine:ore @copper
   143 set *tmp56 @ore-copper
   144 jump *label41 always
   145 label *label40
 
   156 print :mine:y
   157 ucontrol approach :mine:x :mine:y 7
   158 ucontrol getBlock :mine:x :mine:x 0 0 :mine:floor
-    * op equal *tmp59 :mine:floor :mine:oreFloor
-    * jump *label42 equal *tmp59 false
+  159 jump *label42 notEqual :mine:floor :mine:oreFloor
   160 ucontrol mine :mine:x :mine:y
   161 jump *label43 always
   162 label *label42
-    * op notEqual *tmp61 :mine:floor null
-    * jump *label44 equal *tmp61 false
+  163 jump *label44 equal :mine:floor null
   164 ucontrol flag 1
   165 print ": ore disappeared!"
   166 print "\n"

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    42 label *label15
    43 op add .min .min 100
    44 label *label16
-    * jump *label10 always
    45 label *label9
    46 label *label10
    47 sensor :flag @unit @flag
 
    56 sensor *tmp22 @unit @firstItem
    57 jump *label22 equal *tmp22 null
    58 jump *label19 always
-    * jump *label23 always
    59 label *label22
    60 label *label23
-    * jump *label21 always
    61 label *label20
    62 label *label21
    63 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
 
    91 print " (finished)"
    92 print "\n"
    93 ucontrol flag 0
-    * jump *label28 always
    94 label *label27
    95 label *label28
    96 print "\n"
 
   111 print ", switching to a more needed ore"
   112 ucontrol flag 1
   113 jump *label29 always
-    * jump *label33 always
   114 label *label32
   115 label *label33
-    * jump *label31 always
   116 label *label30
   117 label *label31
   118 sensor *tmp47 @unit @firstItem
   119 jump *label34 equal *tmp47 :mine:ore
   120 print " (dropping)"
   121 ucontrol itemDrop @air 20
-    * jump *label35 always
   122 label *label34
   123 label *label35
   124 sensor *tmp50 @unit @totalItems

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
    22 set .min *tmp9
-    * jump *label11 notEqual .min :sand
+   23 jump *label11 notEqual *tmp9 :sand
    24 set *tmp11 @sand
    25 jump *label12 always
    26 label *label11
-    * jump *label13 notEqual .min :lead
+   27 jump *label13 notEqual *tmp9 :lead
    28 set *tmp13 @lead
    29 jump *label14 always
    30 label *label13
 
    34 label *label12
    35 set .minOre *tmp11
    36 print "minOre:"
-    * print .minOre
+   37 print *tmp11
    38 print "\n"
-    * jump *label15 greaterThanEq .min 10
+   39 jump *label15 greaterThanEq *tmp9 10
    40 set .min -100
    41 jump *label16 always
    42 label *label15
-    * op add .min .min 100
+   43 op add .min *tmp9 100
    44 label *label16
    45 label *label9
    46 label *label10
 
    60 label *label23
    61 label *label20
    62 label *label21
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
+   63 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    64 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    65 ucontrol mine :findOreToMine:x :findOreToMine:y
    66 op mul *tmp27 :findOreToMine:x 1000
    67 op add *tmp28 *tmp27 :findOreToMine:y
    68 op mul *tmp29 *tmp28 32
-    * sensor *tmp30 :findOreToMine:ore @id
+   69 sensor *tmp30 .minOre @id
    70 op mul *tmp31 *tmp30 2
    71 op add *tmp32 *tmp29 *tmp31
    72 ucontrol flag *tmp32
    73 print "Found "
-    * print :findOreToMine:ore
+   74 print .minOre
    75 print " "
    76 print "at "
    77 print :findOreToMine:x
 
    99 label *label24
   100 set :mine:flag :flag
   101 print "Mining"
-    * op idiv :mine:flag :mine:flag 2
+  102 op idiv :mine:flag :flag 2
   103 op mod *tmp38 :mine:flag 16
   104 lookup item :mine:ore *tmp38
   105 op idiv :mine:flag :mine:flag 16
 
   141 set *tmp54 *tmp56
   142 label *label39
   143 set :mine:oreFloor *tmp54
-    * set :mine:floor null
   144 print " at "
   145 print :mine:x
   146 print ","
 
   148 print :mine:y
   149 ucontrol approach :mine:x :mine:y 7
   150 ucontrol getBlock :mine:x :mine:x 0 0 :mine:floor
-    * jump *label42 notEqual :mine:floor :mine:oreFloor
+  151 jump *label42 notEqual :mine:floor *tmp54
   152 ucontrol mine :mine:x :mine:y
   153 jump *label43 always
   154 label *label42

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    19 sensor :copper .core @copper
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
-    * set .min *tmp9
    22 jump *label11 notEqual *tmp9 :sand
    23 set *tmp11 @sand
    24 jump *label12 always
 
    48 print :flag
    49 print "\n"
    50 jump *label17 notEqual :flag 0
-    * set :findOreToMine:ore .minOre
    51 sensor *tmp19 @unit @firstItem
    52 jump *label20 equal *tmp19 null
    53 ucontrol itemDrop @air 20
 
    95 label *label26
    96 jump *label25 always
    97 label *label24
-    * set :mine:flag :flag
    98 print "Mining"
    99 op idiv :mine:flag :flag 2
   100 op mod *tmp38 :mine:flag 16
 
   137 label *label41
   138 set *tmp54 *tmp56
   139 label *label39
-    * set :mine:oreFloor *tmp54
   140 print " at "
   141 print :mine:x
   142 print ","

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-4 instructions):
 
    19 sensor :copper .core @copper
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
-    * jump *label11 notEqual *tmp9 :sand
    22 set *tmp11 @sand
-    * jump *label12 always
+   23 jump *label12 equal *tmp9 :sand
    24 label *label11
-    * jump *label13 notEqual *tmp9 :lead
-    * set *tmp13 @lead
+   25 set *tmp11 @copper
+   26 jump *label14 notEqual *tmp9 :lead
+   27 set *tmp11 @lead
    28 jump *label14 always
-    * label *label13
-    * set *tmp13 @copper
    29 label *label14
-    * set *tmp11 *tmp13
    30 label *label12
    31 set .minOre *tmp11
    32 print "minOre:"
    33 print *tmp11
    34 print "\n"
-    * jump *label15 greaterThanEq *tmp9 10
+   35 op add .min *tmp9 100
+   36 jump *label16 greaterThanEq *tmp9 10
    37 set .min -100
    38 jump *label16 always
-    * label *label15
-    * op add .min *tmp9 100
    39 label *label16
    40 label *label9
    41 label *label10
 
   121 ucontrol flag 1
   122 jump *label37 always
   123 label *label36
-    * jump *label38 notEqual :mine:ore @lead
   124 set *tmp54 @ore-lead
-    * jump *label39 always
+  125 jump *label39 equal :mine:ore @lead
   126 label *label38
-    * jump *label40 notEqual :mine:ore @copper
-    * set *tmp56 @ore-copper
+  127 set *tmp54 @sand
+  128 jump *label41 notEqual :mine:ore @copper
+  129 set *tmp54 @ore-copper
   130 jump *label41 always
-    * label *label40
-    * set *tmp56 @sand
   131 label *label41
-    * set *tmp54 *tmp56
   132 label *label39
   133 print " at "
   134 print :mine:x

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
    25 set *tmp11 @copper
    26 jump *label14 notEqual *tmp9 :lead
    27 set *tmp11 @lead
-    * jump *label14 always
    28 label *label14
    29 label *label12
    30 set .minOre *tmp11
 
    34 op add .min *tmp9 100
    35 jump *label16 greaterThanEq *tmp9 10
    36 set .min -100
-    * jump *label16 always
    37 label *label16
    38 label *label9
    39 label *label10
 
   125 set *tmp54 @sand
   126 jump *label41 notEqual :mine:ore @copper
   127 set *tmp54 @ore-copper
-    * jump *label41 always
   128 label *label41
   129 label *label39
   130 print " at "

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     1 set .minOre null
     2 label *label0
     3 ubind @mono
-    * label *label1
     4 jump *label0 equal @unit null
-    * label *label2
     5 set :firstItem @unit
     6 label *label3
     7 ulocate building core false @copper .coreX .coreY 0 .core
-    * label *label4
     8 jump *label3 equal .core null
-    * label *label5
     9 label *label6
    10 ubind @mono
    11 jump *label9 notEqual @unit :firstItem
 
    17 op min *tmp9 *tmp9 :copper
    18 set *tmp11 @sand
    19 jump *label12 equal *tmp9 :sand
-    * label *label11
    20 set *tmp11 @copper
    21 jump *label14 notEqual *tmp9 :lead
    22 set *tmp11 @lead
 
    31 set .min -100
    32 label *label16
    33 label *label9
-    * label *label10
    34 sensor :flag @unit @flag
    35 print "Unit flag: "
    36 print :flag
 
    43 jump *label22 equal *tmp22 null
    44 jump *label19 always
    45 label *label22
-    * label *label23
    46 label *label20
-    * label *label21
    47 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    48 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    49 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    76 print "\n"
    77 ucontrol flag 0
    78 label *label27
-    * label *label28
    79 print "\n"
-    * label *label26
    80 jump *label25 always
    81 label *label24
    82 print "Mining"
 
    93 ucontrol flag 1
    94 jump *label29 always
    95 label *label32
-    * label *label33
    96 label *label30
-    * label *label31
    97 sensor *tmp47 @unit @firstItem
    98 jump *label34 equal *tmp47 :mine:ore
    99 print " (dropping)"
   100 ucontrol itemDrop @air 20
   101 label *label34
-    * label *label35
   102 sensor *tmp50 @unit @totalItems
   103 jump *label36 lessThan *tmp50 20
   104 print ", full"
 
   108 label *label36
   109 set *tmp54 @ore-lead
   110 jump *label39 equal :mine:ore @lead
-    * label *label38
   111 set *tmp54 @sand
   112 jump *label41 notEqual :mine:ore @copper
   113 set *tmp54 @ore-copper
 
   139 label *label29
   140 label *label25
   141 label *label18
-    * label *label7
   142 jump *label6 always
-    * label *label8
   143 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    40 jump *label20 equal *tmp19 null
    41 ucontrol itemDrop @air 20
    42 sensor *tmp22 @unit @firstItem
-    * jump *label22 equal *tmp22 null
-    * jump *label19 always
+   43 jump *label19 notEqual *tmp22 null
    44 label *label22
    45 label *label20
    46 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    41 ucontrol itemDrop @air 20
    42 sensor *tmp22 @unit @firstItem
    43 jump *label19 notEqual *tmp22 null
-    * label *label22
    44 label *label20
    45 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    46 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    40 jump *label20 equal *tmp19 null
    41 ucontrol itemDrop @air 20
    42 sensor *tmp22 @unit @firstItem
-    * jump *label19 notEqual *tmp22 null
+   43 jump *label6 notEqual *tmp22 null
    44 label *label20
    45 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    46 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    62 print :findOreToMine:y
    63 print "\n"
    64 label *label19
-    * jump *label18 always
+   65 jump *label6 always
    66 label *label17
    67 jump *label24 notEqual :flag 1
    68 print "Returning ore"
 
    75 ucontrol flag 0
    76 label *label27
    77 print "\n"
-    * jump *label25 always
+   78 jump *label6 always
    79 label *label24
    80 print "Mining"
    81 op idiv :mine:flag :flag 2
 
    89 jump *label32 lessThanEq *tmp44 .min
    90 print ", switching to a more needed ore"
    91 ucontrol flag 1
-    * jump *label29 always
+   92 jump *label6 always
    93 label *label32
    94 label *label30
    95 sensor *tmp47 @unit @firstItem

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-1 instructions):
 
    61 print " "
    62 print :findOreToMine:y
    63 print "\n"
-    * label *label19
    64 jump *label6 always
    65 label *label17
    66 jump *label24 notEqual :flag 1
 
   133 label *label43
   134 label *label37
   135 print "\n"
-    * label *label29
-    * label *label25
-    * label *label18
   136 jump *label6 always
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-12 instructions):
 
    23 label *label14
    24 label *label12
    25 set .minOre *tmp11
-    * print "minOre:"
-    * print *tmp11
-    * print "\n"
+   26 print "minOre:{0}\n"
+   27 format *tmp11
    28 op add .min *tmp9 100
    29 jump *label16 greaterThanEq *tmp9 10
    30 set .min -100
    31 label *label16
    32 label *label9
    33 sensor :flag @unit @flag
-    * print "Unit flag: "
-    * print :flag
-    * print "\n"
+   34 print "Unit flag: {0}\n"
+   35 format :flag
    36 jump *label17 notEqual :flag 0
    37 sensor *tmp19 @unit @firstItem
    38 jump *label20 equal *tmp19 null
 
    50 op mul *tmp31 *tmp30 2
    51 op add *tmp32 *tmp29 *tmp31
    52 ucontrol flag *tmp32
-    * print "Found "
-    * print .minOre
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   53 print "Found {0} at {0}, {0}\n"
+   54 format .minOre
+   55 format :findOreToMine:x
+   56 format :findOreToMine:y
    57 jump *label6 always
    58 label *label17
    59 jump *label24 notEqual :flag 1
 
    62 ucontrol itemDrop .core 20
    63 sensor *tmp35 @unit @firstItem
    64 jump *label27 notEqual *tmp35 null
-    * print " (finished)"
-    * print "\n"
+   65 print " (finished)\n"
    66 ucontrol flag 0
    67 label *label27
    68 print "\n"
 
   102 set *tmp54 @ore-copper
   103 label *label41
   104 label *label39
-    * print " at "
-    * print :mine:x
-    * print ","
-    * print " "
+  105 print " at {0}, "
+  106 format :mine:x
   107 print :mine:y
   108 ucontrol approach :mine:x :mine:y 7
   109 ucontrol getBlock :mine:x :mine:x 0 0 :mine:floor
 
   113 label *label42
   114 jump *label44 equal :mine:floor null
   115 ucontrol flag 1
-    * print ": ore disappeared!"
-    * print "\n"
+  116 print ": ore disappeared!\n"
   117 jump *label45 always
   118 label *label44
-    * print ": too far away"
-    * print "\n"
+  119 print ": too far away\n"
   120 label *label45
   121 label *label43
   122 label *label37

Final code before resolving virtual instructions:

    0:  jump *label46 always 0 0
    1:  draw triangle message1 .core .coreX .coreY .min .minOre
    2:  draw triangle :copper :firstItem :flag :lead :sand :findOreToMine:x
    3:  draw triangle :findOreToMine:y :mine:flag :mine:floor :mine:ore :mine:x :mine:y
        label *label46
    4:  set .min 0                                                   var min = 0, minOre = null;
    5:  set .minOre null                                             ...
        label *label0                                                do
    6:  ubind @mono                                                  ubind(@mono);
    7:  jump *label0 equal @unit null                                do
    8:  set :firstItem @unit                                         var firstItem = @unit;
        label *label3                                                do
    9:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   10:  jump *label3 equal .core null                                do
        label *label6                                                while true do
   11:  ubind @mono                                                  ubind(@mono);
   12:  jump *label9 notEqual @unit :firstItem                       if @unit == firstItem then
   13:  printflush message1                                          printflush(message1);
   14:  sensor :lead .core @lead                                     var lead = core.@lead;
   15:  sensor :sand .core @sand                                     var sand = core.@sand;
   16:  sensor :copper .core @copper                                 var copper = core.@copper;
   17:  op min *tmp9 :lead :sand                                     min = min(lead, sand, copper);
   18:  op min *tmp9 *tmp9 :copper                                   ...
   19:  set *tmp11 @sand                                             minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   20:  jump *label12 equal *tmp9 :sand                              ...
   21:  set *tmp11 @copper                                           ...
   22:  jump *label14 notEqual *tmp9 :lead                           ...
   23:  set *tmp11 @lead                                             ...
        label *label14                                               ...
        label *label12                                               ...
   24:  set .minOre *tmp11                                           ...
   25:  print "minOre:{0}\n"                                         println("minOre:", minOre);
   26:  format *tmp11                                                ...
   27:  op add .min *tmp9 100                                        if min < 10 then min = -100; else min += 100; end;
   28:  jump *label16 greaterThanEq *tmp9 10                         ...
   29:  set .min -100                                                ...
        label *label16                                               ...
        label *label9                                                if @unit == firstItem then
   30:  sensor :flag @unit @flag                                     var flag = @unit.@flag;
   31:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   32:  format :flag                                                 ...
   33:  jump *label17 notEqual :flag 0                               if flag == 0 then
   34:  sensor *tmp19 @unit @firstItem                               if @unit.@firstItem != null then
   35:  jump *label20 equal *tmp19 null                              ...
   36:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   37:  sensor *tmp22 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   38:  jump *label6 notEqual *tmp22 null                            ...
        label *label20                                               if @unit.@firstItem != null then
   39:  ulocate ore core true .minOre :findOreToMine:x :findOreToMin ulocate(:ore, ore, out x, out y);
   40:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   41:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   42:  op mul *tmp27 :findOreToMine:x 1000                          flag((x * 1000 + y) * 32 + ore.@id * 2);
   43:  op add *tmp28 *tmp27 :findOreToMine:y                        ...
   44:  op mul *tmp29 *tmp28 32                                      ...
   45:  sensor *tmp30 .minOre @id                                    ...
   46:  op mul *tmp31 *tmp30 2                                       ...
   47:  op add *tmp32 *tmp29 *tmp31                                  ...
   48:  ucontrol flag *tmp32 0 0 0 0                                 ...
   49:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   50:  format .minOre                                               ...
   51:  format :findOreToMine:x                                      ...
   52:  format :findOreToMine:y                                      ...
   53:  jump *label6 always 0 0                                      if flag == 0 then
        label *label17                                               ...
   54:  jump *label24 notEqual :flag 1                               elsif flag == 1 then
   55:  print "Returning ore"                                        print("Returning ore");
   56:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   57:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
   58:  sensor *tmp35 @unit @firstItem                               if @unit.@firstItem == null then
   59:  jump *label27 notEqual *tmp35 null                           ...
   60:  print " (finished)\n"                                        println(" (finished)");
   61:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label27                                               if @unit.@firstItem == null then
   62:  print "\n"                                                   println();
   63:  jump *label6 always 0 0                                      elsif flag == 1 then
        label *label24                                               ...
   64:  print "Mining"                                               print("Mining");
   65:  op idiv :mine:flag :flag 2                                   flag \= 2;
   66:  op mod *tmp38 :mine:flag 16                                  var ore = lookup(:item, flag % 16);
   67:  lookup item :mine:ore *tmp38                                 ...
   68:  op idiv :mine:flag :mine:flag 16                             flag \= 16;
   69:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   70:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   71:  jump *label30 equal :mine:ore .minOre                        if ore != minOre then
   72:  sensor *tmp44 .core :mine:ore                                if core.sensor(ore) > min then
   73:  jump *label32 lessThanEq *tmp44 .min                         ...
   74:  print ", switching to a more needed ore"                     print(", switching to a more needed ore");
   75:  ucontrol flag 1 0 0 0 0                                      flag(1);
   76:  jump *label6 always 0 0                                      return;
        label *label32                                               if core.sensor(ore) > min then
        label *label30                                               if ore != minOre then
   77:  sensor *tmp47 @unit @firstItem                               if @unit.@firstItem != ore then
   78:  jump *label34 equal *tmp47 :mine:ore                         ...
   79:  print " (dropping)"                                          print(" (dropping)");
   80:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label34                                               if @unit.@firstItem != ore then
   81:  sensor *tmp50 @unit @totalItems                              if @unit.@totalItems >= capacity then
   82:  jump *label36 lessThan *tmp50 20                             ...
   83:  print ", full"                                               print(", full");
   84:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   85:  ucontrol flag 1 0 0 0 0                                      flag(1);
   86:  jump *label37 always 0 0                                     if @unit.@totalItems >= capacity then
        label *label36                                               ...
   87:  set *tmp54 @ore-lead                                         var oreFloor = ore == @lead ? @ore-lead : ore == @copper ? @ore-copper : @sand;
   88:  jump *label39 equal :mine:ore @lead                          ...
   89:  set *tmp54 @sand                                             ...
   90:  jump *label41 notEqual :mine:ore @copper                     ...
   91:  set *tmp54 @ore-copper                                       ...
        label *label41                                               ...
        label *label39                                               ...
   92:  print " at {0}, "                                            print($" at $x, $y");
   93:  format :mine:x                                               ...
   94:  print :mine:y                                                ...
   95:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
   96:  ucontrol getBlock :mine:x :mine:x 0 0 :mine:floor            getBlock(x, x, , out floor);
   97:  jump *label42 notEqual :mine:floor *tmp54                    if floor == oreFloor then
   98:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
   99:  jump *label43 always 0 0                                     if floor == oreFloor then
        label *label42                                               ...
  100:  jump *label44 equal :mine:floor null                         elsif floor != null then
  101:  ucontrol flag 1 0 0 0 0                                      flag(1);
  102:  print ": ore disappeared!\n"                                 println(": ore disappeared!");
  103:  jump *label45 always 0 0                                     elsif floor != null then
        label *label44                                               ...
  104:  print ": too far away\n"                                     println(": too far away");
        label *label45                                               elsif floor != null then
        label *label43                                               if floor == oreFloor then
        label *label37                                               if @unit.@totalItems >= capacity then
  105:  print "\n"                                                   println();
  106:  jump *label6 always 0 0                                      while true do


Performance: parsed in 208 ms, compiled in 277 ms, optimized in 214 ms, run in 2 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (4 steps):
The program didn't generate any output.
Execution exception at instruction 6: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
