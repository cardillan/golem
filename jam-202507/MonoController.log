   114 instructions before optimizations.
     8 instructions eliminated by Temp Variables Elimination (2 iterations).
    16 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    12 instructions eliminated by Jump Optimization (5 iterations).
     7 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     2 instructions eliminated by If Expression Optimization (3 iterations).
     6 instructions eliminated by Data Flow Optimization (6 iterations).
     1 instructions eliminated by Jump Straightening (5 iterations).
     5 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    60 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-12 instructions):
 
    57 label *label18
    58 set *tmp20 null
    59 label *label19
-    * set *tmp17 *tmp20
    60 jump *label17 always
    61 label *label16
-    * set *tmp17 null
    62 label *label17
    63 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp21 *tmp22
    64 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    71 op add *tmp28 *tmp25 *tmp27
    72 ucontrol flag *tmp28
    73 label *label15
-    * set *tmp14 null
    74 jump *label14 always
    75 label *label13
    76 op equal *tmp29 :flag 1
 
    81 op equal *tmp32 *tmp31 null
    82 jump *label23 equal *tmp32 false
    83 ucontrol flag 0
-    * set *tmp33 null
    84 jump *label24 always
    85 label *label23
-    * set *tmp33 null
    86 label *label24
    87 label *label22
    88 set *tmp30 null
 
   103 op greaterThan *tmp40 *tmp38 *tmp39
   104 jump *label26 equal *tmp40 false
   105 ucontrol flag 0
-    * set *tmp41 null
   106 jump *label27 always
   107 label *label26
-    * set *tmp41 null
   108 label *label27
   109 sensor *tmp42 @unit @firstItem
   110 op notEqual *tmp43 *tmp42 :mine:ore
   111 jump *label28 equal *tmp43 false
   112 ucontrol itemDrop @air 20
-    * set *tmp44 null
   113 jump *label29 always
   114 label *label28
-    * set *tmp44 null
   115 label *label29
   116 ucontrol approach :mine:x :mine:y 7
   117 ucontrol mine :mine:x :mine:y
 
   120 jump *label30 equal *tmp46 false
   121 ucontrol approach .coreX .coreY 7
   122 ucontrol flag 1
-    * set *tmp47 null
   123 jump *label31 always
   124 label *label30
-    * set *tmp47 null
   125 label *label31
   126 label *label25
   127 set *tmp30 null
   128 label *label21
-    * set *tmp14 *tmp30
   129 label *label14
   130 label *label7
   131 jump *label6 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-4 instructions):
 
    52 op notEqual *tmp19 *tmp18 null
    53 jump *label18 equal *tmp19 false
    54 jump *label15 always
-    * set *tmp20 null
    55 jump *label19 always
    56 label *label18
-    * set *tmp20 null
    57 label *label19
    58 jump *label17 always
    59 label *label16
 
    83 label *label23
    84 label *label24
    85 label *label22
-    * set *tmp30 null
    86 jump *label21 always
    87 label *label20
    88 set :mine:flag :flag
 
   121 label *label30
   122 label *label31
   123 label *label25
-    * set *tmp30 null
   124 label *label21
   125 label *label14
   126 label *label7

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-8 instructions):
 
     6 jump *label0 notEqual *tmp0 false
     7 label *label2
     8 label *label3
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+    9 ulocate building core false @copper .coreX .coreY 0 .core
    10 label *label4
    11 op equal *tmp3 .core null
    12 jump *label3 notEqual *tmp3 false
 
    14 label *label6
    15 jump *label8 equal true false
    16 ubind @mono
-    * sensor *tmp4 .core @lead
-    * set :lead *tmp4
-    * sensor *tmp5 .core @sand
-    * set :sand *tmp5
-    * sensor *tmp6 .core @copper
-    * set :copper *tmp6
+   17 sensor :lead .core @lead
+   18 sensor :sand .core @sand
+   19 sensor :copper .core @copper
    20 op min *tmp7 :lead :sand
    21 op min *tmp7 *tmp7 :copper
    22 set .min *tmp7
 
    35 set *tmp9 *tmp11
    36 label *label10
    37 set .minOre *tmp9
-    * sensor *tmp12 @unit @flag
-    * set :flag *tmp12
+   38 sensor :flag @unit @flag
    39 op equal *tmp13 :flag 0
    40 jump *label13 equal *tmp13 false
    41 set :findOreToMine:ore .minOre
 
    53 jump *label17 always
    54 label *label16
    55 label *label17
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp21 *tmp22
+   56 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
    57 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    58 ucontrol mine :findOreToMine:x :findOreToMine:y
    59 op mul *tmp23 :findOreToMine:x 1000
 
    83 set :mine:flag :flag
    84 op idiv :mine:flag :mine:flag 2
    85 op mod *tmp34 :mine:flag 16
-    * lookup item *tmp35 *tmp34
-    * set :mine:ore *tmp35
+   86 lookup item :mine:ore *tmp34
    87 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp36 :mine:flag 1000
-    * set :mine:y *tmp36
-    * op idiv *tmp37 :mine:flag 1000
-    * set :mine:x *tmp37
+   88 op mod :mine:y :mine:flag 1000
+   89 op idiv :mine:x :mine:flag 1000
    90 sensor *tmp38 .core :mine:ore
    91 op add *tmp39 .min 500
    92 op greaterThan *tmp40 *tmp38 *tmp39

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    12 jump *label3 notEqual *tmp3 false
    13 label *label5
    14 label *label6
-    * jump *label8 equal true false
    15 ubind @mono
    16 sensor :lead .core @lead
    17 sensor :sand .core @sand

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-12 instructions):
 
     2 label *label0
     3 ubind @mono
     4 label *label1
-    * op equal *tmp0 @unit null
-    * jump *label0 notEqual *tmp0 false
+    5 jump *label0 equal @unit null
     6 label *label2
     7 label *label3
     8 ulocate building core false @copper .coreX .coreY 0 .core
     9 label *label4
-    * op equal *tmp3 .core null
-    * jump *label3 notEqual *tmp3 false
+   10 jump *label3 equal .core null
    11 label *label5
    12 label *label6
    13 ubind @mono
 
    17 op min *tmp7 :lead :sand
    18 op min *tmp7 *tmp7 :copper
    19 set .min *tmp7
-    * op equal *tmp8 .min :sand
-    * jump *label9 equal *tmp8 false
+   20 jump *label9 notEqual .min :sand
    21 set *tmp9 @sand
    22 jump *label10 always
    23 label *label9
-    * op equal *tmp10 .min :lead
-    * jump *label11 equal *tmp10 false
+   24 jump *label11 notEqual .min :lead
    25 set *tmp11 @lead
    26 jump *label12 always
    27 label *label11
 
    31 label *label10
    32 set .minOre *tmp9
    33 sensor :flag @unit @flag
-    * op equal *tmp13 :flag 0
-    * jump *label13 equal *tmp13 false
+   34 jump *label13 notEqual :flag 0
    35 set :findOreToMine:ore .minOre
    36 sensor *tmp15 @unit @firstItem
-    * op notEqual *tmp16 *tmp15 null
-    * jump *label16 equal *tmp16 false
+   37 jump *label16 equal *tmp15 null
    38 ucontrol itemDrop @air 20
    39 sensor *tmp18 @unit @firstItem
-    * op notEqual *tmp19 *tmp18 null
-    * jump *label18 equal *tmp19 false
+   40 jump *label18 equal *tmp18 null
    41 jump *label15 always
    42 jump *label19 always
    43 label *label18
 
    58 label *label15
    59 jump *label14 always
    60 label *label13
-    * op equal *tmp29 :flag 1
-    * jump *label20 equal *tmp29 false
+   61 jump *label20 notEqual :flag 1
    62 ucontrol approach .coreX .coreY 7
    63 ucontrol itemDrop .core 20
    64 sensor *tmp31 @unit @firstItem
-    * op equal *tmp32 *tmp31 null
-    * jump *label23 equal *tmp32 false
+   65 jump *label23 notEqual *tmp31 null
    66 ucontrol flag 0
    67 jump *label24 always
    68 label *label23
 
    79 op idiv :mine:x :mine:flag 1000
    80 sensor *tmp38 .core :mine:ore
    81 op add *tmp39 .min 500
-    * op greaterThan *tmp40 *tmp38 *tmp39
-    * jump *label26 equal *tmp40 false
+   82 jump *label26 lessThanEq *tmp38 *tmp39
    83 ucontrol flag 0
    84 jump *label27 always
    85 label *label26
    86 label *label27
    87 sensor *tmp42 @unit @firstItem
-    * op notEqual *tmp43 *tmp42 :mine:ore
-    * jump *label28 equal *tmp43 false
+   88 jump *label28 equal *tmp42 :mine:ore
    89 ucontrol itemDrop @air 20
    90 jump *label29 always
    91 label *label28
 
    93 ucontrol approach :mine:x :mine:y 7
    94 ucontrol mine :mine:x :mine:y
    95 sensor *tmp45 @unit @totalItems
-    * op greaterThanEq *tmp46 *tmp45 20
-    * jump *label30 equal *tmp46 false
+   96 jump *label30 lessThan *tmp45 20
    97 ucontrol approach .coreX .coreY 7
    98 ucontrol flag 1
    99 jump *label31 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-6 instructions):
 
    39 sensor *tmp18 @unit @firstItem
    40 jump *label18 equal *tmp18 null
    41 jump *label15 always
-    * jump *label19 always
    42 label *label18
    43 label *label19
-    * jump *label17 always
    44 label *label16
    45 label *label17
    46 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
 
    62 sensor *tmp31 @unit @firstItem
    63 jump *label23 notEqual *tmp31 null
    64 ucontrol flag 0
-    * jump *label24 always
    65 label *label23
    66 label *label24
    67 label *label22
 
    78 op add *tmp39 .min 500
    79 jump *label26 lessThanEq *tmp38 *tmp39
    80 ucontrol flag 0
-    * jump *label27 always
    81 label *label26
    82 label *label27
    83 sensor *tmp42 @unit @firstItem
    84 jump *label28 equal *tmp42 :mine:ore
    85 ucontrol itemDrop @air 20
-    * jump *label29 always
    86 label *label28
    87 label *label29
    88 ucontrol approach :mine:x :mine:y 7
 
    91 jump *label30 lessThan *tmp45 20
    92 ucontrol approach .coreX .coreY 7
    93 ucontrol flag 1
-    * jump *label31 always
    94 label *label30
    95 label *label31
    96 label *label25

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
-    * set .min 0
-    * set .minOre null
     0 label *label0
     1 ubind @mono
     2 label *label1
 
    15 op min *tmp7 :lead :sand
    16 op min *tmp7 *tmp7 :copper
    17 set .min *tmp7
-    * jump *label9 notEqual .min :sand
+   18 jump *label9 notEqual *tmp7 :sand
    19 set *tmp9 @sand
    20 jump *label10 always
    21 label *label9
-    * jump *label11 notEqual .min :lead
+   22 jump *label11 notEqual *tmp7 :lead
    23 set *tmp11 @lead
    24 jump *label12 always
    25 label *label11
 
    30 set .minOre *tmp9
    31 sensor :flag @unit @flag
    32 jump *label13 notEqual :flag 0
-    * set :findOreToMine:ore .minOre
+   33 set :findOreToMine:ore *tmp9
    34 sensor *tmp15 @unit @firstItem
    35 jump *label16 equal *tmp15 null
    36 ucontrol itemDrop @air 20
 
    41 label *label19
    42 label *label16
    43 label *label17
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
+   44 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    45 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    46 ucontrol mine :findOreToMine:x :findOreToMine:y
    47 op mul *tmp23 :findOreToMine:x 1000
    48 op add *tmp24 *tmp23 :findOreToMine:y
    49 op mul *tmp25 *tmp24 32
-    * sensor *tmp26 :findOreToMine:ore @id
+   50 sensor *tmp26 .minOre @id
    51 op mul *tmp27 *tmp26 2
    52 op add *tmp28 *tmp25 *tmp27
    53 ucontrol flag *tmp28
 
    66 jump *label21 always
    67 label *label20
    68 set :mine:flag :flag
-    * op idiv :mine:flag :mine:flag 2
+   69 op idiv :mine:flag :flag 2
    70 op mod *tmp34 :mine:flag 16
    71 lookup item :mine:ore *tmp34
    72 op idiv :mine:flag :mine:flag 16
    73 op mod :mine:y :mine:flag 1000
    74 op idiv :mine:x :mine:flag 1000
    75 sensor *tmp38 .core :mine:ore
-    * op add *tmp39 .min 500
+   76 op add *tmp39 *tmp7 500
    77 jump *label26 lessThanEq *tmp38 *tmp39
    78 ucontrol flag 0
    79 label *label26

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    14 sensor :copper .core @copper
    15 op min *tmp7 :lead :sand
    16 op min *tmp7 *tmp7 :copper
-    * set .min *tmp7
    17 jump *label9 notEqual *tmp7 :sand
    18 set *tmp9 @sand
    19 jump *label10 always
 
    29 set .minOre *tmp9
    30 sensor :flag @unit @flag
    31 jump *label13 notEqual :flag 0
-    * set :findOreToMine:ore *tmp9
    32 sensor *tmp15 @unit @firstItem
    33 jump *label16 equal *tmp15 null
    34 ucontrol itemDrop @air 20
 
    39 label *label19
    40 label *label16
    41 label *label17
-    * ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
+   42 ulocate ore core true *tmp9 :findOreToMine:x :findOreToMine:y 0 0
    43 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    44 ucontrol mine :findOreToMine:x :findOreToMine:y
    45 op mul *tmp23 :findOreToMine:x 1000
    46 op add *tmp24 *tmp23 :findOreToMine:y
    47 op mul *tmp25 *tmp24 32
-    * sensor *tmp26 .minOre @id
+   48 sensor *tmp26 *tmp9 @id
    49 op mul *tmp27 *tmp26 2
    50 op add *tmp28 *tmp25 *tmp27
    51 ucontrol flag *tmp28
 
    63 label *label22
    64 jump *label21 always
    65 label *label20
-    * set :mine:flag :flag
    66 op idiv :mine:flag :flag 2
    67 op mod *tmp34 :mine:flag 16
    68 lookup item :mine:ore *tmp34

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
    26 label *label12
    27 set *tmp9 *tmp11
    28 label *label10
-    * set .minOre *tmp9
    29 sensor :flag @unit @flag
    30 jump *label13 notEqual :flag 0
    31 sensor *tmp15 @unit @firstItem

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    14 sensor :copper .core @copper
    15 op min *tmp7 :lead :sand
    16 op min *tmp7 *tmp7 :copper
-    * jump *label9 notEqual *tmp7 :sand
    17 set *tmp9 @sand
-    * jump *label10 always
+   18 jump *label10 equal *tmp7 :sand
    19 label *label9
-    * jump *label11 notEqual *tmp7 :lead
-    * set *tmp11 @lead
+   20 set *tmp9 @copper
+   21 jump *label12 notEqual *tmp7 :lead
+   22 set *tmp9 @lead
    23 jump *label12 always
-    * label *label11
-    * set *tmp11 @copper
    24 label *label12
-    * set *tmp9 *tmp11
    25 label *label10
    26 sensor :flag @unit @flag
    27 jump *label13 notEqual :flag 0

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    20 set *tmp9 @copper
    21 jump *label12 notEqual *tmp7 :lead
    22 set *tmp9 @lead
-    * jump *label12 always
    23 label *label12
    24 label *label10
    25 sensor :flag @unit @flag

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
     0 label *label0
     1 ubind @mono
-    * label *label1
     2 jump *label0 equal @unit null
-    * label *label2
     3 label *label3
     4 ulocate building core false @copper .coreX .coreY 0 .core
-    * label *label4
     5 jump *label3 equal .core null
-    * label *label5
     6 label *label6
     7 ubind @mono
     8 sensor :lead .core @lead
 
    12 op min *tmp7 *tmp7 :copper
    13 set *tmp9 @sand
    14 jump *label10 equal *tmp7 :sand
-    * label *label9
    15 set *tmp9 @copper
    16 jump *label12 notEqual *tmp7 :lead
    17 set *tmp9 @lead
 
    26 jump *label18 equal *tmp18 null
    27 jump *label15 always
    28 label *label18
-    * label *label19
    29 label *label16
-    * label *label17
    30 ulocate ore core true *tmp9 :findOreToMine:x :findOreToMine:y 0 0
    31 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    32 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    47 jump *label23 notEqual *tmp31 null
    48 ucontrol flag 0
    49 label *label23
-    * label *label24
-    * label *label22
    50 jump *label21 always
    51 label *label20
    52 op idiv :mine:flag :flag 2
 
    60 jump *label26 lessThanEq *tmp38 *tmp39
    61 ucontrol flag 0
    62 label *label26
-    * label *label27
    63 sensor *tmp42 @unit @firstItem
    64 jump *label28 equal *tmp42 :mine:ore
    65 ucontrol itemDrop @air 20
    66 label *label28
-    * label *label29
    67 ucontrol approach :mine:x :mine:y 7
    68 ucontrol mine :mine:x :mine:y
    69 sensor *tmp45 @unit @totalItems
 
    71 ucontrol approach .coreX .coreY 7
    72 ucontrol flag 1
    73 label *label30
-    * label *label31
-    * label *label25
    74 label *label21
    75 label *label14
-    * label *label7
    76 jump *label6 always
-    * label *label8
    77 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    23 jump *label16 equal *tmp15 null
    24 ucontrol itemDrop @air 20
    25 sensor *tmp18 @unit @firstItem
-    * jump *label18 equal *tmp18 null
-    * jump *label15 always
+   26 jump *label15 notEqual *tmp18 null
    27 label *label18
    28 label *label16
    29 ulocate ore core true *tmp9 :findOreToMine:x :findOreToMine:y 0 0

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    24 ucontrol itemDrop @air 20
    25 sensor *tmp18 @unit @firstItem
    26 jump *label15 notEqual *tmp18 null
-    * label *label18
    27 label *label16
    28 ulocate ore core true *tmp9 :findOreToMine:x :findOreToMine:y 0 0
    29 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    23 jump *label16 equal *tmp15 null
    24 ucontrol itemDrop @air 20
    25 sensor *tmp18 @unit @firstItem
-    * jump *label15 notEqual *tmp18 null
+   26 jump *label6 notEqual *tmp18 null
    27 label *label16
    28 ulocate ore core true *tmp9 :findOreToMine:x :findOreToMine:y 0 0
    29 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    36 op add *tmp28 *tmp25 *tmp27
    37 ucontrol flag *tmp28
    38 label *label15
-    * jump *label14 always
+   39 jump *label6 always
    40 label *label13
    41 jump *label20 notEqual :flag 1
    42 ucontrol approach .coreX .coreY 7
    43 ucontrol itemDrop .core 20
    44 sensor *tmp31 @unit @firstItem
-    * jump *label23 notEqual *tmp31 null
+   45 jump *label6 notEqual *tmp31 null
    46 ucontrol flag 0
    47 label *label23
-    * jump *label21 always
+   48 jump *label6 always
    49 label *label20
    50 op idiv :mine:flag :flag 2
    51 op mod *tmp34 :mine:flag 16
 
    65 ucontrol approach :mine:x :mine:y 7
    66 ucontrol mine :mine:x :mine:y
    67 sensor *tmp45 @unit @totalItems
-    * jump *label30 lessThan *tmp45 20
+   68 jump *label6 lessThan *tmp45 20
    69 ucontrol approach .coreX .coreY 7
    70 ucontrol flag 1
    71 label *label30

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-1 instructions):
 
    35 op mul *tmp27 *tmp26 2
    36 op add *tmp28 *tmp25 *tmp27
    37 ucontrol flag *tmp28
-    * label *label15
    38 jump *label6 always
    39 label *label13
    40 jump *label20 notEqual :flag 1
 
    43 sensor *tmp31 @unit @firstItem
    44 jump *label6 notEqual *tmp31 null
    45 ucontrol flag 0
-    * label *label23
    46 jump *label6 always
    47 label *label20
    48 op idiv :mine:flag :flag 2
 
    66 jump *label6 lessThan *tmp45 20
    67 ucontrol approach .coreX .coreY 7
    68 ucontrol flag 1
-    * label *label30
-    * label *label21
-    * label *label14
    69 jump *label6 always
-    * end

Final code before resolving virtual instructions:

        label *label0                                                do
    0:  ubind @mono                                                  ubind(@mono);
    1:  jump *label0 equal @unit null                                do
        label *label3                                                do
    2:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
    3:  jump *label3 equal .core null                                do
        label *label6                                                while true do
    4:  ubind @mono                                                  ubind(@mono);
    5:  sensor :lead .core @lead                                     var lead = core.@lead;
    6:  sensor :sand .core @sand                                     var sand = core.@sand;
    7:  sensor :copper .core @copper                                 var copper = core.@copper;
    8:  op min *tmp7 :lead :sand                                     min = min(lead, sand, copper);
    9:  op min *tmp7 *tmp7 :copper                                   ...
   10:  set *tmp9 @sand                                              minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   11:  jump *label10 equal *tmp7 :sand                              ...
   12:  set *tmp9 @copper                                            ...
   13:  jump *label12 notEqual *tmp7 :lead                           ...
   14:  set *tmp9 @lead                                              ...
        label *label12                                               ...
        label *label10                                               ...
   15:  sensor :flag @unit @flag                                     var flag = @unit.@flag;
   16:  jump *label13 notEqual :flag 0                               if flag == 0 then
   17:  sensor *tmp15 @unit @firstItem                               if @unit.@firstItem != null then
   18:  jump *label16 equal *tmp15 null                              ...
   19:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   20:  sensor *tmp18 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   21:  jump *label6 notEqual *tmp18 null                            ...
        label *label16                                               if @unit.@firstItem != null then
   22:  ulocate ore core true *tmp9 :findOreToMine:x :findOreToMine: ulocate(:ore, ore, out x, out y);
   23:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   24:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   25:  op mul *tmp23 :findOreToMine:x 1000                          flag((x * 1000 + y) * 32 + ore.@id * 2);
   26:  op add *tmp24 *tmp23 :findOreToMine:y                        ...
   27:  op mul *tmp25 *tmp24 32                                      ...
   28:  sensor *tmp26 *tmp9 @id                                      ...
   29:  op mul *tmp27 *tmp26 2                                       ...
   30:  op add *tmp28 *tmp25 *tmp27                                  ...
   31:  ucontrol flag *tmp28 0 0 0 0                                 ...
   32:  jump *label6 always 0 0                                      if flag == 0 then
        label *label13                                               ...
   33:  jump *label20 notEqual :flag 1                               elsif flag == 1 then
   34:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   35:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
   36:  sensor *tmp31 @unit @firstItem                               if @unit.@firstItem == null then
   37:  jump *label6 notEqual *tmp31 null                            ...
   38:  ucontrol flag 0 0 0 0 0                                      flag(0);
   39:  jump *label6 always 0 0                                      elsif flag == 1 then
        label *label20                                               ...
   40:  op idiv :mine:flag :flag 2                                   flag \= 2;
   41:  op mod *tmp34 :mine:flag 16                                  var ore = lookup(:item, flag % 16);
   42:  lookup item :mine:ore *tmp34                                 ...
   43:  op idiv :mine:flag :mine:flag 16                             flag \= 16;
   44:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   45:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   46:  sensor *tmp38 .core :mine:ore                                if core.sensor(ore) > min + 500 then
   47:  op add *tmp39 *tmp7 500                                      ...
   48:  jump *label26 lessThanEq *tmp38 *tmp39                       ...
   49:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label26                                               if core.sensor(ore) > min + 500 then
   50:  sensor *tmp42 @unit @firstItem                               if @unit.@firstItem != ore then
   51:  jump *label28 equal *tmp42 :mine:ore                         ...
   52:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label28                                               if @unit.@firstItem != ore then
   53:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
   54:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
   55:  sensor *tmp45 @unit @totalItems                              if @unit.@totalItems >= capacity then
   56:  jump *label6 lessThan *tmp45 20                              ...
   57:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   58:  ucontrol flag 1 0 0 0 0                                      flag(1);
   59:  jump *label6 always 0 0                                      while true do


Performance: parsed in 185 ms, compiled in 271 ms, optimized in 198 ms, run in 2 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (1 steps):
The program didn't generate any output.
Execution exception at instruction 0: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
