   205 instructions before optimizations.
     9 instructions eliminated by Temp Variables Elimination (2 passes, 5 iterations).
    28 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
    20 instructions eliminated by Jump Optimization (4 iterations).
     7 instructions eliminated by Single Step Elimination (5 iterations).
    14 instructions eliminated by If Expression Optimization (4 iterations).
     5 instructions eliminated by Data Flow Optimization (4 iterations).
     1 instructions eliminated by Jump Straightening (4 iterations).
     5 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   104 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-14 instructions):
 
    60 op add .min .min 100
    61 set *tmp18 .min
    62 label *label19
-    * set *tmp5 *tmp18
    63 jump *label13 always
    64 label *label12
-    * set *tmp5 null
    65 label *label13
    66 sensor *tmp19 @unit @flag
    67 set :backgroundProcess:flag *tmp19
 
    84 label *label25
    85 set *tmp27 null
    86 label *label26
-    * set *tmp24 *tmp27
    87 jump *label24 always
    88 label *label23
-    * set *tmp24 null
    89 label *label24
    90 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
    91 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
   107 print :findOreToMine:y
   108 print "\n"
   109 label *label22
-    * set *tmp21 null
   110 jump *label21 always
   111 label *label20
   112 op equal *tmp36 :backgroundProcess:flag 1
 
   120 print " (finished)"
   121 print "\n"
   122 ucontrol flag 0
-    * set *tmp40 null
   123 jump *label31 always
   124 label *label30
-    * set *tmp40 null
   125 label *label31
   126 print "\n"
   127 label *label29
 
   167 label *label39
   168 set *tmp53 null
   169 label *label40
-    * set *tmp50 *tmp53
   170 jump *label38 always
   171 label *label37
-    * set *tmp50 null
   172 label *label38
   173 sensor *tmp54 @unit @firstItem
   174 op notEqual *tmp55 *tmp54 :mine:ore
   175 jump *label41 equal *tmp55 false
   176 print " (dropping)"
   177 ucontrol itemDrop @air 20
-    * set *tmp56 null
   178 jump *label42 always
   179 label *label41
-    * set *tmp56 null
   180 label *label42
   181 sensor *tmp57 @unit @totalItems
   182 op greaterThanEq *tmp58 *tmp57 20
 
   184 print ", full"
   185 ucontrol approach .coreX .coreY 7
   186 ucontrol flag 1
-    * set *tmp59 null
   187 jump *label44 always
   188 label *label43
   189 set :mine:floor null
 
   225 label *label50
   226 set *tmp63 *tmp67
   227 label *label46
-    * set *tmp59 *tmp63
   228 label *label44
   229 print "\n"
   230 label *label32
   231 set *tmp37 null
   232 label *label28
-    * set *tmp21 *tmp37
   233 label *label21
   234 label *label10
   235 jump *label9 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-10 instructions):
 
    54 op lessThan *tmp17 .min 10
    55 jump *label18 equal *tmp17 false
    56 set .min -100
-    * set *tmp18 .min
    57 jump *label19 always
    58 label *label18
    59 op add .min .min 100
-    * set *tmp18 .min
    60 label *label19
    61 jump *label13 always
    62 label *label12
 
    77 op notEqual *tmp26 *tmp25 null
    78 jump *label25 equal *tmp26 false
    79 jump *label22 always
-    * set *tmp27 null
    80 jump *label26 always
    81 label *label25
-    * set *tmp27 null
    82 label *label26
    83 jump *label24 always
    84 label *label23
 
   121 label *label31
   122 print "\n"
   123 label *label29
-    * set *tmp37 null
   124 jump *label28 always
   125 label *label27
   126 set :mine:flag :backgroundProcess:flag
 
   157 print ", switching to a more needed ore"
   158 ucontrol flag 1
   159 jump *label32 always
-    * set *tmp53 null
   160 jump *label40 always
   161 label *label39
-    * set *tmp53 null
   162 label *label40
   163 jump *label38 always
   164 label *label37
 
   202 print "\n"
   203 set *tmp65 ": no ore!"
   204 label *label48
-    * set *tmp63 *tmp65
   205 jump *label46 always
   206 label *label45
   207 op equal *tmp66 :mine:block null
 
   215 print "\n"
   216 set *tmp67 ": blocked!"
   217 label *label50
-    * set *tmp63 *tmp67
   218 label *label46
   219 label *label44
   220 print "\n"
   221 label *label32
-    * set *tmp37 null
   222 label *label28
   223 label *label21
   224 label *label10

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   194 jump *label47 equal *tmp64 false
   195 print ": too far"
   196 print "\n"
-    * set *tmp65 ": too far"
   197 jump *label48 always
   198 label *label47
   199 ucontrol flag 1
   200 print ": no ore!"
   201 print "\n"
-    * set *tmp65 ": no ore!"
   202 label *label48
   203 jump *label46 always
   204 label *label45
   205 op equal *tmp66 :mine:block null
   206 jump *label49 equal *tmp66 false
   207 ucontrol mine :mine:x :mine:y
-    * set *tmp67 null
   208 jump *label50 always
   209 label *label49
   210 ucontrol flag 1
   211 print ": blocked!"
   212 print "\n"
-    * set *tmp67 ": blocked!"
   213 label *label50
   214 label *label46
   215 label *label44

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-9 instructions):
 
     9 label *label5
    10 set :backgroundProcess:firstItem @unit
    11 label *label6
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   12 ulocate building core false @copper .coreX .coreY *tmp2 .core
    13 label *label7
    14 op equal *tmp3 .core null
    15 jump *label6 notEqual *tmp3 false
 
    21 jump *label12 equal *tmp4 false
    22 printflush message1
    23 sensor *tmp6 .core @lead
-    * op sub *tmp7 *tmp6 .leadTarget
-    * set :backgroundProcess:lead *tmp7
+   24 op sub :backgroundProcess:lead *tmp6 .leadTarget
    25 sensor *tmp8 .core @sand
-    * op sub *tmp9 *tmp8 .sandTarget
-    * set :backgroundProcess:sand *tmp9
+   26 op sub :backgroundProcess:sand *tmp8 .sandTarget
    27 sensor *tmp10 .core @copper
-    * op sub *tmp11 *tmp10 .copperTarget
-    * set :backgroundProcess:copper *tmp11
+   28 op sub :backgroundProcess:copper *tmp10 .copperTarget
    29 op min *tmp12 :backgroundProcess:lead :backgroundProcess:sand
    30 op min *tmp12 *tmp12 :backgroundProcess:copper
    31 set .min *tmp12
 
    57 jump *label13 always
    58 label *label12
    59 label *label13
-    * sensor *tmp19 @unit @flag
-    * set :backgroundProcess:flag *tmp19
+   60 sensor :backgroundProcess:flag @unit @flag
    61 print "Unit flag: "
    62 print :backgroundProcess:flag
    63 print "\n"
 
   122 print "Mining"
   123 op idiv :mine:flag :mine:flag 2
   124 op mod *tmp41 :mine:flag 16
-    * lookup item *tmp42 *tmp41
-    * set :mine:ore *tmp42
+  125 lookup item :mine:ore *tmp41
   126 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp43 :mine:flag 1000
-    * set :mine:y *tmp43
-    * op idiv *tmp44 :mine:flag 1000
-    * set :mine:x *tmp44
+  127 op mod :mine:y :mine:flag 1000
+  128 op idiv :mine:x :mine:flag 1000
   129 op equal *tmp45 :mine:ore @copper
   130 jump *label33 equal *tmp45 false
   131 set *tmp46 @ore-copper
 
   178 print " "
   179 print :mine:y
   180 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp61 *tmp60 :mine:floor
-    * set :mine:block *tmp60
+  181 ucontrol getBlock :mine:x :mine:y *tmp61 :mine:block :mine:floor
   182 op notEqual *tmp62 :mine:floor :mine:floorOre
   183 jump *label45 equal *tmp62 false
   184 op equal *tmp64 :mine:floor null

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    15 jump *label6 notEqual *tmp3 false
    16 label *label8
    17 label *label9
-    * jump *label11 equal true false
    18 ubind @mono
    19 op equal *tmp4 @unit :backgroundProcess:firstItem
    20 jump *label12 equal *tmp4 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-20 instructions):
 
     4 label *label3
     5 ubind @mono
     6 label *label4
-    * op equal *tmp0 @unit null
-    * jump *label3 notEqual *tmp0 false
+    7 jump *label3 equal @unit null
     8 label *label5
     9 set :backgroundProcess:firstItem @unit
    10 label *label6
    11 ulocate building core false @copper .coreX .coreY *tmp2 .core
    12 label *label7
-    * op equal *tmp3 .core null
-    * jump *label6 notEqual *tmp3 false
+   13 jump *label6 equal .core null
    14 label *label8
    15 label *label9
    16 ubind @mono
-    * op equal *tmp4 @unit :backgroundProcess:firstItem
-    * jump *label12 equal *tmp4 false
+   17 jump *label12 notEqual @unit :backgroundProcess:firstItem
    18 printflush message1
    19 sensor *tmp6 .core @lead
    20 op sub :backgroundProcess:lead *tmp6 .leadTarget
 
    25 op min *tmp12 :backgroundProcess:lead :backgroundProcess:sand
    26 op min *tmp12 *tmp12 :backgroundProcess:copper
    27 set .min *tmp12
-    * op equal *tmp13 .min :backgroundProcess:sand
-    * jump *label14 equal *tmp13 false
+   28 jump *label14 notEqual .min :backgroundProcess:sand
    29 set *tmp14 @sand
    30 jump *label15 always
    31 label *label14
-    * op equal *tmp15 .min :backgroundProcess:lead
-    * jump *label16 equal *tmp15 false
+   32 jump *label16 notEqual .min :backgroundProcess:lead
    33 set *tmp16 @lead
    34 jump *label17 always
    35 label *label16
 
    41 print "minOre:"
    42 print .minOre
    43 print "\n"
-    * op lessThan *tmp17 .min 10
-    * jump *label18 equal *tmp17 false
+   44 jump *label18 greaterThanEq .min 10
    45 set .min -100
    46 jump *label19 always
    47 label *label18
 
    54 print "Unit flag: "
    55 print :backgroundProcess:flag
    56 print "\n"
-    * op equal *tmp20 :backgroundProcess:flag 0
-    * jump *label20 equal *tmp20 false
+   57 jump *label20 notEqual :backgroundProcess:flag 0
    58 set :findOreToMine:ore .minOre
    59 sensor *tmp22 @unit @firstItem
-    * op notEqual *tmp23 *tmp22 null
-    * jump *label23 equal *tmp23 false
+   60 jump *label23 equal *tmp22 null
    61 ucontrol itemDrop @air 20
    62 sensor *tmp25 @unit @firstItem
-    * op notEqual *tmp26 *tmp25 null
-    * jump *label25 equal *tmp26 false
+   63 jump *label25 equal *tmp25 null
    64 jump *label22 always
    65 jump *label26 always
    66 label *label25
 
    90 label *label22
    91 jump *label21 always
    92 label *label20
-    * op equal *tmp36 :backgroundProcess:flag 1
-    * jump *label27 equal *tmp36 false
+   93 jump *label27 notEqual :backgroundProcess:flag 1
    94 print "Returning ore"
    95 ucontrol approach .coreX .coreY 7
    96 ucontrol itemDrop .core 20
    97 sensor *tmp38 @unit @firstItem
-    * op equal *tmp39 *tmp38 null
-    * jump *label30 equal *tmp39 false
+   98 jump *label30 notEqual *tmp38 null
    99 print " (finished)"
   100 print "\n"
   101 ucontrol flag 0
 
   114 op idiv :mine:flag :mine:flag 16
   115 op mod :mine:y :mine:flag 1000
   116 op idiv :mine:x :mine:flag 1000
-    * op equal *tmp45 :mine:ore @copper
-    * jump *label33 equal *tmp45 false
+  117 jump *label33 notEqual :mine:ore @copper
   118 set *tmp46 @ore-copper
   119 jump *label34 always
   120 label *label33
-    * op equal *tmp47 :mine:ore @lead
-    * jump *label35 equal *tmp47 false
+  121 jump *label35 notEqual :mine:ore @lead
   122 set *tmp48 @ore-lead
   123 jump *label36 always
   124 label *label35
 
   127 set *tmp46 *tmp48
   128 label *label34
   129 set :mine:floorOre *tmp46
-    * op notEqual *tmp49 :mine:ore .minOre
-    * jump *label37 equal *tmp49 false
+  130 jump *label37 equal :mine:ore .minOre
   131 sensor *tmp51 .core :mine:ore
-    * op greaterThan *tmp52 *tmp51 .min
-    * jump *label39 equal *tmp52 false
+  132 jump *label39 lessThanEq *tmp51 .min
   133 print ", switching to a more needed ore"
   134 ucontrol flag 1
   135 jump *label32 always
 
   140 label *label37
   141 label *label38
   142 sensor *tmp54 @unit @firstItem
-    * op notEqual *tmp55 *tmp54 :mine:ore
-    * jump *label41 equal *tmp55 false
+  143 jump *label41 equal *tmp54 :mine:ore
   144 print " (dropping)"
   145 ucontrol itemDrop @air 20
   146 jump *label42 always
   147 label *label41
   148 label *label42
   149 sensor *tmp57 @unit @totalItems
-    * op greaterThanEq *tmp58 *tmp57 20
-    * jump *label43 equal *tmp58 false
+  150 jump *label43 lessThan *tmp57 20
   151 print ", full"
   152 ucontrol approach .coreX .coreY 7
   153 ucontrol flag 1
 
   161 print :mine:y
   162 ucontrol approach :mine:x :mine:y 7
   163 ucontrol getBlock :mine:x :mine:y *tmp61 :mine:block :mine:floor
-    * op notEqual *tmp62 :mine:floor :mine:floorOre
-    * jump *label45 equal *tmp62 false
-    * op equal *tmp64 :mine:floor null
-    * jump *label47 equal *tmp64 false
+  164 jump *label45 equal :mine:floor :mine:floorOre
+  165 jump *label47 notEqual :mine:floor null
   166 print ": too far"
   167 print "\n"
   168 jump *label48 always
 
   173 label *label48
   174 jump *label46 always
   175 label *label45
-    * op equal *tmp66 :mine:block null
-    * jump *label49 equal *tmp66 false
+  176 jump *label49 notEqual :mine:block null
   177 ucontrol mine :mine:x :mine:y
   178 jump *label50 always
   179 label *label49

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    47 label *label18
    48 op add .min .min 100
    49 label *label19
-    * jump *label13 always
    50 label *label12
    51 label *label13
    52 sensor :backgroundProcess:flag @unit @flag
 
    61 sensor *tmp25 @unit @firstItem
    62 jump *label25 equal *tmp25 null
    63 jump *label22 always
-    * jump *label26 always
    64 label *label25
    65 label *label26
-    * jump *label24 always
    66 label *label23
    67 label *label24
    68 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
 
    96 print " (finished)"
    97 print "\n"
    98 ucontrol flag 0
-    * jump *label31 always
    99 label *label30
   100 label *label31
   101 print "\n"
 
   129 print ", switching to a more needed ore"
   130 ucontrol flag 1
   131 jump *label32 always
-    * jump *label40 always
   132 label *label39
   133 label *label40
-    * jump *label38 always
   134 label *label37
   135 label *label38
   136 sensor *tmp54 @unit @firstItem
   137 jump *label41 equal *tmp54 :mine:ore
   138 print " (dropping)"
   139 ucontrol itemDrop @air 20
-    * jump *label42 always
   140 label *label41
   141 label *label42
   142 sensor *tmp57 @unit @totalItems

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    25 op min *tmp12 :backgroundProcess:lead :backgroundProcess:sand
    26 op min *tmp12 *tmp12 :backgroundProcess:copper
    27 set .min *tmp12
-    * jump *label14 notEqual .min :backgroundProcess:sand
+   28 jump *label14 notEqual *tmp12 :backgroundProcess:sand
    29 set *tmp14 @sand
    30 jump *label15 always
    31 label *label14
-    * jump *label16 notEqual .min :backgroundProcess:lead
+   32 jump *label16 notEqual *tmp12 :backgroundProcess:lead
    33 set *tmp16 @lead
    34 jump *label17 always
    35 label *label16
 
    39 label *label15
    40 set .minOre *tmp14
    41 print "minOre:"
-    * print .minOre
+   42 print *tmp14
    43 print "\n"
-    * jump *label18 greaterThanEq .min 10
+   44 jump *label18 greaterThanEq *tmp12 10
    45 set .min -100
    46 jump *label19 always
    47 label *label18
-    * op add .min .min 100
+   48 op add .min *tmp12 100
    49 label *label19
    50 label *label12
    51 label *label13
 
    65 label *label26
    66 label *label23
    67 label *label24
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
+   68 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
    69 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    70 ucontrol mine :findOreToMine:x :findOreToMine:y
    71 op mul *tmp30 :findOreToMine:x 1000
    72 op add *tmp31 *tmp30 :findOreToMine:y
    73 op mul *tmp32 *tmp31 32
-    * sensor *tmp33 :findOreToMine:ore @id
+   74 sensor *tmp33 .minOre @id
    75 op mul *tmp34 *tmp33 2
    76 op add *tmp35 *tmp32 *tmp34
    77 ucontrol flag *tmp35
    78 print "Found "
-    * print :findOreToMine:ore
+   79 print .minOre
    80 print " "
    81 print "at "
    82 print :findOreToMine:x
 
   104 label *label27
   105 set :mine:flag :backgroundProcess:flag
   106 print "Mining"
-    * op idiv :mine:flag :mine:flag 2
+  107 op idiv :mine:flag :backgroundProcess:flag 2
   108 op mod *tmp41 :mine:flag 16
   109 lookup item :mine:ore *tmp41
   110 op idiv :mine:flag :mine:flag 16
 
   146 ucontrol flag 1
   147 jump *label44 always
   148 label *label43
-    * set :mine:floor null
   149 print " at "
   150 print :mine:x
   151 print ","
 
   153 print :mine:y
   154 ucontrol approach :mine:x :mine:y 7
   155 ucontrol getBlock :mine:x :mine:y *tmp61 :mine:block :mine:floor
-    * jump *label45 equal :mine:floor :mine:floorOre
+  156 jump *label45 equal :mine:floor *tmp46
   157 jump *label47 notEqual :mine:floor null
   158 print ": too far"
   159 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    24 op sub :backgroundProcess:copper *tmp10 .copperTarget
    25 op min *tmp12 :backgroundProcess:lead :backgroundProcess:sand
    26 op min *tmp12 *tmp12 :backgroundProcess:copper
-    * set .min *tmp12
    27 jump *label14 notEqual *tmp12 :backgroundProcess:sand
    28 set *tmp14 @sand
    29 jump *label15 always
 
    53 print :backgroundProcess:flag
    54 print "\n"
    55 jump *label20 notEqual :backgroundProcess:flag 0
-    * set :findOreToMine:ore .minOre
    56 sensor *tmp22 @unit @firstItem
    57 jump *label23 equal *tmp22 null
    58 ucontrol itemDrop @air 20
 
   100 label *label29
   101 jump *label28 always
   102 label *label27
-    * set :mine:flag :backgroundProcess:flag
   103 print "Mining"
   104 op idiv :mine:flag :backgroundProcess:flag 2
   105 op mod *tmp41 :mine:flag 16
 
   119 label *label36
   120 set *tmp46 *tmp48
   121 label *label34
-    * set :mine:floorOre *tmp46
   122 jump *label37 equal :mine:ore .minOre
   123 sensor *tmp51 .core :mine:ore
   124 jump *label39 lessThanEq *tmp51 .min

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-8 instructions):
 
    28 set *tmp14 @sand
    29 jump *label15 always
    30 label *label14
-    * jump *label16 notEqual *tmp12 :backgroundProcess:lead
-    * set *tmp16 @lead
-    * jump *label17 always
-    * label *label16
-    * set *tmp16 @copper
-    * label *label17
+   31 select *tmp16 equal *tmp12 :backgroundProcess:lead @lead @copper
    32 set *tmp14 *tmp16
    33 label *label15
    34 set .minOre *tmp14
    35 print "minOre:"
    36 print *tmp14
    37 print "\n"
-    * jump *label18 greaterThanEq *tmp12 10
-    * set .min -100
-    * jump *label19 always
-    * label *label18
-    * op add .min *tmp12 100
-    * label *label19
+   38 op add *tmp68 *tmp12 100
+   39 select .min lessThan *tmp12 10 -100 *tmp68
    40 label *label12
    41 label *label13
    42 sensor :backgroundProcess:flag @unit @flag
 
   102 set *tmp46 @ore-copper
   103 jump *label34 always
   104 label *label33
-    * jump *label35 notEqual :mine:ore @lead
-    * set *tmp48 @ore-lead
-    * jump *label36 always
-    * label *label35
-    * set *tmp48 @sand-floor
-    * label *label36
+  105 select *tmp48 equal :mine:ore @lead @ore-lead @sand-floor
   106 set *tmp46 *tmp48
   107 label *label34
   108 jump *label37 equal :mine:ore .minOre

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 2 (-6 instructions):
 
    24 op sub :backgroundProcess:copper *tmp10 .copperTarget
    25 op min *tmp12 :backgroundProcess:lead :backgroundProcess:sand
    26 op min *tmp12 *tmp12 :backgroundProcess:copper
-    * jump *label14 notEqual *tmp12 :backgroundProcess:sand
-    * set *tmp14 @sand
-    * jump *label15 always
-    * label *label14
-    * select *tmp16 equal *tmp12 :backgroundProcess:lead @lead @copper
-    * set *tmp14 *tmp16
-    * label *label15
+   27 select *tmp71 equal *tmp12 :backgroundProcess:lead @lead @copper
+   28 select *tmp14 equal *tmp12 :backgroundProcess:sand @sand *tmp71
    29 set .minOre *tmp14
    30 print "minOre:"
    31 print *tmp14
 
    93 op idiv :mine:flag :mine:flag 16
    94 op mod :mine:y :mine:flag 1000
    95 op idiv :mine:x :mine:flag 1000
-    * jump *label33 notEqual :mine:ore @copper
-    * set *tmp46 @ore-copper
-    * jump *label34 always
-    * label *label33
-    * select *tmp48 equal :mine:ore @lead @ore-lead @sand-floor
-    * set *tmp46 *tmp48
-    * label *label34
+   96 select *tmp73 equal :mine:ore @lead @ore-lead @sand-floor
+   97 select *tmp46 equal :mine:ore @copper @ore-copper *tmp73
    98 jump *label37 equal :mine:ore .minOre
    99 sensor *tmp51 .core :mine:ore
   100 jump *label39 lessThanEq *tmp51 .min

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
     3 label *label1
     4 label *label3
     5 ubind @mono
-    * label *label4
     6 jump *label3 equal @unit null
-    * label *label5
     7 set :backgroundProcess:firstItem @unit
     8 label *label6
     9 ulocate building core false @copper .coreX .coreY *tmp2 .core
-    * label *label7
    10 jump *label6 equal .core null
-    * label *label8
    11 label *label9
    12 ubind @mono
    13 jump *label12 notEqual @unit :backgroundProcess:firstItem
 
    29 op add *tmp68 *tmp12 100
    30 select .min lessThan *tmp12 10 -100 *tmp68
    31 label *label12
-    * label *label13
    32 sensor :backgroundProcess:flag @unit @flag
    33 print "Unit flag: "
    34 print :backgroundProcess:flag
 
    41 jump *label25 equal *tmp25 null
    42 jump *label22 always
    43 label *label25
-    * label *label26
    44 label *label23
-    * label *label24
    45 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
    46 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    47 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    74 print "\n"
    75 ucontrol flag 0
    76 label *label30
-    * label *label31
    77 print "\n"
-    * label *label29
    78 jump *label28 always
    79 label *label27
    80 print "Mining"
 
    93 ucontrol flag 1
    94 jump *label32 always
    95 label *label39
-    * label *label40
    96 label *label37
-    * label *label38
    97 sensor *tmp54 @unit @firstItem
    98 jump *label41 equal *tmp54 :mine:ore
    99 print " (dropping)"
   100 ucontrol itemDrop @air 20
   101 label *label41
-    * label *label42
   102 sensor *tmp57 @unit @totalItems
   103 jump *label43 lessThan *tmp57 20
   104 print ", full"
 
   139 label *label32
   140 label *label28
   141 label *label21
-    * label *label10
   142 jump *label9 always
-    * label *label11
-    * label *label2
   143 wait 1e12
   144 jump *label1 always
   145 end

Modifications by Jumps phase, Jump Straightening, pass 3, iteration 1 (-1 instructions):
 
    38 jump *label23 equal *tmp22 null
    39 ucontrol itemDrop @air 20
    40 sensor *tmp25 @unit @firstItem
-    * jump *label25 equal *tmp25 null
-    * jump *label22 always
+   41 jump *label22 notEqual *tmp25 null
    42 label *label25
    43 label *label23
    44 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp28 *tmp29

Modifications by Jumps phase, Jump Optimization, pass 3, iteration 1:
 
    39 ucontrol itemDrop @air 20
    40 sensor *tmp25 @unit @firstItem
    41 jump *label22 notEqual *tmp25 null
-    * label *label25
    42 label *label23
    43 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
    44 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
 
    38 jump *label23 equal *tmp22 null
    39 ucontrol itemDrop @air 20
    40 sensor *tmp25 @unit @firstItem
-    * jump *label22 notEqual *tmp25 null
+   41 jump *label9 notEqual *tmp25 null
    42 label *label23
    43 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
    44 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    60 print :findOreToMine:y
    61 print "\n"
    62 label *label22
-    * jump *label21 always
+   63 jump *label9 always
    64 label *label20
    65 jump *label27 notEqual :backgroundProcess:flag 1
    66 print "Returning ore"
 
    73 ucontrol flag 0
    74 label *label30
    75 print "\n"
-    * jump *label28 always
+   76 jump *label9 always
    77 label *label27
    78 print "Mining"
    79 op idiv :mine:flag :backgroundProcess:flag 2
 
    89 jump *label39 lessThanEq *tmp51 .min
    90 print ", switching to a more needed ore"
    91 ucontrol flag 1
-    * jump *label32 always
+   92 jump *label9 always
    93 label *label39
    94 label *label37
    95 sensor *tmp54 @unit @firstItem
 
   115 jump *label47 notEqual :mine:floor null
   116 print ": too far"
   117 print "\n"
-    * jump *label48 always
+  118 jump *label46 always
   119 label *label47
   120 ucontrol flag 1
   121 print ": no ore!"

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-3 instructions):
 
    59 print " "
    60 print :findOreToMine:y
    61 print "\n"
-    * label *label22
    62 jump *label9 always
    63 label *label20
    64 jump *label27 notEqual :backgroundProcess:flag 1
 
   119 ucontrol flag 1
   120 print ": no ore!"
   121 print "\n"
-    * label *label48
   122 jump *label46 always
   123 label *label45
   124 jump *label49 notEqual :mine:block null
 
   132 label *label46
   133 label *label44
   134 print "\n"
-    * label *label32
-    * label *label28
-    * label *label21
   135 jump *label9 always
-    * wait 1e12
-    * jump *label1 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 3, iteration 1:
     0 set .min 0
     1 set .minOre null
     2 set *signature "0:v1"
-    * label *label1
     3 label *label3
     4 ubind @mono
     5 jump *label3 equal @unit null

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
     5 jump *label3 equal @unit null
     6 set :backgroundProcess:firstItem @unit
     7 label *label6
-    * ulocate building core false @copper .coreX .coreY *tmp2 .core
+    8 ulocate building core false @copper .coreX .coreY 0 .core
     9 jump *label6 equal .core null
    10 label *label9
    11 ubind @mono
 
    39 sensor *tmp25 @unit @firstItem
    40 jump *label9 notEqual *tmp25 null
    41 label *label23
-    * ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
+   42 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    43 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    44 ucontrol mine :findOreToMine:x :findOreToMine:y
    45 op mul *tmp30 :findOreToMine:x 1000
 
   108 print " "
   109 print :mine:y
   110 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp61 :mine:block :mine:floor
+  111 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   112 jump *label45 equal :mine:floor *tmp46
   113 jump *label47 notEqual :mine:floor null
   114 print ": too far"

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    22 select *tmp71 equal *tmp12 :backgroundProcess:lead @lead @copper
    23 select *tmp14 equal *tmp12 :backgroundProcess:sand @sand *tmp71
    24 set .minOre *tmp14
-    * print "minOre:"
-    * print *tmp14
-    * print "\n"
+   25 print "minOre:{0}\n"
+   26 format *tmp14
    27 op add *tmp68 *tmp12 100
    28 select .min lessThan *tmp12 10 -100 *tmp68
    29 label *label12
    30 sensor :backgroundProcess:flag @unit @flag
-    * print "Unit flag: "
-    * print :backgroundProcess:flag
-    * print "\n"
+   31 print "Unit flag: {0}\n"
+   32 format :backgroundProcess:flag
    33 jump *label20 notEqual :backgroundProcess:flag 0
    34 sensor *tmp22 @unit @firstItem
    35 jump *label23 equal *tmp22 null
 
    47 op mul *tmp34 *tmp33 2
    48 op add *tmp35 *tmp32 *tmp34
    49 ucontrol flag *tmp35
-    * print "Found "
-    * print .minOre
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   50 print "Found {0} at {0}, {0}\n"
+   51 format .minOre
+   52 format :findOreToMine:x
+   53 format :findOreToMine:y
    54 jump *label9 always
    55 label *label20
    56 jump *label27 notEqual :backgroundProcess:flag 1
 
    59 ucontrol itemDrop .core 20
    60 sensor *tmp38 @unit @firstItem
    61 jump *label30 notEqual *tmp38 null
-    * print " (finished)"
-    * print "\n"
+   62 print " (finished)\n"
    63 ucontrol flag 0
    64 label *label30
    65 print "\n"
 
    94 ucontrol flag 1
    95 jump *label44 always
    96 label *label43
-    * print " at "
-    * print :mine:x
-    * print ","
-    * print " "
+   97 print " at {0}, "
+   98 format :mine:x
    99 print :mine:y
   100 ucontrol approach :mine:x :mine:y 7
   101 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   102 jump *label45 equal :mine:floor *tmp46
   103 jump *label47 notEqual :mine:floor null
-    * print ": too far"
-    * print "\n"
+  104 print ": too far\n"
   105 jump *label46 always
   106 label *label47
   107 ucontrol flag 1
-    * print ": no ore!"
-    * print "\n"
+  108 print ": no ore!\n"
   109 jump *label46 always
   110 label *label45
   111 jump *label49 notEqual :mine:block null
 
   113 jump *label50 always
   114 label *label49
   115 ucontrol flag 1
-    * print ": blocked!"
-    * print "\n"
+  116 print ": blocked!\n"
   117 label *label50
   118 label *label46
   119 label *label44

Final code before resolving virtual instructions:

    0:  set .min 0                                                   var min = 0, minOre = null;
    1:  set .minOre null                                             ...
    2:  set *signature "0:v1"                                        #set target = 8;
        label *label3                                                do
    3:  ubind @mono                                                  ubind(@mono);
    4:  jump *label3 equal @unit null                                do
    5:  set :backgroundProcess:firstItem @unit                       var firstItem = @unit;
        label *label6                                                do
    6:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
    7:  jump *label6 equal .core null                                do
        label *label9                                                while true do
    8:  ubind @mono                                                  ubind(@mono);
    9:  jump *label12 notEqual @unit :backgroundProcess:firstItem    if @unit == firstItem then
   10:  printflush message1                                          printflush(message1);
   11:  sensor *tmp6 .core @lead                                     var lead = core.@lead - leadTarget;
   12:  op sub :backgroundProcess:lead *tmp6 .leadTarget             ...
   13:  sensor *tmp8 .core @sand                                     var sand = core.@sand - sandTarget;
   14:  op sub :backgroundProcess:sand *tmp8 .sandTarget             ...
   15:  sensor *tmp10 .core @copper                                  var copper = core.@copper - copperTarget;
   16:  op sub :backgroundProcess:copper *tmp10 .copperTarget        ...
   17:  op min *tmp12 :backgroundProcess:lead :backgroundProcess:san min = min(lead, sand, copper);
   18:  op min *tmp12 *tmp12 :backgroundProcess:copper               ...
   19:  select *tmp71 equal *tmp12 :backgroundProcess:lead @lead @co minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   20:  select *tmp14 equal *tmp12 :backgroundProcess:sand @sand *tm ...
   21:  set .minOre *tmp14                                           ...
   22:  print "minOre:{0}\n"                                         println("minOre:", minOre);
   23:  format *tmp14                                                ...
   24:  op add *tmp68 *tmp12 100                                     if min < 10 then min = -100; else min += 100; end;
   25:  select .min lessThan *tmp12 10 -100 *tmp68                   ...
        label *label12                                               if @unit == firstItem then
   26:  sensor :backgroundProcess:flag @unit @flag                   var flag = @unit.@flag;
   27:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   28:  format :backgroundProcess:flag                               ...
   29:  jump *label20 notEqual :backgroundProcess:flag 0             if flag == 0 then
   30:  sensor *tmp22 @unit @firstItem                               if @unit.@firstItem != null then
   31:  jump *label23 equal *tmp22 null                              ...
   32:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   33:  sensor *tmp25 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   34:  jump *label9 notEqual *tmp25 null                            ...
        label *label23                                               if @unit.@firstItem != null then
   35:  ulocate ore core true .minOre :findOreToMine:x :findOreToMin ulocate(:ore, ore, out x, out y);
   36:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   37:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   38:  op mul *tmp30 :findOreToMine:x 1000                          flag((x * 1000 + y) * 32 + ore.@id * 2);
   39:  op add *tmp31 *tmp30 :findOreToMine:y                        ...
   40:  op mul *tmp32 *tmp31 32                                      ...
   41:  sensor *tmp33 .minOre @id                                    ...
   42:  op mul *tmp34 *tmp33 2                                       ...
   43:  op add *tmp35 *tmp32 *tmp34                                  ...
   44:  ucontrol flag *tmp35 0 0 0 0                                 ...
   45:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   46:  format .minOre                                               ...
   47:  format :findOreToMine:x                                      ...
   48:  format :findOreToMine:y                                      ...
   49:  jump *label9 always 0 0                                      if flag == 0 then
        label *label20                                               ...
   50:  jump *label27 notEqual :backgroundProcess:flag 1             elsif flag == 1 then
   51:  print "Returning ore"                                        print("Returning ore");
   52:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   53:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
   54:  sensor *tmp38 @unit @firstItem                               if @unit.@firstItem == null then
   55:  jump *label30 notEqual *tmp38 null                           ...
   56:  print " (finished)\n"                                        println(" (finished)");
   57:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label30                                               if @unit.@firstItem == null then
   58:  print "\n"                                                   println();
   59:  jump *label9 always 0 0                                      elsif flag == 1 then
        label *label27                                               ...
   60:  print "Mining"                                               print("Mining");
   61:  op idiv :mine:flag :backgroundProcess:flag 2                 flag \= 2;
   62:  op mod *tmp41 :mine:flag 16                                  var ore = lookup(:item, flag % 16);
   63:  lookup item :mine:ore *tmp41                                 ...
   64:  op idiv :mine:flag :mine:flag 16                             flag \= 16;
   65:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   66:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   67:  select *tmp73 equal :mine:ore @lead @ore-lead @sand-floor    ore == @copper ? @ore-copper :
   68:  select *tmp46 equal :mine:ore @copper @ore-copper *tmp73     ...
   69:  jump *label37 equal :mine:ore .minOre                        if ore != minOre then
   70:  sensor *tmp51 .core :mine:ore                                if core.sensor(ore) > min then
   71:  jump *label39 lessThanEq *tmp51 .min                         ...
   72:  print ", switching to a more needed ore"                     print(", switching to a more needed ore");
   73:  ucontrol flag 1 0 0 0 0                                      flag(1);
   74:  jump *label9 always 0 0                                      return;
        label *label39                                               if core.sensor(ore) > min then
        label *label37                                               if ore != minOre then
   75:  sensor *tmp54 @unit @firstItem                               if @unit.@firstItem != ore then
   76:  jump *label41 equal *tmp54 :mine:ore                         ...
   77:  print " (dropping)"                                          print(" (dropping)");
   78:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label41                                               if @unit.@firstItem != ore then
   79:  sensor *tmp57 @unit @totalItems                              if @unit.@totalItems >= capacity then
   80:  jump *label43 lessThan *tmp57 20                             ...
   81:  print ", full"                                               print(", full");
   82:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   83:  ucontrol flag 1 0 0 0 0                                      flag(1);
   84:  jump *label44 always 0 0                                     if @unit.@totalItems >= capacity then
        label *label43                                               ...
   85:  print " at {0}, "                                            print($" at $x, $y");
   86:  format :mine:x                                               ...
   87:  print :mine:y                                                ...
   88:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
   89:  ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor  var block = getBlock(x, y, , out floor);
   90:  jump *label45 equal :mine:floor *tmp46                       if floor != floorOre then
   91:  jump *label47 notEqual :mine:floor null                      if floor == null then
   92:  print ": too far\n"                                          println(": too far");
   93:  jump *label46 always 0 0                                     if floor == null then
        label *label47                                               ...
   94:  ucontrol flag 1 0 0 0 0                                      flag(1);
   95:  print ": no ore!\n"                                          println(": no ore!");
   96:  jump *label46 always 0 0                                     if floor != floorOre then
        label *label45                                               ...
   97:  jump *label49 notEqual :mine:block null                      elsif block == null then
   98:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
   99:  jump *label50 always 0 0                                     elsif block == null then
        label *label49                                               ...
  100:  ucontrol flag 1 0 0 0 0                                      flag(1);
  101:  print ": blocked!\n"                                         println(": blocked!");
        label *label50                                               elsif block == null then
        label *label46                                               if floor != floorOre then
        label *label44                                               if @unit.@totalItems >= capacity then
  102:  print "\n"                                                   println();
  103:  jump *label9 always 0 0                                      while true do


Performance: parsed in 214 ms, compiled in 274 ms, optimized in 274 ms, run in 2 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (4 steps):
The program didn't generate any output.
Execution exception at instruction 3: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
