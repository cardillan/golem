   202 instructions before optimizations.
     9 instructions eliminated by Temp Variables Elimination (2 iterations).
    28 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    20 instructions eliminated by Jump Optimization (5 iterations).
    10 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     4 instructions eliminated by If Expression Optimization (3 iterations).
     5 instructions eliminated by Data Flow Optimization (5 iterations).
     1 instructions eliminated by Jump Straightening (5 iterations).
     5 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   110 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-14 instructions):
 
    58 op add .min .min 100
    59 set *tmp18 .min
    60 label *label16
-    * set *tmp5 *tmp18
    61 jump *label10 always
    62 label *label9
-    * set *tmp5 null
    63 label *label10
    64 sensor *tmp19 @unit @flag
    65 set :flag *tmp19
 
    82 label *label22
    83 set *tmp27 null
    84 label *label23
-    * set *tmp24 *tmp27
    85 jump *label21 always
    86 label *label20
-    * set *tmp24 null
    87 label *label21
    88 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
    89 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
   105 print :findOreToMine:y
   106 print "\n"
   107 label *label19
-    * set *tmp21 null
   108 jump *label18 always
   109 label *label17
   110 op equal *tmp36 :flag 1
 
   118 print " (finished)"
   119 print "\n"
   120 ucontrol flag 0
-    * set *tmp40 null
   121 jump *label28 always
   122 label *label27
-    * set *tmp40 null
   123 label *label28
   124 print "\n"
   125 label *label26
 
   165 label *label36
   166 set *tmp53 null
   167 label *label37
-    * set *tmp50 *tmp53
   168 jump *label35 always
   169 label *label34
-    * set *tmp50 null
   170 label *label35
   171 sensor *tmp54 @unit @firstItem
   172 op notEqual *tmp55 *tmp54 :mine:ore
   173 jump *label38 equal *tmp55 false
   174 print " (dropping)"
   175 ucontrol itemDrop @air 20
-    * set *tmp56 null
   176 jump *label39 always
   177 label *label38
-    * set *tmp56 null
   178 label *label39
   179 sensor *tmp57 @unit @totalItems
   180 op greaterThanEq *tmp58 *tmp57 20
 
   182 print ", full"
   183 ucontrol approach .coreX .coreY 7
   184 ucontrol flag 1
-    * set *tmp59 null
   185 jump *label41 always
   186 label *label40
   187 set :mine:floor null
 
   223 label *label47
   224 set *tmp63 *tmp67
   225 label *label43
-    * set *tmp59 *tmp63
   226 label *label41
   227 print "\n"
   228 label *label29
   229 set *tmp37 null
   230 label *label25
-    * set *tmp21 *tmp37
   231 label *label18
   232 label *label7
   233 jump *label6 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-10 instructions):
 
    52 op lessThan *tmp17 .min 10
    53 jump *label15 equal *tmp17 false
    54 set .min -100
-    * set *tmp18 .min
    55 jump *label16 always
    56 label *label15
    57 op add .min .min 100
-    * set *tmp18 .min
    58 label *label16
    59 jump *label10 always
    60 label *label9
 
    75 op notEqual *tmp26 *tmp25 null
    76 jump *label22 equal *tmp26 false
    77 jump *label19 always
-    * set *tmp27 null
    78 jump *label23 always
    79 label *label22
-    * set *tmp27 null
    80 label *label23
    81 jump *label21 always
    82 label *label20
 
   119 label *label28
   120 print "\n"
   121 label *label26
-    * set *tmp37 null
   122 jump *label25 always
   123 label *label24
   124 set :mine:flag :flag
 
   155 print ", switching to a more needed ore"
   156 ucontrol flag 1
   157 jump *label29 always
-    * set *tmp53 null
   158 jump *label37 always
   159 label *label36
-    * set *tmp53 null
   160 label *label37
   161 jump *label35 always
   162 label *label34
 
   200 print "\n"
   201 set *tmp65 ": no ore!"
   202 label *label45
-    * set *tmp63 *tmp65
   203 jump *label43 always
   204 label *label42
   205 op equal *tmp66 :mine:block null
 
   213 print "\n"
   214 set *tmp67 ": blocked!"
   215 label *label47
-    * set *tmp63 *tmp67
   216 label *label43
   217 label *label41
   218 print "\n"
   219 label *label29
-    * set *tmp37 null
   220 label *label25
   221 label *label18
   222 label *label7

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   192 jump *label44 equal *tmp64 false
   193 print ": too far"
   194 print "\n"
-    * set *tmp65 ": too far"
   195 jump *label45 always
   196 label *label44
   197 ucontrol flag 1
   198 print ": no ore!"
   199 print "\n"
-    * set *tmp65 ": no ore!"
   200 label *label45
   201 jump *label43 always
   202 label *label42
   203 op equal *tmp66 :mine:block null
   204 jump *label46 equal *tmp66 false
   205 ucontrol mine :mine:x :mine:y
-    * set *tmp67 null
   206 jump *label47 always
   207 label *label46
   208 ucontrol flag 1
   209 print ": blocked!"
   210 print "\n"
-    * set *tmp67 ": blocked!"
   211 label *label47
   212 label *label43
   213 label *label41

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-9 instructions):
 
     7 label *label2
     8 set :firstItem @unit
     9 label *label3
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   10 ulocate building core false @copper .coreX .coreY 0 .core
    11 label *label4
    12 op equal *tmp3 .core null
    13 jump *label3 notEqual *tmp3 false
 
    19 jump *label9 equal *tmp4 false
    20 printflush message1
    21 sensor *tmp6 .core @lead
-    * op sub *tmp7 *tmp6 .monoLeadTarget
-    * set :lead *tmp7
+   22 op sub :lead *tmp6 .monoLeadTarget
    23 sensor *tmp8 .core @sand
-    * op sub *tmp9 *tmp8 .monoSandTarget
-    * set :sand *tmp9
+   24 op sub :sand *tmp8 .monoSandTarget
    25 sensor *tmp10 .core @copper
-    * op sub *tmp11 *tmp10 .monoCopperTarget
-    * set :copper *tmp11
+   26 op sub :copper *tmp10 .monoCopperTarget
    27 op min *tmp12 :lead :sand
    28 op min *tmp12 *tmp12 :copper
    29 set .min *tmp12
 
    55 jump *label10 always
    56 label *label9
    57 label *label10
-    * sensor *tmp19 @unit @flag
-    * set :flag *tmp19
+   58 sensor :flag @unit @flag
    59 print "Unit flag: "
    60 print :flag
    61 print "\n"
 
    76 jump *label21 always
    77 label *label20
    78 label *label21
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp28 *tmp29
+   79 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
    80 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    81 ucontrol mine :findOreToMine:x :findOreToMine:y
    82 op mul *tmp30 :findOreToMine:x 1000
 
   120 print "Mining"
   121 op idiv :mine:flag :mine:flag 2
   122 op mod *tmp41 :mine:flag 16
-    * lookup item *tmp42 *tmp41
-    * set :mine:ore *tmp42
+  123 lookup item :mine:ore *tmp41
   124 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp43 :mine:flag 1000
-    * set :mine:y *tmp43
-    * op idiv *tmp44 :mine:flag 1000
-    * set :mine:x *tmp44
+  125 op mod :mine:y :mine:flag 1000
+  126 op idiv :mine:x :mine:flag 1000
   127 op equal *tmp45 :mine:ore @copper
   128 jump *label30 equal *tmp45 false
   129 set *tmp46 @ore-copper
 
   176 print " "
   177 print :mine:y
   178 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp61 *tmp60 :mine:floor
-    * set :mine:block *tmp60
+  179 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   180 op notEqual *tmp62 :mine:floor :mine:floorOre
   181 jump *label42 equal *tmp62 false
   182 op equal *tmp64 :mine:floor null

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    13 jump *label3 notEqual *tmp3 false
    14 label *label5
    15 label *label6
-    * jump *label8 equal true false
    16 ubind @mono
    17 op equal *tmp4 @unit :firstItem
    18 jump *label9 equal *tmp4 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-20 instructions):
 
     2 label *label0
     3 ubind @mono
     4 label *label1
-    * op equal *tmp0 @unit null
-    * jump *label0 notEqual *tmp0 false
+    5 jump *label0 equal @unit null
     6 label *label2
     7 set :firstItem @unit
     8 label *label3
     9 ulocate building core false @copper .coreX .coreY 0 .core
    10 label *label4
-    * op equal *tmp3 .core null
-    * jump *label3 notEqual *tmp3 false
+   11 jump *label3 equal .core null
    12 label *label5
    13 label *label6
    14 ubind @mono
-    * op equal *tmp4 @unit :firstItem
-    * jump *label9 equal *tmp4 false
+   15 jump *label9 notEqual @unit :firstItem
    16 printflush message1
    17 sensor *tmp6 .core @lead
    18 op sub :lead *tmp6 .monoLeadTarget
 
    23 op min *tmp12 :lead :sand
    24 op min *tmp12 *tmp12 :copper
    25 set .min *tmp12
-    * op equal *tmp13 .min :sand
-    * jump *label11 equal *tmp13 false
+   26 jump *label11 notEqual .min :sand
    27 set *tmp14 @sand
    28 jump *label12 always
    29 label *label11
-    * op equal *tmp15 .min :lead
-    * jump *label13 equal *tmp15 false
+   30 jump *label13 notEqual .min :lead
    31 set *tmp16 @lead
    32 jump *label14 always
    33 label *label13
 
    39 print "minOre:"
    40 print .minOre
    41 print "\n"
-    * op lessThan *tmp17 .min 10
-    * jump *label15 equal *tmp17 false
+   42 jump *label15 greaterThanEq .min 10
    43 set .min -100
    44 jump *label16 always
    45 label *label15
 
    52 print "Unit flag: "
    53 print :flag
    54 print "\n"
-    * op equal *tmp20 :flag 0
-    * jump *label17 equal *tmp20 false
+   55 jump *label17 notEqual :flag 0
    56 set :findOreToMine:ore .minOre
    57 sensor *tmp22 @unit @firstItem
-    * op notEqual *tmp23 *tmp22 null
-    * jump *label20 equal *tmp23 false
+   58 jump *label20 equal *tmp22 null
    59 ucontrol itemDrop @air 20
    60 sensor *tmp25 @unit @firstItem
-    * op notEqual *tmp26 *tmp25 null
-    * jump *label22 equal *tmp26 false
+   61 jump *label22 equal *tmp25 null
    62 jump *label19 always
    63 jump *label23 always
    64 label *label22
 
    88 label *label19
    89 jump *label18 always
    90 label *label17
-    * op equal *tmp36 :flag 1
-    * jump *label24 equal *tmp36 false
+   91 jump *label24 notEqual :flag 1
    92 print "Returning ore"
    93 ucontrol approach .coreX .coreY 7
    94 ucontrol itemDrop .core 20
    95 sensor *tmp38 @unit @firstItem
-    * op equal *tmp39 *tmp38 null
-    * jump *label27 equal *tmp39 false
+   96 jump *label27 notEqual *tmp38 null
    97 print " (finished)"
    98 print "\n"
    99 ucontrol flag 0
 
   112 op idiv :mine:flag :mine:flag 16
   113 op mod :mine:y :mine:flag 1000
   114 op idiv :mine:x :mine:flag 1000
-    * op equal *tmp45 :mine:ore @copper
-    * jump *label30 equal *tmp45 false
+  115 jump *label30 notEqual :mine:ore @copper
   116 set *tmp46 @ore-copper
   117 jump *label31 always
   118 label *label30
-    * op equal *tmp47 :mine:ore @lead
-    * jump *label32 equal *tmp47 false
+  119 jump *label32 notEqual :mine:ore @lead
   120 set *tmp48 @ore-lead
   121 jump *label33 always
   122 label *label32
 
   125 set *tmp46 *tmp48
   126 label *label31
   127 set :mine:floorOre *tmp46
-    * op notEqual *tmp49 :mine:ore .minOre
-    * jump *label34 equal *tmp49 false
+  128 jump *label34 equal :mine:ore .minOre
   129 sensor *tmp51 .core :mine:ore
-    * op greaterThan *tmp52 *tmp51 .min
-    * jump *label36 equal *tmp52 false
+  130 jump *label36 lessThanEq *tmp51 .min
   131 print ", switching to a more needed ore"
   132 ucontrol flag 1
   133 jump *label29 always
 
   138 label *label34
   139 label *label35
   140 sensor *tmp54 @unit @firstItem
-    * op notEqual *tmp55 *tmp54 :mine:ore
-    * jump *label38 equal *tmp55 false
+  141 jump *label38 equal *tmp54 :mine:ore
   142 print " (dropping)"
   143 ucontrol itemDrop @air 20
   144 jump *label39 always
   145 label *label38
   146 label *label39
   147 sensor *tmp57 @unit @totalItems
-    * op greaterThanEq *tmp58 *tmp57 20
-    * jump *label40 equal *tmp58 false
+  148 jump *label40 lessThan *tmp57 20
   149 print ", full"
   150 ucontrol approach .coreX .coreY 7
   151 ucontrol flag 1
 
   159 print :mine:y
   160 ucontrol approach :mine:x :mine:y 7
   161 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
-    * op notEqual *tmp62 :mine:floor :mine:floorOre
-    * jump *label42 equal *tmp62 false
-    * op equal *tmp64 :mine:floor null
-    * jump *label44 equal *tmp64 false
+  162 jump *label42 equal :mine:floor :mine:floorOre
+  163 jump *label44 notEqual :mine:floor null
   164 print ": too far"
   165 print "\n"
   166 jump *label45 always
 
   171 label *label45
   172 jump *label43 always
   173 label *label42
-    * op equal *tmp66 :mine:block null
-    * jump *label46 equal *tmp66 false
+  174 jump *label46 notEqual :mine:block null
   175 ucontrol mine :mine:x :mine:y
   176 jump *label47 always
   177 label *label46

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    45 label *label15
    46 op add .min .min 100
    47 label *label16
-    * jump *label10 always
    48 label *label9
    49 label *label10
    50 sensor :flag @unit @flag
 
    59 sensor *tmp25 @unit @firstItem
    60 jump *label22 equal *tmp25 null
    61 jump *label19 always
-    * jump *label23 always
    62 label *label22
    63 label *label23
-    * jump *label21 always
    64 label *label20
    65 label *label21
    66 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
 
    94 print " (finished)"
    95 print "\n"
    96 ucontrol flag 0
-    * jump *label28 always
    97 label *label27
    98 label *label28
    99 print "\n"
 
   127 print ", switching to a more needed ore"
   128 ucontrol flag 1
   129 jump *label29 always
-    * jump *label37 always
   130 label *label36
   131 label *label37
-    * jump *label35 always
   132 label *label34
   133 label *label35
   134 sensor *tmp54 @unit @firstItem
   135 jump *label38 equal *tmp54 :mine:ore
   136 print " (dropping)"
   137 ucontrol itemDrop @air 20
-    * jump *label39 always
   138 label *label38
   139 label *label39
   140 sensor *tmp57 @unit @totalItems

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    23 op min *tmp12 :lead :sand
    24 op min *tmp12 *tmp12 :copper
    25 set .min *tmp12
-    * jump *label11 notEqual .min :sand
+   26 jump *label11 notEqual *tmp12 :sand
    27 set *tmp14 @sand
    28 jump *label12 always
    29 label *label11
-    * jump *label13 notEqual .min :lead
+   30 jump *label13 notEqual *tmp12 :lead
    31 set *tmp16 @lead
    32 jump *label14 always
    33 label *label13
 
    37 label *label12
    38 set .minOre *tmp14
    39 print "minOre:"
-    * print .minOre
+   40 print *tmp14
    41 print "\n"
-    * jump *label15 greaterThanEq .min 10
+   42 jump *label15 greaterThanEq *tmp12 10
    43 set .min -100
    44 jump *label16 always
    45 label *label15
-    * op add .min .min 100
+   46 op add .min *tmp12 100
    47 label *label16
    48 label *label9
    49 label *label10
 
    63 label *label23
    64 label *label20
    65 label *label21
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
+   66 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    67 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    68 ucontrol mine :findOreToMine:x :findOreToMine:y
    69 op mul *tmp30 :findOreToMine:x 1000
    70 op add *tmp31 *tmp30 :findOreToMine:y
    71 op mul *tmp32 *tmp31 32
-    * sensor *tmp33 :findOreToMine:ore @id
+   72 sensor *tmp33 .minOre @id
    73 op mul *tmp34 *tmp33 2
    74 op add *tmp35 *tmp32 *tmp34
    75 ucontrol flag *tmp35
    76 print "Found "
-    * print :findOreToMine:ore
+   77 print .minOre
    78 print " "
    79 print "at "
    80 print :findOreToMine:x
 
   102 label *label24
   103 set :mine:flag :flag
   104 print "Mining"
-    * op idiv :mine:flag :mine:flag 2
+  105 op idiv :mine:flag :flag 2
   106 op mod *tmp41 :mine:flag 16
   107 lookup item :mine:ore *tmp41
   108 op idiv :mine:flag :mine:flag 16
 
   144 ucontrol flag 1
   145 jump *label41 always
   146 label *label40
-    * set :mine:floor null
   147 print " at "
   148 print :mine:x
   149 print ","
 
   151 print :mine:y
   152 ucontrol approach :mine:x :mine:y 7
   153 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
-    * jump *label42 equal :mine:floor :mine:floorOre
+  154 jump *label42 equal :mine:floor *tmp46
   155 jump *label44 notEqual :mine:floor null
   156 print ": too far"
   157 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    22 op sub :copper *tmp10 .monoCopperTarget
    23 op min *tmp12 :lead :sand
    24 op min *tmp12 *tmp12 :copper
-    * set .min *tmp12
    25 jump *label11 notEqual *tmp12 :sand
    26 set *tmp14 @sand
    27 jump *label12 always
 
    51 print :flag
    52 print "\n"
    53 jump *label17 notEqual :flag 0
-    * set :findOreToMine:ore .minOre
    54 sensor *tmp22 @unit @firstItem
    55 jump *label20 equal *tmp22 null
    56 ucontrol itemDrop @air 20
 
    98 label *label26
    99 jump *label25 always
   100 label *label24
-    * set :mine:flag :flag
   101 print "Mining"
   102 op idiv :mine:flag :flag 2
   103 op mod *tmp41 :mine:flag 16
 
   117 label *label33
   118 set *tmp46 *tmp48
   119 label *label31
-    * set :mine:floorOre *tmp46
   120 jump *label34 equal :mine:ore .minOre
   121 sensor *tmp51 .core :mine:ore
   122 jump *label36 lessThanEq *tmp51 .min

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-4 instructions):
 
    22 op sub :copper *tmp10 .monoCopperTarget
    23 op min *tmp12 :lead :sand
    24 op min *tmp12 *tmp12 :copper
-    * jump *label11 notEqual *tmp12 :sand
    25 set *tmp14 @sand
-    * jump *label12 always
+   26 jump *label12 equal *tmp12 :sand
    27 label *label11
-    * jump *label13 notEqual *tmp12 :lead
-    * set *tmp16 @lead
+   28 set *tmp14 @copper
+   29 jump *label14 notEqual *tmp12 :lead
+   30 set *tmp14 @lead
    31 jump *label14 always
-    * label *label13
-    * set *tmp16 @copper
    32 label *label14
-    * set *tmp14 *tmp16
    33 label *label12
    34 set .minOre *tmp14
    35 print "minOre:"
    36 print *tmp14
    37 print "\n"
-    * jump *label15 greaterThanEq *tmp12 10
+   38 op add .min *tmp12 100
+   39 jump *label16 greaterThanEq *tmp12 10
    40 set .min -100
    41 jump *label16 always
-    * label *label15
-    * op add .min *tmp12 100
    42 label *label16
    43 label *label9
    44 label *label10
 
   101 op idiv :mine:flag :mine:flag 16
   102 op mod :mine:y :mine:flag 1000
   103 op idiv :mine:x :mine:flag 1000
-    * jump *label30 notEqual :mine:ore @copper
   104 set *tmp46 @ore-copper
-    * jump *label31 always
+  105 jump *label31 equal :mine:ore @copper
   106 label *label30
-    * jump *label32 notEqual :mine:ore @lead
-    * set *tmp48 @ore-lead
+  107 set *tmp46 @sand-floor
+  108 jump *label33 notEqual :mine:ore @lead
+  109 set *tmp46 @ore-lead
   110 jump *label33 always
-    * label *label32
-    * set *tmp48 @sand-floor
   111 label *label33
-    * set *tmp46 *tmp48
   112 label *label31
   113 jump *label34 equal :mine:ore .minOre
   114 sensor *tmp51 .core :mine:ore

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
    28 set *tmp14 @copper
    29 jump *label14 notEqual *tmp12 :lead
    30 set *tmp14 @lead
-    * jump *label14 always
    31 label *label14
    32 label *label12
    33 set .minOre *tmp14
 
    37 op add .min *tmp12 100
    38 jump *label16 greaterThanEq *tmp12 10
    39 set .min -100
-    * jump *label16 always
    40 label *label16
    41 label *label9
    42 label *label10
 
   105 set *tmp46 @sand-floor
   106 jump *label33 notEqual :mine:ore @lead
   107 set *tmp46 @ore-lead
-    * jump *label33 always
   108 label *label33
   109 label *label31
   110 jump *label34 equal :mine:ore .minOre

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     1 set .minOre null
     2 label *label0
     3 ubind @mono
-    * label *label1
     4 jump *label0 equal @unit null
-    * label *label2
     5 set :firstItem @unit
     6 label *label3
     7 ulocate building core false @copper .coreX .coreY 0 .core
-    * label *label4
     8 jump *label3 equal .core null
-    * label *label5
     9 label *label6
    10 ubind @mono
    11 jump *label9 notEqual @unit :firstItem
 
    20 op min *tmp12 *tmp12 :copper
    21 set *tmp14 @sand
    22 jump *label12 equal *tmp12 :sand
-    * label *label11
    23 set *tmp14 @copper
    24 jump *label14 notEqual *tmp12 :lead
    25 set *tmp14 @lead
 
    34 set .min -100
    35 label *label16
    36 label *label9
-    * label *label10
    37 sensor :flag @unit @flag
    38 print "Unit flag: "
    39 print :flag
 
    46 jump *label22 equal *tmp25 null
    47 jump *label19 always
    48 label *label22
-    * label *label23
    49 label *label20
-    * label *label21
    50 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    51 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    52 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    79 print "\n"
    80 ucontrol flag 0
    81 label *label27
-    * label *label28
    82 print "\n"
-    * label *label26
    83 jump *label25 always
    84 label *label24
    85 print "Mining"
 
    91 op idiv :mine:x :mine:flag 1000
    92 set *tmp46 @ore-copper
    93 jump *label31 equal :mine:ore @copper
-    * label *label30
    94 set *tmp46 @sand-floor
    95 jump *label33 notEqual :mine:ore @lead
    96 set *tmp46 @ore-lead
 
   103 ucontrol flag 1
   104 jump *label29 always
   105 label *label36
-    * label *label37
   106 label *label34
-    * label *label35
   107 sensor *tmp54 @unit @firstItem
   108 jump *label38 equal *tmp54 :mine:ore
   109 print " (dropping)"
   110 ucontrol itemDrop @air 20
   111 label *label38
-    * label *label39
   112 sensor *tmp57 @unit @totalItems
   113 jump *label40 lessThan *tmp57 20
   114 print ", full"
 
   149 label *label29
   150 label *label25
   151 label *label18
-    * label *label7
   152 jump *label6 always
-    * label *label8
   153 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    43 jump *label20 equal *tmp22 null
    44 ucontrol itemDrop @air 20
    45 sensor *tmp25 @unit @firstItem
-    * jump *label22 equal *tmp25 null
-    * jump *label19 always
+   46 jump *label19 notEqual *tmp25 null
    47 label *label22
    48 label *label20
    49 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    44 ucontrol itemDrop @air 20
    45 sensor *tmp25 @unit @firstItem
    46 jump *label19 notEqual *tmp25 null
-    * label *label22
    47 label *label20
    48 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    49 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    43 jump *label20 equal *tmp22 null
    44 ucontrol itemDrop @air 20
    45 sensor *tmp25 @unit @firstItem
-    * jump *label19 notEqual *tmp25 null
+   46 jump *label6 notEqual *tmp25 null
    47 label *label20
    48 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    49 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    65 print :findOreToMine:y
    66 print "\n"
    67 label *label19
-    * jump *label18 always
+   68 jump *label6 always
    69 label *label17
    70 jump *label24 notEqual :flag 1
    71 print "Returning ore"
 
    78 ucontrol flag 0
    79 label *label27
    80 print "\n"
-    * jump *label25 always
+   81 jump *label6 always
    82 label *label24
    83 print "Mining"
    84 op idiv :mine:flag :flag 2
 
    99 jump *label36 lessThanEq *tmp51 .min
   100 print ", switching to a more needed ore"
   101 ucontrol flag 1
-    * jump *label29 always
+  102 jump *label6 always
   103 label *label36
   104 label *label34
   105 sensor *tmp54 @unit @firstItem
 
   125 jump *label44 notEqual :mine:floor null
   126 print ": too far"
   127 print "\n"
-    * jump *label45 always
+  128 jump *label43 always
   129 label *label44
   130 ucontrol flag 1
   131 print ": no ore!"

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-1 instructions):
 
    64 print " "
    65 print :findOreToMine:y
    66 print "\n"
-    * label *label19
    67 jump *label6 always
    68 label *label17
    69 jump *label24 notEqual :flag 1
 
   129 ucontrol flag 1
   130 print ": no ore!"
   131 print "\n"
-    * label *label45
   132 jump *label43 always
   133 label *label42
   134 jump *label46 notEqual :mine:block null
 
   142 label *label43
   143 label *label41
   144 print "\n"
-    * label *label29
-    * label *label25
-    * label *label18
   145 jump *label6 always
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    26 label *label14
    27 label *label12
    28 set .minOre *tmp14
-    * print "minOre:"
-    * print *tmp14
-    * print "\n"
+   29 print "minOre:{0}\n"
+   30 format *tmp14
    31 op add .min *tmp12 100
    32 jump *label16 greaterThanEq *tmp12 10
    33 set .min -100
    34 label *label16
    35 label *label9
    36 sensor :flag @unit @flag
-    * print "Unit flag: "
-    * print :flag
-    * print "\n"
+   37 print "Unit flag: {0}\n"
+   38 format :flag
    39 jump *label17 notEqual :flag 0
    40 sensor *tmp22 @unit @firstItem
    41 jump *label20 equal *tmp22 null
 
    53 op mul *tmp34 *tmp33 2
    54 op add *tmp35 *tmp32 *tmp34
    55 ucontrol flag *tmp35
-    * print "Found "
-    * print .minOre
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   56 print "Found {0} at {0}, {0}\n"
+   57 format .minOre
+   58 format :findOreToMine:x
+   59 format :findOreToMine:y
    60 jump *label6 always
    61 label *label17
    62 jump *label24 notEqual :flag 1
 
    65 ucontrol itemDrop .core 20
    66 sensor *tmp38 @unit @firstItem
    67 jump *label27 notEqual *tmp38 null
-    * print " (finished)"
-    * print "\n"
+   68 print " (finished)\n"
    69 ucontrol flag 0
    70 label *label27
    71 print "\n"
 
   105 ucontrol flag 1
   106 jump *label41 always
   107 label *label40
-    * print " at "
-    * print :mine:x
-    * print ","
-    * print " "
+  108 print " at {0}, "
+  109 format :mine:x
   110 print :mine:y
   111 ucontrol approach :mine:x :mine:y 7
   112 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   113 jump *label42 equal :mine:floor *tmp46
   114 jump *label44 notEqual :mine:floor null
-    * print ": too far"
-    * print "\n"
+  115 print ": too far\n"
   116 jump *label43 always
   117 label *label44
   118 ucontrol flag 1
-    * print ": no ore!"
-    * print "\n"
+  119 print ": no ore!\n"
   120 jump *label43 always
   121 label *label42
   122 jump *label46 notEqual :mine:block null
 
   124 jump *label47 always
   125 label *label46
   126 ucontrol flag 1
-    * print ": blocked!"
-    * print "\n"
+  127 print ": blocked!\n"
   128 label *label47
   129 label *label43
   130 label *label41

Final code before resolving virtual instructions:

    0:  set .min 0                                                   var min = 0, minOre = null;
    1:  set .minOre null                                             ...
        label *label0                                                do
    2:  ubind @mono                                                  ubind(@mono);
    3:  jump *label0 equal @unit null                                do
    4:  set :firstItem @unit                                         var firstItem = @unit;
        label *label3                                                do
    5:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
    6:  jump *label3 equal .core null                                do
        label *label6                                                while true do
    7:  ubind @mono                                                  ubind(@mono);
    8:  jump *label9 notEqual @unit :firstItem                       if @unit == firstItem then
    9:  printflush message1                                          printflush(message1);
   10:  sensor *tmp6 .core @lead                                     var lead = core.@lead - monoLeadTarget;
   11:  op sub :lead *tmp6 .monoLeadTarget                           ...
   12:  sensor *tmp8 .core @sand                                     var sand = core.@sand - monoSandTarget;
   13:  op sub :sand *tmp8 .monoSandTarget                           ...
   14:  sensor *tmp10 .core @copper                                  var copper = core.@copper - monoCopperTarget;
   15:  op sub :copper *tmp10 .monoCopperTarget                      ...
   16:  op min *tmp12 :lead :sand                                    min = min(lead, sand, copper);
   17:  op min *tmp12 *tmp12 :copper                                 ...
   18:  set *tmp14 @sand                                             minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   19:  jump *label12 equal *tmp12 :sand                             ...
   20:  set *tmp14 @copper                                           ...
   21:  jump *label14 notEqual *tmp12 :lead                          ...
   22:  set *tmp14 @lead                                             ...
        label *label14                                               ...
        label *label12                                               ...
   23:  set .minOre *tmp14                                           ...
   24:  print "minOre:{0}\n"                                         println("minOre:", minOre);
   25:  format *tmp14                                                ...
   26:  op add .min *tmp12 100                                       if min < 10 then min = -100; else min += 100; end;
   27:  jump *label16 greaterThanEq *tmp12 10                        ...
   28:  set .min -100                                                ...
        label *label16                                               ...
        label *label9                                                if @unit == firstItem then
   29:  sensor :flag @unit @flag                                     var flag = @unit.@flag;
   30:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   31:  format :flag                                                 ...
   32:  jump *label17 notEqual :flag 0                               if flag == 0 then
   33:  sensor *tmp22 @unit @firstItem                               if @unit.@firstItem != null then
   34:  jump *label20 equal *tmp22 null                              ...
   35:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   36:  sensor *tmp25 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   37:  jump *label6 notEqual *tmp25 null                            ...
        label *label20                                               if @unit.@firstItem != null then
   38:  ulocate ore core true .minOre :findOreToMine:x :findOreToMin ulocate(:ore, ore, out x, out y);
   39:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   40:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   41:  op mul *tmp30 :findOreToMine:x 1000                          flag((x * 1000 + y) * 32 + ore.@id * 2);
   42:  op add *tmp31 *tmp30 :findOreToMine:y                        ...
   43:  op mul *tmp32 *tmp31 32                                      ...
   44:  sensor *tmp33 .minOre @id                                    ...
   45:  op mul *tmp34 *tmp33 2                                       ...
   46:  op add *tmp35 *tmp32 *tmp34                                  ...
   47:  ucontrol flag *tmp35 0 0 0 0                                 ...
   48:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   49:  format .minOre                                               ...
   50:  format :findOreToMine:x                                      ...
   51:  format :findOreToMine:y                                      ...
   52:  jump *label6 always 0 0                                      if flag == 0 then
        label *label17                                               ...
   53:  jump *label24 notEqual :flag 1                               elsif flag == 1 then
   54:  print "Returning ore"                                        print("Returning ore");
   55:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   56:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
   57:  sensor *tmp38 @unit @firstItem                               if @unit.@firstItem == null then
   58:  jump *label27 notEqual *tmp38 null                           ...
   59:  print " (finished)\n"                                        println(" (finished)");
   60:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label27                                               if @unit.@firstItem == null then
   61:  print "\n"                                                   println();
   62:  jump *label6 always 0 0                                      elsif flag == 1 then
        label *label24                                               ...
   63:  print "Mining"                                               print("Mining");
   64:  op idiv :mine:flag :flag 2                                   flag \= 2;
   65:  op mod *tmp41 :mine:flag 16                                  var ore = lookup(:item, flag % 16);
   66:  lookup item :mine:ore *tmp41                                 ...
   67:  op idiv :mine:flag :mine:flag 16                             flag \= 16;
   68:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   69:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   70:  set *tmp46 @ore-copper                                       ore == @copper ? @ore-copper :
   71:  jump *label31 equal :mine:ore @copper                        ...
   72:  set *tmp46 @sand-floor                                       ore == @lead ? @ore-lead :
   73:  jump *label33 notEqual :mine:ore @lead                       ...
   74:  set *tmp46 @ore-lead                                         ...
        label *label33                                               ...
        label *label31                                               ore == @copper ? @ore-copper :
   75:  jump *label34 equal :mine:ore .minOre                        if ore != minOre then
   76:  sensor *tmp51 .core :mine:ore                                if core.sensor(ore) > min then
   77:  jump *label36 lessThanEq *tmp51 .min                         ...
   78:  print ", switching to a more needed ore"                     print(", switching to a more needed ore");
   79:  ucontrol flag 1 0 0 0 0                                      flag(1);
   80:  jump *label6 always 0 0                                      return;
        label *label36                                               if core.sensor(ore) > min then
        label *label34                                               if ore != minOre then
   81:  sensor *tmp54 @unit @firstItem                               if @unit.@firstItem != ore then
   82:  jump *label38 equal *tmp54 :mine:ore                         ...
   83:  print " (dropping)"                                          print(" (dropping)");
   84:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label38                                               if @unit.@firstItem != ore then
   85:  sensor *tmp57 @unit @totalItems                              if @unit.@totalItems >= capacity then
   86:  jump *label40 lessThan *tmp57 20                             ...
   87:  print ", full"                                               print(", full");
   88:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   89:  ucontrol flag 1 0 0 0 0                                      flag(1);
   90:  jump *label41 always 0 0                                     if @unit.@totalItems >= capacity then
        label *label40                                               ...
   91:  print " at {0}, "                                            print($" at $x, $y");
   92:  format :mine:x                                               ...
   93:  print :mine:y                                                ...
   94:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
   95:  ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor  var block = getBlock(x, y, , out floor);
   96:  jump *label42 equal :mine:floor *tmp46                       if floor != floorOre then
   97:  jump *label44 notEqual :mine:floor null                      if floor == null then
   98:  print ": too far\n"                                          println(": too far");
   99:  jump *label43 always 0 0                                     if floor == null then
        label *label44                                               ...
  100:  ucontrol flag 1 0 0 0 0                                      flag(1);
  101:  print ": no ore!\n"                                          println(": no ore!");
  102:  jump *label43 always 0 0                                     if floor != floorOre then
        label *label42                                               ...
  103:  jump *label46 notEqual :mine:block null                      elsif block == null then
  104:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
  105:  jump *label47 always 0 0                                     elsif block == null then
        label *label46                                               ...
  106:  ucontrol flag 1 0 0 0 0                                      flag(1);
  107:  print ": blocked!\n"                                         println(": blocked!");
        label *label47                                               elsif block == null then
        label *label43                                               if floor != floorOre then
        label *label41                                               if @unit.@totalItems >= capacity then
  108:  print "\n"                                                   println();
  109:  jump *label6 always 0 0                                      while true do


Performance: parsed in 288 ms, compiled in 362 ms, optimized in 260 ms, run in 6 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (3 steps):
The program didn't generate any output.
Execution exception at instruction 2: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
