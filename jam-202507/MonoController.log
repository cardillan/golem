   199 instructions before optimizations.
     9 instructions eliminated by Temp Variables Elimination (2 iterations).
    28 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    20 instructions eliminated by Jump Optimization (5 iterations).
    10 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     4 instructions eliminated by If Expression Optimization (3 iterations).
     5 instructions eliminated by Data Flow Optimization (5 iterations).
     1 instructions eliminated by Jump Straightening (5 iterations).
     5 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    13 instructions eliminated by Print Merging.
   107 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-14 instructions):
 
    55 op add .min .min 100
    56 set *tmp15 .min
    57 label *label16
-    * set *tmp5 *tmp15
    58 jump *label10 always
    59 label *label9
-    * set *tmp5 null
    60 label *label10
    61 sensor *tmp16 @unit @flag
    62 set :flag *tmp16
 
    79 label *label22
    80 set *tmp24 null
    81 label *label23
-    * set *tmp21 *tmp24
    82 jump *label21 always
    83 label *label20
-    * set *tmp21 null
    84 label *label21
    85 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp25 *tmp26
    86 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
   102 print :findOreToMine:y
   103 print "\n"
   104 label *label19
-    * set *tmp18 null
   105 jump *label18 always
   106 label *label17
   107 op equal *tmp33 :flag 1
 
   115 print " (finished)"
   116 print "\n"
   117 ucontrol flag 0
-    * set *tmp37 null
   118 jump *label28 always
   119 label *label27
-    * set *tmp37 null
   120 label *label28
   121 print "\n"
   122 label *label26
 
   162 label *label36
   163 set *tmp50 null
   164 label *label37
-    * set *tmp47 *tmp50
   165 jump *label35 always
   166 label *label34
-    * set *tmp47 null
   167 label *label35
   168 sensor *tmp51 @unit @firstItem
   169 op notEqual *tmp52 *tmp51 :mine:ore
   170 jump *label38 equal *tmp52 false
   171 print " (dropping)"
   172 ucontrol itemDrop @air 20
-    * set *tmp53 null
   173 jump *label39 always
   174 label *label38
-    * set *tmp53 null
   175 label *label39
   176 sensor *tmp54 @unit @totalItems
   177 op greaterThanEq *tmp55 *tmp54 20
 
   179 print ", full"
   180 ucontrol approach .coreX .coreY 7
   181 ucontrol flag 1
-    * set *tmp56 null
   182 jump *label41 always
   183 label *label40
   184 set :mine:floor null
 
   220 label *label47
   221 set *tmp60 *tmp64
   222 label *label43
-    * set *tmp56 *tmp60
   223 label *label41
   224 print "\n"
   225 label *label29
   226 set *tmp34 null
   227 label *label25
-    * set *tmp18 *tmp34
   228 label *label18
   229 label *label7
   230 jump *label6 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-10 instructions):
 
    49 op lessThan *tmp14 .min 10
    50 jump *label15 equal *tmp14 false
    51 set .min -100
-    * set *tmp15 .min
    52 jump *label16 always
    53 label *label15
    54 op add .min .min 100
-    * set *tmp15 .min
    55 label *label16
    56 jump *label10 always
    57 label *label9
 
    72 op notEqual *tmp23 *tmp22 null
    73 jump *label22 equal *tmp23 false
    74 jump *label19 always
-    * set *tmp24 null
    75 jump *label23 always
    76 label *label22
-    * set *tmp24 null
    77 label *label23
    78 jump *label21 always
    79 label *label20
 
   116 label *label28
   117 print "\n"
   118 label *label26
-    * set *tmp34 null
   119 jump *label25 always
   120 label *label24
   121 set :mine:flag :flag
 
   152 print ", switching to a more needed ore"
   153 ucontrol flag 1
   154 jump *label29 always
-    * set *tmp50 null
   155 jump *label37 always
   156 label *label36
-    * set *tmp50 null
   157 label *label37
   158 jump *label35 always
   159 label *label34
 
   197 print "\n"
   198 set *tmp62 ": no ore!"
   199 label *label45
-    * set *tmp60 *tmp62
   200 jump *label43 always
   201 label *label42
   202 op equal *tmp63 :mine:block null
 
   210 print "\n"
   211 set *tmp64 ": blocked!"
   212 label *label47
-    * set *tmp60 *tmp64
   213 label *label43
   214 label *label41
   215 print "\n"
   216 label *label29
-    * set *tmp34 null
   217 label *label25
   218 label *label18
   219 label *label7

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   189 jump *label44 equal *tmp61 false
   190 print ": too far"
   191 print "\n"
-    * set *tmp62 ": too far"
   192 jump *label45 always
   193 label *label44
   194 ucontrol flag 1
   195 print ": no ore!"
   196 print "\n"
-    * set *tmp62 ": no ore!"
   197 label *label45
   198 jump *label43 always
   199 label *label42
   200 op equal *tmp63 :mine:block null
   201 jump *label46 equal *tmp63 false
   202 ucontrol mine :mine:x :mine:y
-    * set *tmp64 null
   203 jump *label47 always
   204 label *label46
   205 ucontrol flag 1
   206 print ": blocked!"
   207 print "\n"
-    * set *tmp64 ": blocked!"
   208 label *label47
   209 label *label43
   210 label *label41

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-9 instructions):
 
     7 label *label2
     8 set :firstItem @unit
     9 label *label3
-    * ulocate building core false @copper .coreX .coreY *tmp2 *tmp1
-    * set .core *tmp1
+   10 ulocate building core false @copper .coreX .coreY 0 .core
    11 label *label4
    12 op equal *tmp3 .core null
    13 jump *label3 notEqual *tmp3 false
 
    18 op equal *tmp4 @unit :firstItem
    19 jump *label9 equal *tmp4 false
    20 printflush message1
-    * sensor *tmp6 .core @lead
-    * set :lead *tmp6
-    * sensor *tmp7 .core @sand
-    * set :sand *tmp7
-    * sensor *tmp8 .core @copper
-    * set :copper *tmp8
+   21 sensor :lead .core @lead
+   22 sensor :sand .core @sand
+   23 sensor :copper .core @copper
    24 op min *tmp9 :lead :sand
    25 op min *tmp9 *tmp9 :copper
    26 set .min *tmp9
 
    52 jump *label10 always
    53 label *label9
    54 label *label10
-    * sensor *tmp16 @unit @flag
-    * set :flag *tmp16
+   55 sensor :flag @unit @flag
    56 print "Unit flag: "
    57 print :flag
    58 print "\n"
 
    73 jump *label21 always
    74 label *label20
    75 label *label21
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y *tmp25 *tmp26
+   76 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
    77 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    78 ucontrol mine :findOreToMine:x :findOreToMine:y
    79 op mul *tmp27 :findOreToMine:x 1000
 
   117 print "Mining"
   118 op idiv :mine:flag :mine:flag 2
   119 op mod *tmp38 :mine:flag 16
-    * lookup item *tmp39 *tmp38
-    * set :mine:ore *tmp39
+  120 lookup item :mine:ore *tmp38
   121 op idiv :mine:flag :mine:flag 16
-    * op mod *tmp40 :mine:flag 1000
-    * set :mine:y *tmp40
-    * op idiv *tmp41 :mine:flag 1000
-    * set :mine:x *tmp41
+  122 op mod :mine:y :mine:flag 1000
+  123 op idiv :mine:x :mine:flag 1000
   124 op equal *tmp42 :mine:ore @copper
   125 jump *label30 equal *tmp42 false
   126 set *tmp43 @ore-copper
 
   173 print " "
   174 print :mine:y
   175 ucontrol approach :mine:x :mine:y 7
-    * ucontrol getBlock :mine:x :mine:y *tmp58 *tmp57 :mine:floor
-    * set :mine:block *tmp57
+  176 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   177 op notEqual *tmp59 :mine:floor :mine:floorOre
   178 jump *label42 equal *tmp59 false
   179 op equal *tmp61 :mine:floor null

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    13 jump *label3 notEqual *tmp3 false
    14 label *label5
    15 label *label6
-    * jump *label8 equal true false
    16 ubind @mono
    17 op equal *tmp4 @unit :firstItem
    18 jump *label9 equal *tmp4 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-20 instructions):
 
     2 label *label0
     3 ubind @mono
     4 label *label1
-    * op equal *tmp0 @unit null
-    * jump *label0 notEqual *tmp0 false
+    5 jump *label0 equal @unit null
     6 label *label2
     7 set :firstItem @unit
     8 label *label3
     9 ulocate building core false @copper .coreX .coreY 0 .core
    10 label *label4
-    * op equal *tmp3 .core null
-    * jump *label3 notEqual *tmp3 false
+   11 jump *label3 equal .core null
    12 label *label5
    13 label *label6
    14 ubind @mono
-    * op equal *tmp4 @unit :firstItem
-    * jump *label9 equal *tmp4 false
+   15 jump *label9 notEqual @unit :firstItem
    16 printflush message1
    17 sensor :lead .core @lead
    18 sensor :sand .core @sand
 
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
    22 set .min *tmp9
-    * op equal *tmp10 .min :sand
-    * jump *label11 equal *tmp10 false
+   23 jump *label11 notEqual .min :sand
    24 set *tmp11 @sand
    25 jump *label12 always
    26 label *label11
-    * op equal *tmp12 .min :lead
-    * jump *label13 equal *tmp12 false
+   27 jump *label13 notEqual .min :lead
    28 set *tmp13 @lead
    29 jump *label14 always
    30 label *label13
 
    36 print "minOre:"
    37 print .minOre
    38 print "\n"
-    * op lessThan *tmp14 .min 10
-    * jump *label15 equal *tmp14 false
+   39 jump *label15 greaterThanEq .min 10
    40 set .min -100
    41 jump *label16 always
    42 label *label15
 
    49 print "Unit flag: "
    50 print :flag
    51 print "\n"
-    * op equal *tmp17 :flag 0
-    * jump *label17 equal *tmp17 false
+   52 jump *label17 notEqual :flag 0
    53 set :findOreToMine:ore .minOre
    54 sensor *tmp19 @unit @firstItem
-    * op notEqual *tmp20 *tmp19 null
-    * jump *label20 equal *tmp20 false
+   55 jump *label20 equal *tmp19 null
    56 ucontrol itemDrop @air 20
    57 sensor *tmp22 @unit @firstItem
-    * op notEqual *tmp23 *tmp22 null
-    * jump *label22 equal *tmp23 false
+   58 jump *label22 equal *tmp22 null
    59 jump *label19 always
    60 jump *label23 always
    61 label *label22
 
    85 label *label19
    86 jump *label18 always
    87 label *label17
-    * op equal *tmp33 :flag 1
-    * jump *label24 equal *tmp33 false
+   88 jump *label24 notEqual :flag 1
    89 print "Returning ore"
    90 ucontrol approach .coreX .coreY 7
    91 ucontrol itemDrop .core 20
    92 sensor *tmp35 @unit @firstItem
-    * op equal *tmp36 *tmp35 null
-    * jump *label27 equal *tmp36 false
+   93 jump *label27 notEqual *tmp35 null
    94 print " (finished)"
    95 print "\n"
    96 ucontrol flag 0
 
   109 op idiv :mine:flag :mine:flag 16
   110 op mod :mine:y :mine:flag 1000
   111 op idiv :mine:x :mine:flag 1000
-    * op equal *tmp42 :mine:ore @copper
-    * jump *label30 equal *tmp42 false
+  112 jump *label30 notEqual :mine:ore @copper
   113 set *tmp43 @ore-copper
   114 jump *label31 always
   115 label *label30
-    * op equal *tmp44 :mine:ore @lead
-    * jump *label32 equal *tmp44 false
+  116 jump *label32 notEqual :mine:ore @lead
   117 set *tmp45 @ore-lead
   118 jump *label33 always
   119 label *label32
 
   122 set *tmp43 *tmp45
   123 label *label31
   124 set :mine:floorOre *tmp43
-    * op notEqual *tmp46 :mine:ore .minOre
-    * jump *label34 equal *tmp46 false
+  125 jump *label34 equal :mine:ore .minOre
   126 sensor *tmp48 .core :mine:ore
-    * op greaterThan *tmp49 *tmp48 .min
-    * jump *label36 equal *tmp49 false
+  127 jump *label36 lessThanEq *tmp48 .min
   128 print ", switching to a more needed ore"
   129 ucontrol flag 1
   130 jump *label29 always
 
   135 label *label34
   136 label *label35
   137 sensor *tmp51 @unit @firstItem
-    * op notEqual *tmp52 *tmp51 :mine:ore
-    * jump *label38 equal *tmp52 false
+  138 jump *label38 equal *tmp51 :mine:ore
   139 print " (dropping)"
   140 ucontrol itemDrop @air 20
   141 jump *label39 always
   142 label *label38
   143 label *label39
   144 sensor *tmp54 @unit @totalItems
-    * op greaterThanEq *tmp55 *tmp54 20
-    * jump *label40 equal *tmp55 false
+  145 jump *label40 lessThan *tmp54 20
   146 print ", full"
   147 ucontrol approach .coreX .coreY 7
   148 ucontrol flag 1
 
   156 print :mine:y
   157 ucontrol approach :mine:x :mine:y 7
   158 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
-    * op notEqual *tmp59 :mine:floor :mine:floorOre
-    * jump *label42 equal *tmp59 false
-    * op equal *tmp61 :mine:floor null
-    * jump *label44 equal *tmp61 false
+  159 jump *label42 equal :mine:floor :mine:floorOre
+  160 jump *label44 notEqual :mine:floor null
   161 print ": too far"
   162 print "\n"
   163 jump *label45 always
 
   168 label *label45
   169 jump *label43 always
   170 label *label42
-    * op equal *tmp63 :mine:block null
-    * jump *label46 equal *tmp63 false
+  171 jump *label46 notEqual :mine:block null
   172 ucontrol mine :mine:x :mine:y
   173 jump *label47 always
   174 label *label46

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    42 label *label15
    43 op add .min .min 100
    44 label *label16
-    * jump *label10 always
    45 label *label9
    46 label *label10
    47 sensor :flag @unit @flag
 
    56 sensor *tmp22 @unit @firstItem
    57 jump *label22 equal *tmp22 null
    58 jump *label19 always
-    * jump *label23 always
    59 label *label22
    60 label *label23
-    * jump *label21 always
    61 label *label20
    62 label *label21
    63 ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
 
    91 print " (finished)"
    92 print "\n"
    93 ucontrol flag 0
-    * jump *label28 always
    94 label *label27
    95 label *label28
    96 print "\n"
 
   124 print ", switching to a more needed ore"
   125 ucontrol flag 1
   126 jump *label29 always
-    * jump *label37 always
   127 label *label36
   128 label *label37
-    * jump *label35 always
   129 label *label34
   130 label *label35
   131 sensor *tmp51 @unit @firstItem
   132 jump *label38 equal *tmp51 :mine:ore
   133 print " (dropping)"
   134 ucontrol itemDrop @air 20
-    * jump *label39 always
   135 label *label38
   136 label *label39
   137 sensor *tmp54 @unit @totalItems

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
    22 set .min *tmp9
-    * jump *label11 notEqual .min :sand
+   23 jump *label11 notEqual *tmp9 :sand
    24 set *tmp11 @sand
    25 jump *label12 always
    26 label *label11
-    * jump *label13 notEqual .min :lead
+   27 jump *label13 notEqual *tmp9 :lead
    28 set *tmp13 @lead
    29 jump *label14 always
    30 label *label13
 
    34 label *label12
    35 set .minOre *tmp11
    36 print "minOre:"
-    * print .minOre
+   37 print *tmp11
    38 print "\n"
-    * jump *label15 greaterThanEq .min 10
+   39 jump *label15 greaterThanEq *tmp9 10
    40 set .min -100
    41 jump *label16 always
    42 label *label15
-    * op add .min .min 100
+   43 op add .min *tmp9 100
    44 label *label16
    45 label *label9
    46 label *label10
 
    60 label *label23
    61 label *label20
    62 label *label21
-    * ulocate ore core true :findOreToMine:ore :findOreToMine:x :findOreToMine:y 0 0
+   63 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    64 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    65 ucontrol mine :findOreToMine:x :findOreToMine:y
    66 op mul *tmp27 :findOreToMine:x 1000
    67 op add *tmp28 *tmp27 :findOreToMine:y
    68 op mul *tmp29 *tmp28 32
-    * sensor *tmp30 :findOreToMine:ore @id
+   69 sensor *tmp30 .minOre @id
    70 op mul *tmp31 *tmp30 2
    71 op add *tmp32 *tmp29 *tmp31
    72 ucontrol flag *tmp32
    73 print "Found "
-    * print :findOreToMine:ore
+   74 print .minOre
    75 print " "
    76 print "at "
    77 print :findOreToMine:x
 
    99 label *label24
   100 set :mine:flag :flag
   101 print "Mining"
-    * op idiv :mine:flag :mine:flag 2
+  102 op idiv :mine:flag :flag 2
   103 op mod *tmp38 :mine:flag 16
   104 lookup item :mine:ore *tmp38
   105 op idiv :mine:flag :mine:flag 16
 
   141 ucontrol flag 1
   142 jump *label41 always
   143 label *label40
-    * set :mine:floor null
   144 print " at "
   145 print :mine:x
   146 print ","
 
   148 print :mine:y
   149 ucontrol approach :mine:x :mine:y 7
   150 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
-    * jump *label42 equal :mine:floor :mine:floorOre
+  151 jump *label42 equal :mine:floor *tmp43
   152 jump *label44 notEqual :mine:floor null
   153 print ": too far"
   154 print "\n"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    19 sensor :copper .core @copper
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
-    * set .min *tmp9
    22 jump *label11 notEqual *tmp9 :sand
    23 set *tmp11 @sand
    24 jump *label12 always
 
    48 print :flag
    49 print "\n"
    50 jump *label17 notEqual :flag 0
-    * set :findOreToMine:ore .minOre
    51 sensor *tmp19 @unit @firstItem
    52 jump *label20 equal *tmp19 null
    53 ucontrol itemDrop @air 20
 
    95 label *label26
    96 jump *label25 always
    97 label *label24
-    * set :mine:flag :flag
    98 print "Mining"
    99 op idiv :mine:flag :flag 2
   100 op mod *tmp38 :mine:flag 16
 
   114 label *label33
   115 set *tmp43 *tmp45
   116 label *label31
-    * set :mine:floorOre *tmp43
   117 jump *label34 equal :mine:ore .minOre
   118 sensor *tmp48 .core :mine:ore
   119 jump *label36 lessThanEq *tmp48 .min

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-4 instructions):
 
    19 sensor :copper .core @copper
    20 op min *tmp9 :lead :sand
    21 op min *tmp9 *tmp9 :copper
-    * jump *label11 notEqual *tmp9 :sand
    22 set *tmp11 @sand
-    * jump *label12 always
+   23 jump *label12 equal *tmp9 :sand
    24 label *label11
-    * jump *label13 notEqual *tmp9 :lead
-    * set *tmp13 @lead
+   25 set *tmp11 @copper
+   26 jump *label14 notEqual *tmp9 :lead
+   27 set *tmp11 @lead
    28 jump *label14 always
-    * label *label13
-    * set *tmp13 @copper
    29 label *label14
-    * set *tmp11 *tmp13
    30 label *label12
    31 set .minOre *tmp11
    32 print "minOre:"
    33 print *tmp11
    34 print "\n"
-    * jump *label15 greaterThanEq *tmp9 10
+   35 op add .min *tmp9 100
+   36 jump *label16 greaterThanEq *tmp9 10
    37 set .min -100
    38 jump *label16 always
-    * label *label15
-    * op add .min *tmp9 100
    39 label *label16
    40 label *label9
    41 label *label10
 
    98 op idiv :mine:flag :mine:flag 16
    99 op mod :mine:y :mine:flag 1000
   100 op idiv :mine:x :mine:flag 1000
-    * jump *label30 notEqual :mine:ore @copper
   101 set *tmp43 @ore-copper
-    * jump *label31 always
+  102 jump *label31 equal :mine:ore @copper
   103 label *label30
-    * jump *label32 notEqual :mine:ore @lead
-    * set *tmp45 @ore-lead
+  104 set *tmp43 @sand-floor
+  105 jump *label33 notEqual :mine:ore @lead
+  106 set *tmp43 @ore-lead
   107 jump *label33 always
-    * label *label32
-    * set *tmp45 @sand-floor
   108 label *label33
-    * set *tmp43 *tmp45
   109 label *label31
   110 jump *label34 equal :mine:ore .minOre
   111 sensor *tmp48 .core :mine:ore

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
    25 set *tmp11 @copper
    26 jump *label14 notEqual *tmp9 :lead
    27 set *tmp11 @lead
-    * jump *label14 always
    28 label *label14
    29 label *label12
    30 set .minOre *tmp11
 
    34 op add .min *tmp9 100
    35 jump *label16 greaterThanEq *tmp9 10
    36 set .min -100
-    * jump *label16 always
    37 label *label16
    38 label *label9
    39 label *label10
 
   102 set *tmp43 @sand-floor
   103 jump *label33 notEqual :mine:ore @lead
   104 set *tmp43 @ore-lead
-    * jump *label33 always
   105 label *label33
   106 label *label31
   107 jump *label34 equal :mine:ore .minOre

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     1 set .minOre null
     2 label *label0
     3 ubind @mono
-    * label *label1
     4 jump *label0 equal @unit null
-    * label *label2
     5 set :firstItem @unit
     6 label *label3
     7 ulocate building core false @copper .coreX .coreY 0 .core
-    * label *label4
     8 jump *label3 equal .core null
-    * label *label5
     9 label *label6
    10 ubind @mono
    11 jump *label9 notEqual @unit :firstItem
 
    17 op min *tmp9 *tmp9 :copper
    18 set *tmp11 @sand
    19 jump *label12 equal *tmp9 :sand
-    * label *label11
    20 set *tmp11 @copper
    21 jump *label14 notEqual *tmp9 :lead
    22 set *tmp11 @lead
 
    31 set .min -100
    32 label *label16
    33 label *label9
-    * label *label10
    34 sensor :flag @unit @flag
    35 print "Unit flag: "
    36 print :flag
 
    43 jump *label22 equal *tmp22 null
    44 jump *label19 always
    45 label *label22
-    * label *label23
    46 label *label20
-    * label *label21
    47 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    48 ucontrol approach :findOreToMine:x :findOreToMine:y 7
    49 ucontrol mine :findOreToMine:x :findOreToMine:y
 
    76 print "\n"
    77 ucontrol flag 0
    78 label *label27
-    * label *label28
    79 print "\n"
-    * label *label26
    80 jump *label25 always
    81 label *label24
    82 print "Mining"
 
    88 op idiv :mine:x :mine:flag 1000
    89 set *tmp43 @ore-copper
    90 jump *label31 equal :mine:ore @copper
-    * label *label30
    91 set *tmp43 @sand-floor
    92 jump *label33 notEqual :mine:ore @lead
    93 set *tmp43 @ore-lead
 
   100 ucontrol flag 1
   101 jump *label29 always
   102 label *label36
-    * label *label37
   103 label *label34
-    * label *label35
   104 sensor *tmp51 @unit @firstItem
   105 jump *label38 equal *tmp51 :mine:ore
   106 print " (dropping)"
   107 ucontrol itemDrop @air 20
   108 label *label38
-    * label *label39
   109 sensor *tmp54 @unit @totalItems
   110 jump *label40 lessThan *tmp54 20
   111 print ", full"
 
   146 label *label29
   147 label *label25
   148 label *label18
-    * label *label7
   149 jump *label6 always
-    * label *label8
   150 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    40 jump *label20 equal *tmp19 null
    41 ucontrol itemDrop @air 20
    42 sensor *tmp22 @unit @firstItem
-    * jump *label22 equal *tmp22 null
-    * jump *label19 always
+   43 jump *label19 notEqual *tmp22 null
    44 label *label22
    45 label *label20
    46 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    41 ucontrol itemDrop @air 20
    42 sensor *tmp22 @unit @firstItem
    43 jump *label19 notEqual *tmp22 null
-    * label *label22
    44 label *label20
    45 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    46 ucontrol approach :findOreToMine:x :findOreToMine:y 7

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    40 jump *label20 equal *tmp19 null
    41 ucontrol itemDrop @air 20
    42 sensor *tmp22 @unit @firstItem
-    * jump *label19 notEqual *tmp22 null
+   43 jump *label6 notEqual *tmp22 null
    44 label *label20
    45 ulocate ore core true .minOre :findOreToMine:x :findOreToMine:y 0 0
    46 ucontrol approach :findOreToMine:x :findOreToMine:y 7
 
    62 print :findOreToMine:y
    63 print "\n"
    64 label *label19
-    * jump *label18 always
+   65 jump *label6 always
    66 label *label17
    67 jump *label24 notEqual :flag 1
    68 print "Returning ore"
 
    75 ucontrol flag 0
    76 label *label27
    77 print "\n"
-    * jump *label25 always
+   78 jump *label6 always
    79 label *label24
    80 print "Mining"
    81 op idiv :mine:flag :flag 2
 
    96 jump *label36 lessThanEq *tmp48 .min
    97 print ", switching to a more needed ore"
    98 ucontrol flag 1
-    * jump *label29 always
+   99 jump *label6 always
   100 label *label36
   101 label *label34
   102 sensor *tmp51 @unit @firstItem
 
   122 jump *label44 notEqual :mine:floor null
   123 print ": too far"
   124 print "\n"
-    * jump *label45 always
+  125 jump *label43 always
   126 label *label44
   127 ucontrol flag 1
   128 print ": no ore!"

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-1 instructions):
 
    61 print " "
    62 print :findOreToMine:y
    63 print "\n"
-    * label *label19
    64 jump *label6 always
    65 label *label17
    66 jump *label24 notEqual :flag 1
 
   126 ucontrol flag 1
   127 print ": no ore!"
   128 print "\n"
-    * label *label45
   129 jump *label43 always
   130 label *label42
   131 jump *label46 notEqual :mine:block null
 
   139 label *label43
   140 label *label41
   141 print "\n"
-    * label *label29
-    * label *label25
-    * label *label18
   142 jump *label6 always
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-13 instructions):
 
    23 label *label14
    24 label *label12
    25 set .minOre *tmp11
-    * print "minOre:"
-    * print *tmp11
-    * print "\n"
+   26 print "minOre:{0}\n"
+   27 format *tmp11
    28 op add .min *tmp9 100
    29 jump *label16 greaterThanEq *tmp9 10
    30 set .min -100
    31 label *label16
    32 label *label9
    33 sensor :flag @unit @flag
-    * print "Unit flag: "
-    * print :flag
-    * print "\n"
+   34 print "Unit flag: {0}\n"
+   35 format :flag
    36 jump *label17 notEqual :flag 0
    37 sensor *tmp19 @unit @firstItem
    38 jump *label20 equal *tmp19 null
 
    50 op mul *tmp31 *tmp30 2
    51 op add *tmp32 *tmp29 *tmp31
    52 ucontrol flag *tmp32
-    * print "Found "
-    * print .minOre
-    * print " "
-    * print "at "
-    * print :findOreToMine:x
-    * print ","
-    * print " "
-    * print :findOreToMine:y
-    * print "\n"
+   53 print "Found {0} at {0}, {0}\n"
+   54 format .minOre
+   55 format :findOreToMine:x
+   56 format :findOreToMine:y
    57 jump *label6 always
    58 label *label17
    59 jump *label24 notEqual :flag 1
 
    62 ucontrol itemDrop .core 20
    63 sensor *tmp35 @unit @firstItem
    64 jump *label27 notEqual *tmp35 null
-    * print " (finished)"
-    * print "\n"
+   65 print " (finished)\n"
    66 ucontrol flag 0
    67 label *label27
    68 print "\n"
 
   102 ucontrol flag 1
   103 jump *label41 always
   104 label *label40
-    * print " at "
-    * print :mine:x
-    * print ","
-    * print " "
+  105 print " at {0}, "
+  106 format :mine:x
   107 print :mine:y
   108 ucontrol approach :mine:x :mine:y 7
   109 ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor
   110 jump *label42 equal :mine:floor *tmp43
   111 jump *label44 notEqual :mine:floor null
-    * print ": too far"
-    * print "\n"
+  112 print ": too far\n"
   113 jump *label43 always
   114 label *label44
   115 ucontrol flag 1
-    * print ": no ore!"
-    * print "\n"
+  116 print ": no ore!\n"
   117 jump *label43 always
   118 label *label42
   119 jump *label46 notEqual :mine:block null
 
   121 jump *label47 always
   122 label *label46
   123 ucontrol flag 1
-    * print ": blocked!"
-    * print "\n"
+  124 print ": blocked!\n"
   125 label *label47
   126 label *label43
   127 label *label41

Final code before resolving virtual instructions:

    0:  jump *label48 always 0 0
    1:  draw triangle message1 .core .coreX .coreY .min .minOre
    2:  draw triangle :copper :firstItem :flag :lead :sand :findOreToMine:x
    3:  draw triangle :findOreToMine:y :mine:block :mine:flag :mine:floor :mine:ore :mine:x
    4:  draw triangle :mine:y 0 0 0 0 0
        label *label48
    5:  set .min 0                                                   var min = 0, minOre = null;
    6:  set .minOre null                                             ...
        label *label0                                                do
    7:  ubind @mono                                                  ubind(@mono);
    8:  jump *label0 equal @unit null                                do
    9:  set :firstItem @unit                                         var firstItem = @unit;
        label *label3                                                do
   10:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   11:  jump *label3 equal .core null                                do
        label *label6                                                while true do
   12:  ubind @mono                                                  ubind(@mono);
   13:  jump *label9 notEqual @unit :firstItem                       if @unit == firstItem then
   14:  printflush message1                                          printflush(message1);
   15:  sensor :lead .core @lead                                     var lead = core.@lead;
   16:  sensor :sand .core @sand                                     var sand = core.@sand;
   17:  sensor :copper .core @copper                                 var copper = core.@copper;
   18:  op min *tmp9 :lead :sand                                     min = min(lead, sand, copper);
   19:  op min *tmp9 *tmp9 :copper                                   ...
   20:  set *tmp11 @sand                                             minOre = min == sand ? @sand : min == lead ? @lead : @copper;
   21:  jump *label12 equal *tmp9 :sand                              ...
   22:  set *tmp11 @copper                                           ...
   23:  jump *label14 notEqual *tmp9 :lead                           ...
   24:  set *tmp11 @lead                                             ...
        label *label14                                               ...
        label *label12                                               ...
   25:  set .minOre *tmp11                                           ...
   26:  print "minOre:{0}\n"                                         println("minOre:", minOre);
   27:  format *tmp11                                                ...
   28:  op add .min *tmp9 100                                        if min < 10 then min = -100; else min += 100; end;
   29:  jump *label16 greaterThanEq *tmp9 10                         ...
   30:  set .min -100                                                ...
        label *label16                                               ...
        label *label9                                                if @unit == firstItem then
   31:  sensor :flag @unit @flag                                     var flag = @unit.@flag;
   32:  print "Unit flag: {0}\n"                                     println("Unit flag: ", flag);
   33:  format :flag                                                 ...
   34:  jump *label17 notEqual :flag 0                               if flag == 0 then
   35:  sensor *tmp19 @unit @firstItem                               if @unit.@firstItem != null then
   36:  jump *label20 equal *tmp19 null                              ...
   37:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
   38:  sensor *tmp22 @unit @firstItem                               if @unit.@firstItem != null then return; end;
   39:  jump *label6 notEqual *tmp22 null                            ...
        label *label20                                               if @unit.@firstItem != null then
   40:  ulocate ore core true .minOre :findOreToMine:x :findOreToMin ulocate(:ore, ore, out x, out y);
   41:  ucontrol approach :findOreToMine:x :findOreToMine:y 7 0 0    approach(x, y, RADIUS);
   42:  ucontrol mine :findOreToMine:x :findOreToMine:y 0 0 0        mine(x, y);
   43:  op mul *tmp27 :findOreToMine:x 1000                          flag((x * 1000 + y) * 32 + ore.@id * 2);
   44:  op add *tmp28 *tmp27 :findOreToMine:y                        ...
   45:  op mul *tmp29 *tmp28 32                                      ...
   46:  sensor *tmp30 .minOre @id                                    ...
   47:  op mul *tmp31 *tmp30 2                                       ...
   48:  op add *tmp32 *tmp29 *tmp31                                  ...
   49:  ucontrol flag *tmp32 0 0 0 0                                 ...
   50:  print "Found {0} at {0}, {0}\n"                              println($"Found $ore at $x, $y");
   51:  format .minOre                                               ...
   52:  format :findOreToMine:x                                      ...
   53:  format :findOreToMine:y                                      ...
   54:  jump *label6 always 0 0                                      if flag == 0 then
        label *label17                                               ...
   55:  jump *label24 notEqual :flag 1                               elsif flag == 1 then
   56:  print "Returning ore"                                        print("Returning ore");
   57:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   58:  ucontrol itemDrop .core 20 0 0 0                             itemDrop(core, capacity);
   59:  sensor *tmp35 @unit @firstItem                               if @unit.@firstItem == null then
   60:  jump *label27 notEqual *tmp35 null                           ...
   61:  print " (finished)\n"                                        println(" (finished)");
   62:  ucontrol flag 0 0 0 0 0                                      flag(0);
        label *label27                                               if @unit.@firstItem == null then
   63:  print "\n"                                                   println();
   64:  jump *label6 always 0 0                                      elsif flag == 1 then
        label *label24                                               ...
   65:  print "Mining"                                               print("Mining");
   66:  op idiv :mine:flag :flag 2                                   flag \= 2;
   67:  op mod *tmp38 :mine:flag 16                                  var ore = lookup(:item, flag % 16);
   68:  lookup item :mine:ore *tmp38                                 ...
   69:  op idiv :mine:flag :mine:flag 16                             flag \= 16;
   70:  op mod :mine:y :mine:flag 1000                               var y = flag % 1000;
   71:  op idiv :mine:x :mine:flag 1000                              var x = flag \ 1000;
   72:  set *tmp43 @ore-copper                                       ore == @copper ? @ore-copper :
   73:  jump *label31 equal :mine:ore @copper                        ...
   74:  set *tmp43 @sand-floor                                       ore == @lead ? @ore-lead :
   75:  jump *label33 notEqual :mine:ore @lead                       ...
   76:  set *tmp43 @ore-lead                                         ...
        label *label33                                               ...
        label *label31                                               ore == @copper ? @ore-copper :
   77:  jump *label34 equal :mine:ore .minOre                        if ore != minOre then
   78:  sensor *tmp48 .core :mine:ore                                if core.sensor(ore) > min then
   79:  jump *label36 lessThanEq *tmp48 .min                         ...
   80:  print ", switching to a more needed ore"                     print(", switching to a more needed ore");
   81:  ucontrol flag 1 0 0 0 0                                      flag(1);
   82:  jump *label6 always 0 0                                      return;
        label *label36                                               if core.sensor(ore) > min then
        label *label34                                               if ore != minOre then
   83:  sensor *tmp51 @unit @firstItem                               if @unit.@firstItem != ore then
   84:  jump *label38 equal *tmp51 :mine:ore                         ...
   85:  print " (dropping)"                                          print(" (dropping)");
   86:  ucontrol itemDrop @air 20 0 0 0                              itemDrop(@air, capacity);
        label *label38                                               if @unit.@firstItem != ore then
   87:  sensor *tmp54 @unit @totalItems                              if @unit.@totalItems >= capacity then
   88:  jump *label40 lessThan *tmp54 20                             ...
   89:  print ", full"                                               print(", full");
   90:  ucontrol approach .coreX .coreY 7 0 0                        approach(coreX, coreY, RADIUS);
   91:  ucontrol flag 1 0 0 0 0                                      flag(1);
   92:  jump *label41 always 0 0                                     if @unit.@totalItems >= capacity then
        label *label40                                               ...
   93:  print " at {0}, "                                            print($" at $x, $y");
   94:  format :mine:x                                               ...
   95:  print :mine:y                                                ...
   96:  ucontrol approach :mine:x :mine:y 7 0 0                      approach(x, y, RADIUS);
   97:  ucontrol getBlock :mine:x :mine:y 0 :mine:block :mine:floor  var block = getBlock(x, y, , out floor);
   98:  jump *label42 equal :mine:floor *tmp43                       if floor != floorOre then
   99:  jump *label44 notEqual :mine:floor null                      if floor == null then
  100:  print ": too far\n"                                          println(": too far");
  101:  jump *label43 always 0 0                                     if floor == null then
        label *label44                                               ...
  102:  ucontrol flag 1 0 0 0 0                                      flag(1);
  103:  print ": no ore!\n"                                          println(": no ore!");
  104:  jump *label43 always 0 0                                     if floor != floorOre then
        label *label42                                               ...
  105:  jump *label46 notEqual :mine:block null                      elsif block == null then
  106:  ucontrol mine :mine:x :mine:y 0 0 0                          mine(x, y);
  107:  jump *label47 always 0 0                                     elsif block == null then
        label *label46                                               ...
  108:  ucontrol flag 1 0 0 0 0                                      flag(1);
  109:  print ": blocked!\n"                                         println(": blocked!");
        label *label47                                               elsif block == null then
        label *label43                                               if floor != floorOre then
        label *label41                                               if @unit.@totalItems >= capacity then
  110:  print "\n"                                                   println();
  111:  jump *label6 always 0 0                                      while true do


Performance: parsed in 225 ms, compiled in 273 ms, optimized in 224 ms, run in 6 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (4 steps):
The program didn't generate any output.
Execution exception at instruction 7: ubind @mono:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
