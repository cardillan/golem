   285 instructions before optimizations.
    26 instructions eliminated by Temp Variables Elimination (3 iterations).
     1 instructions eliminated by Case Expression Optimization.
    38 instructions eliminated by Dead Code Elimination (7 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 5 iterations).
    14 instructions eliminated by Jump Optimization (5 iterations).
     9 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     1 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
     2 instructions eliminated by If Expression Optimization (3 iterations).
    24 instructions eliminated by Data Flow Optimization (3 passes, 11 iterations).
    52 instructions added by Function Inlining (4 iterations).
     3 function calls inlined by Function Inlining.
     4 instructions eliminated by Jump Straightening (5 iterations).
     6 instructions updated by JumpThreading.
    24 instructions eliminated by Unreachable Code Elimination (2 iterations).
   191 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 820):
  * Inline function 'factoryUnitFinished' defined at line 70:1   size   +57, benefit      109.4, efficiency      1.919 (+50 instructions)
    Inline function call at line 147:13                          size   +29, benefit       21.9, efficiency      0.754
    Inline function call at line 159:13                          size   +29, benefit       43.8, efficiency      1.509
    Inline function call at line 166:13                          size   +29, benefit       43.8, efficiency      1.509

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   292 write *tmp128 .bank *tmp123
   293 label *label49
   294 label *label48
-    * set *tmp130 :factoryUnitFinished:unit
-    * jump *label52 equal *tmp130 @flare
+  295 jump *label52 equal :factoryUnitFinished:unit @flare
   296 jump *label51 always
   297 label *label52
   298 op add *tmp131 .flares 1
 
   301 set *tmp129 *tmp131
   302 jump *label50 always
   303 label *label51
-    * jump *label54 equal *tmp130 @mono
+  304 jump *label54 equal :factoryUnitFinished:unit @mono
   305 jump *label53 always
   306 label *label54
   307 op add *tmp132 .monos 1
 
   310 set *tmp129 *tmp132
   311 jump *label50 always
   312 label *label53
-    * jump *label56 equal *tmp130 @poly
+  313 jump *label56 equal :factoryUnitFinished:unit @poly
   314 jump *label55 always
   315 label *label56
   316 op add *tmp133 .polys 1
 
   319 set *tmp129 *tmp133
   320 jump *label50 always
   321 label *label55
-    * jump *label58 equal *tmp130 @mega
+  322 jump *label58 equal :factoryUnitFinished:unit @mega
   323 jump *label57 always
   324 label *label58
   325 op add *tmp134 .megas 1

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-25 instructions):
 
    43 jump *label7 equal .smelter2 false
    44 set *tmp27 .unloader1
    45 control config *tmp27 @coal
-    * set *tmp26 @coal
    46 jump *label8 always
    47 label *label7
-    * set *tmp26 null
    48 label *label8
    49 sensor *tmp29 .battery @totalPower
    50 set :backgroundProcess:power *tmp29
 
    55 set *tmp34 .generator2
    56 op lessThan *tmp36 :backgroundProcess:power 3800
    57 control enabled *tmp34 *tmp36
-    * set *tmp30 *tmp36
    58 jump *label10 always
    59 label *label9
    60 set *tmp37 .generator
    61 op lessThan *tmp39 :backgroundProcess:power 800
    62 control enabled *tmp37 *tmp39
-    * set *tmp30 *tmp39
    63 label *label10
    64 sensor *tmp40 .factory @progress
    65 set :backgroundProcess:factoryProgress *tmp40
 
    72 set .factoryUnit @flare
    73 set .targetUnit @flare
    74 write @flare .display ".displayNextUnit"
-    * set *tmp44 @flare
    75 jump *label12 always
    76 label *label11
    77 op lessThan *tmp45 .monos .monoTarget
 
   128 label *label16
   129 set *tmp46 *tmp48
   130 label *label14
-    * set *tmp44 *tmp46
   131 label *label12
   132 set *tmp62 .payloadRouter
   133 set *tmp64 .targetUnit
 
   139 set :updateIfSmaller:b :fuzzyUpdate:limitLow
   140 set :updateIfSmaller:newValue false
   141 select :backgroundProcess:enableFactory lessThan :updateIfSmaller:a :updateIfSmaller:b :updateIfSmaller:newValue :backgroundProcess:enableFactory
-    * set *tmp66 null
   142 label *label24
   143 set :updateIfSmaller.1:a :fuzzyUpdate:limitHigh
   144 set :updateIfSmaller.1:b :fuzzyUpdate:value
 
   146 select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
   147 set *tmp67 null
   148 label *label25
-    * set *tmp65 *tmp67
   149 label *label23
   150 op equal *tmp68 .factoryUnit null
   151 jump *label26 equal *tmp68 false
 
   154 set *tmp72 .factory
   155 control config *tmp72 @mono
   156 set :backgroundProcess:lastProgress 0
-    * set *tmp69 :backgroundProcess:lastProgress
   157 jump *label27 always
   158 label *label26
   159 op add *tmp74 :backgroundProcess:factoryProgress 0.1
 
   189 label *label32
   190 set *tmp76 *tmp82
   191 label *label29
-    * set *tmp69 *tmp76
   192 label *label27
   193 op add *tmp90 :backgroundProcess:reconstructorProgress 0.1
   194 op greaterThan *tmp91 :backgroundProcess:lastRecoProgress *tmp90
 
   198 call *label0 *invalid :factoryUnitFinished*retval (m:*label35) (h:*label35)
   199 label *label35
   200 set :backgroundProcess:lastRecoProgress 0
-    * set *tmp92 :backgroundProcess:lastRecoProgress
   201 jump *label34 always
   202 label *label33
   203 set :backgroundProcess:lastRecoProgress :backgroundProcess:reconstructorProgress
-    * set *tmp92 :backgroundProcess:lastRecoProgress
   204 label *label34
   205 op add *tmp93 :backgroundProcess:multiReconstructorProgress 0.1
   206 op greaterThan *tmp94 :backgroundProcess:lastMultiProgress *tmp93
 
   210 call *label0 *invalid :factoryUnitFinished*retval (m:*label38) (h:*label38)
   211 label *label38
   212 set :backgroundProcess:lastMultiProgress 0
-    * set *tmp95 :backgroundProcess:lastMultiProgress
   213 jump *label37 always
   214 label *label36
   215 set :backgroundProcess:lastMultiProgress :backgroundProcess:multiReconstructorProgress
-    * set *tmp95 :backgroundProcess:lastMultiProgress
   216 label *label37
   217 sensor *tmp96 .generator2 @coal
   218 op mul *tmp97 5 .generator2
 
   221 set *tmp100 .unloader2
   222 control config *tmp100 @coal
   223 jump *label5 always
-    * set *tmp99 null
   224 jump *label40 always
   225 label *label39
-    * set *tmp99 null
   226 label *label40
   227 op equal *tmp102 .factoryUnit @mono
   228 op mul *tmp103 *tmp102 30
 
   235 jump *label41 equal *tmp108 false
   236 set *tmp110 .unloader2
   237 control config *tmp110 @lead
-    * set *tmp109 @lead
   238 jump *label42 always
   239 label *label41
   240 op greaterThan *tmp112 :backgroundProcess:coreSilicon .siliconReserve
 
   248 control config *tmp116 @coal
   249 set *tmp113 @coal
   250 label *label44
-    * set *tmp109 *tmp113
   251 label *label42
   252 label *label5
   253 jump *label4 always
 
   280 op add *tmp131 .flares 1
   281 set .flares *tmp131
   282 write *tmp131 .display ".displayFlares"
-    * set *tmp129 *tmp131
   283 jump *label50 always
   284 label *label51
   285 jump *label54 equal :factoryUnitFinished:unit @mono
 
   288 op add *tmp132 .monos 1
   289 set .monos *tmp132
   290 write *tmp132 .display ".displayMonos"
-    * set *tmp129 *tmp132
   291 jump *label50 always
   292 label *label53
   293 jump *label56 equal :factoryUnitFinished:unit @poly
 
   296 op add *tmp133 .polys 1
   297 set .polys *tmp133
   298 write *tmp133 .display ".displayPolys"
-    * set *tmp129 *tmp133
   299 jump *label50 always
   300 label *label55
   301 jump *label58 equal :factoryUnitFinished:unit @mega
 
   304 op add *tmp134 .megas 1
   305 set .megas *tmp134
   306 write *tmp134 .display ".displayMegas"
-    * set *tmp129 *tmp134
   307 jump *label50 always
   308 label *label57
-    * set *tmp129 null
   309 label *label50
   310 write true .display ".displayUnitReset"
-    * set *tmp119 true
   311 jump *label47 always
   312 label *label46
-    * set *tmp119 null
   313 label *label47
   314 label *label45
   315 return :factoryUnitFinished*retaddr

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-7 instructions):
 
    79 set .factoryUnit @mono
    80 set .targetUnit @mono
    81 write @mono .display ".displayNextUnit"
-    * set *tmp46 @mono
    82 jump *label14 always
    83 label *label13
    84 op lessThan *tmp47 .polys .polyTarget
 
   125 label *label20
   126 set *tmp48 *tmp55
   127 label *label16
-    * set *tmp46 *tmp48
   128 label *label14
   129 label *label12
   130 set *tmp62 .payloadRouter
 
   142 set :updateIfSmaller.1:b :fuzzyUpdate:value
   143 set :updateIfSmaller.1:newValue true
   144 select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
-    * set *tmp67 null
   145 label *label25
   146 label *label23
   147 op equal *tmp68 .factoryUnit null
 
   163 call *label0 *invalid :factoryUnitFinished*retval (m:*label30) (h:*label30)
   164 label *label30
   165 set :backgroundProcess:lastProgress 0
-    * set *tmp76 :backgroundProcess:lastProgress
   166 jump *label29 always
   167 label *label28
   168 set *tmp79 .factory
 
   183 set :backgroundProcess:lastProgress :backgroundProcess:factoryProgress
   184 set *tmp82 :backgroundProcess:lastProgress
   185 label *label32
-    * set *tmp76 *tmp82
   186 label *label29
   187 label *label27
   188 op add *tmp90 :backgroundProcess:reconstructorProgress 0.1
 
   236 jump *label43 equal *tmp112 false
   237 set *tmp114 .unloader2
   238 control config *tmp114 @silicon
-    * set *tmp113 @silicon
   239 jump *label44 always
   240 label *label43
   241 set *tmp116 .unloader2
   242 control config *tmp116 @coal
-    * set *tmp113 @coal
   243 label *label44
   244 label *label42
   245 label *label5

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
    96 write @poly .display ".displayNextUnit"
    97 set *tmp52 .reconstructor
    98 control enabled *tmp52 true
-    * set *tmp48 true
    99 jump *label16 always
   100 label *label15
   101 op lessThan *tmp54 .megas .megaTarget
 
   122 write null .display ".displayNextUnit"
   123 set *tmp55 null
   124 label *label20
-    * set *tmp48 *tmp55
   125 label *label16
   126 label *label14
   127 label *label12
 
   173 set *tmp87 .factoryUnit
   174 control config *tmp85 *tmp87
   175 set :backgroundProcess:lastProgress 0
-    * set *tmp82 :backgroundProcess:lastProgress
   176 jump *label32 always
   177 label *label31
   178 set *tmp88 .factory
   179 control enabled *tmp88 :backgroundProcess:enableFactory
   180 set :backgroundProcess:lastProgress :backgroundProcess:factoryProgress
-    * set *tmp82 :backgroundProcess:lastProgress
   181 label *label32
   182 label *label29
   183 label *label27

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   114 set *tmp59 .reconstructor
   115 set *tmp61 .multiReconstructor
   116 control enabled *tmp59 *tmp61
-    * set *tmp55 *tmp61
   117 jump *label20 always
   118 label *label19
   119 set .factoryUnit null
   120 set .targetUnit null
   121 write null .display ".displayNextUnit"
-    * set *tmp55 null
   122 label *label20
   123 label *label16
   124 label *label14

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-23 instructions):
 
    19 set :backgroundProcess:enableFactory true
    20 label *label4
    21 jump *label6 equal true false
-    * sensor *tmp7 .core @silicon
-    * set :backgroundProcess:coreSilicon *tmp7
-    * sensor *tmp8 .core @graphite
-    * set :backgroundProcess:coreGraphite *tmp8
+   22 sensor :backgroundProcess:coreSilicon .core @silicon
+   23 sensor :backgroundProcess:coreGraphite .core @graphite
    24 set *tmp9 .smelter2
    25 set *tmp11 .smelter
    26 op lessThan *tmp13 :backgroundProcess:coreSilicon .smelterTarget
 
    39 op lessThan *tmp25 *tmp24 .kilnTarget
    40 control enabled *tmp22 *tmp25
    41 jump *label7 equal .smelter2 false
-    * set *tmp27 .unloader1
-    * control config *tmp27 @coal
+   42 control config .unloader1 @coal
    43 jump *label8 always
    44 label *label7
    45 label *label8
-    * sensor *tmp29 .battery @totalPower
-    * set :backgroundProcess:power *tmp29
+   46 sensor :backgroundProcess:power .battery @totalPower
    47 jump *label9 equal .generator2 false
    48 set *tmp31 .generator
    49 op lessThan *tmp33 :backgroundProcess:power 10
 
    57 op lessThan *tmp39 :backgroundProcess:power 800
    58 control enabled *tmp37 *tmp39
    59 label *label10
-    * sensor *tmp40 .factory @progress
-    * set :backgroundProcess:factoryProgress *tmp40
-    * sensor *tmp41 .reconstructor @progress
-    * set :backgroundProcess:reconstructorProgress *tmp41
-    * sensor *tmp42 .multiReconstructor @progress
-    * set :backgroundProcess:multiReconstructorProgress *tmp42
+   60 sensor :backgroundProcess:factoryProgress .factory @progress
+   61 sensor :backgroundProcess:reconstructorProgress .reconstructor @progress
+   62 sensor :backgroundProcess:multiReconstructorProgress .multiReconstructor @progress
    63 op lessThan *tmp43 .flares .flareTarget
    64 jump *label11 equal *tmp43 false
    65 set .factoryUnit @flare
 
    87 set .factoryUnit *tmp51
    88 set .targetUnit @poly
    89 write @poly .display ".displayNextUnit"
-    * set *tmp52 .reconstructor
-    * control enabled *tmp52 true
+   90 control enabled .reconstructor true
    91 jump *label16 always
    92 label *label15
    93 op lessThan *tmp54 .megas .megaTarget
 
   104 set .targetUnit @mega
   105 write @mega .display ".displayNextUnit"
   106 set *tmp59 .reconstructor
-    * set *tmp61 .multiReconstructor
-    * control enabled *tmp59 *tmp61
+  107 control enabled *tmp59 .multiReconstructor
   108 jump *label20 always
   109 label *label19
   110 set .factoryUnit null
 
   115 label *label14
   116 label *label12
   117 set *tmp62 .payloadRouter
-    * set *tmp64 .targetUnit
-    * control config *tmp62 *tmp64
+  118 control config *tmp62 .targetUnit
   119 set :fuzzyUpdate:value :backgroundProcess:power
   120 set :fuzzyUpdate:limitLow 200
   121 set :fuzzyUpdate:limitHigh 500
 
   132 label *label23
   133 op equal *tmp68 .factoryUnit null
   134 jump *label26 equal *tmp68 false
-    * set *tmp70 .factory
-    * control enabled *tmp70 false
-    * set *tmp72 .factory
-    * control config *tmp72 @mono
+  135 control enabled .factory false
+  136 control config .factory @mono
   137 set :backgroundProcess:lastProgress 0
   138 jump *label27 always
   139 label *label26
   140 op add *tmp74 :backgroundProcess:factoryProgress 0.1
   141 op greaterThan *tmp75 :backgroundProcess:lastProgress *tmp74
   142 jump *label28 equal *tmp75 false
-    * set *tmp77 .factory
-    * control enabled *tmp77 :backgroundProcess:enableFactory
+  143 control enabled .factory :backgroundProcess:enableFactory
   144 set :factoryUnitFinished:unit .factoryUnit
   145 setaddr :factoryUnitFinished*retaddr *label30 (h:*label30)
   146 call *label0 *invalid :factoryUnitFinished*retval (m:*label30) (h:*label30)
 
   148 set :backgroundProcess:lastProgress 0
   149 jump *label29 always
   150 label *label28
-    * set *tmp79 .factory
-    * sensor *tmp80 *tmp79 @config
+  151 sensor *tmp80 .factory @config
   152 op notEqual *tmp81 *tmp80 .factoryUnit
   153 jump *label31 equal *tmp81 false
-    * set *tmp83 .factory
-    * control enabled *tmp83 :backgroundProcess:enableFactory
+  154 control enabled .factory :backgroundProcess:enableFactory
   155 set *tmp85 .factory
-    * set *tmp87 .factoryUnit
-    * control config *tmp85 *tmp87
+  156 control config *tmp85 .factoryUnit
   157 set :backgroundProcess:lastProgress 0
   158 jump *label32 always
   159 label *label31
-    * set *tmp88 .factory
-    * control enabled *tmp88 :backgroundProcess:enableFactory
+  160 control enabled .factory :backgroundProcess:enableFactory
   161 set :backgroundProcess:lastProgress :backgroundProcess:factoryProgress
   162 label *label32
   163 label *label29
 
   190 op mul *tmp97 5 .generator2
   191 op lessThan *tmp98 *tmp96 *tmp97
   192 jump *label39 equal *tmp98 false
-    * set *tmp100 .unloader2
-    * control config *tmp100 @coal
+  193 control config .unloader2 @coal
   194 jump *label5 always
   195 jump *label40 always
   196 label *label39
   197 label *label40
   198 op equal *tmp102 .factoryUnit @mono
-    * op mul *tmp103 *tmp102 30
-    * set :backgroundProcess:leadLimit *tmp103
+  199 op mul :backgroundProcess:leadLimit *tmp102 30
   200 sensor *tmp104 .factory @lead
   201 op lessThan *tmp105 *tmp104 :backgroundProcess:leadLimit
   202 sensor *tmp106 .core @lead
   203 op greaterThan *tmp107 *tmp106 .leadReserve
   204 op land *tmp108 *tmp105 *tmp107
   205 jump *label41 equal *tmp108 false
-    * set *tmp110 .unloader2
-    * control config *tmp110 @lead
+  206 control config .unloader2 @lead
   207 jump *label42 always
   208 label *label41
   209 op greaterThan *tmp112 :backgroundProcess:coreSilicon .siliconReserve
   210 jump *label43 equal *tmp112 false
-    * set *tmp114 .unloader2
-    * control config *tmp114 @silicon
+  211 control config .unloader2 @silicon
   212 jump *label44 always
   213 label *label43
-    * set *tmp116 .unloader2
-    * control config *tmp116 @coal
+  214 control config .unloader2 @coal
   215 label *label44
   216 label *label42
   217 label *label5
 
   226 jump *label46 equal *tmp118 false
   227 set :logUnit:unit :factoryUnitFinished:unit
   228 sensor *tmp120 :logUnit:unit @id
-    * op add *tmp121 @blockCount *tmp120
-    * set :log:encodedId *tmp121
+  229 op add :log:encodedId @blockCount *tmp120
   230 read *tmp6 .bank 511
   231 op sub *tmp122 *tmp6 1
   232 write *tmp122 .bank 511

Modifications by Initial phase, Temp Variables Elimination, iteration 2 (-3 instructions):
 
   103 set .factoryUnit *tmp58
   104 set .targetUnit @mega
   105 write @mega .display ".displayNextUnit"
-    * set *tmp59 .reconstructor
-    * control enabled *tmp59 .multiReconstructor
+  106 control enabled .reconstructor .multiReconstructor
   107 jump *label20 always
   108 label *label19
   109 set .factoryUnit null
 
   113 label *label16
   114 label *label14
   115 label *label12
-    * set *tmp62 .payloadRouter
-    * control config *tmp62 .targetUnit
+  116 control config .payloadRouter .targetUnit
   117 set :fuzzyUpdate:value :backgroundProcess:power
   118 set :fuzzyUpdate:limitLow 200
   119 set :fuzzyUpdate:limitHigh 500
 
   150 op notEqual *tmp81 *tmp80 .factoryUnit
   151 jump *label31 equal *tmp81 false
   152 control enabled .factory :backgroundProcess:enableFactory
-    * set *tmp85 .factory
-    * control config *tmp85 .factoryUnit
+  153 control config .factory .factoryUnit
   154 set :backgroundProcess:lastProgress 0
   155 jump *label32 always
   156 label *label31

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    18 set :backgroundProcess:multiReconstructorProgress 0
    19 set :backgroundProcess:enableFactory true
    20 label *label4
-    * jump *label6 equal true false
    21 sensor :backgroundProcess:coreSilicon .core @silicon
    22 sensor :backgroundProcess:coreGraphite .core @graphite
    23 set *tmp9 .smelter2

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-4 instructions):
 
   234 write *tmp128 .bank *tmp123
   235 label *label49
   236 label *label48
-    * jump *label52 equal :factoryUnitFinished:unit @flare
-    * jump *label51 always
+  237 jump *label51 notEqual :factoryUnitFinished:unit @flare
   238 label *label52
   239 op add *tmp131 .flares 1
   240 set .flares *tmp131
   241 write *tmp131 .display ".displayFlares"
   242 jump *label50 always
   243 label *label51
-    * jump *label54 equal :factoryUnitFinished:unit @mono
-    * jump *label53 always
+  244 jump *label53 notEqual :factoryUnitFinished:unit @mono
   245 label *label54
   246 op add *tmp132 .monos 1
   247 set .monos *tmp132
   248 write *tmp132 .display ".displayMonos"
   249 jump *label50 always
   250 label *label53
-    * jump *label56 equal :factoryUnitFinished:unit @poly
-    * jump *label55 always
+  251 jump *label55 notEqual :factoryUnitFinished:unit @poly
   252 label *label56
   253 op add *tmp133 .polys 1
   254 set .polys *tmp133
   255 write *tmp133 .display ".displayPolys"
   256 jump *label50 always
   257 label *label55
-    * jump *label58 equal :factoryUnitFinished:unit @mega
-    * jump *label57 always
+  258 jump *label57 notEqual :factoryUnitFinished:unit @mega
   259 label *label58
   260 op add *tmp134 .megas 1
   261 set .megas *tmp134

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-14 instructions):
 
    59 sensor :backgroundProcess:factoryProgress .factory @progress
    60 sensor :backgroundProcess:reconstructorProgress .reconstructor @progress
    61 sensor :backgroundProcess:multiReconstructorProgress .multiReconstructor @progress
-    * op lessThan *tmp43 .flares .flareTarget
-    * jump *label11 equal *tmp43 false
+   62 jump *label11 greaterThanEq .flares .flareTarget
    63 set .factoryUnit @flare
    64 set .targetUnit @flare
    65 write @flare .display ".displayNextUnit"
    66 jump *label12 always
    67 label *label11
-    * op lessThan *tmp45 .monos .monoTarget
-    * jump *label13 equal *tmp45 false
+   68 jump *label13 greaterThanEq .monos .monoTarget
    69 set .factoryUnit @mono
    70 set .targetUnit @mono
    71 write @mono .display ".displayNextUnit"
    72 jump *label14 always
    73 label *label13
-    * op lessThan *tmp47 .polys .polyTarget
-    * jump *label15 equal *tmp47 false
+   74 jump *label15 greaterThanEq .polys .polyTarget
    75 sensor *tmp49 .reconstructor @payloadType
-    * op equal *tmp50 *tmp49 null
-    * jump *label17 equal *tmp50 false
+   76 jump *label17 notEqual *tmp49 null
    77 set *tmp51 @mono
    78 jump *label18 always
    79 label *label17
 
    85 control enabled .reconstructor true
    86 jump *label16 always
    87 label *label15
-    * op lessThan *tmp54 .megas .megaTarget
-    * jump *label19 equal *tmp54 false
+   88 jump *label19 greaterThanEq .megas .megaTarget
    89 sensor *tmp56 .multiReconstructor @payloadType
-    * op equal *tmp57 *tmp56 null
-    * jump *label21 equal *tmp57 false
+   90 jump *label21 notEqual *tmp56 null
    91 set *tmp58 @mono
    92 jump *label22 always
    93 label *label21
 
   121 select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
   122 label *label25
   123 label *label23
-    * op equal *tmp68 .factoryUnit null
-    * jump *label26 equal *tmp68 false
+  124 jump *label26 notEqual .factoryUnit null
   125 control enabled .factory false
   126 control config .factory @mono
   127 set :backgroundProcess:lastProgress 0
   128 jump *label27 always
   129 label *label26
   130 op add *tmp74 :backgroundProcess:factoryProgress 0.1
-    * op greaterThan *tmp75 :backgroundProcess:lastProgress *tmp74
-    * jump *label28 equal *tmp75 false
+  131 jump *label28 lessThanEq :backgroundProcess:lastProgress *tmp74
   132 control enabled .factory :backgroundProcess:enableFactory
   133 set :factoryUnitFinished:unit .factoryUnit
   134 setaddr :factoryUnitFinished*retaddr *label30 (h:*label30)
 
   138 jump *label29 always
   139 label *label28
   140 sensor *tmp80 .factory @config
-    * op notEqual *tmp81 *tmp80 .factoryUnit
-    * jump *label31 equal *tmp81 false
+  141 jump *label31 equal *tmp80 .factoryUnit
   142 control enabled .factory :backgroundProcess:enableFactory
   143 control config .factory .factoryUnit
   144 set :backgroundProcess:lastProgress 0
 
   150 label *label29
   151 label *label27
   152 op add *tmp90 :backgroundProcess:reconstructorProgress 0.1
-    * op greaterThan *tmp91 :backgroundProcess:lastRecoProgress *tmp90
-    * jump *label33 equal *tmp91 false
+  153 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp90
   154 set :factoryUnitFinished:unit @poly
   155 setaddr :factoryUnitFinished*retaddr *label35 (h:*label35)
   156 call *label0 *invalid :factoryUnitFinished*retval (m:*label35) (h:*label35)
 
   161 set :backgroundProcess:lastRecoProgress :backgroundProcess:reconstructorProgress
   162 label *label34
   163 op add *tmp93 :backgroundProcess:multiReconstructorProgress 0.1
-    * op greaterThan *tmp94 :backgroundProcess:lastMultiProgress *tmp93
-    * jump *label36 equal *tmp94 false
+  164 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp93
   165 set :factoryUnitFinished:unit @mega
   166 setaddr :factoryUnitFinished*retaddr *label38 (h:*label38)
   167 call *label0 *invalid :factoryUnitFinished*retval (m:*label38) (h:*label38)
 
   173 label *label37
   174 sensor *tmp96 .generator2 @coal
   175 op mul *tmp97 5 .generator2
-    * op lessThan *tmp98 *tmp96 *tmp97
-    * jump *label39 equal *tmp98 false
+  176 jump *label39 greaterThanEq *tmp96 *tmp97
   177 control config .unloader2 @coal
   178 jump *label5 always
   179 jump *label40 always
 
   190 control config .unloader2 @lead
   191 jump *label42 always
   192 label *label41
-    * op greaterThan *tmp112 :backgroundProcess:coreSilicon .siliconReserve
-    * jump *label43 equal *tmp112 false
+  193 jump *label43 lessThanEq :backgroundProcess:coreSilicon .siliconReserve
   194 control config .unloader2 @silicon
   195 jump *label44 always
   196 label *label43
 
   205 jump *label2 always
   206 end
   207 label *label0
-    * op equal *tmp118 :factoryUnitFinished:unit .targetUnit
-    * jump *label46 equal *tmp118 false
+  208 jump *label46 notEqual :factoryUnitFinished:unit .targetUnit
   209 set :logUnit:unit :factoryUnitFinished:unit
   210 sensor *tmp120 :logUnit:unit @id
   211 op add :log:encodedId @blockCount *tmp120

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    39 control enabled *tmp22 *tmp25
    40 jump *label7 equal .smelter2 false
    41 control config .unloader1 @coal
-    * jump *label8 always
    42 label *label7
    43 label *label8
    44 sensor :backgroundProcess:power .battery @totalPower
 
   175 jump *label39 greaterThanEq *tmp96 *tmp97
   176 control config .unloader2 @coal
   177 jump *label5 always
-    * jump *label40 always
   178 label *label39
   179 label *label40
   180 op equal *tmp102 .factoryUnit @mono
 
   244 op add *tmp134 .megas 1
   245 set .megas *tmp134
   246 write *tmp134 .display ".displayMegas"
-    * jump *label50 always
   247 label *label57
   248 label *label50
   249 write true .display ".displayUnitReset"
-    * jump *label47 always
   250 label *label46
   251 label *label47
   252 label *label45

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   211 op sub *tmp122 *tmp6 1
   212 write *tmp122 .bank 511
   213 set *tmp123 *tmp122
-    * op mul *tmp125 @second 1000
-    * op floor *tmp126 *tmp125
+  214 op idiv *tmp126 @second 0.001
   215 op mul *tmp127 *tmp126 1000
   216 op add *tmp128 :log:encodedId *tmp127
   217 write *tmp128 .bank *tmp123

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-3 instructions):
 
    11 set *signature "0:v1"
    12 label *label2
    13 set :backgroundProcess:lastProgress 0
-    * set :backgroundProcess:factoryProgress 0
    14 set :backgroundProcess:lastRecoProgress 0
-    * set :backgroundProcess:reconstructorProgress 0
    15 set :backgroundProcess:lastMultiProgress 0
-    * set :backgroundProcess:multiReconstructorProgress 0
    16 set :backgroundProcess:enableFactory true
    17 label *label4
    18 sensor :backgroundProcess:coreSilicon .core @silicon
 
   106 set :fuzzyUpdate:value :backgroundProcess:power
   107 set :fuzzyUpdate:limitLow 200
   108 set :fuzzyUpdate:limitHigh 500
-    * set :updateIfSmaller:a :fuzzyUpdate:value
-    * set :updateIfSmaller:b :fuzzyUpdate:limitLow
+  109 set :updateIfSmaller:a :backgroundProcess:power
+  110 set :updateIfSmaller:b 200
   111 set :updateIfSmaller:newValue false
-    * select :backgroundProcess:enableFactory lessThan :updateIfSmaller:a :updateIfSmaller:b :updateIfSmaller:newValue :backgroundProcess:enableFactory
+  112 select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:value :fuzzyUpdate:limitLow false :backgroundProcess:enableFactory
   113 label *label24
-    * set :updateIfSmaller.1:a :fuzzyUpdate:limitHigh
-    * set :updateIfSmaller.1:b :fuzzyUpdate:value
+  114 set :updateIfSmaller.1:a 500
+  115 set :updateIfSmaller.1:b :backgroundProcess:power
   116 set :updateIfSmaller.1:newValue true
-    * select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
+  117 select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:limitHigh :fuzzyUpdate:value true :backgroundProcess:enableFactory
   118 label *label25
   119 label *label23
   120 jump *label26 notEqual .factoryUnit null
 
   202 label *label0
   203 jump *label46 notEqual :factoryUnitFinished:unit .targetUnit
   204 set :logUnit:unit :factoryUnitFinished:unit
-    * sensor *tmp120 :logUnit:unit @id
+  205 sensor *tmp120 :factoryUnitFinished:unit @id
   206 op add :log:encodedId @blockCount *tmp120
   207 read *tmp6 .bank 511
   208 op sub *tmp122 *tmp6 1
 
   211 op idiv *tmp126 @second 0.001
   212 op mul *tmp127 *tmp126 1000
   213 op add *tmp128 :log:encodedId *tmp127
-    * write *tmp128 .bank *tmp123
+  214 write *tmp128 .bank *tmp122
   215 label *label49
   216 label *label48
   217 jump *label51 notEqual :factoryUnitFinished:unit @flare

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-8 instructions):
 
   106 set :fuzzyUpdate:value :backgroundProcess:power
   107 set :fuzzyUpdate:limitLow 200
   108 set :fuzzyUpdate:limitHigh 500
-    * set :updateIfSmaller:a :backgroundProcess:power
-    * set :updateIfSmaller:b 200
-    * set :updateIfSmaller:newValue false
-    * select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:value :fuzzyUpdate:limitLow false :backgroundProcess:enableFactory
+  109 select :backgroundProcess:enableFactory lessThan :backgroundProcess:power 200 false :backgroundProcess:enableFactory
   110 label *label24
-    * set :updateIfSmaller.1:a 500
-    * set :updateIfSmaller.1:b :backgroundProcess:power
-    * set :updateIfSmaller.1:newValue true
-    * select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:limitHigh :fuzzyUpdate:value true :backgroundProcess:enableFactory
+  111 select :backgroundProcess:enableFactory lessThan 500 :backgroundProcess:power true :backgroundProcess:enableFactory
   112 label *label25
   113 label *label23
   114 jump *label26 notEqual .factoryUnit null
 
   195 end
   196 label *label0
   197 jump *label46 notEqual :factoryUnitFinished:unit .targetUnit
-    * set :logUnit:unit :factoryUnitFinished:unit
   198 sensor *tmp120 :factoryUnitFinished:unit @id
   199 op add :log:encodedId @blockCount *tmp120
   200 read *tmp6 .bank 511
   201 op sub *tmp122 *tmp6 1
   202 write *tmp122 .bank 511
-    * set *tmp123 *tmp122
   203 op idiv *tmp126 @second 0.001
   204 op mul *tmp127 *tmp126 1000
   205 op add *tmp128 :log:encodedId *tmp127

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
   103 label *label14
   104 label *label12
   105 control config .payloadRouter .targetUnit
-    * set :fuzzyUpdate:value :backgroundProcess:power
-    * set :fuzzyUpdate:limitLow 200
-    * set :fuzzyUpdate:limitHigh 500
   106 select :backgroundProcess:enableFactory lessThan :backgroundProcess:power 200 false :backgroundProcess:enableFactory
   107 label *label24
   108 select :backgroundProcess:enableFactory lessThan 500 :backgroundProcess:power true :backgroundProcess:enableFactory

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    68 jump *label14 always
    69 label *label13
    70 jump *label15 greaterThanEq .polys .polyTarget
+   71 set .factoryUnit null
    72 sensor *tmp49 .reconstructor @payloadType
-    * jump *label17 notEqual *tmp49 null
-    * set *tmp51 @mono
+   73 jump *label18 notEqual *tmp49 null
+   74 set .factoryUnit @mono
    75 jump *label18 always
-    * label *label17
-    * set *tmp51 null
    76 label *label18
-    * set .factoryUnit *tmp51
    77 set .targetUnit @poly
    78 write @poly .display ".displayNextUnit"
    79 control enabled .reconstructor true
    80 jump *label16 always
    81 label *label15
    82 jump *label19 greaterThanEq .megas .megaTarget
+   83 set .factoryUnit null
    84 sensor *tmp56 .multiReconstructor @payloadType
-    * jump *label21 notEqual *tmp56 null
-    * set *tmp58 @mono
+   85 jump *label22 notEqual *tmp56 null
+   86 set .factoryUnit @mono
    87 jump *label22 always
-    * label *label21
-    * set *tmp58 null
    88 label *label22
-    * set .factoryUnit *tmp58
    89 set .targetUnit @mega
    90 write @mega .display ".displayNextUnit"
    91 control enabled .reconstructor .multiReconstructor

Modifications by Inline function 'factoryUnitFinished' defined at line 70:1 (+52 instructions):
 
   114 jump *label28 lessThanEq :backgroundProcess:lastProgress *tmp74
   115 control enabled .factory :backgroundProcess:enableFactory
   116 set :factoryUnitFinished:unit .factoryUnit
-    * setaddr :factoryUnitFinished*retaddr *label30 (h:*label30)
-    * call *label0 *invalid :factoryUnitFinished*retval (m:*label30) (h:*label30)
-    * label *label30
+  117 label *label59
+  118 jump *label71 notEqual :factoryUnitFinished:unit .targetUnit
+  119 sensor *tmp120 :factoryUnitFinished:unit @id
+  120 op add :log:encodedId @blockCount *tmp120
+  121 read *tmp6 .bank 511
+  122 op sub *tmp122 *tmp6 1
+  123 write *tmp122 .bank 511
+  124 op idiv *tmp126 @second 0.001
+  125 op mul *tmp127 *tmp126 1000
+  126 op add *tmp128 :log:encodedId *tmp127
+  127 write *tmp128 .bank *tmp122
+  128 label *label60
+  129 label *label61
+  130 jump *label63 notEqual :factoryUnitFinished:unit @flare
+  131 label *label62
+  132 op add *tmp131 .flares 1
+  133 set .flares *tmp131
+  134 write *tmp131 .display ".displayFlares"
+  135 jump *label70 always
+  136 label *label63
+  137 jump *label65 notEqual :factoryUnitFinished:unit @mono
+  138 label *label64
+  139 op add *tmp132 .monos 1
+  140 set .monos *tmp132
+  141 write *tmp132 .display ".displayMonos"
+  142 jump *label70 always
+  143 label *label65
+  144 jump *label67 notEqual :factoryUnitFinished:unit @poly
+  145 label *label66
+  146 op add *tmp133 .polys 1
+  147 set .polys *tmp133
+  148 write *tmp133 .display ".displayPolys"
+  149 jump *label70 always
+  150 label *label67
+  151 jump *label69 notEqual :factoryUnitFinished:unit @mega
+  152 label *label68
+  153 op add *tmp134 .megas 1
+  154 set .megas *tmp134
+  155 write *tmp134 .display ".displayMegas"
+  156 label *label69
+  157 label *label70
+  158 write true .display ".displayUnitReset"
+  159 label *label71
+  160 label *label72
+  161 label *label73
   162 set :backgroundProcess:lastProgress 0
   163 jump *label29 always
   164 label *label28
 
   177 op add *tmp90 :backgroundProcess:reconstructorProgress 0.1
   178 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp90
   179 set :factoryUnitFinished:unit @poly
-    * setaddr :factoryUnitFinished*retaddr *label35 (h:*label35)
-    * call *label0 *invalid :factoryUnitFinished*retval (m:*label35) (h:*label35)
-    * label *label35
+  180 label *label74
+  181 jump *label86 notEqual :factoryUnitFinished:unit .targetUnit
+  182 sensor *tmp120 :factoryUnitFinished:unit @id
+  183 op add :log:encodedId @blockCount *tmp120
+  184 read *tmp6 .bank 511
+  185 op sub *tmp122 *tmp6 1
+  186 write *tmp122 .bank 511
+  187 op idiv *tmp126 @second 0.001
+  188 op mul *tmp127 *tmp126 1000
+  189 op add *tmp128 :log:encodedId *tmp127
+  190 write *tmp128 .bank *tmp122
+  191 label *label75
+  192 label *label76
+  193 jump *label78 notEqual :factoryUnitFinished:unit @flare
+  194 label *label77
+  195 op add *tmp131 .flares 1
+  196 set .flares *tmp131
+  197 write *tmp131 .display ".displayFlares"
+  198 jump *label85 always
+  199 label *label78
+  200 jump *label80 notEqual :factoryUnitFinished:unit @mono
+  201 label *label79
+  202 op add *tmp132 .monos 1
+  203 set .monos *tmp132
+  204 write *tmp132 .display ".displayMonos"
+  205 jump *label85 always
+  206 label *label80
+  207 jump *label82 notEqual :factoryUnitFinished:unit @poly
+  208 label *label81
+  209 op add *tmp133 .polys 1
+  210 set .polys *tmp133
+  211 write *tmp133 .display ".displayPolys"
+  212 jump *label85 always
+  213 label *label82
+  214 jump *label84 notEqual :factoryUnitFinished:unit @mega
+  215 label *label83
+  216 op add *tmp134 .megas 1
+  217 set .megas *tmp134
+  218 write *tmp134 .display ".displayMegas"
+  219 label *label84
+  220 label *label85
+  221 write true .display ".displayUnitReset"
+  222 label *label86
+  223 label *label87
+  224 label *label88
   225 set :backgroundProcess:lastRecoProgress 0
   226 jump *label34 always
   227 label *label33
 
   230 op add *tmp93 :backgroundProcess:multiReconstructorProgress 0.1
   231 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp93
   232 set :factoryUnitFinished:unit @mega
-    * setaddr :factoryUnitFinished*retaddr *label38 (h:*label38)
-    * call *label0 *invalid :factoryUnitFinished*retval (m:*label38) (h:*label38)
-    * label *label38
+  233 label *label89
+  234 jump *label101 notEqual :factoryUnitFinished:unit .targetUnit
+  235 sensor *tmp120 :factoryUnitFinished:unit @id
+  236 op add :log:encodedId @blockCount *tmp120
+  237 read *tmp6 .bank 511
+  238 op sub *tmp122 *tmp6 1
+  239 write *tmp122 .bank 511
+  240 op idiv *tmp126 @second 0.001
+  241 op mul *tmp127 *tmp126 1000
+  242 op add *tmp128 :log:encodedId *tmp127
+  243 write *tmp128 .bank *tmp122
+  244 label *label90
+  245 label *label91
+  246 jump *label93 notEqual :factoryUnitFinished:unit @flare
+  247 label *label92
+  248 op add *tmp131 .flares 1
+  249 set .flares *tmp131
+  250 write *tmp131 .display ".displayFlares"
+  251 jump *label100 always
+  252 label *label93
+  253 jump *label95 notEqual :factoryUnitFinished:unit @mono
+  254 label *label94
+  255 op add *tmp132 .monos 1
+  256 set .monos *tmp132
+  257 write *tmp132 .display ".displayMonos"
+  258 jump *label100 always
+  259 label *label95
+  260 jump *label97 notEqual :factoryUnitFinished:unit @poly
+  261 label *label96
+  262 op add *tmp133 .polys 1
+  263 set .polys *tmp133
+  264 write *tmp133 .display ".displayPolys"
+  265 jump *label100 always
+  266 label *label97
+  267 jump *label99 notEqual :factoryUnitFinished:unit @mega
+  268 label *label98
+  269 op add *tmp134 .megas 1
+  270 set .megas *tmp134
+  271 write *tmp134 .display ".displayMegas"
+  272 label *label99
+  273 label *label100
+  274 write true .display ".displayUnitReset"
+  275 label *label101
+  276 label *label102
+  277 label *label103
   278 set :backgroundProcess:lastMultiProgress 0
   279 jump *label37 always
   280 label *label36
 
   312 wait 1e12
   313 jump *label2 always
   314 end
-    * label *label0
-    * jump *label46 notEqual :factoryUnitFinished:unit .targetUnit
-    * sensor *tmp120 :factoryUnitFinished:unit @id
-    * op add :log:encodedId @blockCount *tmp120
-    * read *tmp6 .bank 511
-    * op sub *tmp122 *tmp6 1
-    * write *tmp122 .bank 511
-    * op idiv *tmp126 @second 0.001
-    * op mul *tmp127 *tmp126 1000
-    * op add *tmp128 :log:encodedId *tmp127
-    * write *tmp128 .bank *tmp122
-    * label *label49
-    * label *label48
-    * jump *label51 notEqual :factoryUnitFinished:unit @flare
-    * label *label52
-    * op add *tmp131 .flares 1
-    * set .flares *tmp131
-    * write *tmp131 .display ".displayFlares"
-    * jump *label50 always
-    * label *label51
-    * jump *label53 notEqual :factoryUnitFinished:unit @mono
-    * label *label54
-    * op add *tmp132 .monos 1
-    * set .monos *tmp132
-    * write *tmp132 .display ".displayMonos"
-    * jump *label50 always
-    * label *label53
-    * jump *label55 notEqual :factoryUnitFinished:unit @poly
-    * label *label56
-    * op add *tmp133 .polys 1
-    * set .polys *tmp133
-    * write *tmp133 .display ".displayPolys"
-    * jump *label50 always
-    * label *label55
-    * jump *label57 notEqual :factoryUnitFinished:unit @mega
-    * label *label58
-    * op add *tmp134 .megas 1
-    * set .megas *tmp134
-    * write *tmp134 .display ".displayMegas"
-    * label *label57
-    * label *label50
-    * write true .display ".displayUnitReset"
-    * label *label46
-    * label *label47
-    * label *label45
-    * return :factoryUnitFinished*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   178 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp90
   179 set :factoryUnitFinished:unit @poly
   180 label *label74
-    * jump *label86 notEqual :factoryUnitFinished:unit .targetUnit
-    * sensor *tmp120 :factoryUnitFinished:unit @id
+  181 jump *label86 notEqual @poly .targetUnit
+  182 sensor *tmp120 @poly @id
   183 op add :log:encodedId @blockCount *tmp120
   184 read *tmp6 .bank 511
   185 op sub *tmp122 *tmp6 1
 
   190 write *tmp128 .bank *tmp122
   191 label *label75
   192 label *label76
-    * jump *label78 notEqual :factoryUnitFinished:unit @flare
+  193 jump *label78 notEqual @poly @flare
   194 label *label77
   195 op add *tmp131 .flares 1
   196 set .flares *tmp131
   197 write *tmp131 .display ".displayFlares"
   198 jump *label85 always
   199 label *label78
-    * jump *label80 notEqual :factoryUnitFinished:unit @mono
+  200 jump *label80 notEqual @poly @mono
   201 label *label79
   202 op add *tmp132 .monos 1
   203 set .monos *tmp132
   204 write *tmp132 .display ".displayMonos"
   205 jump *label85 always
   206 label *label80
-    * jump *label82 notEqual :factoryUnitFinished:unit @poly
+  207 jump *label82 notEqual @poly @poly
   208 label *label81
   209 op add *tmp133 .polys 1
   210 set .polys *tmp133
   211 write *tmp133 .display ".displayPolys"
   212 jump *label85 always
   213 label *label82
-    * jump *label84 notEqual :factoryUnitFinished:unit @mega
+  214 jump *label84 notEqual @poly @mega
   215 label *label83
   216 op add *tmp134 .megas 1
   217 set .megas *tmp134
 
   231 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp93
   232 set :factoryUnitFinished:unit @mega
   233 label *label89
-    * jump *label101 notEqual :factoryUnitFinished:unit .targetUnit
-    * sensor *tmp120 :factoryUnitFinished:unit @id
+  234 jump *label101 notEqual @mega .targetUnit
+  235 sensor *tmp120 @mega @id
   236 op add :log:encodedId @blockCount *tmp120
   237 read *tmp6 .bank 511
   238 op sub *tmp122 *tmp6 1
 
   243 write *tmp128 .bank *tmp122
   244 label *label90
   245 label *label91
-    * jump *label93 notEqual :factoryUnitFinished:unit @flare
+  246 jump *label93 notEqual @mega @flare
   247 label *label92
   248 op add *tmp131 .flares 1
   249 set .flares *tmp131
   250 write *tmp131 .display ".displayFlares"
   251 jump *label100 always
   252 label *label93
-    * jump *label95 notEqual :factoryUnitFinished:unit @mono
+  253 jump *label95 notEqual @mega @mono
   254 label *label94
   255 op add *tmp132 .monos 1
   256 set .monos *tmp132
   257 write *tmp132 .display ".displayMonos"
   258 jump *label100 always
   259 label *label95
-    * jump *label97 notEqual :factoryUnitFinished:unit @poly
+  260 jump *label97 notEqual @mega @poly
   261 label *label96
   262 op add *tmp133 .polys 1
   263 set .polys *tmp133
   264 write *tmp133 .display ".displayPolys"
   265 jump *label100 always
   266 label *label97
-    * jump *label99 notEqual :factoryUnitFinished:unit @mega
+  267 jump *label99 notEqual @mega @mega
   268 label *label98
   269 op add *tmp134 .megas 1
   270 set .megas *tmp134

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
   176 label *label27
   177 op add *tmp90 :backgroundProcess:reconstructorProgress 0.1
   178 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp90
-    * set :factoryUnitFinished:unit @poly
   179 label *label74
   180 jump *label86 notEqual @poly .targetUnit
   181 sensor *tmp120 @poly @id
 
   228 label *label34
   229 op add *tmp93 :backgroundProcess:multiReconstructorProgress 0.1
   230 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp93
-    * set :factoryUnitFinished:unit @mega
   231 label *label89
   232 jump *label101 notEqual @mega .targetUnit
   233 sensor *tmp120 @mega @id

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
   189 write *tmp128 .bank *tmp122
   190 label *label75
   191 label *label76
-    * jump *label78 notEqual @poly @flare
+  192 jump *label78 always
   193 label *label77
   194 op add *tmp131 .flares 1
   195 set .flares *tmp131
   196 write *tmp131 .display ".displayFlares"
   197 jump *label85 always
   198 label *label78
-    * jump *label80 notEqual @poly @mono
+  199 jump *label80 always
   200 label *label79
   201 op add *tmp132 .monos 1
   202 set .monos *tmp132
   203 write *tmp132 .display ".displayMonos"
   204 jump *label85 always
   205 label *label80
-    * jump *label82 notEqual @poly @poly
   206 label *label81
   207 op add *tmp133 .polys 1
   208 set .polys *tmp133
   209 write *tmp133 .display ".displayPolys"
   210 jump *label85 always
   211 label *label82
-    * jump *label84 notEqual @poly @mega
+  212 jump *label84 always
   213 label *label83
   214 op add *tmp134 .megas 1
   215 set .megas *tmp134
 
   240 write *tmp128 .bank *tmp122
   241 label *label90
   242 label *label91
-    * jump *label93 notEqual @mega @flare
+  243 jump *label93 always
   244 label *label92
   245 op add *tmp131 .flares 1
   246 set .flares *tmp131
   247 write *tmp131 .display ".displayFlares"
   248 jump *label100 always
   249 label *label93
-    * jump *label95 notEqual @mega @mono
+  250 jump *label95 always
   251 label *label94
   252 op add *tmp132 .monos 1
   253 set .monos *tmp132
   254 write *tmp132 .display ".displayMonos"
   255 jump *label100 always
   256 label *label95
-    * jump *label97 notEqual @mega @poly
+  257 jump *label97 always
   258 label *label96
   259 op add *tmp133 .polys 1
   260 set .polys *tmp133
   261 write *tmp133 .display ".displayPolys"
   262 jump *label100 always
   263 label *label97
-    * jump *label99 notEqual @mega @mega
   264 label *label98
   265 op add *tmp134 .megas 1
   266 set .megas *tmp134

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
    72 sensor *tmp49 .reconstructor @payloadType
    73 jump *label18 notEqual *tmp49 null
    74 set .factoryUnit @mono
-    * jump *label18 always
    75 label *label18
    76 set .targetUnit @poly
    77 write @poly .display ".displayNextUnit"
 
    83 sensor *tmp56 .multiReconstructor @payloadType
    84 jump *label22 notEqual *tmp56 null
    85 set .factoryUnit @mono
-    * jump *label22 always
    86 label *label22
    87 set .targetUnit @mega
    88 write @mega .display ".displayNextUnit"

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   176 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp90
   177 label *label74
   178 jump *label86 notEqual @poly .targetUnit
-    * sensor *tmp120 @poly @id
+  179 set *tmp120 21
   180 op add :log:encodedId @blockCount *tmp120
   181 read *tmp6 .bank 511
   182 op sub *tmp122 *tmp6 1
 
   227 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp93
   228 label *label89
   229 jump *label101 notEqual @mega .targetUnit
-    * sensor *tmp120 @mega @id
+  230 set *tmp120 22
   231 op add :log:encodedId @blockCount *tmp120
   232 read *tmp6 .bank 511
   233 op sub *tmp122 *tmp6 1

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-6 instructions):
 
   177 label *label74
   178 jump *label86 notEqual @poly .targetUnit
   179 set *tmp120 21
-    * op add :log:encodedId @blockCount *tmp120
+  180 op add :log:encodedId @blockCount 21
   181 read *tmp6 .bank 511
   182 op sub *tmp122 *tmp6 1
   183 write *tmp122 .bank 511
 
   189 label *label76
   190 jump *label78 always
   191 label *label77
-    * op add *tmp131 .flares 1
   192 set .flares *tmp131
   193 write *tmp131 .display ".displayFlares"
   194 jump *label85 always
   195 label *label78
   196 jump *label80 always
   197 label *label79
-    * op add *tmp132 .monos 1
   198 set .monos *tmp132
   199 write *tmp132 .display ".displayMonos"
   200 jump *label85 always
 
   207 label *label82
   208 jump *label84 always
   209 label *label83
-    * op add *tmp134 .megas 1
   210 set .megas *tmp134
   211 write *tmp134 .display ".displayMegas"
   212 label *label84
 
   225 label *label89
   226 jump *label101 notEqual @mega .targetUnit
   227 set *tmp120 22
-    * op add :log:encodedId @blockCount *tmp120
+  228 op add :log:encodedId @blockCount 22
   229 read *tmp6 .bank 511
   230 op sub *tmp122 *tmp6 1
   231 write *tmp122 .bank 511
 
   237 label *label91
   238 jump *label93 always
   239 label *label92
-    * op add *tmp131 .flares 1
   240 set .flares *tmp131
   241 write *tmp131 .display ".displayFlares"
   242 jump *label100 always
   243 label *label93
   244 jump *label95 always
   245 label *label94
-    * op add *tmp132 .monos 1
   246 set .monos *tmp132
   247 write *tmp132 .display ".displayMonos"
   248 jump *label100 always
   249 label *label95
   250 jump *label97 always
   251 label *label96
-    * op add *tmp133 .polys 1
   252 set .polys *tmp133
   253 write *tmp133 .display ".displayPolys"
   254 jump *label100 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-2 instructions):
 
   176 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp90
   177 label *label74
   178 jump *label86 notEqual @poly .targetUnit
-    * set *tmp120 21
   179 op add :log:encodedId @blockCount 21
   180 read *tmp6 .bank 511
   181 op sub *tmp122 *tmp6 1
 
   223 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp93
   224 label *label89
   225 jump *label101 notEqual @mega .targetUnit
-    * set *tmp120 22
   226 op add :log:encodedId @blockCount 22
   227 read *tmp6 .bank 511
   228 op sub *tmp122 *tmp6 1

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    37 jump *label7 equal .smelter2 false
    38 control config .unloader1 @coal
    39 label *label7
-    * label *label8
    40 sensor :backgroundProcess:power .battery @totalPower
    41 jump *label9 equal .generator2 false
    42 set *tmp31 .generator
 
    97 label *label12
    98 control config .payloadRouter .targetUnit
    99 select :backgroundProcess:enableFactory lessThan :backgroundProcess:power 200 false :backgroundProcess:enableFactory
-    * label *label24
   100 select :backgroundProcess:enableFactory lessThan 500 :backgroundProcess:power true :backgroundProcess:enableFactory
-    * label *label25
-    * label *label23
   101 jump *label26 notEqual .factoryUnit null
   102 control enabled .factory false
   103 control config .factory @mono
 
   108 jump *label28 lessThanEq :backgroundProcess:lastProgress *tmp74
   109 control enabled .factory :backgroundProcess:enableFactory
   110 set :factoryUnitFinished:unit .factoryUnit
-    * label *label59
   111 jump *label71 notEqual :factoryUnitFinished:unit .targetUnit
   112 sensor *tmp120 :factoryUnitFinished:unit @id
   113 op add :log:encodedId @blockCount *tmp120
 
   118 op mul *tmp127 *tmp126 1000
   119 op add *tmp128 :log:encodedId *tmp127
   120 write *tmp128 .bank *tmp122
-    * label *label60
-    * label *label61
   121 jump *label63 notEqual :factoryUnitFinished:unit @flare
-    * label *label62
   122 op add *tmp131 .flares 1
   123 set .flares *tmp131
   124 write *tmp131 .display ".displayFlares"
   125 jump *label70 always
   126 label *label63
   127 jump *label65 notEqual :factoryUnitFinished:unit @mono
-    * label *label64
   128 op add *tmp132 .monos 1
   129 set .monos *tmp132
   130 write *tmp132 .display ".displayMonos"
   131 jump *label70 always
   132 label *label65
   133 jump *label67 notEqual :factoryUnitFinished:unit @poly
-    * label *label66
   134 op add *tmp133 .polys 1
   135 set .polys *tmp133
   136 write *tmp133 .display ".displayPolys"
   137 jump *label70 always
   138 label *label67
   139 jump *label69 notEqual :factoryUnitFinished:unit @mega
-    * label *label68
   140 op add *tmp134 .megas 1
   141 set .megas *tmp134
   142 write *tmp134 .display ".displayMegas"
 
   144 label *label70
   145 write true .display ".displayUnitReset"
   146 label *label71
-    * label *label72
-    * label *label73
   147 set :backgroundProcess:lastProgress 0
   148 jump *label29 always
   149 label *label28
 
   161 label *label27
   162 op add *tmp90 :backgroundProcess:reconstructorProgress 0.1
   163 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp90
-    * label *label74
   164 jump *label86 notEqual @poly .targetUnit
   165 op add :log:encodedId @blockCount 21
   166 read *tmp6 .bank 511
 
   170 op mul *tmp127 *tmp126 1000
   171 op add *tmp128 :log:encodedId *tmp127
   172 write *tmp128 .bank *tmp122
-    * label *label75
-    * label *label76
   173 jump *label78 always
-    * label *label77
   174 set .flares *tmp131
   175 write *tmp131 .display ".displayFlares"
   176 jump *label85 always
   177 label *label78
   178 jump *label80 always
-    * label *label79
   179 set .monos *tmp132
   180 write *tmp132 .display ".displayMonos"
   181 jump *label85 always
   182 label *label80
-    * label *label81
   183 op add *tmp133 .polys 1
   184 set .polys *tmp133
   185 write *tmp133 .display ".displayPolys"
   186 jump *label85 always
-    * label *label82
   187 jump *label84 always
-    * label *label83
   188 set .megas *tmp134
   189 write *tmp134 .display ".displayMegas"
   190 label *label84
   191 label *label85
   192 write true .display ".displayUnitReset"
   193 label *label86
-    * label *label87
-    * label *label88
   194 set :backgroundProcess:lastRecoProgress 0
   195 jump *label34 always
   196 label *label33
 
   198 label *label34
   199 op add *tmp93 :backgroundProcess:multiReconstructorProgress 0.1
   200 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp93
-    * label *label89
   201 jump *label101 notEqual @mega .targetUnit
   202 op add :log:encodedId @blockCount 22
   203 read *tmp6 .bank 511
 
   207 op mul *tmp127 *tmp126 1000
   208 op add *tmp128 :log:encodedId *tmp127
   209 write *tmp128 .bank *tmp122
-    * label *label90
-    * label *label91
   210 jump *label93 always
-    * label *label92
   211 set .flares *tmp131
   212 write *tmp131 .display ".displayFlares"
   213 jump *label100 always
   214 label *label93
   215 jump *label95 always
-    * label *label94
   216 set .monos *tmp132
   217 write *tmp132 .display ".displayMonos"
   218 jump *label100 always
   219 label *label95
   220 jump *label97 always
-    * label *label96
   221 set .polys *tmp133
   222 write *tmp133 .display ".displayPolys"
   223 jump *label100 always
   224 label *label97
-    * label *label98
   225 op add *tmp134 .megas 1
   226 set .megas *tmp134
   227 write *tmp134 .display ".displayMegas"
-    * label *label99
   228 label *label100
   229 write true .display ".displayUnitReset"
   230 label *label101
-    * label *label102
-    * label *label103
   231 set :backgroundProcess:lastMultiProgress 0
   232 jump *label37 always
   233 label *label36
 
   239 control config .unloader2 @coal
   240 jump *label5 always
   241 label *label39
-    * label *label40
   242 op equal *tmp102 .factoryUnit @mono
   243 op mul :backgroundProcess:leadLimit *tmp102 30
   244 sensor *tmp104 .factory @lead
 
   259 label *label42
   260 label *label5
   261 jump *label4 always
-    * label *label6
-    * label *label3
   262 wait 1e12
   263 jump *label2 always
   264 end

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
   170 op mul *tmp127 *tmp126 1000
   171 op add *tmp128 :log:encodedId *tmp127
   172 write *tmp128 .bank *tmp122
-    * jump *label78 always
+  173 jump *label80 always
   174 set .flares *tmp131
   175 write *tmp131 .display ".displayFlares"
   176 jump *label85 always
 
   207 op mul *tmp127 *tmp126 1000
   208 op add *tmp128 :log:encodedId *tmp127
   209 write *tmp128 .bank *tmp122
-    * jump *label93 always
+  210 jump *label97 always
   211 set .flares *tmp131
   212 write *tmp131 .display ".displayFlares"
   213 jump *label100 always
   214 label *label93
-    * jump *label95 always
+  215 jump *label97 always
   216 set .monos *tmp132
   217 write *tmp132 .display ".displayMonos"
   218 jump *label100 always
 
   237 op mul *tmp97 5 .generator2
   238 jump *label39 greaterThanEq *tmp96 *tmp97
   239 control config .unloader2 @coal
-    * jump *label5 always
+  240 jump *label4 always
   241 label *label39
   242 op equal *tmp102 .factoryUnit @mono
   243 op mul :backgroundProcess:leadLimit *tmp102 30
 
   248 op land *tmp108 *tmp105 *tmp107
   249 jump *label41 equal *tmp108 false
   250 control config .unloader2 @lead
-    * jump *label42 always
+  251 jump *label4 always
   252 label *label41
   253 jump *label43 lessThanEq :backgroundProcess:coreSilicon .siliconReserve
   254 control config .unloader2 @silicon
-    * jump *label44 always
+  255 jump *label4 always
   256 label *label43
   257 control config .unloader2 @coal
   258 label *label44

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-24 instructions):
 
   171 op add *tmp128 :log:encodedId *tmp127
   172 write *tmp128 .bank *tmp122
   173 jump *label80 always
-    * set .flares *tmp131
-    * write *tmp131 .display ".displayFlares"
-    * jump *label85 always
-    * label *label78
-    * jump *label80 always
-    * set .monos *tmp132
-    * write *tmp132 .display ".displayMonos"
-    * jump *label85 always
   174 label *label80
   175 op add *tmp133 .polys 1
   176 set .polys *tmp133
   177 write *tmp133 .display ".displayPolys"
   178 jump *label85 always
-    * jump *label84 always
-    * set .megas *tmp134
-    * write *tmp134 .display ".displayMegas"
-    * label *label84
   179 label *label85
   180 write true .display ".displayUnitReset"
   181 label *label86
 
   196 op add *tmp128 :log:encodedId *tmp127
   197 write *tmp128 .bank *tmp122
   198 jump *label97 always
-    * set .flares *tmp131
-    * write *tmp131 .display ".displayFlares"
-    * jump *label100 always
-    * label *label93
-    * jump *label97 always
-    * set .monos *tmp132
-    * write *tmp132 .display ".displayMonos"
-    * jump *label100 always
-    * label *label95
-    * jump *label97 always
-    * set .polys *tmp133
-    * write *tmp133 .display ".displayPolys"
-    * jump *label100 always
   199 label *label97
   200 op add *tmp134 .megas 1
   201 set .megas *tmp134
 
   230 jump *label4 always
   231 label *label43
   232 control config .unloader2 @coal
-    * label *label44
-    * label *label42
-    * label *label5
   233 jump *label4 always
-    * wait 1e12
-    * jump *label2 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
 
     9 set .polyTarget 0
    10 set .megaTarget 0
    11 set *signature "0:v1"
-    * label *label2
    12 set :backgroundProcess:lastProgress 0
    13 set :backgroundProcess:lastRecoProgress 0
    14 set :backgroundProcess:lastMultiProgress 0
 
   199 op add *tmp134 .megas 1
   200 set .megas *tmp134
   201 write *tmp134 .display ".displayMegas"
-    * label *label100
   202 write true .display ".displayUnitReset"
   203 label *label101
   204 set :backgroundProcess:lastMultiProgress 0

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-3 instructions):
 
   169 op mul *tmp127 *tmp126 1000
   170 op add *tmp128 :log:encodedId *tmp127
   171 write *tmp128 .bank *tmp122
-    * jump *label80 always
   172 label *label80
   173 op add *tmp133 .polys 1
   174 set .polys *tmp133
   175 write *tmp133 .display ".displayPolys"
-    * jump *label85 always
   176 label *label85
   177 write true .display ".displayUnitReset"
   178 label *label86
 
   192 op mul *tmp127 *tmp126 1000
   193 op add *tmp128 :log:encodedId *tmp127
   194 write *tmp128 .bank *tmp122
-    * jump *label97 always
   195 label *label97
   196 op add *tmp134 .megas 1
   197 set .megas *tmp134

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
   169 op mul *tmp127 *tmp126 1000
   170 op add *tmp128 :log:encodedId *tmp127
   171 write *tmp128 .bank *tmp122
-    * label *label80
   172 op add *tmp133 .polys 1
   173 set .polys *tmp133
   174 write *tmp133 .display ".displayPolys"
-    * label *label85
   175 write true .display ".displayUnitReset"
   176 label *label86
   177 set :backgroundProcess:lastRecoProgress 0
 
   190 op mul *tmp127 *tmp126 1000
   191 op add *tmp128 :log:encodedId *tmp127
   192 write *tmp128 .bank *tmp122
-    * label *label97
   193 op add *tmp134 .megas 1
   194 set .megas *tmp134
   195 write *tmp134 .display ".displayMegas"

Final code before resolving virtual instructions:

    0:  jump *label104 always 0 0
    1:  draw triangle .bank .battery .core .display .factory .factoryUnit
    2:  draw triangle .flareTarget .flares .generator .generator2 .kiln .kilnTarget
    3:  draw triangle .leadReserve .megaTarget .megas .monoTarget .monos .multiReconstructor
    4:  draw triangle .multipress .payloadRouter .polyTarget .polys .press .pressTarget
    5:  draw triangle .reconstructor .siliconReserve .smelter .smelter2 .smelterTarget .targetUnit
    6:  draw triangle .unloader1 .unloader2 :backgroundProcess:coreGraphite :backgroundProcess:coreSilicon :backgroundProcess:enableFactory :backgroundProcess:factoryProgress
    7:  draw triangle :backgroundProcess:lastMultiProgress :backgroundProcess:lastProgress :backgroundProcess:lastRecoProgress :backgroundProcess:leadLimit :backgroundProcess:multiReconstructorProgress :backgroundProcess:power
    8:  draw triangle :backgroundProcess:reconstructorProgress :factoryUnitFinished:unit :log:encodedId 0 0 0
        label *label104
    9:  set .flares 0                                                remote var
   10:  set .monos 0                                                 ...
   11:  set .polys 1                                                 ...
   12:  set .megas 0                                                 ...
   13:  set .pressTarget 20                                          ...
   14:  set .smelterTarget 20                                        ...
   15:  set .kilnTarget 20                                           ...
   16:  set .flareTarget 0                                           ...
   17:  set .monoTarget 0                                            ...
   18:  set .polyTarget 0                                            ...
   19:  set .megaTarget 0                                            ...
   20:  set *signature "0:v1"                                        #set target = 8;
   21:  set :backgroundProcess:lastProgress 0                        var lastProgress = 0, factoryProgress = 0;
   22:  set :backgroundProcess:lastRecoProgress 0                    var lastRecoProgress = 0, reconstructorProgress = 0;
   23:  set :backgroundProcess:lastMultiProgress 0                   var lastMultiProgress = 0, multiReconstructorProgress = 0;
   24:  set :backgroundProcess:enableFactory true                    var enableFactory = true;
        label *label4                                                while true do
   25:  sensor :backgroundProcess:coreSilicon .core @silicon         var coreSilicon = core.@silicon;
   26:  sensor :backgroundProcess:coreGraphite .core @graphite       var coreGraphite = core.@graphite;
   27:  set *tmp9 .smelter2                                          smelter2.enabled = smelter.enabled = coreSilicon < smelterTarget;
   28:  set *tmp11 .smelter                                          ...
   29:  op lessThan *tmp13 :backgroundProcess:coreSilicon .smelterTa ...
   30:  control enabled *tmp11 *tmp13 0 0 0                          ...
   31:  control enabled *tmp9 *tmp13 0 0 0                           ...
   32:  set *tmp14 .press                                            press.enabled = !multipress and coreGraphite < pressTarget;
   33:  op equal *tmp16 .multipress false                            ...
   34:  op lessThan *tmp17 :backgroundProcess:coreGraphite .pressTar ...
   35:  op land *tmp18 *tmp16 *tmp17                                 ...
   36:  control enabled *tmp14 *tmp18 0 0 0                          ...
   37:  set *tmp19 .multipress                                       multipress.enabled = coreGraphite < pressTarget;
   38:  op lessThan *tmp21 :backgroundProcess:coreGraphite .pressTar ...
   39:  control enabled *tmp19 *tmp21 0 0 0                          ...
   40:  set *tmp22 .kiln                                             kiln.enabled = core.@metaglass < kilnTarget;
   41:  sensor *tmp24 .core @metaglass                               ...
   42:  op lessThan *tmp25 *tmp24 .kilnTarget                        ...
   43:  control enabled *tmp22 *tmp25 0 0 0                          ...
   44:  jump *label7 equal .smelter2 false                           if smelter2 then unloader1.config = @coal; end;
   45:  control config .unloader1 @coal 0 0 0                        ...
        label *label7                                                ...
   46:  sensor :backgroundProcess:power .battery @totalPower         var power = battery.@totalPower;
   47:  jump *label9 equal .generator2 false                         if generator2 then
   48:  set *tmp31 .generator                                        generator.enabled = power < 10;
   49:  op lessThan *tmp33 :backgroundProcess:power 10               ...
   50:  control enabled *tmp31 *tmp33 0 0 0                          ...
   51:  set *tmp34 .generator2                                       generator2.enabled = power < 3800;
   52:  op lessThan *tmp36 :backgroundProcess:power 3800             ...
   53:  control enabled *tmp34 *tmp36 0 0 0                          ...
   54:  jump *label10 always 0 0                                     if generator2 then
        label *label9                                                ...
   55:  set *tmp37 .generator                                        generator.enabled = power < 800;
   56:  op lessThan *tmp39 :backgroundProcess:power 800              ...
   57:  control enabled *tmp37 *tmp39 0 0 0                          ...
        label *label10                                               if generator2 then
   58:  sensor :backgroundProcess:factoryProgress .factory @progress factoryProgress = factory.@progress;
   59:  sensor :backgroundProcess:reconstructorProgress .reconstruct reconstructorProgress = reconstructor.@progress;
   60:  sensor :backgroundProcess:multiReconstructorProgress .multiR multiReconstructorProgress = multiReconstructor.@progress;
   61:  jump *label11 greaterThanEq .flares .flareTarget             if flares < flareTarget then
   62:  set .factoryUnit @flare                                      displayNextUnit = targetUnit = factoryUnit = @flare;
   63:  set .targetUnit @flare                                       ...
   64:  write @flare .display ".displayNextUnit"                     ...
   65:  jump *label12 always 0 0                                     if flares < flareTarget then
        label *label11                                               ...
   66:  jump *label13 greaterThanEq .monos .monoTarget               elsif monos < monoTarget then
   67:  set .factoryUnit @mono                                       displayNextUnit = targetUnit = factoryUnit = @mono;
   68:  set .targetUnit @mono                                        ...
   69:  write @mono .display ".displayNextUnit"                      ...
   70:  jump *label14 always 0 0                                     elsif monos < monoTarget then
        label *label13                                               ...
   71:  jump *label15 greaterThanEq .polys .polyTarget               elsif polys < polyTarget then
   72:  set .factoryUnit null                                        factoryUnit = reconstructor.@payloadType == null ? @mono : null;
   73:  sensor *tmp49 .reconstructor @payloadType                    ...
   74:  jump *label18 notEqual *tmp49 null                           ...
   75:  set .factoryUnit @mono                                       ...
        label *label18                                               ...
   76:  set .targetUnit @poly                                        displayNextUnit = targetUnit = @poly;
   77:  write @poly .display ".displayNextUnit"                      ...
   78:  control enabled .reconstructor true 0 0 0                    reconstructor.enabled = true;
   79:  jump *label16 always 0 0                                     elsif polys < polyTarget then
        label *label15                                               ...
   80:  jump *label19 greaterThanEq .megas .megaTarget               elsif megas < megaTarget then
   81:  set .factoryUnit null                                        factoryUnit = multiReconstructor.@payloadType == null ? @mono : null;
   82:  sensor *tmp56 .multiReconstructor @payloadType               ...
   83:  jump *label22 notEqual *tmp56 null                           ...
   84:  set .factoryUnit @mono                                       ...
        label *label22                                               ...
   85:  set .targetUnit @mega                                        displayNextUnit = targetUnit = @mega;
   86:  write @mega .display ".displayNextUnit"                      ...
   87:  control enabled .reconstructor .multiReconstructor 0 0 0     reconstructor.enabled = multiReconstructor;
   88:  jump *label20 always 0 0                                     elsif megas < megaTarget then
        label *label19                                               ...
   89:  set .factoryUnit null                                        displayNextUnit = targetUnit = factoryUnit = null;
   90:  set .targetUnit null                                         ...
   91:  write null .display ".displayNextUnit"                       ...
        label *label20                                               elsif megas < megaTarget then
        label *label16                                               elsif polys < polyTarget then
        label *label14                                               elsif monos < monoTarget then
        label *label12                                               if flares < flareTarget then
   92:  control config .payloadRouter .targetUnit 0 0 0              payloadRouter.config = targetUnit;
   93:  select :backgroundProcess:enableFactory lessThan :background mlogSafe("select", out value, "lessThan", in a, in b, in newValue, in value);
   94:  select :backgroundProcess:enableFactory lessThan 500 :backgr ...
   95:  jump *label26 notEqual .factoryUnit null                     if factoryUnit == null then
   96:  control enabled .factory false 0 0 0                         factory.enabled = false;
   97:  control config .factory @mono 0 0 0                          factory.config = @mono;
   98:  set :backgroundProcess:lastProgress 0                        lastProgress = 0;
   99:  jump *label27 always 0 0                                     if factoryUnit == null then
        label *label26                                               ...
  100:  op add *tmp74 :backgroundProcess:factoryProgress 0.1         elsif lastProgress > factoryProgress + 0.1 then
  101:  jump *label28 lessThanEq :backgroundProcess:lastProgress *tm ...
  102:  control enabled .factory :backgroundProcess:enableFactory 0  factory.enabled = enableFactory;
  103:  set :factoryUnitFinished:unit .factoryUnit                   factoryUnitFinished(factoryUnit);
  104:  jump *label71 notEqual :factoryUnitFinished:unit .targetUnit if unit == targetUnit then
  105:  sensor *tmp120 :factoryUnitFinished:unit @id                 log(@blockCount + unit.@id);
  106:  op add :log:encodedId @blockCount *tmp120                    ...
  107:  read *tmp6 .bank 511                                         bank[--logPosition] = encodedId + floor(@second * 1000) * 1000;
  108:  op sub *tmp122 *tmp6 1                                       ...
  109:  write *tmp122 .bank 511                                      ...
  110:  op idiv *tmp126 @second 0.001                                ...
  111:  op mul *tmp127 *tmp126 1000                                  ...
  112:  op add *tmp128 :log:encodedId *tmp127                        ...
  113:  write *tmp128 .bank *tmp122                                  ...
  114:  jump *label63 notEqual :factoryUnitFinished:unit @flare      case unit
  115:  op add *tmp131 .flares 1                                     when @flare then displayFlares = ++flares;
  116:  set .flares *tmp131                                          ...
  117:  write *tmp131 .display ".displayFlares"                      ...
  118:  jump *label70 always 0 0                                     case unit
        label *label63                                               ...
  119:  jump *label65 notEqual :factoryUnitFinished:unit @mono       ...
  120:  op add *tmp132 .monos 1                                      when @mono  then displayMonos = ++monos;
  121:  set .monos *tmp132                                           ...
  122:  write *tmp132 .display ".displayMonos"                       ...
  123:  jump *label70 always 0 0                                     case unit
        label *label65                                               ...
  124:  jump *label67 notEqual :factoryUnitFinished:unit @poly       ...
  125:  op add *tmp133 .polys 1                                      when @poly  then displayPolys = ++polys;
  126:  set .polys *tmp133                                           ...
  127:  write *tmp133 .display ".displayPolys"                       ...
  128:  jump *label70 always 0 0                                     case unit
        label *label67                                               ...
  129:  jump *label69 notEqual :factoryUnitFinished:unit @mega       ...
  130:  op add *tmp134 .megas 1                                      when @mega  then displayMegas = ++megas;
  131:  set .megas *tmp134                                           ...
  132:  write *tmp134 .display ".displayMegas"                       ...
        label *label69                                               case unit
        label *label70                                               ...
  133:  write true .display ".displayUnitReset"                      displayUnitReset = true;
        label *label71                                               if unit == targetUnit then
  134:  set :backgroundProcess:lastProgress 0                        lastProgress = 0;
  135:  jump *label29 always 0 0                                     elsif lastProgress > factoryProgress + 0.1 then
        label *label28                                               ...
  136:  sensor *tmp80 .factory @config                               elsif factory.config != factoryUnit then
  137:  jump *label31 equal *tmp80 .factoryUnit                      ...
  138:  control enabled .factory :backgroundProcess:enableFactory 0  factory.enabled = enableFactory;
  139:  control config .factory .factoryUnit 0 0 0                   factory.config = factoryUnit;
  140:  set :backgroundProcess:lastProgress 0                        lastProgress = 0;
  141:  jump *label32 always 0 0                                     elsif factory.config != factoryUnit then
        label *label31                                               ...
  142:  control enabled .factory :backgroundProcess:enableFactory 0  factory.enabled = enableFactory;
  143:  set :backgroundProcess:lastProgress :backgroundProcess:facto lastProgress = factoryProgress;
        label *label32                                               elsif factory.config != factoryUnit then
        label *label29                                               elsif lastProgress > factoryProgress + 0.1 then
        label *label27                                               if factoryUnit == null then
  144:  op add *tmp90 :backgroundProcess:reconstructorProgress 0.1   if lastRecoProgress > reconstructorProgress + 0.1 then
  145:  jump *label33 lessThanEq :backgroundProcess:lastRecoProgress ...
  146:  jump *label86 notEqual @poly .targetUnit                     if unit == targetUnit then
  147:  op add :log:encodedId @blockCount 21                         log(@blockCount + unit.@id);
  148:  read *tmp6 .bank 511                                         bank[--logPosition] = encodedId + floor(@second * 1000) * 1000;
  149:  op sub *tmp122 *tmp6 1                                       ...
  150:  write *tmp122 .bank 511                                      ...
  151:  op idiv *tmp126 @second 0.001                                ...
  152:  op mul *tmp127 *tmp126 1000                                  ...
  153:  op add *tmp128 :log:encodedId *tmp127                        ...
  154:  write *tmp128 .bank *tmp122                                  ...
  155:  op add *tmp133 .polys 1                                      when @poly  then displayPolys = ++polys;
  156:  set .polys *tmp133                                           ...
  157:  write *tmp133 .display ".displayPolys"                       ...
  158:  write true .display ".displayUnitReset"                      displayUnitReset = true;
        label *label86                                               if unit == targetUnit then
  159:  set :backgroundProcess:lastRecoProgress 0                    lastRecoProgress = 0;
  160:  jump *label34 always 0 0                                     if lastRecoProgress > reconstructorProgress + 0.1 then
        label *label33                                               ...
  161:  set :backgroundProcess:lastRecoProgress :backgroundProcess:r lastRecoProgress = reconstructorProgress;
        label *label34                                               if lastRecoProgress > reconstructorProgress + 0.1 then
  162:  op add *tmp93 :backgroundProcess:multiReconstructorProgress  if lastMultiProgress > multiReconstructorProgress + 0.1 then
  163:  jump *label36 lessThanEq :backgroundProcess:lastMultiProgres ...
  164:  jump *label101 notEqual @mega .targetUnit                    if unit == targetUnit then
  165:  op add :log:encodedId @blockCount 22                         log(@blockCount + unit.@id);
  166:  read *tmp6 .bank 511                                         bank[--logPosition] = encodedId + floor(@second * 1000) * 1000;
  167:  op sub *tmp122 *tmp6 1                                       ...
  168:  write *tmp122 .bank 511                                      ...
  169:  op idiv *tmp126 @second 0.001                                ...
  170:  op mul *tmp127 *tmp126 1000                                  ...
  171:  op add *tmp128 :log:encodedId *tmp127                        ...
  172:  write *tmp128 .bank *tmp122                                  ...
  173:  op add *tmp134 .megas 1                                      when @mega  then displayMegas = ++megas;
  174:  set .megas *tmp134                                           ...
  175:  write *tmp134 .display ".displayMegas"                       ...
  176:  write true .display ".displayUnitReset"                      displayUnitReset = true;
        label *label101                                              if unit == targetUnit then
  177:  set :backgroundProcess:lastMultiProgress 0                   lastMultiProgress = 0;
  178:  jump *label37 always 0 0                                     if lastMultiProgress > multiReconstructorProgress + 0.1 then
        label *label36                                               ...
  179:  set :backgroundProcess:lastMultiProgress :backgroundProcess: lastMultiProgress = multiReconstructorProgress;
        label *label37                                               if lastMultiProgress > multiReconstructorProgress + 0.1 then
  180:  sensor *tmp96 .generator2 @coal                              if generator2.@coal < 5 * generator2 then
  181:  op mul *tmp97 5 .generator2                                  ...
  182:  jump *label39 greaterThanEq *tmp96 *tmp97                    ...
  183:  control config .unloader2 @coal 0 0 0                        unloader2.config = @coal;
  184:  jump *label4 always 0 0                                      continue;
        label *label39                                               if generator2.@coal < 5 * generator2 then
  185:  op equal *tmp102 .factoryUnit @mono                          var leadLimit = (factoryUnit == @mono) * 30;
  186:  op mul :backgroundProcess:leadLimit *tmp102 30               ...
  187:  sensor *tmp104 .factory @lead                                if factory.@lead < leadLimit and core.@lead > leadReserve then
  188:  op lessThan *tmp105 *tmp104 :backgroundProcess:leadLimit     ...
  189:  sensor *tmp106 .core @lead                                   ...
  190:  op greaterThan *tmp107 *tmp106 .leadReserve                  ...
  191:  op land *tmp108 *tmp105 *tmp107                              ...
  192:  jump *label41 equal *tmp108 false                            ...
  193:  control config .unloader2 @lead 0 0 0                        unloader2.config = @lead;
  194:  jump *label4 always 0 0                                      if factory.@lead < leadLimit and core.@lead > leadReserve then
        label *label41                                               ...
  195:  jump *label43 lessThanEq :backgroundProcess:coreSilicon .sil elsif coreSilicon > siliconReserve then
  196:  control config .unloader2 @silicon 0 0 0                     unloader2.config = @silicon;
  197:  jump *label4 always 0 0                                      elsif coreSilicon > siliconReserve then
        label *label43                                               ...
  198:  control config .unloader2 @coal 0 0 0                        unloader2.config = @coal;
  199:  jump *label4 always 0 0                                      while true do


Performance: parsed in 239 ms, compiled in 247 ms, optimized in 450 ms, run in 15 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (18 steps):
The program didn't generate any output.
Execution exception at instruction 25: sensor :backgroundProcess:coreSilicon .core @silicon:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
