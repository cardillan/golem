   228 instructions before optimizations.
    21 instructions eliminated by Temp Variables Elimination (3 iterations).
     1 instructions eliminated by Case Expression Optimization.
    31 instructions eliminated by Dead Code Elimination (6 iterations).
     2 instructions eliminated by Jump Normalization (2 passes, 5 iterations).
    11 instructions eliminated by Jump Optimization (5 iterations).
     5 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     1 instructions modified by Expression Optimization (3 iterations).
     1 instructions eliminated by If Expression Optimization (3 iterations).
    18 instructions eliminated by Data Flow Optimization (3 passes, 11 iterations).
    19 instructions added by Function Inlining (4 iterations).
     2 function calls inlined by Function Inlining.
     3 instructions eliminated by Jump Straightening (5 iterations).
     4 instructions updated by JumpThreading.
    10 instructions eliminated by Unreachable Code Elimination (2 iterations).
   144 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 858):
  * Inline function 'factoryUnitFinished' defined at CoreController.mnd:61:1 size   +23, benefit       65.6, efficiency      2.853 (+18 instructions)
    Inline function call at CoreController.mnd:125:13            size   +24, benefit       21.9, efficiency      0.911
    Inline function call at CoreController.mnd:137:13            size   +24, benefit       43.8, efficiency      1.823
C:\Home\golem\jam-202507\common.mnd:1:7 Variable 'TIME_COMPRESS' is not initialized.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   235 write *tmp104 .bank *tmp99
   236 label *label40
   237 label *label39
-    * set *tmp106 :factoryUnitFinished:unit
-    * jump *label44 equal *tmp106 @flare
+  238 jump *label44 equal :factoryUnitFinished:unit @flare
   239 jump *label43 always
   240 label *label44
   241 op add *tmp107 .flares 1
 
   244 set *tmp105 *tmp107
   245 jump *label42 always
   246 label *label43
-    * jump *label46 equal *tmp106 @mono
+  247 jump *label46 equal :factoryUnitFinished:unit @mono
   248 jump *label45 always
   249 label *label46
   250 op add *tmp108 .monos 1
 
   253 set *tmp105 *tmp108
   254 jump *label42 always
   255 label *label45
-    * jump *label48 equal *tmp106 @poly
+  256 jump *label48 equal :factoryUnitFinished:unit @poly
   257 jump *label47 always
   258 label *label48
   259 op add *tmp109 .polys 1

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-16 instructions):
 
    38 set *tmp25 .generator2
    39 op lessThan *tmp27 :backgroundProcess:power 3800
    40 control enabled *tmp25 *tmp27
-    * set *tmp22 *tmp27
    41 jump *label8 always
    42 label *label7
    43 set *tmp28 .generator
    44 op lessThan *tmp30 :backgroundProcess:power 800
    45 control enabled *tmp28 *tmp30
-    * set *tmp22 *tmp30
    46 label *label8
    47 sensor *tmp31 .factory @progress
    48 set :backgroundProcess:factoryProgress *tmp31
 
    53 set .factoryUnit @flare
    54 set .targetUnit @flare
    55 write @flare .display ".displayNextUnit"
-    * set *tmp34 @flare
    56 jump *label10 always
    57 label *label9
    58 op lessThan *tmp35 .monos .monoTarget
 
    86 label *label14
    87 set *tmp36 *tmp38
    88 label *label12
-    * set *tmp34 *tmp36
    89 label *label10
    90 set *tmp42 .payloadRouter
    91 set *tmp44 .targetUnit
 
    97 set :updateIfSmaller:b :fuzzyUpdate:limitLow
    98 set :updateIfSmaller:newValue false
    99 select :backgroundProcess:enableFactory lessThan :updateIfSmaller:a :updateIfSmaller:b :updateIfSmaller:newValue :backgroundProcess:enableFactory
-    * set *tmp46 null
   100 label *label18
   101 set :updateIfSmaller.1:a :fuzzyUpdate:limitHigh
   102 set :updateIfSmaller.1:b :fuzzyUpdate:value
 
   104 select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
   105 set *tmp47 null
   106 label *label19
-    * set *tmp45 *tmp47
   107 label *label17
   108 op equal *tmp48 .factoryUnit null
   109 jump *label20 equal *tmp48 false
 
   112 set *tmp52 .factory
   113 control config *tmp52 @mono
   114 set :backgroundProcess:lastProgress 0
-    * set *tmp49 :backgroundProcess:lastProgress
   115 jump *label21 always
   116 label *label20
   117 op add *tmp54 :backgroundProcess:factoryProgress 0.1
 
   147 label *label26
   148 set *tmp56 *tmp62
   149 label *label23
-    * set *tmp49 *tmp56
   150 label *label21
   151 op add *tmp70 :backgroundProcess:reconstructorProgress 0.1
   152 op greaterThan *tmp71 :backgroundProcess:lastRecoProgress *tmp70
 
   156 call *label0 *invalid :factoryUnitFinished*retval (m:*label29) (h:*label29)
   157 label *label29
   158 set :backgroundProcess:lastRecoProgress 0
-    * set *tmp72 :backgroundProcess:lastRecoProgress
   159 jump *label28 always
   160 label *label27
   161 set :backgroundProcess:lastRecoProgress :backgroundProcess:reconstructorProgress
-    * set *tmp72 :backgroundProcess:lastRecoProgress
   162 label *label28
   163 sensor *tmp73 .generator2 @coal
   164 op lessThan *tmp74 *tmp73 .generator2
 
   166 set *tmp76 .unloader2
   167 control config *tmp76 @coal
   168 jump *label5 always
-    * set *tmp75 null
   169 jump *label31 always
   170 label *label30
-    * set *tmp75 null
   171 label *label31
   172 op equal *tmp78 .factoryUnit @mono
   173 op mul *tmp79 *tmp78 30
 
   180 jump *label32 equal *tmp84 false
   181 set *tmp86 .unloader2
   182 control config *tmp86 @lead
-    * set *tmp85 @lead
   183 jump *label33 always
   184 label *label32
   185 op greaterThan *tmp88 :backgroundProcess:coreSilicon .siliconReserve
 
   193 control config *tmp92 @coal
   194 set *tmp89 @coal
   195 label *label35
-    * set *tmp85 *tmp89
   196 label *label33
   197 label *label5
   198 jump *label4 always
 
   250 label *label47
   251 set *tmp105 null
   252 label *label42
-    * set *tmp95 *tmp105
   253 jump *label38 always
   254 label *label37
-    * set *tmp95 null
   255 label *label38
   256 label *label36
   257 return :factoryUnitFinished*retaddr

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-11 instructions):
 
    60 set .factoryUnit @mono
    61 set .targetUnit @mono
    62 write @mono .display ".displayNextUnit"
-    * set *tmp36 @mono
    63 jump *label12 always
    64 label *label11
    65 op lessThan *tmp37 .polys .polyTarget
 
    83 write null .display ".displayNextUnit"
    84 set *tmp38 null
    85 label *label14
-    * set *tmp36 *tmp38
    86 label *label12
    87 label *label10
    88 set *tmp42 .payloadRouter
 
   100 set :updateIfSmaller.1:b :fuzzyUpdate:value
   101 set :updateIfSmaller.1:newValue true
   102 select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
-    * set *tmp47 null
   103 label *label19
   104 label *label17
   105 op equal *tmp48 .factoryUnit null
 
   121 call *label0 *invalid :factoryUnitFinished*retval (m:*label24) (h:*label24)
   122 label *label24
   123 set :backgroundProcess:lastProgress 0
-    * set *tmp56 :backgroundProcess:lastProgress
   124 jump *label23 always
   125 label *label22
   126 set *tmp59 .factory
 
   141 set :backgroundProcess:lastProgress :backgroundProcess:factoryProgress
   142 set *tmp62 :backgroundProcess:lastProgress
   143 label *label26
-    * set *tmp56 *tmp62
   144 label *label23
   145 label *label21
   146 op add *tmp70 :backgroundProcess:reconstructorProgress 0.1
 
   181 jump *label34 equal *tmp88 false
   182 set *tmp90 .unloader2
   183 control config *tmp90 @silicon
-    * set *tmp89 @silicon
   184 jump *label35 always
   185 label *label34
   186 set *tmp92 .unloader2
   187 control config *tmp92 @coal
-    * set *tmp89 @coal
   188 label *label35
   189 label *label33
   190 label *label5
 
   220 op add *tmp107 .flares 1
   221 set .flares *tmp107
   222 write *tmp107 .display ".displayFlares"
-    * set *tmp105 *tmp107
   223 jump *label42 always
   224 label *label43
   225 jump *label46 equal :factoryUnitFinished:unit @mono
 
   228 op add *tmp108 .monos 1
   229 set .monos *tmp108
   230 write *tmp108 .display ".displayMonos"
-    * set *tmp105 *tmp108
   231 jump *label42 always
   232 label *label45
   233 jump *label48 equal :factoryUnitFinished:unit @poly
 
   236 op add *tmp109 .polys 1
   237 set .polys *tmp109
   238 write *tmp109 .display ".displayPolys"
-    * set *tmp105 *tmp109
   239 jump *label42 always
   240 label *label47
-    * set *tmp105 null
   241 label *label42
   242 jump *label38 always
   243 label *label37

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
    75 set .factoryUnit *tmp41
    76 set .targetUnit @poly
    77 write @poly .display ".displayNextUnit"
-    * set *tmp38 @poly
    78 jump *label14 always
    79 label *label13
    80 set .factoryUnit null
    81 set .targetUnit null
    82 write null .display ".displayNextUnit"
-    * set *tmp38 null
    83 label *label14
    84 label *label12
    85 label *label10
 
   131 set *tmp67 .factoryUnit
   132 control config *tmp65 *tmp67
   133 set :backgroundProcess:lastProgress 0
-    * set *tmp62 :backgroundProcess:lastProgress
   134 jump *label26 always
   135 label *label25
   136 set *tmp68 .factory
   137 control enabled *tmp68 :backgroundProcess:enableFactory
   138 set :backgroundProcess:lastProgress :backgroundProcess:factoryProgress
-    * set *tmp62 :backgroundProcess:lastProgress
   139 label *label26
   140 label *label23
   141 label *label21

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-19 instructions):
 
    13 set :backgroundProcess:enableFactory true
    14 label *label4
    15 jump *label6 equal true false
-    * sensor *tmp5 .core @silicon
-    * set :backgroundProcess:coreSilicon *tmp5
+   16 sensor :backgroundProcess:coreSilicon .core @silicon
    17 set *tmp6 .smelter
    18 op lessThan *tmp8 :backgroundProcess:coreSilicon .smelterTarget
    19 control enabled *tmp6 *tmp8
 
    29 sensor *tmp19 .core @metaglass
    30 op lessThan *tmp20 *tmp19 .kilnTarget
    31 control enabled *tmp17 *tmp20
-    * sensor *tmp21 .battery @totalPower
-    * set :backgroundProcess:power *tmp21
+   32 sensor :backgroundProcess:power .battery @totalPower
    33 jump *label7 equal .generator2 false
-    * set *tmp23 .generator
-    * control enabled *tmp23 false
+   34 control enabled .generator false
    35 set *tmp25 .generator2
    36 op lessThan *tmp27 :backgroundProcess:power 3800
    37 control enabled *tmp25 *tmp27
 
    41 op lessThan *tmp30 :backgroundProcess:power 800
    42 control enabled *tmp28 *tmp30
    43 label *label8
-    * sensor *tmp31 .factory @progress
-    * set :backgroundProcess:factoryProgress *tmp31
-    * sensor *tmp32 .reconstructor @progress
-    * set :backgroundProcess:reconstructorProgress *tmp32
+   44 sensor :backgroundProcess:factoryProgress .factory @progress
+   45 sensor :backgroundProcess:reconstructorProgress .reconstructor @progress
    46 op lessThan *tmp33 .flares .flareTarget
    47 jump *label9 equal *tmp33 false
    48 set .factoryUnit @flare
 
    79 label *label12
    80 label *label10
    81 set *tmp42 .payloadRouter
-    * set *tmp44 .targetUnit
-    * control config *tmp42 *tmp44
+   82 control config *tmp42 .targetUnit
    83 set :fuzzyUpdate:value :backgroundProcess:power
    84 set :fuzzyUpdate:limitLow 200
    85 set :fuzzyUpdate:limitHigh 500
 
    96 label *label17
    97 op equal *tmp48 .factoryUnit null
    98 jump *label20 equal *tmp48 false
-    * set *tmp50 .factory
-    * control enabled *tmp50 false
-    * set *tmp52 .factory
-    * control config *tmp52 @mono
+   99 control enabled .factory false
+  100 control config .factory @mono
   101 set :backgroundProcess:lastProgress 0
   102 jump *label21 always
   103 label *label20
   104 op add *tmp54 :backgroundProcess:factoryProgress 0.1
   105 op greaterThan *tmp55 :backgroundProcess:lastProgress *tmp54
   106 jump *label22 equal *tmp55 false
-    * set *tmp57 .factory
-    * control enabled *tmp57 :backgroundProcess:enableFactory
+  107 control enabled .factory :backgroundProcess:enableFactory
   108 set :factoryUnitFinished:unit .factoryUnit
   109 setaddr :factoryUnitFinished*retaddr *label24 (h:*label24)
   110 call *label0 *invalid :factoryUnitFinished*retval (m:*label24) (h:*label24)
 
   112 set :backgroundProcess:lastProgress 0
   113 jump *label23 always
   114 label *label22
-    * set *tmp59 .factory
-    * sensor *tmp60 *tmp59 @config
+  115 sensor *tmp60 .factory @config
   116 op notEqual *tmp61 *tmp60 .factoryUnit
   117 jump *label25 equal *tmp61 false
-    * set *tmp63 .factory
-    * control enabled *tmp63 :backgroundProcess:enableFactory
+  118 control enabled .factory :backgroundProcess:enableFactory
   119 set *tmp65 .factory
-    * set *tmp67 .factoryUnit
-    * control config *tmp65 *tmp67
+  120 control config *tmp65 .factoryUnit
   121 set :backgroundProcess:lastProgress 0
   122 jump *label26 always
   123 label *label25
-    * set *tmp68 .factory
-    * control enabled *tmp68 :backgroundProcess:enableFactory
+  124 control enabled .factory :backgroundProcess:enableFactory
   125 set :backgroundProcess:lastProgress :backgroundProcess:factoryProgress
   126 label *label26
   127 label *label23
 
   141 sensor *tmp73 .generator2 @coal
   142 op lessThan *tmp74 *tmp73 .generator2
   143 jump *label30 equal *tmp74 false
-    * set *tmp76 .unloader2
-    * control config *tmp76 @coal
+  144 control config .unloader2 @coal
   145 jump *label5 always
   146 jump *label31 always
   147 label *label30
   148 label *label31
   149 op equal *tmp78 .factoryUnit @mono
-    * op mul *tmp79 *tmp78 30
-    * set :backgroundProcess:leadLimit *tmp79
+  150 op mul :backgroundProcess:leadLimit *tmp78 30
   151 sensor *tmp80 .factory @lead
   152 op lessThan *tmp81 *tmp80 :backgroundProcess:leadLimit
   153 sensor *tmp82 .core @lead
   154 op greaterThan *tmp83 *tmp82 .leadReserve
   155 op land *tmp84 *tmp81 *tmp83
   156 jump *label32 equal *tmp84 false
-    * set *tmp86 .unloader2
-    * control config *tmp86 @lead
+  157 control config .unloader2 @lead
   158 jump *label33 always
   159 label *label32
   160 op greaterThan *tmp88 :backgroundProcess:coreSilicon .siliconReserve
   161 jump *label34 equal *tmp88 false
-    * set *tmp90 .unloader2
-    * control config *tmp90 @silicon
+  162 control config .unloader2 @silicon
   163 jump *label35 always
   164 label *label34
-    * set *tmp92 .unloader2
-    * control config *tmp92 @coal
+  165 control config .unloader2 @coal
   166 label *label35
   167 label *label33
   168 label *label5
 
   177 jump *label37 equal *tmp94 false
   178 set :logUnit:unit :factoryUnitFinished:unit
   179 sensor *tmp96 :logUnit:unit @id
-    * op add *tmp97 @blockCount *tmp96
-    * set :log:encodedId *tmp97
+  180 op add :log:encodedId @blockCount *tmp96
   181 read *tmp4 .bank 511
   182 op sub *tmp98 *tmp4 1
   183 write *tmp98 .bank 511

Modifications by Initial phase, Temp Variables Elimination, iteration 2 (-2 instructions):
 
    78 label *label14
    79 label *label12
    80 label *label10
-    * set *tmp42 .payloadRouter
-    * control config *tmp42 .targetUnit
+   81 control config .payloadRouter .targetUnit
    82 set :fuzzyUpdate:value :backgroundProcess:power
    83 set :fuzzyUpdate:limitLow 200
    84 set :fuzzyUpdate:limitHigh 500
 
   115 op notEqual *tmp61 *tmp60 .factoryUnit
   116 jump *label25 equal *tmp61 false
   117 control enabled .factory :backgroundProcess:enableFactory
-    * set *tmp65 .factory
-    * control config *tmp65 .factoryUnit
+  118 control config .factory .factoryUnit
   119 set :backgroundProcess:lastProgress 0
   120 jump *label26 always
   121 label *label25

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    12 set :backgroundProcess:reconstructorProgress 0
    13 set :backgroundProcess:enableFactory true
    14 label *label4
-    * jump *label6 equal true false
    15 sensor :backgroundProcess:coreSilicon .core @silicon
    16 set *tmp6 .smelter
    17 op lessThan *tmp8 :backgroundProcess:coreSilicon .smelterTarget

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   188 write *tmp104 .bank *tmp99
   189 label *label40
   190 label *label39
-    * jump *label44 equal :factoryUnitFinished:unit @flare
-    * jump *label43 always
+  191 jump *label43 notEqual :factoryUnitFinished:unit @flare
   192 label *label44
   193 op add *tmp107 .flares 1
   194 set .flares *tmp107
   195 write *tmp107 .display ".displayFlares"
   196 jump *label42 always
   197 label *label43
-    * jump *label46 equal :factoryUnitFinished:unit @mono
-    * jump *label45 always
+  198 jump *label45 notEqual :factoryUnitFinished:unit @mono
   199 label *label46
   200 op add *tmp108 .monos 1
   201 set .monos *tmp108
   202 write *tmp108 .display ".displayMonos"
   203 jump *label42 always
   204 label *label45
-    * jump *label48 equal :factoryUnitFinished:unit @poly
-    * jump *label47 always
+  205 jump *label47 notEqual :factoryUnitFinished:unit @poly
   206 label *label48
   207 op add *tmp109 .polys 1
   208 set .polys *tmp109

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-11 instructions):
 
    42 label *label8
    43 sensor :backgroundProcess:factoryProgress .factory @progress
    44 sensor :backgroundProcess:reconstructorProgress .reconstructor @progress
-    * op lessThan *tmp33 .flares .flareTarget
-    * jump *label9 equal *tmp33 false
+   45 jump *label9 greaterThanEq .flares .flareTarget
    46 set .factoryUnit @flare
    47 set .targetUnit @flare
    48 write @flare .display ".displayNextUnit"
    49 jump *label10 always
    50 label *label9
-    * op lessThan *tmp35 .monos .monoTarget
-    * jump *label11 equal *tmp35 false
+   51 jump *label11 greaterThanEq .monos .monoTarget
    52 set .factoryUnit @mono
    53 set .targetUnit @mono
    54 write @mono .display ".displayNextUnit"
    55 jump *label12 always
    56 label *label11
-    * op lessThan *tmp37 .polys .polyTarget
-    * jump *label13 equal *tmp37 false
+   57 jump *label13 greaterThanEq .polys .polyTarget
    58 sensor *tmp39 .reconstructor @payloadType
-    * op equal *tmp40 *tmp39 null
-    * jump *label15 equal *tmp40 false
+   59 jump *label15 notEqual *tmp39 null
    60 set *tmp41 @mono
    61 jump *label16 always
    62 label *label15
 
    88 select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
    89 label *label19
    90 label *label17
-    * op equal *tmp48 .factoryUnit null
-    * jump *label20 equal *tmp48 false
+   91 jump *label20 notEqual .factoryUnit null
    92 control enabled .factory false
    93 control config .factory @mono
    94 set :backgroundProcess:lastProgress 0
    95 jump *label21 always
    96 label *label20
    97 op add *tmp54 :backgroundProcess:factoryProgress 0.1
-    * op greaterThan *tmp55 :backgroundProcess:lastProgress *tmp54
-    * jump *label22 equal *tmp55 false
+   98 jump *label22 lessThanEq :backgroundProcess:lastProgress *tmp54
    99 control enabled .factory :backgroundProcess:enableFactory
   100 set :factoryUnitFinished:unit .factoryUnit
   101 setaddr :factoryUnitFinished*retaddr *label24 (h:*label24)
 
   105 jump *label23 always
   106 label *label22
   107 sensor *tmp60 .factory @config
-    * op notEqual *tmp61 *tmp60 .factoryUnit
-    * jump *label25 equal *tmp61 false
+  108 jump *label25 equal *tmp60 .factoryUnit
   109 control enabled .factory :backgroundProcess:enableFactory
   110 control config .factory .factoryUnit
   111 set :backgroundProcess:lastProgress 0
 
   117 label *label23
   118 label *label21
   119 op add *tmp70 :backgroundProcess:reconstructorProgress 0.1
-    * op greaterThan *tmp71 :backgroundProcess:lastRecoProgress *tmp70
-    * jump *label27 equal *tmp71 false
+  120 jump *label27 lessThanEq :backgroundProcess:lastRecoProgress *tmp70
   121 set :factoryUnitFinished:unit @poly
   122 setaddr :factoryUnitFinished*retaddr *label29 (h:*label29)
   123 call *label0 *invalid :factoryUnitFinished*retval (m:*label29) (h:*label29)
 
   128 set :backgroundProcess:lastRecoProgress :backgroundProcess:reconstructorProgress
   129 label *label28
   130 sensor *tmp73 .generator2 @coal
-    * op lessThan *tmp74 *tmp73 .generator2
-    * jump *label30 equal *tmp74 false
+  131 jump *label30 greaterThanEq *tmp73 .generator2
   132 control config .unloader2 @coal
   133 jump *label5 always
   134 jump *label31 always
 
   145 control config .unloader2 @lead
   146 jump *label33 always
   147 label *label32
-    * op greaterThan *tmp88 :backgroundProcess:coreSilicon .siliconReserve
-    * jump *label34 equal *tmp88 false
+  148 jump *label34 lessThanEq :backgroundProcess:coreSilicon .siliconReserve
   149 control config .unloader2 @silicon
   150 jump *label35 always
   151 label *label34
 
   160 jump *label2 always
   161 end
   162 label *label0
-    * op equal *tmp94 :factoryUnitFinished:unit .targetUnit
-    * jump *label37 equal *tmp94 false
+  163 jump *label37 notEqual :factoryUnitFinished:unit .targetUnit
   164 set :logUnit:unit :factoryUnitFinished:unit
   165 sensor *tmp96 :logUnit:unit @id
   166 op add :log:encodedId @blockCount *tmp96

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-3 instructions):
 
   131 jump *label30 greaterThanEq *tmp73 .generator2
   132 control config .unloader2 @coal
   133 jump *label5 always
-    * jump *label31 always
   134 label *label30
   135 label *label31
   136 op equal *tmp78 .factoryUnit @mono
 
   195 op add *tmp109 .polys 1
   196 set .polys *tmp109
   197 write *tmp109 .display ".displayPolys"
-    * jump *label42 always
   198 label *label47
   199 label *label42
-    * jump *label38 always
   200 label *label37
   201 label *label38
   202 label *label36

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
     7 set *signature "0:v1"
     8 label *label2
     9 set :backgroundProcess:lastProgress 0
-    * set :backgroundProcess:factoryProgress 0
    10 set :backgroundProcess:lastRecoProgress 0
-    * set :backgroundProcess:reconstructorProgress 0
    11 set :backgroundProcess:enableFactory true
    12 label *label4
    13 sensor :backgroundProcess:coreSilicon .core @silicon
 
    75 set :fuzzyUpdate:value :backgroundProcess:power
    76 set :fuzzyUpdate:limitLow 200
    77 set :fuzzyUpdate:limitHigh 500
-    * set :updateIfSmaller:a :fuzzyUpdate:value
-    * set :updateIfSmaller:b :fuzzyUpdate:limitLow
+   78 set :updateIfSmaller:a :backgroundProcess:power
+   79 set :updateIfSmaller:b 200
    80 set :updateIfSmaller:newValue false
-    * select :backgroundProcess:enableFactory lessThan :updateIfSmaller:a :updateIfSmaller:b :updateIfSmaller:newValue :backgroundProcess:enableFactory
+   81 select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:value :fuzzyUpdate:limitLow false :backgroundProcess:enableFactory
    82 label *label18
-    * set :updateIfSmaller.1:a :fuzzyUpdate:limitHigh
-    * set :updateIfSmaller.1:b :fuzzyUpdate:value
+   83 set :updateIfSmaller.1:a 500
+   84 set :updateIfSmaller.1:b :backgroundProcess:power
    85 set :updateIfSmaller.1:newValue true
-    * select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
+   86 select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:limitHigh :fuzzyUpdate:value true :backgroundProcess:enableFactory
    87 label *label19
    88 label *label17
    89 jump *label20 notEqual .factoryUnit null
 
   159 label *label0
   160 jump *label37 notEqual :factoryUnitFinished:unit .targetUnit
   161 set :logUnit:unit :factoryUnitFinished:unit
-    * sensor *tmp96 :logUnit:unit @id
+  162 sensor *tmp96 :factoryUnitFinished:unit @id
   163 op add :log:encodedId @blockCount *tmp96
   164 read *tmp4 .bank 511
   165 op sub *tmp98 *tmp4 1
 
   168 op mul :second:result @second TIME_COMPRESS
   169 set *tmp101 :second:result
   170 label *label41
-    * op floor *tmp102 *tmp101
+  171 op floor *tmp102 :second:result
   172 op mul *tmp103 *tmp102 1000
   173 op add *tmp104 :log:encodedId *tmp103
-    * write *tmp104 .bank *tmp99
+  174 write *tmp104 .bank *tmp98
   175 label *label40
   176 label *label39
   177 jump *label43 notEqual :factoryUnitFinished:unit @flare

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-9 instructions):
 
    75 set :fuzzyUpdate:value :backgroundProcess:power
    76 set :fuzzyUpdate:limitLow 200
    77 set :fuzzyUpdate:limitHigh 500
-    * set :updateIfSmaller:a :backgroundProcess:power
-    * set :updateIfSmaller:b 200
-    * set :updateIfSmaller:newValue false
-    * select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:value :fuzzyUpdate:limitLow false :backgroundProcess:enableFactory
+   78 select :backgroundProcess:enableFactory lessThan :backgroundProcess:power 200 false :backgroundProcess:enableFactory
    79 label *label18
-    * set :updateIfSmaller.1:a 500
-    * set :updateIfSmaller.1:b :backgroundProcess:power
-    * set :updateIfSmaller.1:newValue true
-    * select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:limitHigh :fuzzyUpdate:value true :backgroundProcess:enableFactory
+   80 select :backgroundProcess:enableFactory lessThan 500 :backgroundProcess:power true :backgroundProcess:enableFactory
    81 label *label19
    82 label *label17
    83 jump *label20 notEqual .factoryUnit null
 
   152 end
   153 label *label0
   154 jump *label37 notEqual :factoryUnitFinished:unit .targetUnit
-    * set :logUnit:unit :factoryUnitFinished:unit
   155 sensor *tmp96 :factoryUnitFinished:unit @id
   156 op add :log:encodedId @blockCount *tmp96
   157 read *tmp4 .bank 511
   158 op sub *tmp98 *tmp4 1
   159 write *tmp98 .bank 511
-    * set *tmp99 *tmp98
   160 op mul :second:result @second TIME_COMPRESS
-    * set *tmp101 :second:result
   161 label *label41
   162 op floor *tmp102 :second:result
   163 op mul *tmp103 *tmp102 1000

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
    72 label *label12
    73 label *label10
    74 control config .payloadRouter .targetUnit
-    * set :fuzzyUpdate:value :backgroundProcess:power
-    * set :fuzzyUpdate:limitLow 200
-    * set :fuzzyUpdate:limitHigh 500
    75 select :backgroundProcess:enableFactory lessThan :backgroundProcess:power 200 false :backgroundProcess:enableFactory
    76 label *label18
    77 select :backgroundProcess:enableFactory lessThan 500 :backgroundProcess:power true :backgroundProcess:enableFactory

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    53 jump *label12 always
    54 label *label11
    55 jump *label13 greaterThanEq .polys .polyTarget
+   56 set .factoryUnit null
    57 sensor *tmp39 .reconstructor @payloadType
-    * jump *label15 notEqual *tmp39 null
-    * set *tmp41 @mono
+   58 jump *label16 notEqual *tmp39 null
+   59 set .factoryUnit @mono
    60 jump *label16 always
-    * label *label15
-    * set *tmp41 null
    61 label *label16
-    * set .factoryUnit *tmp41
    62 set .targetUnit @poly
    63 write @poly .display ".displayNextUnit"
    64 jump *label14 always

Modifications by Inline function 'factoryUnitFinished' defined at CoreController.mnd:61:1 (+19 instructions):
 
    85 jump *label22 lessThanEq :backgroundProcess:lastProgress *tmp54
    86 control enabled .factory :backgroundProcess:enableFactory
    87 set :factoryUnitFinished:unit .factoryUnit
-    * setaddr :factoryUnitFinished*retaddr *label24 (h:*label24)
-    * call *label0 *invalid :factoryUnitFinished*retval (m:*label24) (h:*label24)
-    * label *label24
+   88 label *label49
+   89 jump *label60 notEqual :factoryUnitFinished:unit .targetUnit
+   90 sensor *tmp96 :factoryUnitFinished:unit @id
+   91 op add :log:encodedId @blockCount *tmp96
+   92 read *tmp4 .bank 511
+   93 op sub *tmp98 *tmp4 1
+   94 write *tmp98 .bank 511
+   95 op mul :second:result @second TIME_COMPRESS
+   96 label *label50
+   97 op floor *tmp102 :second:result
+   98 op mul *tmp103 *tmp102 1000
+   99 op add *tmp104 :log:encodedId *tmp103
+  100 write *tmp104 .bank *tmp98
+  101 label *label51
+  102 label *label52
+  103 jump *label54 notEqual :factoryUnitFinished:unit @flare
+  104 label *label53
+  105 op add *tmp107 .flares 1
+  106 set .flares *tmp107
+  107 write *tmp107 .display ".displayFlares"
+  108 jump *label59 always
+  109 label *label54
+  110 jump *label56 notEqual :factoryUnitFinished:unit @mono
+  111 label *label55
+  112 op add *tmp108 .monos 1
+  113 set .monos *tmp108
+  114 write *tmp108 .display ".displayMonos"
+  115 jump *label59 always
+  116 label *label56
+  117 jump *label58 notEqual :factoryUnitFinished:unit @poly
+  118 label *label57
+  119 op add *tmp109 .polys 1
+  120 set .polys *tmp109
+  121 write *tmp109 .display ".displayPolys"
+  122 label *label58
+  123 label *label59
+  124 label *label60
+  125 label *label61
+  126 label *label62
   127 set :backgroundProcess:lastProgress 0
   128 jump *label23 always
   129 label *label22
 
   142 op add *tmp70 :backgroundProcess:reconstructorProgress 0.1
   143 jump *label27 lessThanEq :backgroundProcess:lastRecoProgress *tmp70
   144 set :factoryUnitFinished:unit @poly
-    * setaddr :factoryUnitFinished*retaddr *label29 (h:*label29)
-    * call *label0 *invalid :factoryUnitFinished*retval (m:*label29) (h:*label29)
-    * label *label29
+  145 label *label63
+  146 jump *label74 notEqual :factoryUnitFinished:unit .targetUnit
+  147 sensor *tmp96 :factoryUnitFinished:unit @id
+  148 op add :log:encodedId @blockCount *tmp96
+  149 read *tmp4 .bank 511
+  150 op sub *tmp98 *tmp4 1
+  151 write *tmp98 .bank 511
+  152 op mul :second:result @second TIME_COMPRESS
+  153 label *label64
+  154 op floor *tmp102 :second:result
+  155 op mul *tmp103 *tmp102 1000
+  156 op add *tmp104 :log:encodedId *tmp103
+  157 write *tmp104 .bank *tmp98
+  158 label *label65
+  159 label *label66
+  160 jump *label68 notEqual :factoryUnitFinished:unit @flare
+  161 label *label67
+  162 op add *tmp107 .flares 1
+  163 set .flares *tmp107
+  164 write *tmp107 .display ".displayFlares"
+  165 jump *label73 always
+  166 label *label68
+  167 jump *label70 notEqual :factoryUnitFinished:unit @mono
+  168 label *label69
+  169 op add *tmp108 .monos 1
+  170 set .monos *tmp108
+  171 write *tmp108 .display ".displayMonos"
+  172 jump *label73 always
+  173 label *label70
+  174 jump *label72 notEqual :factoryUnitFinished:unit @poly
+  175 label *label71
+  176 op add *tmp109 .polys 1
+  177 set .polys *tmp109
+  178 write *tmp109 .display ".displayPolys"
+  179 label *label72
+  180 label *label73
+  181 label *label74
+  182 label *label75
+  183 label *label76
   184 set :backgroundProcess:lastRecoProgress 0
   185 jump *label28 always
   186 label *label27
 
   217 wait 1e12
   218 jump *label2 always
   219 end
-    * label *label0
-    * jump *label37 notEqual :factoryUnitFinished:unit .targetUnit
-    * sensor *tmp96 :factoryUnitFinished:unit @id
-    * op add :log:encodedId @blockCount *tmp96
-    * read *tmp4 .bank 511
-    * op sub *tmp98 *tmp4 1
-    * write *tmp98 .bank 511
-    * op mul :second:result @second TIME_COMPRESS
-    * label *label41
-    * op floor *tmp102 :second:result
-    * op mul *tmp103 *tmp102 1000
-    * op add *tmp104 :log:encodedId *tmp103
-    * write *tmp104 .bank *tmp98
-    * label *label40
-    * label *label39
-    * jump *label43 notEqual :factoryUnitFinished:unit @flare
-    * label *label44
-    * op add *tmp107 .flares 1
-    * set .flares *tmp107
-    * write *tmp107 .display ".displayFlares"
-    * jump *label42 always
-    * label *label43
-    * jump *label45 notEqual :factoryUnitFinished:unit @mono
-    * label *label46
-    * op add *tmp108 .monos 1
-    * set .monos *tmp108
-    * write *tmp108 .display ".displayMonos"
-    * jump *label42 always
-    * label *label45
-    * jump *label47 notEqual :factoryUnitFinished:unit @poly
-    * label *label48
-    * op add *tmp109 .polys 1
-    * set .polys *tmp109
-    * write *tmp109 .display ".displayPolys"
-    * label *label47
-    * label *label42
-    * label *label37
-    * label *label38
-    * label *label36
-    * return :factoryUnitFinished*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   143 jump *label27 lessThanEq :backgroundProcess:lastRecoProgress *tmp70
   144 set :factoryUnitFinished:unit @poly
   145 label *label63
-    * jump *label74 notEqual :factoryUnitFinished:unit .targetUnit
-    * sensor *tmp96 :factoryUnitFinished:unit @id
+  146 jump *label74 notEqual @poly .targetUnit
+  147 sensor *tmp96 @poly @id
   148 op add :log:encodedId @blockCount *tmp96
   149 read *tmp4 .bank 511
   150 op sub *tmp98 *tmp4 1
 
   157 write *tmp104 .bank *tmp98
   158 label *label65
   159 label *label66
-    * jump *label68 notEqual :factoryUnitFinished:unit @flare
+  160 jump *label68 notEqual @poly @flare
   161 label *label67
   162 op add *tmp107 .flares 1
   163 set .flares *tmp107
   164 write *tmp107 .display ".displayFlares"
   165 jump *label73 always
   166 label *label68
-    * jump *label70 notEqual :factoryUnitFinished:unit @mono
+  167 jump *label70 notEqual @poly @mono
   168 label *label69
   169 op add *tmp108 .monos 1
   170 set .monos *tmp108
   171 write *tmp108 .display ".displayMonos"
   172 jump *label73 always
   173 label *label70
-    * jump *label72 notEqual :factoryUnitFinished:unit @poly
+  174 jump *label72 notEqual @poly @poly
   175 label *label71
   176 op add *tmp109 .polys 1
   177 set .polys *tmp109

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   141 label *label21
   142 op add *tmp70 :backgroundProcess:reconstructorProgress 0.1
   143 jump *label27 lessThanEq :backgroundProcess:lastRecoProgress *tmp70
-    * set :factoryUnitFinished:unit @poly
   144 label *label63
   145 jump *label74 notEqual @poly .targetUnit
   146 sensor *tmp96 @poly @id

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   156 write *tmp104 .bank *tmp98
   157 label *label65
   158 label *label66
-    * jump *label68 notEqual @poly @flare
+  159 jump *label68 always
   160 label *label67
   161 op add *tmp107 .flares 1
   162 set .flares *tmp107
   163 write *tmp107 .display ".displayFlares"
   164 jump *label73 always
   165 label *label68
-    * jump *label70 notEqual @poly @mono
+  166 jump *label70 always
   167 label *label69
   168 op add *tmp108 .monos 1
   169 set .monos *tmp108
   170 write *tmp108 .display ".displayMonos"
   171 jump *label73 always
   172 label *label70
-    * jump *label72 notEqual @poly @poly
   173 label *label71
   174 op add *tmp109 .polys 1
   175 set .polys *tmp109

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    57 sensor *tmp39 .reconstructor @payloadType
    58 jump *label16 notEqual *tmp39 null
    59 set .factoryUnit @mono
-    * jump *label16 always
    60 label *label16
    61 set .targetUnit @poly
    62 write @poly .display ".displayNextUnit"

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   142 jump *label27 lessThanEq :backgroundProcess:lastRecoProgress *tmp70
   143 label *label63
   144 jump *label74 notEqual @poly .targetUnit
-    * sensor *tmp96 @poly @id
+  145 set *tmp96 21
   146 op add :log:encodedId @blockCount *tmp96
   147 read *tmp4 .bank 511
   148 op sub *tmp98 *tmp4 1

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-2 instructions):
 
   143 label *label63
   144 jump *label74 notEqual @poly .targetUnit
   145 set *tmp96 21
-    * op add :log:encodedId @blockCount *tmp96
+  146 op add :log:encodedId @blockCount 21
   147 read *tmp4 .bank 511
   148 op sub *tmp98 *tmp4 1
   149 write *tmp98 .bank 511
 
   157 label *label66
   158 jump *label68 always
   159 label *label67
-    * op add *tmp107 .flares 1
   160 set .flares *tmp107
   161 write *tmp107 .display ".displayFlares"
   162 jump *label73 always
   163 label *label68
   164 jump *label70 always
   165 label *label69
-    * op add *tmp108 .monos 1
   166 set .monos *tmp108
   167 write *tmp108 .display ".displayMonos"
   168 jump *label73 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
   142 jump *label27 lessThanEq :backgroundProcess:lastRecoProgress *tmp70
   143 label *label63
   144 jump *label74 notEqual @poly .targetUnit
-    * set *tmp96 21
   145 op add :log:encodedId @blockCount 21
   146 read *tmp4 .bank 511
   147 op sub *tmp98 *tmp4 1

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    70 label *label10
    71 control config .payloadRouter .targetUnit
    72 select :backgroundProcess:enableFactory lessThan :backgroundProcess:power 200 false :backgroundProcess:enableFactory
-    * label *label18
    73 select :backgroundProcess:enableFactory lessThan 500 :backgroundProcess:power true :backgroundProcess:enableFactory
-    * label *label19
-    * label *label17
    74 jump *label20 notEqual .factoryUnit null
    75 control enabled .factory false
    76 control config .factory @mono
 
    81 jump *label22 lessThanEq :backgroundProcess:lastProgress *tmp54
    82 control enabled .factory :backgroundProcess:enableFactory
    83 set :factoryUnitFinished:unit .factoryUnit
-    * label *label49
    84 jump *label60 notEqual :factoryUnitFinished:unit .targetUnit
    85 sensor *tmp96 :factoryUnitFinished:unit @id
    86 op add :log:encodedId @blockCount *tmp96
 
    88 op sub *tmp98 *tmp4 1
    89 write *tmp98 .bank 511
    90 op mul :second:result @second TIME_COMPRESS
-    * label *label50
    91 op floor *tmp102 :second:result
    92 op mul *tmp103 *tmp102 1000
    93 op add *tmp104 :log:encodedId *tmp103
    94 write *tmp104 .bank *tmp98
-    * label *label51
-    * label *label52
    95 jump *label54 notEqual :factoryUnitFinished:unit @flare
-    * label *label53
    96 op add *tmp107 .flares 1
    97 set .flares *tmp107
    98 write *tmp107 .display ".displayFlares"
    99 jump *label59 always
   100 label *label54
   101 jump *label56 notEqual :factoryUnitFinished:unit @mono
-    * label *label55
   102 op add *tmp108 .monos 1
   103 set .monos *tmp108
   104 write *tmp108 .display ".displayMonos"
   105 jump *label59 always
   106 label *label56
   107 jump *label58 notEqual :factoryUnitFinished:unit @poly
-    * label *label57
   108 op add *tmp109 .polys 1
   109 set .polys *tmp109
   110 write *tmp109 .display ".displayPolys"
   111 label *label58
   112 label *label59
   113 label *label60
-    * label *label61
-    * label *label62
   114 set :backgroundProcess:lastProgress 0
   115 jump *label23 always
   116 label *label22
 
   128 label *label21
   129 op add *tmp70 :backgroundProcess:reconstructorProgress 0.1
   130 jump *label27 lessThanEq :backgroundProcess:lastRecoProgress *tmp70
-    * label *label63
   131 jump *label74 notEqual @poly .targetUnit
   132 op add :log:encodedId @blockCount 21
   133 read *tmp4 .bank 511
   134 op sub *tmp98 *tmp4 1
   135 write *tmp98 .bank 511
   136 op mul :second:result @second TIME_COMPRESS
-    * label *label64
   137 op floor *tmp102 :second:result
   138 op mul *tmp103 *tmp102 1000
   139 op add *tmp104 :log:encodedId *tmp103
   140 write *tmp104 .bank *tmp98
-    * label *label65
-    * label *label66
   141 jump *label68 always
-    * label *label67
   142 set .flares *tmp107
   143 write *tmp107 .display ".displayFlares"
   144 jump *label73 always
   145 label *label68
   146 jump *label70 always
-    * label *label69
   147 set .monos *tmp108
   148 write *tmp108 .display ".displayMonos"
   149 jump *label73 always
   150 label *label70
-    * label *label71
   151 op add *tmp109 .polys 1
   152 set .polys *tmp109
   153 write *tmp109 .display ".displayPolys"
-    * label *label72
   154 label *label73
   155 label *label74
-    * label *label75
-    * label *label76
   156 set :backgroundProcess:lastRecoProgress 0
   157 jump *label28 always
   158 label *label27
 
   163 control config .unloader2 @coal
   164 jump *label5 always
   165 label *label30
-    * label *label31
   166 op equal *tmp78 .factoryUnit @mono
   167 op mul :backgroundProcess:leadLimit *tmp78 30
   168 sensor *tmp80 .factory @lead
 
   183 label *label33
   184 label *label5
   185 jump *label4 always
-    * label *label6
-    * label *label3
   186 wait 1e12
   187 jump *label2 always
   188 end

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
   138 op mul *tmp103 *tmp102 1000
   139 op add *tmp104 :log:encodedId *tmp103
   140 write *tmp104 .bank *tmp98
-    * jump *label68 always
+  141 jump *label70 always
   142 set .flares *tmp107
   143 write *tmp107 .display ".displayFlares"
   144 jump *label73 always
 
   161 sensor *tmp73 .generator2 @coal
   162 jump *label30 greaterThanEq *tmp73 .generator2
   163 control config .unloader2 @coal
-    * jump *label5 always
+  164 jump *label4 always
   165 label *label30
   166 op equal *tmp78 .factoryUnit @mono
   167 op mul :backgroundProcess:leadLimit *tmp78 30
 
   172 op land *tmp84 *tmp81 *tmp83
   173 jump *label32 equal *tmp84 false
   174 control config .unloader2 @lead
-    * jump *label33 always
+  175 jump *label4 always
   176 label *label32
   177 jump *label34 lessThanEq :backgroundProcess:coreSilicon .siliconReserve
   178 control config .unloader2 @silicon
-    * jump *label35 always
+  179 jump *label4 always
   180 label *label34
   181 control config .unloader2 @coal
   182 label *label35

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-10 instructions):
 
   139 op add *tmp104 :log:encodedId *tmp103
   140 write *tmp104 .bank *tmp98
   141 jump *label70 always
-    * set .flares *tmp107
-    * write *tmp107 .display ".displayFlares"
-    * jump *label73 always
-    * label *label68
-    * jump *label70 always
-    * set .monos *tmp108
-    * write *tmp108 .display ".displayMonos"
-    * jump *label73 always
   142 label *label70
   143 op add *tmp109 .polys 1
   144 set .polys *tmp109
 
   171 jump *label4 always
   172 label *label34
   173 control config .unloader2 @coal
-    * label *label35
-    * label *label33
-    * label *label5
   174 jump *label4 always
-    * wait 1e12
-    * jump *label2 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
 
     5 set .monoTarget 0
     6 set .polyTarget 0
     7 set *signature "0:v1"
-    * label *label2
     8 set :backgroundProcess:lastProgress 0
     9 set :backgroundProcess:lastRecoProgress 0
    10 set :backgroundProcess:enableFactory true
 
   142 op add *tmp109 .polys 1
   143 set .polys *tmp109
   144 write *tmp109 .display ".displayPolys"
-    * label *label73
   145 label *label74
   146 set :backgroundProcess:lastRecoProgress 0
   147 jump *label28 always

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   137 op mul *tmp103 *tmp102 1000
   138 op add *tmp104 :log:encodedId *tmp103
   139 write *tmp104 .bank *tmp98
-    * jump *label70 always
   140 label *label70
   141 op add *tmp109 .polys 1
   142 set .polys *tmp109

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
   137 op mul *tmp103 *tmp102 1000
   138 op add *tmp104 :log:encodedId *tmp103
   139 write *tmp104 .bank *tmp98
-    * label *label70
   140 op add *tmp109 .polys 1
   141 set .polys *tmp109
   142 write *tmp109 .display ".displayPolys"

Final code before resolving virtual instructions:

    0:  jump *label77 always 0 0
    1:  draw triangle TIME_COMPRESS .bank .battery .core .display .factory
    2:  draw triangle .factoryUnit .flareTarget .flares .generator .generator2 .kiln
    3:  draw triangle .kilnTarget .leadReserve .monoTarget .monos .multipress .payloadRouter
    4:  draw triangle .polyTarget .polys .press .pressTarget .reconstructor .siliconReserve
    5:  draw triangle .smelter .smelterTarget .targetUnit .unloader2 :backgroundProcess:coreSilicon :backgroundProcess:enableFactory
    6:  draw triangle :backgroundProcess:factoryProgress :backgroundProcess:lastProgress :backgroundProcess:lastRecoProgress :backgroundProcess:leadLimit :backgroundProcess:power :backgroundProcess:reconstructorProgress
    7:  draw triangle :factoryUnitFinished:unit :log:encodedId :second:result 0 0 0
        label *label77
    8:  set TIME_COMPRESS 8                                          common.mnd: param TIME_COMPRESS = 8;
    9:  set .pressTarget 20                                          CoreController.mnd: remote var
   10:  set .smelterTarget 20                                        ...
   11:  set .kilnTarget 20                                           ...
   12:  set .flareTarget 0                                           ...
   13:  set .monoTarget 0                                            ...
   14:  set .polyTarget 0                                            ...
   15:  set *signature "0:v1"                                        CoreController.mnd: #set target = 8;
   16:  set :backgroundProcess:lastProgress 0                        CoreController.mnd: var lastProgress = 0, factoryProgress = 0;
   17:  set :backgroundProcess:lastRecoProgress 0                    CoreController.mnd: var lastRecoProgress = 0, reconstructorProgress = 0;
   18:  set :backgroundProcess:enableFactory true                    CoreController.mnd: var enableFactory = true;
        label *label4                                                CoreController.mnd: while true do
   19:  sensor :backgroundProcess:coreSilicon .core @silicon         CoreController.mnd: var coreSilicon = core.@silicon;
   20:  set *tmp6 .smelter                                           CoreController.mnd: smelter.enabled = coreSilicon < smelterTarget;
   21:  op lessThan *tmp8 :backgroundProcess:coreSilicon .smelterTar ...
   22:  control enabled *tmp6 *tmp8 0 0 0                            ...
   23:  set *tmp9 .press                                             CoreController.mnd: press.enabled = core.@graphite < pressTarget;
   24:  sensor *tmp11 .core @graphite                                ...
   25:  op lessThan *tmp12 *tmp11 .pressTarget                       ...
   26:  control enabled *tmp9 *tmp12 0 0 0                           ...
   27:  set *tmp13 .multipress                                       CoreController.mnd: multipress.enabled = core.@graphite < pressTarget;
   28:  sensor *tmp15 .core @graphite                                ...
   29:  op lessThan *tmp16 *tmp15 .pressTarget                       ...
   30:  control enabled *tmp13 *tmp16 0 0 0                          ...
   31:  set *tmp17 .kiln                                             CoreController.mnd: kiln.enabled = core.@metaglass < kilnTarget;
   32:  sensor *tmp19 .core @metaglass                               ...
   33:  op lessThan *tmp20 *tmp19 .kilnTarget                        ...
   34:  control enabled *tmp17 *tmp20 0 0 0                          ...
   35:  sensor :backgroundProcess:power .battery @totalPower         CoreController.mnd: var power = battery.@totalPower;
   36:  jump *label7 equal .generator2 false                         CoreController.mnd: if generator2 then
   37:  control enabled .generator false 0 0 0                       CoreController.mnd: generator.enabled = false;
   38:  set *tmp25 .generator2                                       CoreController.mnd: generator2.enabled = power < 3800;
   39:  op lessThan *tmp27 :backgroundProcess:power 3800             ...
   40:  control enabled *tmp25 *tmp27 0 0 0                          ...
   41:  jump *label8 always 0 0                                      CoreController.mnd: if generator2 then
        label *label7                                                ...
   42:  set *tmp28 .generator                                        CoreController.mnd: generator.enabled = power < 800;
   43:  op lessThan *tmp30 :backgroundProcess:power 800              ...
   44:  control enabled *tmp28 *tmp30 0 0 0                          ...
        label *label8                                                CoreController.mnd: if generator2 then
   45:  sensor :backgroundProcess:factoryProgress .factory @progress CoreController.mnd: factoryProgress = factory.@progress;
   46:  sensor :backgroundProcess:reconstructorProgress .reconstruct CoreController.mnd: reconstructorProgress = reconstructor.@progress;
   47:  jump *label9 greaterThanEq .flares .flareTarget              CoreController.mnd: if flares < flareTarget then
   48:  set .factoryUnit @flare                                      CoreController.mnd: displayNextUnit = targetUnit = factoryUnit = @flare;
   49:  set .targetUnit @flare                                       ...
   50:  write @flare .display ".displayNextUnit"                     ...
   51:  jump *label10 always 0 0                                     CoreController.mnd: if flares < flareTarget then
        label *label9                                                ...
   52:  jump *label11 greaterThanEq .monos .monoTarget               CoreController.mnd: elsif monos < monoTarget then
   53:  set .factoryUnit @mono                                       CoreController.mnd: displayNextUnit = targetUnit = factoryUnit = @mono;
   54:  set .targetUnit @mono                                        ...
   55:  write @mono .display ".displayNextUnit"                      ...
   56:  jump *label12 always 0 0                                     CoreController.mnd: elsif monos < monoTarget then
        label *label11                                               ...
   57:  jump *label13 greaterThanEq .polys .polyTarget               CoreController.mnd: elsif polys < polyTarget then
   58:  set .factoryUnit null                                        CoreController.mnd: factoryUnit = reconstructor.@payloadType == null ? @mono : null;
   59:  sensor *tmp39 .reconstructor @payloadType                    ...
   60:  jump *label16 notEqual *tmp39 null                           ...
   61:  set .factoryUnit @mono                                       ...
        label *label16                                               ...
   62:  set .targetUnit @poly                                        CoreController.mnd: displayNextUnit = targetUnit = @poly;
   63:  write @poly .display ".displayNextUnit"                      ...
   64:  jump *label14 always 0 0                                     CoreController.mnd: elsif polys < polyTarget then
        label *label13                                               ...
   65:  set .factoryUnit null                                        CoreController.mnd: displayNextUnit = targetUnit = factoryUnit = null;
   66:  set .targetUnit null                                         ...
   67:  write null .display ".displayNextUnit"                       ...
        label *label14                                               CoreController.mnd: elsif polys < polyTarget then
        label *label12                                               CoreController.mnd: elsif monos < monoTarget then
        label *label10                                               CoreController.mnd: if flares < flareTarget then
   68:  control config .payloadRouter .targetUnit 0 0 0              CoreController.mnd: payloadRouter.config = targetUnit;
   69:  select :backgroundProcess:enableFactory lessThan :background CoreController.mnd: mlogSafe("select", out value, "lessThan", in a, in b, in newValue, in value);
   70:  select :backgroundProcess:enableFactory lessThan 500 :backgr ...
   71:  jump *label20 notEqual .factoryUnit null                     CoreController.mnd: if factoryUnit == null then
   72:  control enabled .factory false 0 0 0                         CoreController.mnd: factory.enabled = false;
   73:  control config .factory @mono 0 0 0                          CoreController.mnd: factory.config = @mono;
   74:  set :backgroundProcess:lastProgress 0                        CoreController.mnd: lastProgress = 0;
   75:  jump *label21 always 0 0                                     CoreController.mnd: if factoryUnit == null then
        label *label20                                               ...
   76:  op add *tmp54 :backgroundProcess:factoryProgress 0.1         CoreController.mnd: elsif lastProgress > factoryProgress + 0.1 then
   77:  jump *label22 lessThanEq :backgroundProcess:lastProgress *tm ...
   78:  control enabled .factory :backgroundProcess:enableFactory 0  CoreController.mnd: factory.enabled = enableFactory;
   79:  set :factoryUnitFinished:unit .factoryUnit                   CoreController.mnd: factoryUnitFinished(factoryUnit);
   80:  jump *label60 notEqual :factoryUnitFinished:unit .targetUnit CoreController.mnd: if unit == targetUnit then
   81:  sensor *tmp96 :factoryUnitFinished:unit @id                  CoreController.mnd: log(@blockCount + unit.@id);
   82:  op add :log:encodedId @blockCount *tmp96                     ...
   83:  read *tmp4 .bank 511                                         CoreController.mnd: bank[--logPosition] = encodedId + floor(second()) * 1000;
   84:  op sub *tmp98 *tmp4 1                                        ...
   85:  write *tmp98 .bank 511                                       ...
   86:  op mul :second:result @second TIME_COMPRESS                  common.mnd: mlog (out result) {
   87:  op floor *tmp102 :second:result 0                            CoreController.mnd: bank[--logPosition] = encodedId + floor(second()) * 1000;
   88:  op mul *tmp103 *tmp102 1000                                  ...
   89:  op add *tmp104 :log:encodedId *tmp103                        ...
   90:  write *tmp104 .bank *tmp98                                   ...
   91:  jump *label54 notEqual :factoryUnitFinished:unit @flare      CoreController.mnd: case unit
   92:  op add *tmp107 .flares 1                                     CoreController.mnd: when @flare then displayFlares = ++flares;
   93:  set .flares *tmp107                                          ...
   94:  write *tmp107 .display ".displayFlares"                      ...
   95:  jump *label59 always 0 0                                     CoreController.mnd: case unit
        label *label54                                               ...
   96:  jump *label56 notEqual :factoryUnitFinished:unit @mono       ...
   97:  op add *tmp108 .monos 1                                      CoreController.mnd: when @mono  then displayMonos = ++monos;
   98:  set .monos *tmp108                                           ...
   99:  write *tmp108 .display ".displayMonos"                       ...
  100:  jump *label59 always 0 0                                     CoreController.mnd: case unit
        label *label56                                               ...
  101:  jump *label58 notEqual :factoryUnitFinished:unit @poly       ...
  102:  op add *tmp109 .polys 1                                      CoreController.mnd: when @poly  then displayPolys = ++polys;
  103:  set .polys *tmp109                                           ...
  104:  write *tmp109 .display ".displayPolys"                       ...
        label *label58                                               CoreController.mnd: case unit
        label *label59                                               ...
        label *label60                                               CoreController.mnd: if unit == targetUnit then
  105:  set :backgroundProcess:lastProgress 0                        CoreController.mnd: lastProgress = 0;
  106:  jump *label23 always 0 0                                     CoreController.mnd: elsif lastProgress > factoryProgress + 0.1 then
        label *label22                                               ...
  107:  sensor *tmp60 .factory @config                               CoreController.mnd: elsif factory.config != factoryUnit then
  108:  jump *label25 equal *tmp60 .factoryUnit                      ...
  109:  control enabled .factory :backgroundProcess:enableFactory 0  CoreController.mnd: factory.enabled = enableFactory;
  110:  control config .factory .factoryUnit 0 0 0                   CoreController.mnd: factory.config = factoryUnit;
  111:  set :backgroundProcess:lastProgress 0                        CoreController.mnd: lastProgress = 0;
  112:  jump *label26 always 0 0                                     CoreController.mnd: elsif factory.config != factoryUnit then
        label *label25                                               ...
  113:  control enabled .factory :backgroundProcess:enableFactory 0  CoreController.mnd: factory.enabled = enableFactory;
  114:  set :backgroundProcess:lastProgress :backgroundProcess:facto CoreController.mnd: lastProgress = factoryProgress;
        label *label26                                               CoreController.mnd: elsif factory.config != factoryUnit then
        label *label23                                               CoreController.mnd: elsif lastProgress > factoryProgress + 0.1 then
        label *label21                                               CoreController.mnd: if factoryUnit == null then
  115:  op add *tmp70 :backgroundProcess:reconstructorProgress 0.1   CoreController.mnd: if lastRecoProgress > reconstructorProgress + 0.1 then
  116:  jump *label27 lessThanEq :backgroundProcess:lastRecoProgress ...
  117:  jump *label74 notEqual @poly .targetUnit                     CoreController.mnd: if unit == targetUnit then
  118:  op add :log:encodedId @blockCount 21                         CoreController.mnd: log(@blockCount + unit.@id);
  119:  read *tmp4 .bank 511                                         CoreController.mnd: bank[--logPosition] = encodedId + floor(second()) * 1000;
  120:  op sub *tmp98 *tmp4 1                                        ...
  121:  write *tmp98 .bank 511                                       ...
  122:  op mul :second:result @second TIME_COMPRESS                  common.mnd: mlog (out result) {
  123:  op floor *tmp102 :second:result 0                            CoreController.mnd: bank[--logPosition] = encodedId + floor(second()) * 1000;
  124:  op mul *tmp103 *tmp102 1000                                  ...
  125:  op add *tmp104 :log:encodedId *tmp103                        ...
  126:  write *tmp104 .bank *tmp98                                   ...
  127:  op add *tmp109 .polys 1                                      CoreController.mnd: when @poly  then displayPolys = ++polys;
  128:  set .polys *tmp109                                           ...
  129:  write *tmp109 .display ".displayPolys"                       ...
        label *label74                                               CoreController.mnd: if unit == targetUnit then
  130:  set :backgroundProcess:lastRecoProgress 0                    CoreController.mnd: lastRecoProgress = 0;
  131:  jump *label28 always 0 0                                     CoreController.mnd: if lastRecoProgress > reconstructorProgress + 0.1 then
        label *label27                                               ...
  132:  set :backgroundProcess:lastRecoProgress :backgroundProcess:r CoreController.mnd: lastRecoProgress = reconstructorProgress;
        label *label28                                               CoreController.mnd: if lastRecoProgress > reconstructorProgress + 0.1 then
  133:  sensor *tmp73 .generator2 @coal                              CoreController.mnd: if generator2.@coal < generator2 then
  134:  jump *label30 greaterThanEq *tmp73 .generator2               ...
  135:  control config .unloader2 @coal 0 0 0                        CoreController.mnd: unloader2.config = @coal;
  136:  jump *label4 always 0 0                                      CoreController.mnd: continue;
        label *label30                                               CoreController.mnd: if generator2.@coal < generator2 then
  137:  op equal *tmp78 .factoryUnit @mono                           CoreController.mnd: var leadLimit = (factoryUnit == @mono) * 30;
  138:  op mul :backgroundProcess:leadLimit *tmp78 30                ...
  139:  sensor *tmp80 .factory @lead                                 CoreController.mnd: if factory.@lead < leadLimit and core.@lead > leadReserve then
  140:  op lessThan *tmp81 *tmp80 :backgroundProcess:leadLimit       ...
  141:  sensor *tmp82 .core @lead                                    ...
  142:  op greaterThan *tmp83 *tmp82 .leadReserve                    ...
  143:  op land *tmp84 *tmp81 *tmp83                                 ...
  144:  jump *label32 equal *tmp84 false                             ...
  145:  control config .unloader2 @lead 0 0 0                        CoreController.mnd: unloader2.config = @lead;
  146:  jump *label4 always 0 0                                      CoreController.mnd: if factory.@lead < leadLimit and core.@lead > leadReserve then
        label *label32                                               ...
  147:  jump *label34 lessThanEq :backgroundProcess:coreSilicon .sil CoreController.mnd: elsif coreSilicon > siliconReserve then
  148:  control config .unloader2 @silicon 0 0 0                     CoreController.mnd: unloader2.config = @silicon;
  149:  jump *label4 always 0 0                                      CoreController.mnd: elsif coreSilicon > siliconReserve then
        label *label34                                               ...
  150:  control config .unloader2 @coal 0 0 0                        CoreController.mnd: unloader2.config = @coal;
  151:  jump *label4 always 0 0                                      CoreController.mnd: while true do


Performance: parsed in 247 ms, compiled in 262 ms, optimized in 402 ms, run in 14 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (13 steps):
The program didn't generate any output.
Execution exception at instruction 19: sensor :backgroundProcess:coreSilicon .core @silicon:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
