   144 instructions before optimizations.
    14 instructions eliminated by Temp Variables Elimination (3 iterations).
    18 instructions eliminated by Dead Code Elimination (7 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    10 instructions eliminated by Jump Optimization (5 iterations).
     5 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     3 instructions eliminated by If Expression Optimization (3 iterations).
     3 instructions eliminated by Data Flow Optimization (5 iterations).
     1 instructions eliminated by Jump Straightening (5 iterations).
     6 instructions updated by JumpThreading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    86 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-10 instructions):
 
    26 op equal *tmp23 .factory null
    27 jump *label6 equal *tmp23 false
    28 jump *label4 always
-    * set *tmp24 null
    29 jump *label7 always
    30 label *label6
-    * set *tmp24 null
    31 label *label7
    32 jump *label8 equal .buildUnits false
    33 sensor *tmp26 .factory @progress
 
    64 op add *tmp46 .flares 1
    65 set .flares *tmp46
    66 write *tmp46 .display ".flares"
-    * set *tmp45 *tmp46
    67 jump *label18 always
    68 label *label17
    69 op add *tmp47 .monos 1
    70 set .monos *tmp47
    71 write *tmp47 .display ".monos"
-    * set *tmp45 *tmp47
    72 label *label18
    73 op lessThan *tmp48 .monos 8
    74 jump *label19 equal *tmp48 false
 
   112 label *label13
   113 set *tmp28 *tmp35
   114 label *label11
-    * set *tmp25 *tmp28
   115 jump *label9 always
   116 label *label8
   117 set *tmp63 .factory
   118 control enabled *tmp63 false
-    * set *tmp25 false
   119 label *label9
   120 op notEqual *tmp65 .generator2 null
   121 jump *label25 equal *tmp65 false
 
   130 label *label27
   131 set *tmp69 null
   132 label *label28
-    * set *tmp66 *tmp69
   133 jump *label26 always
   134 label *label25
-    * set *tmp66 null
   135 label *label26
   136 set *tmp72 .factory
   137 sensor *tmp73 *tmp72 @config
 
   151 jump *label31 equal *tmp80 false
   152 set *tmp82 .unloader2
   153 control config *tmp82 @silicon
-    * set *tmp81 @silicon
   154 jump *label32 always
   155 label *label31
   156 set *tmp84 .unloader2
   157 control config *tmp84 @lead
-    * set *tmp81 @lead
   158 label *label32
   159 label *label4
   160 jump *label3 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-4 instructions):
 
    39 set *tmp31 .factory
    40 control config *tmp31 @mono
    41 set .lastProgress 0
-    * set *tmp28 .lastProgress
    42 jump *label11 always
    43 label *label10
    44 op add *tmp33 .factoryProgress 0.1
 
   109 label *label24
   110 set *tmp35 *tmp55
   111 label *label13
-    * set *tmp28 *tmp35
   112 label *label11
   113 jump *label9 always
   114 label *label8
 
   123 set *tmp70 .unloader2
   124 control config *tmp70 @coal
   125 jump *label4 always
-    * set *tmp69 null
   126 jump *label28 always
   127 label *label27
-    * set *tmp69 null
   128 label *label28
   129 jump *label26 always
   130 label *label25

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
    86 set .unitToProduce *tmp49
    87 label *label14
    88 set .lastProgress 0
-    * set *tmp35 .lastProgress
    89 jump *label13 always
    90 label *label12
    91 set *tmp52 .factory
 
   106 set .lastProgress .factoryProgress
   107 set *tmp55 .lastProgress
   108 label *label24
-    * set *tmp35 *tmp55
   109 label *label13
   110 label *label11
   111 jump *label9 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
    98 set *tmp60 .unitToProduce
    99 control config *tmp58 *tmp60
   100 set .lastProgress 0
-    * set *tmp55 .lastProgress
   101 jump *label24 always
   102 label *label23
   103 set *tmp61 .factory
   104 control enabled *tmp61 true
   105 set .lastProgress .factoryProgress
-    * set *tmp55 .lastProgress
   106 label *label24
   107 label *label13
   108 label *label11

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-13 instructions):
 
    30 label *label6
    31 label *label7
    32 jump *label8 equal .buildUnits false
-    * sensor *tmp26 .factory @progress
-    * set .factoryProgress *tmp26
+   33 sensor .factoryProgress .factory @progress
    34 op equal *tmp27 .unitToProduce null
    35 jump *label10 equal *tmp27 false
-    * set *tmp29 .factory
-    * control enabled *tmp29 false
-    * set *tmp31 .factory
-    * control config *tmp31 @mono
+   36 control enabled .factory false
+   37 control config .factory @mono
    38 set .lastProgress 0
    39 jump *label11 always
    40 label *label10
 
    43 jump *label12 equal *tmp34 false
    44 set :logUnit:unit .unitToProduce
    45 sensor *tmp36 :logUnit:unit @id
-    * op add *tmp37 @blockCount *tmp36
-    * set :log:encodedId *tmp37
+   46 op add :log:encodedId @blockCount *tmp36
    47 read *tmp2 .bank 511
    48 op sub *tmp38 *tmp2 1
    49 write *tmp38 .bank 511
 
    84 set .lastProgress 0
    85 jump *label13 always
    86 label *label12
-    * set *tmp52 .factory
-    * sensor *tmp53 *tmp52 @config
+   87 sensor *tmp53 .factory @config
    88 op notEqual *tmp54 *tmp53 .unitToProduce
    89 jump *label23 equal *tmp54 false
-    * set *tmp56 .factory
-    * control enabled *tmp56 true
+   90 control enabled .factory true
    91 set *tmp58 .factory
-    * set *tmp60 .unitToProduce
-    * control config *tmp58 *tmp60
+   92 control config *tmp58 .unitToProduce
    93 set .lastProgress 0
    94 jump *label24 always
    95 label *label23
-    * set *tmp61 .factory
-    * control enabled *tmp61 true
+   96 control enabled .factory true
    97 set .lastProgress .factoryProgress
    98 label *label24
    99 label *label13
   100 label *label11
   101 jump *label9 always
   102 label *label8
-    * set *tmp63 .factory
-    * control enabled *tmp63 false
+  103 control enabled .factory false
   104 label *label9
   105 op notEqual *tmp65 .generator2 null
   106 jump *label25 equal *tmp65 false
   107 sensor *tmp67 .generator2 @coal
   108 op lessThan *tmp68 *tmp67 3
   109 jump *label27 equal *tmp68 false
-    * set *tmp70 .unloader2
-    * control config *tmp70 @coal
+  110 control config .unloader2 @coal
   111 jump *label4 always
   112 jump *label28 always
   113 label *label27
 
   115 jump *label26 always
   116 label *label25
   117 label *label26
-    * set *tmp72 .factory
-    * sensor *tmp73 *tmp72 @config
+  118 sensor *tmp73 .factory @config
   119 op equal *tmp74 *tmp73 @mono
   120 jump *label29 equal *tmp74 false
   121 set *tmp75 60
 
   130 op greaterThan *tmp79 *tmp78 0
   131 op land *tmp80 *tmp77 *tmp79
   132 jump *label31 equal *tmp80 false
-    * set *tmp82 .unloader2
-    * control config *tmp82 @silicon
+  133 control config .unloader2 @silicon
   134 jump *label32 always
   135 label *label31
-    * set *tmp84 .unloader2
-    * control config *tmp84 @lead
+  136 control config .unloader2 @lead
   137 label *label32
   138 label *label4
   139 jump *label3 always

Modifications by Initial phase, Temp Variables Elimination, iteration 2 (-1 instructions):
 
    88 op notEqual *tmp54 *tmp53 .unitToProduce
    89 jump *label23 equal *tmp54 false
    90 control enabled .factory true
-    * set *tmp58 .factory
-    * control config *tmp58 .unitToProduce
+   91 control config .factory .unitToProduce
    92 set .lastProgress 0
    93 jump *label24 always
    94 label *label23

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
     2 set *signature "0:v1"
     3 label *label0
     4 label *label3
-    * jump *label5 equal true false
     5 set *tmp3 .press
     6 sensor *tmp5 .core @graphite
     7 op lessThan *tmp6 *tmp5 .pressTarget

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-10 instructions):
 
    22 sensor *tmp21 .battery @totalPower
    23 op lessThan *tmp22 *tmp21 3800
    24 control enabled *tmp19 *tmp22
-    * op equal *tmp23 .factory null
-    * jump *label6 equal *tmp23 false
+   25 jump *label6 notEqual .factory null
    26 jump *label4 always
    27 jump *label7 always
    28 label *label6
    29 label *label7
    30 jump *label8 equal .buildUnits false
    31 sensor .factoryProgress .factory @progress
-    * op equal *tmp27 .unitToProduce null
-    * jump *label10 equal *tmp27 false
+   32 jump *label10 notEqual .unitToProduce null
    33 control enabled .factory false
    34 control config .factory @mono
    35 set .lastProgress 0
    36 jump *label11 always
    37 label *label10
    38 op add *tmp33 .factoryProgress 0.1
-    * op greaterThan *tmp34 .lastProgress *tmp33
-    * jump *label12 equal *tmp34 false
+   39 jump *label12 lessThanEq .lastProgress *tmp33
    40 set :logUnit:unit .unitToProduce
    41 sensor *tmp36 :logUnit:unit @id
    42 op add :log:encodedId @blockCount *tmp36
 
    50 write *tmp43 .bank *tmp39
    51 label *label16
    52 label *label15
-    * op equal *tmp44 .unitToProduce @flare
-    * jump *label17 equal *tmp44 false
+   53 jump *label17 notEqual .unitToProduce @flare
    54 op add *tmp46 .flares 1
    55 set .flares *tmp46
    56 write *tmp46 .display ".flares"
 
    60 set .monos *tmp47
    61 write *tmp47 .display ".monos"
    62 label *label18
-    * op lessThan *tmp48 .monos 8
-    * jump *label19 equal *tmp48 false
+   63 jump *label19 greaterThanEq .monos 8
    64 set *tmp49 @mono
    65 jump *label20 always
    66 label *label19
-    * op lessThan *tmp50 .flares 8
-    * jump *label21 equal *tmp50 false
+   67 jump *label21 greaterThanEq .flares 8
    68 set *tmp51 @flare
    69 jump *label22 always
    70 label *label21
 
    78 jump *label13 always
    79 label *label12
    80 sensor *tmp53 .factory @config
-    * op notEqual *tmp54 *tmp53 .unitToProduce
-    * jump *label23 equal *tmp54 false
+   81 jump *label23 equal *tmp53 .unitToProduce
    82 control enabled .factory true
    83 control config .factory .unitToProduce
    84 set .lastProgress 0
 
    93 label *label8
    94 control enabled .factory false
    95 label *label9
-    * op notEqual *tmp65 .generator2 null
-    * jump *label25 equal *tmp65 false
+   96 jump *label25 equal .generator2 null
    97 sensor *tmp67 .generator2 @coal
-    * op lessThan *tmp68 *tmp67 3
-    * jump *label27 equal *tmp68 false
+   98 jump *label27 greaterThanEq *tmp67 3
    99 control config .unloader2 @coal
   100 jump *label4 always
   101 jump *label28 always
 
   105 label *label25
   106 label *label26
   107 sensor *tmp73 .factory @config
-    * op equal *tmp74 *tmp73 @mono
-    * jump *label29 equal *tmp74 false
+  108 jump *label29 notEqual *tmp73 @mono
   109 set *tmp75 60
   110 jump *label30 always
   111 label *label29

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-3 instructions):
 
    24 control enabled *tmp19 *tmp22
    25 jump *label6 notEqual .factory null
    26 jump *label4 always
-    * jump *label7 always
    27 label *label6
    28 label *label7
    29 jump *label8 equal .buildUnits false
 
    97 jump *label27 greaterThanEq *tmp67 3
    98 control config .unloader2 @coal
    99 jump *label4 always
-    * jump *label28 always
   100 label *label27
   101 label *label28
-    * jump *label26 always
   102 label *label25
   103 label *label26
   104 sensor *tmp73 .factory @config

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
     0 set .lastProgress 0
-    * set .factoryProgress 0
     1 set *signature "0:v1"
     2 label *label0
     3 label *label3
 
    45 op floor *tmp41 @second
    46 op mul *tmp42 *tmp41 1000
    47 op add *tmp43 :log:encodedId *tmp42
-    * write *tmp43 .bank *tmp39
+   48 write *tmp43 .bank *tmp38
    49 label *label16
    50 label *label15
    51 jump *label17 notEqual .unitToProduce @flare
 
   109 label *label30
   110 set :main:siliconLimit *tmp75
   111 sensor *tmp76 .factory @silicon
-    * op lessThan *tmp77 *tmp76 :main:siliconLimit
+  112 op lessThan *tmp77 *tmp76 *tmp75
   113 sensor *tmp78 .core @silicon
   114 op greaterThan *tmp79 *tmp78 0
   115 op land *tmp80 *tmp77 *tmp79

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    41 read *tmp2 .bank 511
    42 op sub *tmp38 *tmp2 1
    43 write *tmp38 .bank 511
-    * set *tmp39 *tmp38
    44 op floor *tmp41 @second
    45 op mul *tmp42 *tmp41 1000
    46 op add *tmp43 :log:encodedId *tmp42
 
   106 label *label29
   107 set *tmp75 30
   108 label *label30
-    * set :main:siliconLimit *tmp75
   109 sensor *tmp76 .factory @silicon
   110 op lessThan *tmp77 *tmp76 *tmp75
   111 sensor *tmp78 .core @silicon

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
    57 set .monos *tmp47
    58 write *tmp47 .display ".monos"
    59 label *label18
-    * jump *label19 greaterThanEq .monos 8
-    * set *tmp49 @mono
-    * jump *label20 always
+   60 set .unitToProduce @mono
+   61 jump *label20 lessThan .monos 8
    62 label *label19
-    * jump *label21 greaterThanEq .flares 8
-    * set *tmp51 @flare
+   63 set .unitToProduce null
+   64 jump *label22 greaterThanEq .flares 8
+   65 set .unitToProduce @flare
    66 jump *label22 always
-    * label *label21
-    * set *tmp51 null
    67 label *label22
-    * set *tmp49 *tmp51
    68 label *label20
-    * set .unitToProduce *tmp49
    69 label *label14
    70 set .lastProgress 0
    71 jump *label13 always
 
    95 label *label28
    96 label *label25
    97 label *label26
+   98 set *tmp75 30
    99 sensor *tmp73 .factory @config
-    * jump *label29 notEqual *tmp73 @mono
+  100 jump *label30 notEqual *tmp73 @mono
   101 set *tmp75 60
   102 jump *label30 always
-    * label *label29
-    * set *tmp75 30
   103 label *label30
   104 sensor *tmp76 .factory @silicon
   105 op lessThan *tmp77 *tmp76 *tmp75

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
    63 set .unitToProduce null
    64 jump *label22 greaterThanEq .flares 8
    65 set .unitToProduce @flare
-    * jump *label22 always
    66 label *label22
    67 label *label20
    68 label *label14
 
    98 sensor *tmp73 .factory @config
    99 jump *label30 notEqual *tmp73 @mono
   100 set *tmp75 60
-    * jump *label30 always
   101 label *label30
   102 sensor *tmp76 .factory @silicon
   103 op lessThan *tmp77 *tmp76 *tmp75

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    24 jump *label6 notEqual .factory null
    25 jump *label4 always
    26 label *label6
-    * label *label7
    27 jump *label8 equal .buildUnits false
    28 sensor .factoryProgress .factory @progress
    29 jump *label10 notEqual .unitToProduce null
 
    44 op mul *tmp42 *tmp41 1000
    45 op add *tmp43 :log:encodedId *tmp42
    46 write *tmp43 .bank *tmp38
-    * label *label16
-    * label *label15
    47 jump *label17 notEqual .unitToProduce @flare
    48 op add *tmp46 .flares 1
    49 set .flares *tmp46
 
    56 label *label18
    57 set .unitToProduce @mono
    58 jump *label20 lessThan .monos 8
-    * label *label19
    59 set .unitToProduce null
    60 jump *label22 greaterThanEq .flares 8
    61 set .unitToProduce @flare
    62 label *label22
    63 label *label20
-    * label *label14
    64 set .lastProgress 0
    65 jump *label13 always
    66 label *label12
 
    86 control config .unloader2 @coal
    87 jump *label4 always
    88 label *label27
-    * label *label28
    89 label *label25
-    * label *label26
    90 set *tmp75 30
    91 sensor *tmp73 .factory @config
    92 jump *label30 notEqual *tmp73 @mono
 
   105 label *label32
   106 label *label4
   107 jump *label3 always
-    * label *label5
-    * label *label2
-    * label *label1
   108 wait 1e12
   109 jump *label0 always
   110 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    21 sensor *tmp21 .battery @totalPower
    22 op lessThan *tmp22 *tmp21 3800
    23 control enabled *tmp19 *tmp22
-    * jump *label6 notEqual .factory null
-    * jump *label4 always
+   24 jump *label4 equal .factory null
    25 label *label6
    26 jump *label8 equal .buildUnits false
    27 sensor .factoryProgress .factory @progress

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    22 op lessThan *tmp22 *tmp21 3800
    23 control enabled *tmp19 *tmp22
    24 jump *label4 equal .factory null
-    * label *label6
    25 jump *label8 equal .buildUnits false
    26 sensor .factoryProgress .factory @progress
    27 jump *label10 notEqual .unitToProduce null

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    21 sensor *tmp21 .battery @totalPower
    22 op lessThan *tmp22 *tmp21 3800
    23 control enabled *tmp19 *tmp22
-    * jump *label4 equal .factory null
+   24 jump *label3 equal .factory null
    25 jump *label8 equal .buildUnits false
    26 sensor .factoryProgress .factory @progress
    27 jump *label10 notEqual .unitToProduce null
    28 control enabled .factory false
    29 control config .factory @mono
    30 set .lastProgress 0
-    * jump *label11 always
+   31 jump *label9 always
    32 label *label10
    33 op add *tmp33 .factoryProgress 0.1
    34 jump *label12 lessThanEq .lastProgress *tmp33
 
    60 label *label22
    61 label *label20
    62 set .lastProgress 0
-    * jump *label13 always
+   63 jump *label9 always
    64 label *label12
    65 sensor *tmp53 .factory @config
    66 jump *label23 equal *tmp53 .unitToProduce
    67 control enabled .factory true
    68 control config .factory .unitToProduce
    69 set .lastProgress 0
-    * jump *label24 always
+   70 jump *label9 always
    71 label *label23
    72 control enabled .factory true
    73 set .lastProgress .factoryProgress
 
    82 sensor *tmp67 .generator2 @coal
    83 jump *label27 greaterThanEq *tmp67 3
    84 control config .unloader2 @coal
-    * jump *label4 always
+   85 jump *label3 always
    86 label *label27
    87 label *label25
    88 set *tmp75 30
 
    97 op land *tmp80 *tmp77 *tmp79
    98 jump *label31 equal *tmp80 false
    99 control config .unloader2 @silicon
-    * jump *label32 always
+  100 jump *label3 always
   101 label *label31
   102 control config .unloader2 @lead
   103 label *label32

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    71 label *label23
    72 control enabled .factory true
    73 set .lastProgress .factoryProgress
-    * label *label24
-    * label *label13
-    * label *label11
    74 jump *label9 always
    75 label *label8
    76 control enabled .factory false
 
    97 jump *label3 always
    98 label *label31
    99 control config .unloader2 @lead
-    * label *label32
-    * label *label4
   100 jump *label3 always
-    * wait 1e12
-    * jump *label0 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
     0 set .lastProgress 0
     1 set *signature "0:v1"
-    * label *label0
     2 label *label3
     3 set *tmp3 .press
     4 sensor *tmp5 .core @graphite

Final code before resolving virtual instructions:

    0:  jump *label33 always 0 0                                     var lastProgress = 0, factoryProgress = 0;
    1:  draw triangle .bank .battery .buildUnits .core .display .fac ...
    2:  draw triangle .factoryProgress .flares .generator .generator ...
    3:  draw triangle .lastProgress .monos .press .pressTarget .smel ...
    4:  draw triangle .unitToProduce .unloader2 :log:encodedId :logU ...
        label *label33                                               ...
    5:  set .lastProgress 0                                          ...
    6:  set *signature "0:v1"                                        #set target = 8;
        label *label3                                                while true do
    7:  set *tmp3 .press                                             press.enabled = core.@graphite < pressTarget;
    8:  sensor *tmp5 .core @graphite                                 ...
    9:  op lessThan *tmp6 *tmp5 .pressTarget                         ...
   10:  control enabled *tmp3 *tmp6 0 0 0                            ...
   11:  set *tmp7 .smelter                                           smelter.enabled = core.@silicon < smelterTarget;
   12:  sensor *tmp9 .core @silicon                                  ...
   13:  op lessThan *tmp10 *tmp9 .smelterTarget                      ...
   14:  control enabled *tmp7 *tmp10 0 0 0                           ...
   15:  set *tmp11 .kiln                                             kiln.enabled = core.@metaglass < kilnTarget;
   16:  sensor *tmp13 .core @metaglass                               ...
   17:  op lessThan *tmp14 *tmp13 .kilnTarget                        ...
   18:  control enabled *tmp11 *tmp14 0 0 0                          ...
   19:  set *tmp15 .generator                                        generator.enabled = battery.@totalPower < 3500;
   20:  sensor *tmp17 .battery @totalPower                           ...
   21:  op lessThan *tmp18 *tmp17 3500                               ...
   22:  control enabled *tmp15 *tmp18 0 0 0                          ...
   23:  set *tmp19 .generator2                                       generator2.enabled = battery.@totalPower < 3800;
   24:  sensor *tmp21 .battery @totalPower                           ...
   25:  op lessThan *tmp22 *tmp21 3800                               ...
   26:  control enabled *tmp19 *tmp22 0 0 0                          ...
   27:  jump *label3 equal .factory null                             if factory == null then continue; end;
   28:  jump *label8 equal .buildUnits false                         if buildUnits then
   29:  sensor .factoryProgress .factory @progress                   factoryProgress = factory.@progress;
   30:  jump *label10 notEqual .unitToProduce null                   if unitToProduce == null then
   31:  control enabled .factory false 0 0 0                         factory.enabled = false;
   32:  control config .factory @mono 0 0 0                          factory.config = @mono;
   33:  set .lastProgress 0                                          lastProgress = 0;
   34:  jump *label9 always 0 0                                      if unitToProduce == null then
        label *label10                                               ...
   35:  op add *tmp33 .factoryProgress 0.1                           elsif lastProgress > factoryProgress + 0.1 then
   36:  jump *label12 lessThanEq .lastProgress *tmp33                ...
   37:  set :logUnit:unit .unitToProduce                             logUnit(unitToProduce);
   38:  sensor *tmp36 :logUnit:unit @id                              log(@blockCount + unit.@id);
   39:  op add :log:encodedId @blockCount *tmp36                     ...
   40:  read *tmp2 .bank 511                                         bank[--logPosition] = encodedId + floor(@second) * 1000;
   41:  op sub *tmp38 *tmp2 1                                        ...
   42:  write *tmp38 .bank 511                                       ...
   43:  op floor *tmp41 @second 0                                    ...
   44:  op mul *tmp42 *tmp41 1000                                    ...
   45:  op add *tmp43 :log:encodedId *tmp42                          ...
   46:  write *tmp43 .bank *tmp38                                    ...
   47:  jump *label17 notEqual .unitToProduce @flare                 if unitToProduce == @flare then
   48:  op add *tmp46 .flares 1                                      displayFlares = ++flares;
   49:  set .flares *tmp46                                           ...
   50:  write *tmp46 .display ".flares"                              ...
   51:  jump *label18 always 0 0                                     if unitToProduce == @flare then
        label *label17                                               ...
   52:  op add *tmp47 .monos 1                                       displayMonos = ++monos;
   53:  set .monos *tmp47                                            ...
   54:  write *tmp47 .display ".monos"                               ...
        label *label18                                               if unitToProduce == @flare then
   55:  set .unitToProduce @mono                                     unitToProduce = monos < 8 ? @mono : flares < 8 ? @flare : null;
   56:  jump *label20 lessThan .monos 8                              ...
   57:  set .unitToProduce null                                      ...
   58:  jump *label22 greaterThanEq .flares 8                        ...
   59:  set .unitToProduce @flare                                    ...
        label *label22                                               ...
        label *label20                                               ...
   60:  set .lastProgress 0                                          lastProgress = 0;
   61:  jump *label9 always 0 0                                      elsif lastProgress > factoryProgress + 0.1 then
        label *label12                                               ...
   62:  sensor *tmp53 .factory @config                               elsif factory.config != unitToProduce then
   63:  jump *label23 equal *tmp53 .unitToProduce                    ...
   64:  control enabled .factory true 0 0 0                          factory.enabled = true;
   65:  control config .factory .unitToProduce 0 0 0                 factory.config = unitToProduce;
   66:  set .lastProgress 0                                          lastProgress = 0;
   67:  jump *label9 always 0 0                                      elsif factory.config != unitToProduce then
        label *label23                                               ...
   68:  control enabled .factory true 0 0 0                          factory.enabled = true;
   69:  set .lastProgress .factoryProgress                           lastProgress = factoryProgress;
   70:  jump *label9 always 0 0                                      if buildUnits then
        label *label8                                                ...
   71:  control enabled .factory false 0 0 0                         factory.enabled = false;
        label *label9                                                if buildUnits then
   72:  jump *label25 equal .generator2 null                         if generator2 != null then
   73:  sensor *tmp67 .generator2 @coal                              if generator2.@coal < 3 then
   74:  jump *label27 greaterThanEq *tmp67 3                         ...
   75:  control config .unloader2 @coal 0 0 0                        unloader2.config = @coal;
   76:  jump *label3 always 0 0                                      continue;
        label *label27                                               if generator2.@coal < 3 then
        label *label25                                               if generator2 != null then
   77:  set *tmp75 30                                                var siliconLimit = factory.config == @mono ? 60 : 30;
   78:  sensor *tmp73 .factory @config                               ...
   79:  jump *label30 notEqual *tmp73 @mono                          ...
   80:  set *tmp75 60                                                ...
        label *label30                                               ...
   81:  sensor *tmp76 .factory @silicon                              if factory.@silicon < siliconLimit and core.@silicon > 0 then
   82:  op lessThan *tmp77 *tmp76 *tmp75                             ...
   83:  sensor *tmp78 .core @silicon                                 ...
   84:  op greaterThan *tmp79 *tmp78 0                               ...
   85:  op land *tmp80 *tmp77 *tmp79                                 ...
   86:  jump *label31 equal *tmp80 false                             ...
   87:  control config .unloader2 @silicon 0 0 0                     unloader2.config = @silicon;
   88:  jump *label3 always 0 0                                      if factory.@silicon < siliconLimit and core.@silicon > 0 then
        label *label31                                               ...
   89:  control config .unloader2 @lead 0 0 0                        unloader2.config = @lead;
   90:  jump *label3 always 0 0                                      while true do


Performance: parsed in 181 ms, compiled in 220 ms, optimized in 241 ms, run in 2 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (5 steps):
The program didn't generate any output.
Execution exception at instruction 8: sensor *tmp5 .core @graphite:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
