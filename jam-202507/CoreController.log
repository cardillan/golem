   338 instructions before optimizations.
    29 instructions eliminated by Temp Variables Elimination (3 iterations).
     2 instructions eliminated by Case Expression Optimization.
    40 instructions eliminated by Dead Code Elimination (7 iterations).
C:\Home\golem\jam-202507\CoreController.mnd:39:5 Variable 'loopTicks' is not used.
     5 instructions eliminated by Jump Normalization (2 passes, 5 iterations).
    14 instructions eliminated by Jump Optimization (5 iterations).
    11 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     2 instructions modified by Expression Optimization (3 iterations).
     3 instructions eliminated by If Expression Optimization (3 iterations).
    25 instructions eliminated by Data Flow Optimization (3 passes, 11 iterations).
    62 instructions added by Function Inlining (4 iterations).
     3 function calls inlined by Function Inlining.
     5 instructions eliminated by Jump Straightening (5 iterations).
     6 instructions updated by JumpThreading.
    28 instructions eliminated by Unreachable Code Elimination (2 iterations).
   238 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 775):
  * Inline function 'factoryUnitFinished' defined at line 77:1   size   +67, benefit      109.4, efficiency      1.632 (+60 instructions)
    Inline function call at line 167:13                          size   +34, benefit       21.9, efficiency      0.643
    Inline function call at line 179:13                          size   +34, benefit       43.8, efficiency      1.287
    Inline function call at line 186:13                          size   +34, benefit       43.8, efficiency      1.287

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
   338 write *tmp160 .bank *tmp156
   339 label *label51
   340 label *label50
-    * set *tmp162 :factoryUnitFinished:unit
-    * jump *label54 equal *tmp162 @flare
+  341 jump *label54 equal :factoryUnitFinished:unit @flare
   342 jump *label53 always
   343 label *label54
   344 op add *tmp163 .flares 1
 
   347 set *tmp161 *tmp163
   348 jump *label52 always
   349 label *label53
-    * jump *label56 equal *tmp162 @mono
+  350 jump *label56 equal :factoryUnitFinished:unit @mono
   351 jump *label55 always
   352 label *label56
   353 op add *tmp164 .monos 1
 
   356 set *tmp161 *tmp164
   357 jump *label52 always
   358 label *label55
-    * jump *label58 equal *tmp162 @poly
+  359 jump *label58 equal :factoryUnitFinished:unit @poly
   360 jump *label57 always
   361 label *label58
   362 op add *tmp165 .polys 1
 
   365 set *tmp161 *tmp165
   366 jump *label52 always
   367 label *label57
-    * jump *label60 equal *tmp162 @mega
+  368 jump *label60 equal :factoryUnitFinished:unit @mega
   369 jump *label59 always
   370 label *label60
   371 op add *tmp166 .megas 1
 
   381 set *tmp152 .factoryDone
   382 jump *label49 always
   383 label *label48
-    * set *tmp168 :factoryUnitFinished:unit
-    * jump *label63 equal *tmp168 @flare
-    * jump *label63 equal *tmp168 @mono
+  384 jump *label63 equal :factoryUnitFinished:unit @flare
+  385 jump *label63 equal :factoryUnitFinished:unit @mono
   386 jump *label62 always
   387 label *label63
   388 set .factoryDone 1

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-25 instructions):
 
    46 jump *label7 equal .smelter2 false
    47 set *tmp27 .unloader1
    48 control config *tmp27 @coal
-    * set *tmp26 @coal
    49 jump *label8 always
    50 label *label7
-    * set *tmp26 null
    51 label *label8
    52 sensor *tmp29 .battery @totalPower
    53 set :backgroundProcess:power *tmp29
 
    58 set *tmp34 .generator2
    59 op lessThan *tmp36 :backgroundProcess:power 3800
    60 control enabled *tmp34 *tmp36
-    * set *tmp30 *tmp36
    61 jump *label10 always
    62 label *label9
    63 set *tmp37 .generator
    64 op lessThan *tmp39 :backgroundProcess:power 800
    65 control enabled *tmp37 *tmp39
-    * set *tmp30 *tmp39
    66 label *label10
    67 sensor *tmp40 .factory @progress
    68 set :backgroundProcess:factoryProgress *tmp40
 
    79 set *tmp47 .targetUnit
    80 control config *tmp45 *tmp47
    81 set :backgroundProcess:blockFactory false
-    * set *tmp44 :backgroundProcess:blockFactory
    82 jump *label12 always
    83 label *label11
    84 op lessThan *tmp48 .monos .monoTarget
 
   152 label *label16
   153 set *tmp49 *tmp54
   154 label *label14
-    * set *tmp44 *tmp49
   155 label *label12
   156 set :fuzzyUpdate:value :backgroundProcess:power
   157 set :fuzzyUpdate:limitLow 200
 
   160 set :updateIfSmaller:b :fuzzyUpdate:limitLow
   161 set :updateIfSmaller:newValue false
   162 select :backgroundProcess:enableFactory lessThan :updateIfSmaller:a :updateIfSmaller:b :updateIfSmaller:newValue :backgroundProcess:enableFactory
-    * set *tmp79 null
   163 label *label24
   164 set :updateIfSmaller.1:a :fuzzyUpdate:limitHigh
   165 set :updateIfSmaller.1:b :fuzzyUpdate:value
 
   167 select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
   168 set *tmp80 null
   169 label *label25
-    * set *tmp78 *tmp80
   170 label *label23
   171 op equal *tmp81 .factoryUnit null
   172 jump *label26 equal *tmp81 false
 
   175 set *tmp85 .factory
   176 control config *tmp85 @mono
   177 set :backgroundProcess:lastProgress 0
-    * set *tmp82 :backgroundProcess:lastProgress
   178 jump *label27 always
   179 label *label26
   180 op add *tmp87 :backgroundProcess:factoryProgress 0.1
 
   216 label *label32
   217 set *tmp89 *tmp97
   218 label *label29
-    * set *tmp82 *tmp89
   219 label *label27
   220 op add *tmp109 :backgroundProcess:reconstructorProgress 0.1
   221 op greaterThan *tmp110 :backgroundProcess:lastRecoProgress *tmp109
 
   225 call *label0 *invalid :factoryUnitFinished*retval (m:*label35) (h:*label35)
   226 label *label35
   227 set :backgroundProcess:lastRecoProgress 0
-    * set *tmp111 :backgroundProcess:lastRecoProgress
   228 jump *label34 always
   229 label *label33
   230 set :backgroundProcess:lastRecoProgress :backgroundProcess:reconstructorProgress
-    * set *tmp111 :backgroundProcess:lastRecoProgress
   231 label *label34
   232 op add *tmp112 :backgroundProcess:multiReconstructorProgress 0.1
   233 op greaterThan *tmp113 :backgroundProcess:lastMultiProgress *tmp112
 
   237 call *label0 *invalid :factoryUnitFinished*retval (m:*label38) (h:*label38)
   238 label *label38
   239 set :backgroundProcess:lastMultiProgress 0
-    * set *tmp114 :backgroundProcess:lastMultiProgress
   240 jump *label37 always
   241 label *label36
   242 set :backgroundProcess:lastMultiProgress :backgroundProcess:multiReconstructorProgress
-    * set *tmp114 :backgroundProcess:lastMultiProgress
   243 label *label37
   244 sensor *tmp115 .generator2 @coal
   245 op mul *tmp116 5 .generator2
 
   248 set *tmp119 .unloader2
   249 control config *tmp119 @coal
   250 jump *label5 always
-    * set *tmp118 null
   251 jump *label40 always
   252 label *label39
-    * set *tmp118 null
   253 label *label40
   254 set *tmp121 .unloader4
   255 op greaterThan *tmp123 :backgroundProcess:coreSilicon .siliconReserve
 
   267 jump *label41 equal *tmp132 false
   268 set *tmp134 .unloader2
   269 control config *tmp134 @lead
-    * set *tmp133 @lead
   270 jump *label42 always
   271 label *label41
   272 op greaterThan *tmp136 :backgroundProcess:coreSilicon .siliconReserve
 
   280 control config *tmp140 @coal
   281 set *tmp137 @coal
   282 label *label44
-    * set *tmp133 *tmp137
   283 label *label42
   284 set *tmp142 .unloader6
   285 sensor *tmp144 .multiReconstructor @silicon
 
   326 op add *tmp163 .flares 1
   327 set .flares *tmp163
   328 write *tmp163 .display ".displayFlares"
-    * set *tmp161 *tmp163
   329 jump *label52 always
   330 label *label53
   331 jump *label56 equal :factoryUnitFinished:unit @mono
 
   334 op add *tmp164 .monos 1
   335 set .monos *tmp164
   336 write *tmp164 .display ".displayMonos"
-    * set *tmp161 *tmp164
   337 jump *label52 always
   338 label *label55
   339 jump *label58 equal :factoryUnitFinished:unit @poly
 
   342 op add *tmp165 .polys 1
   343 set .polys *tmp165
   344 write *tmp165 .display ".displayPolys"
-    * set *tmp161 *tmp165
   345 jump *label52 always
   346 label *label57
   347 jump *label60 equal :factoryUnitFinished:unit @mega
 
   350 op add *tmp166 .megas 1
   351 set .megas *tmp166
   352 write *tmp166 .display ".displayMegas"
-    * set *tmp161 *tmp166
   353 jump *label52 always
   354 label *label59
-    * set *tmp161 null
   355 label *label52
   356 write true .display ".displayUnitReset"
   357 set .factoryDone 0
-    * set *tmp152 .factoryDone
   358 jump *label49 always
   359 label *label48
   360 jump *label63 equal :factoryUnitFinished:unit @flare
 
   367 label *label62
   368 set *tmp167 null
   369 label *label61
-    * set *tmp152 *tmp167
   370 label *label49
   371 label *label47
   372 return :factoryUnitFinished*retaddr

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-9 instructions):
 
    90 set *tmp52 .targetUnit
    91 control config *tmp50 *tmp52
    92 set :backgroundProcess:blockFactory false
-    * set *tmp49 :backgroundProcess:blockFactory
    93 jump *label14 always
    94 label *label13
    95 op lessThan *tmp53 .polys .polyTarget
 
   149 label *label20
   150 set *tmp54 *tmp67
   151 label *label16
-    * set *tmp49 *tmp54
   152 label *label14
   153 label *label12
   154 set :fuzzyUpdate:value :backgroundProcess:power
 
   163 set :updateIfSmaller.1:b :fuzzyUpdate:value
   164 set :updateIfSmaller.1:newValue true
   165 select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
-    * set *tmp80 null
   166 label *label25
   167 label *label23
   168 op equal *tmp81 .factoryUnit null
 
   186 call *label0 *invalid :factoryUnitFinished*retval (m:*label30) (h:*label30)
   187 label *label30
   188 set :backgroundProcess:lastProgress 0
-    * set *tmp89 :backgroundProcess:lastProgress
   189 jump *label29 always
   190 label *label28
   191 set *tmp94 .factory
 
   210 set :backgroundProcess:lastProgress :backgroundProcess:factoryProgress
   211 set *tmp97 :backgroundProcess:lastProgress
   212 label *label32
-    * set *tmp89 *tmp97
   213 label *label29
   214 label *label27
   215 op add *tmp109 :backgroundProcess:reconstructorProgress 0.1
 
   268 jump *label43 equal *tmp136 false
   269 set *tmp138 .unloader2
   270 control config *tmp138 @silicon
-    * set *tmp137 @silicon
   271 jump *label44 always
   272 label *label43
   273 set *tmp140 .unloader2
   274 control config *tmp140 @coal
-    * set *tmp137 @coal
   275 label *label44
   276 label *label42
   277 set *tmp142 .unloader6
 
   355 jump *label62 always
   356 label *label63
   357 set .factoryDone 1
-    * set *tmp167 .factoryDone
   358 jump *label61 always
   359 label *label62
-    * set *tmp167 null
   360 label *label61
   361 label *label49
   362 label *label47

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   114 op mul *tmp64 *tmp63 :backgroundProcess:factoryProgress
   115 op greaterThan *tmp65 *tmp64 :backgroundProcess:reconstructorProgress
   116 set :backgroundProcess:blockFactory *tmp65
-    * set *tmp54 :backgroundProcess:blockFactory
   117 jump *label16 always
   118 label *label15
   119 op lessThan *tmp66 .megas .megaTarget
 
   146 set :backgroundProcess:blockFactory false
   147 set *tmp67 :backgroundProcess:blockFactory
   148 label *label20
-    * set *tmp54 *tmp67
   149 label *label16
   150 label *label14
   151 label *label12
 
   198 set *tmp104 .factoryUnit
   199 control config *tmp102 *tmp104
   200 set :backgroundProcess:lastProgress 0
-    * set *tmp97 :backgroundProcess:lastProgress
   201 jump *label32 always
   202 label *label31
   203 set *tmp105 .factory
 
   205 op land *tmp108 :backgroundProcess:enableFactory *tmp107
   206 control enabled *tmp105 *tmp108
   207 set :backgroundProcess:lastProgress :backgroundProcess:factoryProgress
-    * set *tmp97 :backgroundProcess:lastProgress
   208 label *label32
   209 label *label29
   210 label *label27

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   137 set *tmp77 .targetUnit
   138 control config *tmp75 *tmp77
   139 set :backgroundProcess:blockFactory false
-    * set *tmp67 :backgroundProcess:blockFactory
   140 jump *label20 always
   141 label *label19
   142 set .factoryUnit null
   143 set .targetUnit null
   144 write null .display ".displayNextUnit"
   145 set :backgroundProcess:blockFactory false
-    * set *tmp67 :backgroundProcess:blockFactory
   146 label *label20
   147 label *label16
   148 label *label14

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-25 instructions):
 
    22 label *label4
    23 jump *label6 equal true false
    24 set :backgroundProcess:ticks @tick
-    * sensor *tmp7 .core @silicon
-    * set :backgroundProcess:coreSilicon *tmp7
-    * sensor *tmp8 .core @graphite
-    * set :backgroundProcess:coreGraphite *tmp8
+   25 sensor :backgroundProcess:coreSilicon .core @silicon
+   26 sensor :backgroundProcess:coreGraphite .core @graphite
    27 set *tmp9 .smelter2
    28 set *tmp11 .smelter
    29 op lessThan *tmp13 :backgroundProcess:coreSilicon .smelterTarget
 
    42 op lessThan *tmp25 *tmp24 .kilnTarget
    43 control enabled *tmp22 *tmp25
    44 jump *label7 equal .smelter2 false
-    * set *tmp27 .unloader1
-    * control config *tmp27 @coal
+   45 control config .unloader1 @coal
    46 jump *label8 always
    47 label *label7
    48 label *label8
-    * sensor *tmp29 .battery @totalPower
-    * set :backgroundProcess:power *tmp29
+   49 sensor :backgroundProcess:power .battery @totalPower
    50 jump *label9 equal .generator2 false
    51 set *tmp31 .generator
    52 op lessThan *tmp33 :backgroundProcess:power 10
 
    60 op lessThan *tmp39 :backgroundProcess:power 800
    61 control enabled *tmp37 *tmp39
    62 label *label10
-    * sensor *tmp40 .factory @progress
-    * set :backgroundProcess:factoryProgress *tmp40
-    * sensor *tmp41 .reconstructor @progress
-    * set :backgroundProcess:reconstructorProgress *tmp41
-    * sensor *tmp42 .multiReconstructor @progress
-    * set :backgroundProcess:multiReconstructorProgress *tmp42
+   63 sensor :backgroundProcess:factoryProgress .factory @progress
+   64 sensor :backgroundProcess:reconstructorProgress .reconstructor @progress
+   65 sensor :backgroundProcess:multiReconstructorProgress .multiReconstructor @progress
    66 op lessThan *tmp43 .flares .flareTarget
    67 jump *label11 equal *tmp43 false
    68 set .factoryUnit @flare
    69 set .targetUnit @flare
    70 write @flare .display ".displayNextUnit"
    71 set *tmp45 .payloadRouter
-    * set *tmp47 .targetUnit
-    * control config *tmp45 *tmp47
+   72 control config *tmp45 .targetUnit
    73 set :backgroundProcess:blockFactory false
    74 jump *label12 always
    75 label *label11
 
    79 set .targetUnit @mono
    80 write @mono .display ".displayNextUnit"
    81 set *tmp50 .payloadRouter
-    * set *tmp52 .targetUnit
-    * control config *tmp50 *tmp52
+   82 control config *tmp50 .targetUnit
    83 set :backgroundProcess:blockFactory false
    84 jump *label14 always
    85 label *label13
 
    96 set .factoryUnit *tmp57
    97 set .targetUnit @poly
    98 write @poly .display ".displayNextUnit"
-    * set *tmp58 .reconstructor
-    * control enabled *tmp58 true
+   99 control enabled .reconstructor true
   100 set *tmp60 .payloadRouter
-    * set *tmp62 .targetUnit
-    * control config *tmp60 *tmp62
+  101 control config *tmp60 .targetUnit
   102 sensor *tmp63 .reconstructor @payloadCount
   103 op mul *tmp64 *tmp63 :backgroundProcess:factoryProgress
-    * op greaterThan *tmp65 *tmp64 :backgroundProcess:reconstructorProgress
-    * set :backgroundProcess:blockFactory *tmp65
+  104 op greaterThan :backgroundProcess:blockFactory *tmp64 :backgroundProcess:reconstructorProgress
   105 jump *label16 always
   106 label *label15
   107 op lessThan *tmp66 .megas .megaTarget
 
   122 op or *tmp74 .multiReconstructor *tmp73
   123 control enabled *tmp71 *tmp74
   124 set *tmp75 .payloadRouter
-    * set *tmp77 .targetUnit
-    * control config *tmp75 *tmp77
+  125 control config *tmp75 .targetUnit
   126 set :backgroundProcess:blockFactory false
   127 jump *label20 always
   128 label *label19
 
   150 label *label23
   151 op equal *tmp81 .factoryUnit null
   152 jump *label26 equal *tmp81 false
-    * set *tmp83 .factory
-    * control enabled *tmp83 false
-    * set *tmp85 .factory
-    * control config *tmp85 @mono
+  153 control enabled .factory false
+  154 control config .factory @mono
   155 set :backgroundProcess:lastProgress 0
   156 jump *label27 always
   157 label *label26
 
   169 set :backgroundProcess:lastProgress 0
   170 jump *label29 always
   171 label *label28
-    * set *tmp94 .factory
-    * sensor *tmp95 *tmp94 @config
+  172 sensor *tmp95 .factory @config
   173 op notEqual *tmp96 *tmp95 .factoryUnit
   174 jump *label31 equal *tmp96 false
   175 set *tmp98 .factory
   176 op equal *tmp100 :backgroundProcess:blockFactory false
   177 op land *tmp101 :backgroundProcess:enableFactory *tmp100
   178 control enabled *tmp98 *tmp101
-    * set *tmp102 .factory
-    * set *tmp104 .factoryUnit
-    * control config *tmp102 *tmp104
+  179 control config .factory .factoryUnit
   180 set :backgroundProcess:lastProgress 0
   181 jump *label32 always
   182 label *label31
 
   216 op mul *tmp116 5 .generator2
   217 op lessThan *tmp117 *tmp115 *tmp116
   218 jump *label39 equal *tmp117 false
-    * set *tmp119 .unloader2
-    * control config *tmp119 @coal
+  219 control config .unloader2 @coal
   220 jump *label5 always
   221 jump *label40 always
   222 label *label39
 
   227 op land *tmp125 *tmp123 *tmp124
   228 control enabled *tmp121 *tmp125
   229 op equal *tmp126 .factoryUnit @mono
-    * op mul *tmp127 *tmp126 30
-    * set :backgroundProcess:leadLimit *tmp127
+  230 op mul :backgroundProcess:leadLimit *tmp126 30
   231 sensor *tmp128 .factory @lead
   232 op lessThan *tmp129 *tmp128 :backgroundProcess:leadLimit
   233 sensor *tmp130 .core @lead
   234 op greaterThan *tmp131 *tmp130 .leadReserve
   235 op land *tmp132 *tmp129 *tmp131
   236 jump *label41 equal *tmp132 false
-    * set *tmp134 .unloader2
-    * control config *tmp134 @lead
+  237 control config .unloader2 @lead
   238 jump *label42 always
   239 label *label41
   240 op greaterThan *tmp136 :backgroundProcess:coreSilicon .siliconReserve
   241 jump *label43 equal *tmp136 false
-    * set *tmp138 .unloader2
-    * control config *tmp138 @silicon
+  242 control config .unloader2 @silicon
   243 jump *label44 always
   244 label *label43
-    * set *tmp140 .unloader2
-    * control config *tmp140 @coal
+  245 control config .unloader2 @coal
   246 label *label44
   247 label *label42
   248 set *tmp142 .unloader6
 
   258 set *tmp149 @silicon
   259 label *label46
   260 control config *tmp142 *tmp149
-    * op sub *tmp150 @tick :backgroundProcess:ticks
-    * set .loopTicks *tmp150
+  261 op sub .loopTicks @tick :backgroundProcess:ticks
   262 label *label5
   263 jump *label4 always
   264 label *label6
 
   271 jump *label48 equal *tmp151 false
   272 set :logUnit:unit :factoryUnitFinished:unit
   273 sensor *tmp153 :logUnit:unit @id
-    * op add *tmp154 @blockCount *tmp153
-    * set :log:encodedId *tmp154
+  274 op add :log:encodedId @blockCount *tmp153
   275 read *tmp6 .bank 511
   276 op sub *tmp155 *tmp6 1
   277 write *tmp155 .bank 511

Modifications by Initial phase, Temp Variables Elimination, iteration 2 (-4 instructions):
 
    68 set .factoryUnit @flare
    69 set .targetUnit @flare
    70 write @flare .display ".displayNextUnit"
-    * set *tmp45 .payloadRouter
-    * control config *tmp45 .targetUnit
+   71 control config .payloadRouter .targetUnit
    72 set :backgroundProcess:blockFactory false
    73 jump *label12 always
    74 label *label11
 
    77 set .factoryUnit @mono
    78 set .targetUnit @mono
    79 write @mono .display ".displayNextUnit"
-    * set *tmp50 .payloadRouter
-    * control config *tmp50 .targetUnit
+   80 control config .payloadRouter .targetUnit
    81 set :backgroundProcess:blockFactory false
    82 jump *label14 always
    83 label *label13
 
    95 set .targetUnit @poly
    96 write @poly .display ".displayNextUnit"
    97 control enabled .reconstructor true
-    * set *tmp60 .payloadRouter
-    * control config *tmp60 .targetUnit
+   98 control config .payloadRouter .targetUnit
    99 sensor *tmp63 .reconstructor @payloadCount
   100 op mul *tmp64 *tmp63 :backgroundProcess:factoryProgress
   101 op greaterThan :backgroundProcess:blockFactory *tmp64 :backgroundProcess:reconstructorProgress
 
   118 op lessThan *tmp73 :backgroundProcess:reconstructorProgress 0.75
   119 op or *tmp74 .multiReconstructor *tmp73
   120 control enabled *tmp71 *tmp74
-    * set *tmp75 .payloadRouter
-    * control config *tmp75 .targetUnit
+  121 control config .payloadRouter .targetUnit
   122 set :backgroundProcess:blockFactory false
   123 jump *label20 always
   124 label *label19

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    20 set :backgroundProcess:enableFactory true
    21 set :backgroundProcess:blockFactory false
    22 label *label4
-    * jump *label6 equal true false
    23 set :backgroundProcess:ticks @tick
    24 sensor :backgroundProcess:coreSilicon .core @silicon
    25 sensor :backgroundProcess:coreGraphite .core @graphite

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-5 instructions):
 
   277 write *tmp160 .bank *tmp156
   278 label *label51
   279 label *label50
-    * jump *label54 equal :factoryUnitFinished:unit @flare
-    * jump *label53 always
+  280 jump *label53 notEqual :factoryUnitFinished:unit @flare
   281 label *label54
   282 op add *tmp163 .flares 1
   283 set .flares *tmp163
   284 write *tmp163 .display ".displayFlares"
   285 jump *label52 always
   286 label *label53
-    * jump *label56 equal :factoryUnitFinished:unit @mono
-    * jump *label55 always
+  287 jump *label55 notEqual :factoryUnitFinished:unit @mono
   288 label *label56
   289 op add *tmp164 .monos 1
   290 set .monos *tmp164
   291 write *tmp164 .display ".displayMonos"
   292 jump *label52 always
   293 label *label55
-    * jump *label58 equal :factoryUnitFinished:unit @poly
-    * jump *label57 always
+  294 jump *label57 notEqual :factoryUnitFinished:unit @poly
   295 label *label58
   296 op add *tmp165 .polys 1
   297 set .polys *tmp165
   298 write *tmp165 .display ".displayPolys"
   299 jump *label52 always
   300 label *label57
-    * jump *label60 equal :factoryUnitFinished:unit @mega
-    * jump *label59 always
+  301 jump *label59 notEqual :factoryUnitFinished:unit @mega
   302 label *label60
   303 op add *tmp166 .megas 1
   304 set .megas *tmp166
 
   311 jump *label49 always
   312 label *label48
   313 jump *label63 equal :factoryUnitFinished:unit @flare
-    * jump *label63 equal :factoryUnitFinished:unit @mono
-    * jump *label62 always
+  314 jump *label62 notEqual :factoryUnitFinished:unit @mono
   315 label *label63
   316 set .factoryDone 1
   317 jump *label61 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-14 instructions):
 
    62 sensor :backgroundProcess:factoryProgress .factory @progress
    63 sensor :backgroundProcess:reconstructorProgress .reconstructor @progress
    64 sensor :backgroundProcess:multiReconstructorProgress .multiReconstructor @progress
-    * op lessThan *tmp43 .flares .flareTarget
-    * jump *label11 equal *tmp43 false
+   65 jump *label11 greaterThanEq .flares .flareTarget
    66 set .factoryUnit @flare
    67 set .targetUnit @flare
    68 write @flare .display ".displayNextUnit"
 
    70 set :backgroundProcess:blockFactory false
    71 jump *label12 always
    72 label *label11
-    * op lessThan *tmp48 .monos .monoTarget
-    * jump *label13 equal *tmp48 false
+   73 jump *label13 greaterThanEq .monos .monoTarget
    74 set .factoryUnit @mono
    75 set .targetUnit @mono
    76 write @mono .display ".displayNextUnit"
 
    78 set :backgroundProcess:blockFactory false
    79 jump *label14 always
    80 label *label13
-    * op lessThan *tmp53 .polys .polyTarget
-    * jump *label15 equal *tmp53 false
+   81 jump *label15 greaterThanEq .polys .polyTarget
    82 op add *tmp55 .factoryDone .polys
-    * op lessThan *tmp56 *tmp55 .polyTarget
-    * jump *label17 equal *tmp56 false
+   83 jump *label17 greaterThanEq *tmp55 .polyTarget
    84 set *tmp57 @mono
    85 jump *label18 always
    86 label *label17
 
    96 op greaterThan :backgroundProcess:blockFactory *tmp64 :backgroundProcess:reconstructorProgress
    97 jump *label16 always
    98 label *label15
-    * op lessThan *tmp66 .megas .megaTarget
-    * jump *label19 equal *tmp66 false
+   99 jump *label19 greaterThanEq .megas .megaTarget
   100 op add *tmp68 .factoryDone .megas
-    * op lessThan *tmp69 *tmp68 .megaTarget
-    * jump *label21 equal *tmp69 false
+  101 jump *label21 greaterThanEq *tmp68 .megaTarget
   102 set *tmp70 @mono
   103 jump *label22 always
   104 label *label21
 
   137 select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
   138 label *label25
   139 label *label23
-    * op equal *tmp81 .factoryUnit null
-    * jump *label26 equal *tmp81 false
+  140 jump *label26 notEqual .factoryUnit null
   141 control enabled .factory false
   142 control config .factory @mono
   143 set :backgroundProcess:lastProgress 0
   144 jump *label27 always
   145 label *label26
   146 op add *tmp87 :backgroundProcess:factoryProgress 0.1
-    * op greaterThan *tmp88 :backgroundProcess:lastProgress *tmp87
-    * jump *label28 equal *tmp88 false
+  147 jump *label28 lessThanEq :backgroundProcess:lastProgress *tmp87
   148 set *tmp90 .factory
   149 op equal *tmp92 :backgroundProcess:blockFactory false
   150 op land *tmp93 :backgroundProcess:enableFactory *tmp92
 
   157 jump *label29 always
   158 label *label28
   159 sensor *tmp95 .factory @config
-    * op notEqual *tmp96 *tmp95 .factoryUnit
-    * jump *label31 equal *tmp96 false
+  160 jump *label31 equal *tmp95 .factoryUnit
   161 set *tmp98 .factory
   162 op equal *tmp100 :backgroundProcess:blockFactory false
   163 op land *tmp101 :backgroundProcess:enableFactory *tmp100
 
   175 label *label29
   176 label *label27
   177 op add *tmp109 :backgroundProcess:reconstructorProgress 0.1
-    * op greaterThan *tmp110 :backgroundProcess:lastRecoProgress *tmp109
-    * jump *label33 equal *tmp110 false
+  178 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp109
   179 set :factoryUnitFinished:unit @poly
   180 setaddr :factoryUnitFinished*retaddr *label35 (h:*label35)
   181 call *label0 *invalid :factoryUnitFinished*retval (m:*label35) (h:*label35)
 
   186 set :backgroundProcess:lastRecoProgress :backgroundProcess:reconstructorProgress
   187 label *label34
   188 op add *tmp112 :backgroundProcess:multiReconstructorProgress 0.1
-    * op greaterThan *tmp113 :backgroundProcess:lastMultiProgress *tmp112
-    * jump *label36 equal *tmp113 false
+  189 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp112
   190 set :factoryUnitFinished:unit @mega
   191 setaddr :factoryUnitFinished*retaddr *label38 (h:*label38)
   192 call *label0 *invalid :factoryUnitFinished*retval (m:*label38) (h:*label38)
 
   198 label *label37
   199 sensor *tmp115 .generator2 @coal
   200 op mul *tmp116 5 .generator2
-    * op lessThan *tmp117 *tmp115 *tmp116
-    * jump *label39 equal *tmp117 false
+  201 jump *label39 greaterThanEq *tmp115 *tmp116
   202 control config .unloader2 @coal
   203 jump *label5 always
   204 jump *label40 always
 
   220 control config .unloader2 @lead
   221 jump *label42 always
   222 label *label41
-    * op greaterThan *tmp136 :backgroundProcess:coreSilicon .siliconReserve
-    * jump *label43 equal *tmp136 false
+  223 jump *label43 lessThanEq :backgroundProcess:coreSilicon .siliconReserve
   224 control config .unloader2 @silicon
   225 jump *label44 always
   226 label *label43
 
   249 jump *label2 always
   250 end
   251 label *label0
-    * op equal *tmp151 :factoryUnitFinished:unit .targetUnit
-    * jump *label48 equal *tmp151 false
+  252 jump *label48 notEqual :factoryUnitFinished:unit .targetUnit
   253 set :logUnit:unit :factoryUnitFinished:unit
   254 sensor *tmp153 :logUnit:unit @id
   255 op add :log:encodedId @blockCount *tmp153

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    42 control enabled *tmp22 *tmp25
    43 jump *label7 equal .smelter2 false
    44 control config .unloader1 @coal
-    * jump *label8 always
    45 label *label7
    46 label *label8
    47 sensor :backgroundProcess:power .battery @totalPower
 
   200 jump *label39 greaterThanEq *tmp115 *tmp116
   201 control config .unloader2 @coal
   202 jump *label5 always
-    * jump *label40 always
   203 label *label39
   204 label *label40
   205 set *tmp121 .unloader4
 
   287 op add *tmp166 .megas 1
   288 set .megas *tmp166
   289 write *tmp166 .display ".displayMegas"
-    * jump *label52 always
   290 label *label59
   291 label *label52
   292 write true .display ".displayUnitReset"
 
   297 jump *label62 notEqual :factoryUnitFinished:unit @mono
   298 label *label63
   299 set .factoryDone 1
-    * jump *label61 always
   300 label *label62
   301 label *label61
   302 label *label49

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
 
    12 set *signature "0:v1"
    13 label *label2
    14 set :backgroundProcess:lastProgress 0
-    * set :backgroundProcess:factoryProgress 0
    15 set :backgroundProcess:lastRecoProgress 0
-    * set :backgroundProcess:reconstructorProgress 0
    16 set :backgroundProcess:lastMultiProgress 0
-    * set :backgroundProcess:multiReconstructorProgress 0
    17 set :backgroundProcess:enableFactory true
-    * set :backgroundProcess:blockFactory false
    18 label *label4
    19 set :backgroundProcess:ticks @tick
    20 sensor :backgroundProcess:coreSilicon .core @silicon
 
   121 set :fuzzyUpdate:value :backgroundProcess:power
   122 set :fuzzyUpdate:limitLow 200
   123 set :fuzzyUpdate:limitHigh 500
-    * set :updateIfSmaller:a :fuzzyUpdate:value
-    * set :updateIfSmaller:b :fuzzyUpdate:limitLow
+  124 set :updateIfSmaller:a :backgroundProcess:power
+  125 set :updateIfSmaller:b 200
   126 set :updateIfSmaller:newValue false
-    * select :backgroundProcess:enableFactory lessThan :updateIfSmaller:a :updateIfSmaller:b :updateIfSmaller:newValue :backgroundProcess:enableFactory
+  127 select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:value :fuzzyUpdate:limitLow false :backgroundProcess:enableFactory
   128 label *label24
-    * set :updateIfSmaller.1:a :fuzzyUpdate:limitHigh
-    * set :updateIfSmaller.1:b :fuzzyUpdate:value
+  129 set :updateIfSmaller.1:a 500
+  130 set :updateIfSmaller.1:b :backgroundProcess:power
   131 set :updateIfSmaller.1:newValue true
-    * select :backgroundProcess:enableFactory lessThan :updateIfSmaller.1:a :updateIfSmaller.1:b :updateIfSmaller.1:newValue :backgroundProcess:enableFactory
+  132 select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:limitHigh :fuzzyUpdate:value true :backgroundProcess:enableFactory
   133 label *label25
   134 label *label23
   135 jump *label26 notEqual .factoryUnit null
 
   245 label *label0
   246 jump *label48 notEqual :factoryUnitFinished:unit .targetUnit
   247 set :logUnit:unit :factoryUnitFinished:unit
-    * sensor *tmp153 :logUnit:unit @id
+  248 sensor *tmp153 :factoryUnitFinished:unit @id
   249 op add :log:encodedId @blockCount *tmp153
   250 read *tmp6 .bank 511
   251 op sub *tmp155 *tmp6 1
 
   254 read *tmp158 .timer "time"
   255 op mul *tmp159 *tmp158 1000
   256 op add *tmp160 :log:encodedId *tmp159
-    * write *tmp160 .bank *tmp156
+  257 write *tmp160 .bank *tmp155
   258 label *label51
   259 label *label50
   260 jump *label53 notEqual :factoryUnitFinished:unit @flare

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-8 instructions):
 
   121 set :fuzzyUpdate:value :backgroundProcess:power
   122 set :fuzzyUpdate:limitLow 200
   123 set :fuzzyUpdate:limitHigh 500
-    * set :updateIfSmaller:a :backgroundProcess:power
-    * set :updateIfSmaller:b 200
-    * set :updateIfSmaller:newValue false
-    * select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:value :fuzzyUpdate:limitLow false :backgroundProcess:enableFactory
+  124 select :backgroundProcess:enableFactory lessThan :backgroundProcess:power 200 false :backgroundProcess:enableFactory
   125 label *label24
-    * set :updateIfSmaller.1:a 500
-    * set :updateIfSmaller.1:b :backgroundProcess:power
-    * set :updateIfSmaller.1:newValue true
-    * select :backgroundProcess:enableFactory lessThan :fuzzyUpdate:limitHigh :fuzzyUpdate:value true :backgroundProcess:enableFactory
+  126 select :backgroundProcess:enableFactory lessThan 500 :backgroundProcess:power true :backgroundProcess:enableFactory
   127 label *label25
   128 label *label23
   129 jump *label26 notEqual .factoryUnit null
 
   238 end
   239 label *label0
   240 jump *label48 notEqual :factoryUnitFinished:unit .targetUnit
-    * set :logUnit:unit :factoryUnitFinished:unit
   241 sensor *tmp153 :factoryUnitFinished:unit @id
   242 op add :log:encodedId @blockCount *tmp153
   243 read *tmp6 .bank 511
   244 op sub *tmp155 *tmp6 1
   245 write *tmp155 .bank 511
-    * set *tmp156 *tmp155
   246 read *tmp158 .timer "time"
   247 op mul *tmp159 *tmp158 1000
   248 op add *tmp160 :log:encodedId *tmp159

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
   118 label *label16
   119 label *label14
   120 label *label12
-    * set :fuzzyUpdate:value :backgroundProcess:power
-    * set :fuzzyUpdate:limitLow 200
-    * set :fuzzyUpdate:limitHigh 500
   121 select :backgroundProcess:enableFactory lessThan :backgroundProcess:power 200 false :backgroundProcess:enableFactory
   122 label *label24
   123 select :backgroundProcess:enableFactory lessThan 500 :backgroundProcess:power true :backgroundProcess:enableFactory

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
    74 jump *label14 always
    75 label *label13
    76 jump *label15 greaterThanEq .polys .polyTarget
+   77 set .factoryUnit null
    78 op add *tmp55 .factoryDone .polys
-    * jump *label17 greaterThanEq *tmp55 .polyTarget
-    * set *tmp57 @mono
+   79 jump *label18 greaterThanEq *tmp55 .polyTarget
+   80 set .factoryUnit @mono
    81 jump *label18 always
-    * label *label17
-    * set *tmp57 null
    82 label *label18
-    * set .factoryUnit *tmp57
    83 set .targetUnit @poly
    84 write @poly .display ".displayNextUnit"
    85 control enabled .reconstructor true
 
    90 jump *label16 always
    91 label *label15
    92 jump *label19 greaterThanEq .megas .megaTarget
+   93 set .factoryUnit null
    94 op add *tmp68 .factoryDone .megas
-    * jump *label21 greaterThanEq *tmp68 .megaTarget
-    * set *tmp70 @mono
+   95 jump *label22 greaterThanEq *tmp68 .megaTarget
+   96 set .factoryUnit @mono
    97 jump *label22 always
-    * label *label21
-    * set *tmp70 null
    98 label *label22
-    * set .factoryUnit *tmp70
    99 set .targetUnit @mega
   100 write @mega .display ".displayNextUnit"
   101 set *tmp71 .reconstructor
 
   215 op lessThan *tmp147 *tmp146 80
   216 op land *tmp148 *tmp145 *tmp147
   217 jump *label45 equal *tmp148 false
-    * set *tmp149 @titanium
+  218 control config *tmp142 @titanium
   219 jump *label46 always
   220 label *label45
-    * set *tmp149 @silicon
+  221 control config *tmp142 @silicon
   222 label *label46
-    * control config *tmp142 *tmp149
   223 op sub .loopTicks @tick :backgroundProcess:ticks
   224 label *label5
   225 jump *label4 always

Modifications by Inline function 'factoryUnitFinished' defined at line 77:1 (+62 instructions):
 
   132 op land *tmp93 :backgroundProcess:enableFactory *tmp92
   133 control enabled *tmp90 *tmp93
   134 set :factoryUnitFinished:unit .factoryUnit
-    * setaddr :factoryUnitFinished*retaddr *label30 (h:*label30)
-    * call *label0 *invalid :factoryUnitFinished*retval (m:*label30) (h:*label30)
-    * label *label30
+  135 label *label64
+  136 jump *label76 notEqual :factoryUnitFinished:unit .targetUnit
+  137 sensor *tmp153 :factoryUnitFinished:unit @id
+  138 op add :log:encodedId @blockCount *tmp153
+  139 read *tmp6 .bank 511
+  140 op sub *tmp155 *tmp6 1
+  141 write *tmp155 .bank 511
+  142 read *tmp158 .timer "time"
+  143 op mul *tmp159 *tmp158 1000
+  144 op add *tmp160 :log:encodedId *tmp159
+  145 write *tmp160 .bank *tmp155
+  146 label *label65
+  147 label *label66
+  148 jump *label68 notEqual :factoryUnitFinished:unit @flare
+  149 label *label67
+  150 op add *tmp163 .flares 1
+  151 set .flares *tmp163
+  152 write *tmp163 .display ".displayFlares"
+  153 jump *label75 always
+  154 label *label68
+  155 jump *label70 notEqual :factoryUnitFinished:unit @mono
+  156 label *label69
+  157 op add *tmp164 .monos 1
+  158 set .monos *tmp164
+  159 write *tmp164 .display ".displayMonos"
+  160 jump *label75 always
+  161 label *label70
+  162 jump *label72 notEqual :factoryUnitFinished:unit @poly
+  163 label *label71
+  164 op add *tmp165 .polys 1
+  165 set .polys *tmp165
+  166 write *tmp165 .display ".displayPolys"
+  167 jump *label75 always
+  168 label *label72
+  169 jump *label74 notEqual :factoryUnitFinished:unit @mega
+  170 label *label73
+  171 op add *tmp166 .megas 1
+  172 set .megas *tmp166
+  173 write *tmp166 .display ".displayMegas"
+  174 label *label74
+  175 label *label75
+  176 write true .display ".displayUnitReset"
+  177 set .factoryDone 0
+  178 jump *label80 always
+  179 label *label76
+  180 jump *label77 equal :factoryUnitFinished:unit @flare
+  181 jump *label78 notEqual :factoryUnitFinished:unit @mono
+  182 label *label77
+  183 set .factoryDone 1
+  184 label *label78
+  185 label *label79
+  186 label *label80
+  187 label *label81
   188 set :backgroundProcess:lastProgress 0
   189 jump *label29 always
   190 label *label28
 
   209 op add *tmp109 :backgroundProcess:reconstructorProgress 0.1
   210 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp109
   211 set :factoryUnitFinished:unit @poly
-    * setaddr :factoryUnitFinished*retaddr *label35 (h:*label35)
-    * call *label0 *invalid :factoryUnitFinished*retval (m:*label35) (h:*label35)
-    * label *label35
+  212 label *label82
+  213 jump *label94 notEqual :factoryUnitFinished:unit .targetUnit
+  214 sensor *tmp153 :factoryUnitFinished:unit @id
+  215 op add :log:encodedId @blockCount *tmp153
+  216 read *tmp6 .bank 511
+  217 op sub *tmp155 *tmp6 1
+  218 write *tmp155 .bank 511
+  219 read *tmp158 .timer "time"
+  220 op mul *tmp159 *tmp158 1000
+  221 op add *tmp160 :log:encodedId *tmp159
+  222 write *tmp160 .bank *tmp155
+  223 label *label83
+  224 label *label84
+  225 jump *label86 notEqual :factoryUnitFinished:unit @flare
+  226 label *label85
+  227 op add *tmp163 .flares 1
+  228 set .flares *tmp163
+  229 write *tmp163 .display ".displayFlares"
+  230 jump *label93 always
+  231 label *label86
+  232 jump *label88 notEqual :factoryUnitFinished:unit @mono
+  233 label *label87
+  234 op add *tmp164 .monos 1
+  235 set .monos *tmp164
+  236 write *tmp164 .display ".displayMonos"
+  237 jump *label93 always
+  238 label *label88
+  239 jump *label90 notEqual :factoryUnitFinished:unit @poly
+  240 label *label89
+  241 op add *tmp165 .polys 1
+  242 set .polys *tmp165
+  243 write *tmp165 .display ".displayPolys"
+  244 jump *label93 always
+  245 label *label90
+  246 jump *label92 notEqual :factoryUnitFinished:unit @mega
+  247 label *label91
+  248 op add *tmp166 .megas 1
+  249 set .megas *tmp166
+  250 write *tmp166 .display ".displayMegas"
+  251 label *label92
+  252 label *label93
+  253 write true .display ".displayUnitReset"
+  254 set .factoryDone 0
+  255 jump *label98 always
+  256 label *label94
+  257 jump *label95 equal :factoryUnitFinished:unit @flare
+  258 jump *label96 notEqual :factoryUnitFinished:unit @mono
+  259 label *label95
+  260 set .factoryDone 1
+  261 label *label96
+  262 label *label97
+  263 label *label98
+  264 label *label99
   265 set :backgroundProcess:lastRecoProgress 0
   266 jump *label34 always
   267 label *label33
 
   270 op add *tmp112 :backgroundProcess:multiReconstructorProgress 0.1
   271 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp112
   272 set :factoryUnitFinished:unit @mega
-    * setaddr :factoryUnitFinished*retaddr *label38 (h:*label38)
-    * call *label0 *invalid :factoryUnitFinished*retval (m:*label38) (h:*label38)
-    * label *label38
+  273 label *label100
+  274 jump *label112 notEqual :factoryUnitFinished:unit .targetUnit
+  275 sensor *tmp153 :factoryUnitFinished:unit @id
+  276 op add :log:encodedId @blockCount *tmp153
+  277 read *tmp6 .bank 511
+  278 op sub *tmp155 *tmp6 1
+  279 write *tmp155 .bank 511
+  280 read *tmp158 .timer "time"
+  281 op mul *tmp159 *tmp158 1000
+  282 op add *tmp160 :log:encodedId *tmp159
+  283 write *tmp160 .bank *tmp155
+  284 label *label101
+  285 label *label102
+  286 jump *label104 notEqual :factoryUnitFinished:unit @flare
+  287 label *label103
+  288 op add *tmp163 .flares 1
+  289 set .flares *tmp163
+  290 write *tmp163 .display ".displayFlares"
+  291 jump *label111 always
+  292 label *label104
+  293 jump *label106 notEqual :factoryUnitFinished:unit @mono
+  294 label *label105
+  295 op add *tmp164 .monos 1
+  296 set .monos *tmp164
+  297 write *tmp164 .display ".displayMonos"
+  298 jump *label111 always
+  299 label *label106
+  300 jump *label108 notEqual :factoryUnitFinished:unit @poly
+  301 label *label107
+  302 op add *tmp165 .polys 1
+  303 set .polys *tmp165
+  304 write *tmp165 .display ".displayPolys"
+  305 jump *label111 always
+  306 label *label108
+  307 jump *label110 notEqual :factoryUnitFinished:unit @mega
+  308 label *label109
+  309 op add *tmp166 .megas 1
+  310 set .megas *tmp166
+  311 write *tmp166 .display ".displayMegas"
+  312 label *label110
+  313 label *label111
+  314 write true .display ".displayUnitReset"
+  315 set .factoryDone 0
+  316 jump *label116 always
+  317 label *label112
+  318 jump *label113 equal :factoryUnitFinished:unit @flare
+  319 jump *label114 notEqual :factoryUnitFinished:unit @mono
+  320 label *label113
+  321 set .factoryDone 1
+  322 label *label114
+  323 label *label115
+  324 label *label116
+  325 label *label117
   326 set :backgroundProcess:lastMultiProgress 0
   327 jump *label37 always
   328 label *label36
 
   378 wait 1e12
   379 jump *label2 always
   380 end
-    * label *label0
-    * jump *label48 notEqual :factoryUnitFinished:unit .targetUnit
-    * sensor *tmp153 :factoryUnitFinished:unit @id
-    * op add :log:encodedId @blockCount *tmp153
-    * read *tmp6 .bank 511
-    * op sub *tmp155 *tmp6 1
-    * write *tmp155 .bank 511
-    * read *tmp158 .timer "time"
-    * op mul *tmp159 *tmp158 1000
-    * op add *tmp160 :log:encodedId *tmp159
-    * write *tmp160 .bank *tmp155
-    * label *label51
-    * label *label50
-    * jump *label53 notEqual :factoryUnitFinished:unit @flare
-    * label *label54
-    * op add *tmp163 .flares 1
-    * set .flares *tmp163
-    * write *tmp163 .display ".displayFlares"
-    * jump *label52 always
-    * label *label53
-    * jump *label55 notEqual :factoryUnitFinished:unit @mono
-    * label *label56
-    * op add *tmp164 .monos 1
-    * set .monos *tmp164
-    * write *tmp164 .display ".displayMonos"
-    * jump *label52 always
-    * label *label55
-    * jump *label57 notEqual :factoryUnitFinished:unit @poly
-    * label *label58
-    * op add *tmp165 .polys 1
-    * set .polys *tmp165
-    * write *tmp165 .display ".displayPolys"
-    * jump *label52 always
-    * label *label57
-    * jump *label59 notEqual :factoryUnitFinished:unit @mega
-    * label *label60
-    * op add *tmp166 .megas 1
-    * set .megas *tmp166
-    * write *tmp166 .display ".displayMegas"
-    * label *label59
-    * label *label52
-    * write true .display ".displayUnitReset"
-    * set .factoryDone 0
-    * jump *label49 always
-    * label *label48
-    * jump *label63 equal :factoryUnitFinished:unit @flare
-    * jump *label62 notEqual :factoryUnitFinished:unit @mono
-    * label *label63
-    * set .factoryDone 1
-    * label *label62
-    * label *label61
-    * label *label49
-    * label *label47
-    * return :factoryUnitFinished*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   210 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp109
   211 set :factoryUnitFinished:unit @poly
   212 label *label82
-    * jump *label94 notEqual :factoryUnitFinished:unit .targetUnit
-    * sensor *tmp153 :factoryUnitFinished:unit @id
+  213 jump *label94 notEqual @poly .targetUnit
+  214 sensor *tmp153 @poly @id
   215 op add :log:encodedId @blockCount *tmp153
   216 read *tmp6 .bank 511
   217 op sub *tmp155 *tmp6 1
 
   222 write *tmp160 .bank *tmp155
   223 label *label83
   224 label *label84
-    * jump *label86 notEqual :factoryUnitFinished:unit @flare
+  225 jump *label86 notEqual @poly @flare
   226 label *label85
   227 op add *tmp163 .flares 1
   228 set .flares *tmp163
   229 write *tmp163 .display ".displayFlares"
   230 jump *label93 always
   231 label *label86
-    * jump *label88 notEqual :factoryUnitFinished:unit @mono
+  232 jump *label88 notEqual @poly @mono
   233 label *label87
   234 op add *tmp164 .monos 1
   235 set .monos *tmp164
   236 write *tmp164 .display ".displayMonos"
   237 jump *label93 always
   238 label *label88
-    * jump *label90 notEqual :factoryUnitFinished:unit @poly
+  239 jump *label90 notEqual @poly @poly
   240 label *label89
   241 op add *tmp165 .polys 1
   242 set .polys *tmp165
   243 write *tmp165 .display ".displayPolys"
   244 jump *label93 always
   245 label *label90
-    * jump *label92 notEqual :factoryUnitFinished:unit @mega
+  246 jump *label92 notEqual @poly @mega
   247 label *label91
   248 op add *tmp166 .megas 1
   249 set .megas *tmp166
 
   254 set .factoryDone 0
   255 jump *label98 always
   256 label *label94
-    * jump *label95 equal :factoryUnitFinished:unit @flare
-    * jump *label96 notEqual :factoryUnitFinished:unit @mono
+  257 jump *label95 equal @poly @flare
+  258 jump *label96 notEqual @poly @mono
   259 label *label95
   260 set .factoryDone 1
   261 label *label96
 
   271 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp112
   272 set :factoryUnitFinished:unit @mega
   273 label *label100
-    * jump *label112 notEqual :factoryUnitFinished:unit .targetUnit
-    * sensor *tmp153 :factoryUnitFinished:unit @id
+  274 jump *label112 notEqual @mega .targetUnit
+  275 sensor *tmp153 @mega @id
   276 op add :log:encodedId @blockCount *tmp153
   277 read *tmp6 .bank 511
   278 op sub *tmp155 *tmp6 1
 
   283 write *tmp160 .bank *tmp155
   284 label *label101
   285 label *label102
-    * jump *label104 notEqual :factoryUnitFinished:unit @flare
+  286 jump *label104 notEqual @mega @flare
   287 label *label103
   288 op add *tmp163 .flares 1
   289 set .flares *tmp163
   290 write *tmp163 .display ".displayFlares"
   291 jump *label111 always
   292 label *label104
-    * jump *label106 notEqual :factoryUnitFinished:unit @mono
+  293 jump *label106 notEqual @mega @mono
   294 label *label105
   295 op add *tmp164 .monos 1
   296 set .monos *tmp164
   297 write *tmp164 .display ".displayMonos"
   298 jump *label111 always
   299 label *label106
-    * jump *label108 notEqual :factoryUnitFinished:unit @poly
+  300 jump *label108 notEqual @mega @poly
   301 label *label107
   302 op add *tmp165 .polys 1
   303 set .polys *tmp165
   304 write *tmp165 .display ".displayPolys"
   305 jump *label111 always
   306 label *label108
-    * jump *label110 notEqual :factoryUnitFinished:unit @mega
+  307 jump *label110 notEqual @mega @mega
   308 label *label109
   309 op add *tmp166 .megas 1
   310 set .megas *tmp166
 
   315 set .factoryDone 0
   316 jump *label116 always
   317 label *label112
-    * jump *label113 equal :factoryUnitFinished:unit @flare
-    * jump *label114 notEqual :factoryUnitFinished:unit @mono
+  318 jump *label113 equal @mega @flare
+  319 jump *label114 notEqual @mega @mono
   320 label *label113
   321 set .factoryDone 1
   322 label *label114

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
   208 label *label27
   209 op add *tmp109 :backgroundProcess:reconstructorProgress 0.1
   210 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp109
-    * set :factoryUnitFinished:unit @poly
   211 label *label82
   212 jump *label94 notEqual @poly .targetUnit
   213 sensor *tmp153 @poly @id
 
   268 label *label34
   269 op add *tmp112 :backgroundProcess:multiReconstructorProgress 0.1
   270 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp112
-    * set :factoryUnitFinished:unit @mega
   271 label *label100
   272 jump *label112 notEqual @mega .targetUnit
   273 sensor *tmp153 @mega @id

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-4 instructions):
 
   221 write *tmp160 .bank *tmp155
   222 label *label83
   223 label *label84
-    * jump *label86 notEqual @poly @flare
+  224 jump *label86 always
   225 label *label85
   226 op add *tmp163 .flares 1
   227 set .flares *tmp163
   228 write *tmp163 .display ".displayFlares"
   229 jump *label93 always
   230 label *label86
-    * jump *label88 notEqual @poly @mono
+  231 jump *label88 always
   232 label *label87
   233 op add *tmp164 .monos 1
   234 set .monos *tmp164
   235 write *tmp164 .display ".displayMonos"
   236 jump *label93 always
   237 label *label88
-    * jump *label90 notEqual @poly @poly
   238 label *label89
   239 op add *tmp165 .polys 1
   240 set .polys *tmp165
   241 write *tmp165 .display ".displayPolys"
   242 jump *label93 always
   243 label *label90
-    * jump *label92 notEqual @poly @mega
+  244 jump *label92 always
   245 label *label91
   246 op add *tmp166 .megas 1
   247 set .megas *tmp166
 
   252 set .factoryDone 0
   253 jump *label98 always
   254 label *label94
-    * jump *label95 equal @poly @flare
-    * jump *label96 notEqual @poly @mono
+  255 jump *label96 always
   256 label *label95
   257 set .factoryDone 1
   258 label *label96
 
   279 write *tmp160 .bank *tmp155
   280 label *label101
   281 label *label102
-    * jump *label104 notEqual @mega @flare
+  282 jump *label104 always
   283 label *label103
   284 op add *tmp163 .flares 1
   285 set .flares *tmp163
   286 write *tmp163 .display ".displayFlares"
   287 jump *label111 always
   288 label *label104
-    * jump *label106 notEqual @mega @mono
+  289 jump *label106 always
   290 label *label105
   291 op add *tmp164 .monos 1
   292 set .monos *tmp164
   293 write *tmp164 .display ".displayMonos"
   294 jump *label111 always
   295 label *label106
-    * jump *label108 notEqual @mega @poly
+  296 jump *label108 always
   297 label *label107
   298 op add *tmp165 .polys 1
   299 set .polys *tmp165
   300 write *tmp165 .display ".displayPolys"
   301 jump *label111 always
   302 label *label108
-    * jump *label110 notEqual @mega @mega
   303 label *label109
   304 op add *tmp166 .megas 1
   305 set .megas *tmp166
 
   310 set .factoryDone 0
   311 jump *label116 always
   312 label *label112
-    * jump *label113 equal @mega @flare
-    * jump *label114 notEqual @mega @mono
+  313 jump *label114 always
   314 label *label113
   315 set .factoryDone 1
   316 label *label114

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
    78 op add *tmp55 .factoryDone .polys
    79 jump *label18 greaterThanEq *tmp55 .polyTarget
    80 set .factoryUnit @mono
-    * jump *label18 always
    81 label *label18
    82 set .targetUnit @poly
    83 write @poly .display ".displayNextUnit"
 
    93 op add *tmp68 .factoryDone .megas
    94 jump *label22 greaterThanEq *tmp68 .megaTarget
    95 set .factoryUnit @mono
-    * jump *label22 always
    96 label *label22
    97 set .targetUnit @mega
    98 write @mega .display ".displayNextUnit"

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   208 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp109
   209 label *label82
   210 jump *label94 notEqual @poly .targetUnit
-    * sensor *tmp153 @poly @id
+  211 set *tmp153 21
   212 op add :log:encodedId @blockCount *tmp153
   213 read *tmp6 .bank 511
   214 op sub *tmp155 *tmp6 1
 
   266 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp112
   267 label *label100
   268 jump *label112 notEqual @mega .targetUnit
-    * sensor *tmp153 @mega @id
+  269 set *tmp153 22
   270 op add :log:encodedId @blockCount *tmp153
   271 read *tmp6 .bank 511
   272 op sub *tmp155 *tmp6 1

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-6 instructions):
 
   209 label *label82
   210 jump *label94 notEqual @poly .targetUnit
   211 set *tmp153 21
-    * op add :log:encodedId @blockCount *tmp153
+  212 op add :log:encodedId @blockCount 21
   213 read *tmp6 .bank 511
   214 op sub *tmp155 *tmp6 1
   215 write *tmp155 .bank 511
 
   221 label *label84
   222 jump *label86 always
   223 label *label85
-    * op add *tmp163 .flares 1
   224 set .flares *tmp163
   225 write *tmp163 .display ".displayFlares"
   226 jump *label93 always
   227 label *label86
   228 jump *label88 always
   229 label *label87
-    * op add *tmp164 .monos 1
   230 set .monos *tmp164
   231 write *tmp164 .display ".displayMonos"
   232 jump *label93 always
 
   239 label *label90
   240 jump *label92 always
   241 label *label91
-    * op add *tmp166 .megas 1
   242 set .megas *tmp166
   243 write *tmp166 .display ".displayMegas"
   244 label *label92
 
   264 label *label100
   265 jump *label112 notEqual @mega .targetUnit
   266 set *tmp153 22
-    * op add :log:encodedId @blockCount *tmp153
+  267 op add :log:encodedId @blockCount 22
   268 read *tmp6 .bank 511
   269 op sub *tmp155 *tmp6 1
   270 write *tmp155 .bank 511
 
   276 label *label102
   277 jump *label104 always
   278 label *label103
-    * op add *tmp163 .flares 1
   279 set .flares *tmp163
   280 write *tmp163 .display ".displayFlares"
   281 jump *label111 always
   282 label *label104
   283 jump *label106 always
   284 label *label105
-    * op add *tmp164 .monos 1
   285 set .monos *tmp164
   286 write *tmp164 .display ".displayMonos"
   287 jump *label111 always
   288 label *label106
   289 jump *label108 always
   290 label *label107
-    * op add *tmp165 .polys 1
   291 set .polys *tmp165
   292 write *tmp165 .display ".displayPolys"
   293 jump *label111 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-2 instructions):
 
   208 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp109
   209 label *label82
   210 jump *label94 notEqual @poly .targetUnit
-    * set *tmp153 21
   211 op add :log:encodedId @blockCount 21
   212 read *tmp6 .bank 511
   213 op sub *tmp155 *tmp6 1
 
   262 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp112
   263 label *label100
   264 jump *label112 notEqual @mega .targetUnit
-    * set *tmp153 22
   265 op add :log:encodedId @blockCount 22
   266 read *tmp6 .bank 511
   267 op sub *tmp155 *tmp6 1

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    39 jump *label7 equal .smelter2 false
    40 control config .unloader1 @coal
    41 label *label7
-    * label *label8
    42 sensor :backgroundProcess:power .battery @totalPower
    43 jump *label9 equal .generator2 false
    44 set *tmp31 .generator
 
   112 label *label14
   113 label *label12
   114 select :backgroundProcess:enableFactory lessThan :backgroundProcess:power 200 false :backgroundProcess:enableFactory
-    * label *label24
   115 select :backgroundProcess:enableFactory lessThan 500 :backgroundProcess:power true :backgroundProcess:enableFactory
-    * label *label25
-    * label *label23
   116 jump *label26 notEqual .factoryUnit null
   117 control enabled .factory false
   118 control config .factory @mono
 
   126 op land *tmp93 :backgroundProcess:enableFactory *tmp92
   127 control enabled *tmp90 *tmp93
   128 set :factoryUnitFinished:unit .factoryUnit
-    * label *label64
   129 jump *label76 notEqual :factoryUnitFinished:unit .targetUnit
   130 sensor *tmp153 :factoryUnitFinished:unit @id
   131 op add :log:encodedId @blockCount *tmp153
 
   136 op mul *tmp159 *tmp158 1000
   137 op add *tmp160 :log:encodedId *tmp159
   138 write *tmp160 .bank *tmp155
-    * label *label65
-    * label *label66
   139 jump *label68 notEqual :factoryUnitFinished:unit @flare
-    * label *label67
   140 op add *tmp163 .flares 1
   141 set .flares *tmp163
   142 write *tmp163 .display ".displayFlares"
   143 jump *label75 always
   144 label *label68
   145 jump *label70 notEqual :factoryUnitFinished:unit @mono
-    * label *label69
   146 op add *tmp164 .monos 1
   147 set .monos *tmp164
   148 write *tmp164 .display ".displayMonos"
   149 jump *label75 always
   150 label *label70
   151 jump *label72 notEqual :factoryUnitFinished:unit @poly
-    * label *label71
   152 op add *tmp165 .polys 1
   153 set .polys *tmp165
   154 write *tmp165 .display ".displayPolys"
   155 jump *label75 always
   156 label *label72
   157 jump *label74 notEqual :factoryUnitFinished:unit @mega
-    * label *label73
   158 op add *tmp166 .megas 1
   159 set .megas *tmp166
   160 write *tmp166 .display ".displayMegas"
 
   169 label *label77
   170 set .factoryDone 1
   171 label *label78
-    * label *label79
   172 label *label80
-    * label *label81
   173 set :backgroundProcess:lastProgress 0
   174 jump *label29 always
   175 label *label28
 
   193 label *label27
   194 op add *tmp109 :backgroundProcess:reconstructorProgress 0.1
   195 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp109
-    * label *label82
   196 jump *label94 notEqual @poly .targetUnit
   197 op add :log:encodedId @blockCount 21
   198 read *tmp6 .bank 511
 
   202 op mul *tmp159 *tmp158 1000
   203 op add *tmp160 :log:encodedId *tmp159
   204 write *tmp160 .bank *tmp155
-    * label *label83
-    * label *label84
   205 jump *label86 always
-    * label *label85
   206 set .flares *tmp163
   207 write *tmp163 .display ".displayFlares"
   208 jump *label93 always
   209 label *label86
   210 jump *label88 always
-    * label *label87
   211 set .monos *tmp164
   212 write *tmp164 .display ".displayMonos"
   213 jump *label93 always
   214 label *label88
-    * label *label89
   215 op add *tmp165 .polys 1
   216 set .polys *tmp165
   217 write *tmp165 .display ".displayPolys"
   218 jump *label93 always
-    * label *label90
   219 jump *label92 always
-    * label *label91
   220 set .megas *tmp166
   221 write *tmp166 .display ".displayMegas"
   222 label *label92
 
   226 jump *label98 always
   227 label *label94
   228 jump *label96 always
-    * label *label95
   229 set .factoryDone 1
   230 label *label96
-    * label *label97
   231 label *label98
-    * label *label99
   232 set :backgroundProcess:lastRecoProgress 0
   233 jump *label34 always
   234 label *label33
 
   236 label *label34
   237 op add *tmp112 :backgroundProcess:multiReconstructorProgress 0.1
   238 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp112
-    * label *label100
   239 jump *label112 notEqual @mega .targetUnit
   240 op add :log:encodedId @blockCount 22
   241 read *tmp6 .bank 511
 
   245 op mul *tmp159 *tmp158 1000
   246 op add *tmp160 :log:encodedId *tmp159
   247 write *tmp160 .bank *tmp155
-    * label *label101
-    * label *label102
   248 jump *label104 always
-    * label *label103
   249 set .flares *tmp163
   250 write *tmp163 .display ".displayFlares"
   251 jump *label111 always
   252 label *label104
   253 jump *label106 always
-    * label *label105
   254 set .monos *tmp164
   255 write *tmp164 .display ".displayMonos"
   256 jump *label111 always
   257 label *label106
   258 jump *label108 always
-    * label *label107
   259 set .polys *tmp165
   260 write *tmp165 .display ".displayPolys"
   261 jump *label111 always
   262 label *label108
-    * label *label109
   263 op add *tmp166 .megas 1
   264 set .megas *tmp166
   265 write *tmp166 .display ".displayMegas"
-    * label *label110
   266 label *label111
   267 write true .display ".displayUnitReset"
   268 set .factoryDone 0
   269 jump *label116 always
   270 label *label112
   271 jump *label114 always
-    * label *label113
   272 set .factoryDone 1
   273 label *label114
-    * label *label115
   274 label *label116
-    * label *label117
   275 set :backgroundProcess:lastMultiProgress 0
   276 jump *label37 always
   277 label *label36
 
   283 control config .unloader2 @coal
   284 jump *label5 always
   285 label *label39
-    * label *label40
   286 set *tmp121 .unloader4
   287 op greaterThan *tmp123 :backgroundProcess:coreSilicon .siliconReserve
   288 op greaterThan *tmp124 :backgroundProcess:coreGraphite .graphiteReserve
 
   321 op sub .loopTicks @tick :backgroundProcess:ticks
   322 label *label5
   323 jump *label4 always
-    * label *label6
-    * label *label3
   324 wait 1e12
   325 jump *label2 always
   326 end

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
   193 label *label27
   194 op add *tmp109 :backgroundProcess:reconstructorProgress 0.1
   195 jump *label33 lessThanEq :backgroundProcess:lastRecoProgress *tmp109
-    * jump *label94 notEqual @poly .targetUnit
+  196 jump *label96 notEqual @poly .targetUnit
   197 op add :log:encodedId @blockCount 21
   198 read *tmp6 .bank 511
   199 op sub *tmp155 *tmp6 1
 
   202 op mul *tmp159 *tmp158 1000
   203 op add *tmp160 :log:encodedId *tmp159
   204 write *tmp160 .bank *tmp155
-    * jump *label86 always
+  205 jump *label88 always
   206 set .flares *tmp163
   207 write *tmp163 .display ".displayFlares"
   208 jump *label93 always
 
   236 label *label34
   237 op add *tmp112 :backgroundProcess:multiReconstructorProgress 0.1
   238 jump *label36 lessThanEq :backgroundProcess:lastMultiProgress *tmp112
-    * jump *label112 notEqual @mega .targetUnit
+  239 jump *label114 notEqual @mega .targetUnit
   240 op add :log:encodedId @blockCount 22
   241 read *tmp6 .bank 511
   242 op sub *tmp155 *tmp6 1
 
   245 op mul *tmp159 *tmp158 1000
   246 op add *tmp160 :log:encodedId *tmp159
   247 write *tmp160 .bank *tmp155
-    * jump *label104 always
+  248 jump *label108 always
   249 set .flares *tmp163
   250 write *tmp163 .display ".displayFlares"
   251 jump *label111 always
   252 label *label104
-    * jump *label106 always
+  253 jump *label108 always
   254 set .monos *tmp164
   255 write *tmp164 .display ".displayMonos"
   256 jump *label111 always
 
   281 op mul *tmp116 5 .generator2
   282 jump *label39 greaterThanEq *tmp115 *tmp116
   283 control config .unloader2 @coal
-    * jump *label5 always
+  284 jump *label4 always
   285 label *label39
   286 set *tmp121 .unloader4
   287 op greaterThan *tmp123 :backgroundProcess:coreSilicon .siliconReserve

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-28 instructions):
 
   203 op add *tmp160 :log:encodedId *tmp159
   204 write *tmp160 .bank *tmp155
   205 jump *label88 always
-    * set .flares *tmp163
-    * write *tmp163 .display ".displayFlares"
-    * jump *label93 always
-    * label *label86
-    * jump *label88 always
-    * set .monos *tmp164
-    * write *tmp164 .display ".displayMonos"
-    * jump *label93 always
   206 label *label88
   207 op add *tmp165 .polys 1
   208 set .polys *tmp165
   209 write *tmp165 .display ".displayPolys"
   210 jump *label93 always
-    * jump *label92 always
-    * set .megas *tmp166
-    * write *tmp166 .display ".displayMegas"
-    * label *label92
   211 label *label93
   212 write true .display ".displayUnitReset"
   213 set .factoryDone 0
   214 jump *label98 always
-    * label *label94
-    * jump *label96 always
-    * set .factoryDone 1
   215 label *label96
   216 label *label98
   217 set :backgroundProcess:lastRecoProgress 0
 
   231 op add *tmp160 :log:encodedId *tmp159
   232 write *tmp160 .bank *tmp155
   233 jump *label108 always
-    * set .flares *tmp163
-    * write *tmp163 .display ".displayFlares"
-    * jump *label111 always
-    * label *label104
-    * jump *label108 always
-    * set .monos *tmp164
-    * write *tmp164 .display ".displayMonos"
-    * jump *label111 always
-    * label *label106
-    * jump *label108 always
-    * set .polys *tmp165
-    * write *tmp165 .display ".displayPolys"
-    * jump *label111 always
   234 label *label108
   235 op add *tmp166 .megas 1
   236 set .megas *tmp166
 
   239 write true .display ".displayUnitReset"
   240 set .factoryDone 0
   241 jump *label116 always
-    * label *label112
-    * jump *label114 always
-    * set .factoryDone 1
   242 label *label114
   243 label *label116
   244 set :backgroundProcess:lastMultiProgress 0
 
   288 control config *tmp142 @silicon
   289 label *label46
   290 op sub .loopTicks @tick :backgroundProcess:ticks
-    * label *label5
   291 jump *label4 always
-    * wait 1e12
-    * jump *label2 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
 
    10 set .megaTarget 0
    11 set .factoryDone 0
    12 set *signature "0:v1"
-    * label *label2
    13 set :backgroundProcess:lastProgress 0
    14 set :backgroundProcess:lastRecoProgress 0
    15 set :backgroundProcess:lastMultiProgress 0
 
   234 op add *tmp166 .megas 1
   235 set .megas *tmp166
   236 write *tmp166 .display ".displayMegas"
-    * label *label111
   237 write true .display ".displayUnitReset"
   238 set .factoryDone 0
   239 jump *label116 always

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-5 instructions):
 
   201 op mul *tmp159 *tmp158 1000
   202 op add *tmp160 :log:encodedId *tmp159
   203 write *tmp160 .bank *tmp155
-    * jump *label88 always
   204 label *label88
   205 op add *tmp165 .polys 1
   206 set .polys *tmp165
   207 write *tmp165 .display ".displayPolys"
-    * jump *label93 always
   208 label *label93
   209 write true .display ".displayUnitReset"
   210 set .factoryDone 0
-    * jump *label98 always
   211 label *label96
   212 label *label98
   213 set :backgroundProcess:lastRecoProgress 0
 
   226 op mul *tmp159 *tmp158 1000
   227 op add *tmp160 :log:encodedId *tmp159
   228 write *tmp160 .bank *tmp155
-    * jump *label108 always
   229 label *label108
   230 op add *tmp166 .megas 1
   231 set .megas *tmp166
   232 write *tmp166 .display ".displayMegas"
   233 write true .display ".displayUnitReset"
   234 set .factoryDone 0
-    * jump *label116 always
   235 label *label114
   236 label *label116
   237 set :backgroundProcess:lastMultiProgress 0

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
   201 op mul *tmp159 *tmp158 1000
   202 op add *tmp160 :log:encodedId *tmp159
   203 write *tmp160 .bank *tmp155
-    * label *label88
   204 op add *tmp165 .polys 1
   205 set .polys *tmp165
   206 write *tmp165 .display ".displayPolys"
-    * label *label93
   207 write true .display ".displayUnitReset"
   208 set .factoryDone 0
   209 label *label96
-    * label *label98
   210 set :backgroundProcess:lastRecoProgress 0
   211 jump *label34 always
   212 label *label33
 
   223 op mul *tmp159 *tmp158 1000
   224 op add *tmp160 :log:encodedId *tmp159
   225 write *tmp160 .bank *tmp155
-    * label *label108
   226 op add *tmp166 .megas 1
   227 set .megas *tmp166
   228 write *tmp166 .display ".displayMegas"
   229 write true .display ".displayUnitReset"
   230 set .factoryDone 0
   231 label *label114
-    * label *label116
   232 set :backgroundProcess:lastMultiProgress 0
   233 jump *label37 always
   234 label *label36

Final code before resolving virtual instructions:

    0:  set .flares 0                                                remote var
    1:  set .monos 0                                                 ...
    2:  set .polys 1                                                 ...
    3:  set .megas 0                                                 ...
    4:  set .pressTarget 20                                          ...
    5:  set .smelterTarget 20                                        ...
    6:  set .kilnTarget 20                                           ...
    7:  set .flareTarget 0                                           ...
    8:  set .monoTarget 0                                            ...
    9:  set .polyTarget 0                                            ...
   10:  set .megaTarget 0                                            ...
   11:  set .factoryDone 0                                           var factoryDone = 0;
   12:  set *signature "0:v1"                                        #set target = 8;
   13:  set :backgroundProcess:lastProgress 0                        var lastProgress = 0, factoryProgress = 0;
   14:  set :backgroundProcess:lastRecoProgress 0                    var lastRecoProgress = 0, reconstructorProgress = 0;
   15:  set :backgroundProcess:lastMultiProgress 0                   var lastMultiProgress = 0, multiReconstructorProgress = 0;
   16:  set :backgroundProcess:enableFactory true                    var enableFactory = true, blockFactory = false;
        label *label4                                                while true do
   17:  set :backgroundProcess:ticks @tick                           var ticks = @tick;
   18:  sensor :backgroundProcess:coreSilicon .core @silicon         var coreSilicon = core.@silicon;
   19:  sensor :backgroundProcess:coreGraphite .core @graphite       var coreGraphite = core.@graphite;
   20:  set *tmp9 .smelter2                                          smelter2.enabled = smelter.enabled = coreSilicon < smelterTarget;
   21:  set *tmp11 .smelter                                          ...
   22:  op lessThan *tmp13 :backgroundProcess:coreSilicon .smelterTa ...
   23:  control enabled *tmp11 *tmp13 0 0 0                          ...
   24:  control enabled *tmp9 *tmp13 0 0 0                           ...
   25:  set *tmp14 .press                                            press.enabled = !multipress and coreGraphite < pressTarget;
   26:  op equal *tmp16 .multipress false                            ...
   27:  op lessThan *tmp17 :backgroundProcess:coreGraphite .pressTar ...
   28:  op land *tmp18 *tmp16 *tmp17                                 ...
   29:  control enabled *tmp14 *tmp18 0 0 0                          ...
   30:  set *tmp19 .multipress                                       multipress.enabled = coreGraphite < pressTarget;
   31:  op lessThan *tmp21 :backgroundProcess:coreGraphite .pressTar ...
   32:  control enabled *tmp19 *tmp21 0 0 0                          ...
   33:  set *tmp22 .kiln                                             kiln.enabled = core.@metaglass < kilnTarget;
   34:  sensor *tmp24 .core @metaglass                               ...
   35:  op lessThan *tmp25 *tmp24 .kilnTarget                        ...
   36:  control enabled *tmp22 *tmp25 0 0 0                          ...
   37:  jump *label7 equal .smelter2 false                           if smelter2 then unloader1.config = @coal; end;
   38:  control config .unloader1 @coal 0 0 0                        ...
        label *label7                                                ...
   39:  sensor :backgroundProcess:power .battery @totalPower         var power = battery.@totalPower;
   40:  jump *label9 equal .generator2 false                         if generator2 then
   41:  set *tmp31 .generator                                        generator.enabled = power < 10;
   42:  op lessThan *tmp33 :backgroundProcess:power 10               ...
   43:  control enabled *tmp31 *tmp33 0 0 0                          ...
   44:  set *tmp34 .generator2                                       generator2.enabled = power < 3800;
   45:  op lessThan *tmp36 :backgroundProcess:power 3800             ...
   46:  control enabled *tmp34 *tmp36 0 0 0                          ...
   47:  jump *label10 always 0 0                                     if generator2 then
        label *label9                                                ...
   48:  set *tmp37 .generator                                        generator.enabled = power < 800;
   49:  op lessThan *tmp39 :backgroundProcess:power 800              ...
   50:  control enabled *tmp37 *tmp39 0 0 0                          ...
        label *label10                                               if generator2 then
   51:  sensor :backgroundProcess:factoryProgress .factory @progress factoryProgress = factory.@progress;
   52:  sensor :backgroundProcess:reconstructorProgress .reconstruct reconstructorProgress = reconstructor.@progress;
   53:  sensor :backgroundProcess:multiReconstructorProgress .multiR multiReconstructorProgress = multiReconstructor.@progress;
   54:  jump *label11 greaterThanEq .flares .flareTarget             if flares < flareTarget then
   55:  set .factoryUnit @flare                                      displayNextUnit = targetUnit = factoryUnit = @flare;
   56:  set .targetUnit @flare                                       ...
   57:  write @flare .display ".displayNextUnit"                     ...
   58:  control config .payloadRouter .targetUnit 0 0 0              payloadRouter.config = targetUnit;
   59:  set :backgroundProcess:blockFactory false                    blockFactory = false;
   60:  jump *label12 always 0 0                                     if flares < flareTarget then
        label *label11                                               ...
   61:  jump *label13 greaterThanEq .monos .monoTarget               elsif monos < monoTarget then
   62:  set .factoryUnit @mono                                       displayNextUnit = targetUnit = factoryUnit = @mono;
   63:  set .targetUnit @mono                                        ...
   64:  write @mono .display ".displayNextUnit"                      ...
   65:  control config .payloadRouter .targetUnit 0 0 0              payloadRouter.config = targetUnit;
   66:  set :backgroundProcess:blockFactory false                    blockFactory = false;
   67:  jump *label14 always 0 0                                     elsif monos < monoTarget then
        label *label13                                               ...
   68:  jump *label15 greaterThanEq .polys .polyTarget               elsif polys < polyTarget then
   69:  set .factoryUnit null                                        factoryUnit = factoryDone + polys < polyTarget ? @mono : null;
   70:  op add *tmp55 .factoryDone .polys                            ...
   71:  jump *label18 greaterThanEq *tmp55 .polyTarget               ...
   72:  set .factoryUnit @mono                                       ...
        label *label18                                               ...
   73:  set .targetUnit @poly                                        displayNextUnit = targetUnit = @poly;
   74:  write @poly .display ".displayNextUnit"                      ...
   75:  control enabled .reconstructor true 0 0 0                    reconstructor.enabled = true;
   76:  control config .payloadRouter .targetUnit 0 0 0              payloadRouter.config = targetUnit;
   77:  sensor *tmp63 .reconstructor @payloadCount                   blockFactory = reconstructor.@payloadCount * factoryProgress > reconstructorProgress;
   78:  op mul *tmp64 *tmp63 :backgroundProcess:factoryProgress      ...
   79:  op greaterThan :backgroundProcess:blockFactory *tmp64 :backg ...
   80:  jump *label16 always 0 0                                     elsif polys < polyTarget then
        label *label15                                               ...
   81:  jump *label19 greaterThanEq .megas .megaTarget               elsif megas < megaTarget then
   82:  set .factoryUnit null                                        factoryUnit = factoryDone + megas < megaTarget ? @mono : null;
   83:  op add *tmp68 .factoryDone .megas                            ...
   84:  jump *label22 greaterThanEq *tmp68 .megaTarget               ...
   85:  set .factoryUnit @mono                                       ...
        label *label22                                               ...
   86:  set .targetUnit @mega                                        displayNextUnit = targetUnit = @mega;
   87:  write @mega .display ".displayNextUnit"                      ...
   88:  set *tmp71 .reconstructor                                    reconstructor.enabled = multiReconstructor or reconstructorProgress < 0.75;
   89:  op lessThan *tmp73 :backgroundProcess:reconstructorProgress  ...
   90:  op or *tmp74 .multiReconstructor *tmp73                      ...
   91:  control enabled *tmp71 *tmp74 0 0 0                          ...
   92:  control config .payloadRouter .targetUnit 0 0 0              payloadRouter.config = targetUnit;
   93:  set :backgroundProcess:blockFactory false                    blockFactory = false;
   94:  jump *label20 always 0 0                                     elsif megas < megaTarget then
        label *label19                                               ...
   95:  set .factoryUnit null                                        displayNextUnit = targetUnit = factoryUnit = null;
   96:  set .targetUnit null                                         ...
   97:  write null .display ".displayNextUnit"                       ...
   98:  set :backgroundProcess:blockFactory false                    blockFactory = false;
        label *label20                                               elsif megas < megaTarget then
        label *label16                                               elsif polys < polyTarget then
        label *label14                                               elsif monos < monoTarget then
        label *label12                                               if flares < flareTarget then
   99:  select :backgroundProcess:enableFactory lessThan :background mlogSafe("select", out value, "lessThan", in a, in b, in newValue, in value);
  100:  select :backgroundProcess:enableFactory lessThan 500 :backgr ...
  101:  jump *label26 notEqual .factoryUnit null                     if factoryUnit == null then
  102:  control enabled .factory false 0 0 0                         factory.enabled = false;
  103:  control config .factory @mono 0 0 0                          factory.config = @mono;
  104:  set :backgroundProcess:lastProgress 0                        lastProgress = 0;
  105:  jump *label27 always 0 0                                     if factoryUnit == null then
        label *label26                                               ...
  106:  op add *tmp87 :backgroundProcess:factoryProgress 0.1         elsif lastProgress > factoryProgress + 0.1 then
  107:  jump *label28 lessThanEq :backgroundProcess:lastProgress *tm ...
  108:  set *tmp90 .factory                                          factory.enabled = enableFactory and not blockFactory;
  109:  op equal *tmp92 :backgroundProcess:blockFactory false        ...
  110:  op land *tmp93 :backgroundProcess:enableFactory *tmp92       ...
  111:  control enabled *tmp90 *tmp93 0 0 0                          ...
  112:  set :factoryUnitFinished:unit .factoryUnit                   factoryUnitFinished(factoryUnit);
  113:  jump *label76 notEqual :factoryUnitFinished:unit .targetUnit if unit == targetUnit then
  114:  sensor *tmp153 :factoryUnitFinished:unit @id                 log(@blockCount + unit.@id);
  115:  op add :log:encodedId @blockCount *tmp153                    ...
  116:  read *tmp6 .bank 511                                         bank[--logPosition] = encodedId + timer.read("time") * 1000;
  117:  op sub *tmp155 *tmp6 1                                       ...
  118:  write *tmp155 .bank 511                                      ...
  119:  read *tmp158 .timer "time"                                   ...
  120:  op mul *tmp159 *tmp158 1000                                  ...
  121:  op add *tmp160 :log:encodedId *tmp159                        ...
  122:  write *tmp160 .bank *tmp155                                  ...
  123:  jump *label68 notEqual :factoryUnitFinished:unit @flare      case unit
  124:  op add *tmp163 .flares 1                                     when @flare then displayFlares = ++flares;
  125:  set .flares *tmp163                                          ...
  126:  write *tmp163 .display ".displayFlares"                      ...
  127:  jump *label75 always 0 0                                     case unit
        label *label68                                               ...
  128:  jump *label70 notEqual :factoryUnitFinished:unit @mono       ...
  129:  op add *tmp164 .monos 1                                      when @mono  then displayMonos = ++monos;
  130:  set .monos *tmp164                                           ...
  131:  write *tmp164 .display ".displayMonos"                       ...
  132:  jump *label75 always 0 0                                     case unit
        label *label70                                               ...
  133:  jump *label72 notEqual :factoryUnitFinished:unit @poly       ...
  134:  op add *tmp165 .polys 1                                      when @poly  then displayPolys = ++polys;
  135:  set .polys *tmp165                                           ...
  136:  write *tmp165 .display ".displayPolys"                       ...
  137:  jump *label75 always 0 0                                     case unit
        label *label72                                               ...
  138:  jump *label74 notEqual :factoryUnitFinished:unit @mega       ...
  139:  op add *tmp166 .megas 1                                      when @mega  then displayMegas = ++megas;
  140:  set .megas *tmp166                                           ...
  141:  write *tmp166 .display ".displayMegas"                       ...
        label *label74                                               case unit
        label *label75                                               ...
  142:  write true .display ".displayUnitReset"                      displayUnitReset = true;
  143:  set .factoryDone 0                                           factoryDone = 0;
  144:  jump *label80 always 0 0                                     if unit == targetUnit then
        label *label76                                               ...
  145:  jump *label77 equal :factoryUnitFinished:unit @flare         case unit
  146:  jump *label78 notEqual :factoryUnitFinished:unit @mono       ...
        label *label77                                               ...
  147:  set .factoryDone 1                                           when @flare, @mono then factoryDone = 1;
        label *label78                                               case unit
        label *label80                                               if unit == targetUnit then
  148:  set :backgroundProcess:lastProgress 0                        lastProgress = 0;
  149:  jump *label29 always 0 0                                     elsif lastProgress > factoryProgress + 0.1 then
        label *label28                                               ...
  150:  sensor *tmp95 .factory @config                               elsif factory.config != factoryUnit then
  151:  jump *label31 equal *tmp95 .factoryUnit                      ...
  152:  set *tmp98 .factory                                          factory.enabled = enableFactory and not blockFactory;
  153:  op equal *tmp100 :backgroundProcess:blockFactory false       ...
  154:  op land *tmp101 :backgroundProcess:enableFactory *tmp100     ...
  155:  control enabled *tmp98 *tmp101 0 0 0                         ...
  156:  control config .factory .factoryUnit 0 0 0                   factory.config = factoryUnit;
  157:  set :backgroundProcess:lastProgress 0                        lastProgress = 0;
  158:  jump *label32 always 0 0                                     elsif factory.config != factoryUnit then
        label *label31                                               ...
  159:  set *tmp105 .factory                                         factory.enabled = enableFactory and not blockFactory;
  160:  op equal *tmp107 :backgroundProcess:blockFactory false       ...
  161:  op land *tmp108 :backgroundProcess:enableFactory *tmp107     ...
  162:  control enabled *tmp105 *tmp108 0 0 0                        ...
  163:  set :backgroundProcess:lastProgress :backgroundProcess:facto lastProgress = factoryProgress;
        label *label32                                               elsif factory.config != factoryUnit then
        label *label29                                               elsif lastProgress > factoryProgress + 0.1 then
        label *label27                                               if factoryUnit == null then
  164:  op add *tmp109 :backgroundProcess:reconstructorProgress 0.1  if lastRecoProgress > reconstructorProgress + 0.1 then
  165:  jump *label33 lessThanEq :backgroundProcess:lastRecoProgress ...
  166:  jump *label96 notEqual @poly .targetUnit                     if unit == targetUnit then
  167:  op add :log:encodedId @blockCount 21                         log(@blockCount + unit.@id);
  168:  read *tmp6 .bank 511                                         bank[--logPosition] = encodedId + timer.read("time") * 1000;
  169:  op sub *tmp155 *tmp6 1                                       ...
  170:  write *tmp155 .bank 511                                      ...
  171:  read *tmp158 .timer "time"                                   ...
  172:  op mul *tmp159 *tmp158 1000                                  ...
  173:  op add *tmp160 :log:encodedId *tmp159                        ...
  174:  write *tmp160 .bank *tmp155                                  ...
  175:  op add *tmp165 .polys 1                                      when @poly  then displayPolys = ++polys;
  176:  set .polys *tmp165                                           ...
  177:  write *tmp165 .display ".displayPolys"                       ...
  178:  write true .display ".displayUnitReset"                      displayUnitReset = true;
  179:  set .factoryDone 0                                           factoryDone = 0;
        label *label96                                               case unit
  180:  set :backgroundProcess:lastRecoProgress 0                    lastRecoProgress = 0;
  181:  jump *label34 always 0 0                                     if lastRecoProgress > reconstructorProgress + 0.1 then
        label *label33                                               ...
  182:  set :backgroundProcess:lastRecoProgress :backgroundProcess:r lastRecoProgress = reconstructorProgress;
        label *label34                                               if lastRecoProgress > reconstructorProgress + 0.1 then
  183:  op add *tmp112 :backgroundProcess:multiReconstructorProgress if lastMultiProgress > multiReconstructorProgress + 0.1 then
  184:  jump *label36 lessThanEq :backgroundProcess:lastMultiProgres ...
  185:  jump *label114 notEqual @mega .targetUnit                    if unit == targetUnit then
  186:  op add :log:encodedId @blockCount 22                         log(@blockCount + unit.@id);
  187:  read *tmp6 .bank 511                                         bank[--logPosition] = encodedId + timer.read("time") * 1000;
  188:  op sub *tmp155 *tmp6 1                                       ...
  189:  write *tmp155 .bank 511                                      ...
  190:  read *tmp158 .timer "time"                                   ...
  191:  op mul *tmp159 *tmp158 1000                                  ...
  192:  op add *tmp160 :log:encodedId *tmp159                        ...
  193:  write *tmp160 .bank *tmp155                                  ...
  194:  op add *tmp166 .megas 1                                      when @mega  then displayMegas = ++megas;
  195:  set .megas *tmp166                                           ...
  196:  write *tmp166 .display ".displayMegas"                       ...
  197:  write true .display ".displayUnitReset"                      displayUnitReset = true;
  198:  set .factoryDone 0                                           factoryDone = 0;
        label *label114                                              case unit
  199:  set :backgroundProcess:lastMultiProgress 0                   lastMultiProgress = 0;
  200:  jump *label37 always 0 0                                     if lastMultiProgress > multiReconstructorProgress + 0.1 then
        label *label36                                               ...
  201:  set :backgroundProcess:lastMultiProgress :backgroundProcess: lastMultiProgress = multiReconstructorProgress;
        label *label37                                               if lastMultiProgress > multiReconstructorProgress + 0.1 then
  202:  sensor *tmp115 .generator2 @coal                             if generator2.@coal < 5 * generator2 then
  203:  op mul *tmp116 5 .generator2                                 ...
  204:  jump *label39 greaterThanEq *tmp115 *tmp116                  ...
  205:  control config .unloader2 @coal 0 0 0                        unloader2.config = @coal;
  206:  jump *label4 always 0 0                                      continue;
        label *label39                                               if generator2.@coal < 5 * generator2 then
  207:  set *tmp121 .unloader4                                       unloader4.enabled = coreSilicon > siliconReserve and coreGraphite > graphiteReserve;
  208:  op greaterThan *tmp123 :backgroundProcess:coreSilicon .silic ...
  209:  op greaterThan *tmp124 :backgroundProcess:coreGraphite .grap ...
  210:  op land *tmp125 *tmp123 *tmp124                              ...
  211:  control enabled *tmp121 *tmp125 0 0 0                        ...
  212:  op equal *tmp126 .factoryUnit @mono                          var leadLimit = (factoryUnit == @mono) * 30;
  213:  op mul :backgroundProcess:leadLimit *tmp126 30               ...
  214:  sensor *tmp128 .factory @lead                                if factory.@lead < leadLimit and core.@lead > leadReserve then
  215:  op lessThan *tmp129 *tmp128 :backgroundProcess:leadLimit     ...
  216:  sensor *tmp130 .core @lead                                   ...
  217:  op greaterThan *tmp131 *tmp130 .leadReserve                  ...
  218:  op land *tmp132 *tmp129 *tmp131                              ...
  219:  jump *label41 equal *tmp132 false                            ...
  220:  control config .unloader2 @lead 0 0 0                        unloader2.config = @lead;
  221:  jump *label42 always 0 0                                     if factory.@lead < leadLimit and core.@lead > leadReserve then
        label *label41                                               ...
  222:  jump *label43 lessThanEq :backgroundProcess:coreSilicon .sil elsif coreSilicon > siliconReserve then
  223:  control config .unloader2 @silicon 0 0 0                     unloader2.config = @silicon;
  224:  jump *label44 always 0 0                                     elsif coreSilicon > siliconReserve then
        label *label43                                               ...
  225:  control config .unloader2 @coal 0 0 0                        unloader2.config = @coal;
        label *label44                                               elsif coreSilicon > siliconReserve then
        label *label42                                               if factory.@lead < leadLimit and core.@lead > leadReserve then
  226:  set *tmp142 .unloader6                                       unloader6.config = multiReconstructor.@silicon >= 130 and multiReconstructor.@titanium < 80 ? @titanium : @silicon;
  227:  sensor *tmp144 .multiReconstructor @silicon                  ...
  228:  op greaterThanEq *tmp145 *tmp144 130                         ...
  229:  sensor *tmp146 .multiReconstructor @titanium                 ...
  230:  op lessThan *tmp147 *tmp146 80                               ...
  231:  op land *tmp148 *tmp145 *tmp147                              ...
  232:  jump *label45 equal *tmp148 false                            ...
  233:  control config *tmp142 @titanium 0 0 0                       ...
  234:  jump *label46 always 0 0                                     ...
        label *label45                                               ...
  235:  control config *tmp142 @silicon 0 0 0                        ...
        label *label46                                               ...
  236:  op sub .loopTicks @tick :backgroundProcess:ticks             loopTicks = @tick - ticks;
  237:  jump *label4 always 0 0                                      while true do


Performance: parsed in 327 ms, compiled in 271 ms, optimized in 668 ms, run in 21 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (19 steps):
The program didn't generate any output.
Execution exception at instruction 18: sensor :backgroundProcess:coreSilicon .core @silicon:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
