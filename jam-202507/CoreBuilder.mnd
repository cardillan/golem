#set target = 8;
#set syntax = strict;
#set sort-variables;
//#set function-inlining = none;

// Linked variables
linked message1, bank1, processor1, processor2, processor3, processor4, processor5;

noinit var display, controller, flareController, oreLocator, polyController;

require units;
require "Actions.mnd";
require "Display.mnd" remote display;
require "OreLocator.mnd" remote oreLocator;
require "CoreController.mnd" remote controller;
require "FlareController.mnd" remote flareController;
require "PolyController.mnd" remote polyController;

// At this point, we're only using a poly
const capacity = 30;

// Built blocks
var
    press = null,
    generator = null,
    battery = null,
    smelter = null,
    titaniumDrill = null,
    unloader1 = null,
    kiln = null;

noinit var
    core, coreX, coreY,
    builder,

    // Targets to be met for the next build
    targetCopper,
    targetLead,
    targetGraphite,
    targetSilicon,
    targetTitanium,
    targetMetaglass,
    powerTarget;

var
    leadSurplus = 0,
    graphiteSurplus = 20,
    siliconSurplus = 20,
    metaglassSurplus = 20;

var
    flareControllerStarted = false;

external bank1[511] logPosition = 511;

// See BlockConfiguration.mnd
const PRESS = "#'+nA#####";
const BATTERY1 = "k*/(7#####";
const BATTERY2 = "k+/(7#####";
const GENERATOR = "m*.<2#####";
const SMELTER = "%+-A<#####";
const INVERTED_SORT1 = "T+,%%#####";
const PNEUMATIC_DRILL = "w**5#-####";
const UNLOADER1 = "*,###A<##";
const INVERTED_SORT2 = "T),%%#####";
const OVERFLOW_GATE1 = "W*-'%#####";
const PROCESSOR = "®-.}U#U###";
const POWER_NODE = "g)'%)#####";
const UNLOADER2 = "(*###A<##";
const AIR_FACTORY = "'(_i####&";
const UNLOADER3 = ",)###A<##";
const INVERTED_SORT3 = "T,*%%#####";
const KILN = "',+_AA####";
const WATER_EXT = "z%-AAA##A#";
const OVERFLOW_GATE2 = "W'*'%#####";
const OVERFLOW_GATE3 = "W&*'%#####";
const STEAM_GEN = "o%+FK<A###";
const MULTIPRESS = "$(.#U<##";
const WATER_EXT2 = "z%/AAA##A#";
const PAYLOAD_ROUTER = " '%-#2####";
const UNLOADER4 = "*(###A<##";
const UNDERFLOW_GATE = "X*''%#####";
const ADDITIVE_REC = "*%ë#}###";
const OVERFLOW_GATE4 = "W&*'%#####";
const LASER_DRILL = "x**F#AA7##";
const SOLAR_PANEL = "r**#-#+###";
const BATTERY_LARGE = "l.-#U#A7##";

void unpackCfg(cfg, out type, out x, out y, out cu, out pb, out gr, out si, out ti, out mg, out rotation)
    var index = 0;
    type = lookup(:block, char(cfg, index++) - 35);
    x = char(cfg, index++) - 35 - 7;
    y = char(cfg, index++) - 35 - 7;
    cu = char(cfg, index++) - 35;
    pb = char(cfg, index++) - 35;
    gr = char(cfg, index++) - 35;
    si = char(cfg, index++) - 35;
    ti = char(cfg, index++) - 35;
    mg = char(cfg, index++) - 35;
    rotation = char(cfg, index++) - 35;
    //println($"Type: $type, x: $x, y: $y, $cu, $pb, $gr, $si, $ti, $mg, $rotation");
end;

// SUPPLY OPERATIONS

inline void supplyBase0()
    var supplied = false;

    if unloader1 == null then
        if core.@graphite < targetGraphite then
            if press.@coal < 5 then
                status1("Goal 1: graphite requirement");
                supplyBlock(press, @coal);
                supplied = true;
            end;
        end;

        if core.@silicon < targetSilicon then
            if smelter.@coal < 5 then
                status1("Goal 2: coal for silicon requirement");
                supplyBlock(smelter, @coal);
                supplied = true;
            elsif smelter.@sand < 5 then
                status1("Goal 3: sand for silicon requirement");
                supplyBlock(smelter, @sand);
                supplied = true;
            end;
        end;

        if battery.@totalPower < powerTarget then
            if generator.@coal < 2 then
                status1("Goal 4: supplying generator");
                supplyBlock(generator, @coal);
                supplied = true;
            end;
       end;
    end;

    var titaniumTrigger = core.@titanium < targetTitanium ? min(7, targetTitanium - core.@titanium) : 100;
    if titaniumDrill.@titanium < titaniumTrigger then
        if !supplied then
            if battery.@totalPower < unloader1 * powerTarget then
                status1("Goal 5: supplying generator");
                mineOre(@coal);
            elsif core.@silicon < targetSilicon then
                status1("Goal 6: silicon requirement");
                var coal = core.@coal;
                var sand = core.@sand;
                var ore = coal < sand ? @coal : @sand;
                mineOre(ore);
            elsif core.@copper < targetCopper then
                status1("Goal 7: copper requirement");
                mineOre(@copper);
            elsif core.@lead < targetLead then
                status1("Goal 8: lead requirement");
                mineOre(@lead);
            elsif core.@metaglass < targetMetaglass then
                status1("Goal 9: metaglass requirement");
                mineOre(@sand);
            else
                status1("Goal 10: supplying base");
                var coal = core.@coal;
                var sand = core.@sand;
                var ore = coal <= sand ? @coal : @sand;
                mineOre(ore);
            end;
        end;
    else
        status1("Goal 11: Fetching titanium");
        fetchBlock(titaniumDrill, @titanium);
    end;
end;

inline void supplyBase1()
    status1("Phase 1: supplying base");
    mineOre(@coal);
end;

void supplyBase()
    if !flareControllerStarted then
        if controller.flares > 0 then
            flareControllerStarted = true;
            async(flareController.start(core, titaniumDrill));
        end;
    end;

    if controller.monos > 3 then
        supplyBase1();
    else
        supplyBase0();
    end;
end;

inline def targetMet()
    // This is horrible, but Mindcode doesn'T do short-circuit evaluation yet.
    if core.@copper < targetCopper then return false; end;
    if core.@lead < targetLead then return false; end;
    if core.@graphite < targetGraphite then return false; end;
    if core.@silicon < targetSilicon then return false; end;
    if core.@titanium < targetTitanium then return false; end;
    if core.@metaglass < targetMetaglass then return false; end;
    return true;
end;

void meetTarget(block, copper, lead, graphite, silicon, titanium, metaglass)
    // Update display
    var count = 0;
    for var t in copper, lead, graphite, silicon, titanium, metaglass do count += sign(t); end;
    display.totalTargets = count;
    display.nextBlock = block;
    display.targetCopper = copper;
    display.targetLead = lead;
    display.targetGraphite = graphite;
    display.targetSilicon = silicon;
    display.targetTitanium = titanium;
    display.targetMetaglass = metaglass;

    targetCopper = copper;
    targetLead = lead + leadSurplus + 1;
    targetGraphite = graphite;
    targetSilicon = silicon;
    targetTitanium = titanium;
    targetMetaglass = metaglass;

    controller.pressTarget = graphite + graphiteSurplus;
    controller.smelterTarget = silicon + siliconSurplus;
    controller.kilnTarget = metaglass + metaglassSurplus;
    controller.leadReserve = lead + leadSurplus;
    controller.siliconReserve = silicon + sign(silicon) * 20;

    while !targetMet() do
        supplyBase();
    end;
end;

// BUILDING OPERATIONS

inline void log(encodedId)
    bank1[--logPosition] = encodedId + floor(@second * 1000) * 1000;
end;

inline void logBlock(block)
    log(block.@id);
end;

def buildBlockAt(block, x, y, rotation, config, skipError)
    moveTo(x, y);

    status3("Building...");
    var type;
    var building = getBlock(x, y, out type);
    if building != null then
        // The block is already there
        if type == block then return building; end;
        if skipError then return null; end;
        error("Cannot build at (", x, ", ", y, "), tile already contains ", building);
    end;

    build(x, y, block, rotation, config);
    wait(0.25);
    do
        building = getBlock(x, y, out type);
        if building == null then return null; end;
    while type != block;

    logBlock(block);

    return building;
end;

def buildBlock(block, x, y, copper, lead, graphite, silicon, titanium, metaglass, rotation, config)
    meetTarget(block, copper, lead, graphite, silicon, titanium, metaglass);
    return buildBlockAt(block, x, y, rotation, config, false);
end;

// Builds a block
def buildBlockFromCfg(cfg)
    var type, x, y, cu, pb, gr, si, ti, mg, rotation;
    unpackCfg(cfg, out type, out x, out y, out cu, out pb, out gr, out si, out ti, out mg, out rotation);
    return buildBlock(type, coreX + x, coreY + y, cu, pb, gr, si, ti, mg, rotation, null);
end;

def buildBlockFromCfg(cfg, config)
    var type, x, y, cu, pb, gr, si, ti, mg, rotation;
    unpackCfg(cfg, out type, out x, out y, out cu, out pb, out gr, out si, out ti, out mg, out rotation);
    return buildBlock(type, coreX + x, coreY + y, cu, pb, gr, si, ti, mg, rotation, config);
end;

void meetTarget(cfg)
    var type, cu, pb, gr, si, ti, mg;
    unpackCfg(cfg, out type, , , out cu, out pb, out gr, out si, out ti, out mg);
    meetTarget(type, cu, pb, gr, si, ti, mg);
end;

def buildTitaniumDrill(cfg)
    meetTarget(cfg);

    display.nextBlock = @titanium;
    var dx, dy;
    var result = oreLocator.findDrillLocation(coreX, coreY, @unit, @titanium, @ore-titanium, 2, 4, out dx, out dy);
    if !result then error("Cannot locate spot for titanium drill"); end;
    display.nextBlock = @pneumatic-drill;

    return buildBlockAt(@pneumatic-drill, dx, dy, null, 0, false);
end;

void buildThoriumDrill()
    meetTarget(LASER_DRILL);

    var result = await(layoutThoriumDrill);
    if !result then error("Cannot locate spot for thorium drill"); end;
    var thoriumDrill = buildBlockAt(@laser-drill, oreLocator.drillX, oreLocator.drillY, null, 0, false);

    if oreLocator.water1X < 0 then return; end;
    meetTarget(WATER_EXT);
    buildBlockAt(@water-extractor, oreLocator.water1X, oreLocator.water1Y, null, 0, false);

    if oreLocator.water2X < 0 then return; end;

    meetTarget(WATER_EXT);
    buildBlockAt(@water-extractor, oreLocator.water2X, oreLocator.water2Y, null, 0, false);

    meetTarget(WATER_EXT);
    var thoriumGenerator = buildBlockAt(@steam-generator, oreLocator.generatorX, oreLocator.generatorY, null, 0, false);

    meetTarget(POWER_NODE);
    buildBlockAt(@power-node, oreLocator.nodeX, oreLocator.nodeY, null, 0, false);

    meetTarget(SOLAR_PANEL);
    buildBlockAt(@solar-panel, oreLocator.panelX, oreLocator.panelY, null, 0, false);

    meetTarget(BATTERY1);
    buildBlockAt(@battery, oreLocator.batteryX, oreLocator.batteryY, null, 0, false);

    display.thoriumDrill = thoriumDrill;
    flareController.addThoriumDrill(thoriumDrill, thoriumGenerator);
end;

// MAIN

def findUnits(type, out count)
    count = 0;
    var firstUnit = ubind(type);
    if firstUnit != null then
        do
            count++;
            ubind(type);
        while @unit != firstUnit;
    end;

    count;
end;

void buildUnits()
    meetTarget(0, 0, 0, 0, 0, 0, 0);
    display.totalTargets = 0;
    display.nextBlock = null;
    controller.leadReserve = 0;
    controller.siliconReserve = 0;
end;

begin
    // INITIALIZATION

    do
        builder = ubind(@poly);
        core = ulocate(:building, :core, false, out coreX, out coreY);
    while core == null;

    display = processor1;
    flareController = processor3;
    oreLocator = processor4;
    polyController = processor5;
    async(polyController.startPolyController(core, @unit));

    // Bind and flag units
    var flares = findUnits(@flare, out display.displayFlares);
    var monos = findUnits(@mono, out display.displayMonos);
    var polys = findUnits(@poly, out display.displayPolys);

    // PHASE 0: BASIC BLOCKS

    press = buildBlockFromCfg(PRESS);
    battery = buildBlockFromCfg(BATTERY1);
    buildBlockFromCfg(BATTERY2);
    generator = buildBlockFromCfg(GENERATOR);

    powerTarget = 400;

    smelter = buildBlockFromCfg(SMELTER);
    buildBlockFromCfg(INVERTED_SORT1);
    titaniumDrill = buildTitaniumDrill(PNEUMATIC_DRILL);
    display.titaniumDrill = titaniumDrill;
    unloader1 = buildBlockFromCfg(UNLOADER1);
    buildBlockFromCfg(INVERTED_SORT2);
    buildBlockFromCfg(OVERFLOW_GATE1);
    graphiteSurplus = 100;

    // Build and initialize base controller

    controller = buildBlockFromCfg(PROCESSOR, processor2);
    controller.display = display;
    controller.core = core;
    controller.bank = bank1;
    controller.battery = battery;
    controller.generator = generator;
    controller.smelter = smelter;
    controller.press = press;
    controller.monos = monos;
    controller.flares = flares;
    controller.polys = polys;

    buildBlockFromCfg(POWER_NODE);
    controller.unloader2 = buildBlockFromCfg(UNLOADER2);

    var factory = buildBlockFromCfg(AIR_FACTORY);
    controller.factory = factory;
    display.factory = factory;

    // PHASE 1: BUILDING UNITS

    controller.flareTarget = 1;
    controller.monoTarget = 3;
    controller.polyTarget = 0;
    controller.pressTarget = 85;
    controller.smelterTarget = 150;
    controller.kilnTarget = 30;
    siliconSurplus = leadSurplus = 20;

    buildUnits();
    do
        supplyBase();

        // We're low on power: the air units might not get built in time
        // Go on building additional power reserves yourself.
        if battery.@totalPower < 300 then break; end;
    while controller.monos < 3;

    // Build stock
    siliconSurplus = 65;

    // Kiln - needed for metaglass
    buildBlockFromCfg(UNLOADER3);
    buildBlockFromCfg(INVERTED_SORT3);
    kiln = buildBlockFromCfg(KILN);
    controller.kiln = kiln;

    // Steam generator
    buildBlockFromCfg(WATER_EXT);
    buildBlockFromCfg(OVERFLOW_GATE2);
    buildBlockFromCfg(OVERFLOW_GATE3);
    controller.generator2 = buildBlockFromCfg(STEAM_GEN);

    controller.multipress = buildBlockFromCfg(MULTIPRESS);
    //buildBlockFromCfg(WATER_EXT2);

    //buildBlockFromCfg(BATTERY_LARGE);
    graphiteSurplus = 200;

    // POLYS
    controller.payloadRouter = buildBlockFromCfg(PAYLOAD_ROUTER);
    buildBlockFromCfg(UNLOADER4);
    buildBlockFromCfg(UNDERFLOW_GATE);
    var reconstructor = buildBlockFromCfg(ADDITIVE_REC);
    controller.reconstructor = reconstructor;
    display.reconstructor = reconstructor;

    buildUnits();

    // Even more stock
    siliconSurplus = 1000;
    metaglassSurplus = 200;

    controller.polyTarget = 3;
    while controller.polys < 3 do
        supplyBase();
    end;

    controller.flareTarget = 8;
    controller.polyTarget = 6;
    while controller.flares < 2 do
        supplyBase();
    end;

    ubind(@flare);
    display.nextBlock = @ore-titanium;
    oreLocator.findDrillLocation(coreX, coreY, @unit, @titanium, @ore-titanium, 4, 1e9);
    ubind(builder);

    do
        supplyBase();
    while !finished(oreLocator.findDrillLocation);

    display.nextBlock = null;

    findFreeUnit(@flare, 0);
    async(oreLocator.layoutThoriumDrill(coreX, coreY, @unit, 7));
    ubind(builder);
    do
        supplyBase();
    while !finished(layoutThoriumDrill);

    buildThoriumDrill();

    display.totalTargets = 0;
    display.nextBlock = null;
    do
        supplyBase();
    while controller.flares + controller.monos < 16;

    while true do
        supplyBase();
    end;

    stop();
    error("Done");
end;
