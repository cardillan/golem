#set target = 8;
#set syntax = strict;
#set function-inlining = none;
#set sort-variables;
//#set loop-hoisting = none;
//#set unreachable-code-elimination = none;
//#set optimization = none;

// Linked variables
linked message1, bank1, processor1, processor2, processor3, processor4;

noinit var display, controller, flareController, oreLocator;

require units;
require "Actions.mnd";
require "Display.mnd" remote display;
require "CoreController.mnd" remote controller;
require "FlareController.mnd" remote flareController;
require "OreLocator.mnd" remote oreLocator;

// At this point, we're only using a poly
const capacity = 30;

// Built blocks
var
    press = null,
    generator = null,
    battery = null,
    smelter = null,
    titaniumDrill = null,
    unloader1 = null,
    unloader2 = null,
    factory = null,
    generator2 = null,
    kiln = null,
    thoriumDrill = null,
    thoriumGenerator = null;

// Targets to be met for the next build
noinit var
    core, coreX, coreY,
    builder,
    targetCopper,
    targetLead,
    targetGraphite,
    targetSilicon,
    targetTitanium,
    targetMetaglass,
    targetLeadFactory,
    targetSiliconFactory,
    powerTarget;

var phase = 0;

var
    graphiteSurplus = 20,
    siliconSurplus = 20,
    metaglassSurplus = 20;

external bank1[511] logPosition = 511;

// Blocks layout around the core and build requirements

const CFG_BLOCK_TYPE  = 0;
const CFG_X           = CFG_BLOCK_TYPE + 1;
const CFG_Y           = CFG_X + 1;
const CFG_COPPER      = CFG_Y + 1;
const CFG_LEAD        = CFG_COPPER + 1;
const CFG_GRAPHITE    = CFG_LEAD + 1;
const CFG_SILICON     = CFG_GRAPHITE + 1;
const CFG_TITANIUM    = CFG_SILICON + 1;
const CFG_METAGLASS   = CFG_TITANIUM + 1;
const CFG_ROTATION    = CFG_METAGLASS + 1;
const CFG_CONFIG      = CFG_ROTATION + 1;

//                         Block type                 X     Y   Cu  Pb  GR  Si  Ti  MG   R  Cfg
const PRESS[]           = (@graphite-press,        -1.5, +2.5,  75, 30,  0,  0,  0,  0,  0, null);
const BATTERY1[]        = (@battery,                0.0, +4.0,   5, 20,  0,  0,  0,  0,  0, null);
const BATTERY2[]        = (@battery,               -1.0, +4.0,   5, 20,  0,  0,  0,  0,  0, null);
const GENERATOR[]       = (@combustion-generator,   0.0, +3.0,  25, 15,  0,  0,  0,  0,  0, null);
const SMELTER[]         = (@silicon-smelter,       +1.5, +2.5,  30, 25,  0,  0,  0,  0,  0, null);
const PNEUMATIC_DRILL[] = (@pneumatic-drill,        0.0,  0.0,  18,  0, 10,  0,  0,  0,  0, null);
const UNLOADER1[]       = (@unloader,               0.0, +2.0,   0,  0,  0, 30, 25,  0,  0, null);
const PROCESSOR[]       = (@micro-processor,       +1.0, +4.0,  90, 50,  0, 50,  0,  0,  0, processor2);
const POWER_NODE[]      = (@power-node,            -2.0, -1.0,   2,  6,  0,  0,  0,  0,  0, null);
const BATTERY_LARGE[]   = (@battery-large,         +4.0, +3.0,   0, 50,  0, 30, 20,  0,  0, null);
const UNLOADER2[]       = (@unloader,              -2.0, +1.0,   0,  0,  0, 30, 25,  0,  0, null);
const OVERFLOW_GATE[]   = (@overflow-gate,         -3.0,  1.0,   4,  2,  0,  0,  0,  0,  0, null);
const AIR_FACTORY[]     = (@air-factory,           -4.0, -1.0,  60, 70,  0,  0,  0,  0,  3, @mono);

const LASER_DRILL[]     = (@laser-drill,            0.0,  0.0,  35,  0, 30, 30, 20,  0,  0, null);
const SOLAR_PANEL[]     = (@solar-panel,            0.0,  0.0,   0, 10,  0,  8,  0,  0,  0, null);

const UNLOADER3[]       = (@unloader,              +2.0,  0.0,   0,  0,  0, 30, 25,  0,  0, null);
const KILN[]            = (@kiln,                  +3.5, +0.5,  60, 30, 30,  0,  0,  0,  0, null);
const JUNCTION[]        = (@junction,              +2.0, +1.0,   3,  0,  0,  0,  0,  0,  0, null);
const WATER_EXT[]       = (@water-extractor,       -3.5, +4.5,  30, 30, 30,  0,  0, 30,  0, null);
const STEAM_GEN[]       = (@steam-generator,       -3.5, +2.5,  35, 40, 25, 30,  0,  0,  0, null);
const SORTER[]          = (@sorter,                -4.0,  1.0,   2,  2,  0,  0,  0,  0,  0, @coal);

// Non-core based blocks

// UTILITY FUNCTIONS

inline void status1(text)
    display.status1 = text;
end;

inline void status2(text, item, block)
    display.status2  = text;
    display.item2  = item;
    display.block2 = block;
end;

inline void status3(text)
    display.status3 = text;
end;

inline void transportStatus(target, item)
    display.transportTarget = target;
    display.transportItem = item;
end;

// SUPPLY OPERATIONS

// Supplies the block with the given amount of ore
inline void supplyBlock(block, ore)
    status2("Supplying ", ore, block);
    var blockCapacity = block.@itemCapacity;
    var missing = blockCapacity - block.sensor(ore);
    if missing > 0 then
        mineOre(ore, blockCapacity, block);
    end;
end;

void supplyBase0()
    var supplied = false;

    if unloader1 == null then
        if core.@graphite < targetGraphite then
            if press.@coal < 5 then
                status1("Goal 1: graphite requirement");
                supplyBlock(press, @coal);
                supplied = true;
            end;
        end;

        if core.@silicon < targetSilicon then
            if smelter.@coal < 5 then
                status1("Goal 2: coal for silicon requirement");
                supplyBlock(smelter, @coal);
                supplied = true;
            elsif smelter.@sand < 5 then
                status1("Goal 3: sand for silicon requirement");
                supplyBlock(smelter, @sand);
                supplied = true;
            end;
        end;

        if battery.@totalPower < powerTarget then
            if generator.@coal < 2 then
                status1("Goal 4: supplying generator");
                supplyBlock(generator, @coal);
                supplied = true;
            end;
       end;
    end;

    var titaniumTrigger = core.@titanium < targetTitanium ? min(7, targetTitanium - core.@titanium) : 100;
    if titaniumDrill.@titanium < titaniumTrigger then
        if !supplied then
            if battery.@totalPower < unloader1 * powerTarget then
                status1("Goal 5: supplying generator");
                mineOre(@coal);
            elsif core.@silicon < targetSilicon then
                status1("Goal 6: silicon requirement");
                var coal = core.@coal;
                var sand = core.@sand;
                var ore = coal < sand ? @coal : @sand;
                mineOre(ore);
            elsif core.@copper < targetCopper then
                status1("Goal 7: copper requirement");
                mineOre(@copper);
            elsif core.@lead < targetLead then
                status1("Goal 8: lead requirement");
                mineOre(@lead);
            elsif core.@metaglass < targetMetaglass then
                status1("Goal 9: metaglass requirement");
                mineOre(@sand);
            else
                status1("Goal 10: supplying base");
                var coal = core.@coal;
                var sand = core.@sand;
                var ore = coal <= sand ? @coal : @sand;
                mineOre(ore);
            end;
        end;
    else
        status1("Goal 11: Fetching titanium");
        fetchBlock(titaniumDrill, @titanium);
    end;
end;

void supplyBase1()
    status1("Phase 1: supplying base");
    mineOre(@coal);
//    if core.@sand < core.@coal then
//        if core.@sand < core.@lead then
//            status1("Phase 1: mining sand");
//            mineOre(@sand);
//        else
//            status1("Phase 1: mining lead");
//            mineOre(@lead);
//        end;
//    else
//        if core.@coal < core.@lead then
//            status1("Phase 1: mining coal");
//            mineOre(@coal);
//        else
//            status1("Phase 1: mining lead");
//            mineOre(@lead);
//        end;
//    end;
end;

void supplyBase()
    if controller.monos > 3 then
        supplyBase1();
    else
        supplyBase0();
    end;
end;

noinit var leadSiliconBlock;

def targetMet()
    if core.@copper >= targetCopper then
        if core.@lead >= targetLead then
            if core.@graphite >= targetGraphite then
                if core.@silicon >= targetSilicon then
                    if core.@titanium >= targetTitanium then
                        if core.@metaglass >= targetMetaglass then
                            return true;
                        end;
                    end;
                end;
            end;
        end;
    end;
    return false;
end;

void meetTarget(block, copper, lead, graphite, silicon, titanium, metaglass)
    // Update display
    var count = 0;
    for var t in copper, lead, graphite, silicon, titanium, metaglass do count += sign(t); end;
    display.totalTargets = count;
    display.nextBlock = block;
    display.targetCopper = copper;
    display.targetLead = lead;
    display.targetGraphite = graphite;
    display.targetSilicon = silicon;
    display.targetTitanium = titanium;
    display.targetMetaglass = metaglass;

    targetCopper = copper;
    targetLead = lead;
    targetGraphite = graphite;
    targetSilicon = silicon;
    targetTitanium = titanium;
    targetMetaglass = metaglass;

    controller.pressTarget = graphite + graphiteSurplus;
    controller.smelterTarget = silicon + siliconSurplus;
    controller.kilnTarget = metaglass + metaglassSurplus;
    controller.leadReserve = lead + sign(lead) * 20;
    controller.siliconReserve = silicon + sign(silicon) * 20;

    while !targetMet() do
        supplyBase();
    end;
end;

// BUILDING OPERATIONS

void log(encodedId)
    bank1[--logPosition] = encodedId + floor(second()) * 1000;
end;

void logBlock(block)
    log(block.@id);
end;

def buildBlockAt(block, x, y, rotation, config, skipError)
    moveTo(x, y);

    status3("Building...");
    var type;
    var building = getBlock(x, y, out type);
    if building != null then
        // The block is already there
        if type == block then return building; end;
        if skipError then return null; end;
        error("Cannot build at (", x, ", ", y, "), tile already contains ", building);
    end;

    build(x, y, block, rotation, config);
    wait(0.25);
    do
        building = getBlock(x, y, out type);
        if building == null then return null; end;
    while type != block;

    logBlock(block);

    return building;
end;

def buildBlock(block, x, y, copper, lead, graphite, silicon, titanium, metaglass, rotation, config)
    meetTarget(block, copper, lead, graphite, silicon, titanium, metaglass);
    return buildBlockAt(block, x, y, rotation, config, false);
end;

// Builds a block
inline def buildBlockFromCfg(ref cfg)
    for var block, offsetX, offsetY, copper, lead, graphite, silicon, titanium, metaglass, rotation, config in cfg do
        var x = coreX + offsetX;
        var y = coreY + offsetY;
        return buildBlock(block, x, y, copper, lead, graphite, silicon, titanium, metaglass, rotation, config);
    end;
end;


inline void meetTarget(ref cfg)
    meetTarget(
        cfg[CFG_BLOCK_TYPE],
        cfg[CFG_COPPER],
        cfg[CFG_LEAD],
        cfg[CFG_GRAPHITE],
        cfg[CFG_SILICON],
        cfg[CFG_TITANIUM],
        cfg[CFG_METAGLASS]);
end;

inline def buildTitaniumDrill(ref cfg)
    meetTarget(ref cfg);

    display.nextBlock = @titanium;
    var dx, dy;
    var result = oreLocator.findDrillLocation(coreX, coreY, @unit, @titanium, @ore-titanium, false, 4, out dx, out dy);
    if !result then error("Cannot locate spot for titanium drill"); end;
    display.nextBlock = @pneumatic-drill;

    return buildBlockAt(@pneumatic-drill, dx, dy, null, 0, false);
end;

void buildThoriumDrill()
    meetTarget(ref LASER_DRILL);

    var result = await(layoutThoriumDrill);
    if !result then error("Cannot locate spot for thorium drill"); end;
    thoriumDrill = buildBlockAt(@laser-drill, oreLocator.drillX, oreLocator.drillY, null, 0, false);

    if oreLocator.water1X < 0 then return; end;
    meetTarget(ref WATER_EXT);
    buildBlockAt(@water-extractor, oreLocator.water1X, oreLocator.water1Y, null, 0, false);

    if oreLocator.water2X < 0 then return; end;

    meetTarget(ref WATER_EXT);
    buildBlockAt(@water-extractor, oreLocator.water2X, oreLocator.water2Y, null, 0, false);

    meetTarget(ref WATER_EXT);
    thoriumGenerator = buildBlockAt(@steam-generator, oreLocator.generatorX, oreLocator.generatorY, null, 0, false);

    meetTarget(ref POWER_NODE);
    buildBlockAt(@power-node, oreLocator.nodeX, oreLocator.nodeY, null, 0, false);

    meetTarget(ref SOLAR_PANEL);
    buildBlockAt(@solar-panel, oreLocator.panelX, oreLocator.panelY, null, 0, false);

    meetTarget(ref BATTERY1);
    buildBlockAt(@battery, oreLocator.batteryX, oreLocator.batteryY, null, 0, false);

    display.thoriumDrill = thoriumDrill;
    flareController.addThoriumDrill(thoriumDrill, thoriumGenerator);
end;

// MAIN

def findUnits(type, out count)
    count = 0;
    var firstUnit = ubind(type);
    if firstUnit != null then
        do
            count++;
            ubind(type);
        while @unit != firstUnit;
    end;

    count;
end;

void buildUnits(unit)
    display.totalTargets = 0;
    display.nextBlock = null;
    controller.leadReserve = 0;
    controller.siliconReserve = 0;
    controller.unitToProduce = unit;
end;

begin
    do
        builder = ubind(@poly);
        core = ulocate(:building, :core, false, out coreX, out coreY);
    while core == null;

    // Error - unrecognized remote processor
    //verifySignature(display);
    display = processor1;
    flareController = processor3;
    oreLocator = processor4;

    // Bind and flag units
    var monos = findUnits(@mono, out display.monos);
    var flares = findUnits(@flare, out display.flares);
    var polys = findUnits(@poly, out display.polys);

    // Basic blocks: copper and lead
    press = buildBlockFromCfg(ref PRESS);
    battery = buildBlockFromCfg(ref BATTERY1);
    buildBlockFromCfg(ref BATTERY2);
    generator = buildBlockFromCfg(ref GENERATOR);

    powerTarget = 800;

    smelter = buildBlockFromCfg(ref SMELTER);
    titaniumDrill = buildTitaniumDrill(ref PNEUMATIC_DRILL);
    display.titaniumDrill = titaniumDrill;

    unloader1 = buildBlockFromCfg(ref UNLOADER1);
    controller = buildBlockFromCfg(ref PROCESSOR);

    controller.display = display;
    controller.core = core;
    controller.bank = bank1;
    controller.battery = battery;
    controller.generator = generator;
    controller.smelter = smelter;
    controller.press = press;
    controller.monos = monos;
    controller.flares = flares;
    controller.polys = polys;

    buildBlockFromCfg(ref POWER_NODE);
    unloader2 = buildBlockFromCfg(ref UNLOADER2);
    controller.unloader2 = unloader2;

    buildBlockFromCfg(ref OVERFLOW_GATE);
    factory = buildBlockFromCfg(ref AIR_FACTORY);
    controller.factory = factory;
    display.factory = factory;

    // We're getting into the "build the damn units" mode
    controller.flareTarget = 2;
    buildUnits(@flare);
    phase++;

    controller.pressTarget = 85;
    controller.smelterTarget = 150;
    controller.kilnTarget = 30;

    var searchThorium = true;
    do
        if searchThorium and controller.flares > 0 then
            searchThorium = false;
            findFreeUnit(@flare, 0);
            async(oreLocator.layoutThoriumDrill(coreX, coreY, @unit, 7));
            ubind(builder);
            flareController.start(core, titaniumDrill);
        end;

        supplyBase();
        if battery.@totalPower < 300 then break; end;
    while controller.monos < 3;

    flareController.start(core, titaniumDrill);

    buildBlockFromCfg(ref UNLOADER3);
    kiln = buildBlockFromCfg(ref KILN);
    controller.kiln = kiln;

    buildBlockFromCfg(ref JUNCTION);
    buildBlockFromCfg(ref WATER_EXT);
    generator2 = buildBlockFromCfg(ref STEAM_GEN);
    controller.generator2 = generator2;
    //buildBlockFromCfg(ref BATTERY_LARGE);

    graphiteSurplus = 200;
    siliconSurplus = 1000;
    metaglassSurplus = 200;

    if searchThorium then
        while controller.flares < 1 do
            supplyBase();
        end;

        searchThorium = false;
        findFreeUnit(@flare, 0);
        async(oreLocator.layoutThoriumDrill(coreX, coreY, @unit, 7));
        ubind(builder);
        do
            supplyBase();
        while !finished(layoutThoriumDrill);
    end;

    buildThoriumDrill();
    buildBlockFromCfg(ref SORTER);

    display.totalTargets = 0;
    display.nextBlock = null;
    do
        supplyBase();
    while controller.flares + controller.monos < 16;

    while true do
        supplyBase();
    end;

    stop();
    error("Done");
end;
