#set target = 8;
#set syntax = strict;
#set function-inlining = none;
#set sort-variables;
//#set loop-hoisting = none;
//#set unreachable-code-elimination = none;
//#set optimization = none;

// Linked variables
linked message1, switch1, processor1, processor2;

noinit var processor, display;

require "Display.mnd" remote display;
require "CoreController.mnd" remote processor;

const DROP_MINING_RADIUS = 7;
const REGULAR_RADIUS =  5;     // or build

// At this point, we're only using a poly
const capacity = 30;

// Built blocks
var
    press = null,
    generator = null,
    battery = null,
    smelter = null,
    titanium_drill = null,
    unloader1 = null,
    unloader2 = null,
    factory = null,
    generator2 = null,
    kiln = null;

// Targets to be met for the next build
noinit var
    mainUnit,
    core, coreX, coreY,
    copperTarget,
    leadTarget,
    graphiteTarget,
    siliconTarget,
    titaniumTarget,
    metaglassTarget,
    powerTarget,
    titaniumTrigger;

var
    monos = 0,
    flares = 0,
    polys = 0;

// Blocks layout around the core and build requirements

const CFG_BLOCK_TYPE  = 0;
const CFG_X           = CFG_BLOCK_TYPE + 1;
const CFG_Y           = CFG_X + 1;
const CFG_COPPER      = CFG_Y + 1;
const CFG_LEAD        = CFG_COPPER + 1;
const CFG_GRAPHITE    = CFG_LEAD + 1;
const CFG_SILICON     = CFG_GRAPHITE + 1;
const CFG_TITANIUM    = CFG_SILICON + 1;
const CFG_METAGLASS   = CFG_TITANIUM + 1;
const CFG_ROTATION    = CFG_METAGLASS + 1;
const CFG_CONFIG      = CFG_ROTATION + 1;

//                         Block type                 X     Y   Cu  Pb  GR  Si  Ti  MG   R  Cfg
const PRESS[]           = (@graphite-press,        -1.5, +2.5,  75, 30,  0,  0,  0,  0,  0, null);
const GENERATOR[]       = (@combustion-generator,   0.0, +3.0,  25, 15,  0,  0,  0,  0,  0, null);
const BATTERY1[]        = (@battery,                0.0, +4.0,   5, 20,  0,  0,  0,  0,  0, null);
const BATTERY2[]        = (@battery,               -1.0, +4.0,   5, 20,  0,  0,  0,  0,  0, null);
const SMELTER[]         = (@silicon-smelter,       +1.5, +2.5,  30, 25,  0,  0,  0,  0,  0, null);
const UNLOADER1[]       = (@unloader,               0.0, +2.0,   0,  0,  0, 30, 25,  0,  0, null);
const PROCESSOR[]       = (@micro-processor,       +1.0, +4.0,  90, 50,  0, 50,  0,  0,  0, processor2);
const UNLOADER2[]       = (@unloader,              -2.0, +1.0,   0,  0,  0, 30, 25,  0,  0, null);
const POWER_NODE[]      = (@power-node,            -2.0, -1.0,   2,  6,  0,  0,  0,  0,  0, null);
const OVERFLOW_GATE[]   = (@overflow-gate,         -3.0,  1.0,   4,  2,  0,  0,  0,  0,  0, null);
const AIR_FACTORY[]     = (@air-factory,           -4.0, -1.0,  60, 70,  0,  0,  0,  0,  3, @mono);

const UNLOADER3[]       = (@unloader,              +2.0,  0.0,   0,  0,  0, 30, 25,  0,  0, null);
const KILN[]            = (@kiln,                  +3.5, +0.5,  60, 30, 30,  0,  0,  0,  0, null);
const JUNCTION[]        = (@junction,              +2.0, +1.0,   3,  0,  0,  0,  0,  0,  0, null);
const WATER_EXT[]       = (@water-extractor,       -3.5, +4.5,  30, 30, 30,  0,  0, 30,  0, null);
const STEAM_GEN[]       = (@steam-generator,       -3.5, +2.5,  35, 40, 25, 30,  0,  0,  0, null);
const SORTER[]          = (@sorter,                -4.0,  1.0,   2,  2,  0,  0,  0,  0,  0, @coal);

// Non-core based blocks
const PNEU_DRILL[]      = (@pneumatic-drill,        0.0,  0.0,  18,  0, 10,  0,  0,  0,  0, null);

// UTILITY FUNCTIONS

inline void status1(text)
    display.status1 = text;
end;

inline void status2(text, item, block)
    display.status2  = text;
    display.item2  = item;
    display.block2 = block;
end;

inline void status3(text)
    display.status3 = text;
end;

inline void error(text...)
    print("[salmon]", text);
    printflush(message1);
    stopProcessor();
end;

// BASIC OPERATIONS
// ALL THESE WAIT FOR COMPLETION

// Moves the unit to a given distance from the location
void moveTo(x, y, radius)
    status3("Moving...");
    while !within(x, y, radius) do
        approach(x, y, radius - 0.5);
    end;
end;

// Moves the unit to a mining distance from the location
void moveTo(x, y)
    moveTo(x, y, REGULAR_RADIUS);
end;

// Moves the unit to the given location, ensuring it is empty on arrival
void moveToEmpty(x, y)
    status3("Moving...");
    do
        // If ore is held, try to drop it during transport to start cooldown earlier
        if @unit.@firstItem != null then itemDrop(@air, 1000); end;
        approach(x, y, REGULAR_RADIUS - 0.5);
    while !within(x, y, REGULAR_RADIUS);

    // Now drop it for real
    while @unit.@firstItem != null do
        itemDrop(@air, 1000);
    end;
end;

// Moves the unit to the a given distance from a block
void moveToBlock(block, radius)
    moveTo(block.@x, block.@y, radius);
end;

// Drops all items to block (does nothing when empty)
// - moves to a drop distance from the block
// - makes sure everything is dropped or the block is full
void depositItems(block, item, fromMining)
    status3("Depositing...");
    if @unit.@firstItem == item then
        moveToBlock(block, fromMining && block == core ? DROP_MINING_RADIUS : REGULAR_RADIUS);
        var cap = block.@itemCapacity;
        do
            itemDrop(block, capacity);
            if block.sensor(item) >= cap then break; end;
        while @unit.@firstItem != null;
    else
        // Wrong item(!)
        while @unit.@firstItem != null do
            itemDrop(@air, 1000);
        end;
    end;
    display.transportTarget = 0;
    display.transportItem = null;
end;

// Locates the ore, crashes when not successful
void locateOre(ore, out x, out y)
    if !ulocate(:ore, ore, out x, out y) then
        error("Cannot locate ", ore);
    end;
end;

// Mines given amount of ore and deposits it to given block
void mineOre(ore, amount, block)
    amount = min(amount, capacity);
    display.transportTarget = amount;
    display.transportItem = ore;
    var x, y;
    locateOre(ore, out x, out y);

    moveToEmpty(x, y);

    status3("Mining...");
    do
        // Okay, not sure how it can happen, but it does sometimes
        var item = @unit.@firstItem;
        if item != null && item != ore then break; end;

        mine(x, y);
    while @unit.@totalItems < amount;

    // We need to stop mining. stop() somehow interferes with building.
    unbind();

    // And drop it
    depositItems(block, ore, true);
end;

// Mines to the core
void mineOre(ore)
    status2("Mining ", ore, "core");
    mineOre(ore, capacity, core);
end;

// SUPPLY OPERATIONS

void fetchBlock(block, item)
    display.transportTarget = block.@itemCapacity;
    display.transportItem = item;
    status2("Fetching ", item, block);
    moveToEmpty(block.@x, block.@y);

    do
        itemTake(block, item, capacity);
        var unitItem = @unit.@firstItem;
        if unitItem != null and unitItem != item then
            itemDrop(@air, 1000);
        end;
     while @unit.sensor(item) < capacity and block.sensor(item);

    depositItems(core, item, false);
end;

// Supplies the block with the given amount of ore
inline void supplyBlock(block, ore)
    status2("Supplying ", ore, block);
    var blockCapacity = block.@itemCapacity;
    var missing = blockCapacity - block.sensor(ore);
    if missing > 0 then
        mineOre(ore, blockCapacity, block);
    end;
end;

// Returns true when all targets are met
void supplyBase()
    var supplied = false;

    if unloader1 == null then
        if core.@graphite < graphiteTarget then
            if press.@coal < 5 then
                status1("Goal 1: Meeting the graphite target");
                supplyBlock(press, @coal);
                supplied = true;
            end;
        end;

        if core.@silicon < siliconTarget then
            if smelter.@coal < 5 then
                status1("Goal 2: Meeting the silicon target (coal)");
                supplyBlock(smelter, @coal);
                supplied = true;
            elsif smelter.@sand < 5 then
                status1("Goal 3: Meeting the silicon target (sand)");
                supplyBlock(smelter, @sand);
                supplied = true;
            end;
        end;

        if battery.@totalPower < powerTarget then
            if generator.@coal < 2 then
                status1("Goal 4: Supplying generator");
                supplyBlock(generator, @coal);
                supplied = true;
            end;
       end;
    end;

    if titanium_drill.@titanium < titaniumTrigger then
        if !supplied then
            if battery.@totalPower < unloader1 * powerTarget then
                status1("Goal 5: Supplying generator (5)");
                mineOre(@coal);
            elsif core.@silicon < siliconTarget then
                status1("Goal 6: Meeting the silicon target");
                var coal = core.@coal;
                var sand = core.@sand;
                var ore = coal < sand ? @coal : @sand;
                mineOre(ore);
            elsif core.@copper < copperTarget then
                status1("Goal 7: Meeting the copper target");
                mineOre(@copper);
            elsif core.@lead < leadTarget then
                status1("Goal 8: Meeting the lead target");
                mineOre(@lead);
            elsif core.@metaglass < metaglassTarget then
                status1("Goal 9: Meeting the metaglass target");
                mineOre(@sand);
            else
                status1("Goal 10: Supplying base");
                var coal = core.@coal;
                var sand = core.@sand;
                var ore = coal <= sand ? @coal : @sand;
                mineOre(ore);
            end;
        end;
    else
        status1("Goal 11: Fetching titanium");
        fetchBlock(titanium_drill, @titanium);
    end;
end;


void meetTarget(block, copper, lead, graphite, silicon, titanium, metaglass, factoryLead, factorySilicon)
    // Update display
    var totalLead = max(lead, factoryLead);
    var totalSilicon = max(silicon, factorySilicon);
    var count = 0;
    for var t in copper, totalLead, graphite, totalSilicon, titanium, metaglass do count += sign(t); end;
    display.totalTargets = count;
    display.nextBlock = block;
    display.copperTarget = copper;
    display.leadTarget = totalLead;
    display.graphiteTarget = graphite;
    display.siliconTarget = totalSilicon;
    display.titaniumTarget = titanium;
    display.metaglassTarget = metaglass;
    display.monos = monos;
    display.polys = polys;
    display.flares = flares;

    copperTarget = copper;
    leadTarget = lead + factory * 10;
    graphiteTarget = graphite;
    siliconTarget = silicon + factory * 10;
    titaniumTarget = titanium;
    metaglassTarget = metaglass;

    processor.pressTarget = graphiteTarget + 20;
    processor.smelterTarget = siliconTarget + 20;
    processor.kilnTarget = metaglassTarget + 20;

    titaniumTrigger = core.@titanium < titaniumTarget ? 7 : 100;

    while core.@copper < copperTarget
        || core.@lead < leadTarget
        || core.@graphite < graphiteTarget
        || core.@silicon < siliconTarget
        || core.@titanium < titaniumTarget
        || core.@metaglass < metaglassTarget
        || factory.@lead < factoryLead
        || factory.@silicon < factorySilicon
    do
        supplyBase();
    end;
end;

// BUILDING OPERATIONS

def buildBlockAt(block, x, y, rotation, config, skipError)
    moveTo(x, y);

    status3("Building...");
    var type;
    var building = getBlock(x, y, out type);
    if building != null then
        // The block is already there
        if type == block then return building; end;
        if skipError then return null; end;
        error("Cannot build at (", x, ", ", y, "), tile already contains ", building);
    end;

    build(x, y, block, rotation, config);
    wait(0.25);
    do
        building = getBlock(x, y, out type);
        if building == null then break; end;
    while type != block;

    return building;
end;

def buildBlock(block, x, y, copper, lead, graphite, silicon, titanium, metaglass, rotation, config)
    meetTarget(block, copper, lead, graphite, silicon, titanium, metaglass, 0, 0);
    return buildBlockAt(block, x, y, rotation, config, false);
end;

// Builds a block
inline def buildBlockFromCfg(ref cfg)
    for var block, offsetX, offsetY, copper, lead, graphite, silicon, titanium, metaglass, rotation, config in cfg do
        var x = coreX + offsetX;
        var y = coreY + offsetY;
        return buildBlock(block, x, y, copper, lead, graphite, silicon, titanium, metaglass, rotation, config);
    end;
end;

inline def moveToNextLocation(ref distance, ref angle)
    moveTo(coreX + sin(angle) * distance, coreY + cos(angle) * distance);
    distance += 4;
    angle += 45;
end;

inline def locateOreAway(ore, out x, out y, in out distance, in out angle)
    while true do
        locateOre(ore, out x, out y);
        if abs(x - coreX) >= 10 or abs(y - coreY) >= 10 then break; end;

        moveToNextLocation(ref distance, ref angle);
    end;
end;

inline def checkOre(x, y, ore, in out count)
    var floor;
    getBlock(x, y, , out floor);
    if floor == ore then count++; end;
end;

inline def buildTitaniumDrillCfg(ref cfg)
    var distance = 32;
    var angle = 0;
    var attempts = 0;
    var minimum = 3;

    while true do
        meetTarget(
            cfg[CFG_BLOCK_TYPE],
            cfg[CFG_COPPER],
            cfg[CFG_LEAD],
            cfg[CFG_GRAPHITE],
            cfg[CFG_SILICON],
            cfg[CFG_TITANIUM],
            cfg[CFG_METAGLASS],
            0, 0);

        var x, y;
        locateOreAway(@titanium, out x, out y, in out distance, in out angle);
        moveTo(x, y);

        // Try to find the best match
        var ax = x, ay = y;
        var best = 0, dx = 0, dy = 0;

    SearchLoop:
        for var searches in 0 ... 5 do
            ax += dx;
            ay += dy;
            best = 0;

            for var xx in 1, 1, -1, -1; var yy in 1, -1, 1, -1 do
                var count = 0;
                checkOre(ax, ay, @ore-titanium, in out count);
                checkOre(ax + xx, ay, @ore-titanium, in out count);
                checkOre(ax, ay + yy, @ore-titanium, in out count);
                checkOre(ax + xx, ay + yy, @ore-titanium, in out count);

                if count > best then
                    dx = xx;
                    dy = yy;
                    best = count;
                    if count >= 4 then break SearchLoop; end;
                end;
            end;
//            println("Search ", searches + 1);
//            println($"ax: $ax, ay: $ay");
//            println($"dx: $dy, dy: $dy");
//            printflush(message1);
        end;

        if best > minimum then
            ax = ax + dx / 2;
            ay = ay + dy / 2;

//            println($"Ore found at $x, $y");
//            println($"Best displacement $dx, $dy");
//            println($"Trying to build at $ax, $ay");
//            printflush(message1);
//            do while !switch1.enabled;
//            switch1.enabled = false;

            if abs(x - coreX) >= 10 or abs(y - coreY) >= 10 then
                var result = buildBlockAt(@pneumatic-drill, ax, ay, null, 0, true);
                if result != null then return result; end;

                // Try to patch the original spot to disable it
                build(x, y, @conveyor, 0, null);
            else
                // Force mote to the next location and start over
                attempts = 1000;
                minimum = 3;
            end;
        end;

        // No luck. Go elsewhere
        if ++attempts > 5 then
            moveToNextLocation(ref distance, ref angle);
            attempts = 0;
            minimum = max(minimum - 1, 1);
        end;
    end;
end;

def buildTitaniumDrill()
    buildTitaniumDrillCfg(ref PNEU_DRILL);
end;

// Building units

noinline def buildUnit(type, lead, silicon, in out count)
    meetTarget(type, 0, 0, 0, 0, 0, 0, lead, silicon);

    processor.unitToProduce = type;
    do
        supplyBase();
    while processor.unitToProduce != null;

    do
        ubind(type);
    while @unit.@flag != null;

    flag(++count);

    moveTo(coreX + 10 * count, coreY);

    var result = @unit;
    ubind(mainUnit);
    return result;
end;

def buildMono()
    buildUnit(@mono, 15, 30, in out monos);
end;

def buildFlare()
    buildUnit(@flare, 0, 15, in out flares);
end;

// MAIN

void findUnits(type, out count)
    count = 0;
    var firstUnit = ubind(type);
    if firstUnit != null then
        do
            flag(++count);
            ubind(type);
        while @unit != firstUnit;
    end;
end;

begin
    do
        ubind(@poly);
        core = ulocate(:building, :core, false, out coreX, out coreY);
    while core == null;
    mainUnit = @unit;

    // Error - unrecognized remote processor
    //verifySignature(display);
    display = processor1;

    // Bind and flag units
    findUnits(@mono, out monos);
    findUnits(@flare, out flares);
    findUnits(@poly, out polys);

    // Basic blocks: copper and lead
    press = buildBlockFromCfg(ref PRESS);
    battery = buildBlockFromCfg(ref BATTERY1);
    buildBlockFromCfg(ref BATTERY2);
    generator = buildBlockFromCfg(ref GENERATOR);

    powerTarget = 400;

    smelter = buildBlockFromCfg(ref SMELTER);

    titanium_drill = buildTitaniumDrill();

    unloader1 = buildBlockFromCfg(ref UNLOADER1);

    processor = buildBlockFromCfg(ref PROCESSOR);

    processor.core = core;
    processor.battery = battery;
    processor.generator = generator;
    processor.smelter = smelter;
    processor.press = press;

    buildBlockFromCfg(ref POWER_NODE);
    factory = buildBlockFromCfg(ref AIR_FACTORY);
    processor.factory = factory;

    unloader2 = buildBlockFromCfg(ref UNLOADER2);
    processor.unloader2 = unloader2;
    buildBlockFromCfg(ref OVERFLOW_GATE);

    buildFlare();
    buildMono();

    buildBlockFromCfg(ref UNLOADER3);
    buildBlockFromCfg(ref KILN);
    processor.kiln = kiln;

    buildBlockFromCfg(ref JUNCTION);
    buildBlockFromCfg(ref WATER_EXT);
    generator2 = buildBlockFromCfg(ref STEAM_GEN);
    processor.generator2 = generator2;
    buildBlockFromCfg(ref SORTER);

    while true do
        supplyBase();
    end;

    stop();
    error("Done");
end;
