   112 instructions before optimizations.
     7 instructions eliminated by Temp Variables Elimination (2 iterations).
    10 instructions eliminated by Dead Code Elimination (5 iterations).
C:\Home\golem\jam-202507\BlockBuilder.mnd:12:11 Variable 'coreX' is not used.
C:\Home\golem\jam-202507\BlockBuilder.mnd:12:18 Variable 'coreY' is not used.
C:\Home\golem\jam-202507\BlockBuilder.mnd:17:21 Variable 'ERROR' is not used.
C:\Home\golem\jam-202507\BlockBuilder.mnd:17:28 Variable 'ERROR_BLOCK_NEW' is not used.
C:\Home\golem\jam-202507\BlockBuilder.mnd:17:45 Variable 'ERROR_BLOCK_OLD' is not used.
C:\Home\golem\jam-202507\BlockBuilder.mnd:17:62 Variable 'ERROR_X' is not used.
C:\Home\golem\jam-202507\BlockBuilder.mnd:17:71 Variable 'ERROR_Y' is not used.
     6 instructions eliminated by Jump Optimization (5 iterations).
     5 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Expression Optimization (3 iterations).
    19 instructions eliminated by Data Flow Optimization (7 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     1 loops improved by Loop Optimization.
     2 instructions eliminated by Unreachable Code Elimination (2 iterations).
    63 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 935):
  * Replicate loop condition at line 30:5                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-8 instructions):
 
    42 jump *label14 equal *tmp14 false
    43 set :buildBlockAt*retval :buildBlockAt:building
    44 jump *label6 always
-    * set *tmp15 null
    45 jump *label15 always
    46 label *label14
-    * set *tmp15 null
    47 label *label15
    48 set :buildError:new :buildBlockAt:block
    49 set :buildError:old :buildBlockAt:type
 
    56 set .ERROR_Y :buildError:y
    57 stop
    58 label *label16
-    * set *tmp13 null
    59 jump *label13 always
    60 label *label12
-    * set *tmp13 null
    61 label *label13
    62 sensor *tmp16 .core @coal
    63 set :buildBlockAt:coal *tmp16
 
    84 set .ERROR_Y :buildError.1:y
    85 stop
    86 label *label22
-    * set *tmp23 null
    87 jump *label21 always
    88 label *label20
    89 set :buildBlockAt:success true
-    * set *tmp23 :buildBlockAt:success
    90 label *label21
    91 jump *label23 equal :buildBlockAt:fullBuildSupport false
    92 control enabled processor1 false
 
   100 label *label25
   101 set *tmp27 null
   102 label *label26
-    * set *tmp24 *tmp27
   103 jump *label24 always
   104 label *label23
-    * set *tmp24 null
   105 label *label24
   106 label *label18
   107 op notEqual *tmp28 :buildBlockAt:type :buildBlockAt:block

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
    95 jump *label25 equal *tmp26 false
    96 ucontrol approach :buildBlockAt:x :buildBlockAt:y 6
    97 ucontrol build :buildBlockAt:x :buildBlockAt:y :buildBlockAt:block :buildBlockAt:rotation :buildBlockAt:config
-    * set *tmp27 null
    98 jump *label26 always
    99 label *label25
-    * set *tmp27 null
   100 label *label26
   101 jump *label24 always
   102 label *label23

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-7 instructions):
 
     2 label *label1
     3 label *label2
     4 ubind @poly
-    * set *tmp1 @unit
-    * set .builder *tmp1
-    * ulocate building core false @copper .coreX .coreY *tmp3 *tmp2
-    * set .core *tmp2
+    5 set .builder @unit
+    6 ulocate building core false @copper .coreX .coreY 0 .core
     7 label *label3
     8 op equal *tmp4 .core null
     9 jump *label2 notEqual *tmp4 false
 
    32 label *label11
    33 label *label8
    34 label *label7
-    * ucontrol getBlock :buildBlockAt:x :buildBlockAt:y :buildBlockAt:type *tmp10 *tmp11
-    * set :buildBlockAt:building *tmp10
+   35 ucontrol getBlock :buildBlockAt:x :buildBlockAt:y :buildBlockAt:type :buildBlockAt:building 0
    36 op notEqual *tmp12 :buildBlockAt:building null
    37 jump *label12 equal *tmp12 false
    38 op equal *tmp14 :buildBlockAt:type :buildBlockAt:block
 
    56 jump *label13 always
    57 label *label12
    58 label *label13
-    * sensor *tmp16 .core @coal
-    * set :buildBlockAt:coal *tmp16
-    * op greaterThan *tmp17 :buildBlockAt:coal 200
-    * set :buildBlockAt:fullBuildSupport *tmp17
+   59 sensor :buildBlockAt:coal .core @coal
+   60 op greaterThan :buildBlockAt:fullBuildSupport :buildBlockAt:coal 200
    61 ucontrol build :buildBlockAt:x :buildBlockAt:y :buildBlockAt:block :buildBlockAt:rotation :buildBlockAt:config
    62 wait 0.25
    63 set :buildBlockAt:success false
    64 label *label17
-    * ucontrol getBlock :buildBlockAt:x :buildBlockAt:y :buildBlockAt:type *tmp18 *tmp19
-    * set :buildBlockAt:building *tmp18
+   65 ucontrol getBlock :buildBlockAt:x :buildBlockAt:y :buildBlockAt:type :buildBlockAt:building 0
    66 op equal *tmp20 :buildBlockAt:building null
    67 op equal *tmp21 :buildBlockAt:success false
    68 op land *tmp22 *tmp20 *tmp21
 
   102 control enabled processor1 true
   103 ubind .builder
   104 set :logBlock:block :buildBlockAt:block
-    * sensor *tmp30 :logBlock:block @id
-    * set :log:encodedId *tmp30
+  105 sensor :log:encodedId :logBlock:block @id
   106 read *tmp0 bank1 511
   107 op sub *tmp31 *tmp0 1
   108 write *tmp31 bank1 511

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-6 instructions):
 
     5 set .builder @unit
     6 ulocate building core false @copper .coreX .coreY 0 .core
     7 label *label3
-    * op equal *tmp4 .core null
-    * jump *label2 notEqual *tmp4 false
+    8 jump *label2 equal .core null
     9 label *label4
    10 set *signature "e4bd0450ec228cd3:v1"
    11 label *label5
 
    22 set :moveTo.1:radius 6
    23 label *label9
    24 ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp7
-    * op equal *tmp8 *tmp7 false
-    * jump *label11 equal *tmp8 false
+   25 jump *label11 notEqual *tmp7 false
    26 op sub *tmp9 :moveTo.1:radius 0.5
    27 ucontrol approach :moveTo.1:x :moveTo.1:y *tmp9
    28 label *label10
 
    31 label *label8
    32 label *label7
    33 ucontrol getBlock :buildBlockAt:x :buildBlockAt:y :buildBlockAt:type :buildBlockAt:building 0
-    * op notEqual *tmp12 :buildBlockAt:building null
-    * jump *label12 equal *tmp12 false
-    * op equal *tmp14 :buildBlockAt:type :buildBlockAt:block
-    * jump *label14 equal *tmp14 false
+   34 jump *label12 equal :buildBlockAt:building null
+   35 jump *label14 notEqual :buildBlockAt:type :buildBlockAt:block
    36 set :buildBlockAt*retval :buildBlockAt:building
    37 jump *label6 always
    38 jump *label15 always
 
    81 jump *label23 equal :buildBlockAt:fullBuildSupport false
    82 control enabled processor1 false
    83 ubind @poly
-    * op notEqual *tmp26 @unit .builder
-    * jump *label25 equal *tmp26 false
+   84 jump *label25 equal @unit .builder
    85 ucontrol approach :buildBlockAt:x :buildBlockAt:y 6
    86 ucontrol build :buildBlockAt:x :buildBlockAt:y :buildBlockAt:block :buildBlockAt:rotation :buildBlockAt:config
    87 jump *label26 always
 
    91 label *label23
    92 label *label24
    93 label *label18
-    * op notEqual *tmp28 :buildBlockAt:type :buildBlockAt:block
-    * jump *label17 notEqual *tmp28 false
+   94 jump *label17 notEqual :buildBlockAt:type :buildBlockAt:block
    95 label *label19
    96 control enabled processor1 true
    97 ubind .builder

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    35 jump *label14 notEqual :buildBlockAt:type :buildBlockAt:block
    36 set :buildBlockAt*retval :buildBlockAt:building
    37 jump *label6 always
-    * jump *label15 always
    38 label *label14
    39 label *label15
    40 set :buildError:new :buildBlockAt:block
 
    48 set .ERROR_Y :buildError:y
    49 stop
    50 label *label16
-    * jump *label13 always
    51 label *label12
    52 label *label13
    53 sensor :buildBlockAt:coal .core @coal
 
    82 jump *label25 equal @unit .builder
    83 ucontrol approach :buildBlockAt:x :buildBlockAt:y 6
    84 ucontrol build :buildBlockAt:x :buildBlockAt:y :buildBlockAt:block :buildBlockAt:rotation :buildBlockAt:config
-    * jump *label26 always
    85 label *label25
    86 label *label26
-    * jump *label24 always
    87 label *label23
    88 label *label24
    89 label *label18

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    97 op sub *tmp31 *tmp0 1
    98 write *tmp31 bank1 511
    99 set *tmp32 *tmp31
-    * op mul *tmp34 @second 1000
-    * op floor *tmp35 *tmp34
+  100 op idiv *tmp35 @second 0.001
   101 op mul *tmp36 *tmp35 1000
   102 op add *tmp37 :log:encodedId *tmp36
   103 write *tmp37 bank1 *tmp32

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    15 label *label0
    16 set :moveTo:x :buildBlockAt:x
    17 set :moveTo:y :buildBlockAt:y
-    * set *tmp5 :moveTo:x
-    * set *tmp6 :moveTo:y
-    * set :moveTo.1:x *tmp5
-    * set :moveTo.1:y *tmp6
+   18 set *tmp5 :buildBlockAt:x
+   19 set *tmp6 :buildBlockAt:y
+   20 set :moveTo.1:x :moveTo:x
+   21 set :moveTo.1:y :moveTo:y
    22 set :moveTo.1:radius 6
    23 label *label9
-    * ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp7
+   24 ucontrol within *tmp5 *tmp6 6 *tmp7
    25 jump *label11 notEqual *tmp7 false
-    * op sub *tmp9 :moveTo.1:radius 0.5
-    * ucontrol approach :moveTo.1:x :moveTo.1:y *tmp9
+   26 op sub *tmp9 6 0.5
+   27 ucontrol approach *tmp5 *tmp6 5.5
    28 label *label10
    29 jump *label9 always
    30 label *label11
 
    42 set :buildError:x :buildBlockAt:x
    43 set :buildError:y :buildBlockAt:y
    44 set .ERROR "Cannot build at position"
-    * set .ERROR_BLOCK_NEW :buildError:new
-    * set .ERROR_BLOCK_OLD :buildError:old
-    * set .ERROR_X :buildError:x
-    * set .ERROR_Y :buildError:y
+   45 set .ERROR_BLOCK_NEW :buildBlockAt:block
+   46 set .ERROR_BLOCK_OLD :buildBlockAt:type
+   47 set .ERROR_X :buildBlockAt:x
+   48 set .ERROR_Y :buildBlockAt:y
    49 stop
    50 label *label16
    51 label *label12
 
    66 set :buildError.1:x :buildBlockAt:x
    67 set :buildError.1:y :buildBlockAt:y
    68 set .ERROR "Cannot build at position"
-    * set .ERROR_BLOCK_NEW :buildError.1:new
-    * set .ERROR_BLOCK_OLD :buildError.1:old
-    * set .ERROR_X :buildError.1:x
-    * set .ERROR_Y :buildError.1:y
+   69 set .ERROR_BLOCK_NEW :buildBlockAt:block
+   70 set .ERROR_BLOCK_OLD "unknown"
+   71 set .ERROR_X :buildBlockAt:x
+   72 set .ERROR_Y :buildBlockAt:y
    73 stop
    74 label *label22
    75 jump *label21 always
 
    92 control enabled processor1 true
    93 ubind .builder
    94 set :logBlock:block :buildBlockAt:block
-    * sensor :log:encodedId :logBlock:block @id
+   95 sensor :log:encodedId :buildBlockAt:block @id
    96 read *tmp0 bank1 511
    97 op sub *tmp31 *tmp0 1
    98 write *tmp31 bank1 511
 
   100 op idiv *tmp35 @second 0.001
   101 op mul *tmp36 *tmp35 1000
   102 op add *tmp37 :log:encodedId *tmp36
-    * write *tmp37 bank1 *tmp32
+  103 write *tmp37 bank1 *tmp31
   104 label *label28
   105 label *label27
   106 set :buildBlockAt*retval :buildBlockAt:building
   107 jump *label6 always
-    * set :buildBlockAt*retval null
   108 label *label6
   109 set :buildBlockAt*finished true
   110 jump *label5 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-12 instructions):
 
    17 set :moveTo:y :buildBlockAt:y
    18 set *tmp5 :buildBlockAt:x
    19 set *tmp6 :buildBlockAt:y
-    * set :moveTo.1:x :moveTo:x
-    * set :moveTo.1:y :moveTo:y
-    * set :moveTo.1:radius 6
+   20 set :moveTo.1:x :buildBlockAt:x
+   21 set :moveTo.1:y :buildBlockAt:y
    22 label *label9
-    * ucontrol within *tmp5 *tmp6 6 *tmp7
+   23 ucontrol within :buildBlockAt:x :buildBlockAt:y 6 *tmp7
    24 jump *label11 notEqual *tmp7 false
-    * op sub *tmp9 6 0.5
-    * ucontrol approach *tmp5 *tmp6 5.5
+   25 ucontrol approach :buildBlockAt:x :buildBlockAt:y 5.5
    26 label *label10
    27 jump *label9 always
    28 label *label11
 
    35 jump *label6 always
    36 label *label14
    37 label *label15
-    * set :buildError:new :buildBlockAt:block
-    * set :buildError:old :buildBlockAt:type
-    * set :buildError:x :buildBlockAt:x
-    * set :buildError:y :buildBlockAt:y
    38 set .ERROR "Cannot build at position"
    39 set .ERROR_BLOCK_NEW :buildBlockAt:block
    40 set .ERROR_BLOCK_OLD :buildBlockAt:type
 
    55 op equal *tmp21 :buildBlockAt:success false
    56 op land *tmp22 *tmp20 *tmp21
    57 jump *label20 equal *tmp22 false
-    * set :buildError.1:new :buildBlockAt:block
-    * set :buildError.1:old "unknown"
-    * set :buildError.1:x :buildBlockAt:x
-    * set :buildError.1:y :buildBlockAt:y
    58 set .ERROR "Cannot build at position"
    59 set .ERROR_BLOCK_NEW :buildBlockAt:block
    60 set .ERROR_BLOCK_OLD "unknown"
 
    81 label *label19
    82 control enabled processor1 true
    83 ubind .builder
-    * set :logBlock:block :buildBlockAt:block
    84 sensor :log:encodedId :buildBlockAt:block @id
    85 read *tmp0 bank1 511
    86 op sub *tmp31 *tmp0 1
    87 write *tmp31 bank1 511
-    * set *tmp32 *tmp31
    88 op idiv *tmp35 @second 0.001
    89 op mul *tmp36 *tmp35 1000
    90 op add *tmp37 :log:encodedId *tmp36

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-6 instructions):
 
    13 jump *label5 always
    14 end
    15 label *label0
-    * set :moveTo:x :buildBlockAt:x
-    * set :moveTo:y :buildBlockAt:y
-    * set *tmp5 :buildBlockAt:x
-    * set *tmp6 :buildBlockAt:y
-    * set :moveTo.1:x :buildBlockAt:x
-    * set :moveTo.1:y :buildBlockAt:y
    16 label *label9
    17 ucontrol within :buildBlockAt:x :buildBlockAt:y 6 *tmp7
    18 jump *label11 notEqual *tmp7 false

Modifications by Replicate loop condition at line 30:5 (+1 instructions):
 
    16 label *label9
    17 ucontrol within :buildBlockAt:x :buildBlockAt:y 6 *tmp7
    18 jump *label11 notEqual *tmp7 false
+   19 label *label29
    20 ucontrol approach :buildBlockAt:x :buildBlockAt:y 5.5
    21 label *label10
-    * jump *label9 always
+   22 ucontrol within :buildBlockAt:x :buildBlockAt:y 6 *tmp7
+   23 jump *label29 equal *tmp7 false
    24 label *label11
    25 label *label8
    26 label *label7

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    88 label *label28
    89 label *label27
    90 set :buildBlockAt*retval :buildBlockAt:building
-    * jump *label6 always
    91 label *label6
    92 set :buildBlockAt*finished true
    93 jump *label5 always

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     4 ubind @poly
     5 set .builder @unit
     6 ulocate building core false @copper .coreX .coreY 0 .core
-    * label *label3
     7 jump *label2 equal .core null
-    * label *label4
     8 set *signature "e4bd0450ec228cd3:v1"
     9 label *label5
    10 wait 1e12
    11 jump *label5 always
    12 end
    13 label *label0
-    * label *label9
    14 ucontrol within :buildBlockAt:x :buildBlockAt:y 6 *tmp7
    15 jump *label11 notEqual *tmp7 false
    16 label *label29
    17 ucontrol approach :buildBlockAt:x :buildBlockAt:y 5.5
-    * label *label10
    18 ucontrol within :buildBlockAt:x :buildBlockAt:y 6 *tmp7
    19 jump *label29 equal *tmp7 false
    20 label *label11
-    * label *label8
-    * label *label7
    21 ucontrol getBlock :buildBlockAt:x :buildBlockAt:y :buildBlockAt:type :buildBlockAt:building 0
    22 jump *label12 equal :buildBlockAt:building null
    23 jump *label14 notEqual :buildBlockAt:type :buildBlockAt:block
    24 set :buildBlockAt*retval :buildBlockAt:building
    25 jump *label6 always
    26 label *label14
-    * label *label15
    27 set .ERROR "Cannot build at position"
    28 set .ERROR_BLOCK_NEW :buildBlockAt:block
    29 set .ERROR_BLOCK_OLD :buildBlockAt:type
    30 set .ERROR_X :buildBlockAt:x
    31 set .ERROR_Y :buildBlockAt:y
    32 stop
-    * label *label16
    33 label *label12
-    * label *label13
    34 sensor :buildBlockAt:coal .core @coal
    35 op greaterThan :buildBlockAt:fullBuildSupport :buildBlockAt:coal 200
    36 ucontrol build :buildBlockAt:x :buildBlockAt:y :buildBlockAt:block :buildBlockAt:rotation :buildBlockAt:config
 
    48 set .ERROR_X :buildBlockAt:x
    49 set .ERROR_Y :buildBlockAt:y
    50 stop
-    * label *label22
    51 jump *label21 always
    52 label *label20
    53 set :buildBlockAt:success true
 
    59 ucontrol approach :buildBlockAt:x :buildBlockAt:y 6
    60 ucontrol build :buildBlockAt:x :buildBlockAt:y :buildBlockAt:block :buildBlockAt:rotation :buildBlockAt:config
    61 label *label25
-    * label *label26
    62 label *label23
-    * label *label24
-    * label *label18
    63 jump *label17 notEqual :buildBlockAt:type :buildBlockAt:block
-    * label *label19
    64 control enabled processor1 true
    65 ubind .builder
    66 sensor :log:encodedId :buildBlockAt:block @id
 
    71 op mul *tmp36 *tmp35 1000
    72 op add *tmp37 :log:encodedId *tmp36
    73 write *tmp37 bank1 *tmp31
-    * label *label28
-    * label *label27
    74 set :buildBlockAt*retval :buildBlockAt:building
    75 label *label6
    76 set :buildBlockAt*finished true

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-2 instructions):
 
     9 label *label5
    10 wait 1e12
    11 jump *label5 always
-    * end
    12 label *label0
    13 ucontrol within :buildBlockAt:x :buildBlockAt:y 6 *tmp7
    14 jump *label11 notEqual *tmp7 false
 
    74 label *label6
    75 set :buildBlockAt*finished true
    76 jump *label5 always
-    * end

Final code before resolving virtual instructions:

    0:  jump *label1 always 0 0                                      #set target = 8;
    1:  jump *label0 always 0 0                                      ...
    2:  draw triangle bank1 processor1 .ERROR .ERROR_BLOCK_NEW .ERROR_BLOCK_OLD .ERROR_X
    3:  draw triangle .ERROR_Y .builder .core .coreX .coreY :buildBlockAt:block
    4:  draw triangle :buildBlockAt:building :buildBlockAt:coal :buildBlockAt:config :buildBlockAt:fullBuildSupport :buildBlockAt:rotation :buildBlockAt:success
    5:  draw triangle :buildBlockAt:type :buildBlockAt:x :buildBlockAt:y :log:encodedId 0 0
        label *label1                                                ...
        label *label2                                                do
    6:  ubind @poly                                                  builder = ubind(@poly);
    7:  set .builder @unit                                           ...
    8:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
    9:  jump *label2 equal .core null                                do
   10:  set *signature "e4bd0450ec228cd3:v1"                         #set target = 8;
        label *label5                                                ...
   11:  wait 1e12                                                    ...
   12:  jump *label5 always 0 0                                      ...
        label *label0                                                remote def buildBlockAt(block, x, y, rotation, config)
   13:  ucontrol within :buildBlockAt:x :buildBlockAt:y 6 *tmp7 0    while !within(x, y, radius) do
   14:  jump *label11 notEqual *tmp7 false                           ...
        label *label29                                               ...
   15:  ucontrol approach :buildBlockAt:x :buildBlockAt:y 5.5 0 0    approach(x, y, radius - 0.5);
   16:  ucontrol within :buildBlockAt:x :buildBlockAt:y 6 *tmp7 0    while !within(x, y, radius) do
   17:  jump *label29 equal *tmp7 false                              ...
        label *label11                                               ...
   18:  ucontrol getBlock :buildBlockAt:x :buildBlockAt:y :buildBloc var building = getBlock(x, y, out type);
   19:  jump *label12 equal :buildBlockAt:building null              if building != null then
   20:  jump *label14 notEqual :buildBlockAt:type :buildBlockAt:bloc if type == block then return building; end;
   21:  set :buildBlockAt*retval :buildBlockAt:building              ...
   22:  jump *label6 always 0 0                                      ...
        label *label14                                               ...
   23:  set .ERROR "Cannot build at position"                        ERROR = "Cannot build at position";
   24:  set .ERROR_BLOCK_NEW :buildBlockAt:block                     ERROR_BLOCK_NEW = new;
   25:  set .ERROR_BLOCK_OLD :buildBlockAt:type                      ERROR_BLOCK_OLD = old;
   26:  set .ERROR_X :buildBlockAt:x                                 ERROR_X = x;
   27:  set .ERROR_Y :buildBlockAt:y                                 ERROR_Y = y;
   28:  stop                                                         stopProcessor();
        label *label12                                               if building != null then
   29:  sensor :buildBlockAt:coal .core @coal                        var coal = core.@coal;
   30:  op greaterThan :buildBlockAt:fullBuildSupport :buildBlockAt: var fullBuildSupport = coal > 200;
   31:  ucontrol build :buildBlockAt:x :buildBlockAt:y :buildBlockAt build(x, y, block, rotation, config);
   32:  wait 0.25                                                    wait(0.25);
   33:  set :buildBlockAt:success false                              var success = false;
        label *label17                                               do
   34:  ucontrol getBlock :buildBlockAt:x :buildBlockAt:y :buildBloc building = getBlock(x, y, out type);
   35:  op equal *tmp20 :buildBlockAt:building null                  if building == null and !success then
   36:  op equal *tmp21 :buildBlockAt:success false                  ...
   37:  op land *tmp22 *tmp20 *tmp21                                 ...
   38:  jump *label20 equal *tmp22 false                             ...
   39:  set .ERROR "Cannot build at position"                        ERROR = "Cannot build at position";
   40:  set .ERROR_BLOCK_NEW :buildBlockAt:block                     ERROR_BLOCK_NEW = new;
   41:  set .ERROR_BLOCK_OLD "unknown"                               ERROR_BLOCK_OLD = old;
   42:  set .ERROR_X :buildBlockAt:x                                 ERROR_X = x;
   43:  set .ERROR_Y :buildBlockAt:y                                 ERROR_Y = y;
   44:  stop                                                         stopProcessor();
   45:  jump *label21 always 0 0                                     if building == null and !success then
        label *label20                                               ...
   46:  set :buildBlockAt:success true                               success = true;
        label *label21                                               if building == null and !success then
   47:  jump *label23 equal :buildBlockAt:fullBuildSupport false     if fullBuildSupport then
   48:  control enabled processor1 false 0 0 0                       polyController.enabled = false;     // Brutal, but effective :)
   49:  ubind @poly                                                  ubind(@poly);
   50:  jump *label25 equal @unit .builder                           if @unit != builder then
   51:  ucontrol approach :buildBlockAt:x :buildBlockAt:y 6 0 0      approach(x, y, RADIUS);
   52:  ucontrol build :buildBlockAt:x :buildBlockAt:y :buildBlockAt build(x, y, block, rotation, config);
        label *label25                                               if @unit != builder then
        label *label23                                               if fullBuildSupport then
   53:  jump *label17 notEqual :buildBlockAt:type :buildBlockAt:bloc do
   54:  control enabled processor1 true 0 0 0                        polyController.enabled = true;
   55:  ubind .builder                                               ubind(builder);
   56:  sensor :log:encodedId :buildBlockAt:block @id                log(block.@id);
   57:  read *tmp0 bank1 511                                         bank1[--logPosition] = encodedId + floor(@second * 1000) * 1000;
   58:  op sub *tmp31 *tmp0 1                                        ...
   59:  write *tmp31 bank1 511                                       ...
   60:  op idiv *tmp35 @second 0.001                                 ...
   61:  op mul *tmp36 *tmp35 1000                                    ...
   62:  op add *tmp37 :log:encodedId *tmp36                          ...
   63:  write *tmp37 bank1 *tmp31                                    ...
   64:  set :buildBlockAt*retval :buildBlockAt:building              return building;
        label *label6                                                remote def buildBlockAt(block, x, y, rotation, config)
   65:  set :buildBlockAt*finished true                              ...
   66:  jump *label5 always 0 0                                      ...


Performance: parsed in 197 ms, compiled in 236 ms, optimized in 176 ms, run in 2 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (2 steps):
The program didn't generate any output.
Execution exception at instruction 6: ubind @poly:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
