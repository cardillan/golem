   188 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (2 iterations).
    21 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (7 iterations).
    12 instructions eliminated by Jump Optimization (7 iterations).
    18 instructions eliminated by Single Step Elimination (3 passes, 10 iterations).
     1 instructions modified by Expression Optimization (5 iterations).
     5 instructions eliminated by Data Flow Optimization (2 passes, 10 iterations).
   340 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
     1 jump tables inlined by Array Optimization.
    20 instructions eliminated by Jump Straightening (7 iterations).
    14 instructions eliminated by Unreachable Code Elimination (2 iterations).
   428 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 864):
    Unroll iteration loop at line 65:9                           size  +341, benefit     1475.0, efficiency      4.326
  * Inline write jump table of array 'titaniumDrills'            size    -4, benefit        1.0, efficiency   Infinity (-4 instructions)
    Inline 'titaniumDrills' write access at line 31:9            size   +17, benefit        1.0, efficiency      0.059

Pass 1: speed optimization selection (cost limit 868):
  * Unroll iteration loop at line 65:9                           size  +341, benefit     1475.0, efficiency      4.326 (+340 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-14 instructions):
 
    18 set .coreX *tmp6
    19 sensor *tmp7 .core @y
    20 set .coreY *tmp7
-    * set *tmp2 *tmp7
    21 jump *label10 always
    22 label *label9
-    * set *tmp2 null
    23 label *label10
    24 label *label14
    25 jump *label16 equal true false
 
    85 op equal *tmp9 :backgroundProcess:drill null
    86 jump *label30 equal *tmp9 false
    87 jump *label19 always
-    * set *tmp10 null
    88 jump *label31 always
    89 label *label30
-    * set *tmp10 null
    90 label *label31
    91 sensor *tmp11 :backgroundProcess:drill @titanium
    92 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   101 jump *label35 equal *tmp16 false
   102 set *tmp15 null
   103 jump *label34 always
-    * set *tmp17 null
   104 jump *label36 always
   105 label *label35
-    * set *tmp17 null
   106 label *label36
   107 set :findFreeUnit:first_unit @unit
   108 label *label37
 
   112 ucontrol flag :findFreeUnit:initial_flag
   113 set *tmp15 @unit
   114 jump *label34 always
-    * set *tmp20 null
   115 jump *label41 always
   116 label *label40
   117 sensor *tmp21 :findFreeUnit:first_unit @dead
 
   124 label *label42
   125 set *tmp23 null
   126 label *label43
-    * set *tmp20 *tmp23
   127 label *label41
   128 ubind :findFreeUnit:unit_type
   129 label *label38
 
   143 label *label44
   144 set *tmp27 null
   145 label *label45
-    * set *tmp14 *tmp27
   146 jump *label33 always
   147 label *label32
-    * set *tmp14 null
   148 label *label33
   149 # "Function: void serviceDrill(in drill, in unit)"
   150 set :serviceDrill:drill :backgroundProcess:drill
 
   156 jump *label47 equal *tmp29 false
   157 ucontrol approach .coreX .coreY 4
   158 ucontrol itemDrop .core 10
-    * set *tmp30 null
   159 jump *label48 always
   160 label *label47
   161 op equal *tmp31 :serviceDrill:item null
 
   170 ucontrol itemDrop @air 10
   171 set *tmp32 null
   172 label *label50
-    * set *tmp30 *tmp32
   173 label *label48
   174 label *label46
   175 label *label18
 
   193 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp37
   194 set *tmp39 .drills
   195 op add .drills .drills 1
-    * set *tmp36 *tmp39
   196 jump *label53 always
   197 label *label52
-    * set *tmp36 null
   198 label *label53
   199 label *label51
   200 set :addTitaniumDrill*finished true

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-7 instructions):
 
   119 jump *label42 equal *tmp22 false
   120 set *tmp24 @unit
   121 set :findFreeUnit:first_unit *tmp24
-    * set *tmp23 :findFreeUnit:first_unit
   122 jump *label43 always
   123 label *label42
-    * set *tmp23 null
   124 label *label43
   125 label *label41
   126 ubind :findFreeUnit:unit_type
 
   136 op equal *tmp26 :backgroundProcess:unit null
   137 jump *label44 equal *tmp26 false
   138 jump *label18 always
-    * set *tmp27 null
   139 jump *label45 always
   140 label *label44
-    * set *tmp27 null
   141 label *label45
   142 jump *label33 always
   143 label *label32
 
   160 sensor *tmp34 :serviceDrill:drill @y
   161 ucontrol approach *tmp33 *tmp34 4
   162 ucontrol itemTake :serviceDrill:drill @titanium 10
-    * set *tmp32 null
   163 jump *label50 always
   164 label *label49
   165 ucontrol itemDrop @air 10
-    * set *tmp32 null
   166 label *label50
   167 label *label48
   168 label *label46
 
   185 jump *label52 equal *tmp35 false
   186 set *tmp37 .drills
   187 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp37
-    * set *tmp39 .drills
   188 op add .drills .drills 1
   189 jump *label53 always
   190 label *label52

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
     8 jump *label9 equal *tmp1 false
     9 label *label11
    10 ubind @flare
-    * ulocate building core false @copper .coreX .coreY *tmp4 *tmp3
-    * set .core *tmp3
+   11 ulocate building core false @copper .coreX .coreY 0 .core
    12 label *label12
    13 op equal *tmp5 .core null
    14 jump *label11 notEqual *tmp5 false
    15 label *label13
-    * sensor *tmp6 .core @x
-    * set .coreX *tmp6
-    * sensor *tmp7 .core @y
-    * set .coreY *tmp7
+   16 sensor .coreX .core @x
+   17 sensor .coreY .core @y
    18 jump *label10 always
    19 label *label9
    20 label *label10
 
   114 sensor *tmp21 :findFreeUnit:first_unit @dead
   115 op equal *tmp22 *tmp21 1
   116 jump *label42 equal *tmp22 false
-    * set *tmp24 @unit
-    * set :findFreeUnit:first_unit *tmp24
+  117 set :findFreeUnit:first_unit @unit
   118 jump *label43 always
   119 label *label42
   120 label *label43
 
   142 set :serviceDrill:drill :backgroundProcess:drill
   143 set :serviceDrill:unit :backgroundProcess:unit
   144 ubind :serviceDrill:unit
-    * sensor *tmp28 @unit @firstItem
-    * set :serviceDrill:item *tmp28
+  145 sensor :serviceDrill:item @unit @firstItem
   146 op equal *tmp29 :serviceDrill:item @titanium
   147 jump *label47 equal *tmp29 false
   148 ucontrol approach .coreX .coreY 4
 
   178 # "Function: remote void addTitaniumDrill(in drill)"
   179 op lessThan *tmp35 .drills 9
   180 jump *label52 equal *tmp35 false
-    * set *tmp37 .drills
-    * writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp37
+  181 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   182 op add .drills .drills 1
   183 jump *label53 always
   184 label *label52

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    19 label *label9
    20 label *label10
    21 label *label14
-    * jump *label16 equal true false
    22 set :backgroundProcess:count 0
    23 set :backgroundProcess:drill .titaniumDrills*0
    24 set :backgroundProcess:unit .units*0

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-12 instructions):
 
     4 set *signature "881dde114374c003:v1"
     5 label *label7
     6 # "Function: void backgroundProcess()"
-    * op equal *tmp1 .core null
-    * jump *label9 equal *tmp1 false
+    7 jump *label9 notEqual .core null
     8 label *label11
     9 ubind @flare
    10 ulocate building core false @copper .coreX .coreY 0 .core
    11 label *label12
-    * op equal *tmp5 .core null
-    * jump *label11 notEqual *tmp5 false
+   12 jump *label11 equal .core null
    13 label *label13
    14 sensor .coreX .core @x
    15 sensor .coreY .core @y
 
    76 set :backgroundProcess:unit .units*9
    77 set *tmp8 null
    78 label *label17
-    * op equal *tmp9 :backgroundProcess:drill null
-    * jump *label30 equal *tmp9 false
+   79 jump *label30 notEqual :backgroundProcess:drill null
    80 jump *label19 always
    81 jump *label31 always
    82 label *label30
 
    84 sensor *tmp11 :backgroundProcess:drill @titanium
    85 op add :backgroundProcess:count :backgroundProcess:count *tmp11
    86 sensor *tmp12 :backgroundProcess:unit @controller
-    * op notEqual *tmp13 *tmp12 @this
-    * jump *label32 equal *tmp13 false
+   87 jump *label32 equal *tmp12 @this
    88 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    89 set :findFreeUnit:unit_type @flare
    90 set :findFreeUnit:initial_flag 0
    91 ubind :findFreeUnit:unit_type
-    * op equal *tmp16 @unit null
-    * jump *label35 equal *tmp16 false
+   92 jump *label35 notEqual @unit null
    93 set *tmp15 null
    94 jump *label34 always
    95 jump *label36 always
 
    98 set :findFreeUnit:first_unit @unit
    99 label *label37
   100 sensor *tmp18 @unit @controlled
-    * op equal *tmp19 *tmp18 0
-    * jump *label40 equal *tmp19 false
+  101 jump *label40 notEqual *tmp18 0
   102 ucontrol flag :findFreeUnit:initial_flag
   103 set *tmp15 @unit
   104 jump *label34 always
   105 jump *label41 always
   106 label *label40
   107 sensor *tmp21 :findFreeUnit:first_unit @dead
-    * op equal *tmp22 *tmp21 1
-    * jump *label42 equal *tmp22 false
+  108 jump *label42 notEqual *tmp21 1
   109 set :findFreeUnit:first_unit @unit
   110 jump *label43 always
   111 label *label42
 
   113 label *label41
   114 ubind :findFreeUnit:unit_type
   115 label *label38
-    * op notEqual *tmp25 :findFreeUnit:first_unit @unit
-    * jump *label37 notEqual *tmp25 false
+  116 jump *label37 notEqual :findFreeUnit:first_unit @unit
   117 label *label39
   118 set *tmp15 null
   119 jump *label34 always
   120 set *tmp15 null
   121 label *label34
   122 set :backgroundProcess:unit *tmp15
-    * op equal *tmp26 :backgroundProcess:unit null
-    * jump *label44 equal *tmp26 false
+  123 jump *label44 notEqual :backgroundProcess:unit null
   124 jump *label18 always
   125 jump *label45 always
   126 label *label44
 
   133 set :serviceDrill:unit :backgroundProcess:unit
   134 ubind :serviceDrill:unit
   135 sensor :serviceDrill:item @unit @firstItem
-    * op equal *tmp29 :serviceDrill:item @titanium
-    * jump *label47 equal *tmp29 false
+  136 jump *label47 notEqual :serviceDrill:item @titanium
   137 ucontrol approach .coreX .coreY 4
   138 ucontrol itemDrop .core 10
   139 jump *label48 always
   140 label *label47
-    * op equal *tmp31 :serviceDrill:item null
-    * jump *label49 equal *tmp31 false
+  141 jump *label49 notEqual :serviceDrill:item null
   142 sensor *tmp33 :serviceDrill:drill @x
   143 sensor *tmp34 :serviceDrill:drill @y
   144 ucontrol approach *tmp33 *tmp34 4
 
   164 end
   165 label *label0
   166 # "Function: remote void addTitaniumDrill(in drill)"
-    * op lessThan *tmp35 .drills 9
-    * jump *label52 equal *tmp35 false
+  167 jump *label52 greaterThanEq .drills 9
   168 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   169 op add .drills .drills 1
   170 jump *label53 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    13 label *label13
    14 sensor .coreX .core @x
    15 sensor .coreY .core @y
-    * jump *label10 always
    16 label *label9
    17 label *label10
    18 label *label14
 
    77 label *label17
    78 jump *label30 notEqual :backgroundProcess:drill null
    79 jump *label19 always
-    * jump *label31 always
    80 label *label30
    81 label *label31
    82 sensor *tmp11 :backgroundProcess:drill @titanium
 
    90 jump *label35 notEqual @unit null
    91 set *tmp15 null
    92 jump *label34 always
-    * jump *label36 always
    93 label *label35
    94 label *label36
    95 set :findFreeUnit:first_unit @unit
 
   104 sensor *tmp21 :findFreeUnit:first_unit @dead
   105 jump *label42 notEqual *tmp21 1
   106 set :findFreeUnit:first_unit @unit
-    * jump *label43 always
   107 label *label42
   108 label *label43
   109 label *label41
 
   118 set :backgroundProcess:unit *tmp15
   119 jump *label44 notEqual :backgroundProcess:unit null
   120 jump *label18 always
-    * jump *label45 always
   121 label *label44
   122 label *label45
-    * jump *label33 always
   123 label *label32
   124 label *label33
   125 # "Function: void serviceDrill(in drill, in unit)"
 
   161 jump *label52 greaterThanEq .drills 9
   162 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   163 op add .drills .drills 1
-    * jump *label53 always
   164 label *label52
   165 label *label53
   166 label *label51

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    86 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    87 set :findFreeUnit:unit_type @flare
    88 set :findFreeUnit:initial_flag 0
-    * ubind :findFreeUnit:unit_type
+   89 ubind @flare
    90 jump *label35 notEqual @unit null
    91 set *tmp15 null
    92 jump *label34 always
 
    96 label *label37
    97 sensor *tmp18 @unit @controlled
    98 jump *label40 notEqual *tmp18 0
-    * ucontrol flag :findFreeUnit:initial_flag
+   99 ucontrol flag 0
   100 set *tmp15 @unit
   101 jump *label34 always
   102 jump *label41 always
 
   107 label *label42
   108 label *label43
   109 label *label41
-    * ubind :findFreeUnit:unit_type
+  110 ubind @flare
   111 label *label38
   112 jump *label37 notEqual :findFreeUnit:first_unit @unit
   113 label *label39
   114 set *tmp15 null
   115 jump *label34 always
-    * set *tmp15 null
   116 label *label34
   117 set :backgroundProcess:unit *tmp15
-    * jump *label44 notEqual :backgroundProcess:unit null
+  118 jump *label44 notEqual *tmp15 null
   119 jump *label18 always
   120 label *label44
   121 label *label45
 
   124 # "Function: void serviceDrill(in drill, in unit)"
   125 set :serviceDrill:drill :backgroundProcess:drill
   126 set :serviceDrill:unit :backgroundProcess:unit
-    * ubind :serviceDrill:unit
+  127 ubind :backgroundProcess:unit
   128 sensor :serviceDrill:item @unit @firstItem
   129 jump *label47 notEqual :serviceDrill:item @titanium
   130 ucontrol approach .coreX .coreY 4
 
   132 jump *label48 always
   133 label *label47
   134 jump *label49 notEqual :serviceDrill:item null
-    * sensor *tmp33 :serviceDrill:drill @x
-    * sensor *tmp34 :serviceDrill:drill @y
+  135 sensor *tmp33 :backgroundProcess:drill @x
+  136 sensor *tmp34 :backgroundProcess:drill @y
   137 ucontrol approach *tmp33 *tmp34 4
-    * ucontrol itemTake :serviceDrill:drill @titanium 10
+  138 ucontrol itemTake :backgroundProcess:drill @titanium 10
   139 jump *label50 always
   140 label *label49
   141 ucontrol itemDrop @air 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    84 sensor *tmp12 :backgroundProcess:unit @controller
    85 jump *label32 equal *tmp12 @this
    86 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * set :findFreeUnit:unit_type @flare
-    * set :findFreeUnit:initial_flag 0
    87 ubind @flare
    88 jump *label35 notEqual @unit null
    89 set *tmp15 null
 
   120 label *label32
   121 label *label33
   122 # "Function: void serviceDrill(in drill, in unit)"
-    * set :serviceDrill:drill :backgroundProcess:drill
-    * set :serviceDrill:unit :backgroundProcess:unit
   123 ubind :backgroundProcess:unit
   124 sensor :serviceDrill:item @unit @firstItem
   125 jump *label47 notEqual :serviceDrill:item @titanium

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
 
   154 label *label0
   155 # "Function: remote void addTitaniumDrill(in drill)"
   156 jump *label52 greaterThanEq .drills 9
-    * writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  157 writearr<inlined> :addTitaniumDrill:drill .titaniumDrills[] .drills
   158 op add .drills .drills 1
   159 label *label52
   160 label *label53

Modifications by Unroll iteration loop at line 65:9 (+340 instructions):
 
    17 label *label10
    18 label *label14
    19 set :backgroundProcess:count 0
-    * set :backgroundProcess:drill .titaniumDrills*0
-    * set :backgroundProcess:unit .units*0
-    * op add *tmp8 @counter 1
-    * jump *label17 always
-    * multilabel *label20 (m:marker0)
-    * set .units*0 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*1
-    * set :backgroundProcess:unit .units*1
-    * op add *tmp8 @counter 1
-    * jump *label17 always
-    * multilabel *label21 (m:marker0)
-    * set .units*1 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*2
-    * set :backgroundProcess:unit .units*2
-    * op add *tmp8 @counter 1
-    * jump *label17 always
-    * multilabel *label22 (m:marker0)
-    * set .units*2 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*3
-    * set :backgroundProcess:unit .units*3
-    * op add *tmp8 @counter 1
-    * jump *label17 always
-    * multilabel *label23 (m:marker0)
-    * set .units*3 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*4
-    * set :backgroundProcess:unit .units*4
-    * op add *tmp8 @counter 1
-    * jump *label17 always
-    * multilabel *label24 (m:marker0)
-    * set .units*4 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*5
-    * set :backgroundProcess:unit .units*5
-    * op add *tmp8 @counter 1
-    * jump *label17 always
-    * multilabel *label25 (m:marker0)
-    * set .units*5 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*6
-    * set :backgroundProcess:unit .units*6
-    * op add *tmp8 @counter 1
-    * jump *label17 always
-    * multilabel *label26 (m:marker0)
-    * set .units*6 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*7
-    * set :backgroundProcess:unit .units*7
-    * op add *tmp8 @counter 1
-    * jump *label17 always
-    * multilabel *label27 (m:marker0)
-    * set .units*7 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*8
-    * set :backgroundProcess:unit .units*8
-    * op add *tmp8 @counter 1
-    * jump *label17 always
-    * multilabel *label28 (m:marker0)
-    * set .units*8 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*9
-    * set :backgroundProcess:unit .units*9
-    * set *tmp8 null
-    * label *label17
-    * jump *label30 notEqual :backgroundProcess:drill null
-    * jump *label19 always
-    * label *label30
-    * label *label31
-    * sensor *tmp11 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count :backgroundProcess:count *tmp11
-    * sensor *tmp12 :backgroundProcess:unit @controller
-    * jump *label32 equal *tmp12 @this
-    * # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * ubind @flare
-    * jump *label35 notEqual @unit null
-    * set *tmp15 null
-    * jump *label34 always
-    * label *label35
-    * label *label36
-    * set :findFreeUnit:first_unit @unit
-    * label *label37
-    * sensor *tmp18 @unit @controlled
-    * jump *label40 notEqual *tmp18 0
-    * ucontrol flag 0
-    * set *tmp15 @unit
-    * jump *label34 always
-    * jump *label41 always
-    * label *label40
-    * sensor *tmp21 :findFreeUnit:first_unit @dead
-    * jump *label42 notEqual *tmp21 1
-    * set :findFreeUnit:first_unit @unit
-    * label *label42
-    * label *label43
-    * label *label41
-    * ubind @flare
-    * label *label38
-    * jump *label37 notEqual :findFreeUnit:first_unit @unit
-    * label *label39
-    * set *tmp15 null
-    * jump *label34 always
-    * label *label34
-    * set :backgroundProcess:unit *tmp15
-    * jump *label44 notEqual *tmp15 null
-    * jump *label18 always
-    * label *label44
-    * label *label45
-    * label *label32
-    * label *label33
-    * # "Function: void serviceDrill(in drill, in unit)"
-    * ubind :backgroundProcess:unit
-    * sensor :serviceDrill:item @unit @firstItem
-    * jump *label47 notEqual :serviceDrill:item @titanium
-    * ucontrol approach .coreX .coreY 4
-    * ucontrol itemDrop .core 10
-    * jump *label48 always
-    * label *label47
-    * jump *label49 notEqual :serviceDrill:item null
-    * sensor *tmp33 :backgroundProcess:drill @x
-    * sensor *tmp34 :backgroundProcess:drill @y
-    * ucontrol approach *tmp33 *tmp34 4
-    * ucontrol itemTake :backgroundProcess:drill @titanium 10
-    * jump *label50 always
-    * label *label49
-    * ucontrol itemDrop @air 10
-    * label *label50
-    * label *label48
-    * label *label46
-    * label *label18
-    * multijump *tmp8 0 0 (m:marker0)
-    * multilabel *label29 (m:marker0)
-    * set .units*9 :backgroundProcess:unit
-    * label *label19
+   20 set :backgroundProcess:drill .titaniumDrills*0
+   21 set :backgroundProcess:unit .units*0
+   22 label *label54
+   23 jump *label55 notEqual :backgroundProcess:drill null
+   24 jump *label19 always
+   25 label *label55
+   26 label *label56
+   27 sensor *tmp11 :backgroundProcess:drill @titanium
+   28 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+   29 sensor *tmp12 :backgroundProcess:unit @controller
+   30 jump *label69 equal *tmp12 @this
+   31 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+   32 ubind @flare
+   33 jump *label57 notEqual @unit null
+   34 set *tmp15 null
+   35 jump *label66 always
+   36 label *label57
+   37 label *label58
+   38 set :findFreeUnit:first_unit @unit
+   39 label *label59
+   40 sensor *tmp18 @unit @controlled
+   41 jump *label60 notEqual *tmp18 0
+   42 ucontrol flag 0
+   43 set *tmp15 @unit
+   44 jump *label66 always
+   45 jump *label63 always
+   46 label *label60
+   47 sensor *tmp21 :findFreeUnit:first_unit @dead
+   48 jump *label61 notEqual *tmp21 1
+   49 set :findFreeUnit:first_unit @unit
+   50 label *label61
+   51 label *label62
+   52 label *label63
+   53 ubind @flare
+   54 label *label64
+   55 jump *label59 notEqual :findFreeUnit:first_unit @unit
+   56 label *label65
+   57 set *tmp15 null
+   58 jump *label66 always
+   59 label *label66
+   60 set :backgroundProcess:unit *tmp15
+   61 jump *label67 notEqual *tmp15 null
+   62 jump *label76 always
+   63 label *label67
+   64 label *label68
+   65 label *label69
+   66 label *label70
+   67 # "Function: void serviceDrill(in drill, in unit)"
+   68 ubind :backgroundProcess:unit
+   69 sensor :serviceDrill:item @unit @firstItem
+   70 jump *label71 notEqual :serviceDrill:item @titanium
+   71 ucontrol approach .coreX .coreY 4
+   72 ucontrol itemDrop .core 10
+   73 jump *label74 always
+   74 label *label71
+   75 jump *label72 notEqual :serviceDrill:item null
+   76 sensor *tmp33 :backgroundProcess:drill @x
+   77 sensor *tmp34 :backgroundProcess:drill @y
+   78 ucontrol approach *tmp33 *tmp34 4
+   79 ucontrol itemTake :backgroundProcess:drill @titanium 10
+   80 jump *label73 always
+   81 label *label72
+   82 ucontrol itemDrop @air 10
+   83 label *label73
+   84 label *label74
+   85 label *label75
+   86 label *label76
+   87 set .units*0 :backgroundProcess:unit
+   88 set :backgroundProcess:drill .titaniumDrills*1
+   89 set :backgroundProcess:unit .units*1
+   90 label *label79
+   91 jump *label80 notEqual :backgroundProcess:drill null
+   92 jump *label19 always
+   93 label *label80
+   94 label *label81
+   95 sensor *tmp11 :backgroundProcess:drill @titanium
+   96 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+   97 sensor *tmp12 :backgroundProcess:unit @controller
+   98 jump *label94 equal *tmp12 @this
+   99 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  100 ubind @flare
+  101 jump *label82 notEqual @unit null
+  102 set *tmp15 null
+  103 jump *label91 always
+  104 label *label82
+  105 label *label83
+  106 set :findFreeUnit:first_unit @unit
+  107 label *label84
+  108 sensor *tmp18 @unit @controlled
+  109 jump *label85 notEqual *tmp18 0
+  110 ucontrol flag 0
+  111 set *tmp15 @unit
+  112 jump *label91 always
+  113 jump *label88 always
+  114 label *label85
+  115 sensor *tmp21 :findFreeUnit:first_unit @dead
+  116 jump *label86 notEqual *tmp21 1
+  117 set :findFreeUnit:first_unit @unit
+  118 label *label86
+  119 label *label87
+  120 label *label88
+  121 ubind @flare
+  122 label *label89
+  123 jump *label84 notEqual :findFreeUnit:first_unit @unit
+  124 label *label90
+  125 set *tmp15 null
+  126 jump *label91 always
+  127 label *label91
+  128 set :backgroundProcess:unit *tmp15
+  129 jump *label92 notEqual *tmp15 null
+  130 jump *label101 always
+  131 label *label92
+  132 label *label93
+  133 label *label94
+  134 label *label95
+  135 # "Function: void serviceDrill(in drill, in unit)"
+  136 ubind :backgroundProcess:unit
+  137 sensor :serviceDrill:item @unit @firstItem
+  138 jump *label96 notEqual :serviceDrill:item @titanium
+  139 ucontrol approach .coreX .coreY 4
+  140 ucontrol itemDrop .core 10
+  141 jump *label99 always
+  142 label *label96
+  143 jump *label97 notEqual :serviceDrill:item null
+  144 sensor *tmp33 :backgroundProcess:drill @x
+  145 sensor *tmp34 :backgroundProcess:drill @y
+  146 ucontrol approach *tmp33 *tmp34 4
+  147 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  148 jump *label98 always
+  149 label *label97
+  150 ucontrol itemDrop @air 10
+  151 label *label98
+  152 label *label99
+  153 label *label100
+  154 label *label101
+  155 set .units*1 :backgroundProcess:unit
+  156 set :backgroundProcess:drill .titaniumDrills*2
+  157 set :backgroundProcess:unit .units*2
+  158 label *label104
+  159 jump *label105 notEqual :backgroundProcess:drill null
+  160 jump *label19 always
+  161 label *label105
+  162 label *label106
+  163 sensor *tmp11 :backgroundProcess:drill @titanium
+  164 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+  165 sensor *tmp12 :backgroundProcess:unit @controller
+  166 jump *label119 equal *tmp12 @this
+  167 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  168 ubind @flare
+  169 jump *label107 notEqual @unit null
+  170 set *tmp15 null
+  171 jump *label116 always
+  172 label *label107
+  173 label *label108
+  174 set :findFreeUnit:first_unit @unit
+  175 label *label109
+  176 sensor *tmp18 @unit @controlled
+  177 jump *label110 notEqual *tmp18 0
+  178 ucontrol flag 0
+  179 set *tmp15 @unit
+  180 jump *label116 always
+  181 jump *label113 always
+  182 label *label110
+  183 sensor *tmp21 :findFreeUnit:first_unit @dead
+  184 jump *label111 notEqual *tmp21 1
+  185 set :findFreeUnit:first_unit @unit
+  186 label *label111
+  187 label *label112
+  188 label *label113
+  189 ubind @flare
+  190 label *label114
+  191 jump *label109 notEqual :findFreeUnit:first_unit @unit
+  192 label *label115
+  193 set *tmp15 null
+  194 jump *label116 always
+  195 label *label116
+  196 set :backgroundProcess:unit *tmp15
+  197 jump *label117 notEqual *tmp15 null
+  198 jump *label126 always
+  199 label *label117
+  200 label *label118
+  201 label *label119
+  202 label *label120
+  203 # "Function: void serviceDrill(in drill, in unit)"
+  204 ubind :backgroundProcess:unit
+  205 sensor :serviceDrill:item @unit @firstItem
+  206 jump *label121 notEqual :serviceDrill:item @titanium
+  207 ucontrol approach .coreX .coreY 4
+  208 ucontrol itemDrop .core 10
+  209 jump *label124 always
+  210 label *label121
+  211 jump *label122 notEqual :serviceDrill:item null
+  212 sensor *tmp33 :backgroundProcess:drill @x
+  213 sensor *tmp34 :backgroundProcess:drill @y
+  214 ucontrol approach *tmp33 *tmp34 4
+  215 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  216 jump *label123 always
+  217 label *label122
+  218 ucontrol itemDrop @air 10
+  219 label *label123
+  220 label *label124
+  221 label *label125
+  222 label *label126
+  223 set .units*2 :backgroundProcess:unit
+  224 set :backgroundProcess:drill .titaniumDrills*3
+  225 set :backgroundProcess:unit .units*3
+  226 label *label129
+  227 jump *label130 notEqual :backgroundProcess:drill null
+  228 jump *label19 always
+  229 label *label130
+  230 label *label131
+  231 sensor *tmp11 :backgroundProcess:drill @titanium
+  232 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+  233 sensor *tmp12 :backgroundProcess:unit @controller
+  234 jump *label144 equal *tmp12 @this
+  235 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  236 ubind @flare
+  237 jump *label132 notEqual @unit null
+  238 set *tmp15 null
+  239 jump *label141 always
+  240 label *label132
+  241 label *label133
+  242 set :findFreeUnit:first_unit @unit
+  243 label *label134
+  244 sensor *tmp18 @unit @controlled
+  245 jump *label135 notEqual *tmp18 0
+  246 ucontrol flag 0
+  247 set *tmp15 @unit
+  248 jump *label141 always
+  249 jump *label138 always
+  250 label *label135
+  251 sensor *tmp21 :findFreeUnit:first_unit @dead
+  252 jump *label136 notEqual *tmp21 1
+  253 set :findFreeUnit:first_unit @unit
+  254 label *label136
+  255 label *label137
+  256 label *label138
+  257 ubind @flare
+  258 label *label139
+  259 jump *label134 notEqual :findFreeUnit:first_unit @unit
+  260 label *label140
+  261 set *tmp15 null
+  262 jump *label141 always
+  263 label *label141
+  264 set :backgroundProcess:unit *tmp15
+  265 jump *label142 notEqual *tmp15 null
+  266 jump *label151 always
+  267 label *label142
+  268 label *label143
+  269 label *label144
+  270 label *label145
+  271 # "Function: void serviceDrill(in drill, in unit)"
+  272 ubind :backgroundProcess:unit
+  273 sensor :serviceDrill:item @unit @firstItem
+  274 jump *label146 notEqual :serviceDrill:item @titanium
+  275 ucontrol approach .coreX .coreY 4
+  276 ucontrol itemDrop .core 10
+  277 jump *label149 always
+  278 label *label146
+  279 jump *label147 notEqual :serviceDrill:item null
+  280 sensor *tmp33 :backgroundProcess:drill @x
+  281 sensor *tmp34 :backgroundProcess:drill @y
+  282 ucontrol approach *tmp33 *tmp34 4
+  283 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  284 jump *label148 always
+  285 label *label147
+  286 ucontrol itemDrop @air 10
+  287 label *label148
+  288 label *label149
+  289 label *label150
+  290 label *label151
+  291 set .units*3 :backgroundProcess:unit
+  292 set :backgroundProcess:drill .titaniumDrills*4
+  293 set :backgroundProcess:unit .units*4
+  294 label *label154
+  295 jump *label155 notEqual :backgroundProcess:drill null
+  296 jump *label19 always
+  297 label *label155
+  298 label *label156
+  299 sensor *tmp11 :backgroundProcess:drill @titanium
+  300 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+  301 sensor *tmp12 :backgroundProcess:unit @controller
+  302 jump *label169 equal *tmp12 @this
+  303 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  304 ubind @flare
+  305 jump *label157 notEqual @unit null
+  306 set *tmp15 null
+  307 jump *label166 always
+  308 label *label157
+  309 label *label158
+  310 set :findFreeUnit:first_unit @unit
+  311 label *label159
+  312 sensor *tmp18 @unit @controlled
+  313 jump *label160 notEqual *tmp18 0
+  314 ucontrol flag 0
+  315 set *tmp15 @unit
+  316 jump *label166 always
+  317 jump *label163 always
+  318 label *label160
+  319 sensor *tmp21 :findFreeUnit:first_unit @dead
+  320 jump *label161 notEqual *tmp21 1
+  321 set :findFreeUnit:first_unit @unit
+  322 label *label161
+  323 label *label162
+  324 label *label163
+  325 ubind @flare
+  326 label *label164
+  327 jump *label159 notEqual :findFreeUnit:first_unit @unit
+  328 label *label165
+  329 set *tmp15 null
+  330 jump *label166 always
+  331 label *label166
+  332 set :backgroundProcess:unit *tmp15
+  333 jump *label167 notEqual *tmp15 null
+  334 jump *label176 always
+  335 label *label167
+  336 label *label168
+  337 label *label169
+  338 label *label170
+  339 # "Function: void serviceDrill(in drill, in unit)"
+  340 ubind :backgroundProcess:unit
+  341 sensor :serviceDrill:item @unit @firstItem
+  342 jump *label171 notEqual :serviceDrill:item @titanium
+  343 ucontrol approach .coreX .coreY 4
+  344 ucontrol itemDrop .core 10
+  345 jump *label174 always
+  346 label *label171
+  347 jump *label172 notEqual :serviceDrill:item null
+  348 sensor *tmp33 :backgroundProcess:drill @x
+  349 sensor *tmp34 :backgroundProcess:drill @y
+  350 ucontrol approach *tmp33 *tmp34 4
+  351 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  352 jump *label173 always
+  353 label *label172
+  354 ucontrol itemDrop @air 10
+  355 label *label173
+  356 label *label174
+  357 label *label175
+  358 label *label176
+  359 set .units*4 :backgroundProcess:unit
+  360 set :backgroundProcess:drill .titaniumDrills*5
+  361 set :backgroundProcess:unit .units*5
+  362 label *label179
+  363 jump *label180 notEqual :backgroundProcess:drill null
+  364 jump *label19 always
+  365 label *label180
+  366 label *label181
+  367 sensor *tmp11 :backgroundProcess:drill @titanium
+  368 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+  369 sensor *tmp12 :backgroundProcess:unit @controller
+  370 jump *label194 equal *tmp12 @this
+  371 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  372 ubind @flare
+  373 jump *label182 notEqual @unit null
+  374 set *tmp15 null
+  375 jump *label191 always
+  376 label *label182
+  377 label *label183
+  378 set :findFreeUnit:first_unit @unit
+  379 label *label184
+  380 sensor *tmp18 @unit @controlled
+  381 jump *label185 notEqual *tmp18 0
+  382 ucontrol flag 0
+  383 set *tmp15 @unit
+  384 jump *label191 always
+  385 jump *label188 always
+  386 label *label185
+  387 sensor *tmp21 :findFreeUnit:first_unit @dead
+  388 jump *label186 notEqual *tmp21 1
+  389 set :findFreeUnit:first_unit @unit
+  390 label *label186
+  391 label *label187
+  392 label *label188
+  393 ubind @flare
+  394 label *label189
+  395 jump *label184 notEqual :findFreeUnit:first_unit @unit
+  396 label *label190
+  397 set *tmp15 null
+  398 jump *label191 always
+  399 label *label191
+  400 set :backgroundProcess:unit *tmp15
+  401 jump *label192 notEqual *tmp15 null
+  402 jump *label201 always
+  403 label *label192
+  404 label *label193
+  405 label *label194
+  406 label *label195
+  407 # "Function: void serviceDrill(in drill, in unit)"
+  408 ubind :backgroundProcess:unit
+  409 sensor :serviceDrill:item @unit @firstItem
+  410 jump *label196 notEqual :serviceDrill:item @titanium
+  411 ucontrol approach .coreX .coreY 4
+  412 ucontrol itemDrop .core 10
+  413 jump *label199 always
+  414 label *label196
+  415 jump *label197 notEqual :serviceDrill:item null
+  416 sensor *tmp33 :backgroundProcess:drill @x
+  417 sensor *tmp34 :backgroundProcess:drill @y
+  418 ucontrol approach *tmp33 *tmp34 4
+  419 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  420 jump *label198 always
+  421 label *label197
+  422 ucontrol itemDrop @air 10
+  423 label *label198
+  424 label *label199
+  425 label *label200
+  426 label *label201
+  427 set .units*5 :backgroundProcess:unit
+  428 set :backgroundProcess:drill .titaniumDrills*6
+  429 set :backgroundProcess:unit .units*6
+  430 label *label204
+  431 jump *label205 notEqual :backgroundProcess:drill null
+  432 jump *label19 always
+  433 label *label205
+  434 label *label206
+  435 sensor *tmp11 :backgroundProcess:drill @titanium
+  436 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+  437 sensor *tmp12 :backgroundProcess:unit @controller
+  438 jump *label219 equal *tmp12 @this
+  439 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  440 ubind @flare
+  441 jump *label207 notEqual @unit null
+  442 set *tmp15 null
+  443 jump *label216 always
+  444 label *label207
+  445 label *label208
+  446 set :findFreeUnit:first_unit @unit
+  447 label *label209
+  448 sensor *tmp18 @unit @controlled
+  449 jump *label210 notEqual *tmp18 0
+  450 ucontrol flag 0
+  451 set *tmp15 @unit
+  452 jump *label216 always
+  453 jump *label213 always
+  454 label *label210
+  455 sensor *tmp21 :findFreeUnit:first_unit @dead
+  456 jump *label211 notEqual *tmp21 1
+  457 set :findFreeUnit:first_unit @unit
+  458 label *label211
+  459 label *label212
+  460 label *label213
+  461 ubind @flare
+  462 label *label214
+  463 jump *label209 notEqual :findFreeUnit:first_unit @unit
+  464 label *label215
+  465 set *tmp15 null
+  466 jump *label216 always
+  467 label *label216
+  468 set :backgroundProcess:unit *tmp15
+  469 jump *label217 notEqual *tmp15 null
+  470 jump *label226 always
+  471 label *label217
+  472 label *label218
+  473 label *label219
+  474 label *label220
+  475 # "Function: void serviceDrill(in drill, in unit)"
+  476 ubind :backgroundProcess:unit
+  477 sensor :serviceDrill:item @unit @firstItem
+  478 jump *label221 notEqual :serviceDrill:item @titanium
+  479 ucontrol approach .coreX .coreY 4
+  480 ucontrol itemDrop .core 10
+  481 jump *label224 always
+  482 label *label221
+  483 jump *label222 notEqual :serviceDrill:item null
+  484 sensor *tmp33 :backgroundProcess:drill @x
+  485 sensor *tmp34 :backgroundProcess:drill @y
+  486 ucontrol approach *tmp33 *tmp34 4
+  487 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  488 jump *label223 always
+  489 label *label222
+  490 ucontrol itemDrop @air 10
+  491 label *label223
+  492 label *label224
+  493 label *label225
+  494 label *label226
+  495 set .units*6 :backgroundProcess:unit
+  496 set :backgroundProcess:drill .titaniumDrills*7
+  497 set :backgroundProcess:unit .units*7
+  498 label *label229
+  499 jump *label230 notEqual :backgroundProcess:drill null
+  500 jump *label19 always
+  501 label *label230
+  502 label *label231
+  503 sensor *tmp11 :backgroundProcess:drill @titanium
+  504 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+  505 sensor *tmp12 :backgroundProcess:unit @controller
+  506 jump *label244 equal *tmp12 @this
+  507 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  508 ubind @flare
+  509 jump *label232 notEqual @unit null
+  510 set *tmp15 null
+  511 jump *label241 always
+  512 label *label232
+  513 label *label233
+  514 set :findFreeUnit:first_unit @unit
+  515 label *label234
+  516 sensor *tmp18 @unit @controlled
+  517 jump *label235 notEqual *tmp18 0
+  518 ucontrol flag 0
+  519 set *tmp15 @unit
+  520 jump *label241 always
+  521 jump *label238 always
+  522 label *label235
+  523 sensor *tmp21 :findFreeUnit:first_unit @dead
+  524 jump *label236 notEqual *tmp21 1
+  525 set :findFreeUnit:first_unit @unit
+  526 label *label236
+  527 label *label237
+  528 label *label238
+  529 ubind @flare
+  530 label *label239
+  531 jump *label234 notEqual :findFreeUnit:first_unit @unit
+  532 label *label240
+  533 set *tmp15 null
+  534 jump *label241 always
+  535 label *label241
+  536 set :backgroundProcess:unit *tmp15
+  537 jump *label242 notEqual *tmp15 null
+  538 jump *label251 always
+  539 label *label242
+  540 label *label243
+  541 label *label244
+  542 label *label245
+  543 # "Function: void serviceDrill(in drill, in unit)"
+  544 ubind :backgroundProcess:unit
+  545 sensor :serviceDrill:item @unit @firstItem
+  546 jump *label246 notEqual :serviceDrill:item @titanium
+  547 ucontrol approach .coreX .coreY 4
+  548 ucontrol itemDrop .core 10
+  549 jump *label249 always
+  550 label *label246
+  551 jump *label247 notEqual :serviceDrill:item null
+  552 sensor *tmp33 :backgroundProcess:drill @x
+  553 sensor *tmp34 :backgroundProcess:drill @y
+  554 ucontrol approach *tmp33 *tmp34 4
+  555 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  556 jump *label248 always
+  557 label *label247
+  558 ucontrol itemDrop @air 10
+  559 label *label248
+  560 label *label249
+  561 label *label250
+  562 label *label251
+  563 set .units*7 :backgroundProcess:unit
+  564 set :backgroundProcess:drill .titaniumDrills*8
+  565 set :backgroundProcess:unit .units*8
+  566 label *label254
+  567 jump *label255 notEqual :backgroundProcess:drill null
+  568 jump *label19 always
+  569 label *label255
+  570 label *label256
+  571 sensor *tmp11 :backgroundProcess:drill @titanium
+  572 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+  573 sensor *tmp12 :backgroundProcess:unit @controller
+  574 jump *label269 equal *tmp12 @this
+  575 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  576 ubind @flare
+  577 jump *label257 notEqual @unit null
+  578 set *tmp15 null
+  579 jump *label266 always
+  580 label *label257
+  581 label *label258
+  582 set :findFreeUnit:first_unit @unit
+  583 label *label259
+  584 sensor *tmp18 @unit @controlled
+  585 jump *label260 notEqual *tmp18 0
+  586 ucontrol flag 0
+  587 set *tmp15 @unit
+  588 jump *label266 always
+  589 jump *label263 always
+  590 label *label260
+  591 sensor *tmp21 :findFreeUnit:first_unit @dead
+  592 jump *label261 notEqual *tmp21 1
+  593 set :findFreeUnit:first_unit @unit
+  594 label *label261
+  595 label *label262
+  596 label *label263
+  597 ubind @flare
+  598 label *label264
+  599 jump *label259 notEqual :findFreeUnit:first_unit @unit
+  600 label *label265
+  601 set *tmp15 null
+  602 jump *label266 always
+  603 label *label266
+  604 set :backgroundProcess:unit *tmp15
+  605 jump *label267 notEqual *tmp15 null
+  606 jump *label276 always
+  607 label *label267
+  608 label *label268
+  609 label *label269
+  610 label *label270
+  611 # "Function: void serviceDrill(in drill, in unit)"
+  612 ubind :backgroundProcess:unit
+  613 sensor :serviceDrill:item @unit @firstItem
+  614 jump *label271 notEqual :serviceDrill:item @titanium
+  615 ucontrol approach .coreX .coreY 4
+  616 ucontrol itemDrop .core 10
+  617 jump *label274 always
+  618 label *label271
+  619 jump *label272 notEqual :serviceDrill:item null
+  620 sensor *tmp33 :backgroundProcess:drill @x
+  621 sensor *tmp34 :backgroundProcess:drill @y
+  622 ucontrol approach *tmp33 *tmp34 4
+  623 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  624 jump *label273 always
+  625 label *label272
+  626 ucontrol itemDrop @air 10
+  627 label *label273
+  628 label *label274
+  629 label *label275
+  630 label *label276
+  631 set .units*8 :backgroundProcess:unit
+  632 set :backgroundProcess:drill .titaniumDrills*9
+  633 set :backgroundProcess:unit .units*9
+  634 label *label279
+  635 jump *label280 notEqual :backgroundProcess:drill null
+  636 jump *label19 always
+  637 label *label280
+  638 label *label281
+  639 sensor *tmp11 :backgroundProcess:drill @titanium
+  640 op add :backgroundProcess:count :backgroundProcess:count *tmp11
+  641 sensor *tmp12 :backgroundProcess:unit @controller
+  642 jump *label294 equal *tmp12 @this
+  643 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  644 ubind @flare
+  645 jump *label282 notEqual @unit null
+  646 set *tmp15 null
+  647 jump *label291 always
+  648 label *label282
+  649 label *label283
+  650 set :findFreeUnit:first_unit @unit
+  651 label *label284
+  652 sensor *tmp18 @unit @controlled
+  653 jump *label285 notEqual *tmp18 0
+  654 ucontrol flag 0
+  655 set *tmp15 @unit
+  656 jump *label291 always
+  657 jump *label288 always
+  658 label *label285
+  659 sensor *tmp21 :findFreeUnit:first_unit @dead
+  660 jump *label286 notEqual *tmp21 1
+  661 set :findFreeUnit:first_unit @unit
+  662 label *label286
+  663 label *label287
+  664 label *label288
+  665 ubind @flare
+  666 label *label289
+  667 jump *label284 notEqual :findFreeUnit:first_unit @unit
+  668 label *label290
+  669 set *tmp15 null
+  670 jump *label291 always
+  671 label *label291
+  672 set :backgroundProcess:unit *tmp15
+  673 jump *label292 notEqual *tmp15 null
+  674 jump *label301 always
+  675 label *label292
+  676 label *label293
+  677 label *label294
+  678 label *label295
+  679 # "Function: void serviceDrill(in drill, in unit)"
+  680 ubind :backgroundProcess:unit
+  681 sensor :serviceDrill:item @unit @firstItem
+  682 jump *label296 notEqual :serviceDrill:item @titanium
+  683 ucontrol approach .coreX .coreY 4
+  684 ucontrol itemDrop .core 10
+  685 jump *label299 always
+  686 label *label296
+  687 jump *label297 notEqual :serviceDrill:item null
+  688 sensor *tmp33 :backgroundProcess:drill @x
+  689 sensor *tmp34 :backgroundProcess:drill @y
+  690 ucontrol approach *tmp33 *tmp34 4
+  691 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  692 jump *label298 always
+  693 label *label297
+  694 ucontrol itemDrop @air 10
+  695 label *label298
+  696 label *label299
+  697 label *label300
+  698 label *label301
+  699 set .units*9 :backgroundProcess:unit
+  700 label *label19
   701 write :backgroundProcess:count processor1 ".titaniumDrillCount"
   702 label *label15
   703 jump *label14 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    25 label *label55
    26 label *label56
    27 sensor *tmp11 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count :backgroundProcess:count *tmp11
+   28 op add :backgroundProcess:count 0 *tmp11
    29 sensor *tmp12 :backgroundProcess:unit @controller
    30 jump *label69 equal *tmp12 @this
    31 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-10 instructions):
 
    55 jump *label59 notEqual :findFreeUnit:first_unit @unit
    56 label *label65
    57 set *tmp15 null
-    * jump *label66 always
    58 label *label66
    59 set :backgroundProcess:unit *tmp15
    60 jump *label67 notEqual *tmp15 null
 
   122 jump *label84 notEqual :findFreeUnit:first_unit @unit
   123 label *label90
   124 set *tmp15 null
-    * jump *label91 always
   125 label *label91
   126 set :backgroundProcess:unit *tmp15
   127 jump *label92 notEqual *tmp15 null
 
   189 jump *label109 notEqual :findFreeUnit:first_unit @unit
   190 label *label115
   191 set *tmp15 null
-    * jump *label116 always
   192 label *label116
   193 set :backgroundProcess:unit *tmp15
   194 jump *label117 notEqual *tmp15 null
 
   256 jump *label134 notEqual :findFreeUnit:first_unit @unit
   257 label *label140
   258 set *tmp15 null
-    * jump *label141 always
   259 label *label141
   260 set :backgroundProcess:unit *tmp15
   261 jump *label142 notEqual *tmp15 null
 
   323 jump *label159 notEqual :findFreeUnit:first_unit @unit
   324 label *label165
   325 set *tmp15 null
-    * jump *label166 always
   326 label *label166
   327 set :backgroundProcess:unit *tmp15
   328 jump *label167 notEqual *tmp15 null
 
   390 jump *label184 notEqual :findFreeUnit:first_unit @unit
   391 label *label190
   392 set *tmp15 null
-    * jump *label191 always
   393 label *label191
   394 set :backgroundProcess:unit *tmp15
   395 jump *label192 notEqual *tmp15 null
 
   457 jump *label209 notEqual :findFreeUnit:first_unit @unit
   458 label *label215
   459 set *tmp15 null
-    * jump *label216 always
   460 label *label216
   461 set :backgroundProcess:unit *tmp15
   462 jump *label217 notEqual *tmp15 null
 
   524 jump *label234 notEqual :findFreeUnit:first_unit @unit
   525 label *label240
   526 set *tmp15 null
-    * jump *label241 always
   527 label *label241
   528 set :backgroundProcess:unit *tmp15
   529 jump *label242 notEqual *tmp15 null
 
   591 jump *label259 notEqual :findFreeUnit:first_unit @unit
   592 label *label265
   593 set *tmp15 null
-    * jump *label266 always
   594 label *label266
   595 set :backgroundProcess:unit *tmp15
   596 jump *label267 notEqual *tmp15 null
 
   658 jump *label284 notEqual :findFreeUnit:first_unit @unit
   659 label *label290
   660 set *tmp15 null
-    * jump *label291 always
   661 label *label291
   662 set :backgroundProcess:unit *tmp15
   663 jump *label292 notEqual *tmp15 null

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    25 label *label55
    26 label *label56
    27 sensor *tmp11 :backgroundProcess:drill @titanium
-    * op add :backgroundProcess:count 0 *tmp11
+   28 set :backgroundProcess:count *tmp11
    29 sensor *tmp12 :backgroundProcess:unit @controller
    30 jump *label69 equal *tmp12 @this
    31 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Virtual Instruction Expansion (+1 instructions):
 
   699 label *label0
   700 # "Function: remote void addTitaniumDrill(in drill)"
   701 jump *label52 greaterThanEq .drills 9
-    * writearr<inlined> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  702 op mul *tmp40 .drills 2
+  703 multijump *label306 *tmp40 0 (m:marker1)
+  704 multilabel *label306 (m:marker1)
+  705 set .titaniumDrills*0 :addTitaniumDrill:drill
+  706 jump *label305 always
+  707 multilabel *label307 (m:marker1)
+  708 set .titaniumDrills*1 :addTitaniumDrill:drill
+  709 jump *label305 always
+  710 multilabel *label308 (m:marker1)
+  711 set .titaniumDrills*2 :addTitaniumDrill:drill
+  712 jump *label305 always
+  713 multilabel *label309 (m:marker1)
+  714 set .titaniumDrills*3 :addTitaniumDrill:drill
+  715 jump *label305 always
+  716 multilabel *label310 (m:marker1)
+  717 set .titaniumDrills*4 :addTitaniumDrill:drill
+  718 jump *label305 always
+  719 multilabel *label311 (m:marker1)
+  720 set .titaniumDrills*5 :addTitaniumDrill:drill
+  721 jump *label305 always
+  722 multilabel *label312 (m:marker1)
+  723 set .titaniumDrills*6 :addTitaniumDrill:drill
+  724 jump *label305 always
+  725 multilabel *label313 (m:marker1)
+  726 set .titaniumDrills*7 :addTitaniumDrill:drill
+  727 jump *label305 always
+  728 multilabel *label314 (m:marker1)
+  729 set .titaniumDrills*8 :addTitaniumDrill:drill
+  730 jump *label305 always
+  731 multilabel *label315 (m:marker1)
+  732 set .titaniumDrills*9 :addTitaniumDrill:drill
+  733 jump *label305 always
+  734 label *label305
   735 op add .drills .drills 1
   736 label *label52
   737 label *label53

Modifications by Iterated phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   730 jump *label305 always
   731 multilabel *label315 (m:marker1)
   732 set .titaniumDrills*9 :addTitaniumDrill:drill
-    * jump *label305 always
   733 label *label305
   734 op add .drills .drills 1
   735 label *label52

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
     8 label *label11
     9 ubind @flare
    10 ulocate building core false @copper .coreX .coreY 0 .core
-    * label *label12
    11 jump *label11 equal .core null
-    * label *label13
    12 sensor .coreX .core @x
    13 sensor .coreY .core @y
    14 label *label9
-    * label *label10
    15 label *label14
    16 set :backgroundProcess:count 0
    17 set :backgroundProcess:drill .titaniumDrills*0
    18 set :backgroundProcess:unit .units*0
-    * label *label54
    19 jump *label55 notEqual :backgroundProcess:drill null
    20 jump *label19 always
    21 label *label55
-    * label *label56
    22 sensor *tmp11 :backgroundProcess:drill @titanium
    23 set :backgroundProcess:count *tmp11
    24 sensor *tmp12 :backgroundProcess:unit @controller
 
    29 set *tmp15 null
    30 jump *label66 always
    31 label *label57
-    * label *label58
    32 set :findFreeUnit:first_unit @unit
    33 label *label59
    34 sensor *tmp18 @unit @controlled
 
    42 jump *label61 notEqual *tmp21 1
    43 set :findFreeUnit:first_unit @unit
    44 label *label61
-    * label *label62
    45 label *label63
    46 ubind @flare
-    * label *label64
    47 jump *label59 notEqual :findFreeUnit:first_unit @unit
-    * label *label65
    48 set *tmp15 null
    49 label *label66
    50 set :backgroundProcess:unit *tmp15
    51 jump *label67 notEqual *tmp15 null
    52 jump *label76 always
    53 label *label67
-    * label *label68
    54 label *label69
-    * label *label70
    55 # "Function: void serviceDrill(in drill, in unit)"
    56 ubind :backgroundProcess:unit
    57 sensor :serviceDrill:item @unit @firstItem
 
    70 ucontrol itemDrop @air 10
    71 label *label73
    72 label *label74
-    * label *label75
    73 label *label76
    74 set .units*0 :backgroundProcess:unit
    75 set :backgroundProcess:drill .titaniumDrills*1
    76 set :backgroundProcess:unit .units*1
-    * label *label79
    77 jump *label80 notEqual :backgroundProcess:drill null
    78 jump *label19 always
    79 label *label80
-    * label *label81
    80 sensor *tmp11 :backgroundProcess:drill @titanium
    81 op add :backgroundProcess:count :backgroundProcess:count *tmp11
    82 sensor *tmp12 :backgroundProcess:unit @controller
 
    87 set *tmp15 null
    88 jump *label91 always
    89 label *label82
-    * label *label83
    90 set :findFreeUnit:first_unit @unit
    91 label *label84
    92 sensor *tmp18 @unit @controlled
 
   100 jump *label86 notEqual *tmp21 1
   101 set :findFreeUnit:first_unit @unit
   102 label *label86
-    * label *label87
   103 label *label88
   104 ubind @flare
-    * label *label89
   105 jump *label84 notEqual :findFreeUnit:first_unit @unit
-    * label *label90
   106 set *tmp15 null
   107 label *label91
   108 set :backgroundProcess:unit *tmp15
   109 jump *label92 notEqual *tmp15 null
   110 jump *label101 always
   111 label *label92
-    * label *label93
   112 label *label94
-    * label *label95
   113 # "Function: void serviceDrill(in drill, in unit)"
   114 ubind :backgroundProcess:unit
   115 sensor :serviceDrill:item @unit @firstItem
 
   128 ucontrol itemDrop @air 10
   129 label *label98
   130 label *label99
-    * label *label100
   131 label *label101
   132 set .units*1 :backgroundProcess:unit
   133 set :backgroundProcess:drill .titaniumDrills*2
   134 set :backgroundProcess:unit .units*2
-    * label *label104
   135 jump *label105 notEqual :backgroundProcess:drill null
   136 jump *label19 always
   137 label *label105
-    * label *label106
   138 sensor *tmp11 :backgroundProcess:drill @titanium
   139 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   140 sensor *tmp12 :backgroundProcess:unit @controller
 
   145 set *tmp15 null
   146 jump *label116 always
   147 label *label107
-    * label *label108
   148 set :findFreeUnit:first_unit @unit
   149 label *label109
   150 sensor *tmp18 @unit @controlled
 
   158 jump *label111 notEqual *tmp21 1
   159 set :findFreeUnit:first_unit @unit
   160 label *label111
-    * label *label112
   161 label *label113
   162 ubind @flare
-    * label *label114
   163 jump *label109 notEqual :findFreeUnit:first_unit @unit
-    * label *label115
   164 set *tmp15 null
   165 label *label116
   166 set :backgroundProcess:unit *tmp15
   167 jump *label117 notEqual *tmp15 null
   168 jump *label126 always
   169 label *label117
-    * label *label118
   170 label *label119
-    * label *label120
   171 # "Function: void serviceDrill(in drill, in unit)"
   172 ubind :backgroundProcess:unit
   173 sensor :serviceDrill:item @unit @firstItem
 
   186 ucontrol itemDrop @air 10
   187 label *label123
   188 label *label124
-    * label *label125
   189 label *label126
   190 set .units*2 :backgroundProcess:unit
   191 set :backgroundProcess:drill .titaniumDrills*3
   192 set :backgroundProcess:unit .units*3
-    * label *label129
   193 jump *label130 notEqual :backgroundProcess:drill null
   194 jump *label19 always
   195 label *label130
-    * label *label131
   196 sensor *tmp11 :backgroundProcess:drill @titanium
   197 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   198 sensor *tmp12 :backgroundProcess:unit @controller
 
   203 set *tmp15 null
   204 jump *label141 always
   205 label *label132
-    * label *label133
   206 set :findFreeUnit:first_unit @unit
   207 label *label134
   208 sensor *tmp18 @unit @controlled
 
   216 jump *label136 notEqual *tmp21 1
   217 set :findFreeUnit:first_unit @unit
   218 label *label136
-    * label *label137
   219 label *label138
   220 ubind @flare
-    * label *label139
   221 jump *label134 notEqual :findFreeUnit:first_unit @unit
-    * label *label140
   222 set *tmp15 null
   223 label *label141
   224 set :backgroundProcess:unit *tmp15
   225 jump *label142 notEqual *tmp15 null
   226 jump *label151 always
   227 label *label142
-    * label *label143
   228 label *label144
-    * label *label145
   229 # "Function: void serviceDrill(in drill, in unit)"
   230 ubind :backgroundProcess:unit
   231 sensor :serviceDrill:item @unit @firstItem
 
   244 ucontrol itemDrop @air 10
   245 label *label148
   246 label *label149
-    * label *label150
   247 label *label151
   248 set .units*3 :backgroundProcess:unit
   249 set :backgroundProcess:drill .titaniumDrills*4
   250 set :backgroundProcess:unit .units*4
-    * label *label154
   251 jump *label155 notEqual :backgroundProcess:drill null
   252 jump *label19 always
   253 label *label155
-    * label *label156
   254 sensor *tmp11 :backgroundProcess:drill @titanium
   255 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   256 sensor *tmp12 :backgroundProcess:unit @controller
 
   261 set *tmp15 null
   262 jump *label166 always
   263 label *label157
-    * label *label158
   264 set :findFreeUnit:first_unit @unit
   265 label *label159
   266 sensor *tmp18 @unit @controlled
 
   274 jump *label161 notEqual *tmp21 1
   275 set :findFreeUnit:first_unit @unit
   276 label *label161
-    * label *label162
   277 label *label163
   278 ubind @flare
-    * label *label164
   279 jump *label159 notEqual :findFreeUnit:first_unit @unit
-    * label *label165
   280 set *tmp15 null
   281 label *label166
   282 set :backgroundProcess:unit *tmp15
   283 jump *label167 notEqual *tmp15 null
   284 jump *label176 always
   285 label *label167
-    * label *label168
   286 label *label169
-    * label *label170
   287 # "Function: void serviceDrill(in drill, in unit)"
   288 ubind :backgroundProcess:unit
   289 sensor :serviceDrill:item @unit @firstItem
 
   302 ucontrol itemDrop @air 10
   303 label *label173
   304 label *label174
-    * label *label175
   305 label *label176
   306 set .units*4 :backgroundProcess:unit
   307 set :backgroundProcess:drill .titaniumDrills*5
   308 set :backgroundProcess:unit .units*5
-    * label *label179
   309 jump *label180 notEqual :backgroundProcess:drill null
   310 jump *label19 always
   311 label *label180
-    * label *label181
   312 sensor *tmp11 :backgroundProcess:drill @titanium
   313 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   314 sensor *tmp12 :backgroundProcess:unit @controller
 
   319 set *tmp15 null
   320 jump *label191 always
   321 label *label182
-    * label *label183
   322 set :findFreeUnit:first_unit @unit
   323 label *label184
   324 sensor *tmp18 @unit @controlled
 
   332 jump *label186 notEqual *tmp21 1
   333 set :findFreeUnit:first_unit @unit
   334 label *label186
-    * label *label187
   335 label *label188
   336 ubind @flare
-    * label *label189
   337 jump *label184 notEqual :findFreeUnit:first_unit @unit
-    * label *label190
   338 set *tmp15 null
   339 label *label191
   340 set :backgroundProcess:unit *tmp15
   341 jump *label192 notEqual *tmp15 null
   342 jump *label201 always
   343 label *label192
-    * label *label193
   344 label *label194
-    * label *label195
   345 # "Function: void serviceDrill(in drill, in unit)"
   346 ubind :backgroundProcess:unit
   347 sensor :serviceDrill:item @unit @firstItem
 
   360 ucontrol itemDrop @air 10
   361 label *label198
   362 label *label199
-    * label *label200
   363 label *label201
   364 set .units*5 :backgroundProcess:unit
   365 set :backgroundProcess:drill .titaniumDrills*6
   366 set :backgroundProcess:unit .units*6
-    * label *label204
   367 jump *label205 notEqual :backgroundProcess:drill null
   368 jump *label19 always
   369 label *label205
-    * label *label206
   370 sensor *tmp11 :backgroundProcess:drill @titanium
   371 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   372 sensor *tmp12 :backgroundProcess:unit @controller
 
   377 set *tmp15 null
   378 jump *label216 always
   379 label *label207
-    * label *label208
   380 set :findFreeUnit:first_unit @unit
   381 label *label209
   382 sensor *tmp18 @unit @controlled
 
   390 jump *label211 notEqual *tmp21 1
   391 set :findFreeUnit:first_unit @unit
   392 label *label211
-    * label *label212
   393 label *label213
   394 ubind @flare
-    * label *label214
   395 jump *label209 notEqual :findFreeUnit:first_unit @unit
-    * label *label215
   396 set *tmp15 null
   397 label *label216
   398 set :backgroundProcess:unit *tmp15
   399 jump *label217 notEqual *tmp15 null
   400 jump *label226 always
   401 label *label217
-    * label *label218
   402 label *label219
-    * label *label220
   403 # "Function: void serviceDrill(in drill, in unit)"
   404 ubind :backgroundProcess:unit
   405 sensor :serviceDrill:item @unit @firstItem
 
   418 ucontrol itemDrop @air 10
   419 label *label223
   420 label *label224
-    * label *label225
   421 label *label226
   422 set .units*6 :backgroundProcess:unit
   423 set :backgroundProcess:drill .titaniumDrills*7
   424 set :backgroundProcess:unit .units*7
-    * label *label229
   425 jump *label230 notEqual :backgroundProcess:drill null
   426 jump *label19 always
   427 label *label230
-    * label *label231
   428 sensor *tmp11 :backgroundProcess:drill @titanium
   429 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   430 sensor *tmp12 :backgroundProcess:unit @controller
 
   435 set *tmp15 null
   436 jump *label241 always
   437 label *label232
-    * label *label233
   438 set :findFreeUnit:first_unit @unit
   439 label *label234
   440 sensor *tmp18 @unit @controlled
 
   448 jump *label236 notEqual *tmp21 1
   449 set :findFreeUnit:first_unit @unit
   450 label *label236
-    * label *label237
   451 label *label238
   452 ubind @flare
-    * label *label239
   453 jump *label234 notEqual :findFreeUnit:first_unit @unit
-    * label *label240
   454 set *tmp15 null
   455 label *label241
   456 set :backgroundProcess:unit *tmp15
   457 jump *label242 notEqual *tmp15 null
   458 jump *label251 always
   459 label *label242
-    * label *label243
   460 label *label244
-    * label *label245
   461 # "Function: void serviceDrill(in drill, in unit)"
   462 ubind :backgroundProcess:unit
   463 sensor :serviceDrill:item @unit @firstItem
 
   476 ucontrol itemDrop @air 10
   477 label *label248
   478 label *label249
-    * label *label250
   479 label *label251
   480 set .units*7 :backgroundProcess:unit
   481 set :backgroundProcess:drill .titaniumDrills*8
   482 set :backgroundProcess:unit .units*8
-    * label *label254
   483 jump *label255 notEqual :backgroundProcess:drill null
   484 jump *label19 always
   485 label *label255
-    * label *label256
   486 sensor *tmp11 :backgroundProcess:drill @titanium
   487 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   488 sensor *tmp12 :backgroundProcess:unit @controller
 
   493 set *tmp15 null
   494 jump *label266 always
   495 label *label257
-    * label *label258
   496 set :findFreeUnit:first_unit @unit
   497 label *label259
   498 sensor *tmp18 @unit @controlled
 
   506 jump *label261 notEqual *tmp21 1
   507 set :findFreeUnit:first_unit @unit
   508 label *label261
-    * label *label262
   509 label *label263
   510 ubind @flare
-    * label *label264
   511 jump *label259 notEqual :findFreeUnit:first_unit @unit
-    * label *label265
   512 set *tmp15 null
   513 label *label266
   514 set :backgroundProcess:unit *tmp15
   515 jump *label267 notEqual *tmp15 null
   516 jump *label276 always
   517 label *label267
-    * label *label268
   518 label *label269
-    * label *label270
   519 # "Function: void serviceDrill(in drill, in unit)"
   520 ubind :backgroundProcess:unit
   521 sensor :serviceDrill:item @unit @firstItem
 
   534 ucontrol itemDrop @air 10
   535 label *label273
   536 label *label274
-    * label *label275
   537 label *label276
   538 set .units*8 :backgroundProcess:unit
   539 set :backgroundProcess:drill .titaniumDrills*9
   540 set :backgroundProcess:unit .units*9
-    * label *label279
   541 jump *label280 notEqual :backgroundProcess:drill null
   542 jump *label19 always
   543 label *label280
-    * label *label281
   544 sensor *tmp11 :backgroundProcess:drill @titanium
   545 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   546 sensor *tmp12 :backgroundProcess:unit @controller
 
   551 set *tmp15 null
   552 jump *label291 always
   553 label *label282
-    * label *label283
   554 set :findFreeUnit:first_unit @unit
   555 label *label284
   556 sensor *tmp18 @unit @controlled
 
   564 jump *label286 notEqual *tmp21 1
   565 set :findFreeUnit:first_unit @unit
   566 label *label286
-    * label *label287
   567 label *label288
   568 ubind @flare
-    * label *label289
   569 jump *label284 notEqual :findFreeUnit:first_unit @unit
-    * label *label290
   570 set *tmp15 null
   571 label *label291
   572 set :backgroundProcess:unit *tmp15
   573 jump *label292 notEqual *tmp15 null
   574 jump *label301 always
   575 label *label292
-    * label *label293
   576 label *label294
-    * label *label295
   577 # "Function: void serviceDrill(in drill, in unit)"
   578 ubind :backgroundProcess:unit
   579 sensor :serviceDrill:item @unit @firstItem
 
   592 ucontrol itemDrop @air 10
   593 label *label298
   594 label *label299
-    * label *label300
   595 label *label301
   596 set .units*9 :backgroundProcess:unit
   597 label *label19
   598 write :backgroundProcess:count processor1 ".titaniumDrillCount"
-    * label *label15
   599 jump *label14 always
-    * label *label16
-    * label *label8
   600 wait 1e12
   601 jump *label7 always
   602 end
 
   637 label *label305
   638 op add .drills .drills 1
   639 label *label52
-    * label *label53
-    * label *label51
   640 set :addTitaniumDrill*finished true
   641 jump *label7 always
   642 end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-20 instructions):
 
    16 set :backgroundProcess:count 0
    17 set :backgroundProcess:drill .titaniumDrills*0
    18 set :backgroundProcess:unit .units*0
-    * jump *label55 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+   19 jump *label19 equal :backgroundProcess:drill null
    20 label *label55
    21 sensor *tmp11 :backgroundProcess:drill @titanium
    22 set :backgroundProcess:count *tmp11
 
    47 set *tmp15 null
    48 label *label66
    49 set :backgroundProcess:unit *tmp15
-    * jump *label67 notEqual *tmp15 null
-    * jump *label76 always
+   50 jump *label76 equal *tmp15 null
    51 label *label67
    52 label *label69
    53 # "Function: void serviceDrill(in drill, in unit)"
 
    72 set .units*0 :backgroundProcess:unit
    73 set :backgroundProcess:drill .titaniumDrills*1
    74 set :backgroundProcess:unit .units*1
-    * jump *label80 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+   75 jump *label19 equal :backgroundProcess:drill null
    76 label *label80
    77 sensor *tmp11 :backgroundProcess:drill @titanium
    78 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   103 set *tmp15 null
   104 label *label91
   105 set :backgroundProcess:unit *tmp15
-    * jump *label92 notEqual *tmp15 null
-    * jump *label101 always
+  106 jump *label101 equal *tmp15 null
   107 label *label92
   108 label *label94
   109 # "Function: void serviceDrill(in drill, in unit)"
 
   128 set .units*1 :backgroundProcess:unit
   129 set :backgroundProcess:drill .titaniumDrills*2
   130 set :backgroundProcess:unit .units*2
-    * jump *label105 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  131 jump *label19 equal :backgroundProcess:drill null
   132 label *label105
   133 sensor *tmp11 :backgroundProcess:drill @titanium
   134 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   159 set *tmp15 null
   160 label *label116
   161 set :backgroundProcess:unit *tmp15
-    * jump *label117 notEqual *tmp15 null
-    * jump *label126 always
+  162 jump *label126 equal *tmp15 null
   163 label *label117
   164 label *label119
   165 # "Function: void serviceDrill(in drill, in unit)"
 
   184 set .units*2 :backgroundProcess:unit
   185 set :backgroundProcess:drill .titaniumDrills*3
   186 set :backgroundProcess:unit .units*3
-    * jump *label130 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  187 jump *label19 equal :backgroundProcess:drill null
   188 label *label130
   189 sensor *tmp11 :backgroundProcess:drill @titanium
   190 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   215 set *tmp15 null
   216 label *label141
   217 set :backgroundProcess:unit *tmp15
-    * jump *label142 notEqual *tmp15 null
-    * jump *label151 always
+  218 jump *label151 equal *tmp15 null
   219 label *label142
   220 label *label144
   221 # "Function: void serviceDrill(in drill, in unit)"
 
   240 set .units*3 :backgroundProcess:unit
   241 set :backgroundProcess:drill .titaniumDrills*4
   242 set :backgroundProcess:unit .units*4
-    * jump *label155 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  243 jump *label19 equal :backgroundProcess:drill null
   244 label *label155
   245 sensor *tmp11 :backgroundProcess:drill @titanium
   246 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   271 set *tmp15 null
   272 label *label166
   273 set :backgroundProcess:unit *tmp15
-    * jump *label167 notEqual *tmp15 null
-    * jump *label176 always
+  274 jump *label176 equal *tmp15 null
   275 label *label167
   276 label *label169
   277 # "Function: void serviceDrill(in drill, in unit)"
 
   296 set .units*4 :backgroundProcess:unit
   297 set :backgroundProcess:drill .titaniumDrills*5
   298 set :backgroundProcess:unit .units*5
-    * jump *label180 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  299 jump *label19 equal :backgroundProcess:drill null
   300 label *label180
   301 sensor *tmp11 :backgroundProcess:drill @titanium
   302 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   327 set *tmp15 null
   328 label *label191
   329 set :backgroundProcess:unit *tmp15
-    * jump *label192 notEqual *tmp15 null
-    * jump *label201 always
+  330 jump *label201 equal *tmp15 null
   331 label *label192
   332 label *label194
   333 # "Function: void serviceDrill(in drill, in unit)"
 
   352 set .units*5 :backgroundProcess:unit
   353 set :backgroundProcess:drill .titaniumDrills*6
   354 set :backgroundProcess:unit .units*6
-    * jump *label205 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  355 jump *label19 equal :backgroundProcess:drill null
   356 label *label205
   357 sensor *tmp11 :backgroundProcess:drill @titanium
   358 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   383 set *tmp15 null
   384 label *label216
   385 set :backgroundProcess:unit *tmp15
-    * jump *label217 notEqual *tmp15 null
-    * jump *label226 always
+  386 jump *label226 equal *tmp15 null
   387 label *label217
   388 label *label219
   389 # "Function: void serviceDrill(in drill, in unit)"
 
   408 set .units*6 :backgroundProcess:unit
   409 set :backgroundProcess:drill .titaniumDrills*7
   410 set :backgroundProcess:unit .units*7
-    * jump *label230 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  411 jump *label19 equal :backgroundProcess:drill null
   412 label *label230
   413 sensor *tmp11 :backgroundProcess:drill @titanium
   414 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   439 set *tmp15 null
   440 label *label241
   441 set :backgroundProcess:unit *tmp15
-    * jump *label242 notEqual *tmp15 null
-    * jump *label251 always
+  442 jump *label251 equal *tmp15 null
   443 label *label242
   444 label *label244
   445 # "Function: void serviceDrill(in drill, in unit)"
 
   464 set .units*7 :backgroundProcess:unit
   465 set :backgroundProcess:drill .titaniumDrills*8
   466 set :backgroundProcess:unit .units*8
-    * jump *label255 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  467 jump *label19 equal :backgroundProcess:drill null
   468 label *label255
   469 sensor *tmp11 :backgroundProcess:drill @titanium
   470 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   495 set *tmp15 null
   496 label *label266
   497 set :backgroundProcess:unit *tmp15
-    * jump *label267 notEqual *tmp15 null
-    * jump *label276 always
+  498 jump *label276 equal *tmp15 null
   499 label *label267
   500 label *label269
   501 # "Function: void serviceDrill(in drill, in unit)"
 
   520 set .units*8 :backgroundProcess:unit
   521 set :backgroundProcess:drill .titaniumDrills*9
   522 set :backgroundProcess:unit .units*9
-    * jump *label280 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  523 jump *label19 equal :backgroundProcess:drill null
   524 label *label280
   525 sensor *tmp11 :backgroundProcess:drill @titanium
   526 op add :backgroundProcess:count :backgroundProcess:count *tmp11
 
   551 set *tmp15 null
   552 label *label291
   553 set :backgroundProcess:unit *tmp15
-    * jump *label292 notEqual *tmp15 null
-    * jump *label301 always
+  554 jump *label301 equal *tmp15 null
   555 label *label292
   556 label *label294
   557 # "Function: void serviceDrill(in drill, in unit)"

Modifications by Jumps phase, Jump Optimization, pass 6, iteration 1:
 
    17 set :backgroundProcess:drill .titaniumDrills*0
    18 set :backgroundProcess:unit .units*0
    19 jump *label19 equal :backgroundProcess:drill null
-    * label *label55
    20 sensor *tmp11 :backgroundProcess:drill @titanium
    21 set :backgroundProcess:count *tmp11
    22 sensor *tmp12 :backgroundProcess:unit @controller
 
    47 label *label66
    48 set :backgroundProcess:unit *tmp15
    49 jump *label76 equal *tmp15 null
-    * label *label67
    50 label *label69
    51 # "Function: void serviceDrill(in drill, in unit)"
    52 ubind :backgroundProcess:unit
 
    71 set :backgroundProcess:drill .titaniumDrills*1
    72 set :backgroundProcess:unit .units*1
    73 jump *label19 equal :backgroundProcess:drill null
-    * label *label80
    74 sensor *tmp11 :backgroundProcess:drill @titanium
    75 op add :backgroundProcess:count :backgroundProcess:count *tmp11
    76 sensor *tmp12 :backgroundProcess:unit @controller
 
   101 label *label91
   102 set :backgroundProcess:unit *tmp15
   103 jump *label101 equal *tmp15 null
-    * label *label92
   104 label *label94
   105 # "Function: void serviceDrill(in drill, in unit)"
   106 ubind :backgroundProcess:unit
 
   125 set :backgroundProcess:drill .titaniumDrills*2
   126 set :backgroundProcess:unit .units*2
   127 jump *label19 equal :backgroundProcess:drill null
-    * label *label105
   128 sensor *tmp11 :backgroundProcess:drill @titanium
   129 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   130 sensor *tmp12 :backgroundProcess:unit @controller
 
   155 label *label116
   156 set :backgroundProcess:unit *tmp15
   157 jump *label126 equal *tmp15 null
-    * label *label117
   158 label *label119
   159 # "Function: void serviceDrill(in drill, in unit)"
   160 ubind :backgroundProcess:unit
 
   179 set :backgroundProcess:drill .titaniumDrills*3
   180 set :backgroundProcess:unit .units*3
   181 jump *label19 equal :backgroundProcess:drill null
-    * label *label130
   182 sensor *tmp11 :backgroundProcess:drill @titanium
   183 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   184 sensor *tmp12 :backgroundProcess:unit @controller
 
   209 label *label141
   210 set :backgroundProcess:unit *tmp15
   211 jump *label151 equal *tmp15 null
-    * label *label142
   212 label *label144
   213 # "Function: void serviceDrill(in drill, in unit)"
   214 ubind :backgroundProcess:unit
 
   233 set :backgroundProcess:drill .titaniumDrills*4
   234 set :backgroundProcess:unit .units*4
   235 jump *label19 equal :backgroundProcess:drill null
-    * label *label155
   236 sensor *tmp11 :backgroundProcess:drill @titanium
   237 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   238 sensor *tmp12 :backgroundProcess:unit @controller
 
   263 label *label166
   264 set :backgroundProcess:unit *tmp15
   265 jump *label176 equal *tmp15 null
-    * label *label167
   266 label *label169
   267 # "Function: void serviceDrill(in drill, in unit)"
   268 ubind :backgroundProcess:unit
 
   287 set :backgroundProcess:drill .titaniumDrills*5
   288 set :backgroundProcess:unit .units*5
   289 jump *label19 equal :backgroundProcess:drill null
-    * label *label180
   290 sensor *tmp11 :backgroundProcess:drill @titanium
   291 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   292 sensor *tmp12 :backgroundProcess:unit @controller
 
   317 label *label191
   318 set :backgroundProcess:unit *tmp15
   319 jump *label201 equal *tmp15 null
-    * label *label192
   320 label *label194
   321 # "Function: void serviceDrill(in drill, in unit)"
   322 ubind :backgroundProcess:unit
 
   341 set :backgroundProcess:drill .titaniumDrills*6
   342 set :backgroundProcess:unit .units*6
   343 jump *label19 equal :backgroundProcess:drill null
-    * label *label205
   344 sensor *tmp11 :backgroundProcess:drill @titanium
   345 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   346 sensor *tmp12 :backgroundProcess:unit @controller
 
   371 label *label216
   372 set :backgroundProcess:unit *tmp15
   373 jump *label226 equal *tmp15 null
-    * label *label217
   374 label *label219
   375 # "Function: void serviceDrill(in drill, in unit)"
   376 ubind :backgroundProcess:unit
 
   395 set :backgroundProcess:drill .titaniumDrills*7
   396 set :backgroundProcess:unit .units*7
   397 jump *label19 equal :backgroundProcess:drill null
-    * label *label230
   398 sensor *tmp11 :backgroundProcess:drill @titanium
   399 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   400 sensor *tmp12 :backgroundProcess:unit @controller
 
   425 label *label241
   426 set :backgroundProcess:unit *tmp15
   427 jump *label251 equal *tmp15 null
-    * label *label242
   428 label *label244
   429 # "Function: void serviceDrill(in drill, in unit)"
   430 ubind :backgroundProcess:unit
 
   449 set :backgroundProcess:drill .titaniumDrills*8
   450 set :backgroundProcess:unit .units*8
   451 jump *label19 equal :backgroundProcess:drill null
-    * label *label255
   452 sensor *tmp11 :backgroundProcess:drill @titanium
   453 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   454 sensor *tmp12 :backgroundProcess:unit @controller
 
   479 label *label266
   480 set :backgroundProcess:unit *tmp15
   481 jump *label276 equal *tmp15 null
-    * label *label267
   482 label *label269
   483 # "Function: void serviceDrill(in drill, in unit)"
   484 ubind :backgroundProcess:unit
 
   503 set :backgroundProcess:drill .titaniumDrills*9
   504 set :backgroundProcess:unit .units*9
   505 jump *label19 equal :backgroundProcess:drill null
-    * label *label280
   506 sensor *tmp11 :backgroundProcess:drill @titanium
   507 op add :backgroundProcess:count :backgroundProcess:count *tmp11
   508 sensor *tmp12 :backgroundProcess:unit @controller
 
   533 label *label291
   534 set :backgroundProcess:unit *tmp15
   535 jump *label301 equal *tmp15 null
-    * label *label292
   536 label *label294
   537 # "Function: void serviceDrill(in drill, in unit)"
   538 ubind :backgroundProcess:unit

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-14 instructions):
 
    34 ucontrol flag 0
    35 set *tmp15 @unit
    36 jump *label66 always
-    * jump *label63 always
    37 label *label60
    38 sensor *tmp21 :findFreeUnit:first_unit @dead
    39 jump *label61 notEqual *tmp21 1
 
    87 ucontrol flag 0
    88 set *tmp15 @unit
    89 jump *label91 always
-    * jump *label88 always
    90 label *label85
    91 sensor *tmp21 :findFreeUnit:first_unit @dead
    92 jump *label86 notEqual *tmp21 1
 
   140 ucontrol flag 0
   141 set *tmp15 @unit
   142 jump *label116 always
-    * jump *label113 always
   143 label *label110
   144 sensor *tmp21 :findFreeUnit:first_unit @dead
   145 jump *label111 notEqual *tmp21 1
 
   193 ucontrol flag 0
   194 set *tmp15 @unit
   195 jump *label141 always
-    * jump *label138 always
   196 label *label135
   197 sensor *tmp21 :findFreeUnit:first_unit @dead
   198 jump *label136 notEqual *tmp21 1
 
   246 ucontrol flag 0
   247 set *tmp15 @unit
   248 jump *label166 always
-    * jump *label163 always
   249 label *label160
   250 sensor *tmp21 :findFreeUnit:first_unit @dead
   251 jump *label161 notEqual *tmp21 1
 
   299 ucontrol flag 0
   300 set *tmp15 @unit
   301 jump *label191 always
-    * jump *label188 always
   302 label *label185
   303 sensor *tmp21 :findFreeUnit:first_unit @dead
   304 jump *label186 notEqual *tmp21 1
 
   352 ucontrol flag 0
   353 set *tmp15 @unit
   354 jump *label216 always
-    * jump *label213 always
   355 label *label210
   356 sensor *tmp21 :findFreeUnit:first_unit @dead
   357 jump *label211 notEqual *tmp21 1
 
   405 ucontrol flag 0
   406 set *tmp15 @unit
   407 jump *label241 always
-    * jump *label238 always
   408 label *label235
   409 sensor *tmp21 :findFreeUnit:first_unit @dead
   410 jump *label236 notEqual *tmp21 1
 
   458 ucontrol flag 0
   459 set *tmp15 @unit
   460 jump *label266 always
-    * jump *label263 always
   461 label *label260
   462 sensor *tmp21 :findFreeUnit:first_unit @dead
   463 jump *label261 notEqual *tmp21 1
 
   511 ucontrol flag 0
   512 set *tmp15 @unit
   513 jump *label291 always
-    * jump *label288 always
   514 label *label285
   515 sensor *tmp21 :findFreeUnit:first_unit @dead
   516 jump *label286 notEqual *tmp21 1
 
   547 label *label19
   548 write :backgroundProcess:count processor1 ".titaniumDrillCount"
   549 jump *label14 always
-    * wait 1e12
-    * jump *label7 always
-    * end
   550 label *label0
   551 # "Function: remote void addTitaniumDrill(in drill)"
   552 jump *label52 greaterThanEq .drills 9
 
   586 label *label52
   587 set :addTitaniumDrill*finished true
   588 jump *label7 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 6, iteration 1:
 
    39 jump *label61 notEqual *tmp21 1
    40 set :findFreeUnit:first_unit @unit
    41 label *label61
-    * label *label63
    42 ubind @flare
    43 jump *label59 notEqual :findFreeUnit:first_unit @unit
    44 set *tmp15 null
 
    91 jump *label86 notEqual *tmp21 1
    92 set :findFreeUnit:first_unit @unit
    93 label *label86
-    * label *label88
    94 ubind @flare
    95 jump *label84 notEqual :findFreeUnit:first_unit @unit
    96 set *tmp15 null
 
   143 jump *label111 notEqual *tmp21 1
   144 set :findFreeUnit:first_unit @unit
   145 label *label111
-    * label *label113
   146 ubind @flare
   147 jump *label109 notEqual :findFreeUnit:first_unit @unit
   148 set *tmp15 null
 
   195 jump *label136 notEqual *tmp21 1
   196 set :findFreeUnit:first_unit @unit
   197 label *label136
-    * label *label138
   198 ubind @flare
   199 jump *label134 notEqual :findFreeUnit:first_unit @unit
   200 set *tmp15 null
 
   247 jump *label161 notEqual *tmp21 1
   248 set :findFreeUnit:first_unit @unit
   249 label *label161
-    * label *label163
   250 ubind @flare
   251 jump *label159 notEqual :findFreeUnit:first_unit @unit
   252 set *tmp15 null
 
   299 jump *label186 notEqual *tmp21 1
   300 set :findFreeUnit:first_unit @unit
   301 label *label186
-    * label *label188
   302 ubind @flare
   303 jump *label184 notEqual :findFreeUnit:first_unit @unit
   304 set *tmp15 null
 
   351 jump *label211 notEqual *tmp21 1
   352 set :findFreeUnit:first_unit @unit
   353 label *label211
-    * label *label213
   354 ubind @flare
   355 jump *label209 notEqual :findFreeUnit:first_unit @unit
   356 set *tmp15 null
 
   403 jump *label236 notEqual *tmp21 1
   404 set :findFreeUnit:first_unit @unit
   405 label *label236
-    * label *label238
   406 ubind @flare
   407 jump *label234 notEqual :findFreeUnit:first_unit @unit
   408 set *tmp15 null
 
   455 jump *label261 notEqual *tmp21 1
   456 set :findFreeUnit:first_unit @unit
   457 label *label261
-    * label *label263
   458 ubind @flare
   459 jump *label259 notEqual :findFreeUnit:first_unit @unit
   460 set *tmp15 null
 
   507 jump *label286 notEqual *tmp21 1
   508 set :findFreeUnit:first_unit @unit
   509 label *label286
-    * label *label288
   510 ubind @flare
   511 jump *label284 notEqual :findFreeUnit:first_unit @unit
   512 set *tmp15 null

Final code before resolving virtual instructions:

    0:  jump *label6 always 0 0                                      #set target = 8;
    1:  jump *label0 always 0 0                                      ...
        label *label6                                                ...
    2:  set .drills 0                                                volatile var drills = 0;
    3:  set *signature "881dde114374c003:v1"                         #set target = 8;
        label *label7                                                ...
        # "Function: void backgroundProcess()"                       ...
    4:  jump *label9 notEqual .core null                             if core == null then
        label *label11                                               do
    5:  ubind @flare                                                 ubind(@flare);
    6:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
    7:  jump *label11 equal .core null                               do
    8:  sensor .coreX .core @x                                       coreX = core.@x;
    9:  sensor .coreY .core @y                                       coreY = core.@y;
        label *label9                                                if core == null then
        label *label14                                               while true do
   10:  set :backgroundProcess:count 0                               var count = 0;
   11:  set :backgroundProcess:drill .titaniumDrills*0               for var drill in titaniumDrills; var out unit in units do
   12:  set :backgroundProcess:unit .units*0                         ...
   13:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
   14:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
   15:  set :backgroundProcess:count *tmp11                          ...
   16:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
   17:  jump *label69 equal *tmp12 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
   18:  ubind @flare                                                 *units: ubind(unit_type);
   19:  jump *label57 notEqual @unit null                            *units: if @unit == null then return null; end;
   20:  set *tmp15 null                                              ...
   21:  jump *label66 always 0 0                                     ...
        label *label57                                               ...
   22:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label59                                               *units: do
   23:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
   24:  jump *label60 notEqual *tmp18 0                              ...
   25:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   26:  set *tmp15 @unit                                             *units: return @unit;
   27:  jump *label66 always 0 0                                     ...
        label *label60                                               *units: if @unit.@controlled == 0 then
   28:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   29:  jump *label61 notEqual *tmp21 1                              ...
   30:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label61                                               *units: elsif first_unit.@dead == 1 then
   31:  ubind @flare                                                 *units: ubind(unit_type);
   32:  jump *label59 notEqual :findFreeUnit:first_unit @unit        *units: do
   33:  set *tmp15 null                                              *units: return null;
        label *label66                                               unit = findFreeUnit(@flare, 0);
   34:  set :backgroundProcess:unit *tmp15                           ...
   35:  jump *label76 equal *tmp15 null                              if unit == null then continue; end;
        label *label69                                               if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
   36:  ubind :backgroundProcess:unit                                ubind(unit);
   37:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
   38:  jump *label71 notEqual :serviceDrill:item @titanium          if item == @titanium then
   39:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
   40:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
   41:  jump *label74 always 0 0                                     if item == @titanium then
        label *label71                                               ...
   42:  jump *label72 notEqual :serviceDrill:item null               elsif item == null then
   43:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
   44:  sensor *tmp34 :backgroundProcess:drill @y                    ...
   45:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
   46:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
   47:  jump *label73 always 0 0                                     elsif item == null then
        label *label72                                               ...
   48:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label73                                               elsif item == null then
        label *label74                                               if item == @titanium then
        label *label76                                               for var drill in titaniumDrills; var out unit in units do
   49:  set .units*0 :backgroundProcess:unit                         ...
   50:  set :backgroundProcess:drill .titaniumDrills*1               ...
   51:  set :backgroundProcess:unit .units*1                         ...
   52:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
   53:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
   54:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
   55:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
   56:  jump *label94 equal *tmp12 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
   57:  ubind @flare                                                 *units: ubind(unit_type);
   58:  jump *label82 notEqual @unit null                            *units: if @unit == null then return null; end;
   59:  set *tmp15 null                                              ...
   60:  jump *label91 always 0 0                                     ...
        label *label82                                               ...
   61:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label84                                               *units: do
   62:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
   63:  jump *label85 notEqual *tmp18 0                              ...
   64:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   65:  set *tmp15 @unit                                             *units: return @unit;
   66:  jump *label91 always 0 0                                     ...
        label *label85                                               *units: if @unit.@controlled == 0 then
   67:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   68:  jump *label86 notEqual *tmp21 1                              ...
   69:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label86                                               *units: elsif first_unit.@dead == 1 then
   70:  ubind @flare                                                 *units: ubind(unit_type);
   71:  jump *label84 notEqual :findFreeUnit:first_unit @unit        *units: do
   72:  set *tmp15 null                                              *units: return null;
        label *label91                                               unit = findFreeUnit(@flare, 0);
   73:  set :backgroundProcess:unit *tmp15                           ...
   74:  jump *label101 equal *tmp15 null                             if unit == null then continue; end;
        label *label94                                               if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
   75:  ubind :backgroundProcess:unit                                ubind(unit);
   76:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
   77:  jump *label96 notEqual :serviceDrill:item @titanium          if item == @titanium then
   78:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
   79:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
   80:  jump *label99 always 0 0                                     if item == @titanium then
        label *label96                                               ...
   81:  jump *label97 notEqual :serviceDrill:item null               elsif item == null then
   82:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
   83:  sensor *tmp34 :backgroundProcess:drill @y                    ...
   84:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
   85:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
   86:  jump *label98 always 0 0                                     elsif item == null then
        label *label97                                               ...
   87:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label98                                               elsif item == null then
        label *label99                                               if item == @titanium then
        label *label101                                              for var drill in titaniumDrills; var out unit in units do
   88:  set .units*1 :backgroundProcess:unit                         ...
   89:  set :backgroundProcess:drill .titaniumDrills*2               ...
   90:  set :backgroundProcess:unit .units*2                         ...
   91:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
   92:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
   93:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
   94:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
   95:  jump *label119 equal *tmp12 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
   96:  ubind @flare                                                 *units: ubind(unit_type);
   97:  jump *label107 notEqual @unit null                           *units: if @unit == null then return null; end;
   98:  set *tmp15 null                                              ...
   99:  jump *label116 always 0 0                                    ...
        label *label107                                              ...
  100:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label109                                              *units: do
  101:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
  102:  jump *label110 notEqual *tmp18 0                             ...
  103:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  104:  set *tmp15 @unit                                             *units: return @unit;
  105:  jump *label116 always 0 0                                    ...
        label *label110                                              *units: if @unit.@controlled == 0 then
  106:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  107:  jump *label111 notEqual *tmp21 1                             ...
  108:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label111                                              *units: elsif first_unit.@dead == 1 then
  109:  ubind @flare                                                 *units: ubind(unit_type);
  110:  jump *label109 notEqual :findFreeUnit:first_unit @unit       *units: do
  111:  set *tmp15 null                                              *units: return null;
        label *label116                                              unit = findFreeUnit(@flare, 0);
  112:  set :backgroundProcess:unit *tmp15                           ...
  113:  jump *label126 equal *tmp15 null                             if unit == null then continue; end;
        label *label119                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  114:  ubind :backgroundProcess:unit                                ubind(unit);
  115:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  116:  jump *label121 notEqual :serviceDrill:item @titanium         if item == @titanium then
  117:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  118:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  119:  jump *label124 always 0 0                                    if item == @titanium then
        label *label121                                              ...
  120:  jump *label122 notEqual :serviceDrill:item null              elsif item == null then
  121:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  122:  sensor *tmp34 :backgroundProcess:drill @y                    ...
  123:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
  124:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  125:  jump *label123 always 0 0                                    elsif item == null then
        label *label122                                              ...
  126:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label123                                              elsif item == null then
        label *label124                                              if item == @titanium then
        label *label126                                              for var drill in titaniumDrills; var out unit in units do
  127:  set .units*2 :backgroundProcess:unit                         ...
  128:  set :backgroundProcess:drill .titaniumDrills*3               ...
  129:  set :backgroundProcess:unit .units*3                         ...
  130:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
  131:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
  132:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  133:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
  134:  jump *label144 equal *tmp12 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  135:  ubind @flare                                                 *units: ubind(unit_type);
  136:  jump *label132 notEqual @unit null                           *units: if @unit == null then return null; end;
  137:  set *tmp15 null                                              ...
  138:  jump *label141 always 0 0                                    ...
        label *label132                                              ...
  139:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label134                                              *units: do
  140:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
  141:  jump *label135 notEqual *tmp18 0                             ...
  142:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  143:  set *tmp15 @unit                                             *units: return @unit;
  144:  jump *label141 always 0 0                                    ...
        label *label135                                              *units: if @unit.@controlled == 0 then
  145:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  146:  jump *label136 notEqual *tmp21 1                             ...
  147:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label136                                              *units: elsif first_unit.@dead == 1 then
  148:  ubind @flare                                                 *units: ubind(unit_type);
  149:  jump *label134 notEqual :findFreeUnit:first_unit @unit       *units: do
  150:  set *tmp15 null                                              *units: return null;
        label *label141                                              unit = findFreeUnit(@flare, 0);
  151:  set :backgroundProcess:unit *tmp15                           ...
  152:  jump *label151 equal *tmp15 null                             if unit == null then continue; end;
        label *label144                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  153:  ubind :backgroundProcess:unit                                ubind(unit);
  154:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  155:  jump *label146 notEqual :serviceDrill:item @titanium         if item == @titanium then
  156:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  157:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  158:  jump *label149 always 0 0                                    if item == @titanium then
        label *label146                                              ...
  159:  jump *label147 notEqual :serviceDrill:item null              elsif item == null then
  160:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  161:  sensor *tmp34 :backgroundProcess:drill @y                    ...
  162:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
  163:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  164:  jump *label148 always 0 0                                    elsif item == null then
        label *label147                                              ...
  165:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label148                                              elsif item == null then
        label *label149                                              if item == @titanium then
        label *label151                                              for var drill in titaniumDrills; var out unit in units do
  166:  set .units*3 :backgroundProcess:unit                         ...
  167:  set :backgroundProcess:drill .titaniumDrills*4               ...
  168:  set :backgroundProcess:unit .units*4                         ...
  169:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
  170:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
  171:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  172:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
  173:  jump *label169 equal *tmp12 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  174:  ubind @flare                                                 *units: ubind(unit_type);
  175:  jump *label157 notEqual @unit null                           *units: if @unit == null then return null; end;
  176:  set *tmp15 null                                              ...
  177:  jump *label166 always 0 0                                    ...
        label *label157                                              ...
  178:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label159                                              *units: do
  179:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
  180:  jump *label160 notEqual *tmp18 0                             ...
  181:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  182:  set *tmp15 @unit                                             *units: return @unit;
  183:  jump *label166 always 0 0                                    ...
        label *label160                                              *units: if @unit.@controlled == 0 then
  184:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  185:  jump *label161 notEqual *tmp21 1                             ...
  186:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label161                                              *units: elsif first_unit.@dead == 1 then
  187:  ubind @flare                                                 *units: ubind(unit_type);
  188:  jump *label159 notEqual :findFreeUnit:first_unit @unit       *units: do
  189:  set *tmp15 null                                              *units: return null;
        label *label166                                              unit = findFreeUnit(@flare, 0);
  190:  set :backgroundProcess:unit *tmp15                           ...
  191:  jump *label176 equal *tmp15 null                             if unit == null then continue; end;
        label *label169                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  192:  ubind :backgroundProcess:unit                                ubind(unit);
  193:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  194:  jump *label171 notEqual :serviceDrill:item @titanium         if item == @titanium then
  195:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  196:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  197:  jump *label174 always 0 0                                    if item == @titanium then
        label *label171                                              ...
  198:  jump *label172 notEqual :serviceDrill:item null              elsif item == null then
  199:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  200:  sensor *tmp34 :backgroundProcess:drill @y                    ...
  201:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
  202:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  203:  jump *label173 always 0 0                                    elsif item == null then
        label *label172                                              ...
  204:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label173                                              elsif item == null then
        label *label174                                              if item == @titanium then
        label *label176                                              for var drill in titaniumDrills; var out unit in units do
  205:  set .units*4 :backgroundProcess:unit                         ...
  206:  set :backgroundProcess:drill .titaniumDrills*5               ...
  207:  set :backgroundProcess:unit .units*5                         ...
  208:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
  209:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
  210:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  211:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
  212:  jump *label194 equal *tmp12 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  213:  ubind @flare                                                 *units: ubind(unit_type);
  214:  jump *label182 notEqual @unit null                           *units: if @unit == null then return null; end;
  215:  set *tmp15 null                                              ...
  216:  jump *label191 always 0 0                                    ...
        label *label182                                              ...
  217:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label184                                              *units: do
  218:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
  219:  jump *label185 notEqual *tmp18 0                             ...
  220:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  221:  set *tmp15 @unit                                             *units: return @unit;
  222:  jump *label191 always 0 0                                    ...
        label *label185                                              *units: if @unit.@controlled == 0 then
  223:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  224:  jump *label186 notEqual *tmp21 1                             ...
  225:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label186                                              *units: elsif first_unit.@dead == 1 then
  226:  ubind @flare                                                 *units: ubind(unit_type);
  227:  jump *label184 notEqual :findFreeUnit:first_unit @unit       *units: do
  228:  set *tmp15 null                                              *units: return null;
        label *label191                                              unit = findFreeUnit(@flare, 0);
  229:  set :backgroundProcess:unit *tmp15                           ...
  230:  jump *label201 equal *tmp15 null                             if unit == null then continue; end;
        label *label194                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  231:  ubind :backgroundProcess:unit                                ubind(unit);
  232:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  233:  jump *label196 notEqual :serviceDrill:item @titanium         if item == @titanium then
  234:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  235:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  236:  jump *label199 always 0 0                                    if item == @titanium then
        label *label196                                              ...
  237:  jump *label197 notEqual :serviceDrill:item null              elsif item == null then
  238:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  239:  sensor *tmp34 :backgroundProcess:drill @y                    ...
  240:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
  241:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  242:  jump *label198 always 0 0                                    elsif item == null then
        label *label197                                              ...
  243:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label198                                              elsif item == null then
        label *label199                                              if item == @titanium then
        label *label201                                              for var drill in titaniumDrills; var out unit in units do
  244:  set .units*5 :backgroundProcess:unit                         ...
  245:  set :backgroundProcess:drill .titaniumDrills*6               ...
  246:  set :backgroundProcess:unit .units*6                         ...
  247:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
  248:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
  249:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  250:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
  251:  jump *label219 equal *tmp12 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  252:  ubind @flare                                                 *units: ubind(unit_type);
  253:  jump *label207 notEqual @unit null                           *units: if @unit == null then return null; end;
  254:  set *tmp15 null                                              ...
  255:  jump *label216 always 0 0                                    ...
        label *label207                                              ...
  256:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label209                                              *units: do
  257:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
  258:  jump *label210 notEqual *tmp18 0                             ...
  259:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  260:  set *tmp15 @unit                                             *units: return @unit;
  261:  jump *label216 always 0 0                                    ...
        label *label210                                              *units: if @unit.@controlled == 0 then
  262:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  263:  jump *label211 notEqual *tmp21 1                             ...
  264:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label211                                              *units: elsif first_unit.@dead == 1 then
  265:  ubind @flare                                                 *units: ubind(unit_type);
  266:  jump *label209 notEqual :findFreeUnit:first_unit @unit       *units: do
  267:  set *tmp15 null                                              *units: return null;
        label *label216                                              unit = findFreeUnit(@flare, 0);
  268:  set :backgroundProcess:unit *tmp15                           ...
  269:  jump *label226 equal *tmp15 null                             if unit == null then continue; end;
        label *label219                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  270:  ubind :backgroundProcess:unit                                ubind(unit);
  271:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  272:  jump *label221 notEqual :serviceDrill:item @titanium         if item == @titanium then
  273:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  274:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  275:  jump *label224 always 0 0                                    if item == @titanium then
        label *label221                                              ...
  276:  jump *label222 notEqual :serviceDrill:item null              elsif item == null then
  277:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  278:  sensor *tmp34 :backgroundProcess:drill @y                    ...
  279:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
  280:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  281:  jump *label223 always 0 0                                    elsif item == null then
        label *label222                                              ...
  282:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label223                                              elsif item == null then
        label *label224                                              if item == @titanium then
        label *label226                                              for var drill in titaniumDrills; var out unit in units do
  283:  set .units*6 :backgroundProcess:unit                         ...
  284:  set :backgroundProcess:drill .titaniumDrills*7               ...
  285:  set :backgroundProcess:unit .units*7                         ...
  286:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
  287:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
  288:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  289:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
  290:  jump *label244 equal *tmp12 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  291:  ubind @flare                                                 *units: ubind(unit_type);
  292:  jump *label232 notEqual @unit null                           *units: if @unit == null then return null; end;
  293:  set *tmp15 null                                              ...
  294:  jump *label241 always 0 0                                    ...
        label *label232                                              ...
  295:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label234                                              *units: do
  296:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
  297:  jump *label235 notEqual *tmp18 0                             ...
  298:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  299:  set *tmp15 @unit                                             *units: return @unit;
  300:  jump *label241 always 0 0                                    ...
        label *label235                                              *units: if @unit.@controlled == 0 then
  301:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  302:  jump *label236 notEqual *tmp21 1                             ...
  303:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label236                                              *units: elsif first_unit.@dead == 1 then
  304:  ubind @flare                                                 *units: ubind(unit_type);
  305:  jump *label234 notEqual :findFreeUnit:first_unit @unit       *units: do
  306:  set *tmp15 null                                              *units: return null;
        label *label241                                              unit = findFreeUnit(@flare, 0);
  307:  set :backgroundProcess:unit *tmp15                           ...
  308:  jump *label251 equal *tmp15 null                             if unit == null then continue; end;
        label *label244                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  309:  ubind :backgroundProcess:unit                                ubind(unit);
  310:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  311:  jump *label246 notEqual :serviceDrill:item @titanium         if item == @titanium then
  312:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  313:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  314:  jump *label249 always 0 0                                    if item == @titanium then
        label *label246                                              ...
  315:  jump *label247 notEqual :serviceDrill:item null              elsif item == null then
  316:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  317:  sensor *tmp34 :backgroundProcess:drill @y                    ...
  318:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
  319:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  320:  jump *label248 always 0 0                                    elsif item == null then
        label *label247                                              ...
  321:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label248                                              elsif item == null then
        label *label249                                              if item == @titanium then
        label *label251                                              for var drill in titaniumDrills; var out unit in units do
  322:  set .units*7 :backgroundProcess:unit                         ...
  323:  set :backgroundProcess:drill .titaniumDrills*8               ...
  324:  set :backgroundProcess:unit .units*8                         ...
  325:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
  326:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
  327:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  328:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
  329:  jump *label269 equal *tmp12 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  330:  ubind @flare                                                 *units: ubind(unit_type);
  331:  jump *label257 notEqual @unit null                           *units: if @unit == null then return null; end;
  332:  set *tmp15 null                                              ...
  333:  jump *label266 always 0 0                                    ...
        label *label257                                              ...
  334:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label259                                              *units: do
  335:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
  336:  jump *label260 notEqual *tmp18 0                             ...
  337:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  338:  set *tmp15 @unit                                             *units: return @unit;
  339:  jump *label266 always 0 0                                    ...
        label *label260                                              *units: if @unit.@controlled == 0 then
  340:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  341:  jump *label261 notEqual *tmp21 1                             ...
  342:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label261                                              *units: elsif first_unit.@dead == 1 then
  343:  ubind @flare                                                 *units: ubind(unit_type);
  344:  jump *label259 notEqual :findFreeUnit:first_unit @unit       *units: do
  345:  set *tmp15 null                                              *units: return null;
        label *label266                                              unit = findFreeUnit(@flare, 0);
  346:  set :backgroundProcess:unit *tmp15                           ...
  347:  jump *label276 equal *tmp15 null                             if unit == null then continue; end;
        label *label269                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  348:  ubind :backgroundProcess:unit                                ubind(unit);
  349:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  350:  jump *label271 notEqual :serviceDrill:item @titanium         if item == @titanium then
  351:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  352:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  353:  jump *label274 always 0 0                                    if item == @titanium then
        label *label271                                              ...
  354:  jump *label272 notEqual :serviceDrill:item null              elsif item == null then
  355:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  356:  sensor *tmp34 :backgroundProcess:drill @y                    ...
  357:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
  358:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  359:  jump *label273 always 0 0                                    elsif item == null then
        label *label272                                              ...
  360:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label273                                              elsif item == null then
        label *label274                                              if item == @titanium then
        label *label276                                              for var drill in titaniumDrills; var out unit in units do
  361:  set .units*8 :backgroundProcess:unit                         ...
  362:  set :backgroundProcess:drill .titaniumDrills*9               ...
  363:  set :backgroundProcess:unit .units*9                         ...
  364:  jump *label19 equal :backgroundProcess:drill null            if drill == null then break; end;
  365:  sensor *tmp11 :backgroundProcess:drill @titanium             count += drill.@titanium;
  366:  op add :backgroundProcess:count :backgroundProcess:count *tm ...
  367:  sensor *tmp12 :backgroundProcess:unit @controller            if unit.@controller != @this then
  368:  jump *label294 equal *tmp12 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  369:  ubind @flare                                                 *units: ubind(unit_type);
  370:  jump *label282 notEqual @unit null                           *units: if @unit == null then return null; end;
  371:  set *tmp15 null                                              ...
  372:  jump *label291 always 0 0                                    ...
        label *label282                                              ...
  373:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label284                                              *units: do
  374:  sensor *tmp18 @unit @controlled                              *units: if @unit.@controlled == 0 then
  375:  jump *label285 notEqual *tmp18 0                             ...
  376:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  377:  set *tmp15 @unit                                             *units: return @unit;
  378:  jump *label291 always 0 0                                    ...
        label *label285                                              *units: if @unit.@controlled == 0 then
  379:  sensor *tmp21 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  380:  jump *label286 notEqual *tmp21 1                             ...
  381:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label286                                              *units: elsif first_unit.@dead == 1 then
  382:  ubind @flare                                                 *units: ubind(unit_type);
  383:  jump *label284 notEqual :findFreeUnit:first_unit @unit       *units: do
  384:  set *tmp15 null                                              *units: return null;
        label *label291                                              unit = findFreeUnit(@flare, 0);
  385:  set :backgroundProcess:unit *tmp15                           ...
  386:  jump *label301 equal *tmp15 null                             if unit == null then continue; end;
        label *label294                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  387:  ubind :backgroundProcess:unit                                ubind(unit);
  388:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  389:  jump *label296 notEqual :serviceDrill:item @titanium         if item == @titanium then
  390:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  391:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  392:  jump *label299 always 0 0                                    if item == @titanium then
        label *label296                                              ...
  393:  jump *label297 notEqual :serviceDrill:item null              elsif item == null then
  394:  sensor *tmp33 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  395:  sensor *tmp34 :backgroundProcess:drill @y                    ...
  396:  ucontrol approach *tmp33 *tmp34 4 0 0                        ...
  397:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  398:  jump *label298 always 0 0                                    elsif item == null then
        label *label297                                              ...
  399:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label298                                              elsif item == null then
        label *label299                                              if item == @titanium then
        label *label301                                              for var drill in titaniumDrills; var out unit in units do
  400:  set .units*9 :backgroundProcess:unit                         ...
        label *label19                                               ...
  401:  write :backgroundProcess:count processor1 ".titaniumDrillCou titaniumDrillCount = count;
  402:  jump *label14 always 0 0                                     while true do
        label *label0                                                remote void addTitaniumDrill(drill)
        # "Function: remote void addTitaniumDrill(in drill)"         ...
  403:  jump *label52 greaterThanEq .drills 9                        if drills < length(titaniumDrills) - 1 then
  404:  op mul *tmp40 .drills 2                                      titaniumDrills[drills] = drill;
  405:  multijump *label306 *tmp40 0                                 ...
        multilabel *label306                                         ...
  406:  set .titaniumDrills*0 :addTitaniumDrill:drill                ...
  407:  jump *label305 always 0 0                                    ...
        multilabel *label307                                         ...
  408:  set .titaniumDrills*1 :addTitaniumDrill:drill                ...
  409:  jump *label305 always 0 0                                    ...
        multilabel *label308                                         ...
  410:  set .titaniumDrills*2 :addTitaniumDrill:drill                ...
  411:  jump *label305 always 0 0                                    ...
        multilabel *label309                                         ...
  412:  set .titaniumDrills*3 :addTitaniumDrill:drill                ...
  413:  jump *label305 always 0 0                                    ...
        multilabel *label310                                         ...
  414:  set .titaniumDrills*4 :addTitaniumDrill:drill                ...
  415:  jump *label305 always 0 0                                    ...
        multilabel *label311                                         ...
  416:  set .titaniumDrills*5 :addTitaniumDrill:drill                ...
  417:  jump *label305 always 0 0                                    ...
        multilabel *label312                                         ...
  418:  set .titaniumDrills*6 :addTitaniumDrill:drill                ...
  419:  jump *label305 always 0 0                                    ...
        multilabel *label313                                         ...
  420:  set .titaniumDrills*7 :addTitaniumDrill:drill                ...
  421:  jump *label305 always 0 0                                    ...
        multilabel *label314                                         ...
  422:  set .titaniumDrills*8 :addTitaniumDrill:drill                ...
  423:  jump *label305 always 0 0                                    ...
        multilabel *label315                                         ...
  424:  set .titaniumDrills*9 :addTitaniumDrill:drill                ...
        label *label305                                              ...
  425:  op add .drills .drills 1                                     if drills < length(titaniumDrills) - 1 then
        label *label52                                               ...
  426:  set :addTitaniumDrill*finished true                          remote void addTitaniumDrill(drill)
  427:  jump *label7 always 0 0                                      ...


Performance: parsed in 332 ms, compiled in 366 ms, optimized in 598 ms, run in 25 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (5 steps):
The program didn't generate any output.
Execution exception at instruction 5: ubind @flare:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
