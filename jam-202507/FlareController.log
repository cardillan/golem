   184 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (2 iterations).
    21 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (7 iterations).
    12 instructions eliminated by Jump Optimization (7 iterations).
    18 instructions eliminated by Single Step Elimination (3 passes, 10 iterations).
     5 instructions eliminated by Data Flow Optimization (9 iterations).
   322 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
     1 jump tables inlined by Array Optimization.
    20 instructions eliminated by Jump Straightening (7 iterations).
    10 instructions updated by JumpThreading.
    14 instructions eliminated by Unreachable Code Elimination (2 iterations).
   406 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 868):
    Unroll iteration loop at line 63:9                           size  +321, benefit     1475.0, efficiency      4.595
  * Inline write jump table of array 'titaniumDrills'            size    -4, benefit        1.0, efficiency   Infinity (-4 instructions)
    Inline 'titaniumDrills' write access at line 30:9            size   +17, benefit        1.0, efficiency      0.059

Pass 1: speed optimization selection (cost limit 872):
  * Unroll iteration loop at line 63:9                           size  +321, benefit     1475.0, efficiency      4.595 (+322 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-14 instructions):
 
    18 set .coreX *tmp5
    19 sensor *tmp6 .core @y
    20 set .coreY *tmp6
-    * set *tmp1 *tmp6
    21 jump *label10 always
    22 label *label9
-    * set *tmp1 null
    23 label *label10
    24 label *label14
    25 jump *label16 equal true false
 
    84 op equal *tmp8 :backgroundProcess:drill null
    85 jump *label30 equal *tmp8 false
    86 jump *label19 always
-    * set *tmp9 null
    87 jump *label31 always
    88 label *label30
-    * set *tmp9 null
    89 label *label31
    90 sensor *tmp10 :backgroundProcess:unit @controller
    91 op notEqual *tmp11 *tmp10 @this
 
    98 jump *label35 equal *tmp14 false
    99 set *tmp13 null
   100 jump *label34 always
-    * set *tmp15 null
   101 jump *label36 always
   102 label *label35
-    * set *tmp15 null
   103 label *label36
   104 set :findFreeUnit:first_unit @unit
   105 label *label37
 
   109 ucontrol flag :findFreeUnit:initial_flag
   110 set *tmp13 @unit
   111 jump *label34 always
-    * set *tmp18 null
   112 jump *label41 always
   113 label *label40
   114 sensor *tmp19 :findFreeUnit:first_unit @dead
 
   121 label *label42
   122 set *tmp21 null
   123 label *label43
-    * set *tmp18 *tmp21
   124 label *label41
   125 ubind :findFreeUnit:unit_type
   126 label *label38
 
   140 label *label44
   141 set *tmp25 null
   142 label *label45
-    * set *tmp12 *tmp25
   143 jump *label33 always
   144 label *label32
-    * set *tmp12 null
   145 label *label33
   146 # "Function: void serviceDrill(in drill, in unit)"
   147 set :serviceDrill:drill :backgroundProcess:drill
 
   153 jump *label47 equal *tmp27 false
   154 ucontrol approach .coreX .coreY 4
   155 ucontrol itemDrop .core 10
-    * set *tmp28 null
   156 jump *label48 always
   157 label *label47
   158 op equal *tmp29 :serviceDrill:item null
 
   167 ucontrol itemDrop @air 10
   168 set *tmp30 null
   169 label *label50
-    * set *tmp28 *tmp30
   170 label *label48
   171 label *label46
   172 label *label18
 
   189 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp35
   190 set *tmp37 .drills
   191 op add .drills .drills 1
-    * set *tmp34 *tmp37
   192 jump *label53 always
   193 label *label52
-    * set *tmp34 null
   194 label *label53
   195 label *label51
   196 set :addTitaniumDrill*finished true

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-7 instructions):
 
   116 jump *label42 equal *tmp20 false
   117 set *tmp22 @unit
   118 set :findFreeUnit:first_unit *tmp22
-    * set *tmp21 :findFreeUnit:first_unit
   119 jump *label43 always
   120 label *label42
-    * set *tmp21 null
   121 label *label43
   122 label *label41
   123 ubind :findFreeUnit:unit_type
 
   133 op equal *tmp24 :backgroundProcess:unit null
   134 jump *label44 equal *tmp24 false
   135 jump *label18 always
-    * set *tmp25 null
   136 jump *label45 always
   137 label *label44
-    * set *tmp25 null
   138 label *label45
   139 jump *label33 always
   140 label *label32
 
   157 sensor *tmp32 :serviceDrill:drill @y
   158 ucontrol approach *tmp31 *tmp32 4
   159 ucontrol itemTake :serviceDrill:drill @titanium 10
-    * set *tmp30 null
   160 jump *label50 always
   161 label *label49
   162 ucontrol itemDrop @air 10
-    * set *tmp30 null
   163 label *label50
   164 label *label48
   165 label *label46
 
   181 jump *label52 equal *tmp33 false
   182 set *tmp35 .drills
   183 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp35
-    * set *tmp37 .drills
   184 op add .drills .drills 1
   185 jump *label53 always
   186 label *label52

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
     8 jump *label9 equal *tmp0 false
     9 label *label11
    10 ubind @flare
-    * ulocate building core false @copper .coreX .coreY *tmp3 *tmp2
-    * set .core *tmp2
+   11 ulocate building core false @copper .coreX .coreY 0 .core
    12 label *label12
    13 op equal *tmp4 .core null
    14 jump *label11 notEqual *tmp4 false
    15 label *label13
-    * sensor *tmp5 .core @x
-    * set .coreX *tmp5
-    * sensor *tmp6 .core @y
-    * set .coreY *tmp6
+   16 sensor .coreX .core @x
+   17 sensor .coreY .core @y
    18 jump *label10 always
    19 label *label9
    20 label *label10
 
   111 sensor *tmp19 :findFreeUnit:first_unit @dead
   112 op equal *tmp20 *tmp19 1
   113 jump *label42 equal *tmp20 false
-    * set *tmp22 @unit
-    * set :findFreeUnit:first_unit *tmp22
+  114 set :findFreeUnit:first_unit @unit
   115 jump *label43 always
   116 label *label42
   117 label *label43
 
   139 set :serviceDrill:drill :backgroundProcess:drill
   140 set :serviceDrill:unit :backgroundProcess:unit
   141 ubind :serviceDrill:unit
-    * sensor *tmp26 @unit @firstItem
-    * set :serviceDrill:item *tmp26
+  142 sensor :serviceDrill:item @unit @firstItem
   143 op equal *tmp27 :serviceDrill:item @titanium
   144 jump *label47 equal *tmp27 false
   145 ucontrol approach .coreX .coreY 4
 
   174 # "Function: remote void addTitaniumDrill(in drill)"
   175 op lessThan *tmp33 .drills 9
   176 jump *label52 equal *tmp33 false
-    * set *tmp35 .drills
-    * writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp35
+  177 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   178 op add .drills .drills 1
   179 jump *label53 always
   180 label *label52

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    19 label *label9
    20 label *label10
    21 label *label14
-    * jump *label16 equal true false
    22 set :backgroundProcess:drill .titaniumDrills*0
    23 set :backgroundProcess:unit .units*0
    24 op add *tmp7 @counter 1

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-12 instructions):
 
     4 set *signature "881dde114374c003:v1"
     5 label *label7
     6 # "Function: void backgroundProcess()"
-    * op equal *tmp0 .core null
-    * jump *label9 equal *tmp0 false
+    7 jump *label9 notEqual .core null
     8 label *label11
     9 ubind @flare
    10 ulocate building core false @copper .coreX .coreY 0 .core
    11 label *label12
-    * op equal *tmp4 .core null
-    * jump *label11 notEqual *tmp4 false
+   12 jump *label11 equal .core null
    13 label *label13
    14 sensor .coreX .core @x
    15 sensor .coreY .core @y
 
    75 set :backgroundProcess:unit .units*9
    76 set *tmp7 null
    77 label *label17
-    * op equal *tmp8 :backgroundProcess:drill null
-    * jump *label30 equal *tmp8 false
+   78 jump *label30 notEqual :backgroundProcess:drill null
    79 jump *label19 always
    80 jump *label31 always
    81 label *label30
    82 label *label31
    83 sensor *tmp10 :backgroundProcess:unit @controller
-    * op notEqual *tmp11 *tmp10 @this
-    * jump *label32 equal *tmp11 false
+   84 jump *label32 equal *tmp10 @this
    85 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    86 set :findFreeUnit:unit_type @flare
    87 set :findFreeUnit:initial_flag 0
    88 ubind :findFreeUnit:unit_type
-    * op equal *tmp14 @unit null
-    * jump *label35 equal *tmp14 false
+   89 jump *label35 notEqual @unit null
    90 set *tmp13 null
    91 jump *label34 always
    92 jump *label36 always
 
    95 set :findFreeUnit:first_unit @unit
    96 label *label37
    97 sensor *tmp16 @unit @controlled
-    * op equal *tmp17 *tmp16 0
-    * jump *label40 equal *tmp17 false
+   98 jump *label40 notEqual *tmp16 0
    99 ucontrol flag :findFreeUnit:initial_flag
   100 set *tmp13 @unit
   101 jump *label34 always
   102 jump *label41 always
   103 label *label40
   104 sensor *tmp19 :findFreeUnit:first_unit @dead
-    * op equal *tmp20 *tmp19 1
-    * jump *label42 equal *tmp20 false
+  105 jump *label42 notEqual *tmp19 1
   106 set :findFreeUnit:first_unit @unit
   107 jump *label43 always
   108 label *label42
 
   110 label *label41
   111 ubind :findFreeUnit:unit_type
   112 label *label38
-    * op notEqual *tmp23 :findFreeUnit:first_unit @unit
-    * jump *label37 notEqual *tmp23 false
+  113 jump *label37 notEqual :findFreeUnit:first_unit @unit
   114 label *label39
   115 set *tmp13 null
   116 jump *label34 always
   117 set *tmp13 null
   118 label *label34
   119 set :backgroundProcess:unit *tmp13
-    * op equal *tmp24 :backgroundProcess:unit null
-    * jump *label44 equal *tmp24 false
+  120 jump *label44 notEqual :backgroundProcess:unit null
   121 jump *label18 always
   122 jump *label45 always
   123 label *label44
 
   130 set :serviceDrill:unit :backgroundProcess:unit
   131 ubind :serviceDrill:unit
   132 sensor :serviceDrill:item @unit @firstItem
-    * op equal *tmp27 :serviceDrill:item @titanium
-    * jump *label47 equal *tmp27 false
+  133 jump *label47 notEqual :serviceDrill:item @titanium
   134 ucontrol approach .coreX .coreY 4
   135 ucontrol itemDrop .core 10
   136 jump *label48 always
   137 label *label47
-    * op equal *tmp29 :serviceDrill:item null
-    * jump *label49 equal *tmp29 false
+  138 jump *label49 notEqual :serviceDrill:item null
   139 sensor *tmp31 :serviceDrill:drill @x
   140 sensor *tmp32 :serviceDrill:drill @y
   141 ucontrol approach *tmp31 *tmp32 4
 
   160 end
   161 label *label0
   162 # "Function: remote void addTitaniumDrill(in drill)"
-    * op lessThan *tmp33 .drills 9
-    * jump *label52 equal *tmp33 false
+  163 jump *label52 greaterThanEq .drills 9
   164 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   165 op add .drills .drills 1
   166 jump *label53 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    13 label *label13
    14 sensor .coreX .core @x
    15 sensor .coreY .core @y
-    * jump *label10 always
    16 label *label9
    17 label *label10
    18 label *label14
 
    76 label *label17
    77 jump *label30 notEqual :backgroundProcess:drill null
    78 jump *label19 always
-    * jump *label31 always
    79 label *label30
    80 label *label31
    81 sensor *tmp10 :backgroundProcess:unit @controller
 
    87 jump *label35 notEqual @unit null
    88 set *tmp13 null
    89 jump *label34 always
-    * jump *label36 always
    90 label *label35
    91 label *label36
    92 set :findFreeUnit:first_unit @unit
 
   101 sensor *tmp19 :findFreeUnit:first_unit @dead
   102 jump *label42 notEqual *tmp19 1
   103 set :findFreeUnit:first_unit @unit
-    * jump *label43 always
   104 label *label42
   105 label *label43
   106 label *label41
 
   115 set :backgroundProcess:unit *tmp13
   116 jump *label44 notEqual :backgroundProcess:unit null
   117 jump *label18 always
-    * jump *label45 always
   118 label *label44
   119 label *label45
-    * jump *label33 always
   120 label *label32
   121 label *label33
   122 # "Function: void serviceDrill(in drill, in unit)"
 
   157 jump *label52 greaterThanEq .drills 9
   158 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   159 op add .drills .drills 1
-    * jump *label53 always
   160 label *label52
   161 label *label53
   162 label *label51

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    83 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    84 set :findFreeUnit:unit_type @flare
    85 set :findFreeUnit:initial_flag 0
-    * ubind :findFreeUnit:unit_type
+   86 ubind @flare
    87 jump *label35 notEqual @unit null
    88 set *tmp13 null
    89 jump *label34 always
 
    93 label *label37
    94 sensor *tmp16 @unit @controlled
    95 jump *label40 notEqual *tmp16 0
-    * ucontrol flag :findFreeUnit:initial_flag
+   96 ucontrol flag 0
    97 set *tmp13 @unit
    98 jump *label34 always
    99 jump *label41 always
 
   104 label *label42
   105 label *label43
   106 label *label41
-    * ubind :findFreeUnit:unit_type
+  107 ubind @flare
   108 label *label38
   109 jump *label37 notEqual :findFreeUnit:first_unit @unit
   110 label *label39
   111 set *tmp13 null
   112 jump *label34 always
-    * set *tmp13 null
   113 label *label34
   114 set :backgroundProcess:unit *tmp13
-    * jump *label44 notEqual :backgroundProcess:unit null
+  115 jump *label44 notEqual *tmp13 null
   116 jump *label18 always
   117 label *label44
   118 label *label45
 
   121 # "Function: void serviceDrill(in drill, in unit)"
   122 set :serviceDrill:drill :backgroundProcess:drill
   123 set :serviceDrill:unit :backgroundProcess:unit
-    * ubind :serviceDrill:unit
+  124 ubind :backgroundProcess:unit
   125 sensor :serviceDrill:item @unit @firstItem
   126 jump *label47 notEqual :serviceDrill:item @titanium
   127 ucontrol approach .coreX .coreY 4
 
   129 jump *label48 always
   130 label *label47
   131 jump *label49 notEqual :serviceDrill:item null
-    * sensor *tmp31 :serviceDrill:drill @x
-    * sensor *tmp32 :serviceDrill:drill @y
+  132 sensor *tmp31 :backgroundProcess:drill @x
+  133 sensor *tmp32 :backgroundProcess:drill @y
   134 ucontrol approach *tmp31 *tmp32 4
-    * ucontrol itemTake :serviceDrill:drill @titanium 10
+  135 ucontrol itemTake :backgroundProcess:drill @titanium 10
   136 jump *label50 always
   137 label *label49
   138 ucontrol itemDrop @air 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    81 sensor *tmp10 :backgroundProcess:unit @controller
    82 jump *label32 equal *tmp10 @this
    83 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * set :findFreeUnit:unit_type @flare
-    * set :findFreeUnit:initial_flag 0
    84 ubind @flare
    85 jump *label35 notEqual @unit null
    86 set *tmp13 null
 
   117 label *label32
   118 label *label33
   119 # "Function: void serviceDrill(in drill, in unit)"
-    * set :serviceDrill:drill :backgroundProcess:drill
-    * set :serviceDrill:unit :backgroundProcess:unit
   120 ubind :backgroundProcess:unit
   121 sensor :serviceDrill:item @unit @firstItem
   122 jump *label47 notEqual :serviceDrill:item @titanium

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
 
   150 label *label0
   151 # "Function: remote void addTitaniumDrill(in drill)"
   152 jump *label52 greaterThanEq .drills 9
-    * writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  153 writearr<inlined> :addTitaniumDrill:drill .titaniumDrills[] .drills
   154 op add .drills .drills 1
   155 label *label52
   156 label *label53

Modifications by Unroll iteration loop at line 63:9 (+322 instructions):
 
    16 label *label9
    17 label *label10
    18 label *label14
-    * set :backgroundProcess:drill .titaniumDrills*0
-    * set :backgroundProcess:unit .units*0
-    * op add *tmp7 @counter 1
-    * jump *label17 always
-    * multilabel *label20 (m:marker0)
-    * set .units*0 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*1
-    * set :backgroundProcess:unit .units*1
-    * op add *tmp7 @counter 1
-    * jump *label17 always
-    * multilabel *label21 (m:marker0)
-    * set .units*1 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*2
-    * set :backgroundProcess:unit .units*2
-    * op add *tmp7 @counter 1
-    * jump *label17 always
-    * multilabel *label22 (m:marker0)
-    * set .units*2 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*3
-    * set :backgroundProcess:unit .units*3
-    * op add *tmp7 @counter 1
-    * jump *label17 always
-    * multilabel *label23 (m:marker0)
-    * set .units*3 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*4
-    * set :backgroundProcess:unit .units*4
-    * op add *tmp7 @counter 1
-    * jump *label17 always
-    * multilabel *label24 (m:marker0)
-    * set .units*4 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*5
-    * set :backgroundProcess:unit .units*5
-    * op add *tmp7 @counter 1
-    * jump *label17 always
-    * multilabel *label25 (m:marker0)
-    * set .units*5 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*6
-    * set :backgroundProcess:unit .units*6
-    * op add *tmp7 @counter 1
-    * jump *label17 always
-    * multilabel *label26 (m:marker0)
-    * set .units*6 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*7
-    * set :backgroundProcess:unit .units*7
-    * op add *tmp7 @counter 1
-    * jump *label17 always
-    * multilabel *label27 (m:marker0)
-    * set .units*7 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*8
-    * set :backgroundProcess:unit .units*8
-    * op add *tmp7 @counter 1
-    * jump *label17 always
-    * multilabel *label28 (m:marker0)
-    * set .units*8 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*9
-    * set :backgroundProcess:unit .units*9
-    * set *tmp7 null
-    * label *label17
-    * jump *label30 notEqual :backgroundProcess:drill null
-    * jump *label19 always
-    * label *label30
-    * label *label31
-    * sensor *tmp10 :backgroundProcess:unit @controller
-    * jump *label32 equal *tmp10 @this
-    * # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * ubind @flare
-    * jump *label35 notEqual @unit null
-    * set *tmp13 null
-    * jump *label34 always
-    * label *label35
-    * label *label36
-    * set :findFreeUnit:first_unit @unit
-    * label *label37
-    * sensor *tmp16 @unit @controlled
-    * jump *label40 notEqual *tmp16 0
-    * ucontrol flag 0
-    * set *tmp13 @unit
-    * jump *label34 always
-    * jump *label41 always
-    * label *label40
-    * sensor *tmp19 :findFreeUnit:first_unit @dead
-    * jump *label42 notEqual *tmp19 1
-    * set :findFreeUnit:first_unit @unit
-    * label *label42
-    * label *label43
-    * label *label41
-    * ubind @flare
-    * label *label38
-    * jump *label37 notEqual :findFreeUnit:first_unit @unit
-    * label *label39
-    * set *tmp13 null
-    * jump *label34 always
-    * label *label34
-    * set :backgroundProcess:unit *tmp13
-    * jump *label44 notEqual *tmp13 null
-    * jump *label18 always
-    * label *label44
-    * label *label45
-    * label *label32
-    * label *label33
-    * # "Function: void serviceDrill(in drill, in unit)"
-    * ubind :backgroundProcess:unit
-    * sensor :serviceDrill:item @unit @firstItem
-    * jump *label47 notEqual :serviceDrill:item @titanium
-    * ucontrol approach .coreX .coreY 4
-    * ucontrol itemDrop .core 10
-    * jump *label48 always
-    * label *label47
-    * jump *label49 notEqual :serviceDrill:item null
-    * sensor *tmp31 :backgroundProcess:drill @x
-    * sensor *tmp32 :backgroundProcess:drill @y
-    * ucontrol approach *tmp31 *tmp32 4
-    * ucontrol itemTake :backgroundProcess:drill @titanium 10
-    * jump *label50 always
-    * label *label49
-    * ucontrol itemDrop @air 10
-    * label *label50
-    * label *label48
-    * label *label46
-    * label *label18
-    * multijump *tmp7 0 0 (m:marker0)
-    * multilabel *label29 (m:marker0)
-    * set .units*9 :backgroundProcess:unit
-    * label *label19
+   19 set :backgroundProcess:drill .titaniumDrills*0
+   20 set :backgroundProcess:unit .units*0
+   21 label *label54
+   22 jump *label55 notEqual :backgroundProcess:drill null
+   23 jump *label19 always
+   24 label *label55
+   25 label *label56
+   26 sensor *tmp10 :backgroundProcess:unit @controller
+   27 jump *label69 equal *tmp10 @this
+   28 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+   29 ubind @flare
+   30 jump *label57 notEqual @unit null
+   31 set *tmp13 null
+   32 jump *label66 always
+   33 label *label57
+   34 label *label58
+   35 set :findFreeUnit:first_unit @unit
+   36 label *label59
+   37 sensor *tmp16 @unit @controlled
+   38 jump *label60 notEqual *tmp16 0
+   39 ucontrol flag 0
+   40 set *tmp13 @unit
+   41 jump *label66 always
+   42 jump *label63 always
+   43 label *label60
+   44 sensor *tmp19 :findFreeUnit:first_unit @dead
+   45 jump *label61 notEqual *tmp19 1
+   46 set :findFreeUnit:first_unit @unit
+   47 label *label61
+   48 label *label62
+   49 label *label63
+   50 ubind @flare
+   51 label *label64
+   52 jump *label59 notEqual :findFreeUnit:first_unit @unit
+   53 label *label65
+   54 set *tmp13 null
+   55 jump *label66 always
+   56 label *label66
+   57 set :backgroundProcess:unit *tmp13
+   58 jump *label67 notEqual *tmp13 null
+   59 jump *label76 always
+   60 label *label67
+   61 label *label68
+   62 label *label69
+   63 label *label70
+   64 # "Function: void serviceDrill(in drill, in unit)"
+   65 ubind :backgroundProcess:unit
+   66 sensor :serviceDrill:item @unit @firstItem
+   67 jump *label71 notEqual :serviceDrill:item @titanium
+   68 ucontrol approach .coreX .coreY 4
+   69 ucontrol itemDrop .core 10
+   70 jump *label74 always
+   71 label *label71
+   72 jump *label72 notEqual :serviceDrill:item null
+   73 sensor *tmp31 :backgroundProcess:drill @x
+   74 sensor *tmp32 :backgroundProcess:drill @y
+   75 ucontrol approach *tmp31 *tmp32 4
+   76 ucontrol itemTake :backgroundProcess:drill @titanium 10
+   77 jump *label73 always
+   78 label *label72
+   79 ucontrol itemDrop @air 10
+   80 label *label73
+   81 label *label74
+   82 label *label75
+   83 label *label76
+   84 set .units*0 :backgroundProcess:unit
+   85 set :backgroundProcess:drill .titaniumDrills*1
+   86 set :backgroundProcess:unit .units*1
+   87 label *label79
+   88 jump *label80 notEqual :backgroundProcess:drill null
+   89 jump *label19 always
+   90 label *label80
+   91 label *label81
+   92 sensor *tmp10 :backgroundProcess:unit @controller
+   93 jump *label94 equal *tmp10 @this
+   94 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+   95 ubind @flare
+   96 jump *label82 notEqual @unit null
+   97 set *tmp13 null
+   98 jump *label91 always
+   99 label *label82
+  100 label *label83
+  101 set :findFreeUnit:first_unit @unit
+  102 label *label84
+  103 sensor *tmp16 @unit @controlled
+  104 jump *label85 notEqual *tmp16 0
+  105 ucontrol flag 0
+  106 set *tmp13 @unit
+  107 jump *label91 always
+  108 jump *label88 always
+  109 label *label85
+  110 sensor *tmp19 :findFreeUnit:first_unit @dead
+  111 jump *label86 notEqual *tmp19 1
+  112 set :findFreeUnit:first_unit @unit
+  113 label *label86
+  114 label *label87
+  115 label *label88
+  116 ubind @flare
+  117 label *label89
+  118 jump *label84 notEqual :findFreeUnit:first_unit @unit
+  119 label *label90
+  120 set *tmp13 null
+  121 jump *label91 always
+  122 label *label91
+  123 set :backgroundProcess:unit *tmp13
+  124 jump *label92 notEqual *tmp13 null
+  125 jump *label101 always
+  126 label *label92
+  127 label *label93
+  128 label *label94
+  129 label *label95
+  130 # "Function: void serviceDrill(in drill, in unit)"
+  131 ubind :backgroundProcess:unit
+  132 sensor :serviceDrill:item @unit @firstItem
+  133 jump *label96 notEqual :serviceDrill:item @titanium
+  134 ucontrol approach .coreX .coreY 4
+  135 ucontrol itemDrop .core 10
+  136 jump *label99 always
+  137 label *label96
+  138 jump *label97 notEqual :serviceDrill:item null
+  139 sensor *tmp31 :backgroundProcess:drill @x
+  140 sensor *tmp32 :backgroundProcess:drill @y
+  141 ucontrol approach *tmp31 *tmp32 4
+  142 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  143 jump *label98 always
+  144 label *label97
+  145 ucontrol itemDrop @air 10
+  146 label *label98
+  147 label *label99
+  148 label *label100
+  149 label *label101
+  150 set .units*1 :backgroundProcess:unit
+  151 set :backgroundProcess:drill .titaniumDrills*2
+  152 set :backgroundProcess:unit .units*2
+  153 label *label104
+  154 jump *label105 notEqual :backgroundProcess:drill null
+  155 jump *label19 always
+  156 label *label105
+  157 label *label106
+  158 sensor *tmp10 :backgroundProcess:unit @controller
+  159 jump *label119 equal *tmp10 @this
+  160 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  161 ubind @flare
+  162 jump *label107 notEqual @unit null
+  163 set *tmp13 null
+  164 jump *label116 always
+  165 label *label107
+  166 label *label108
+  167 set :findFreeUnit:first_unit @unit
+  168 label *label109
+  169 sensor *tmp16 @unit @controlled
+  170 jump *label110 notEqual *tmp16 0
+  171 ucontrol flag 0
+  172 set *tmp13 @unit
+  173 jump *label116 always
+  174 jump *label113 always
+  175 label *label110
+  176 sensor *tmp19 :findFreeUnit:first_unit @dead
+  177 jump *label111 notEqual *tmp19 1
+  178 set :findFreeUnit:first_unit @unit
+  179 label *label111
+  180 label *label112
+  181 label *label113
+  182 ubind @flare
+  183 label *label114
+  184 jump *label109 notEqual :findFreeUnit:first_unit @unit
+  185 label *label115
+  186 set *tmp13 null
+  187 jump *label116 always
+  188 label *label116
+  189 set :backgroundProcess:unit *tmp13
+  190 jump *label117 notEqual *tmp13 null
+  191 jump *label126 always
+  192 label *label117
+  193 label *label118
+  194 label *label119
+  195 label *label120
+  196 # "Function: void serviceDrill(in drill, in unit)"
+  197 ubind :backgroundProcess:unit
+  198 sensor :serviceDrill:item @unit @firstItem
+  199 jump *label121 notEqual :serviceDrill:item @titanium
+  200 ucontrol approach .coreX .coreY 4
+  201 ucontrol itemDrop .core 10
+  202 jump *label124 always
+  203 label *label121
+  204 jump *label122 notEqual :serviceDrill:item null
+  205 sensor *tmp31 :backgroundProcess:drill @x
+  206 sensor *tmp32 :backgroundProcess:drill @y
+  207 ucontrol approach *tmp31 *tmp32 4
+  208 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  209 jump *label123 always
+  210 label *label122
+  211 ucontrol itemDrop @air 10
+  212 label *label123
+  213 label *label124
+  214 label *label125
+  215 label *label126
+  216 set .units*2 :backgroundProcess:unit
+  217 set :backgroundProcess:drill .titaniumDrills*3
+  218 set :backgroundProcess:unit .units*3
+  219 label *label129
+  220 jump *label130 notEqual :backgroundProcess:drill null
+  221 jump *label19 always
+  222 label *label130
+  223 label *label131
+  224 sensor *tmp10 :backgroundProcess:unit @controller
+  225 jump *label144 equal *tmp10 @this
+  226 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  227 ubind @flare
+  228 jump *label132 notEqual @unit null
+  229 set *tmp13 null
+  230 jump *label141 always
+  231 label *label132
+  232 label *label133
+  233 set :findFreeUnit:first_unit @unit
+  234 label *label134
+  235 sensor *tmp16 @unit @controlled
+  236 jump *label135 notEqual *tmp16 0
+  237 ucontrol flag 0
+  238 set *tmp13 @unit
+  239 jump *label141 always
+  240 jump *label138 always
+  241 label *label135
+  242 sensor *tmp19 :findFreeUnit:first_unit @dead
+  243 jump *label136 notEqual *tmp19 1
+  244 set :findFreeUnit:first_unit @unit
+  245 label *label136
+  246 label *label137
+  247 label *label138
+  248 ubind @flare
+  249 label *label139
+  250 jump *label134 notEqual :findFreeUnit:first_unit @unit
+  251 label *label140
+  252 set *tmp13 null
+  253 jump *label141 always
+  254 label *label141
+  255 set :backgroundProcess:unit *tmp13
+  256 jump *label142 notEqual *tmp13 null
+  257 jump *label151 always
+  258 label *label142
+  259 label *label143
+  260 label *label144
+  261 label *label145
+  262 # "Function: void serviceDrill(in drill, in unit)"
+  263 ubind :backgroundProcess:unit
+  264 sensor :serviceDrill:item @unit @firstItem
+  265 jump *label146 notEqual :serviceDrill:item @titanium
+  266 ucontrol approach .coreX .coreY 4
+  267 ucontrol itemDrop .core 10
+  268 jump *label149 always
+  269 label *label146
+  270 jump *label147 notEqual :serviceDrill:item null
+  271 sensor *tmp31 :backgroundProcess:drill @x
+  272 sensor *tmp32 :backgroundProcess:drill @y
+  273 ucontrol approach *tmp31 *tmp32 4
+  274 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  275 jump *label148 always
+  276 label *label147
+  277 ucontrol itemDrop @air 10
+  278 label *label148
+  279 label *label149
+  280 label *label150
+  281 label *label151
+  282 set .units*3 :backgroundProcess:unit
+  283 set :backgroundProcess:drill .titaniumDrills*4
+  284 set :backgroundProcess:unit .units*4
+  285 label *label154
+  286 jump *label155 notEqual :backgroundProcess:drill null
+  287 jump *label19 always
+  288 label *label155
+  289 label *label156
+  290 sensor *tmp10 :backgroundProcess:unit @controller
+  291 jump *label169 equal *tmp10 @this
+  292 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  293 ubind @flare
+  294 jump *label157 notEqual @unit null
+  295 set *tmp13 null
+  296 jump *label166 always
+  297 label *label157
+  298 label *label158
+  299 set :findFreeUnit:first_unit @unit
+  300 label *label159
+  301 sensor *tmp16 @unit @controlled
+  302 jump *label160 notEqual *tmp16 0
+  303 ucontrol flag 0
+  304 set *tmp13 @unit
+  305 jump *label166 always
+  306 jump *label163 always
+  307 label *label160
+  308 sensor *tmp19 :findFreeUnit:first_unit @dead
+  309 jump *label161 notEqual *tmp19 1
+  310 set :findFreeUnit:first_unit @unit
+  311 label *label161
+  312 label *label162
+  313 label *label163
+  314 ubind @flare
+  315 label *label164
+  316 jump *label159 notEqual :findFreeUnit:first_unit @unit
+  317 label *label165
+  318 set *tmp13 null
+  319 jump *label166 always
+  320 label *label166
+  321 set :backgroundProcess:unit *tmp13
+  322 jump *label167 notEqual *tmp13 null
+  323 jump *label176 always
+  324 label *label167
+  325 label *label168
+  326 label *label169
+  327 label *label170
+  328 # "Function: void serviceDrill(in drill, in unit)"
+  329 ubind :backgroundProcess:unit
+  330 sensor :serviceDrill:item @unit @firstItem
+  331 jump *label171 notEqual :serviceDrill:item @titanium
+  332 ucontrol approach .coreX .coreY 4
+  333 ucontrol itemDrop .core 10
+  334 jump *label174 always
+  335 label *label171
+  336 jump *label172 notEqual :serviceDrill:item null
+  337 sensor *tmp31 :backgroundProcess:drill @x
+  338 sensor *tmp32 :backgroundProcess:drill @y
+  339 ucontrol approach *tmp31 *tmp32 4
+  340 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  341 jump *label173 always
+  342 label *label172
+  343 ucontrol itemDrop @air 10
+  344 label *label173
+  345 label *label174
+  346 label *label175
+  347 label *label176
+  348 set .units*4 :backgroundProcess:unit
+  349 set :backgroundProcess:drill .titaniumDrills*5
+  350 set :backgroundProcess:unit .units*5
+  351 label *label179
+  352 jump *label180 notEqual :backgroundProcess:drill null
+  353 jump *label19 always
+  354 label *label180
+  355 label *label181
+  356 sensor *tmp10 :backgroundProcess:unit @controller
+  357 jump *label194 equal *tmp10 @this
+  358 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  359 ubind @flare
+  360 jump *label182 notEqual @unit null
+  361 set *tmp13 null
+  362 jump *label191 always
+  363 label *label182
+  364 label *label183
+  365 set :findFreeUnit:first_unit @unit
+  366 label *label184
+  367 sensor *tmp16 @unit @controlled
+  368 jump *label185 notEqual *tmp16 0
+  369 ucontrol flag 0
+  370 set *tmp13 @unit
+  371 jump *label191 always
+  372 jump *label188 always
+  373 label *label185
+  374 sensor *tmp19 :findFreeUnit:first_unit @dead
+  375 jump *label186 notEqual *tmp19 1
+  376 set :findFreeUnit:first_unit @unit
+  377 label *label186
+  378 label *label187
+  379 label *label188
+  380 ubind @flare
+  381 label *label189
+  382 jump *label184 notEqual :findFreeUnit:first_unit @unit
+  383 label *label190
+  384 set *tmp13 null
+  385 jump *label191 always
+  386 label *label191
+  387 set :backgroundProcess:unit *tmp13
+  388 jump *label192 notEqual *tmp13 null
+  389 jump *label201 always
+  390 label *label192
+  391 label *label193
+  392 label *label194
+  393 label *label195
+  394 # "Function: void serviceDrill(in drill, in unit)"
+  395 ubind :backgroundProcess:unit
+  396 sensor :serviceDrill:item @unit @firstItem
+  397 jump *label196 notEqual :serviceDrill:item @titanium
+  398 ucontrol approach .coreX .coreY 4
+  399 ucontrol itemDrop .core 10
+  400 jump *label199 always
+  401 label *label196
+  402 jump *label197 notEqual :serviceDrill:item null
+  403 sensor *tmp31 :backgroundProcess:drill @x
+  404 sensor *tmp32 :backgroundProcess:drill @y
+  405 ucontrol approach *tmp31 *tmp32 4
+  406 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  407 jump *label198 always
+  408 label *label197
+  409 ucontrol itemDrop @air 10
+  410 label *label198
+  411 label *label199
+  412 label *label200
+  413 label *label201
+  414 set .units*5 :backgroundProcess:unit
+  415 set :backgroundProcess:drill .titaniumDrills*6
+  416 set :backgroundProcess:unit .units*6
+  417 label *label204
+  418 jump *label205 notEqual :backgroundProcess:drill null
+  419 jump *label19 always
+  420 label *label205
+  421 label *label206
+  422 sensor *tmp10 :backgroundProcess:unit @controller
+  423 jump *label219 equal *tmp10 @this
+  424 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  425 ubind @flare
+  426 jump *label207 notEqual @unit null
+  427 set *tmp13 null
+  428 jump *label216 always
+  429 label *label207
+  430 label *label208
+  431 set :findFreeUnit:first_unit @unit
+  432 label *label209
+  433 sensor *tmp16 @unit @controlled
+  434 jump *label210 notEqual *tmp16 0
+  435 ucontrol flag 0
+  436 set *tmp13 @unit
+  437 jump *label216 always
+  438 jump *label213 always
+  439 label *label210
+  440 sensor *tmp19 :findFreeUnit:first_unit @dead
+  441 jump *label211 notEqual *tmp19 1
+  442 set :findFreeUnit:first_unit @unit
+  443 label *label211
+  444 label *label212
+  445 label *label213
+  446 ubind @flare
+  447 label *label214
+  448 jump *label209 notEqual :findFreeUnit:first_unit @unit
+  449 label *label215
+  450 set *tmp13 null
+  451 jump *label216 always
+  452 label *label216
+  453 set :backgroundProcess:unit *tmp13
+  454 jump *label217 notEqual *tmp13 null
+  455 jump *label226 always
+  456 label *label217
+  457 label *label218
+  458 label *label219
+  459 label *label220
+  460 # "Function: void serviceDrill(in drill, in unit)"
+  461 ubind :backgroundProcess:unit
+  462 sensor :serviceDrill:item @unit @firstItem
+  463 jump *label221 notEqual :serviceDrill:item @titanium
+  464 ucontrol approach .coreX .coreY 4
+  465 ucontrol itemDrop .core 10
+  466 jump *label224 always
+  467 label *label221
+  468 jump *label222 notEqual :serviceDrill:item null
+  469 sensor *tmp31 :backgroundProcess:drill @x
+  470 sensor *tmp32 :backgroundProcess:drill @y
+  471 ucontrol approach *tmp31 *tmp32 4
+  472 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  473 jump *label223 always
+  474 label *label222
+  475 ucontrol itemDrop @air 10
+  476 label *label223
+  477 label *label224
+  478 label *label225
+  479 label *label226
+  480 set .units*6 :backgroundProcess:unit
+  481 set :backgroundProcess:drill .titaniumDrills*7
+  482 set :backgroundProcess:unit .units*7
+  483 label *label229
+  484 jump *label230 notEqual :backgroundProcess:drill null
+  485 jump *label19 always
+  486 label *label230
+  487 label *label231
+  488 sensor *tmp10 :backgroundProcess:unit @controller
+  489 jump *label244 equal *tmp10 @this
+  490 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  491 ubind @flare
+  492 jump *label232 notEqual @unit null
+  493 set *tmp13 null
+  494 jump *label241 always
+  495 label *label232
+  496 label *label233
+  497 set :findFreeUnit:first_unit @unit
+  498 label *label234
+  499 sensor *tmp16 @unit @controlled
+  500 jump *label235 notEqual *tmp16 0
+  501 ucontrol flag 0
+  502 set *tmp13 @unit
+  503 jump *label241 always
+  504 jump *label238 always
+  505 label *label235
+  506 sensor *tmp19 :findFreeUnit:first_unit @dead
+  507 jump *label236 notEqual *tmp19 1
+  508 set :findFreeUnit:first_unit @unit
+  509 label *label236
+  510 label *label237
+  511 label *label238
+  512 ubind @flare
+  513 label *label239
+  514 jump *label234 notEqual :findFreeUnit:first_unit @unit
+  515 label *label240
+  516 set *tmp13 null
+  517 jump *label241 always
+  518 label *label241
+  519 set :backgroundProcess:unit *tmp13
+  520 jump *label242 notEqual *tmp13 null
+  521 jump *label251 always
+  522 label *label242
+  523 label *label243
+  524 label *label244
+  525 label *label245
+  526 # "Function: void serviceDrill(in drill, in unit)"
+  527 ubind :backgroundProcess:unit
+  528 sensor :serviceDrill:item @unit @firstItem
+  529 jump *label246 notEqual :serviceDrill:item @titanium
+  530 ucontrol approach .coreX .coreY 4
+  531 ucontrol itemDrop .core 10
+  532 jump *label249 always
+  533 label *label246
+  534 jump *label247 notEqual :serviceDrill:item null
+  535 sensor *tmp31 :backgroundProcess:drill @x
+  536 sensor *tmp32 :backgroundProcess:drill @y
+  537 ucontrol approach *tmp31 *tmp32 4
+  538 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  539 jump *label248 always
+  540 label *label247
+  541 ucontrol itemDrop @air 10
+  542 label *label248
+  543 label *label249
+  544 label *label250
+  545 label *label251
+  546 set .units*7 :backgroundProcess:unit
+  547 set :backgroundProcess:drill .titaniumDrills*8
+  548 set :backgroundProcess:unit .units*8
+  549 label *label254
+  550 jump *label255 notEqual :backgroundProcess:drill null
+  551 jump *label19 always
+  552 label *label255
+  553 label *label256
+  554 sensor *tmp10 :backgroundProcess:unit @controller
+  555 jump *label269 equal *tmp10 @this
+  556 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  557 ubind @flare
+  558 jump *label257 notEqual @unit null
+  559 set *tmp13 null
+  560 jump *label266 always
+  561 label *label257
+  562 label *label258
+  563 set :findFreeUnit:first_unit @unit
+  564 label *label259
+  565 sensor *tmp16 @unit @controlled
+  566 jump *label260 notEqual *tmp16 0
+  567 ucontrol flag 0
+  568 set *tmp13 @unit
+  569 jump *label266 always
+  570 jump *label263 always
+  571 label *label260
+  572 sensor *tmp19 :findFreeUnit:first_unit @dead
+  573 jump *label261 notEqual *tmp19 1
+  574 set :findFreeUnit:first_unit @unit
+  575 label *label261
+  576 label *label262
+  577 label *label263
+  578 ubind @flare
+  579 label *label264
+  580 jump *label259 notEqual :findFreeUnit:first_unit @unit
+  581 label *label265
+  582 set *tmp13 null
+  583 jump *label266 always
+  584 label *label266
+  585 set :backgroundProcess:unit *tmp13
+  586 jump *label267 notEqual *tmp13 null
+  587 jump *label276 always
+  588 label *label267
+  589 label *label268
+  590 label *label269
+  591 label *label270
+  592 # "Function: void serviceDrill(in drill, in unit)"
+  593 ubind :backgroundProcess:unit
+  594 sensor :serviceDrill:item @unit @firstItem
+  595 jump *label271 notEqual :serviceDrill:item @titanium
+  596 ucontrol approach .coreX .coreY 4
+  597 ucontrol itemDrop .core 10
+  598 jump *label274 always
+  599 label *label271
+  600 jump *label272 notEqual :serviceDrill:item null
+  601 sensor *tmp31 :backgroundProcess:drill @x
+  602 sensor *tmp32 :backgroundProcess:drill @y
+  603 ucontrol approach *tmp31 *tmp32 4
+  604 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  605 jump *label273 always
+  606 label *label272
+  607 ucontrol itemDrop @air 10
+  608 label *label273
+  609 label *label274
+  610 label *label275
+  611 label *label276
+  612 set .units*8 :backgroundProcess:unit
+  613 set :backgroundProcess:drill .titaniumDrills*9
+  614 set :backgroundProcess:unit .units*9
+  615 label *label279
+  616 jump *label280 notEqual :backgroundProcess:drill null
+  617 jump *label19 always
+  618 label *label280
+  619 label *label281
+  620 sensor *tmp10 :backgroundProcess:unit @controller
+  621 jump *label294 equal *tmp10 @this
+  622 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  623 ubind @flare
+  624 jump *label282 notEqual @unit null
+  625 set *tmp13 null
+  626 jump *label291 always
+  627 label *label282
+  628 label *label283
+  629 set :findFreeUnit:first_unit @unit
+  630 label *label284
+  631 sensor *tmp16 @unit @controlled
+  632 jump *label285 notEqual *tmp16 0
+  633 ucontrol flag 0
+  634 set *tmp13 @unit
+  635 jump *label291 always
+  636 jump *label288 always
+  637 label *label285
+  638 sensor *tmp19 :findFreeUnit:first_unit @dead
+  639 jump *label286 notEqual *tmp19 1
+  640 set :findFreeUnit:first_unit @unit
+  641 label *label286
+  642 label *label287
+  643 label *label288
+  644 ubind @flare
+  645 label *label289
+  646 jump *label284 notEqual :findFreeUnit:first_unit @unit
+  647 label *label290
+  648 set *tmp13 null
+  649 jump *label291 always
+  650 label *label291
+  651 set :backgroundProcess:unit *tmp13
+  652 jump *label292 notEqual *tmp13 null
+  653 jump *label301 always
+  654 label *label292
+  655 label *label293
+  656 label *label294
+  657 label *label295
+  658 # "Function: void serviceDrill(in drill, in unit)"
+  659 ubind :backgroundProcess:unit
+  660 sensor :serviceDrill:item @unit @firstItem
+  661 jump *label296 notEqual :serviceDrill:item @titanium
+  662 ucontrol approach .coreX .coreY 4
+  663 ucontrol itemDrop .core 10
+  664 jump *label299 always
+  665 label *label296
+  666 jump *label297 notEqual :serviceDrill:item null
+  667 sensor *tmp31 :backgroundProcess:drill @x
+  668 sensor *tmp32 :backgroundProcess:drill @y
+  669 ucontrol approach *tmp31 *tmp32 4
+  670 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  671 jump *label298 always
+  672 label *label297
+  673 ucontrol itemDrop @air 10
+  674 label *label298
+  675 label *label299
+  676 label *label300
+  677 label *label301
+  678 set .units*9 :backgroundProcess:unit
+  679 label *label19
   680 label *label15
   681 jump *label14 always
   682 label *label16

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-10 instructions):
 
    52 jump *label59 notEqual :findFreeUnit:first_unit @unit
    53 label *label65
    54 set *tmp13 null
-    * jump *label66 always
    55 label *label66
    56 set :backgroundProcess:unit *tmp13
    57 jump *label67 notEqual *tmp13 null
 
   117 jump *label84 notEqual :findFreeUnit:first_unit @unit
   118 label *label90
   119 set *tmp13 null
-    * jump *label91 always
   120 label *label91
   121 set :backgroundProcess:unit *tmp13
   122 jump *label92 notEqual *tmp13 null
 
   182 jump *label109 notEqual :findFreeUnit:first_unit @unit
   183 label *label115
   184 set *tmp13 null
-    * jump *label116 always
   185 label *label116
   186 set :backgroundProcess:unit *tmp13
   187 jump *label117 notEqual *tmp13 null
 
   247 jump *label134 notEqual :findFreeUnit:first_unit @unit
   248 label *label140
   249 set *tmp13 null
-    * jump *label141 always
   250 label *label141
   251 set :backgroundProcess:unit *tmp13
   252 jump *label142 notEqual *tmp13 null
 
   312 jump *label159 notEqual :findFreeUnit:first_unit @unit
   313 label *label165
   314 set *tmp13 null
-    * jump *label166 always
   315 label *label166
   316 set :backgroundProcess:unit *tmp13
   317 jump *label167 notEqual *tmp13 null
 
   377 jump *label184 notEqual :findFreeUnit:first_unit @unit
   378 label *label190
   379 set *tmp13 null
-    * jump *label191 always
   380 label *label191
   381 set :backgroundProcess:unit *tmp13
   382 jump *label192 notEqual *tmp13 null
 
   442 jump *label209 notEqual :findFreeUnit:first_unit @unit
   443 label *label215
   444 set *tmp13 null
-    * jump *label216 always
   445 label *label216
   446 set :backgroundProcess:unit *tmp13
   447 jump *label217 notEqual *tmp13 null
 
   507 jump *label234 notEqual :findFreeUnit:first_unit @unit
   508 label *label240
   509 set *tmp13 null
-    * jump *label241 always
   510 label *label241
   511 set :backgroundProcess:unit *tmp13
   512 jump *label242 notEqual *tmp13 null
 
   572 jump *label259 notEqual :findFreeUnit:first_unit @unit
   573 label *label265
   574 set *tmp13 null
-    * jump *label266 always
   575 label *label266
   576 set :backgroundProcess:unit *tmp13
   577 jump *label267 notEqual *tmp13 null
 
   637 jump *label284 notEqual :findFreeUnit:first_unit @unit
   638 label *label290
   639 set *tmp13 null
-    * jump *label291 always
   640 label *label291
   641 set :backgroundProcess:unit *tmp13
   642 jump *label292 notEqual *tmp13 null

Modifications by Virtual Instruction Expansion (+1 instructions):
 
   677 label *label0
   678 # "Function: remote void addTitaniumDrill(in drill)"
   679 jump *label52 greaterThanEq .drills 9
-    * writearr<inlined> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  680 op mul *tmp38 .drills 2
+  681 multijump *label306 *tmp38 0 (m:marker1)
+  682 multilabel *label306 (m:marker1)
+  683 set .titaniumDrills*0 :addTitaniumDrill:drill
+  684 jump *label305 always
+  685 multilabel *label307 (m:marker1)
+  686 set .titaniumDrills*1 :addTitaniumDrill:drill
+  687 jump *label305 always
+  688 multilabel *label308 (m:marker1)
+  689 set .titaniumDrills*2 :addTitaniumDrill:drill
+  690 jump *label305 always
+  691 multilabel *label309 (m:marker1)
+  692 set .titaniumDrills*3 :addTitaniumDrill:drill
+  693 jump *label305 always
+  694 multilabel *label310 (m:marker1)
+  695 set .titaniumDrills*4 :addTitaniumDrill:drill
+  696 jump *label305 always
+  697 multilabel *label311 (m:marker1)
+  698 set .titaniumDrills*5 :addTitaniumDrill:drill
+  699 jump *label305 always
+  700 multilabel *label312 (m:marker1)
+  701 set .titaniumDrills*6 :addTitaniumDrill:drill
+  702 jump *label305 always
+  703 multilabel *label313 (m:marker1)
+  704 set .titaniumDrills*7 :addTitaniumDrill:drill
+  705 jump *label305 always
+  706 multilabel *label314 (m:marker1)
+  707 set .titaniumDrills*8 :addTitaniumDrill:drill
+  708 jump *label305 always
+  709 multilabel *label315 (m:marker1)
+  710 set .titaniumDrills*9 :addTitaniumDrill:drill
+  711 jump *label305 always
+  712 label *label305
   713 op add .drills .drills 1
   714 label *label52
   715 label *label53

Modifications by Iterated phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   708 jump *label305 always
   709 multilabel *label315 (m:marker1)
   710 set .titaniumDrills*9 :addTitaniumDrill:drill
-    * jump *label305 always
   711 label *label305
   712 op add .drills .drills 1
   713 label *label52

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
     8 label *label11
     9 ubind @flare
    10 ulocate building core false @copper .coreX .coreY 0 .core
-    * label *label12
    11 jump *label11 equal .core null
-    * label *label13
    12 sensor .coreX .core @x
    13 sensor .coreY .core @y
    14 label *label9
-    * label *label10
    15 label *label14
    16 set :backgroundProcess:drill .titaniumDrills*0
    17 set :backgroundProcess:unit .units*0
-    * label *label54
    18 jump *label55 notEqual :backgroundProcess:drill null
    19 jump *label19 always
    20 label *label55
-    * label *label56
    21 sensor *tmp10 :backgroundProcess:unit @controller
    22 jump *label69 equal *tmp10 @this
    23 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    26 set *tmp13 null
    27 jump *label66 always
    28 label *label57
-    * label *label58
    29 set :findFreeUnit:first_unit @unit
    30 label *label59
    31 sensor *tmp16 @unit @controlled
 
    39 jump *label61 notEqual *tmp19 1
    40 set :findFreeUnit:first_unit @unit
    41 label *label61
-    * label *label62
    42 label *label63
    43 ubind @flare
-    * label *label64
    44 jump *label59 notEqual :findFreeUnit:first_unit @unit
-    * label *label65
    45 set *tmp13 null
    46 label *label66
    47 set :backgroundProcess:unit *tmp13
    48 jump *label67 notEqual *tmp13 null
    49 jump *label76 always
    50 label *label67
-    * label *label68
    51 label *label69
-    * label *label70
    52 # "Function: void serviceDrill(in drill, in unit)"
    53 ubind :backgroundProcess:unit
    54 sensor :serviceDrill:item @unit @firstItem
 
    67 ucontrol itemDrop @air 10
    68 label *label73
    69 label *label74
-    * label *label75
    70 label *label76
    71 set .units*0 :backgroundProcess:unit
    72 set :backgroundProcess:drill .titaniumDrills*1
    73 set :backgroundProcess:unit .units*1
-    * label *label79
    74 jump *label80 notEqual :backgroundProcess:drill null
    75 jump *label19 always
    76 label *label80
-    * label *label81
    77 sensor *tmp10 :backgroundProcess:unit @controller
    78 jump *label94 equal *tmp10 @this
    79 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    82 set *tmp13 null
    83 jump *label91 always
    84 label *label82
-    * label *label83
    85 set :findFreeUnit:first_unit @unit
    86 label *label84
    87 sensor *tmp16 @unit @controlled
 
    95 jump *label86 notEqual *tmp19 1
    96 set :findFreeUnit:first_unit @unit
    97 label *label86
-    * label *label87
    98 label *label88
    99 ubind @flare
-    * label *label89
   100 jump *label84 notEqual :findFreeUnit:first_unit @unit
-    * label *label90
   101 set *tmp13 null
   102 label *label91
   103 set :backgroundProcess:unit *tmp13
   104 jump *label92 notEqual *tmp13 null
   105 jump *label101 always
   106 label *label92
-    * label *label93
   107 label *label94
-    * label *label95
   108 # "Function: void serviceDrill(in drill, in unit)"
   109 ubind :backgroundProcess:unit
   110 sensor :serviceDrill:item @unit @firstItem
 
   123 ucontrol itemDrop @air 10
   124 label *label98
   125 label *label99
-    * label *label100
   126 label *label101
   127 set .units*1 :backgroundProcess:unit
   128 set :backgroundProcess:drill .titaniumDrills*2
   129 set :backgroundProcess:unit .units*2
-    * label *label104
   130 jump *label105 notEqual :backgroundProcess:drill null
   131 jump *label19 always
   132 label *label105
-    * label *label106
   133 sensor *tmp10 :backgroundProcess:unit @controller
   134 jump *label119 equal *tmp10 @this
   135 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   138 set *tmp13 null
   139 jump *label116 always
   140 label *label107
-    * label *label108
   141 set :findFreeUnit:first_unit @unit
   142 label *label109
   143 sensor *tmp16 @unit @controlled
 
   151 jump *label111 notEqual *tmp19 1
   152 set :findFreeUnit:first_unit @unit
   153 label *label111
-    * label *label112
   154 label *label113
   155 ubind @flare
-    * label *label114
   156 jump *label109 notEqual :findFreeUnit:first_unit @unit
-    * label *label115
   157 set *tmp13 null
   158 label *label116
   159 set :backgroundProcess:unit *tmp13
   160 jump *label117 notEqual *tmp13 null
   161 jump *label126 always
   162 label *label117
-    * label *label118
   163 label *label119
-    * label *label120
   164 # "Function: void serviceDrill(in drill, in unit)"
   165 ubind :backgroundProcess:unit
   166 sensor :serviceDrill:item @unit @firstItem
 
   179 ucontrol itemDrop @air 10
   180 label *label123
   181 label *label124
-    * label *label125
   182 label *label126
   183 set .units*2 :backgroundProcess:unit
   184 set :backgroundProcess:drill .titaniumDrills*3
   185 set :backgroundProcess:unit .units*3
-    * label *label129
   186 jump *label130 notEqual :backgroundProcess:drill null
   187 jump *label19 always
   188 label *label130
-    * label *label131
   189 sensor *tmp10 :backgroundProcess:unit @controller
   190 jump *label144 equal *tmp10 @this
   191 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   194 set *tmp13 null
   195 jump *label141 always
   196 label *label132
-    * label *label133
   197 set :findFreeUnit:first_unit @unit
   198 label *label134
   199 sensor *tmp16 @unit @controlled
 
   207 jump *label136 notEqual *tmp19 1
   208 set :findFreeUnit:first_unit @unit
   209 label *label136
-    * label *label137
   210 label *label138
   211 ubind @flare
-    * label *label139
   212 jump *label134 notEqual :findFreeUnit:first_unit @unit
-    * label *label140
   213 set *tmp13 null
   214 label *label141
   215 set :backgroundProcess:unit *tmp13
   216 jump *label142 notEqual *tmp13 null
   217 jump *label151 always
   218 label *label142
-    * label *label143
   219 label *label144
-    * label *label145
   220 # "Function: void serviceDrill(in drill, in unit)"
   221 ubind :backgroundProcess:unit
   222 sensor :serviceDrill:item @unit @firstItem
 
   235 ucontrol itemDrop @air 10
   236 label *label148
   237 label *label149
-    * label *label150
   238 label *label151
   239 set .units*3 :backgroundProcess:unit
   240 set :backgroundProcess:drill .titaniumDrills*4
   241 set :backgroundProcess:unit .units*4
-    * label *label154
   242 jump *label155 notEqual :backgroundProcess:drill null
   243 jump *label19 always
   244 label *label155
-    * label *label156
   245 sensor *tmp10 :backgroundProcess:unit @controller
   246 jump *label169 equal *tmp10 @this
   247 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   250 set *tmp13 null
   251 jump *label166 always
   252 label *label157
-    * label *label158
   253 set :findFreeUnit:first_unit @unit
   254 label *label159
   255 sensor *tmp16 @unit @controlled
 
   263 jump *label161 notEqual *tmp19 1
   264 set :findFreeUnit:first_unit @unit
   265 label *label161
-    * label *label162
   266 label *label163
   267 ubind @flare
-    * label *label164
   268 jump *label159 notEqual :findFreeUnit:first_unit @unit
-    * label *label165
   269 set *tmp13 null
   270 label *label166
   271 set :backgroundProcess:unit *tmp13
   272 jump *label167 notEqual *tmp13 null
   273 jump *label176 always
   274 label *label167
-    * label *label168
   275 label *label169
-    * label *label170
   276 # "Function: void serviceDrill(in drill, in unit)"
   277 ubind :backgroundProcess:unit
   278 sensor :serviceDrill:item @unit @firstItem
 
   291 ucontrol itemDrop @air 10
   292 label *label173
   293 label *label174
-    * label *label175
   294 label *label176
   295 set .units*4 :backgroundProcess:unit
   296 set :backgroundProcess:drill .titaniumDrills*5
   297 set :backgroundProcess:unit .units*5
-    * label *label179
   298 jump *label180 notEqual :backgroundProcess:drill null
   299 jump *label19 always
   300 label *label180
-    * label *label181
   301 sensor *tmp10 :backgroundProcess:unit @controller
   302 jump *label194 equal *tmp10 @this
   303 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   306 set *tmp13 null
   307 jump *label191 always
   308 label *label182
-    * label *label183
   309 set :findFreeUnit:first_unit @unit
   310 label *label184
   311 sensor *tmp16 @unit @controlled
 
   319 jump *label186 notEqual *tmp19 1
   320 set :findFreeUnit:first_unit @unit
   321 label *label186
-    * label *label187
   322 label *label188
   323 ubind @flare
-    * label *label189
   324 jump *label184 notEqual :findFreeUnit:first_unit @unit
-    * label *label190
   325 set *tmp13 null
   326 label *label191
   327 set :backgroundProcess:unit *tmp13
   328 jump *label192 notEqual *tmp13 null
   329 jump *label201 always
   330 label *label192
-    * label *label193
   331 label *label194
-    * label *label195
   332 # "Function: void serviceDrill(in drill, in unit)"
   333 ubind :backgroundProcess:unit
   334 sensor :serviceDrill:item @unit @firstItem
 
   347 ucontrol itemDrop @air 10
   348 label *label198
   349 label *label199
-    * label *label200
   350 label *label201
   351 set .units*5 :backgroundProcess:unit
   352 set :backgroundProcess:drill .titaniumDrills*6
   353 set :backgroundProcess:unit .units*6
-    * label *label204
   354 jump *label205 notEqual :backgroundProcess:drill null
   355 jump *label19 always
   356 label *label205
-    * label *label206
   357 sensor *tmp10 :backgroundProcess:unit @controller
   358 jump *label219 equal *tmp10 @this
   359 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   362 set *tmp13 null
   363 jump *label216 always
   364 label *label207
-    * label *label208
   365 set :findFreeUnit:first_unit @unit
   366 label *label209
   367 sensor *tmp16 @unit @controlled
 
   375 jump *label211 notEqual *tmp19 1
   376 set :findFreeUnit:first_unit @unit
   377 label *label211
-    * label *label212
   378 label *label213
   379 ubind @flare
-    * label *label214
   380 jump *label209 notEqual :findFreeUnit:first_unit @unit
-    * label *label215
   381 set *tmp13 null
   382 label *label216
   383 set :backgroundProcess:unit *tmp13
   384 jump *label217 notEqual *tmp13 null
   385 jump *label226 always
   386 label *label217
-    * label *label218
   387 label *label219
-    * label *label220
   388 # "Function: void serviceDrill(in drill, in unit)"
   389 ubind :backgroundProcess:unit
   390 sensor :serviceDrill:item @unit @firstItem
 
   403 ucontrol itemDrop @air 10
   404 label *label223
   405 label *label224
-    * label *label225
   406 label *label226
   407 set .units*6 :backgroundProcess:unit
   408 set :backgroundProcess:drill .titaniumDrills*7
   409 set :backgroundProcess:unit .units*7
-    * label *label229
   410 jump *label230 notEqual :backgroundProcess:drill null
   411 jump *label19 always
   412 label *label230
-    * label *label231
   413 sensor *tmp10 :backgroundProcess:unit @controller
   414 jump *label244 equal *tmp10 @this
   415 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   418 set *tmp13 null
   419 jump *label241 always
   420 label *label232
-    * label *label233
   421 set :findFreeUnit:first_unit @unit
   422 label *label234
   423 sensor *tmp16 @unit @controlled
 
   431 jump *label236 notEqual *tmp19 1
   432 set :findFreeUnit:first_unit @unit
   433 label *label236
-    * label *label237
   434 label *label238
   435 ubind @flare
-    * label *label239
   436 jump *label234 notEqual :findFreeUnit:first_unit @unit
-    * label *label240
   437 set *tmp13 null
   438 label *label241
   439 set :backgroundProcess:unit *tmp13
   440 jump *label242 notEqual *tmp13 null
   441 jump *label251 always
   442 label *label242
-    * label *label243
   443 label *label244
-    * label *label245
   444 # "Function: void serviceDrill(in drill, in unit)"
   445 ubind :backgroundProcess:unit
   446 sensor :serviceDrill:item @unit @firstItem
 
   459 ucontrol itemDrop @air 10
   460 label *label248
   461 label *label249
-    * label *label250
   462 label *label251
   463 set .units*7 :backgroundProcess:unit
   464 set :backgroundProcess:drill .titaniumDrills*8
   465 set :backgroundProcess:unit .units*8
-    * label *label254
   466 jump *label255 notEqual :backgroundProcess:drill null
   467 jump *label19 always
   468 label *label255
-    * label *label256
   469 sensor *tmp10 :backgroundProcess:unit @controller
   470 jump *label269 equal *tmp10 @this
   471 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   474 set *tmp13 null
   475 jump *label266 always
   476 label *label257
-    * label *label258
   477 set :findFreeUnit:first_unit @unit
   478 label *label259
   479 sensor *tmp16 @unit @controlled
 
   487 jump *label261 notEqual *tmp19 1
   488 set :findFreeUnit:first_unit @unit
   489 label *label261
-    * label *label262
   490 label *label263
   491 ubind @flare
-    * label *label264
   492 jump *label259 notEqual :findFreeUnit:first_unit @unit
-    * label *label265
   493 set *tmp13 null
   494 label *label266
   495 set :backgroundProcess:unit *tmp13
   496 jump *label267 notEqual *tmp13 null
   497 jump *label276 always
   498 label *label267
-    * label *label268
   499 label *label269
-    * label *label270
   500 # "Function: void serviceDrill(in drill, in unit)"
   501 ubind :backgroundProcess:unit
   502 sensor :serviceDrill:item @unit @firstItem
 
   515 ucontrol itemDrop @air 10
   516 label *label273
   517 label *label274
-    * label *label275
   518 label *label276
   519 set .units*8 :backgroundProcess:unit
   520 set :backgroundProcess:drill .titaniumDrills*9
   521 set :backgroundProcess:unit .units*9
-    * label *label279
   522 jump *label280 notEqual :backgroundProcess:drill null
   523 jump *label19 always
   524 label *label280
-    * label *label281
   525 sensor *tmp10 :backgroundProcess:unit @controller
   526 jump *label294 equal *tmp10 @this
   527 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   530 set *tmp13 null
   531 jump *label291 always
   532 label *label282
-    * label *label283
   533 set :findFreeUnit:first_unit @unit
   534 label *label284
   535 sensor *tmp16 @unit @controlled
 
   543 jump *label286 notEqual *tmp19 1
   544 set :findFreeUnit:first_unit @unit
   545 label *label286
-    * label *label287
   546 label *label288
   547 ubind @flare
-    * label *label289
   548 jump *label284 notEqual :findFreeUnit:first_unit @unit
-    * label *label290
   549 set *tmp13 null
   550 label *label291
   551 set :backgroundProcess:unit *tmp13
   552 jump *label292 notEqual *tmp13 null
   553 jump *label301 always
   554 label *label292
-    * label *label293
   555 label *label294
-    * label *label295
   556 # "Function: void serviceDrill(in drill, in unit)"
   557 ubind :backgroundProcess:unit
   558 sensor :serviceDrill:item @unit @firstItem
 
   571 ucontrol itemDrop @air 10
   572 label *label298
   573 label *label299
-    * label *label300
   574 label *label301
   575 set .units*9 :backgroundProcess:unit
   576 label *label19
-    * label *label15
   577 jump *label14 always
-    * label *label16
-    * label *label8
   578 wait 1e12
   579 jump *label7 always
   580 end
 
   615 label *label305
   616 op add .drills .drills 1
   617 label *label52
-    * label *label53
-    * label *label51
   618 set :addTitaniumDrill*finished true
   619 jump *label7 always
   620 end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-20 instructions):
 
    15 label *label14
    16 set :backgroundProcess:drill .titaniumDrills*0
    17 set :backgroundProcess:unit .units*0
-    * jump *label55 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+   18 jump *label19 equal :backgroundProcess:drill null
    19 label *label55
    20 sensor *tmp10 :backgroundProcess:unit @controller
    21 jump *label69 equal *tmp10 @this
 
    44 set *tmp13 null
    45 label *label66
    46 set :backgroundProcess:unit *tmp13
-    * jump *label67 notEqual *tmp13 null
-    * jump *label76 always
+   47 jump *label76 equal *tmp13 null
    48 label *label67
    49 label *label69
    50 # "Function: void serviceDrill(in drill, in unit)"
 
    69 set .units*0 :backgroundProcess:unit
    70 set :backgroundProcess:drill .titaniumDrills*1
    71 set :backgroundProcess:unit .units*1
-    * jump *label80 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+   72 jump *label19 equal :backgroundProcess:drill null
    73 label *label80
    74 sensor *tmp10 :backgroundProcess:unit @controller
    75 jump *label94 equal *tmp10 @this
 
    98 set *tmp13 null
    99 label *label91
   100 set :backgroundProcess:unit *tmp13
-    * jump *label92 notEqual *tmp13 null
-    * jump *label101 always
+  101 jump *label101 equal *tmp13 null
   102 label *label92
   103 label *label94
   104 # "Function: void serviceDrill(in drill, in unit)"
 
   123 set .units*1 :backgroundProcess:unit
   124 set :backgroundProcess:drill .titaniumDrills*2
   125 set :backgroundProcess:unit .units*2
-    * jump *label105 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  126 jump *label19 equal :backgroundProcess:drill null
   127 label *label105
   128 sensor *tmp10 :backgroundProcess:unit @controller
   129 jump *label119 equal *tmp10 @this
 
   152 set *tmp13 null
   153 label *label116
   154 set :backgroundProcess:unit *tmp13
-    * jump *label117 notEqual *tmp13 null
-    * jump *label126 always
+  155 jump *label126 equal *tmp13 null
   156 label *label117
   157 label *label119
   158 # "Function: void serviceDrill(in drill, in unit)"
 
   177 set .units*2 :backgroundProcess:unit
   178 set :backgroundProcess:drill .titaniumDrills*3
   179 set :backgroundProcess:unit .units*3
-    * jump *label130 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  180 jump *label19 equal :backgroundProcess:drill null
   181 label *label130
   182 sensor *tmp10 :backgroundProcess:unit @controller
   183 jump *label144 equal *tmp10 @this
 
   206 set *tmp13 null
   207 label *label141
   208 set :backgroundProcess:unit *tmp13
-    * jump *label142 notEqual *tmp13 null
-    * jump *label151 always
+  209 jump *label151 equal *tmp13 null
   210 label *label142
   211 label *label144
   212 # "Function: void serviceDrill(in drill, in unit)"
 
   231 set .units*3 :backgroundProcess:unit
   232 set :backgroundProcess:drill .titaniumDrills*4
   233 set :backgroundProcess:unit .units*4
-    * jump *label155 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  234 jump *label19 equal :backgroundProcess:drill null
   235 label *label155
   236 sensor *tmp10 :backgroundProcess:unit @controller
   237 jump *label169 equal *tmp10 @this
 
   260 set *tmp13 null
   261 label *label166
   262 set :backgroundProcess:unit *tmp13
-    * jump *label167 notEqual *tmp13 null
-    * jump *label176 always
+  263 jump *label176 equal *tmp13 null
   264 label *label167
   265 label *label169
   266 # "Function: void serviceDrill(in drill, in unit)"
 
   285 set .units*4 :backgroundProcess:unit
   286 set :backgroundProcess:drill .titaniumDrills*5
   287 set :backgroundProcess:unit .units*5
-    * jump *label180 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  288 jump *label19 equal :backgroundProcess:drill null
   289 label *label180
   290 sensor *tmp10 :backgroundProcess:unit @controller
   291 jump *label194 equal *tmp10 @this
 
   314 set *tmp13 null
   315 label *label191
   316 set :backgroundProcess:unit *tmp13
-    * jump *label192 notEqual *tmp13 null
-    * jump *label201 always
+  317 jump *label201 equal *tmp13 null
   318 label *label192
   319 label *label194
   320 # "Function: void serviceDrill(in drill, in unit)"
 
   339 set .units*5 :backgroundProcess:unit
   340 set :backgroundProcess:drill .titaniumDrills*6
   341 set :backgroundProcess:unit .units*6
-    * jump *label205 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  342 jump *label19 equal :backgroundProcess:drill null
   343 label *label205
   344 sensor *tmp10 :backgroundProcess:unit @controller
   345 jump *label219 equal *tmp10 @this
 
   368 set *tmp13 null
   369 label *label216
   370 set :backgroundProcess:unit *tmp13
-    * jump *label217 notEqual *tmp13 null
-    * jump *label226 always
+  371 jump *label226 equal *tmp13 null
   372 label *label217
   373 label *label219
   374 # "Function: void serviceDrill(in drill, in unit)"
 
   393 set .units*6 :backgroundProcess:unit
   394 set :backgroundProcess:drill .titaniumDrills*7
   395 set :backgroundProcess:unit .units*7
-    * jump *label230 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  396 jump *label19 equal :backgroundProcess:drill null
   397 label *label230
   398 sensor *tmp10 :backgroundProcess:unit @controller
   399 jump *label244 equal *tmp10 @this
 
   422 set *tmp13 null
   423 label *label241
   424 set :backgroundProcess:unit *tmp13
-    * jump *label242 notEqual *tmp13 null
-    * jump *label251 always
+  425 jump *label251 equal *tmp13 null
   426 label *label242
   427 label *label244
   428 # "Function: void serviceDrill(in drill, in unit)"
 
   447 set .units*7 :backgroundProcess:unit
   448 set :backgroundProcess:drill .titaniumDrills*8
   449 set :backgroundProcess:unit .units*8
-    * jump *label255 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  450 jump *label19 equal :backgroundProcess:drill null
   451 label *label255
   452 sensor *tmp10 :backgroundProcess:unit @controller
   453 jump *label269 equal *tmp10 @this
 
   476 set *tmp13 null
   477 label *label266
   478 set :backgroundProcess:unit *tmp13
-    * jump *label267 notEqual *tmp13 null
-    * jump *label276 always
+  479 jump *label276 equal *tmp13 null
   480 label *label267
   481 label *label269
   482 # "Function: void serviceDrill(in drill, in unit)"
 
   501 set .units*8 :backgroundProcess:unit
   502 set :backgroundProcess:drill .titaniumDrills*9
   503 set :backgroundProcess:unit .units*9
-    * jump *label280 notEqual :backgroundProcess:drill null
-    * jump *label19 always
+  504 jump *label19 equal :backgroundProcess:drill null
   505 label *label280
   506 sensor *tmp10 :backgroundProcess:unit @controller
   507 jump *label294 equal *tmp10 @this
 
   530 set *tmp13 null
   531 label *label291
   532 set :backgroundProcess:unit *tmp13
-    * jump *label292 notEqual *tmp13 null
-    * jump *label301 always
+  533 jump *label301 equal *tmp13 null
   534 label *label292
   535 label *label294
   536 # "Function: void serviceDrill(in drill, in unit)"

Modifications by Jumps phase, Jump Optimization, pass 6, iteration 1:
 
    16 set :backgroundProcess:drill .titaniumDrills*0
    17 set :backgroundProcess:unit .units*0
    18 jump *label19 equal :backgroundProcess:drill null
-    * label *label55
    19 sensor *tmp10 :backgroundProcess:unit @controller
    20 jump *label69 equal *tmp10 @this
    21 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    44 label *label66
    45 set :backgroundProcess:unit *tmp13
    46 jump *label76 equal *tmp13 null
-    * label *label67
    47 label *label69
    48 # "Function: void serviceDrill(in drill, in unit)"
    49 ubind :backgroundProcess:unit
 
    68 set :backgroundProcess:drill .titaniumDrills*1
    69 set :backgroundProcess:unit .units*1
    70 jump *label19 equal :backgroundProcess:drill null
-    * label *label80
    71 sensor *tmp10 :backgroundProcess:unit @controller
    72 jump *label94 equal *tmp10 @this
    73 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    96 label *label91
    97 set :backgroundProcess:unit *tmp13
    98 jump *label101 equal *tmp13 null
-    * label *label92
    99 label *label94
   100 # "Function: void serviceDrill(in drill, in unit)"
   101 ubind :backgroundProcess:unit
 
   120 set :backgroundProcess:drill .titaniumDrills*2
   121 set :backgroundProcess:unit .units*2
   122 jump *label19 equal :backgroundProcess:drill null
-    * label *label105
   123 sensor *tmp10 :backgroundProcess:unit @controller
   124 jump *label119 equal *tmp10 @this
   125 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   148 label *label116
   149 set :backgroundProcess:unit *tmp13
   150 jump *label126 equal *tmp13 null
-    * label *label117
   151 label *label119
   152 # "Function: void serviceDrill(in drill, in unit)"
   153 ubind :backgroundProcess:unit
 
   172 set :backgroundProcess:drill .titaniumDrills*3
   173 set :backgroundProcess:unit .units*3
   174 jump *label19 equal :backgroundProcess:drill null
-    * label *label130
   175 sensor *tmp10 :backgroundProcess:unit @controller
   176 jump *label144 equal *tmp10 @this
   177 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   200 label *label141
   201 set :backgroundProcess:unit *tmp13
   202 jump *label151 equal *tmp13 null
-    * label *label142
   203 label *label144
   204 # "Function: void serviceDrill(in drill, in unit)"
   205 ubind :backgroundProcess:unit
 
   224 set :backgroundProcess:drill .titaniumDrills*4
   225 set :backgroundProcess:unit .units*4
   226 jump *label19 equal :backgroundProcess:drill null
-    * label *label155
   227 sensor *tmp10 :backgroundProcess:unit @controller
   228 jump *label169 equal *tmp10 @this
   229 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   252 label *label166
   253 set :backgroundProcess:unit *tmp13
   254 jump *label176 equal *tmp13 null
-    * label *label167
   255 label *label169
   256 # "Function: void serviceDrill(in drill, in unit)"
   257 ubind :backgroundProcess:unit
 
   276 set :backgroundProcess:drill .titaniumDrills*5
   277 set :backgroundProcess:unit .units*5
   278 jump *label19 equal :backgroundProcess:drill null
-    * label *label180
   279 sensor *tmp10 :backgroundProcess:unit @controller
   280 jump *label194 equal *tmp10 @this
   281 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   304 label *label191
   305 set :backgroundProcess:unit *tmp13
   306 jump *label201 equal *tmp13 null
-    * label *label192
   307 label *label194
   308 # "Function: void serviceDrill(in drill, in unit)"
   309 ubind :backgroundProcess:unit
 
   328 set :backgroundProcess:drill .titaniumDrills*6
   329 set :backgroundProcess:unit .units*6
   330 jump *label19 equal :backgroundProcess:drill null
-    * label *label205
   331 sensor *tmp10 :backgroundProcess:unit @controller
   332 jump *label219 equal *tmp10 @this
   333 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   356 label *label216
   357 set :backgroundProcess:unit *tmp13
   358 jump *label226 equal *tmp13 null
-    * label *label217
   359 label *label219
   360 # "Function: void serviceDrill(in drill, in unit)"
   361 ubind :backgroundProcess:unit
 
   380 set :backgroundProcess:drill .titaniumDrills*7
   381 set :backgroundProcess:unit .units*7
   382 jump *label19 equal :backgroundProcess:drill null
-    * label *label230
   383 sensor *tmp10 :backgroundProcess:unit @controller
   384 jump *label244 equal *tmp10 @this
   385 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   408 label *label241
   409 set :backgroundProcess:unit *tmp13
   410 jump *label251 equal *tmp13 null
-    * label *label242
   411 label *label244
   412 # "Function: void serviceDrill(in drill, in unit)"
   413 ubind :backgroundProcess:unit
 
   432 set :backgroundProcess:drill .titaniumDrills*8
   433 set :backgroundProcess:unit .units*8
   434 jump *label19 equal :backgroundProcess:drill null
-    * label *label255
   435 sensor *tmp10 :backgroundProcess:unit @controller
   436 jump *label269 equal *tmp10 @this
   437 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   460 label *label266
   461 set :backgroundProcess:unit *tmp13
   462 jump *label276 equal *tmp13 null
-    * label *label267
   463 label *label269
   464 # "Function: void serviceDrill(in drill, in unit)"
   465 ubind :backgroundProcess:unit
 
   484 set :backgroundProcess:drill .titaniumDrills*9
   485 set :backgroundProcess:unit .units*9
   486 jump *label19 equal :backgroundProcess:drill null
-    * label *label280
   487 sensor *tmp10 :backgroundProcess:unit @controller
   488 jump *label294 equal *tmp10 @this
   489 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   512 label *label291
   513 set :backgroundProcess:unit *tmp13
   514 jump *label301 equal *tmp13 null
-    * label *label292
   515 label *label294
   516 # "Function: void serviceDrill(in drill, in unit)"
   517 ubind :backgroundProcess:unit

Modifications by Jumps phase, Jump Threading, pass 6, iteration 1:
 
    15 label *label14
    16 set :backgroundProcess:drill .titaniumDrills*0
    17 set :backgroundProcess:unit .units*0
-    * jump *label19 equal :backgroundProcess:drill null
+   18 jump *label14 equal :backgroundProcess:drill null
    19 sensor *tmp10 :backgroundProcess:unit @controller
    20 jump *label69 equal *tmp10 @this
    21 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    67 set .units*0 :backgroundProcess:unit
    68 set :backgroundProcess:drill .titaniumDrills*1
    69 set :backgroundProcess:unit .units*1
-    * jump *label19 equal :backgroundProcess:drill null
+   70 jump *label14 equal :backgroundProcess:drill null
    71 sensor *tmp10 :backgroundProcess:unit @controller
    72 jump *label94 equal *tmp10 @this
    73 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   119 set .units*1 :backgroundProcess:unit
   120 set :backgroundProcess:drill .titaniumDrills*2
   121 set :backgroundProcess:unit .units*2
-    * jump *label19 equal :backgroundProcess:drill null
+  122 jump *label14 equal :backgroundProcess:drill null
   123 sensor *tmp10 :backgroundProcess:unit @controller
   124 jump *label119 equal *tmp10 @this
   125 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   171 set .units*2 :backgroundProcess:unit
   172 set :backgroundProcess:drill .titaniumDrills*3
   173 set :backgroundProcess:unit .units*3
-    * jump *label19 equal :backgroundProcess:drill null
+  174 jump *label14 equal :backgroundProcess:drill null
   175 sensor *tmp10 :backgroundProcess:unit @controller
   176 jump *label144 equal *tmp10 @this
   177 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   223 set .units*3 :backgroundProcess:unit
   224 set :backgroundProcess:drill .titaniumDrills*4
   225 set :backgroundProcess:unit .units*4
-    * jump *label19 equal :backgroundProcess:drill null
+  226 jump *label14 equal :backgroundProcess:drill null
   227 sensor *tmp10 :backgroundProcess:unit @controller
   228 jump *label169 equal *tmp10 @this
   229 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   275 set .units*4 :backgroundProcess:unit
   276 set :backgroundProcess:drill .titaniumDrills*5
   277 set :backgroundProcess:unit .units*5
-    * jump *label19 equal :backgroundProcess:drill null
+  278 jump *label14 equal :backgroundProcess:drill null
   279 sensor *tmp10 :backgroundProcess:unit @controller
   280 jump *label194 equal *tmp10 @this
   281 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   327 set .units*5 :backgroundProcess:unit
   328 set :backgroundProcess:drill .titaniumDrills*6
   329 set :backgroundProcess:unit .units*6
-    * jump *label19 equal :backgroundProcess:drill null
+  330 jump *label14 equal :backgroundProcess:drill null
   331 sensor *tmp10 :backgroundProcess:unit @controller
   332 jump *label219 equal *tmp10 @this
   333 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   379 set .units*6 :backgroundProcess:unit
   380 set :backgroundProcess:drill .titaniumDrills*7
   381 set :backgroundProcess:unit .units*7
-    * jump *label19 equal :backgroundProcess:drill null
+  382 jump *label14 equal :backgroundProcess:drill null
   383 sensor *tmp10 :backgroundProcess:unit @controller
   384 jump *label244 equal *tmp10 @this
   385 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   431 set .units*7 :backgroundProcess:unit
   432 set :backgroundProcess:drill .titaniumDrills*8
   433 set :backgroundProcess:unit .units*8
-    * jump *label19 equal :backgroundProcess:drill null
+  434 jump *label14 equal :backgroundProcess:drill null
   435 sensor *tmp10 :backgroundProcess:unit @controller
   436 jump *label269 equal *tmp10 @this
   437 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   483 set .units*8 :backgroundProcess:unit
   484 set :backgroundProcess:drill .titaniumDrills*9
   485 set :backgroundProcess:unit .units*9
-    * jump *label19 equal :backgroundProcess:drill null
+  486 jump *label14 equal :backgroundProcess:drill null
   487 sensor *tmp10 :backgroundProcess:unit @controller
   488 jump *label294 equal *tmp10 @this
   489 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-14 instructions):
 
    31 ucontrol flag 0
    32 set *tmp13 @unit
    33 jump *label66 always
-    * jump *label63 always
    34 label *label60
    35 sensor *tmp19 :findFreeUnit:first_unit @dead
    36 jump *label61 notEqual *tmp19 1
 
    82 ucontrol flag 0
    83 set *tmp13 @unit
    84 jump *label91 always
-    * jump *label88 always
    85 label *label85
    86 sensor *tmp19 :findFreeUnit:first_unit @dead
    87 jump *label86 notEqual *tmp19 1
 
   133 ucontrol flag 0
   134 set *tmp13 @unit
   135 jump *label116 always
-    * jump *label113 always
   136 label *label110
   137 sensor *tmp19 :findFreeUnit:first_unit @dead
   138 jump *label111 notEqual *tmp19 1
 
   184 ucontrol flag 0
   185 set *tmp13 @unit
   186 jump *label141 always
-    * jump *label138 always
   187 label *label135
   188 sensor *tmp19 :findFreeUnit:first_unit @dead
   189 jump *label136 notEqual *tmp19 1
 
   235 ucontrol flag 0
   236 set *tmp13 @unit
   237 jump *label166 always
-    * jump *label163 always
   238 label *label160
   239 sensor *tmp19 :findFreeUnit:first_unit @dead
   240 jump *label161 notEqual *tmp19 1
 
   286 ucontrol flag 0
   287 set *tmp13 @unit
   288 jump *label191 always
-    * jump *label188 always
   289 label *label185
   290 sensor *tmp19 :findFreeUnit:first_unit @dead
   291 jump *label186 notEqual *tmp19 1
 
   337 ucontrol flag 0
   338 set *tmp13 @unit
   339 jump *label216 always
-    * jump *label213 always
   340 label *label210
   341 sensor *tmp19 :findFreeUnit:first_unit @dead
   342 jump *label211 notEqual *tmp19 1
 
   388 ucontrol flag 0
   389 set *tmp13 @unit
   390 jump *label241 always
-    * jump *label238 always
   391 label *label235
   392 sensor *tmp19 :findFreeUnit:first_unit @dead
   393 jump *label236 notEqual *tmp19 1
 
   439 ucontrol flag 0
   440 set *tmp13 @unit
   441 jump *label266 always
-    * jump *label263 always
   442 label *label260
   443 sensor *tmp19 :findFreeUnit:first_unit @dead
   444 jump *label261 notEqual *tmp19 1
 
   490 ucontrol flag 0
   491 set *tmp13 @unit
   492 jump *label291 always
-    * jump *label288 always
   493 label *label285
   494 sensor *tmp19 :findFreeUnit:first_unit @dead
   495 jump *label286 notEqual *tmp19 1
 
   523 label *label299
   524 label *label301
   525 set .units*9 :backgroundProcess:unit
-    * label *label19
   526 jump *label14 always
-    * wait 1e12
-    * jump *label7 always
-    * end
   527 label *label0
   528 # "Function: remote void addTitaniumDrill(in drill)"
   529 jump *label52 greaterThanEq .drills 9
 
   563 label *label52
   564 set :addTitaniumDrill*finished true
   565 jump *label7 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 6, iteration 1:
 
    36 jump *label61 notEqual *tmp19 1
    37 set :findFreeUnit:first_unit @unit
    38 label *label61
-    * label *label63
    39 ubind @flare
    40 jump *label59 notEqual :findFreeUnit:first_unit @unit
    41 set *tmp13 null
 
    86 jump *label86 notEqual *tmp19 1
    87 set :findFreeUnit:first_unit @unit
    88 label *label86
-    * label *label88
    89 ubind @flare
    90 jump *label84 notEqual :findFreeUnit:first_unit @unit
    91 set *tmp13 null
 
   136 jump *label111 notEqual *tmp19 1
   137 set :findFreeUnit:first_unit @unit
   138 label *label111
-    * label *label113
   139 ubind @flare
   140 jump *label109 notEqual :findFreeUnit:first_unit @unit
   141 set *tmp13 null
 
   186 jump *label136 notEqual *tmp19 1
   187 set :findFreeUnit:first_unit @unit
   188 label *label136
-    * label *label138
   189 ubind @flare
   190 jump *label134 notEqual :findFreeUnit:first_unit @unit
   191 set *tmp13 null
 
   236 jump *label161 notEqual *tmp19 1
   237 set :findFreeUnit:first_unit @unit
   238 label *label161
-    * label *label163
   239 ubind @flare
   240 jump *label159 notEqual :findFreeUnit:first_unit @unit
   241 set *tmp13 null
 
   286 jump *label186 notEqual *tmp19 1
   287 set :findFreeUnit:first_unit @unit
   288 label *label186
-    * label *label188
   289 ubind @flare
   290 jump *label184 notEqual :findFreeUnit:first_unit @unit
   291 set *tmp13 null
 
   336 jump *label211 notEqual *tmp19 1
   337 set :findFreeUnit:first_unit @unit
   338 label *label211
-    * label *label213
   339 ubind @flare
   340 jump *label209 notEqual :findFreeUnit:first_unit @unit
   341 set *tmp13 null
 
   386 jump *label236 notEqual *tmp19 1
   387 set :findFreeUnit:first_unit @unit
   388 label *label236
-    * label *label238
   389 ubind @flare
   390 jump *label234 notEqual :findFreeUnit:first_unit @unit
   391 set *tmp13 null
 
   436 jump *label261 notEqual *tmp19 1
   437 set :findFreeUnit:first_unit @unit
   438 label *label261
-    * label *label263
   439 ubind @flare
   440 jump *label259 notEqual :findFreeUnit:first_unit @unit
   441 set *tmp13 null
 
   486 jump *label286 notEqual *tmp19 1
   487 set :findFreeUnit:first_unit @unit
   488 label *label286
-    * label *label288
   489 ubind @flare
   490 jump *label284 notEqual :findFreeUnit:first_unit @unit
   491 set *tmp13 null

Final code before resolving virtual instructions:

    0:  jump *label6 always 0 0                                      #set target = 8;
    1:  jump *label0 always 0 0                                      ...
    2:  draw triangle .core .coreX .coreY .drills .titaniumDrills*0 .titaniumDrills*1
    3:  draw triangle .titaniumDrills*2 .titaniumDrills*3 .titaniumDrills*4 .titaniumDrills*5 .titaniumDrills*6 .titaniumDrills*7
    4:  draw triangle .titaniumDrills*8 .titaniumDrills*9 .units*0 .units*1 .units*2 .units*3
    5:  draw triangle .units*4 .units*5 .units*6 .units*7 .units*8 .units*9
    6:  draw triangle :addTitaniumDrill:drill :backgroundProcess:drill :backgroundProcess:unit :findFreeUnit:first_unit :serviceDrill:item 0
        label *label6                                                ...
    7:  set .drills 0                                                volatile var drills = 0;
    8:  set *signature "881dde114374c003:v1"                         #set target = 8;
        label *label7                                                ...
        # "Function: void backgroundProcess()"                       ...
    9:  jump *label9 notEqual .core null                             if core == null then
        label *label11                                               do
   10:  ubind @flare                                                 ubind(@flare);
   11:  ulocate building core false @copper .coreX .coreY 0 .core    core = ulocate(:building, :core, false, out coreX, out coreY);
   12:  jump *label11 equal .core null                               do
   13:  sensor .coreX .core @x                                       coreX = core.@x;
   14:  sensor .coreY .core @y                                       coreY = core.@y;
        label *label9                                                if core == null then
        label *label14                                               while true do
   15:  set :backgroundProcess:drill .titaniumDrills*0               for var drill in titaniumDrills; var out unit in units do
   16:  set :backgroundProcess:unit .units*0                         ...
   17:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
   18:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
   19:  jump *label69 equal *tmp10 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
   20:  ubind @flare                                                 *units: ubind(unit_type);
   21:  jump *label57 notEqual @unit null                            *units: if @unit == null then return null; end;
   22:  set *tmp13 null                                              ...
   23:  jump *label66 always 0 0                                     ...
        label *label57                                               ...
   24:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label59                                               *units: do
   25:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
   26:  jump *label60 notEqual *tmp16 0                              ...
   27:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   28:  set *tmp13 @unit                                             *units: return @unit;
   29:  jump *label66 always 0 0                                     ...
        label *label60                                               *units: if @unit.@controlled == 0 then
   30:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   31:  jump *label61 notEqual *tmp19 1                              ...
   32:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label61                                               *units: elsif first_unit.@dead == 1 then
   33:  ubind @flare                                                 *units: ubind(unit_type);
   34:  jump *label59 notEqual :findFreeUnit:first_unit @unit        *units: do
   35:  set *tmp13 null                                              *units: return null;
        label *label66                                               unit = findFreeUnit(@flare, 0);
   36:  set :backgroundProcess:unit *tmp13                           ...
   37:  jump *label76 equal *tmp13 null                              if unit == null then continue; end;
        label *label69                                               if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
   38:  ubind :backgroundProcess:unit                                ubind(unit);
   39:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
   40:  jump *label71 notEqual :serviceDrill:item @titanium          if item == @titanium then
   41:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
   42:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
   43:  jump *label74 always 0 0                                     if item == @titanium then
        label *label71                                               ...
   44:  jump *label72 notEqual :serviceDrill:item null               elsif item == null then
   45:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
   46:  sensor *tmp32 :backgroundProcess:drill @y                    ...
   47:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
   48:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
   49:  jump *label73 always 0 0                                     elsif item == null then
        label *label72                                               ...
   50:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label73                                               elsif item == null then
        label *label74                                               if item == @titanium then
        label *label76                                               for var drill in titaniumDrills; var out unit in units do
   51:  set .units*0 :backgroundProcess:unit                         ...
   52:  set :backgroundProcess:drill .titaniumDrills*1               ...
   53:  set :backgroundProcess:unit .units*1                         ...
   54:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
   55:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
   56:  jump *label94 equal *tmp10 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
   57:  ubind @flare                                                 *units: ubind(unit_type);
   58:  jump *label82 notEqual @unit null                            *units: if @unit == null then return null; end;
   59:  set *tmp13 null                                              ...
   60:  jump *label91 always 0 0                                     ...
        label *label82                                               ...
   61:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label84                                               *units: do
   62:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
   63:  jump *label85 notEqual *tmp16 0                              ...
   64:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   65:  set *tmp13 @unit                                             *units: return @unit;
   66:  jump *label91 always 0 0                                     ...
        label *label85                                               *units: if @unit.@controlled == 0 then
   67:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   68:  jump *label86 notEqual *tmp19 1                              ...
   69:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label86                                               *units: elsif first_unit.@dead == 1 then
   70:  ubind @flare                                                 *units: ubind(unit_type);
   71:  jump *label84 notEqual :findFreeUnit:first_unit @unit        *units: do
   72:  set *tmp13 null                                              *units: return null;
        label *label91                                               unit = findFreeUnit(@flare, 0);
   73:  set :backgroundProcess:unit *tmp13                           ...
   74:  jump *label101 equal *tmp13 null                             if unit == null then continue; end;
        label *label94                                               if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
   75:  ubind :backgroundProcess:unit                                ubind(unit);
   76:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
   77:  jump *label96 notEqual :serviceDrill:item @titanium          if item == @titanium then
   78:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
   79:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
   80:  jump *label99 always 0 0                                     if item == @titanium then
        label *label96                                               ...
   81:  jump *label97 notEqual :serviceDrill:item null               elsif item == null then
   82:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
   83:  sensor *tmp32 :backgroundProcess:drill @y                    ...
   84:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
   85:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
   86:  jump *label98 always 0 0                                     elsif item == null then
        label *label97                                               ...
   87:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label98                                               elsif item == null then
        label *label99                                               if item == @titanium then
        label *label101                                              for var drill in titaniumDrills; var out unit in units do
   88:  set .units*1 :backgroundProcess:unit                         ...
   89:  set :backgroundProcess:drill .titaniumDrills*2               ...
   90:  set :backgroundProcess:unit .units*2                         ...
   91:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
   92:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
   93:  jump *label119 equal *tmp10 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
   94:  ubind @flare                                                 *units: ubind(unit_type);
   95:  jump *label107 notEqual @unit null                           *units: if @unit == null then return null; end;
   96:  set *tmp13 null                                              ...
   97:  jump *label116 always 0 0                                    ...
        label *label107                                              ...
   98:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label109                                              *units: do
   99:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
  100:  jump *label110 notEqual *tmp16 0                             ...
  101:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  102:  set *tmp13 @unit                                             *units: return @unit;
  103:  jump *label116 always 0 0                                    ...
        label *label110                                              *units: if @unit.@controlled == 0 then
  104:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  105:  jump *label111 notEqual *tmp19 1                             ...
  106:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label111                                              *units: elsif first_unit.@dead == 1 then
  107:  ubind @flare                                                 *units: ubind(unit_type);
  108:  jump *label109 notEqual :findFreeUnit:first_unit @unit       *units: do
  109:  set *tmp13 null                                              *units: return null;
        label *label116                                              unit = findFreeUnit(@flare, 0);
  110:  set :backgroundProcess:unit *tmp13                           ...
  111:  jump *label126 equal *tmp13 null                             if unit == null then continue; end;
        label *label119                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  112:  ubind :backgroundProcess:unit                                ubind(unit);
  113:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  114:  jump *label121 notEqual :serviceDrill:item @titanium         if item == @titanium then
  115:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  116:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  117:  jump *label124 always 0 0                                    if item == @titanium then
        label *label121                                              ...
  118:  jump *label122 notEqual :serviceDrill:item null              elsif item == null then
  119:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  120:  sensor *tmp32 :backgroundProcess:drill @y                    ...
  121:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
  122:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  123:  jump *label123 always 0 0                                    elsif item == null then
        label *label122                                              ...
  124:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label123                                              elsif item == null then
        label *label124                                              if item == @titanium then
        label *label126                                              for var drill in titaniumDrills; var out unit in units do
  125:  set .units*2 :backgroundProcess:unit                         ...
  126:  set :backgroundProcess:drill .titaniumDrills*3               ...
  127:  set :backgroundProcess:unit .units*3                         ...
  128:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
  129:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
  130:  jump *label144 equal *tmp10 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  131:  ubind @flare                                                 *units: ubind(unit_type);
  132:  jump *label132 notEqual @unit null                           *units: if @unit == null then return null; end;
  133:  set *tmp13 null                                              ...
  134:  jump *label141 always 0 0                                    ...
        label *label132                                              ...
  135:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label134                                              *units: do
  136:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
  137:  jump *label135 notEqual *tmp16 0                             ...
  138:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  139:  set *tmp13 @unit                                             *units: return @unit;
  140:  jump *label141 always 0 0                                    ...
        label *label135                                              *units: if @unit.@controlled == 0 then
  141:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  142:  jump *label136 notEqual *tmp19 1                             ...
  143:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label136                                              *units: elsif first_unit.@dead == 1 then
  144:  ubind @flare                                                 *units: ubind(unit_type);
  145:  jump *label134 notEqual :findFreeUnit:first_unit @unit       *units: do
  146:  set *tmp13 null                                              *units: return null;
        label *label141                                              unit = findFreeUnit(@flare, 0);
  147:  set :backgroundProcess:unit *tmp13                           ...
  148:  jump *label151 equal *tmp13 null                             if unit == null then continue; end;
        label *label144                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  149:  ubind :backgroundProcess:unit                                ubind(unit);
  150:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  151:  jump *label146 notEqual :serviceDrill:item @titanium         if item == @titanium then
  152:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  153:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  154:  jump *label149 always 0 0                                    if item == @titanium then
        label *label146                                              ...
  155:  jump *label147 notEqual :serviceDrill:item null              elsif item == null then
  156:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  157:  sensor *tmp32 :backgroundProcess:drill @y                    ...
  158:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
  159:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  160:  jump *label148 always 0 0                                    elsif item == null then
        label *label147                                              ...
  161:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label148                                              elsif item == null then
        label *label149                                              if item == @titanium then
        label *label151                                              for var drill in titaniumDrills; var out unit in units do
  162:  set .units*3 :backgroundProcess:unit                         ...
  163:  set :backgroundProcess:drill .titaniumDrills*4               ...
  164:  set :backgroundProcess:unit .units*4                         ...
  165:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
  166:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
  167:  jump *label169 equal *tmp10 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  168:  ubind @flare                                                 *units: ubind(unit_type);
  169:  jump *label157 notEqual @unit null                           *units: if @unit == null then return null; end;
  170:  set *tmp13 null                                              ...
  171:  jump *label166 always 0 0                                    ...
        label *label157                                              ...
  172:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label159                                              *units: do
  173:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
  174:  jump *label160 notEqual *tmp16 0                             ...
  175:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  176:  set *tmp13 @unit                                             *units: return @unit;
  177:  jump *label166 always 0 0                                    ...
        label *label160                                              *units: if @unit.@controlled == 0 then
  178:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  179:  jump *label161 notEqual *tmp19 1                             ...
  180:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label161                                              *units: elsif first_unit.@dead == 1 then
  181:  ubind @flare                                                 *units: ubind(unit_type);
  182:  jump *label159 notEqual :findFreeUnit:first_unit @unit       *units: do
  183:  set *tmp13 null                                              *units: return null;
        label *label166                                              unit = findFreeUnit(@flare, 0);
  184:  set :backgroundProcess:unit *tmp13                           ...
  185:  jump *label176 equal *tmp13 null                             if unit == null then continue; end;
        label *label169                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  186:  ubind :backgroundProcess:unit                                ubind(unit);
  187:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  188:  jump *label171 notEqual :serviceDrill:item @titanium         if item == @titanium then
  189:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  190:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  191:  jump *label174 always 0 0                                    if item == @titanium then
        label *label171                                              ...
  192:  jump *label172 notEqual :serviceDrill:item null              elsif item == null then
  193:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  194:  sensor *tmp32 :backgroundProcess:drill @y                    ...
  195:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
  196:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  197:  jump *label173 always 0 0                                    elsif item == null then
        label *label172                                              ...
  198:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label173                                              elsif item == null then
        label *label174                                              if item == @titanium then
        label *label176                                              for var drill in titaniumDrills; var out unit in units do
  199:  set .units*4 :backgroundProcess:unit                         ...
  200:  set :backgroundProcess:drill .titaniumDrills*5               ...
  201:  set :backgroundProcess:unit .units*5                         ...
  202:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
  203:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
  204:  jump *label194 equal *tmp10 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  205:  ubind @flare                                                 *units: ubind(unit_type);
  206:  jump *label182 notEqual @unit null                           *units: if @unit == null then return null; end;
  207:  set *tmp13 null                                              ...
  208:  jump *label191 always 0 0                                    ...
        label *label182                                              ...
  209:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label184                                              *units: do
  210:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
  211:  jump *label185 notEqual *tmp16 0                             ...
  212:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  213:  set *tmp13 @unit                                             *units: return @unit;
  214:  jump *label191 always 0 0                                    ...
        label *label185                                              *units: if @unit.@controlled == 0 then
  215:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  216:  jump *label186 notEqual *tmp19 1                             ...
  217:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label186                                              *units: elsif first_unit.@dead == 1 then
  218:  ubind @flare                                                 *units: ubind(unit_type);
  219:  jump *label184 notEqual :findFreeUnit:first_unit @unit       *units: do
  220:  set *tmp13 null                                              *units: return null;
        label *label191                                              unit = findFreeUnit(@flare, 0);
  221:  set :backgroundProcess:unit *tmp13                           ...
  222:  jump *label201 equal *tmp13 null                             if unit == null then continue; end;
        label *label194                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  223:  ubind :backgroundProcess:unit                                ubind(unit);
  224:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  225:  jump *label196 notEqual :serviceDrill:item @titanium         if item == @titanium then
  226:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  227:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  228:  jump *label199 always 0 0                                    if item == @titanium then
        label *label196                                              ...
  229:  jump *label197 notEqual :serviceDrill:item null              elsif item == null then
  230:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  231:  sensor *tmp32 :backgroundProcess:drill @y                    ...
  232:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
  233:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  234:  jump *label198 always 0 0                                    elsif item == null then
        label *label197                                              ...
  235:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label198                                              elsif item == null then
        label *label199                                              if item == @titanium then
        label *label201                                              for var drill in titaniumDrills; var out unit in units do
  236:  set .units*5 :backgroundProcess:unit                         ...
  237:  set :backgroundProcess:drill .titaniumDrills*6               ...
  238:  set :backgroundProcess:unit .units*6                         ...
  239:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
  240:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
  241:  jump *label219 equal *tmp10 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  242:  ubind @flare                                                 *units: ubind(unit_type);
  243:  jump *label207 notEqual @unit null                           *units: if @unit == null then return null; end;
  244:  set *tmp13 null                                              ...
  245:  jump *label216 always 0 0                                    ...
        label *label207                                              ...
  246:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label209                                              *units: do
  247:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
  248:  jump *label210 notEqual *tmp16 0                             ...
  249:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  250:  set *tmp13 @unit                                             *units: return @unit;
  251:  jump *label216 always 0 0                                    ...
        label *label210                                              *units: if @unit.@controlled == 0 then
  252:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  253:  jump *label211 notEqual *tmp19 1                             ...
  254:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label211                                              *units: elsif first_unit.@dead == 1 then
  255:  ubind @flare                                                 *units: ubind(unit_type);
  256:  jump *label209 notEqual :findFreeUnit:first_unit @unit       *units: do
  257:  set *tmp13 null                                              *units: return null;
        label *label216                                              unit = findFreeUnit(@flare, 0);
  258:  set :backgroundProcess:unit *tmp13                           ...
  259:  jump *label226 equal *tmp13 null                             if unit == null then continue; end;
        label *label219                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  260:  ubind :backgroundProcess:unit                                ubind(unit);
  261:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  262:  jump *label221 notEqual :serviceDrill:item @titanium         if item == @titanium then
  263:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  264:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  265:  jump *label224 always 0 0                                    if item == @titanium then
        label *label221                                              ...
  266:  jump *label222 notEqual :serviceDrill:item null              elsif item == null then
  267:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  268:  sensor *tmp32 :backgroundProcess:drill @y                    ...
  269:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
  270:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  271:  jump *label223 always 0 0                                    elsif item == null then
        label *label222                                              ...
  272:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label223                                              elsif item == null then
        label *label224                                              if item == @titanium then
        label *label226                                              for var drill in titaniumDrills; var out unit in units do
  273:  set .units*6 :backgroundProcess:unit                         ...
  274:  set :backgroundProcess:drill .titaniumDrills*7               ...
  275:  set :backgroundProcess:unit .units*7                         ...
  276:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
  277:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
  278:  jump *label244 equal *tmp10 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  279:  ubind @flare                                                 *units: ubind(unit_type);
  280:  jump *label232 notEqual @unit null                           *units: if @unit == null then return null; end;
  281:  set *tmp13 null                                              ...
  282:  jump *label241 always 0 0                                    ...
        label *label232                                              ...
  283:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label234                                              *units: do
  284:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
  285:  jump *label235 notEqual *tmp16 0                             ...
  286:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  287:  set *tmp13 @unit                                             *units: return @unit;
  288:  jump *label241 always 0 0                                    ...
        label *label235                                              *units: if @unit.@controlled == 0 then
  289:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  290:  jump *label236 notEqual *tmp19 1                             ...
  291:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label236                                              *units: elsif first_unit.@dead == 1 then
  292:  ubind @flare                                                 *units: ubind(unit_type);
  293:  jump *label234 notEqual :findFreeUnit:first_unit @unit       *units: do
  294:  set *tmp13 null                                              *units: return null;
        label *label241                                              unit = findFreeUnit(@flare, 0);
  295:  set :backgroundProcess:unit *tmp13                           ...
  296:  jump *label251 equal *tmp13 null                             if unit == null then continue; end;
        label *label244                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  297:  ubind :backgroundProcess:unit                                ubind(unit);
  298:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  299:  jump *label246 notEqual :serviceDrill:item @titanium         if item == @titanium then
  300:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  301:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  302:  jump *label249 always 0 0                                    if item == @titanium then
        label *label246                                              ...
  303:  jump *label247 notEqual :serviceDrill:item null              elsif item == null then
  304:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  305:  sensor *tmp32 :backgroundProcess:drill @y                    ...
  306:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
  307:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  308:  jump *label248 always 0 0                                    elsif item == null then
        label *label247                                              ...
  309:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label248                                              elsif item == null then
        label *label249                                              if item == @titanium then
        label *label251                                              for var drill in titaniumDrills; var out unit in units do
  310:  set .units*7 :backgroundProcess:unit                         ...
  311:  set :backgroundProcess:drill .titaniumDrills*8               ...
  312:  set :backgroundProcess:unit .units*8                         ...
  313:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
  314:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
  315:  jump *label269 equal *tmp10 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  316:  ubind @flare                                                 *units: ubind(unit_type);
  317:  jump *label257 notEqual @unit null                           *units: if @unit == null then return null; end;
  318:  set *tmp13 null                                              ...
  319:  jump *label266 always 0 0                                    ...
        label *label257                                              ...
  320:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label259                                              *units: do
  321:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
  322:  jump *label260 notEqual *tmp16 0                             ...
  323:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  324:  set *tmp13 @unit                                             *units: return @unit;
  325:  jump *label266 always 0 0                                    ...
        label *label260                                              *units: if @unit.@controlled == 0 then
  326:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  327:  jump *label261 notEqual *tmp19 1                             ...
  328:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label261                                              *units: elsif first_unit.@dead == 1 then
  329:  ubind @flare                                                 *units: ubind(unit_type);
  330:  jump *label259 notEqual :findFreeUnit:first_unit @unit       *units: do
  331:  set *tmp13 null                                              *units: return null;
        label *label266                                              unit = findFreeUnit(@flare, 0);
  332:  set :backgroundProcess:unit *tmp13                           ...
  333:  jump *label276 equal *tmp13 null                             if unit == null then continue; end;
        label *label269                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  334:  ubind :backgroundProcess:unit                                ubind(unit);
  335:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  336:  jump *label271 notEqual :serviceDrill:item @titanium         if item == @titanium then
  337:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  338:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  339:  jump *label274 always 0 0                                    if item == @titanium then
        label *label271                                              ...
  340:  jump *label272 notEqual :serviceDrill:item null              elsif item == null then
  341:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  342:  sensor *tmp32 :backgroundProcess:drill @y                    ...
  343:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
  344:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  345:  jump *label273 always 0 0                                    elsif item == null then
        label *label272                                              ...
  346:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label273                                              elsif item == null then
        label *label274                                              if item == @titanium then
        label *label276                                              for var drill in titaniumDrills; var out unit in units do
  347:  set .units*8 :backgroundProcess:unit                         ...
  348:  set :backgroundProcess:drill .titaniumDrills*9               ...
  349:  set :backgroundProcess:unit .units*9                         ...
  350:  jump *label14 equal :backgroundProcess:drill null            if drill == null then break; end;
  351:  sensor *tmp10 :backgroundProcess:unit @controller            if unit.@controller != @this then
  352:  jump *label294 equal *tmp10 @this                            ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  353:  ubind @flare                                                 *units: ubind(unit_type);
  354:  jump *label282 notEqual @unit null                           *units: if @unit == null then return null; end;
  355:  set *tmp13 null                                              ...
  356:  jump *label291 always 0 0                                    ...
        label *label282                                              ...
  357:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label284                                              *units: do
  358:  sensor *tmp16 @unit @controlled                              *units: if @unit.@controlled == 0 then
  359:  jump *label285 notEqual *tmp16 0                             ...
  360:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  361:  set *tmp13 @unit                                             *units: return @unit;
  362:  jump *label291 always 0 0                                    ...
        label *label285                                              *units: if @unit.@controlled == 0 then
  363:  sensor *tmp19 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  364:  jump *label286 notEqual *tmp19 1                             ...
  365:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label286                                              *units: elsif first_unit.@dead == 1 then
  366:  ubind @flare                                                 *units: ubind(unit_type);
  367:  jump *label284 notEqual :findFreeUnit:first_unit @unit       *units: do
  368:  set *tmp13 null                                              *units: return null;
        label *label291                                              unit = findFreeUnit(@flare, 0);
  369:  set :backgroundProcess:unit *tmp13                           ...
  370:  jump *label301 equal *tmp13 null                             if unit == null then continue; end;
        label *label294                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  371:  ubind :backgroundProcess:unit                                ubind(unit);
  372:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  373:  jump *label296 notEqual :serviceDrill:item @titanium         if item == @titanium then
  374:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  375:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  376:  jump *label299 always 0 0                                    if item == @titanium then
        label *label296                                              ...
  377:  jump *label297 notEqual :serviceDrill:item null              elsif item == null then
  378:  sensor *tmp31 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  379:  sensor *tmp32 :backgroundProcess:drill @y                    ...
  380:  ucontrol approach *tmp31 *tmp32 4 0 0                        ...
  381:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  382:  jump *label298 always 0 0                                    elsif item == null then
        label *label297                                              ...
  383:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label298                                              elsif item == null then
        label *label299                                              if item == @titanium then
        label *label301                                              for var drill in titaniumDrills; var out unit in units do
  384:  set .units*9 :backgroundProcess:unit                         ...
  385:  jump *label14 always 0 0                                     while true do
        label *label0                                                remote void addTitaniumDrill(drill)
        # "Function: remote void addTitaniumDrill(in drill)"         ...
  386:  jump *label52 greaterThanEq .drills 9                        if drills < length(titaniumDrills) - 1 then
  387:  op mul *tmp38 .drills 2                                      titaniumDrills[drills] = drill;
  388:  multijump *label306 *tmp38 0                                 ...
        multilabel *label306                                         ...
  389:  set .titaniumDrills*0 :addTitaniumDrill:drill                ...
  390:  jump *label305 always 0 0                                    ...
        multilabel *label307                                         ...
  391:  set .titaniumDrills*1 :addTitaniumDrill:drill                ...
  392:  jump *label305 always 0 0                                    ...
        multilabel *label308                                         ...
  393:  set .titaniumDrills*2 :addTitaniumDrill:drill                ...
  394:  jump *label305 always 0 0                                    ...
        multilabel *label309                                         ...
  395:  set .titaniumDrills*3 :addTitaniumDrill:drill                ...
  396:  jump *label305 always 0 0                                    ...
        multilabel *label310                                         ...
  397:  set .titaniumDrills*4 :addTitaniumDrill:drill                ...
  398:  jump *label305 always 0 0                                    ...
        multilabel *label311                                         ...
  399:  set .titaniumDrills*5 :addTitaniumDrill:drill                ...
  400:  jump *label305 always 0 0                                    ...
        multilabel *label312                                         ...
  401:  set .titaniumDrills*6 :addTitaniumDrill:drill                ...
  402:  jump *label305 always 0 0                                    ...
        multilabel *label313                                         ...
  403:  set .titaniumDrills*7 :addTitaniumDrill:drill                ...
  404:  jump *label305 always 0 0                                    ...
        multilabel *label314                                         ...
  405:  set .titaniumDrills*8 :addTitaniumDrill:drill                ...
  406:  jump *label305 always 0 0                                    ...
        multilabel *label315                                         ...
  407:  set .titaniumDrills*9 :addTitaniumDrill:drill                ...
        label *label305                                              ...
  408:  op add .drills .drills 1                                     if drills < length(titaniumDrills) - 1 then
        label *label52                                               ...
  409:  set :addTitaniumDrill*finished true                          remote void addTitaniumDrill(drill)
  410:  jump *label7 always 0 0                                      ...


Performance: parsed in 283 ms, compiled in 298 ms, optimized in 477 ms, run in 22 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (5 steps):
The program didn't generate any output.
Execution exception at instruction 10: ubind @flare:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
