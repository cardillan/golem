    96 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (2 iterations).
    17 instructions eliminated by Dead Code Elimination (5 iterations).
C:\Home\golem\jam-202507\FlareController.mnd:22:21 Variable 'status2.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:22:27 Variable 'status2.item' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:22:33 Variable 'status2.block' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:25:21 Variable 'status3.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:25:21 Variable 'status3.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:25:21 Variable 'status3.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:29 Variable 'transportStatus.target' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:29 Variable 'transportStatus.target' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:37 Variable 'transportStatus.item' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:37 Variable 'transportStatus.item' is not used.
C:\Home\golem\jam-202507\Actions.mnd:8:14 Variable 'ERROR' is not used.
     1 instructions eliminated by Jump Normalization (4 iterations).
     7 instructions eliminated by Jump Optimization (4 iterations).
     2 instructions eliminated by Single Step Elimination (5 iterations).
    10 instructions eliminated by Data Flow Optimization (8 iterations).
     3 instructions added by Loop Optimization (2 iterations).
     3 loops improved by Loop Optimization.
     2 instructions updated by JumpThreading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    57 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 943):
  * Replicate loop condition at Actions.mnd:45:5                 size    +1, benefit      625.0, efficiency    625.000 (+1 instructions)
    Replicate loop condition at Actions.mnd:23:5                 size    +1, benefit      312.5, efficiency    312.500
    Replicate loop condition at Actions.mnd:68:9                 size    +1, benefit      312.5, efficiency    312.500

Pass 1: speed optimization selection (cost limit 942):
  * Replicate loop condition at Actions.mnd:23:5                 size    +1, benefit      312.5, efficiency    312.500 (+1 instructions)
    Replicate loop condition at Actions.mnd:68:9                 size    +1, benefit      312.5, efficiency    312.500

Pass 1: speed optimization selection (cost limit 941):
  * Replicate loop condition at Actions.mnd:68:9                 size    +1, benefit      312.5, efficiency    312.500 (+1 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-16 instructions):
 
    14 set :fetchBlock:block .drill
    15 set :fetchBlock:item @titanium
    16 sensor *tmp4 :fetchBlock:block @itemCapacity
-    * set :transportStatus:target *tmp4
-    * set :transportStatus:item :fetchBlock:item
    17 label *label14
-    * set :status2:text "Fetching "
-    * set :status2:item :fetchBlock:item
-    * set :status2:block :fetchBlock:block
    18 label *label15
    19 sensor *tmp5 :fetchBlock:block @x
    20 sensor *tmp6 :fetchBlock:block @y
    21 set :moveToEmpty:x *tmp5
    22 set :moveToEmpty:y *tmp6
-    * set :status3:text "Moving..."
    23 label *label17
    24 label *label18
    25 sensor *tmp7 @unit @firstItem
    26 op notEqual *tmp8 *tmp7 null
    27 jump *label21 equal *tmp8 false
    28 ucontrol itemDrop @air 1000
-    * set *tmp9 null
    29 jump *label22 always
    30 label *label21
-    * set *tmp9 null
    31 label *label22
    32 ucontrol approach :moveToEmpty:x :moveToEmpty:y 5.5
    33 label *label19
 
    54 op land *tmp17 *tmp15 *tmp16
    55 jump *label30 equal *tmp17 false
    56 ucontrol itemDrop @air 1000
-    * set *tmp18 null
    57 jump *label31 always
    58 label *label30
-    * set *tmp18 null
    59 label *label31
    60 label *label28
    61 sensor *tmp19 @unit :fetchBlock:item
 
    66 label *label29
    67 set :depositItems:block .core
    68 set :depositItems:item :fetchBlock:item
-    * set :status3.1:text "Depositing..."
    69 label *label33
    70 sensor *tmp23 @unit @firstItem
    71 op equal *tmp24 *tmp23 :depositItems:item
 
    77 set :moveTo.1:x *tmp26
    78 set :moveTo.1:y *tmp27
    79 set :moveTo.1:radius :moveToBlock:radius
-    * set :status3.2:text "Moving..."
    80 label *label38
    81 label *label39
    82 ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp28
 
   100 op greaterThan *tmp35 *tmp33 *tmp34
   101 jump *label42 notEqual *tmp35 false
   102 label *label44
-    * set *tmp25 null
   103 jump *label35 always
   104 label *label34
   105 label *label45
 
   110 label *label46
   111 jump *label45 always
   112 label *label47
-    * set *tmp25 null
   113 label *label35
-    * set :transportStatus.1:target 0
-    * set :transportStatus.1:item null
   114 label *label48
   115 label *label32
   116 label *label13

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-1 instructions):
 
    13 jump *label12 equal true false
    14 set :fetchBlock:block .drill
    15 set :fetchBlock:item @titanium
-    * sensor *tmp4 :fetchBlock:block @itemCapacity
    16 label *label14
    17 label *label15
    18 sensor *tmp5 :fetchBlock:block @x

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
    46 label *label23
    47 label *label27
    48 ucontrol itemTake :fetchBlock:block :fetchBlock:item 10
-    * sensor *tmp14 @unit @firstItem
-    * set :fetchBlock:unitItem *tmp14
+   49 sensor :fetchBlock:unitItem @unit @firstItem
    50 op notEqual *tmp15 :fetchBlock:unitItem null
    51 op notEqual *tmp16 :fetchBlock:unitItem :fetchBlock:item
    52 op land *tmp17 *tmp15 *tmp16
 
    87 label *label41
    88 label *label37
    89 label *label36
-    * sensor *tmp31 :depositItems:block @itemCapacity
-    * set :depositItems:cap *tmp31
+   90 sensor :depositItems:cap :depositItems:block @itemCapacity
    91 label *label42
    92 ucontrol itemDrop :depositItems:block 10
    93 label *label43

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    10 jump *label7 notEqual *tmp3 false
    11 label *label9
    12 label *label10
-    * jump *label12 equal true false
    13 set :fetchBlock:block .drill
    14 set :fetchBlock:item @titanium
    15 label *label14

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-7 instructions):
 
    21 label *label17
    22 label *label18
    23 sensor *tmp7 @unit @firstItem
-    * op notEqual *tmp8 *tmp7 null
-    * jump *label21 equal *tmp8 false
+   24 jump *label21 equal *tmp7 null
    25 ucontrol itemDrop @air 1000
    26 jump *label22 always
    27 label *label21
 
    29 ucontrol approach :moveToEmpty:x :moveToEmpty:y 5.5
    30 label *label19
    31 ucontrol within :moveToEmpty:x :moveToEmpty:y 6 *tmp10
-    * op equal *tmp11 *tmp10 false
-    * jump *label18 notEqual *tmp11 false
+   32 jump *label18 equal *tmp10 false
    33 label *label20
    34 label *label16
    35 label *label24
    36 sensor *tmp12 @unit @firstItem
-    * op notEqual *tmp13 *tmp12 null
-    * jump *label26 equal *tmp13 false
+   37 jump *label26 equal *tmp12 null
    38 ucontrol itemDrop @air 1000
    39 label *label25
    40 jump *label24 always
 
    62 set :depositItems:item :fetchBlock:item
    63 label *label33
    64 sensor *tmp23 @unit @firstItem
-    * op equal *tmp24 *tmp23 :depositItems:item
-    * jump *label34 equal *tmp24 false
+   65 jump *label34 notEqual *tmp23 :depositItems:item
    66 set :moveToBlock:block :depositItems:block
    67 set :moveToBlock:radius 6
    68 sensor *tmp26 :moveToBlock:block @x
 
    73 label *label38
    74 label *label39
    75 ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp28
-    * op equal *tmp29 *tmp28 false
-    * jump *label41 equal *tmp29 false
+   76 jump *label41 notEqual *tmp28 false
    77 op sub *tmp30 :moveTo.1:radius 0.5
    78 ucontrol approach :moveTo.1:x :moveTo.1:y *tmp30
    79 label *label40
 
    88 sensor *tmp32 @unit @firstItem
    89 op mul *tmp33 *tmp32 :depositItems:cap
    90 sensor *tmp34 :depositItems:block :depositItems:item
-    * op greaterThan *tmp35 *tmp33 *tmp34
-    * jump *label42 notEqual *tmp35 false
+   91 jump *label42 greaterThan *tmp33 *tmp34
    92 label *label44
    93 jump *label35 always
    94 label *label34
    95 label *label45
    96 sensor *tmp36 @unit @firstItem
-    * op notEqual *tmp37 *tmp36 null
-    * jump *label47 equal *tmp37 false
+   97 jump *label47 equal *tmp36 null
    98 ucontrol itemDrop @air 1000
    99 label *label46
   100 jump *label45 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    23 sensor *tmp7 @unit @firstItem
    24 jump *label21 equal *tmp7 null
    25 ucontrol itemDrop @air 1000
-    * jump *label22 always
    26 label *label21
    27 label *label22
    28 ucontrol approach :moveToEmpty:x :moveToEmpty:y 5.5
 
    47 op land *tmp17 *tmp15 *tmp16
    48 jump *label30 equal *tmp17 false
    49 ucontrol itemDrop @air 1000
-    * jump *label31 always
    50 label *label30
    51 label *label31
    52 label *label28

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    25 ucontrol itemDrop @air 1000
    26 label *label21
    27 label *label22
-    * ucontrol approach :moveToEmpty:x :moveToEmpty:y 5.5
+   28 ucontrol approach *tmp5 *tmp6 5.5
    29 label *label19
-    * ucontrol within :moveToEmpty:x :moveToEmpty:y 6 *tmp10
+   30 ucontrol within *tmp5 *tmp6 6 *tmp10
    31 jump *label18 equal *tmp10 false
    32 label *label20
    33 label *label16
 
    40 label *label26
    41 label *label23
    42 label *label27
-    * ucontrol itemTake :fetchBlock:block :fetchBlock:item 10
+   43 ucontrol itemTake :fetchBlock:block @titanium 10
    44 sensor :fetchBlock:unitItem @unit @firstItem
    45 op notEqual *tmp15 :fetchBlock:unitItem null
-    * op notEqual *tmp16 :fetchBlock:unitItem :fetchBlock:item
+   46 op notEqual *tmp16 :fetchBlock:unitItem @titanium
    47 op land *tmp17 *tmp15 *tmp16
    48 jump *label30 equal *tmp17 false
    49 ucontrol itemDrop @air 1000
    50 label *label30
    51 label *label31
    52 label *label28
-    * sensor *tmp19 @unit :fetchBlock:item
+   53 sensor *tmp19 @unit @titanium
    54 op lessThan *tmp20 *tmp19 10
-    * sensor *tmp21 :fetchBlock:block :fetchBlock:item
+   55 sensor *tmp21 :fetchBlock:block @titanium
    56 op land *tmp22 *tmp20 *tmp21
    57 jump *label27 notEqual *tmp22 false
    58 label *label29
    59 set :depositItems:block .core
-    * set :depositItems:item :fetchBlock:item
+   60 set :depositItems:item @titanium
    61 label *label33
    62 sensor *tmp23 @unit @firstItem
-    * jump *label34 notEqual *tmp23 :depositItems:item
+   63 jump *label34 notEqual *tmp23 :fetchBlock:item
    64 set :moveToBlock:block :depositItems:block
    65 set :moveToBlock:radius 6
-    * sensor *tmp26 :moveToBlock:block @x
-    * sensor *tmp27 :moveToBlock:block @y
+   66 sensor *tmp26 :depositItems:block @x
+   67 sensor *tmp27 :depositItems:block @y
    68 set :moveTo.1:x *tmp26
    69 set :moveTo.1:y *tmp27
-    * set :moveTo.1:radius :moveToBlock:radius
+   70 set :moveTo.1:radius 6
    71 label *label38
    72 label *label39
-    * ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp28
+   73 ucontrol within *tmp26 *tmp27 :moveToBlock:radius *tmp28
    74 jump *label41 notEqual *tmp28 false
-    * op sub *tmp30 :moveTo.1:radius 0.5
-    * ucontrol approach :moveTo.1:x :moveTo.1:y *tmp30
+   75 op sub *tmp30 :moveToBlock:radius 0.5
+   76 ucontrol approach *tmp26 *tmp27 *tmp30
    77 label *label40
    78 jump *label39 always
    79 label *label41
 
    85 label *label43
    86 sensor *tmp32 @unit @firstItem
    87 op mul *tmp33 *tmp32 :depositItems:cap
-    * sensor *tmp34 :depositItems:block :depositItems:item
+   88 sensor *tmp34 :depositItems:block :fetchBlock:item
    89 jump *label42 greaterThan *tmp33 *tmp34
    90 label *label44
    91 jump *label35 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
    16 label *label15
    17 sensor *tmp5 :fetchBlock:block @x
    18 sensor *tmp6 :fetchBlock:block @y
-    * set :moveToEmpty:x *tmp5
-    * set :moveToEmpty:y *tmp6
    19 label *label17
    20 label *label18
    21 sensor *tmp7 @unit @firstItem
 
    55 jump *label27 notEqual *tmp22 false
    56 label *label29
    57 set :depositItems:block .core
-    * set :depositItems:item @titanium
    58 label *label33
    59 sensor *tmp23 @unit @firstItem
-    * jump *label34 notEqual *tmp23 :fetchBlock:item
-    * set :moveToBlock:block :depositItems:block
+   60 jump *label34 notEqual *tmp23 @titanium
    61 set :moveToBlock:radius 6
    62 sensor *tmp26 :depositItems:block @x
    63 sensor *tmp27 :depositItems:block @y
-    * set :moveTo.1:x *tmp26
-    * set :moveTo.1:y *tmp27
-    * set :moveTo.1:radius 6
    64 label *label38
    65 label *label39
-    * ucontrol within *tmp26 *tmp27 :moveToBlock:radius *tmp28
+   66 ucontrol within *tmp26 *tmp27 6 *tmp28
    67 jump *label41 notEqual *tmp28 false
-    * op sub *tmp30 :moveToBlock:radius 0.5
-    * ucontrol approach *tmp26 *tmp27 *tmp30
+   68 op sub *tmp30 6 0.5
+   69 ucontrol approach *tmp26 *tmp27 5.5
    70 label *label40
    71 jump *label39 always
    72 label *label41
 
    78 label *label43
    79 sensor *tmp32 @unit @firstItem
    80 op mul *tmp33 *tmp32 :depositItems:cap
-    * sensor *tmp34 :depositItems:block :fetchBlock:item
+   81 sensor *tmp34 :depositItems:block @titanium
    82 jump *label42 greaterThan *tmp33 *tmp34
    83 label *label44
    84 jump *label35 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
    11 label *label9
    12 label *label10
    13 set :fetchBlock:block .drill
-    * set :fetchBlock:item @titanium
    14 label *label14
    15 label *label15
    16 sensor *tmp5 :fetchBlock:block @x
 
    57 label *label33
    58 sensor *tmp23 @unit @firstItem
    59 jump *label34 notEqual *tmp23 @titanium
-    * set :moveToBlock:radius 6
    60 sensor *tmp26 :depositItems:block @x
    61 sensor *tmp27 :depositItems:block @y
    62 label *label38
    63 label *label39
    64 ucontrol within *tmp26 *tmp27 6 *tmp28
    65 jump *label41 notEqual *tmp28 false
-    * op sub *tmp30 6 0.5
    66 ucontrol approach *tmp26 *tmp27 5.5
    67 label *label40
    68 jump *label39 always

Modifications by Replicate loop condition at Actions.mnd:45:5 (+1 instructions):
 
    31 label *label24
    32 sensor *tmp12 @unit @firstItem
    33 jump *label26 equal *tmp12 null
+   34 label *label107
    35 ucontrol itemDrop @air 1000
    36 label *label25
-    * jump *label24 always
+   37 sensor *tmp12 @unit @firstItem
+   38 jump *label107 notEqual *tmp12 null
    39 label *label26
    40 label *label23
    41 label *label27

Modifications by Replicate loop condition at Actions.mnd:23:5 (+1 instructions):
 
    65 label *label39
    66 ucontrol within *tmp26 *tmp27 6 *tmp28
    67 jump *label41 notEqual *tmp28 false
+   68 label *label108
    69 ucontrol approach *tmp26 *tmp27 5.5
    70 label *label40
-    * jump *label39 always
+   71 ucontrol within *tmp26 *tmp27 6 *tmp28
+   72 jump *label108 equal *tmp28 false
    73 label *label41
    74 label *label37
    75 label *label36

Modifications by Replicate loop condition at Actions.mnd:68:9 (+1 instructions):
 
    87 label *label45
    88 sensor *tmp36 @unit @firstItem
    89 jump *label47 equal *tmp36 null
+   90 label *label109
    91 ucontrol itemDrop @air 1000
    92 label *label46
-    * jump *label45 always
+   93 sensor *tmp36 @unit @firstItem
+   94 jump *label109 notEqual *tmp36 null
    95 label *label47
    96 label *label35
    97 label *label48

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
     2 label *label5
     3 label *label7
     4 ubind @flare
-    * label *label8
     5 op equal *tmp0 @unit null
     6 sensor *tmp1 @unit @controller
     7 op notEqual *tmp2 *tmp1 null
     8 op or *tmp3 *tmp0 *tmp2
     9 jump *label7 notEqual *tmp3 false
-    * label *label9
    10 label *label10
    11 set :fetchBlock:block .drill
-    * label *label14
-    * label *label15
    12 sensor *tmp5 :fetchBlock:block @x
    13 sensor *tmp6 :fetchBlock:block @y
-    * label *label17
    14 label *label18
    15 sensor *tmp7 @unit @firstItem
    16 jump *label21 equal *tmp7 null
    17 ucontrol itemDrop @air 1000
    18 label *label21
-    * label *label22
    19 ucontrol approach *tmp5 *tmp6 5.5
-    * label *label19
    20 ucontrol within *tmp5 *tmp6 6 *tmp10
    21 jump *label18 equal *tmp10 false
-    * label *label20
-    * label *label16
-    * label *label24
    22 sensor *tmp12 @unit @firstItem
    23 jump *label26 equal *tmp12 null
    24 label *label107
    25 ucontrol itemDrop @air 1000
-    * label *label25
    26 sensor *tmp12 @unit @firstItem
    27 jump *label107 notEqual *tmp12 null
    28 label *label26
-    * label *label23
    29 label *label27
    30 ucontrol itemTake :fetchBlock:block @titanium 10
    31 sensor :fetchBlock:unitItem @unit @firstItem
 
    35 jump *label30 equal *tmp17 false
    36 ucontrol itemDrop @air 1000
    37 label *label30
-    * label *label31
-    * label *label28
    38 sensor *tmp19 @unit @titanium
    39 op lessThan *tmp20 *tmp19 10
    40 sensor *tmp21 :fetchBlock:block @titanium
    41 op land *tmp22 *tmp20 *tmp21
    42 jump *label27 notEqual *tmp22 false
-    * label *label29
    43 set :depositItems:block .core
-    * label *label33
    44 sensor *tmp23 @unit @firstItem
    45 jump *label34 notEqual *tmp23 @titanium
    46 sensor *tmp26 :depositItems:block @x
    47 sensor *tmp27 :depositItems:block @y
-    * label *label38
-    * label *label39
    48 ucontrol within *tmp26 *tmp27 6 *tmp28
    49 jump *label41 notEqual *tmp28 false
    50 label *label108
    51 ucontrol approach *tmp26 *tmp27 5.5
-    * label *label40
    52 ucontrol within *tmp26 *tmp27 6 *tmp28
    53 jump *label108 equal *tmp28 false
    54 label *label41
-    * label *label37
-    * label *label36
    55 sensor :depositItems:cap :depositItems:block @itemCapacity
    56 label *label42
    57 ucontrol itemDrop :depositItems:block 10
-    * label *label43
    58 sensor *tmp32 @unit @firstItem
    59 op mul *tmp33 *tmp32 :depositItems:cap
    60 sensor *tmp34 :depositItems:block @titanium
    61 jump *label42 greaterThan *tmp33 *tmp34
-    * label *label44
    62 jump *label35 always
    63 label *label34
-    * label *label45
    64 sensor *tmp36 @unit @firstItem
    65 jump *label47 equal *tmp36 null
    66 label *label109
    67 ucontrol itemDrop @air 1000
-    * label *label46
    68 sensor *tmp36 @unit @firstItem
    69 jump *label109 notEqual *tmp36 null
    70 label *label47
    71 label *label35
-    * label *label48
-    * label *label32
-    * label *label13
-    * label *label11
    72 jump *label10 always
-    * label *label12
-    * label *label6
    73 wait 1e12
    74 jump *label5 always
    75 end

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
 
    59 op mul *tmp33 *tmp32 :depositItems:cap
    60 sensor *tmp34 :depositItems:block @titanium
    61 jump *label42 greaterThan *tmp33 *tmp34
-    * jump *label35 always
+   62 jump *label10 always
    63 label *label34
    64 sensor *tmp36 @unit @firstItem
-    * jump *label47 equal *tmp36 null
+   65 jump *label10 equal *tmp36 null
    66 label *label109
    67 ucontrol itemDrop @air 1000
    68 sensor *tmp36 @unit @firstItem

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-3 instructions):
 
    67 ucontrol itemDrop @air 1000
    68 sensor *tmp36 @unit @firstItem
    69 jump *label109 notEqual *tmp36 null
-    * label *label47
-    * label *label35
    70 jump *label10 always
-    * wait 1e12
-    * jump *label5 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 3, iteration 1:
     0 set .ERROR ""
     1 set *signature "0:v1"
-    * label *label5
     2 label *label7
     3 ubind @flare
     4 op equal *tmp0 @unit null

Final code before resolving virtual instructions:

    0:  jump *label110 always 0 0
    1:  draw triangle .ERROR .core .drill :depositItems:block :depositItems:cap :fetchBlock:block
    2:  draw triangle :fetchBlock:unitItem 0 0 0 0 0
        label *label110
    3:  set .ERROR ""                                                Actions.mnd: volatile var ERROR = "";
    4:  set *signature "0:v1"                                        FlareController.mnd: #set target = 8;
        label *label7                                                FlareController.mnd: do
    5:  ubind @flare                                                 FlareController.mnd: ubind(@flare);
    6:  op equal *tmp0 @unit null                                    FlareController.mnd: while @unit == null or @unit.@controller != null;
    7:  sensor *tmp1 @unit @controller                               ...
    8:  op notEqual *tmp2 *tmp1 null                                 ...
    9:  op or *tmp3 *tmp0 *tmp2                                      ...
   10:  jump *label7 notEqual *tmp3 false                            FlareController.mnd: do
        label *label10                                               FlareController.mnd: while true do
   11:  set :fetchBlock:block .drill                                 FlareController.mnd: fetchBlock(drill, @titanium);
   12:  sensor *tmp5 :fetchBlock:block @x                            Actions.mnd: moveToEmpty(block.@x, block.@y);
   13:  sensor *tmp6 :fetchBlock:block @y                            ...
        label *label18                                               Actions.mnd: do
   14:  sensor *tmp7 @unit @firstItem                                Actions.mnd: if @unit.@firstItem != null then itemDrop(@air, 1000); end;
   15:  jump *label21 equal *tmp7 null                               ...
   16:  ucontrol itemDrop @air 1000 0 0 0                            ...
        label *label21                                               ...
   17:  ucontrol approach *tmp5 *tmp6 5.5 0 0                        Actions.mnd: approach(x, y, RADIUS - 0.5);
   18:  ucontrol within *tmp5 *tmp6 6 *tmp10 0                       Actions.mnd: while !within(x, y, RADIUS);
   19:  jump *label18 equal *tmp10 false                             Actions.mnd: do
   20:  sensor *tmp12 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   21:  jump *label26 equal *tmp12 null                              ...
        label *label107                                              ...
   22:  ucontrol itemDrop @air 1000 0 0 0                            Actions.mnd: itemDrop(@air, 1000);
   23:  sensor *tmp12 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   24:  jump *label107 notEqual *tmp12 null                          ...
        label *label26                                               ...
        label *label27                                               Actions.mnd: do
   25:  ucontrol itemTake :fetchBlock:block @titanium 10 0 0         Actions.mnd: itemTake(block, item, capacity);
   26:  sensor :fetchBlock:unitItem @unit @firstItem                 Actions.mnd: var unitItem = @unit.@firstItem;
   27:  op notEqual *tmp15 :fetchBlock:unitItem null                 Actions.mnd: if unitItem != null and unitItem != item then
   28:  op notEqual *tmp16 :fetchBlock:unitItem @titanium            ...
   29:  op land *tmp17 *tmp15 *tmp16                                 ...
   30:  jump *label30 equal *tmp17 false                             ...
   31:  ucontrol itemDrop @air 1000 0 0 0                            Actions.mnd: itemDrop(@air, 1000);
        label *label30                                               Actions.mnd: if unitItem != null and unitItem != item then
   32:  sensor *tmp19 @unit @titanium                                Actions.mnd: while @unit.sensor(item) < capacity and block.sensor(item);
   33:  op lessThan *tmp20 *tmp19 10                                 ...
   34:  sensor *tmp21 :fetchBlock:block @titanium                    ...
   35:  op land *tmp22 *tmp20 *tmp21                                 ...
   36:  jump *label27 notEqual *tmp22 false                          Actions.mnd: do
   37:  set :depositItems:block .core                                Actions.mnd: depositItems(core, item);
   38:  sensor *tmp23 @unit @firstItem                               Actions.mnd: if @unit.@firstItem == item then
   39:  jump *label34 notEqual *tmp23 @titanium                      ...
   40:  sensor *tmp26 :depositItems:block @x                         Actions.mnd: moveTo(block.@x, block.@y, radius);
   41:  sensor *tmp27 :depositItems:block @y                         ...
   42:  ucontrol within *tmp26 *tmp27 6 *tmp28 0                     Actions.mnd: while !within(x, y, radius) do
   43:  jump *label41 notEqual *tmp28 false                          ...
        label *label108                                              ...
   44:  ucontrol approach *tmp26 *tmp27 5.5 0 0                      Actions.mnd: approach(x, y, radius - 0.5);
   45:  ucontrol within *tmp26 *tmp27 6 *tmp28 0                     Actions.mnd: while !within(x, y, radius) do
   46:  jump *label108 equal *tmp28 false                            ...
        label *label41                                               ...
   47:  sensor :depositItems:cap :depositItems:block @itemCapacity   Actions.mnd: var cap = block.@itemCapacity;
        label *label42                                               Actions.mnd: do
   48:  ucontrol itemDrop :depositItems:block 10 0 0 0               Actions.mnd: itemDrop(block, capacity);
   49:  sensor *tmp32 @unit @firstItem                               Actions.mnd: while @unit.@firstItem * cap > block.sensor(item);
   50:  op mul *tmp33 *tmp32 :depositItems:cap                       ...
   51:  sensor *tmp34 :depositItems:block @titanium                  ...
   52:  jump *label42 greaterThan *tmp33 *tmp34                      Actions.mnd: do
   53:  jump *label10 always 0 0                                     Actions.mnd: if @unit.@firstItem == item then
        label *label34                                               ...
   54:  sensor *tmp36 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   55:  jump *label10 equal *tmp36 null                              ...
        label *label109                                              ...
   56:  ucontrol itemDrop @air 1000 0 0 0                            Actions.mnd: itemDrop(@air, 1000);
   57:  sensor *tmp36 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   58:  jump *label109 notEqual *tmp36 null                          ...
   59:  jump *label10 always 0 0                                     FlareController.mnd: while true do


Performance: parsed in 203 ms, compiled in 332 ms, optimized in 226 ms, run in 2 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (4 steps):
The program didn't generate any output.
Execution exception at instruction 5: ubind @flare:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
