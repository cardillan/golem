   122 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (2 iterations).
    21 instructions eliminated by Dead Code Elimination (5 iterations).
C:\Home\golem\jam-202507\FlareController.mnd:25:21 Variable 'status2.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:25:27 Variable 'status2.item' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:25:33 Variable 'status2.block' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:21 Variable 'status3.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:21 Variable 'status3.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:21 Variable 'status3.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:31:29 Variable 'transportStatus.target' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:31:29 Variable 'transportStatus.target' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:31:37 Variable 'transportStatus.item' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:31:37 Variable 'transportStatus.item' is not used.
C:\Home\golem\jam-202507\Actions.mnd:8:14 Variable 'ERROR' is not used.
     1 instructions eliminated by Jump Normalization (4 iterations).
    11 instructions eliminated by Jump Optimization (4 iterations).
     4 instructions eliminated by Single Step Elimination (5 iterations).
    12 instructions eliminated by Data Flow Optimization (9 iterations).
     4 instructions added by Loop Optimization (2 iterations).
     4 loops improved by Loop Optimization.
     2 instructions eliminated by Jump Straightening (4 iterations).
     1 instructions updated by JumpThreading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    70 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 929):
    Replicate loop condition at FlareController.mnd:58:9         size    +1, benefit      625.0, efficiency    625.000
  * Replicate loop condition at Actions.mnd:45:5                 size    +1, benefit    15625.0, efficiency  15625.000 (+1 instructions)
    Replicate loop condition at Actions.mnd:23:5                 size    +1, benefit     7812.5, efficiency   7812.500
    Replicate loop condition at Actions.mnd:68:9                 size    +1, benefit     7812.5, efficiency   7812.500

Pass 1: speed optimization selection (cost limit 928):
    Replicate loop condition at FlareController.mnd:58:9         size    +1, benefit      625.0, efficiency    625.000
  * Replicate loop condition at Actions.mnd:23:5                 size    +1, benefit     7812.5, efficiency   7812.500 (+1 instructions)
    Replicate loop condition at Actions.mnd:68:9                 size    +1, benefit     7812.5, efficiency   7812.500

Pass 1: speed optimization selection (cost limit 927):
    Replicate loop condition at FlareController.mnd:58:9         size    +1, benefit      625.0, efficiency    625.000
  * Replicate loop condition at Actions.mnd:68:9                 size    +1, benefit     7812.5, efficiency   7812.500 (+1 instructions)

Pass 1: speed optimization selection (cost limit 926):
  * Replicate loop condition at FlareController.mnd:58:9         size    +1, benefit      625.0, efficiency    625.000 (+1 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-20 instructions):
 
     7 op equal *tmp0 .core null
     8 jump *label15 equal *tmp0 false
     9 jump *label14 always
-    * set *tmp1 null
    10 jump *label16 always
    11 label *label15
-    * set *tmp1 null
    12 label *label16
    13 label *label17
    14 jump *label19 equal true false
 
    18 op equal *tmp3 *tmp2 @this
    19 jump *label23 equal *tmp3 false
    20 jump *label22 always
-    * set *tmp4 null
    21 jump *label24 always
    22 label *label23
-    * set *tmp4 null
    23 label *label24
    24 label *label21
    25 sensor *tmp5 @unit @controlled
 
    33 set :fetchBlock:block .drill
    34 set :fetchBlock:item @titanium
    35 sensor *tmp9 :fetchBlock:block @itemCapacity
-    * set :transportStatus:target *tmp9
-    * set :transportStatus:item :fetchBlock:item
    36 label *label29
-    * set :status2:text "Fetching "
-    * set :status2:item :fetchBlock:item
-    * set :status2:block :fetchBlock:block
    37 label *label30
    38 sensor *tmp10 :fetchBlock:block @x
    39 sensor *tmp11 :fetchBlock:block @y
    40 set :moveToEmpty:x *tmp10
    41 set :moveToEmpty:y *tmp11
-    * set :status3:text "Moving..."
    42 label *label32
    43 label *label33
    44 sensor *tmp12 @unit @firstItem
    45 op notEqual *tmp13 *tmp12 null
    46 jump *label36 equal *tmp13 false
    47 ucontrol itemDrop @air 1000
-    * set *tmp14 null
    48 jump *label37 always
    49 label *label36
-    * set *tmp14 null
    50 label *label37
    51 ucontrol approach :moveToEmpty:x :moveToEmpty:y 5.5
    52 label *label34
 
    73 op land *tmp22 *tmp20 *tmp21
    74 jump *label45 equal *tmp22 false
    75 ucontrol itemDrop @air 1000
-    * set *tmp23 null
    76 jump *label46 always
    77 label *label45
-    * set *tmp23 null
    78 label *label46
    79 label *label43
    80 sensor *tmp24 @unit :fetchBlock:item
 
    85 label *label44
    86 set :depositItems:block .core
    87 set :depositItems:item :fetchBlock:item
-    * set :status3.1:text "Depositing..."
    88 label *label48
    89 sensor *tmp28 @unit @firstItem
    90 op equal *tmp29 *tmp28 :depositItems:item
 
    96 set :moveTo.1:x *tmp31
    97 set :moveTo.1:y *tmp32
    98 set :moveTo.1:radius :moveToBlock:radius
-    * set :status3.2:text "Moving..."
    99 label *label53
   100 label *label54
   101 ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp33
 
   119 op greaterThan *tmp40 *tmp38 *tmp39
   120 jump *label57 notEqual *tmp40 false
   121 label *label59
-    * set *tmp30 null
   122 jump *label50 always
   123 label *label49
   124 label *label60
 
   129 label *label61
   130 jump *label60 always
   131 label *label62
-    * set *tmp30 null
   132 label *label50
-    * set :transportStatus.1:target 0
-    * set :transportStatus.1:item null
   133 label *label63
   134 label *label47
   135 label *label28

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-1 instructions):
 
    32 jump *label27 equal *tmp8 false
    33 set :fetchBlock:block .drill
    34 set :fetchBlock:item @titanium
-    * sensor *tmp9 :fetchBlock:block @itemCapacity
    35 label *label29
    36 label *label30
    37 sensor *tmp10 :fetchBlock:block @x

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
    65 label *label38
    66 label *label42
    67 ucontrol itemTake :fetchBlock:block :fetchBlock:item 10
-    * sensor *tmp19 @unit @firstItem
-    * set :fetchBlock:unitItem *tmp19
+   68 sensor :fetchBlock:unitItem @unit @firstItem
    69 op notEqual *tmp20 :fetchBlock:unitItem null
    70 op notEqual *tmp21 :fetchBlock:unitItem :fetchBlock:item
    71 op land *tmp22 *tmp20 *tmp21
 
   106 label *label56
   107 label *label52
   108 label *label51
-    * sensor *tmp36 :depositItems:block @itemCapacity
-    * set :depositItems:cap *tmp36
+  109 sensor :depositItems:cap :depositItems:block @itemCapacity
   110 label *label57
   111 ucontrol itemDrop :depositItems:block 10
   112 label *label58

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    11 label *label15
    12 label *label16
    13 label *label17
-    * jump *label19 equal true false
    14 label *label20
    15 ubind @flare
    16 sensor *tmp2 @unit @controller

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-11 instructions):
 
     4 set .ERROR ""
     5 set *signature "8266fae8e050cb59:v1"
     6 label *label13
-    * op equal *tmp0 .core null
-    * jump *label15 equal *tmp0 false
+    7 jump *label15 notEqual .core null
     8 jump *label14 always
     9 jump *label16 always
    10 label *label15
 
    13 label *label20
    14 ubind @flare
    15 sensor *tmp2 @unit @controller
-    * op equal *tmp3 *tmp2 @this
-    * jump *label23 equal *tmp3 false
+   16 jump *label23 notEqual *tmp2 @this
    17 jump *label22 always
    18 jump *label24 always
    19 label *label23
    20 label *label24
    21 label *label21
    22 sensor *tmp5 @unit @controlled
-    * op notEqual *tmp6 *tmp5 0
-    * jump *label20 notEqual *tmp6 false
+   23 jump *label20 notEqual *tmp5 0
    24 label *label22
    25 label *label25
    26 sensor *tmp7 @unit @controller
-    * op equal *tmp8 *tmp7 @this
-    * jump *label27 equal *tmp8 false
+   27 jump *label27 notEqual *tmp7 @this
    28 set :fetchBlock:block .drill
    29 set :fetchBlock:item @titanium
    30 label *label29
 
    36 label *label32
    37 label *label33
    38 sensor *tmp12 @unit @firstItem
-    * op notEqual *tmp13 *tmp12 null
-    * jump *label36 equal *tmp13 false
+   39 jump *label36 equal *tmp12 null
    40 ucontrol itemDrop @air 1000
    41 jump *label37 always
    42 label *label36
 
    44 ucontrol approach :moveToEmpty:x :moveToEmpty:y 5.5
    45 label *label34
    46 ucontrol within :moveToEmpty:x :moveToEmpty:y 6 *tmp15
-    * op equal *tmp16 *tmp15 false
-    * jump *label33 notEqual *tmp16 false
+   47 jump *label33 equal *tmp15 false
    48 label *label35
    49 label *label31
    50 label *label39
    51 sensor *tmp17 @unit @firstItem
-    * op notEqual *tmp18 *tmp17 null
-    * jump *label41 equal *tmp18 false
+   52 jump *label41 equal *tmp17 null
    53 ucontrol itemDrop @air 1000
    54 label *label40
    55 jump *label39 always
 
    77 set :depositItems:item :fetchBlock:item
    78 label *label48
    79 sensor *tmp28 @unit @firstItem
-    * op equal *tmp29 *tmp28 :depositItems:item
-    * jump *label49 equal *tmp29 false
+   80 jump *label49 notEqual *tmp28 :depositItems:item
    81 set :moveToBlock:block :depositItems:block
    82 set :moveToBlock:radius 6
    83 sensor *tmp31 :moveToBlock:block @x
 
    88 label *label53
    89 label *label54
    90 ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp33
-    * op equal *tmp34 *tmp33 false
-    * jump *label56 equal *tmp34 false
+   91 jump *label56 notEqual *tmp33 false
    92 op sub *tmp35 :moveTo.1:radius 0.5
    93 ucontrol approach :moveTo.1:x :moveTo.1:y *tmp35
    94 label *label55
 
   103 sensor *tmp37 @unit @firstItem
   104 op mul *tmp38 *tmp37 :depositItems:cap
   105 sensor *tmp39 :depositItems:block :depositItems:item
-    * op greaterThan *tmp40 *tmp38 *tmp39
-    * jump *label57 notEqual *tmp40 false
+  106 jump *label57 greaterThan *tmp38 *tmp39
   107 label *label59
   108 jump *label50 always
   109 label *label49
   110 label *label60
   111 sensor *tmp41 @unit @firstItem
-    * op notEqual *tmp42 *tmp41 null
-    * jump *label62 equal *tmp42 false
+  112 jump *label62 equal *tmp41 null
   113 ucontrol itemDrop @air 1000
   114 label *label61
   115 jump *label60 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
     6 label *label13
     7 jump *label15 notEqual .core null
     8 jump *label14 always
-    * jump *label16 always
     9 label *label15
    10 label *label16
    11 label *label17
 
    14 sensor *tmp2 @unit @controller
    15 jump *label23 notEqual *tmp2 @this
    16 jump *label22 always
-    * jump *label24 always
    17 label *label23
    18 label *label24
    19 label *label21
 
    36 sensor *tmp12 @unit @firstItem
    37 jump *label36 equal *tmp12 null
    38 ucontrol itemDrop @air 1000
-    * jump *label37 always
    39 label *label36
    40 label *label37
    41 ucontrol approach :moveToEmpty:x :moveToEmpty:y 5.5
 
    60 op land *tmp22 *tmp20 *tmp21
    61 jump *label45 equal *tmp22 false
    62 ucontrol itemDrop @air 1000
-    * jump *label46 always
    63 label *label45
    64 label *label46
    65 label *label43

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    27 set :fetchBlock:item @titanium
    28 label *label29
    29 label *label30
-    * sensor *tmp10 :fetchBlock:block @x
-    * sensor *tmp11 :fetchBlock:block @y
+   30 sensor *tmp10 .drill @x
+   31 sensor *tmp11 .drill @y
    32 set :moveToEmpty:x *tmp10
    33 set :moveToEmpty:y *tmp11
    34 label *label32
 
    38 ucontrol itemDrop @air 1000
    39 label *label36
    40 label *label37
-    * ucontrol approach :moveToEmpty:x :moveToEmpty:y 5.5
+   41 ucontrol approach *tmp10 *tmp11 5.5
    42 label *label34
-    * ucontrol within :moveToEmpty:x :moveToEmpty:y 6 *tmp15
+   43 ucontrol within *tmp10 *tmp11 6 *tmp15
    44 jump *label33 equal *tmp15 false
    45 label *label35
    46 label *label31
 
    53 label *label41
    54 label *label38
    55 label *label42
-    * ucontrol itemTake :fetchBlock:block :fetchBlock:item 10
+   56 ucontrol itemTake .drill @titanium 10
    57 sensor :fetchBlock:unitItem @unit @firstItem
    58 op notEqual *tmp20 :fetchBlock:unitItem null
-    * op notEqual *tmp21 :fetchBlock:unitItem :fetchBlock:item
+   59 op notEqual *tmp21 :fetchBlock:unitItem @titanium
    60 op land *tmp22 *tmp20 *tmp21
    61 jump *label45 equal *tmp22 false
    62 ucontrol itemDrop @air 1000
    63 label *label45
    64 label *label46
    65 label *label43
-    * sensor *tmp24 @unit :fetchBlock:item
+   66 sensor *tmp24 @unit @titanium
    67 op lessThan *tmp25 *tmp24 10
-    * sensor *tmp26 :fetchBlock:block :fetchBlock:item
+   68 sensor *tmp26 .drill @titanium
    69 op land *tmp27 *tmp25 *tmp26
    70 jump *label42 notEqual *tmp27 false
    71 label *label44
    72 set :depositItems:block .core
-    * set :depositItems:item :fetchBlock:item
+   73 set :depositItems:item @titanium
    74 label *label48
    75 sensor *tmp28 @unit @firstItem
-    * jump *label49 notEqual *tmp28 :depositItems:item
-    * set :moveToBlock:block :depositItems:block
+   76 jump *label49 notEqual *tmp28 :fetchBlock:item
+   77 set :moveToBlock:block .core
    78 set :moveToBlock:radius 6
-    * sensor *tmp31 :moveToBlock:block @x
-    * sensor *tmp32 :moveToBlock:block @y
+   79 sensor *tmp31 :depositItems:block @x
+   80 sensor *tmp32 :depositItems:block @y
    81 set :moveTo.1:x *tmp31
    82 set :moveTo.1:y *tmp32
-    * set :moveTo.1:radius :moveToBlock:radius
+   83 set :moveTo.1:radius 6
    84 label *label53
    85 label *label54
-    * ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp33
+   86 ucontrol within *tmp31 *tmp32 :moveToBlock:radius *tmp33
    87 jump *label56 notEqual *tmp33 false
-    * op sub *tmp35 :moveTo.1:radius 0.5
-    * ucontrol approach :moveTo.1:x :moveTo.1:y *tmp35
+   88 op sub *tmp35 :moveToBlock:radius 0.5
+   89 ucontrol approach *tmp31 *tmp32 *tmp35
    90 label *label55
    91 jump *label54 always
    92 label *label56
    93 label *label52
    94 label *label51
-    * sensor :depositItems:cap :depositItems:block @itemCapacity
+   95 sensor :depositItems:cap .core @itemCapacity
    96 label *label57
-    * ucontrol itemDrop :depositItems:block 10
+   97 ucontrol itemDrop .core 10
    98 label *label58
    99 sensor *tmp37 @unit @firstItem
   100 op mul *tmp38 *tmp37 :depositItems:cap
-    * sensor *tmp39 :depositItems:block :depositItems:item
+  101 sensor *tmp39 .core :fetchBlock:item
   102 jump *label57 greaterThan *tmp38 *tmp39
   103 label *label59
   104 jump *label50 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-8 instructions):
 
    23 label *label25
    24 sensor *tmp7 @unit @controller
    25 jump *label27 notEqual *tmp7 @this
-    * set :fetchBlock:block .drill
    26 set :fetchBlock:item @titanium
    27 label *label29
    28 label *label30
    29 sensor *tmp10 .drill @x
    30 sensor *tmp11 .drill @y
-    * set :moveToEmpty:x *tmp10
-    * set :moveToEmpty:y *tmp11
    31 label *label32
    32 label *label33
    33 sensor *tmp12 @unit @firstItem
 
    67 jump *label42 notEqual *tmp27 false
    68 label *label44
    69 set :depositItems:block .core
-    * set :depositItems:item @titanium
    70 label *label48
    71 sensor *tmp28 @unit @firstItem
-    * jump *label49 notEqual *tmp28 :fetchBlock:item
-    * set :moveToBlock:block .core
+   72 jump *label49 notEqual *tmp28 @titanium
    73 set :moveToBlock:radius 6
-    * sensor *tmp31 :depositItems:block @x
-    * sensor *tmp32 :depositItems:block @y
-    * set :moveTo.1:x *tmp31
-    * set :moveTo.1:y *tmp32
-    * set :moveTo.1:radius 6
+   74 sensor *tmp31 .core @x
+   75 sensor *tmp32 .core @y
    76 label *label53
    77 label *label54
-    * ucontrol within *tmp31 *tmp32 :moveToBlock:radius *tmp33
+   78 ucontrol within *tmp31 *tmp32 6 *tmp33
    79 jump *label56 notEqual *tmp33 false
-    * op sub *tmp35 :moveToBlock:radius 0.5
-    * ucontrol approach *tmp31 *tmp32 *tmp35
+   80 op sub *tmp35 6 0.5
+   81 ucontrol approach *tmp31 *tmp32 5.5
    82 label *label55
    83 jump *label54 always
    84 label *label56
 
    90 label *label58
    91 sensor *tmp37 @unit @firstItem
    92 op mul *tmp38 *tmp37 :depositItems:cap
-    * sensor *tmp39 .core :fetchBlock:item
+   93 sensor *tmp39 .core @titanium
    94 jump *label57 greaterThan *tmp38 *tmp39
    95 label *label59
    96 jump *label50 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-4 instructions):
 
    23 label *label25
    24 sensor *tmp7 @unit @controller
    25 jump *label27 notEqual *tmp7 @this
-    * set :fetchBlock:item @titanium
    26 label *label29
    27 label *label30
    28 sensor *tmp10 .drill @x
 
    65 op land *tmp27 *tmp25 *tmp26
    66 jump *label42 notEqual *tmp27 false
    67 label *label44
-    * set :depositItems:block .core
    68 label *label48
    69 sensor *tmp28 @unit @firstItem
    70 jump *label49 notEqual *tmp28 @titanium
-    * set :moveToBlock:radius 6
    71 sensor *tmp31 .core @x
    72 sensor *tmp32 .core @y
    73 label *label53
    74 label *label54
    75 ucontrol within *tmp31 *tmp32 6 *tmp33
    76 jump *label56 notEqual *tmp33 false
-    * op sub *tmp35 6 0.5
    77 ucontrol approach *tmp31 *tmp32 5.5
    78 label *label55
    79 jump *label54 always

Modifications by Replicate loop condition at Actions.mnd:45:5 (+1 instructions):
 
    43 label *label39
    44 sensor *tmp17 @unit @firstItem
    45 jump *label41 equal *tmp17 null
+   46 label *label124
    47 ucontrol itemDrop @air 1000
    48 label *label40
-    * jump *label39 always
+   49 sensor *tmp17 @unit @firstItem
+   50 jump *label124 notEqual *tmp17 null
    51 label *label41
    52 label *label38
    53 label *label42

Modifications by Replicate loop condition at Actions.mnd:23:5 (+1 instructions):
 
    76 label *label54
    77 ucontrol within *tmp31 *tmp32 6 *tmp33
    78 jump *label56 notEqual *tmp33 false
+   79 label *label125
    80 ucontrol approach *tmp31 *tmp32 5.5
    81 label *label55
-    * jump *label54 always
+   82 ucontrol within *tmp31 *tmp32 6 *tmp33
+   83 jump *label125 equal *tmp33 false
    84 label *label56
    85 label *label52
    86 label *label51

Modifications by Replicate loop condition at Actions.mnd:68:9 (+1 instructions):
 
    98 label *label60
    99 sensor *tmp41 @unit @firstItem
   100 jump *label62 equal *tmp41 null
+  101 label *label126
   102 ucontrol itemDrop @air 1000
   103 label *label61
-    * jump *label60 always
+  104 sensor *tmp41 @unit @firstItem
+  105 jump *label126 notEqual *tmp41 null
   106 label *label62
   107 label *label50
   108 label *label63

Modifications by Replicate loop condition at FlareController.mnd:58:9 (+1 instructions):
 
    23 label *label25
    24 sensor *tmp7 @unit @controller
    25 jump *label27 notEqual *tmp7 @this
+   26 label *label127
    27 label *label29
    28 label *label30
    29 sensor *tmp10 .drill @x
 
   110 label *label47
   111 label *label28
   112 label *label26
-    * jump *label25 always
+  113 sensor *tmp7 @unit @controller
+  114 jump *label127 equal *tmp7 @this
   115 label *label27
   116 label *label18
   117 jump *label17 always

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
     7 jump *label15 notEqual .core null
     8 jump *label14 always
     9 label *label15
-    * label *label16
    10 label *label17
    11 label *label20
    12 ubind @flare
 
    14 jump *label23 notEqual *tmp2 @this
    15 jump *label22 always
    16 label *label23
-    * label *label24
-    * label *label21
    17 sensor *tmp5 @unit @controlled
    18 jump *label20 notEqual *tmp5 0
    19 label *label22
-    * label *label25
    20 sensor *tmp7 @unit @controller
    21 jump *label27 notEqual *tmp7 @this
    22 label *label127
-    * label *label29
-    * label *label30
    23 sensor *tmp10 .drill @x
    24 sensor *tmp11 .drill @y
-    * label *label32
    25 label *label33
    26 sensor *tmp12 @unit @firstItem
    27 jump *label36 equal *tmp12 null
    28 ucontrol itemDrop @air 1000
    29 label *label36
-    * label *label37
    30 ucontrol approach *tmp10 *tmp11 5.5
-    * label *label34
    31 ucontrol within *tmp10 *tmp11 6 *tmp15
    32 jump *label33 equal *tmp15 false
-    * label *label35
-    * label *label31
-    * label *label39
    33 sensor *tmp17 @unit @firstItem
    34 jump *label41 equal *tmp17 null
    35 label *label124
    36 ucontrol itemDrop @air 1000
-    * label *label40
    37 sensor *tmp17 @unit @firstItem
    38 jump *label124 notEqual *tmp17 null
    39 label *label41
-    * label *label38
    40 label *label42
    41 ucontrol itemTake .drill @titanium 10
    42 sensor :fetchBlock:unitItem @unit @firstItem
 
    46 jump *label45 equal *tmp22 false
    47 ucontrol itemDrop @air 1000
    48 label *label45
-    * label *label46
-    * label *label43
    49 sensor *tmp24 @unit @titanium
    50 op lessThan *tmp25 *tmp24 10
    51 sensor *tmp26 .drill @titanium
    52 op land *tmp27 *tmp25 *tmp26
    53 jump *label42 notEqual *tmp27 false
-    * label *label44
-    * label *label48
    54 sensor *tmp28 @unit @firstItem
    55 jump *label49 notEqual *tmp28 @titanium
    56 sensor *tmp31 .core @x
    57 sensor *tmp32 .core @y
-    * label *label53
-    * label *label54
    58 ucontrol within *tmp31 *tmp32 6 *tmp33
    59 jump *label56 notEqual *tmp33 false
    60 label *label125
    61 ucontrol approach *tmp31 *tmp32 5.5
-    * label *label55
    62 ucontrol within *tmp31 *tmp32 6 *tmp33
    63 jump *label125 equal *tmp33 false
    64 label *label56
-    * label *label52
-    * label *label51
    65 sensor :depositItems:cap .core @itemCapacity
    66 label *label57
    67 ucontrol itemDrop .core 10
-    * label *label58
    68 sensor *tmp37 @unit @firstItem
    69 op mul *tmp38 *tmp37 :depositItems:cap
    70 sensor *tmp39 .core @titanium
    71 jump *label57 greaterThan *tmp38 *tmp39
-    * label *label59
    72 jump *label50 always
    73 label *label49
-    * label *label60
    74 sensor *tmp41 @unit @firstItem
    75 jump *label62 equal *tmp41 null
    76 label *label126
    77 ucontrol itemDrop @air 1000
-    * label *label61
    78 sensor *tmp41 @unit @firstItem
    79 jump *label126 notEqual *tmp41 null
    80 label *label62
    81 label *label50
-    * label *label63
-    * label *label47
-    * label *label28
-    * label *label26
    82 sensor *tmp7 @unit @controller
    83 jump *label127 equal *tmp7 @this
    84 label *label27
-    * label *label18
    85 jump *label17 always
-    * label *label19
    86 label *label14
    87 wait 1e12
    88 jump *label13 always
 
    90 label *label0
    91 set .core :start:aCore
    92 set .drill :start:aDrill
-    * label *label122
    93 set :start*finished true
    94 jump *label13 always
    95 end
    96 label *label1
-    * label *label123
    97 set :addDrill*finished true
    98 jump *label13 always
    99 end

Modifications by Jumps phase, Jump Straightening, pass 3, iteration 1 (-2 instructions):
 
     4 set .ERROR ""
     5 set *signature "8266fae8e050cb59:v1"
     6 label *label13
-    * jump *label15 notEqual .core null
-    * jump *label14 always
+    7 jump *label14 equal .core null
     8 label *label15
     9 label *label17
    10 label *label20
    11 ubind @flare
    12 sensor *tmp2 @unit @controller
-    * jump *label23 notEqual *tmp2 @this
-    * jump *label22 always
+   13 jump *label22 equal *tmp2 @this
    14 label *label23
    15 sensor *tmp5 @unit @controlled
    16 jump *label20 notEqual *tmp5 0

Modifications by Jumps phase, Jump Optimization, pass 3, iteration 1:
 
     5 set *signature "8266fae8e050cb59:v1"
     6 label *label13
     7 jump *label14 equal .core null
-    * label *label15
     8 label *label17
     9 label *label20
    10 ubind @flare
    11 sensor *tmp2 @unit @controller
    12 jump *label22 equal *tmp2 @this
-    * label *label23
    13 sensor *tmp5 @unit @controlled
    14 jump *label20 notEqual *tmp5 0
    15 label *label22

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
 
    14 jump *label20 notEqual *tmp5 0
    15 label *label22
    16 sensor *tmp7 @unit @controller
-    * jump *label27 notEqual *tmp7 @this
+   17 jump *label17 notEqual *tmp7 @this
    18 label *label127
    19 sensor *tmp10 .drill @x
    20 sensor *tmp11 .drill @y

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-3 instructions):
 
    77 label *label50
    78 sensor *tmp7 @unit @controller
    79 jump *label127 equal *tmp7 @this
-    * label *label27
    80 jump *label17 always
    81 label *label14
    82 wait 1e12
    83 jump *label13 always
-    * end
    84 label *label0
    85 set .core :start:aCore
    86 set .drill :start:aDrill
    87 set :start*finished true
    88 jump *label13 always
-    * end
    89 label *label1
    90 set :addDrill*finished true
    91 jump *label13 always
-    * end

Final code before resolving virtual instructions:

    0:  jump *label12 always 0 0                                     FlareController.mnd: #set target = 8;
    1:  jump *label1 always 0 0                                      ...
    2:  jump *label0 always 0 0                                      ...
    3:  draw triangle .ERROR .core .drill :depositItems:cap :fetchBlock:unitItem :start:aCore
    4:  draw triangle :start:aDrill 0 0 0 0 0
        label *label12                                               ...
    5:  set .ERROR ""                                                Actions.mnd: volatile var ERROR = "";
    6:  set *signature "8266fae8e050cb59:v1"                         FlareController.mnd: #set target = 8;
        label *label13                                               ...
    7:  jump *label14 equal .core null                               FlareController.mnd: if core == null then return; end;
        label *label17                                               FlareController.mnd: while true do
        label *label20                                               FlareController.mnd: do
    8:  ubind @flare                                                 FlareController.mnd: ubind(@flare);
    9:  sensor *tmp2 @unit @controller                               FlareController.mnd: if @unit.@controller == @this then break; end;
   10:  jump *label22 equal *tmp2 @this                              ...
   11:  sensor *tmp5 @unit @controlled                               FlareController.mnd: while @unit.@controlled != 0;
   12:  jump *label20 notEqual *tmp5 0                               FlareController.mnd: do
        label *label22                                               ...
   13:  sensor *tmp7 @unit @controller                               FlareController.mnd: while @unit.@controller == @this do
   14:  jump *label17 notEqual *tmp7 @this                           ...
        label *label127                                              ...
   15:  sensor *tmp10 .drill @x                                      Actions.mnd: moveToEmpty(block.@x, block.@y);
   16:  sensor *tmp11 .drill @y                                      ...
        label *label33                                               Actions.mnd: do
   17:  sensor *tmp12 @unit @firstItem                               Actions.mnd: if @unit.@firstItem != null then itemDrop(@air, 1000); end;
   18:  jump *label36 equal *tmp12 null                              ...
   19:  ucontrol itemDrop @air 1000 0 0 0                            ...
        label *label36                                               ...
   20:  ucontrol approach *tmp10 *tmp11 5.5 0 0                      Actions.mnd: approach(x, y, RADIUS - 0.5);
   21:  ucontrol within *tmp10 *tmp11 6 *tmp15 0                     Actions.mnd: while !within(x, y, RADIUS);
   22:  jump *label33 equal *tmp15 false                             Actions.mnd: do
   23:  sensor *tmp17 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   24:  jump *label41 equal *tmp17 null                              ...
        label *label124                                              ...
   25:  ucontrol itemDrop @air 1000 0 0 0                            Actions.mnd: itemDrop(@air, 1000);
   26:  sensor *tmp17 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   27:  jump *label124 notEqual *tmp17 null                          ...
        label *label41                                               ...
        label *label42                                               Actions.mnd: do
   28:  ucontrol itemTake .drill @titanium 10 0 0                    Actions.mnd: itemTake(block, item, capacity);
   29:  sensor :fetchBlock:unitItem @unit @firstItem                 Actions.mnd: var unitItem = @unit.@firstItem;
   30:  op notEqual *tmp20 :fetchBlock:unitItem null                 Actions.mnd: if unitItem != null and unitItem != item then
   31:  op notEqual *tmp21 :fetchBlock:unitItem @titanium            ...
   32:  op land *tmp22 *tmp20 *tmp21                                 ...
   33:  jump *label45 equal *tmp22 false                             ...
   34:  ucontrol itemDrop @air 1000 0 0 0                            Actions.mnd: itemDrop(@air, 1000);
        label *label45                                               Actions.mnd: if unitItem != null and unitItem != item then
   35:  sensor *tmp24 @unit @titanium                                Actions.mnd: while @unit.sensor(item) < capacity and block.sensor(item);
   36:  op lessThan *tmp25 *tmp24 10                                 ...
   37:  sensor *tmp26 .drill @titanium                               ...
   38:  op land *tmp27 *tmp25 *tmp26                                 ...
   39:  jump *label42 notEqual *tmp27 false                          Actions.mnd: do
   40:  sensor *tmp28 @unit @firstItem                               Actions.mnd: if @unit.@firstItem == item then
   41:  jump *label49 notEqual *tmp28 @titanium                      ...
   42:  sensor *tmp31 .core @x                                       Actions.mnd: moveTo(block.@x, block.@y, radius);
   43:  sensor *tmp32 .core @y                                       ...
   44:  ucontrol within *tmp31 *tmp32 6 *tmp33 0                     Actions.mnd: while !within(x, y, radius) do
   45:  jump *label56 notEqual *tmp33 false                          ...
        label *label125                                              ...
   46:  ucontrol approach *tmp31 *tmp32 5.5 0 0                      Actions.mnd: approach(x, y, radius - 0.5);
   47:  ucontrol within *tmp31 *tmp32 6 *tmp33 0                     Actions.mnd: while !within(x, y, radius) do
   48:  jump *label125 equal *tmp33 false                            ...
        label *label56                                               ...
   49:  sensor :depositItems:cap .core @itemCapacity                 Actions.mnd: var cap = block.@itemCapacity;
        label *label57                                               Actions.mnd: do
   50:  ucontrol itemDrop .core 10 0 0 0                             Actions.mnd: itemDrop(block, capacity);
   51:  sensor *tmp37 @unit @firstItem                               Actions.mnd: while @unit.@firstItem * cap > block.sensor(item);
   52:  op mul *tmp38 *tmp37 :depositItems:cap                       ...
   53:  sensor *tmp39 .core @titanium                                ...
   54:  jump *label57 greaterThan *tmp38 *tmp39                      Actions.mnd: do
   55:  jump *label50 always 0 0                                     Actions.mnd: if @unit.@firstItem == item then
        label *label49                                               ...
   56:  sensor *tmp41 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   57:  jump *label62 equal *tmp41 null                              ...
        label *label126                                              ...
   58:  ucontrol itemDrop @air 1000 0 0 0                            Actions.mnd: itemDrop(@air, 1000);
   59:  sensor *tmp41 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   60:  jump *label126 notEqual *tmp41 null                          ...
        label *label62                                               ...
        label *label50                                               Actions.mnd: if @unit.@firstItem == item then
   61:  sensor *tmp7 @unit @controller                               FlareController.mnd: while @unit.@controller == @this do
   62:  jump *label127 equal *tmp7 @this                             ...
   63:  jump *label17 always 0 0                                     FlareController.mnd: while true do
        label *label14                                               FlareController.mnd: #set target = 8;
   64:  wait 1e12                                                    ...
   65:  jump *label13 always 0 0                                     ...
        label *label0                                                FlareController.mnd: remote void start(aCore, aDrill)
   66:  set .core :start:aCore                                       FlareController.mnd: core = aCore;
   67:  set .drill :start:aDrill                                     FlareController.mnd: drill = aDrill;
   68:  set :start*finished true                                     FlareController.mnd: remote void start(aCore, aDrill)
   69:  jump *label13 always 0 0                                     ...
        label *label1                                                FlareController.mnd: remote void addDrill(drill)
   70:  set :addDrill*finished true                                  ...
   71:  jump *label13 always 0 0                                     ...


Performance: parsed in 240 ms, compiled in 296 ms, optimized in 242 ms, run in 3 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (5 steps):
The program didn't generate any output.
Execution exception at instruction 64: wait 1e12:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
