   187 instructions before optimizations.
     5 instructions eliminated by Temp Variables Elimination (2 iterations).
    21 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (7 iterations).
    11 instructions eliminated by Jump Optimization (7 iterations).
    18 instructions eliminated by Single Step Elimination (3 passes, 10 iterations).
     5 instructions eliminated by Data Flow Optimization (9 iterations).
   322 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
     1 jump tables inlined by Array Optimization.
    21 instructions eliminated by Jump Straightening (7 iterations).
    10 instructions updated by JumpThreading.
    13 instructions eliminated by Unreachable Code Elimination (2 iterations).
   411 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 863):
    Unroll iteration loop at line 67:9                           size  +321, benefit     1475.0, efficiency      4.595
  * Inline write jump table of array 'titaniumDrills'            size    -4, benefit        1.0, efficiency   Infinity (-4 instructions)
    Inline 'titaniumDrills' write access at line 40:9            size   +17, benefit        1.0, efficiency      0.059

Pass 1: speed optimization selection (cost limit 867):
  * Unroll iteration loop at line 67:9                           size  +321, benefit     1475.0, efficiency      4.595 (+322 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-14 instructions):
 
     8 op equal *tmp0 .core null
     9 jump *label10 equal *tmp0 false
    10 jump *label9 always
-    * set *tmp1 null
    11 jump *label11 always
    12 label *label10
-    * set *tmp1 null
    13 label *label11
    14 label *label12
    15 jump *label14 equal true false
 
    74 op equal *tmp3 :backgroundProcess:drill null
    75 jump *label28 equal *tmp3 false
    76 jump *label17 always
-    * set *tmp4 null
    77 jump *label29 always
    78 label *label28
-    * set *tmp4 null
    79 label *label29
    80 sensor *tmp5 :backgroundProcess:unit @controller
    81 op notEqual *tmp6 *tmp5 @this
 
    88 jump *label33 equal *tmp9 false
    89 set *tmp8 null
    90 jump *label32 always
-    * set *tmp10 null
    91 jump *label34 always
    92 label *label33
-    * set *tmp10 null
    93 label *label34
    94 set :findFreeUnit:first_unit @unit
    95 label *label35
 
    99 ucontrol flag :findFreeUnit:initial_flag
   100 set *tmp8 @unit
   101 jump *label32 always
-    * set *tmp13 null
   102 jump *label39 always
   103 label *label38
   104 sensor *tmp14 :findFreeUnit:first_unit @dead
 
   111 label *label40
   112 set *tmp16 null
   113 label *label41
-    * set *tmp13 *tmp16
   114 label *label39
   115 ubind :findFreeUnit:unit_type
   116 label *label36
 
   130 label *label42
   131 set *tmp20 null
   132 label *label43
-    * set *tmp7 *tmp20
   133 jump *label31 always
   134 label *label30
-    * set *tmp7 null
   135 label *label31
   136 # "Function: void serviceDrill(in drill, in unit)"
   137 set :serviceDrill:drill :backgroundProcess:drill
 
   143 jump *label45 equal *tmp22 false
   144 ucontrol approach .coreX .coreY 4
   145 ucontrol itemDrop .core 10
-    * set *tmp23 null
   146 jump *label46 always
   147 label *label45
   148 op equal *tmp24 :serviceDrill:item null
 
   157 ucontrol itemDrop @air 10
   158 set *tmp25 null
   159 label *label48
-    * set *tmp23 *tmp25
   160 label *label46
   161 label *label44
   162 label *label16
 
   192 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp32
   193 set *tmp34 .drills
   194 op add .drills .drills 1
-    * set *tmp31 *tmp34
   195 jump *label52 always
   196 label *label51
-    * set *tmp31 null
   197 label *label52
   198 label *label50
   199 set :addTitaniumDrill*finished true

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-7 instructions):
 
   106 jump *label40 equal *tmp15 false
   107 set *tmp17 @unit
   108 set :findFreeUnit:first_unit *tmp17
-    * set *tmp16 :findFreeUnit:first_unit
   109 jump *label41 always
   110 label *label40
-    * set *tmp16 null
   111 label *label41
   112 label *label39
   113 ubind :findFreeUnit:unit_type
 
   123 op equal *tmp19 :backgroundProcess:unit null
   124 jump *label42 equal *tmp19 false
   125 jump *label16 always
-    * set *tmp20 null
   126 jump *label43 always
   127 label *label42
-    * set *tmp20 null
   128 label *label43
   129 jump *label31 always
   130 label *label30
 
   147 sensor *tmp27 :serviceDrill:drill @y
   148 ucontrol approach *tmp26 *tmp27 4
   149 ucontrol itemTake :serviceDrill:drill @titanium 10
-    * set *tmp25 null
   150 jump *label48 always
   151 label *label47
   152 ucontrol itemDrop @air 10
-    * set *tmp25 null
   153 label *label48
   154 label *label46
   155 label *label44
 
   184 jump *label51 equal *tmp30 false
   185 set *tmp32 .drills
   186 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp32
-    * set *tmp34 .drills
   187 op add .drills .drills 1
   188 jump *label52 always
   189 label *label51

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-5 instructions):
 
   104 sensor *tmp14 :findFreeUnit:first_unit @dead
   105 op equal *tmp15 *tmp14 1
   106 jump *label40 equal *tmp15 false
-    * set *tmp17 @unit
-    * set :findFreeUnit:first_unit *tmp17
+  107 set :findFreeUnit:first_unit @unit
   108 jump *label41 always
   109 label *label40
   110 label *label41
 
   132 set :serviceDrill:drill :backgroundProcess:drill
   133 set :serviceDrill:unit :backgroundProcess:unit
   134 ubind :serviceDrill:unit
-    * sensor *tmp21 @unit @firstItem
-    * set :serviceDrill:item *tmp21
+  135 sensor :serviceDrill:item @unit @firstItem
   136 op equal *tmp22 :serviceDrill:item @titanium
   137 jump *label45 equal *tmp22 false
   138 ucontrol approach .coreX .coreY 4
 
   166 label *label0
   167 # "Function: remote void start(in aCore, in drill)"
   168 set .core :start:aCore
-    * sensor *tmp28 .core @x
-    * set .coreX *tmp28
-    * sensor *tmp29 .core @y
-    * set .coreY *tmp29
+  169 sensor .coreX .core @x
+  170 sensor .coreY .core @y
   171 set .titaniumDrills*0 :start:drill
   172 set .drills 1
   173 label *label49
 
   178 # "Function: remote void addTitaniumDrill(in drill)"
   179 op lessThan *tmp30 .drills 9
   180 jump *label51 equal *tmp30 false
-    * set *tmp32 .drills
-    * writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] *tmp32
+  181 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   182 op add .drills .drills 1
   183 jump *label52 always
   184 label *label51

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    12 label *label10
    13 label *label11
    14 label *label12
-    * jump *label14 equal true false
    15 set :backgroundProcess:drill .titaniumDrills*0
    16 set :backgroundProcess:unit .units*0
    17 op add *tmp2 @counter 1

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-11 instructions):
 
     5 set *signature "ea15a0387a220137:v1"
     6 label *label8
     7 # "Function: void backgroundProcess()"
-    * op equal *tmp0 .core null
-    * jump *label10 equal *tmp0 false
+    8 jump *label10 notEqual .core null
     9 jump *label9 always
    10 jump *label11 always
    11 label *label10
 
    69 set :backgroundProcess:unit .units*9
    70 set *tmp2 null
    71 label *label15
-    * op equal *tmp3 :backgroundProcess:drill null
-    * jump *label28 equal *tmp3 false
+   72 jump *label28 notEqual :backgroundProcess:drill null
    73 jump *label17 always
    74 jump *label29 always
    75 label *label28
    76 label *label29
    77 sensor *tmp5 :backgroundProcess:unit @controller
-    * op notEqual *tmp6 *tmp5 @this
-    * jump *label30 equal *tmp6 false
+   78 jump *label30 equal *tmp5 @this
    79 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    80 set :findFreeUnit:unit_type @flare
    81 set :findFreeUnit:initial_flag 0
    82 ubind :findFreeUnit:unit_type
-    * op equal *tmp9 @unit null
-    * jump *label33 equal *tmp9 false
+   83 jump *label33 notEqual @unit null
    84 set *tmp8 null
    85 jump *label32 always
    86 jump *label34 always
 
    89 set :findFreeUnit:first_unit @unit
    90 label *label35
    91 sensor *tmp11 @unit @controlled
-    * op equal *tmp12 *tmp11 0
-    * jump *label38 equal *tmp12 false
+   92 jump *label38 notEqual *tmp11 0
    93 ucontrol flag :findFreeUnit:initial_flag
    94 set *tmp8 @unit
    95 jump *label32 always
    96 jump *label39 always
    97 label *label38
    98 sensor *tmp14 :findFreeUnit:first_unit @dead
-    * op equal *tmp15 *tmp14 1
-    * jump *label40 equal *tmp15 false
+   99 jump *label40 notEqual *tmp14 1
   100 set :findFreeUnit:first_unit @unit
   101 jump *label41 always
   102 label *label40
 
   104 label *label39
   105 ubind :findFreeUnit:unit_type
   106 label *label36
-    * op notEqual *tmp18 :findFreeUnit:first_unit @unit
-    * jump *label35 notEqual *tmp18 false
+  107 jump *label35 notEqual :findFreeUnit:first_unit @unit
   108 label *label37
   109 set *tmp8 null
   110 jump *label32 always
   111 set *tmp8 null
   112 label *label32
   113 set :backgroundProcess:unit *tmp8
-    * op equal *tmp19 :backgroundProcess:unit null
-    * jump *label42 equal *tmp19 false
+  114 jump *label42 notEqual :backgroundProcess:unit null
   115 jump *label16 always
   116 jump *label43 always
   117 label *label42
 
   124 set :serviceDrill:unit :backgroundProcess:unit
   125 ubind :serviceDrill:unit
   126 sensor :serviceDrill:item @unit @firstItem
-    * op equal *tmp22 :serviceDrill:item @titanium
-    * jump *label45 equal *tmp22 false
+  127 jump *label45 notEqual :serviceDrill:item @titanium
   128 ucontrol approach .coreX .coreY 4
   129 ucontrol itemDrop .core 10
   130 jump *label46 always
   131 label *label45
-    * op equal *tmp24 :serviceDrill:item null
-    * jump *label47 equal *tmp24 false
+  132 jump *label47 notEqual :serviceDrill:item null
   133 sensor *tmp26 :serviceDrill:drill @x
   134 sensor *tmp27 :serviceDrill:drill @y
   135 ucontrol approach *tmp26 *tmp27 4
 
   165 end
   166 label *label1
   167 # "Function: remote void addTitaniumDrill(in drill)"
-    * op lessThan *tmp30 .drills 9
-    * jump *label51 equal *tmp30 false
+  168 jump *label51 greaterThanEq .drills 9
   169 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   170 op add .drills .drills 1
   171 jump *label52 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
     7 # "Function: void backgroundProcess()"
     8 jump *label10 notEqual .core null
     9 jump *label9 always
-    * jump *label11 always
    10 label *label10
    11 label *label11
    12 label *label12
 
    70 label *label15
    71 jump *label28 notEqual :backgroundProcess:drill null
    72 jump *label17 always
-    * jump *label29 always
    73 label *label28
    74 label *label29
    75 sensor *tmp5 :backgroundProcess:unit @controller
 
    81 jump *label33 notEqual @unit null
    82 set *tmp8 null
    83 jump *label32 always
-    * jump *label34 always
    84 label *label33
    85 label *label34
    86 set :findFreeUnit:first_unit @unit
 
    95 sensor *tmp14 :findFreeUnit:first_unit @dead
    96 jump *label40 notEqual *tmp14 1
    97 set :findFreeUnit:first_unit @unit
-    * jump *label41 always
    98 label *label40
    99 label *label41
   100 label *label39
 
   109 set :backgroundProcess:unit *tmp8
   110 jump *label42 notEqual :backgroundProcess:unit null
   111 jump *label16 always
-    * jump *label43 always
   112 label *label42
   113 label *label43
-    * jump *label31 always
   114 label *label30
   115 label *label31
   116 # "Function: void serviceDrill(in drill, in unit)"
 
   162 jump *label51 greaterThanEq .drills 9
   163 writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
   164 op add .drills .drills 1
-    * jump *label52 always
   165 label *label51
   166 label *label52
   167 label *label50

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    77 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
    78 set :findFreeUnit:unit_type @flare
    79 set :findFreeUnit:initial_flag 0
-    * ubind :findFreeUnit:unit_type
+   80 ubind @flare
    81 jump *label33 notEqual @unit null
    82 set *tmp8 null
    83 jump *label32 always
 
    87 label *label35
    88 sensor *tmp11 @unit @controlled
    89 jump *label38 notEqual *tmp11 0
-    * ucontrol flag :findFreeUnit:initial_flag
+   90 ucontrol flag 0
    91 set *tmp8 @unit
    92 jump *label32 always
    93 jump *label39 always
 
    98 label *label40
    99 label *label41
   100 label *label39
-    * ubind :findFreeUnit:unit_type
+  101 ubind @flare
   102 label *label36
   103 jump *label35 notEqual :findFreeUnit:first_unit @unit
   104 label *label37
   105 set *tmp8 null
   106 jump *label32 always
-    * set *tmp8 null
   107 label *label32
   108 set :backgroundProcess:unit *tmp8
-    * jump *label42 notEqual :backgroundProcess:unit null
+  109 jump *label42 notEqual *tmp8 null
   110 jump *label16 always
   111 label *label42
   112 label *label43
 
   115 # "Function: void serviceDrill(in drill, in unit)"
   116 set :serviceDrill:drill :backgroundProcess:drill
   117 set :serviceDrill:unit :backgroundProcess:unit
-    * ubind :serviceDrill:unit
+  118 ubind :backgroundProcess:unit
   119 sensor :serviceDrill:item @unit @firstItem
   120 jump *label45 notEqual :serviceDrill:item @titanium
   121 ucontrol approach .coreX .coreY 4
 
   123 jump *label46 always
   124 label *label45
   125 jump *label47 notEqual :serviceDrill:item null
-    * sensor *tmp26 :serviceDrill:drill @x
-    * sensor *tmp27 :serviceDrill:drill @y
+  126 sensor *tmp26 :backgroundProcess:drill @x
+  127 sensor *tmp27 :backgroundProcess:drill @y
   128 ucontrol approach *tmp26 *tmp27 4
-    * ucontrol itemTake :serviceDrill:drill @titanium 10
+  129 ucontrol itemTake :backgroundProcess:drill @titanium 10
   130 jump *label48 always
   131 label *label47
   132 ucontrol itemDrop @air 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    75 sensor *tmp5 :backgroundProcess:unit @controller
    76 jump *label30 equal *tmp5 @this
    77 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * set :findFreeUnit:unit_type @flare
-    * set :findFreeUnit:initial_flag 0
    78 ubind @flare
    79 jump *label33 notEqual @unit null
    80 set *tmp8 null
 
   111 label *label30
   112 label *label31
   113 # "Function: void serviceDrill(in drill, in unit)"
-    * set :serviceDrill:drill :backgroundProcess:drill
-    * set :serviceDrill:unit :backgroundProcess:unit
   114 ubind :backgroundProcess:unit
   115 sensor :serviceDrill:item @unit @firstItem
   116 jump *label45 notEqual :serviceDrill:item @titanium

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
 
   155 label *label1
   156 # "Function: remote void addTitaniumDrill(in drill)"
   157 jump *label51 greaterThanEq .drills 9
-    * writearr<regular> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  158 writearr<inlined> :addTitaniumDrill:drill .titaniumDrills[] .drills
   159 op add .drills .drills 1
   160 label *label51
   161 label *label52

Modifications by Unroll iteration loop at line 67:9 (+322 instructions):
 
    10 label *label10
    11 label *label11
    12 label *label12
-    * set :backgroundProcess:drill .titaniumDrills*0
-    * set :backgroundProcess:unit .units*0
-    * op add *tmp2 @counter 1
-    * jump *label15 always
-    * multilabel *label18 (m:marker0)
-    * set .units*0 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*1
-    * set :backgroundProcess:unit .units*1
-    * op add *tmp2 @counter 1
-    * jump *label15 always
-    * multilabel *label19 (m:marker0)
-    * set .units*1 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*2
-    * set :backgroundProcess:unit .units*2
-    * op add *tmp2 @counter 1
-    * jump *label15 always
-    * multilabel *label20 (m:marker0)
-    * set .units*2 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*3
-    * set :backgroundProcess:unit .units*3
-    * op add *tmp2 @counter 1
-    * jump *label15 always
-    * multilabel *label21 (m:marker0)
-    * set .units*3 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*4
-    * set :backgroundProcess:unit .units*4
-    * op add *tmp2 @counter 1
-    * jump *label15 always
-    * multilabel *label22 (m:marker0)
-    * set .units*4 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*5
-    * set :backgroundProcess:unit .units*5
-    * op add *tmp2 @counter 1
-    * jump *label15 always
-    * multilabel *label23 (m:marker0)
-    * set .units*5 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*6
-    * set :backgroundProcess:unit .units*6
-    * op add *tmp2 @counter 1
-    * jump *label15 always
-    * multilabel *label24 (m:marker0)
-    * set .units*6 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*7
-    * set :backgroundProcess:unit .units*7
-    * op add *tmp2 @counter 1
-    * jump *label15 always
-    * multilabel *label25 (m:marker0)
-    * set .units*7 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*8
-    * set :backgroundProcess:unit .units*8
-    * op add *tmp2 @counter 1
-    * jump *label15 always
-    * multilabel *label26 (m:marker0)
-    * set .units*8 :backgroundProcess:unit
-    * set :backgroundProcess:drill .titaniumDrills*9
-    * set :backgroundProcess:unit .units*9
-    * set *tmp2 null
-    * label *label15
-    * jump *label28 notEqual :backgroundProcess:drill null
-    * jump *label17 always
-    * label *label28
-    * label *label29
-    * sensor *tmp5 :backgroundProcess:unit @controller
-    * jump *label30 equal *tmp5 @this
-    * # "Function: def findFreeUnit(in unit_type, in initial_flag)"
-    * ubind @flare
-    * jump *label33 notEqual @unit null
-    * set *tmp8 null
-    * jump *label32 always
-    * label *label33
-    * label *label34
-    * set :findFreeUnit:first_unit @unit
-    * label *label35
-    * sensor *tmp11 @unit @controlled
-    * jump *label38 notEqual *tmp11 0
-    * ucontrol flag 0
-    * set *tmp8 @unit
-    * jump *label32 always
-    * jump *label39 always
-    * label *label38
-    * sensor *tmp14 :findFreeUnit:first_unit @dead
-    * jump *label40 notEqual *tmp14 1
-    * set :findFreeUnit:first_unit @unit
-    * label *label40
-    * label *label41
-    * label *label39
-    * ubind @flare
-    * label *label36
-    * jump *label35 notEqual :findFreeUnit:first_unit @unit
-    * label *label37
-    * set *tmp8 null
-    * jump *label32 always
-    * label *label32
-    * set :backgroundProcess:unit *tmp8
-    * jump *label42 notEqual *tmp8 null
-    * jump *label16 always
-    * label *label42
-    * label *label43
-    * label *label30
-    * label *label31
-    * # "Function: void serviceDrill(in drill, in unit)"
-    * ubind :backgroundProcess:unit
-    * sensor :serviceDrill:item @unit @firstItem
-    * jump *label45 notEqual :serviceDrill:item @titanium
-    * ucontrol approach .coreX .coreY 4
-    * ucontrol itemDrop .core 10
-    * jump *label46 always
-    * label *label45
-    * jump *label47 notEqual :serviceDrill:item null
-    * sensor *tmp26 :backgroundProcess:drill @x
-    * sensor *tmp27 :backgroundProcess:drill @y
-    * ucontrol approach *tmp26 *tmp27 4
-    * ucontrol itemTake :backgroundProcess:drill @titanium 10
-    * jump *label48 always
-    * label *label47
-    * ucontrol itemDrop @air 10
-    * label *label48
-    * label *label46
-    * label *label44
-    * label *label16
-    * multijump *tmp2 0 0 (m:marker0)
-    * multilabel *label27 (m:marker0)
-    * set .units*9 :backgroundProcess:unit
-    * label *label17
+   13 set :backgroundProcess:drill .titaniumDrills*0
+   14 set :backgroundProcess:unit .units*0
+   15 label *label53
+   16 jump *label54 notEqual :backgroundProcess:drill null
+   17 jump *label17 always
+   18 label *label54
+   19 label *label55
+   20 sensor *tmp5 :backgroundProcess:unit @controller
+   21 jump *label68 equal *tmp5 @this
+   22 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+   23 ubind @flare
+   24 jump *label56 notEqual @unit null
+   25 set *tmp8 null
+   26 jump *label65 always
+   27 label *label56
+   28 label *label57
+   29 set :findFreeUnit:first_unit @unit
+   30 label *label58
+   31 sensor *tmp11 @unit @controlled
+   32 jump *label59 notEqual *tmp11 0
+   33 ucontrol flag 0
+   34 set *tmp8 @unit
+   35 jump *label65 always
+   36 jump *label62 always
+   37 label *label59
+   38 sensor *tmp14 :findFreeUnit:first_unit @dead
+   39 jump *label60 notEqual *tmp14 1
+   40 set :findFreeUnit:first_unit @unit
+   41 label *label60
+   42 label *label61
+   43 label *label62
+   44 ubind @flare
+   45 label *label63
+   46 jump *label58 notEqual :findFreeUnit:first_unit @unit
+   47 label *label64
+   48 set *tmp8 null
+   49 jump *label65 always
+   50 label *label65
+   51 set :backgroundProcess:unit *tmp8
+   52 jump *label66 notEqual *tmp8 null
+   53 jump *label75 always
+   54 label *label66
+   55 label *label67
+   56 label *label68
+   57 label *label69
+   58 # "Function: void serviceDrill(in drill, in unit)"
+   59 ubind :backgroundProcess:unit
+   60 sensor :serviceDrill:item @unit @firstItem
+   61 jump *label70 notEqual :serviceDrill:item @titanium
+   62 ucontrol approach .coreX .coreY 4
+   63 ucontrol itemDrop .core 10
+   64 jump *label73 always
+   65 label *label70
+   66 jump *label71 notEqual :serviceDrill:item null
+   67 sensor *tmp26 :backgroundProcess:drill @x
+   68 sensor *tmp27 :backgroundProcess:drill @y
+   69 ucontrol approach *tmp26 *tmp27 4
+   70 ucontrol itemTake :backgroundProcess:drill @titanium 10
+   71 jump *label72 always
+   72 label *label71
+   73 ucontrol itemDrop @air 10
+   74 label *label72
+   75 label *label73
+   76 label *label74
+   77 label *label75
+   78 set .units*0 :backgroundProcess:unit
+   79 set :backgroundProcess:drill .titaniumDrills*1
+   80 set :backgroundProcess:unit .units*1
+   81 label *label78
+   82 jump *label79 notEqual :backgroundProcess:drill null
+   83 jump *label17 always
+   84 label *label79
+   85 label *label80
+   86 sensor *tmp5 :backgroundProcess:unit @controller
+   87 jump *label93 equal *tmp5 @this
+   88 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+   89 ubind @flare
+   90 jump *label81 notEqual @unit null
+   91 set *tmp8 null
+   92 jump *label90 always
+   93 label *label81
+   94 label *label82
+   95 set :findFreeUnit:first_unit @unit
+   96 label *label83
+   97 sensor *tmp11 @unit @controlled
+   98 jump *label84 notEqual *tmp11 0
+   99 ucontrol flag 0
+  100 set *tmp8 @unit
+  101 jump *label90 always
+  102 jump *label87 always
+  103 label *label84
+  104 sensor *tmp14 :findFreeUnit:first_unit @dead
+  105 jump *label85 notEqual *tmp14 1
+  106 set :findFreeUnit:first_unit @unit
+  107 label *label85
+  108 label *label86
+  109 label *label87
+  110 ubind @flare
+  111 label *label88
+  112 jump *label83 notEqual :findFreeUnit:first_unit @unit
+  113 label *label89
+  114 set *tmp8 null
+  115 jump *label90 always
+  116 label *label90
+  117 set :backgroundProcess:unit *tmp8
+  118 jump *label91 notEqual *tmp8 null
+  119 jump *label100 always
+  120 label *label91
+  121 label *label92
+  122 label *label93
+  123 label *label94
+  124 # "Function: void serviceDrill(in drill, in unit)"
+  125 ubind :backgroundProcess:unit
+  126 sensor :serviceDrill:item @unit @firstItem
+  127 jump *label95 notEqual :serviceDrill:item @titanium
+  128 ucontrol approach .coreX .coreY 4
+  129 ucontrol itemDrop .core 10
+  130 jump *label98 always
+  131 label *label95
+  132 jump *label96 notEqual :serviceDrill:item null
+  133 sensor *tmp26 :backgroundProcess:drill @x
+  134 sensor *tmp27 :backgroundProcess:drill @y
+  135 ucontrol approach *tmp26 *tmp27 4
+  136 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  137 jump *label97 always
+  138 label *label96
+  139 ucontrol itemDrop @air 10
+  140 label *label97
+  141 label *label98
+  142 label *label99
+  143 label *label100
+  144 set .units*1 :backgroundProcess:unit
+  145 set :backgroundProcess:drill .titaniumDrills*2
+  146 set :backgroundProcess:unit .units*2
+  147 label *label103
+  148 jump *label104 notEqual :backgroundProcess:drill null
+  149 jump *label17 always
+  150 label *label104
+  151 label *label105
+  152 sensor *tmp5 :backgroundProcess:unit @controller
+  153 jump *label118 equal *tmp5 @this
+  154 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  155 ubind @flare
+  156 jump *label106 notEqual @unit null
+  157 set *tmp8 null
+  158 jump *label115 always
+  159 label *label106
+  160 label *label107
+  161 set :findFreeUnit:first_unit @unit
+  162 label *label108
+  163 sensor *tmp11 @unit @controlled
+  164 jump *label109 notEqual *tmp11 0
+  165 ucontrol flag 0
+  166 set *tmp8 @unit
+  167 jump *label115 always
+  168 jump *label112 always
+  169 label *label109
+  170 sensor *tmp14 :findFreeUnit:first_unit @dead
+  171 jump *label110 notEqual *tmp14 1
+  172 set :findFreeUnit:first_unit @unit
+  173 label *label110
+  174 label *label111
+  175 label *label112
+  176 ubind @flare
+  177 label *label113
+  178 jump *label108 notEqual :findFreeUnit:first_unit @unit
+  179 label *label114
+  180 set *tmp8 null
+  181 jump *label115 always
+  182 label *label115
+  183 set :backgroundProcess:unit *tmp8
+  184 jump *label116 notEqual *tmp8 null
+  185 jump *label125 always
+  186 label *label116
+  187 label *label117
+  188 label *label118
+  189 label *label119
+  190 # "Function: void serviceDrill(in drill, in unit)"
+  191 ubind :backgroundProcess:unit
+  192 sensor :serviceDrill:item @unit @firstItem
+  193 jump *label120 notEqual :serviceDrill:item @titanium
+  194 ucontrol approach .coreX .coreY 4
+  195 ucontrol itemDrop .core 10
+  196 jump *label123 always
+  197 label *label120
+  198 jump *label121 notEqual :serviceDrill:item null
+  199 sensor *tmp26 :backgroundProcess:drill @x
+  200 sensor *tmp27 :backgroundProcess:drill @y
+  201 ucontrol approach *tmp26 *tmp27 4
+  202 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  203 jump *label122 always
+  204 label *label121
+  205 ucontrol itemDrop @air 10
+  206 label *label122
+  207 label *label123
+  208 label *label124
+  209 label *label125
+  210 set .units*2 :backgroundProcess:unit
+  211 set :backgroundProcess:drill .titaniumDrills*3
+  212 set :backgroundProcess:unit .units*3
+  213 label *label128
+  214 jump *label129 notEqual :backgroundProcess:drill null
+  215 jump *label17 always
+  216 label *label129
+  217 label *label130
+  218 sensor *tmp5 :backgroundProcess:unit @controller
+  219 jump *label143 equal *tmp5 @this
+  220 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  221 ubind @flare
+  222 jump *label131 notEqual @unit null
+  223 set *tmp8 null
+  224 jump *label140 always
+  225 label *label131
+  226 label *label132
+  227 set :findFreeUnit:first_unit @unit
+  228 label *label133
+  229 sensor *tmp11 @unit @controlled
+  230 jump *label134 notEqual *tmp11 0
+  231 ucontrol flag 0
+  232 set *tmp8 @unit
+  233 jump *label140 always
+  234 jump *label137 always
+  235 label *label134
+  236 sensor *tmp14 :findFreeUnit:first_unit @dead
+  237 jump *label135 notEqual *tmp14 1
+  238 set :findFreeUnit:first_unit @unit
+  239 label *label135
+  240 label *label136
+  241 label *label137
+  242 ubind @flare
+  243 label *label138
+  244 jump *label133 notEqual :findFreeUnit:first_unit @unit
+  245 label *label139
+  246 set *tmp8 null
+  247 jump *label140 always
+  248 label *label140
+  249 set :backgroundProcess:unit *tmp8
+  250 jump *label141 notEqual *tmp8 null
+  251 jump *label150 always
+  252 label *label141
+  253 label *label142
+  254 label *label143
+  255 label *label144
+  256 # "Function: void serviceDrill(in drill, in unit)"
+  257 ubind :backgroundProcess:unit
+  258 sensor :serviceDrill:item @unit @firstItem
+  259 jump *label145 notEqual :serviceDrill:item @titanium
+  260 ucontrol approach .coreX .coreY 4
+  261 ucontrol itemDrop .core 10
+  262 jump *label148 always
+  263 label *label145
+  264 jump *label146 notEqual :serviceDrill:item null
+  265 sensor *tmp26 :backgroundProcess:drill @x
+  266 sensor *tmp27 :backgroundProcess:drill @y
+  267 ucontrol approach *tmp26 *tmp27 4
+  268 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  269 jump *label147 always
+  270 label *label146
+  271 ucontrol itemDrop @air 10
+  272 label *label147
+  273 label *label148
+  274 label *label149
+  275 label *label150
+  276 set .units*3 :backgroundProcess:unit
+  277 set :backgroundProcess:drill .titaniumDrills*4
+  278 set :backgroundProcess:unit .units*4
+  279 label *label153
+  280 jump *label154 notEqual :backgroundProcess:drill null
+  281 jump *label17 always
+  282 label *label154
+  283 label *label155
+  284 sensor *tmp5 :backgroundProcess:unit @controller
+  285 jump *label168 equal *tmp5 @this
+  286 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  287 ubind @flare
+  288 jump *label156 notEqual @unit null
+  289 set *tmp8 null
+  290 jump *label165 always
+  291 label *label156
+  292 label *label157
+  293 set :findFreeUnit:first_unit @unit
+  294 label *label158
+  295 sensor *tmp11 @unit @controlled
+  296 jump *label159 notEqual *tmp11 0
+  297 ucontrol flag 0
+  298 set *tmp8 @unit
+  299 jump *label165 always
+  300 jump *label162 always
+  301 label *label159
+  302 sensor *tmp14 :findFreeUnit:first_unit @dead
+  303 jump *label160 notEqual *tmp14 1
+  304 set :findFreeUnit:first_unit @unit
+  305 label *label160
+  306 label *label161
+  307 label *label162
+  308 ubind @flare
+  309 label *label163
+  310 jump *label158 notEqual :findFreeUnit:first_unit @unit
+  311 label *label164
+  312 set *tmp8 null
+  313 jump *label165 always
+  314 label *label165
+  315 set :backgroundProcess:unit *tmp8
+  316 jump *label166 notEqual *tmp8 null
+  317 jump *label175 always
+  318 label *label166
+  319 label *label167
+  320 label *label168
+  321 label *label169
+  322 # "Function: void serviceDrill(in drill, in unit)"
+  323 ubind :backgroundProcess:unit
+  324 sensor :serviceDrill:item @unit @firstItem
+  325 jump *label170 notEqual :serviceDrill:item @titanium
+  326 ucontrol approach .coreX .coreY 4
+  327 ucontrol itemDrop .core 10
+  328 jump *label173 always
+  329 label *label170
+  330 jump *label171 notEqual :serviceDrill:item null
+  331 sensor *tmp26 :backgroundProcess:drill @x
+  332 sensor *tmp27 :backgroundProcess:drill @y
+  333 ucontrol approach *tmp26 *tmp27 4
+  334 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  335 jump *label172 always
+  336 label *label171
+  337 ucontrol itemDrop @air 10
+  338 label *label172
+  339 label *label173
+  340 label *label174
+  341 label *label175
+  342 set .units*4 :backgroundProcess:unit
+  343 set :backgroundProcess:drill .titaniumDrills*5
+  344 set :backgroundProcess:unit .units*5
+  345 label *label178
+  346 jump *label179 notEqual :backgroundProcess:drill null
+  347 jump *label17 always
+  348 label *label179
+  349 label *label180
+  350 sensor *tmp5 :backgroundProcess:unit @controller
+  351 jump *label193 equal *tmp5 @this
+  352 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  353 ubind @flare
+  354 jump *label181 notEqual @unit null
+  355 set *tmp8 null
+  356 jump *label190 always
+  357 label *label181
+  358 label *label182
+  359 set :findFreeUnit:first_unit @unit
+  360 label *label183
+  361 sensor *tmp11 @unit @controlled
+  362 jump *label184 notEqual *tmp11 0
+  363 ucontrol flag 0
+  364 set *tmp8 @unit
+  365 jump *label190 always
+  366 jump *label187 always
+  367 label *label184
+  368 sensor *tmp14 :findFreeUnit:first_unit @dead
+  369 jump *label185 notEqual *tmp14 1
+  370 set :findFreeUnit:first_unit @unit
+  371 label *label185
+  372 label *label186
+  373 label *label187
+  374 ubind @flare
+  375 label *label188
+  376 jump *label183 notEqual :findFreeUnit:first_unit @unit
+  377 label *label189
+  378 set *tmp8 null
+  379 jump *label190 always
+  380 label *label190
+  381 set :backgroundProcess:unit *tmp8
+  382 jump *label191 notEqual *tmp8 null
+  383 jump *label200 always
+  384 label *label191
+  385 label *label192
+  386 label *label193
+  387 label *label194
+  388 # "Function: void serviceDrill(in drill, in unit)"
+  389 ubind :backgroundProcess:unit
+  390 sensor :serviceDrill:item @unit @firstItem
+  391 jump *label195 notEqual :serviceDrill:item @titanium
+  392 ucontrol approach .coreX .coreY 4
+  393 ucontrol itemDrop .core 10
+  394 jump *label198 always
+  395 label *label195
+  396 jump *label196 notEqual :serviceDrill:item null
+  397 sensor *tmp26 :backgroundProcess:drill @x
+  398 sensor *tmp27 :backgroundProcess:drill @y
+  399 ucontrol approach *tmp26 *tmp27 4
+  400 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  401 jump *label197 always
+  402 label *label196
+  403 ucontrol itemDrop @air 10
+  404 label *label197
+  405 label *label198
+  406 label *label199
+  407 label *label200
+  408 set .units*5 :backgroundProcess:unit
+  409 set :backgroundProcess:drill .titaniumDrills*6
+  410 set :backgroundProcess:unit .units*6
+  411 label *label203
+  412 jump *label204 notEqual :backgroundProcess:drill null
+  413 jump *label17 always
+  414 label *label204
+  415 label *label205
+  416 sensor *tmp5 :backgroundProcess:unit @controller
+  417 jump *label218 equal *tmp5 @this
+  418 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  419 ubind @flare
+  420 jump *label206 notEqual @unit null
+  421 set *tmp8 null
+  422 jump *label215 always
+  423 label *label206
+  424 label *label207
+  425 set :findFreeUnit:first_unit @unit
+  426 label *label208
+  427 sensor *tmp11 @unit @controlled
+  428 jump *label209 notEqual *tmp11 0
+  429 ucontrol flag 0
+  430 set *tmp8 @unit
+  431 jump *label215 always
+  432 jump *label212 always
+  433 label *label209
+  434 sensor *tmp14 :findFreeUnit:first_unit @dead
+  435 jump *label210 notEqual *tmp14 1
+  436 set :findFreeUnit:first_unit @unit
+  437 label *label210
+  438 label *label211
+  439 label *label212
+  440 ubind @flare
+  441 label *label213
+  442 jump *label208 notEqual :findFreeUnit:first_unit @unit
+  443 label *label214
+  444 set *tmp8 null
+  445 jump *label215 always
+  446 label *label215
+  447 set :backgroundProcess:unit *tmp8
+  448 jump *label216 notEqual *tmp8 null
+  449 jump *label225 always
+  450 label *label216
+  451 label *label217
+  452 label *label218
+  453 label *label219
+  454 # "Function: void serviceDrill(in drill, in unit)"
+  455 ubind :backgroundProcess:unit
+  456 sensor :serviceDrill:item @unit @firstItem
+  457 jump *label220 notEqual :serviceDrill:item @titanium
+  458 ucontrol approach .coreX .coreY 4
+  459 ucontrol itemDrop .core 10
+  460 jump *label223 always
+  461 label *label220
+  462 jump *label221 notEqual :serviceDrill:item null
+  463 sensor *tmp26 :backgroundProcess:drill @x
+  464 sensor *tmp27 :backgroundProcess:drill @y
+  465 ucontrol approach *tmp26 *tmp27 4
+  466 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  467 jump *label222 always
+  468 label *label221
+  469 ucontrol itemDrop @air 10
+  470 label *label222
+  471 label *label223
+  472 label *label224
+  473 label *label225
+  474 set .units*6 :backgroundProcess:unit
+  475 set :backgroundProcess:drill .titaniumDrills*7
+  476 set :backgroundProcess:unit .units*7
+  477 label *label228
+  478 jump *label229 notEqual :backgroundProcess:drill null
+  479 jump *label17 always
+  480 label *label229
+  481 label *label230
+  482 sensor *tmp5 :backgroundProcess:unit @controller
+  483 jump *label243 equal *tmp5 @this
+  484 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  485 ubind @flare
+  486 jump *label231 notEqual @unit null
+  487 set *tmp8 null
+  488 jump *label240 always
+  489 label *label231
+  490 label *label232
+  491 set :findFreeUnit:first_unit @unit
+  492 label *label233
+  493 sensor *tmp11 @unit @controlled
+  494 jump *label234 notEqual *tmp11 0
+  495 ucontrol flag 0
+  496 set *tmp8 @unit
+  497 jump *label240 always
+  498 jump *label237 always
+  499 label *label234
+  500 sensor *tmp14 :findFreeUnit:first_unit @dead
+  501 jump *label235 notEqual *tmp14 1
+  502 set :findFreeUnit:first_unit @unit
+  503 label *label235
+  504 label *label236
+  505 label *label237
+  506 ubind @flare
+  507 label *label238
+  508 jump *label233 notEqual :findFreeUnit:first_unit @unit
+  509 label *label239
+  510 set *tmp8 null
+  511 jump *label240 always
+  512 label *label240
+  513 set :backgroundProcess:unit *tmp8
+  514 jump *label241 notEqual *tmp8 null
+  515 jump *label250 always
+  516 label *label241
+  517 label *label242
+  518 label *label243
+  519 label *label244
+  520 # "Function: void serviceDrill(in drill, in unit)"
+  521 ubind :backgroundProcess:unit
+  522 sensor :serviceDrill:item @unit @firstItem
+  523 jump *label245 notEqual :serviceDrill:item @titanium
+  524 ucontrol approach .coreX .coreY 4
+  525 ucontrol itemDrop .core 10
+  526 jump *label248 always
+  527 label *label245
+  528 jump *label246 notEqual :serviceDrill:item null
+  529 sensor *tmp26 :backgroundProcess:drill @x
+  530 sensor *tmp27 :backgroundProcess:drill @y
+  531 ucontrol approach *tmp26 *tmp27 4
+  532 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  533 jump *label247 always
+  534 label *label246
+  535 ucontrol itemDrop @air 10
+  536 label *label247
+  537 label *label248
+  538 label *label249
+  539 label *label250
+  540 set .units*7 :backgroundProcess:unit
+  541 set :backgroundProcess:drill .titaniumDrills*8
+  542 set :backgroundProcess:unit .units*8
+  543 label *label253
+  544 jump *label254 notEqual :backgroundProcess:drill null
+  545 jump *label17 always
+  546 label *label254
+  547 label *label255
+  548 sensor *tmp5 :backgroundProcess:unit @controller
+  549 jump *label268 equal *tmp5 @this
+  550 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  551 ubind @flare
+  552 jump *label256 notEqual @unit null
+  553 set *tmp8 null
+  554 jump *label265 always
+  555 label *label256
+  556 label *label257
+  557 set :findFreeUnit:first_unit @unit
+  558 label *label258
+  559 sensor *tmp11 @unit @controlled
+  560 jump *label259 notEqual *tmp11 0
+  561 ucontrol flag 0
+  562 set *tmp8 @unit
+  563 jump *label265 always
+  564 jump *label262 always
+  565 label *label259
+  566 sensor *tmp14 :findFreeUnit:first_unit @dead
+  567 jump *label260 notEqual *tmp14 1
+  568 set :findFreeUnit:first_unit @unit
+  569 label *label260
+  570 label *label261
+  571 label *label262
+  572 ubind @flare
+  573 label *label263
+  574 jump *label258 notEqual :findFreeUnit:first_unit @unit
+  575 label *label264
+  576 set *tmp8 null
+  577 jump *label265 always
+  578 label *label265
+  579 set :backgroundProcess:unit *tmp8
+  580 jump *label266 notEqual *tmp8 null
+  581 jump *label275 always
+  582 label *label266
+  583 label *label267
+  584 label *label268
+  585 label *label269
+  586 # "Function: void serviceDrill(in drill, in unit)"
+  587 ubind :backgroundProcess:unit
+  588 sensor :serviceDrill:item @unit @firstItem
+  589 jump *label270 notEqual :serviceDrill:item @titanium
+  590 ucontrol approach .coreX .coreY 4
+  591 ucontrol itemDrop .core 10
+  592 jump *label273 always
+  593 label *label270
+  594 jump *label271 notEqual :serviceDrill:item null
+  595 sensor *tmp26 :backgroundProcess:drill @x
+  596 sensor *tmp27 :backgroundProcess:drill @y
+  597 ucontrol approach *tmp26 *tmp27 4
+  598 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  599 jump *label272 always
+  600 label *label271
+  601 ucontrol itemDrop @air 10
+  602 label *label272
+  603 label *label273
+  604 label *label274
+  605 label *label275
+  606 set .units*8 :backgroundProcess:unit
+  607 set :backgroundProcess:drill .titaniumDrills*9
+  608 set :backgroundProcess:unit .units*9
+  609 label *label278
+  610 jump *label279 notEqual :backgroundProcess:drill null
+  611 jump *label17 always
+  612 label *label279
+  613 label *label280
+  614 sensor *tmp5 :backgroundProcess:unit @controller
+  615 jump *label293 equal *tmp5 @this
+  616 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
+  617 ubind @flare
+  618 jump *label281 notEqual @unit null
+  619 set *tmp8 null
+  620 jump *label290 always
+  621 label *label281
+  622 label *label282
+  623 set :findFreeUnit:first_unit @unit
+  624 label *label283
+  625 sensor *tmp11 @unit @controlled
+  626 jump *label284 notEqual *tmp11 0
+  627 ucontrol flag 0
+  628 set *tmp8 @unit
+  629 jump *label290 always
+  630 jump *label287 always
+  631 label *label284
+  632 sensor *tmp14 :findFreeUnit:first_unit @dead
+  633 jump *label285 notEqual *tmp14 1
+  634 set :findFreeUnit:first_unit @unit
+  635 label *label285
+  636 label *label286
+  637 label *label287
+  638 ubind @flare
+  639 label *label288
+  640 jump *label283 notEqual :findFreeUnit:first_unit @unit
+  641 label *label289
+  642 set *tmp8 null
+  643 jump *label290 always
+  644 label *label290
+  645 set :backgroundProcess:unit *tmp8
+  646 jump *label291 notEqual *tmp8 null
+  647 jump *label300 always
+  648 label *label291
+  649 label *label292
+  650 label *label293
+  651 label *label294
+  652 # "Function: void serviceDrill(in drill, in unit)"
+  653 ubind :backgroundProcess:unit
+  654 sensor :serviceDrill:item @unit @firstItem
+  655 jump *label295 notEqual :serviceDrill:item @titanium
+  656 ucontrol approach .coreX .coreY 4
+  657 ucontrol itemDrop .core 10
+  658 jump *label298 always
+  659 label *label295
+  660 jump *label296 notEqual :serviceDrill:item null
+  661 sensor *tmp26 :backgroundProcess:drill @x
+  662 sensor *tmp27 :backgroundProcess:drill @y
+  663 ucontrol approach *tmp26 *tmp27 4
+  664 ucontrol itemTake :backgroundProcess:drill @titanium 10
+  665 jump *label297 always
+  666 label *label296
+  667 ucontrol itemDrop @air 10
+  668 label *label297
+  669 label *label298
+  670 label *label299
+  671 label *label300
+  672 set .units*9 :backgroundProcess:unit
+  673 label *label17
   674 label *label13
   675 jump *label12 always
   676 label *label14

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-10 instructions):
 
    46 jump *label58 notEqual :findFreeUnit:first_unit @unit
    47 label *label64
    48 set *tmp8 null
-    * jump *label65 always
    49 label *label65
    50 set :backgroundProcess:unit *tmp8
    51 jump *label66 notEqual *tmp8 null
 
   111 jump *label83 notEqual :findFreeUnit:first_unit @unit
   112 label *label89
   113 set *tmp8 null
-    * jump *label90 always
   114 label *label90
   115 set :backgroundProcess:unit *tmp8
   116 jump *label91 notEqual *tmp8 null
 
   176 jump *label108 notEqual :findFreeUnit:first_unit @unit
   177 label *label114
   178 set *tmp8 null
-    * jump *label115 always
   179 label *label115
   180 set :backgroundProcess:unit *tmp8
   181 jump *label116 notEqual *tmp8 null
 
   241 jump *label133 notEqual :findFreeUnit:first_unit @unit
   242 label *label139
   243 set *tmp8 null
-    * jump *label140 always
   244 label *label140
   245 set :backgroundProcess:unit *tmp8
   246 jump *label141 notEqual *tmp8 null
 
   306 jump *label158 notEqual :findFreeUnit:first_unit @unit
   307 label *label164
   308 set *tmp8 null
-    * jump *label165 always
   309 label *label165
   310 set :backgroundProcess:unit *tmp8
   311 jump *label166 notEqual *tmp8 null
 
   371 jump *label183 notEqual :findFreeUnit:first_unit @unit
   372 label *label189
   373 set *tmp8 null
-    * jump *label190 always
   374 label *label190
   375 set :backgroundProcess:unit *tmp8
   376 jump *label191 notEqual *tmp8 null
 
   436 jump *label208 notEqual :findFreeUnit:first_unit @unit
   437 label *label214
   438 set *tmp8 null
-    * jump *label215 always
   439 label *label215
   440 set :backgroundProcess:unit *tmp8
   441 jump *label216 notEqual *tmp8 null
 
   501 jump *label233 notEqual :findFreeUnit:first_unit @unit
   502 label *label239
   503 set *tmp8 null
-    * jump *label240 always
   504 label *label240
   505 set :backgroundProcess:unit *tmp8
   506 jump *label241 notEqual *tmp8 null
 
   566 jump *label258 notEqual :findFreeUnit:first_unit @unit
   567 label *label264
   568 set *tmp8 null
-    * jump *label265 always
   569 label *label265
   570 set :backgroundProcess:unit *tmp8
   571 jump *label266 notEqual *tmp8 null
 
   631 jump *label283 notEqual :findFreeUnit:first_unit @unit
   632 label *label289
   633 set *tmp8 null
-    * jump *label290 always
   634 label *label290
   635 set :backgroundProcess:unit *tmp8
   636 jump *label291 notEqual *tmp8 null

Modifications by Virtual Instruction Expansion (+1 instructions):
 
   682 label *label1
   683 # "Function: remote void addTitaniumDrill(in drill)"
   684 jump *label51 greaterThanEq .drills 9
-    * writearr<inlined> :addTitaniumDrill:drill .titaniumDrills[] .drills
+  685 op mul *tmp35 .drills 2
+  686 multijump *label305 *tmp35 0 (m:marker1)
+  687 multilabel *label305 (m:marker1)
+  688 set .titaniumDrills*0 :addTitaniumDrill:drill
+  689 jump *label304 always
+  690 multilabel *label306 (m:marker1)
+  691 set .titaniumDrills*1 :addTitaniumDrill:drill
+  692 jump *label304 always
+  693 multilabel *label307 (m:marker1)
+  694 set .titaniumDrills*2 :addTitaniumDrill:drill
+  695 jump *label304 always
+  696 multilabel *label308 (m:marker1)
+  697 set .titaniumDrills*3 :addTitaniumDrill:drill
+  698 jump *label304 always
+  699 multilabel *label309 (m:marker1)
+  700 set .titaniumDrills*4 :addTitaniumDrill:drill
+  701 jump *label304 always
+  702 multilabel *label310 (m:marker1)
+  703 set .titaniumDrills*5 :addTitaniumDrill:drill
+  704 jump *label304 always
+  705 multilabel *label311 (m:marker1)
+  706 set .titaniumDrills*6 :addTitaniumDrill:drill
+  707 jump *label304 always
+  708 multilabel *label312 (m:marker1)
+  709 set .titaniumDrills*7 :addTitaniumDrill:drill
+  710 jump *label304 always
+  711 multilabel *label313 (m:marker1)
+  712 set .titaniumDrills*8 :addTitaniumDrill:drill
+  713 jump *label304 always
+  714 multilabel *label314 (m:marker1)
+  715 set .titaniumDrills*9 :addTitaniumDrill:drill
+  716 jump *label304 always
+  717 label *label304
   718 op add .drills .drills 1
   719 label *label51
   720 label *label52

Modifications by Iterated phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   713 jump *label304 always
   714 multilabel *label314 (m:marker1)
   715 set .titaniumDrills*9 :addTitaniumDrill:drill
-    * jump *label304 always
   716 label *label304
   717 op add .drills .drills 1
   718 label *label51

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
     8 jump *label10 notEqual .core null
     9 jump *label9 always
    10 label *label10
-    * label *label11
    11 label *label12
    12 set :backgroundProcess:drill .titaniumDrills*0
    13 set :backgroundProcess:unit .units*0
-    * label *label53
    14 jump *label54 notEqual :backgroundProcess:drill null
    15 jump *label17 always
    16 label *label54
-    * label *label55
    17 sensor *tmp5 :backgroundProcess:unit @controller
    18 jump *label68 equal *tmp5 @this
    19 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    22 set *tmp8 null
    23 jump *label65 always
    24 label *label56
-    * label *label57
    25 set :findFreeUnit:first_unit @unit
    26 label *label58
    27 sensor *tmp11 @unit @controlled
 
    35 jump *label60 notEqual *tmp14 1
    36 set :findFreeUnit:first_unit @unit
    37 label *label60
-    * label *label61
    38 label *label62
    39 ubind @flare
-    * label *label63
    40 jump *label58 notEqual :findFreeUnit:first_unit @unit
-    * label *label64
    41 set *tmp8 null
    42 label *label65
    43 set :backgroundProcess:unit *tmp8
    44 jump *label66 notEqual *tmp8 null
    45 jump *label75 always
    46 label *label66
-    * label *label67
    47 label *label68
-    * label *label69
    48 # "Function: void serviceDrill(in drill, in unit)"
    49 ubind :backgroundProcess:unit
    50 sensor :serviceDrill:item @unit @firstItem
 
    63 ucontrol itemDrop @air 10
    64 label *label72
    65 label *label73
-    * label *label74
    66 label *label75
    67 set .units*0 :backgroundProcess:unit
    68 set :backgroundProcess:drill .titaniumDrills*1
    69 set :backgroundProcess:unit .units*1
-    * label *label78
    70 jump *label79 notEqual :backgroundProcess:drill null
    71 jump *label17 always
    72 label *label79
-    * label *label80
    73 sensor *tmp5 :backgroundProcess:unit @controller
    74 jump *label93 equal *tmp5 @this
    75 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    78 set *tmp8 null
    79 jump *label90 always
    80 label *label81
-    * label *label82
    81 set :findFreeUnit:first_unit @unit
    82 label *label83
    83 sensor *tmp11 @unit @controlled
 
    91 jump *label85 notEqual *tmp14 1
    92 set :findFreeUnit:first_unit @unit
    93 label *label85
-    * label *label86
    94 label *label87
    95 ubind @flare
-    * label *label88
    96 jump *label83 notEqual :findFreeUnit:first_unit @unit
-    * label *label89
    97 set *tmp8 null
    98 label *label90
    99 set :backgroundProcess:unit *tmp8
   100 jump *label91 notEqual *tmp8 null
   101 jump *label100 always
   102 label *label91
-    * label *label92
   103 label *label93
-    * label *label94
   104 # "Function: void serviceDrill(in drill, in unit)"
   105 ubind :backgroundProcess:unit
   106 sensor :serviceDrill:item @unit @firstItem
 
   119 ucontrol itemDrop @air 10
   120 label *label97
   121 label *label98
-    * label *label99
   122 label *label100
   123 set .units*1 :backgroundProcess:unit
   124 set :backgroundProcess:drill .titaniumDrills*2
   125 set :backgroundProcess:unit .units*2
-    * label *label103
   126 jump *label104 notEqual :backgroundProcess:drill null
   127 jump *label17 always
   128 label *label104
-    * label *label105
   129 sensor *tmp5 :backgroundProcess:unit @controller
   130 jump *label118 equal *tmp5 @this
   131 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   134 set *tmp8 null
   135 jump *label115 always
   136 label *label106
-    * label *label107
   137 set :findFreeUnit:first_unit @unit
   138 label *label108
   139 sensor *tmp11 @unit @controlled
 
   147 jump *label110 notEqual *tmp14 1
   148 set :findFreeUnit:first_unit @unit
   149 label *label110
-    * label *label111
   150 label *label112
   151 ubind @flare
-    * label *label113
   152 jump *label108 notEqual :findFreeUnit:first_unit @unit
-    * label *label114
   153 set *tmp8 null
   154 label *label115
   155 set :backgroundProcess:unit *tmp8
   156 jump *label116 notEqual *tmp8 null
   157 jump *label125 always
   158 label *label116
-    * label *label117
   159 label *label118
-    * label *label119
   160 # "Function: void serviceDrill(in drill, in unit)"
   161 ubind :backgroundProcess:unit
   162 sensor :serviceDrill:item @unit @firstItem
 
   175 ucontrol itemDrop @air 10
   176 label *label122
   177 label *label123
-    * label *label124
   178 label *label125
   179 set .units*2 :backgroundProcess:unit
   180 set :backgroundProcess:drill .titaniumDrills*3
   181 set :backgroundProcess:unit .units*3
-    * label *label128
   182 jump *label129 notEqual :backgroundProcess:drill null
   183 jump *label17 always
   184 label *label129
-    * label *label130
   185 sensor *tmp5 :backgroundProcess:unit @controller
   186 jump *label143 equal *tmp5 @this
   187 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   190 set *tmp8 null
   191 jump *label140 always
   192 label *label131
-    * label *label132
   193 set :findFreeUnit:first_unit @unit
   194 label *label133
   195 sensor *tmp11 @unit @controlled
 
   203 jump *label135 notEqual *tmp14 1
   204 set :findFreeUnit:first_unit @unit
   205 label *label135
-    * label *label136
   206 label *label137
   207 ubind @flare
-    * label *label138
   208 jump *label133 notEqual :findFreeUnit:first_unit @unit
-    * label *label139
   209 set *tmp8 null
   210 label *label140
   211 set :backgroundProcess:unit *tmp8
   212 jump *label141 notEqual *tmp8 null
   213 jump *label150 always
   214 label *label141
-    * label *label142
   215 label *label143
-    * label *label144
   216 # "Function: void serviceDrill(in drill, in unit)"
   217 ubind :backgroundProcess:unit
   218 sensor :serviceDrill:item @unit @firstItem
 
   231 ucontrol itemDrop @air 10
   232 label *label147
   233 label *label148
-    * label *label149
   234 label *label150
   235 set .units*3 :backgroundProcess:unit
   236 set :backgroundProcess:drill .titaniumDrills*4
   237 set :backgroundProcess:unit .units*4
-    * label *label153
   238 jump *label154 notEqual :backgroundProcess:drill null
   239 jump *label17 always
   240 label *label154
-    * label *label155
   241 sensor *tmp5 :backgroundProcess:unit @controller
   242 jump *label168 equal *tmp5 @this
   243 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   246 set *tmp8 null
   247 jump *label165 always
   248 label *label156
-    * label *label157
   249 set :findFreeUnit:first_unit @unit
   250 label *label158
   251 sensor *tmp11 @unit @controlled
 
   259 jump *label160 notEqual *tmp14 1
   260 set :findFreeUnit:first_unit @unit
   261 label *label160
-    * label *label161
   262 label *label162
   263 ubind @flare
-    * label *label163
   264 jump *label158 notEqual :findFreeUnit:first_unit @unit
-    * label *label164
   265 set *tmp8 null
   266 label *label165
   267 set :backgroundProcess:unit *tmp8
   268 jump *label166 notEqual *tmp8 null
   269 jump *label175 always
   270 label *label166
-    * label *label167
   271 label *label168
-    * label *label169
   272 # "Function: void serviceDrill(in drill, in unit)"
   273 ubind :backgroundProcess:unit
   274 sensor :serviceDrill:item @unit @firstItem
 
   287 ucontrol itemDrop @air 10
   288 label *label172
   289 label *label173
-    * label *label174
   290 label *label175
   291 set .units*4 :backgroundProcess:unit
   292 set :backgroundProcess:drill .titaniumDrills*5
   293 set :backgroundProcess:unit .units*5
-    * label *label178
   294 jump *label179 notEqual :backgroundProcess:drill null
   295 jump *label17 always
   296 label *label179
-    * label *label180
   297 sensor *tmp5 :backgroundProcess:unit @controller
   298 jump *label193 equal *tmp5 @this
   299 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   302 set *tmp8 null
   303 jump *label190 always
   304 label *label181
-    * label *label182
   305 set :findFreeUnit:first_unit @unit
   306 label *label183
   307 sensor *tmp11 @unit @controlled
 
   315 jump *label185 notEqual *tmp14 1
   316 set :findFreeUnit:first_unit @unit
   317 label *label185
-    * label *label186
   318 label *label187
   319 ubind @flare
-    * label *label188
   320 jump *label183 notEqual :findFreeUnit:first_unit @unit
-    * label *label189
   321 set *tmp8 null
   322 label *label190
   323 set :backgroundProcess:unit *tmp8
   324 jump *label191 notEqual *tmp8 null
   325 jump *label200 always
   326 label *label191
-    * label *label192
   327 label *label193
-    * label *label194
   328 # "Function: void serviceDrill(in drill, in unit)"
   329 ubind :backgroundProcess:unit
   330 sensor :serviceDrill:item @unit @firstItem
 
   343 ucontrol itemDrop @air 10
   344 label *label197
   345 label *label198
-    * label *label199
   346 label *label200
   347 set .units*5 :backgroundProcess:unit
   348 set :backgroundProcess:drill .titaniumDrills*6
   349 set :backgroundProcess:unit .units*6
-    * label *label203
   350 jump *label204 notEqual :backgroundProcess:drill null
   351 jump *label17 always
   352 label *label204
-    * label *label205
   353 sensor *tmp5 :backgroundProcess:unit @controller
   354 jump *label218 equal *tmp5 @this
   355 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   358 set *tmp8 null
   359 jump *label215 always
   360 label *label206
-    * label *label207
   361 set :findFreeUnit:first_unit @unit
   362 label *label208
   363 sensor *tmp11 @unit @controlled
 
   371 jump *label210 notEqual *tmp14 1
   372 set :findFreeUnit:first_unit @unit
   373 label *label210
-    * label *label211
   374 label *label212
   375 ubind @flare
-    * label *label213
   376 jump *label208 notEqual :findFreeUnit:first_unit @unit
-    * label *label214
   377 set *tmp8 null
   378 label *label215
   379 set :backgroundProcess:unit *tmp8
   380 jump *label216 notEqual *tmp8 null
   381 jump *label225 always
   382 label *label216
-    * label *label217
   383 label *label218
-    * label *label219
   384 # "Function: void serviceDrill(in drill, in unit)"
   385 ubind :backgroundProcess:unit
   386 sensor :serviceDrill:item @unit @firstItem
 
   399 ucontrol itemDrop @air 10
   400 label *label222
   401 label *label223
-    * label *label224
   402 label *label225
   403 set .units*6 :backgroundProcess:unit
   404 set :backgroundProcess:drill .titaniumDrills*7
   405 set :backgroundProcess:unit .units*7
-    * label *label228
   406 jump *label229 notEqual :backgroundProcess:drill null
   407 jump *label17 always
   408 label *label229
-    * label *label230
   409 sensor *tmp5 :backgroundProcess:unit @controller
   410 jump *label243 equal *tmp5 @this
   411 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   414 set *tmp8 null
   415 jump *label240 always
   416 label *label231
-    * label *label232
   417 set :findFreeUnit:first_unit @unit
   418 label *label233
   419 sensor *tmp11 @unit @controlled
 
   427 jump *label235 notEqual *tmp14 1
   428 set :findFreeUnit:first_unit @unit
   429 label *label235
-    * label *label236
   430 label *label237
   431 ubind @flare
-    * label *label238
   432 jump *label233 notEqual :findFreeUnit:first_unit @unit
-    * label *label239
   433 set *tmp8 null
   434 label *label240
   435 set :backgroundProcess:unit *tmp8
   436 jump *label241 notEqual *tmp8 null
   437 jump *label250 always
   438 label *label241
-    * label *label242
   439 label *label243
-    * label *label244
   440 # "Function: void serviceDrill(in drill, in unit)"
   441 ubind :backgroundProcess:unit
   442 sensor :serviceDrill:item @unit @firstItem
 
   455 ucontrol itemDrop @air 10
   456 label *label247
   457 label *label248
-    * label *label249
   458 label *label250
   459 set .units*7 :backgroundProcess:unit
   460 set :backgroundProcess:drill .titaniumDrills*8
   461 set :backgroundProcess:unit .units*8
-    * label *label253
   462 jump *label254 notEqual :backgroundProcess:drill null
   463 jump *label17 always
   464 label *label254
-    * label *label255
   465 sensor *tmp5 :backgroundProcess:unit @controller
   466 jump *label268 equal *tmp5 @this
   467 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   470 set *tmp8 null
   471 jump *label265 always
   472 label *label256
-    * label *label257
   473 set :findFreeUnit:first_unit @unit
   474 label *label258
   475 sensor *tmp11 @unit @controlled
 
   483 jump *label260 notEqual *tmp14 1
   484 set :findFreeUnit:first_unit @unit
   485 label *label260
-    * label *label261
   486 label *label262
   487 ubind @flare
-    * label *label263
   488 jump *label258 notEqual :findFreeUnit:first_unit @unit
-    * label *label264
   489 set *tmp8 null
   490 label *label265
   491 set :backgroundProcess:unit *tmp8
   492 jump *label266 notEqual *tmp8 null
   493 jump *label275 always
   494 label *label266
-    * label *label267
   495 label *label268
-    * label *label269
   496 # "Function: void serviceDrill(in drill, in unit)"
   497 ubind :backgroundProcess:unit
   498 sensor :serviceDrill:item @unit @firstItem
 
   511 ucontrol itemDrop @air 10
   512 label *label272
   513 label *label273
-    * label *label274
   514 label *label275
   515 set .units*8 :backgroundProcess:unit
   516 set :backgroundProcess:drill .titaniumDrills*9
   517 set :backgroundProcess:unit .units*9
-    * label *label278
   518 jump *label279 notEqual :backgroundProcess:drill null
   519 jump *label17 always
   520 label *label279
-    * label *label280
   521 sensor *tmp5 :backgroundProcess:unit @controller
   522 jump *label293 equal *tmp5 @this
   523 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   526 set *tmp8 null
   527 jump *label290 always
   528 label *label281
-    * label *label282
   529 set :findFreeUnit:first_unit @unit
   530 label *label283
   531 sensor *tmp11 @unit @controlled
 
   539 jump *label285 notEqual *tmp14 1
   540 set :findFreeUnit:first_unit @unit
   541 label *label285
-    * label *label286
   542 label *label287
   543 ubind @flare
-    * label *label288
   544 jump *label283 notEqual :findFreeUnit:first_unit @unit
-    * label *label289
   545 set *tmp8 null
   546 label *label290
   547 set :backgroundProcess:unit *tmp8
   548 jump *label291 notEqual *tmp8 null
   549 jump *label300 always
   550 label *label291
-    * label *label292
   551 label *label293
-    * label *label294
   552 # "Function: void serviceDrill(in drill, in unit)"
   553 ubind :backgroundProcess:unit
   554 sensor :serviceDrill:item @unit @firstItem
 
   567 ucontrol itemDrop @air 10
   568 label *label297
   569 label *label298
-    * label *label299
   570 label *label300
   571 set .units*9 :backgroundProcess:unit
   572 label *label17
-    * label *label13
   573 jump *label12 always
-    * label *label14
   574 label *label9
   575 wait 1e12
   576 jump *label8 always
 
   582 sensor .coreY .core @y
   583 set .titaniumDrills*0 :start:drill
   584 set .drills 1
-    * label *label49
   585 set :start*finished true
   586 jump *label8 always
   587 end
 
   622 label *label304
   623 op add .drills .drills 1
   624 label *label51
-    * label *label52
-    * label *label50
   625 set :addTitaniumDrill*finished true
   626 jump *label8 always
   627 end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-21 instructions):
 
     5 set *signature "ea15a0387a220137:v1"
     6 label *label8
     7 # "Function: void backgroundProcess()"
-    * jump *label10 notEqual .core null
-    * jump *label9 always
+    8 jump *label9 equal .core null
     9 label *label10
    10 label *label12
    11 set :backgroundProcess:drill .titaniumDrills*0
    12 set :backgroundProcess:unit .units*0
-    * jump *label54 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+   13 jump *label17 equal :backgroundProcess:drill null
    14 label *label54
    15 sensor *tmp5 :backgroundProcess:unit @controller
    16 jump *label68 equal *tmp5 @this
 
    39 set *tmp8 null
    40 label *label65
    41 set :backgroundProcess:unit *tmp8
-    * jump *label66 notEqual *tmp8 null
-    * jump *label75 always
+   42 jump *label75 equal *tmp8 null
    43 label *label66
    44 label *label68
    45 # "Function: void serviceDrill(in drill, in unit)"
 
    64 set .units*0 :backgroundProcess:unit
    65 set :backgroundProcess:drill .titaniumDrills*1
    66 set :backgroundProcess:unit .units*1
-    * jump *label79 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+   67 jump *label17 equal :backgroundProcess:drill null
    68 label *label79
    69 sensor *tmp5 :backgroundProcess:unit @controller
    70 jump *label93 equal *tmp5 @this
 
    93 set *tmp8 null
    94 label *label90
    95 set :backgroundProcess:unit *tmp8
-    * jump *label91 notEqual *tmp8 null
-    * jump *label100 always
+   96 jump *label100 equal *tmp8 null
    97 label *label91
    98 label *label93
    99 # "Function: void serviceDrill(in drill, in unit)"
 
   118 set .units*1 :backgroundProcess:unit
   119 set :backgroundProcess:drill .titaniumDrills*2
   120 set :backgroundProcess:unit .units*2
-    * jump *label104 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+  121 jump *label17 equal :backgroundProcess:drill null
   122 label *label104
   123 sensor *tmp5 :backgroundProcess:unit @controller
   124 jump *label118 equal *tmp5 @this
 
   147 set *tmp8 null
   148 label *label115
   149 set :backgroundProcess:unit *tmp8
-    * jump *label116 notEqual *tmp8 null
-    * jump *label125 always
+  150 jump *label125 equal *tmp8 null
   151 label *label116
   152 label *label118
   153 # "Function: void serviceDrill(in drill, in unit)"
 
   172 set .units*2 :backgroundProcess:unit
   173 set :backgroundProcess:drill .titaniumDrills*3
   174 set :backgroundProcess:unit .units*3
-    * jump *label129 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+  175 jump *label17 equal :backgroundProcess:drill null
   176 label *label129
   177 sensor *tmp5 :backgroundProcess:unit @controller
   178 jump *label143 equal *tmp5 @this
 
   201 set *tmp8 null
   202 label *label140
   203 set :backgroundProcess:unit *tmp8
-    * jump *label141 notEqual *tmp8 null
-    * jump *label150 always
+  204 jump *label150 equal *tmp8 null
   205 label *label141
   206 label *label143
   207 # "Function: void serviceDrill(in drill, in unit)"
 
   226 set .units*3 :backgroundProcess:unit
   227 set :backgroundProcess:drill .titaniumDrills*4
   228 set :backgroundProcess:unit .units*4
-    * jump *label154 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+  229 jump *label17 equal :backgroundProcess:drill null
   230 label *label154
   231 sensor *tmp5 :backgroundProcess:unit @controller
   232 jump *label168 equal *tmp5 @this
 
   255 set *tmp8 null
   256 label *label165
   257 set :backgroundProcess:unit *tmp8
-    * jump *label166 notEqual *tmp8 null
-    * jump *label175 always
+  258 jump *label175 equal *tmp8 null
   259 label *label166
   260 label *label168
   261 # "Function: void serviceDrill(in drill, in unit)"
 
   280 set .units*4 :backgroundProcess:unit
   281 set :backgroundProcess:drill .titaniumDrills*5
   282 set :backgroundProcess:unit .units*5
-    * jump *label179 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+  283 jump *label17 equal :backgroundProcess:drill null
   284 label *label179
   285 sensor *tmp5 :backgroundProcess:unit @controller
   286 jump *label193 equal *tmp5 @this
 
   309 set *tmp8 null
   310 label *label190
   311 set :backgroundProcess:unit *tmp8
-    * jump *label191 notEqual *tmp8 null
-    * jump *label200 always
+  312 jump *label200 equal *tmp8 null
   313 label *label191
   314 label *label193
   315 # "Function: void serviceDrill(in drill, in unit)"
 
   334 set .units*5 :backgroundProcess:unit
   335 set :backgroundProcess:drill .titaniumDrills*6
   336 set :backgroundProcess:unit .units*6
-    * jump *label204 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+  337 jump *label17 equal :backgroundProcess:drill null
   338 label *label204
   339 sensor *tmp5 :backgroundProcess:unit @controller
   340 jump *label218 equal *tmp5 @this
 
   363 set *tmp8 null
   364 label *label215
   365 set :backgroundProcess:unit *tmp8
-    * jump *label216 notEqual *tmp8 null
-    * jump *label225 always
+  366 jump *label225 equal *tmp8 null
   367 label *label216
   368 label *label218
   369 # "Function: void serviceDrill(in drill, in unit)"
 
   388 set .units*6 :backgroundProcess:unit
   389 set :backgroundProcess:drill .titaniumDrills*7
   390 set :backgroundProcess:unit .units*7
-    * jump *label229 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+  391 jump *label17 equal :backgroundProcess:drill null
   392 label *label229
   393 sensor *tmp5 :backgroundProcess:unit @controller
   394 jump *label243 equal *tmp5 @this
 
   417 set *tmp8 null
   418 label *label240
   419 set :backgroundProcess:unit *tmp8
-    * jump *label241 notEqual *tmp8 null
-    * jump *label250 always
+  420 jump *label250 equal *tmp8 null
   421 label *label241
   422 label *label243
   423 # "Function: void serviceDrill(in drill, in unit)"
 
   442 set .units*7 :backgroundProcess:unit
   443 set :backgroundProcess:drill .titaniumDrills*8
   444 set :backgroundProcess:unit .units*8
-    * jump *label254 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+  445 jump *label17 equal :backgroundProcess:drill null
   446 label *label254
   447 sensor *tmp5 :backgroundProcess:unit @controller
   448 jump *label268 equal *tmp5 @this
 
   471 set *tmp8 null
   472 label *label265
   473 set :backgroundProcess:unit *tmp8
-    * jump *label266 notEqual *tmp8 null
-    * jump *label275 always
+  474 jump *label275 equal *tmp8 null
   475 label *label266
   476 label *label268
   477 # "Function: void serviceDrill(in drill, in unit)"
 
   496 set .units*8 :backgroundProcess:unit
   497 set :backgroundProcess:drill .titaniumDrills*9
   498 set :backgroundProcess:unit .units*9
-    * jump *label279 notEqual :backgroundProcess:drill null
-    * jump *label17 always
+  499 jump *label17 equal :backgroundProcess:drill null
   500 label *label279
   501 sensor *tmp5 :backgroundProcess:unit @controller
   502 jump *label293 equal *tmp5 @this
 
   525 set *tmp8 null
   526 label *label290
   527 set :backgroundProcess:unit *tmp8
-    * jump *label291 notEqual *tmp8 null
-    * jump *label300 always
+  528 jump *label300 equal *tmp8 null
   529 label *label291
   530 label *label293
   531 # "Function: void serviceDrill(in drill, in unit)"

Modifications by Jumps phase, Jump Optimization, pass 6, iteration 1:
 
     6 label *label8
     7 # "Function: void backgroundProcess()"
     8 jump *label9 equal .core null
-    * label *label10
     9 label *label12
    10 set :backgroundProcess:drill .titaniumDrills*0
    11 set :backgroundProcess:unit .units*0
    12 jump *label17 equal :backgroundProcess:drill null
-    * label *label54
    13 sensor *tmp5 :backgroundProcess:unit @controller
    14 jump *label68 equal *tmp5 @this
    15 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    38 label *label65
    39 set :backgroundProcess:unit *tmp8
    40 jump *label75 equal *tmp8 null
-    * label *label66
    41 label *label68
    42 # "Function: void serviceDrill(in drill, in unit)"
    43 ubind :backgroundProcess:unit
 
    62 set :backgroundProcess:drill .titaniumDrills*1
    63 set :backgroundProcess:unit .units*1
    64 jump *label17 equal :backgroundProcess:drill null
-    * label *label79
    65 sensor *tmp5 :backgroundProcess:unit @controller
    66 jump *label93 equal *tmp5 @this
    67 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    90 label *label90
    91 set :backgroundProcess:unit *tmp8
    92 jump *label100 equal *tmp8 null
-    * label *label91
    93 label *label93
    94 # "Function: void serviceDrill(in drill, in unit)"
    95 ubind :backgroundProcess:unit
 
   114 set :backgroundProcess:drill .titaniumDrills*2
   115 set :backgroundProcess:unit .units*2
   116 jump *label17 equal :backgroundProcess:drill null
-    * label *label104
   117 sensor *tmp5 :backgroundProcess:unit @controller
   118 jump *label118 equal *tmp5 @this
   119 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   142 label *label115
   143 set :backgroundProcess:unit *tmp8
   144 jump *label125 equal *tmp8 null
-    * label *label116
   145 label *label118
   146 # "Function: void serviceDrill(in drill, in unit)"
   147 ubind :backgroundProcess:unit
 
   166 set :backgroundProcess:drill .titaniumDrills*3
   167 set :backgroundProcess:unit .units*3
   168 jump *label17 equal :backgroundProcess:drill null
-    * label *label129
   169 sensor *tmp5 :backgroundProcess:unit @controller
   170 jump *label143 equal *tmp5 @this
   171 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   194 label *label140
   195 set :backgroundProcess:unit *tmp8
   196 jump *label150 equal *tmp8 null
-    * label *label141
   197 label *label143
   198 # "Function: void serviceDrill(in drill, in unit)"
   199 ubind :backgroundProcess:unit
 
   218 set :backgroundProcess:drill .titaniumDrills*4
   219 set :backgroundProcess:unit .units*4
   220 jump *label17 equal :backgroundProcess:drill null
-    * label *label154
   221 sensor *tmp5 :backgroundProcess:unit @controller
   222 jump *label168 equal *tmp5 @this
   223 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   246 label *label165
   247 set :backgroundProcess:unit *tmp8
   248 jump *label175 equal *tmp8 null
-    * label *label166
   249 label *label168
   250 # "Function: void serviceDrill(in drill, in unit)"
   251 ubind :backgroundProcess:unit
 
   270 set :backgroundProcess:drill .titaniumDrills*5
   271 set :backgroundProcess:unit .units*5
   272 jump *label17 equal :backgroundProcess:drill null
-    * label *label179
   273 sensor *tmp5 :backgroundProcess:unit @controller
   274 jump *label193 equal *tmp5 @this
   275 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   298 label *label190
   299 set :backgroundProcess:unit *tmp8
   300 jump *label200 equal *tmp8 null
-    * label *label191
   301 label *label193
   302 # "Function: void serviceDrill(in drill, in unit)"
   303 ubind :backgroundProcess:unit
 
   322 set :backgroundProcess:drill .titaniumDrills*6
   323 set :backgroundProcess:unit .units*6
   324 jump *label17 equal :backgroundProcess:drill null
-    * label *label204
   325 sensor *tmp5 :backgroundProcess:unit @controller
   326 jump *label218 equal *tmp5 @this
   327 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   350 label *label215
   351 set :backgroundProcess:unit *tmp8
   352 jump *label225 equal *tmp8 null
-    * label *label216
   353 label *label218
   354 # "Function: void serviceDrill(in drill, in unit)"
   355 ubind :backgroundProcess:unit
 
   374 set :backgroundProcess:drill .titaniumDrills*7
   375 set :backgroundProcess:unit .units*7
   376 jump *label17 equal :backgroundProcess:drill null
-    * label *label229
   377 sensor *tmp5 :backgroundProcess:unit @controller
   378 jump *label243 equal *tmp5 @this
   379 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   402 label *label240
   403 set :backgroundProcess:unit *tmp8
   404 jump *label250 equal *tmp8 null
-    * label *label241
   405 label *label243
   406 # "Function: void serviceDrill(in drill, in unit)"
   407 ubind :backgroundProcess:unit
 
   426 set :backgroundProcess:drill .titaniumDrills*8
   427 set :backgroundProcess:unit .units*8
   428 jump *label17 equal :backgroundProcess:drill null
-    * label *label254
   429 sensor *tmp5 :backgroundProcess:unit @controller
   430 jump *label268 equal *tmp5 @this
   431 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   454 label *label265
   455 set :backgroundProcess:unit *tmp8
   456 jump *label275 equal *tmp8 null
-    * label *label266
   457 label *label268
   458 # "Function: void serviceDrill(in drill, in unit)"
   459 ubind :backgroundProcess:unit
 
   478 set :backgroundProcess:drill .titaniumDrills*9
   479 set :backgroundProcess:unit .units*9
   480 jump *label17 equal :backgroundProcess:drill null
-    * label *label279
   481 sensor *tmp5 :backgroundProcess:unit @controller
   482 jump *label293 equal *tmp5 @this
   483 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   506 label *label290
   507 set :backgroundProcess:unit *tmp8
   508 jump *label300 equal *tmp8 null
-    * label *label291
   509 label *label293
   510 # "Function: void serviceDrill(in drill, in unit)"
   511 ubind :backgroundProcess:unit

Modifications by Jumps phase, Jump Threading, pass 6, iteration 1:
 
     9 label *label12
    10 set :backgroundProcess:drill .titaniumDrills*0
    11 set :backgroundProcess:unit .units*0
-    * jump *label17 equal :backgroundProcess:drill null
+   12 jump *label12 equal :backgroundProcess:drill null
    13 sensor *tmp5 :backgroundProcess:unit @controller
    14 jump *label68 equal *tmp5 @this
    15 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
    61 set .units*0 :backgroundProcess:unit
    62 set :backgroundProcess:drill .titaniumDrills*1
    63 set :backgroundProcess:unit .units*1
-    * jump *label17 equal :backgroundProcess:drill null
+   64 jump *label12 equal :backgroundProcess:drill null
    65 sensor *tmp5 :backgroundProcess:unit @controller
    66 jump *label93 equal *tmp5 @this
    67 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   113 set .units*1 :backgroundProcess:unit
   114 set :backgroundProcess:drill .titaniumDrills*2
   115 set :backgroundProcess:unit .units*2
-    * jump *label17 equal :backgroundProcess:drill null
+  116 jump *label12 equal :backgroundProcess:drill null
   117 sensor *tmp5 :backgroundProcess:unit @controller
   118 jump *label118 equal *tmp5 @this
   119 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   165 set .units*2 :backgroundProcess:unit
   166 set :backgroundProcess:drill .titaniumDrills*3
   167 set :backgroundProcess:unit .units*3
-    * jump *label17 equal :backgroundProcess:drill null
+  168 jump *label12 equal :backgroundProcess:drill null
   169 sensor *tmp5 :backgroundProcess:unit @controller
   170 jump *label143 equal *tmp5 @this
   171 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   217 set .units*3 :backgroundProcess:unit
   218 set :backgroundProcess:drill .titaniumDrills*4
   219 set :backgroundProcess:unit .units*4
-    * jump *label17 equal :backgroundProcess:drill null
+  220 jump *label12 equal :backgroundProcess:drill null
   221 sensor *tmp5 :backgroundProcess:unit @controller
   222 jump *label168 equal *tmp5 @this
   223 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   269 set .units*4 :backgroundProcess:unit
   270 set :backgroundProcess:drill .titaniumDrills*5
   271 set :backgroundProcess:unit .units*5
-    * jump *label17 equal :backgroundProcess:drill null
+  272 jump *label12 equal :backgroundProcess:drill null
   273 sensor *tmp5 :backgroundProcess:unit @controller
   274 jump *label193 equal *tmp5 @this
   275 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   321 set .units*5 :backgroundProcess:unit
   322 set :backgroundProcess:drill .titaniumDrills*6
   323 set :backgroundProcess:unit .units*6
-    * jump *label17 equal :backgroundProcess:drill null
+  324 jump *label12 equal :backgroundProcess:drill null
   325 sensor *tmp5 :backgroundProcess:unit @controller
   326 jump *label218 equal *tmp5 @this
   327 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   373 set .units*6 :backgroundProcess:unit
   374 set :backgroundProcess:drill .titaniumDrills*7
   375 set :backgroundProcess:unit .units*7
-    * jump *label17 equal :backgroundProcess:drill null
+  376 jump *label12 equal :backgroundProcess:drill null
   377 sensor *tmp5 :backgroundProcess:unit @controller
   378 jump *label243 equal *tmp5 @this
   379 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   425 set .units*7 :backgroundProcess:unit
   426 set :backgroundProcess:drill .titaniumDrills*8
   427 set :backgroundProcess:unit .units*8
-    * jump *label17 equal :backgroundProcess:drill null
+  428 jump *label12 equal :backgroundProcess:drill null
   429 sensor *tmp5 :backgroundProcess:unit @controller
   430 jump *label268 equal *tmp5 @this
   431 # "Function: def findFreeUnit(in unit_type, in initial_flag)"
 
   477 set .units*8 :backgroundProcess:unit
   478 set :backgroundProcess:drill .titaniumDrills*9
   479 set :backgroundProcess:unit .units*9
-    * jump *label17 equal :backgroundProcess:drill null
+  480 jump *label12 equal :backgroundProcess:drill null
   481 sensor *tmp5 :backgroundProcess:unit @controller
   482 jump *label293 equal *tmp5 @this
   483 # "Function: def findFreeUnit(in unit_type, in initial_flag)"

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-13 instructions):
 
    25 ucontrol flag 0
    26 set *tmp8 @unit
    27 jump *label65 always
-    * jump *label62 always
    28 label *label59
    29 sensor *tmp14 :findFreeUnit:first_unit @dead
    30 jump *label60 notEqual *tmp14 1
 
    76 ucontrol flag 0
    77 set *tmp8 @unit
    78 jump *label90 always
-    * jump *label87 always
    79 label *label84
    80 sensor *tmp14 :findFreeUnit:first_unit @dead
    81 jump *label85 notEqual *tmp14 1
 
   127 ucontrol flag 0
   128 set *tmp8 @unit
   129 jump *label115 always
-    * jump *label112 always
   130 label *label109
   131 sensor *tmp14 :findFreeUnit:first_unit @dead
   132 jump *label110 notEqual *tmp14 1
 
   178 ucontrol flag 0
   179 set *tmp8 @unit
   180 jump *label140 always
-    * jump *label137 always
   181 label *label134
   182 sensor *tmp14 :findFreeUnit:first_unit @dead
   183 jump *label135 notEqual *tmp14 1
 
   229 ucontrol flag 0
   230 set *tmp8 @unit
   231 jump *label165 always
-    * jump *label162 always
   232 label *label159
   233 sensor *tmp14 :findFreeUnit:first_unit @dead
   234 jump *label160 notEqual *tmp14 1
 
   280 ucontrol flag 0
   281 set *tmp8 @unit
   282 jump *label190 always
-    * jump *label187 always
   283 label *label184
   284 sensor *tmp14 :findFreeUnit:first_unit @dead
   285 jump *label185 notEqual *tmp14 1
 
   331 ucontrol flag 0
   332 set *tmp8 @unit
   333 jump *label215 always
-    * jump *label212 always
   334 label *label209
   335 sensor *tmp14 :findFreeUnit:first_unit @dead
   336 jump *label210 notEqual *tmp14 1
 
   382 ucontrol flag 0
   383 set *tmp8 @unit
   384 jump *label240 always
-    * jump *label237 always
   385 label *label234
   386 sensor *tmp14 :findFreeUnit:first_unit @dead
   387 jump *label235 notEqual *tmp14 1
 
   433 ucontrol flag 0
   434 set *tmp8 @unit
   435 jump *label265 always
-    * jump *label262 always
   436 label *label259
   437 sensor *tmp14 :findFreeUnit:first_unit @dead
   438 jump *label260 notEqual *tmp14 1
 
   484 ucontrol flag 0
   485 set *tmp8 @unit
   486 jump *label290 always
-    * jump *label287 always
   487 label *label284
   488 sensor *tmp14 :findFreeUnit:first_unit @dead
   489 jump *label285 notEqual *tmp14 1
 
   517 label *label298
   518 label *label300
   519 set .units*9 :backgroundProcess:unit
-    * label *label17
   520 jump *label12 always
   521 label *label9
   522 wait 1e12
   523 jump *label8 always
-    * end
   524 label *label0
   525 # "Function: remote void start(in aCore, in drill)"
   526 set .core :start:aCore
 
   530 set .drills 1
   531 set :start*finished true
   532 jump *label8 always
-    * end
   533 label *label1
   534 # "Function: remote void addTitaniumDrill(in drill)"
   535 jump *label51 greaterThanEq .drills 9
 
   569 label *label51
   570 set :addTitaniumDrill*finished true
   571 jump *label8 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 6, iteration 1:
 
    30 jump *label60 notEqual *tmp14 1
    31 set :findFreeUnit:first_unit @unit
    32 label *label60
-    * label *label62
    33 ubind @flare
    34 jump *label58 notEqual :findFreeUnit:first_unit @unit
    35 set *tmp8 null
 
    80 jump *label85 notEqual *tmp14 1
    81 set :findFreeUnit:first_unit @unit
    82 label *label85
-    * label *label87
    83 ubind @flare
    84 jump *label83 notEqual :findFreeUnit:first_unit @unit
    85 set *tmp8 null
 
   130 jump *label110 notEqual *tmp14 1
   131 set :findFreeUnit:first_unit @unit
   132 label *label110
-    * label *label112
   133 ubind @flare
   134 jump *label108 notEqual :findFreeUnit:first_unit @unit
   135 set *tmp8 null
 
   180 jump *label135 notEqual *tmp14 1
   181 set :findFreeUnit:first_unit @unit
   182 label *label135
-    * label *label137
   183 ubind @flare
   184 jump *label133 notEqual :findFreeUnit:first_unit @unit
   185 set *tmp8 null
 
   230 jump *label160 notEqual *tmp14 1
   231 set :findFreeUnit:first_unit @unit
   232 label *label160
-    * label *label162
   233 ubind @flare
   234 jump *label158 notEqual :findFreeUnit:first_unit @unit
   235 set *tmp8 null
 
   280 jump *label185 notEqual *tmp14 1
   281 set :findFreeUnit:first_unit @unit
   282 label *label185
-    * label *label187
   283 ubind @flare
   284 jump *label183 notEqual :findFreeUnit:first_unit @unit
   285 set *tmp8 null
 
   330 jump *label210 notEqual *tmp14 1
   331 set :findFreeUnit:first_unit @unit
   332 label *label210
-    * label *label212
   333 ubind @flare
   334 jump *label208 notEqual :findFreeUnit:first_unit @unit
   335 set *tmp8 null
 
   380 jump *label235 notEqual *tmp14 1
   381 set :findFreeUnit:first_unit @unit
   382 label *label235
-    * label *label237
   383 ubind @flare
   384 jump *label233 notEqual :findFreeUnit:first_unit @unit
   385 set *tmp8 null
 
   430 jump *label260 notEqual *tmp14 1
   431 set :findFreeUnit:first_unit @unit
   432 label *label260
-    * label *label262
   433 ubind @flare
   434 jump *label258 notEqual :findFreeUnit:first_unit @unit
   435 set *tmp8 null
 
   480 jump *label285 notEqual *tmp14 1
   481 set :findFreeUnit:first_unit @unit
   482 label *label285
-    * label *label287
   483 ubind @flare
   484 jump *label283 notEqual :findFreeUnit:first_unit @unit
   485 set *tmp8 null

Final code before resolving virtual instructions:

    0:  jump *label7 always 0 0                                      #set target = 8;
    1:  jump *label1 always 0 0                                      ...
    2:  jump *label0 always 0 0                                      ...
    3:  draw triangle .core .coreX .coreY .drills .titaniumDrills*0 .titaniumDrills*1
    4:  draw triangle .titaniumDrills*2 .titaniumDrills*3 .titaniumDrills*4 .titaniumDrills*5 .titaniumDrills*6 .titaniumDrills*7
    5:  draw triangle .titaniumDrills*8 .titaniumDrills*9 .units*0 .units*1 .units*2 .units*3
    6:  draw triangle .units*4 .units*5 .units*6 .units*7 .units*8 .units*9
    7:  draw triangle :addTitaniumDrill:drill :backgroundProcess:drill :backgroundProcess:unit :findFreeUnit:first_unit :serviceDrill:item :start:aCore
    8:  draw triangle :start:drill 0 0 0 0 0
        label *label7                                                ...
    9:  set .drills 0                                                volatile var drills = 0;
   10:  set *signature "ea15a0387a220137:v1"                         #set target = 8;
        label *label8                                                ...
        # "Function: void backgroundProcess()"                       ...
   11:  jump *label9 equal .core null                                if core == null then return; end;
        label *label12                                               while true do
   12:  set :backgroundProcess:drill .titaniumDrills*0               for var drill in titaniumDrills; var out unit in units do
   13:  set :backgroundProcess:unit .units*0                         ...
   14:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
   15:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
   16:  jump *label68 equal *tmp5 @this                              ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
   17:  ubind @flare                                                 *units: ubind(unit_type);
   18:  jump *label56 notEqual @unit null                            *units: if @unit == null then return null; end;
   19:  set *tmp8 null                                               ...
   20:  jump *label65 always 0 0                                     ...
        label *label56                                               ...
   21:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label58                                               *units: do
   22:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
   23:  jump *label59 notEqual *tmp11 0                              ...
   24:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   25:  set *tmp8 @unit                                              *units: return @unit;
   26:  jump *label65 always 0 0                                     ...
        label *label59                                               *units: if @unit.@controlled == 0 then
   27:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   28:  jump *label60 notEqual *tmp14 1                              ...
   29:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label60                                               *units: elsif first_unit.@dead == 1 then
   30:  ubind @flare                                                 *units: ubind(unit_type);
   31:  jump *label58 notEqual :findFreeUnit:first_unit @unit        *units: do
   32:  set *tmp8 null                                               *units: return null;
        label *label65                                               unit = findFreeUnit(@flare, 0);
   33:  set :backgroundProcess:unit *tmp8                            ...
   34:  jump *label75 equal *tmp8 null                               if unit == null then continue; end;
        label *label68                                               if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
   35:  ubind :backgroundProcess:unit                                ubind(unit);
   36:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
   37:  jump *label70 notEqual :serviceDrill:item @titanium          if item == @titanium then
   38:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
   39:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
   40:  jump *label73 always 0 0                                     if item == @titanium then
        label *label70                                               ...
   41:  jump *label71 notEqual :serviceDrill:item null               elsif item == null then
   42:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
   43:  sensor *tmp27 :backgroundProcess:drill @y                    ...
   44:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
   45:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
   46:  jump *label72 always 0 0                                     elsif item == null then
        label *label71                                               ...
   47:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label72                                               elsif item == null then
        label *label73                                               if item == @titanium then
        label *label75                                               for var drill in titaniumDrills; var out unit in units do
   48:  set .units*0 :backgroundProcess:unit                         ...
   49:  set :backgroundProcess:drill .titaniumDrills*1               ...
   50:  set :backgroundProcess:unit .units*1                         ...
   51:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
   52:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
   53:  jump *label93 equal *tmp5 @this                              ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
   54:  ubind @flare                                                 *units: ubind(unit_type);
   55:  jump *label81 notEqual @unit null                            *units: if @unit == null then return null; end;
   56:  set *tmp8 null                                               ...
   57:  jump *label90 always 0 0                                     ...
        label *label81                                               ...
   58:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label83                                               *units: do
   59:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
   60:  jump *label84 notEqual *tmp11 0                              ...
   61:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   62:  set *tmp8 @unit                                              *units: return @unit;
   63:  jump *label90 always 0 0                                     ...
        label *label84                                               *units: if @unit.@controlled == 0 then
   64:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
   65:  jump *label85 notEqual *tmp14 1                              ...
   66:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label85                                               *units: elsif first_unit.@dead == 1 then
   67:  ubind @flare                                                 *units: ubind(unit_type);
   68:  jump *label83 notEqual :findFreeUnit:first_unit @unit        *units: do
   69:  set *tmp8 null                                               *units: return null;
        label *label90                                               unit = findFreeUnit(@flare, 0);
   70:  set :backgroundProcess:unit *tmp8                            ...
   71:  jump *label100 equal *tmp8 null                              if unit == null then continue; end;
        label *label93                                               if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
   72:  ubind :backgroundProcess:unit                                ubind(unit);
   73:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
   74:  jump *label95 notEqual :serviceDrill:item @titanium          if item == @titanium then
   75:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
   76:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
   77:  jump *label98 always 0 0                                     if item == @titanium then
        label *label95                                               ...
   78:  jump *label96 notEqual :serviceDrill:item null               elsif item == null then
   79:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
   80:  sensor *tmp27 :backgroundProcess:drill @y                    ...
   81:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
   82:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
   83:  jump *label97 always 0 0                                     elsif item == null then
        label *label96                                               ...
   84:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label97                                               elsif item == null then
        label *label98                                               if item == @titanium then
        label *label100                                              for var drill in titaniumDrills; var out unit in units do
   85:  set .units*1 :backgroundProcess:unit                         ...
   86:  set :backgroundProcess:drill .titaniumDrills*2               ...
   87:  set :backgroundProcess:unit .units*2                         ...
   88:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
   89:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
   90:  jump *label118 equal *tmp5 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
   91:  ubind @flare                                                 *units: ubind(unit_type);
   92:  jump *label106 notEqual @unit null                           *units: if @unit == null then return null; end;
   93:  set *tmp8 null                                               ...
   94:  jump *label115 always 0 0                                    ...
        label *label106                                              ...
   95:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label108                                              *units: do
   96:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
   97:  jump *label109 notEqual *tmp11 0                             ...
   98:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
   99:  set *tmp8 @unit                                              *units: return @unit;
  100:  jump *label115 always 0 0                                    ...
        label *label109                                              *units: if @unit.@controlled == 0 then
  101:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  102:  jump *label110 notEqual *tmp14 1                             ...
  103:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label110                                              *units: elsif first_unit.@dead == 1 then
  104:  ubind @flare                                                 *units: ubind(unit_type);
  105:  jump *label108 notEqual :findFreeUnit:first_unit @unit       *units: do
  106:  set *tmp8 null                                               *units: return null;
        label *label115                                              unit = findFreeUnit(@flare, 0);
  107:  set :backgroundProcess:unit *tmp8                            ...
  108:  jump *label125 equal *tmp8 null                              if unit == null then continue; end;
        label *label118                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  109:  ubind :backgroundProcess:unit                                ubind(unit);
  110:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  111:  jump *label120 notEqual :serviceDrill:item @titanium         if item == @titanium then
  112:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  113:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  114:  jump *label123 always 0 0                                    if item == @titanium then
        label *label120                                              ...
  115:  jump *label121 notEqual :serviceDrill:item null              elsif item == null then
  116:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  117:  sensor *tmp27 :backgroundProcess:drill @y                    ...
  118:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
  119:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  120:  jump *label122 always 0 0                                    elsif item == null then
        label *label121                                              ...
  121:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label122                                              elsif item == null then
        label *label123                                              if item == @titanium then
        label *label125                                              for var drill in titaniumDrills; var out unit in units do
  122:  set .units*2 :backgroundProcess:unit                         ...
  123:  set :backgroundProcess:drill .titaniumDrills*3               ...
  124:  set :backgroundProcess:unit .units*3                         ...
  125:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
  126:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
  127:  jump *label143 equal *tmp5 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  128:  ubind @flare                                                 *units: ubind(unit_type);
  129:  jump *label131 notEqual @unit null                           *units: if @unit == null then return null; end;
  130:  set *tmp8 null                                               ...
  131:  jump *label140 always 0 0                                    ...
        label *label131                                              ...
  132:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label133                                              *units: do
  133:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
  134:  jump *label134 notEqual *tmp11 0                             ...
  135:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  136:  set *tmp8 @unit                                              *units: return @unit;
  137:  jump *label140 always 0 0                                    ...
        label *label134                                              *units: if @unit.@controlled == 0 then
  138:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  139:  jump *label135 notEqual *tmp14 1                             ...
  140:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label135                                              *units: elsif first_unit.@dead == 1 then
  141:  ubind @flare                                                 *units: ubind(unit_type);
  142:  jump *label133 notEqual :findFreeUnit:first_unit @unit       *units: do
  143:  set *tmp8 null                                               *units: return null;
        label *label140                                              unit = findFreeUnit(@flare, 0);
  144:  set :backgroundProcess:unit *tmp8                            ...
  145:  jump *label150 equal *tmp8 null                              if unit == null then continue; end;
        label *label143                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  146:  ubind :backgroundProcess:unit                                ubind(unit);
  147:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  148:  jump *label145 notEqual :serviceDrill:item @titanium         if item == @titanium then
  149:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  150:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  151:  jump *label148 always 0 0                                    if item == @titanium then
        label *label145                                              ...
  152:  jump *label146 notEqual :serviceDrill:item null              elsif item == null then
  153:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  154:  sensor *tmp27 :backgroundProcess:drill @y                    ...
  155:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
  156:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  157:  jump *label147 always 0 0                                    elsif item == null then
        label *label146                                              ...
  158:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label147                                              elsif item == null then
        label *label148                                              if item == @titanium then
        label *label150                                              for var drill in titaniumDrills; var out unit in units do
  159:  set .units*3 :backgroundProcess:unit                         ...
  160:  set :backgroundProcess:drill .titaniumDrills*4               ...
  161:  set :backgroundProcess:unit .units*4                         ...
  162:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
  163:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
  164:  jump *label168 equal *tmp5 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  165:  ubind @flare                                                 *units: ubind(unit_type);
  166:  jump *label156 notEqual @unit null                           *units: if @unit == null then return null; end;
  167:  set *tmp8 null                                               ...
  168:  jump *label165 always 0 0                                    ...
        label *label156                                              ...
  169:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label158                                              *units: do
  170:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
  171:  jump *label159 notEqual *tmp11 0                             ...
  172:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  173:  set *tmp8 @unit                                              *units: return @unit;
  174:  jump *label165 always 0 0                                    ...
        label *label159                                              *units: if @unit.@controlled == 0 then
  175:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  176:  jump *label160 notEqual *tmp14 1                             ...
  177:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label160                                              *units: elsif first_unit.@dead == 1 then
  178:  ubind @flare                                                 *units: ubind(unit_type);
  179:  jump *label158 notEqual :findFreeUnit:first_unit @unit       *units: do
  180:  set *tmp8 null                                               *units: return null;
        label *label165                                              unit = findFreeUnit(@flare, 0);
  181:  set :backgroundProcess:unit *tmp8                            ...
  182:  jump *label175 equal *tmp8 null                              if unit == null then continue; end;
        label *label168                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  183:  ubind :backgroundProcess:unit                                ubind(unit);
  184:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  185:  jump *label170 notEqual :serviceDrill:item @titanium         if item == @titanium then
  186:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  187:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  188:  jump *label173 always 0 0                                    if item == @titanium then
        label *label170                                              ...
  189:  jump *label171 notEqual :serviceDrill:item null              elsif item == null then
  190:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  191:  sensor *tmp27 :backgroundProcess:drill @y                    ...
  192:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
  193:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  194:  jump *label172 always 0 0                                    elsif item == null then
        label *label171                                              ...
  195:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label172                                              elsif item == null then
        label *label173                                              if item == @titanium then
        label *label175                                              for var drill in titaniumDrills; var out unit in units do
  196:  set .units*4 :backgroundProcess:unit                         ...
  197:  set :backgroundProcess:drill .titaniumDrills*5               ...
  198:  set :backgroundProcess:unit .units*5                         ...
  199:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
  200:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
  201:  jump *label193 equal *tmp5 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  202:  ubind @flare                                                 *units: ubind(unit_type);
  203:  jump *label181 notEqual @unit null                           *units: if @unit == null then return null; end;
  204:  set *tmp8 null                                               ...
  205:  jump *label190 always 0 0                                    ...
        label *label181                                              ...
  206:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label183                                              *units: do
  207:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
  208:  jump *label184 notEqual *tmp11 0                             ...
  209:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  210:  set *tmp8 @unit                                              *units: return @unit;
  211:  jump *label190 always 0 0                                    ...
        label *label184                                              *units: if @unit.@controlled == 0 then
  212:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  213:  jump *label185 notEqual *tmp14 1                             ...
  214:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label185                                              *units: elsif first_unit.@dead == 1 then
  215:  ubind @flare                                                 *units: ubind(unit_type);
  216:  jump *label183 notEqual :findFreeUnit:first_unit @unit       *units: do
  217:  set *tmp8 null                                               *units: return null;
        label *label190                                              unit = findFreeUnit(@flare, 0);
  218:  set :backgroundProcess:unit *tmp8                            ...
  219:  jump *label200 equal *tmp8 null                              if unit == null then continue; end;
        label *label193                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  220:  ubind :backgroundProcess:unit                                ubind(unit);
  221:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  222:  jump *label195 notEqual :serviceDrill:item @titanium         if item == @titanium then
  223:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  224:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  225:  jump *label198 always 0 0                                    if item == @titanium then
        label *label195                                              ...
  226:  jump *label196 notEqual :serviceDrill:item null              elsif item == null then
  227:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  228:  sensor *tmp27 :backgroundProcess:drill @y                    ...
  229:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
  230:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  231:  jump *label197 always 0 0                                    elsif item == null then
        label *label196                                              ...
  232:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label197                                              elsif item == null then
        label *label198                                              if item == @titanium then
        label *label200                                              for var drill in titaniumDrills; var out unit in units do
  233:  set .units*5 :backgroundProcess:unit                         ...
  234:  set :backgroundProcess:drill .titaniumDrills*6               ...
  235:  set :backgroundProcess:unit .units*6                         ...
  236:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
  237:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
  238:  jump *label218 equal *tmp5 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  239:  ubind @flare                                                 *units: ubind(unit_type);
  240:  jump *label206 notEqual @unit null                           *units: if @unit == null then return null; end;
  241:  set *tmp8 null                                               ...
  242:  jump *label215 always 0 0                                    ...
        label *label206                                              ...
  243:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label208                                              *units: do
  244:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
  245:  jump *label209 notEqual *tmp11 0                             ...
  246:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  247:  set *tmp8 @unit                                              *units: return @unit;
  248:  jump *label215 always 0 0                                    ...
        label *label209                                              *units: if @unit.@controlled == 0 then
  249:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  250:  jump *label210 notEqual *tmp14 1                             ...
  251:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label210                                              *units: elsif first_unit.@dead == 1 then
  252:  ubind @flare                                                 *units: ubind(unit_type);
  253:  jump *label208 notEqual :findFreeUnit:first_unit @unit       *units: do
  254:  set *tmp8 null                                               *units: return null;
        label *label215                                              unit = findFreeUnit(@flare, 0);
  255:  set :backgroundProcess:unit *tmp8                            ...
  256:  jump *label225 equal *tmp8 null                              if unit == null then continue; end;
        label *label218                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  257:  ubind :backgroundProcess:unit                                ubind(unit);
  258:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  259:  jump *label220 notEqual :serviceDrill:item @titanium         if item == @titanium then
  260:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  261:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  262:  jump *label223 always 0 0                                    if item == @titanium then
        label *label220                                              ...
  263:  jump *label221 notEqual :serviceDrill:item null              elsif item == null then
  264:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  265:  sensor *tmp27 :backgroundProcess:drill @y                    ...
  266:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
  267:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  268:  jump *label222 always 0 0                                    elsif item == null then
        label *label221                                              ...
  269:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label222                                              elsif item == null then
        label *label223                                              if item == @titanium then
        label *label225                                              for var drill in titaniumDrills; var out unit in units do
  270:  set .units*6 :backgroundProcess:unit                         ...
  271:  set :backgroundProcess:drill .titaniumDrills*7               ...
  272:  set :backgroundProcess:unit .units*7                         ...
  273:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
  274:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
  275:  jump *label243 equal *tmp5 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  276:  ubind @flare                                                 *units: ubind(unit_type);
  277:  jump *label231 notEqual @unit null                           *units: if @unit == null then return null; end;
  278:  set *tmp8 null                                               ...
  279:  jump *label240 always 0 0                                    ...
        label *label231                                              ...
  280:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label233                                              *units: do
  281:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
  282:  jump *label234 notEqual *tmp11 0                             ...
  283:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  284:  set *tmp8 @unit                                              *units: return @unit;
  285:  jump *label240 always 0 0                                    ...
        label *label234                                              *units: if @unit.@controlled == 0 then
  286:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  287:  jump *label235 notEqual *tmp14 1                             ...
  288:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label235                                              *units: elsif first_unit.@dead == 1 then
  289:  ubind @flare                                                 *units: ubind(unit_type);
  290:  jump *label233 notEqual :findFreeUnit:first_unit @unit       *units: do
  291:  set *tmp8 null                                               *units: return null;
        label *label240                                              unit = findFreeUnit(@flare, 0);
  292:  set :backgroundProcess:unit *tmp8                            ...
  293:  jump *label250 equal *tmp8 null                              if unit == null then continue; end;
        label *label243                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  294:  ubind :backgroundProcess:unit                                ubind(unit);
  295:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  296:  jump *label245 notEqual :serviceDrill:item @titanium         if item == @titanium then
  297:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  298:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  299:  jump *label248 always 0 0                                    if item == @titanium then
        label *label245                                              ...
  300:  jump *label246 notEqual :serviceDrill:item null              elsif item == null then
  301:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  302:  sensor *tmp27 :backgroundProcess:drill @y                    ...
  303:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
  304:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  305:  jump *label247 always 0 0                                    elsif item == null then
        label *label246                                              ...
  306:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label247                                              elsif item == null then
        label *label248                                              if item == @titanium then
        label *label250                                              for var drill in titaniumDrills; var out unit in units do
  307:  set .units*7 :backgroundProcess:unit                         ...
  308:  set :backgroundProcess:drill .titaniumDrills*8               ...
  309:  set :backgroundProcess:unit .units*8                         ...
  310:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
  311:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
  312:  jump *label268 equal *tmp5 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  313:  ubind @flare                                                 *units: ubind(unit_type);
  314:  jump *label256 notEqual @unit null                           *units: if @unit == null then return null; end;
  315:  set *tmp8 null                                               ...
  316:  jump *label265 always 0 0                                    ...
        label *label256                                              ...
  317:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label258                                              *units: do
  318:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
  319:  jump *label259 notEqual *tmp11 0                             ...
  320:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  321:  set *tmp8 @unit                                              *units: return @unit;
  322:  jump *label265 always 0 0                                    ...
        label *label259                                              *units: if @unit.@controlled == 0 then
  323:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  324:  jump *label260 notEqual *tmp14 1                             ...
  325:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label260                                              *units: elsif first_unit.@dead == 1 then
  326:  ubind @flare                                                 *units: ubind(unit_type);
  327:  jump *label258 notEqual :findFreeUnit:first_unit @unit       *units: do
  328:  set *tmp8 null                                               *units: return null;
        label *label265                                              unit = findFreeUnit(@flare, 0);
  329:  set :backgroundProcess:unit *tmp8                            ...
  330:  jump *label275 equal *tmp8 null                              if unit == null then continue; end;
        label *label268                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  331:  ubind :backgroundProcess:unit                                ubind(unit);
  332:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  333:  jump *label270 notEqual :serviceDrill:item @titanium         if item == @titanium then
  334:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  335:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  336:  jump *label273 always 0 0                                    if item == @titanium then
        label *label270                                              ...
  337:  jump *label271 notEqual :serviceDrill:item null              elsif item == null then
  338:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  339:  sensor *tmp27 :backgroundProcess:drill @y                    ...
  340:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
  341:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  342:  jump *label272 always 0 0                                    elsif item == null then
        label *label271                                              ...
  343:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label272                                              elsif item == null then
        label *label273                                              if item == @titanium then
        label *label275                                              for var drill in titaniumDrills; var out unit in units do
  344:  set .units*8 :backgroundProcess:unit                         ...
  345:  set :backgroundProcess:drill .titaniumDrills*9               ...
  346:  set :backgroundProcess:unit .units*9                         ...
  347:  jump *label12 equal :backgroundProcess:drill null            if drill == null then break; end;
  348:  sensor *tmp5 :backgroundProcess:unit @controller             if unit.@controller != @this then
  349:  jump *label293 equal *tmp5 @this                             ...
        # "Function: def findFreeUnit(in unit_type, in initial_flag) unit = findFreeUnit(@flare, 0);
  350:  ubind @flare                                                 *units: ubind(unit_type);
  351:  jump *label281 notEqual @unit null                           *units: if @unit == null then return null; end;
  352:  set *tmp8 null                                               ...
  353:  jump *label290 always 0 0                                    ...
        label *label281                                              ...
  354:  set :findFreeUnit:first_unit @unit                           *units: var first_unit = @unit;
        label *label283                                              *units: do
  355:  sensor *tmp11 @unit @controlled                              *units: if @unit.@controlled == 0 then
  356:  jump *label284 notEqual *tmp11 0                             ...
  357:  ucontrol flag 0 0 0 0 0                                      *units: flag(initial_flag);        // Mark unit as active
  358:  set *tmp8 @unit                                              *units: return @unit;
  359:  jump *label290 always 0 0                                    ...
        label *label284                                              *units: if @unit.@controlled == 0 then
  360:  sensor *tmp14 :findFreeUnit:first_unit @dead                 *units: elsif first_unit.@dead == 1 then
  361:  jump *label285 notEqual *tmp14 1                             ...
  362:  set :findFreeUnit:first_unit @unit                           *units: first_unit = @unit;
        label *label285                                              *units: elsif first_unit.@dead == 1 then
  363:  ubind @flare                                                 *units: ubind(unit_type);
  364:  jump *label283 notEqual :findFreeUnit:first_unit @unit       *units: do
  365:  set *tmp8 null                                               *units: return null;
        label *label290                                              unit = findFreeUnit(@flare, 0);
  366:  set :backgroundProcess:unit *tmp8                            ...
  367:  jump *label300 equal *tmp8 null                              if unit == null then continue; end;
        label *label293                                              if unit.@controller != @this then
        # "Function: void serviceDrill(in drill, in unit)"           serviceDrill(drill, unit);
  368:  ubind :backgroundProcess:unit                                ubind(unit);
  369:  sensor :serviceDrill:item @unit @firstItem                   var item = @unit.@firstItem;
  370:  jump *label295 notEqual :serviceDrill:item @titanium         if item == @titanium then
  371:  ucontrol approach .coreX .coreY 4 0 0                        approach(coreX, coreY, RADIUS);
  372:  ucontrol itemDrop .core 10 0 0 0                             itemDrop(core, CAPACITY);
  373:  jump *label298 always 0 0                                    if item == @titanium then
        label *label295                                              ...
  374:  jump *label296 notEqual :serviceDrill:item null              elsif item == null then
  375:  sensor *tmp26 :backgroundProcess:drill @x                    approach(drill.@x, drill.@y, RADIUS);
  376:  sensor *tmp27 :backgroundProcess:drill @y                    ...
  377:  ucontrol approach *tmp26 *tmp27 4 0 0                        ...
  378:  ucontrol itemTake :backgroundProcess:drill @titanium 10 0 0  itemTake(drill, @titanium, CAPACITY);
  379:  jump *label297 always 0 0                                    elsif item == null then
        label *label296                                              ...
  380:  ucontrol itemDrop @air 10 0 0 0                              itemDrop(@air, CAPACITY);
        label *label297                                              elsif item == null then
        label *label298                                              if item == @titanium then
        label *label300                                              for var drill in titaniumDrills; var out unit in units do
  381:  set .units*9 :backgroundProcess:unit                         ...
  382:  jump *label12 always 0 0                                     while true do
        label *label9                                                #set target = 8;
  383:  wait 1e12                                                    ...
  384:  jump *label8 always 0 0                                      ...
        label *label0                                                remote void start(aCore, drill)
        # "Function: remote void start(in aCore, in drill)"          ...
  385:  set .core :start:aCore                                       core = aCore;
  386:  sensor .coreX .core @x                                       coreX = core.@x;
  387:  sensor .coreY .core @y                                       coreY = core.@y;
  388:  set .titaniumDrills*0 :start:drill                           titaniumDrills[0] = drill;
  389:  set .drills 1                                                drills = 1;
  390:  set :start*finished true                                     remote void start(aCore, drill)
  391:  jump *label8 always 0 0                                      ...
        label *label1                                                remote void addTitaniumDrill(drill)
        # "Function: remote void addTitaniumDrill(in drill)"         ...
  392:  jump *label51 greaterThanEq .drills 9                        if drills < length(titaniumDrills) - 1 then
  393:  op mul *tmp35 .drills 2                                      titaniumDrills[drills] = drill;
  394:  multijump *label305 *tmp35 0                                 ...
        multilabel *label305                                         ...
  395:  set .titaniumDrills*0 :addTitaniumDrill:drill                ...
  396:  jump *label304 always 0 0                                    ...
        multilabel *label306                                         ...
  397:  set .titaniumDrills*1 :addTitaniumDrill:drill                ...
  398:  jump *label304 always 0 0                                    ...
        multilabel *label307                                         ...
  399:  set .titaniumDrills*2 :addTitaniumDrill:drill                ...
  400:  jump *label304 always 0 0                                    ...
        multilabel *label308                                         ...
  401:  set .titaniumDrills*3 :addTitaniumDrill:drill                ...
  402:  jump *label304 always 0 0                                    ...
        multilabel *label309                                         ...
  403:  set .titaniumDrills*4 :addTitaniumDrill:drill                ...
  404:  jump *label304 always 0 0                                    ...
        multilabel *label310                                         ...
  405:  set .titaniumDrills*5 :addTitaniumDrill:drill                ...
  406:  jump *label304 always 0 0                                    ...
        multilabel *label311                                         ...
  407:  set .titaniumDrills*6 :addTitaniumDrill:drill                ...
  408:  jump *label304 always 0 0                                    ...
        multilabel *label312                                         ...
  409:  set .titaniumDrills*7 :addTitaniumDrill:drill                ...
  410:  jump *label304 always 0 0                                    ...
        multilabel *label313                                         ...
  411:  set .titaniumDrills*8 :addTitaniumDrill:drill                ...
  412:  jump *label304 always 0 0                                    ...
        multilabel *label314                                         ...
  413:  set .titaniumDrills*9 :addTitaniumDrill:drill                ...
        label *label304                                              ...
  414:  op add .drills .drills 1                                     if drills < length(titaniumDrills) - 1 then
        label *label51                                               ...
  415:  set :addTitaniumDrill*finished true                          remote void addTitaniumDrill(drill)
  416:  jump *label8 always 0 0                                      ...


Performance: parsed in 219 ms, compiled in 312 ms, optimized in 429 ms, run in 18 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (5 steps):
The program didn't generate any output.
Execution exception at instruction 383: wait 1e12:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
