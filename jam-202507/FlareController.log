   105 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (2 iterations).
    19 instructions eliminated by Dead Code Elimination (5 iterations).
C:\Home\golem\jam-202507\FlareController.mnd:22:21 Variable 'status2.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:22:27 Variable 'status2.item' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:22:33 Variable 'status2.block' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:25:21 Variable 'status3.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:25:21 Variable 'status3.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:25:21 Variable 'status3.text' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:29 Variable 'transportStatus.target' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:29 Variable 'transportStatus.target' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:37 Variable 'transportStatus.item' is not used.
C:\Home\golem\jam-202507\FlareController.mnd:28:37 Variable 'transportStatus.item' is not used.
C:\Home\golem\jam-202507\Actions.mnd:9:14 Variable 'ERROR' is not used.
     1 instructions eliminated by Jump Normalization (2 passes, 6 iterations).
     9 instructions eliminated by Jump Optimization (6 iterations).
     5 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
     1 instructions modified by Expression Optimization (4 iterations).
     1 instructions modified by If Expression Optimization (4 iterations).
    15 instructions eliminated by Data Flow Optimization (2 passes, 12 iterations).
     1 loops improved by Loop Hoisting.
     3 instructions added by Loop Optimization (4 iterations).
     3 loops improved by Loop Optimization.
     1 instructions eliminated by Jump Straightening (6 iterations).
     3 instructions updated by JumpThreading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    53 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 939):
  * Replicate loop condition at Actions.mnd:44:5                 size    +1, benefit      625.0, efficiency    625.000 (+1 instructions)
    Replicate loop condition at Actions.mnd:24:5                 size    +1, benefit      312.5, efficiency    312.500
    Replicate loop condition at Actions.mnd:68:9                 size    +1, benefit      312.5, efficiency    312.500

Pass 1: speed optimization selection (cost limit 938):
  * Replicate loop condition at Actions.mnd:24:5                 size    +1, benefit      312.5, efficiency    312.500 (+1 instructions)
    Replicate loop condition at Actions.mnd:68:9                 size    +1, benefit      312.5, efficiency    312.500

Pass 1: speed optimization selection (cost limit 937):
  * Replicate loop condition at Actions.mnd:68:9                 size    +1, benefit      312.5, efficiency    312.500 (+1 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-18 instructions):
 
    11 set :fetchBlock:block .drill
    12 set :fetchBlock:item @titanium
    13 sensor *tmp1 :fetchBlock:block @itemCapacity
-    * set :transportStatus:target *tmp1
-    * set :transportStatus:item :fetchBlock:item
    14 label *label13
-    * set :status2:text "Fetching "
-    * set :status2:item :fetchBlock:item
-    * set :status2:block :fetchBlock:block
    15 label *label14
    16 sensor *tmp2 :fetchBlock:block @x
    17 sensor *tmp3 :fetchBlock:block @y
    18 set :moveToEmpty:x *tmp2
    19 set :moveToEmpty:y *tmp3
-    * set :status3:text "Moving..."
    20 label *label16
    21 label *label17
    22 sensor *tmp4 @unit @firstItem
    23 op notEqual *tmp5 *tmp4 null
    24 jump *label20 equal *tmp5 false
    25 ucontrol itemDrop @air 1000
-    * set *tmp6 null
    26 jump *label21 always
    27 label *label20
-    * set *tmp6 null
    28 label *label21
    29 ucontrol approach :moveToEmpty:x :moveToEmpty:y 4.5
    30 label *label18
 
    50 op land *tmp14 *tmp12 *tmp13
    51 jump *label28 equal *tmp14 false
    52 ucontrol itemDrop @air 1000
-    * set *tmp15 null
    53 jump *label29 always
    54 label *label28
-    * set *tmp15 null
    55 label *label29
    56 label *label26
    57 sensor *tmp16 @unit :fetchBlock:item
 
    63 set :depositItems:block .core
    64 set :depositItems:item :fetchBlock:item
    65 set :depositItems:fromMining false
-    * set :status3.1:text "Depositing..."
    66 label *label31
    67 sensor *tmp20 @unit @firstItem
    68 op equal *tmp21 *tmp20 :depositItems:item
 
    82 set :moveTo.1:x *tmp26
    83 set :moveTo.1:y *tmp27
    84 set :moveTo.1:radius :moveToBlock:radius
-    * set :status3.2:text "Moving..."
    85 label *label38
    86 label *label39
    87 ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp28
 
   102 op greaterThanEq *tmp33 *tmp32 :depositItems:cap
   103 jump *label45 equal *tmp33 false
   104 jump *label44 always
-    * set *tmp34 null
   105 jump *label46 always
   106 label *label45
-    * set *tmp34 null
   107 label *label46
   108 label *label43
   109 sensor *tmp35 @unit @firstItem
   110 op notEqual *tmp36 *tmp35 null
   111 jump *label42 notEqual *tmp36 false
   112 label *label44
-    * set *tmp22 null
   113 jump *label33 always
   114 label *label32
   115 label *label47
 
   120 label *label48
   121 jump *label47 always
   122 label *label49
-    * set *tmp22 null
   123 label *label33
-    * set :transportStatus.1:target 0
-    * set :transportStatus.1:item null
   124 label *label50
   125 label *label30
   126 label *label12

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-1 instructions):
 
    10 jump *label11 equal true false
    11 set :fetchBlock:block .drill
    12 set :fetchBlock:item @titanium
-    * sensor *tmp1 :fetchBlock:block @itemCapacity
    13 label *label13
    14 label *label14
    15 sensor *tmp2 :fetchBlock:block @x

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
    42 label *label15
    43 label *label25
    44 ucontrol itemTake :fetchBlock:block :fetchBlock:item 10
-    * sensor *tmp11 @unit @firstItem
-    * set :fetchBlock:unitItem *tmp11
+   45 sensor :fetchBlock:unitItem @unit @firstItem
    46 op notEqual *tmp12 :fetchBlock:unitItem null
    47 op notEqual *tmp13 :fetchBlock:unitItem :fetchBlock:item
    48 op land *tmp14 *tmp12 *tmp13
 
    92 label *label41
    93 label *label37
    94 label *label36
-    * sensor *tmp31 :depositItems:block @itemCapacity
-    * set :depositItems:cap *tmp31
+   95 sensor :depositItems:cap :depositItems:block @itemCapacity
    96 label *label42
    97 ucontrol itemDrop :depositItems:block 10
    98 sensor *tmp32 :depositItems:block :depositItems:item

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
     7 jump *label6 notEqual *tmp0 false
     8 label *label8
     9 label *label9
-    * jump *label11 equal true false
    10 set :fetchBlock:block .drill
    11 set :fetchBlock:item @titanium
    12 label *label13

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-9 instructions):
 
     3 label *label6
     4 ubind @flare
     5 label *label7
-    * op equal *tmp0 @unit null
-    * jump *label6 notEqual *tmp0 false
+    6 jump *label6 equal @unit null
     7 label *label8
     8 label *label9
     9 set :fetchBlock:block .drill
 
    17 label *label16
    18 label *label17
    19 sensor *tmp4 @unit @firstItem
-    * op notEqual *tmp5 *tmp4 null
-    * jump *label20 equal *tmp5 false
+   20 jump *label20 equal *tmp4 null
    21 ucontrol itemDrop @air 1000
    22 jump *label21 always
    23 label *label20
 
    25 ucontrol approach :moveToEmpty:x :moveToEmpty:y 4.5
    26 label *label18
    27 ucontrol within :moveToEmpty:x :moveToEmpty:y 5 *tmp7
-    * op equal *tmp8 *tmp7 false
-    * jump *label17 notEqual *tmp8 false
+   28 jump *label17 equal *tmp7 false
    29 label *label19
    30 label *label22
    31 sensor *tmp9 @unit @firstItem
-    * op notEqual *tmp10 *tmp9 null
-    * jump *label24 equal *tmp10 false
+   32 jump *label24 equal *tmp9 null
    33 ucontrol itemDrop @air 1000
    34 label *label23
    35 jump *label22 always
 
    58 set :depositItems:fromMining false
    59 label *label31
    60 sensor *tmp20 @unit @firstItem
-    * op equal *tmp21 *tmp20 :depositItems:item
-    * jump *label32 equal *tmp21 false
+   61 jump *label32 notEqual *tmp20 :depositItems:item
    62 op equal *tmp23 :depositItems:block .core
    63 op land *tmp24 :depositItems:fromMining *tmp23
    64 jump *label34 equal *tmp24 false
 
    77 label *label38
    78 label *label39
    79 ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp28
-    * op equal *tmp29 *tmp28 false
-    * jump *label41 equal *tmp29 false
+   80 jump *label41 notEqual *tmp28 false
    81 op sub *tmp30 :moveTo.1:radius 0.5
    82 ucontrol approach :moveTo.1:x :moveTo.1:y *tmp30
    83 label *label40
 
    89 label *label42
    90 ucontrol itemDrop :depositItems:block 10
    91 sensor *tmp32 :depositItems:block :depositItems:item
-    * op greaterThanEq *tmp33 *tmp32 :depositItems:cap
-    * jump *label45 equal *tmp33 false
+   92 jump *label45 lessThan *tmp32 :depositItems:cap
    93 jump *label44 always
    94 jump *label46 always
    95 label *label45
    96 label *label46
    97 label *label43
    98 sensor *tmp35 @unit @firstItem
-    * op notEqual *tmp36 *tmp35 null
-    * jump *label42 notEqual *tmp36 false
+   99 jump *label42 notEqual *tmp35 null
   100 label *label44
   101 jump *label33 always
   102 label *label32
   103 label *label47
   104 sensor *tmp37 @unit @firstItem
-    * op notEqual *tmp38 *tmp37 null
-    * jump *label49 equal *tmp38 false
+  105 jump *label49 equal *tmp37 null
   106 ucontrol itemDrop @air 1000
   107 label *label48
   108 jump *label47 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-3 instructions):
 
    19 sensor *tmp4 @unit @firstItem
    20 jump *label20 equal *tmp4 null
    21 ucontrol itemDrop @air 1000
-    * jump *label21 always
    22 label *label20
    23 label *label21
    24 ucontrol approach :moveToEmpty:x :moveToEmpty:y 4.5
 
    42 op land *tmp14 *tmp12 *tmp13
    43 jump *label28 equal *tmp14 false
    44 ucontrol itemDrop @air 1000
-    * jump *label29 always
    45 label *label28
    46 label *label29
    47 label *label26
 
    89 sensor *tmp32 :depositItems:block :depositItems:item
    90 jump *label45 lessThan *tmp32 :depositItems:cap
    91 jump *label44 always
-    * jump *label46 always
    92 label *label45
    93 label *label46
    94 label *label43

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    21 ucontrol itemDrop @air 1000
    22 label *label20
    23 label *label21
-    * ucontrol approach :moveToEmpty:x :moveToEmpty:y 4.5
+   24 ucontrol approach *tmp2 *tmp3 4.5
    25 label *label18
-    * ucontrol within :moveToEmpty:x :moveToEmpty:y 5 *tmp7
+   26 ucontrol within *tmp2 *tmp3 5 *tmp7
    27 jump *label17 equal *tmp7 false
    28 label *label19
    29 label *label22
 
    35 label *label24
    36 label *label15
    37 label *label25
-    * ucontrol itemTake :fetchBlock:block :fetchBlock:item 10
+   38 ucontrol itemTake :fetchBlock:block @titanium 10
    39 sensor :fetchBlock:unitItem @unit @firstItem
    40 op notEqual *tmp12 :fetchBlock:unitItem null
-    * op notEqual *tmp13 :fetchBlock:unitItem :fetchBlock:item
+   41 op notEqual *tmp13 :fetchBlock:unitItem @titanium
    42 op land *tmp14 *tmp12 *tmp13
    43 jump *label28 equal *tmp14 false
    44 ucontrol itemDrop @air 1000
    45 label *label28
    46 label *label29
    47 label *label26
-    * sensor *tmp16 @unit :fetchBlock:item
+   48 sensor *tmp16 @unit @titanium
    49 op lessThan *tmp17 *tmp16 10
-    * sensor *tmp18 :fetchBlock:block :fetchBlock:item
+   50 sensor *tmp18 :fetchBlock:block @titanium
    51 op land *tmp19 *tmp17 *tmp18
    52 jump *label25 notEqual *tmp19 false
    53 label *label27
    54 set :depositItems:block .core
-    * set :depositItems:item :fetchBlock:item
+   55 set :depositItems:item @titanium
    56 set :depositItems:fromMining false
    57 label *label31
    58 sensor *tmp20 @unit @firstItem
-    * jump *label32 notEqual *tmp20 :depositItems:item
+   59 jump *label32 notEqual *tmp20 :fetchBlock:item
    60 op equal *tmp23 :depositItems:block .core
-    * op land *tmp24 :depositItems:fromMining *tmp23
+   61 op land *tmp24 false *tmp23
    62 jump *label34 equal *tmp24 false
    63 set *tmp25 7
    64 jump *label35 always
 
    67 label *label35
    68 set :moveToBlock:block :depositItems:block
    69 set :moveToBlock:radius *tmp25
-    * sensor *tmp26 :moveToBlock:block @x
-    * sensor *tmp27 :moveToBlock:block @y
+   70 sensor *tmp26 :depositItems:block @x
+   71 sensor *tmp27 :depositItems:block @y
    72 set :moveTo.1:x *tmp26
    73 set :moveTo.1:y *tmp27
-    * set :moveTo.1:radius :moveToBlock:radius
+   74 set :moveTo.1:radius *tmp25
    75 label *label38
    76 label *label39
-    * ucontrol within :moveTo.1:x :moveTo.1:y :moveTo.1:radius *tmp28
+   77 ucontrol within *tmp26 *tmp27 :moveToBlock:radius *tmp28
    78 jump *label41 notEqual *tmp28 false
-    * op sub *tmp30 :moveTo.1:radius 0.5
-    * ucontrol approach :moveTo.1:x :moveTo.1:y *tmp30
+   79 op sub *tmp30 :moveToBlock:radius 0.5
+   80 ucontrol approach *tmp26 *tmp27 *tmp30
    81 label *label40
    82 jump *label39 always
    83 label *label41
 
    86 sensor :depositItems:cap :depositItems:block @itemCapacity
    87 label *label42
    88 ucontrol itemDrop :depositItems:block 10
-    * sensor *tmp32 :depositItems:block :depositItems:item
+   89 sensor *tmp32 :depositItems:block :fetchBlock:item
    90 jump *label45 lessThan *tmp32 :depositItems:cap
    91 jump *label44 always
    92 label *label45

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-8 instructions):
 
    12 label *label14
    13 sensor *tmp2 :fetchBlock:block @x
    14 sensor *tmp3 :fetchBlock:block @y
-    * set :moveToEmpty:x *tmp2
-    * set :moveToEmpty:y *tmp3
    15 label *label16
    16 label *label17
    17 sensor *tmp4 @unit @firstItem
 
    50 jump *label25 notEqual *tmp19 false
    51 label *label27
    52 set :depositItems:block .core
-    * set :depositItems:item @titanium
-    * set :depositItems:fromMining false
    53 label *label31
    54 sensor *tmp20 @unit @firstItem
-    * jump *label32 notEqual *tmp20 :fetchBlock:item
+   55 jump *label32 notEqual *tmp20 @titanium
    56 op equal *tmp23 :depositItems:block .core
    57 op land *tmp24 false *tmp23
    58 jump *label34 equal *tmp24 false
 
    61 label *label34
    62 set *tmp25 5
    63 label *label35
-    * set :moveToBlock:block :depositItems:block
    64 set :moveToBlock:radius *tmp25
    65 sensor *tmp26 :depositItems:block @x
    66 sensor *tmp27 :depositItems:block @y
-    * set :moveTo.1:x *tmp26
-    * set :moveTo.1:y *tmp27
-    * set :moveTo.1:radius *tmp25
    67 label *label38
    68 label *label39
-    * ucontrol within *tmp26 *tmp27 :moveToBlock:radius *tmp28
+   69 ucontrol within *tmp26 *tmp27 *tmp25 *tmp28
    70 jump *label41 notEqual *tmp28 false
-    * op sub *tmp30 :moveToBlock:radius 0.5
+   71 op sub *tmp30 *tmp25 0.5
    72 ucontrol approach *tmp26 *tmp27 *tmp30
    73 label *label40
    74 jump *label39 always
 
    78 sensor :depositItems:cap :depositItems:block @itemCapacity
    79 label *label42
    80 ucontrol itemDrop :depositItems:block 10
-    * sensor *tmp32 :depositItems:block :fetchBlock:item
+   81 sensor *tmp32 :depositItems:block @titanium
    82 jump *label45 lessThan *tmp32 :depositItems:cap
    83 jump *label44 always
    84 label *label45

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-2 instructions):
 
     7 label *label8
     8 label *label9
     9 set :fetchBlock:block .drill
-    * set :fetchBlock:item @titanium
    10 label *label13
    11 label *label14
    12 sensor *tmp2 :fetchBlock:block @x
 
    60 label *label34
    61 set *tmp25 5
    62 label *label35
-    * set :moveToBlock:radius *tmp25
    63 sensor *tmp26 :depositItems:block @x
    64 sensor *tmp27 :depositItems:block @y
    65 label *label38

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    63 sensor *tmp26 :depositItems:block @x
    64 sensor *tmp27 :depositItems:block @y
    65 label *label38
+   66 op sub *tmp30 *tmp25 0.5
    67 label *label39
    68 ucontrol within *tmp26 *tmp27 *tmp25 *tmp28
    69 jump *label41 notEqual *tmp28 false
-    * op sub *tmp30 *tmp25 0.5
    70 ucontrol approach *tmp26 *tmp27 *tmp30
    71 label *label40
    72 jump *label39 always

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1:
 
    52 label *label31
    53 sensor *tmp20 @unit @firstItem
    54 jump *label32 notEqual *tmp20 @titanium
+   55 set *tmp25 5
    56 op equal *tmp23 :depositItems:block .core
    57 op land *tmp24 false *tmp23
-    * jump *label34 equal *tmp24 false
+   58 jump *label35 equal *tmp24 false
    59 set *tmp25 7
    60 jump *label35 always
-    * label *label34
-    * set *tmp25 5
    61 label *label35
    62 sensor *tmp26 :depositItems:block @x
    63 sensor *tmp27 :depositItems:block @y

Modifications by Replicate loop condition at Actions.mnd:44:5 (+1 instructions):
 
    26 label *label22
    27 sensor *tmp9 @unit @firstItem
    28 jump *label24 equal *tmp9 null
+   29 label *label110
    30 ucontrol itemDrop @air 1000
    31 label *label23
-    * jump *label22 always
+   32 sensor *tmp9 @unit @firstItem
+   33 jump *label110 notEqual *tmp9 null
    34 label *label24
    35 label *label15
    36 label *label25

Modifications by Replicate loop condition at Actions.mnd:24:5 (+1 instructions):
 
    68 label *label39
    69 ucontrol within *tmp26 *tmp27 *tmp25 *tmp28
    70 jump *label41 notEqual *tmp28 false
+   71 label *label111
    72 ucontrol approach *tmp26 *tmp27 *tmp30
    73 label *label40
-    * jump *label39 always
+   74 ucontrol within *tmp26 *tmp27 *tmp25 *tmp28
+   75 jump *label111 equal *tmp28 false
    76 label *label41
    77 label *label37
    78 label *label36

Modifications by Replicate loop condition at Actions.mnd:68:9 (+1 instructions):
 
    93 label *label47
    94 sensor *tmp37 @unit @firstItem
    95 jump *label49 equal *tmp37 null
+   96 label *label112
    97 ucontrol itemDrop @air 1000
    98 label *label48
-    * jump *label47 always
+   99 sensor *tmp37 @unit @firstItem
+  100 jump *label112 notEqual *tmp37 null
   101 label *label49
   102 label *label33
   103 label *label50

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    59 op land *tmp24 false *tmp23
    60 jump *label35 equal *tmp24 false
    61 set *tmp25 7
-    * jump *label35 always
    62 label *label35
    63 sensor *tmp26 :depositItems:block @x
    64 sensor *tmp27 :depositItems:block @y

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    56 jump *label32 notEqual *tmp20 @titanium
    57 set *tmp25 5
    58 op equal *tmp23 :depositItems:block .core
-    * op land *tmp24 false *tmp23
+   59 set *tmp24 false
    60 jump *label35 equal *tmp24 false
    61 set *tmp25 7
    62 label *label35

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
    55 sensor *tmp20 @unit @firstItem
    56 jump *label32 notEqual *tmp20 @titanium
    57 set *tmp25 5
-    * op equal *tmp23 :depositItems:block .core
    58 set *tmp24 false
-    * jump *label35 equal *tmp24 false
+   59 jump *label35 equal false false
    60 set *tmp25 7
    61 label *label35
    62 sensor *tmp26 :depositItems:block @x
    63 sensor *tmp27 :depositItems:block @y
    64 label *label38
-    * op sub *tmp30 *tmp25 0.5
+   65 op sub *tmp30 5 0.5
    66 label *label39
-    * ucontrol within *tmp26 *tmp27 *tmp25 *tmp28
+   67 ucontrol within *tmp26 *tmp27 5 *tmp28
    68 jump *label41 notEqual *tmp28 false
    69 label *label111
-    * ucontrol approach *tmp26 *tmp27 *tmp30
+   70 ucontrol approach *tmp26 *tmp27 4.5
    71 label *label40
-    * ucontrol within *tmp26 *tmp27 *tmp25 *tmp28
+   72 ucontrol within *tmp26 *tmp27 5 *tmp28
    73 jump *label111 equal *tmp28 false
    74 label *label41
    75 label *label37

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-4 instructions):
 
    54 label *label31
    55 sensor *tmp20 @unit @firstItem
    56 jump *label32 notEqual *tmp20 @titanium
-    * set *tmp25 5
-    * set *tmp24 false
    57 jump *label35 equal false false
-    * set *tmp25 7
    58 label *label35
    59 sensor *tmp26 :depositItems:block @x
    60 sensor *tmp27 :depositItems:block @y
    61 label *label38
-    * op sub *tmp30 5 0.5
    62 label *label39
    63 ucontrol within *tmp26 *tmp27 5 *tmp28
    64 jump *label41 notEqual *tmp28 false

Modifications by Iterated phase, Jump Normalization, pass 3, iteration 1:
 
    54 label *label31
    55 sensor *tmp20 @unit @firstItem
    56 jump *label32 notEqual *tmp20 @titanium
-    * jump *label35 equal false false
+   57 jump *label35 always
    58 label *label35
    59 sensor *tmp26 :depositItems:block @x
    60 sensor *tmp27 :depositItems:block @y

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
    54 label *label31
    55 sensor *tmp20 @unit @firstItem
    56 jump *label32 notEqual *tmp20 @titanium
-    * jump *label35 always
    57 label *label35
    58 sensor *tmp26 :depositItems:block @x
    59 sensor *tmp27 :depositItems:block @y

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
     2 label *label4
     3 label *label6
     4 ubind @flare
-    * label *label7
     5 jump *label6 equal @unit null
-    * label *label8
     6 label *label9
     7 set :fetchBlock:block .drill
-    * label *label13
-    * label *label14
     8 sensor *tmp2 :fetchBlock:block @x
     9 sensor *tmp3 :fetchBlock:block @y
-    * label *label16
    10 label *label17
    11 sensor *tmp4 @unit @firstItem
    12 jump *label20 equal *tmp4 null
    13 ucontrol itemDrop @air 1000
    14 label *label20
-    * label *label21
    15 ucontrol approach *tmp2 *tmp3 4.5
-    * label *label18
    16 ucontrol within *tmp2 *tmp3 5 *tmp7
    17 jump *label17 equal *tmp7 false
-    * label *label19
-    * label *label22
    18 sensor *tmp9 @unit @firstItem
    19 jump *label24 equal *tmp9 null
    20 label *label110
    21 ucontrol itemDrop @air 1000
-    * label *label23
    22 sensor *tmp9 @unit @firstItem
    23 jump *label110 notEqual *tmp9 null
    24 label *label24
-    * label *label15
    25 label *label25
    26 ucontrol itemTake :fetchBlock:block @titanium 10
    27 sensor :fetchBlock:unitItem @unit @firstItem
 
    31 jump *label28 equal *tmp14 false
    32 ucontrol itemDrop @air 1000
    33 label *label28
-    * label *label29
-    * label *label26
    34 sensor *tmp16 @unit @titanium
    35 op lessThan *tmp17 *tmp16 10
    36 sensor *tmp18 :fetchBlock:block @titanium
    37 op land *tmp19 *tmp17 *tmp18
    38 jump *label25 notEqual *tmp19 false
-    * label *label27
    39 set :depositItems:block .core
-    * label *label31
    40 sensor *tmp20 @unit @firstItem
    41 jump *label32 notEqual *tmp20 @titanium
-    * label *label35
    42 sensor *tmp26 :depositItems:block @x
    43 sensor *tmp27 :depositItems:block @y
-    * label *label38
-    * label *label39
    44 ucontrol within *tmp26 *tmp27 5 *tmp28
    45 jump *label41 notEqual *tmp28 false
    46 label *label111
    47 ucontrol approach *tmp26 *tmp27 4.5
-    * label *label40
    48 ucontrol within *tmp26 *tmp27 5 *tmp28
    49 jump *label111 equal *tmp28 false
    50 label *label41
-    * label *label37
-    * label *label36
    51 sensor :depositItems:cap :depositItems:block @itemCapacity
    52 label *label42
    53 ucontrol itemDrop :depositItems:block 10
 
    55 jump *label45 lessThan *tmp32 :depositItems:cap
    56 jump *label44 always
    57 label *label45
-    * label *label46
-    * label *label43
    58 sensor *tmp35 @unit @firstItem
    59 jump *label42 notEqual *tmp35 null
    60 label *label44
    61 jump *label33 always
    62 label *label32
-    * label *label47
    63 sensor *tmp37 @unit @firstItem
    64 jump *label49 equal *tmp37 null
    65 label *label112
    66 ucontrol itemDrop @air 1000
-    * label *label48
    67 sensor *tmp37 @unit @firstItem
    68 jump *label112 notEqual *tmp37 null
    69 label *label49
    70 label *label33
-    * label *label50
-    * label *label30
-    * label *label12
-    * label *label10
    71 jump *label9 always
-    * label *label11
-    * label *label5
    72 wait 1e12
    73 jump *label4 always
    74 end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-1 instructions):
 
    52 label *label42
    53 ucontrol itemDrop :depositItems:block 10
    54 sensor *tmp32 :depositItems:block @titanium
-    * jump *label45 lessThan *tmp32 :depositItems:cap
-    * jump *label44 always
+   55 jump *label44 greaterThanEq *tmp32 :depositItems:cap
    56 label *label45
    57 sensor *tmp35 @unit @firstItem
    58 jump *label42 notEqual *tmp35 null

Modifications by Jumps phase, Jump Optimization, pass 5, iteration 1:
 
    53 ucontrol itemDrop :depositItems:block 10
    54 sensor *tmp32 :depositItems:block @titanium
    55 jump *label44 greaterThanEq *tmp32 :depositItems:cap
-    * label *label45
    56 sensor *tmp35 @unit @firstItem
    57 jump *label42 notEqual *tmp35 null
    58 label *label44

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
 
    52 label *label42
    53 ucontrol itemDrop :depositItems:block 10
    54 sensor *tmp32 :depositItems:block @titanium
-    * jump *label44 greaterThanEq *tmp32 :depositItems:cap
+   55 jump *label9 greaterThanEq *tmp32 :depositItems:cap
    56 sensor *tmp35 @unit @firstItem
    57 jump *label42 notEqual *tmp35 null
    58 label *label44
-    * jump *label33 always
+   59 jump *label9 always
    60 label *label32
    61 sensor *tmp37 @unit @firstItem
-    * jump *label49 equal *tmp37 null
+   62 jump *label9 equal *tmp37 null
    63 label *label112
    64 ucontrol itemDrop @air 1000
    65 sensor *tmp37 @unit @firstItem

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-3 instructions):
 
    55 jump *label9 greaterThanEq *tmp32 :depositItems:cap
    56 sensor *tmp35 @unit @firstItem
    57 jump *label42 notEqual *tmp35 null
-    * label *label44
    58 jump *label9 always
    59 label *label32
    60 sensor *tmp37 @unit @firstItem
 
    63 ucontrol itemDrop @air 1000
    64 sensor *tmp37 @unit @firstItem
    65 jump *label112 notEqual *tmp37 null
-    * label *label49
-    * label *label33
    66 jump *label9 always
-    * wait 1e12
-    * jump *label4 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 5, iteration 1:
     0 set .ERROR ""
     1 set *signature "0:v1"
-    * label *label4
     2 label *label6
     3 ubind @flare
     4 jump *label6 equal @unit null

Final code before resolving virtual instructions:

    0:  jump *label113 always 0 0                                    Actions.mnd: volatile var ERROR = "";
    1:  draw triangle .ERROR .core .drill :depositItems:block :depos ...
    2:  draw triangle :fetchBlock:unitItem 0 0 0 0 0                 ...
        label *label113                                              ...
    3:  set .ERROR ""                                                ...
    4:  set *signature "0:v1"                                        FlareController.mnd: #set target = 8;
        label *label6                                                FlareController.mnd: do
    5:  ubind @flare                                                 FlareController.mnd: ubind(@flare);
    6:  jump *label6 equal @unit null                                FlareController.mnd: do
        label *label9                                                FlareController.mnd: while true do
    7:  set :fetchBlock:block .drill                                 FlareController.mnd: fetchBlock(drill, @titanium);
    8:  sensor *tmp2 :fetchBlock:block @x                            Actions.mnd: moveToEmpty(block.@x, block.@y);
    9:  sensor *tmp3 :fetchBlock:block @y                            ...
        label *label17                                               Actions.mnd: do
   10:  sensor *tmp4 @unit @firstItem                                Actions.mnd: if @unit.@firstItem != null then itemDrop(@air, 1000); end;
   11:  jump *label20 equal *tmp4 null                               ...
   12:  ucontrol itemDrop @air 1000 0 0 0                            ...
        label *label20                                               ...
   13:  ucontrol approach *tmp2 *tmp3 4.5 0 0                        Actions.mnd: approach(x, y, REGULAR_RADIUS - 0.5);
   14:  ucontrol within *tmp2 *tmp3 5 *tmp7 0                        Actions.mnd: while !within(x, y, REGULAR_RADIUS);
   15:  jump *label17 equal *tmp7 false                              Actions.mnd: do
   16:  sensor *tmp9 @unit @firstItem                                Actions.mnd: while @unit.@firstItem != null do
   17:  jump *label24 equal *tmp9 null                               ...
        label *label110                                              ...
   18:  ucontrol itemDrop @air 1000 0 0 0                            Actions.mnd: itemDrop(@air, 1000);
   19:  sensor *tmp9 @unit @firstItem                                Actions.mnd: while @unit.@firstItem != null do
   20:  jump *label110 notEqual *tmp9 null                           ...
        label *label24                                               ...
        label *label25                                               Actions.mnd: do
   21:  ucontrol itemTake :fetchBlock:block @titanium 10 0 0         Actions.mnd: itemTake(block, item, capacity);
   22:  sensor :fetchBlock:unitItem @unit @firstItem                 Actions.mnd: var unitItem = @unit.@firstItem;
   23:  op notEqual *tmp12 :fetchBlock:unitItem null                 Actions.mnd: if unitItem != null and unitItem != item then
   24:  op notEqual *tmp13 :fetchBlock:unitItem @titanium            ...
   25:  op land *tmp14 *tmp12 *tmp13                                 ...
   26:  jump *label28 equal *tmp14 false                             ...
   27:  ucontrol itemDrop @air 1000 0 0 0                            Actions.mnd: itemDrop(@air, 1000);
        label *label28                                               Actions.mnd: if unitItem != null and unitItem != item then
   28:  sensor *tmp16 @unit @titanium                                Actions.mnd: while @unit.sensor(item) < capacity and block.sensor(item);
   29:  op lessThan *tmp17 *tmp16 10                                 ...
   30:  sensor *tmp18 :fetchBlock:block @titanium                    ...
   31:  op land *tmp19 *tmp17 *tmp18                                 ...
   32:  jump *label25 notEqual *tmp19 false                          Actions.mnd: do
   33:  set :depositItems:block .core                                Actions.mnd: depositItems(core, item, false);
   34:  sensor *tmp20 @unit @firstItem                               Actions.mnd: if @unit.@firstItem == item then
   35:  jump *label32 notEqual *tmp20 @titanium                      ...
   36:  sensor *tmp26 :depositItems:block @x                         Actions.mnd: moveTo(block.@x, block.@y, radius);
   37:  sensor *tmp27 :depositItems:block @y                         ...
   38:  ucontrol within *tmp26 *tmp27 5 *tmp28 0                     Actions.mnd: while !within(x, y, radius) do
   39:  jump *label41 notEqual *tmp28 false                          ...
        label *label111                                              ...
   40:  ucontrol approach *tmp26 *tmp27 4.5 0 0                      Actions.mnd: approach(x, y, radius - 0.5);
   41:  ucontrol within *tmp26 *tmp27 5 *tmp28 0                     Actions.mnd: while !within(x, y, radius) do
   42:  jump *label111 equal *tmp28 false                            ...
        label *label41                                               ...
   43:  sensor :depositItems:cap :depositItems:block @itemCapacity   Actions.mnd: var cap = block.@itemCapacity;
        label *label42                                               Actions.mnd: do
   44:  ucontrol itemDrop :depositItems:block 10 0 0 0               Actions.mnd: itemDrop(block, capacity);
   45:  sensor *tmp32 :depositItems:block @titanium                  Actions.mnd: if block.sensor(item) >= cap then break; end;
   46:  jump *label9 greaterThanEq *tmp32 :depositItems:cap          ...
   47:  sensor *tmp35 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null;
   48:  jump *label42 notEqual *tmp35 null                           Actions.mnd: do
   49:  jump *label9 always 0 0                                      Actions.mnd: if @unit.@firstItem == item then
        label *label32                                               ...
   50:  sensor *tmp37 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   51:  jump *label9 equal *tmp37 null                               ...
        label *label112                                              ...
   52:  ucontrol itemDrop @air 1000 0 0 0                            Actions.mnd: itemDrop(@air, 1000);
   53:  sensor *tmp37 @unit @firstItem                               Actions.mnd: while @unit.@firstItem != null do
   54:  jump *label112 notEqual *tmp37 null                          ...
   55:  jump *label9 always 0 0                                      FlareController.mnd: while true do


Performance: parsed in 200 ms, compiled in 333 ms, optimized in 261 ms, run in 4 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (4 steps):
The program didn't generate any output.
Execution exception at instruction 5: ubind @flare:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
