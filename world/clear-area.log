    32 instructions before optimizations.
     3 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     1 instructions eliminated by Single Step Elimination (5 iterations).
     1 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    26 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    31 read *tmp11 processor3 ":clearArea2*finished"
    32 jump *label16 equal *tmp11 false
    33 read *tmp12 processor3 ":clearArea2*retval"
-    * set *tmp5 *tmp12
    34 jump *label13 always
    35 label *label12
-    * set *tmp5 null
    36 label *label13
    37 label *label10
    38 jump *label9 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-1 instructions):
 
    30 wait 1e-15
    31 read *tmp11 processor3 ":clearArea2*finished"
    32 jump *label16 equal *tmp11 false
-    * read *tmp12 processor3 ":clearArea2*retval"
    33 jump *label13 always
    34 label *label12
    35 label *label13

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
     8 jump *label8 notEqual *tmp2 "8bd370a6df37009f:v1"
     9 control enabled switch1 false
    10 label *label9
-    * jump *label11 equal true false
    11 sensor *tmp4 switch1 @enabled
    12 jump *label12 equal *tmp4 false
    13 control enabled switch1 false

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-1 instructions):
 
    29 wait 1e-15
    30 read *tmp11 processor3 ":clearArea2*finished"
    31 jump *label16 equal *tmp11 false
-    * jump *label13 always
    32 label *label12
    33 label *label13
    34 label *label10

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-1 instructions):
 
    30 read *tmp11 processor3 ":clearArea2*finished"
    31 jump *label16 equal *tmp11 false
    32 label *label12
-    * label *label13
-    * label *label10
    33 jump *label9 always
-    * label *label11
-    * end

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
 
     9 control enabled switch1 false
    10 label *label9
    11 sensor *tmp4 switch1 @enabled
-    * jump *label12 equal *tmp4 false
+   12 jump *label9 equal *tmp4 false
    13 control enabled switch1 false
    14 write false processor1 ":clearArea0*finished"
    15 write 1 processor1 "@counter"

Final code before resolving virtual instructions:

        label *label6                                                clear-area.mnd: require "clear-area-0.mnd" remote processor1;
    0:  read *tmp0 processor1 "*signature"                           ...
    1:  jump *label6 notEqual *tmp0 "8bd373c6df37009f:v1"            ...
        label *label7                                                clear-area.mnd: require "clear-area-1.mnd" remote processor2;
    2:  read *tmp1 processor2 "*signature"                           ...
    3:  jump *label7 notEqual *tmp1 "8bd37276df37009f:v1"            ...
        label *label8                                                clear-area.mnd: require "clear-area-2.mnd" remote processor3;
    4:  read *tmp2 processor3 "*signature"                           ...
    5:  jump *label8 notEqual *tmp2 "8bd370a6df37009f:v1"            ...
    6:  control enabled switch1 false 0 0 0                          clear-area.mnd: switch1.enabled = false;
        label *label9                                                clear-area.mnd: while true do
    7:  sensor *tmp4 switch1 @enabled                                clear-area.mnd: if switch1.enabled then
    8:  jump *label9 equal *tmp4 false                               ...
    9:  control enabled switch1 false 0 0 0                          clear-area.mnd: switch1.enabled = false;
   10:  write false processor1 ":clearArea0*finished"                clear-area.mnd: async(processor1.clearArea0());
   11:  write 1 processor1 "@counter"                                ...
   12:  write false processor2 ":clearArea1*finished"                clear-area.mnd: async(processor2.clearArea1());
   13:  write 1 processor2 "@counter"                                ...
   14:  write false processor3 ":clearArea2*finished"                clear-area.mnd: async(processor3.clearArea2());
   15:  write 1 processor3 "@counter"                                ...
        label *label14                                               clear-area.mnd: await(processor1.clearArea0);
   16:  wait 1e-15                                                   ...
   17:  read *tmp7 processor1 ":clearArea0*finished"                 ...
   18:  jump *label14 equal *tmp7 false                              ...
        label *label15                                               clear-area.mnd: await(processor2.clearArea1);
   19:  wait 1e-15                                                   ...
   20:  read *tmp9 processor2 ":clearArea1*finished"                 ...
   21:  jump *label15 equal *tmp9 false                              ...
        label *label16                                               clear-area.mnd: await(processor3.clearArea2);
   22:  wait 1e-15                                                   ...
   23:  read *tmp11 processor3 ":clearArea2*finished"                ...
   24:  jump *label16 equal *tmp11 false                             ...
   25:  jump *label9 always 0 0                                      clear-area.mnd: while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
    27     1x     27,0  <no function>

Performance: parsed in 161 ms, compiled in 244 ms, optimized in 79 ms, run in 10 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (1 steps):
The program didn't generate any output.
Execution exception at instruction 0: read *tmp0 processor1 "*signature":
Variable 'processor1' is not an object.
(Use the '#set err-not-an-object = false;' directive or the '--err-not-an-object false' command line option to ignore this exception.)
