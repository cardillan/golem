   663 instructions before optimizations.
    55 instructions eliminated by Temp Variables Elimination (7 iterations).
     4 instructions eliminated by Case Expression Optimization.
    85 instructions eliminated by Dead Code Elimination (7 iterations).
     1 instructions eliminated by Jump Normalization (6 iterations).
    47 instructions eliminated by Condition Optimization (2 passes, 8 iterations).
    45 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
     1 instructions eliminated by Expression Optimization (4 iterations).
     4 instructions eliminated by Boolean Optimization (7 iterations).
       4 final jumps of a short-circuited expression optimized.
     3 instructions eliminated by If Expression Optimization (2 passes, 4 iterations).
     8 instructions eliminated by Data Flow Optimization (2 passes, 9 iterations).
     1 instructions eliminated by Loop Rotation (4 iterations).
       1 loop conditions were fully rotated.
       2 loop conditions were partially rotated.
   150 instructions added by Case Switching (6 iterations).
     2 case expressions converted to switched jumps by Case Switching.
    16 instructions eliminated by Jump Straightening (7 iterations).
    12 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    24 instructions eliminated by Print Merging.
   518 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 600):
  o Convert case at line 122:9 (segments: 7)                     size    +1, benefit      125.0, efficiency    125.000
  o Convert case at line 122:9 (segments: 1)                     size   +39, benefit      375.0, efficiency      9.615
  o Convert case at line 122:9 (segments: 1, padded low)         size   +75, benefit     1000.0, efficiency     13.333
  o Convert case at line 420:9 (segments: 7)                     size    +0, benefit      125.0, efficiency   Infinity
  o Convert case at line 420:9 (segments: 2)                     size   +38, benefit      250.0, efficiency      6.579
  o Convert case at line 420:9 (segments: 1)                     size   +39, benefit      375.0, efficiency      9.615
  * Convert case at line 420:9 (segments: 1, padded low)         size   +75, benefit     1000.0, efficiency     13.333 (+74 instructions)

Pass 1: speed optimization selection (cost limit 526):
  o Convert case at line 122:9 (segments: 7)                     size    +1, benefit      125.0, efficiency    125.000
  o Convert case at line 122:9 (segments: 1)                     size   +39, benefit      375.0, efficiency      9.615
  * Convert case at line 122:9 (segments: 1, padded low)         size   +75, benefit     1000.0, efficiency     13.333 (+75 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-4 instructions):
 
    19 print :block
    20 print "\n"
    21 sensor *tmp5 :block @type
-    * set *tmp6 *tmp5
-    * jump *label8 equal *tmp6 @impact-reactor
+   22 jump *label8 equal *tmp5 @impact-reactor
    23 jump *label7 always
    24 label *label8
    25 set .START :n
 
    27 set *tmp4 :reactors
    28 jump *label6 always
    29 label *label7
-    * jump *label10 equal *tmp6 @overdrive-projector
-    * jump *label10 equal *tmp6 @overdrive-dome
-    * jump *label10 equal *tmp6 @conduit
-    * jump *label10 equal *tmp6 @pulse-conduit
-    * jump *label10 equal *tmp6 @plated-conduit
-    * jump *label10 equal *tmp6 @conveyor
-    * jump *label10 equal *tmp6 @titanium-conveyor
-    * jump *label10 equal *tmp6 @plastanium-conveyor
-    * jump *label10 equal *tmp6 @armored-conveyor
+   30 jump *label10 equal *tmp5 @overdrive-projector
+   31 jump *label10 equal *tmp5 @overdrive-dome
+   32 jump *label10 equal *tmp5 @conduit
+   33 jump *label10 equal *tmp5 @pulse-conduit
+   34 jump *label10 equal *tmp5 @plated-conduit
+   35 jump *label10 equal *tmp5 @conveyor
+   36 jump *label10 equal *tmp5 @titanium-conveyor
+   37 jump *label10 equal *tmp5 @plastanium-conveyor
+   38 jump *label10 equal *tmp5 @armored-conveyor
    39 jump *label9 always
    40 label *label10
    41 set .START :n
 
   197 label *label18
   198 set *tmp43 null
   199 label *label19
-    * set *tmp60 .MODE
-    * jump *label35 equal *tmp60 0
+  200 jump *label35 equal .MODE 0
   201 jump *label34 always
   202 label *label35
   203 set *tmp59 "[salmon]SHUTDOWN[]"
   204 jump *label33 always
   205 label *label34
-    * jump *label37 equal *tmp60 1
+  206 jump *label37 equal .MODE 1
   207 jump *label36 always
   208 label *label37
   209 set *tmp59 "[gold]STARTUP[]"
   210 jump *label33 always
   211 label *label36
-    * jump *label39 equal *tmp60 2
+  212 jump *label39 equal .MODE 2
   213 jump *label38 always
   214 label *label39
   215 set *tmp59 "[green]RUNNING[]"
 
   297 print :net_power
   298 print "["
   299 print "]"
-    * set *tmp76 .MODE
-    * jump *label50 equal *tmp76 0
+  300 jump *label50 equal .MODE 0
   301 jump *label49 always
   302 label *label50
   303 set .REACTORS_ON 0
 
   327 set *tmp75 *tmp81
   328 jump *label48 always
   329 label *label49
-    * jump *label54 equal *tmp76 1
+  330 jump *label54 equal .MODE 1
   331 jump *label53 always
   332 label *label54
   333 jump *label55 equal .OUTPUT_1 false
 
   484 set *tmp75 *tmp88
   485 jump *label48 always
   486 label *label53
-    * jump *label88 equal *tmp76 2
+  487 jump *label88 equal .MODE 2
   488 jump *label87 always
   489 label *label88
   490 jump *label89 equal .COOLANT_FLAG false
 
   722 getlink *tmp185 :n
   723 set :block *tmp185
   724 sensor *tmp187 :block @type
-    * set *tmp188 *tmp187
-    * jump *label143 equal *tmp188 @impact-reactor
+  725 jump *label143 equal *tmp187 @impact-reactor
   726 jump *label142 always
   727 label *label143
   728 op add :reactors :reactors 1
 
   741 set *tmp186 *tmp192
   742 jump *label141 always
   743 label *label142
-    * jump *label147 equal *tmp188 @overdrive-projector
-    * jump *label147 equal *tmp188 @overdrive-dome
+  744 jump *label147 equal *tmp187 @overdrive-projector
+  745 jump *label147 equal *tmp187 @overdrive-dome
   746 jump *label146 always
   747 label *label147
   748 set *tmp194 :block
 
   750 set *tmp186 .OVERDRIVE
   751 jump *label141 always
   752 label *label146
-    * jump *label149 equal *tmp188 @conduit
-    * jump *label149 equal *tmp188 @pulse-conduit
-    * jump *label149 equal *tmp188 @plated-conduit
-    * jump *label149 equal *tmp188 @conveyor
-    * jump *label149 equal *tmp188 @titanium-conveyor
-    * jump *label149 equal *tmp188 @plastanium-conveyor
-    * jump *label149 equal *tmp188 @armored-conveyor
+  753 jump *label149 equal *tmp187 @conduit
+  754 jump *label149 equal *tmp187 @pulse-conduit
+  755 jump *label149 equal *tmp187 @plated-conduit
+  756 jump *label149 equal *tmp187 @conveyor
+  757 jump *label149 equal *tmp187 @titanium-conveyor
+  758 jump *label149 equal *tmp187 @plastanium-conveyor
+  759 jump *label149 equal *tmp187 @armored-conveyor
   760 jump *label148 always
   761 label *label149
   762 set *tmp196 :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-57 instructions):
 
    24 label *label8
    25 set .START :n
    26 op add :reactors :reactors 1
-    * set *tmp4 :reactors
    27 jump *label6 always
    28 label *label7
    29 jump *label10 equal *tmp5 @overdrive-projector
 
    38 jump *label9 always
    39 label *label10
    40 set .START :n
-    * set *tmp4 .START
    41 jump *label6 always
    42 label *label9
-    * set *tmp4 null
    43 label *label6
    44 label *label4
    45 jump *label3 always
 
    49 op equal *tmp8 :reactors 0
    50 jump *label11 equal *tmp8 false
    51 print "No reactor."
-    * set *tmp9 "No reactor."
    52 jump *label12 always
    53 label *label11
-    * set *tmp9 null
    54 label *label12
    55 printflush message1
    56 label *label1
 
    80 op equal *tmp20 .MODE 0
    81 jump *label13 equal *tmp20 false
    82 set .REASON "Processor reset"
-    * set *tmp21 .REASON
    83 jump *label14 always
    84 label *label13
    85 set .REASON "Reason unknown -- out of power?"
-    * set *tmp21 .REASON
    86 label *label14
    87 op notEqual *tmp23 .MODE 0
    88 control enabled switch1 *tmp23
 
   185 label *label28
   186 set *tmp46 *tmp53
   187 label *label21
-    * set *tmp43 *tmp46
   188 jump *label19 always
   189 label *label18
-    * set *tmp43 null
   190 label *label19
   191 jump *label35 equal .MODE 0
   192 jump *label34 always
 
   227 print " ([gold]"
   228 print :multiplier
   229 print "x[])"
-    * set *tmp61 "x[])"
   230 jump *label41 always
   231 label *label40
-    * set *tmp61 null
   232 label *label41
   233 print "\n=================================="
   234 sensor *tmp67 tank1 @totalLiquids
   235 op lessThan *tmp68 *tmp67 750
   236 jump *label42 equal *tmp68 false
   237 print "\n[salmon]Cryofluid level critical![]"
-    * set *tmp69 "\n[salmon]Cryofluid level critical![]"
   238 jump *label43 always
   239 label *label42
-    * set *tmp69 null
   240 label *label43
   241 sensor *tmp70 vault1 @blast-compound
   242 op lessThan *tmp71 *tmp70 700
   243 jump *label44 equal *tmp71 false
   244 print "\n[salmon]Blast compound level critical![]"
-    * set *tmp72 "\n[salmon]Blast compound level critical![]"
   245 jump *label45 always
   246 label *label44
-    * set *tmp72 null
   247 label *label45
   248 op equal *tmp73 :enough_battery false
   249 jump *label46 equal *tmp73 false
 
   254 print :missing_battery
   255 print " "
   256 print "K[] of additional storage to internal battery."
-    * set *tmp74 null
   257 jump *label47 always
   258 label *label46
-    * set *tmp74 null
   259 label *label47
   260 print "\n"
   261 print "Internal battery:    [gold]"
 
   307 label *label51
   308 set *tmp81 null
   309 label *label52
-    * set *tmp75 *tmp81
   310 jump *label48 always
   311 label *label49
   312 jump *label54 equal .MODE 1
 
   356 print :neededPower
   357 print "["
   358 print "]"
-    * set *tmp94 null
   359 jump *label62 always
   360 label *label61
-    * set *tmp94 null
   361 label *label62
   362 op greaterThan *tmp95 :net_power 100
   363 jump *label63 equal *tmp95 false
   364 set .OVERDRIVE true
-    * set *tmp96 .OVERDRIVE
   365 jump *label64 always
   366 label *label63
-    * set *tmp96 null
   367 label *label64
   368 op lessThan *tmp97 .REACTORS_ON :reactors
   369 jump *label65 equal *tmp97 false
 
   386 jump *label70 equal *tmp101 false
   387 set .OUTPUT_2 .OUTPUT_1
   388 set .OUTPUT_1 1
-    * set *tmp102 .OUTPUT_1
   389 jump *label71 always
   390 label *label70
-    * set *tmp102 null
   391 label *label71
   392 op equal *tmp103 .OUTPUT_1 0
   393 jump *label72 equal *tmp103 false
 
   404 label *label74
   405 set *tmp108 null
   406 label *label75
-    * set *tmp104 *tmp108
   407 jump *label73 always
   408 label *label72
-    * set *tmp104 null
   409 label *label73
   410 jump *label76 equal :canStart false
   411 label *label79
 
   426 set .REACTORS_ON *tmp115
   427 op add *tmp116 @time 2000
   428 set :nextStart *tmp116
-    * set *tmp111 :nextStart
   429 jump *label77 always
   430 label *label76
-    * set *tmp111 null
   431 label *label77
   432 op greaterThanEq *tmp117 .REACTORS_ON :reactors
   433 jump *label82 equal *tmp117 false
 
   453 label *label83
   454 set *tmp88 *tmp120
   455 label *label58
-    * set *tmp75 *tmp88
   456 jump *label48 always
   457 label *label53
   458 jump *label88 equal .MODE 2
 
   468 set .MODE 0
   469 control enabled switch1 false
   470 set .REASON "Cryo level too low"
-    * set *tmp124 .REASON
   471 jump *label90 always
   472 label *label89
-    * set *tmp124 null
   473 label *label90
   474 jump *label93 equal .FUEL_FLAG false
   475 label *label96
 
   481 set .MODE 0
   482 control enabled switch1 false
   483 set .REASON "Blast compound level too low"
-    * set *tmp128 .REASON
   484 jump *label94 always
   485 label *label93
-    * set *tmp128 null
   486 label *label94
   487 jump *label99 notEqual .COOLANT_FLAG false
   488 label *label100
 
   542 op idiv *tmp149 :commit_level 1000
   543 print "\nCommit threshold:   [gold]"
   544 print *tmp149
-    * set *tmp141 *tmp149
   545 jump *label110 always
   546 label *label109
-    * set *tmp141 null
   547 label *label110
   548 op equal *tmp150 :commit_level 0
   549 jump *label114 equal *tmp150 false
   550 op idiv *tmp152 :min_level 1000
   551 print "\nRestart threshold: [gold]"
   552 print *tmp152
-    * set *tmp151 *tmp152
   553 jump *label115 always
   554 label *label114
-    * set *tmp151 null
   555 label *label115
   556 print "[] K"
   557 op lessThan *tmp153 :total_battery :min_level
 
   580 label *label122
   581 op add *tmp162 @time 6000
   582 set :nextDecommit *tmp162
-    * set *tmp161 :nextDecommit
   583 jump *label121 always
   584 label *label120
-    * set *tmp161 null
   585 label *label121
   586 op greaterThan *tmp163 @time :nextDecommit
   587 jump *label124 equal *tmp163 false
   588 jump *label126 equal .OVERDRIVE false
   589 set .OVERDRIVE false
-    * set *tmp165 .OVERDRIVE
   590 jump *label127 always
   591 label *label126
   592 op sub *tmp166 .REACTORS_ON 1
   593 op max *tmp167 *tmp166 1
   594 set .REACTORS_ON *tmp167
   595 set .CAN_COMMIT true
-    * set *tmp165 .CAN_COMMIT
   596 label *label127
   597 op add *tmp168 @time 6000
   598 set :nextDecommit *tmp168
 
   613 label *label125
   614 set *tmp156 *tmp164
   615 label *label117
-    * set *tmp137 *tmp156
   616 jump *label106 always
   617 label *label105
   618 sensor *tmp171 switch2 @enabled
   619 jump *label130 equal *tmp171 false
   620 print "\n[salmon]Load adapting not possible.[]"
-    * set *tmp172 "\n[salmon]Load adapting not possible.[]"
   621 jump *label131 always
   622 label *label130
   623 print "\n[gold]Load adapting not active.[]"
-    * set *tmp172 "\n[gold]Load adapting not active.[]"
   624 label *label131
   625 set .REACTORS_ON :reactors
   626 set .OVERDRIVE true
-    * set *tmp137 .OVERDRIVE
   627 label *label106
   628 op mul *tmp173 PLANT_PROTECTION 47500
   629 op lessThan *tmp174 :total_battery *tmp173
   630 jump *label132 equal *tmp174 false
   631 set .OUTPUT_2 0
-    * set *tmp175 .OUTPUT_2
   632 jump *label133 always
   633 label *label132
-    * set *tmp175 null
   634 label *label133
   635 op equal *tmp176 .OUTPUT_2 0
   636 jump *label134 equal *tmp176 false
 
   648 label *label134
   649 set *tmp177 null
   650 label *label135
-    * set *tmp75 *tmp177
   651 jump *label48 always
   652 label *label87
-    * set *tmp75 null
   653 label *label48
   654 print "\n"
   655 print .STARTUPS
 
   689 label *label144
   690 set *tmp192 null
   691 label *label145
-    * set *tmp186 *tmp192
   692 jump *label141 always
   693 label *label142
   694 jump *label147 equal *tmp187 @overdrive-projector
 
   697 label *label147
   698 set *tmp194 :block
   699 control enabled *tmp194 .OVERDRIVE
-    * set *tmp186 .OVERDRIVE
   700 jump *label141 always
   701 label *label146
   702 jump *label149 equal *tmp187 @conduit
 
   710 label *label149
   711 set *tmp196 :block
   712 control enabled *tmp196 :startup
-    * set *tmp186 :startup
   713 jump *label141 always
   714 label *label148
-    * set *tmp186 null
   715 label *label141
   716 label *label139
   717 op add :n :n 1
 
   726 op add :reactors :reactors *tmp203
   727 read *tmp204 cell2 4
   728 op add :boosts :boosts *tmp204
-    * set *tmp199 :boosts
   729 jump *label151 always
   730 label *label150
-    * set *tmp199 null
   731 label *label151
   732 op min *tmp205 .REACTORS_ON :reactors
   733 set .REACTORS_ON *tmp205
 
   736 set .STARTUPS 0
   737 set .RESETS 0
   738 set .COMMITS 0
-    * set *tmp207 .COMMITS
   739 jump *label153 always
   740 label *label152
   741 write .MODE cell1 0
 
   748 write .STARTUPS cell1 7
   749 write .RESETS cell1 8
   750 write .COMMITS cell1 9
-    * set *tmp207 .COMMITS
   751 label *label153
   752 label *label16
   753 jump *label15 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-14 instructions):
 
   130 jump *label20 equal *tmp45 false
   131 set .MODE 0
   132 set .REASON "Manual power off"
-    * set *tmp46 .REASON
   133 jump *label21 always
   134 label *label20
   135 op mul *tmp47 .REACTORS_ON 1200
 
   182 set :failure_cnt 0
   183 set *tmp53 :failure_cnt
   184 label *label28
-    * set *tmp46 *tmp53
   185 label *label21
   186 jump *label19 always
   187 label *label18
 
   300 set :failure_cnt 0
   301 set .GENERATOR true
   302 set .REASON "Unknown -- out of power?"
-    * set *tmp81 .REASON
   303 jump *label52 always
   304 label *label51
-    * set *tmp81 null
   305 label *label52
   306 jump *label48 always
   307 label *label49
 
   335 print " K[]"
   336 set *tmp90 " K[]"
   337 label *label60
-    * set *tmp88 *tmp90
   338 jump *label58 always
   339 label *label57
   340 op add *tmp92 .OUTPUT_1 .OUTPUT_2
 
   394 jump *label74 equal *tmp107 false
   395 op add *tmp109 @time 2000
   396 set :nextStart *tmp109
-    * set *tmp108 :nextStart
   397 jump *label75 always
   398 label *label74
-    * set *tmp108 null
   399 label *label75
   400 jump *label73 always
   401 label *label72
 
   444 label *label82
   445 set *tmp120 null
   446 label *label83
-    * set *tmp88 *tmp120
   447 label *label58
   448 jump *label48 always
   449 label *label53
 
   560 set .REACTORS_ON :reactors
   561 op add *tmp158 @time 6000
   562 set :nextDecommit *tmp158
-    * set *tmp156 :nextDecommit
   563 jump *label117 always
   564 label *label116
   565 op lessThan *tmp159 :battery_level 47500
 
   602 label *label129
   603 set *tmp164 *tmp170
   604 label *label125
-    * set *tmp156 *tmp164
   605 label *label117
   606 jump *label106 always
   607 label *label105
 
   633 print "\n*** [gold]Surge tower 2 offline[] ***"
   634 set *tmp179 "\n*** [gold]Surge tower 2 offline[] ***"
   635 label *label137
-    * set *tmp177 *tmp179
   636 jump *label135 always
   637 label *label134
-    * set *tmp177 null
   638 label *label135
   639 jump *label48 always
   640 label *label87
 
   672 jump *label144 equal :enabled false
   673 sensor *tmp193 :block @timescale
   674 op add :boosts :boosts *tmp193
-    * set *tmp192 :boosts
   675 jump *label145 always
   676 label *label144
-    * set *tmp192 null
   677 label *label145
   678 jump *label141 always
   679 label *label142

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   176 label *label31
   177 set *tmp57 null
   178 label *label32
-    * set *tmp53 *tmp57
   179 jump *label28 always
   180 label *label27
   181 set :failure_cnt 0
-    * set *tmp53 :failure_cnt
   182 label *label28
   183 label *label21
   184 jump *label19 always
 
   325 set .REACTORS_ON 1
   326 op add *tmp91 @time 2000
   327 set :nextStart *tmp91
-    * set *tmp90 :nextStart
   328 jump *label60 always
   329 label *label59
   330 print "\nRequired startup energy: [gold]"
   331 print 25
   332 print " K[]"
-    * set *tmp90 " K[]"
   333 label *label60
   334 jump *label58 always
   335 label *label57
 
   435 set .COOLANT_FLAG 0
   436 set .FUEL_FLAG 0
   437 set .GENERATOR false
-    * set *tmp120 .GENERATOR
   438 jump *label83 always
   439 label *label82
-    * set *tmp120 null
   440 label *label83
   441 label *label58
   442 jump *label48 always
 
   581 label *label127
   582 op add *tmp168 @time 6000
   583 set :nextDecommit *tmp168
-    * set *tmp164 :nextDecommit
   584 jump *label125 always
   585 label *label124
   586 op lessThan *tmp169 :total_battery :commit_level
 
   593 label *label128
   594 set *tmp170 null
   595 label *label129
-    * set *tmp164 *tmp170
   596 label *label125
   597 label *label117
   598 jump *label106 always
 
   619 op greaterThan *tmp178 :total_battery 47500
   620 jump *label136 equal *tmp178 false
   621 set .OUTPUT_2 1
-    * set *tmp179 .OUTPUT_2
   622 jump *label137 always
   623 label *label136
   624 print "\n*** [gold]Surge tower 2 offline[] ***"
-    * set *tmp179 "\n*** [gold]Surge tower 2 offline[] ***"
   625 label *label137
   626 jump *label135 always
   627 label *label134

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-4 instructions):
 
   171 print "\nMin. consumption: "
   172 print :min_consumption
   173 printflush message2
-    * set *tmp57 null
   174 jump *label32 always
   175 label *label31
-    * set *tmp57 null
   176 label *label32
   177 jump *label28 always
   178 label *label27
 
   586 op add .REACTORS_ON .REACTORS_ON 1
   587 op add .COMMITS .COMMITS 1
   588 set .CAN_COMMIT false
-    * set *tmp170 .CAN_COMMIT
   589 jump *label129 always
   590 label *label128
-    * set *tmp170 null
   591 label *label129
   592 label *label125
   593 label *label117

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-55 instructions):
 
     7 op equal *tmp0 :reactors 0
     8 jump *label2 equal *tmp0 false
     9 set :reactors 0
-    * set *tmp1 @links
-    * set :n *tmp1
+   10 set :n @links
    11 label *label3
    12 op greaterThan *tmp2 :n 0
    13 jump *label5 equal *tmp2 false
    14 op sub :n :n 1
-    * getlink *tmp3 :n
-    * set :block *tmp3
+   15 getlink :block :n
    16 print "Found: "
    17 print :block
    18 print "\n"
 
    54 label *label1
    55 jump *label0 always
    56 label *label2
-    * read *tmp10 cell1 0
-    * set .MODE *tmp10
-    * read *tmp11 cell1 1
-    * set .OUTPUT_1 *tmp11
-    * read *tmp12 cell1 2
-    * set .OUTPUT_2 *tmp12
-    * read *tmp13 cell1 3
-    * set .REACTORS_ON *tmp13
-    * read *tmp14 cell1 4
-    * set .OVERDRIVE *tmp14
-    * read *tmp15 cell1 5
-    * set .GENERATOR *tmp15
-    * read *tmp16 cell1 6
-    * set .CAN_COMMIT *tmp16
-    * read *tmp17 cell1 7
-    * set .STARTUPS *tmp17
-    * read *tmp18 cell1 8
-    * set .RESETS *tmp18
-    * read *tmp19 cell1 9
-    * set .COMMITS *tmp19
+   57 read .MODE cell1 0
+   58 read .OUTPUT_1 cell1 1
+   59 read .OUTPUT_2 cell1 2
+   60 read .REACTORS_ON cell1 3
+   61 read .OVERDRIVE cell1 4
+   62 read .GENERATOR cell1 5
+   63 read .CAN_COMMIT cell1 6
+   64 read .STARTUPS cell1 7
+   65 read .RESETS cell1 8
+   66 read .COMMITS cell1 9
    67 set :reactors .REACTORS_ON
    68 op equal *tmp20 .MODE 0
    69 jump *label13 equal *tmp20 false
 
    77 set :failure_cnt 0
    78 set :boosts 0
    79 set :nextStart 0
-    * op add *tmp24 @time 6000
-    * set :nextDecommit *tmp24
+   80 op add :nextDecommit @time 6000
    81 label *label15
    82 jump *label17 equal true false
    83 sensor *tmp25 battery1 @totalPower
-    * op floor *tmp26 *tmp25
-    * set :battery_level *tmp26
-    * op idiv *tmp27 :battery_level 1000
-    * set :battery_level_str *tmp27
+   84 op floor :battery_level *tmp25
+   85 op idiv :battery_level_str :battery_level 1000
    86 sensor *tmp28 battery1 @powerNetStored
-    * op floor *tmp29 *tmp28
-    * set :total_battery *tmp29
-    * op idiv *tmp30 :total_battery 1000
-    * set :total_battery_str *tmp30
-    * sensor *tmp31 battery1 @powerNetOut
-    * set :consumption *tmp31
-    * read *tmp32 bank1 509
-    * set :production *tmp32
-    * read *tmp33 bank1 510
-    * set :net_power *tmp33
-    * read *tmp34 bank1 511
-    * set :battery_change *tmp34
-    * sensor *tmp35 battery1 @powerNetCapacity
-    * set :total_capacity *tmp35
-    * op idiv *tmp36 :total_capacity 1000
-    * set :total_capacity_str *tmp36
-    * op mul *tmp37 100000 :reactors
-    * set :required_capacity *tmp37
-    * op greaterThanEq *tmp38 :total_capacity :required_capacity
-    * set :enough_battery *tmp38
+   87 op floor :total_battery *tmp28
+   88 op idiv :total_battery_str :total_battery 1000
+   89 sensor :consumption battery1 @powerNetOut
+   90 read :production bank1 509
+   91 read :net_power bank1 510
+   92 read :battery_change bank1 511
+   93 sensor :total_capacity battery1 @powerNetCapacity
+   94 op idiv :total_capacity_str :total_capacity 1000
+   95 op mul :required_capacity 100000 :reactors
+   96 op greaterThanEq :enough_battery :total_capacity :required_capacity
    97 op sub *tmp39 :required_capacity :total_capacity
    98 op div *tmp40 *tmp39 1000
-    * op ceil *tmp41 *tmp40
-    * set :missing_battery *tmp41
+   99 op ceil :missing_battery *tmp40
   100 op notEqual *tmp42 .MODE 0
   101 jump *label18 equal *tmp42 false
   102 sensor *tmp44 switch1 @enabled
 
   106 set .REASON "Manual power off"
   107 jump *label21 always
   108 label *label20
-    * op mul *tmp47 .REACTORS_ON 1200
-    * set :min_consumption *tmp47
-    * op lessThan *tmp48 :consumption :min_consumption
-    * set :failure1 *tmp48
+  109 op mul :min_consumption .REACTORS_ON 1200
+  110 op lessThan :failure1 :consumption :min_consumption
   111 op equal *tmp49 :battery_level 0
   112 jump *label22 equal *tmp49 false
   113 label *label26
 
   188 op div *tmp63 *tmp62 .REACTORS_ON
   189 op add *tmp64 *tmp63 0.5
   190 op floor *tmp65 *tmp64
-    * op div *tmp66 *tmp65 100
-    * set :multiplier *tmp66
+  191 op div :multiplier *tmp65 100
   192 print " ([gold]"
   193 print :multiplier
   194 print "x[])"
 
   254 set .OUTPUT_2 0
   255 op greaterThanEq *tmp77 :net_power -150
   256 op lessThan *tmp78 :total_battery 47500
-    * op land *tmp79 *tmp77 *tmp78
-    * set .GENERATOR *tmp79
+  257 op land .GENERATOR *tmp77 *tmp78
   258 print "\nShutdown reason: [gold]"
   259 print .REASON
   260 print "[]"
 
   284 sensor *tmp83 :nextBattery @powerNetOut
   285 op mul *tmp84 *tmp83 1.05
   286 op floor *tmp85 *tmp84
-    * op max *tmp86 *tmp85 1000
-    * set :neededPower *tmp86
+  287 op max :neededPower *tmp85 1000
   288 op equal *tmp87 .REACTORS_ON 0
   289 jump *label57 equal *tmp87 false
   290 op greaterThanEq *tmp89 :total_battery 25000
   291 jump *label59 equal *tmp89 false
   292 set .REACTORS_ON 1
-    * op add *tmp91 @time 2000
-    * set :nextStart *tmp91
+  293 op add :nextStart @time 2000
   294 jump *label60 always
   295 label *label59
   296 print "\nRequired startup energy: [gold]"
 
   299 label *label60
   300 jump *label58 always
   301 label *label57
-    * op add *tmp92 .OUTPUT_1 .OUTPUT_2
-    * set :outputs *tmp92
+  302 op add :outputs .OUTPUT_1 .OUTPUT_2
   303 print "\n"
   304 print "[gold]"
   305 print :outputs
 
   347 label *label71
   348 op equal *tmp103 .OUTPUT_1 0
   349 jump *label72 equal *tmp103 false
-    * op mul *tmp105 6300 :boosts
-    * set :availablePower *tmp105
-    * op div *tmp106 :neededPower :availablePower
-    * set :ratio *tmp106
+  350 op mul :availablePower 6300 :boosts
+  351 op div :ratio :neededPower :availablePower
   352 op lessThan *tmp107 :ratio 1
   353 jump *label74 equal *tmp107 false
-    * op add *tmp109 @time 2000
-    * set :nextStart *tmp109
+  354 op add :nextStart @time 2000
   355 jump *label75 always
   356 label *label74
   357 label *label75
 
   365 jump *label78 always
   366 label *label78
   367 jump *label80 equal FAST_START false
-    * op idiv *tmp113 :total_battery 25000
-    * set *tmp112 *tmp113
+  368 op idiv *tmp112 :total_battery 25000
   369 jump *label81 always
   370 label *label80
   371 set *tmp112 1
   372 label *label81
   373 set :start_at_once *tmp112
   374 op add *tmp114 .REACTORS_ON :start_at_once
-    * op min *tmp115 *tmp114 :reactors
-    * set .REACTORS_ON *tmp115
-    * op add *tmp116 @time 2000
-    * set :nextStart *tmp116
+  375 op min .REACTORS_ON *tmp114 :reactors
+  376 op add :nextStart @time 2000
   377 jump *label77 always
   378 label *label76
   379 label *label77
 
   389 jump *label84 always
   390 label *label84
   391 set .MODE 2
-    * op add *tmp121 @time 6000
-    * set :nextDecommit *tmp121
+  392 op add :nextDecommit @time 6000
   393 set .COOLANT_FLAG 0
   394 set .FUEL_FLAG 0
   395 set .GENERATOR false
 
   460 jump *label105 equal *tmp136 false
   461 jump *label107 always
   462 label *label107
-    * op mul *tmp138 0.5 :required_capacity
-    * set :min_level *tmp138
+  463 op mul :min_level 0.5 :required_capacity
   464 set :commit_level 0
   465 jump *label109 equal .CAN_COMMIT false
   466 label *label113
 
   473 jump *label111 always
   474 label *label111
   475 op sub *tmp142 :battery_change 1500
-    * op sub *tmp143 *tmp142 1000
-    * set :p *tmp143
+  476 op sub :p *tmp142 1000
   477 op mul *tmp144 :p 0.00472972972972973
   478 op add *tmp145 -5 *tmp144
   479 op mul *tmp146 :p *tmp145
-    * op add *tmp147 25000 *tmp146
-    * set :commit_margin *tmp147
-    * op add *tmp148 :min_level :commit_margin
-    * set :commit_level *tmp148
+  480 op add :commit_margin 25000 *tmp146
+  481 op add :commit_level :min_level :commit_margin
   482 op idiv *tmp149 :commit_level 1000
   483 print "\nCommit threshold:   [gold]"
   484 print *tmp149
 
   506 op add .RESETS .RESETS *tmp157
   507 set .OVERDRIVE true
   508 set .REACTORS_ON :reactors
-    * op add *tmp158 @time 6000
-    * set :nextDecommit *tmp158
+  509 op add :nextDecommit @time 6000
   510 jump *label117 always
   511 label *label116
   512 op lessThan *tmp159 :battery_level 47500
 
   516 jump *label122 notEqual *tmp160 false
   517 jump *label120 always
   518 label *label122
-    * op add *tmp162 @time 6000
-    * set :nextDecommit *tmp162
+  519 op add :nextDecommit @time 6000
   520 jump *label121 always
   521 label *label120
   522 label *label121
 
   527 jump *label127 always
   528 label *label126
   529 op sub *tmp166 .REACTORS_ON 1
-    * op max *tmp167 *tmp166 1
-    * set .REACTORS_ON *tmp167
+  530 op max .REACTORS_ON *tmp166 1
   531 set .CAN_COMMIT true
   532 label *label127
-    * op add *tmp168 @time 6000
-    * set :nextDecommit *tmp168
+  533 op add :nextDecommit @time 6000
   534 jump *label125 always
   535 label *label124
   536 op lessThan *tmp169 :total_battery :commit_level
 
   588 control enabled diode2 .OUTPUT_2
   589 control enabled generator1 .GENERATOR
   590 control enabled generator2 .GENERATOR
-    * op equal *tmp184 .MODE 1
-    * set :startup *tmp184
+  591 op equal :startup .MODE 1
   592 set :reactors 0
   593 set :boosts 0
   594 set :enabled true
   595 set :n .START
   596 label *label138
   597 jump *label140 greaterThanEq :n @links
-    * getlink *tmp185 :n
-    * set :block *tmp185
+  598 getlink :block :n
   599 sensor *tmp187 :block @type
   600 jump *label143 equal *tmp187 @impact-reactor
   601 jump *label142 always
   602 label *label143
   603 op add :reactors :reactors 1
-    * op lessThanEq *tmp189 :reactors .REACTORS_ON
-    * set :enabled *tmp189
-    * set *tmp190 :block
-    * control enabled *tmp190 :enabled
+  604 op lessThanEq :enabled :reactors .REACTORS_ON
+  605 control enabled :block :enabled
   606 jump *label144 equal :enabled false
   607 sensor *tmp193 :block @timescale
   608 op add :boosts :boosts *tmp193
 
   615 jump *label147 equal *tmp187 @overdrive-dome
   616 jump *label146 always
   617 label *label147
-    * set *tmp194 :block
-    * control enabled *tmp194 .OVERDRIVE
+  618 control enabled :block .OVERDRIVE
   619 jump *label141 always
   620 label *label146
   621 jump *label149 equal *tmp187 @conduit
 
   627 jump *label149 equal *tmp187 @armored-conveyor
   628 jump *label148 always
   629 label *label149
-    * set *tmp196 :block
-    * control enabled *tmp196 :startup
+  630 control enabled :block :startup
   631 jump *label141 always
   632 label *label148
   633 label *label141
 
   647 jump *label151 always
   648 label *label150
   649 label *label151
-    * op min *tmp205 .REACTORS_ON :reactors
-    * set .REACTORS_ON *tmp205
+  650 op min .REACTORS_ON .REACTORS_ON :reactors
   651 op equal *tmp206 cell1 null
   652 jump *label152 equal *tmp206 false
   653 set .STARTUPS 0

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    79 set :nextStart 0
    80 op add :nextDecommit @time 6000
    81 label *label15
-    * jump *label17 equal true false
    82 sensor *tmp25 battery1 @totalPower
    83 op floor :battery_level *tmp25
    84 op idiv :battery_level_str :battery_level 1000

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-16 instructions):
 
    17 print :block
    18 print "\n"
    19 sensor *tmp5 :block @type
-    * jump *label8 equal *tmp5 @impact-reactor
-    * jump *label7 always
+   20 jump *label7 notEqual *tmp5 @impact-reactor
    21 label *label8
    22 set .START :n
    23 op add :reactors :reactors 1
 
    31 jump *label10 equal *tmp5 @conveyor
    32 jump *label10 equal *tmp5 @titanium-conveyor
    33 jump *label10 equal *tmp5 @plastanium-conveyor
-    * jump *label10 equal *tmp5 @armored-conveyor
-    * jump *label9 always
+   34 jump *label9 notEqual *tmp5 @armored-conveyor
    35 label *label10
    36 set .START :n
    37 jump *label6 always
 
   124 set :failure2 *tmp52
   125 jump *label29 notEqual :failure1 false
   126 label *label30
-    * jump *label29 notEqual :failure2 false
-    * jump *label27 always
+  127 jump *label27 equal :failure2 false
   128 label *label29
   129 op add :failure_cnt :failure_cnt 1
   130 read *tmp54 cell2 1
 
   150 jump *label19 always
   151 label *label18
   152 label *label19
-    * jump *label35 equal .MODE 0
-    * jump *label34 always
+  153 jump *label34 notEqual .MODE 0
   154 label *label35
   155 set *tmp59 "[salmon]SHUTDOWN[]"
   156 jump *label33 always
   157 label *label34
-    * jump *label37 equal .MODE 1
-    * jump *label36 always
+  158 jump *label36 notEqual .MODE 1
   159 label *label37
   160 set *tmp59 "[gold]STARTUP[]"
   161 jump *label33 always
   162 label *label36
-    * jump *label39 equal .MODE 2
-    * jump *label38 always
+  163 jump *label38 notEqual .MODE 2
   164 label *label39
   165 set *tmp59 "[green]RUNNING[]"
   166 jump *label33 always
 
   238 print :net_power
   239 print "["
   240 print "]"
-    * jump *label50 equal .MODE 0
-    * jump *label49 always
+  241 jump *label49 notEqual .MODE 0
   242 label *label50
   243 set .REACTORS_ON 0
   244 set .OVERDRIVE 0
 
   263 label *label52
   264 jump *label48 always
   265 label *label49
-    * jump *label54 equal .MODE 1
-    * jump *label53 always
+  266 jump *label53 notEqual .MODE 1
   267 label *label54
   268 jump *label55 equal .OUTPUT_1 false
   269 set *tmp82 battery3
 
   390 label *label58
   391 jump *label48 always
   392 label *label53
-    * jump *label88 equal .MODE 2
-    * jump *label87 always
+  393 jump *label87 notEqual .MODE 2
   394 label *label88
   395 jump *label89 equal .COOLANT_FLAG false
   396 label *label92
 
   422 label *label100
   423 sensor *tmp130 tank1 @totalLiquids
   424 op greaterThan *tmp131 *tmp130 1000
-    * jump *label99 notEqual *tmp131 false
-    * jump *label97 always
+  425 jump *label97 equal *tmp131 false
   426 label *label99
   427 set *tmp132 true
   428 jump *label98 always
 
   434 label *label104
   435 sensor *tmp133 vault1 @blast-compound
   436 op greaterThan *tmp134 *tmp133 800
-    * jump *label103 notEqual *tmp134 false
-    * jump *label101 always
+  437 jump *label101 equal *tmp134 false
   438 label *label103
   439 set *tmp135 true
   440 jump *label102 always
 
   487 label *label119
   488 op mul *tmp154 .REACTORS_ON -2500
   489 op lessThan *tmp155 :battery_change *tmp154
-    * jump *label118 notEqual *tmp155 false
-    * jump *label116 always
+  490 jump *label116 equal *tmp155 false
   491 label *label118
   492 op equal *tmp157 .OVERDRIVE false
   493 op add .RESETS .RESETS *tmp157
 
   500 jump *label122 notEqual *tmp159 false
   501 label *label123
   502 op lessThan *tmp160 :battery_change -100
-    * jump *label122 notEqual *tmp160 false
-    * jump *label120 always
+  503 jump *label120 equal *tmp160 false
   504 label *label122
   505 op add :nextDecommit @time 6000
   506 jump *label121 always
 
   583 jump *label140 greaterThanEq :n @links
   584 getlink :block :n
   585 sensor *tmp187 :block @type
-    * jump *label143 equal *tmp187 @impact-reactor
-    * jump *label142 always
+  586 jump *label142 notEqual *tmp187 @impact-reactor
   587 label *label143
   588 op add :reactors :reactors 1
   589 op lessThanEq :enabled :reactors .REACTORS_ON
 
   597 jump *label141 always
   598 label *label142
   599 jump *label147 equal *tmp187 @overdrive-projector
-    * jump *label147 equal *tmp187 @overdrive-dome
-    * jump *label146 always
+  600 jump *label146 notEqual *tmp187 @overdrive-dome
   601 label *label147
   602 control enabled :block .OVERDRIVE
   603 jump *label141 always
 
   608 jump *label149 equal *tmp187 @conveyor
   609 jump *label149 equal *tmp187 @titanium-conveyor
   610 jump *label149 equal *tmp187 @plastanium-conveyor
-    * jump *label149 equal *tmp187 @armored-conveyor
-    * jump *label148 always
+  611 jump *label148 notEqual *tmp187 @armored-conveyor
   612 label *label149
   613 control enabled :block :startup
   614 jump *label141 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-46 instructions):
 
     4 set .START null
     5 set :reactors 0
     6 label *label0
-    * op equal *tmp0 :reactors 0
-    * jump *label2 equal *tmp0 false
+    7 jump *label2 notEqual :reactors 0
     8 set :reactors 0
     9 set :n @links
    10 label *label3
-    * op greaterThan *tmp2 :n 0
-    * jump *label5 equal *tmp2 false
+   11 jump *label5 lessThanEq :n 0
    12 op sub :n :n 1
    13 getlink :block :n
    14 print "Found: "
 
    40 label *label5
    41 read *tmp7 cell2 1
    42 op add :reactors :reactors *tmp7
-    * op equal *tmp8 :reactors 0
-    * jump *label11 equal *tmp8 false
+   43 jump *label11 notEqual :reactors 0
    44 print "No reactor."
    45 jump *label12 always
    46 label *label11
 
    60 read .RESETS cell1 8
    61 read .COMMITS cell1 9
    62 set :reactors .REACTORS_ON
-    * op equal *tmp20 .MODE 0
-    * jump *label13 equal *tmp20 false
+   63 jump *label13 notEqual .MODE 0
    64 set .REASON "Processor reset"
    65 jump *label14 always
    66 label *label13
 
    90 op sub *tmp39 :required_capacity :total_capacity
    91 op div *tmp40 *tmp39 1000
    92 op ceil :missing_battery *tmp40
-    * op notEqual *tmp42 .MODE 0
-    * jump *label18 equal *tmp42 false
+   93 jump *label18 equal .MODE 0
    94 sensor *tmp44 switch1 @enabled
-    * op equal *tmp45 *tmp44 false
-    * jump *label20 equal *tmp45 false
+   95 jump *label20 notEqual *tmp44 false
    96 set .MODE 0
    97 set .REASON "Manual power off"
    98 jump *label21 always
    99 label *label20
   100 op mul :min_consumption .REACTORS_ON 1200
-    * op lessThan :failure1 :consumption :min_consumption
-    * op equal *tmp49 :battery_level 0
-    * jump *label22 equal *tmp49 false
+  101 jump *label22 notEqual :battery_level 0
   102 label *label26
-    * op greaterThan *tmp50 :consumption 0
-    * jump *label22 equal *tmp50 false
+  103 jump *label22 lessThanEq :consumption 0
   104 jump *label25 always
   105 label *label25
-    * op equal *tmp51 :production 0
-    * jump *label22 equal *tmp51 false
+  106 jump *label22 notEqual :production 0
   107 jump *label24 always
   108 label *label24
   109 set *tmp52 true
 
   112 set *tmp52 false
   113 label *label23
   114 set :failure2 *tmp52
-    * jump *label29 notEqual :failure1 false
+  115 jump *label29 lessThan :consumption :min_consumption
   116 label *label30
   117 jump *label27 equal :failure2 false
   118 label *label29
   119 op add :failure_cnt :failure_cnt 1
   120 read *tmp54 cell2 1
   121 op add *tmp55 10 *tmp54
-    * op greaterThan *tmp56 :failure_cnt *tmp55
-    * jump *label31 equal *tmp56 false
+  122 jump *label31 lessThanEq :failure_cnt *tmp55
   123 set .MODE 0
   124 control enabled switch1 false
   125 set .REASON "Unknown -- out of power?"
 
   179 label *label41
   180 print "\n=================================="
   181 sensor *tmp67 tank1 @totalLiquids
-    * op lessThan *tmp68 *tmp67 750
-    * jump *label42 equal *tmp68 false
+  182 jump *label42 greaterThanEq *tmp67 750
   183 print "\n[salmon]Cryofluid level critical![]"
   184 jump *label43 always
   185 label *label42
   186 label *label43
   187 sensor *tmp70 vault1 @blast-compound
-    * op lessThan *tmp71 *tmp70 700
-    * jump *label44 equal *tmp71 false
+  188 jump *label44 greaterThanEq *tmp70 700
   189 print "\n[salmon]Blast compound level critical![]"
   190 jump *label45 always
   191 label *label44
   192 label *label45
-    * op equal *tmp73 :enough_battery false
-    * jump *label46 equal *tmp73 false
+  193 jump *label46 notEqual :enough_battery false
   194 print "\n"
   195 print "[salmon]Insufficient battery storage![]"
   196 print "\n"
 
   262 op mul *tmp84 *tmp83 1.05
   263 op floor *tmp85 *tmp84
   264 op max :neededPower *tmp85 1000
-    * op equal *tmp87 .REACTORS_ON 0
-    * jump *label57 equal *tmp87 false
-    * op greaterThanEq *tmp89 :total_battery 25000
-    * jump *label59 equal *tmp89 false
+  265 jump *label57 notEqual .REACTORS_ON 0
+  266 jump *label59 lessThan :total_battery 25000
   267 set .REACTORS_ON 1
   268 op add :nextStart @time 2000
   269 jump *label60 always
 
   280 print :outputs
   281 print "["
   282 print "] surge tower(s) online"
-    * op equal *tmp93 .OUTPUT_2 0
-    * jump *label61 equal *tmp93 false
+  283 jump *label61 notEqual .OUTPUT_2 0
   284 print "\n"
   285 print "Required power level: [gold]"
   286 print :neededPower
 
   289 jump *label62 always
   290 label *label61
   291 label *label62
-    * op greaterThan *tmp95 :net_power 100
-    * jump *label63 equal *tmp95 false
+  292 jump *label63 lessThanEq :net_power 100
   293 set .OVERDRIVE true
   294 jump *label64 always
   295 label *label63
   296 label *label64
-    * op lessThan *tmp97 .REACTORS_ON :reactors
-    * jump *label65 equal *tmp97 false
+  297 jump *label65 greaterThanEq .REACTORS_ON :reactors
   298 label *label69
-    * op greaterThan *tmp98 :net_power 1000
-    * jump *label65 equal *tmp98 false
+  299 jump *label65 lessThanEq :net_power 1000
   300 jump *label68 always
   301 label *label68
-    * op greaterThanEq *tmp99 :total_battery 25000
-    * jump *label65 equal *tmp99 false
+  302 jump *label65 lessThan :total_battery 25000
   303 jump *label67 always
   304 label *label67
   305 set *tmp100 true
 
   308 set *tmp100 false
   309 label *label66
   310 set :canStart *tmp100
-    * op greaterThanEq *tmp101 :net_power :neededPower
-    * jump *label70 equal *tmp101 false
+  311 jump *label70 lessThan :net_power :neededPower
   312 set .OUTPUT_2 .OUTPUT_1
   313 set .OUTPUT_1 1
   314 jump *label71 always
   315 label *label70
   316 label *label71
-    * op equal *tmp103 .OUTPUT_1 0
-    * jump *label72 equal *tmp103 false
+  317 jump *label72 notEqual .OUTPUT_1 0
   318 op mul :availablePower 6300 :boosts
   319 op div :ratio :neededPower :availablePower
-    * op lessThan *tmp107 :ratio 1
-    * jump *label74 equal *tmp107 false
+  320 jump *label74 greaterThanEq :ratio 1
   321 op add :nextStart @time 2000
   322 jump *label75 always
   323 label *label74
 
   327 label *label73
   328 jump *label76 equal :canStart false
   329 label *label79
-    * op greaterThan *tmp110 @time :nextStart
-    * jump *label76 equal *tmp110 false
+  330 jump *label76 lessThanEq @time :nextStart
   331 jump *label78 always
   332 label *label78
   333 jump *label80 equal FAST_START false
 
   343 jump *label77 always
   344 label *label76
   345 label *label77
-    * op greaterThanEq *tmp117 .REACTORS_ON :reactors
-    * jump *label82 equal *tmp117 false
+  346 jump *label82 lessThan .REACTORS_ON :reactors
   347 label *label86
-    * op greaterThan *tmp118 @time :nextStart
-    * jump *label82 equal *tmp118 false
+  348 jump *label82 lessThanEq @time :nextStart
   349 jump *label85 always
   350 label *label85
-    * op greaterThan *tmp119 .OUTPUT_2 0
-    * jump *label82 equal *tmp119 false
+  351 jump *label82 lessThanEq .OUTPUT_2 0
   352 jump *label84 always
   353 label *label84
   354 set .MODE 2
 
   367 jump *label89 equal .COOLANT_FLAG false
   368 label *label92
   369 sensor *tmp122 tank1 @totalLiquids
-    * op lessThan *tmp123 *tmp122 750
-    * jump *label89 equal *tmp123 false
+  370 jump *label89 greaterThanEq *tmp122 750
   371 jump *label91 always
   372 label *label91
   373 set .MODE 0
 
   379 jump *label93 equal .FUEL_FLAG false
   380 label *label96
   381 sensor *tmp126 vault1 @blast-compound
-    * op lessThan *tmp127 *tmp126 700
-    * jump *label93 equal *tmp127 false
+  382 jump *label93 greaterThanEq *tmp126 700
   383 jump *label95 always
   384 label *label95
   385 set .MODE 0
 
   391 jump *label99 notEqual .COOLANT_FLAG false
   392 label *label100
   393 sensor *tmp130 tank1 @totalLiquids
-    * op greaterThan *tmp131 *tmp130 1000
-    * jump *label97 equal *tmp131 false
+  394 jump *label97 lessThanEq *tmp130 1000
   395 label *label99
   396 set *tmp132 true
   397 jump *label98 always
 
   402 jump *label103 notEqual .FUEL_FLAG false
   403 label *label104
   404 sensor *tmp133 vault1 @blast-compound
-    * op greaterThan *tmp134 *tmp133 800
-    * jump *label101 equal *tmp134 false
+  405 jump *label101 lessThanEq *tmp133 800
   406 label *label103
   407 set *tmp135 true
   408 jump *label102 always
 
   420 set :commit_level 0
   421 jump *label109 equal .CAN_COMMIT false
   422 label *label113
-    * op lessThan *tmp139 :battery_change 0
-    * jump *label109 equal *tmp139 false
+  423 jump *label109 greaterThanEq :battery_change 0
   424 jump *label112 always
   425 label *label112
-    * op lessThan *tmp140 .REACTORS_ON :reactors
-    * jump *label109 equal *tmp140 false
+  426 jump *label109 greaterThanEq .REACTORS_ON :reactors
   427 jump *label111 always
   428 label *label111
   429 op sub *tmp142 :battery_change 1500
 
   439 jump *label110 always
   440 label *label109
   441 label *label110
-    * op equal *tmp150 :commit_level 0
-    * jump *label114 equal *tmp150 false
+  442 jump *label114 notEqual :commit_level 0
   443 op idiv *tmp152 :min_level 1000
   444 print "\nRestart threshold: [gold]"
   445 print *tmp152
 
   447 label *label114
   448 label *label115
   449 print "[] K"
-    * op lessThan *tmp153 :total_battery :min_level
-    * jump *label118 notEqual *tmp153 false
+  450 jump *label118 lessThan :total_battery :min_level
   451 label *label119
   452 op mul *tmp154 .REACTORS_ON -2500
-    * op lessThan *tmp155 :battery_change *tmp154
-    * jump *label116 equal *tmp155 false
+  453 jump *label116 greaterThanEq :battery_change *tmp154
   454 label *label118
   455 op equal *tmp157 .OVERDRIVE false
   456 op add .RESETS .RESETS *tmp157
 
   459 op add :nextDecommit @time 6000
   460 jump *label117 always
   461 label *label116
-    * op lessThan *tmp159 :battery_level 47500
-    * jump *label122 notEqual *tmp159 false
+  462 jump *label122 lessThan :battery_level 47500
   463 label *label123
-    * op lessThan *tmp160 :battery_change -100
-    * jump *label120 equal *tmp160 false
+  464 jump *label120 greaterThanEq :battery_change -100
   465 label *label122
   466 op add :nextDecommit @time 6000
   467 jump *label121 always
   468 label *label120
   469 label *label121
-    * op greaterThan *tmp163 @time :nextDecommit
-    * jump *label124 equal *tmp163 false
+  470 jump *label124 lessThanEq @time :nextDecommit
   471 jump *label126 equal .OVERDRIVE false
   472 set .OVERDRIVE false
   473 jump *label127 always
 
   479 op add :nextDecommit @time 6000
   480 jump *label125 always
   481 label *label124
-    * op lessThan *tmp169 :total_battery :commit_level
-    * jump *label128 equal *tmp169 false
+  482 jump *label128 greaterThanEq :total_battery :commit_level
   483 op add .REACTORS_ON .REACTORS_ON 1
   484 op add .COMMITS .COMMITS 1
   485 set .CAN_COMMIT false
 
   501 set .OVERDRIVE true
   502 label *label106
   503 op mul *tmp173 PLANT_PROTECTION 47500
-    * op lessThan *tmp174 :total_battery *tmp173
-    * jump *label132 equal *tmp174 false
+  504 jump *label132 greaterThanEq :total_battery *tmp173
   505 set .OUTPUT_2 0
   506 jump *label133 always
   507 label *label132
   508 label *label133
-    * op equal *tmp176 .OUTPUT_2 0
-    * jump *label134 equal *tmp176 false
-    * op greaterThan *tmp178 :total_battery 47500
-    * jump *label136 equal *tmp178 false
+  509 jump *label134 notEqual .OUTPUT_2 0
+  510 jump *label136 lessThanEq :total_battery 47500
   511 set .OUTPUT_2 1
   512 jump *label137 always
   513 label *label136
 
   574 op add :n :n 1
   575 jump *label138 always
   576 label *label140
-    * op notEqual *tmp198 cell2 null
-    * jump *label150 equal *tmp198 false
+  577 jump *label150 equal cell2 null
   578 write :reactors cell2 0
   579 write .REACTORS_ON cell2 2
   580 write .OVERDRIVE cell2 3
 
   586 label *label150
   587 label *label151
   588 op min .REACTORS_ON .REACTORS_ON :reactors
-    * op equal *tmp206 cell1 null
-    * jump *label152 equal *tmp206 false
+  589 jump *label152 notEqual cell1 null
   590 set .STARTUPS 0
   591 set .RESETS 0
   592 set .COMMITS 0

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-40 instructions):
 
    32 jump *label9 notEqual *tmp5 @armored-conveyor
    33 label *label10
    34 set .START :n
-    * jump *label6 always
    35 label *label9
    36 label *label6
    37 label *label4
 
    41 op add :reactors :reactors *tmp7
    42 jump *label11 notEqual :reactors 0
    43 print "No reactor."
-    * jump *label12 always
    44 label *label11
    45 label *label12
    46 printflush message1
 
    99 jump *label22 notEqual :battery_level 0
   100 label *label26
   101 jump *label22 lessThanEq :consumption 0
-    * jump *label25 always
   102 label *label25
   103 jump *label22 notEqual :production 0
-    * jump *label24 always
   104 label *label24
   105 set *tmp52 true
   106 jump *label23 always
 
   124 print "\nMin. consumption: "
   125 print :min_consumption
   126 printflush message2
-    * jump *label32 always
   127 label *label31
   128 label *label32
   129 jump *label28 always
 
   131 set :failure_cnt 0
   132 label *label28
   133 label *label21
-    * jump *label19 always
   134 label *label18
   135 label *label19
   136 jump *label34 notEqual .MODE 0
 
   168 print " ([gold]"
   169 print :multiplier
   170 print "x[])"
-    * jump *label41 always
   171 label *label40
   172 label *label41
   173 print "\n=================================="
   174 sensor *tmp67 tank1 @totalLiquids
   175 jump *label42 greaterThanEq *tmp67 750
   176 print "\n[salmon]Cryofluid level critical![]"
-    * jump *label43 always
   177 label *label42
   178 label *label43
   179 sensor *tmp70 vault1 @blast-compound
   180 jump *label44 greaterThanEq *tmp70 700
   181 print "\n[salmon]Blast compound level critical![]"
-    * jump *label45 always
   182 label *label44
   183 label *label45
   184 jump *label46 notEqual :enough_battery false
 
   189 print :missing_battery
   190 print " "
   191 print "K[] of additional storage to internal battery."
-    * jump *label47 always
   192 label *label46
   193 label *label47
   194 print "\n"
 
   234 set :failure_cnt 0
   235 set .GENERATOR true
   236 set .REASON "Unknown -- out of power?"
-    * jump *label52 always
   237 label *label51
   238 label *label52
   239 jump *label48 always
 
   275 print :neededPower
   276 print "["
   277 print "]"
-    * jump *label62 always
   278 label *label61
   279 label *label62
   280 jump *label63 lessThanEq :net_power 100
   281 set .OVERDRIVE true
-    * jump *label64 always
   282 label *label63
   283 label *label64
   284 jump *label65 greaterThanEq .REACTORS_ON :reactors
   285 label *label69
   286 jump *label65 lessThanEq :net_power 1000
-    * jump *label68 always
   287 label *label68
   288 jump *label65 lessThan :total_battery 25000
-    * jump *label67 always
   289 label *label67
   290 set *tmp100 true
   291 jump *label66 always
 
   296 jump *label70 lessThan :net_power :neededPower
   297 set .OUTPUT_2 .OUTPUT_1
   298 set .OUTPUT_1 1
-    * jump *label71 always
   299 label *label70
   300 label *label71
   301 jump *label72 notEqual .OUTPUT_1 0
 
   303 op div :ratio :neededPower :availablePower
   304 jump *label74 greaterThanEq :ratio 1
   305 op add :nextStart @time 2000
-    * jump *label75 always
   306 label *label74
   307 label *label75
-    * jump *label73 always
   308 label *label72
   309 label *label73
   310 jump *label76 equal :canStart false
   311 label *label79
   312 jump *label76 lessThanEq @time :nextStart
-    * jump *label78 always
   313 label *label78
   314 jump *label80 equal FAST_START false
   315 op idiv *tmp112 :total_battery 25000
 
   321 op add *tmp114 .REACTORS_ON :start_at_once
   322 op min .REACTORS_ON *tmp114 :reactors
   323 op add :nextStart @time 2000
-    * jump *label77 always
   324 label *label76
   325 label *label77
   326 jump *label82 lessThan .REACTORS_ON :reactors
   327 label *label86
   328 jump *label82 lessThanEq @time :nextStart
-    * jump *label85 always
   329 label *label85
   330 jump *label82 lessThanEq .OUTPUT_2 0
-    * jump *label84 always
   331 label *label84
   332 set .MODE 2
   333 op add :nextDecommit @time 6000
   334 set .COOLANT_FLAG 0
   335 set .FUEL_FLAG 0
   336 set .GENERATOR false
-    * jump *label83 always
   337 label *label82
   338 label *label83
   339 label *label58
 
   345 label *label92
   346 sensor *tmp122 tank1 @totalLiquids
   347 jump *label89 greaterThanEq *tmp122 750
-    * jump *label91 always
   348 label *label91
   349 set .MODE 0
   350 control enabled switch1 false
   351 set .REASON "Cryo level too low"
-    * jump *label90 always
   352 label *label89
   353 label *label90
   354 jump *label93 equal .FUEL_FLAG false
   355 label *label96
   356 sensor *tmp126 vault1 @blast-compound
   357 jump *label93 greaterThanEq *tmp126 700
-    * jump *label95 always
   358 label *label95
   359 set .MODE 0
   360 control enabled switch1 false
   361 set .REASON "Blast compound level too low"
-    * jump *label94 always
   362 label *label93
   363 label *label94
   364 jump *label99 notEqual .COOLANT_FLAG false
 
   387 label *label108
   388 sensor *tmp136 switch2 @enabled
   389 jump *label105 equal *tmp136 false
-    * jump *label107 always
   390 label *label107
   391 op mul :min_level 0.5 :required_capacity
   392 set :commit_level 0
   393 jump *label109 equal .CAN_COMMIT false
   394 label *label113
   395 jump *label109 greaterThanEq :battery_change 0
-    * jump *label112 always
   396 label *label112
   397 jump *label109 greaterThanEq .REACTORS_ON :reactors
-    * jump *label111 always
   398 label *label111
   399 op sub *tmp142 :battery_change 1500
   400 op sub :p *tmp142 1000
 
   406 op idiv *tmp149 :commit_level 1000
   407 print "\nCommit threshold:   [gold]"
   408 print *tmp149
-    * jump *label110 always
   409 label *label109
   410 label *label110
   411 jump *label114 notEqual :commit_level 0
   412 op idiv *tmp152 :min_level 1000
   413 print "\nRestart threshold: [gold]"
   414 print *tmp152
-    * jump *label115 always
   415 label *label114
   416 label *label115
   417 print "[] K"
 
   432 jump *label120 greaterThanEq :battery_change -100
   433 label *label122
   434 op add :nextDecommit @time 6000
-    * jump *label121 always
   435 label *label120
   436 label *label121
   437 jump *label124 lessThanEq @time :nextDecommit
 
   450 op add .REACTORS_ON .REACTORS_ON 1
   451 op add .COMMITS .COMMITS 1
   452 set .CAN_COMMIT false
-    * jump *label129 always
   453 label *label128
   454 label *label129
   455 label *label125
 
   469 op mul *tmp173 PLANT_PROTECTION 47500
   470 jump *label132 greaterThanEq :total_battery *tmp173
   471 set .OUTPUT_2 0
-    * jump *label133 always
   472 label *label132
   473 label *label133
   474 jump *label134 notEqual .OUTPUT_2 0
 
   478 label *label136
   479 print "\n*** [gold]Surge tower 2 offline[] ***"
   480 label *label137
-    * jump *label135 always
   481 label *label134
   482 label *label135
-    * jump *label48 always
   483 label *label87
   484 label *label48
   485 print "\n"
 
   510 jump *label144 equal :enabled false
   511 sensor *tmp193 :block @timescale
   512 op add :boosts :boosts *tmp193
-    * jump *label145 always
   513 label *label144
   514 label *label145
   515 jump *label141 always
 
   529 jump *label148 notEqual *tmp187 @armored-conveyor
   530 label *label149
   531 control enabled :block :startup
-    * jump *label141 always
   532 label *label148
   533 label *label141
   534 label *label139
 
   543 op add :reactors :reactors *tmp203
   544 read *tmp204 cell2 4
   545 op add :boosts :boosts *tmp204
-    * jump *label151 always
   546 label *label150
   547 label *label151
   548 op min .REACTORS_ON .REACTORS_ON :reactors

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   248 label *label56
   249 set :nextBattery *tmp82
   250 sensor *tmp83 :nextBattery @powerNetOut
-    * op mul *tmp84 *tmp83 1.05
-    * op floor *tmp85 *tmp84
+  251 op idiv *tmp85 *tmp83 0.9523809523809523
   252 op max :neededPower *tmp85 1000
   253 jump *label57 notEqual .REACTORS_ON 0
   254 jump *label59 lessThan :total_battery 25000

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
   110 set :failure2 *tmp52
   111 jump *label29 lessThan :consumption :min_consumption
   112 label *label30
-    * jump *label27 equal :failure2 false
+  113 jump *label27 equal *tmp52 false
   114 label *label29
   115 op add :failure_cnt :failure_cnt 1
   116 read *tmp54 cell2 1
 
   151 set *tmp59 null
   152 label *label33
   153 set .STR_MODE *tmp59
-    * print .STR_MODE
+  154 print *tmp59
   155 print ","
   156 print " reactors [green]"
   157 print .REACTORS_ON
 
   247 set *tmp82 battery2
   248 label *label56
   249 set :nextBattery *tmp82
-    * sensor *tmp83 :nextBattery @powerNetOut
+  250 sensor *tmp83 *tmp82 @powerNetOut
   251 op idiv *tmp85 *tmp83 0.9523809523809523
   252 op max :neededPower *tmp85 1000
   253 jump *label57 notEqual .REACTORS_ON 0
 
   306 label *label75
   307 label *label72
   308 label *label73
-    * jump *label76 equal :canStart false
+  309 jump *label76 equal *tmp100 false
   310 label *label79
   311 jump *label76 lessThanEq @time :nextStart
   312 label *label78
 
   317 set *tmp112 1
   318 label *label81
   319 set :start_at_once *tmp112
-    * op add *tmp114 .REACTORS_ON :start_at_once
+  320 op add *tmp114 .REACTORS_ON *tmp112
   321 op min .REACTORS_ON *tmp114 :reactors
   322 op add :nextStart @time 2000
   323 label *label76
 
   387 sensor *tmp136 switch2 @enabled
   388 jump *label105 equal *tmp136 false
   389 label *label107
-    * op mul :min_level 0.5 :required_capacity
+  390 op mul :min_level :reactors 50000
   391 set :commit_level 0
   392 jump *label109 equal .CAN_COMMIT false
   393 label *label113
 
   396 jump *label109 greaterThanEq .REACTORS_ON :reactors
   397 label *label111
   398 op sub *tmp142 :battery_change 1500
-    * op sub :p *tmp142 1000
+  399 op sub :p :battery_change 2500
   400 op mul *tmp144 :p 0.00472972972972973
   401 op add *tmp145 -5 *tmp144
   402 op mul *tmp146 :p *tmp145
 
   495 op equal :startup .MODE 1
   496 set :reactors 0
   497 set :boosts 0
-    * set :enabled true
   498 set :n .START
   499 label *label138
   500 jump *label140 greaterThanEq :n @links

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-6 instructions):
 
   107 label *label22
   108 set *tmp52 false
   109 label *label23
-    * set :failure2 *tmp52
   110 jump *label29 lessThan :consumption :min_consumption
   111 label *label30
   112 jump *label27 equal *tmp52 false
 
   149 label *label38
   150 set *tmp59 null
   151 label *label33
-    * set .STR_MODE *tmp59
   152 print *tmp59
   153 print ","
   154 print " reactors [green]"
 
   244 label *label55
   245 set *tmp82 battery2
   246 label *label56
-    * set :nextBattery *tmp82
   247 sensor *tmp83 *tmp82 @powerNetOut
   248 op idiv *tmp85 *tmp83 0.9523809523809523
   249 op max :neededPower *tmp85 1000
 
   288 label *label65
   289 set *tmp100 false
   290 label *label66
-    * set :canStart *tmp100
   291 jump *label70 lessThan :net_power :neededPower
   292 set .OUTPUT_2 .OUTPUT_1
   293 set .OUTPUT_1 1
 
   312 label *label80
   313 set *tmp112 1
   314 label *label81
-    * set :start_at_once *tmp112
   315 op add *tmp114 .REACTORS_ON *tmp112
   316 op min .REACTORS_ON *tmp114 :reactors
   317 op add :nextStart @time 2000
 
   390 label *label112
   391 jump *label109 greaterThanEq .REACTORS_ON :reactors
   392 label *label111
-    * op sub *tmp142 :battery_change 1500
   393 op sub :p :battery_change 2500
   394 op mul *tmp144 :p 0.00472972972972973
   395 op add *tmp145 -5 *tmp144

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1 (-1 instructions):
 
     4 set .START null
     5 set :reactors 0
     6 label *label0
-    * jump *label2 notEqual :reactors 0
+    7 label *label154
     8 set :reactors 0
     9 set :n @links
    10 label *label3
    11 jump *label5 lessThanEq :n 0
+   12 label *label155
    13 op sub :n :n 1
    14 getlink :block :n
    15 print "Found: "
 
    36 label *label9
    37 label *label6
    38 label *label4
-    * jump *label3 always
+   39 jump *label155 greaterThan :n 0
    40 label *label5
    41 read *tmp7 cell2 1
    42 op add :reactors :reactors *tmp7
 
    46 label *label12
    47 printflush message1
    48 label *label1
-    * jump *label0 always
+   49 jump *label154 equal :reactors 0
    50 label *label2
    51 read .MODE cell1 0
    52 read .OUTPUT_1 cell1 1
 
   493 set :n .START
   494 label *label138
   495 jump *label140 greaterThanEq :n @links
+  496 label *label156
   497 getlink :block :n
   498 sensor *tmp187 :block @type
   499 jump *label142 notEqual *tmp187 @impact-reactor
 
   527 label *label141
   528 label *label139
   529 op add :n :n 1
-    * jump *label138 always
+  530 jump *label156 lessThan :n @links
   531 label *label140
   532 jump *label150 equal cell2 null
   533 write :reactors cell2 0

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-4 instructions):
 
    98 label *label20
    99 op mul :min_consumption .REACTORS_ON 1200
   100 jump *label22 notEqual :battery_level 0
-    * label *label26
   101 jump *label22 lessThanEq :consumption 0
-    * label *label25
-    * jump *label22 notEqual :production 0
-    * label *label24
-    * set *tmp52 true
+  102 op equal *tmp52 :production 0
   103 jump *label23 always
   104 label *label22
   105 set *tmp52 false
   106 label *label23
   107 jump *label29 lessThan :consumption :min_consumption
-    * label *label30
   108 jump *label27 equal *tmp52 false
   109 label *label29
   110 op add :failure_cnt :failure_cnt 1
 
   274 label *label63
   275 label *label64
   276 jump *label65 greaterThanEq .REACTORS_ON :reactors
-    * label *label69
   277 jump *label65 lessThanEq :net_power 1000
-    * label *label68
-    * jump *label65 lessThan :total_battery 25000
-    * label *label67
-    * set *tmp100 true
+  278 op greaterThanEq *tmp100 :total_battery 25000
   279 jump *label66 always
   280 label *label65
   281 set *tmp100 false
 
   295 label *label72
   296 label *label73
   297 jump *label76 equal *tmp100 false
-    * label *label79
   298 jump *label76 lessThanEq @time :nextStart
-    * label *label78
   299 jump *label80 equal FAST_START false
   300 op idiv *tmp112 :total_battery 25000
   301 jump *label81 always
 
   308 label *label76
   309 label *label77
   310 jump *label82 lessThan .REACTORS_ON :reactors
-    * label *label86
   311 jump *label82 lessThanEq @time :nextStart
-    * label *label85
   312 jump *label82 lessThanEq .OUTPUT_2 0
-    * label *label84
   313 set .MODE 2
   314 op add :nextDecommit @time 6000
   315 set .COOLANT_FLAG 0
 
   323 jump *label87 notEqual .MODE 2
   324 label *label88
   325 jump *label89 equal .COOLANT_FLAG false
-    * label *label92
   326 sensor *tmp122 tank1 @totalLiquids
   327 jump *label89 greaterThanEq *tmp122 750
-    * label *label91
   328 set .MODE 0
   329 control enabled switch1 false
   330 set .REASON "Cryo level too low"
   331 label *label89
   332 label *label90
   333 jump *label93 equal .FUEL_FLAG false
-    * label *label96
   334 sensor *tmp126 vault1 @blast-compound
   335 jump *label93 greaterThanEq *tmp126 700
-    * label *label95
   336 set .MODE 0
   337 control enabled switch1 false
   338 set .REASON "Blast compound level too low"
   339 label *label93
   340 label *label94
-    * jump *label99 notEqual .COOLANT_FLAG false
-    * label *label100
-    * sensor *tmp130 tank1 @totalLiquids
-    * jump *label97 lessThanEq *tmp130 1000
+  341 jump *label97 equal .COOLANT_FLAG false
   342 label *label99
   343 set *tmp132 true
   344 jump *label98 always
   345 label *label97
-    * set *tmp132 false
+  346 sensor *tmp130 tank1 @totalLiquids
+  347 op greaterThan *tmp132 *tmp130 1000
   348 label *label98
   349 set .COOLANT_FLAG *tmp132
-    * jump *label103 notEqual .FUEL_FLAG false
-    * label *label104
-    * sensor *tmp133 vault1 @blast-compound
-    * jump *label101 lessThanEq *tmp133 800
+  350 jump *label101 equal .FUEL_FLAG false
   351 label *label103
   352 set *tmp135 true
   353 jump *label102 always
   354 label *label101
-    * set *tmp135 false
+  355 sensor *tmp133 vault1 @blast-compound
+  356 op greaterThan *tmp135 *tmp133 800
   357 label *label102
   358 set .FUEL_FLAG *tmp135
   359 jump *label105 equal :enough_battery false
-    * label *label108
   360 sensor *tmp136 switch2 @enabled
   361 jump *label105 equal *tmp136 false
-    * label *label107
   362 op mul :min_level :reactors 50000
   363 set :commit_level 0
   364 jump *label109 equal .CAN_COMMIT false
-    * label *label113
   365 jump *label109 greaterThanEq :battery_change 0
-    * label *label112
   366 jump *label109 greaterThanEq .REACTORS_ON :reactors
-    * label *label111
   367 op sub :p :battery_change 2500
   368 op mul *tmp144 :p 0.00472972972972973
   369 op add *tmp145 -5 *tmp144
 
   383 label *label115
   384 print "[] K"
   385 jump *label118 lessThan :total_battery :min_level
-    * label *label119
   386 op mul *tmp154 .REACTORS_ON -2500
   387 jump *label116 greaterThanEq :battery_change *tmp154
   388 label *label118
 
   394 jump *label117 always
   395 label *label116
   396 jump *label122 lessThan :battery_level 47500
-    * label *label123
   397 jump *label120 greaterThanEq :battery_change -100
   398 label *label122
   399 op add :nextDecommit @time 6000

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
    59 read .RESETS cell1 8
    60 read .COMMITS cell1 9
    61 set :reactors .REACTORS_ON
-    * jump *label13 notEqual .MODE 0
+   62 set .REASON "Reason unknown -- out of power?"
+   63 jump *label14 notEqual .MODE 0
    64 set .REASON "Processor reset"
    65 jump *label14 always
-    * label *label13
-    * set .REASON "Reason unknown -- out of power?"
    66 label *label14
    67 op notEqual *tmp23 .MODE 0
    68 control enabled switch1 *tmp23
 
    96 jump *label21 always
    97 label *label20
    98 op mul :min_consumption .REACTORS_ON 1200
-    * jump *label22 notEqual :battery_level 0
-    * jump *label22 lessThanEq :consumption 0
+   99 set *tmp52 false
+  100 jump *label23 notEqual :battery_level 0
+  101 jump *label23 lessThanEq :consumption 0
   102 op equal *tmp52 :production 0
   103 jump *label23 always
-    * label *label22
-    * set *tmp52 false
   104 label *label23
   105 jump *label29 lessThan :consumption :min_consumption
   106 jump *label27 equal *tmp52 false
 
   233 jump *label53 notEqual .MODE 1
   234 label *label54
   235 jump *label55 equal .OUTPUT_1 false
-    * set *tmp82 battery3
+  236 sensor *tmp83 battery3 @powerNetOut
   237 jump *label56 always
   238 label *label55
-    * set *tmp82 battery2
+  239 sensor *tmp83 battery2 @powerNetOut
   240 label *label56
-    * sensor *tmp83 *tmp82 @powerNetOut
   241 op idiv *tmp85 *tmp83 0.9523809523809523
   242 op max :neededPower *tmp85 1000
   243 jump *label57 notEqual .REACTORS_ON 0
 
   270 set .OVERDRIVE true
   271 label *label63
   272 label *label64
-    * jump *label65 greaterThanEq .REACTORS_ON :reactors
-    * jump *label65 lessThanEq :net_power 1000
+  273 set *tmp100 false
+  274 jump *label66 greaterThanEq .REACTORS_ON :reactors
+  275 jump *label66 lessThanEq :net_power 1000
   276 op greaterThanEq *tmp100 :total_battery 25000
   277 jump *label66 always
-    * label *label65
-    * set *tmp100 false
   278 label *label66
   279 jump *label70 lessThan :net_power :neededPower
   280 set .OUTPUT_2 .OUTPUT_1
 
   292 label *label73
   293 jump *label76 equal *tmp100 false
   294 jump *label76 lessThanEq @time :nextStart
-    * jump *label80 equal FAST_START false
+  295 set *tmp112 1
+  296 jump *label81 equal FAST_START false
   297 op idiv *tmp112 :total_battery 25000
   298 jump *label81 always
-    * label *label80
-    * set *tmp112 1
   299 label *label81
   300 op add *tmp114 .REACTORS_ON *tmp112
   301 op min .REACTORS_ON *tmp114 :reactors
 
   334 label *label93
   335 label *label94
   336 jump *label97 equal .COOLANT_FLAG false
-    * set *tmp132 true
+  337 set .COOLANT_FLAG true
   338 jump *label98 always
   339 label *label97
   340 sensor *tmp130 tank1 @totalLiquids
-    * op greaterThan *tmp132 *tmp130 1000
+  341 op greaterThan .COOLANT_FLAG *tmp130 1000
   342 label *label98
-    * set .COOLANT_FLAG *tmp132
   343 jump *label101 equal .FUEL_FLAG false
-    * set *tmp135 true
+  344 set .FUEL_FLAG true
   345 jump *label102 always
   346 label *label101
   347 sensor *tmp133 vault1 @blast-compound
-    * op greaterThan *tmp135 *tmp133 800
+  348 op greaterThan .FUEL_FLAG *tmp133 800
   349 label *label102
-    * set .FUEL_FLAG *tmp135
   350 jump *label105 equal :enough_battery false
   351 sensor *tmp136 switch2 @enabled
   352 jump *label105 equal *tmp136 false

Modifications by Convert case at line 420:9 (segments: 1, padded low) (+75 instructions):
 
   458 label *label156
   459 getlink :block :n
   460 sensor *tmp187 :block @type
-    * jump *label142 notEqual *tmp187 @impact-reactor
+  461 sensor *tmp208 *tmp187 @id
+  462 jump *label159 greaterThanEq *tmp208 83
+  463 multijump *label161 *tmp208 0 (m:*label160)
+  464 multilabel *label161 (m:*label160)
+  465 jump *label159 always
+  466 multilabel *label162 (m:*label160)
+  467 jump *label159 always
+  468 multilabel *label163 (m:*label160)
+  469 jump *label159 always
+  470 multilabel *label164 (m:*label160)
+  471 jump *label159 always
+  472 multilabel *label165 (m:*label160)
+  473 jump *label159 always
+  474 multilabel *label166 (m:*label160)
+  475 jump *label159 always
+  476 multilabel *label167 (m:*label160)
+  477 jump *label159 always
+  478 multilabel *label168 (m:*label160)
+  479 jump *label159 always
+  480 multilabel *label169 (m:*label160)
+  481 jump *label159 always
+  482 multilabel *label170 (m:*label160)
+  483 jump *label159 always
+  484 multilabel *label171 (m:*label160)
+  485 jump *label159 always
+  486 multilabel *label172 (m:*label160)
+  487 jump *label159 always
+  488 multilabel *label173 (m:*label160)
+  489 jump *label159 always
+  490 multilabel *label174 (m:*label160)
+  491 jump *label159 always
+  492 multilabel *label175 (m:*label160)
+  493 jump *label159 always
+  494 multilabel *label176 (m:*label160)
+  495 jump *label159 always
+  496 multilabel *label177 (m:*label160)
+  497 jump *label159 always
+  498 multilabel *label178 (m:*label160)
+  499 jump *label159 always
+  500 multilabel *label179 (m:*label160)
+  501 jump *label159 always
+  502 multilabel *label180 (m:*label160)
+  503 jump *label159 always
+  504 multilabel *label181 (m:*label160)
+  505 jump *label159 always
+  506 multilabel *label182 (m:*label160)
+  507 jump *label159 always
+  508 multilabel *label183 (m:*label160)
+  509 jump *label159 always
+  510 multilabel *label184 (m:*label160)
+  511 jump *label159 always
+  512 multilabel *label185 (m:*label160)
+  513 jump *label159 always
+  514 multilabel *label186 (m:*label160)
+  515 jump *label159 always
+  516 multilabel *label187 (m:*label160)
+  517 jump *label159 always
+  518 multilabel *label188 (m:*label160)
+  519 jump *label159 always
+  520 multilabel *label189 (m:*label160)
+  521 jump *label159 always
+  522 multilabel *label190 (m:*label160)
+  523 jump *label159 always
+  524 multilabel *label191 (m:*label160)
+  525 jump *label159 always
+  526 multilabel *label192 (m:*label160)
+  527 jump *label159 always
+  528 multilabel *label193 (m:*label160)
+  529 jump *label159 always
+  530 multilabel *label194 (m:*label160)
+  531 jump *label159 always
+  532 multilabel *label195 (m:*label160)
+  533 jump *label159 always
+  534 multilabel *label196 (m:*label160)
+  535 jump *label159 always
+  536 multilabel *label197 (m:*label160)
+  537 jump *label159 always
+  538 multilabel *label198 (m:*label160)
+  539 jump *label147 always
+  540 multilabel *label199 (m:*label160)
+  541 jump *label147 always
+  542 multilabel *label200 (m:*label160)
+  543 jump *label159 always
+  544 multilabel *label201 (m:*label160)
+  545 jump *label159 always
+  546 multilabel *label202 (m:*label160)
+  547 jump *label149 always
+  548 multilabel *label203 (m:*label160)
+  549 jump *label149 always
+  550 multilabel *label204 (m:*label160)
+  551 jump *label149 always
+  552 multilabel *label205 (m:*label160)
+  553 jump *label149 always
+  554 multilabel *label206 (m:*label160)
+  555 jump *label159 always
+  556 multilabel *label207 (m:*label160)
+  557 jump *label159 always
+  558 multilabel *label208 (m:*label160)
+  559 jump *label159 always
+  560 multilabel *label209 (m:*label160)
+  561 jump *label159 always
+  562 multilabel *label210 (m:*label160)
+  563 jump *label159 always
+  564 multilabel *label211 (m:*label160)
+  565 jump *label159 always
+  566 multilabel *label212 (m:*label160)
+  567 jump *label159 always
+  568 multilabel *label213 (m:*label160)
+  569 jump *label159 always
+  570 multilabel *label214 (m:*label160)
+  571 jump *label159 always
+  572 multilabel *label215 (m:*label160)
+  573 jump *label159 always
+  574 multilabel *label216 (m:*label160)
+  575 jump *label159 always
+  576 multilabel *label217 (m:*label160)
+  577 jump *label159 always
+  578 multilabel *label218 (m:*label160)
+  579 jump *label159 always
+  580 multilabel *label219 (m:*label160)
+  581 jump *label159 always
+  582 multilabel *label220 (m:*label160)
+  583 jump *label159 always
+  584 multilabel *label221 (m:*label160)
+  585 jump *label149 always
+  586 multilabel *label222 (m:*label160)
+  587 jump *label149 always
+  588 multilabel *label223 (m:*label160)
+  589 jump *label149 always
+  590 multilabel *label224 (m:*label160)
+  591 jump *label159 always
+  592 multilabel *label225 (m:*label160)
+  593 jump *label159 always
+  594 multilabel *label226 (m:*label160)
+  595 jump *label159 always
+  596 multilabel *label227 (m:*label160)
+  597 jump *label159 always
+  598 multilabel *label228 (m:*label160)
+  599 jump *label159 always
+  600 multilabel *label229 (m:*label160)
+  601 jump *label159 always
+  602 multilabel *label230 (m:*label160)
+  603 jump *label159 always
+  604 multilabel *label231 (m:*label160)
+  605 jump *label159 always
+  606 multilabel *label232 (m:*label160)
+  607 jump *label159 always
+  608 multilabel *label233 (m:*label160)
+  609 jump *label159 always
+  610 multilabel *label234 (m:*label160)
+  611 jump *label159 always
+  612 multilabel *label235 (m:*label160)
+  613 jump *label159 always
+  614 multilabel *label236 (m:*label160)
+  615 jump *label159 always
+  616 multilabel *label237 (m:*label160)
+  617 jump *label159 always
+  618 multilabel *label238 (m:*label160)
+  619 jump *label159 always
+  620 multilabel *label239 (m:*label160)
+  621 jump *label159 always
+  622 multilabel *label240 (m:*label160)
+  623 jump *label159 always
+  624 multilabel *label241 (m:*label160)
+  625 jump *label159 always
+  626 multilabel *label242 (m:*label160)
+  627 jump *label159 always
+  628 multilabel *label243 (m:*label160)
   629 label *label143
-    * op add :reactors :reactors 1
-    * op lessThanEq :enabled :reactors .REACTORS_ON
-    * control enabled :block :enabled
-    * jump *label144 equal :enabled false
-    * sensor *tmp193 :block @timescale
-    * op add :boosts :boosts *tmp193
-    * label *label144
-    * label *label145
-    * jump *label141 always
+  630 op add :reactors :reactors 1
+  631 op lessThanEq :enabled :reactors .REACTORS_ON
+  632 control enabled :block :enabled
+  633 jump *label244 equal :enabled false
+  634 sensor *tmp193 :block @timescale
+  635 op add :boosts :boosts *tmp193
+  636 label *label244
+  637 label *label245
+  638 jump *label141 always
   639 label *label142
-    * jump *label147 equal *tmp187 @overdrive-projector
-    * jump *label146 notEqual *tmp187 @overdrive-dome
   640 label *label147
   641 control enabled :block .OVERDRIVE
   642 jump *label141 always
   643 label *label146
-    * jump *label149 equal *tmp187 @conduit
-    * jump *label149 equal *tmp187 @pulse-conduit
-    * jump *label149 equal *tmp187 @plated-conduit
-    * jump *label149 equal *tmp187 @conveyor
-    * jump *label149 equal *tmp187 @titanium-conveyor
-    * jump *label149 equal *tmp187 @plastanium-conveyor
-    * jump *label148 notEqual *tmp187 @armored-conveyor
   644 label *label149
   645 control enabled :block :startup
   646 label *label148
+  647 label *label159
   648 label *label141
   649 label *label139
   650 op add :n :n 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
     2 set .COOLANT_FLAG null
     3 set .FUEL_FLAG null
     4 set .START null
-    * set :reactors 0
     5 label *label0
     6 label *label154
     7 set :reactors 0
 
   453 set :boosts 0
   454 set :n .START
   455 label *label138
-    * jump *label140 greaterThanEq :n @links
+  456 jump *label140 greaterThanEq .START @links
   457 label *label156
   458 getlink :block :n
   459 sensor *tmp187 :block @type

Modifications by Convert case at line 122:9 (segments: 1, padded low) (+75 instructions):
 
    15 print :block
    16 print "\n"
    17 sensor *tmp5 :block @type
-    * jump *label7 notEqual *tmp5 @impact-reactor
+   18 sensor *tmp209 *tmp5 @id
+   19 jump *label246 greaterThanEq *tmp209 83
+   20 multijump *label248 *tmp209 0 (m:*label247)
+   21 multilabel *label248 (m:*label247)
+   22 jump *label246 always
+   23 multilabel *label249 (m:*label247)
+   24 jump *label246 always
+   25 multilabel *label250 (m:*label247)
+   26 jump *label246 always
+   27 multilabel *label251 (m:*label247)
+   28 jump *label246 always
+   29 multilabel *label252 (m:*label247)
+   30 jump *label246 always
+   31 multilabel *label253 (m:*label247)
+   32 jump *label246 always
+   33 multilabel *label254 (m:*label247)
+   34 jump *label246 always
+   35 multilabel *label255 (m:*label247)
+   36 jump *label246 always
+   37 multilabel *label256 (m:*label247)
+   38 jump *label246 always
+   39 multilabel *label257 (m:*label247)
+   40 jump *label246 always
+   41 multilabel *label258 (m:*label247)
+   42 jump *label246 always
+   43 multilabel *label259 (m:*label247)
+   44 jump *label246 always
+   45 multilabel *label260 (m:*label247)
+   46 jump *label246 always
+   47 multilabel *label261 (m:*label247)
+   48 jump *label246 always
+   49 multilabel *label262 (m:*label247)
+   50 jump *label246 always
+   51 multilabel *label263 (m:*label247)
+   52 jump *label246 always
+   53 multilabel *label264 (m:*label247)
+   54 jump *label246 always
+   55 multilabel *label265 (m:*label247)
+   56 jump *label246 always
+   57 multilabel *label266 (m:*label247)
+   58 jump *label246 always
+   59 multilabel *label267 (m:*label247)
+   60 jump *label246 always
+   61 multilabel *label268 (m:*label247)
+   62 jump *label246 always
+   63 multilabel *label269 (m:*label247)
+   64 jump *label246 always
+   65 multilabel *label270 (m:*label247)
+   66 jump *label246 always
+   67 multilabel *label271 (m:*label247)
+   68 jump *label246 always
+   69 multilabel *label272 (m:*label247)
+   70 jump *label246 always
+   71 multilabel *label273 (m:*label247)
+   72 jump *label246 always
+   73 multilabel *label274 (m:*label247)
+   74 jump *label246 always
+   75 multilabel *label275 (m:*label247)
+   76 jump *label246 always
+   77 multilabel *label276 (m:*label247)
+   78 jump *label246 always
+   79 multilabel *label277 (m:*label247)
+   80 jump *label246 always
+   81 multilabel *label278 (m:*label247)
+   82 jump *label246 always
+   83 multilabel *label279 (m:*label247)
+   84 jump *label246 always
+   85 multilabel *label280 (m:*label247)
+   86 jump *label246 always
+   87 multilabel *label281 (m:*label247)
+   88 jump *label246 always
+   89 multilabel *label282 (m:*label247)
+   90 jump *label246 always
+   91 multilabel *label283 (m:*label247)
+   92 jump *label246 always
+   93 multilabel *label284 (m:*label247)
+   94 jump *label246 always
+   95 multilabel *label285 (m:*label247)
+   96 jump *label10 always
+   97 multilabel *label286 (m:*label247)
+   98 jump *label10 always
+   99 multilabel *label287 (m:*label247)
+  100 jump *label246 always
+  101 multilabel *label288 (m:*label247)
+  102 jump *label246 always
+  103 multilabel *label289 (m:*label247)
+  104 jump *label10 always
+  105 multilabel *label290 (m:*label247)
+  106 jump *label10 always
+  107 multilabel *label291 (m:*label247)
+  108 jump *label10 always
+  109 multilabel *label292 (m:*label247)
+  110 jump *label10 always
+  111 multilabel *label293 (m:*label247)
+  112 jump *label246 always
+  113 multilabel *label294 (m:*label247)
+  114 jump *label246 always
+  115 multilabel *label295 (m:*label247)
+  116 jump *label246 always
+  117 multilabel *label296 (m:*label247)
+  118 jump *label246 always
+  119 multilabel *label297 (m:*label247)
+  120 jump *label246 always
+  121 multilabel *label298 (m:*label247)
+  122 jump *label246 always
+  123 multilabel *label299 (m:*label247)
+  124 jump *label246 always
+  125 multilabel *label300 (m:*label247)
+  126 jump *label246 always
+  127 multilabel *label301 (m:*label247)
+  128 jump *label246 always
+  129 multilabel *label302 (m:*label247)
+  130 jump *label246 always
+  131 multilabel *label303 (m:*label247)
+  132 jump *label246 always
+  133 multilabel *label304 (m:*label247)
+  134 jump *label246 always
+  135 multilabel *label305 (m:*label247)
+  136 jump *label246 always
+  137 multilabel *label306 (m:*label247)
+  138 jump *label246 always
+  139 multilabel *label307 (m:*label247)
+  140 jump *label246 always
+  141 multilabel *label308 (m:*label247)
+  142 jump *label10 always
+  143 multilabel *label309 (m:*label247)
+  144 jump *label10 always
+  145 multilabel *label310 (m:*label247)
+  146 jump *label10 always
+  147 multilabel *label311 (m:*label247)
+  148 jump *label246 always
+  149 multilabel *label312 (m:*label247)
+  150 jump *label246 always
+  151 multilabel *label313 (m:*label247)
+  152 jump *label246 always
+  153 multilabel *label314 (m:*label247)
+  154 jump *label246 always
+  155 multilabel *label315 (m:*label247)
+  156 jump *label246 always
+  157 multilabel *label316 (m:*label247)
+  158 jump *label246 always
+  159 multilabel *label317 (m:*label247)
+  160 jump *label246 always
+  161 multilabel *label318 (m:*label247)
+  162 jump *label246 always
+  163 multilabel *label319 (m:*label247)
+  164 jump *label246 always
+  165 multilabel *label320 (m:*label247)
+  166 jump *label246 always
+  167 multilabel *label321 (m:*label247)
+  168 jump *label246 always
+  169 multilabel *label322 (m:*label247)
+  170 jump *label246 always
+  171 multilabel *label323 (m:*label247)
+  172 jump *label246 always
+  173 multilabel *label324 (m:*label247)
+  174 jump *label246 always
+  175 multilabel *label325 (m:*label247)
+  176 jump *label246 always
+  177 multilabel *label326 (m:*label247)
+  178 jump *label246 always
+  179 multilabel *label327 (m:*label247)
+  180 jump *label246 always
+  181 multilabel *label328 (m:*label247)
+  182 jump *label246 always
+  183 multilabel *label329 (m:*label247)
+  184 jump *label246 always
+  185 multilabel *label330 (m:*label247)
   186 label *label8
-    * set .START :n
-    * op add :reactors :reactors 1
-    * jump *label6 always
+  187 set .START :n
+  188 op add :reactors :reactors 1
+  189 jump *label6 always
   190 label *label7
-    * jump *label10 equal *tmp5 @overdrive-projector
-    * jump *label10 equal *tmp5 @overdrive-dome
-    * jump *label10 equal *tmp5 @conduit
-    * jump *label10 equal *tmp5 @pulse-conduit
-    * jump *label10 equal *tmp5 @plated-conduit
-    * jump *label10 equal *tmp5 @conveyor
-    * jump *label10 equal *tmp5 @titanium-conveyor
-    * jump *label10 equal *tmp5 @plastanium-conveyor
-    * jump *label9 notEqual *tmp5 @armored-conveyor
   191 label *label10
   192 set .START :n
   193 label *label9
+  194 label *label246
   195 label *label6
   196 label *label4
   197 jump *label155 greaterThan :n 0

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-1 instructions):
 
   242 sensor :total_capacity battery1 @powerNetCapacity
   243 op idiv :total_capacity_str :total_capacity 1000
   244 op mul :required_capacity 100000 :reactors
-    * op greaterThanEq :enough_battery :total_capacity :required_capacity
   245 op sub *tmp39 :required_capacity :total_capacity
   246 op div *tmp40 *tmp39 1000
   247 op ceil :missing_battery *tmp40
 
   330 print "\n[salmon]Blast compound level critical![]"
   331 label *label44
   332 label *label45
-    * jump *label46 notEqual :enough_battery false
+  333 jump *label46 greaterThanEq :total_capacity :required_capacity
   334 print "\n"
   335 print "[salmon]Insufficient battery storage![]"
   336 print "\n"
 
   504 sensor *tmp133 vault1 @blast-compound
   505 op greaterThan .FUEL_FLAG *tmp133 800
   506 label *label102
-    * jump *label105 equal :enough_battery false
+  507 jump *label105 lessThan :total_capacity :required_capacity
   508 sensor *tmp136 switch2 @enabled
   509 jump *label105 equal *tmp136 false
   510 op mul :min_level :reactors 50000
 
   787 op add :reactors :reactors 1
   788 op lessThanEq :enabled :reactors .REACTORS_ON
   789 control enabled :block :enabled
-    * jump *label244 equal :enabled false
+  790 jump *label244 greaterThan :reactors .REACTORS_ON
   791 sensor *tmp193 :block @timescale
   792 op add :boosts :boosts *tmp193
   793 label *label244

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-4 instructions):
 
   220 set .REASON "Reason unknown -- out of power?"
   221 jump *label14 notEqual .MODE 0
   222 set .REASON "Processor reset"
-    * jump *label14 always
   223 label *label14
   224 op notEqual *tmp23 .MODE 0
   225 control enabled switch1 *tmp23
 
   256 jump *label23 notEqual :battery_level 0
   257 jump *label23 lessThanEq :consumption 0
   258 op equal *tmp52 :production 0
-    * jump *label23 always
   259 label *label23
   260 jump *label29 lessThan :consumption :min_consumption
   261 jump *label27 equal *tmp52 false
 
   429 jump *label66 greaterThanEq .REACTORS_ON :reactors
   430 jump *label66 lessThanEq :net_power 1000
   431 op greaterThanEq *tmp100 :total_battery 25000
-    * jump *label66 always
   432 label *label66
   433 jump *label70 lessThan :net_power :neededPower
   434 set .OUTPUT_2 .OUTPUT_1
 
   449 set *tmp112 1
   450 jump *label81 equal FAST_START false
   451 op idiv *tmp112 :total_battery 25000
-    * jump *label81 always
   452 label *label81
   453 op add *tmp114 .REACTORS_ON *tmp112
   454 op min .REACTORS_ON *tmp114 :reactors

Modifications by Iterated phase, If Expression Optimization, pass 2, iteration 1:
 
   387 label *label49
   388 jump *label53 notEqual .MODE 1
   389 label *label54
-    * jump *label55 equal .OUTPUT_1 false
+  390 sensor *tmp83 battery2 @powerNetOut
+  391 jump *label56 equal .OUTPUT_1 false
   392 sensor *tmp83 battery3 @powerNetOut
   393 jump *label56 always
-    * label *label55
-    * sensor *tmp83 battery2 @powerNetOut
   394 label *label56
   395 op idiv *tmp85 *tmp83 0.9523809523809523
   396 op max :neededPower *tmp85 1000

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
   390 sensor *tmp83 battery2 @powerNetOut
   391 jump *label56 equal .OUTPUT_1 false
   392 sensor *tmp83 battery3 @powerNetOut
-    * jump *label56 always
   393 label *label56
   394 op idiv *tmp85 *tmp83 0.9523809523809523
   395 op max :neededPower *tmp85 1000

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-1 instructions):
 
     2 set .COOLANT_FLAG null
     3 set .FUEL_FLAG null
     4 set .START null
-    * label *label0
     5 label *label154
     6 set :reactors 0
     7 set :n @links
-    * label *label3
     8 jump *label5 lessThanEq :n 0
     9 label *label155
    10 op sub :n :n 1
 
   181 multilabel *label329 (m:*label247)
   182 jump *label246 always
   183 multilabel *label330 (m:*label247)
-    * label *label8
   184 set .START :n
   185 op add :reactors :reactors 1
   186 jump *label6 always
-    * label *label7
   187 label *label10
   188 set .START :n
-    * label *label9
   189 label *label246
   190 label *label6
-    * label *label4
   191 jump *label155 greaterThan :n 0
   192 label *label5
   193 read *tmp7 cell2 1
 
   195 jump *label11 notEqual :reactors 0
   196 print "No reactor."
   197 label *label11
-    * label *label12
   198 printflush message1
-    * label *label1
   199 jump *label154 equal :reactors 0
-    * label *label2
   200 read .MODE cell1 0
   201 read .OUTPUT_1 cell1 1
   202 read .OUTPUT_2 cell1 2
 
   264 print :min_consumption
   265 printflush message2
   266 label *label31
-    * label *label32
   267 jump *label28 always
   268 label *label27
   269 set :failure_cnt 0
   270 label *label28
   271 label *label21
   272 label *label18
-    * label *label19
   273 jump *label34 notEqual .MODE 0
-    * label *label35
   274 set *tmp59 "[salmon]SHUTDOWN[]"
   275 jump *label33 always
   276 label *label34
   277 jump *label36 notEqual .MODE 1
-    * label *label37
   278 set *tmp59 "[gold]STARTUP[]"
   279 jump *label33 always
   280 label *label36
   281 jump *label38 notEqual .MODE 2
-    * label *label39
   282 set *tmp59 "[green]RUNNING[]"
   283 jump *label33 always
   284 label *label38
 
   302 print :multiplier
   303 print "x[])"
   304 label *label40
-    * label *label41
   305 print "\n=================================="
   306 sensor *tmp67 tank1 @totalLiquids
   307 jump *label42 greaterThanEq *tmp67 750
   308 print "\n[salmon]Cryofluid level critical![]"
   309 label *label42
-    * label *label43
   310 sensor *tmp70 vault1 @blast-compound
   311 jump *label44 greaterThanEq *tmp70 700
   312 print "\n[salmon]Blast compound level critical![]"
   313 label *label44
-    * label *label45
   314 jump *label46 greaterThanEq :total_capacity :required_capacity
   315 print "\n"
   316 print "[salmon]Insufficient battery storage![]"
 
   320 print " "
   321 print "K[] of additional storage to internal battery."
   322 label *label46
-    * label *label47
   323 print "\n"
   324 print "Internal battery:    [gold]"
   325 print :battery_level_str
 
   344 print "["
   345 print "]"
   346 jump *label49 notEqual .MODE 0
-    * label *label50
   347 set .REACTORS_ON 0
   348 set .OVERDRIVE 0
   349 set .OUTPUT_1 0
 
   363 set .GENERATOR true
   364 set .REASON "Unknown -- out of power?"
   365 label *label51
-    * label *label52
   366 jump *label48 always
   367 label *label49
   368 jump *label53 notEqual .MODE 1
-    * label *label54
   369 sensor *tmp83 battery2 @powerNetOut
   370 jump *label56 equal .OUTPUT_1 false
   371 sensor *tmp83 battery3 @powerNetOut
 
   397 print "["
   398 print "]"
   399 label *label61
-    * label *label62
   400 jump *label63 lessThanEq :net_power 100
   401 set .OVERDRIVE true
   402 label *label63
-    * label *label64
   403 set *tmp100 false
   404 jump *label66 greaterThanEq .REACTORS_ON :reactors
   405 jump *label66 lessThanEq :net_power 1000
 
   409 set .OUTPUT_2 .OUTPUT_1
   410 set .OUTPUT_1 1
   411 label *label70
-    * label *label71
   412 jump *label72 notEqual .OUTPUT_1 0
   413 op mul :availablePower 6300 :boosts
   414 op div :ratio :neededPower :availablePower
   415 jump *label74 greaterThanEq :ratio 1
   416 op add :nextStart @time 2000
   417 label *label74
-    * label *label75
   418 label *label72
-    * label *label73
   419 jump *label76 equal *tmp100 false
   420 jump *label76 lessThanEq @time :nextStart
   421 set *tmp112 1
 
   426 op min .REACTORS_ON *tmp114 :reactors
   427 op add :nextStart @time 2000
   428 label *label76
-    * label *label77
   429 jump *label82 lessThan .REACTORS_ON :reactors
   430 jump *label82 lessThanEq @time :nextStart
   431 jump *label82 lessThanEq .OUTPUT_2 0
 
   435 set .FUEL_FLAG 0
   436 set .GENERATOR false
   437 label *label82
-    * label *label83
   438 label *label58
   439 jump *label48 always
   440 label *label53
   441 jump *label87 notEqual .MODE 2
-    * label *label88
   442 jump *label89 equal .COOLANT_FLAG false
   443 sensor *tmp122 tank1 @totalLiquids
   444 jump *label89 greaterThanEq *tmp122 750
 
   446 control enabled switch1 false
   447 set .REASON "Cryo level too low"
   448 label *label89
-    * label *label90
   449 jump *label93 equal .FUEL_FLAG false
   450 sensor *tmp126 vault1 @blast-compound
   451 jump *label93 greaterThanEq *tmp126 700
 
   453 control enabled switch1 false
   454 set .REASON "Blast compound level too low"
   455 label *label93
-    * label *label94
   456 jump *label97 equal .COOLANT_FLAG false
   457 set .COOLANT_FLAG true
   458 jump *label98 always
 
   485 print "\nCommit threshold:   [gold]"
   486 print *tmp149
   487 label *label109
-    * label *label110
   488 jump *label114 notEqual :commit_level 0
   489 op idiv *tmp152 :min_level 1000
   490 print "\nRestart threshold: [gold]"
   491 print *tmp152
   492 label *label114
-    * label *label115
   493 print "[] K"
   494 jump *label118 lessThan :total_battery :min_level
   495 op mul *tmp154 .REACTORS_ON -2500
 
   507 label *label122
   508 op add :nextDecommit @time 6000
   509 label *label120
-    * label *label121
   510 jump *label124 lessThanEq @time :nextDecommit
   511 jump *label126 equal .OVERDRIVE false
   512 set .OVERDRIVE false
 
   524 op add .COMMITS .COMMITS 1
   525 set .CAN_COMMIT false
   526 label *label128
-    * label *label129
   527 label *label125
   528 label *label117
   529 jump *label106 always
 
   542 jump *label132 greaterThanEq :total_battery *tmp173
   543 set .OUTPUT_2 0
   544 label *label132
-    * label *label133
   545 jump *label134 notEqual .OUTPUT_2 0
   546 jump *label136 lessThanEq :total_battery 47500
   547 set .OUTPUT_2 1
 
   550 print "\n*** [gold]Surge tower 2 offline[] ***"
   551 label *label137
   552 label *label134
-    * label *label135
   553 label *label87
   554 label *label48
   555 print "\n"
 
   567 set :reactors 0
   568 set :boosts 0
   569 set :n .START
-    * label *label138
   570 jump *label140 greaterThanEq .START @links
   571 label *label156
   572 getlink :block :n
 
   739 multilabel *label242 (m:*label160)
   740 jump *label159 always
   741 multilabel *label243 (m:*label160)
-    * label *label143
   742 op add :reactors :reactors 1
   743 op lessThanEq :enabled :reactors .REACTORS_ON
   744 control enabled :block :enabled
 
   746 sensor *tmp193 :block @timescale
   747 op add :boosts :boosts *tmp193
   748 label *label244
-    * label *label245
   749 jump *label141 always
-    * label *label142
   750 label *label147
   751 control enabled :block .OVERDRIVE
   752 jump *label141 always
-    * label *label146
   753 label *label149
   754 control enabled :block :startup
-    * label *label148
   755 label *label159
   756 label *label141
-    * label *label139
   757 op add :n :n 1
   758 jump *label156 lessThan :n @links
   759 label *label140
 
   766 read *tmp204 cell2 4
   767 op add :boosts :boosts *tmp204
   768 label *label150
-    * label *label151
   769 op min .REACTORS_ON .REACTORS_ON :reactors
   770 jump *label152 notEqual cell1 null
   771 set .STARTUPS 0
 
   784 write .RESETS cell1 8
   785 write .COMMITS cell1 9
   786 label *label153
-    * label *label16
   787 jump *label15 always
-    * label *label17
-    * end

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
 
   254 op add :failure_cnt :failure_cnt 1
   255 read *tmp54 cell2 1
   256 op add *tmp55 10 *tmp54
-    * jump *label31 lessThanEq :failure_cnt *tmp55
+  257 jump *label28 lessThanEq :failure_cnt *tmp55
   258 set .MODE 0
   259 control enabled switch1 false
   260 set .REASON "Unknown -- out of power?"
 
   355 print .REASON
   356 print "[]"
   357 sensor *tmp80 switch1 @enabled
-    * jump *label51 equal *tmp80 false
+  358 jump *label48 equal *tmp80 false
   359 set .MODE 1
   360 op add .STARTUPS .STARTUPS 1
   361 set :nextStart 0
 
   376 jump *label59 lessThan :total_battery 25000
   377 set .REACTORS_ON 1
   378 op add :nextStart @time 2000
-    * jump *label60 always
+  379 jump *label48 always
   380 label *label59
   381 print "\nRequired startup energy: [gold]"
   382 print 25
   383 print " K[]"
   384 label *label60
-    * jump *label58 always
+  385 jump *label48 always
   386 label *label57
   387 op add :outputs .OUTPUT_1 .OUTPUT_2
   388 print "\n"
 
   426 op min .REACTORS_ON *tmp114 :reactors
   427 op add :nextStart @time 2000
   428 label *label76
-    * jump *label82 lessThan .REACTORS_ON :reactors
-    * jump *label82 lessThanEq @time :nextStart
-    * jump *label82 lessThanEq .OUTPUT_2 0
+  429 jump *label48 lessThan .REACTORS_ON :reactors
+  430 jump *label48 lessThanEq @time :nextStart
+  431 jump *label48 lessThanEq .OUTPUT_2 0
   432 set .MODE 2
   433 op add :nextDecommit @time 6000
   434 set .COOLANT_FLAG 0
 
   500 set .OVERDRIVE true
   501 set .REACTORS_ON :reactors
   502 op add :nextDecommit @time 6000
-    * jump *label117 always
+  503 jump *label106 always
   504 label *label116
   505 jump *label122 lessThan :battery_level 47500
   506 jump *label120 greaterThanEq :battery_change -100
 
   517 set .CAN_COMMIT true
   518 label *label127
   519 op add :nextDecommit @time 6000
-    * jump *label125 always
+  520 jump *label106 always
   521 label *label124
-    * jump *label128 greaterThanEq :total_battery :commit_level
+  522 jump *label106 greaterThanEq :total_battery :commit_level
   523 op add .REACTORS_ON .REACTORS_ON 1
   524 op add .COMMITS .COMMITS 1
   525 set .CAN_COMMIT false
 
   742 op add :reactors :reactors 1
   743 op lessThanEq :enabled :reactors .REACTORS_ON
   744 control enabled :block :enabled
-    * jump *label244 greaterThan :reactors .REACTORS_ON
+  745 jump *label141 greaterThan :reactors .REACTORS_ON
   746 sensor *tmp193 :block @timescale
   747 op add :boosts :boosts *tmp193
   748 label *label244
 
   771 set .STARTUPS 0
   772 set .RESETS 0
   773 set .COMMITS 0
-    * jump *label153 always
+  774 jump *label15 always
   775 label *label152
   776 write .MODE cell1 0
   777 write .OUTPUT_1 cell1 1

Modifications by Final phase, Print Merging, iteration 1 (-24 instructions):
 
   284 set *tmp59 null
   285 label *label33
   286 print *tmp59
-    * print ","
-    * print " reactors [green]"
+  287 print ", reactors [green]"
   288 print .REACTORS_ON
   289 print "/"
   290 print :reactors
-    * print "["
-    * print "]"
+  291 print "[]"
   292 jump *label40 equal .OVERDRIVE false
   293 op mul *tmp62 100 :boosts
   294 op div *tmp63 *tmp62 .REACTORS_ON
 
   309 print "\n[salmon]Blast compound level critical![]"
   310 label *label44
   311 jump *label46 greaterThanEq :total_capacity :required_capacity
-    * print "\n"
-    * print "[salmon]Insufficient battery storage![]"
-    * print "\n"
-    * print "Link [gold]"
+  312 print "\n[salmon]Insufficient battery storage![]\nLink [gold]"
   313 print :missing_battery
-    * print " "
-    * print "K[] of additional storage to internal battery."
+  314 print " K[] of additional storage to internal battery."
   315 label *label46
-    * print "\n"
-    * print "Internal battery:    [gold]"
+  316 print "\nInternal battery:    [gold]"
   317 print :battery_level_str
-    * print "["
-    * print "]/[green]50[] K"
-    * print "\n"
-    * print "Total battery:        [gold]"
+  318 print "[]/[green]50[] K\nTotal battery:        [gold]"
   319 print :total_battery_str
-    * print "["
-    * print "]/[green]"
+  320 print "[]/[green]"
   321 print :total_capacity_str
-    * print "["
-    * print "] K"
-    * print "\n"
-    * print "Battery change:     [gold]"
+  322 print "[] K\nBattery change:     [gold]"
   323 print :battery_change
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "Power balance:       [gold]"
+  324 print "[]\nPower balance:       [gold]"
   325 print :net_power
-    * print "["
-    * print "]"
+  326 print "[]"
   327 jump *label49 notEqual .MODE 0
   328 set .REACTORS_ON 0
   329 set .OVERDRIVE 0
 
   358 op add :nextStart @time 2000
   359 jump *label48 always
   360 label *label59
-    * print "\nRequired startup energy: [gold]"
-    * print 25
-    * print " K[]"
+  361 print "\nRequired startup energy: [gold]25 K[]"
   362 jump *label48 always
   363 label *label57
   364 op add :outputs .OUTPUT_1 .OUTPUT_2
-    * print "\n"
-    * print "[gold]"
+  365 print "\n[gold]"
   366 print :outputs
-    * print "["
-    * print "] surge tower(s) online"
+  367 print "[] surge tower(s) online"
   368 jump *label61 notEqual .OUTPUT_2 0
-    * print "\n"
-    * print "Required power level: [gold]"
+  369 print "\nRequired power level: [gold]"
   370 print :neededPower
-    * print "["
-    * print "]"
+  371 print "[]"
   372 label *label61
   373 jump *label63 lessThanEq :net_power 100
   374 set .OVERDRIVE true

Final code before resolving virtual instructions:

    0:  set PLANT_PROTECTION 1                                       param PLANT_PROTECTION      = 1;        // If internal battery level gets too low, output to base is switched off
    1:  set FAST_START 1                                             param FAST_START            = 1;        // Starts as many reactors at once as possible during startup
    2:  set .COOLANT_FLAG null                                       COOLANT_FLAG = null; FUEL_FLAG = null; START = null;
    3:  set .FUEL_FLAG null                                          ...
    4:  set .START null                                              ...
        label *label154                                              while reactors == 0 do
    5:  set :reactors 0                                              reactors = 0;
    6:  set :n @links                                                n = @links;
    7:  jump *label5 lessThanEq :n 0                                 while n > 0 do
        label *label155                                              ...
    8:  op sub :n :n 1                                               block = getlink(--n);
    9:  getlink :block :n                                            ...
   10:  print "Found: "                                              println($"Found: $block");
   11:  print :block                                                 ...
   12:  print "\n"                                                   ...
   13:  sensor *tmp5 :block @type                                    case block.@type
   14:  sensor *tmp209 *tmp5 @id                                     while n > 0 do
   15:  jump *label246 greaterThanEq *tmp209 83                      case block.@type
   16:  multijump *label248 *tmp209 0                                ...
        multilabel *label248                                         ...
   17:  jump *label246 always 0 0                                    ...
        multilabel *label249                                         ...
   18:  jump *label246 always 0 0                                    ...
        multilabel *label250                                         ...
   19:  jump *label246 always 0 0                                    ...
        multilabel *label251                                         ...
   20:  jump *label246 always 0 0                                    ...
        multilabel *label252                                         ...
   21:  jump *label246 always 0 0                                    ...
        multilabel *label253                                         ...
   22:  jump *label246 always 0 0                                    ...
        multilabel *label254                                         ...
   23:  jump *label246 always 0 0                                    ...
        multilabel *label255                                         ...
   24:  jump *label246 always 0 0                                    ...
        multilabel *label256                                         ...
   25:  jump *label246 always 0 0                                    ...
        multilabel *label257                                         ...
   26:  jump *label246 always 0 0                                    ...
        multilabel *label258                                         ...
   27:  jump *label246 always 0 0                                    ...
        multilabel *label259                                         ...
   28:  jump *label246 always 0 0                                    ...
        multilabel *label260                                         ...
   29:  jump *label246 always 0 0                                    ...
        multilabel *label261                                         ...
   30:  jump *label246 always 0 0                                    ...
        multilabel *label262                                         ...
   31:  jump *label246 always 0 0                                    ...
        multilabel *label263                                         ...
   32:  jump *label246 always 0 0                                    ...
        multilabel *label264                                         ...
   33:  jump *label246 always 0 0                                    ...
        multilabel *label265                                         ...
   34:  jump *label246 always 0 0                                    ...
        multilabel *label266                                         ...
   35:  jump *label246 always 0 0                                    ...
        multilabel *label267                                         ...
   36:  jump *label246 always 0 0                                    ...
        multilabel *label268                                         ...
   37:  jump *label246 always 0 0                                    ...
        multilabel *label269                                         ...
   38:  jump *label246 always 0 0                                    ...
        multilabel *label270                                         ...
   39:  jump *label246 always 0 0                                    ...
        multilabel *label271                                         ...
   40:  jump *label246 always 0 0                                    ...
        multilabel *label272                                         ...
   41:  jump *label246 always 0 0                                    ...
        multilabel *label273                                         ...
   42:  jump *label246 always 0 0                                    ...
        multilabel *label274                                         ...
   43:  jump *label246 always 0 0                                    ...
        multilabel *label275                                         ...
   44:  jump *label246 always 0 0                                    ...
        multilabel *label276                                         ...
   45:  jump *label246 always 0 0                                    ...
        multilabel *label277                                         ...
   46:  jump *label246 always 0 0                                    ...
        multilabel *label278                                         ...
   47:  jump *label246 always 0 0                                    ...
        multilabel *label279                                         ...
   48:  jump *label246 always 0 0                                    ...
        multilabel *label280                                         ...
   49:  jump *label246 always 0 0                                    ...
        multilabel *label281                                         ...
   50:  jump *label246 always 0 0                                    ...
        multilabel *label282                                         ...
   51:  jump *label246 always 0 0                                    ...
        multilabel *label283                                         ...
   52:  jump *label246 always 0 0                                    ...
        multilabel *label284                                         ...
   53:  jump *label246 always 0 0                                    ...
        multilabel *label285                                         ...
   54:  jump *label10 always 0 0                                     ...
        multilabel *label286                                         ...
   55:  jump *label10 always 0 0                                     ...
        multilabel *label287                                         ...
   56:  jump *label246 always 0 0                                    ...
        multilabel *label288                                         ...
   57:  jump *label246 always 0 0                                    ...
        multilabel *label289                                         ...
   58:  jump *label10 always 0 0                                     ...
        multilabel *label290                                         ...
   59:  jump *label10 always 0 0                                     ...
        multilabel *label291                                         ...
   60:  jump *label10 always 0 0                                     ...
        multilabel *label292                                         ...
   61:  jump *label10 always 0 0                                     ...
        multilabel *label293                                         ...
   62:  jump *label246 always 0 0                                    ...
        multilabel *label294                                         ...
   63:  jump *label246 always 0 0                                    ...
        multilabel *label295                                         ...
   64:  jump *label246 always 0 0                                    ...
        multilabel *label296                                         ...
   65:  jump *label246 always 0 0                                    ...
        multilabel *label297                                         ...
   66:  jump *label246 always 0 0                                    ...
        multilabel *label298                                         ...
   67:  jump *label246 always 0 0                                    ...
        multilabel *label299                                         ...
   68:  jump *label246 always 0 0                                    ...
        multilabel *label300                                         ...
   69:  jump *label246 always 0 0                                    ...
        multilabel *label301                                         ...
   70:  jump *label246 always 0 0                                    ...
        multilabel *label302                                         ...
   71:  jump *label246 always 0 0                                    ...
        multilabel *label303                                         ...
   72:  jump *label246 always 0 0                                    ...
        multilabel *label304                                         ...
   73:  jump *label246 always 0 0                                    ...
        multilabel *label305                                         ...
   74:  jump *label246 always 0 0                                    ...
        multilabel *label306                                         ...
   75:  jump *label246 always 0 0                                    ...
        multilabel *label307                                         ...
   76:  jump *label246 always 0 0                                    ...
        multilabel *label308                                         ...
   77:  jump *label10 always 0 0                                     ...
        multilabel *label309                                         ...
   78:  jump *label10 always 0 0                                     ...
        multilabel *label310                                         ...
   79:  jump *label10 always 0 0                                     ...
        multilabel *label311                                         ...
   80:  jump *label246 always 0 0                                    ...
        multilabel *label312                                         ...
   81:  jump *label246 always 0 0                                    ...
        multilabel *label313                                         ...
   82:  jump *label246 always 0 0                                    ...
        multilabel *label314                                         ...
   83:  jump *label246 always 0 0                                    ...
        multilabel *label315                                         ...
   84:  jump *label246 always 0 0                                    ...
        multilabel *label316                                         ...
   85:  jump *label246 always 0 0                                    ...
        multilabel *label317                                         ...
   86:  jump *label246 always 0 0                                    ...
        multilabel *label318                                         ...
   87:  jump *label246 always 0 0                                    ...
        multilabel *label319                                         ...
   88:  jump *label246 always 0 0                                    ...
        multilabel *label320                                         ...
   89:  jump *label246 always 0 0                                    ...
        multilabel *label321                                         ...
   90:  jump *label246 always 0 0                                    ...
        multilabel *label322                                         ...
   91:  jump *label246 always 0 0                                    ...
        multilabel *label323                                         ...
   92:  jump *label246 always 0 0                                    ...
        multilabel *label324                                         ...
   93:  jump *label246 always 0 0                                    ...
        multilabel *label325                                         ...
   94:  jump *label246 always 0 0                                    ...
        multilabel *label326                                         ...
   95:  jump *label246 always 0 0                                    ...
        multilabel *label327                                         ...
   96:  jump *label246 always 0 0                                    ...
        multilabel *label328                                         ...
   97:  jump *label246 always 0 0                                    ...
        multilabel *label329                                         ...
   98:  jump *label246 always 0 0                                    ...
        multilabel *label330                                         ...
   99:  set .START :n                                                START = n;
  100:  op add :reactors :reactors 1                                 reactors += 1;
  101:  jump *label6 always 0 0                                      case block.@type
        label *label10                                               ...
  102:  set .START :n                                                START = n;
        label *label246                                              case block.@type
        label *label6                                                ...
  103:  jump *label155 greaterThan :n 0                              while n > 0 do
        label *label5                                                ...
  104:  read *tmp7 cell2 1                                           reactors += cell2[CELL_REMOTE_REACTORS];
  105:  op add :reactors :reactors *tmp7                             ...
  106:  jump *label11 notEqual :reactors 0                           if reactors == 0 then
  107:  print "No reactor."                                          print("No reactor.");
        label *label11                                               if reactors == 0 then
  108:  printflush message1                                          printflush(message1);
  109:  jump *label154 equal :reactors 0                             while reactors == 0 do
  110:  read .MODE cell1 0                                           MODE = $MODE;
  111:  read .OUTPUT_1 cell1 1                                       OUTPUT_1 = $OUTPUT_1;
  112:  read .OUTPUT_2 cell1 2                                       OUTPUT_2 = $OUTPUT_2;
  113:  read .REACTORS_ON cell1 3                                    REACTORS_ON = $REACTORS_ON;
  114:  read .OVERDRIVE cell1 4                                      OVERDRIVE = $OVERDRIVE;
  115:  read .GENERATOR cell1 5                                      GENERATOR = $GENERATOR;
  116:  read .CAN_COMMIT cell1 6                                     CAN_COMMIT = $CAN_COMMIT;
  117:  read .STARTUPS cell1 7                                       STARTUPS = $STARTUPS;
  118:  read .RESETS cell1 8                                         RESETS = $RESETS;
  119:  read .COMMITS cell1 9                                        COMMITS = $COMMITS;
  120:  set :reactors .REACTORS_ON                                   reactors = REACTORS_ON;
  121:  set .REASON "Reason unknown -- out of power?"                REASON = "Reason unknown -- out of power?";
  122:  jump *label14 notEqual .MODE 0                               if MODE == SHUTDOWN then
  123:  set .REASON "Processor reset"                                REASON = "Processor reset";
        label *label14                                               if MODE == SHUTDOWN then
  124:  op notEqual *tmp23 .MODE 0                                   switch1.enabled = MODE != SHUTDOWN;
  125:  control enabled switch1 *tmp23 0 0 0                         ...
  126:  set :failure_cnt 0                                           failure_cnt = 0;
  127:  set :boosts 0                                                boosts = 0;
  128:  set :nextStart 0                                             nextStart = 0;
  129:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
        label *label15                                               while true do
  130:  sensor *tmp25 battery1 @totalPower                           battery_level = floor(battery1.@totalPower);
  131:  op floor :battery_level *tmp25 0                             ...
  132:  op idiv :battery_level_str :battery_level 1000               battery_level_str = battery_level \ 1000;
  133:  sensor *tmp28 battery1 @powerNetStored                       total_battery = floor(battery1.@powerNetStored);
  134:  op floor :total_battery *tmp28 0                             ...
  135:  op idiv :total_battery_str :total_battery 1000               total_battery_str = total_battery \ 1000;
  136:  sensor :consumption battery1 @powerNetOut                    consumption = battery1.@powerNetOut;
  137:  read :production bank1 509                                   production = bank1[PRODUCTION_INDEX];
  138:  read :net_power bank1 510                                    net_power = bank1[NET_POWER_INDEX];
  139:  read :battery_change bank1 511                               battery_change = bank1[BATTERY_CHANGE_INDEX];
  140:  sensor :total_capacity battery1 @powerNetCapacity            total_capacity = battery1.@powerNetCapacity;
  141:  op idiv :total_capacity_str :total_capacity 1000             total_capacity_str = total_capacity \ 1000;
  142:  op mul :required_capacity 100000 :reactors                   required_capacity = BATTERY_PER_REACTOR * reactors;
  143:  op sub *tmp39 :required_capacity :total_capacity             missing_battery = ceil((required_capacity - total_capacity) / 1000);
  144:  op div *tmp40 *tmp39 1000                                    ...
  145:  op ceil :missing_battery *tmp40 0                            ...
  146:  jump *label18 equal .MODE 0                                  if MODE != SHUTDOWN then
  147:  sensor *tmp44 switch1 @enabled                               if switch1.@enabled == false then
  148:  jump *label20 notEqual *tmp44 false                          ...
  149:  set .MODE 0                                                  MODE = SHUTDOWN;
  150:  set .REASON "Manual power off"                               REASON = "Manual power off";
  151:  jump *label21 always 0 0                                     if switch1.@enabled == false then
        label *label20                                               ...
  152:  op mul :min_consumption .REACTORS_ON 1200                    min_consumption = REACTORS_ON * MIN_CONS_REACTOR;
  153:  set *tmp52 false                                             failure2 = (battery_level == 0) and (consumption > 0) and (production == 0);
  154:  jump *label23 notEqual :battery_level 0                      ...
  155:  jump *label23 lessThanEq :consumption 0                      ...
  156:  op equal *tmp52 :production 0                                ...
        label *label23                                               ...
  157:  jump *label29 lessThan :consumption :min_consumption         if failure1 or failure2 then
  158:  jump *label27 equal *tmp52 false                             ...
        label *label29                                               ...
  159:  op add :failure_cnt :failure_cnt 1                           failure_cnt += 1;
  160:  read *tmp54 cell2 1                                          if failure_cnt > 10 + cell2[CELL_REMOTE_REACTORS] then
  161:  op add *tmp55 10 *tmp54                                      ...
  162:  jump *label28 lessThanEq :failure_cnt *tmp55                 ...
  163:  set .MODE 0                                                  MODE = SHUTDOWN;
  164:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  165:  set .REASON "Unknown -- out of power?"                       REASON = "Unknown -- out of power?";
  166:  print "Consumption: "                                        print("Consumption: ", consumption);
  167:  print :consumption                                           ...
  168:  print "\nMin. consumption: "                                 print("\nMin. consumption: ", min_consumption);
  169:  print :min_consumption                                       ...
  170:  printflush message2                                          printflush(message2);
  171:  jump *label28 always 0 0                                     if failure1 or failure2 then
        label *label27                                               ...
  172:  set :failure_cnt 0                                           failure_cnt = 0;
        label *label28                                               if failure1 or failure2 then
        label *label21                                               if switch1.@enabled == false then
        label *label18                                               if MODE != SHUTDOWN then
  173:  jump *label34 notEqual .MODE 0                               STR_MODE = case MODE
  174:  set *tmp59 "[salmon]SHUTDOWN[]"                              ...
  175:  jump *label33 always 0 0                                     ...
        label *label34                                               ...
  176:  jump *label36 notEqual .MODE 1                               ...
  177:  set *tmp59 "[gold]STARTUP[]"                                 ...
  178:  jump *label33 always 0 0                                     ...
        label *label36                                               ...
  179:  jump *label38 notEqual .MODE 2                               ...
  180:  set *tmp59 "[green]RUNNING[]"                                ...
  181:  jump *label33 always 0 0                                     ...
        label *label38                                               ...
  182:  set *tmp59 null                                              ...
        label *label33                                               ...
  183:  print *tmp59                                                 print($"$STR_MODE, reactors [green]$REACTORS_ON/$reactors[]");
  184:  print ", reactors [green]"                                   ...
  185:  print .REACTORS_ON                                           ...
  186:  print "/"                                                    ...
  187:  print :reactors                                              ...
  188:  print "[]"                                                   ...
  189:  jump *label40 equal .OVERDRIVE false                         if OVERDRIVE then
  190:  op mul *tmp62 100 :boosts                                    multiplier = floor(100 * boosts / REACTORS_ON + 0.5) / 100;
  191:  op div *tmp63 *tmp62 .REACTORS_ON                            ...
  192:  op add *tmp64 *tmp63 0.5                                     ...
  193:  op floor *tmp65 *tmp64 0                                     ...
  194:  op div :multiplier *tmp65 100                                ...
  195:  print " ([gold]"                                             print(" ([gold]", multiplier, "x[])");
  196:  print :multiplier                                            ...
  197:  print "x[])"                                                 ...
        label *label40                                               if OVERDRIVE then
  198:  print "\n=================================="                 print("\n==================================");
  199:  sensor *tmp67 tank1 @totalLiquids                            if tank1.@totalLiquids < COOLANT_CUTOFF then
  200:  jump *label42 greaterThanEq *tmp67 750                       ...
  201:  print "\n[salmon]Cryofluid level critical![]"                print("\n[salmon]Cryofluid level critical![]");
        label *label42                                               if tank1.@totalLiquids < COOLANT_CUTOFF then
  202:  sensor *tmp70 vault1 @blast-compound                         if vault1.@blast-compound < FUEL_CUTOFF then
  203:  jump *label44 greaterThanEq *tmp70 700                       ...
  204:  print "\n[salmon]Blast compound level critical![]"           print("\n[salmon]Blast compound level critical![]");
        label *label44                                               if vault1.@blast-compound < FUEL_CUTOFF then
  205:  jump *label46 greaterThanEq :total_capacity :required_capaci if enough_battery == false then
  206:  print "\n[salmon]Insufficient battery storage![]\nLink [gold print($"\nLink [gold]$missing_battery K[] of additional storage to internal battery.");
  207:  print :missing_battery                                       ...
  208:  print " K[] of additional storage to internal battery."      ...
        label *label46                                               if enough_battery == false then
  209:  print "\nInternal battery:    [gold]"                        print($"\nInternal battery:    [gold]$battery_level_str[]/[green]50[] K");
  210:  print :battery_level_str                                     ...
  211:  print "[]/[green]50[] K\nTotal battery:        [gold]"       print($"\nTotal battery:        [gold]$total_battery_str[]/[green]$total_capacity_str[] K");
  212:  print :total_battery_str                                     ...
  213:  print "[]/[green]"                                           ...
  214:  print :total_capacity_str                                    ...
  215:  print "[] K\nBattery change:     [gold]"                     print($"\nBattery change:     [gold]$battery_change[]");
  216:  print :battery_change                                        ...
  217:  print "[]\nPower balance:       [gold]"                      print($"\nPower balance:       [gold]$net_power[]");
  218:  print :net_power                                             ...
  219:  print "[]"                                                   ...
  220:  jump *label49 notEqual .MODE 0                               case MODE
  221:  set .REACTORS_ON 0                                           REACTORS_ON = 0;
  222:  set .OVERDRIVE 0                                             OVERDRIVE = 0;
  223:  set .OUTPUT_1 0                                              OUTPUT_1 = 0;
  224:  set .OUTPUT_2 0                                              OUTPUT_2 = 0;
  225:  op greaterThanEq *tmp77 :net_power -150                      GENERATOR = (net_power >= -150) && (total_battery < BATTERY_SAT);
  226:  op lessThan *tmp78 :total_battery 47500                      ...
  227:  op land .GENERATOR *tmp77 *tmp78                             ...
  228:  print "\nShutdown reason: [gold]"                            print("\nShutdown reason: [gold]", REASON, "[]");
  229:  print .REASON                                                ...
  230:  print "[]"                                                   ...
  231:  sensor *tmp80 switch1 @enabled                               if switch1.@enabled then
  232:  jump *label48 equal *tmp80 false                             ...
  233:  set .MODE 1                                                  MODE = STARTUP;
  234:  op add .STARTUPS .STARTUPS 1                                 STARTUPS += 1;
  235:  set :nextStart 0                                             nextStart = 0;
  236:  set :failure_cnt 0                                           failure_cnt = 0;
  237:  set .GENERATOR true                                          GENERATOR = true;
  238:  set .REASON "Unknown -- out of power?"                       REASON = "Unknown -- out of power?";
  239:  jump *label48 always 0 0                                     case MODE
        label *label49                                               ...
  240:  jump *label53 notEqual .MODE 1                               ...
  241:  sensor *tmp83 battery2 @powerNetOut                          nextBattery = OUTPUT_1 ? battery3 : battery2;
  242:  jump *label56 equal .OUTPUT_1 false                          ...
  243:  sensor *tmp83 battery3 @powerNetOut                          ...
        label *label56                                               ...
  244:  op idiv *tmp85 *tmp83 0.9523809523809523                     neededPower = max(floor(nextBattery.@powerNetOut * POWER_MARGIN), 1000);
  245:  op max :neededPower *tmp85 1000                              ...
  246:  jump *label57 notEqual .REACTORS_ON 0                        if REACTORS_ON == 0 then
  247:  jump *label59 lessThan :total_battery 25000                  if total_battery >= STARTUP_BAT_ENERGY then
  248:  set .REACTORS_ON 1                                           REACTORS_ON = 1;
  249:  op add :nextStart @time 2000                                 nextStart = @time + STARTUP_DELAY;
  250:  jump *label48 always 0 0                                     if total_battery >= STARTUP_BAT_ENERGY then
        label *label59                                               ...
  251:  print "\nRequired startup energy: [gold]25 K[]"              print("\nRequired startup energy: [gold]", STARTUP_BAT_ENERGY \ 1000, " K[]");
  252:  jump *label48 always 0 0                                     if REACTORS_ON == 0 then
        label *label57                                               ...
  253:  op add :outputs .OUTPUT_1 .OUTPUT_2                          outputs = OUTPUT_1 + OUTPUT_2;
  254:  print "\n[gold]"                                             print($"\n[gold]$outputs[] surge tower(s) online");
  255:  print :outputs                                               ...
  256:  print "[] surge tower(s) online"                             ...
  257:  jump *label61 notEqual .OUTPUT_2 0                           if OUTPUT_2 == 0 then
  258:  print "\nRequired power level: [gold]"                       print($"\nRequired power level: [gold]$neededPower[]");
  259:  print :neededPower                                           ...
  260:  print "[]"                                                   ...
        label *label61                                               if OUTPUT_2 == 0 then
  261:  jump *label63 lessThanEq :net_power 100                      if net_power > 100 then
  262:  set .OVERDRIVE true                                          OVERDRIVE = true;
        label *label63                                               if net_power > 100 then
  263:  set *tmp100 false                                            canStart = (REACTORS_ON < reactors) and (net_power > 1000) and (total_battery >= STARTUP_BAT_ENERGY);
  264:  jump *label66 greaterThanEq .REACTORS_ON :reactors           ...
  265:  jump *label66 lessThanEq :net_power 1000                     ...
  266:  op greaterThanEq *tmp100 :total_battery 25000                ...
        label *label66                                               ...
  267:  jump *label70 lessThan :net_power :neededPower               if net_power >= neededPower then
  268:  set .OUTPUT_2 .OUTPUT_1                                      OUTPUT_2 = OUTPUT_1;
  269:  set .OUTPUT_1 1                                              OUTPUT_1 = 1;
        label *label70                                               if net_power >= neededPower then
  270:  jump *label72 notEqual .OUTPUT_1 0                           if OUTPUT_1 == 0 then
  271:  op mul :availablePower 6300 :boosts                          availablePower = REACTOR_OUTPUT * boosts;
  272:  op div :ratio :neededPower :availablePower                   ratio = neededPower / availablePower;
  273:  jump *label74 greaterThanEq :ratio 1                         if ratio < 1 then
  274:  op add :nextStart @time 2000                                 nextStart = @time + STARTUP_DELAY;
        label *label74                                               if ratio < 1 then
        label *label72                                               if OUTPUT_1 == 0 then
  275:  jump *label76 equal *tmp100 false                            if canStart and (@time > nextStart) then
  276:  jump *label76 lessThanEq @time :nextStart                    ...
  277:  set *tmp112 1                                                start_at_once = FAST_START ? total_battery \ STARTUP_BAT_ENERGY : 1;
  278:  jump *label81 equal FAST_START false                         ...
  279:  op idiv *tmp112 :total_battery 25000                         ...
        label *label81                                               ...
  280:  op add *tmp114 .REACTORS_ON *tmp112                          REACTORS_ON = min(REACTORS_ON + start_at_once, reactors);
  281:  op min .REACTORS_ON *tmp114 :reactors                        ...
  282:  op add :nextStart @time 2000                                 nextStart = @time + STARTUP_DELAY;
        label *label76                                               if canStart and (@time > nextStart) then
  283:  jump *label48 lessThan .REACTORS_ON :reactors                if (REACTORS_ON >= reactors) and (@time > nextStart) and (OUTPUT_2 > 0) then
  284:  jump *label48 lessThanEq @time :nextStart                    ...
  285:  jump *label48 lessThanEq .OUTPUT_2 0                         ...
  286:  set .MODE 2                                                  MODE = RUNNING;
  287:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
  288:  set .COOLANT_FLAG 0                                          COOLANT_FLAG = 0;
  289:  set .FUEL_FLAG 0                                             FUEL_FLAG = 0;
  290:  set .GENERATOR false                                         GENERATOR = false;
  291:  jump *label48 always 0 0                                     case MODE
        label *label53                                               ...
  292:  jump *label87 notEqual .MODE 2                               ...
  293:  jump *label89 equal .COOLANT_FLAG false                      if COOLANT_FLAG and (tank1.@totalLiquids < COOLANT_CUTOFF) then
  294:  sensor *tmp122 tank1 @totalLiquids                           ...
  295:  jump *label89 greaterThanEq *tmp122 750                      ...
  296:  set .MODE 0                                                  MODE = SHUTDOWN;
  297:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  298:  set .REASON "Cryo level too low"                             REASON = "Cryo level too low";
        label *label89                                               if COOLANT_FLAG and (tank1.@totalLiquids < COOLANT_CUTOFF) then
  299:  jump *label93 equal .FUEL_FLAG false                         if FUEL_FLAG and (vault1.@blast-compound < FUEL_CUTOFF) then
  300:  sensor *tmp126 vault1 @blast-compound                        ...
  301:  jump *label93 greaterThanEq *tmp126 700                      ...
  302:  set .MODE 0                                                  MODE = SHUTDOWN;
  303:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  304:  set .REASON "Blast compound level too low"                   REASON = "Blast compound level too low";
        label *label93                                               if FUEL_FLAG and (vault1.@blast-compound < FUEL_CUTOFF) then
  305:  jump *label97 equal .COOLANT_FLAG false                      COOLANT_FLAG = COOLANT_FLAG or (tank1.@totalLiquids > COOLANT_SAT);
  306:  set .COOLANT_FLAG true                                       ...
  307:  jump *label98 always 0 0                                     ...
        label *label97                                               ...
  308:  sensor *tmp130 tank1 @totalLiquids                           ...
  309:  op greaterThan .COOLANT_FLAG *tmp130 1000                    ...
        label *label98                                               ...
  310:  jump *label101 equal .FUEL_FLAG false                        FUEL_FLAG = FUEL_FLAG or (vault1.@blast-compound > FUEL_SAT);
  311:  set .FUEL_FLAG true                                          ...
  312:  jump *label102 always 0 0                                    ...
        label *label101                                              ...
  313:  sensor *tmp133 vault1 @blast-compound                        ...
  314:  op greaterThan .FUEL_FLAG *tmp133 800                        ...
        label *label102                                              ...
  315:  jump *label105 lessThan :total_capacity :required_capacity   if enough_battery and switch2.@enabled then
  316:  sensor *tmp136 switch2 @enabled                              ...
  317:  jump *label105 equal *tmp136 false                           ...
  318:  op mul :min_level :reactors 50000                            min_level = BATTERY_CRITICAL * required_capacity;
  319:  set :commit_level 0                                          commit_level = 0;
  320:  jump *label109 equal .CAN_COMMIT false                       if CAN_COMMIT and (battery_change < 0) and (REACTORS_ON < reactors) then
  321:  jump *label109 greaterThanEq :battery_change 0               ...
  322:  jump *label109 greaterThanEq .REACTORS_ON :reactors          ...
  323:  op sub :p :battery_change 2500                               p = battery_change - OWN_CONSUMPTION - SAFETY_MARGIN;
  324:  op mul *tmp144 :p 0.00472972972972973                        commit_margin = STARTUP_BAT_ENERGY + (p * (COEF_A1 + (p * COEF_A2)));
  325:  op add *tmp145 -5 *tmp144                                    ...
  326:  op mul *tmp146 :p *tmp145                                    ...
  327:  op add :commit_margin 25000 *tmp146                          ...
  328:  op add :commit_level :min_level :commit_margin               commit_level = min_level + commit_margin;
  329:  op idiv *tmp149 :commit_level 1000                           print("\nCommit threshold:   [gold]", commit_level \ 1000);
  330:  print "\nCommit threshold:   [gold]"                         ...
  331:  print *tmp149                                                ...
        label *label109                                              if CAN_COMMIT and (battery_change < 0) and (REACTORS_ON < reactors) then
  332:  jump *label114 notEqual :commit_level 0                      if commit_level == 0 then
  333:  op idiv *tmp152 :min_level 1000                              print("\nRestart threshold: [gold]", min_level \ 1000);
  334:  print "\nRestart threshold: [gold]"                          ...
  335:  print *tmp152                                                ...
        label *label114                                              if commit_level == 0 then
  336:  print "[] K"                                                 print("[] K");
  337:  jump *label118 lessThan :total_battery :min_level            if (total_battery < min_level) or (battery_change < REACTORS_ON * PANIC_ENERGY_DROP) then
  338:  op mul *tmp154 .REACTORS_ON -2500                            ...
  339:  jump *label116 greaterThanEq :battery_change *tmp154         ...
        label *label118                                              ...
  340:  op equal *tmp157 .OVERDRIVE false                            RESETS += (OVERDRIVE == false);
  341:  op add .RESETS .RESETS *tmp157                               ...
  342:  set .OVERDRIVE true                                          OVERDRIVE = true;
  343:  set .REACTORS_ON :reactors                                   REACTORS_ON = reactors;
  344:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
  345:  jump *label106 always 0 0                                    if (total_battery < min_level) or (battery_change < REACTORS_ON * PANIC_ENERGY_DROP) then
        label *label116                                              ...
  346:  jump *label122 lessThan :battery_level 47500                 if (battery_level < BATTERY_SAT) or (battery_change < -100) then
  347:  jump *label120 greaterThanEq :battery_change -100            ...
        label *label122                                              ...
  348:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
        label *label120                                              if (battery_level < BATTERY_SAT) or (battery_change < -100) then
  349:  jump *label124 lessThanEq @time :nextDecommit                if @time > nextDecommit then
  350:  jump *label126 equal .OVERDRIVE false                        if OVERDRIVE then
  351:  set .OVERDRIVE false                                         OVERDRIVE = false;
  352:  jump *label127 always 0 0                                    if OVERDRIVE then
        label *label126                                              ...
  353:  op sub *tmp166 .REACTORS_ON 1                                REACTORS_ON = max(REACTORS_ON - 1, 1);
  354:  op max .REACTORS_ON *tmp166 1                                ...
  355:  set .CAN_COMMIT true                                         CAN_COMMIT = true;
        label *label127                                              if OVERDRIVE then
  356:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
  357:  jump *label106 always 0 0                                    if @time > nextDecommit then
        label *label124                                              ...
  358:  jump *label106 greaterThanEq :total_battery :commit_level    if total_battery < commit_level then
  359:  op add .REACTORS_ON .REACTORS_ON 1                           REACTORS_ON += 1;
  360:  op add .COMMITS .COMMITS 1                                   COMMITS += 1;
  361:  set .CAN_COMMIT false                                        CAN_COMMIT = false;
  362:  jump *label106 always 0 0                                    if enough_battery and switch2.@enabled then
        label *label105                                              ...
  363:  sensor *tmp171 switch2 @enabled                              if switch2.@enabled then
  364:  jump *label130 equal *tmp171 false                           ...
  365:  print "\n[salmon]Load adapting not possible.[]"              print("\n[salmon]Load adapting not possible.[]");
  366:  jump *label131 always 0 0                                    if switch2.@enabled then
        label *label130                                              ...
  367:  print "\n[gold]Load adapting not active.[]"                  print("\n[gold]Load adapting not active.[]");
        label *label131                                              if switch2.@enabled then
  368:  set .REACTORS_ON :reactors                                   REACTORS_ON = reactors;
  369:  set .OVERDRIVE true                                          OVERDRIVE = true;
        label *label106                                              if enough_battery and switch2.@enabled then
  370:  op mul *tmp173 PLANT_PROTECTION 47500                        if total_battery < PLANT_PROTECTION * BATTERY_SAT then
  371:  jump *label132 greaterThanEq :total_battery *tmp173          ...
  372:  set .OUTPUT_2 0                                              OUTPUT_2 = 0;
        label *label132                                              if total_battery < PLANT_PROTECTION * BATTERY_SAT then
  373:  jump *label134 notEqual .OUTPUT_2 0                          if OUTPUT_2 == 0 then
  374:  jump *label136 lessThanEq :total_battery 47500               if total_battery > BATTERY_SAT then
  375:  set .OUTPUT_2 1                                              OUTPUT_2 = 1;
  376:  jump *label137 always 0 0                                    if total_battery > BATTERY_SAT then
        label *label136                                              ...
  377:  print "\n*** [gold]Surge tower 2 offline[] ***"              print("\n*** [gold]Surge tower 2 offline[] ***");
        label *label137                                              if total_battery > BATTERY_SAT then
        label *label134                                              if OUTPUT_2 == 0 then
        label *label87                                               case MODE
        label *label48                                               ...
  378:  print "\n"                                                   print($"\n${STARTUPS}-${RESETS}-${COMMITS}");
  379:  print .STARTUPS                                              ...
  380:  print "-"                                                    ...
  381:  print .RESETS                                                ...
  382:  print "-"                                                    ...
  383:  print .COMMITS                                               ...
  384:  printflush message1                                          printflush(message1);
  385:  control enabled diode1 .OUTPUT_1 0 0 0                       diode1.enabled = OUTPUT_1;
  386:  control enabled diode2 .OUTPUT_2 0 0 0                       diode2.enabled = OUTPUT_2;
  387:  control enabled generator1 .GENERATOR 0 0 0                  generator1.enabled = GENERATOR;
  388:  control enabled generator2 .GENERATOR 0 0 0                  generator2.enabled = GENERATOR;
  389:  op equal :startup .MODE 1                                    startup = MODE == STARTUP;
  390:  set :reactors 0                                              reactors = 0;
  391:  set :boosts 0                                                boosts = 0;
  392:  set :n .START                                                for n in START ... @links do
  393:  jump *label140 greaterThanEq .START @links                   ...
        label *label156                                              ...
  394:  getlink :block :n                                            block = getlink(n);
  395:  sensor *tmp187 :block @type                                  case block.@type
  396:  sensor *tmp208 *tmp187 @id                                   for n in START ... @links do
  397:  jump *label159 greaterThanEq *tmp208 83                      case block.@type
  398:  multijump *label161 *tmp208 0                                ...
        multilabel *label161                                         ...
  399:  jump *label159 always 0 0                                    ...
        multilabel *label162                                         ...
  400:  jump *label159 always 0 0                                    ...
        multilabel *label163                                         ...
  401:  jump *label159 always 0 0                                    ...
        multilabel *label164                                         ...
  402:  jump *label159 always 0 0                                    ...
        multilabel *label165                                         ...
  403:  jump *label159 always 0 0                                    ...
        multilabel *label166                                         ...
  404:  jump *label159 always 0 0                                    ...
        multilabel *label167                                         ...
  405:  jump *label159 always 0 0                                    ...
        multilabel *label168                                         ...
  406:  jump *label159 always 0 0                                    ...
        multilabel *label169                                         ...
  407:  jump *label159 always 0 0                                    ...
        multilabel *label170                                         ...
  408:  jump *label159 always 0 0                                    ...
        multilabel *label171                                         ...
  409:  jump *label159 always 0 0                                    ...
        multilabel *label172                                         ...
  410:  jump *label159 always 0 0                                    ...
        multilabel *label173                                         ...
  411:  jump *label159 always 0 0                                    ...
        multilabel *label174                                         ...
  412:  jump *label159 always 0 0                                    ...
        multilabel *label175                                         ...
  413:  jump *label159 always 0 0                                    ...
        multilabel *label176                                         ...
  414:  jump *label159 always 0 0                                    ...
        multilabel *label177                                         ...
  415:  jump *label159 always 0 0                                    ...
        multilabel *label178                                         ...
  416:  jump *label159 always 0 0                                    ...
        multilabel *label179                                         ...
  417:  jump *label159 always 0 0                                    ...
        multilabel *label180                                         ...
  418:  jump *label159 always 0 0                                    ...
        multilabel *label181                                         ...
  419:  jump *label159 always 0 0                                    ...
        multilabel *label182                                         ...
  420:  jump *label159 always 0 0                                    ...
        multilabel *label183                                         ...
  421:  jump *label159 always 0 0                                    ...
        multilabel *label184                                         ...
  422:  jump *label159 always 0 0                                    ...
        multilabel *label185                                         ...
  423:  jump *label159 always 0 0                                    ...
        multilabel *label186                                         ...
  424:  jump *label159 always 0 0                                    ...
        multilabel *label187                                         ...
  425:  jump *label159 always 0 0                                    ...
        multilabel *label188                                         ...
  426:  jump *label159 always 0 0                                    ...
        multilabel *label189                                         ...
  427:  jump *label159 always 0 0                                    ...
        multilabel *label190                                         ...
  428:  jump *label159 always 0 0                                    ...
        multilabel *label191                                         ...
  429:  jump *label159 always 0 0                                    ...
        multilabel *label192                                         ...
  430:  jump *label159 always 0 0                                    ...
        multilabel *label193                                         ...
  431:  jump *label159 always 0 0                                    ...
        multilabel *label194                                         ...
  432:  jump *label159 always 0 0                                    ...
        multilabel *label195                                         ...
  433:  jump *label159 always 0 0                                    ...
        multilabel *label196                                         ...
  434:  jump *label159 always 0 0                                    ...
        multilabel *label197                                         ...
  435:  jump *label159 always 0 0                                    ...
        multilabel *label198                                         ...
  436:  jump *label147 always 0 0                                    ...
        multilabel *label199                                         ...
  437:  jump *label147 always 0 0                                    ...
        multilabel *label200                                         ...
  438:  jump *label159 always 0 0                                    ...
        multilabel *label201                                         ...
  439:  jump *label159 always 0 0                                    ...
        multilabel *label202                                         ...
  440:  jump *label149 always 0 0                                    ...
        multilabel *label203                                         ...
  441:  jump *label149 always 0 0                                    ...
        multilabel *label204                                         ...
  442:  jump *label149 always 0 0                                    ...
        multilabel *label205                                         ...
  443:  jump *label149 always 0 0                                    ...
        multilabel *label206                                         ...
  444:  jump *label159 always 0 0                                    ...
        multilabel *label207                                         ...
  445:  jump *label159 always 0 0                                    ...
        multilabel *label208                                         ...
  446:  jump *label159 always 0 0                                    ...
        multilabel *label209                                         ...
  447:  jump *label159 always 0 0                                    ...
        multilabel *label210                                         ...
  448:  jump *label159 always 0 0                                    ...
        multilabel *label211                                         ...
  449:  jump *label159 always 0 0                                    ...
        multilabel *label212                                         ...
  450:  jump *label159 always 0 0                                    ...
        multilabel *label213                                         ...
  451:  jump *label159 always 0 0                                    ...
        multilabel *label214                                         ...
  452:  jump *label159 always 0 0                                    ...
        multilabel *label215                                         ...
  453:  jump *label159 always 0 0                                    ...
        multilabel *label216                                         ...
  454:  jump *label159 always 0 0                                    ...
        multilabel *label217                                         ...
  455:  jump *label159 always 0 0                                    ...
        multilabel *label218                                         ...
  456:  jump *label159 always 0 0                                    ...
        multilabel *label219                                         ...
  457:  jump *label159 always 0 0                                    ...
        multilabel *label220                                         ...
  458:  jump *label159 always 0 0                                    ...
        multilabel *label221                                         ...
  459:  jump *label149 always 0 0                                    ...
        multilabel *label222                                         ...
  460:  jump *label149 always 0 0                                    ...
        multilabel *label223                                         ...
  461:  jump *label149 always 0 0                                    ...
        multilabel *label224                                         ...
  462:  jump *label159 always 0 0                                    ...
        multilabel *label225                                         ...
  463:  jump *label159 always 0 0                                    ...
        multilabel *label226                                         ...
  464:  jump *label159 always 0 0                                    ...
        multilabel *label227                                         ...
  465:  jump *label159 always 0 0                                    ...
        multilabel *label228                                         ...
  466:  jump *label159 always 0 0                                    ...
        multilabel *label229                                         ...
  467:  jump *label159 always 0 0                                    ...
        multilabel *label230                                         ...
  468:  jump *label159 always 0 0                                    ...
        multilabel *label231                                         ...
  469:  jump *label159 always 0 0                                    ...
        multilabel *label232                                         ...
  470:  jump *label159 always 0 0                                    ...
        multilabel *label233                                         ...
  471:  jump *label159 always 0 0                                    ...
        multilabel *label234                                         ...
  472:  jump *label159 always 0 0                                    ...
        multilabel *label235                                         ...
  473:  jump *label159 always 0 0                                    ...
        multilabel *label236                                         ...
  474:  jump *label159 always 0 0                                    ...
        multilabel *label237                                         ...
  475:  jump *label159 always 0 0                                    ...
        multilabel *label238                                         ...
  476:  jump *label159 always 0 0                                    ...
        multilabel *label239                                         ...
  477:  jump *label159 always 0 0                                    ...
        multilabel *label240                                         ...
  478:  jump *label159 always 0 0                                    ...
        multilabel *label241                                         ...
  479:  jump *label159 always 0 0                                    ...
        multilabel *label242                                         ...
  480:  jump *label159 always 0 0                                    ...
        multilabel *label243                                         ...
  481:  op add :reactors :reactors 1                                 reactors += 1;
  482:  op lessThanEq :enabled :reactors .REACTORS_ON                enabled = reactors <= REACTORS_ON;
  483:  control enabled :block :enabled 0 0 0                        block.enabled = enabled;
  484:  jump *label141 greaterThan :reactors .REACTORS_ON            if enabled then
  485:  sensor *tmp193 :block @timescale                             boosts += block.@timescale;
  486:  op add :boosts :boosts *tmp193                               ...
  487:  jump *label141 always 0 0                                    case block.@type
        label *label147                                              ...
  488:  control enabled :block .OVERDRIVE 0 0 0                      block.enabled = OVERDRIVE;
  489:  jump *label141 always 0 0                                    case block.@type
        label *label149                                              ...
  490:  control enabled :block :startup 0 0 0                        block.enabled = startup;
        label *label159                                              case block.@type
        label *label141                                              ...
  491:  op add :n :n 1                                               for n in START ... @links do
  492:  jump *label156 lessThan :n @links                            ...
        label *label140                                              ...
  493:  jump *label150 equal cell2 null                              if cell2 != null then
  494:  write :reactors cell2 0                                      cell2[CELL_PRIOR_REACTORS] = reactors;
  495:  write .REACTORS_ON cell2 2                                   cell2[CELL_REACTORS_ON] = REACTORS_ON;
  496:  write .OVERDRIVE cell2 3                                     cell2[CELL_OVERDRIVE] = OVERDRIVE;
  497:  read *tmp203 cell2 1                                         reactors += cell2[CELL_REMOTE_REACTORS];
  498:  op add :reactors :reactors *tmp203                           ...
  499:  read *tmp204 cell2 4                                         boosts += cell2[CELL_BOOSTS];
  500:  op add :boosts :boosts *tmp204                               ...
        label *label150                                              if cell2 != null then
  501:  op min .REACTORS_ON .REACTORS_ON :reactors                   REACTORS_ON = min(REACTORS_ON, reactors);
  502:  jump *label152 notEqual cell1 null                           if cell1 == null then
  503:  set .STARTUPS 0                                              STARTUPS = 0;
  504:  set .RESETS 0                                                RESETS = 0;
  505:  set .COMMITS 0                                               COMMITS = 0;
  506:  jump *label15 always 0 0                                     if cell1 == null then
        label *label152                                              ...
  507:  write .MODE cell1 0                                          $MODE = MODE;
  508:  write .OUTPUT_1 cell1 1                                      $OUTPUT_1 = OUTPUT_1;
  509:  write .OUTPUT_2 cell1 2                                      $OUTPUT_2 = OUTPUT_2;
  510:  write .REACTORS_ON cell1 3                                   $REACTORS_ON = REACTORS_ON;
  511:  write .OVERDRIVE cell1 4                                     $OVERDRIVE = OVERDRIVE;
  512:  write .GENERATOR cell1 5                                     $GENERATOR = GENERATOR;
  513:  write .CAN_COMMIT cell1 6                                    $CAN_COMMIT = CAN_COMMIT;
  514:  write .STARTUPS cell1 7                                      $STARTUPS = STARTUPS;
  515:  write .RESETS cell1 8                                        $RESETS = RESETS;
  516:  write .COMMITS cell1 9                                       $COMMITS = COMMITS;
  517:  jump *label15 always 0 0                                     while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   519     1x    519,0  <no function>

Performance: parsed in 390 ms, compiled in 207 ms, optimized in 649 ms, run in 68 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
No reactor.
[--- Previous segment repeated 299,30 times ---]

Execution step limit of 100000 exceeded.
