   632 instructions before optimizations.
    56 instructions eliminated by Temp Variables Elimination.
     4 instructions eliminated by Case Expression Optimization.
    85 instructions eliminated by Dead Code Elimination (6 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    25 instructions eliminated by Jump Optimization (5 iterations).
    31 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     1 instructions eliminated by Expression Optimization (4 iterations).
     1 instructions eliminated by If Expression Optimization (2 passes, 4 iterations).
     9 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     1 instructions eliminated by Loop Optimization (4 iterations).
     3 loops improved by Loop Optimization.
    11 instructions eliminated by Jump Straightening (5 iterations).
    10 instructions updated by JumpThreading.
     1 instructions eliminated by Unreachable Code Elimination.
    24 instructions eliminated by Print Merging.
   382 instructions after optimizations.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-4 instructions):
 
    21 print :block
    22 print "\n"
    23 sensor *tmp5 :block @type
-    * set *tmp6 *tmp5
-    * jump *label9 equal *tmp6 @impact-reactor
+   24 jump *label9 equal *tmp5 @impact-reactor
    25 jump *label8 always
    26 label *label9
    27 set .START :n
 
    29 set *tmp4 :reactors
    30 jump *label7 always
    31 label *label8
-    * jump *label11 equal *tmp6 @overdrive-projector
-    * jump *label11 equal *tmp6 @overdrive-dome
-    * jump *label11 equal *tmp6 @conduit
-    * jump *label11 equal *tmp6 @pulse-conduit
-    * jump *label11 equal *tmp6 @plated-conduit
-    * jump *label11 equal *tmp6 @conveyor
-    * jump *label11 equal *tmp6 @titanium-conveyor
-    * jump *label11 equal *tmp6 @plastanium-conveyor
-    * jump *label11 equal *tmp6 @armored-conveyor
+   32 jump *label11 equal *tmp5 @overdrive-projector
+   33 jump *label11 equal *tmp5 @overdrive-dome
+   34 jump *label11 equal *tmp5 @conduit
+   35 jump *label11 equal *tmp5 @pulse-conduit
+   36 jump *label11 equal *tmp5 @plated-conduit
+   37 jump *label11 equal *tmp5 @conveyor
+   38 jump *label11 equal *tmp5 @titanium-conveyor
+   39 jump *label11 equal *tmp5 @plastanium-conveyor
+   40 jump *label11 equal *tmp5 @armored-conveyor
    41 jump *label10 always
    42 label *label11
    43 set .START :n
 
   185 label *label19
   186 set *tmp43 null
   187 label *label20
-    * set *tmp62 .MODE
-    * jump *label29 equal *tmp62 0
+  188 jump *label29 equal .MODE 0
   189 jump *label28 always
   190 label *label29
   191 set *tmp61 "[salmon]SHUTDOWN[]"
   192 jump *label27 always
   193 label *label28
-    * jump *label31 equal *tmp62 1
+  194 jump *label31 equal .MODE 1
   195 jump *label30 always
   196 label *label31
   197 set *tmp61 "[gold]STARTUP[]"
   198 jump *label27 always
   199 label *label30
-    * jump *label33 equal *tmp62 2
+  200 jump *label33 equal .MODE 2
   201 jump *label32 always
   202 label *label33
   203 set *tmp61 "[green]RUNNING[]"
 
   285 print :net_power
   286 print "["
   287 print "]"
-    * set *tmp78 .MODE
-    * jump *label44 equal *tmp78 0
+  288 jump *label44 equal .MODE 0
   289 jump *label43 always
   290 label *label44
   291 set .REACTORS_ON 0
 
   315 set *tmp77 *tmp83
   316 jump *label42 always
   317 label *label43
-    * jump *label48 equal *tmp78 1
+  318 jump *label48 equal .MODE 1
   319 jump *label47 always
   320 label *label48
   321 jump *label49 equal .OUTPUT_1 false
 
   453 set *tmp77 *tmp90
   454 jump *label42 always
   455 label *label47
-    * jump *label72 equal *tmp78 2
+  456 jump *label72 equal .MODE 2
   457 jump *label71 always
   458 label *label72
   459 sensor *tmp128 tank1 @totalLiquids
 
   654 getlink *tmp199 :n
   655 set :block *tmp199
   656 sensor *tmp201 :block @type
-    * set *tmp202 *tmp201
-    * jump *label106 equal *tmp202 @impact-reactor
+  657 jump *label106 equal *tmp201 @impact-reactor
   658 jump *label105 always
   659 label *label106
   660 op add :reactors :reactors 1
 
   673 set *tmp200 *tmp206
   674 jump *label104 always
   675 label *label105
-    * jump *label110 equal *tmp202 @overdrive-projector
-    * jump *label110 equal *tmp202 @overdrive-dome
+  676 jump *label110 equal *tmp201 @overdrive-projector
+  677 jump *label110 equal *tmp201 @overdrive-dome
   678 jump *label109 always
   679 label *label110
   680 set *tmp208 :block
 
   682 set *tmp200 .OVERDRIVE
   683 jump *label104 always
   684 label *label109
-    * jump *label112 equal *tmp202 @conduit
-    * jump *label112 equal *tmp202 @pulse-conduit
-    * jump *label112 equal *tmp202 @plated-conduit
-    * jump *label112 equal *tmp202 @conveyor
-    * jump *label112 equal *tmp202 @titanium-conveyor
-    * jump *label112 equal *tmp202 @plastanium-conveyor
-    * jump *label112 equal *tmp202 @armored-conveyor
+  685 jump *label112 equal *tmp201 @conduit
+  686 jump *label112 equal *tmp201 @pulse-conduit
+  687 jump *label112 equal *tmp201 @plated-conduit
+  688 jump *label112 equal *tmp201 @conveyor
+  689 jump *label112 equal *tmp201 @titanium-conveyor
+  690 jump *label112 equal *tmp201 @plastanium-conveyor
+  691 jump *label112 equal *tmp201 @armored-conveyor
   692 jump *label111 always
   693 label *label112
   694 set *tmp210 :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-57 instructions):
 
    26 label *label9
    27 set .START :n
    28 op add :reactors :reactors 1
-    * set *tmp4 :reactors
    29 jump *label7 always
    30 label *label8
    31 jump *label11 equal *tmp5 @overdrive-projector
 
    40 jump *label10 always
    41 label *label11
    42 set .START :n
-    * set *tmp4 .START
    43 jump *label7 always
    44 label *label10
-    * set *tmp4 null
    45 label *label7
    46 label *label5
    47 jump *label4 always
 
    51 op equal *tmp8 :reactors 0
    52 jump *label12 equal *tmp8 false
    53 print "No reactor."
-    * set *tmp9 "No reactor."
    54 jump *label13 always
    55 label *label12
-    * set *tmp9 null
    56 label *label13
    57 printflush message1
    58 label *label2
 
    82 op equal *tmp20 .MODE 0
    83 jump *label14 equal *tmp20 false
    84 set .REASON "Processor reset"
-    * set *tmp21 .REASON
    85 jump *label15 always
    86 label *label14
    87 set .REASON "Reason unknown -- out of power?"
-    * set *tmp21 .REASON
    88 label *label15
    89 op notEqual *tmp23 .MODE 0
    90 control enabled switch1 *tmp23
 
   173 label *label24
   174 set *tmp46 *tmp55
   175 label *label22
-    * set *tmp43 *tmp46
   176 jump *label20 always
   177 label *label19
-    * set *tmp43 null
   178 label *label20
   179 jump *label29 equal .MODE 0
   180 jump *label28 always
 
   215 print " ([gold]"
   216 print :multiplier
   217 print "x[])"
-    * set *tmp63 "x[])"
   218 jump *label35 always
   219 label *label34
-    * set *tmp63 null
   220 label *label35
   221 print "\n=================================="
   222 sensor *tmp69 tank1 @totalLiquids
   223 op lessThan *tmp70 *tmp69 750
   224 jump *label36 equal *tmp70 false
   225 print "\n[salmon]Cryofluid level critical![]"
-    * set *tmp71 "\n[salmon]Cryofluid level critical![]"
   226 jump *label37 always
   227 label *label36
-    * set *tmp71 null
   228 label *label37
   229 sensor *tmp72 vault1 @blast-compound
   230 op lessThan *tmp73 *tmp72 700
   231 jump *label38 equal *tmp73 false
   232 print "\n[salmon]Blast compound level critical![]"
-    * set *tmp74 "\n[salmon]Blast compound level critical![]"
   233 jump *label39 always
   234 label *label38
-    * set *tmp74 null
   235 label *label39
   236 op equal *tmp75 :enough_battery false
   237 jump *label40 equal *tmp75 false
 
   242 print :missing_battery
   243 print " "
   244 print "K[] of additional storage to internal battery."
-    * set *tmp76 null
   245 jump *label41 always
   246 label *label40
-    * set *tmp76 null
   247 label *label41
   248 print "\n"
   249 print "Internal battery:    [gold]"
 
   295 label *label45
   296 set *tmp83 null
   297 label *label46
-    * set *tmp77 *tmp83
   298 jump *label42 always
   299 label *label43
   300 jump *label48 equal .MODE 1
 
   344 print :neededPower
   345 print "["
   346 print "]"
-    * set *tmp96 null
   347 jump *label56 always
   348 label *label55
-    * set *tmp96 null
   349 label *label56
   350 op greaterThan *tmp97 :net_power 100
   351 jump *label57 equal *tmp97 false
   352 set .OVERDRIVE true
-    * set *tmp98 .OVERDRIVE
   353 jump *label58 always
   354 label *label57
-    * set *tmp98 null
   355 label *label58
   356 op lessThan *tmp99 .REACTORS_ON :reactors
   357 op greaterThan *tmp100 :net_power 1000
 
   363 jump *label59 equal *tmp104 false
   364 set .OUTPUT_2 .OUTPUT_1
   365 set .OUTPUT_1 1
-    * set *tmp105 .OUTPUT_1
   366 jump *label60 always
   367 label *label59
-    * set *tmp105 null
   368 label *label60
   369 op equal *tmp106 .OUTPUT_1 0
   370 jump *label61 equal *tmp106 false
 
   381 label *label63
   382 set *tmp111 null
   383 label *label64
-    * set *tmp107 *tmp111
   384 jump *label62 always
   385 label *label61
-    * set *tmp107 null
   386 label *label62
   387 op greaterThan *tmp113 @time :nextStart
   388 op land *tmp114 :canStart *tmp113
 
   400 set .REACTORS_ON *tmp119
   401 op add *tmp120 @time 2000
   402 set :nextStart *tmp120
-    * set *tmp115 :nextStart
   403 jump *label66 always
   404 label *label65
-    * set *tmp115 null
   405 label *label66
   406 op greaterThanEq *tmp121 .REACTORS_ON :reactors
   407 op greaterThan *tmp122 @time :nextStart
 
   422 label *label70
   423 set *tmp90 *tmp126
   424 label *label52
-    * set *tmp77 *tmp90
   425 jump *label42 always
   426 label *label47
   427 jump *label72 equal .MODE 2
 
   434 set .MODE 0
   435 control enabled switch1 false
   436 set .REASON "Cryo level too low"
-    * set *tmp131 .REASON
   437 jump *label74 always
   438 label *label73
-    * set *tmp131 null
   439 label *label74
   440 sensor *tmp133 vault1 @blast-compound
   441 op lessThan *tmp134 *tmp133 700
 
   444 set .MODE 0
   445 control enabled switch1 false
   446 set .REASON "Blast compound level too low"
-    * set *tmp136 .REASON
   447 jump *label76 always
   448 label *label75
-    * set *tmp136 null
   449 label *label76
   450 sensor *tmp138 tank1 @totalLiquids
   451 op greaterThan *tmp139 *tmp138 1000
 
   479 op idiv *tmp160 :commit_level 1000
   480 print "\nCommit threshold:   [gold]"
   481 print *tmp160
-    * set *tmp152 *tmp160
   482 jump *label80 always
   483 label *label79
-    * set *tmp152 null
   484 label *label80
   485 op equal *tmp161 :commit_level 0
   486 jump *label81 equal *tmp161 false
   487 op idiv *tmp163 :min_level 1000
   488 print "\nRestart threshold: [gold]"
   489 print *tmp163
-    * set *tmp162 *tmp163
   490 jump *label82 always
   491 label *label81
-    * set *tmp162 null
   492 label *label82
   493 print "[] K"
   494 op lessThan *tmp164 :total_battery :min_level
 
   511 jump *label85 equal *tmp173 false
   512 op add *tmp175 @time 6000
   513 set :nextDecommit *tmp175
-    * set *tmp174 :nextDecommit
   514 jump *label86 always
   515 label *label85
-    * set *tmp174 null
   516 label *label86
   517 op greaterThan *tmp176 @time :nextDecommit
   518 jump *label87 equal *tmp176 false
   519 jump *label89 equal .OVERDRIVE false
   520 set .OVERDRIVE false
-    * set *tmp178 .OVERDRIVE
   521 jump *label90 always
   522 label *label89
   523 op sub *tmp179 .REACTORS_ON 1
   524 op max *tmp180 *tmp179 1
   525 set .REACTORS_ON *tmp180
   526 set .CAN_COMMIT true
-    * set *tmp178 .CAN_COMMIT
   527 label *label90
   528 op add *tmp181 @time 6000
   529 set :nextDecommit *tmp181
 
   544 label *label88
   545 set *tmp168 *tmp177
   546 label *label84
-    * set *tmp146 *tmp168
   547 jump *label78 always
   548 label *label77
   549 sensor *tmp184 switch2 @enabled
   550 jump *label93 equal *tmp184 false
   551 print "\n[salmon]Load adapting not possible.[]"
-    * set *tmp185 "\n[salmon]Load adapting not possible.[]"
   552 jump *label94 always
   553 label *label93
   554 print "\n[gold]Load adapting not active.[]"
-    * set *tmp185 "\n[gold]Load adapting not active.[]"
   555 label *label94
   556 set .REACTORS_ON :reactors
   557 set .OVERDRIVE true
-    * set *tmp146 .OVERDRIVE
   558 label *label78
   559 op mul *tmp186 PLANT_PROTECTION 47500
   560 op lessThan *tmp187 :total_battery *tmp186
   561 jump *label95 equal *tmp187 false
   562 set .OUTPUT_2 0
-    * set *tmp188 .OUTPUT_2
   563 jump *label96 always
   564 label *label95
-    * set *tmp188 null
   565 label *label96
   566 op equal *tmp189 .OUTPUT_2 0
   567 jump *label97 equal *tmp189 false
 
   579 label *label97
   580 set *tmp190 null
   581 label *label98
-    * set *tmp77 *tmp190
   582 jump *label42 always
   583 label *label71
-    * set *tmp77 null
   584 label *label42
   585 print "\n"
   586 print .STARTUPS
 
   621 label *label107
   622 set *tmp206 null
   623 label *label108
-    * set *tmp200 *tmp206
   624 jump *label104 always
   625 label *label105
   626 jump *label110 equal *tmp201 @overdrive-projector
 
   629 label *label110
   630 set *tmp208 :block
   631 control enabled *tmp208 .OVERDRIVE
-    * set *tmp200 .OVERDRIVE
   632 jump *label104 always
   633 label *label109
   634 jump *label112 equal *tmp201 @conduit
 
   642 label *label112
   643 set *tmp210 :block
   644 control enabled *tmp210 :startup
-    * set *tmp200 :startup
   645 jump *label104 always
   646 label *label111
-    * set *tmp200 null
   647 label *label104
   648 label *label102
   649 op add :n :n 1
 
   658 op add :reactors :reactors *tmp217
   659 read *tmp218 cell2 4
   660 op add :boosts :boosts *tmp218
-    * set *tmp213 :boosts
   661 jump *label114 always
   662 label *label113
-    * set *tmp213 null
   663 label *label114
   664 op min *tmp219 .REACTORS_ON :reactors
   665 set .REACTORS_ON *tmp219
 
   668 set .STARTUPS 0
   669 set .RESETS 0
   670 set .COMMITS 0
-    * set *tmp221 .COMMITS
   671 jump *label116 always
   672 label *label115
   673 write .MODE cell1 0
 
   680 write .STARTUPS cell1 7
   681 write .RESETS cell1 8
   682 write .COMMITS cell1 9
-    * set *tmp221 .COMMITS
   683 label *label116
   684 label *label17
   685 jump *label16 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-14 instructions):
 
   132 jump *label21 equal *tmp45 false
   133 set .MODE 0
   134 set .REASON "Manual power off"
-    * set *tmp46 .REASON
   135 jump *label22 always
   136 label *label21
   137 op mul *tmp47 .REACTORS_ON 1200
 
   170 set :failure_cnt 0
   171 set *tmp55 :failure_cnt
   172 label *label24
-    * set *tmp46 *tmp55
   173 label *label22
   174 jump *label20 always
   175 label *label19
 
   288 set :failure_cnt 0
   289 set .GENERATOR true
   290 set .REASON "Unknown -- out of power?"
-    * set *tmp83 .REASON
   291 jump *label46 always
   292 label *label45
-    * set *tmp83 null
   293 label *label46
   294 jump *label42 always
   295 label *label43
 
   323 print " K[]"
   324 set *tmp92 " K[]"
   325 label *label54
-    * set *tmp90 *tmp92
   326 jump *label52 always
   327 label *label51
   328 op add *tmp94 .OUTPUT_1 .OUTPUT_2
 
   371 jump *label63 equal *tmp110 false
   372 op add *tmp112 @time 2000
   373 set :nextStart *tmp112
-    * set *tmp111 :nextStart
   374 jump *label64 always
   375 label *label63
-    * set *tmp111 null
   376 label *label64
   377 jump *label62 always
   378 label *label61
 
   413 label *label69
   414 set *tmp126 null
   415 label *label70
-    * set *tmp90 *tmp126
   416 label *label52
   417 jump *label42 always
   418 label *label47
 
   494 set .REACTORS_ON :reactors
   495 op add *tmp170 @time 6000
   496 set :nextDecommit *tmp170
-    * set *tmp168 :nextDecommit
   497 jump *label84 always
   498 label *label83
   499 op lessThan *tmp171 :battery_level 47500
 
   533 label *label92
   534 set *tmp177 *tmp183
   535 label *label88
-    * set *tmp168 *tmp177
   536 label *label84
   537 jump *label78 always
   538 label *label77
 
   564 print "\n*** [gold]Surge tower 2 offline[] ***"
   565 set *tmp192 "\n*** [gold]Surge tower 2 offline[] ***"
   566 label *label100
-    * set *tmp190 *tmp192
   567 jump *label98 always
   568 label *label97
-    * set *tmp190 null
   569 label *label98
   570 jump *label42 always
   571 label *label71
 
   604 jump *label107 equal :enabled false
   605 sensor *tmp207 :block @timescale
   606 op add :boosts :boosts *tmp207
-    * set *tmp206 :boosts
   607 jump *label108 always
   608 label *label107
-    * set *tmp206 null
   609 label *label108
   610 jump *label104 always
   611 label *label105

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   164 label *label25
   165 set *tmp59 null
   166 label *label26
-    * set *tmp55 *tmp59
   167 jump *label24 always
   168 label *label23
   169 set :failure_cnt 0
-    * set *tmp55 :failure_cnt
   170 label *label24
   171 label *label22
   172 jump *label20 always
 
   313 set .REACTORS_ON 1
   314 op add *tmp93 @time 2000
   315 set :nextStart *tmp93
-    * set *tmp92 :nextStart
   316 jump *label54 always
   317 label *label53
   318 print "\nRequired startup energy: [gold]"
   319 print 25
   320 print " K[]"
-    * set *tmp92 " K[]"
   321 label *label54
   322 jump *label52 always
   323 label *label51
 
   404 set .COOLANT_FLAG 0
   405 set .FUEL_FLAG 0
   406 set .GENERATOR false
-    * set *tmp126 .GENERATOR
   407 jump *label70 always
   408 label *label69
-    * set *tmp126 null
   409 label *label70
   410 label *label52
   411 jump *label42 always
 
   512 label *label90
   513 op add *tmp181 @time 6000
   514 set :nextDecommit *tmp181
-    * set *tmp177 :nextDecommit
   515 jump *label88 always
   516 label *label87
   517 op lessThan *tmp182 :total_battery :commit_level
 
   524 label *label91
   525 set *tmp183 null
   526 label *label92
-    * set *tmp177 *tmp183
   527 label *label88
   528 label *label84
   529 jump *label78 always
 
   550 op greaterThan *tmp191 :total_battery 47500
   551 jump *label99 equal *tmp191 false
   552 set .OUTPUT_2 1
-    * set *tmp192 .OUTPUT_2
   553 jump *label100 always
   554 label *label99
   555 print "\n*** [gold]Surge tower 2 offline[] ***"
-    * set *tmp192 "\n*** [gold]Surge tower 2 offline[] ***"
   556 label *label100
   557 jump *label98 always
   558 label *label97

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-4 instructions):
 
   159 print "\nMin. consumption: "
   160 print :min_consumption
   161 printflush message2
-    * set *tmp59 null
   162 jump *label26 always
   163 label *label25
-    * set *tmp59 null
   164 label *label26
   165 jump *label24 always
   166 label *label23
 
   517 op add .REACTORS_ON .REACTORS_ON 1
   518 op add .COMMITS .COMMITS 1
   519 set .CAN_COMMIT false
-    * set *tmp183 .CAN_COMMIT
   520 jump *label92 always
   521 label *label91
-    * set *tmp183 null
   522 label *label92
   523 label *label88
   524 label *label84

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-56 instructions):
 
     9 op equal *tmp0 :reactors 0
    10 jump *label3 equal *tmp0 false
    11 set :reactors 0
-    * set *tmp1 @links
-    * set :n *tmp1
+   12 set :n @links
    13 label *label4
    14 op greaterThan *tmp2 :n 0
    15 jump *label6 equal *tmp2 false
    16 op sub :n :n 1
-    * getlink *tmp3 :n
-    * set :block *tmp3
+   17 getlink :block :n
    18 print "Found: "
    19 print :block
    20 print "\n"
 
    56 label *label2
    57 jump *label1 always
    58 label *label3
-    * read *tmp10 cell1 0
-    * set .MODE *tmp10
-    * read *tmp11 cell1 1
-    * set .OUTPUT_1 *tmp11
-    * read *tmp12 cell1 2
-    * set .OUTPUT_2 *tmp12
-    * read *tmp13 cell1 3
-    * set .REACTORS_ON *tmp13
-    * read *tmp14 cell1 4
-    * set .OVERDRIVE *tmp14
-    * read *tmp15 cell1 5
-    * set .GENERATOR *tmp15
-    * read *tmp16 cell1 6
-    * set .CAN_COMMIT *tmp16
-    * read *tmp17 cell1 7
-    * set .STARTUPS *tmp17
-    * read *tmp18 cell1 8
-    * set .RESETS *tmp18
-    * read *tmp19 cell1 9
-    * set .COMMITS *tmp19
+   59 read .MODE cell1 0
+   60 read .OUTPUT_1 cell1 1
+   61 read .OUTPUT_2 cell1 2
+   62 read .REACTORS_ON cell1 3
+   63 read .OVERDRIVE cell1 4
+   64 read .GENERATOR cell1 5
+   65 read .CAN_COMMIT cell1 6
+   66 read .STARTUPS cell1 7
+   67 read .RESETS cell1 8
+   68 read .COMMITS cell1 9
    69 set :reactors .REACTORS_ON
    70 op equal *tmp20 .MODE 0
    71 jump *label14 equal *tmp20 false
 
    79 set :failure_cnt 0
    80 set :boosts 0
    81 set :nextStart 0
-    * op add *tmp24 @time 6000
-    * set :nextDecommit *tmp24
+   82 op add :nextDecommit @time 6000
    83 label *label16
    84 jump *label18 equal true false
    85 sensor *tmp25 battery1 @totalPower
-    * op floor *tmp26 *tmp25
-    * set :battery_level *tmp26
-    * op idiv *tmp27 :battery_level 1000
-    * set :battery_level_str *tmp27
+   86 op floor :battery_level *tmp25
+   87 op idiv :battery_level_str :battery_level 1000
    88 sensor *tmp28 battery1 @powerNetStored
-    * op floor *tmp29 *tmp28
-    * set :total_battery *tmp29
-    * op idiv *tmp30 :total_battery 1000
-    * set :total_battery_str *tmp30
-    * sensor *tmp31 battery1 @powerNetOut
-    * set :consumption *tmp31
-    * read *tmp32 bank1 509
-    * set :production *tmp32
-    * read *tmp33 bank1 510
-    * set :net_power *tmp33
-    * read *tmp34 bank1 511
-    * set :battery_change *tmp34
-    * sensor *tmp35 battery1 @powerNetCapacity
-    * set :total_capacity *tmp35
-    * op idiv *tmp36 :total_capacity 1000
-    * set :total_capacity_str *tmp36
-    * op mul *tmp37 100000 :reactors
-    * set :required_capacity *tmp37
-    * op greaterThanEq *tmp38 :total_capacity :required_capacity
-    * set :enough_battery *tmp38
+   89 op floor :total_battery *tmp28
+   90 op idiv :total_battery_str :total_battery 1000
+   91 sensor :consumption battery1 @powerNetOut
+   92 read :production bank1 509
+   93 read :net_power bank1 510
+   94 read :battery_change bank1 511
+   95 sensor :total_capacity battery1 @powerNetCapacity
+   96 op idiv :total_capacity_str :total_capacity 1000
+   97 op mul :required_capacity 100000 :reactors
+   98 op greaterThanEq :enough_battery :total_capacity :required_capacity
    99 op sub *tmp39 :required_capacity :total_capacity
   100 op div *tmp40 *tmp39 1000
-    * op ceil *tmp41 *tmp40
-    * set :missing_battery *tmp41
+  101 op ceil :missing_battery *tmp40
   102 op notEqual *tmp42 .MODE 0
   103 jump *label19 equal *tmp42 false
   104 sensor *tmp44 switch1 @enabled
 
   108 set .REASON "Manual power off"
   109 jump *label22 always
   110 label *label21
-    * op mul *tmp47 .REACTORS_ON 1200
-    * set :min_consumption *tmp47
-    * op lessThan *tmp48 :consumption :min_consumption
-    * set :failure1 *tmp48
+  111 op mul :min_consumption .REACTORS_ON 1200
+  112 op lessThan :failure1 :consumption :min_consumption
   113 op equal *tmp49 :battery_level 0
   114 op greaterThan *tmp50 :consumption 0
   115 op land *tmp51 *tmp49 *tmp50
   116 op equal *tmp52 :production 0
-    * op land *tmp53 *tmp51 *tmp52
-    * set :failure2 *tmp53
+  117 op land :failure2 *tmp51 *tmp52
   118 op or *tmp54 :failure1 :failure2
   119 jump *label23 equal *tmp54 false
   120 op add :failure_cnt :failure_cnt 1
 
   175 op div *tmp65 *tmp64 .REACTORS_ON
   176 op add *tmp66 *tmp65 0.5
   177 op floor *tmp67 *tmp66
-    * op div *tmp68 *tmp67 100
-    * set :multiplier *tmp68
+  178 op div :multiplier *tmp67 100
   179 print " ([gold]"
   180 print :multiplier
   181 print "x[])"
 
   241 set .OUTPUT_2 0
   242 op greaterThanEq *tmp79 :net_power -150
   243 op lessThan *tmp80 :total_battery 47500
-    * op land *tmp81 *tmp79 *tmp80
-    * set .GENERATOR *tmp81
+  244 op land .GENERATOR *tmp79 *tmp80
   245 print "\nShutdown reason: [gold]"
   246 print .REASON
   247 print "[]"
 
   271 sensor *tmp85 :nextBattery @powerNetOut
   272 op mul *tmp86 *tmp85 1.05
   273 op floor *tmp87 *tmp86
-    * op max *tmp88 *tmp87 1000
-    * set :neededPower *tmp88
+  274 op max :neededPower *tmp87 1000
   275 op equal *tmp89 .REACTORS_ON 0
   276 jump *label51 equal *tmp89 false
   277 op greaterThanEq *tmp91 :total_battery 25000
   278 jump *label53 equal *tmp91 false
   279 set .REACTORS_ON 1
-    * op add *tmp93 @time 2000
-    * set :nextStart *tmp93
+  280 op add :nextStart @time 2000
   281 jump *label54 always
   282 label *label53
   283 print "\nRequired startup energy: [gold]"
 
   286 label *label54
   287 jump *label52 always
   288 label *label51
-    * op add *tmp94 .OUTPUT_1 .OUTPUT_2
-    * set :outputs *tmp94
+  289 op add :outputs .OUTPUT_1 .OUTPUT_2
   290 print "\n"
   291 print "[gold]"
   292 print :outputs
 
   312 op greaterThan *tmp100 :net_power 1000
   313 op land *tmp101 *tmp99 *tmp100
   314 op greaterThanEq *tmp102 :total_battery 25000
-    * op land *tmp103 *tmp101 *tmp102
-    * set :canStart *tmp103
+  315 op land :canStart *tmp101 *tmp102
   316 op greaterThanEq *tmp104 :net_power :neededPower
   317 jump *label59 equal *tmp104 false
   318 set .OUTPUT_2 .OUTPUT_1
 
   322 label *label60
   323 op equal *tmp106 .OUTPUT_1 0
   324 jump *label61 equal *tmp106 false
-    * op mul *tmp108 6300 :boosts
-    * set :availablePower *tmp108
-    * op div *tmp109 :neededPower :availablePower
-    * set :ratio *tmp109
+  325 op mul :availablePower 6300 :boosts
+  326 op div :ratio :neededPower :availablePower
   327 op lessThan *tmp110 :ratio 1
   328 jump *label63 equal *tmp110 false
-    * op add *tmp112 @time 2000
-    * set :nextStart *tmp112
+  329 op add :nextStart @time 2000
   330 jump *label64 always
   331 label *label63
   332 label *label64
 
   337 op land *tmp114 :canStart *tmp113
   338 jump *label65 equal *tmp114 false
   339 jump *label67 equal FAST_START false
-    * op idiv *tmp117 :total_battery 25000
-    * set *tmp116 *tmp117
+  340 op idiv *tmp116 :total_battery 25000
   341 jump *label68 always
   342 label *label67
   343 set *tmp116 1
   344 label *label68
   345 set :start_at_once *tmp116
   346 op add *tmp118 .REACTORS_ON :start_at_once
-    * op min *tmp119 *tmp118 :reactors
-    * set .REACTORS_ON *tmp119
-    * op add *tmp120 @time 2000
-    * set :nextStart *tmp120
+  347 op min .REACTORS_ON *tmp118 :reactors
+  348 op add :nextStart @time 2000
   349 jump *label66 always
   350 label *label65
   351 label *label66
 
   356 op land *tmp125 *tmp123 *tmp124
   357 jump *label69 equal *tmp125 false
   358 set .MODE 2
-    * op add *tmp127 @time 6000
-    * set :nextDecommit *tmp127
+  359 op add :nextDecommit @time 6000
   360 set .COOLANT_FLAG 0
   361 set .FUEL_FLAG 0
   362 set .GENERATOR false
 
   391 label *label76
   392 sensor *tmp138 tank1 @totalLiquids
   393 op greaterThan *tmp139 *tmp138 1000
-    * op or *tmp140 .COOLANT_FLAG *tmp139
-    * set .COOLANT_FLAG *tmp140
+  394 op or .COOLANT_FLAG .COOLANT_FLAG *tmp139
   395 sensor *tmp141 vault1 @blast-compound
   396 op greaterThan *tmp142 *tmp141 800
-    * op or *tmp143 .FUEL_FLAG *tmp142
-    * set .FUEL_FLAG *tmp143
+  397 op or .FUEL_FLAG .FUEL_FLAG *tmp142
   398 sensor *tmp144 switch2 @enabled
   399 op land *tmp145 :enough_battery *tmp144
   400 jump *label77 equal *tmp145 false
-    * op mul *tmp147 0.5 :required_capacity
-    * set :min_level *tmp147
+  401 op mul :min_level 0.5 :required_capacity
   402 set :commit_level 0
   403 op lessThan *tmp148 :battery_change 0
   404 op land *tmp149 .CAN_COMMIT *tmp148
 
   406 op land *tmp151 *tmp149 *tmp150
   407 jump *label79 equal *tmp151 false
   408 op sub *tmp153 :battery_change 1500
-    * op sub *tmp154 *tmp153 1000
-    * set :p *tmp154
+  409 op sub :p *tmp153 1000
   410 op mul *tmp155 :p 0.00472972972972973
   411 op add *tmp156 -5 *tmp155
   412 op mul *tmp157 :p *tmp156
-    * op add *tmp158 25000 *tmp157
-    * set :commit_margin *tmp158
-    * op add *tmp159 :min_level :commit_margin
-    * set :commit_level *tmp159
+  413 op add :commit_margin 25000 *tmp157
+  414 op add :commit_level :min_level :commit_margin
   415 op idiv *tmp160 :commit_level 1000
   416 print "\nCommit threshold:   [gold]"
   417 print *tmp160
 
   436 op add .RESETS .RESETS *tmp169
   437 set .OVERDRIVE true
   438 set .REACTORS_ON :reactors
-    * op add *tmp170 @time 6000
-    * set :nextDecommit *tmp170
+  439 op add :nextDecommit @time 6000
   440 jump *label84 always
   441 label *label83
   442 op lessThan *tmp171 :battery_level 47500
   443 op lessThan *tmp172 :battery_change -100
   444 op or *tmp173 *tmp171 *tmp172
   445 jump *label85 equal *tmp173 false
-    * op add *tmp175 @time 6000
-    * set :nextDecommit *tmp175
+  446 op add :nextDecommit @time 6000
   447 jump *label86 always
   448 label *label85
   449 label *label86
 
   454 jump *label90 always
   455 label *label89
   456 op sub *tmp179 .REACTORS_ON 1
-    * op max *tmp180 *tmp179 1
-    * set .REACTORS_ON *tmp180
+  457 op max .REACTORS_ON *tmp179 1
   458 set .CAN_COMMIT true
   459 label *label90
-    * op add *tmp181 @time 6000
-    * set :nextDecommit *tmp181
+  460 op add :nextDecommit @time 6000
   461 jump *label88 always
   462 label *label87
   463 op lessThan *tmp182 :total_battery :commit_level
 
   515 control enabled diode2 .OUTPUT_2
   516 control enabled generator1 .GENERATOR
   517 control enabled generator2 .GENERATOR
-    * op equal *tmp197 .MODE 1
-    * set :startup *tmp197
+  518 op equal :startup .MODE 1
   519 set :reactors 0
   520 set :boosts 0
   521 set :enabled true
 
   523 set :n .START
   524 label *label101
   525 jump *label103 greaterThanEq :n *tmp198
-    * getlink *tmp199 :n
-    * set :block *tmp199
+  526 getlink :block :n
   527 sensor *tmp201 :block @type
   528 jump *label106 equal *tmp201 @impact-reactor
   529 jump *label105 always
   530 label *label106
   531 op add :reactors :reactors 1
-    * op lessThanEq *tmp203 :reactors .REACTORS_ON
-    * set :enabled *tmp203
+  532 op lessThanEq :enabled :reactors .REACTORS_ON
   533 set *tmp204 :block
   534 control enabled *tmp204 :enabled
   535 jump *label107 equal :enabled false
 
   578 jump *label114 always
   579 label *label113
   580 label *label114
-    * op min *tmp219 .REACTORS_ON :reactors
-    * set .REACTORS_ON *tmp219
+  581 op min .REACTORS_ON .REACTORS_ON :reactors
   582 op equal *tmp220 cell1 null
   583 jump *label115 equal *tmp220 false
   584 set .STARTUPS 0

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    81 set :nextStart 0
    82 op add :nextDecommit @time 6000
    83 label *label16
-    * jump *label18 equal true false
    84 sensor *tmp25 battery1 @totalPower
    85 op floor :battery_level *tmp25
    86 op idiv :battery_level_str :battery_level 1000

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-11 instructions):
 
    19 print :block
    20 print "\n"
    21 sensor *tmp5 :block @type
-    * jump *label9 equal *tmp5 @impact-reactor
-    * jump *label8 always
+   22 jump *label8 notEqual *tmp5 @impact-reactor
    23 label *label9
    24 set .START :n
    25 op add :reactors :reactors 1
 
    33 jump *label11 equal *tmp5 @conveyor
    34 jump *label11 equal *tmp5 @titanium-conveyor
    35 jump *label11 equal *tmp5 @plastanium-conveyor
-    * jump *label11 equal *tmp5 @armored-conveyor
-    * jump *label10 always
+   36 jump *label10 notEqual *tmp5 @armored-conveyor
    37 label *label11
    38 set .START :n
    39 jump *label7 always
 
   138 jump *label20 always
   139 label *label19
   140 label *label20
-    * jump *label29 equal .MODE 0
-    * jump *label28 always
+  141 jump *label28 notEqual .MODE 0
   142 label *label29
   143 set *tmp61 "[salmon]SHUTDOWN[]"
   144 jump *label27 always
   145 label *label28
-    * jump *label31 equal .MODE 1
-    * jump *label30 always
+  146 jump *label30 notEqual .MODE 1
   147 label *label31
   148 set *tmp61 "[gold]STARTUP[]"
   149 jump *label27 always
   150 label *label30
-    * jump *label33 equal .MODE 2
-    * jump *label32 always
+  151 jump *label32 notEqual .MODE 2
   152 label *label33
   153 set *tmp61 "[green]RUNNING[]"
   154 jump *label27 always
 
   226 print :net_power
   227 print "["
   228 print "]"
-    * jump *label44 equal .MODE 0
-    * jump *label43 always
+  229 jump *label43 notEqual .MODE 0
   230 label *label44
   231 set .REACTORS_ON 0
   232 set .OVERDRIVE 0
 
   251 label *label46
   252 jump *label42 always
   253 label *label43
-    * jump *label48 equal .MODE 1
-    * jump *label47 always
+  254 jump *label47 notEqual .MODE 1
   255 label *label48
   256 jump *label49 equal .OUTPUT_1 false
   257 set *tmp84 battery3
 
   358 label *label52
   359 jump *label42 always
   360 label *label47
-    * jump *label72 equal .MODE 2
-    * jump *label71 always
+  361 jump *label71 notEqual .MODE 2
   362 label *label72
   363 sensor *tmp128 tank1 @totalLiquids
   364 op lessThan *tmp129 *tmp128 750
 
   516 jump *label103 greaterThanEq :n *tmp198
   517 getlink :block :n
   518 sensor *tmp201 :block @type
-    * jump *label106 equal *tmp201 @impact-reactor
-    * jump *label105 always
+  519 jump *label105 notEqual *tmp201 @impact-reactor
   520 label *label106
   521 op add :reactors :reactors 1
   522 op lessThanEq :enabled :reactors .REACTORS_ON
 
   531 jump *label104 always
   532 label *label105
   533 jump *label110 equal *tmp201 @overdrive-projector
-    * jump *label110 equal *tmp201 @overdrive-dome
-    * jump *label109 always
+  534 jump *label109 notEqual *tmp201 @overdrive-dome
   535 label *label110
   536 set *tmp208 :block
   537 control enabled *tmp208 .OVERDRIVE
 
   543 jump *label112 equal *tmp201 @conveyor
   544 jump *label112 equal *tmp201 @titanium-conveyor
   545 jump *label112 equal *tmp201 @plastanium-conveyor
-    * jump *label112 equal *tmp201 @armored-conveyor
-    * jump *label111 always
+  546 jump *label111 notEqual *tmp201 @armored-conveyor
   547 label *label112
   548 set *tmp210 :block
   549 control enabled *tmp210 :startup

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-25 instructions):
 
     6 set .START null
     7 set :reactors 0
     8 label *label1
-    * op equal *tmp0 :reactors 0
-    * jump *label3 equal *tmp0 false
+    9 jump *label3 notEqual :reactors 0
    10 set :reactors 0
    11 set :n @links
    12 label *label4
-    * op greaterThan *tmp2 :n 0
-    * jump *label6 equal *tmp2 false
+   13 jump *label6 lessThanEq :n 0
    14 op sub :n :n 1
    15 getlink :block :n
    16 print "Found: "
 
    42 label *label6
    43 read *tmp7 cell2 1
    44 op add :reactors :reactors *tmp7
-    * op equal *tmp8 :reactors 0
-    * jump *label12 equal *tmp8 false
+   45 jump *label12 notEqual :reactors 0
    46 print "No reactor."
    47 jump *label13 always
    48 label *label12
 
    62 read .RESETS cell1 8
    63 read .COMMITS cell1 9
    64 set :reactors .REACTORS_ON
-    * op equal *tmp20 .MODE 0
-    * jump *label14 equal *tmp20 false
+   65 jump *label14 notEqual .MODE 0
    66 set .REASON "Processor reset"
    67 jump *label15 always
    68 label *label14
 
    92 op sub *tmp39 :required_capacity :total_capacity
    93 op div *tmp40 *tmp39 1000
    94 op ceil :missing_battery *tmp40
-    * op notEqual *tmp42 .MODE 0
-    * jump *label19 equal *tmp42 false
+   95 jump *label19 equal .MODE 0
    96 sensor *tmp44 switch1 @enabled
-    * op equal *tmp45 *tmp44 false
-    * jump *label21 equal *tmp45 false
+   97 jump *label21 notEqual *tmp44 false
    98 set .MODE 0
    99 set .REASON "Manual power off"
   100 jump *label22 always
 
   111 op add :failure_cnt :failure_cnt 1
   112 read *tmp56 cell2 1
   113 op add *tmp57 10 *tmp56
-    * op greaterThan *tmp58 :failure_cnt *tmp57
-    * jump *label25 equal *tmp58 false
+  114 jump *label25 lessThanEq :failure_cnt *tmp57
   115 set .MODE 0
   116 control enabled switch1 false
   117 set .REASON "Unknown -- out of power?"
 
   171 label *label35
   172 print "\n=================================="
   173 sensor *tmp69 tank1 @totalLiquids
-    * op lessThan *tmp70 *tmp69 750
-    * jump *label36 equal *tmp70 false
+  174 jump *label36 greaterThanEq *tmp69 750
   175 print "\n[salmon]Cryofluid level critical![]"
   176 jump *label37 always
   177 label *label36
   178 label *label37
   179 sensor *tmp72 vault1 @blast-compound
-    * op lessThan *tmp73 *tmp72 700
-    * jump *label38 equal *tmp73 false
+  180 jump *label38 greaterThanEq *tmp72 700
   181 print "\n[salmon]Blast compound level critical![]"
   182 jump *label39 always
   183 label *label38
   184 label *label39
-    * op equal *tmp75 :enough_battery false
-    * jump *label40 equal *tmp75 false
+  185 jump *label40 notEqual :enough_battery false
   186 print "\n"
   187 print "[salmon]Insufficient battery storage![]"
   188 print "\n"
 
   254 op mul *tmp86 *tmp85 1.05
   255 op floor *tmp87 *tmp86
   256 op max :neededPower *tmp87 1000
-    * op equal *tmp89 .REACTORS_ON 0
-    * jump *label51 equal *tmp89 false
-    * op greaterThanEq *tmp91 :total_battery 25000
-    * jump *label53 equal *tmp91 false
+  257 jump *label51 notEqual .REACTORS_ON 0
+  258 jump *label53 lessThan :total_battery 25000
   259 set .REACTORS_ON 1
   260 op add :nextStart @time 2000
   261 jump *label54 always
 
   272 print :outputs
   273 print "["
   274 print "] surge tower(s) online"
-    * op equal *tmp95 .OUTPUT_2 0
-    * jump *label55 equal *tmp95 false
+  275 jump *label55 notEqual .OUTPUT_2 0
   276 print "\n"
   277 print "Required power level: [gold]"
   278 print :neededPower
 
   281 jump *label56 always
   282 label *label55
   283 label *label56
-    * op greaterThan *tmp97 :net_power 100
-    * jump *label57 equal *tmp97 false
+  284 jump *label57 lessThanEq :net_power 100
   285 set .OVERDRIVE true
   286 jump *label58 always
   287 label *label57
 
   291 op land *tmp101 *tmp99 *tmp100
   292 op greaterThanEq *tmp102 :total_battery 25000
   293 op land :canStart *tmp101 *tmp102
-    * op greaterThanEq *tmp104 :net_power :neededPower
-    * jump *label59 equal *tmp104 false
+  294 jump *label59 lessThan :net_power :neededPower
   295 set .OUTPUT_2 .OUTPUT_1
   296 set .OUTPUT_1 1
   297 jump *label60 always
   298 label *label59
   299 label *label60
-    * op equal *tmp106 .OUTPUT_1 0
-    * jump *label61 equal *tmp106 false
+  300 jump *label61 notEqual .OUTPUT_1 0
   301 op mul :availablePower 6300 :boosts
   302 op div :ratio :neededPower :availablePower
-    * op lessThan *tmp110 :ratio 1
-    * jump *label63 equal *tmp110 false
+  303 jump *label63 greaterThanEq :ratio 1
   304 op add :nextStart @time 2000
   305 jump *label64 always
   306 label *label63
 
   392 jump *label80 always
   393 label *label79
   394 label *label80
-    * op equal *tmp161 :commit_level 0
-    * jump *label81 equal *tmp161 false
+  395 jump *label81 notEqual :commit_level 0
   396 op idiv *tmp163 :min_level 1000
   397 print "\nRestart threshold: [gold]"
   398 print *tmp163
 
   420 jump *label86 always
   421 label *label85
   422 label *label86
-    * op greaterThan *tmp176 @time :nextDecommit
-    * jump *label87 equal *tmp176 false
+  423 jump *label87 lessThanEq @time :nextDecommit
   424 jump *label89 equal .OVERDRIVE false
   425 set .OVERDRIVE false
   426 jump *label90 always
 
   432 op add :nextDecommit @time 6000
   433 jump *label88 always
   434 label *label87
-    * op lessThan *tmp182 :total_battery :commit_level
-    * jump *label91 equal *tmp182 false
+  435 jump *label91 greaterThanEq :total_battery :commit_level
   436 op add .REACTORS_ON .REACTORS_ON 1
   437 op add .COMMITS .COMMITS 1
   438 set .CAN_COMMIT false
 
   454 set .OVERDRIVE true
   455 label *label78
   456 op mul *tmp186 PLANT_PROTECTION 47500
-    * op lessThan *tmp187 :total_battery *tmp186
-    * jump *label95 equal *tmp187 false
+  457 jump *label95 greaterThanEq :total_battery *tmp186
   458 set .OUTPUT_2 0
   459 jump *label96 always
   460 label *label95
   461 label *label96
-    * op equal *tmp189 .OUTPUT_2 0
-    * jump *label97 equal *tmp189 false
-    * op greaterThan *tmp191 :total_battery 47500
-    * jump *label99 equal *tmp191 false
+  462 jump *label97 notEqual .OUTPUT_2 0
+  463 jump *label99 lessThanEq :total_battery 47500
   464 set .OUTPUT_2 1
   465 jump *label100 always
   466 label *label99
 
   531 op add :n :n 1
   532 jump *label101 always
   533 label *label103
-    * op notEqual *tmp212 cell2 null
-    * jump *label113 equal *tmp212 false
+  534 jump *label113 equal cell2 null
   535 write :reactors cell2 0
   536 write .REACTORS_ON cell2 2
   537 write .OVERDRIVE cell2 3
 
   543 label *label113
   544 label *label114
   545 op min .REACTORS_ON .REACTORS_ON :reactors
-    * op equal *tmp220 cell1 null
-    * jump *label115 equal *tmp220 false
+  546 jump *label115 notEqual cell1 null
   547 set .STARTUPS 0
   548 set .RESETS 0
   549 set .COMMITS 0

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-28 instructions):
 
    34 jump *label10 notEqual *tmp5 @armored-conveyor
    35 label *label11
    36 set .START :n
-    * jump *label7 always
    37 label *label10
    38 label *label7
    39 label *label5
 
    43 op add :reactors :reactors *tmp7
    44 jump *label12 notEqual :reactors 0
    45 print "No reactor."
-    * jump *label13 always
    46 label *label12
    47 label *label13
    48 printflush message1
 
   118 print "\nMin. consumption: "
   119 print :min_consumption
   120 printflush message2
-    * jump *label26 always
   121 label *label25
   122 label *label26
   123 jump *label24 always
 
   125 set :failure_cnt 0
   126 label *label24
   127 label *label22
-    * jump *label20 always
   128 label *label19
   129 label *label20
   130 jump *label28 notEqual .MODE 0
 
   162 print " ([gold]"
   163 print :multiplier
   164 print "x[])"
-    * jump *label35 always
   165 label *label34
   166 label *label35
   167 print "\n=================================="
   168 sensor *tmp69 tank1 @totalLiquids
   169 jump *label36 greaterThanEq *tmp69 750
   170 print "\n[salmon]Cryofluid level critical![]"
-    * jump *label37 always
   171 label *label36
   172 label *label37
   173 sensor *tmp72 vault1 @blast-compound
   174 jump *label38 greaterThanEq *tmp72 700
   175 print "\n[salmon]Blast compound level critical![]"
-    * jump *label39 always
   176 label *label38
   177 label *label39
   178 jump *label40 notEqual :enough_battery false
 
   183 print :missing_battery
   184 print " "
   185 print "K[] of additional storage to internal battery."
-    * jump *label41 always
   186 label *label40
   187 label *label41
   188 print "\n"
 
   228 set :failure_cnt 0
   229 set .GENERATOR true
   230 set .REASON "Unknown -- out of power?"
-    * jump *label46 always
   231 label *label45
   232 label *label46
   233 jump *label42 always
 
   269 print :neededPower
   270 print "["
   271 print "]"
-    * jump *label56 always
   272 label *label55
   273 label *label56
   274 jump *label57 lessThanEq :net_power 100
   275 set .OVERDRIVE true
-    * jump *label58 always
   276 label *label57
   277 label *label58
   278 op lessThan *tmp99 .REACTORS_ON :reactors
 
   283 jump *label59 lessThan :net_power :neededPower
   284 set .OUTPUT_2 .OUTPUT_1
   285 set .OUTPUT_1 1
-    * jump *label60 always
   286 label *label59
   287 label *label60
   288 jump *label61 notEqual .OUTPUT_1 0
 
   290 op div :ratio :neededPower :availablePower
   291 jump *label63 greaterThanEq :ratio 1
   292 op add :nextStart @time 2000
-    * jump *label64 always
   293 label *label63
   294 label *label64
-    * jump *label62 always
   295 label *label61
   296 label *label62
   297 op greaterThan *tmp113 @time :nextStart
 
   307 op add *tmp118 .REACTORS_ON :start_at_once
   308 op min .REACTORS_ON *tmp118 :reactors
   309 op add :nextStart @time 2000
-    * jump *label66 always
   310 label *label65
   311 label *label66
   312 op greaterThanEq *tmp121 .REACTORS_ON :reactors
 
   320 set .COOLANT_FLAG 0
   321 set .FUEL_FLAG 0
   322 set .GENERATOR false
-    * jump *label70 always
   323 label *label69
   324 label *label70
   325 label *label52
 
   334 set .MODE 0
   335 control enabled switch1 false
   336 set .REASON "Cryo level too low"
-    * jump *label74 always
   337 label *label73
   338 label *label74
   339 sensor *tmp133 vault1 @blast-compound
 
   343 set .MODE 0
   344 control enabled switch1 false
   345 set .REASON "Blast compound level too low"
-    * jump *label76 always
   346 label *label75
   347 label *label76
   348 sensor *tmp138 tank1 @totalLiquids
 
   371 op idiv *tmp160 :commit_level 1000
   372 print "\nCommit threshold:   [gold]"
   373 print *tmp160
-    * jump *label80 always
   374 label *label79
   375 label *label80
   376 jump *label81 notEqual :commit_level 0
   377 op idiv *tmp163 :min_level 1000
   378 print "\nRestart threshold: [gold]"
   379 print *tmp163
-    * jump *label82 always
   380 label *label81
   381 label *label82
   382 print "[] K"
 
   397 op or *tmp173 *tmp171 *tmp172
   398 jump *label85 equal *tmp173 false
   399 op add :nextDecommit @time 6000
-    * jump *label86 always
   400 label *label85
   401 label *label86
   402 jump *label87 lessThanEq @time :nextDecommit
 
   415 op add .REACTORS_ON .REACTORS_ON 1
   416 op add .COMMITS .COMMITS 1
   417 set .CAN_COMMIT false
-    * jump *label92 always
   418 label *label91
   419 label *label92
   420 label *label88
 
   434 op mul *tmp186 PLANT_PROTECTION 47500
   435 jump *label95 greaterThanEq :total_battery *tmp186
   436 set .OUTPUT_2 0
-    * jump *label96 always
   437 label *label95
   438 label *label96
   439 jump *label97 notEqual .OUTPUT_2 0
 
   443 label *label99
   444 print "\n*** [gold]Surge tower 2 offline[] ***"
   445 label *label100
-    * jump *label98 always
   446 label *label97
   447 label *label98
-    * jump *label42 always
   448 label *label71
   449 label *label42
   450 print "\n"
 
   477 jump *label107 equal :enabled false
   478 sensor *tmp207 :block @timescale
   479 op add :boosts :boosts *tmp207
-    * jump *label108 always
   480 label *label107
   481 label *label108
   482 jump *label104 always
 
   498 label *label112
   499 set *tmp210 :block
   500 control enabled *tmp210 :startup
-    * jump *label104 always
   501 label *label111
   502 label *label104
   503 label *label102
 
   512 op add :reactors :reactors *tmp217
   513 read *tmp218 cell2 4
   514 op add :boosts :boosts *tmp218
-    * jump *label114 always
   515 label *label113
   516 label *label114
   517 op min .REACTORS_ON .REACTORS_ON :reactors

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   242 label *label50
   243 set :nextBattery *tmp84
   244 sensor *tmp85 :nextBattery @powerNetOut
-    * op mul *tmp86 *tmp85 1.05
-    * op floor *tmp87 *tmp86
+  245 op idiv *tmp87 *tmp85 0.9523809523809523
   246 op max :neededPower *tmp87 1000
   247 jump *label51 notEqual .REACTORS_ON 0
   248 jump *label53 lessThan :total_battery 25000

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
   145 set *tmp61 null
   146 label *label27
   147 set .STR_MODE *tmp61
-    * print .STR_MODE
+  148 print *tmp61
   149 print ","
   150 print " reactors [green]"
   151 print .REACTORS_ON
 
   241 set *tmp84 battery2
   242 label *label50
   243 set :nextBattery *tmp84
-    * sensor *tmp85 :nextBattery @powerNetOut
+  244 sensor *tmp85 *tmp84 @powerNetOut
   245 op idiv *tmp87 *tmp85 0.9523809523809523
   246 op max :neededPower *tmp87 1000
   247 jump *label51 notEqual .REACTORS_ON 0
 
   303 set *tmp116 1
   304 label *label68
   305 set :start_at_once *tmp116
-    * op add *tmp118 .REACTORS_ON :start_at_once
+  306 op add *tmp118 .REACTORS_ON *tmp116
   307 op min .REACTORS_ON *tmp118 :reactors
   308 op add :nextStart @time 2000
   309 label *label65
 
   353 sensor *tmp144 switch2 @enabled
   354 op land *tmp145 :enough_battery *tmp144
   355 jump *label77 equal *tmp145 false
-    * op mul :min_level 0.5 :required_capacity
+  356 op mul :min_level :reactors 50000
   357 set :commit_level 0
   358 op lessThan *tmp148 :battery_change 0
   359 op land *tmp149 .CAN_COMMIT *tmp148
 
   361 op land *tmp151 *tmp149 *tmp150
   362 jump *label79 equal *tmp151 false
   363 op sub *tmp153 :battery_change 1500
-    * op sub :p *tmp153 1000
+  364 op sub :p :battery_change 2500
   365 op mul *tmp155 :p 0.00472972972972973
   366 op add *tmp156 -5 *tmp155
   367 op mul *tmp157 :p *tmp156
 
   460 op equal :startup .MODE 1
   461 set :reactors 0
   462 set :boosts 0
-    * set :enabled true
   463 set *tmp198 @links
   464 set :n .START
   465 label *label101
 
   471 op add :reactors :reactors 1
   472 op lessThanEq :enabled :reactors .REACTORS_ON
   473 set *tmp204 :block
-    * control enabled *tmp204 :enabled
+  474 control enabled :block :enabled
   475 jump *label107 equal :enabled false
   476 sensor *tmp207 :block @timescale
   477 op add :boosts :boosts *tmp207
 
   483 jump *label109 notEqual *tmp201 @overdrive-dome
   484 label *label110
   485 set *tmp208 :block
-    * control enabled *tmp208 .OVERDRIVE
+  486 control enabled :block .OVERDRIVE
   487 jump *label104 always
   488 label *label109
   489 jump *label112 equal *tmp201 @conduit
 
   495 jump *label111 notEqual *tmp201 @armored-conveyor
   496 label *label112
   497 set *tmp210 :block
-    * control enabled *tmp210 :startup
+  498 control enabled :block :startup
   499 label *label111
   500 label *label104
   501 label *label102

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
   144 label *label32
   145 set *tmp61 null
   146 label *label27
-    * set .STR_MODE *tmp61
   147 print *tmp61
   148 print ","
   149 print " reactors [green]"
 
   239 label *label49
   240 set *tmp84 battery2
   241 label *label50
-    * set :nextBattery *tmp84
   242 sensor *tmp85 *tmp84 @powerNetOut
   243 op idiv *tmp87 *tmp85 0.9523809523809523
   244 op max :neededPower *tmp87 1000
 
   300 label *label67
   301 set *tmp116 1
   302 label *label68
-    * set :start_at_once *tmp116
   303 op add *tmp118 .REACTORS_ON *tmp116
   304 op min .REACTORS_ON *tmp118 :reactors
   305 op add :nextStart @time 2000
 
   357 op lessThan *tmp150 .REACTORS_ON :reactors
   358 op land *tmp151 *tmp149 *tmp150
   359 jump *label79 equal *tmp151 false
-    * op sub *tmp153 :battery_change 1500
   360 op sub :p :battery_change 2500
   361 op mul *tmp155 :p 0.00472972972972973
   362 op add *tmp156 -5 *tmp155
 
   466 label *label106
   467 op add :reactors :reactors 1
   468 op lessThanEq :enabled :reactors .REACTORS_ON
-    * set *tmp204 :block
   469 control enabled :block :enabled
   470 jump *label107 equal :enabled false
   471 sensor *tmp207 :block @timescale
 
   477 jump *label110 equal *tmp201 @overdrive-projector
   478 jump *label109 notEqual *tmp201 @overdrive-dome
   479 label *label110
-    * set *tmp208 :block
   480 control enabled :block .OVERDRIVE
   481 jump *label104 always
   482 label *label109
 
   488 jump *label112 equal *tmp201 @plastanium-conveyor
   489 jump *label111 notEqual *tmp201 @armored-conveyor
   490 label *label112
-    * set *tmp210 :block
   491 control enabled :block :startup
   492 label *label111
   493 label *label104

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
 
     6 set .START null
     7 set :reactors 0
     8 label *label1
-    * jump *label3 notEqual :reactors 0
+    9 label *label117
    10 set :reactors 0
    11 set :n @links
    12 label *label4
    13 jump *label6 lessThanEq :n 0
+   14 label *label118
    15 op sub :n :n 1
    16 getlink :block :n
    17 print "Found: "
 
    38 label *label10
    39 label *label7
    40 label *label5
-    * jump *label4 always
+   41 jump *label118 greaterThan :n 0
    42 label *label6
    43 read *tmp7 cell2 1
    44 op add :reactors :reactors *tmp7
 
    48 label *label13
    49 printflush message1
    50 label *label2
-    * jump *label1 always
+   51 jump *label117 equal :reactors 0
    52 label *label3
    53 read .MODE cell1 0
    54 read .OUTPUT_1 cell1 1
 
   461 set :n .START
   462 label *label101
   463 jump *label103 greaterThanEq :n *tmp198
+  464 label *label119
   465 getlink :block :n
   466 sensor *tmp201 :block @type
   467 jump *label105 notEqual *tmp201 @impact-reactor
 
   495 label *label104
   496 label *label102
   497 op add :n :n 1
-    * jump *label101 always
+  498 jump *label119 lessThan :n *tmp198
   499 label *label103
   500 jump *label113 equal cell2 null
   501 write :reactors cell2 0

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    61 read .RESETS cell1 8
    62 read .COMMITS cell1 9
    63 set :reactors .REACTORS_ON
-    * jump *label14 notEqual .MODE 0
+   64 set .REASON "Reason unknown -- out of power?"
+   65 jump *label15 notEqual .MODE 0
    66 set .REASON "Processor reset"
    67 jump *label15 always
-    * label *label14
-    * set .REASON "Reason unknown -- out of power?"
    68 label *label15
    69 op notEqual *tmp23 .MODE 0
    70 control enabled switch1 *tmp23
 
   234 jump *label47 notEqual .MODE 1
   235 label *label48
   236 jump *label49 equal .OUTPUT_1 false
-    * set *tmp84 battery3
+  237 sensor *tmp85 battery3 @powerNetOut
   238 jump *label50 always
   239 label *label49
-    * set *tmp84 battery2
+  240 sensor *tmp85 battery2 @powerNetOut
   241 label *label50
-    * sensor *tmp85 *tmp84 @powerNetOut
   242 op idiv *tmp87 *tmp85 0.9523809523809523
   243 op max :neededPower *tmp87 1000
   244 jump *label51 notEqual .REACTORS_ON 0
 
   293 op greaterThan *tmp113 @time :nextStart
   294 op land *tmp114 :canStart *tmp113
   295 jump *label65 equal *tmp114 false
-    * jump *label67 equal FAST_START false
+  296 set *tmp116 1
+  297 jump *label68 equal FAST_START false
   298 op idiv *tmp116 :total_battery 25000
   299 jump *label68 always
-    * label *label67
-    * set *tmp116 1
   300 label *label68
   301 op add *tmp118 .REACTORS_ON *tmp116
   302 op min .REACTORS_ON *tmp118 :reactors

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
    64 set .REASON "Reason unknown -- out of power?"
    65 jump *label15 notEqual .MODE 0
    66 set .REASON "Processor reset"
-    * jump *label15 always
    67 label *label15
    68 op notEqual *tmp23 .MODE 0
    69 control enabled switch1 *tmp23
 
   295 set *tmp116 1
   296 jump *label68 equal FAST_START false
   297 op idiv *tmp116 :total_battery 25000
-    * jump *label68 always
   298 label *label68
   299 op add *tmp118 .REACTORS_ON *tmp116
   300 op min .REACTORS_ON *tmp118 :reactors

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
     4 set .COOLANT_FLAG null
     5 set .FUEL_FLAG null
     6 set .START null
-    * set :reactors 0
     7 label *label1
     8 label *label117
     9 set :reactors 0
 
   454 set *tmp198 @links
   455 set :n .START
   456 label *label101
-    * jump *label103 greaterThanEq :n *tmp198
+  457 jump *label103 greaterThanEq .START *tmp198
   458 label *label119
   459 getlink :block :n
   460 sensor *tmp201 :block @type

Modifications by Iterated phase, If Expression Optimization, pass 2, iteration 1:
 
   231 label *label43
   232 jump *label47 notEqual .MODE 1
   233 label *label48
-    * jump *label49 equal .OUTPUT_1 false
+  234 sensor *tmp85 battery2 @powerNetOut
+  235 jump *label50 equal .OUTPUT_1 false
   236 sensor *tmp85 battery3 @powerNetOut
   237 jump *label50 always
-    * label *label49
-    * sensor *tmp85 battery2 @powerNetOut
   238 label *label50
   239 op idiv *tmp87 *tmp85 0.9523809523809523
   240 op max :neededPower *tmp87 1000

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
   234 sensor *tmp85 battery2 @powerNetOut
   235 jump *label50 equal .OUTPUT_1 false
   236 sensor *tmp85 battery3 @powerNetOut
-    * jump *label50 always
   237 label *label50
   238 op idiv *tmp87 *tmp85 0.9523809523809523
   239 op max :neededPower *tmp87 1000

Modifications by Final phase, Jump Threading, iteration 1:
 
   107 op add :failure_cnt :failure_cnt 1
   108 read *tmp56 cell2 1
   109 op add *tmp57 10 *tmp56
-    * jump *label25 lessThanEq :failure_cnt *tmp57
+  110 jump *label24 lessThanEq :failure_cnt *tmp57
   111 set .MODE 0
   112 control enabled switch1 false
   113 set .REASON "Unknown -- out of power?"
 
   218 print .REASON
   219 print "[]"
   220 sensor *tmp82 switch1 @enabled
-    * jump *label45 equal *tmp82 false
+  221 jump *label42 equal *tmp82 false
   222 set .MODE 1
   223 op add .STARTUPS .STARTUPS 1
   224 set :nextStart 0
 
   241 jump *label53 lessThan :total_battery 25000
   242 set .REACTORS_ON 1
   243 op add :nextStart @time 2000
-    * jump *label54 always
+  244 jump *label42 always
   245 label *label53
   246 print "\nRequired startup energy: [gold]"
   247 print 25
   248 print " K[]"
   249 label *label54
-    * jump *label52 always
+  250 jump *label42 always
   251 label *label51
   252 op add :outputs .OUTPUT_1 .OUTPUT_2
   253 print "\n"
 
   303 op land *tmp123 *tmp121 *tmp122
   304 op greaterThan *tmp124 .OUTPUT_2 0
   305 op land *tmp125 *tmp123 *tmp124
-    * jump *label69 equal *tmp125 false
+  306 jump *label42 equal *tmp125 false
   307 set .MODE 2
   308 op add :nextDecommit @time 6000
   309 set .COOLANT_FLAG 0
 
   378 set .OVERDRIVE true
   379 set .REACTORS_ON :reactors
   380 op add :nextDecommit @time 6000
-    * jump *label84 always
+  381 jump *label78 always
   382 label *label83
   383 op lessThan *tmp171 :battery_level 47500
   384 op lessThan *tmp172 :battery_change -100
 
   397 set .CAN_COMMIT true
   398 label *label90
   399 op add :nextDecommit @time 6000
-    * jump *label88 always
+  400 jump *label78 always
   401 label *label87
-    * jump *label91 greaterThanEq :total_battery :commit_level
+  402 jump *label78 greaterThanEq :total_battery :commit_level
   403 op add .REACTORS_ON .REACTORS_ON 1
   404 op add .COMMITS .COMMITS 1
   405 set .CAN_COMMIT false
 
   461 op add :reactors :reactors 1
   462 op lessThanEq :enabled :reactors .REACTORS_ON
   463 control enabled :block :enabled
-    * jump *label107 equal :enabled false
+  464 jump *label104 equal :enabled false
   465 sensor *tmp207 :block @timescale
   466 op add :boosts :boosts *tmp207
   467 label *label107
 
   504 set .STARTUPS 0
   505 set .RESETS 0
   506 set .COMMITS 0
-    * jump *label116 always
+  507 jump *label16 always
   508 label *label115
   509 write .MODE cell1 0
   510 write .OUTPUT_1 cell1 1

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
   519 label *label116
   520 label *label17
   521 jump *label16 always
-    * label *label18
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-24 instructions):
 
   143 set *tmp61 null
   144 label *label27
   145 print *tmp61
-    * print ","
-    * print " reactors [green]"
+  146 print ", reactors [green]"
   147 print .REACTORS_ON
   148 print "/"
   149 print :reactors
-    * print "["
-    * print "]"
+  150 print "[]"
   151 jump *label34 equal .OVERDRIVE false
   152 op mul *tmp64 100 :boosts
   153 op div *tmp65 *tmp64 .REACTORS_ON
 
   171 label *label38
   172 label *label39
   173 jump *label40 notEqual :enough_battery false
-    * print "\n"
-    * print "[salmon]Insufficient battery storage![]"
-    * print "\n"
-    * print "Link [gold]"
+  174 print "\n[salmon]Insufficient battery storage![]\nLink [gold]"
   175 print :missing_battery
-    * print " "
-    * print "K[] of additional storage to internal battery."
+  176 print " K[] of additional storage to internal battery."
   177 label *label40
   178 label *label41
-    * print "\n"
-    * print "Internal battery:    [gold]"
+  179 print "\nInternal battery:    [gold]"
   180 print :battery_level_str
-    * print "["
-    * print "]/[green]50[] K"
-    * print "\n"
-    * print "Total battery:        [gold]"
+  181 print "[]/[green]50[] K\nTotal battery:        [gold]"
   182 print :total_battery_str
-    * print "["
-    * print "]/[green]"
+  183 print "[]/[green]"
   184 print :total_capacity_str
-    * print "["
-    * print "] K"
-    * print "\n"
-    * print "Battery change:     [gold]"
+  185 print "[] K\nBattery change:     [gold]"
   186 print :battery_change
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "Power balance:       [gold]"
+  187 print "[]\nPower balance:       [gold]"
   188 print :net_power
-    * print "["
-    * print "]"
+  189 print "[]"
   190 jump *label43 notEqual .MODE 0
   191 label *label44
   192 set .REACTORS_ON 0
 
   225 op add :nextStart @time 2000
   226 jump *label42 always
   227 label *label53
-    * print "\nRequired startup energy: [gold]"
-    * print 25
-    * print " K[]"
+  228 print "\nRequired startup energy: [gold]25 K[]"
   229 label *label54
   230 jump *label42 always
   231 label *label51
   232 op add :outputs .OUTPUT_1 .OUTPUT_2
-    * print "\n"
-    * print "[gold]"
+  233 print "\n[gold]"
   234 print :outputs
-    * print "["
-    * print "] surge tower(s) online"
+  235 print "[] surge tower(s) online"
   236 jump *label55 notEqual .OUTPUT_2 0
-    * print "\n"
-    * print "Required power level: [gold]"
+  237 print "\nRequired power level: [gold]"
   238 print :neededPower
-    * print "["
-    * print "]"
+  239 print "[]"
   240 label *label55
   241 label *label56
   242 jump *label57 lessThanEq :net_power 100

Final code before resolving virtual instructions:

    0:  set PLANT_PROTECTION 1                                       param PLANT_PROTECTION      = 1;        // If internal battery level gets too low, output to base is switched off
    1:  set FAST_START 1                                             param FAST_START            = 1;        // Starts as many reactors at once as possible during startup
        label *label0                                                allocate heap in cell1[0 ... 64];
    2:  jump *label0 equal cell1 null                                ...
    3:  set .COOLANT_FLAG null                                       COOLANT_FLAG = null; FUEL_FLAG = null; START = null;
    4:  set .FUEL_FLAG null                                          ...
    5:  set .START null                                              ...
        label *label117                                              while reactors == 0 do
    6:  set :reactors 0                                              reactors = 0;
    7:  set :n @links                                                n = @links;
    8:  jump *label6 lessThanEq :n 0                                 while n > 0 do
        label *label118                                              ...
    9:  op sub :n :n 1                                               block = getlink(--n);
   10:  getlink :block :n                                            ...
   11:  print "Found: "                                              println($"Found: $block");
   12:  print :block                                                 ...
   13:  print "\n"                                                   ...
   14:  sensor *tmp5 :block @type                                    case block.@type
   15:  jump *label8 notEqual *tmp5 @impact-reactor                  ...
   16:  set .START :n                                                START = n;
   17:  op add :reactors :reactors 1                                 reactors += 1;
   18:  jump *label7 always 0 0                                      case block.@type
        label *label8                                                ...
   19:  jump *label11 equal *tmp5 @overdrive-projector               ...
   20:  jump *label11 equal *tmp5 @overdrive-dome                    ...
   21:  jump *label11 equal *tmp5 @conduit                           ...
   22:  jump *label11 equal *tmp5 @pulse-conduit                     ...
   23:  jump *label11 equal *tmp5 @plated-conduit                    ...
   24:  jump *label11 equal *tmp5 @conveyor                          ...
   25:  jump *label11 equal *tmp5 @titanium-conveyor                 ...
   26:  jump *label11 equal *tmp5 @plastanium-conveyor               ...
   27:  jump *label10 notEqual *tmp5 @armored-conveyor               ...
        label *label11                                               ...
   28:  set .START :n                                                START = n;
        label *label10                                               case block.@type
        label *label7                                                ...
   29:  jump *label118 greaterThan :n 0                              while n > 0 do
        label *label6                                                ...
   30:  read *tmp7 cell2 1                                           reactors += cell2[CELL_REMOTE_REACTORS];
   31:  op add :reactors :reactors *tmp7                             ...
   32:  jump *label12 notEqual :reactors 0                           if reactors == 0 then
   33:  print "No reactor."                                          print("No reactor.");
        label *label12                                               if reactors == 0 then
   34:  printflush message1                                          printflush(message1);
   35:  jump *label117 equal :reactors 0                             while reactors == 0 do
   36:  read .MODE cell1 0                                           MODE = $MODE;
   37:  read .OUTPUT_1 cell1 1                                       OUTPUT_1 = $OUTPUT_1;
   38:  read .OUTPUT_2 cell1 2                                       OUTPUT_2 = $OUTPUT_2;
   39:  read .REACTORS_ON cell1 3                                    REACTORS_ON = $REACTORS_ON;
   40:  read .OVERDRIVE cell1 4                                      OVERDRIVE = $OVERDRIVE;
   41:  read .GENERATOR cell1 5                                      GENERATOR = $GENERATOR;
   42:  read .CAN_COMMIT cell1 6                                     CAN_COMMIT = $CAN_COMMIT;
   43:  read .STARTUPS cell1 7                                       STARTUPS = $STARTUPS;
   44:  read .RESETS cell1 8                                         RESETS = $RESETS;
   45:  read .COMMITS cell1 9                                        COMMITS = $COMMITS;
   46:  set :reactors .REACTORS_ON                                   reactors = REACTORS_ON;
   47:  set .REASON "Reason unknown -- out of power?"                REASON = "Reason unknown -- out of power?";
   48:  jump *label15 notEqual .MODE 0                               if MODE == SHUTDOWN then
   49:  set .REASON "Processor reset"                                REASON = "Processor reset";
        label *label15                                               if MODE == SHUTDOWN then
   50:  op notEqual *tmp23 .MODE 0                                   switch1.enabled = MODE != SHUTDOWN;
   51:  control enabled switch1 *tmp23 0 0 0                         ...
   52:  set :failure_cnt 0                                           failure_cnt = 0;
   53:  set :boosts 0                                                boosts = 0;
   54:  set :nextStart 0                                             nextStart = 0;
   55:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
        label *label16                                               while true do
   56:  sensor *tmp25 battery1 @totalPower                           battery_level = floor(battery1.@totalPower);
   57:  op floor :battery_level *tmp25 0                             ...
   58:  op idiv :battery_level_str :battery_level 1000               battery_level_str = battery_level \ 1000;
   59:  sensor *tmp28 battery1 @powerNetStored                       total_battery = floor(battery1.@powerNetStored);
   60:  op floor :total_battery *tmp28 0                             ...
   61:  op idiv :total_battery_str :total_battery 1000               total_battery_str = total_battery \ 1000;
   62:  sensor :consumption battery1 @powerNetOut                    consumption = battery1.@powerNetOut;
   63:  read :production bank1 509                                   production = bank1[PRODUCTION_INDEX];
   64:  read :net_power bank1 510                                    net_power = bank1[NET_POWER_INDEX];
   65:  read :battery_change bank1 511                               battery_change = bank1[BATTERY_CHANGE_INDEX];
   66:  sensor :total_capacity battery1 @powerNetCapacity            total_capacity = battery1.@powerNetCapacity;
   67:  op idiv :total_capacity_str :total_capacity 1000             total_capacity_str = total_capacity \ 1000;
   68:  op mul :required_capacity 100000 :reactors                   required_capacity = BATTERY_PER_REACTOR * reactors;
   69:  op greaterThanEq :enough_battery :total_capacity :required_c enough_battery = total_capacity >= required_capacity;
   70:  op sub *tmp39 :required_capacity :total_capacity             missing_battery = ceil((required_capacity - total_capacity) / 1000);
   71:  op div *tmp40 *tmp39 1000                                    ...
   72:  op ceil :missing_battery *tmp40 0                            ...
   73:  jump *label19 equal .MODE 0                                  if MODE != SHUTDOWN then
   74:  sensor *tmp44 switch1 @enabled                               if switch1.@enabled == false then
   75:  jump *label21 notEqual *tmp44 false                          ...
   76:  set .MODE 0                                                  MODE = SHUTDOWN;
   77:  set .REASON "Manual power off"                               REASON = "Manual power off";
   78:  jump *label22 always 0 0                                     if switch1.@enabled == false then
        label *label21                                               ...
   79:  op mul :min_consumption .REACTORS_ON 1200                    min_consumption = REACTORS_ON * MIN_CONS_REACTOR;
   80:  op lessThan :failure1 :consumption :min_consumption          failure1 = (consumption < min_consumption);
   81:  op equal *tmp49 :battery_level 0                             failure2 = (battery_level == 0) and (consumption > 0) and (production == 0);
   82:  op greaterThan *tmp50 :consumption 0                         ...
   83:  op land *tmp51 *tmp49 *tmp50                                 ...
   84:  op equal *tmp52 :production 0                                ...
   85:  op land :failure2 *tmp51 *tmp52                              ...
   86:  op or *tmp54 :failure1 :failure2                             if failure1 or failure2 then
   87:  jump *label23 equal *tmp54 false                             ...
   88:  op add :failure_cnt :failure_cnt 1                           failure_cnt += 1;
   89:  read *tmp56 cell2 1                                          if failure_cnt > 10 + cell2[CELL_REMOTE_REACTORS] then
   90:  op add *tmp57 10 *tmp56                                      ...
   91:  jump *label24 lessThanEq :failure_cnt *tmp57                 ...
   92:  set .MODE 0                                                  MODE = SHUTDOWN;
   93:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
   94:  set .REASON "Unknown -- out of power?"                       REASON = "Unknown -- out of power?";
   95:  print "Consumption: "                                        print("Consumption: ", consumption);
   96:  print :consumption                                           ...
   97:  print "\nMin. consumption: "                                 print("\nMin. consumption: ", min_consumption);
   98:  print :min_consumption                                       ...
   99:  printflush message2                                          printflush(message2);
  100:  jump *label24 always 0 0                                     if failure1 or failure2 then
        label *label23                                               ...
  101:  set :failure_cnt 0                                           failure_cnt = 0;
        label *label24                                               if failure1 or failure2 then
        label *label22                                               if switch1.@enabled == false then
        label *label19                                               if MODE != SHUTDOWN then
  102:  jump *label28 notEqual .MODE 0                               STR_MODE = case MODE
  103:  set *tmp61 "[salmon]SHUTDOWN[]"                              ...
  104:  jump *label27 always 0 0                                     ...
        label *label28                                               ...
  105:  jump *label30 notEqual .MODE 1                               ...
  106:  set *tmp61 "[gold]STARTUP[]"                                 ...
  107:  jump *label27 always 0 0                                     ...
        label *label30                                               ...
  108:  jump *label32 notEqual .MODE 2                               ...
  109:  set *tmp61 "[green]RUNNING[]"                                ...
  110:  jump *label27 always 0 0                                     ...
        label *label32                                               ...
  111:  set *tmp61 null                                              ...
        label *label27                                               ...
  112:  print *tmp61                                                 print($"$STR_MODE, reactors [green]$REACTORS_ON/$reactors[]");
  113:  print ", reactors [green]"                                   ...
  114:  print .REACTORS_ON                                           ...
  115:  print "/"                                                    ...
  116:  print :reactors                                              ...
  117:  print "[]"                                                   ...
  118:  jump *label34 equal .OVERDRIVE false                         if OVERDRIVE then
  119:  op mul *tmp64 100 :boosts                                    multiplier = floor(100 * boosts / REACTORS_ON + 0.5) / 100;
  120:  op div *tmp65 *tmp64 .REACTORS_ON                            ...
  121:  op add *tmp66 *tmp65 0.5                                     ...
  122:  op floor *tmp67 *tmp66 0                                     ...
  123:  op div :multiplier *tmp67 100                                ...
  124:  print " ([gold]"                                             print(" ([gold]", multiplier, "x[])");
  125:  print :multiplier                                            ...
  126:  print "x[])"                                                 ...
        label *label34                                               if OVERDRIVE then
  127:  print "\n=================================="                 print("\n==================================");
  128:  sensor *tmp69 tank1 @totalLiquids                            if tank1.@totalLiquids < COOLANT_CUTOFF then
  129:  jump *label36 greaterThanEq *tmp69 750                       ...
  130:  print "\n[salmon]Cryofluid level critical![]"                print("\n[salmon]Cryofluid level critical![]");
        label *label36                                               if tank1.@totalLiquids < COOLANT_CUTOFF then
  131:  sensor *tmp72 vault1 @blast-compound                         if vault1.@blast-compound < FUEL_CUTOFF then
  132:  jump *label38 greaterThanEq *tmp72 700                       ...
  133:  print "\n[salmon]Blast compound level critical![]"           print("\n[salmon]Blast compound level critical![]");
        label *label38                                               if vault1.@blast-compound < FUEL_CUTOFF then
  134:  jump *label40 notEqual :enough_battery false                 if enough_battery == false then
  135:  print "\n[salmon]Insufficient battery storage![]\nLink [gold print($"\nLink [gold]$missing_battery K[] of additional storage to internal battery.");
  136:  print :missing_battery                                       ...
  137:  print " K[] of additional storage to internal battery."      ...
        label *label40                                               if enough_battery == false then
  138:  print "\nInternal battery:    [gold]"                        print($"\nInternal battery:    [gold]$battery_level_str[]/[green]50[] K");
  139:  print :battery_level_str                                     ...
  140:  print "[]/[green]50[] K\nTotal battery:        [gold]"       print($"\nTotal battery:        [gold]$total_battery_str[]/[green]$total_capacity_str[] K");
  141:  print :total_battery_str                                     ...
  142:  print "[]/[green]"                                           ...
  143:  print :total_capacity_str                                    ...
  144:  print "[] K\nBattery change:     [gold]"                     print($"\nBattery change:     [gold]$battery_change[]");
  145:  print :battery_change                                        ...
  146:  print "[]\nPower balance:       [gold]"                      print($"\nPower balance:       [gold]$net_power[]");
  147:  print :net_power                                             ...
  148:  print "[]"                                                   ...
  149:  jump *label43 notEqual .MODE 0                               case MODE
  150:  set .REACTORS_ON 0                                           REACTORS_ON = 0;
  151:  set .OVERDRIVE 0                                             OVERDRIVE = 0;
  152:  set .OUTPUT_1 0                                              OUTPUT_1 = 0;
  153:  set .OUTPUT_2 0                                              OUTPUT_2 = 0;
  154:  op greaterThanEq *tmp79 :net_power -150                      GENERATOR = (net_power >= -150) && (total_battery < BATTERY_SAT);
  155:  op lessThan *tmp80 :total_battery 47500                      ...
  156:  op land .GENERATOR *tmp79 *tmp80                             ...
  157:  print "\nShutdown reason: [gold]"                            print("\nShutdown reason: [gold]", REASON, "[]");
  158:  print .REASON                                                ...
  159:  print "[]"                                                   ...
  160:  sensor *tmp82 switch1 @enabled                               if switch1.@enabled then
  161:  jump *label42 equal *tmp82 false                             ...
  162:  set .MODE 1                                                  MODE = STARTUP;
  163:  op add .STARTUPS .STARTUPS 1                                 STARTUPS += 1;
  164:  set :nextStart 0                                             nextStart = 0;
  165:  set :failure_cnt 0                                           failure_cnt = 0;
  166:  set .GENERATOR true                                          GENERATOR = true;
  167:  set .REASON "Unknown -- out of power?"                       REASON = "Unknown -- out of power?";
  168:  jump *label42 always 0 0                                     case MODE
        label *label43                                               ...
  169:  jump *label47 notEqual .MODE 1                               ...
  170:  sensor *tmp85 battery2 @powerNetOut                          nextBattery = OUTPUT_1 ? battery3 : battery2;
  171:  jump *label50 equal .OUTPUT_1 false                          ...
  172:  sensor *tmp85 battery3 @powerNetOut                          ...
        label *label50                                               ...
  173:  op idiv *tmp87 *tmp85 0.9523809523809523                     neededPower = max(floor(nextBattery.@powerNetOut * POWER_MARGIN), 1000);
  174:  op max :neededPower *tmp87 1000                              ...
  175:  jump *label51 notEqual .REACTORS_ON 0                        if REACTORS_ON == 0 then
  176:  jump *label53 lessThan :total_battery 25000                  if total_battery >= STARTUP_BAT_ENERGY then
  177:  set .REACTORS_ON 1                                           REACTORS_ON = 1;
  178:  op add :nextStart @time 2000                                 nextStart = @time + STARTUP_DELAY;
  179:  jump *label42 always 0 0                                     if total_battery >= STARTUP_BAT_ENERGY then
        label *label53                                               ...
  180:  print "\nRequired startup energy: [gold]25 K[]"              print("\nRequired startup energy: [gold]", STARTUP_BAT_ENERGY \ 1000, " K[]");
  181:  jump *label42 always 0 0                                     if REACTORS_ON == 0 then
        label *label51                                               ...
  182:  op add :outputs .OUTPUT_1 .OUTPUT_2                          outputs = OUTPUT_1 + OUTPUT_2;
  183:  print "\n[gold]"                                             print($"\n[gold]$outputs[] surge tower(s) online");
  184:  print :outputs                                               ...
  185:  print "[] surge tower(s) online"                             ...
  186:  jump *label55 notEqual .OUTPUT_2 0                           if OUTPUT_2 == 0 then
  187:  print "\nRequired power level: [gold]"                       print($"\nRequired power level: [gold]$neededPower[]");
  188:  print :neededPower                                           ...
  189:  print "[]"                                                   ...
        label *label55                                               if OUTPUT_2 == 0 then
  190:  jump *label57 lessThanEq :net_power 100                      if net_power > 100 then
  191:  set .OVERDRIVE true                                          OVERDRIVE = true;
        label *label57                                               if net_power > 100 then
  192:  op lessThan *tmp99 .REACTORS_ON :reactors                    canStart = (REACTORS_ON < reactors) and (net_power > 1000) and (total_battery >= STARTUP_BAT_ENERGY);
  193:  op greaterThan *tmp100 :net_power 1000                       ...
  194:  op land *tmp101 *tmp99 *tmp100                               ...
  195:  op greaterThanEq *tmp102 :total_battery 25000                ...
  196:  op land :canStart *tmp101 *tmp102                            ...
  197:  jump *label59 lessThan :net_power :neededPower               if net_power >= neededPower then
  198:  set .OUTPUT_2 .OUTPUT_1                                      OUTPUT_2 = OUTPUT_1;
  199:  set .OUTPUT_1 1                                              OUTPUT_1 = 1;
        label *label59                                               if net_power >= neededPower then
  200:  jump *label61 notEqual .OUTPUT_1 0                           if OUTPUT_1 == 0 then
  201:  op mul :availablePower 6300 :boosts                          availablePower = REACTOR_OUTPUT * boosts;
  202:  op div :ratio :neededPower :availablePower                   ratio = neededPower / availablePower;
  203:  jump *label63 greaterThanEq :ratio 1                         if ratio < 1 then
  204:  op add :nextStart @time 2000                                 nextStart = @time + STARTUP_DELAY;
        label *label63                                               if ratio < 1 then
        label *label61                                               if OUTPUT_1 == 0 then
  205:  op greaterThan *tmp113 @time :nextStart                      if canStart and (@time > nextStart) then
  206:  op land *tmp114 :canStart *tmp113                            ...
  207:  jump *label65 equal *tmp114 false                            ...
  208:  set *tmp116 1                                                start_at_once = FAST_START ? total_battery \ STARTUP_BAT_ENERGY : 1;
  209:  jump *label68 equal FAST_START false                         ...
  210:  op idiv *tmp116 :total_battery 25000                         ...
        label *label68                                               ...
  211:  op add *tmp118 .REACTORS_ON *tmp116                          REACTORS_ON = min(REACTORS_ON + start_at_once, reactors);
  212:  op min .REACTORS_ON *tmp118 :reactors                        ...
  213:  op add :nextStart @time 2000                                 nextStart = @time + STARTUP_DELAY;
        label *label65                                               if canStart and (@time > nextStart) then
  214:  op greaterThanEq *tmp121 .REACTORS_ON :reactors              if (REACTORS_ON >= reactors) and (@time > nextStart) and (OUTPUT_2 > 0) then
  215:  op greaterThan *tmp122 @time :nextStart                      ...
  216:  op land *tmp123 *tmp121 *tmp122                              ...
  217:  op greaterThan *tmp124 .OUTPUT_2 0                           ...
  218:  op land *tmp125 *tmp123 *tmp124                              ...
  219:  jump *label42 equal *tmp125 false                            ...
  220:  set .MODE 2                                                  MODE = RUNNING;
  221:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
  222:  set .COOLANT_FLAG 0                                          COOLANT_FLAG = 0;
  223:  set .FUEL_FLAG 0                                             FUEL_FLAG = 0;
  224:  set .GENERATOR false                                         GENERATOR = false;
  225:  jump *label42 always 0 0                                     case MODE
        label *label47                                               ...
  226:  jump *label71 notEqual .MODE 2                               ...
  227:  sensor *tmp128 tank1 @totalLiquids                           if COOLANT_FLAG and (tank1.@totalLiquids < COOLANT_CUTOFF) then
  228:  op lessThan *tmp129 *tmp128 750                              ...
  229:  op land *tmp130 .COOLANT_FLAG *tmp129                        ...
  230:  jump *label73 equal *tmp130 false                            ...
  231:  set .MODE 0                                                  MODE = SHUTDOWN;
  232:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  233:  set .REASON "Cryo level too low"                             REASON = "Cryo level too low";
        label *label73                                               if COOLANT_FLAG and (tank1.@totalLiquids < COOLANT_CUTOFF) then
  234:  sensor *tmp133 vault1 @blast-compound                        if FUEL_FLAG and (vault1.@blast-compound < FUEL_CUTOFF) then
  235:  op lessThan *tmp134 *tmp133 700                              ...
  236:  op land *tmp135 .FUEL_FLAG *tmp134                           ...
  237:  jump *label75 equal *tmp135 false                            ...
  238:  set .MODE 0                                                  MODE = SHUTDOWN;
  239:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
  240:  set .REASON "Blast compound level too low"                   REASON = "Blast compound level too low";
        label *label75                                               if FUEL_FLAG and (vault1.@blast-compound < FUEL_CUTOFF) then
  241:  sensor *tmp138 tank1 @totalLiquids                           COOLANT_FLAG = COOLANT_FLAG or (tank1.@totalLiquids > COOLANT_SAT);
  242:  op greaterThan *tmp139 *tmp138 1000                          ...
  243:  op or .COOLANT_FLAG .COOLANT_FLAG *tmp139                    ...
  244:  sensor *tmp141 vault1 @blast-compound                        FUEL_FLAG = FUEL_FLAG or (vault1.@blast-compound > FUEL_SAT);
  245:  op greaterThan *tmp142 *tmp141 800                           ...
  246:  op or .FUEL_FLAG .FUEL_FLAG *tmp142                          ...
  247:  sensor *tmp144 switch2 @enabled                              if enough_battery and switch2.@enabled then
  248:  op land *tmp145 :enough_battery *tmp144                      ...
  249:  jump *label77 equal *tmp145 false                            ...
  250:  op mul :min_level :reactors 50000                            min_level = BATTERY_CRITICAL * required_capacity;
  251:  set :commit_level 0                                          commit_level = 0;
  252:  op lessThan *tmp148 :battery_change 0                        if CAN_COMMIT and (battery_change < 0) and (REACTORS_ON < reactors) then
  253:  op land *tmp149 .CAN_COMMIT *tmp148                          ...
  254:  op lessThan *tmp150 .REACTORS_ON :reactors                   ...
  255:  op land *tmp151 *tmp149 *tmp150                              ...
  256:  jump *label79 equal *tmp151 false                            ...
  257:  op sub :p :battery_change 2500                               p = battery_change - OWN_CONSUMPTION - SAFETY_MARGIN;
  258:  op mul *tmp155 :p 0.00472972972972973                        commit_margin = STARTUP_BAT_ENERGY + (p * (COEF_A1 + (p * COEF_A2)));
  259:  op add *tmp156 -5 *tmp155                                    ...
  260:  op mul *tmp157 :p *tmp156                                    ...
  261:  op add :commit_margin 25000 *tmp157                          ...
  262:  op add :commit_level :min_level :commit_margin               commit_level = min_level + commit_margin;
  263:  op idiv *tmp160 :commit_level 1000                           print("\nCommit threshold:   [gold]", commit_level \ 1000);
  264:  print "\nCommit threshold:   [gold]"                         ...
  265:  print *tmp160                                                ...
        label *label79                                               if CAN_COMMIT and (battery_change < 0) and (REACTORS_ON < reactors) then
  266:  jump *label81 notEqual :commit_level 0                       if commit_level == 0 then
  267:  op idiv *tmp163 :min_level 1000                              print("\nRestart threshold: [gold]", min_level \ 1000);
  268:  print "\nRestart threshold: [gold]"                          ...
  269:  print *tmp163                                                ...
        label *label81                                               if commit_level == 0 then
  270:  print "[] K"                                                 print("[] K");
  271:  op lessThan *tmp164 :total_battery :min_level                if (total_battery < min_level) or (battery_change < REACTORS_ON * PANIC_ENERGY_DROP) then
  272:  op mul *tmp165 .REACTORS_ON -2500                            ...
  273:  op lessThan *tmp166 :battery_change *tmp165                  ...
  274:  op or *tmp167 *tmp164 *tmp166                                ...
  275:  jump *label83 equal *tmp167 false                            ...
  276:  op equal *tmp169 .OVERDRIVE false                            RESETS += (OVERDRIVE == false);
  277:  op add .RESETS .RESETS *tmp169                               ...
  278:  set .OVERDRIVE true                                          OVERDRIVE = true;
  279:  set .REACTORS_ON :reactors                                   REACTORS_ON = reactors;
  280:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
  281:  jump *label78 always 0 0                                     if (total_battery < min_level) or (battery_change < REACTORS_ON * PANIC_ENERGY_DROP) then
        label *label83                                               ...
  282:  op lessThan *tmp171 :battery_level 47500                     if (battery_level < BATTERY_SAT) or (battery_change < -100) then
  283:  op lessThan *tmp172 :battery_change -100                     ...
  284:  op or *tmp173 *tmp171 *tmp172                                ...
  285:  jump *label85 equal *tmp173 false                            ...
  286:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
        label *label85                                               if (battery_level < BATTERY_SAT) or (battery_change < -100) then
  287:  jump *label87 lessThanEq @time :nextDecommit                 if @time > nextDecommit then
  288:  jump *label89 equal .OVERDRIVE false                         if OVERDRIVE then
  289:  set .OVERDRIVE false                                         OVERDRIVE = false;
  290:  jump *label90 always 0 0                                     if OVERDRIVE then
        label *label89                                               ...
  291:  op sub *tmp179 .REACTORS_ON 1                                REACTORS_ON = max(REACTORS_ON - 1, 1);
  292:  op max .REACTORS_ON *tmp179 1                                ...
  293:  set .CAN_COMMIT true                                         CAN_COMMIT = true;
        label *label90                                               if OVERDRIVE then
  294:  op add :nextDecommit @time 6000                              nextDecommit = @time + DECOMMIT_DELAY;
  295:  jump *label78 always 0 0                                     if @time > nextDecommit then
        label *label87                                               ...
  296:  jump *label78 greaterThanEq :total_battery :commit_level     if total_battery < commit_level then
  297:  op add .REACTORS_ON .REACTORS_ON 1                           REACTORS_ON += 1;
  298:  op add .COMMITS .COMMITS 1                                   COMMITS += 1;
  299:  set .CAN_COMMIT false                                        CAN_COMMIT = false;
  300:  jump *label78 always 0 0                                     if enough_battery and switch2.@enabled then
        label *label77                                               ...
  301:  sensor *tmp184 switch2 @enabled                              if switch2.@enabled then
  302:  jump *label93 equal *tmp184 false                            ...
  303:  print "\n[salmon]Load adapting not possible.[]"              print("\n[salmon]Load adapting not possible.[]");
  304:  jump *label94 always 0 0                                     if switch2.@enabled then
        label *label93                                               ...
  305:  print "\n[gold]Load adapting not active.[]"                  print("\n[gold]Load adapting not active.[]");
        label *label94                                               if switch2.@enabled then
  306:  set .REACTORS_ON :reactors                                   REACTORS_ON = reactors;
  307:  set .OVERDRIVE true                                          OVERDRIVE = true;
        label *label78                                               if enough_battery and switch2.@enabled then
  308:  op mul *tmp186 PLANT_PROTECTION 47500                        if total_battery < PLANT_PROTECTION * BATTERY_SAT then
  309:  jump *label95 greaterThanEq :total_battery *tmp186           ...
  310:  set .OUTPUT_2 0                                              OUTPUT_2 = 0;
        label *label95                                               if total_battery < PLANT_PROTECTION * BATTERY_SAT then
  311:  jump *label97 notEqual .OUTPUT_2 0                           if OUTPUT_2 == 0 then
  312:  jump *label99 lessThanEq :total_battery 47500                if total_battery > BATTERY_SAT then
  313:  set .OUTPUT_2 1                                              OUTPUT_2 = 1;
  314:  jump *label100 always 0 0                                    if total_battery > BATTERY_SAT then
        label *label99                                               ...
  315:  print "\n*** [gold]Surge tower 2 offline[] ***"              print("\n*** [gold]Surge tower 2 offline[] ***");
        label *label100                                              if total_battery > BATTERY_SAT then
        label *label97                                               if OUTPUT_2 == 0 then
        label *label71                                               case MODE
        label *label42                                               ...
  316:  print "\n"                                                   print($"\n${STARTUPS}-${RESETS}-${COMMITS}");
  317:  print .STARTUPS                                              ...
  318:  print "-"                                                    ...
  319:  print .RESETS                                                ...
  320:  print "-"                                                    ...
  321:  print .COMMITS                                               ...
  322:  printflush message1                                          printflush(message1);
  323:  control enabled diode1 .OUTPUT_1 0 0 0                       diode1.enabled = OUTPUT_1;
  324:  control enabled diode2 .OUTPUT_2 0 0 0                       diode2.enabled = OUTPUT_2;
  325:  control enabled generator1 .GENERATOR 0 0 0                  generator1.enabled = GENERATOR;
  326:  control enabled generator2 .GENERATOR 0 0 0                  generator2.enabled = GENERATOR;
  327:  op equal :startup .MODE 1                                    startup = MODE == STARTUP;
  328:  set :reactors 0                                              reactors = 0;
  329:  set :boosts 0                                                boosts = 0;
  330:  set *tmp198 @links                                           for n in START ... @links do
  331:  set :n .START                                                ...
  332:  jump *label103 greaterThanEq .START *tmp198                  ...
        label *label119                                              ...
  333:  getlink :block :n                                            block = getlink(n);
  334:  sensor *tmp201 :block @type                                  case block.@type
  335:  jump *label105 notEqual *tmp201 @impact-reactor              ...
  336:  op add :reactors :reactors 1                                 reactors += 1;
  337:  op lessThanEq :enabled :reactors .REACTORS_ON                enabled = reactors <= REACTORS_ON;
  338:  control enabled :block :enabled 0 0 0                        block.enabled = enabled;
  339:  jump *label104 equal :enabled false                          if enabled then
  340:  sensor *tmp207 :block @timescale                             boosts += block.@timescale;
  341:  op add :boosts :boosts *tmp207                               ...
  342:  jump *label104 always 0 0                                    case block.@type
        label *label105                                              ...
  343:  jump *label110 equal *tmp201 @overdrive-projector            ...
  344:  jump *label109 notEqual *tmp201 @overdrive-dome              ...
        label *label110                                              ...
  345:  control enabled :block .OVERDRIVE 0 0 0                      block.enabled = OVERDRIVE;
  346:  jump *label104 always 0 0                                    case block.@type
        label *label109                                              ...
  347:  jump *label112 equal *tmp201 @conduit                        ...
  348:  jump *label112 equal *tmp201 @pulse-conduit                  ...
  349:  jump *label112 equal *tmp201 @plated-conduit                 ...
  350:  jump *label112 equal *tmp201 @conveyor                       ...
  351:  jump *label112 equal *tmp201 @titanium-conveyor              ...
  352:  jump *label112 equal *tmp201 @plastanium-conveyor            ...
  353:  jump *label111 notEqual *tmp201 @armored-conveyor            ...
        label *label112                                              ...
  354:  control enabled :block :startup 0 0 0                        block.enabled = startup;
        label *label111                                              case block.@type
        label *label104                                              ...
  355:  op add :n :n 1                                               for n in START ... @links do
  356:  jump *label119 lessThan :n *tmp198                           ...
        label *label103                                              ...
  357:  jump *label113 equal cell2 null                              if cell2 != null then
  358:  write :reactors cell2 0                                      cell2[CELL_PRIOR_REACTORS] = reactors;
  359:  write .REACTORS_ON cell2 2                                   cell2[CELL_REACTORS_ON] = REACTORS_ON;
  360:  write .OVERDRIVE cell2 3                                     cell2[CELL_OVERDRIVE] = OVERDRIVE;
  361:  read *tmp217 cell2 1                                         reactors += cell2[CELL_REMOTE_REACTORS];
  362:  op add :reactors :reactors *tmp217                           ...
  363:  read *tmp218 cell2 4                                         boosts += cell2[CELL_BOOSTS];
  364:  op add :boosts :boosts *tmp218                               ...
        label *label113                                              if cell2 != null then
  365:  op min .REACTORS_ON .REACTORS_ON :reactors                   REACTORS_ON = min(REACTORS_ON, reactors);
  366:  jump *label115 notEqual cell1 null                           if cell1 == null then
  367:  set .STARTUPS 0                                              STARTUPS = 0;
  368:  set .RESETS 0                                                RESETS = 0;
  369:  set .COMMITS 0                                               COMMITS = 0;
  370:  jump *label16 always 0 0                                     if cell1 == null then
        label *label115                                              ...
  371:  write .MODE cell1 0                                          $MODE = MODE;
  372:  write .OUTPUT_1 cell1 1                                      $OUTPUT_1 = OUTPUT_1;
  373:  write .OUTPUT_2 cell1 2                                      $OUTPUT_2 = OUTPUT_2;
  374:  write .REACTORS_ON cell1 3                                   $REACTORS_ON = REACTORS_ON;
  375:  write .OVERDRIVE cell1 4                                     $OVERDRIVE = OVERDRIVE;
  376:  write .GENERATOR cell1 5                                     $GENERATOR = GENERATOR;
  377:  write .CAN_COMMIT cell1 6                                    $CAN_COMMIT = CAN_COMMIT;
  378:  write .STARTUPS cell1 7                                      $STARTUPS = STARTUPS;
  379:  write .RESETS cell1 8                                        $RESETS = RESETS;
  380:  write .COMMITS cell1 9                                       $COMMITS = COMMITS;
  381:  jump *label16 always 0 0                                     while true do


Performance: parsed in 273 ms, compiled in 171 ms, optimized in 411 ms, run in 85 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
No reactor.
[--- Previous segment repeated 160,03 times ---]

Execution step limit of 100000 exceeded.
