jump 3 always 0 0
print "This is the preferred unit type to use for bringing in supplies."
print "If no units of this type exist, we'll try using other types."
set UNIT_TYPE @poly
jump 6 always 0 0
print "Do not modify anything below this line."
set .MSG ""
set .VAULT vault1
sensor *tmp0 vault1 @dead
jump 13 equal *tmp0 0
set .VAULT vault1
sensor *tmp0 vault1 @dead
jump 10 notEqual *tmp0 0
printflush null
print "[gold]Looking for suitable unit type:[]\n"
set :areUnitsAvailable:occupied 0
ubind UNIT_TYPE
set :areUnitsAvailable:firstUnit @unit
jump 30 equal :areUnitsAvailable:firstUnit null
sensor *tmp7 @unit @controlled
jump 23 equal *tmp7 0
sensor *tmp9 @unit @controller
jump 25 notEqual *tmp9 @this
set *tmp3 true
jump 35 always 0 0
op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
ubind UNIT_TYPE
jump 30 equal @unit :areUnitsAvailable:firstUnit
sensor *tmp13 :areUnitsAvailable:firstUnit @dead
jump 19 equal *tmp13 0
print UNIT_TYPE
print " occupied: "
print :areUnitsAvailable:occupied
print "\n"
set *tmp3 false
jump 38 equal *tmp3 false
set *tmp2 UNIT_TYPE
jump 136 always 0 0
jump 62 equal @flare UNIT_TYPE
set :areUnitsAvailable.1:occupied 0
ubind @flare
set :areUnitsAvailable.1:firstUnit @unit
jump 54 equal :areUnitsAvailable.1:firstUnit null
sensor *tmp24 @unit @controlled
jump 47 equal *tmp24 0
sensor *tmp26 @unit @controller
jump 49 notEqual *tmp26 @this
set *tmp20 true
jump 58 always 0 0
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
ubind @flare
jump 54 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
jump 43 equal *tmp30 0
print "flare occupied: "
print :areUnitsAvailable.1:occupied
print "\n"
set *tmp20 false
jump 62 equal *tmp20 false
printflush null
set *tmp2 @flare
jump 136 always 0 0
jump 86 equal @poly UNIT_TYPE
set :areUnitsAvailable.1:occupied 0
ubind @poly
set :areUnitsAvailable.1:firstUnit @unit
jump 78 equal :areUnitsAvailable.1:firstUnit null
sensor *tmp24 @unit @controlled
jump 71 equal *tmp24 0
sensor *tmp26 @unit @controller
jump 73 notEqual *tmp26 @this
set *tmp20 true
jump 82 always 0 0
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
ubind @poly
jump 78 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
jump 67 equal *tmp30 0
print "poly occupied: "
print :areUnitsAvailable.1:occupied
print "\n"
set *tmp20 false
jump 86 equal *tmp20 false
printflush null
set *tmp2 @poly
jump 136 always 0 0
jump 110 equal @mega UNIT_TYPE
set :areUnitsAvailable.1:occupied 0
ubind @mega
set :areUnitsAvailable.1:firstUnit @unit
jump 102 equal :areUnitsAvailable.1:firstUnit null
sensor *tmp24 @unit @controlled
jump 95 equal *tmp24 0
sensor *tmp26 @unit @controller
jump 97 notEqual *tmp26 @this
set *tmp20 true
jump 106 always 0 0
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
ubind @mega
jump 102 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
jump 91 equal *tmp30 0
print "mega occupied: "
print :areUnitsAvailable.1:occupied
print "\n"
set *tmp20 false
jump 110 equal *tmp20 false
printflush null
set *tmp2 @mega
jump 136 always 0 0
jump 134 equal @mono UNIT_TYPE
set :areUnitsAvailable.1:occupied 0
ubind @mono
set :areUnitsAvailable.1:firstUnit @unit
jump 126 equal :areUnitsAvailable.1:firstUnit null
sensor *tmp24 @unit @controlled
jump 119 equal *tmp24 0
sensor *tmp26 @unit @controller
jump 121 notEqual *tmp26 @this
set *tmp20 true
jump 130 always 0 0
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
ubind @mono
jump 126 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
jump 115 equal *tmp30 0
print "mono occupied: "
print :areUnitsAvailable.1:occupied
print "\n"
set *tmp20 false
jump 134 equal *tmp20 false
printflush null
set *tmp2 @mono
jump 136 always 0 0
printflush message1
jump 13 always 0 0
ubind *tmp2
set :rebindUnit:firstUnit @unit
jump 0 equal :rebindUnit:firstUnit null
sensor *tmp47 @unit @controlled
jump 146 equal *tmp47 0
ubind *tmp2
jump 0 equal @unit :rebindUnit:firstUnit
sensor *tmp51 :rebindUnit:firstUnit @dead
jump 139 equal *tmp51 0
end
ucontrol flag 1 0 0 0 0
set *tmp34 @unit
set .UNIT *tmp34
sensor .UNIT_CAPACITY *tmp34 @itemCapacity
sensor .SPEED *tmp34 @speed
op div .SPEED_TENTHS .SPEED 10
print "[gold]Locating core..."
printflush message1
ulocate building core false @copper 0 0 0 .CORE
jump 154 equal .CORE null
sensor .CORE_X .CORE @x
sensor .CORE_Y .CORE @y
sensor .VAULT_X .VAULT @x
sensor .VAULT_Y .VAULT @y
op add :unitCheck @time 5000
set :start @time
sensor *tmp67 .VAULT @thorium
print " === [gold]Supplying Power Plant[] === \n\n\n[gold]Thorium[] status: [green]"
print *tmp67
print "[]\n"
sensor *tmp68 .VAULT @thorium
jump 283 greaterThanEq *tmp68 500
print "\nUnit type: [green]"
print *tmp2
print "[]\n"
jump 179 equal .UNIT null
ubind .UNIT
sensor *tmp75 @unit @dead
op equal *tmp76 *tmp75 0
sensor *tmp77 @unit @controller
op equal *tmp78 *tmp77 @this
op land *tmp79 *tmp76 *tmp78
jump 189 notEqual *tmp79 false
ubind *tmp2
set :rebindUnit.1:firstUnit @unit
jump 0 equal :rebindUnit.1:firstUnit null
sensor *tmp84 @unit @controlled
jump 189 equal *tmp84 0
ubind *tmp2
jump 0 equal @unit :rebindUnit.1:firstUnit
sensor *tmp88 :rebindUnit.1:firstUnit @dead
jump 182 equal *tmp88 0
end
sensor :processUnit:state @unit @flag
set :processUnit:distance -1
jump 193 lessThan :processUnit:state 2
jump 206 lessThanEq :processUnit:state 3
sensor *tmp94 @unit @firstItem
jump 197 notEqual *tmp94 @thorium
set :processUnit:state 3
jump 206 always 0 0
sensor *tmp97 @unit @totalItems
jump 201 notEqual *tmp97 0
set :processUnit:state 2
jump 206 always 0 0
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6 0 0
ucontrol within .CORE_X .CORE_Y 8 *tmp100 0
jump 206 equal *tmp100 false
ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0
jump 226 notEqual :processUnit:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp104 0
jump 217 equal *tmp104 false
ucontrol itemTake .CORE @thorium .UNIT_CAPACITY 0 0
sensor *tmp106 @unit @totalItems
jump 215 lessThan *tmp106 .UNIT_CAPACITY
ucontrol approach .VAULT_X .VAULT_Y 6 0 0
set :processUnit:state 3
jump 226 always 0 0
set .MSG ", loading\n"
jump 226 always 0 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set .MSG ", fetching in [gold]"
sensor *tmp109 @unit @x
op sub *tmp110 .CORE_X *tmp109
sensor *tmp111 @unit @y
op sub *tmp112 .CORE_Y *tmp111
op len *tmp113 *tmp110 *tmp112
op idiv *tmp114 *tmp113 .SPEED_TENTHS
op div :processUnit:distance *tmp114 10
jump 245 notEqual :processUnit:state 3
ucontrol within .VAULT_X .VAULT_Y 8 *tmp118 0
jump 236 equal *tmp118 false
ucontrol itemDrop .VAULT .UNIT_CAPACITY 0 0 0
set .MSG ", supplying\n"
sensor *tmp120 @unit @totalItems
jump 245 greaterThan *tmp120 0
ucontrol approach .CORE_X .CORE_Y 6 0 0
set :processUnit:state 2
jump 245 always 0 0
ucontrol approach .VAULT_X .VAULT_Y 6 0 0
set .MSG ", returning in [gold]"
sensor *tmp123 @unit @x
op sub *tmp124 .VAULT_X *tmp123
sensor *tmp125 @unit @y
op sub *tmp126 .VAULT_Y *tmp125
op len *tmp127 *tmp124 *tmp126
op idiv *tmp128 *tmp127 .SPEED_TENTHS
op div :processUnit:distance *tmp128 10
ucontrol flag :processUnit:state 0 0 0 0
sensor *tmp130 @unit @totalItems
print "[gold]"
print *tmp130
print "[]"
jump 255 lessThan :processUnit:distance 0
print .MSG
print :processUnit:distance
print "[] sec\n"
jump 256 always 0 0
print .MSG
set .UNIT @unit
jump 262 notEqual :processUnit:state 2
sensor *tmp134 .VAULT @thorium
jump 262 lessThan *tmp134 500
ucontrol unbind 0 0 0 0 0
jump 283 always 0 0
jump 283 equal *tmp2 UNIT_TYPE
jump 283 lessThanEq :unitCheck @time
set :areUnitsAvailable.2:occupied 0
ubind UNIT_TYPE
set :areUnitsAvailable.2:firstUnit @unit
jump 279 equal :areUnitsAvailable.2:firstUnit null
sensor *tmp144 @unit @controlled
jump 272 equal *tmp144 0
sensor *tmp146 @unit @controller
jump 274 notEqual *tmp146 @this
set *tmp140 true
jump 280 always 0 0
op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
ubind UNIT_TYPE
jump 279 equal @unit :areUnitsAvailable.2:firstUnit
sensor *tmp150 :areUnitsAvailable.2:firstUnit @dead
jump 268 equal *tmp150 0
set *tmp140 false
jump 282 equal *tmp140 false
end
op add :unitCheck @time 5000
op sub *tmp155 @time :start
op floor *tmp156 *tmp155 0
print "\n[lightgray]Loop time: "
print *tmp156
print " ms"
printflush message1
jump 161 always 0 0
print "Compiled by Mindcode - github.com/cardillan/mindcode"

