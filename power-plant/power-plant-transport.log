   466 instructions before optimizations.
    19 instructions eliminated by Temp Variables Elimination.
    73 instructions eliminated by Dead Code Elimination (7 iterations).
     7 instructions eliminated by Jump Normalization (2 passes, 5 iterations).
    20 instructions eliminated by Jump Optimization (5 iterations).
    34 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
    32 instructions eliminated by Data Flow Optimization (4 passes, 13 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     1 loops improved by Loop Optimization.
    91 instructions added by Loop Unrolling (5 iterations).
     1 loops unrolled by Loop Unrolling.
     4 instructions eliminated by Jump Straightening (5 iterations).
    10 instructions updated by JumpThreading.
    18 instructions eliminated by Unreachable Code Elimination (2 iterations).
    26 instructions eliminated by Print Merging.
   325 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 697):
  * Replicate loop condition at line 30:1                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
    Unroll iteration loop at line 93:9                           cost   117, benefit      375.0, efficiency        3.2

Pass 1: speed optimization selection (cost limit 696):
  * Unroll iteration loop at line 93:9                           cost   117, benefit      375.0, efficiency        3.2 (+87 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-49 instructions):
 
    35 jump *label13 equal *tmp11 false
    36 set *tmp3 true
    37 jump *label7 always
-    * set *tmp12 null
    38 jump *label14 always
    39 label *label13
    40 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
-    * set *tmp12 :areUnitsAvailable:occupied
    41 label *label14
    42 ubind :areUnitsAvailable:type
    43 label *label11
 
    47 op land *tmp16 *tmp13 *tmp15
    48 jump *label10 notEqual *tmp16 false
    49 label *label12
-    * set *tmp6 null
    50 jump *label9 always
    51 label *label8
-    * set *tmp6 null
    52 label *label9
    53 jump *label15 equal :areUnitsAvailable:output false
    54 print :areUnitsAvailable:type
 
    56 print "occupied: "
    57 print :areUnitsAvailable:occupied
    58 print "\n"
-    * set *tmp17 null
    59 jump *label16 always
    60 label *label15
-    * set *tmp17 null
    61 label *label16
    62 set *tmp3 false
    63 jump *label7 always
 
    66 jump *label17 equal *tmp3 false
    67 set *tmp2 UNIT_TYPE
    68 jump *label3 always
-    * set *tmp18 null
    69 jump *label18 always
    70 label *label17
-    * set *tmp18 null
    71 label *label18
    72 set :chooseUnitType:type @flare
    73 setaddr *tmp19 *label22
 
   103 jump *label34 equal *tmp30 false
   104 set *tmp22 true
   105 jump *label28 always
-    * set *tmp31 null
   106 jump *label35 always
   107 label *label34
   108 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp31 :areUnitsAvailable.1:occupied
   109 label *label35
   110 ubind :areUnitsAvailable.1:type
   111 label *label32
 
   115 op land *tmp35 *tmp32 *tmp34
   116 jump *label31 notEqual *tmp35 false
   117 label *label33
-    * set *tmp25 null
   118 jump *label30 always
   119 label *label29
-    * set *tmp25 null
   120 label *label30
   121 jump *label36 equal :areUnitsAvailable.1:output false
   122 print :areUnitsAvailable.1:type
 
   124 print "occupied: "
   125 print :areUnitsAvailable.1:occupied
   126 print "\n"
-    * set *tmp36 null
   127 jump *label37 always
   128 label *label36
-    * set *tmp36 null
   129 label *label37
   130 set *tmp22 false
   131 jump *label28 always
 
   140 label *label38
   141 set *tmp37 null
   142 label *label39
-    * set *tmp21 *tmp37
   143 jump *label27 always
   144 label *label26
-    * set *tmp21 null
   145 label *label27
   146 label *label20
   147 multijump *tmp19 0 0 (m:marker0)
 
   165 op equal *tmp45 *tmp44 @this
   166 op land *tmp46 *tmp43 *tmp45
   167 jump *label44 equal *tmp46 false
-    * set *tmp39 :rebindUnit:currentUnit
   168 jump *label41 always
   169 set *tmp47 null
   170 jump *label45 always
   171 label *label44
   172 set *tmp47 null
   173 label *label45
-    * set *tmp41 *tmp47
   174 jump *label43 always
   175 label *label42
-    * set *tmp41 null
   176 label *label43
   177 ubind .TYPE
   178 set *tmp48 @unit
 
   183 sensor *tmp51 @unit @controlled
   184 op equal *tmp52 *tmp51 0
   185 jump *label51 equal *tmp52 false
-    * set *tmp39 @unit
   186 jump *label41 always
-    * set *tmp53 null
   187 jump *label52 always
   188 label *label51
-    * set *tmp53 null
   189 label *label52
   190 ubind .TYPE
   191 label *label49
 
   195 op land *tmp57 *tmp54 *tmp56
   196 jump *label48 notEqual *tmp57 false
   197 label *label50
-    * set *tmp50 null
   198 jump *label47 always
   199 label *label46
-    * set *tmp50 null
   200 label *label47
   201 end
-    * set *tmp39 null
   202 label *label41
   203 ucontrol flag 1
   204 set *tmp38 @unit
 
   272 label *label65
   273 set *tmp85 null
   274 label *label66
-    * set *tmp79 *tmp85
   275 jump *label64 always
   276 label *label63
-    * set *tmp79 null
   277 label *label64
   278 ubind .TYPE
   279 set *tmp86 @unit
 
   286 jump *label72 equal *tmp90 false
   287 set *tmp77 @unit
   288 jump *label62 always
-    * set *tmp91 null
   289 jump *label73 always
   290 label *label72
-    * set *tmp91 null
   291 label *label73
   292 ubind .TYPE
   293 label *label70
 
   297 op land *tmp95 *tmp92 *tmp94
   298 jump *label69 notEqual *tmp95 false
   299 label *label71
-    * set *tmp88 null
   300 jump *label68 always
   301 label *label67
-    * set *tmp88 null
   302 label *label68
   303 end
   304 set *tmp77 null
 
   340 label *label79
   341 set *tmp103 *tmp106
   342 label *label77
-    * set *tmp100 *tmp103
   343 jump *label75 always
   344 label *label74
-    * set *tmp100 null
   345 label *label75
   346 op equal *tmp109 :processUnit:state 2
   347 jump *label82 equal *tmp109 false
 
   374 set :processUnit:distance *tmp122
   375 set *tmp112 :processUnit:distance
   376 label *label85
-    * set *tmp110 *tmp112
   377 jump *label83 always
   378 label *label82
-    * set *tmp110 null
   379 label *label83
   380 op equal *tmp123 :processUnit:state 3
   381 jump *label88 equal *tmp123 false
 
   408 set :processUnit:distance *tmp136
   409 set *tmp126 :processUnit:distance
   410 label *label91
-    * set *tmp124 *tmp126
   411 jump *label89 always
   412 label *label88
-    * set *tmp124 null
   413 label *label89
   414 ucontrol flag :processUnit:state
   415 sensor *tmp137 @unit @totalItems
 
   426 print "["
   427 print "] sec"
   428 print "\n"
-    * set *tmp139 null
   429 jump *label95 always
   430 label *label94
   431 print .MSG
-    * set *tmp139 .MSG
   432 label *label95
   433 set *tmp76 @unit
   434 jump *label61 always
 
   466 jump *label106 equal *tmp157 false
   467 set *tmp149 true
   468 jump *label100 always
-    * set *tmp158 null
   469 jump *label107 always
   470 label *label106
   471 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp158 :areUnitsAvailable.2:occupied
   472 label *label107
   473 ubind :areUnitsAvailable.2:type
   474 label *label104
 
   478 op land *tmp162 *tmp159 *tmp161
   479 jump *label103 notEqual *tmp162 false
   480 label *label105
-    * set *tmp152 null
   481 jump *label102 always
   482 label *label101
-    * set *tmp152 null
   483 label *label102
   484 jump *label108 equal :areUnitsAvailable.2:output false
   485 print :areUnitsAvailable.2:type
 
   487 print "occupied: "
   488 print :areUnitsAvailable.2:occupied
   489 print "\n"
-    * set *tmp163 null
   490 jump *label109 always
   491 label *label108
-    * set *tmp163 null
   492 label *label109
   493 set *tmp149 false
   494 jump *label100 always
 
   496 label *label100
   497 jump *label110 equal *tmp149 false
   498 end
-    * set *tmp164 null
   499 jump *label111 always
   500 label *label110
-    * set *tmp164 null
   501 label *label111
   502 op add *tmp165 @time 5000
   503 set :unitCheck *tmp165
 
   508 label *label99
   509 set *tmp144 *tmp148
   510 label *label97
-    * set *tmp75 *tmp144
   511 jump *label60 always
   512 label *label59
-    * set *tmp75 null
   513 label *label60
   514 op sub *tmp166 @time :start
   515 op floor *tmp167 *tmp166

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-14 instructions):
 
   135 printflush null
   136 set *tmp2 :chooseUnitType:type
   137 jump *label3 always
-    * set *tmp37 null
   138 jump *label39 always
   139 label *label38
-    * set *tmp37 null
   140 label *label39
   141 jump *label27 always
   142 label *label26
 
   164 op land *tmp46 *tmp43 *tmp45
   165 jump *label44 equal *tmp46 false
   166 jump *label41 always
-    * set *tmp47 null
   167 jump *label45 always
   168 label *label44
-    * set *tmp47 null
   169 label *label45
   170 jump *label43 always
   171 label *label42
 
   263 jump *label65 equal *tmp84 false
   264 set *tmp77 :rebindUnit.1:currentUnit
   265 jump *label62 always
-    * set *tmp85 null
   266 jump *label66 always
   267 label *label65
-    * set *tmp85 null
   268 label *label66
   269 jump *label64 always
   270 label *label63
 
   310 op equal *tmp102 *tmp101 .ITEM
   311 jump *label76 equal *tmp102 false
   312 set :processUnit:state 3
-    * set *tmp103 :processUnit:state
   313 jump *label77 always
   314 label *label76
   315 sensor *tmp104 @unit @totalItems
 
   331 label *label81
   332 set *tmp106 *tmp108
   333 label *label79
-    * set *tmp103 *tmp106
   334 label *label77
   335 jump *label75 always
   336 label *label74
 
   351 set .MSG ", loading\n"
   352 set *tmp115 .MSG
   353 label *label87
-    * set *tmp112 *tmp115
   354 jump *label85 always
   355 label *label84
   356 ucontrol approach .CORE_X .CORE_Y 6
 
   363 op idiv *tmp121 *tmp120 .SPEED_TENTHS
   364 op div *tmp122 *tmp121 10
   365 set :processUnit:distance *tmp122
-    * set *tmp112 :processUnit:distance
   366 label *label85
   367 jump *label83 always
   368 label *label82
 
   383 label *label92
   384 set *tmp129 null
   385 label *label93
-    * set *tmp126 *tmp129
   386 jump *label91 always
   387 label *label90
   388 ucontrol approach .VAULT_X .VAULT_Y 6
 
   395 op idiv *tmp135 *tmp134 .SPEED_TENTHS
   396 op div *tmp136 *tmp135 10
   397 set :processUnit:distance *tmp136
-    * set *tmp126 :processUnit:distance
   398 label *label91
   399 jump *label89 always
   400 label *label88
 
   430 op land *tmp143 *tmp140 *tmp142
   431 jump *label96 equal *tmp143 false
   432 ucontrol unbind
-    * set *tmp144 null
   433 jump *label97 always
   434 label *label96
   435 op notEqual *tmp145 .TYPE UNIT_TYPE
 
   493 label *label98
   494 set *tmp148 null
   495 label *label99
-    * set *tmp144 *tmp148
   496 label *label97
   497 jump *label60 always
   498 label *label59

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-8 instructions):
 
   316 op equal *tmp105 *tmp104 0
   317 jump *label78 equal *tmp105 false
   318 set :processUnit:state 2
-    * set *tmp106 :processUnit:state
   319 jump *label79 always
   320 label *label78
   321 set .MSG ", initializing\n"
 
   328 label *label80
   329 set *tmp108 null
   330 label *label81
-    * set *tmp106 *tmp108
   331 label *label79
   332 label *label77
   333 jump *label75 always
 
   343 jump *label86 equal *tmp114 false
   344 ucontrol approach .VAULT_X .VAULT_Y 6
   345 set :processUnit:state 3
-    * set *tmp115 :processUnit:state
   346 jump *label87 always
   347 label *label86
   348 set .MSG ", loading\n"
-    * set *tmp115 .MSG
   349 label *label87
   350 jump *label85 always
   351 label *label84
 
   374 jump *label92 equal *tmp128 false
   375 ucontrol approach .CORE_X .CORE_Y 6
   376 set :processUnit:state 2
-    * set *tmp129 :processUnit:state
   377 jump *label93 always
   378 label *label92
-    * set *tmp129 null
   379 label *label93
   380 jump *label91 always
   381 label *label90
 
   482 label *label111
   483 op add *tmp165 @time 5000
   484 set :unitCheck *tmp165
-    * set *tmp148 :unitCheck
   485 jump *label99 always
   486 label *label98
-    * set *tmp148 null
   487 label *label99
   488 label *label97
   489 jump *label60 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   323 ucontrol within .CORE_X .CORE_Y 8 *tmp107
   324 jump *label80 equal *tmp107 false
   325 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp108 null
   326 jump *label81 always
   327 label *label80
-    * set *tmp108 null
   328 label *label81
   329 label *label79
   330 label *label77

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-19 instructions):
 
    22 set :areUnitsAvailable:output true
    23 set :areUnitsAvailable:occupied 0
    24 ubind :areUnitsAvailable:type
-    * set *tmp4 @unit
-    * set :areUnitsAvailable:firstUnit *tmp4
+   25 set :areUnitsAvailable:firstUnit @unit
    26 op notEqual *tmp5 :areUnitsAvailable:firstUnit null
    27 jump *label8 equal *tmp5 false
    28 label *label10
 
    89 set :areUnitsAvailable.1:output true
    90 set :areUnitsAvailable.1:occupied 0
    91 ubind :areUnitsAvailable.1:type
-    * set *tmp23 @unit
-    * set :areUnitsAvailable.1:firstUnit *tmp23
+   92 set :areUnitsAvailable.1:firstUnit @unit
    93 op notEqual *tmp24 :areUnitsAvailable.1:firstUnit null
    94 jump *label29 equal *tmp24 false
    95 label *label31
 
   169 label *label42
   170 label *label43
   171 ubind .TYPE
-    * set *tmp48 @unit
-    * set :rebindUnit:firstUnit *tmp48
+  172 set :rebindUnit:firstUnit @unit
   173 op notEqual *tmp49 :rebindUnit:firstUnit null
   174 jump *label46 equal *tmp49 false
   175 label *label48
 
   199 set *tmp38 null
   200 label *label40
   201 set .UNIT *tmp38
-    * sensor *tmp58 .UNIT @itemCapacity
-    * set .UNIT_CAPACITY *tmp58
-    * sensor *tmp59 .UNIT @speed
-    * set .SPEED *tmp59
-    * op div *tmp60 .SPEED 10
-    * set .SPEED_TENTHS *tmp60
+  202 sensor .UNIT_CAPACITY .UNIT @itemCapacity
+  203 sensor .SPEED .UNIT @speed
+  204 op div .SPEED_TENTHS .SPEED 10
   205 print "[gold]Locating core..."
   206 printflush message1
   207 label *label53
-    * ulocate building core false @copper *tmp62 *tmp63 *tmp64 *tmp61
-    * set .CORE *tmp61
+  208 ulocate building core false @copper 0 0 0 .CORE
   209 label *label54
   210 op equal *tmp65 .CORE null
   211 jump *label53 notEqual *tmp65 false
   212 label *label55
-    * sensor *tmp66 .CORE @x
-    * set .CORE_X *tmp66
-    * sensor *tmp67 .CORE @y
-    * set .CORE_Y *tmp67
-    * sensor *tmp68 .VAULT @x
-    * set .VAULT_X *tmp68
-    * sensor *tmp69 .VAULT @y
-    * set .VAULT_Y *tmp69
-    * op add *tmp70 @time 5000
-    * set :unitCheck *tmp70
+  213 sensor .CORE_X .CORE @x
+  214 sensor .CORE_Y .CORE @y
+  215 sensor .VAULT_X .VAULT @x
+  216 sensor .VAULT_Y .VAULT @y
+  217 op add :unitCheck @time 5000
   218 label *label56
   219 jump *label58 equal true false
-    * set *tmp71 @time
-    * set :start *tmp71
+  220 set :start @time
   221 print " === [gold]Supplying Power Plant[] === "
   222 print "\n"
   223 print "\n"
 
   257 label *label63
   258 label *label64
   259 ubind .TYPE
-    * set *tmp86 @unit
-    * set :rebindUnit.1:firstUnit *tmp86
+  260 set :rebindUnit.1:firstUnit @unit
   261 op notEqual *tmp87 :rebindUnit.1:firstUnit null
   262 jump *label67 equal *tmp87 false
   263 label *label69
 
   284 set *tmp77 null
   285 label *label62
   286 set :processUnit:unit *tmp77
-    * sensor *tmp96 @unit @flag
-    * set :processUnit:state *tmp96
+  287 sensor :processUnit:state @unit @flag
   288 set :processUnit:distance -1
   289 set :processUnit:color "gold"
   290 op lessThan *tmp97 :processUnit:state 2
 
   340 op sub *tmp119 .CORE_Y *tmp118
   341 op len *tmp120 *tmp117 *tmp119
   342 op idiv *tmp121 *tmp120 .SPEED_TENTHS
-    * op div *tmp122 *tmp121 10
-    * set :processUnit:distance *tmp122
+  343 op div :processUnit:distance *tmp121 10
   344 label *label85
   345 jump *label83 always
   346 label *label82
 
   369 op sub *tmp133 .VAULT_Y *tmp132
   370 op len *tmp134 *tmp131 *tmp133
   371 op idiv *tmp135 *tmp134 .SPEED_TENTHS
-    * op div *tmp136 *tmp135 10
-    * set :processUnit:distance *tmp136
+  372 op div :processUnit:distance *tmp135 10
   373 label *label91
   374 jump *label89 always
   375 label *label88
 
   415 set :areUnitsAvailable.2:output false
   416 set :areUnitsAvailable.2:occupied 0
   417 ubind :areUnitsAvailable.2:type
-    * set *tmp150 @unit
-    * set :areUnitsAvailable.2:firstUnit *tmp150
+  418 set :areUnitsAvailable.2:firstUnit @unit
   419 op notEqual *tmp151 :areUnitsAvailable.2:firstUnit null
   420 jump *label101 equal *tmp151 false
   421 label *label103
 
   460 jump *label111 always
   461 label *label110
   462 label *label111
-    * op add *tmp165 @time 5000
-    * set :unitCheck *tmp165
+  463 op add :unitCheck @time 5000
   464 jump *label99 always
   465 label *label98
   466 label *label99

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    14 jump *label0 always
    15 label *label2
    16 label *label4
-    * jump *label6 equal true false
    17 printflush null
    18 print "[gold]Looking for suitable unit type:[]"
    19 print "\n"
 
   215 sensor .VAULT_Y .VAULT @y
   216 op add :unitCheck @time 5000
   217 label *label56
-    * jump *label58 equal true false
   218 set :start @time
   219 print " === [gold]Supplying Power Plant[] === "
   220 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-20 instructions):
 
     7 set .VAULT vault1
     8 label *label0
     9 sensor *tmp0 .VAULT @dead
-    * op notEqual *tmp1 *tmp0 0
-    * jump *label2 equal *tmp1 false
+   10 jump *label2 equal *tmp0 0
    11 set .VAULT vault1
    12 label *label1
    13 jump *label0 always
 
    21 set :areUnitsAvailable:occupied 0
    22 ubind :areUnitsAvailable:type
    23 set :areUnitsAvailable:firstUnit @unit
-    * op notEqual *tmp5 :areUnitsAvailable:firstUnit null
-    * jump *label8 equal *tmp5 false
+   24 jump *label8 equal :areUnitsAvailable:firstUnit null
    25 label *label10
    26 sensor *tmp7 @unit @controlled
    27 op equal *tmp8 *tmp7 0
 
    80 set :chooseUnitType:type @mono
    81 setaddr *tmp19 *label25
    82 label *label19
-    * op notEqual *tmp20 :chooseUnitType:type UNIT_TYPE
-    * jump *label26 equal *tmp20 false
+   83 jump *label26 equal :chooseUnitType:type UNIT_TYPE
    84 set :areUnitsAvailable.1:type :chooseUnitType:type
    85 set :areUnitsAvailable.1:output true
    86 set :areUnitsAvailable.1:occupied 0
    87 ubind :areUnitsAvailable.1:type
    88 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp24 :areUnitsAvailable.1:firstUnit null
-    * jump *label29 equal *tmp24 false
+   89 jump *label29 equal :areUnitsAvailable.1:firstUnit null
    90 label *label31
    91 sensor *tmp26 @unit @controlled
    92 op equal *tmp27 *tmp26 0
 
   147 set .TYPE *tmp2
   148 set :acquireUnit:currentUnit .UNIT
   149 set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * op notEqual *tmp40 :rebindUnit:currentUnit null
-    * jump *label42 equal *tmp40 false
+  150 jump *label42 equal :rebindUnit:currentUnit null
   151 ubind :rebindUnit:currentUnit
   152 sensor *tmp42 @unit @dead
   153 op equal *tmp43 *tmp42 0
 
   164 label *label43
   165 ubind .TYPE
   166 set :rebindUnit:firstUnit @unit
-    * op notEqual *tmp49 :rebindUnit:firstUnit null
-    * jump *label46 equal *tmp49 false
+  167 jump *label46 equal :rebindUnit:firstUnit null
   168 label *label48
   169 sensor *tmp51 @unit @controlled
-    * op equal *tmp52 *tmp51 0
-    * jump *label51 equal *tmp52 false
+  170 jump *label51 notEqual *tmp51 0
   171 jump *label41 always
   172 jump *label52 always
   173 label *label51
 
   199 label *label53
   200 ulocate building core false @copper 0 0 0 .CORE
   201 label *label54
-    * op equal *tmp65 .CORE null
-    * jump *label53 notEqual *tmp65 false
+  202 jump *label53 equal .CORE null
   203 label *label55
   204 sensor .CORE_X .CORE @x
   205 sensor .CORE_Y .CORE @y
 
   219 print "]"
   220 print "\n"
   221 sensor *tmp73 .VAULT .ITEM
-    * op lessThan *tmp74 *tmp73 500
-    * jump *label59 equal *tmp74 false
+  222 jump *label59 greaterThanEq *tmp73 500
   223 print "\n"
   224 print "Unit type: [green]"
   225 print .TYPE
 
   228 print "\n"
   229 set :processUnit:unit .UNIT
   230 set :rebindUnit.1:currentUnit :processUnit:unit
-    * op notEqual *tmp78 :rebindUnit.1:currentUnit null
-    * jump *label63 equal *tmp78 false
+  231 jump *label63 equal :rebindUnit.1:currentUnit null
   232 ubind :rebindUnit.1:currentUnit
   233 sensor *tmp80 @unit @dead
   234 op equal *tmp81 *tmp80 0
 
   246 label *label64
   247 ubind .TYPE
   248 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp87 :rebindUnit.1:firstUnit null
-    * jump *label67 equal *tmp87 false
+  249 jump *label67 equal :rebindUnit.1:firstUnit null
   250 label *label69
   251 sensor *tmp89 @unit @controlled
-    * op equal *tmp90 *tmp89 0
-    * jump *label72 equal *tmp90 false
+  252 jump *label72 notEqual *tmp89 0
   253 set *tmp77 @unit
   254 jump *label62 always
   255 jump *label73 always
 
   278 op or *tmp99 *tmp97 *tmp98
   279 jump *label74 equal *tmp99 false
   280 sensor *tmp101 @unit @firstItem
-    * op equal *tmp102 *tmp101 .ITEM
-    * jump *label76 equal *tmp102 false
+  281 jump *label76 notEqual *tmp101 .ITEM
   282 set :processUnit:state 3
   283 jump *label77 always
   284 label *label76
   285 sensor *tmp104 @unit @totalItems
-    * op equal *tmp105 *tmp104 0
-    * jump *label78 equal *tmp105 false
+  286 jump *label78 notEqual *tmp104 0
   287 set :processUnit:state 2
   288 jump *label79 always
   289 label *label78
 
   300 jump *label75 always
   301 label *label74
   302 label *label75
-    * op equal *tmp109 :processUnit:state 2
-    * jump *label82 equal *tmp109 false
+  303 jump *label82 notEqual :processUnit:state 2
   304 ucontrol within .CORE_X .CORE_Y 8 *tmp111
   305 jump *label84 equal *tmp111 false
   306 ucontrol itemTake .CORE .ITEM .UNIT_CAPACITY
   307 sensor *tmp113 @unit @totalItems
-    * op greaterThanEq *tmp114 *tmp113 .UNIT_CAPACITY
-    * jump *label86 equal *tmp114 false
+  308 jump *label86 lessThan *tmp113 .UNIT_CAPACITY
   309 ucontrol approach .VAULT_X .VAULT_Y 6
   310 set :processUnit:state 3
   311 jump *label87 always
 
   327 jump *label83 always
   328 label *label82
   329 label *label83
-    * op equal *tmp123 :processUnit:state 3
-    * jump *label88 equal *tmp123 false
+  330 jump *label88 notEqual :processUnit:state 3
   331 ucontrol within .VAULT_X .VAULT_Y 8 *tmp125
   332 jump *label90 equal *tmp125 false
   333 ucontrol itemDrop .VAULT .UNIT_CAPACITY
   334 set .MSG ", supplying\n"
   335 sensor *tmp127 @unit @totalItems
-    * op lessThanEq *tmp128 *tmp127 0
-    * jump *label92 equal *tmp128 false
+  336 jump *label92 greaterThan *tmp127 0
   337 ucontrol approach .CORE_X .CORE_Y 6
   338 set :processUnit:state 2
   339 jump *label93 always
 
   362 print *tmp137
   363 print "["
   364 print "]"
-    * op greaterThanEq *tmp138 :processUnit:distance 0
-    * jump *label94 equal *tmp138 false
+  365 jump *label94 lessThan :processUnit:distance 0
   366 print .MSG
   367 print :processUnit:distance
   368 print "["
 
   395 set :areUnitsAvailable.2:occupied 0
   396 ubind :areUnitsAvailable.2:type
   397 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp151 :areUnitsAvailable.2:firstUnit null
-    * jump *label101 equal *tmp151 false
+  398 jump *label101 equal :areUnitsAvailable.2:firstUnit null
   399 label *label103
   400 sensor *tmp153 @unit @controlled
   401 op equal *tmp154 *tmp153 0

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-25 instructions):
 
    43 op land *tmp16 *tmp13 *tmp15
    44 jump *label10 notEqual *tmp16 false
    45 label *label12
-    * jump *label9 always
    46 label *label8
    47 label *label9
    48 jump *label15 equal :areUnitsAvailable:output false
 
    51 print "occupied: "
    52 print :areUnitsAvailable:occupied
    53 print "\n"
-    * jump *label16 always
    54 label *label15
    55 label *label16
    56 set *tmp3 false
 
    60 jump *label17 equal *tmp3 false
    61 set *tmp2 UNIT_TYPE
    62 jump *label3 always
-    * jump *label18 always
    63 label *label17
    64 label *label18
    65 set :chooseUnitType:type @flare
 
   105 op land *tmp35 *tmp32 *tmp34
   106 jump *label31 notEqual *tmp35 false
   107 label *label33
-    * jump *label30 always
   108 label *label29
   109 label *label30
   110 jump *label36 equal :areUnitsAvailable.1:output false
 
   113 print "occupied: "
   114 print :areUnitsAvailable.1:occupied
   115 print "\n"
-    * jump *label37 always
   116 label *label36
   117 label *label37
   118 set *tmp22 false
 
   123 printflush null
   124 set *tmp2 :chooseUnitType:type
   125 jump *label3 always
-    * jump *label39 always
   126 label *label38
   127 label *label39
-    * jump *label27 always
   128 label *label26
   129 label *label27
   130 label *label20
 
   149 op land *tmp46 *tmp43 *tmp45
   150 jump *label44 equal *tmp46 false
   151 jump *label41 always
-    * jump *label45 always
   152 label *label44
   153 label *label45
-    * jump *label43 always
   154 label *label42
   155 label *label43
   156 ubind .TYPE
 
   160 sensor *tmp51 @unit @controlled
   161 jump *label51 notEqual *tmp51 0
   162 jump *label41 always
-    * jump *label52 always
   163 label *label51
   164 label *label52
   165 ubind .TYPE
 
   170 op land *tmp57 *tmp54 *tmp56
   171 jump *label48 notEqual *tmp57 false
   172 label *label50
-    * jump *label47 always
   173 label *label46
   174 label *label47
   175 end
 
   227 jump *label65 equal *tmp84 false
   228 set *tmp77 :rebindUnit.1:currentUnit
   229 jump *label62 always
-    * jump *label66 always
   230 label *label65
   231 label *label66
-    * jump *label64 always
   232 label *label63
   233 label *label64
   234 ubind .TYPE
 
   239 jump *label72 notEqual *tmp89 0
   240 set *tmp77 @unit
   241 jump *label62 always
-    * jump *label73 always
   242 label *label72
   243 label *label73
   244 ubind .TYPE
 
   249 op land *tmp95 *tmp92 *tmp94
   250 jump *label69 notEqual *tmp95 false
   251 label *label71
-    * jump *label68 always
   252 label *label67
   253 label *label68
   254 end
 
   277 ucontrol within .CORE_X .CORE_Y 8 *tmp107
   278 jump *label80 equal *tmp107 false
   279 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label81 always
   280 label *label80
   281 label *label81
   282 label *label79
   283 label *label77
-    * jump *label75 always
   284 label *label74
   285 label *label75
   286 jump *label82 notEqual :processUnit:state 2
 
   307 op idiv *tmp121 *tmp120 .SPEED_TENTHS
   308 op div :processUnit:distance *tmp121 10
   309 label *label85
-    * jump *label83 always
   310 label *label82
   311 label *label83
   312 jump *label88 notEqual :processUnit:state 3
 
   318 jump *label92 greaterThan *tmp127 0
   319 ucontrol approach .CORE_X .CORE_Y 6
   320 set :processUnit:state 2
-    * jump *label93 always
   321 label *label92
   322 label *label93
   323 jump *label91 always
 
   332 op idiv *tmp135 *tmp134 .SPEED_TENTHS
   333 op div :processUnit:distance *tmp135 10
   334 label *label91
-    * jump *label89 always
   335 label *label88
   336 label *label89
   337 ucontrol flag :processUnit:state
 
   397 op land *tmp162 *tmp159 *tmp161
   398 jump *label103 notEqual *tmp162 false
   399 label *label105
-    * jump *label102 always
   400 label *label101
   401 label *label102
   402 jump *label108 equal :areUnitsAvailable.2:output false
 
   405 print "occupied: "
   406 print :areUnitsAvailable.2:occupied
   407 print "\n"
-    * jump *label109 always
   408 label *label108
   409 label *label109
   410 set *tmp149 false
 
   413 label *label100
   414 jump *label110 equal *tmp149 false
   415 end
-    * jump *label111 always
   416 label *label110
   417 label *label111
   418 op add :unitCheck @time 5000
-    * jump *label99 always
   419 label *label98
   420 label *label99
   421 label *label97
-    * jump *label60 always
   422 label *label59
   423 label *label60
   424 op sub *tmp166 @time :start

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-7 instructions):
 
    19 set :areUnitsAvailable:type UNIT_TYPE
    20 set :areUnitsAvailable:output true
    21 set :areUnitsAvailable:occupied 0
-    * ubind :areUnitsAvailable:type
+   22 ubind UNIT_TYPE
    23 set :areUnitsAvailable:firstUnit @unit
    24 jump *label8 equal :areUnitsAvailable:firstUnit null
    25 label *label10
 
    35 label *label13
    36 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    37 label *label14
-    * ubind :areUnitsAvailable:type
+   38 ubind UNIT_TYPE
    39 label *label11
    40 op notEqual *tmp13 @unit :areUnitsAvailable:firstUnit
    41 sensor *tmp14 :areUnitsAvailable:firstUnit @dead
 
    45 label *label12
    46 label *label8
    47 label *label9
-    * jump *label15 equal :areUnitsAvailable:output false
-    * print :areUnitsAvailable:type
+   48 jump *label15 equal true false
+   49 print UNIT_TYPE
    50 print " "
    51 print "occupied: "
    52 print :areUnitsAvailable:occupied
 
    55 label *label16
    56 set *tmp3 false
    57 jump *label7 always
-    * set *tmp3 null
    58 label *label7
    59 jump *label17 equal *tmp3 false
    60 set *tmp2 UNIT_TYPE
 
    80 set :areUnitsAvailable.1:type :chooseUnitType:type
    81 set :areUnitsAvailable.1:output true
    82 set :areUnitsAvailable.1:occupied 0
-    * ubind :areUnitsAvailable.1:type
+   83 ubind :chooseUnitType:type
    84 set :areUnitsAvailable.1:firstUnit @unit
    85 jump *label29 equal :areUnitsAvailable.1:firstUnit null
    86 label *label31
 
    96 label *label34
    97 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    98 label *label35
-    * ubind :areUnitsAvailable.1:type
+   99 ubind :chooseUnitType:type
   100 label *label32
   101 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   102 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   106 label *label33
   107 label *label29
   108 label *label30
-    * jump *label36 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  109 jump *label36 equal true false
+  110 print :chooseUnitType:type
   111 print " "
   112 print "occupied: "
   113 print :areUnitsAvailable.1:occupied
 
   116 label *label37
   117 set *tmp22 false
   118 jump *label28 always
-    * set *tmp22 null
   119 label *label28
   120 jump *label38 equal *tmp22 false
   121 printflush null
 
   136 set *tmp2 null
   137 label *label3
   138 set .TYPE *tmp2
-    * set :acquireUnit:currentUnit .UNIT
-    * set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * jump *label42 equal :rebindUnit:currentUnit null
-    * ubind :rebindUnit:currentUnit
+  139 set :acquireUnit:currentUnit null
+  140 set :rebindUnit:currentUnit .UNIT
+  141 jump *label42 equal :acquireUnit:currentUnit null
+  142 ubind :acquireUnit:currentUnit
   143 sensor *tmp42 @unit @dead
   144 op equal *tmp43 *tmp42 0
   145 sensor *tmp44 @unit @controller
 
   151 label *label45
   152 label *label42
   153 label *label43
-    * ubind .TYPE
+  154 ubind *tmp2
   155 set :rebindUnit:firstUnit @unit
   156 jump *label46 equal :rebindUnit:firstUnit null
   157 label *label48
 
   160 jump *label41 always
   161 label *label51
   162 label *label52
-    * ubind .TYPE
+  163 ubind *tmp2
   164 label *label49
   165 op notEqual *tmp54 @unit :rebindUnit:firstUnit
   166 sensor *tmp55 :rebindUnit:firstUnit @dead
 
   175 ucontrol flag 1
   176 set *tmp38 @unit
   177 jump *label40 always
-    * set *tmp38 null
   178 label *label40
   179 set .UNIT *tmp38
-    * sensor .UNIT_CAPACITY .UNIT @itemCapacity
-    * sensor .SPEED .UNIT @speed
+  180 sensor .UNIT_CAPACITY *tmp38 @itemCapacity
+  181 sensor .SPEED *tmp38 @speed
   182 op div .SPEED_TENTHS .SPEED 10
   183 print "[gold]Locating core..."
   184 printflush message1
 
   197 print " === [gold]Supplying Power Plant[] === "
   198 print "\n"
   199 print "\n"
-    * sensor *tmp72 .VAULT .ITEM
+  200 sensor *tmp72 .VAULT @thorium
   201 print "\n"
   202 print "[gold]Thorium[] status: [green]"
   203 print *tmp72
   204 print "["
   205 print "]"
   206 print "\n"
-    * sensor *tmp73 .VAULT .ITEM
+  207 sensor *tmp73 .VAULT @thorium
   208 jump *label59 greaterThanEq *tmp73 500
   209 print "\n"
   210 print "Unit type: [green]"
-    * print .TYPE
+  211 print *tmp2
   212 print "["
   213 print "]"
   214 print "\n"
   215 set :processUnit:unit .UNIT
-    * set :rebindUnit.1:currentUnit :processUnit:unit
-    * jump *label63 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  216 set :rebindUnit.1:currentUnit .UNIT
+  217 jump *label63 equal :processUnit:unit null
+  218 ubind :processUnit:unit
   219 sensor *tmp80 @unit @dead
   220 op equal *tmp81 *tmp80 0
   221 sensor *tmp82 @unit @controller
   222 op equal *tmp83 *tmp82 @this
   223 op land *tmp84 *tmp81 *tmp83
   224 jump *label65 equal *tmp84 false
-    * set *tmp77 :rebindUnit.1:currentUnit
+  225 set *tmp77 :processUnit:unit
   226 jump *label62 always
   227 label *label65
   228 label *label66
   229 label *label63
   230 label *label64
-    * ubind .TYPE
+  231 ubind *tmp2
   232 set :rebindUnit.1:firstUnit @unit
   233 jump *label67 equal :rebindUnit.1:firstUnit null
   234 label *label69
 
   238 jump *label62 always
   239 label *label72
   240 label *label73
-    * ubind .TYPE
+  241 ubind *tmp2
   242 label *label70
   243 op notEqual *tmp92 @unit :rebindUnit.1:firstUnit
   244 sensor *tmp93 :rebindUnit.1:firstUnit @dead
 
   249 label *label67
   250 label *label68
   251 end
-    * set *tmp77 null
   252 label *label62
-    * set :processUnit:unit *tmp77
   253 sensor :processUnit:state @unit @flag
   254 set :processUnit:distance -1
   255 set :processUnit:color "gold"
 
   258 op or *tmp99 *tmp97 *tmp98
   259 jump *label74 equal *tmp99 false
   260 sensor *tmp101 @unit @firstItem
-    * jump *label76 notEqual *tmp101 .ITEM
+  261 jump *label76 notEqual *tmp101 @thorium
   262 set :processUnit:state 3
   263 jump *label77 always
   264 label *label76
 
   281 jump *label82 notEqual :processUnit:state 2
   282 ucontrol within .CORE_X .CORE_Y 8 *tmp111
   283 jump *label84 equal *tmp111 false
-    * ucontrol itemTake .CORE .ITEM .UNIT_CAPACITY
+  284 ucontrol itemTake .CORE @thorium .UNIT_CAPACITY
   285 sensor *tmp113 @unit @totalItems
   286 jump *label86 lessThan *tmp113 .UNIT_CAPACITY
   287 ucontrol approach .VAULT_X .VAULT_Y 6
 
   332 ucontrol flag :processUnit:state
   333 sensor *tmp137 @unit @totalItems
   334 print "["
-    * print :processUnit:color
+  335 print "gold"
   336 print "]"
   337 print *tmp137
   338 print "["
 
   349 label *label95
   350 set *tmp76 @unit
   351 jump *label61 always
-    * set *tmp76 null
   352 label *label61
   353 set :state :processUnit:state
   354 set .UNIT *tmp76
-    * op equal *tmp140 :state 2
-    * sensor *tmp141 .VAULT .ITEM
+  355 op equal *tmp140 :processUnit:state 2
+  356 sensor *tmp141 .VAULT @thorium
   357 op greaterThanEq *tmp142 *tmp141 500
   358 op land *tmp143 *tmp140 *tmp142
   359 jump *label96 equal *tmp143 false
   360 ucontrol unbind
   361 jump *label97 always
   362 label *label96
-    * op notEqual *tmp145 .TYPE UNIT_TYPE
+  363 op notEqual *tmp145 *tmp2 UNIT_TYPE
   364 op greaterThan *tmp146 :unitCheck @time
   365 op land *tmp147 *tmp145 *tmp146
   366 jump *label98 equal *tmp147 false
   367 set :areUnitsAvailable.2:type UNIT_TYPE
   368 set :areUnitsAvailable.2:output false
   369 set :areUnitsAvailable.2:occupied 0
-    * ubind :areUnitsAvailable.2:type
+  370 ubind UNIT_TYPE
   371 set :areUnitsAvailable.2:firstUnit @unit
   372 jump *label101 equal :areUnitsAvailable.2:firstUnit null
   373 label *label103
 
   383 label *label106
   384 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
   385 label *label107
-    * ubind :areUnitsAvailable.2:type
+  386 ubind UNIT_TYPE
   387 label *label104
   388 op notEqual *tmp159 @unit :areUnitsAvailable.2:firstUnit
   389 sensor *tmp160 :areUnitsAvailable.2:firstUnit @dead
 
   393 label *label105
   394 label *label101
   395 label *label102
-    * jump *label108 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+  396 jump *label108 equal false false
+  397 print UNIT_TYPE
   398 print " "
   399 print "occupied: "
   400 print :areUnitsAvailable.2:occupied
 
   403 label *label109
   404 set *tmp149 false
   405 jump *label100 always
-    * set *tmp149 null
   406 label *label100
   407 jump *label110 equal *tmp149 false
   408 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-12 instructions):
 
     1 remark "If no units of this type exist, we'll try using other types."
     2 set UNIT_TYPE @poly
     3 remark "Do not modify anything below this line."
-    * set .ITEM @thorium
     4 set .MSG ""
     5 set .UNIT null
     6 set .VAULT vault1
 
    15 printflush null
    16 print "[gold]Looking for suitable unit type:[]"
    17 print "\n"
-    * set :areUnitsAvailable:type UNIT_TYPE
-    * set :areUnitsAvailable:output true
    18 set :areUnitsAvailable:occupied 0
    19 ubind UNIT_TYPE
    20 set :areUnitsAvailable:firstUnit @unit
 
    74 setaddr *tmp19 *label25
    75 label *label19
    76 jump *label26 equal :chooseUnitType:type UNIT_TYPE
-    * set :areUnitsAvailable.1:type :chooseUnitType:type
-    * set :areUnitsAvailable.1:output true
    77 set :areUnitsAvailable.1:occupied 0
    78 ubind :chooseUnitType:type
    79 set :areUnitsAvailable.1:firstUnit @unit
 
   130 label *label6
   131 set *tmp2 null
   132 label *label3
-    * set .TYPE *tmp2
   133 set :acquireUnit:currentUnit null
-    * set :rebindUnit:currentUnit .UNIT
-    * jump *label42 equal :acquireUnit:currentUnit null
-    * ubind :acquireUnit:currentUnit
+  134 set :rebindUnit:currentUnit null
+  135 jump *label42 equal null null
+  136 ubind null
   137 sensor *tmp42 @unit @dead
   138 op equal *tmp43 *tmp42 0
   139 sensor *tmp44 @unit @controller
 
   207 print "]"
   208 print "\n"
   209 set :processUnit:unit .UNIT
-    * set :rebindUnit.1:currentUnit .UNIT
-    * jump *label63 equal :processUnit:unit null
-    * ubind :processUnit:unit
+  210 jump *label63 equal .UNIT null
+  211 ubind .UNIT
   212 sensor *tmp80 @unit @dead
   213 op equal *tmp81 *tmp80 0
   214 sensor *tmp82 @unit @controller
   215 op equal *tmp83 *tmp82 @this
   216 op land *tmp84 *tmp81 *tmp83
   217 jump *label65 equal *tmp84 false
-    * set *tmp77 :processUnit:unit
+  218 set *tmp77 .UNIT
   219 jump *label62 always
   220 label *label65
   221 label *label66
 
   227 label *label69
   228 sensor *tmp89 @unit @controlled
   229 jump *label72 notEqual *tmp89 0
-    * set *tmp77 @unit
   230 jump *label62 always
   231 label *label72
   232 label *label73
 
   244 label *label62
   245 sensor :processUnit:state @unit @flag
   246 set :processUnit:distance -1
-    * set :processUnit:color "gold"
   247 op lessThan *tmp97 :processUnit:state 2
   248 op greaterThan *tmp98 :processUnit:state 3
   249 op or *tmp99 *tmp97 *tmp98
 
   341 set *tmp76 @unit
   342 jump *label61 always
   343 label *label61
-    * set :state :processUnit:state
   344 set .UNIT *tmp76
   345 op equal *tmp140 :processUnit:state 2
   346 sensor *tmp141 .VAULT @thorium
 
   354 op greaterThan *tmp146 :unitCheck @time
   355 op land *tmp147 *tmp145 *tmp146
   356 jump *label98 equal *tmp147 false
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
   357 set :areUnitsAvailable.2:occupied 0
   358 ubind UNIT_TYPE
   359 set :areUnitsAvailable.2:firstUnit @unit

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-5 instructions):
 
     2 set UNIT_TYPE @poly
     3 remark "Do not modify anything below this line."
     4 set .MSG ""
-    * set .UNIT null
     5 set .VAULT vault1
     6 label *label0
     7 sensor *tmp0 .VAULT @dead
 
   129 label *label6
   130 set *tmp2 null
   131 label *label3
-    * set :acquireUnit:currentUnit null
-    * set :rebindUnit:currentUnit null
   132 jump *label42 equal null null
   133 ubind null
   134 sensor *tmp42 @unit @dead
 
   203 print "["
   204 print "]"
   205 print "\n"
-    * set :processUnit:unit .UNIT
   206 jump *label63 equal .UNIT null
   207 ubind .UNIT
   208 sensor *tmp80 @unit @dead
 
   211 op equal *tmp83 *tmp82 @this
   212 op land *tmp84 *tmp81 *tmp83
   213 jump *label65 equal *tmp84 false
-    * set *tmp77 .UNIT
   214 jump *label62 always
   215 label *label65
   216 label *label66

Modifications by Replicate loop condition at line 30:1 (+1 instructions):
 
     6 label *label0
     7 sensor *tmp0 .VAULT @dead
     8 jump *label2 equal *tmp0 0
+    9 label *label112
    10 set .VAULT vault1
    11 label *label1
-    * jump *label0 always
+   12 sensor *tmp0 .VAULT @dead
+   13 jump *label112 notEqual *tmp0 0
    14 label *label2
    15 label *label4
    16 printflush null

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     4 set .MSG ""
     5 set .VAULT vault1
     6 label *label0
-    * sensor *tmp0 .VAULT @dead
+    7 sensor *tmp0 vault1 @dead
     8 jump *label2 equal *tmp0 0
     9 label *label112
    10 set .VAULT vault1
    11 label *label1
-    * sensor *tmp0 .VAULT @dead
+   12 sensor *tmp0 vault1 @dead
    13 jump *label112 notEqual *tmp0 0
    14 label *label2
    15 label *label4

Modifications by Unroll iteration loop at line 93:9 (+91 instructions):
 
    59 jump *label3 always
    60 label *label17
    61 label *label18
-    * set :chooseUnitType:type @flare
-    * setaddr *tmp19 *label22
-    * jump *label19 always
-    * multilabel *label22 (m:marker0)
-    * set :chooseUnitType:type @poly
-    * setaddr *tmp19 *label23
-    * jump *label19 always
-    * multilabel *label23 (m:marker0)
-    * set :chooseUnitType:type @mega
-    * setaddr *tmp19 *label24
-    * jump *label19 always
-    * multilabel *label24 (m:marker0)
-    * set :chooseUnitType:type @mono
-    * setaddr *tmp19 *label25
-    * label *label19
-    * jump *label26 equal :chooseUnitType:type UNIT_TYPE
-    * set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label29 equal :areUnitsAvailable.1:firstUnit null
-    * label *label31
-    * sensor *tmp26 @unit @controlled
-    * op equal *tmp27 *tmp26 0
-    * sensor *tmp28 @unit @controller
-    * op equal *tmp29 *tmp28 @this
-    * op or *tmp30 *tmp27 *tmp29
-    * jump *label34 equal *tmp30 false
-    * set *tmp22 true
-    * jump *label28 always
-    * jump *label35 always
-    * label *label34
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label35
-    * ubind :chooseUnitType:type
-    * label *label32
-    * op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp34 *tmp33 0
-    * op land *tmp35 *tmp32 *tmp34
-    * jump *label31 notEqual *tmp35 false
-    * label *label33
-    * label *label29
-    * label *label30
-    * jump *label36 equal true false
-    * print :chooseUnitType:type
-    * print " "
-    * print "occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print "\n"
-    * label *label36
-    * label *label37
-    * set *tmp22 false
-    * jump *label28 always
-    * label *label28
-    * jump *label38 equal *tmp22 false
-    * printflush null
-    * set *tmp2 :chooseUnitType:type
-    * jump *label3 always
-    * label *label38
-    * label *label39
-    * label *label26
-    * label *label27
-    * label *label20
-    * multijump *tmp19 0 0 (m:marker0)
-    * multilabel *label25 (m:marker0)
-    * label *label21
+   62 set :chooseUnitType:type @flare
+   63 label *label113
+   64 jump *label126 equal :chooseUnitType:type UNIT_TYPE
+   65 set :areUnitsAvailable.1:occupied 0
+   66 ubind :chooseUnitType:type
+   67 set :areUnitsAvailable.1:firstUnit @unit
+   68 jump *label119 equal :areUnitsAvailable.1:firstUnit null
+   69 label *label114
+   70 sensor *tmp26 @unit @controlled
+   71 op equal *tmp27 *tmp26 0
+   72 sensor *tmp28 @unit @controller
+   73 op equal *tmp29 *tmp28 @this
+   74 op or *tmp30 *tmp27 *tmp29
+   75 jump *label115 equal *tmp30 false
+   76 set *tmp22 true
+   77 jump *label123 always
+   78 jump *label116 always
+   79 label *label115
+   80 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+   81 label *label116
+   82 ubind :chooseUnitType:type
+   83 label *label117
+   84 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
+   85 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
+   86 op equal *tmp34 *tmp33 0
+   87 op land *tmp35 *tmp32 *tmp34
+   88 jump *label114 notEqual *tmp35 false
+   89 label *label118
+   90 label *label119
+   91 label *label120
+   92 jump *label121 equal true false
+   93 print :chooseUnitType:type
+   94 print " "
+   95 print "occupied: "
+   96 print :areUnitsAvailable.1:occupied
+   97 print "\n"
+   98 label *label121
+   99 label *label122
+  100 set *tmp22 false
+  101 jump *label123 always
+  102 label *label123
+  103 jump *label124 equal *tmp22 false
+  104 printflush null
+  105 set *tmp2 :chooseUnitType:type
+  106 jump *label3 always
+  107 label *label124
+  108 label *label125
+  109 label *label126
+  110 label *label127
+  111 label *label128
+  112 set :chooseUnitType:type @poly
+  113 label *label131
+  114 jump *label144 equal :chooseUnitType:type UNIT_TYPE
+  115 set :areUnitsAvailable.1:occupied 0
+  116 ubind :chooseUnitType:type
+  117 set :areUnitsAvailable.1:firstUnit @unit
+  118 jump *label137 equal :areUnitsAvailable.1:firstUnit null
+  119 label *label132
+  120 sensor *tmp26 @unit @controlled
+  121 op equal *tmp27 *tmp26 0
+  122 sensor *tmp28 @unit @controller
+  123 op equal *tmp29 *tmp28 @this
+  124 op or *tmp30 *tmp27 *tmp29
+  125 jump *label133 equal *tmp30 false
+  126 set *tmp22 true
+  127 jump *label141 always
+  128 jump *label134 always
+  129 label *label133
+  130 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  131 label *label134
+  132 ubind :chooseUnitType:type
+  133 label *label135
+  134 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
+  135 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
+  136 op equal *tmp34 *tmp33 0
+  137 op land *tmp35 *tmp32 *tmp34
+  138 jump *label132 notEqual *tmp35 false
+  139 label *label136
+  140 label *label137
+  141 label *label138
+  142 jump *label139 equal true false
+  143 print :chooseUnitType:type
+  144 print " "
+  145 print "occupied: "
+  146 print :areUnitsAvailable.1:occupied
+  147 print "\n"
+  148 label *label139
+  149 label *label140
+  150 set *tmp22 false
+  151 jump *label141 always
+  152 label *label141
+  153 jump *label142 equal *tmp22 false
+  154 printflush null
+  155 set *tmp2 :chooseUnitType:type
+  156 jump *label3 always
+  157 label *label142
+  158 label *label143
+  159 label *label144
+  160 label *label145
+  161 label *label146
+  162 set :chooseUnitType:type @mega
+  163 label *label149
+  164 jump *label162 equal :chooseUnitType:type UNIT_TYPE
+  165 set :areUnitsAvailable.1:occupied 0
+  166 ubind :chooseUnitType:type
+  167 set :areUnitsAvailable.1:firstUnit @unit
+  168 jump *label155 equal :areUnitsAvailable.1:firstUnit null
+  169 label *label150
+  170 sensor *tmp26 @unit @controlled
+  171 op equal *tmp27 *tmp26 0
+  172 sensor *tmp28 @unit @controller
+  173 op equal *tmp29 *tmp28 @this
+  174 op or *tmp30 *tmp27 *tmp29
+  175 jump *label151 equal *tmp30 false
+  176 set *tmp22 true
+  177 jump *label159 always
+  178 jump *label152 always
+  179 label *label151
+  180 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  181 label *label152
+  182 ubind :chooseUnitType:type
+  183 label *label153
+  184 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
+  185 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
+  186 op equal *tmp34 *tmp33 0
+  187 op land *tmp35 *tmp32 *tmp34
+  188 jump *label150 notEqual *tmp35 false
+  189 label *label154
+  190 label *label155
+  191 label *label156
+  192 jump *label157 equal true false
+  193 print :chooseUnitType:type
+  194 print " "
+  195 print "occupied: "
+  196 print :areUnitsAvailable.1:occupied
+  197 print "\n"
+  198 label *label157
+  199 label *label158
+  200 set *tmp22 false
+  201 jump *label159 always
+  202 label *label159
+  203 jump *label160 equal *tmp22 false
+  204 printflush null
+  205 set *tmp2 :chooseUnitType:type
+  206 jump *label3 always
+  207 label *label160
+  208 label *label161
+  209 label *label162
+  210 label *label163
+  211 label *label164
+  212 set :chooseUnitType:type @mono
+  213 label *label167
+  214 jump *label180 equal :chooseUnitType:type UNIT_TYPE
+  215 set :areUnitsAvailable.1:occupied 0
+  216 ubind :chooseUnitType:type
+  217 set :areUnitsAvailable.1:firstUnit @unit
+  218 jump *label173 equal :areUnitsAvailable.1:firstUnit null
+  219 label *label168
+  220 sensor *tmp26 @unit @controlled
+  221 op equal *tmp27 *tmp26 0
+  222 sensor *tmp28 @unit @controller
+  223 op equal *tmp29 *tmp28 @this
+  224 op or *tmp30 *tmp27 *tmp29
+  225 jump *label169 equal *tmp30 false
+  226 set *tmp22 true
+  227 jump *label177 always
+  228 jump *label170 always
+  229 label *label169
+  230 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  231 label *label170
+  232 ubind :chooseUnitType:type
+  233 label *label171
+  234 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
+  235 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
+  236 op equal *tmp34 *tmp33 0
+  237 op land *tmp35 *tmp32 *tmp34
+  238 jump *label168 notEqual *tmp35 false
+  239 label *label172
+  240 label *label173
+  241 label *label174
+  242 jump *label175 equal true false
+  243 print :chooseUnitType:type
+  244 print " "
+  245 print "occupied: "
+  246 print :areUnitsAvailable.1:occupied
+  247 print "\n"
+  248 label *label175
+  249 label *label176
+  250 set *tmp22 false
+  251 jump *label177 always
+  252 label *label177
+  253 jump *label178 equal *tmp22 false
+  254 printflush null
+  255 set *tmp2 :chooseUnitType:type
+  256 jump *label3 always
+  257 label *label178
+  258 label *label179
+  259 label *label180
+  260 label *label181
+  261 label *label182
+  262 label *label21
   263 printflush message1
   264 label *label5
   265 jump *label4 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    61 label *label18
    62 set :chooseUnitType:type @flare
    63 label *label113
-    * jump *label126 equal :chooseUnitType:type UNIT_TYPE
+   64 jump *label126 equal @flare UNIT_TYPE
    65 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
+   66 ubind @flare
    67 set :areUnitsAvailable.1:firstUnit @unit
    68 jump *label119 equal :areUnitsAvailable.1:firstUnit null
    69 label *label114
 
    79 label *label115
    80 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    81 label *label116
-    * ubind :chooseUnitType:type
+   82 ubind @flare
    83 label *label117
    84 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
    85 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
    90 label *label119
    91 label *label120
    92 jump *label121 equal true false
-    * print :chooseUnitType:type
+   93 print @flare
    94 print " "
    95 print "occupied: "
    96 print :areUnitsAvailable.1:occupied
 
   102 label *label123
   103 jump *label124 equal *tmp22 false
   104 printflush null
-    * set *tmp2 :chooseUnitType:type
+  105 set *tmp2 @flare
   106 jump *label3 always
   107 label *label124
   108 label *label125
 
   111 label *label128
   112 set :chooseUnitType:type @poly
   113 label *label131
-    * jump *label144 equal :chooseUnitType:type UNIT_TYPE
+  114 jump *label144 equal @poly UNIT_TYPE
   115 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
+  116 ubind @poly
   117 set :areUnitsAvailable.1:firstUnit @unit
   118 jump *label137 equal :areUnitsAvailable.1:firstUnit null
   119 label *label132
 
   129 label *label133
   130 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   131 label *label134
-    * ubind :chooseUnitType:type
+  132 ubind @poly
   133 label *label135
   134 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   135 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   140 label *label137
   141 label *label138
   142 jump *label139 equal true false
-    * print :chooseUnitType:type
+  143 print @poly
   144 print " "
   145 print "occupied: "
   146 print :areUnitsAvailable.1:occupied
 
   152 label *label141
   153 jump *label142 equal *tmp22 false
   154 printflush null
-    * set *tmp2 :chooseUnitType:type
+  155 set *tmp2 @poly
   156 jump *label3 always
   157 label *label142
   158 label *label143
 
   161 label *label146
   162 set :chooseUnitType:type @mega
   163 label *label149
-    * jump *label162 equal :chooseUnitType:type UNIT_TYPE
+  164 jump *label162 equal @mega UNIT_TYPE
   165 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
+  166 ubind @mega
   167 set :areUnitsAvailable.1:firstUnit @unit
   168 jump *label155 equal :areUnitsAvailable.1:firstUnit null
   169 label *label150
 
   179 label *label151
   180 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   181 label *label152
-    * ubind :chooseUnitType:type
+  182 ubind @mega
   183 label *label153
   184 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   185 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   190 label *label155
   191 label *label156
   192 jump *label157 equal true false
-    * print :chooseUnitType:type
+  193 print @mega
   194 print " "
   195 print "occupied: "
   196 print :areUnitsAvailable.1:occupied
 
   202 label *label159
   203 jump *label160 equal *tmp22 false
   204 printflush null
-    * set *tmp2 :chooseUnitType:type
+  205 set *tmp2 @mega
   206 jump *label3 always
   207 label *label160
   208 label *label161
 
   211 label *label164
   212 set :chooseUnitType:type @mono
   213 label *label167
-    * jump *label180 equal :chooseUnitType:type UNIT_TYPE
+  214 jump *label180 equal @mono UNIT_TYPE
   215 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
+  216 ubind @mono
   217 set :areUnitsAvailable.1:firstUnit @unit
   218 jump *label173 equal :areUnitsAvailable.1:firstUnit null
   219 label *label168
 
   229 label *label169
   230 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   231 label *label170
-    * ubind :chooseUnitType:type
+  232 ubind @mono
   233 label *label171
   234 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   235 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   240 label *label173
   241 label *label174
   242 jump *label175 equal true false
-    * print :chooseUnitType:type
+  243 print @mono
   244 print " "
   245 print "occupied: "
   246 print :areUnitsAvailable.1:occupied
 
   252 label *label177
   253 jump *label178 equal *tmp22 false
   254 printflush null
-    * set *tmp2 :chooseUnitType:type
+  255 set *tmp2 @mono
   256 jump *label3 always
   257 label *label178
   258 label *label179

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    59 jump *label3 always
    60 label *label17
    61 label *label18
-    * set :chooseUnitType:type @flare
    62 label *label113
    63 jump *label126 equal @flare UNIT_TYPE
    64 set :areUnitsAvailable.1:occupied 0
 
   108 label *label126
   109 label *label127
   110 label *label128
-    * set :chooseUnitType:type @poly
   111 label *label131
   112 jump *label144 equal @poly UNIT_TYPE
   113 set :areUnitsAvailable.1:occupied 0
 
   157 label *label144
   158 label *label145
   159 label *label146
-    * set :chooseUnitType:type @mega
   160 label *label149
   161 jump *label162 equal @mega UNIT_TYPE
   162 set :areUnitsAvailable.1:occupied 0
 
   206 label *label162
   207 label *label163
   208 label *label164
-    * set :chooseUnitType:type @mono
   209 label *label167
   210 jump *label180 equal @mono UNIT_TYPE
   211 set :areUnitsAvailable.1:occupied 0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-5 instructions):
 
    43 label *label12
    44 label *label8
    45 label *label9
-    * jump *label15 equal true false
    46 print UNIT_TYPE
    47 print " "
    48 print "occupied: "
 
    87 label *label118
    88 label *label119
    89 label *label120
-    * jump *label121 equal true false
    90 print @flare
    91 print " "
    92 print "occupied: "
 
   135 label *label136
   136 label *label137
   137 label *label138
-    * jump *label139 equal true false
   138 print @poly
   139 print " "
   140 print "occupied: "
 
   183 label *label154
   184 label *label155
   185 label *label156
-    * jump *label157 equal true false
   186 print @mega
   187 print " "
   188 print "occupied: "
 
   231 label *label172
   232 label *label173
   233 label *label174
-    * jump *label175 equal true false
   234 print @mono
   235 print " "
   236 print "occupied: "
 
   257 label *label6
   258 set *tmp2 null
   259 label *label3
-    * jump *label42 equal null null
+  260 jump *label42 always
   261 ubind null
   262 sensor *tmp42 @unit @dead
   263 op equal *tmp43 *tmp42 0
 
   504 label *label105
   505 label *label101
   506 label *label102
-    * jump *label108 equal false false
+  507 jump *label108 always
   508 print UNIT_TYPE
   509 print " "
   510 print "occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-8 instructions):
 
    51 label *label15
    52 label *label16
    53 set *tmp3 false
-    * jump *label7 always
    54 label *label7
    55 jump *label17 equal *tmp3 false
    56 set *tmp2 UNIT_TYPE
 
    94 label *label121
    95 label *label122
    96 set *tmp22 false
-    * jump *label123 always
    97 label *label123
    98 jump *label124 equal *tmp22 false
    99 printflush null
 
   141 label *label139
   142 label *label140
   143 set *tmp22 false
-    * jump *label141 always
   144 label *label141
   145 jump *label142 equal *tmp22 false
   146 printflush null
 
   188 label *label157
   189 label *label158
   190 set *tmp22 false
-    * jump *label159 always
   191 label *label159
   192 jump *label160 equal *tmp22 false
   193 printflush null
 
   235 label *label175
   236 label *label176
   237 set *tmp22 false
-    * jump *label177 always
   238 label *label177
   239 jump *label178 equal *tmp22 false
   240 printflush null
 
   288 label *label41
   289 ucontrol flag 1
   290 set *tmp38 @unit
-    * jump *label40 always
   291 label *label40
   292 set .UNIT *tmp38
   293 sensor .UNIT_CAPACITY *tmp38 @itemCapacity
 
   456 print .MSG
   457 label *label95
   458 set *tmp76 @unit
-    * jump *label61 always
   459 label *label61
   460 set .UNIT *tmp76
   461 op equal *tmp140 :processUnit:state 2
 
   506 label *label108
   507 label *label109
   508 set *tmp149 false
-    * jump *label100 always
   509 label *label100
   510 jump *label110 equal *tmp149 false
   511 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   455 label *label94
   456 print .MSG
   457 label *label95
-    * set *tmp76 @unit
+  458 set .UNIT @unit
   459 label *label61
-    * set .UNIT *tmp76
   460 op equal *tmp140 :processUnit:state 2
   461 sensor *tmp141 .VAULT @thorium
   462 op greaterThanEq *tmp142 *tmp141 500

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-3 instructions):
 
   255 jump *label42 always
   256 ubind null
   257 sensor *tmp42 @unit @dead
-    * op equal *tmp43 *tmp42 0
   258 sensor *tmp44 @unit @controller
-    * op equal *tmp45 *tmp44 @this
-    * op land *tmp46 *tmp43 *tmp45
   259 jump *label44 equal *tmp46 false
   260 jump *label41 always
   261 label *label44

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     3 remark "Do not modify anything below this line."
     4 set .MSG ""
     5 set .VAULT vault1
-    * label *label0
     6 sensor *tmp0 vault1 @dead
     7 jump *label2 equal *tmp0 0
     8 label *label112
     9 set .VAULT vault1
-    * label *label1
    10 sensor *tmp0 vault1 @dead
    11 jump *label112 notEqual *tmp0 0
    12 label *label2
 
    32 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    33 label *label14
    34 ubind UNIT_TYPE
-    * label *label11
    35 op notEqual *tmp13 @unit :areUnitsAvailable:firstUnit
    36 sensor *tmp14 :areUnitsAvailable:firstUnit @dead
    37 op equal *tmp15 *tmp14 0
    38 op land *tmp16 *tmp13 *tmp15
    39 jump *label10 notEqual *tmp16 false
-    * label *label12
    40 label *label8
-    * label *label9
    41 print UNIT_TYPE
    42 print " "
    43 print "occupied: "
    44 print :areUnitsAvailable:occupied
    45 print "\n"
-    * label *label15
-    * label *label16
    46 set *tmp3 false
    47 label *label7
    48 jump *label17 equal *tmp3 false
    49 set *tmp2 UNIT_TYPE
    50 jump *label3 always
    51 label *label17
-    * label *label18
-    * label *label113
    52 jump *label126 equal @flare UNIT_TYPE
    53 set :areUnitsAvailable.1:occupied 0
    54 ubind @flare
 
    68 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    69 label *label116
    70 ubind @flare
-    * label *label117
    71 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
    72 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
    73 op equal *tmp34 *tmp33 0
    74 op land *tmp35 *tmp32 *tmp34
    75 jump *label114 notEqual *tmp35 false
-    * label *label118
    76 label *label119
-    * label *label120
    77 print @flare
    78 print " "
    79 print "occupied: "
    80 print :areUnitsAvailable.1:occupied
    81 print "\n"
-    * label *label121
-    * label *label122
    82 set *tmp22 false
    83 label *label123
    84 jump *label124 equal *tmp22 false
 
    86 set *tmp2 @flare
    87 jump *label3 always
    88 label *label124
-    * label *label125
    89 label *label126
-    * label *label127
-    * label *label128
-    * label *label131
    90 jump *label144 equal @poly UNIT_TYPE
    91 set :areUnitsAvailable.1:occupied 0
    92 ubind @poly
 
   106 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   107 label *label134
   108 ubind @poly
-    * label *label135
   109 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   110 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
   111 op equal *tmp34 *tmp33 0
   112 op land *tmp35 *tmp32 *tmp34
   113 jump *label132 notEqual *tmp35 false
-    * label *label136
   114 label *label137
-    * label *label138
   115 print @poly
   116 print " "
   117 print "occupied: "
   118 print :areUnitsAvailable.1:occupied
   119 print "\n"
-    * label *label139
-    * label *label140
   120 set *tmp22 false
   121 label *label141
   122 jump *label142 equal *tmp22 false
 
   124 set *tmp2 @poly
   125 jump *label3 always
   126 label *label142
-    * label *label143
   127 label *label144
-    * label *label145
-    * label *label146
-    * label *label149
   128 jump *label162 equal @mega UNIT_TYPE
   129 set :areUnitsAvailable.1:occupied 0
   130 ubind @mega
 
   144 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   145 label *label152
   146 ubind @mega
-    * label *label153
   147 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   148 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
   149 op equal *tmp34 *tmp33 0
   150 op land *tmp35 *tmp32 *tmp34
   151 jump *label150 notEqual *tmp35 false
-    * label *label154
   152 label *label155
-    * label *label156
   153 print @mega
   154 print " "
   155 print "occupied: "
   156 print :areUnitsAvailable.1:occupied
   157 print "\n"
-    * label *label157
-    * label *label158
   158 set *tmp22 false
   159 label *label159
   160 jump *label160 equal *tmp22 false
 
   162 set *tmp2 @mega
   163 jump *label3 always
   164 label *label160
-    * label *label161
   165 label *label162
-    * label *label163
-    * label *label164
-    * label *label167
   166 jump *label180 equal @mono UNIT_TYPE
   167 set :areUnitsAvailable.1:occupied 0
   168 ubind @mono
 
   182 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   183 label *label170
   184 ubind @mono
-    * label *label171
   185 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   186 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
   187 op equal *tmp34 *tmp33 0
   188 op land *tmp35 *tmp32 *tmp34
   189 jump *label168 notEqual *tmp35 false
-    * label *label172
   190 label *label173
-    * label *label174
   191 print @mono
   192 print " "
   193 print "occupied: "
   194 print :areUnitsAvailable.1:occupied
   195 print "\n"
-    * label *label175
-    * label *label176
   196 set *tmp22 false
   197 label *label177
   198 jump *label178 equal *tmp22 false
 
   200 set *tmp2 @mono
   201 jump *label3 always
   202 label *label178
-    * label *label179
   203 label *label180
-    * label *label181
-    * label *label182
-    * label *label21
   204 printflush message1
-    * label *label5
   205 jump *label4 always
-    * label *label6
   206 set *tmp2 null
   207 label *label3
   208 jump *label42 always
 
   212 jump *label44 equal *tmp46 false
   213 jump *label41 always
   214 label *label44
-    * label *label45
   215 label *label42
-    * label *label43
   216 ubind *tmp2
   217 set :rebindUnit:firstUnit @unit
   218 jump *label46 equal :rebindUnit:firstUnit null
 
   221 jump *label51 notEqual *tmp51 0
   222 jump *label41 always
   223 label *label51
-    * label *label52
   224 ubind *tmp2
-    * label *label49
   225 op notEqual *tmp54 @unit :rebindUnit:firstUnit
   226 sensor *tmp55 :rebindUnit:firstUnit @dead
   227 op equal *tmp56 *tmp55 0
   228 op land *tmp57 *tmp54 *tmp56
   229 jump *label48 notEqual *tmp57 false
-    * label *label50
   230 label *label46
-    * label *label47
   231 end
   232 label *label41
   233 ucontrol flag 1
   234 set *tmp38 @unit
-    * label *label40
   235 set .UNIT *tmp38
   236 sensor .UNIT_CAPACITY *tmp38 @itemCapacity
   237 sensor .SPEED *tmp38 @speed
 
   240 printflush message1
   241 label *label53
   242 ulocate building core false @copper 0 0 0 .CORE
-    * label *label54
   243 jump *label53 equal .CORE null
-    * label *label55
   244 sensor .CORE_X .CORE @x
   245 sensor .CORE_Y .CORE @y
   246 sensor .VAULT_X .VAULT @x
 
   276 jump *label65 equal *tmp84 false
   277 jump *label62 always
   278 label *label65
-    * label *label66
   279 label *label63
-    * label *label64
   280 ubind *tmp2
   281 set :rebindUnit.1:firstUnit @unit
   282 jump *label67 equal :rebindUnit.1:firstUnit null
 
   285 jump *label72 notEqual *tmp89 0
   286 jump *label62 always
   287 label *label72
-    * label *label73
   288 ubind *tmp2
-    * label *label70
   289 op notEqual *tmp92 @unit :rebindUnit.1:firstUnit
   290 sensor *tmp93 :rebindUnit.1:firstUnit @dead
   291 op equal *tmp94 *tmp93 0
   292 op land *tmp95 *tmp92 *tmp94
   293 jump *label69 notEqual *tmp95 false
-    * label *label71
   294 label *label67
-    * label *label68
   295 end
   296 label *label62
   297 sensor :processUnit:state @unit @flag
 
   316 jump *label80 equal *tmp107 false
   317 ucontrol itemDrop .CORE .UNIT_CAPACITY
   318 label *label80
-    * label *label81
   319 label *label79
   320 label *label77
   321 label *label74
-    * label *label75
   322 jump *label82 notEqual :processUnit:state 2
   323 ucontrol within .CORE_X .CORE_Y 8 *tmp111
   324 jump *label84 equal *tmp111 false
 
   344 op div :processUnit:distance *tmp121 10
   345 label *label85
   346 label *label82
-    * label *label83
   347 jump *label88 notEqual :processUnit:state 3
   348 ucontrol within .VAULT_X .VAULT_Y 8 *tmp125
   349 jump *label90 equal *tmp125 false
 
   354 ucontrol approach .CORE_X .CORE_Y 6
   355 set :processUnit:state 2
   356 label *label92
-    * label *label93
   357 jump *label91 always
   358 label *label90
   359 ucontrol approach .VAULT_X .VAULT_Y 6
 
   367 op div :processUnit:distance *tmp135 10
   368 label *label91
   369 label *label88
-    * label *label89
   370 ucontrol flag :processUnit:state
   371 sensor *tmp137 @unit @totalItems
   372 print "["
 
   386 print .MSG
   387 label *label95
   388 set .UNIT @unit
-    * label *label61
   389 op equal *tmp140 :processUnit:state 2
   390 sensor *tmp141 .VAULT @thorium
   391 op greaterThanEq *tmp142 *tmp141 500
 
   416 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
   417 label *label107
   418 ubind UNIT_TYPE
-    * label *label104
   419 op notEqual *tmp159 @unit :areUnitsAvailable.2:firstUnit
   420 sensor *tmp160 :areUnitsAvailable.2:firstUnit @dead
   421 op equal *tmp161 *tmp160 0
   422 op land *tmp162 *tmp159 *tmp161
   423 jump *label103 notEqual *tmp162 false
-    * label *label105
   424 label *label101
-    * label *label102
   425 jump *label108 always
   426 print UNIT_TYPE
   427 print " "
 
   429 print :areUnitsAvailable.2:occupied
   430 print "\n"
   431 label *label108
-    * label *label109
   432 set *tmp149 false
   433 label *label100
   434 jump *label110 equal *tmp149 false
   435 end
   436 label *label110
-    * label *label111
   437 op add :unitCheck @time 5000
   438 label *label98
-    * label *label99
   439 label *label97
   440 label *label59
-    * label *label60
   441 op sub *tmp166 @time :start
   442 op floor *tmp167 *tmp166
   443 print "\n"
 
   446 print " "
   447 print "ms"
   448 printflush message1
-    * label *label57
   449 jump *label56 always
-    * label *label58
   450 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-4 instructions):
 
   209 ubind null
   210 sensor *tmp42 @unit @dead
   211 sensor *tmp44 @unit @controller
-    * jump *label44 equal *tmp46 false
-    * jump *label41 always
+  212 jump *label41 notEqual *tmp46 false
   213 label *label44
   214 label *label42
   215 ubind *tmp2
 
   217 jump *label46 equal :rebindUnit:firstUnit null
   218 label *label48
   219 sensor *tmp51 @unit @controlled
-    * jump *label51 notEqual *tmp51 0
-    * jump *label41 always
+  220 jump *label41 equal *tmp51 0
   221 label *label51
   222 ubind *tmp2
   223 op notEqual *tmp54 @unit :rebindUnit:firstUnit
 
   271 sensor *tmp82 @unit @controller
   272 op equal *tmp83 *tmp82 @this
   273 op land *tmp84 *tmp81 *tmp83
-    * jump *label65 equal *tmp84 false
-    * jump *label62 always
+  274 jump *label62 notEqual *tmp84 false
   275 label *label65
   276 label *label63
   277 ubind *tmp2
 
   279 jump *label67 equal :rebindUnit.1:firstUnit null
   280 label *label69
   281 sensor *tmp89 @unit @controlled
-    * jump *label72 notEqual *tmp89 0
-    * jump *label62 always
+  282 jump *label62 equal *tmp89 0
   283 label *label72
   284 ubind *tmp2
   285 op notEqual *tmp92 @unit :rebindUnit.1:firstUnit

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
   210 sensor *tmp42 @unit @dead
   211 sensor *tmp44 @unit @controller
   212 jump *label41 notEqual *tmp46 false
-    * label *label44
   213 label *label42
   214 ubind *tmp2
   215 set :rebindUnit:firstUnit @unit
 
   217 label *label48
   218 sensor *tmp51 @unit @controlled
   219 jump *label41 equal *tmp51 0
-    * label *label51
   220 ubind *tmp2
   221 op notEqual *tmp54 @unit :rebindUnit:firstUnit
   222 sensor *tmp55 :rebindUnit:firstUnit @dead
 
   270 op equal *tmp83 *tmp82 @this
   271 op land *tmp84 *tmp81 *tmp83
   272 jump *label62 notEqual *tmp84 false
-    * label *label65
   273 label *label63
   274 ubind *tmp2
   275 set :rebindUnit.1:firstUnit @unit
 
   277 label *label69
   278 sensor *tmp89 @unit @controlled
   279 jump *label62 equal *tmp89 0
-    * label *label72
   280 ubind *tmp2
   281 op notEqual *tmp92 @unit :rebindUnit.1:firstUnit
   282 sensor *tmp93 :rebindUnit.1:firstUnit @dead

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @poly
 
    48 label *label7
    49 jump *label17 equal *tmp3 false
    50 set *tmp2 UNIT_TYPE
-    * jump *label3 always
+   51 jump *label42 always
    52 label *label17
    53 jump *label126 equal @flare UNIT_TYPE
    54 set :areUnitsAvailable.1:occupied 0
 
    85 jump *label124 equal *tmp22 false
    86 printflush null
    87 set *tmp2 @flare
-    * jump *label3 always
+   88 jump *label42 always
    89 label *label124
    90 label *label126
    91 jump *label144 equal @poly UNIT_TYPE
 
   123 jump *label142 equal *tmp22 false
   124 printflush null
   125 set *tmp2 @poly
-    * jump *label3 always
+  126 jump *label42 always
   127 label *label142
   128 label *label144
   129 jump *label162 equal @mega UNIT_TYPE
 
   161 jump *label160 equal *tmp22 false
   162 printflush null
   163 set *tmp2 @mega
-    * jump *label3 always
+  164 jump *label42 always
   165 label *label160
   166 label *label162
   167 jump *label180 equal @mono UNIT_TYPE
 
   199 jump *label178 equal *tmp22 false
   200 printflush null
   201 set *tmp2 @mono
-    * jump *label3 always
+  202 jump *label42 always
   203 label *label178
   204 label *label180
   205 printflush message1
 
   214 label *label42
   215 ubind *tmp2
   216 set :rebindUnit:firstUnit @unit
-    * jump *label46 equal :rebindUnit:firstUnit null
+  217 jump __start__ equal :rebindUnit:firstUnit null
   218 label *label48
   219 sensor *tmp51 @unit @controlled
   220 jump *label41 equal *tmp51 0
 
   274 label *label63
   275 ubind *tmp2
   276 set :rebindUnit.1:firstUnit @unit
-    * jump *label67 equal :rebindUnit.1:firstUnit null
+  277 jump __start__ equal :rebindUnit.1:firstUnit null
   278 label *label69
   279 sensor *tmp89 @unit @controlled
   280 jump *label62 equal *tmp89 0
 
   320 jump *label86 lessThan *tmp113 .UNIT_CAPACITY
   321 ucontrol approach .VAULT_X .VAULT_Y 6
   322 set :processUnit:state 3
-    * jump *label87 always
+  323 jump *label85 always
   324 label *label86
   325 set .MSG ", loading\n"
   326 label *label87
 
   343 ucontrol itemDrop .VAULT .UNIT_CAPACITY
   344 set .MSG ", supplying\n"
   345 sensor *tmp127 @unit @totalItems
-    * jump *label92 greaterThan *tmp127 0
+  346 jump *label91 greaterThan *tmp127 0
   347 ucontrol approach .CORE_X .CORE_Y 6
   348 set :processUnit:state 2
   349 label *label92
 
   394 set :areUnitsAvailable.2:occupied 0
   395 ubind UNIT_TYPE
   396 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label101 equal :areUnitsAvailable.2:firstUnit null
+  397 jump *label108 equal :areUnitsAvailable.2:firstUnit null
   398 label *label103
   399 sensor *tmp153 @unit @controlled
   400 op equal *tmp154 *tmp153 0

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-18 instructions):
 
    28 jump *label13 equal *tmp11 false
    29 set *tmp3 true
    30 jump *label7 always
-    * jump *label14 always
    31 label *label13
    32 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    33 label *label14
 
    63 jump *label115 equal *tmp30 false
    64 set *tmp22 true
    65 jump *label123 always
-    * jump *label116 always
    66 label *label115
    67 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    68 label *label116
 
   100 jump *label133 equal *tmp30 false
   101 set *tmp22 true
   102 jump *label141 always
-    * jump *label134 always
   103 label *label133
   104 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   105 label *label134
 
   137 jump *label151 equal *tmp30 false
   138 set *tmp22 true
   139 jump *label159 always
-    * jump *label152 always
   140 label *label151
   141 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   142 label *label152
 
   174 jump *label169 equal *tmp30 false
   175 set *tmp22 true
   176 jump *label177 always
-    * jump *label170 always
   177 label *label169
   178 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   179 label *label170
 
   199 label *label180
   200 printflush message1
   201 jump *label4 always
-    * set *tmp2 null
-    * label *label3
-    * jump *label42 always
-    * ubind null
-    * sensor *tmp42 @unit @dead
-    * sensor *tmp44 @unit @controller
-    * jump *label41 notEqual *tmp46 false
   202 label *label42
   203 ubind *tmp2
   204 set :rebindUnit:firstUnit @unit
 
   212 op equal *tmp56 *tmp55 0
   213 op land *tmp57 *tmp54 *tmp56
   214 jump *label48 notEqual *tmp57 false
-    * label *label46
   215 end
   216 label *label41
   217 ucontrol flag 1
 
   271 op equal *tmp94 *tmp93 0
   272 op land *tmp95 *tmp92 *tmp94
   273 jump *label69 notEqual *tmp95 false
-    * label *label67
   274 end
   275 label *label62
   276 sensor :processUnit:state @unit @flag
 
   309 jump *label85 always
   310 label *label86
   311 set .MSG ", loading\n"
-    * label *label87
   312 jump *label85 always
   313 label *label84
   314 ucontrol approach .CORE_X .CORE_Y 6
 
   331 jump *label91 greaterThan *tmp127 0
   332 ucontrol approach .CORE_X .CORE_Y 6
   333 set :processUnit:state 2
-    * label *label92
   334 jump *label91 always
   335 label *label90
   336 ucontrol approach .VAULT_X .VAULT_Y 6
 
   388 jump *label106 equal *tmp157 false
   389 set *tmp149 true
   390 jump *label100 always
-    * jump *label107 always
   391 label *label106
   392 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
   393 label *label107
 
   397 op equal *tmp161 *tmp160 0
   398 op land *tmp162 *tmp159 *tmp161
   399 jump *label103 notEqual *tmp162 false
-    * label *label101
   400 jump *label108 always
-    * print UNIT_TYPE
-    * print " "
-    * print "occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print "\n"
   401 label *label108
   402 set *tmp149 false
   403 label *label100
 
   417 print "ms"
   418 printflush message1
   419 jump *label56 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
 
    30 jump *label7 always
    31 label *label13
    32 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
-    * label *label14
    33 ubind UNIT_TYPE
    34 op notEqual *tmp13 @unit :areUnitsAvailable:firstUnit
    35 sensor *tmp14 :areUnitsAvailable:firstUnit @dead
 
    64 jump *label123 always
    65 label *label115
    66 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label116
    67 ubind @flare
    68 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
    69 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   100 jump *label141 always
   101 label *label133
   102 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label134
   103 ubind @poly
   104 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   105 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   136 jump *label159 always
   137 label *label151
   138 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label152
   139 ubind @mega
   140 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   141 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   172 jump *label177 always
   173 label *label169
   174 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label170
   175 ubind @mono
   176 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   177 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   385 jump *label100 always
   386 label *label106
   387 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * label *label107
   388 ubind UNIT_TYPE
   389 op notEqual *tmp159 @unit :areUnitsAvailable.2:firstUnit
   390 sensor *tmp160 :areUnitsAvailable.2:firstUnit @dead

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   391 op equal *tmp161 *tmp160 0
   392 op land *tmp162 *tmp159 *tmp161
   393 jump *label103 notEqual *tmp162 false
-    * jump *label108 always
   394 label *label108
   395 set *tmp149 false
   396 label *label100

Modifications by Final phase, Print Merging, iteration 1 (-26 instructions):
 
    13 label *label2
    14 label *label4
    15 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   16 print "[gold]Looking for suitable unit type:[]\n"
    17 set :areUnitsAvailable:occupied 0
    18 ubind UNIT_TYPE
    19 set :areUnitsAvailable:firstUnit @unit
 
    37 jump *label10 notEqual *tmp16 false
    38 label *label8
    39 print UNIT_TYPE
-    * print " "
-    * print "occupied: "
+   40 print " occupied: "
    41 print :areUnitsAvailable:occupied
    42 print "\n"
    43 set *tmp3 false
 
    69 op land *tmp35 *tmp32 *tmp34
    70 jump *label114 notEqual *tmp35 false
    71 label *label119
-    * print @flare
-    * print " "
-    * print "occupied: "
+   72 print "flare occupied: "
    73 print :areUnitsAvailable.1:occupied
    74 print "\n"
    75 set *tmp22 false
 
   103 op land *tmp35 *tmp32 *tmp34
   104 jump *label132 notEqual *tmp35 false
   105 label *label137
-    * print @poly
-    * print " "
-    * print "occupied: "
+  106 print "poly occupied: "
   107 print :areUnitsAvailable.1:occupied
   108 print "\n"
   109 set *tmp22 false
 
   137 op land *tmp35 *tmp32 *tmp34
   138 jump *label150 notEqual *tmp35 false
   139 label *label155
-    * print @mega
-    * print " "
-    * print "occupied: "
+  140 print "mega occupied: "
   141 print :areUnitsAvailable.1:occupied
   142 print "\n"
   143 set *tmp22 false
 
   171 op land *tmp35 *tmp32 *tmp34
   172 jump *label168 notEqual *tmp35 false
   173 label *label173
-    * print @mono
-    * print " "
-    * print "occupied: "
+  174 print "mono occupied: "
   175 print :areUnitsAvailable.1:occupied
   176 print "\n"
   177 set *tmp22 false
 
   217 op add :unitCheck @time 5000
   218 label *label56
   219 set :start @time
-    * print " === [gold]Supplying Power Plant[] === "
-    * print "\n"
-    * print "\n"
   220 sensor *tmp72 .VAULT @thorium
-    * print "\n"
-    * print "[gold]Thorium[] status: [green]"
+  221 print " === [gold]Supplying Power Plant[] === \n\n\n[gold]Thorium[] status: [green]"
   222 print *tmp72
-    * print "["
-    * print "]"
-    * print "\n"
+  223 print "[]\n"
   224 sensor *tmp73 .VAULT @thorium
   225 jump *label59 greaterThanEq *tmp73 500
-    * print "\n"
-    * print "Unit type: [green]"
+  226 print "\nUnit type: [green]"
   227 print *tmp2
-    * print "["
-    * print "]"
-    * print "\n"
+  228 print "[]\n"
   229 jump *label63 equal .UNIT null
   230 ubind .UNIT
   231 sensor *tmp80 @unit @dead
 
   322 label *label88
   323 ucontrol flag :processUnit:state
   324 sensor *tmp137 @unit @totalItems
-    * print "["
-    * print "gold"
-    * print "]"
+  325 print "[gold]"
   326 print *tmp137
-    * print "["
-    * print "]"
+  327 print "[]"
   328 jump *label94 lessThan :processUnit:distance 0
   329 print .MSG
   330 print :processUnit:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  331 print "[] sec\n"
   332 jump *label95 always
   333 label *label94
   334 print .MSG
 
   379 label *label59
   380 op sub *tmp166 @time :start
   381 op floor *tmp167 *tmp166
-    * print "\n"
-    * print "[lightgray]Loop time: "
+  382 print "\n[lightgray]Loop time: "
   383 print *tmp167
-    * print " "
-    * print "ms"
+  384 print " ms"
   385 printflush message1
   386 jump *label56 always

Final code before resolving virtual instructions:

        label __start__                                              /// This is the preferred unit type to use for bringing in supplies.
    0:  remark "This is the preferred unit type to use for bringing  ...
    2:  remark "If no units of this type exist, we'll try using othe /// If no units of this type exist, we'll try using other types.
    3:  set UNIT_TYPE @poly                                          param UNIT_TYPE         = @poly;  // Which unit to use
    4:  remark "Do not modify anything below this line."             /// Do not modify anything below this line.
    6:  set .MSG ""                                                  MSG = "";
    7:  set .VAULT vault1                                            VAULT = vault1;
    8:  sensor *tmp0 vault1 @dead                                    while VAULT.@dead != 0 do
    9:  jump *label2 equal *tmp0 0                                   ...
        label *label112                                              ...
   10:  set .VAULT vault1                                            VAULT = vault1;
   11:  sensor *tmp0 vault1 @dead                                    while VAULT.@dead != 0 do
   12:  jump *label112 notEqual *tmp0 0                              ...
        label *label2                                                ...
        label *label4                                                while true do
   13:  printflush null                                              printflush(null);       // empty text buffer
   14:  print "[gold]Looking for suitable unit type:[]\n"            println("[gold]Looking for suitable unit type:[]");
   15:  set :areUnitsAvailable:occupied 0                            occupied = 0;
   16:  ubind UNIT_TYPE                                              firstUnit = ubind(type);
   17:  set :areUnitsAvailable:firstUnit @unit                       ...
   18:  jump *label8 equal :areUnitsAvailable:firstUnit null         if firstUnit != null then
        label *label10                                               do
   19:  sensor *tmp7 @unit @controlled                               if @unit.@controlled == 0 or @unit.@controller == @this then
   20:  op equal *tmp8 *tmp7 0                                       ...
   21:  sensor *tmp9 @unit @controller                               ...
   22:  op equal *tmp10 *tmp9 @this                                  ...
   23:  op or *tmp11 *tmp8 *tmp10                                    ...
   24:  jump *label13 equal *tmp11 false                             ...
   25:  set *tmp3 true                                               return true;
   26:  jump *label7 always 0 0                                      ...
        label *label13                                               if @unit.@controlled == 0 or @unit.@controller == @this then
   27:  op add :areUnitsAvailable:occupied :areUnitsAvailable:occupi occupied += 1;
   28:  ubind UNIT_TYPE                                              ubind(type);
   29:  op notEqual *tmp13 @unit :areUnitsAvailable:firstUnit        while @unit != firstUnit and firstUnit.@dead == 0;
   30:  sensor *tmp14 :areUnitsAvailable:firstUnit @dead             ...
   31:  op equal *tmp15 *tmp14 0                                     ...
   32:  op land *tmp16 *tmp13 *tmp15                                 ...
   33:  jump *label10 notEqual *tmp16 false                          do
        label *label8                                                if firstUnit != null then
   34:  print UNIT_TYPE                                              print($"$type occupied: $occupied");
   35:  print " occupied: "                                          ...
   36:  print :areUnitsAvailable:occupied                            ...
   37:  print "\n"                                                   println();
   38:  set *tmp3 false                                              return false;
        label *label7                                                if areUnitsAvailable(UNIT_TYPE, true) then
   39:  jump *label17 equal *tmp3 false                              ...
   40:  set *tmp2 UNIT_TYPE                                          return UNIT_TYPE;
   41:  jump *label42 always 0 0                                     ...
        label *label17                                               if areUnitsAvailable(UNIT_TYPE, true) then
   42:  jump *label126 equal @flare UNIT_TYPE                        if type != UNIT_TYPE then
   43:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
   44:  ubind @flare                                                 firstUnit = ubind(type);
   45:  set :areUnitsAvailable.1:firstUnit @unit                     ...
   46:  jump *label119 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label114                                              do
   47:  sensor *tmp26 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
   48:  op equal *tmp27 *tmp26 0                                     ...
   49:  sensor *tmp28 @unit @controller                              ...
   50:  op equal *tmp29 *tmp28 @this                                 ...
   51:  op or *tmp30 *tmp27 *tmp29                                   ...
   52:  jump *label115 equal *tmp30 false                            ...
   53:  set *tmp22 true                                              return true;
   54:  jump *label123 always 0 0                                    ...
        label *label115                                              if @unit.@controlled == 0 or @unit.@controller == @this then
   55:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
   56:  ubind @flare                                                 ubind(type);
   57:  op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
   58:  sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead           ...
   59:  op equal *tmp34 *tmp33 0                                     ...
   60:  op land *tmp35 *tmp32 *tmp34                                 ...
   61:  jump *label114 notEqual *tmp35 false                         do
        label *label119                                              if firstUnit != null then
   62:  print "flare occupied: "                                     print($"$type occupied: $occupied");
   63:  print :areUnitsAvailable.1:occupied                          ...
   64:  print "\n"                                                   println();
   65:  set *tmp22 false                                             return false;
        label *label123                                              if areUnitsAvailable(type, true) then
   66:  jump *label124 equal *tmp22 false                            ...
   67:  printflush null                                              printflush(null);
   68:  set *tmp2 @flare                                             return type;
   69:  jump *label42 always 0 0                                     ...
        label *label124                                              if areUnitsAvailable(type, true) then
        label *label126                                              if type != UNIT_TYPE then
   70:  jump *label144 equal @poly UNIT_TYPE                         ...
   71:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
   72:  ubind @poly                                                  firstUnit = ubind(type);
   73:  set :areUnitsAvailable.1:firstUnit @unit                     ...
   74:  jump *label137 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label132                                              do
   75:  sensor *tmp26 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
   76:  op equal *tmp27 *tmp26 0                                     ...
   77:  sensor *tmp28 @unit @controller                              ...
   78:  op equal *tmp29 *tmp28 @this                                 ...
   79:  op or *tmp30 *tmp27 *tmp29                                   ...
   80:  jump *label133 equal *tmp30 false                            ...
   81:  set *tmp22 true                                              return true;
   82:  jump *label141 always 0 0                                    ...
        label *label133                                              if @unit.@controlled == 0 or @unit.@controller == @this then
   83:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
   84:  ubind @poly                                                  ubind(type);
   85:  op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
   86:  sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead           ...
   87:  op equal *tmp34 *tmp33 0                                     ...
   88:  op land *tmp35 *tmp32 *tmp34                                 ...
   89:  jump *label132 notEqual *tmp35 false                         do
        label *label137                                              if firstUnit != null then
   90:  print "poly occupied: "                                      print($"$type occupied: $occupied");
   91:  print :areUnitsAvailable.1:occupied                          ...
   92:  print "\n"                                                   println();
   93:  set *tmp22 false                                             return false;
        label *label141                                              if areUnitsAvailable(type, true) then
   94:  jump *label142 equal *tmp22 false                            ...
   95:  printflush null                                              printflush(null);
   96:  set *tmp2 @poly                                              return type;
   97:  jump *label42 always 0 0                                     ...
        label *label142                                              if areUnitsAvailable(type, true) then
        label *label144                                              if type != UNIT_TYPE then
   98:  jump *label162 equal @mega UNIT_TYPE                         ...
   99:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
  100:  ubind @mega                                                  firstUnit = ubind(type);
  101:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  102:  jump *label155 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label150                                              do
  103:  sensor *tmp26 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  104:  op equal *tmp27 *tmp26 0                                     ...
  105:  sensor *tmp28 @unit @controller                              ...
  106:  op equal *tmp29 *tmp28 @this                                 ...
  107:  op or *tmp30 *tmp27 *tmp29                                   ...
  108:  jump *label151 equal *tmp30 false                            ...
  109:  set *tmp22 true                                              return true;
  110:  jump *label159 always 0 0                                    ...
        label *label151                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  111:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
  112:  ubind @mega                                                  ubind(type);
  113:  op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
  114:  sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead           ...
  115:  op equal *tmp34 *tmp33 0                                     ...
  116:  op land *tmp35 *tmp32 *tmp34                                 ...
  117:  jump *label150 notEqual *tmp35 false                         do
        label *label155                                              if firstUnit != null then
  118:  print "mega occupied: "                                      print($"$type occupied: $occupied");
  119:  print :areUnitsAvailable.1:occupied                          ...
  120:  print "\n"                                                   println();
  121:  set *tmp22 false                                             return false;
        label *label159                                              if areUnitsAvailable(type, true) then
  122:  jump *label160 equal *tmp22 false                            ...
  123:  printflush null                                              printflush(null);
  124:  set *tmp2 @mega                                              return type;
  125:  jump *label42 always 0 0                                     ...
        label *label160                                              if areUnitsAvailable(type, true) then
        label *label162                                              if type != UNIT_TYPE then
  126:  jump *label180 equal @mono UNIT_TYPE                         ...
  127:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
  128:  ubind @mono                                                  firstUnit = ubind(type);
  129:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  130:  jump *label173 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label168                                              do
  131:  sensor *tmp26 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  132:  op equal *tmp27 *tmp26 0                                     ...
  133:  sensor *tmp28 @unit @controller                              ...
  134:  op equal *tmp29 *tmp28 @this                                 ...
  135:  op or *tmp30 *tmp27 *tmp29                                   ...
  136:  jump *label169 equal *tmp30 false                            ...
  137:  set *tmp22 true                                              return true;
  138:  jump *label177 always 0 0                                    ...
        label *label169                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  139:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
  140:  ubind @mono                                                  ubind(type);
  141:  op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
  142:  sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead           ...
  143:  op equal *tmp34 *tmp33 0                                     ...
  144:  op land *tmp35 *tmp32 *tmp34                                 ...
  145:  jump *label168 notEqual *tmp35 false                         do
        label *label173                                              if firstUnit != null then
  146:  print "mono occupied: "                                      print($"$type occupied: $occupied");
  147:  print :areUnitsAvailable.1:occupied                          ...
  148:  print "\n"                                                   println();
  149:  set *tmp22 false                                             return false;
        label *label177                                              if areUnitsAvailable(type, true) then
  150:  jump *label178 equal *tmp22 false                            ...
  151:  printflush null                                              printflush(null);
  152:  set *tmp2 @mono                                              return type;
  153:  jump *label42 always 0 0                                     ...
        label *label178                                              if areUnitsAvailable(type, true) then
        label *label180                                              if type != UNIT_TYPE then
  154:  printflush message1                                          printflush(message1);
  155:  jump *label4 always 0 0                                      while true do
        label *label42                                               if currentUnit != null then
  156:  ubind *tmp2                                                  firstUnit = ubind(TYPE);
  157:  set :rebindUnit:firstUnit @unit                              ...
  158:  jump __start__ equal :rebindUnit:firstUnit null              if firstUnit != null then
        label *label48                                               do
  159:  sensor *tmp51 @unit @controlled                              if @unit.@controlled == 0 then
  160:  jump *label41 equal *tmp51 0                                 ...
  161:  ubind *tmp2                                                  ubind(TYPE);
  162:  op notEqual *tmp54 @unit :rebindUnit:firstUnit               while @unit != firstUnit and firstUnit.@dead == 0;
  163:  sensor *tmp55 :rebindUnit:firstUnit @dead                    ...
  164:  op equal *tmp56 *tmp55 0                                     ...
  165:  op land *tmp57 *tmp54 *tmp56                                 ...
  166:  jump *label48 notEqual *tmp57 false                          do
  167:  end                                                          end();
        label *label41                                               rebindUnit(currentUnit);
  168:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  169:  set *tmp38 @unit                                             return @unit;
  170:  set .UNIT *tmp38                                             UNIT = acquireUnit(UNIT);
  171:  sensor .UNIT_CAPACITY *tmp38 @itemCapacity                   UNIT_CAPACITY = UNIT.@itemCapacity;
  172:  sensor .SPEED *tmp38 @speed                                  SPEED = UNIT.@speed;
  173:  op div .SPEED_TENTHS .SPEED 10                               SPEED_TENTHS = SPEED / 10;
  174:  print "[gold]Locating core..."                               print("[gold]Locating core...");
  175:  printflush message1                                          printflush(message1);
        label *label53                                               do
  176:  ulocate building core false @copper 0 0 0 .CORE              CORE = ulocate(:building, :core, false);
  177:  jump *label53 equal .CORE null                               do
  178:  sensor .CORE_X .CORE @x                                      CORE_X = CORE.@x;
  179:  sensor .CORE_Y .CORE @y                                      CORE_Y = CORE.@y;
  180:  sensor .VAULT_X .VAULT @x                                    VAULT_X = VAULT.@x;
  181:  sensor .VAULT_Y .VAULT @y                                    VAULT_Y = VAULT.@y;
  182:  op add :unitCheck @time 5000                                 unitCheck = @time + UNIT_CHECK_TIME;
        label *label56                                               while true do
  183:  set :start @time                                             start = @time;
  184:  sensor *tmp72 .VAULT @thorium                                println($"\n[gold]Thorium[] status: [green]$[]", VAULT.sensor(ITEM));
  185:  print " === [gold]Supplying Power Plant[] === \n\n\n[gold]Th ...
  186:  print *tmp72                                                 ...
  187:  print "[]\n"                                                 ...
  188:  sensor *tmp73 .VAULT @thorium                                if VAULT.sensor(ITEM) < 500 then
  189:  jump *label59 greaterThanEq *tmp73 500                       ...
  190:  print "\nUnit type: [green]"                                 println($"\nUnit type: [green]$TYPE[]");
  191:  print *tmp2                                                  ...
  192:  print "[]\n"                                                 ...
  193:  jump *label63 equal .UNIT null                               if currentUnit != null then
  194:  ubind .UNIT                                                  ubind(currentUnit);
  195:  sensor *tmp80 @unit @dead                                    if @unit.@dead == 0 && @unit.@controller == @this then
  196:  op equal *tmp81 *tmp80 0                                     ...
  197:  sensor *tmp82 @unit @controller                              ...
  198:  op equal *tmp83 *tmp82 @this                                 ...
  199:  op land *tmp84 *tmp81 *tmp83                                 ...
  200:  jump *label62 notEqual *tmp84 false                          ...
        label *label63                                               if currentUnit != null then
  201:  ubind *tmp2                                                  firstUnit = ubind(TYPE);
  202:  set :rebindUnit.1:firstUnit @unit                            ...
  203:  jump __start__ equal :rebindUnit.1:firstUnit null            if firstUnit != null then
        label *label69                                               do
  204:  sensor *tmp89 @unit @controlled                              if @unit.@controlled == 0 then
  205:  jump *label62 equal *tmp89 0                                 ...
  206:  ubind *tmp2                                                  ubind(TYPE);
  207:  op notEqual *tmp92 @unit :rebindUnit.1:firstUnit             while @unit != firstUnit and firstUnit.@dead == 0;
  208:  sensor *tmp93 :rebindUnit.1:firstUnit @dead                  ...
  209:  op equal *tmp94 *tmp93 0                                     ...
  210:  op land *tmp95 *tmp92 *tmp94                                 ...
  211:  jump *label69 notEqual *tmp95 false                          do
  212:  end                                                          end();
        label *label62                                               unit = rebindUnit(unit);
  213:  sensor :processUnit:state @unit @flag                        state = @unit.@flag;
  214:  set :processUnit:distance -1                                 distance = -1;
  215:  op lessThan *tmp97 :processUnit:state 2                      if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  216:  op greaterThan *tmp98 :processUnit:state 3                   ...
  217:  op or *tmp99 *tmp97 *tmp98                                   ...
  218:  jump *label74 equal *tmp99 false                             ...
  219:  sensor *tmp101 @unit @firstItem                              if @unit.@firstItem == ITEM then
  220:  jump *label76 notEqual *tmp101 @thorium                      ...
  221:  set :processUnit:state 3                                     state = S_APPROACH_DST;
  222:  jump *label77 always 0 0                                     if @unit.@firstItem == ITEM then
        label *label76                                               ...
  223:  sensor *tmp104 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  224:  jump *label78 notEqual *tmp104 0                             ...
  225:  set :processUnit:state 2                                     state = S_APPROACH_SRC;
  226:  jump *label79 always 0 0                                     elsif @unit.@totalItems == 0 then
        label *label78                                               ...
  227:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  228:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  229:  ucontrol within .CORE_X .CORE_Y 8 *tmp107 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  230:  jump *label80 equal *tmp107 false                            ...
  231:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label80                                               if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label79                                               elsif @unit.@totalItems == 0 then
        label *label77                                               if @unit.@firstItem == ITEM then
        label *label74                                               if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  232:  jump *label82 notEqual :processUnit:state 2                  if state == S_APPROACH_SRC then
  233:  ucontrol within .CORE_X .CORE_Y 8 *tmp111 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  234:  jump *label84 equal *tmp111 false                            ...
  235:  ucontrol itemTake .CORE @thorium .UNIT_CAPACITY 0 0          itemTake(CORE, ITEM, UNIT_CAPACITY);
  236:  sensor *tmp113 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  237:  jump *label86 lessThan *tmp113 .UNIT_CAPACITY                ...
  238:  ucontrol approach .VAULT_X .VAULT_Y 6 0 0                    approach(VAULT_X, VAULT_Y, RADIUS_APPROACH);
  239:  set :processUnit:state 3                                     state = S_APPROACH_DST;
  240:  jump *label85 always 0 0                                     if @unit.@totalItems >= UNIT_CAPACITY then
        label *label86                                               ...
  241:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  242:  jump *label85 always 0 0                                     if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label84                                               ...
  243:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  244:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  245:  sensor *tmp116 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  246:  op sub *tmp117 .CORE_X *tmp116                               ...
  247:  sensor *tmp118 @unit @y                                      ...
  248:  op sub *tmp119 .CORE_Y *tmp118                               ...
  249:  op len *tmp120 *tmp117 *tmp119                               ...
  250:  op idiv *tmp121 *tmp120 .SPEED_TENTHS                        ...
  251:  op div :processUnit:distance *tmp121 10                      ...
        label *label85                                               if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label82                                               if state == S_APPROACH_SRC then
  252:  jump *label88 notEqual :processUnit:state 3                  if state == S_APPROACH_DST then
  253:  ucontrol within .VAULT_X .VAULT_Y 8 *tmp125 0                if within(VAULT_X, VAULT_Y, RADIUS_WITHIN) then
  254:  jump *label90 equal *tmp125 false                            ...
  255:  ucontrol itemDrop .VAULT .UNIT_CAPACITY 0 0 0                itemDrop(VAULT, UNIT_CAPACITY);
  256:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  257:  sensor *tmp127 @unit @totalItems                             if @unit.@totalItems <= 0 then
  258:  jump *label91 greaterThan *tmp127 0                          ...
  259:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  260:  set :processUnit:state 2                                     state = S_APPROACH_SRC;
  261:  jump *label91 always 0 0                                     if within(VAULT_X, VAULT_Y, RADIUS_WITHIN) then
        label *label90                                               ...
  262:  ucontrol approach .VAULT_X .VAULT_Y 6 0 0                    approach(VAULT_X, VAULT_Y, RADIUS_APPROACH);
  263:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  264:  sensor *tmp130 @unit @x                                      distance = len(VAULT_X - @unit.@x, VAULT_Y - @unit.@y) \ SPEED_TENTHS / 10;
  265:  op sub *tmp131 .VAULT_X *tmp130                              ...
  266:  sensor *tmp132 @unit @y                                      ...
  267:  op sub *tmp133 .VAULT_Y *tmp132                              ...
  268:  op len *tmp134 *tmp131 *tmp133                               ...
  269:  op idiv *tmp135 *tmp134 .SPEED_TENTHS                        ...
  270:  op div :processUnit:distance *tmp135 10                      ...
        label *label91                                               if within(VAULT_X, VAULT_Y, RADIUS_WITHIN) then
        label *label88                                               if state == S_APPROACH_DST then
  271:  ucontrol flag :processUnit:state 0 0 0 0                     flag(state);
  272:  sensor *tmp137 @unit @totalItems                             print($"[$color]$[]", @unit.@totalItems);
  273:  print "[gold]"                                               ...
  274:  print *tmp137                                                ...
  275:  print "[]"                                                   ...
  276:  jump *label94 lessThan :processUnit:distance 0               if distance >= 0 then
  277:  print .MSG                                                   println($"$MSG$distance[] sec");
  278:  print :processUnit:distance                                  ...
  279:  print "[] sec\n"                                             ...
  280:  jump *label95 always 0 0                                     if distance >= 0 then
        label *label94                                               ...
  281:  print .MSG                                                   print(MSG);
        label *label95                                               if distance >= 0 then
  282:  set .UNIT @unit                                              return @unit;
  283:  op equal *tmp140 :processUnit:state 2                        if state == S_APPROACH_SRC and VAULT.sensor(ITEM) >= 500 then
  284:  sensor *tmp141 .VAULT @thorium                               ...
  285:  op greaterThanEq *tmp142 *tmp141 500                         ...
  286:  op land *tmp143 *tmp140 *tmp142                              ...
  287:  jump *label96 equal *tmp143 false                            ...
  288:  ucontrol unbind 0 0 0 0 0                                    unbind();
  289:  jump *label97 always 0 0                                     if state == S_APPROACH_SRC and VAULT.sensor(ITEM) >= 500 then
        label *label96                                               ...
  290:  op notEqual *tmp145 *tmp2 UNIT_TYPE                          elsif TYPE != UNIT_TYPE and unitCheck > @time then
  291:  op greaterThan *tmp146 :unitCheck @time                      ...
  292:  op land *tmp147 *tmp145 *tmp146                              ...
  293:  jump *label98 equal *tmp147 false                            ...
  294:  set :areUnitsAvailable.2:occupied 0                          occupied = 0;
  295:  ubind UNIT_TYPE                                              firstUnit = ubind(type);
  296:  set :areUnitsAvailable.2:firstUnit @unit                     ...
  297:  jump *label108 equal :areUnitsAvailable.2:firstUnit null     if firstUnit != null then
        label *label103                                              do
  298:  sensor *tmp153 @unit @controlled                             if @unit.@controlled == 0 or @unit.@controller == @this then
  299:  op equal *tmp154 *tmp153 0                                   ...
  300:  sensor *tmp155 @unit @controller                             ...
  301:  op equal *tmp156 *tmp155 @this                               ...
  302:  op or *tmp157 *tmp154 *tmp156                                ...
  303:  jump *label106 equal *tmp157 false                           ...
  304:  set *tmp149 true                                             return true;
  305:  jump *label100 always 0 0                                    ...
        label *label106                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  306:  op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:oc occupied += 1;
  307:  ubind UNIT_TYPE                                              ubind(type);
  308:  op notEqual *tmp159 @unit :areUnitsAvailable.2:firstUnit     while @unit != firstUnit and firstUnit.@dead == 0;
  309:  sensor *tmp160 :areUnitsAvailable.2:firstUnit @dead          ...
  310:  op equal *tmp161 *tmp160 0                                   ...
  311:  op land *tmp162 *tmp159 *tmp161                              ...
  312:  jump *label103 notEqual *tmp162 false                        do
        label *label108                                              if output then
  313:  set *tmp149 false                                            return false;
        label *label100                                              if areUnitsAvailable(UNIT_TYPE, false) then
  314:  jump *label110 equal *tmp149 false                           ...
  315:  end                                                          end();
        label *label110                                              if areUnitsAvailable(UNIT_TYPE, false) then
  316:  op add :unitCheck @time 5000                                 unitCheck = @time + UNIT_CHECK_TIME;
        label *label98                                               elsif TYPE != UNIT_TYPE and unitCheck > @time then
        label *label97                                               if state == S_APPROACH_SRC and VAULT.sensor(ITEM) >= 500 then
        label *label59                                               if VAULT.sensor(ITEM) < 500 then
  317:  op sub *tmp166 @time :start                                  print($"\n[lightgray]Loop time: $ ms", floor(@time - start));
  318:  op floor *tmp167 *tmp166 0                                   ...
  319:  print "\n[lightgray]Loop time: "                             ...
  320:  print *tmp167                                                ...
  321:  print " ms"                                                  ...
  322:  printflush message1                                          printflush(message1);
  323:  jump *label56 always 0 0                                     while true do


Performance: parsed in 198 ms, compiled in 219 ms, optimized in 596 ms, run in 9 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: success.

Program output (6 steps):
The program didn't generate any output.
Execution exception at instruction 8: sensor *tmp0 vault1 @dead:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
