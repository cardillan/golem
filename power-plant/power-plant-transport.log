   464 instructions before optimizations.
    19 instructions eliminated by Temp Variables Elimination.
    78 instructions eliminated by Dead Code Elimination (6 iterations).
     7 instructions eliminated by Jump Normalization (2 passes, 4 iterations).
    20 instructions eliminated by Jump Optimization (4 iterations).
    34 instructions eliminated by Single Step Elimination (3 passes, 7 iterations).
    27 instructions eliminated by Data Flow Optimization (4 passes, 12 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     1 loops improved by Loop Optimization.
    91 instructions added by Loop Unrolling (5 iterations).
     1 loops unrolled by Loop Unrolling.
     4 instructions eliminated by Jump Straightening (4 iterations).
    10 instructions updated by JumpThreading.
    18 instructions eliminated by Unreachable Code Elimination.
    26 instructions eliminated by Print Merging.
   323 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 701):
  * Replicate loop condition at line 30:1                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
    Unroll iteration loop at line 93:9                           cost   117, benefit      375.0, efficiency        3.2

Pass 1: speed optimization selection (cost limit 700):
  * Unroll iteration loop at line 93:9                           cost   117, benefit      375.0, efficiency        3.2 (+87 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-54 instructions):
 
    35 jump *label13 equal *tmp11 false
    36 set *tmp3 true
    37 jump *label7 always
-    * set *tmp12 null
    38 jump *label14 always
    39 label *label13
    40 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
-    * set *tmp12 :areUnitsAvailable.0:occupied
    41 label *label14
    42 ubind :areUnitsAvailable.0:type
    43 label *label11
 
    47 op land *tmp16 *tmp13 *tmp15
    48 jump *label10 notEqual *tmp16 false
    49 label *label12
-    * set *tmp6 null
    50 jump *label9 always
    51 label *label8
-    * set *tmp6 null
    52 label *label9
    53 jump *label15 equal :areUnitsAvailable.0:output false
    54 print :areUnitsAvailable.0:type
 
    56 print "occupied: "
    57 print :areUnitsAvailable.0:occupied
    58 print "\n"
-    * set *tmp17 null
    59 jump *label16 always
    60 label *label15
-    * set *tmp17 null
    61 label *label16
    62 set *tmp3 false
    63 jump *label7 always
 
    66 jump *label17 equal *tmp3 false
    67 set *tmp2 UNIT_TYPE
    68 jump *label3 always
-    * set *tmp18 null
    69 jump *label18 always
    70 label *label17
-    * set *tmp18 null
    71 label *label18
    72 setaddr *tmp19 *label22
    73 set :chooseUnitType.0:type @flare
 
   103 jump *label34 equal *tmp30 false
   104 set *tmp22 true
   105 jump *label28 always
-    * set *tmp31 null
   106 jump *label35 always
   107 label *label34
   108 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp31 :areUnitsAvailable.1:occupied
   109 label *label35
   110 ubind :areUnitsAvailable.1:type
   111 label *label32
 
   115 op land *tmp35 *tmp32 *tmp34
   116 jump *label31 notEqual *tmp35 false
   117 label *label33
-    * set *tmp25 null
   118 jump *label30 always
   119 label *label29
-    * set *tmp25 null
   120 label *label30
   121 jump *label36 equal :areUnitsAvailable.1:output false
   122 print :areUnitsAvailable.1:type
 
   124 print "occupied: "
   125 print :areUnitsAvailable.1:occupied
   126 print "\n"
-    * set *tmp36 null
   127 jump *label37 always
   128 label *label36
-    * set *tmp36 null
   129 label *label37
   130 set *tmp22 false
   131 jump *label28 always
 
   140 label *label38
   141 set *tmp37 null
   142 label *label39
-    * set *tmp21 *tmp37
   143 jump *label27 always
   144 label *label26
-    * set *tmp21 null
   145 label *label27
   146 label *label20
   147 multijump *tmp19 0 0 marker0
 
   165 op equal *tmp45 *tmp44 @this
   166 op land *tmp46 *tmp43 *tmp45
   167 jump *label44 equal *tmp46 false
-    * set *tmp39 :rebindUnit.0:currentUnit
   168 jump *label41 always
   169 set *tmp47 null
   170 jump *label45 always
   171 label *label44
   172 set *tmp47 null
   173 label *label45
-    * set *tmp41 *tmp47
   174 jump *label43 always
   175 label *label42
-    * set *tmp41 null
   176 label *label43
   177 ubind .TYPE
   178 set *tmp48 @unit
 
   183 sensor *tmp51 @unit @controlled
   184 op equal *tmp52 *tmp51 0
   185 jump *label51 equal *tmp52 false
-    * set *tmp39 @unit
   186 jump *label41 always
-    * set *tmp53 null
   187 jump *label52 always
   188 label *label51
-    * set *tmp53 null
   189 label *label52
   190 ubind .TYPE
   191 label *label49
 
   195 op land *tmp57 *tmp54 *tmp56
   196 jump *label48 notEqual *tmp57 false
   197 label *label50
-    * set *tmp50 null
   198 jump *label47 always
   199 label *label46
-    * set *tmp50 null
   200 label *label47
   201 end
-    * set *tmp39 null
   202 label *label41
   203 ucontrol flag 1
   204 set *tmp38 @unit
 
   265 op equal *tmp83 *tmp82 @this
   266 op land *tmp84 *tmp81 *tmp83
   267 jump *label65 equal *tmp84 false
-    * set *tmp77 :rebindUnit.1:currentUnit
   268 jump *label62 always
   269 set *tmp85 null
   270 jump *label66 always
   271 label *label65
   272 set *tmp85 null
   273 label *label66
-    * set *tmp79 *tmp85
   274 jump *label64 always
   275 label *label63
-    * set *tmp79 null
   276 label *label64
   277 ubind .TYPE
   278 set *tmp86 @unit
 
   283 sensor *tmp89 @unit @controlled
   284 op equal *tmp90 *tmp89 0
   285 jump *label72 equal *tmp90 false
-    * set *tmp77 @unit
   286 jump *label62 always
-    * set *tmp91 null
   287 jump *label73 always
   288 label *label72
-    * set *tmp91 null
   289 label *label73
   290 ubind .TYPE
   291 label *label70
 
   295 op land *tmp95 *tmp92 *tmp94
   296 jump *label69 notEqual *tmp95 false
   297 label *label71
-    * set *tmp88 null
   298 jump *label68 always
   299 label *label67
-    * set *tmp88 null
   300 label *label68
   301 end
-    * set *tmp77 null
   302 label *label62
   303 sensor *tmp96 @unit @flag
   304 set :processUnit.0:state *tmp96
 
   336 label *label79
   337 set *tmp103 *tmp106
   338 label *label77
-    * set *tmp100 *tmp103
   339 jump *label75 always
   340 label *label74
-    * set *tmp100 null
   341 label *label75
   342 op equal *tmp109 :processUnit.0:state 2
   343 jump *label82 equal *tmp109 false
 
   370 set :processUnit.0:distance *tmp122
   371 set *tmp112 :processUnit.0:distance
   372 label *label85
-    * set *tmp110 *tmp112
   373 jump *label83 always
   374 label *label82
-    * set *tmp110 null
   375 label *label83
   376 op equal *tmp123 :processUnit.0:state 3
   377 jump *label88 equal *tmp123 false
 
   404 set :processUnit.0:distance *tmp136
   405 set *tmp126 :processUnit.0:distance
   406 label *label91
-    * set *tmp124 *tmp126
   407 jump *label89 always
   408 label *label88
-    * set *tmp124 null
   409 label *label89
   410 ucontrol flag :processUnit.0:state
   411 sensor *tmp137 @unit @totalItems
 
   422 print "["
   423 print "] sec"
   424 print "\n"
-    * set *tmp139 null
   425 jump *label95 always
   426 label *label94
   427 print .MSG
-    * set *tmp139 .MSG
   428 label *label95
-    * set *tmp76 @unit
   429 jump *label61 always
-    * set *tmp76 null
   430 label *label61
   431 set :state :processUnit.0:state
   432 op equal *tmp140 :state 2
 
   459 jump *label106 equal *tmp157 false
   460 set *tmp149 true
   461 jump *label100 always
-    * set *tmp158 null
   462 jump *label107 always
   463 label *label106
   464 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp158 :areUnitsAvailable.2:occupied
   465 label *label107
   466 ubind :areUnitsAvailable.2:type
   467 label *label104
 
   471 op land *tmp162 *tmp159 *tmp161
   472 jump *label103 notEqual *tmp162 false
   473 label *label105
-    * set *tmp152 null
   474 jump *label102 always
   475 label *label101
-    * set *tmp152 null
   476 label *label102
   477 jump *label108 equal :areUnitsAvailable.2:output false
   478 print :areUnitsAvailable.2:type
 
   480 print "occupied: "
   481 print :areUnitsAvailable.2:occupied
   482 print "\n"
-    * set *tmp163 null
   483 jump *label109 always
   484 label *label108
-    * set *tmp163 null
   485 label *label109
   486 set *tmp149 false
   487 jump *label100 always
 
   489 label *label100
   490 jump *label110 equal *tmp149 false
   491 end
-    * set *tmp164 null
   492 jump *label111 always
   493 label *label110
-    * set *tmp164 null
   494 label *label111
   495 op add *tmp165 @time 5000
   496 set :unitCheck *tmp165
 
   501 label *label99
   502 set *tmp144 *tmp148
   503 label *label97
-    * set *tmp75 *tmp144
   504 jump *label60 always
   505 label *label59
-    * set *tmp75 null
   506 label *label60
   507 op sub *tmp166 @time :start
   508 op floor *tmp167 *tmp166

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-14 instructions):
 
   135 printflush null
   136 set *tmp2 :chooseUnitType.0:type
   137 jump *label3 always
-    * set *tmp37 null
   138 jump *label39 always
   139 label *label38
-    * set *tmp37 null
   140 label *label39
   141 jump *label27 always
   142 label *label26
 
   164 op land *tmp46 *tmp43 *tmp45
   165 jump *label44 equal *tmp46 false
   166 jump *label41 always
-    * set *tmp47 null
   167 jump *label45 always
   168 label *label44
-    * set *tmp47 null
   169 label *label45
   170 jump *label43 always
   171 label *label42
 
   262 op land *tmp84 *tmp81 *tmp83
   263 jump *label65 equal *tmp84 false
   264 jump *label62 always
-    * set *tmp85 null
   265 jump *label66 always
   266 label *label65
-    * set *tmp85 null
   267 label *label66
   268 jump *label64 always
   269 label *label63
 
   306 op equal *tmp102 *tmp101 .ITEM
   307 jump *label76 equal *tmp102 false
   308 set :processUnit.0:state 3
-    * set *tmp103 :processUnit.0:state
   309 jump *label77 always
   310 label *label76
   311 sensor *tmp104 @unit @totalItems
 
   327 label *label81
   328 set *tmp106 *tmp108
   329 label *label79
-    * set *tmp103 *tmp106
   330 label *label77
   331 jump *label75 always
   332 label *label74
 
   347 set .MSG ", loading\n"
   348 set *tmp115 .MSG
   349 label *label87
-    * set *tmp112 *tmp115
   350 jump *label85 always
   351 label *label84
   352 ucontrol approach .CORE_X .CORE_Y 6
 
   359 op idiv *tmp121 *tmp120 .SPEED_TENTHS
   360 op div *tmp122 *tmp121 10
   361 set :processUnit.0:distance *tmp122
-    * set *tmp112 :processUnit.0:distance
   362 label *label85
   363 jump *label83 always
   364 label *label82
 
   379 label *label92
   380 set *tmp129 null
   381 label *label93
-    * set *tmp126 *tmp129
   382 jump *label91 always
   383 label *label90
   384 ucontrol approach .VAULT_X .VAULT_Y 6
 
   391 op idiv *tmp135 *tmp134 .SPEED_TENTHS
   392 op div *tmp136 *tmp135 10
   393 set :processUnit.0:distance *tmp136
-    * set *tmp126 :processUnit.0:distance
   394 label *label91
   395 jump *label89 always
   396 label *label88
 
   423 op land *tmp143 *tmp140 *tmp142
   424 jump *label96 equal *tmp143 false
   425 ucontrol unbind
-    * set *tmp144 null
   426 jump *label97 always
   427 label *label96
   428 op notEqual *tmp145 .TYPE UNIT_TYPE
 
   486 label *label98
   487 set *tmp148 null
   488 label *label99
-    * set *tmp144 *tmp148
   489 label *label97
   490 jump *label60 always
   491 label *label59

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-8 instructions):
 
   312 op equal *tmp105 *tmp104 0
   313 jump *label78 equal *tmp105 false
   314 set :processUnit.0:state 2
-    * set *tmp106 :processUnit.0:state
   315 jump *label79 always
   316 label *label78
   317 set .MSG ", initializing\n"
 
   324 label *label80
   325 set *tmp108 null
   326 label *label81
-    * set *tmp106 *tmp108
   327 label *label79
   328 label *label77
   329 jump *label75 always
 
   339 jump *label86 equal *tmp114 false
   340 ucontrol approach .VAULT_X .VAULT_Y 6
   341 set :processUnit.0:state 3
-    * set *tmp115 :processUnit.0:state
   342 jump *label87 always
   343 label *label86
   344 set .MSG ", loading\n"
-    * set *tmp115 .MSG
   345 label *label87
   346 jump *label85 always
   347 label *label84
 
   370 jump *label92 equal *tmp128 false
   371 ucontrol approach .CORE_X .CORE_Y 6
   372 set :processUnit.0:state 2
-    * set *tmp129 :processUnit.0:state
   373 jump *label93 always
   374 label *label92
-    * set *tmp129 null
   375 label *label93
   376 jump *label91 always
   377 label *label90
 
   475 label *label111
   476 op add *tmp165 @time 5000
   477 set :unitCheck *tmp165
-    * set *tmp148 :unitCheck
   478 jump *label99 always
   479 label *label98
-    * set *tmp148 null
   480 label *label99
   481 label *label97
   482 jump *label60 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   319 ucontrol within .CORE_X .CORE_Y 8 *tmp107
   320 jump *label80 equal *tmp107 false
   321 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp108 null
   322 jump *label81 always
   323 label *label80
-    * set *tmp108 null
   324 label *label81
   325 label *label79
   326 label *label77

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-19 instructions):
 
    22 set :areUnitsAvailable.0:output true
    23 set :areUnitsAvailable.0:occupied 0
    24 ubind :areUnitsAvailable.0:type
-    * set *tmp4 @unit
-    * set :areUnitsAvailable.0:firstUnit *tmp4
+   25 set :areUnitsAvailable.0:firstUnit @unit
    26 op notEqual *tmp5 :areUnitsAvailable.0:firstUnit null
    27 jump *label8 equal *tmp5 false
    28 label *label10
 
    89 set :areUnitsAvailable.1:output true
    90 set :areUnitsAvailable.1:occupied 0
    91 ubind :areUnitsAvailable.1:type
-    * set *tmp23 @unit
-    * set :areUnitsAvailable.1:firstUnit *tmp23
+   92 set :areUnitsAvailable.1:firstUnit @unit
    93 op notEqual *tmp24 :areUnitsAvailable.1:firstUnit null
    94 jump *label29 equal *tmp24 false
    95 label *label31
 
   169 label *label42
   170 label *label43
   171 ubind .TYPE
-    * set *tmp48 @unit
-    * set :rebindUnit.0:firstUnit *tmp48
+  172 set :rebindUnit.0:firstUnit @unit
   173 op notEqual *tmp49 :rebindUnit.0:firstUnit null
   174 jump *label46 equal *tmp49 false
   175 label *label48
 
   199 set *tmp38 null
   200 label *label40
   201 set .UNIT *tmp38
-    * sensor *tmp58 .UNIT @itemCapacity
-    * set .UNIT_CAPACITY *tmp58
-    * sensor *tmp59 .UNIT @speed
-    * set .SPEED *tmp59
-    * op div *tmp60 .SPEED 10
-    * set .SPEED_TENTHS *tmp60
+  202 sensor .UNIT_CAPACITY .UNIT @itemCapacity
+  203 sensor .SPEED .UNIT @speed
+  204 op div .SPEED_TENTHS .SPEED 10
   205 print "[gold]Locating core..."
   206 printflush message1
   207 label *label53
-    * ulocate building core false @copper *tmp62 *tmp63 *tmp64 *tmp61
-    * set .CORE *tmp61
+  208 ulocate building core false @copper 0 0 0 .CORE
   209 label *label54
   210 op equal *tmp65 .CORE null
   211 jump *label53 notEqual *tmp65 false
   212 label *label55
-    * sensor *tmp66 .CORE @x
-    * set .CORE_X *tmp66
-    * sensor *tmp67 .CORE @y
-    * set .CORE_Y *tmp67
-    * sensor *tmp68 .VAULT @x
-    * set .VAULT_X *tmp68
-    * sensor *tmp69 .VAULT @y
-    * set .VAULT_Y *tmp69
-    * op add *tmp70 @time 5000
-    * set :unitCheck *tmp70
+  213 sensor .CORE_X .CORE @x
+  214 sensor .CORE_Y .CORE @y
+  215 sensor .VAULT_X .VAULT @x
+  216 sensor .VAULT_Y .VAULT @y
+  217 op add :unitCheck @time 5000
   218 label *label56
   219 jump *label58 equal true false
-    * set *tmp71 @time
-    * set :start *tmp71
+  220 set :start @time
   221 print " === [gold]Supplying Power Plant[] === "
   222 print "\n"
   223 print "\n"
 
   256 label *label63
   257 label *label64
   258 ubind .TYPE
-    * set *tmp86 @unit
-    * set :rebindUnit.1:firstUnit *tmp86
+  259 set :rebindUnit.1:firstUnit @unit
   260 op notEqual *tmp87 :rebindUnit.1:firstUnit null
   261 jump *label67 equal *tmp87 false
   262 label *label69
 
   280 label *label68
   281 end
   282 label *label62
-    * sensor *tmp96 @unit @flag
-    * set :processUnit.0:state *tmp96
+  283 sensor :processUnit.0:state @unit @flag
   284 set :processUnit.0:distance -1
   285 set :processUnit.0:color "gold"
   286 op lessThan *tmp97 :processUnit.0:state 2
 
   336 op sub *tmp119 .CORE_Y *tmp118
   337 op len *tmp120 *tmp117 *tmp119
   338 op idiv *tmp121 *tmp120 .SPEED_TENTHS
-    * op div *tmp122 *tmp121 10
-    * set :processUnit.0:distance *tmp122
+  339 op div :processUnit.0:distance *tmp121 10
   340 label *label85
   341 jump *label83 always
   342 label *label82
 
   365 op sub *tmp133 .VAULT_Y *tmp132
   366 op len *tmp134 *tmp131 *tmp133
   367 op idiv *tmp135 *tmp134 .SPEED_TENTHS
-    * op div *tmp136 *tmp135 10
-    * set :processUnit.0:distance *tmp136
+  368 op div :processUnit.0:distance *tmp135 10
   369 label *label91
   370 jump *label89 always
   371 label *label88
 
   408 set :areUnitsAvailable.2:output false
   409 set :areUnitsAvailable.2:occupied 0
   410 ubind :areUnitsAvailable.2:type
-    * set *tmp150 @unit
-    * set :areUnitsAvailable.2:firstUnit *tmp150
+  411 set :areUnitsAvailable.2:firstUnit @unit
   412 op notEqual *tmp151 :areUnitsAvailable.2:firstUnit null
   413 jump *label101 equal *tmp151 false
   414 label *label103
 
   453 jump *label111 always
   454 label *label110
   455 label *label111
-    * op add *tmp165 @time 5000
-    * set :unitCheck *tmp165
+  456 op add :unitCheck @time 5000
   457 jump *label99 always
   458 label *label98
   459 label *label99

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    14 jump *label0 always
    15 label *label2
    16 label *label4
-    * jump *label6 equal true false
    17 printflush null
    18 print "[gold]Looking for suitable unit type:[]"
    19 print "\n"
 
   215 sensor .VAULT_Y .VAULT @y
   216 op add :unitCheck @time 5000
   217 label *label56
-    * jump *label58 equal true false
   218 set :start @time
   219 print " === [gold]Supplying Power Plant[] === "
   220 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-20 instructions):
 
     7 set .VAULT vault1
     8 label *label0
     9 sensor *tmp0 .VAULT @dead
-    * op notEqual *tmp1 *tmp0 0
-    * jump *label2 equal *tmp1 false
+   10 jump *label2 equal *tmp0 0
    11 set .VAULT vault1
    12 label *label1
    13 jump *label0 always
 
    21 set :areUnitsAvailable.0:occupied 0
    22 ubind :areUnitsAvailable.0:type
    23 set :areUnitsAvailable.0:firstUnit @unit
-    * op notEqual *tmp5 :areUnitsAvailable.0:firstUnit null
-    * jump *label8 equal *tmp5 false
+   24 jump *label8 equal :areUnitsAvailable.0:firstUnit null
    25 label *label10
    26 sensor *tmp7 @unit @controlled
    27 op equal *tmp8 *tmp7 0
 
    80 setaddr *tmp19 *label25
    81 set :chooseUnitType.0:type @mono
    82 label *label19
-    * op notEqual *tmp20 :chooseUnitType.0:type UNIT_TYPE
-    * jump *label26 equal *tmp20 false
+   83 jump *label26 equal :chooseUnitType.0:type UNIT_TYPE
    84 set :areUnitsAvailable.1:type :chooseUnitType.0:type
    85 set :areUnitsAvailable.1:output true
    86 set :areUnitsAvailable.1:occupied 0
    87 ubind :areUnitsAvailable.1:type
    88 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp24 :areUnitsAvailable.1:firstUnit null
-    * jump *label29 equal *tmp24 false
+   89 jump *label29 equal :areUnitsAvailable.1:firstUnit null
    90 label *label31
    91 sensor *tmp26 @unit @controlled
    92 op equal *tmp27 *tmp26 0
 
   147 set .TYPE *tmp2
   148 set :acquireUnit.0:currentUnit .UNIT
   149 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * op notEqual *tmp40 :rebindUnit.0:currentUnit null
-    * jump *label42 equal *tmp40 false
+  150 jump *label42 equal :rebindUnit.0:currentUnit null
   151 ubind :rebindUnit.0:currentUnit
   152 sensor *tmp42 @unit @dead
   153 op equal *tmp43 *tmp42 0
 
   164 label *label43
   165 ubind .TYPE
   166 set :rebindUnit.0:firstUnit @unit
-    * op notEqual *tmp49 :rebindUnit.0:firstUnit null
-    * jump *label46 equal *tmp49 false
+  167 jump *label46 equal :rebindUnit.0:firstUnit null
   168 label *label48
   169 sensor *tmp51 @unit @controlled
-    * op equal *tmp52 *tmp51 0
-    * jump *label51 equal *tmp52 false
+  170 jump *label51 notEqual *tmp51 0
   171 jump *label41 always
   172 jump *label52 always
   173 label *label51
 
   199 label *label53
   200 ulocate building core false @copper 0 0 0 .CORE
   201 label *label54
-    * op equal *tmp65 .CORE null
-    * jump *label53 notEqual *tmp65 false
+  202 jump *label53 equal .CORE null
   203 label *label55
   204 sensor .CORE_X .CORE @x
   205 sensor .CORE_Y .CORE @y
 
   219 print "]"
   220 print "\n"
   221 sensor *tmp73 .VAULT .ITEM
-    * op lessThan *tmp74 *tmp73 500
-    * jump *label59 equal *tmp74 false
+  222 jump *label59 greaterThanEq *tmp73 500
   223 print "\n"
   224 print "Unit type: [green]"
   225 print .TYPE
 
   228 print "\n"
   229 set :processUnit.0:unit .UNIT
   230 set :rebindUnit.1:currentUnit :processUnit.0:unit
-    * op notEqual *tmp78 :rebindUnit.1:currentUnit null
-    * jump *label63 equal *tmp78 false
+  231 jump *label63 equal :rebindUnit.1:currentUnit null
   232 ubind :rebindUnit.1:currentUnit
   233 sensor *tmp80 @unit @dead
   234 op equal *tmp81 *tmp80 0
 
   245 label *label64
   246 ubind .TYPE
   247 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp87 :rebindUnit.1:firstUnit null
-    * jump *label67 equal *tmp87 false
+  248 jump *label67 equal :rebindUnit.1:firstUnit null
   249 label *label69
   250 sensor *tmp89 @unit @controlled
-    * op equal *tmp90 *tmp89 0
-    * jump *label72 equal *tmp90 false
+  251 jump *label72 notEqual *tmp89 0
   252 jump *label62 always
   253 jump *label73 always
   254 label *label72
 
   274 op or *tmp99 *tmp97 *tmp98
   275 jump *label74 equal *tmp99 false
   276 sensor *tmp101 @unit @firstItem
-    * op equal *tmp102 *tmp101 .ITEM
-    * jump *label76 equal *tmp102 false
+  277 jump *label76 notEqual *tmp101 .ITEM
   278 set :processUnit.0:state 3
   279 jump *label77 always
   280 label *label76
   281 sensor *tmp104 @unit @totalItems
-    * op equal *tmp105 *tmp104 0
-    * jump *label78 equal *tmp105 false
+  282 jump *label78 notEqual *tmp104 0
   283 set :processUnit.0:state 2
   284 jump *label79 always
   285 label *label78
 
   296 jump *label75 always
   297 label *label74
   298 label *label75
-    * op equal *tmp109 :processUnit.0:state 2
-    * jump *label82 equal *tmp109 false
+  299 jump *label82 notEqual :processUnit.0:state 2
   300 ucontrol within .CORE_X .CORE_Y 8 *tmp111
   301 jump *label84 equal *tmp111 false
   302 ucontrol itemTake .CORE .ITEM .UNIT_CAPACITY
   303 sensor *tmp113 @unit @totalItems
-    * op greaterThanEq *tmp114 *tmp113 .UNIT_CAPACITY
-    * jump *label86 equal *tmp114 false
+  304 jump *label86 lessThan *tmp113 .UNIT_CAPACITY
   305 ucontrol approach .VAULT_X .VAULT_Y 6
   306 set :processUnit.0:state 3
   307 jump *label87 always
 
   323 jump *label83 always
   324 label *label82
   325 label *label83
-    * op equal *tmp123 :processUnit.0:state 3
-    * jump *label88 equal *tmp123 false
+  326 jump *label88 notEqual :processUnit.0:state 3
   327 ucontrol within .VAULT_X .VAULT_Y 8 *tmp125
   328 jump *label90 equal *tmp125 false
   329 ucontrol itemDrop .VAULT .UNIT_CAPACITY
   330 set .MSG ", supplying\n"
   331 sensor *tmp127 @unit @totalItems
-    * op lessThanEq *tmp128 *tmp127 0
-    * jump *label92 equal *tmp128 false
+  332 jump *label92 greaterThan *tmp127 0
   333 ucontrol approach .CORE_X .CORE_Y 6
   334 set :processUnit.0:state 2
   335 jump *label93 always
 
   358 print *tmp137
   359 print "["
   360 print "]"
-    * op greaterThanEq *tmp138 :processUnit.0:distance 0
-    * jump *label94 equal *tmp138 false
+  361 jump *label94 lessThan :processUnit.0:distance 0
   362 print .MSG
   363 print :processUnit.0:distance
   364 print "["
 
   388 set :areUnitsAvailable.2:occupied 0
   389 ubind :areUnitsAvailable.2:type
   390 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp151 :areUnitsAvailable.2:firstUnit null
-    * jump *label101 equal *tmp151 false
+  391 jump *label101 equal :areUnitsAvailable.2:firstUnit null
   392 label *label103
   393 sensor *tmp153 @unit @controlled
   394 op equal *tmp154 *tmp153 0

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-26 instructions):
 
    43 op land *tmp16 *tmp13 *tmp15
    44 jump *label10 notEqual *tmp16 false
    45 label *label12
-    * jump *label9 always
    46 label *label8
    47 label *label9
    48 jump *label15 equal :areUnitsAvailable.0:output false
 
    51 print "occupied: "
    52 print :areUnitsAvailable.0:occupied
    53 print "\n"
-    * jump *label16 always
    54 label *label15
    55 label *label16
    56 set *tmp3 false
 
    60 jump *label17 equal *tmp3 false
    61 set *tmp2 UNIT_TYPE
    62 jump *label3 always
-    * jump *label18 always
    63 label *label17
    64 label *label18
    65 setaddr *tmp19 *label22
 
   105 op land *tmp35 *tmp32 *tmp34
   106 jump *label31 notEqual *tmp35 false
   107 label *label33
-    * jump *label30 always
   108 label *label29
   109 label *label30
   110 jump *label36 equal :areUnitsAvailable.1:output false
 
   113 print "occupied: "
   114 print :areUnitsAvailable.1:occupied
   115 print "\n"
-    * jump *label37 always
   116 label *label36
   117 label *label37
   118 set *tmp22 false
 
   123 printflush null
   124 set *tmp2 :chooseUnitType.0:type
   125 jump *label3 always
-    * jump *label39 always
   126 label *label38
   127 label *label39
-    * jump *label27 always
   128 label *label26
   129 label *label27
   130 label *label20
 
   149 op land *tmp46 *tmp43 *tmp45
   150 jump *label44 equal *tmp46 false
   151 jump *label41 always
-    * jump *label45 always
   152 label *label44
   153 label *label45
-    * jump *label43 always
   154 label *label42
   155 label *label43
   156 ubind .TYPE
 
   160 sensor *tmp51 @unit @controlled
   161 jump *label51 notEqual *tmp51 0
   162 jump *label41 always
-    * jump *label52 always
   163 label *label51
   164 label *label52
   165 ubind .TYPE
 
   170 op land *tmp57 *tmp54 *tmp56
   171 jump *label48 notEqual *tmp57 false
   172 label *label50
-    * jump *label47 always
   173 label *label46
   174 label *label47
   175 end
 
   226 op land *tmp84 *tmp81 *tmp83
   227 jump *label65 equal *tmp84 false
   228 jump *label62 always
-    * jump *label66 always
   229 label *label65
   230 label *label66
-    * jump *label64 always
   231 label *label63
   232 label *label64
   233 ubind .TYPE
 
   237 sensor *tmp89 @unit @controlled
   238 jump *label72 notEqual *tmp89 0
   239 jump *label62 always
-    * jump *label73 always
   240 label *label72
   241 label *label73
   242 ubind .TYPE
 
   247 op land *tmp95 *tmp92 *tmp94
   248 jump *label69 notEqual *tmp95 false
   249 label *label71
-    * jump *label68 always
   250 label *label67
   251 label *label68
   252 end
 
   273 ucontrol within .CORE_X .CORE_Y 8 *tmp107
   274 jump *label80 equal *tmp107 false
   275 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label81 always
   276 label *label80
   277 label *label81
   278 label *label79
   279 label *label77
-    * jump *label75 always
   280 label *label74
   281 label *label75
   282 jump *label82 notEqual :processUnit.0:state 2
 
   303 op idiv *tmp121 *tmp120 .SPEED_TENTHS
   304 op div :processUnit.0:distance *tmp121 10
   305 label *label85
-    * jump *label83 always
   306 label *label82
   307 label *label83
   308 jump *label88 notEqual :processUnit.0:state 3
 
   314 jump *label92 greaterThan *tmp127 0
   315 ucontrol approach .CORE_X .CORE_Y 6
   316 set :processUnit.0:state 2
-    * jump *label93 always
   317 label *label92
   318 label *label93
   319 jump *label91 always
 
   328 op idiv *tmp135 *tmp134 .SPEED_TENTHS
   329 op div :processUnit.0:distance *tmp135 10
   330 label *label91
-    * jump *label89 always
   331 label *label88
   332 label *label89
   333 ucontrol flag :processUnit.0:state
 
   348 label *label94
   349 print .MSG
   350 label *label95
-    * jump *label61 always
   351 label *label61
   352 set :state :processUnit.0:state
   353 op equal *tmp140 :state 2
 
   389 op land *tmp162 *tmp159 *tmp161
   390 jump *label103 notEqual *tmp162 false
   391 label *label105
-    * jump *label102 always
   392 label *label101
   393 label *label102
   394 jump *label108 equal :areUnitsAvailable.2:output false
 
   397 print "occupied: "
   398 print :areUnitsAvailable.2:occupied
   399 print "\n"
-    * jump *label109 always
   400 label *label108
   401 label *label109
   402 set *tmp149 false
 
   405 label *label100
   406 jump *label110 equal *tmp149 false
   407 end
-    * jump *label111 always
   408 label *label110
   409 label *label111
   410 op add :unitCheck @time 5000
-    * jump *label99 always
   411 label *label98
   412 label *label99
   413 label *label97
-    * jump *label60 always
   414 label *label59
   415 label *label60
   416 op sub *tmp166 @time :start

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
 
    19 set :areUnitsAvailable.0:type UNIT_TYPE
    20 set :areUnitsAvailable.0:output true
    21 set :areUnitsAvailable.0:occupied 0
-    * ubind :areUnitsAvailable.0:type
+   22 ubind UNIT_TYPE
    23 set :areUnitsAvailable.0:firstUnit @unit
    24 jump *label8 equal :areUnitsAvailable.0:firstUnit null
    25 label *label10
 
    35 label *label13
    36 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
    37 label *label14
-    * ubind :areUnitsAvailable.0:type
+   38 ubind UNIT_TYPE
    39 label *label11
    40 op notEqual *tmp13 @unit :areUnitsAvailable.0:firstUnit
    41 sensor *tmp14 :areUnitsAvailable.0:firstUnit @dead
 
    45 label *label12
    46 label *label8
    47 label *label9
-    * jump *label15 equal :areUnitsAvailable.0:output false
-    * print :areUnitsAvailable.0:type
+   48 jump *label15 equal true false
+   49 print UNIT_TYPE
    50 print " "
    51 print "occupied: "
    52 print :areUnitsAvailable.0:occupied
 
    55 label *label16
    56 set *tmp3 false
    57 jump *label7 always
-    * set *tmp3 null
    58 label *label7
    59 jump *label17 equal *tmp3 false
    60 set *tmp2 UNIT_TYPE
 
    80 set :areUnitsAvailable.1:type :chooseUnitType.0:type
    81 set :areUnitsAvailable.1:output true
    82 set :areUnitsAvailable.1:occupied 0
-    * ubind :areUnitsAvailable.1:type
+   83 ubind :chooseUnitType.0:type
    84 set :areUnitsAvailable.1:firstUnit @unit
    85 jump *label29 equal :areUnitsAvailable.1:firstUnit null
    86 label *label31
 
    96 label *label34
    97 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    98 label *label35
-    * ubind :areUnitsAvailable.1:type
+   99 ubind :chooseUnitType.0:type
   100 label *label32
   101 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   102 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   106 label *label33
   107 label *label29
   108 label *label30
-    * jump *label36 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  109 jump *label36 equal true false
+  110 print :chooseUnitType.0:type
   111 print " "
   112 print "occupied: "
   113 print :areUnitsAvailable.1:occupied
 
   116 label *label37
   117 set *tmp22 false
   118 jump *label28 always
-    * set *tmp22 null
   119 label *label28
   120 jump *label38 equal *tmp22 false
   121 printflush null
 
   136 set *tmp2 null
   137 label *label3
   138 set .TYPE *tmp2
-    * set :acquireUnit.0:currentUnit .UNIT
-    * set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * jump *label42 equal :rebindUnit.0:currentUnit null
-    * ubind :rebindUnit.0:currentUnit
+  139 set :acquireUnit.0:currentUnit null
+  140 set :rebindUnit.0:currentUnit .UNIT
+  141 jump *label42 equal :acquireUnit.0:currentUnit null
+  142 ubind :acquireUnit.0:currentUnit
   143 sensor *tmp42 @unit @dead
   144 op equal *tmp43 *tmp42 0
   145 sensor *tmp44 @unit @controller
 
   151 label *label45
   152 label *label42
   153 label *label43
-    * ubind .TYPE
+  154 ubind *tmp2
   155 set :rebindUnit.0:firstUnit @unit
   156 jump *label46 equal :rebindUnit.0:firstUnit null
   157 label *label48
 
   160 jump *label41 always
   161 label *label51
   162 label *label52
-    * ubind .TYPE
+  163 ubind *tmp2
   164 label *label49
   165 op notEqual *tmp54 @unit :rebindUnit.0:firstUnit
   166 sensor *tmp55 :rebindUnit.0:firstUnit @dead
 
   175 ucontrol flag 1
   176 set *tmp38 @unit
   177 jump *label40 always
-    * set *tmp38 null
   178 label *label40
   179 set .UNIT *tmp38
-    * sensor .UNIT_CAPACITY .UNIT @itemCapacity
-    * sensor .SPEED .UNIT @speed
+  180 sensor .UNIT_CAPACITY *tmp38 @itemCapacity
+  181 sensor .SPEED *tmp38 @speed
   182 op div .SPEED_TENTHS .SPEED 10
   183 print "[gold]Locating core..."
   184 printflush message1
 
   197 print " === [gold]Supplying Power Plant[] === "
   198 print "\n"
   199 print "\n"
-    * sensor *tmp72 .VAULT .ITEM
+  200 sensor *tmp72 .VAULT @thorium
   201 print "\n"
   202 print "[gold]Thorium[] status: [green]"
   203 print *tmp72
   204 print "["
   205 print "]"
   206 print "\n"
-    * sensor *tmp73 .VAULT .ITEM
+  207 sensor *tmp73 .VAULT @thorium
   208 jump *label59 greaterThanEq *tmp73 500
   209 print "\n"
   210 print "Unit type: [green]"
-    * print .TYPE
+  211 print *tmp2
   212 print "["
   213 print "]"
   214 print "\n"
-    * set :processUnit.0:unit .UNIT
-    * set :rebindUnit.1:currentUnit :processUnit.0:unit
-    * jump *label63 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  215 set :processUnit.0:unit *tmp38
+  216 set :rebindUnit.1:currentUnit .UNIT
+  217 jump *label63 equal :processUnit.0:unit null
+  218 ubind :processUnit.0:unit
   219 sensor *tmp80 @unit @dead
   220 op equal *tmp81 *tmp80 0
   221 sensor *tmp82 @unit @controller
 
   227 label *label66
   228 label *label63
   229 label *label64
-    * ubind .TYPE
+  230 ubind *tmp2
   231 set :rebindUnit.1:firstUnit @unit
   232 jump *label67 equal :rebindUnit.1:firstUnit null
   233 label *label69
 
   236 jump *label62 always
   237 label *label72
   238 label *label73
-    * ubind .TYPE
+  239 ubind *tmp2
   240 label *label70
   241 op notEqual *tmp92 @unit :rebindUnit.1:firstUnit
   242 sensor *tmp93 :rebindUnit.1:firstUnit @dead
 
   256 op or *tmp99 *tmp97 *tmp98
   257 jump *label74 equal *tmp99 false
   258 sensor *tmp101 @unit @firstItem
-    * jump *label76 notEqual *tmp101 .ITEM
+  259 jump *label76 notEqual *tmp101 @thorium
   260 set :processUnit.0:state 3
   261 jump *label77 always
   262 label *label76
 
   279 jump *label82 notEqual :processUnit.0:state 2
   280 ucontrol within .CORE_X .CORE_Y 8 *tmp111
   281 jump *label84 equal *tmp111 false
-    * ucontrol itemTake .CORE .ITEM .UNIT_CAPACITY
+  282 ucontrol itemTake .CORE @thorium .UNIT_CAPACITY
   283 sensor *tmp113 @unit @totalItems
   284 jump *label86 lessThan *tmp113 .UNIT_CAPACITY
   285 ucontrol approach .VAULT_X .VAULT_Y 6
 
   330 ucontrol flag :processUnit.0:state
   331 sensor *tmp137 @unit @totalItems
   332 print "["
-    * print :processUnit.0:color
+  333 print "gold"
   334 print "]"
   335 print *tmp137
   336 print "["
 
   347 label *label95
   348 label *label61
   349 set :state :processUnit.0:state
-    * op equal *tmp140 :state 2
-    * sensor *tmp141 .VAULT .ITEM
+  350 op equal *tmp140 :processUnit.0:state 2
+  351 sensor *tmp141 .VAULT @thorium
   352 op greaterThanEq *tmp142 *tmp141 500
   353 op land *tmp143 *tmp140 *tmp142
   354 jump *label96 equal *tmp143 false
   355 ucontrol unbind
   356 jump *label97 always
   357 label *label96
-    * op notEqual *tmp145 .TYPE UNIT_TYPE
+  358 op notEqual *tmp145 *tmp2 UNIT_TYPE
   359 op greaterThan *tmp146 :unitCheck @time
   360 op land *tmp147 *tmp145 *tmp146
   361 jump *label98 equal *tmp147 false
   362 set :areUnitsAvailable.2:type UNIT_TYPE
   363 set :areUnitsAvailable.2:output false
   364 set :areUnitsAvailable.2:occupied 0
-    * ubind :areUnitsAvailable.2:type
+  365 ubind UNIT_TYPE
   366 set :areUnitsAvailable.2:firstUnit @unit
   367 jump *label101 equal :areUnitsAvailable.2:firstUnit null
   368 label *label103
 
   378 label *label106
   379 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
   380 label *label107
-    * ubind :areUnitsAvailable.2:type
+  381 ubind UNIT_TYPE
   382 label *label104
   383 op notEqual *tmp159 @unit :areUnitsAvailable.2:firstUnit
   384 sensor *tmp160 :areUnitsAvailable.2:firstUnit @dead
 
   388 label *label105
   389 label *label101
   390 label *label102
-    * jump *label108 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+  391 jump *label108 equal false false
+  392 print UNIT_TYPE
   393 print " "
   394 print "occupied: "
   395 print :areUnitsAvailable.2:occupied
 
   398 label *label109
   399 set *tmp149 false
   400 jump *label100 always
-    * set *tmp149 null
   401 label *label100
   402 jump *label110 equal *tmp149 false
   403 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-10 instructions):
 
     1 remark "If no units of this type exist, we'll try using other types."
     2 set UNIT_TYPE @poly
     3 remark "Do not modify anything below this line."
-    * set .ITEM @thorium
     4 set .MSG ""
     5 set .UNIT null
     6 set .VAULT vault1
 
    15 printflush null
    16 print "[gold]Looking for suitable unit type:[]"
    17 print "\n"
-    * set :areUnitsAvailable.0:type UNIT_TYPE
-    * set :areUnitsAvailable.0:output true
    18 set :areUnitsAvailable.0:occupied 0
    19 ubind UNIT_TYPE
    20 set :areUnitsAvailable.0:firstUnit @unit
 
    74 set :chooseUnitType.0:type @mono
    75 label *label19
    76 jump *label26 equal :chooseUnitType.0:type UNIT_TYPE
-    * set :areUnitsAvailable.1:type :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:output true
    77 set :areUnitsAvailable.1:occupied 0
    78 ubind :chooseUnitType.0:type
    79 set :areUnitsAvailable.1:firstUnit @unit
 
   130 label *label6
   131 set *tmp2 null
   132 label *label3
-    * set .TYPE *tmp2
   133 set :acquireUnit.0:currentUnit null
-    * set :rebindUnit.0:currentUnit .UNIT
-    * jump *label42 equal :acquireUnit.0:currentUnit null
-    * ubind :acquireUnit.0:currentUnit
+  134 set :rebindUnit.0:currentUnit null
+  135 jump *label42 equal null null
+  136 ubind null
   137 sensor *tmp42 @unit @dead
   138 op equal *tmp43 *tmp42 0
   139 sensor *tmp44 @unit @controller
 
   207 print "]"
   208 print "\n"
   209 set :processUnit.0:unit *tmp38
-    * set :rebindUnit.1:currentUnit .UNIT
-    * jump *label63 equal :processUnit.0:unit null
-    * ubind :processUnit.0:unit
+  210 set :rebindUnit.1:currentUnit *tmp38
+  211 jump *label63 equal *tmp38 null
+  212 ubind *tmp38
   213 sensor *tmp80 @unit @dead
   214 op equal *tmp81 *tmp80 0
   215 sensor *tmp82 @unit @controller
 
   244 label *label62
   245 sensor :processUnit.0:state @unit @flag
   246 set :processUnit.0:distance -1
-    * set :processUnit.0:color "gold"
   247 op lessThan *tmp97 :processUnit.0:state 2
   248 op greaterThan *tmp98 :processUnit.0:state 3
   249 op or *tmp99 *tmp97 *tmp98
 
   339 print .MSG
   340 label *label95
   341 label *label61
-    * set :state :processUnit.0:state
   342 op equal *tmp140 :processUnit.0:state 2
   343 sensor *tmp141 .VAULT @thorium
   344 op greaterThanEq *tmp142 *tmp141 500
 
   351 op greaterThan *tmp146 :unitCheck @time
   352 op land *tmp147 *tmp145 *tmp146
   353 jump *label98 equal *tmp147 false
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
   354 set :areUnitsAvailable.2:occupied 0
   355 ubind UNIT_TYPE
   356 set :areUnitsAvailable.2:firstUnit @unit

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-6 instructions):
 
     2 set UNIT_TYPE @poly
     3 remark "Do not modify anything below this line."
     4 set .MSG ""
-    * set .UNIT null
     5 set .VAULT vault1
     6 label *label0
     7 sensor *tmp0 .VAULT @dead
 
   129 label *label6
   130 set *tmp2 null
   131 label *label3
-    * set :acquireUnit.0:currentUnit null
-    * set :rebindUnit.0:currentUnit null
   132 jump *label42 equal null null
   133 ubind null
   134 sensor *tmp42 @unit @dead
 
   167 set *tmp38 @unit
   168 jump *label40 always
   169 label *label40
-    * set .UNIT *tmp38
   170 sensor .UNIT_CAPACITY *tmp38 @itemCapacity
   171 sensor .SPEED *tmp38 @speed
   172 op div .SPEED_TENTHS .SPEED 10
 
   202 print "["
   203 print "]"
   204 print "\n"
-    * set :processUnit.0:unit *tmp38
-    * set :rebindUnit.1:currentUnit *tmp38
   205 jump *label63 equal *tmp38 null
   206 ubind *tmp38
   207 sensor *tmp80 @unit @dead

Modifications by Replicate loop condition at line 30:1 (+1 instructions):
 
     6 label *label0
     7 sensor *tmp0 .VAULT @dead
     8 jump *label2 equal *tmp0 0
+    9 label *label112
    10 set .VAULT vault1
    11 label *label1
-    * jump *label0 always
+   12 sensor *tmp0 .VAULT @dead
+   13 jump *label112 notEqual *tmp0 0
    14 label *label2
    15 label *label4
    16 printflush null

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     4 set .MSG ""
     5 set .VAULT vault1
     6 label *label0
-    * sensor *tmp0 .VAULT @dead
+    7 sensor *tmp0 vault1 @dead
     8 jump *label2 equal *tmp0 0
     9 label *label112
    10 set .VAULT vault1
    11 label *label1
-    * sensor *tmp0 .VAULT @dead
+   12 sensor *tmp0 vault1 @dead
    13 jump *label112 notEqual *tmp0 0
    14 label *label2
    15 label *label4

Modifications by Unroll iteration loop at line 93:9 (+91 instructions):
 
    59 jump *label3 always
    60 label *label17
    61 label *label18
-    * setaddr *tmp19 *label22
-    * set :chooseUnitType.0:type @flare
-    * jump *label19 always
-    * multilabel *label22 marker0
-    * setaddr *tmp19 *label23
-    * set :chooseUnitType.0:type @poly
-    * jump *label19 always
-    * multilabel *label23 marker0
-    * setaddr *tmp19 *label24
-    * set :chooseUnitType.0:type @mega
-    * jump *label19 always
-    * multilabel *label24 marker0
-    * setaddr *tmp19 *label25
-    * set :chooseUnitType.0:type @mono
-    * label *label19
-    * jump *label26 equal :chooseUnitType.0:type UNIT_TYPE
-    * set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label29 equal :areUnitsAvailable.1:firstUnit null
-    * label *label31
-    * sensor *tmp26 @unit @controlled
-    * op equal *tmp27 *tmp26 0
-    * sensor *tmp28 @unit @controller
-    * op equal *tmp29 *tmp28 @this
-    * op or *tmp30 *tmp27 *tmp29
-    * jump *label34 equal *tmp30 false
-    * set *tmp22 true
-    * jump *label28 always
-    * jump *label35 always
-    * label *label34
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label35
-    * ubind :chooseUnitType.0:type
-    * label *label32
-    * op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp34 *tmp33 0
-    * op land *tmp35 *tmp32 *tmp34
-    * jump *label31 notEqual *tmp35 false
-    * label *label33
-    * label *label29
-    * label *label30
-    * jump *label36 equal true false
-    * print :chooseUnitType.0:type
-    * print " "
-    * print "occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print "\n"
-    * label *label36
-    * label *label37
-    * set *tmp22 false
-    * jump *label28 always
-    * label *label28
-    * jump *label38 equal *tmp22 false
-    * printflush null
-    * set *tmp2 :chooseUnitType.0:type
-    * jump *label3 always
-    * label *label38
-    * label *label39
-    * label *label26
-    * label *label27
-    * label *label20
-    * multijump *tmp19 0 0 marker0
-    * multilabel *label25 marker0
-    * label *label21
+   62 set :chooseUnitType.0:type @flare
+   63 label *label113
+   64 jump *label126 equal :chooseUnitType.0:type UNIT_TYPE
+   65 set :areUnitsAvailable.1:occupied 0
+   66 ubind :chooseUnitType.0:type
+   67 set :areUnitsAvailable.1:firstUnit @unit
+   68 jump *label119 equal :areUnitsAvailable.1:firstUnit null
+   69 label *label114
+   70 sensor *tmp26 @unit @controlled
+   71 op equal *tmp27 *tmp26 0
+   72 sensor *tmp28 @unit @controller
+   73 op equal *tmp29 *tmp28 @this
+   74 op or *tmp30 *tmp27 *tmp29
+   75 jump *label115 equal *tmp30 false
+   76 set *tmp22 true
+   77 jump *label123 always
+   78 jump *label116 always
+   79 label *label115
+   80 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+   81 label *label116
+   82 ubind :chooseUnitType.0:type
+   83 label *label117
+   84 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
+   85 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
+   86 op equal *tmp34 *tmp33 0
+   87 op land *tmp35 *tmp32 *tmp34
+   88 jump *label114 notEqual *tmp35 false
+   89 label *label118
+   90 label *label119
+   91 label *label120
+   92 jump *label121 equal true false
+   93 print :chooseUnitType.0:type
+   94 print " "
+   95 print "occupied: "
+   96 print :areUnitsAvailable.1:occupied
+   97 print "\n"
+   98 label *label121
+   99 label *label122
+  100 set *tmp22 false
+  101 jump *label123 always
+  102 label *label123
+  103 jump *label124 equal *tmp22 false
+  104 printflush null
+  105 set *tmp2 :chooseUnitType.0:type
+  106 jump *label3 always
+  107 label *label124
+  108 label *label125
+  109 label *label126
+  110 label *label127
+  111 label *label128
+  112 set :chooseUnitType.0:type @poly
+  113 label *label131
+  114 jump *label144 equal :chooseUnitType.0:type UNIT_TYPE
+  115 set :areUnitsAvailable.1:occupied 0
+  116 ubind :chooseUnitType.0:type
+  117 set :areUnitsAvailable.1:firstUnit @unit
+  118 jump *label137 equal :areUnitsAvailable.1:firstUnit null
+  119 label *label132
+  120 sensor *tmp26 @unit @controlled
+  121 op equal *tmp27 *tmp26 0
+  122 sensor *tmp28 @unit @controller
+  123 op equal *tmp29 *tmp28 @this
+  124 op or *tmp30 *tmp27 *tmp29
+  125 jump *label133 equal *tmp30 false
+  126 set *tmp22 true
+  127 jump *label141 always
+  128 jump *label134 always
+  129 label *label133
+  130 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  131 label *label134
+  132 ubind :chooseUnitType.0:type
+  133 label *label135
+  134 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
+  135 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
+  136 op equal *tmp34 *tmp33 0
+  137 op land *tmp35 *tmp32 *tmp34
+  138 jump *label132 notEqual *tmp35 false
+  139 label *label136
+  140 label *label137
+  141 label *label138
+  142 jump *label139 equal true false
+  143 print :chooseUnitType.0:type
+  144 print " "
+  145 print "occupied: "
+  146 print :areUnitsAvailable.1:occupied
+  147 print "\n"
+  148 label *label139
+  149 label *label140
+  150 set *tmp22 false
+  151 jump *label141 always
+  152 label *label141
+  153 jump *label142 equal *tmp22 false
+  154 printflush null
+  155 set *tmp2 :chooseUnitType.0:type
+  156 jump *label3 always
+  157 label *label142
+  158 label *label143
+  159 label *label144
+  160 label *label145
+  161 label *label146
+  162 set :chooseUnitType.0:type @mega
+  163 label *label149
+  164 jump *label162 equal :chooseUnitType.0:type UNIT_TYPE
+  165 set :areUnitsAvailable.1:occupied 0
+  166 ubind :chooseUnitType.0:type
+  167 set :areUnitsAvailable.1:firstUnit @unit
+  168 jump *label155 equal :areUnitsAvailable.1:firstUnit null
+  169 label *label150
+  170 sensor *tmp26 @unit @controlled
+  171 op equal *tmp27 *tmp26 0
+  172 sensor *tmp28 @unit @controller
+  173 op equal *tmp29 *tmp28 @this
+  174 op or *tmp30 *tmp27 *tmp29
+  175 jump *label151 equal *tmp30 false
+  176 set *tmp22 true
+  177 jump *label159 always
+  178 jump *label152 always
+  179 label *label151
+  180 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  181 label *label152
+  182 ubind :chooseUnitType.0:type
+  183 label *label153
+  184 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
+  185 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
+  186 op equal *tmp34 *tmp33 0
+  187 op land *tmp35 *tmp32 *tmp34
+  188 jump *label150 notEqual *tmp35 false
+  189 label *label154
+  190 label *label155
+  191 label *label156
+  192 jump *label157 equal true false
+  193 print :chooseUnitType.0:type
+  194 print " "
+  195 print "occupied: "
+  196 print :areUnitsAvailable.1:occupied
+  197 print "\n"
+  198 label *label157
+  199 label *label158
+  200 set *tmp22 false
+  201 jump *label159 always
+  202 label *label159
+  203 jump *label160 equal *tmp22 false
+  204 printflush null
+  205 set *tmp2 :chooseUnitType.0:type
+  206 jump *label3 always
+  207 label *label160
+  208 label *label161
+  209 label *label162
+  210 label *label163
+  211 label *label164
+  212 set :chooseUnitType.0:type @mono
+  213 label *label167
+  214 jump *label180 equal :chooseUnitType.0:type UNIT_TYPE
+  215 set :areUnitsAvailable.1:occupied 0
+  216 ubind :chooseUnitType.0:type
+  217 set :areUnitsAvailable.1:firstUnit @unit
+  218 jump *label173 equal :areUnitsAvailable.1:firstUnit null
+  219 label *label168
+  220 sensor *tmp26 @unit @controlled
+  221 op equal *tmp27 *tmp26 0
+  222 sensor *tmp28 @unit @controller
+  223 op equal *tmp29 *tmp28 @this
+  224 op or *tmp30 *tmp27 *tmp29
+  225 jump *label169 equal *tmp30 false
+  226 set *tmp22 true
+  227 jump *label177 always
+  228 jump *label170 always
+  229 label *label169
+  230 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  231 label *label170
+  232 ubind :chooseUnitType.0:type
+  233 label *label171
+  234 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
+  235 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
+  236 op equal *tmp34 *tmp33 0
+  237 op land *tmp35 *tmp32 *tmp34
+  238 jump *label168 notEqual *tmp35 false
+  239 label *label172
+  240 label *label173
+  241 label *label174
+  242 jump *label175 equal true false
+  243 print :chooseUnitType.0:type
+  244 print " "
+  245 print "occupied: "
+  246 print :areUnitsAvailable.1:occupied
+  247 print "\n"
+  248 label *label175
+  249 label *label176
+  250 set *tmp22 false
+  251 jump *label177 always
+  252 label *label177
+  253 jump *label178 equal *tmp22 false
+  254 printflush null
+  255 set *tmp2 :chooseUnitType.0:type
+  256 jump *label3 always
+  257 label *label178
+  258 label *label179
+  259 label *label180
+  260 label *label181
+  261 label *label182
+  262 label *label21
   263 printflush message1
   264 label *label5
   265 jump *label4 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    61 label *label18
    62 set :chooseUnitType.0:type @flare
    63 label *label113
-    * jump *label126 equal :chooseUnitType.0:type UNIT_TYPE
+   64 jump *label126 equal @flare UNIT_TYPE
    65 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType.0:type
+   66 ubind @flare
    67 set :areUnitsAvailable.1:firstUnit @unit
    68 jump *label119 equal :areUnitsAvailable.1:firstUnit null
    69 label *label114
 
    79 label *label115
    80 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    81 label *label116
-    * ubind :chooseUnitType.0:type
+   82 ubind @flare
    83 label *label117
    84 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
    85 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
    90 label *label119
    91 label *label120
    92 jump *label121 equal true false
-    * print :chooseUnitType.0:type
+   93 print @flare
    94 print " "
    95 print "occupied: "
    96 print :areUnitsAvailable.1:occupied
 
   102 label *label123
   103 jump *label124 equal *tmp22 false
   104 printflush null
-    * set *tmp2 :chooseUnitType.0:type
+  105 set *tmp2 @flare
   106 jump *label3 always
   107 label *label124
   108 label *label125
 
   111 label *label128
   112 set :chooseUnitType.0:type @poly
   113 label *label131
-    * jump *label144 equal :chooseUnitType.0:type UNIT_TYPE
+  114 jump *label144 equal @poly UNIT_TYPE
   115 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType.0:type
+  116 ubind @poly
   117 set :areUnitsAvailable.1:firstUnit @unit
   118 jump *label137 equal :areUnitsAvailable.1:firstUnit null
   119 label *label132
 
   129 label *label133
   130 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   131 label *label134
-    * ubind :chooseUnitType.0:type
+  132 ubind @poly
   133 label *label135
   134 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   135 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   140 label *label137
   141 label *label138
   142 jump *label139 equal true false
-    * print :chooseUnitType.0:type
+  143 print @poly
   144 print " "
   145 print "occupied: "
   146 print :areUnitsAvailable.1:occupied
 
   152 label *label141
   153 jump *label142 equal *tmp22 false
   154 printflush null
-    * set *tmp2 :chooseUnitType.0:type
+  155 set *tmp2 @poly
   156 jump *label3 always
   157 label *label142
   158 label *label143
 
   161 label *label146
   162 set :chooseUnitType.0:type @mega
   163 label *label149
-    * jump *label162 equal :chooseUnitType.0:type UNIT_TYPE
+  164 jump *label162 equal @mega UNIT_TYPE
   165 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType.0:type
+  166 ubind @mega
   167 set :areUnitsAvailable.1:firstUnit @unit
   168 jump *label155 equal :areUnitsAvailable.1:firstUnit null
   169 label *label150
 
   179 label *label151
   180 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   181 label *label152
-    * ubind :chooseUnitType.0:type
+  182 ubind @mega
   183 label *label153
   184 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   185 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   190 label *label155
   191 label *label156
   192 jump *label157 equal true false
-    * print :chooseUnitType.0:type
+  193 print @mega
   194 print " "
   195 print "occupied: "
   196 print :areUnitsAvailable.1:occupied
 
   202 label *label159
   203 jump *label160 equal *tmp22 false
   204 printflush null
-    * set *tmp2 :chooseUnitType.0:type
+  205 set *tmp2 @mega
   206 jump *label3 always
   207 label *label160
   208 label *label161
 
   211 label *label164
   212 set :chooseUnitType.0:type @mono
   213 label *label167
-    * jump *label180 equal :chooseUnitType.0:type UNIT_TYPE
+  214 jump *label180 equal @mono UNIT_TYPE
   215 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType.0:type
+  216 ubind @mono
   217 set :areUnitsAvailable.1:firstUnit @unit
   218 jump *label173 equal :areUnitsAvailable.1:firstUnit null
   219 label *label168
 
   229 label *label169
   230 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   231 label *label170
-    * ubind :chooseUnitType.0:type
+  232 ubind @mono
   233 label *label171
   234 op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit
   235 sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead
 
   240 label *label173
   241 label *label174
   242 jump *label175 equal true false
-    * print :chooseUnitType.0:type
+  243 print @mono
   244 print " "
   245 print "occupied: "
   246 print :areUnitsAvailable.1:occupied
 
   252 label *label177
   253 jump *label178 equal *tmp22 false
   254 printflush null
-    * set *tmp2 :chooseUnitType.0:type
+  255 set *tmp2 @mono
   256 jump *label3 always
   257 label *label178
   258 label *label179

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    59 jump *label3 always
    60 label *label17
    61 label *label18
-    * set :chooseUnitType.0:type @flare
    62 label *label113
    63 jump *label126 equal @flare UNIT_TYPE
    64 set :areUnitsAvailable.1:occupied 0
 
   108 label *label126
   109 label *label127
   110 label *label128
-    * set :chooseUnitType.0:type @poly
   111 label *label131
   112 jump *label144 equal @poly UNIT_TYPE
   113 set :areUnitsAvailable.1:occupied 0
 
   157 label *label144
   158 label *label145
   159 label *label146
-    * set :chooseUnitType.0:type @mega
   160 label *label149
   161 jump *label162 equal @mega UNIT_TYPE
   162 set :areUnitsAvailable.1:occupied 0
 
   206 label *label162
   207 label *label163
   208 label *label164
-    * set :chooseUnitType.0:type @mono
   209 label *label167
   210 jump *label180 equal @mono UNIT_TYPE
   211 set :areUnitsAvailable.1:occupied 0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-5 instructions):
 
    43 label *label12
    44 label *label8
    45 label *label9
-    * jump *label15 equal true false
    46 print UNIT_TYPE
    47 print " "
    48 print "occupied: "
 
    87 label *label118
    88 label *label119
    89 label *label120
-    * jump *label121 equal true false
    90 print @flare
    91 print " "
    92 print "occupied: "
 
   135 label *label136
   136 label *label137
   137 label *label138
-    * jump *label139 equal true false
   138 print @poly
   139 print " "
   140 print "occupied: "
 
   183 label *label154
   184 label *label155
   185 label *label156
-    * jump *label157 equal true false
   186 print @mega
   187 print " "
   188 print "occupied: "
 
   231 label *label172
   232 label *label173
   233 label *label174
-    * jump *label175 equal true false
   234 print @mono
   235 print " "
   236 print "occupied: "
 
   257 label *label6
   258 set *tmp2 null
   259 label *label3
-    * jump *label42 equal null null
+  260 jump *label42 always
   261 ubind null
   262 sensor *tmp42 @unit @dead
   263 op equal *tmp43 *tmp42 0
 
   500 label *label105
   501 label *label101
   502 label *label102
-    * jump *label108 equal false false
+  503 jump *label108 always
   504 print UNIT_TYPE
   505 print " "
   506 print "occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-7 instructions):
 
    51 label *label15
    52 label *label16
    53 set *tmp3 false
-    * jump *label7 always
    54 label *label7
    55 jump *label17 equal *tmp3 false
    56 set *tmp2 UNIT_TYPE
 
    94 label *label121
    95 label *label122
    96 set *tmp22 false
-    * jump *label123 always
    97 label *label123
    98 jump *label124 equal *tmp22 false
    99 printflush null
 
   141 label *label139
   142 label *label140
   143 set *tmp22 false
-    * jump *label141 always
   144 label *label141
   145 jump *label142 equal *tmp22 false
   146 printflush null
 
   188 label *label157
   189 label *label158
   190 set *tmp22 false
-    * jump *label159 always
   191 label *label159
   192 jump *label160 equal *tmp22 false
   193 printflush null
 
   235 label *label175
   236 label *label176
   237 set *tmp22 false
-    * jump *label177 always
   238 label *label177
   239 jump *label178 equal *tmp22 false
   240 printflush null
 
   288 label *label41
   289 ucontrol flag 1
   290 set *tmp38 @unit
-    * jump *label40 always
   291 label *label40
   292 sensor .UNIT_CAPACITY *tmp38 @itemCapacity
   293 sensor .SPEED *tmp38 @speed
 
   503 label *label108
   504 label *label109
   505 set *tmp149 false
-    * jump *label100 always
   506 label *label100
   507 jump *label110 equal *tmp149 false
   508 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-3 instructions):
 
   255 jump *label42 always
   256 ubind null
   257 sensor *tmp42 @unit @dead
-    * op equal *tmp43 *tmp42 0
   258 sensor *tmp44 @unit @controller
-    * op equal *tmp45 *tmp44 @this
-    * op land *tmp46 *tmp43 *tmp45
   259 jump *label44 equal *tmp46 false
   260 jump *label41 always
   261 label *label44

Modifications by Final phase, Jump Straightening, iteration 1 (-4 instructions):
 
   256 ubind null
   257 sensor *tmp42 @unit @dead
   258 sensor *tmp44 @unit @controller
-    * jump *label44 equal *tmp46 false
-    * jump *label41 always
+  259 jump *label41 notEqual *tmp46 false
   260 label *label44
   261 label *label45
   262 label *label42
 
   266 jump *label46 equal :rebindUnit.0:firstUnit null
   267 label *label48
   268 sensor *tmp51 @unit @controlled
-    * jump *label51 notEqual *tmp51 0
-    * jump *label41 always
+  269 jump *label41 equal *tmp51 0
   270 label *label51
   271 label *label52
   272 ubind *tmp2
 
   326 sensor *tmp82 @unit @controller
   327 op equal *tmp83 *tmp82 @this
   328 op land *tmp84 *tmp81 *tmp83
-    * jump *label65 equal *tmp84 false
-    * jump *label62 always
+  329 jump *label62 notEqual *tmp84 false
   330 label *label65
   331 label *label66
   332 label *label63
 
   336 jump *label67 equal :rebindUnit.1:firstUnit null
   337 label *label69
   338 sensor *tmp89 @unit @controlled
-    * jump *label72 notEqual *tmp89 0
-    * jump *label62 always
+  339 jump *label62 equal *tmp89 0
   340 label *label72
   341 label *label73
   342 ubind *tmp2

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @poly
 
    55 label *label7
    56 jump *label17 equal *tmp3 false
    57 set *tmp2 UNIT_TYPE
-    * jump *label3 always
+   58 jump *label42 always
    59 label *label17
    60 label *label18
    61 label *label113
 
    99 jump *label124 equal *tmp22 false
   100 printflush null
   101 set *tmp2 @flare
-    * jump *label3 always
+  102 jump *label42 always
   103 label *label124
   104 label *label125
   105 label *label126
 
   146 jump *label142 equal *tmp22 false
   147 printflush null
   148 set *tmp2 @poly
-    * jump *label3 always
+  149 jump *label42 always
   150 label *label142
   151 label *label143
   152 label *label144
 
   193 jump *label160 equal *tmp22 false
   194 printflush null
   195 set *tmp2 @mega
-    * jump *label3 always
+  196 jump *label42 always
   197 label *label160
   198 label *label161
   199 label *label162
 
   240 jump *label178 equal *tmp22 false
   241 printflush null
   242 set *tmp2 @mono
-    * jump *label3 always
+  243 jump *label42 always
   244 label *label178
   245 label *label179
   246 label *label180
 
   264 label *label43
   265 ubind *tmp2
   266 set :rebindUnit.0:firstUnit @unit
-    * jump *label46 equal :rebindUnit.0:firstUnit null
+  267 jump __start__ equal :rebindUnit.0:firstUnit null
   268 label *label48
   269 sensor *tmp51 @unit @controlled
   270 jump *label41 equal *tmp51 0
 
   334 label *label64
   335 ubind *tmp2
   336 set :rebindUnit.1:firstUnit @unit
-    * jump *label67 equal :rebindUnit.1:firstUnit null
+  337 jump __start__ equal :rebindUnit.1:firstUnit null
   338 label *label69
   339 sensor *tmp89 @unit @controlled
   340 jump *label62 equal *tmp89 0
 
   387 jump *label86 lessThan *tmp113 .UNIT_CAPACITY
   388 ucontrol approach .VAULT_X .VAULT_Y 6
   389 set :processUnit.0:state 3
-    * jump *label87 always
+  390 jump *label85 always
   391 label *label86
   392 set .MSG ", loading\n"
   393 label *label87
 
   411 ucontrol itemDrop .VAULT .UNIT_CAPACITY
   412 set .MSG ", supplying\n"
   413 sensor *tmp127 @unit @totalItems
-    * jump *label92 greaterThan *tmp127 0
+  414 jump *label91 greaterThan *tmp127 0
   415 ucontrol approach .CORE_X .CORE_Y 6
   416 set :processUnit.0:state 2
   417 label *label92
 
   464 set :areUnitsAvailable.2:occupied 0
   465 ubind UNIT_TYPE
   466 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label101 equal :areUnitsAvailable.2:firstUnit null
+  467 jump *label108 equal :areUnitsAvailable.2:firstUnit null
   468 label *label103
   469 sensor *tmp153 @unit @controlled
   470 op equal *tmp154 *tmp153 0

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-18 instructions):
 
    30 jump *label13 equal *tmp11 false
    31 set *tmp3 true
    32 jump *label7 always
-    * jump *label14 always
    33 label *label13
    34 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
    35 label *label14
 
    72 jump *label115 equal *tmp30 false
    73 set *tmp22 true
    74 jump *label123 always
-    * jump *label116 always
    75 label *label115
    76 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    77 label *label116
 
   118 jump *label133 equal *tmp30 false
   119 set *tmp22 true
   120 jump *label141 always
-    * jump *label134 always
   121 label *label133
   122 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   123 label *label134
 
   164 jump *label151 equal *tmp30 false
   165 set *tmp22 true
   166 jump *label159 always
-    * jump *label152 always
   167 label *label151
   168 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   169 label *label152
 
   210 jump *label169 equal *tmp30 false
   211 set *tmp22 true
   212 jump *label177 always
-    * jump *label170 always
   213 label *label169
   214 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   215 label *label170
 
   245 printflush message1
   246 label *label5
   247 jump *label4 always
-    * label *label6
-    * set *tmp2 null
-    * label *label3
-    * jump *label42 always
-    * ubind null
-    * sensor *tmp42 @unit @dead
-    * sensor *tmp44 @unit @controller
-    * jump *label41 notEqual *tmp46 false
-    * label *label44
-    * label *label45
   248 label *label42
   249 label *label43
   250 ubind *tmp2
 
   459 jump *label106 equal *tmp157 false
   460 set *tmp149 true
   461 jump *label100 always
-    * jump *label107 always
   462 label *label106
   463 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
   464 label *label107
 
   473 label *label101
   474 label *label102
   475 jump *label108 always
-    * print UNIT_TYPE
-    * print " "
-    * print "occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print "\n"
   476 label *label108
   477 label *label109
   478 set *tmp149 false
 
   497 printflush message1
   498 label *label57
   499 jump *label56 always
-    * label *label58
-    * end

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   472 label *label105
   473 label *label101
   474 label *label102
-    * jump *label108 always
   475 label *label108
   476 label *label109
   477 set *tmp149 false

Modifications by Final phase, Print Merging, iteration 1 (-26 instructions):
 
    15 label *label2
    16 label *label4
    17 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   18 print "[gold]Looking for suitable unit type:[]\n"
    19 set :areUnitsAvailable.0:occupied 0
    20 ubind UNIT_TYPE
    21 set :areUnitsAvailable.0:firstUnit @unit
 
    43 label *label8
    44 label *label9
    45 print UNIT_TYPE
-    * print " "
-    * print "occupied: "
+   46 print " occupied: "
    47 print :areUnitsAvailable.0:occupied
    48 print "\n"
    49 label *label15
 
    83 label *label118
    84 label *label119
    85 label *label120
-    * print @flare
-    * print " "
-    * print "occupied: "
+   86 print "flare occupied: "
    87 print :areUnitsAvailable.1:occupied
    88 print "\n"
    89 label *label121
 
   127 label *label136
   128 label *label137
   129 label *label138
-    * print @poly
-    * print " "
-    * print "occupied: "
+  130 print "poly occupied: "
   131 print :areUnitsAvailable.1:occupied
   132 print "\n"
   133 label *label139
 
   171 label *label154
   172 label *label155
   173 label *label156
-    * print @mega
-    * print " "
-    * print "occupied: "
+  174 print "mega occupied: "
   175 print :areUnitsAvailable.1:occupied
   176 print "\n"
   177 label *label157
 
   215 label *label172
   216 label *label173
   217 label *label174
-    * print @mono
-    * print " "
-    * print "occupied: "
+  218 print "mono occupied: "
   219 print :areUnitsAvailable.1:occupied
   220 print "\n"
   221 label *label175
 
   277 op add :unitCheck @time 5000
   278 label *label56
   279 set :start @time
-    * print " === [gold]Supplying Power Plant[] === "
-    * print "\n"
-    * print "\n"
   280 sensor *tmp72 .VAULT @thorium
-    * print "\n"
-    * print "[gold]Thorium[] status: [green]"
+  281 print " === [gold]Supplying Power Plant[] === \n\n\n[gold]Thorium[] status: [green]"
   282 print *tmp72
-    * print "["
-    * print "]"
-    * print "\n"
+  283 print "[]\n"
   284 sensor *tmp73 .VAULT @thorium
   285 jump *label59 greaterThanEq *tmp73 500
-    * print "\n"
-    * print "Unit type: [green]"
+  286 print "\nUnit type: [green]"
   287 print *tmp2
-    * print "["
-    * print "]"
-    * print "\n"
+  288 print "[]\n"
   289 jump *label63 equal *tmp38 null
   290 ubind *tmp38
   291 sensor *tmp80 @unit @dead
 
   398 label *label89
   399 ucontrol flag :processUnit.0:state
   400 sensor *tmp137 @unit @totalItems
-    * print "["
-    * print "gold"
-    * print "]"
+  401 print "[gold]"
   402 print *tmp137
-    * print "["
-    * print "]"
+  403 print "[]"
   404 jump *label94 lessThan :processUnit.0:distance 0
   405 print .MSG
   406 print :processUnit.0:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  407 print "[] sec\n"
   408 jump *label95 always
   409 label *label94
   410 print .MSG
 
   464 label *label60
   465 op sub *tmp166 @time :start
   466 op floor *tmp167 *tmp166
-    * print "\n"
-    * print "[lightgray]Loop time: "
+  467 print "\n[lightgray]Loop time: "
   468 print *tmp167
-    * print " "
-    * print "ms"
+  469 print " ms"
   470 printflush message1
   471 label *label57
   472 jump *label56 always

Final code before resolving virtual instructions:

        label __start__                                              /// This is the preferred unit type to use for bringing in supplies.
    0:  remark "This is the preferred unit type to use for bringing  ...
    2:  remark "If no units of this type exist, we'll try using othe /// If no units of this type exist, we'll try using other types.
    3:  set UNIT_TYPE @poly                                          param UNIT_TYPE         = @poly;  // Which unit to use
    4:  remark "Do not modify anything below this line."             /// Do not modify anything below this line.
    6:  set .MSG ""                                                  MSG = "";
    7:  set .VAULT vault1                                            VAULT = vault1;
    8:  sensor *tmp0 vault1 @dead                                    while VAULT.@dead != 0 do
    9:  jump *label2 equal *tmp0 0                                   ...
        label *label112                                              ...
   10:  set .VAULT vault1                                            VAULT = vault1;
   11:  sensor *tmp0 vault1 @dead                                    while VAULT.@dead != 0 do
   12:  jump *label112 notEqual *tmp0 0                              ...
        label *label2                                                ...
        label *label4                                                while true do
   13:  printflush null                                              printflush(null);       // empty text buffer
   14:  print "[gold]Looking for suitable unit type:[]\n"            println("[gold]Looking for suitable unit type:[]");
   15:  set :areUnitsAvailable.0:occupied 0                          occupied = 0;
   16:  ubind UNIT_TYPE                                              firstUnit = ubind(type);
   17:  set :areUnitsAvailable.0:firstUnit @unit                     ...
   18:  jump *label8 equal :areUnitsAvailable.0:firstUnit null       if firstUnit != null then
        label *label10                                               do
   19:  sensor *tmp7 @unit @controlled                               if @unit.@controlled == 0 or @unit.@controller == @this then
   20:  op equal *tmp8 *tmp7 0                                       ...
   21:  sensor *tmp9 @unit @controller                               ...
   22:  op equal *tmp10 *tmp9 @this                                  ...
   23:  op or *tmp11 *tmp8 *tmp10                                    ...
   24:  jump *label13 equal *tmp11 false                             ...
   25:  set *tmp3 true                                               return true;
   26:  jump *label7 always 0 0                                      ...
        label *label13                                               if @unit.@controlled == 0 or @unit.@controller == @this then
   27:  op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:oc occupied += 1;
   28:  ubind UNIT_TYPE                                              ubind(type);
   29:  op notEqual *tmp13 @unit :areUnitsAvailable.0:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
   30:  sensor *tmp14 :areUnitsAvailable.0:firstUnit @dead           ...
   31:  op equal *tmp15 *tmp14 0                                     ...
   32:  op land *tmp16 *tmp13 *tmp15                                 ...
   33:  jump *label10 notEqual *tmp16 false                          do
        label *label8                                                if firstUnit != null then
   34:  print UNIT_TYPE                                              print($"$type occupied: $occupied");
   35:  print " occupied: "                                          ...
   36:  print :areUnitsAvailable.0:occupied                          ...
   37:  print "\n"                                                   println();
   38:  set *tmp3 false                                              return false;
        label *label7                                                if areUnitsAvailable(UNIT_TYPE, true) then
   39:  jump *label17 equal *tmp3 false                              ...
   40:  set *tmp2 UNIT_TYPE                                          return UNIT_TYPE;
   41:  jump *label42 always 0 0                                     ...
        label *label17                                               if areUnitsAvailable(UNIT_TYPE, true) then
   42:  jump *label126 equal @flare UNIT_TYPE                        if type != UNIT_TYPE then
   43:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
   44:  ubind @flare                                                 firstUnit = ubind(type);
   45:  set :areUnitsAvailable.1:firstUnit @unit                     ...
   46:  jump *label119 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label114                                              do
   47:  sensor *tmp26 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
   48:  op equal *tmp27 *tmp26 0                                     ...
   49:  sensor *tmp28 @unit @controller                              ...
   50:  op equal *tmp29 *tmp28 @this                                 ...
   51:  op or *tmp30 *tmp27 *tmp29                                   ...
   52:  jump *label115 equal *tmp30 false                            ...
   53:  set *tmp22 true                                              return true;
   54:  jump *label123 always 0 0                                    ...
        label *label115                                              if @unit.@controlled == 0 or @unit.@controller == @this then
   55:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
   56:  ubind @flare                                                 ubind(type);
   57:  op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
   58:  sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead           ...
   59:  op equal *tmp34 *tmp33 0                                     ...
   60:  op land *tmp35 *tmp32 *tmp34                                 ...
   61:  jump *label114 notEqual *tmp35 false                         do
        label *label119                                              if firstUnit != null then
   62:  print "flare occupied: "                                     print($"$type occupied: $occupied");
   63:  print :areUnitsAvailable.1:occupied                          ...
   64:  print "\n"                                                   println();
   65:  set *tmp22 false                                             return false;
        label *label123                                              if areUnitsAvailable(type, true) then
   66:  jump *label124 equal *tmp22 false                            ...
   67:  printflush null                                              printflush(null);
   68:  set *tmp2 @flare                                             return type;
   69:  jump *label42 always 0 0                                     ...
        label *label124                                              if areUnitsAvailable(type, true) then
        label *label126                                              if type != UNIT_TYPE then
   70:  jump *label144 equal @poly UNIT_TYPE                         ...
   71:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
   72:  ubind @poly                                                  firstUnit = ubind(type);
   73:  set :areUnitsAvailable.1:firstUnit @unit                     ...
   74:  jump *label137 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label132                                              do
   75:  sensor *tmp26 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
   76:  op equal *tmp27 *tmp26 0                                     ...
   77:  sensor *tmp28 @unit @controller                              ...
   78:  op equal *tmp29 *tmp28 @this                                 ...
   79:  op or *tmp30 *tmp27 *tmp29                                   ...
   80:  jump *label133 equal *tmp30 false                            ...
   81:  set *tmp22 true                                              return true;
   82:  jump *label141 always 0 0                                    ...
        label *label133                                              if @unit.@controlled == 0 or @unit.@controller == @this then
   83:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
   84:  ubind @poly                                                  ubind(type);
   85:  op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
   86:  sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead           ...
   87:  op equal *tmp34 *tmp33 0                                     ...
   88:  op land *tmp35 *tmp32 *tmp34                                 ...
   89:  jump *label132 notEqual *tmp35 false                         do
        label *label137                                              if firstUnit != null then
   90:  print "poly occupied: "                                      print($"$type occupied: $occupied");
   91:  print :areUnitsAvailable.1:occupied                          ...
   92:  print "\n"                                                   println();
   93:  set *tmp22 false                                             return false;
        label *label141                                              if areUnitsAvailable(type, true) then
   94:  jump *label142 equal *tmp22 false                            ...
   95:  printflush null                                              printflush(null);
   96:  set *tmp2 @poly                                              return type;
   97:  jump *label42 always 0 0                                     ...
        label *label142                                              if areUnitsAvailable(type, true) then
        label *label144                                              if type != UNIT_TYPE then
   98:  jump *label162 equal @mega UNIT_TYPE                         ...
   99:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
  100:  ubind @mega                                                  firstUnit = ubind(type);
  101:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  102:  jump *label155 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label150                                              do
  103:  sensor *tmp26 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  104:  op equal *tmp27 *tmp26 0                                     ...
  105:  sensor *tmp28 @unit @controller                              ...
  106:  op equal *tmp29 *tmp28 @this                                 ...
  107:  op or *tmp30 *tmp27 *tmp29                                   ...
  108:  jump *label151 equal *tmp30 false                            ...
  109:  set *tmp22 true                                              return true;
  110:  jump *label159 always 0 0                                    ...
        label *label151                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  111:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
  112:  ubind @mega                                                  ubind(type);
  113:  op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
  114:  sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead           ...
  115:  op equal *tmp34 *tmp33 0                                     ...
  116:  op land *tmp35 *tmp32 *tmp34                                 ...
  117:  jump *label150 notEqual *tmp35 false                         do
        label *label155                                              if firstUnit != null then
  118:  print "mega occupied: "                                      print($"$type occupied: $occupied");
  119:  print :areUnitsAvailable.1:occupied                          ...
  120:  print "\n"                                                   println();
  121:  set *tmp22 false                                             return false;
        label *label159                                              if areUnitsAvailable(type, true) then
  122:  jump *label160 equal *tmp22 false                            ...
  123:  printflush null                                              printflush(null);
  124:  set *tmp2 @mega                                              return type;
  125:  jump *label42 always 0 0                                     ...
        label *label160                                              if areUnitsAvailable(type, true) then
        label *label162                                              if type != UNIT_TYPE then
  126:  jump *label180 equal @mono UNIT_TYPE                         ...
  127:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
  128:  ubind @mono                                                  firstUnit = ubind(type);
  129:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  130:  jump *label173 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label168                                              do
  131:  sensor *tmp26 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  132:  op equal *tmp27 *tmp26 0                                     ...
  133:  sensor *tmp28 @unit @controller                              ...
  134:  op equal *tmp29 *tmp28 @this                                 ...
  135:  op or *tmp30 *tmp27 *tmp29                                   ...
  136:  jump *label169 equal *tmp30 false                            ...
  137:  set *tmp22 true                                              return true;
  138:  jump *label177 always 0 0                                    ...
        label *label169                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  139:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
  140:  ubind @mono                                                  ubind(type);
  141:  op notEqual *tmp32 @unit :areUnitsAvailable.1:firstUnit      while @unit != firstUnit and firstUnit.@dead == 0;
  142:  sensor *tmp33 :areUnitsAvailable.1:firstUnit @dead           ...
  143:  op equal *tmp34 *tmp33 0                                     ...
  144:  op land *tmp35 *tmp32 *tmp34                                 ...
  145:  jump *label168 notEqual *tmp35 false                         do
        label *label173                                              if firstUnit != null then
  146:  print "mono occupied: "                                      print($"$type occupied: $occupied");
  147:  print :areUnitsAvailable.1:occupied                          ...
  148:  print "\n"                                                   println();
  149:  set *tmp22 false                                             return false;
        label *label177                                              if areUnitsAvailable(type, true) then
  150:  jump *label178 equal *tmp22 false                            ...
  151:  printflush null                                              printflush(null);
  152:  set *tmp2 @mono                                              return type;
  153:  jump *label42 always 0 0                                     ...
        label *label178                                              if areUnitsAvailable(type, true) then
        label *label180                                              if type != UNIT_TYPE then
  154:  printflush message1                                          printflush(message1);
  155:  jump *label4 always 0 0                                      while true do
        label *label42                                               if currentUnit != null then
  156:  ubind *tmp2                                                  firstUnit = ubind(TYPE);
  157:  set :rebindUnit.0:firstUnit @unit                            ...
  158:  jump __start__ equal :rebindUnit.0:firstUnit null            if firstUnit != null then
        label *label48                                               do
  159:  sensor *tmp51 @unit @controlled                              if @unit.@controlled == 0 then
  160:  jump *label41 equal *tmp51 0                                 ...
  161:  ubind *tmp2                                                  ubind(TYPE);
  162:  op notEqual *tmp54 @unit :rebindUnit.0:firstUnit             while @unit != firstUnit and firstUnit.@dead == 0;
  163:  sensor *tmp55 :rebindUnit.0:firstUnit @dead                  ...
  164:  op equal *tmp56 *tmp55 0                                     ...
  165:  op land *tmp57 *tmp54 *tmp56                                 ...
  166:  jump *label48 notEqual *tmp57 false                          do
  167:  end                                                          end();
        label *label41                                               rebindUnit(currentUnit);
  168:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  169:  set *tmp38 @unit                                             return @unit;
  170:  sensor .UNIT_CAPACITY *tmp38 @itemCapacity                   UNIT_CAPACITY = UNIT.@itemCapacity;
  171:  sensor .SPEED *tmp38 @speed                                  SPEED = UNIT.@speed;
  172:  op div .SPEED_TENTHS .SPEED 10                               SPEED_TENTHS = SPEED / 10;
  173:  print "[gold]Locating core..."                               print("[gold]Locating core...");
  174:  printflush message1                                          printflush(message1);
        label *label53                                               do
  175:  ulocate building core false @copper 0 0 0 .CORE              CORE = ulocate(:building, :core, false);
  176:  jump *label53 equal .CORE null                               do
  177:  sensor .CORE_X .CORE @x                                      CORE_X = CORE.@x;
  178:  sensor .CORE_Y .CORE @y                                      CORE_Y = CORE.@y;
  179:  sensor .VAULT_X .VAULT @x                                    VAULT_X = VAULT.@x;
  180:  sensor .VAULT_Y .VAULT @y                                    VAULT_Y = VAULT.@y;
  181:  op add :unitCheck @time 5000                                 unitCheck = @time + UNIT_CHECK_TIME;
        label *label56                                               while true do
  182:  set :start @time                                             start = @time;
  183:  sensor *tmp72 .VAULT @thorium                                println($"\n[gold]Thorium[] status: [green]$[]", VAULT.sensor(ITEM));
  184:  print " === [gold]Supplying Power Plant[] === \n\n\n[gold]Th ...
  185:  print *tmp72                                                 ...
  186:  print "[]\n"                                                 ...
  187:  sensor *tmp73 .VAULT @thorium                                if VAULT.sensor(ITEM) < 500 then
  188:  jump *label59 greaterThanEq *tmp73 500                       ...
  189:  print "\nUnit type: [green]"                                 println($"\nUnit type: [green]$TYPE[]");
  190:  print *tmp2                                                  ...
  191:  print "[]\n"                                                 ...
  192:  jump *label63 equal *tmp38 null                              if currentUnit != null then
  193:  ubind *tmp38                                                 ubind(currentUnit);
  194:  sensor *tmp80 @unit @dead                                    if @unit.@dead == 0 && @unit.@controller == @this then
  195:  op equal *tmp81 *tmp80 0                                     ...
  196:  sensor *tmp82 @unit @controller                              ...
  197:  op equal *tmp83 *tmp82 @this                                 ...
  198:  op land *tmp84 *tmp81 *tmp83                                 ...
  199:  jump *label62 notEqual *tmp84 false                          ...
        label *label63                                               if currentUnit != null then
  200:  ubind *tmp2                                                  firstUnit = ubind(TYPE);
  201:  set :rebindUnit.1:firstUnit @unit                            ...
  202:  jump __start__ equal :rebindUnit.1:firstUnit null            if firstUnit != null then
        label *label69                                               do
  203:  sensor *tmp89 @unit @controlled                              if @unit.@controlled == 0 then
  204:  jump *label62 equal *tmp89 0                                 ...
  205:  ubind *tmp2                                                  ubind(TYPE);
  206:  op notEqual *tmp92 @unit :rebindUnit.1:firstUnit             while @unit != firstUnit and firstUnit.@dead == 0;
  207:  sensor *tmp93 :rebindUnit.1:firstUnit @dead                  ...
  208:  op equal *tmp94 *tmp93 0                                     ...
  209:  op land *tmp95 *tmp92 *tmp94                                 ...
  210:  jump *label69 notEqual *tmp95 false                          do
  211:  end                                                          end();
        label *label62                                               rebindUnit(unit);
  212:  sensor :processUnit.0:state @unit @flag                      state = @unit.@flag;
  213:  set :processUnit.0:distance -1                               distance = -1;
  214:  op lessThan *tmp97 :processUnit.0:state 2                    if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  215:  op greaterThan *tmp98 :processUnit.0:state 3                 ...
  216:  op or *tmp99 *tmp97 *tmp98                                   ...
  217:  jump *label74 equal *tmp99 false                             ...
  218:  sensor *tmp101 @unit @firstItem                              if @unit.@firstItem == ITEM then
  219:  jump *label76 notEqual *tmp101 @thorium                      ...
  220:  set :processUnit.0:state 3                                   state = S_APPROACH_DST;
  221:  jump *label77 always 0 0                                     if @unit.@firstItem == ITEM then
        label *label76                                               ...
  222:  sensor *tmp104 @unit @totalItems                             elsif @unit.@totalItems == 0 then
  223:  jump *label78 notEqual *tmp104 0                             ...
  224:  set :processUnit.0:state 2                                   state = S_APPROACH_SRC;
  225:  jump *label79 always 0 0                                     elsif @unit.@totalItems == 0 then
        label *label78                                               ...
  226:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  227:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  228:  ucontrol within .CORE_X .CORE_Y 8 *tmp107 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  229:  jump *label80 equal *tmp107 false                            ...
  230:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label80                                               if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label79                                               elsif @unit.@totalItems == 0 then
        label *label77                                               if @unit.@firstItem == ITEM then
        label *label74                                               if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  231:  jump *label82 notEqual :processUnit.0:state 2                if state == S_APPROACH_SRC then
  232:  ucontrol within .CORE_X .CORE_Y 8 *tmp111 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  233:  jump *label84 equal *tmp111 false                            ...
  234:  ucontrol itemTake .CORE @thorium .UNIT_CAPACITY 0 0          itemTake(CORE, ITEM, UNIT_CAPACITY);
  235:  sensor *tmp113 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  236:  jump *label86 lessThan *tmp113 .UNIT_CAPACITY                ...
  237:  ucontrol approach .VAULT_X .VAULT_Y 6 0 0                    approach(VAULT_X, VAULT_Y, RADIUS_APPROACH);
  238:  set :processUnit.0:state 3                                   state = S_APPROACH_DST;
  239:  jump *label85 always 0 0                                     if @unit.@totalItems >= UNIT_CAPACITY then
        label *label86                                               ...
  240:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  241:  jump *label85 always 0 0                                     if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label84                                               ...
  242:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  243:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  244:  sensor *tmp116 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  245:  op sub *tmp117 .CORE_X *tmp116                               ...
  246:  sensor *tmp118 @unit @y                                      ...
  247:  op sub *tmp119 .CORE_Y *tmp118                               ...
  248:  op len *tmp120 *tmp117 *tmp119                               ...
  249:  op idiv *tmp121 *tmp120 .SPEED_TENTHS                        ...
  250:  op div :processUnit.0:distance *tmp121 10                    ...
        label *label85                                               if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label82                                               if state == S_APPROACH_SRC then
  251:  jump *label88 notEqual :processUnit.0:state 3                if state == S_APPROACH_DST then
  252:  ucontrol within .VAULT_X .VAULT_Y 8 *tmp125 0                if within(VAULT_X, VAULT_Y, RADIUS_WITHIN) then
  253:  jump *label90 equal *tmp125 false                            ...
  254:  ucontrol itemDrop .VAULT .UNIT_CAPACITY 0 0 0                itemDrop(VAULT, UNIT_CAPACITY);
  255:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  256:  sensor *tmp127 @unit @totalItems                             if @unit.@totalItems <= 0 then
  257:  jump *label91 greaterThan *tmp127 0                          ...
  258:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  259:  set :processUnit.0:state 2                                   state = S_APPROACH_SRC;
  260:  jump *label91 always 0 0                                     if within(VAULT_X, VAULT_Y, RADIUS_WITHIN) then
        label *label90                                               ...
  261:  ucontrol approach .VAULT_X .VAULT_Y 6 0 0                    approach(VAULT_X, VAULT_Y, RADIUS_APPROACH);
  262:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  263:  sensor *tmp130 @unit @x                                      distance = len(VAULT_X - @unit.@x, VAULT_Y - @unit.@y) \ SPEED_TENTHS / 10;
  264:  op sub *tmp131 .VAULT_X *tmp130                              ...
  265:  sensor *tmp132 @unit @y                                      ...
  266:  op sub *tmp133 .VAULT_Y *tmp132                              ...
  267:  op len *tmp134 *tmp131 *tmp133                               ...
  268:  op idiv *tmp135 *tmp134 .SPEED_TENTHS                        ...
  269:  op div :processUnit.0:distance *tmp135 10                    ...
        label *label91                                               if within(VAULT_X, VAULT_Y, RADIUS_WITHIN) then
        label *label88                                               if state == S_APPROACH_DST then
  270:  ucontrol flag :processUnit.0:state 0 0 0 0                   flag(state);
  271:  sensor *tmp137 @unit @totalItems                             print($"[$color]$[]", @unit.@totalItems);
  272:  print "[gold]"                                               ...
  273:  print *tmp137                                                ...
  274:  print "[]"                                                   ...
  275:  jump *label94 lessThan :processUnit.0:distance 0             if distance >= 0 then
  276:  print .MSG                                                   println($"$MSG$distance[] sec");
  277:  print :processUnit.0:distance                                ...
  278:  print "[] sec\n"                                             ...
  279:  jump *label95 always 0 0                                     if distance >= 0 then
        label *label94                                               ...
  280:  print .MSG                                                   print(MSG);
        label *label95                                               if distance >= 0 then
  281:  op equal *tmp140 :processUnit.0:state 2                      if state == S_APPROACH_SRC and VAULT.sensor(ITEM) >= 500 then
  282:  sensor *tmp141 .VAULT @thorium                               ...
  283:  op greaterThanEq *tmp142 *tmp141 500                         ...
  284:  op land *tmp143 *tmp140 *tmp142                              ...
  285:  jump *label96 equal *tmp143 false                            ...
  286:  ucontrol unbind 0 0 0 0 0                                    unbind();
  287:  jump *label97 always 0 0                                     if state == S_APPROACH_SRC and VAULT.sensor(ITEM) >= 500 then
        label *label96                                               ...
  288:  op notEqual *tmp145 *tmp2 UNIT_TYPE                          elsif TYPE != UNIT_TYPE and unitCheck > @time then
  289:  op greaterThan *tmp146 :unitCheck @time                      ...
  290:  op land *tmp147 *tmp145 *tmp146                              ...
  291:  jump *label98 equal *tmp147 false                            ...
  292:  set :areUnitsAvailable.2:occupied 0                          occupied = 0;
  293:  ubind UNIT_TYPE                                              firstUnit = ubind(type);
  294:  set :areUnitsAvailable.2:firstUnit @unit                     ...
  295:  jump *label108 equal :areUnitsAvailable.2:firstUnit null     if firstUnit != null then
        label *label103                                              do
  296:  sensor *tmp153 @unit @controlled                             if @unit.@controlled == 0 or @unit.@controller == @this then
  297:  op equal *tmp154 *tmp153 0                                   ...
  298:  sensor *tmp155 @unit @controller                             ...
  299:  op equal *tmp156 *tmp155 @this                               ...
  300:  op or *tmp157 *tmp154 *tmp156                                ...
  301:  jump *label106 equal *tmp157 false                           ...
  302:  set *tmp149 true                                             return true;
  303:  jump *label100 always 0 0                                    ...
        label *label106                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  304:  op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:oc occupied += 1;
  305:  ubind UNIT_TYPE                                              ubind(type);
  306:  op notEqual *tmp159 @unit :areUnitsAvailable.2:firstUnit     while @unit != firstUnit and firstUnit.@dead == 0;
  307:  sensor *tmp160 :areUnitsAvailable.2:firstUnit @dead          ...
  308:  op equal *tmp161 *tmp160 0                                   ...
  309:  op land *tmp162 *tmp159 *tmp161                              ...
  310:  jump *label103 notEqual *tmp162 false                        do
        label *label108                                              if output then
  311:  set *tmp149 false                                            return false;
        label *label100                                              if areUnitsAvailable(UNIT_TYPE, false) then
  312:  jump *label110 equal *tmp149 false                           ...
  313:  end                                                          end();
        label *label110                                              if areUnitsAvailable(UNIT_TYPE, false) then
  314:  op add :unitCheck @time 5000                                 unitCheck = @time + UNIT_CHECK_TIME;
        label *label98                                               elsif TYPE != UNIT_TYPE and unitCheck > @time then
        label *label97                                               if state == S_APPROACH_SRC and VAULT.sensor(ITEM) >= 500 then
        label *label59                                               if VAULT.sensor(ITEM) < 500 then
  315:  op sub *tmp166 @time :start                                  print($"\n[lightgray]Loop time: $ ms", floor(@time - start));
  316:  op floor *tmp167 *tmp166 0                                   ...
  317:  print "\n[lightgray]Loop time: "                             ...
  318:  print *tmp167                                                ...
  319:  print " ms"                                                  ...
  320:  printflush message1                                          printflush(message1);
  321:  jump *label56 always 0 0                                     while true do


Performance: parsed in 208 ms, compiled in 194 ms, optimized in 457 ms, run in 11 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (6 steps):
The program didn't generate any output.
Execution exception at instruction 8: sensor *tmp0 vault1 @dead:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
