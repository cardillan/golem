   477 instructions before optimizations.
    20 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
    73 instructions eliminated by Dead Code Elimination (7 iterations).
     7 instructions eliminated by Jump Normalization (2 passes, 5 iterations).
    42 instructions eliminated by Condition Optimization (6 iterations).
    37 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
    33 instructions eliminated by Data Flow Optimization (4 passes, 12 iterations).
     1 instructions added by Loop Rotation (3 iterations).
       1 loop conditions were partially rotated.
    79 instructions added by Loop Unrolling (5 iterations).
     1 loops unrolled by Loop Unrolling.
    12 instructions eliminated by Jump Straightening (2 passes, 7 iterations).
    13 instructions updated by Jump Threading.
    16 instructions eliminated by Unreachable Code Elimination (2 iterations).
    26 instructions eliminated by Print Merging.
   291 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 719):
  * Partial loop rotation at line 30:1                           size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Unroll iteration loop at line 93:9                           size  +101, benefit      375.0, efficiency      3.713

Pass 1: speed optimization selection (cost limit 718):
  * Unroll iteration loop at line 93:9                           size  +101, benefit      375.0, efficiency      3.713 (+75 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-49 instructions):
 
    38 label *label17
    39 set *tmp3 true
    40 jump *label9 always
-    * set *tmp11 null
    41 jump *label16 always
    42 label *label15
    43 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
-    * set *tmp11 :areUnitsAvailable:occupied
    44 label *label16
    45 ubind :areUnitsAvailable:type
    46 label *label13
 
    52 jump *label14 equal *tmp14 false
    53 jump *label12 always
    54 label *label14
-    * set *tmp6 null
    55 jump *label11 always
    56 label *label10
-    * set *tmp6 null
    57 label *label11
    58 jump *label20 equal :areUnitsAvailable:output false
    59 print :areUnitsAvailable:type
 
    61 print "occupied: "
    62 print :areUnitsAvailable:occupied
    63 print "\n"
-    * set *tmp15 null
    64 jump *label21 always
    65 label *label20
-    * set *tmp15 null
    66 label *label21
    67 set *tmp3 false
    68 jump *label9 always
 
    71 jump *label7 equal *tmp3 false
    72 set *tmp2 UNIT_TYPE
    73 jump *label3 always
-    * set *tmp16 null
    74 jump *label8 always
    75 label *label7
-    * set *tmp16 null
    76 label *label8
    77 set :chooseUnitType:type @flare
    78 setaddr *tmp17 *label25
 
   111 label *label41
   112 set *tmp20 true
   113 jump *label33 always
-    * set *tmp28 null
   114 jump *label40 always
   115 label *label39
   116 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp28 :areUnitsAvailable.1:occupied
   117 label *label40
   118 ubind :areUnitsAvailable.1:type
   119 label *label37
 
   125 jump *label38 equal *tmp31 false
   126 jump *label36 always
   127 label *label38
-    * set *tmp23 null
   128 jump *label35 always
   129 label *label34
-    * set *tmp23 null
   130 label *label35
   131 jump *label44 equal :areUnitsAvailable.1:output false
   132 print :areUnitsAvailable.1:type
 
   134 print "occupied: "
   135 print :areUnitsAvailable.1:occupied
   136 print "\n"
-    * set *tmp32 null
   137 jump *label45 always
   138 label *label44
-    * set *tmp32 null
   139 label *label45
   140 set *tmp20 false
   141 jump *label33 always
 
   150 label *label31
   151 set *tmp33 null
   152 label *label32
-    * set *tmp19 *tmp33
   153 jump *label30 always
   154 label *label29
-    * set *tmp19 null
   155 label *label30
   156 label *label23
   157 multijump *tmp17 0 0 (m:marker0)
 
   175 op equal *tmp41 *tmp40 @this
   176 op land *tmp42 *tmp39 *tmp41
   177 jump *label50 equal *tmp42 false
-    * set *tmp35 :rebindUnit:currentUnit
   178 jump *label47 always
   179 set *tmp43 null
   180 jump *label51 always
   181 label *label50
   182 set *tmp43 null
   183 label *label51
-    * set *tmp37 *tmp43
   184 jump *label49 always
   185 label *label48
-    * set *tmp37 null
   186 label *label49
   187 ubind .TYPE
   188 set *tmp44 @unit
 
   193 sensor *tmp47 @unit @controlled
   194 op equal *tmp48 *tmp47 0
   195 jump *label57 equal *tmp48 false
-    * set *tmp35 @unit
   196 jump *label47 always
-    * set *tmp49 null
   197 jump *label58 always
   198 label *label57
-    * set *tmp49 null
   199 label *label58
   200 ubind .TYPE
   201 label *label55
 
   207 jump *label56 equal *tmp52 false
   208 jump *label54 always
   209 label *label56
-    * set *tmp46 null
   210 jump *label53 always
   211 label *label52
-    * set *tmp46 null
   212 label *label53
   213 end
-    * set *tmp35 null
   214 label *label47
   215 ucontrol flag 1
   216 set *tmp34 @unit
 
   284 label *label72
   285 set *tmp80 null
   286 label *label73
-    * set *tmp74 *tmp80
   287 jump *label71 always
   288 label *label70
-    * set *tmp74 null
   289 label *label71
   290 ubind .TYPE
   291 set *tmp81 @unit
 
   298 jump *label79 equal *tmp85 false
   299 set *tmp72 @unit
   300 jump *label69 always
-    * set *tmp86 null
   301 jump *label80 always
   302 label *label79
-    * set *tmp86 null
   303 label *label80
   304 ubind .TYPE
   305 label *label77
 
   311 jump *label78 equal *tmp89 false
   312 jump *label76 always
   313 label *label78
-    * set *tmp83 null
   314 jump *label75 always
   315 label *label74
-    * set *tmp83 null
   316 label *label75
   317 end
   318 set *tmp72 null
 
   357 label *label89
   358 set *tmp96 *tmp99
   359 label *label87
-    * set *tmp93 *tmp96
   360 jump *label83 always
   361 label *label82
-    * set *tmp93 null
   362 label *label83
   363 op equal *tmp102 :processUnit:state 2
   364 jump *label92 equal *tmp102 false
 
   391 set :processUnit:distance *tmp115
   392 set *tmp105 :processUnit:distance
   393 label *label95
-    * set *tmp103 *tmp105
   394 jump *label93 always
   395 label *label92
-    * set *tmp103 null
   396 label *label93
   397 op equal *tmp116 :processUnit:state 3
   398 jump *label98 equal *tmp116 false
 
   425 set :processUnit:distance *tmp129
   426 set *tmp119 :processUnit:distance
   427 label *label101
-    * set *tmp117 *tmp119
   428 jump *label99 always
   429 label *label98
-    * set *tmp117 null
   430 label *label99
   431 ucontrol flag :processUnit:state
   432 sensor *tmp130 @unit @totalItems
 
   443 print "["
   444 print "] sec"
   445 print "\n"
-    * set *tmp132 null
   446 jump *label105 always
   447 label *label104
   448 print .MSG
-    * set *tmp132 .MSG
   449 label *label105
   450 set *tmp71 @unit
   451 jump *label68 always
 
   492 label *label124
   493 set *tmp140 true
   494 jump *label116 always
-    * set *tmp148 null
   495 jump *label123 always
   496 label *label122
   497 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp148 :areUnitsAvailable.2:occupied
   498 label *label123
   499 ubind :areUnitsAvailable.2:type
   500 label *label120
 
   506 jump *label121 equal *tmp151 false
   507 jump *label119 always
   508 label *label121
-    * set *tmp143 null
   509 jump *label118 always
   510 label *label117
-    * set *tmp143 null
   511 label *label118
   512 jump *label127 equal :areUnitsAvailable.2:output false
   513 print :areUnitsAvailable.2:type
 
   515 print "occupied: "
   516 print :areUnitsAvailable.2:occupied
   517 print "\n"
-    * set *tmp152 null
   518 jump *label128 always
   519 label *label127
-    * set *tmp152 null
   520 label *label128
   521 set *tmp140 false
   522 jump *label116 always
 
   524 label *label116
   525 jump *label114 equal *tmp140 false
   526 end
-    * set *tmp153 null
   527 jump *label115 always
   528 label *label114
-    * set *tmp153 null
   529 label *label115
   530 op add *tmp154 @time 5000
   531 set :unitCheck *tmp154
 
   536 label *label111
   537 set *tmp136 *tmp139
   538 label *label107
-    * set *tmp70 *tmp136
   539 jump *label67 always
   540 label *label66
-    * set *tmp70 null
   541 label *label67
   542 op sub *tmp155 @time :start
   543 op floor *tmp156 *tmp155

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-14 instructions):
 
   145 printflush null
   146 set *tmp2 :chooseUnitType:type
   147 jump *label3 always
-    * set *tmp33 null
   148 jump *label32 always
   149 label *label31
-    * set *tmp33 null
   150 label *label32
   151 jump *label30 always
   152 label *label29
 
   174 op land *tmp42 *tmp39 *tmp41
   175 jump *label50 equal *tmp42 false
   176 jump *label47 always
-    * set *tmp43 null
   177 jump *label51 always
   178 label *label50
-    * set *tmp43 null
   179 label *label51
   180 jump *label49 always
   181 label *label48
 
   275 jump *label72 equal *tmp79 false
   276 set *tmp72 :rebindUnit.1:currentUnit
   277 jump *label69 always
-    * set *tmp80 null
   278 jump *label73 always
   279 label *label72
-    * set *tmp80 null
   280 label *label73
   281 jump *label71 always
   282 label *label70
 
   327 op equal *tmp95 *tmp94 .ITEM
   328 jump *label86 equal *tmp95 false
   329 set :processUnit:state 3
-    * set *tmp96 :processUnit:state
   330 jump *label87 always
   331 label *label86
   332 sensor *tmp97 @unit @totalItems
 
   348 label *label91
   349 set *tmp99 *tmp101
   350 label *label89
-    * set *tmp96 *tmp99
   351 label *label87
   352 jump *label83 always
   353 label *label82
 
   368 set .MSG ", loading\n"
   369 set *tmp108 .MSG
   370 label *label97
-    * set *tmp105 *tmp108
   371 jump *label95 always
   372 label *label94
   373 ucontrol approach .CORE_X .CORE_Y 6
 
   380 op idiv *tmp114 *tmp113 .SPEED_TENTHS
   381 op div *tmp115 *tmp114 10
   382 set :processUnit:distance *tmp115
-    * set *tmp105 :processUnit:distance
   383 label *label95
   384 jump *label93 always
   385 label *label92
 
   400 label *label102
   401 set *tmp122 null
   402 label *label103
-    * set *tmp119 *tmp122
   403 jump *label101 always
   404 label *label100
   405 ucontrol approach .VAULT_X .VAULT_Y 6
 
   412 op idiv *tmp128 *tmp127 .SPEED_TENTHS
   413 op div *tmp129 *tmp128 10
   414 set :processUnit:distance *tmp129
-    * set *tmp119 :processUnit:distance
   415 label *label101
   416 jump *label99 always
   417 label *label98
 
   450 jump *label108 always
   451 label *label108
   452 ucontrol unbind
-    * set *tmp136 null
   453 jump *label107 always
   454 label *label106
   455 op notEqual *tmp137 .TYPE UNIT_TYPE
 
   521 label *label110
   522 set *tmp139 null
   523 label *label111
-    * set *tmp136 *tmp139
   524 label *label107
   525 jump *label67 always
   526 label *label66

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-8 instructions):
 
   333 op equal *tmp98 *tmp97 0
   334 jump *label88 equal *tmp98 false
   335 set :processUnit:state 2
-    * set *tmp99 :processUnit:state
   336 jump *label89 always
   337 label *label88
   338 set .MSG ", initializing\n"
 
   345 label *label90
   346 set *tmp101 null
   347 label *label91
-    * set *tmp99 *tmp101
   348 label *label89
   349 label *label87
   350 jump *label83 always
 
   360 jump *label96 equal *tmp107 false
   361 ucontrol approach .VAULT_X .VAULT_Y 6
   362 set :processUnit:state 3
-    * set *tmp108 :processUnit:state
   363 jump *label97 always
   364 label *label96
   365 set .MSG ", loading\n"
-    * set *tmp108 .MSG
   366 label *label97
   367 jump *label95 always
   368 label *label94
 
   391 jump *label102 equal *tmp121 false
   392 ucontrol approach .CORE_X .CORE_Y 6
   393 set :processUnit:state 2
-    * set *tmp122 :processUnit:state
   394 jump *label103 always
   395 label *label102
-    * set *tmp122 null
   396 label *label103
   397 jump *label101 always
   398 label *label100
 
   510 label *label115
   511 op add *tmp154 @time 5000
   512 set :unitCheck *tmp154
-    * set *tmp139 :unitCheck
   513 jump *label111 always
   514 label *label110
-    * set *tmp139 null
   515 label *label111
   516 label *label107
   517 jump *label67 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   340 ucontrol within .CORE_X .CORE_Y 8 *tmp100
   341 jump *label90 equal *tmp100 false
   342 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp101 null
   343 jump *label91 always
   344 label *label90
-    * set *tmp101 null
   345 label *label91
   346 label *label89
   347 label *label87

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-19 instructions):
 
    22 set :areUnitsAvailable:output true
    23 set :areUnitsAvailable:occupied 0
    24 ubind :areUnitsAvailable:type
-    * set *tmp4 @unit
-    * set :areUnitsAvailable:firstUnit *tmp4
+   25 set :areUnitsAvailable:firstUnit @unit
    26 op notEqual *tmp5 :areUnitsAvailable:firstUnit null
    27 jump *label10 equal *tmp5 false
    28 label *label12
 
    94 set :areUnitsAvailable.1:output true
    95 set :areUnitsAvailable.1:occupied 0
    96 ubind :areUnitsAvailable.1:type
-    * set *tmp21 @unit
-    * set :areUnitsAvailable.1:firstUnit *tmp21
+   97 set :areUnitsAvailable.1:firstUnit @unit
    98 op notEqual *tmp22 :areUnitsAvailable.1:firstUnit null
    99 jump *label34 equal *tmp22 false
   100 label *label36
 
   179 label *label48
   180 label *label49
   181 ubind .TYPE
-    * set *tmp44 @unit
-    * set :rebindUnit:firstUnit *tmp44
+  182 set :rebindUnit:firstUnit @unit
   183 op notEqual *tmp45 :rebindUnit:firstUnit null
   184 jump *label52 equal *tmp45 false
   185 label *label54
 
   211 set *tmp34 null
   212 label *label46
   213 set .UNIT *tmp34
-    * sensor *tmp53 .UNIT @itemCapacity
-    * set .UNIT_CAPACITY *tmp53
-    * sensor *tmp54 .UNIT @speed
-    * set .SPEED *tmp54
-    * op div *tmp55 .SPEED 10
-    * set .SPEED_TENTHS *tmp55
+  214 sensor .UNIT_CAPACITY .UNIT @itemCapacity
+  215 sensor .SPEED .UNIT @speed
+  216 op div .SPEED_TENTHS .SPEED 10
   217 print "[gold]Locating core..."
   218 printflush message1
   219 label *label60
-    * ulocate building core false @copper *tmp57 *tmp58 *tmp59 *tmp56
-    * set .CORE *tmp56
+  220 ulocate building core false @copper *tmp57 *tmp58 *tmp59 .CORE
   221 label *label61
   222 op equal *tmp60 .CORE null
   223 jump *label60 notEqual *tmp60 false
   224 label *label62
-    * sensor *tmp61 .CORE @x
-    * set .CORE_X *tmp61
-    * sensor *tmp62 .CORE @y
-    * set .CORE_Y *tmp62
-    * sensor *tmp63 .VAULT @x
-    * set .VAULT_X *tmp63
-    * sensor *tmp64 .VAULT @y
-    * set .VAULT_Y *tmp64
-    * op add *tmp65 @time 5000
-    * set :unitCheck *tmp65
+  225 sensor .CORE_X .CORE @x
+  226 sensor .CORE_Y .CORE @y
+  227 sensor .VAULT_X .VAULT @x
+  228 sensor .VAULT_Y .VAULT @y
+  229 op add :unitCheck @time 5000
   230 label *label63
   231 jump *label65 equal true false
-    * set *tmp66 @time
-    * set :start *tmp66
+  232 set :start @time
   233 print " === [gold]Supplying Power Plant[] === "
   234 print "\n"
   235 print "\n"
 
   269 label *label70
   270 label *label71
   271 ubind .TYPE
-    * set *tmp81 @unit
-    * set :rebindUnit.1:firstUnit *tmp81
+  272 set :rebindUnit.1:firstUnit @unit
   273 op notEqual *tmp82 :rebindUnit.1:firstUnit null
   274 jump *label74 equal *tmp82 false
   275 label *label76
 
   298 set *tmp72 null
   299 label *label69
   300 set :processUnit:unit *tmp72
-    * sensor *tmp90 @unit @flag
-    * set :processUnit:state *tmp90
+  301 sensor :processUnit:state @unit @flag
   302 set :processUnit:distance -1
   303 set :processUnit:color "gold"
   304 op lessThan *tmp91 :processUnit:state 2
 
   357 op sub *tmp112 .CORE_Y *tmp111
   358 op len *tmp113 *tmp110 *tmp112
   359 op idiv *tmp114 *tmp113 .SPEED_TENTHS
-    * op div *tmp115 *tmp114 10
-    * set :processUnit:distance *tmp115
+  360 op div :processUnit:distance *tmp114 10
   361 label *label95
   362 jump *label93 always
   363 label *label92
 
   386 op sub *tmp126 .VAULT_Y *tmp125
   387 op len *tmp127 *tmp124 *tmp126
   388 op idiv *tmp128 *tmp127 .SPEED_TENTHS
-    * op div *tmp129 *tmp128 10
-    * set :processUnit:distance *tmp129
+  389 op div :processUnit:distance *tmp128 10
   390 label *label101
   391 jump *label99 always
   392 label *label98
 
   438 set :areUnitsAvailable.2:output false
   439 set :areUnitsAvailable.2:occupied 0
   440 ubind :areUnitsAvailable.2:type
-    * set *tmp141 @unit
-    * set :areUnitsAvailable.2:firstUnit *tmp141
+  441 set :areUnitsAvailable.2:firstUnit @unit
   442 op notEqual *tmp142 :areUnitsAvailable.2:firstUnit null
   443 jump *label117 equal *tmp142 false
   444 label *label119
 
   488 jump *label115 always
   489 label *label114
   490 label *label115
-    * op add *tmp154 @time 5000
-    * set :unitCheck *tmp154
+  491 op add :unitCheck @time 5000
   492 jump *label111 always
   493 label *label110
   494 label *label111

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    14 jump *label0 always
    15 label *label2
    16 label *label4
-    * jump *label6 equal true false
    17 printflush null
    18 print "[gold]Looking for suitable unit type:[]"
    19 print "\n"
 
   227 sensor .VAULT_Y .VAULT @y
   228 op add :unitCheck @time 5000
   229 label *label63
-    * jump *label65 equal true false
   230 set :start @time
   231 print " === [gold]Supplying Power Plant[] === "
   232 print "\n"

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-9 instructions):
 
    31 label *label18
    32 sensor *tmp9 @unit @controller
    33 op equal *tmp10 *tmp9 @this
-    * jump *label17 notEqual *tmp10 false
-    * jump *label15 always
+   34 jump *label15 equal *tmp10 false
    35 label *label17
    36 set *tmp3 true
    37 jump *label9 always
 
    46 label *label19
    47 sensor *tmp13 :areUnitsAvailable:firstUnit @dead
    48 op equal *tmp14 *tmp13 0
-    * jump *label14 equal *tmp14 false
-    * jump *label12 always
+   49 jump *label12 notEqual *tmp14 false
    50 label *label14
    51 jump *label11 always
    52 label *label10
 
   101 label *label42
   102 sensor *tmp26 @unit @controller
   103 op equal *tmp27 *tmp26 @this
-    * jump *label41 notEqual *tmp27 false
-    * jump *label39 always
+  104 jump *label39 equal *tmp27 false
   105 label *label41
   106 set *tmp20 true
   107 jump *label33 always
 
   116 label *label43
   117 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
   118 op equal *tmp31 *tmp30 0
-    * jump *label38 equal *tmp31 false
-    * jump *label36 always
+  119 jump *label36 notEqual *tmp31 false
   120 label *label38
   121 jump *label35 always
   122 label *label34
 
   192 label *label59
   193 sensor *tmp51 :rebindUnit:firstUnit @dead
   194 op equal *tmp52 *tmp51 0
-    * jump *label56 equal *tmp52 false
-    * jump *label54 always
+  195 jump *label54 notEqual *tmp52 false
   196 label *label56
   197 jump *label53 always
   198 label *label52
 
   281 label *label81
   282 sensor *tmp88 :rebindUnit.1:firstUnit @dead
   283 op equal *tmp89 *tmp88 0
-    * jump *label78 equal *tmp89 false
-    * jump *label76 always
+  284 jump *label76 notEqual *tmp89 false
   285 label *label78
   286 jump *label75 always
   287 label *label74
 
   297 jump *label84 notEqual *tmp91 false
   298 label *label85
   299 op greaterThan *tmp92 :processUnit:state 3
-    * jump *label84 notEqual *tmp92 false
-    * jump *label82 always
+  300 jump *label82 equal *tmp92 false
   301 label *label84
   302 sensor *tmp94 @unit @firstItem
   303 op equal *tmp95 *tmp94 .ITEM
 
   439 label *label125
   440 sensor *tmp146 @unit @controller
   441 op equal *tmp147 *tmp146 @this
-    * jump *label124 notEqual *tmp147 false
-    * jump *label122 always
+  442 jump *label122 equal *tmp147 false
   443 label *label124
   444 set *tmp140 true
   445 jump *label116 always
 
   454 label *label126
   455 sensor *tmp150 :areUnitsAvailable.2:firstUnit @dead
   456 op equal *tmp151 *tmp150 0
-    * jump *label121 equal *tmp151 false
-    * jump *label119 always
+  457 jump *label119 notEqual *tmp151 false
   458 label *label121
   459 jump *label118 always
   460 label *label117

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-42 instructions):
 
     7 set .VAULT vault1
     8 label *label0
     9 sensor *tmp0 .VAULT @dead
-    * op notEqual *tmp1 *tmp0 0
-    * jump *label2 equal *tmp1 false
+   10 jump *label2 equal *tmp0 0
    11 set .VAULT vault1
    12 label *label1
    13 jump *label0 always
 
    21 set :areUnitsAvailable:occupied 0
    22 ubind :areUnitsAvailable:type
    23 set :areUnitsAvailable:firstUnit @unit
-    * op notEqual *tmp5 :areUnitsAvailable:firstUnit null
-    * jump *label10 equal *tmp5 false
+   24 jump *label10 equal :areUnitsAvailable:firstUnit null
    25 label *label12
    26 sensor *tmp7 @unit @controlled
-    * op equal *tmp8 *tmp7 0
-    * jump *label17 notEqual *tmp8 false
+   27 jump *label17 equal *tmp7 0
    28 label *label18
    29 sensor *tmp9 @unit @controller
-    * op equal *tmp10 *tmp9 @this
-    * jump *label15 equal *tmp10 false
+   30 jump *label15 notEqual *tmp9 @this
    31 label *label17
    32 set *tmp3 true
    33 jump *label9 always
 
    37 label *label16
    38 ubind :areUnitsAvailable:type
    39 label *label13
-    * op notEqual *tmp12 @unit :areUnitsAvailable:firstUnit
-    * jump *label14 equal *tmp12 false
+   40 jump *label14 equal @unit :areUnitsAvailable:firstUnit
    41 label *label19
    42 sensor *tmp13 :areUnitsAvailable:firstUnit @dead
-    * op equal *tmp14 *tmp13 0
-    * jump *label12 notEqual *tmp14 false
+   43 jump *label12 equal *tmp13 0
    44 label *label14
    45 jump *label11 always
    46 label *label10
 
    79 set :chooseUnitType:type @mono
    80 setaddr *tmp17 *label28
    81 label *label22
-    * op notEqual *tmp18 :chooseUnitType:type UNIT_TYPE
-    * jump *label29 equal *tmp18 false
+   82 jump *label29 equal :chooseUnitType:type UNIT_TYPE
    83 set :areUnitsAvailable.1:type :chooseUnitType:type
    84 set :areUnitsAvailable.1:output true
    85 set :areUnitsAvailable.1:occupied 0
    86 ubind :areUnitsAvailable.1:type
    87 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp22 :areUnitsAvailable.1:firstUnit null
-    * jump *label34 equal *tmp22 false
+   88 jump *label34 equal :areUnitsAvailable.1:firstUnit null
    89 label *label36
    90 sensor *tmp24 @unit @controlled
-    * op equal *tmp25 *tmp24 0
-    * jump *label41 notEqual *tmp25 false
+   91 jump *label41 equal *tmp24 0
    92 label *label42
    93 sensor *tmp26 @unit @controller
-    * op equal *tmp27 *tmp26 @this
-    * jump *label39 equal *tmp27 false
+   94 jump *label39 notEqual *tmp26 @this
    95 label *label41
    96 set *tmp20 true
    97 jump *label33 always
 
   101 label *label40
   102 ubind :areUnitsAvailable.1:type
   103 label *label37
-    * op notEqual *tmp29 @unit :areUnitsAvailable.1:firstUnit
-    * jump *label38 equal *tmp29 false
+  104 jump *label38 equal @unit :areUnitsAvailable.1:firstUnit
   105 label *label43
   106 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp31 *tmp30 0
-    * jump *label36 notEqual *tmp31 false
+  107 jump *label36 equal *tmp30 0
   108 label *label38
   109 jump *label35 always
   110 label *label34
 
   145 set .TYPE *tmp2
   146 set :acquireUnit:currentUnit .UNIT
   147 set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * op notEqual *tmp36 :rebindUnit:currentUnit null
-    * jump *label48 equal *tmp36 false
+  148 jump *label48 equal :rebindUnit:currentUnit null
   149 ubind :rebindUnit:currentUnit
   150 sensor *tmp38 @unit @dead
   151 op equal *tmp39 *tmp38 0
 
   162 label *label49
   163 ubind .TYPE
   164 set :rebindUnit:firstUnit @unit
-    * op notEqual *tmp45 :rebindUnit:firstUnit null
-    * jump *label52 equal *tmp45 false
+  165 jump *label52 equal :rebindUnit:firstUnit null
   166 label *label54
   167 sensor *tmp47 @unit @controlled
-    * op equal *tmp48 *tmp47 0
-    * jump *label57 equal *tmp48 false
+  168 jump *label57 notEqual *tmp47 0
   169 jump *label47 always
   170 jump *label58 always
   171 label *label57
   172 label *label58
   173 ubind .TYPE
   174 label *label55
-    * op notEqual *tmp50 @unit :rebindUnit:firstUnit
-    * jump *label56 equal *tmp50 false
+  175 jump *label56 equal @unit :rebindUnit:firstUnit
   176 label *label59
   177 sensor *tmp51 :rebindUnit:firstUnit @dead
-    * op equal *tmp52 *tmp51 0
-    * jump *label54 notEqual *tmp52 false
+  178 jump *label54 equal *tmp51 0
   179 label *label56
   180 jump *label53 always
   181 label *label52
 
   196 label *label60
   197 ulocate building core false @copper *tmp57 *tmp58 *tmp59 .CORE
   198 label *label61
-    * op equal *tmp60 .CORE null
-    * jump *label60 notEqual *tmp60 false
+  199 jump *label60 equal .CORE null
   200 label *label62
   201 sensor .CORE_X .CORE @x
   202 sensor .CORE_Y .CORE @y
 
   216 print "]"
   217 print "\n"
   218 sensor *tmp68 .VAULT .ITEM
-    * op lessThan *tmp69 *tmp68 500
-    * jump *label66 equal *tmp69 false
+  219 jump *label66 greaterThanEq *tmp68 500
   220 print "\n"
   221 print "Unit type: [green]"
   222 print .TYPE
 
   225 print "\n"
   226 set :processUnit:unit .UNIT
   227 set :rebindUnit.1:currentUnit :processUnit:unit
-    * op notEqual *tmp73 :rebindUnit.1:currentUnit null
-    * jump *label70 equal *tmp73 false
+  228 jump *label70 equal :rebindUnit.1:currentUnit null
   229 ubind :rebindUnit.1:currentUnit
   230 sensor *tmp75 @unit @dead
   231 op equal *tmp76 *tmp75 0
 
   243 label *label71
   244 ubind .TYPE
   245 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp82 :rebindUnit.1:firstUnit null
-    * jump *label74 equal *tmp82 false
+  246 jump *label74 equal :rebindUnit.1:firstUnit null
   247 label *label76
   248 sensor *tmp84 @unit @controlled
-    * op equal *tmp85 *tmp84 0
-    * jump *label79 equal *tmp85 false
+  249 jump *label79 notEqual *tmp84 0
   250 set *tmp72 @unit
   251 jump *label69 always
   252 jump *label80 always
 
   254 label *label80
   255 ubind .TYPE
   256 label *label77
-    * op notEqual *tmp87 @unit :rebindUnit.1:firstUnit
-    * jump *label78 equal *tmp87 false
+  257 jump *label78 equal @unit :rebindUnit.1:firstUnit
   258 label *label81
   259 sensor *tmp88 :rebindUnit.1:firstUnit @dead
-    * op equal *tmp89 *tmp88 0
-    * jump *label76 notEqual *tmp89 false
+  260 jump *label76 equal *tmp88 0
   261 label *label78
   262 jump *label75 always
   263 label *label74
 
   269 sensor :processUnit:state @unit @flag
   270 set :processUnit:distance -1
   271 set :processUnit:color "gold"
-    * op lessThan *tmp91 :processUnit:state 2
-    * jump *label84 notEqual *tmp91 false
+  272 jump *label84 lessThan :processUnit:state 2
   273 label *label85
-    * op greaterThan *tmp92 :processUnit:state 3
-    * jump *label82 equal *tmp92 false
+  274 jump *label82 lessThanEq :processUnit:state 3
   275 label *label84
   276 sensor *tmp94 @unit @firstItem
-    * op equal *tmp95 *tmp94 .ITEM
-    * jump *label86 equal *tmp95 false
+  277 jump *label86 notEqual *tmp94 .ITEM
   278 set :processUnit:state 3
   279 jump *label87 always
   280 label *label86
   281 sensor *tmp97 @unit @totalItems
-    * op equal *tmp98 *tmp97 0
-    * jump *label88 equal *tmp98 false
+  282 jump *label88 notEqual *tmp97 0
   283 set :processUnit:state 2
   284 jump *label89 always
   285 label *label88
 
   296 jump *label83 always
   297 label *label82
   298 label *label83
-    * op equal *tmp102 :processUnit:state 2
-    * jump *label92 equal *tmp102 false
+  299 jump *label92 notEqual :processUnit:state 2
   300 ucontrol within .CORE_X .CORE_Y 8 *tmp104
   301 jump *label94 equal *tmp104 false
   302 ucontrol itemTake .CORE .ITEM .UNIT_CAPACITY
   303 sensor *tmp106 @unit @totalItems
-    * op greaterThanEq *tmp107 *tmp106 .UNIT_CAPACITY
-    * jump *label96 equal *tmp107 false
+  304 jump *label96 lessThan *tmp106 .UNIT_CAPACITY
   305 ucontrol approach .VAULT_X .VAULT_Y 6
   306 set :processUnit:state 3
   307 jump *label97 always
 
   323 jump *label93 always
   324 label *label92
   325 label *label93
-    * op equal *tmp116 :processUnit:state 3
-    * jump *label98 equal *tmp116 false
+  326 jump *label98 notEqual :processUnit:state 3
   327 ucontrol within .VAULT_X .VAULT_Y 8 *tmp118
   328 jump *label100 equal *tmp118 false
   329 ucontrol itemDrop .VAULT .UNIT_CAPACITY
   330 set .MSG ", supplying\n"
   331 sensor *tmp120 @unit @totalItems
-    * op lessThanEq *tmp121 *tmp120 0
-    * jump *label102 equal *tmp121 false
+  332 jump *label102 greaterThan *tmp120 0
   333 ucontrol approach .CORE_X .CORE_Y 6
   334 set :processUnit:state 2
   335 jump *label103 always
 
   358 print *tmp130
   359 print "["
   360 print "]"
-    * op greaterThanEq *tmp131 :processUnit:distance 0
-    * jump *label104 equal *tmp131 false
+  361 jump *label104 lessThan :processUnit:distance 0
   362 print .MSG
   363 print :processUnit:distance
   364 print "["
 
   374 label *label68
   375 set :state :processUnit:state
   376 set .UNIT *tmp71
-    * op equal *tmp133 :state 2
-    * jump *label106 equal *tmp133 false
+  377 jump *label106 notEqual :state 2
   378 label *label109
   379 sensor *tmp134 .VAULT .ITEM
-    * op greaterThanEq *tmp135 *tmp134 500
-    * jump *label106 equal *tmp135 false
+  380 jump *label106 lessThan *tmp134 500
   381 jump *label108 always
   382 label *label108
   383 ucontrol unbind
   384 jump *label107 always
   385 label *label106
-    * op notEqual *tmp137 .TYPE UNIT_TYPE
-    * jump *label110 equal *tmp137 false
+  386 jump *label110 equal .TYPE UNIT_TYPE
   387 label *label113
-    * op greaterThan *tmp138 :unitCheck @time
-    * jump *label110 equal *tmp138 false
+  388 jump *label110 lessThanEq :unitCheck @time
   389 jump *label112 always
   390 label *label112
   391 set :areUnitsAvailable.2:type UNIT_TYPE
 
   393 set :areUnitsAvailable.2:occupied 0
   394 ubind :areUnitsAvailable.2:type
   395 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp142 :areUnitsAvailable.2:firstUnit null
-    * jump *label117 equal *tmp142 false
+  396 jump *label117 equal :areUnitsAvailable.2:firstUnit null
   397 label *label119
   398 sensor *tmp144 @unit @controlled
-    * op equal *tmp145 *tmp144 0
-    * jump *label124 notEqual *tmp145 false
+  399 jump *label124 equal *tmp144 0
   400 label *label125
   401 sensor *tmp146 @unit @controller
-    * op equal *tmp147 *tmp146 @this
-    * jump *label122 equal *tmp147 false
+  402 jump *label122 notEqual *tmp146 @this
   403 label *label124
   404 set *tmp140 true
   405 jump *label116 always
 
   409 label *label123
   410 ubind :areUnitsAvailable.2:type
   411 label *label120
-    * op notEqual *tmp149 @unit :areUnitsAvailable.2:firstUnit
-    * jump *label121 equal *tmp149 false
+  412 jump *label121 equal @unit :areUnitsAvailable.2:firstUnit
   413 label *label126
   414 sensor *tmp150 :areUnitsAvailable.2:firstUnit @dead
-    * op equal *tmp151 *tmp150 0
-    * jump *label119 notEqual *tmp151 false
+  415 jump *label119 equal *tmp150 0
   416 label *label121
   417 jump *label118 always
   418 label *label117

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-27 instructions):
 
    42 sensor *tmp13 :areUnitsAvailable:firstUnit @dead
    43 jump *label12 equal *tmp13 0
    44 label *label14
-    * jump *label11 always
    45 label *label10
    46 label *label11
    47 jump *label20 equal :areUnitsAvailable:output false
 
    50 print "occupied: "
    51 print :areUnitsAvailable:occupied
    52 print "\n"
-    * jump *label21 always
    53 label *label20
    54 label *label21
    55 set *tmp3 false
 
    59 jump *label7 equal *tmp3 false
    60 set *tmp2 UNIT_TYPE
    61 jump *label3 always
-    * jump *label8 always
    62 label *label7
    63 label *label8
    64 set :chooseUnitType:type @flare
 
   103 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
   104 jump *label36 equal *tmp30 0
   105 label *label38
-    * jump *label35 always
   106 label *label34
   107 label *label35
   108 jump *label44 equal :areUnitsAvailable.1:output false
 
   111 print "occupied: "
   112 print :areUnitsAvailable.1:occupied
   113 print "\n"
-    * jump *label45 always
   114 label *label44
   115 label *label45
   116 set *tmp20 false
 
   121 printflush null
   122 set *tmp2 :chooseUnitType:type
   123 jump *label3 always
-    * jump *label32 always
   124 label *label31
   125 label *label32
-    * jump *label30 always
   126 label *label29
   127 label *label30
   128 label *label23
 
   147 op land *tmp42 *tmp39 *tmp41
   148 jump *label50 equal *tmp42 false
   149 jump *label47 always
-    * jump *label51 always
   150 label *label50
   151 label *label51
-    * jump *label49 always
   152 label *label48
   153 label *label49
   154 ubind .TYPE
 
   158 sensor *tmp47 @unit @controlled
   159 jump *label57 notEqual *tmp47 0
   160 jump *label47 always
-    * jump *label58 always
   161 label *label57
   162 label *label58
   163 ubind .TYPE
 
   167 sensor *tmp51 :rebindUnit:firstUnit @dead
   168 jump *label54 equal *tmp51 0
   169 label *label56
-    * jump *label53 always
   170 label *label52
   171 label *label53
   172 end
 
   224 jump *label72 equal *tmp79 false
   225 set *tmp72 :rebindUnit.1:currentUnit
   226 jump *label69 always
-    * jump *label73 always
   227 label *label72
   228 label *label73
-    * jump *label71 always
   229 label *label70
   230 label *label71
   231 ubind .TYPE
 
   236 jump *label79 notEqual *tmp84 0
   237 set *tmp72 @unit
   238 jump *label69 always
-    * jump *label80 always
   239 label *label79
   240 label *label80
   241 ubind .TYPE
 
   245 sensor *tmp88 :rebindUnit.1:firstUnit @dead
   246 jump *label76 equal *tmp88 0
   247 label *label78
-    * jump *label75 always
   248 label *label74
   249 label *label75
   250 end
 
   273 ucontrol within .CORE_X .CORE_Y 8 *tmp100
   274 jump *label90 equal *tmp100 false
   275 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label91 always
   276 label *label90
   277 label *label91
   278 label *label89
   279 label *label87
-    * jump *label83 always
   280 label *label82
   281 label *label83
   282 jump *label92 notEqual :processUnit:state 2
 
   303 op idiv *tmp114 *tmp113 .SPEED_TENTHS
   304 op div :processUnit:distance *tmp114 10
   305 label *label95
-    * jump *label93 always
   306 label *label92
   307 label *label93
   308 jump *label98 notEqual :processUnit:state 3
 
   314 jump *label102 greaterThan *tmp120 0
   315 ucontrol approach .CORE_X .CORE_Y 6
   316 set :processUnit:state 2
-    * jump *label103 always
   317 label *label102
   318 label *label103
   319 jump *label101 always
 
   328 op idiv *tmp128 *tmp127 .SPEED_TENTHS
   329 op div :processUnit:distance *tmp128 10
   330 label *label101
-    * jump *label99 always
   331 label *label98
   332 label *label99
   333 ucontrol flag :processUnit:state
 
   358 label *label109
   359 sensor *tmp134 .VAULT .ITEM
   360 jump *label106 lessThan *tmp134 500
-    * jump *label108 always
   361 label *label108
   362 ucontrol unbind
   363 jump *label107 always
 
   365 jump *label110 equal .TYPE UNIT_TYPE
   366 label *label113
   367 jump *label110 lessThanEq :unitCheck @time
-    * jump *label112 always
   368 label *label112
   369 set :areUnitsAvailable.2:type UNIT_TYPE
   370 set :areUnitsAvailable.2:output false
 
   392 sensor *tmp150 :areUnitsAvailable.2:firstUnit @dead
   393 jump *label119 equal *tmp150 0
   394 label *label121
-    * jump *label118 always
   395 label *label117
   396 label *label118
   397 jump *label127 equal :areUnitsAvailable.2:output false
 
   400 print "occupied: "
   401 print :areUnitsAvailable.2:occupied
   402 print "\n"
-    * jump *label128 always
   403 label *label127
   404 label *label128
   405 set *tmp140 false
 
   408 label *label116
   409 jump *label114 equal *tmp140 false
   410 end
-    * jump *label115 always
   411 label *label114
   412 label *label115
   413 op add :unitCheck @time 5000
-    * jump *label111 always
   414 label *label110
   415 label *label111
   416 label *label107
-    * jump *label67 always
   417 label *label66
   418 label *label67
   419 op sub *tmp155 @time :start

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-7 instructions):
 
    19 set :areUnitsAvailable:type UNIT_TYPE
    20 set :areUnitsAvailable:output true
    21 set :areUnitsAvailable:occupied 0
-    * ubind :areUnitsAvailable:type
+   22 ubind UNIT_TYPE
    23 set :areUnitsAvailable:firstUnit @unit
    24 jump *label10 equal :areUnitsAvailable:firstUnit null
    25 label *label12
 
    35 label *label15
    36 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    37 label *label16
-    * ubind :areUnitsAvailable:type
+   38 ubind UNIT_TYPE
    39 label *label13
    40 jump *label14 equal @unit :areUnitsAvailable:firstUnit
    41 label *label19
 
    44 label *label14
    45 label *label10
    46 label *label11
-    * jump *label20 equal :areUnitsAvailable:output false
-    * print :areUnitsAvailable:type
+   47 jump *label20 equal true false
+   48 print UNIT_TYPE
    49 print " "
    50 print "occupied: "
    51 print :areUnitsAvailable:occupied
 
    54 label *label21
    55 set *tmp3 false
    56 jump *label9 always
-    * set *tmp3 null
    57 label *label9
    58 jump *label7 equal *tmp3 false
    59 set *tmp2 UNIT_TYPE
 
    79 set :areUnitsAvailable.1:type :chooseUnitType:type
    80 set :areUnitsAvailable.1:output true
    81 set :areUnitsAvailable.1:occupied 0
-    * ubind :areUnitsAvailable.1:type
+   82 ubind :chooseUnitType:type
    83 set :areUnitsAvailable.1:firstUnit @unit
    84 jump *label34 equal :areUnitsAvailable.1:firstUnit null
    85 label *label36
 
    95 label *label39
    96 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    97 label *label40
-    * ubind :areUnitsAvailable.1:type
+   98 ubind :chooseUnitType:type
    99 label *label37
   100 jump *label38 equal @unit :areUnitsAvailable.1:firstUnit
   101 label *label43
 
   104 label *label38
   105 label *label34
   106 label *label35
-    * jump *label44 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  107 jump *label44 equal true false
+  108 print :chooseUnitType:type
   109 print " "
   110 print "occupied: "
   111 print :areUnitsAvailable.1:occupied
 
   114 label *label45
   115 set *tmp20 false
   116 jump *label33 always
-    * set *tmp20 null
   117 label *label33
   118 jump *label31 equal *tmp20 false
   119 printflush null
 
   134 set *tmp2 null
   135 label *label3
   136 set .TYPE *tmp2
-    * set :acquireUnit:currentUnit .UNIT
-    * set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * jump *label48 equal :rebindUnit:currentUnit null
-    * ubind :rebindUnit:currentUnit
+  137 set :acquireUnit:currentUnit null
+  138 set :rebindUnit:currentUnit .UNIT
+  139 jump *label48 equal :acquireUnit:currentUnit null
+  140 ubind :acquireUnit:currentUnit
   141 sensor *tmp38 @unit @dead
   142 op equal *tmp39 *tmp38 0
   143 sensor *tmp40 @unit @controller
 
   149 label *label51
   150 label *label48
   151 label *label49
-    * ubind .TYPE
+  152 ubind *tmp2
   153 set :rebindUnit:firstUnit @unit
   154 jump *label52 equal :rebindUnit:firstUnit null
   155 label *label54
 
   158 jump *label47 always
   159 label *label57
   160 label *label58
-    * ubind .TYPE
+  161 ubind *tmp2
   162 label *label55
   163 jump *label56 equal @unit :rebindUnit:firstUnit
   164 label *label59
 
   172 ucontrol flag 1
   173 set *tmp34 @unit
   174 jump *label46 always
-    * set *tmp34 null
   175 label *label46
   176 set .UNIT *tmp34
-    * sensor .UNIT_CAPACITY .UNIT @itemCapacity
-    * sensor .SPEED .UNIT @speed
+  177 sensor .UNIT_CAPACITY *tmp34 @itemCapacity
+  178 sensor .SPEED *tmp34 @speed
   179 op div .SPEED_TENTHS .SPEED 10
   180 print "[gold]Locating core..."
   181 printflush message1
 
   194 print " === [gold]Supplying Power Plant[] === "
   195 print "\n"
   196 print "\n"
-    * sensor *tmp67 .VAULT .ITEM
+  197 sensor *tmp67 .VAULT @thorium
   198 print "\n"
   199 print "[gold]Thorium[] status: [green]"
   200 print *tmp67
   201 print "["
   202 print "]"
   203 print "\n"
-    * sensor *tmp68 .VAULT .ITEM
+  204 sensor *tmp68 .VAULT @thorium
   205 jump *label66 greaterThanEq *tmp68 500
   206 print "\n"
   207 print "Unit type: [green]"
-    * print .TYPE
+  208 print *tmp2
   209 print "["
   210 print "]"
   211 print "\n"
   212 set :processUnit:unit .UNIT
-    * set :rebindUnit.1:currentUnit :processUnit:unit
-    * jump *label70 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  213 set :rebindUnit.1:currentUnit .UNIT
+  214 jump *label70 equal :processUnit:unit null
+  215 ubind :processUnit:unit
   216 sensor *tmp75 @unit @dead
   217 op equal *tmp76 *tmp75 0
   218 sensor *tmp77 @unit @controller
   219 op equal *tmp78 *tmp77 @this
   220 op land *tmp79 *tmp76 *tmp78
   221 jump *label72 equal *tmp79 false
-    * set *tmp72 :rebindUnit.1:currentUnit
+  222 set *tmp72 :processUnit:unit
   223 jump *label69 always
   224 label *label72
   225 label *label73
   226 label *label70
   227 label *label71
-    * ubind .TYPE
+  228 ubind *tmp2
   229 set :rebindUnit.1:firstUnit @unit
   230 jump *label74 equal :rebindUnit.1:firstUnit null
   231 label *label76
 
   235 jump *label69 always
   236 label *label79
   237 label *label80
-    * ubind .TYPE
+  238 ubind *tmp2
   239 label *label77
   240 jump *label78 equal @unit :rebindUnit.1:firstUnit
   241 label *label81
 
   245 label *label74
   246 label *label75
   247 end
-    * set *tmp72 null
   248 label *label69
-    * set :processUnit:unit *tmp72
   249 sensor :processUnit:state @unit @flag
   250 set :processUnit:distance -1
   251 set :processUnit:color "gold"
 
   254 jump *label82 lessThanEq :processUnit:state 3
   255 label *label84
   256 sensor *tmp94 @unit @firstItem
-    * jump *label86 notEqual *tmp94 .ITEM
+  257 jump *label86 notEqual *tmp94 @thorium
   258 set :processUnit:state 3
   259 jump *label87 always
   260 label *label86
 
   277 jump *label92 notEqual :processUnit:state 2
   278 ucontrol within .CORE_X .CORE_Y 8 *tmp104
   279 jump *label94 equal *tmp104 false
-    * ucontrol itemTake .CORE .ITEM .UNIT_CAPACITY
+  280 ucontrol itemTake .CORE @thorium .UNIT_CAPACITY
   281 sensor *tmp106 @unit @totalItems
   282 jump *label96 lessThan *tmp106 .UNIT_CAPACITY
   283 ucontrol approach .VAULT_X .VAULT_Y 6
 
   328 ucontrol flag :processUnit:state
   329 sensor *tmp130 @unit @totalItems
   330 print "["
-    * print :processUnit:color
+  331 print "gold"
   332 print "]"
   333 print *tmp130
   334 print "["
 
   345 label *label105
   346 set *tmp71 @unit
   347 jump *label68 always
-    * set *tmp71 null
   348 label *label68
   349 set :state :processUnit:state
   350 set .UNIT *tmp71
-    * jump *label106 notEqual :state 2
+  351 jump *label106 notEqual :processUnit:state 2
   352 label *label109
-    * sensor *tmp134 .VAULT .ITEM
+  353 sensor *tmp134 .VAULT @thorium
   354 jump *label106 lessThan *tmp134 500
   355 label *label108
   356 ucontrol unbind
   357 jump *label107 always
   358 label *label106
-    * jump *label110 equal .TYPE UNIT_TYPE
+  359 jump *label110 equal *tmp2 UNIT_TYPE
   360 label *label113
   361 jump *label110 lessThanEq :unitCheck @time
   362 label *label112
   363 set :areUnitsAvailable.2:type UNIT_TYPE
   364 set :areUnitsAvailable.2:output false
   365 set :areUnitsAvailable.2:occupied 0
-    * ubind :areUnitsAvailable.2:type
+  366 ubind UNIT_TYPE
   367 set :areUnitsAvailable.2:firstUnit @unit
   368 jump *label117 equal :areUnitsAvailable.2:firstUnit null
   369 label *label119
 
   379 label *label122
   380 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
   381 label *label123
-    * ubind :areUnitsAvailable.2:type
+  382 ubind UNIT_TYPE
   383 label *label120
   384 jump *label121 equal @unit :areUnitsAvailable.2:firstUnit
   385 label *label126
 
   388 label *label121
   389 label *label117
   390 label *label118
-    * jump *label127 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+  391 jump *label127 equal false false
+  392 print UNIT_TYPE
   393 print " "
   394 print "occupied: "
   395 print :areUnitsAvailable.2:occupied
 
   398 label *label128
   399 set *tmp140 false
   400 jump *label116 always
-    * set *tmp140 null
   401 label *label116
   402 jump *label114 equal *tmp140 false
   403 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-12 instructions):
 
     1 remark "If no units of this type exist, we'll try using other types."
     2 set UNIT_TYPE @poly
     3 remark "Do not modify anything below this line."
-    * set .ITEM @thorium
     4 set .MSG ""
     5 set .UNIT null
     6 set .VAULT vault1
 
    15 printflush null
    16 print "[gold]Looking for suitable unit type:[]"
    17 print "\n"
-    * set :areUnitsAvailable:type UNIT_TYPE
-    * set :areUnitsAvailable:output true
    18 set :areUnitsAvailable:occupied 0
    19 ubind UNIT_TYPE
    20 set :areUnitsAvailable:firstUnit @unit
 
    73 setaddr *tmp17 *label28
    74 label *label22
    75 jump *label29 equal :chooseUnitType:type UNIT_TYPE
-    * set :areUnitsAvailable.1:type :chooseUnitType:type
-    * set :areUnitsAvailable.1:output true
    76 set :areUnitsAvailable.1:occupied 0
    77 ubind :chooseUnitType:type
    78 set :areUnitsAvailable.1:firstUnit @unit
 
   128 label *label6
   129 set *tmp2 null
   130 label *label3
-    * set .TYPE *tmp2
   131 set :acquireUnit:currentUnit null
-    * set :rebindUnit:currentUnit .UNIT
-    * jump *label48 equal :acquireUnit:currentUnit null
-    * ubind :acquireUnit:currentUnit
+  132 set :rebindUnit:currentUnit null
+  133 jump *label48 equal null null
+  134 ubind null
   135 sensor *tmp38 @unit @dead
   136 op equal *tmp39 *tmp38 0
   137 sensor *tmp40 @unit @controller
 
   204 print "]"
   205 print "\n"
   206 set :processUnit:unit .UNIT
-    * set :rebindUnit.1:currentUnit .UNIT
-    * jump *label70 equal :processUnit:unit null
-    * ubind :processUnit:unit
+  207 jump *label70 equal .UNIT null
+  208 ubind .UNIT
   209 sensor *tmp75 @unit @dead
   210 op equal *tmp76 *tmp75 0
   211 sensor *tmp77 @unit @controller
   212 op equal *tmp78 *tmp77 @this
   213 op land *tmp79 *tmp76 *tmp78
   214 jump *label72 equal *tmp79 false
-    * set *tmp72 :processUnit:unit
+  215 set *tmp72 .UNIT
   216 jump *label69 always
   217 label *label72
   218 label *label73
 
   224 label *label76
   225 sensor *tmp84 @unit @controlled
   226 jump *label79 notEqual *tmp84 0
-    * set *tmp72 @unit
   227 jump *label69 always
   228 label *label79
   229 label *label80
 
   240 label *label69
   241 sensor :processUnit:state @unit @flag
   242 set :processUnit:distance -1
-    * set :processUnit:color "gold"
   243 jump *label84 lessThan :processUnit:state 2
   244 label *label85
   245 jump *label82 lessThanEq :processUnit:state 3
 
   337 set *tmp71 @unit
   338 jump *label68 always
   339 label *label68
-    * set :state :processUnit:state
   340 set .UNIT *tmp71
   341 jump *label106 notEqual :processUnit:state 2
   342 label *label109
 
   350 label *label113
   351 jump *label110 lessThanEq :unitCheck @time
   352 label *label112
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
   353 set :areUnitsAvailable.2:occupied 0
   354 ubind UNIT_TYPE
   355 set :areUnitsAvailable.2:firstUnit @unit

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-5 instructions):
 
     2 set UNIT_TYPE @poly
     3 remark "Do not modify anything below this line."
     4 set .MSG ""
-    * set .UNIT null
     5 set .VAULT vault1
     6 label *label0
     7 sensor *tmp0 .VAULT @dead
 
   127 label *label6
   128 set *tmp2 null
   129 label *label3
-    * set :acquireUnit:currentUnit null
-    * set :rebindUnit:currentUnit null
   130 jump *label48 equal null null
   131 ubind null
   132 sensor *tmp38 @unit @dead
 
   200 print "["
   201 print "]"
   202 print "\n"
-    * set :processUnit:unit .UNIT
   203 jump *label70 equal .UNIT null
   204 ubind .UNIT
   205 sensor *tmp75 @unit @dead
 
   208 op equal *tmp78 *tmp77 @this
   209 op land *tmp79 *tmp76 *tmp78
   210 jump *label72 equal *tmp79 false
-    * set *tmp72 .UNIT
   211 jump *label69 always
   212 label *label72
   213 label *label73

Modifications by Partial loop rotation at line 30:1 (+1 instructions):
 
     6 label *label0
     7 sensor *tmp0 .VAULT @dead
     8 jump *label2 equal *tmp0 0
+    9 label *label129
    10 set .VAULT vault1
    11 label *label1
-    * jump *label0 always
+   12 sensor *tmp0 .VAULT @dead
+   13 jump *label129 notEqual *tmp0 0
    14 label *label2
    15 label *label4
    16 printflush null

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     4 set .MSG ""
     5 set .VAULT vault1
     6 label *label0
-    * sensor *tmp0 .VAULT @dead
+    7 sensor *tmp0 vault1 @dead
     8 jump *label2 equal *tmp0 0
     9 label *label129
    10 set .VAULT vault1
    11 label *label1
-    * sensor *tmp0 .VAULT @dead
+   12 sensor *tmp0 vault1 @dead
    13 jump *label129 notEqual *tmp0 0
    14 label *label2
    15 label *label4

Modifications by Unroll iteration loop at line 93:9 (+79 instructions):
 
    56 jump *label3 always
    57 label *label7
    58 label *label8
-    * set :chooseUnitType:type @flare
-    * setaddr *tmp17 *label25
-    * jump *label22 always
-    * multilabel *label25 (m:marker0)
-    * set :chooseUnitType:type @poly
-    * setaddr *tmp17 *label26
-    * jump *label22 always
-    * multilabel *label26 (m:marker0)
-    * set :chooseUnitType:type @mega
-    * setaddr *tmp17 *label27
-    * jump *label22 always
-    * multilabel *label27 (m:marker0)
-    * set :chooseUnitType:type @mono
-    * setaddr *tmp17 *label28
-    * label *label22
-    * jump *label29 equal :chooseUnitType:type UNIT_TYPE
-    * set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label34 equal :areUnitsAvailable.1:firstUnit null
-    * label *label36
-    * sensor *tmp24 @unit @controlled
-    * jump *label41 equal *tmp24 0
-    * sensor *tmp26 @unit @controller
-    * jump *label39 notEqual *tmp26 @this
-    * label *label41
-    * set *tmp20 true
-    * jump *label33 always
-    * jump *label40 always
-    * label *label39
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label40
-    * ubind :chooseUnitType:type
-    * label *label37
-    * jump *label38 equal @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
-    * jump *label36 equal *tmp30 0
-    * label *label38
-    * label *label34
-    * label *label35
-    * jump *label44 equal true false
-    * print :chooseUnitType:type
-    * print " "
-    * print "occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print "\n"
-    * label *label44
-    * label *label45
-    * set *tmp20 false
-    * jump *label33 always
-    * label *label33
-    * jump *label31 equal *tmp20 false
-    * printflush null
-    * set *tmp2 :chooseUnitType:type
-    * jump *label3 always
-    * label *label31
-    * label *label32
-    * label *label29
-    * label *label30
-    * label *label23
-    * multijump *tmp17 0 0 (m:marker0)
-    * multilabel *label28 (m:marker0)
-    * label *label24
+   59 set :chooseUnitType:type @flare
+   60 label *label130
+   61 jump *label144 equal :chooseUnitType:type UNIT_TYPE
+   62 set :areUnitsAvailable.1:occupied 0
+   63 ubind :chooseUnitType:type
+   64 set :areUnitsAvailable.1:firstUnit @unit
+   65 jump *label137 equal :areUnitsAvailable.1:firstUnit null
+   66 label *label131
+   67 sensor *tmp24 @unit @controlled
+   68 jump *label132 equal *tmp24 0
+   69 sensor *tmp26 @unit @controller
+   70 jump *label133 notEqual *tmp26 @this
+   71 label *label132
+   72 set *tmp20 true
+   73 jump *label141 always
+   74 jump *label134 always
+   75 label *label133
+   76 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+   77 label *label134
+   78 ubind :chooseUnitType:type
+   79 label *label135
+   80 jump *label136 equal @unit :areUnitsAvailable.1:firstUnit
+   81 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
+   82 jump *label131 equal *tmp30 0
+   83 label *label136
+   84 label *label137
+   85 label *label138
+   86 jump *label139 equal true false
+   87 print :chooseUnitType:type
+   88 print " "
+   89 print "occupied: "
+   90 print :areUnitsAvailable.1:occupied
+   91 print "\n"
+   92 label *label139
+   93 label *label140
+   94 set *tmp20 false
+   95 jump *label141 always
+   96 label *label141
+   97 jump *label142 equal *tmp20 false
+   98 printflush null
+   99 set *tmp2 :chooseUnitType:type
+  100 jump *label3 always
+  101 label *label142
+  102 label *label143
+  103 label *label144
+  104 label *label145
+  105 label *label146
+  106 set :chooseUnitType:type @poly
+  107 label *label149
+  108 jump *label163 equal :chooseUnitType:type UNIT_TYPE
+  109 set :areUnitsAvailable.1:occupied 0
+  110 ubind :chooseUnitType:type
+  111 set :areUnitsAvailable.1:firstUnit @unit
+  112 jump *label156 equal :areUnitsAvailable.1:firstUnit null
+  113 label *label150
+  114 sensor *tmp24 @unit @controlled
+  115 jump *label151 equal *tmp24 0
+  116 sensor *tmp26 @unit @controller
+  117 jump *label152 notEqual *tmp26 @this
+  118 label *label151
+  119 set *tmp20 true
+  120 jump *label160 always
+  121 jump *label153 always
+  122 label *label152
+  123 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  124 label *label153
+  125 ubind :chooseUnitType:type
+  126 label *label154
+  127 jump *label155 equal @unit :areUnitsAvailable.1:firstUnit
+  128 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
+  129 jump *label150 equal *tmp30 0
+  130 label *label155
+  131 label *label156
+  132 label *label157
+  133 jump *label158 equal true false
+  134 print :chooseUnitType:type
+  135 print " "
+  136 print "occupied: "
+  137 print :areUnitsAvailable.1:occupied
+  138 print "\n"
+  139 label *label158
+  140 label *label159
+  141 set *tmp20 false
+  142 jump *label160 always
+  143 label *label160
+  144 jump *label161 equal *tmp20 false
+  145 printflush null
+  146 set *tmp2 :chooseUnitType:type
+  147 jump *label3 always
+  148 label *label161
+  149 label *label162
+  150 label *label163
+  151 label *label164
+  152 label *label165
+  153 set :chooseUnitType:type @mega
+  154 label *label168
+  155 jump *label182 equal :chooseUnitType:type UNIT_TYPE
+  156 set :areUnitsAvailable.1:occupied 0
+  157 ubind :chooseUnitType:type
+  158 set :areUnitsAvailable.1:firstUnit @unit
+  159 jump *label175 equal :areUnitsAvailable.1:firstUnit null
+  160 label *label169
+  161 sensor *tmp24 @unit @controlled
+  162 jump *label170 equal *tmp24 0
+  163 sensor *tmp26 @unit @controller
+  164 jump *label171 notEqual *tmp26 @this
+  165 label *label170
+  166 set *tmp20 true
+  167 jump *label179 always
+  168 jump *label172 always
+  169 label *label171
+  170 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  171 label *label172
+  172 ubind :chooseUnitType:type
+  173 label *label173
+  174 jump *label174 equal @unit :areUnitsAvailable.1:firstUnit
+  175 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
+  176 jump *label169 equal *tmp30 0
+  177 label *label174
+  178 label *label175
+  179 label *label176
+  180 jump *label177 equal true false
+  181 print :chooseUnitType:type
+  182 print " "
+  183 print "occupied: "
+  184 print :areUnitsAvailable.1:occupied
+  185 print "\n"
+  186 label *label177
+  187 label *label178
+  188 set *tmp20 false
+  189 jump *label179 always
+  190 label *label179
+  191 jump *label180 equal *tmp20 false
+  192 printflush null
+  193 set *tmp2 :chooseUnitType:type
+  194 jump *label3 always
+  195 label *label180
+  196 label *label181
+  197 label *label182
+  198 label *label183
+  199 label *label184
+  200 set :chooseUnitType:type @mono
+  201 label *label187
+  202 jump *label201 equal :chooseUnitType:type UNIT_TYPE
+  203 set :areUnitsAvailable.1:occupied 0
+  204 ubind :chooseUnitType:type
+  205 set :areUnitsAvailable.1:firstUnit @unit
+  206 jump *label194 equal :areUnitsAvailable.1:firstUnit null
+  207 label *label188
+  208 sensor *tmp24 @unit @controlled
+  209 jump *label189 equal *tmp24 0
+  210 sensor *tmp26 @unit @controller
+  211 jump *label190 notEqual *tmp26 @this
+  212 label *label189
+  213 set *tmp20 true
+  214 jump *label198 always
+  215 jump *label191 always
+  216 label *label190
+  217 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  218 label *label191
+  219 ubind :chooseUnitType:type
+  220 label *label192
+  221 jump *label193 equal @unit :areUnitsAvailable.1:firstUnit
+  222 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
+  223 jump *label188 equal *tmp30 0
+  224 label *label193
+  225 label *label194
+  226 label *label195
+  227 jump *label196 equal true false
+  228 print :chooseUnitType:type
+  229 print " "
+  230 print "occupied: "
+  231 print :areUnitsAvailable.1:occupied
+  232 print "\n"
+  233 label *label196
+  234 label *label197
+  235 set *tmp20 false
+  236 jump *label198 always
+  237 label *label198
+  238 jump *label199 equal *tmp20 false
+  239 printflush null
+  240 set *tmp2 :chooseUnitType:type
+  241 jump *label3 always
+  242 label *label199
+  243 label *label200
+  244 label *label201
+  245 label *label202
+  246 label *label203
+  247 label *label24
   248 printflush message1
   249 label *label5
   250 jump *label4 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    58 label *label8
    59 set :chooseUnitType:type @flare
    60 label *label130
-    * jump *label144 equal :chooseUnitType:type UNIT_TYPE
+   61 jump *label144 equal @flare UNIT_TYPE
    62 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
+   63 ubind @flare
    64 set :areUnitsAvailable.1:firstUnit @unit
    65 jump *label137 equal :areUnitsAvailable.1:firstUnit null
    66 label *label131
 
    75 label *label133
    76 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    77 label *label134
-    * ubind :chooseUnitType:type
+   78 ubind @flare
    79 label *label135
    80 jump *label136 equal @unit :areUnitsAvailable.1:firstUnit
    81 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
 
    84 label *label137
    85 label *label138
    86 jump *label139 equal true false
-    * print :chooseUnitType:type
+   87 print @flare
    88 print " "
    89 print "occupied: "
    90 print :areUnitsAvailable.1:occupied
 
    96 label *label141
    97 jump *label142 equal *tmp20 false
    98 printflush null
-    * set *tmp2 :chooseUnitType:type
+   99 set *tmp2 @flare
   100 jump *label3 always
   101 label *label142
   102 label *label143
 
   105 label *label146
   106 set :chooseUnitType:type @poly
   107 label *label149
-    * jump *label163 equal :chooseUnitType:type UNIT_TYPE
+  108 jump *label163 equal @poly UNIT_TYPE
   109 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
+  110 ubind @poly
   111 set :areUnitsAvailable.1:firstUnit @unit
   112 jump *label156 equal :areUnitsAvailable.1:firstUnit null
   113 label *label150
 
   122 label *label152
   123 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   124 label *label153
-    * ubind :chooseUnitType:type
+  125 ubind @poly
   126 label *label154
   127 jump *label155 equal @unit :areUnitsAvailable.1:firstUnit
   128 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
 
   131 label *label156
   132 label *label157
   133 jump *label158 equal true false
-    * print :chooseUnitType:type
+  134 print @poly
   135 print " "
   136 print "occupied: "
   137 print :areUnitsAvailable.1:occupied
 
   143 label *label160
   144 jump *label161 equal *tmp20 false
   145 printflush null
-    * set *tmp2 :chooseUnitType:type
+  146 set *tmp2 @poly
   147 jump *label3 always
   148 label *label161
   149 label *label162
 
   152 label *label165
   153 set :chooseUnitType:type @mega
   154 label *label168
-    * jump *label182 equal :chooseUnitType:type UNIT_TYPE
+  155 jump *label182 equal @mega UNIT_TYPE
   156 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
+  157 ubind @mega
   158 set :areUnitsAvailable.1:firstUnit @unit
   159 jump *label175 equal :areUnitsAvailable.1:firstUnit null
   160 label *label169
 
   169 label *label171
   170 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   171 label *label172
-    * ubind :chooseUnitType:type
+  172 ubind @mega
   173 label *label173
   174 jump *label174 equal @unit :areUnitsAvailable.1:firstUnit
   175 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
 
   178 label *label175
   179 label *label176
   180 jump *label177 equal true false
-    * print :chooseUnitType:type
+  181 print @mega
   182 print " "
   183 print "occupied: "
   184 print :areUnitsAvailable.1:occupied
 
   190 label *label179
   191 jump *label180 equal *tmp20 false
   192 printflush null
-    * set *tmp2 :chooseUnitType:type
+  193 set *tmp2 @mega
   194 jump *label3 always
   195 label *label180
   196 label *label181
 
   199 label *label184
   200 set :chooseUnitType:type @mono
   201 label *label187
-    * jump *label201 equal :chooseUnitType:type UNIT_TYPE
+  202 jump *label201 equal @mono UNIT_TYPE
   203 set :areUnitsAvailable.1:occupied 0
-    * ubind :chooseUnitType:type
+  204 ubind @mono
   205 set :areUnitsAvailable.1:firstUnit @unit
   206 jump *label194 equal :areUnitsAvailable.1:firstUnit null
   207 label *label188
 
   216 label *label190
   217 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   218 label *label191
-    * ubind :chooseUnitType:type
+  219 ubind @mono
   220 label *label192
   221 jump *label193 equal @unit :areUnitsAvailable.1:firstUnit
   222 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
 
   225 label *label194
   226 label *label195
   227 jump *label196 equal true false
-    * print :chooseUnitType:type
+  228 print @mono
   229 print " "
   230 print "occupied: "
   231 print :areUnitsAvailable.1:occupied
 
   237 label *label198
   238 jump *label199 equal *tmp20 false
   239 printflush null
-    * set *tmp2 :chooseUnitType:type
+  240 set *tmp2 @mono
   241 jump *label3 always
   242 label *label199
   243 label *label200

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    56 jump *label3 always
    57 label *label7
    58 label *label8
-    * set :chooseUnitType:type @flare
    59 label *label130
    60 jump *label144 equal @flare UNIT_TYPE
    61 set :areUnitsAvailable.1:occupied 0
 
   102 label *label144
   103 label *label145
   104 label *label146
-    * set :chooseUnitType:type @poly
   105 label *label149
   106 jump *label163 equal @poly UNIT_TYPE
   107 set :areUnitsAvailable.1:occupied 0
 
   148 label *label163
   149 label *label164
   150 label *label165
-    * set :chooseUnitType:type @mega
   151 label *label168
   152 jump *label182 equal @mega UNIT_TYPE
   153 set :areUnitsAvailable.1:occupied 0
 
   194 label *label182
   195 label *label183
   196 label *label184
-    * set :chooseUnitType:type @mono
   197 label *label187
   198 jump *label201 equal @mono UNIT_TYPE
   199 set :areUnitsAvailable.1:occupied 0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-5 instructions):
 
    40 label *label14
    41 label *label10
    42 label *label11
-    * jump *label20 equal true false
    43 print UNIT_TYPE
    44 print " "
    45 print "occupied: "
 
    81 label *label136
    82 label *label137
    83 label *label138
-    * jump *label139 equal true false
    84 print @flare
    85 print " "
    86 print "occupied: "
 
   126 label *label155
   127 label *label156
   128 label *label157
-    * jump *label158 equal true false
   129 print @poly
   130 print " "
   131 print "occupied: "
 
   171 label *label174
   172 label *label175
   173 label *label176
-    * jump *label177 equal true false
   174 print @mega
   175 print " "
   176 print "occupied: "
 
   216 label *label193
   217 label *label194
   218 label *label195
-    * jump *label196 equal true false
   219 print @mono
   220 print " "
   221 print "occupied: "
 
   242 label *label6
   243 set *tmp2 null
   244 label *label3
-    * jump *label48 equal null null
+  245 jump *label48 always
   246 ubind null
   247 sensor *tmp38 @unit @dead
   248 op equal *tmp39 *tmp38 0
 
   477 label *label121
   478 label *label117
   479 label *label118
-    * jump *label127 equal false false
+  480 jump *label127 always
   481 print UNIT_TYPE
   482 print " "
   483 print "occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-8 instructions):
 
    48 label *label20
    49 label *label21
    50 set *tmp3 false
-    * jump *label9 always
    51 label *label9
    52 jump *label7 equal *tmp3 false
    53 set *tmp2 UNIT_TYPE
 
    88 label *label139
    89 label *label140
    90 set *tmp20 false
-    * jump *label141 always
    91 label *label141
    92 jump *label142 equal *tmp20 false
    93 printflush null
 
   132 label *label158
   133 label *label159
   134 set *tmp20 false
-    * jump *label160 always
   135 label *label160
   136 jump *label161 equal *tmp20 false
   137 printflush null
 
   176 label *label177
   177 label *label178
   178 set *tmp20 false
-    * jump *label179 always
   179 label *label179
   180 jump *label180 equal *tmp20 false
   181 printflush null
 
   220 label *label196
   221 label *label197
   222 set *tmp20 false
-    * jump *label198 always
   223 label *label198
   224 jump *label199 equal *tmp20 false
   225 printflush null
 
   271 label *label47
   272 ucontrol flag 1
   273 set *tmp34 @unit
-    * jump *label46 always
   274 label *label46
   275 set .UNIT *tmp34
   276 sensor .UNIT_CAPACITY *tmp34 @itemCapacity
 
   436 print .MSG
   437 label *label105
   438 set *tmp71 @unit
-    * jump *label68 always
   439 label *label68
   440 set .UNIT *tmp71
   441 jump *label106 notEqual :processUnit:state 2
 
   479 label *label127
   480 label *label128
   481 set *tmp140 false
-    * jump *label116 always
   482 label *label116
   483 jump *label114 equal *tmp140 false
   484 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-5 instructions):
 
   239 label *label3
   240 jump *label48 always
   241 ubind null
-    * sensor *tmp38 @unit @dead
-    * op equal *tmp39 *tmp38 0
-    * sensor *tmp40 @unit @controller
-    * op equal *tmp41 *tmp40 @this
-    * op land *tmp42 *tmp39 *tmp41
   242 jump *label50 equal *tmp42 false
   243 jump *label47 always
   244 label *label50

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-16 instructions):
 
     3 remark "Do not modify anything below this line."
     4 set .MSG ""
     5 set .VAULT vault1
-    * label *label0
     6 sensor *tmp0 vault1 @dead
     7 jump *label2 equal *tmp0 0
     8 label *label129
     9 set .VAULT vault1
-    * label *label1
    10 sensor *tmp0 vault1 @dead
    11 jump *label129 notEqual *tmp0 0
    12 label *label2
 
    26 label *label17
    27 set *tmp3 true
    28 jump *label9 always
-    * jump *label16 always
    29 label *label15
    30 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    31 label *label16
    32 ubind UNIT_TYPE
-    * label *label13
    33 jump *label14 equal @unit :areUnitsAvailable:firstUnit
    34 sensor *tmp13 :areUnitsAvailable:firstUnit @dead
    35 jump *label12 equal *tmp13 0
    36 label *label14
    37 label *label10
-    * label *label11
    38 print UNIT_TYPE
    39 print " "
    40 print "occupied: "
    41 print :areUnitsAvailable:occupied
    42 print "\n"
-    * label *label20
-    * label *label21
    43 set *tmp3 false
    44 label *label9
    45 jump *label7 equal *tmp3 false
    46 set *tmp2 UNIT_TYPE
    47 jump *label3 always
    48 label *label7
-    * label *label8
-    * label *label130
    49 jump *label144 equal @flare UNIT_TYPE
    50 set :areUnitsAvailable.1:occupied 0
    51 ubind @flare
 
    59 label *label132
    60 set *tmp20 true
    61 jump *label141 always
-    * jump *label134 always
    62 label *label133
    63 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    64 label *label134
    65 ubind @flare
-    * label *label135
    66 jump *label136 equal @unit :areUnitsAvailable.1:firstUnit
    67 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
    68 jump *label131 equal *tmp30 0
    69 label *label136
    70 label *label137
-    * label *label138
    71 print @flare
    72 print " "
    73 print "occupied: "
    74 print :areUnitsAvailable.1:occupied
    75 print "\n"
-    * label *label139
-    * label *label140
    76 set *tmp20 false
    77 label *label141
    78 jump *label142 equal *tmp20 false
 
    80 set *tmp2 @flare
    81 jump *label3 always
    82 label *label142
-    * label *label143
    83 label *label144
-    * label *label145
-    * label *label146
-    * label *label149
    84 jump *label163 equal @poly UNIT_TYPE
    85 set :areUnitsAvailable.1:occupied 0
    86 ubind @poly
 
    94 label *label151
    95 set *tmp20 true
    96 jump *label160 always
-    * jump *label153 always
    97 label *label152
    98 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
    99 label *label153
   100 ubind @poly
-    * label *label154
   101 jump *label155 equal @unit :areUnitsAvailable.1:firstUnit
   102 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
   103 jump *label150 equal *tmp30 0
   104 label *label155
   105 label *label156
-    * label *label157
   106 print @poly
   107 print " "
   108 print "occupied: "
   109 print :areUnitsAvailable.1:occupied
   110 print "\n"
-    * label *label158
-    * label *label159
   111 set *tmp20 false
   112 label *label160
   113 jump *label161 equal *tmp20 false
 
   115 set *tmp2 @poly
   116 jump *label3 always
   117 label *label161
-    * label *label162
   118 label *label163
-    * label *label164
-    * label *label165
-    * label *label168
   119 jump *label182 equal @mega UNIT_TYPE
   120 set :areUnitsAvailable.1:occupied 0
   121 ubind @mega
 
   129 label *label170
   130 set *tmp20 true
   131 jump *label179 always
-    * jump *label172 always
   132 label *label171
   133 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   134 label *label172
   135 ubind @mega
-    * label *label173
   136 jump *label174 equal @unit :areUnitsAvailable.1:firstUnit
   137 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
   138 jump *label169 equal *tmp30 0
   139 label *label174
   140 label *label175
-    * label *label176
   141 print @mega
   142 print " "
   143 print "occupied: "
   144 print :areUnitsAvailable.1:occupied
   145 print "\n"
-    * label *label177
-    * label *label178
   146 set *tmp20 false
   147 label *label179
   148 jump *label180 equal *tmp20 false
 
   150 set *tmp2 @mega
   151 jump *label3 always
   152 label *label180
-    * label *label181
   153 label *label182
-    * label *label183
-    * label *label184
-    * label *label187
   154 jump *label201 equal @mono UNIT_TYPE
   155 set :areUnitsAvailable.1:occupied 0
   156 ubind @mono
 
   164 label *label189
   165 set *tmp20 true
   166 jump *label198 always
-    * jump *label191 always
   167 label *label190
   168 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   169 label *label191
   170 ubind @mono
-    * label *label192
   171 jump *label193 equal @unit :areUnitsAvailable.1:firstUnit
   172 sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead
   173 jump *label188 equal *tmp30 0
   174 label *label193
   175 label *label194
-    * label *label195
   176 print @mono
   177 print " "
   178 print "occupied: "
   179 print :areUnitsAvailable.1:occupied
   180 print "\n"
-    * label *label196
-    * label *label197
   181 set *tmp20 false
   182 label *label198
   183 jump *label199 equal *tmp20 false
 
   185 set *tmp2 @mono
   186 jump *label3 always
   187 label *label199
-    * label *label200
   188 label *label201
-    * label *label202
-    * label *label203
-    * label *label24
   189 printflush message1
-    * label *label5
   190 jump *label4 always
-    * label *label6
-    * set *tmp2 null
   191 label *label3
   192 jump *label48 always
-    * ubind null
-    * jump *label50 equal *tmp42 false
-    * jump *label47 always
-    * label *label50
-    * label *label51
   193 label *label48
-    * label *label49
   194 ubind *tmp2
   195 set :rebindUnit:firstUnit @unit
   196 jump *label52 equal :rebindUnit:firstUnit null
 
   199 jump *label57 notEqual *tmp47 0
   200 jump *label47 always
   201 label *label57
-    * label *label58
   202 ubind *tmp2
-    * label *label55
   203 jump *label56 equal @unit :rebindUnit:firstUnit
   204 sensor *tmp51 :rebindUnit:firstUnit @dead
   205 jump *label54 equal *tmp51 0
   206 label *label56
   207 label *label52
-    * label *label53
   208 end
   209 label *label47
   210 ucontrol flag 1
   211 set *tmp34 @unit
-    * label *label46
   212 set .UNIT *tmp34
   213 sensor .UNIT_CAPACITY *tmp34 @itemCapacity
   214 sensor .SPEED *tmp34 @speed
 
   217 printflush message1
   218 label *label60
   219 ulocate building core false @copper *tmp57 *tmp58 *tmp59 .CORE
-    * label *label61
   220 jump *label60 equal .CORE null
-    * label *label62
   221 sensor .CORE_X .CORE @x
   222 sensor .CORE_Y .CORE @y
   223 sensor .VAULT_X .VAULT @x
 
   253 jump *label72 equal *tmp79 false
   254 jump *label69 always
   255 label *label72
-    * label *label73
   256 label *label70
-    * label *label71
   257 ubind *tmp2
   258 set :rebindUnit.1:firstUnit @unit
   259 jump *label74 equal :rebindUnit.1:firstUnit null
 
   262 jump *label79 notEqual *tmp84 0
   263 jump *label69 always
   264 label *label79
-    * label *label80
   265 ubind *tmp2
-    * label *label77
   266 jump *label78 equal @unit :rebindUnit.1:firstUnit
   267 sensor *tmp88 :rebindUnit.1:firstUnit @dead
   268 jump *label76 equal *tmp88 0
   269 label *label78
   270 label *label74
-    * label *label75
   271 end
   272 label *label69
   273 sensor :processUnit:state @unit @flag
 
   291 jump *label90 equal *tmp100 false
   292 ucontrol itemDrop .CORE .UNIT_CAPACITY
   293 label *label90
-    * label *label91
   294 label *label89
   295 label *label87
   296 label *label82
-    * label *label83
   297 jump *label92 notEqual :processUnit:state 2
   298 ucontrol within .CORE_X .CORE_Y 8 *tmp104
   299 jump *label94 equal *tmp104 false
 
   319 op div :processUnit:distance *tmp114 10
   320 label *label95
   321 label *label92
-    * label *label93
   322 jump *label98 notEqual :processUnit:state 3
   323 ucontrol within .VAULT_X .VAULT_Y 8 *tmp118
   324 jump *label100 equal *tmp118 false
 
   329 ucontrol approach .CORE_X .CORE_Y 6
   330 set :processUnit:state 2
   331 label *label102
-    * label *label103
   332 jump *label101 always
   333 label *label100
   334 ucontrol approach .VAULT_X .VAULT_Y 6
 
   342 op div :processUnit:distance *tmp128 10
   343 label *label101
   344 label *label98
-    * label *label99
   345 ucontrol flag :processUnit:state
   346 sensor *tmp130 @unit @totalItems
   347 print "["
 
   361 print .MSG
   362 label *label105
   363 set *tmp71 @unit
-    * label *label68
   364 set .UNIT *tmp71
   365 jump *label106 notEqual :processUnit:state 2
   366 sensor *tmp134 .VAULT @thorium
 
   382 label *label124
   383 set *tmp140 true
   384 jump *label116 always
-    * jump *label123 always
   385 label *label122
   386 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
   387 label *label123
   388 ubind UNIT_TYPE
-    * label *label120
   389 jump *label121 equal @unit :areUnitsAvailable.2:firstUnit
   390 sensor *tmp150 :areUnitsAvailable.2:firstUnit @dead
   391 jump *label119 equal *tmp150 0
   392 label *label121
   393 label *label117
-    * label *label118
   394 jump *label127 always
-    * print UNIT_TYPE
-    * print " "
-    * print "occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print "\n"
   395 label *label127
-    * label *label128
   396 set *tmp140 false
   397 label *label116
   398 jump *label114 equal *tmp140 false
   399 end
   400 label *label114
-    * label *label115
   401 op add :unitCheck @time 5000
   402 label *label110
-    * label *label111
   403 label *label107
   404 label *label66
-    * label *label67
   405 op sub *tmp155 @time :start
   406 op floor *tmp156 *tmp155
   407 print "\n"
 
   410 print " "
   411 print "ms"
   412 printflush message1
-    * label *label64
   413 jump *label63 always
-    * label *label65
-    * end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-3 instructions):
 
   191 jump *label52 equal :rebindUnit:firstUnit null
   192 label *label54
   193 sensor *tmp47 @unit @controlled
-    * jump *label57 notEqual *tmp47 0
-    * jump *label47 always
+  194 jump *label47 equal *tmp47 0
   195 label *label57
   196 ubind *tmp2
   197 jump *label56 equal @unit :rebindUnit:firstUnit
 
   244 sensor *tmp77 @unit @controller
   245 op equal *tmp78 *tmp77 @this
   246 op land *tmp79 *tmp76 *tmp78
-    * jump *label72 equal *tmp79 false
-    * jump *label69 always
+  247 jump *label69 notEqual *tmp79 false
   248 label *label72
   249 label *label70
   250 ubind *tmp2
 
   252 jump *label74 equal :rebindUnit.1:firstUnit null
   253 label *label76
   254 sensor *tmp84 @unit @controlled
-    * jump *label79 notEqual *tmp84 0
-    * jump *label69 always
+  255 jump *label69 equal *tmp84 0
   256 label *label79
   257 ubind *tmp2
   258 jump *label78 equal @unit :rebindUnit.1:firstUnit

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @poly
 
    44 label *label9
    45 jump *label7 equal *tmp3 false
    46 set *tmp2 UNIT_TYPE
-    * jump *label3 always
+   47 jump *label48 always
    48 label *label7
    49 jump *label144 equal @flare UNIT_TYPE
    50 set :areUnitsAvailable.1:occupied 0
 
    77 jump *label142 equal *tmp20 false
    78 printflush null
    79 set *tmp2 @flare
-    * jump *label3 always
+   80 jump *label48 always
    81 label *label142
    82 label *label144
    83 jump *label163 equal @poly UNIT_TYPE
 
   111 jump *label161 equal *tmp20 false
   112 printflush null
   113 set *tmp2 @poly
-    * jump *label3 always
+  114 jump *label48 always
   115 label *label161
   116 label *label163
   117 jump *label182 equal @mega UNIT_TYPE
 
   145 jump *label180 equal *tmp20 false
   146 printflush null
   147 set *tmp2 @mega
-    * jump *label3 always
+  148 jump *label48 always
   149 label *label180
   150 label *label182
   151 jump *label201 equal @mono UNIT_TYPE
 
   179 jump *label199 equal *tmp20 false
   180 printflush null
   181 set *tmp2 @mono
-    * jump *label3 always
+  182 jump *label48 always
   183 label *label199
   184 label *label201
   185 printflush message1
 
   189 label *label48
   190 ubind *tmp2
   191 set :rebindUnit:firstUnit @unit
-    * jump *label52 equal :rebindUnit:firstUnit null
+  192 jump __start__ equal :rebindUnit:firstUnit null
   193 label *label54
   194 sensor *tmp47 @unit @controlled
   195 jump *label47 equal *tmp47 0
   196 ubind *tmp2
-    * jump *label56 equal @unit :rebindUnit:firstUnit
+  197 jump __start__ equal @unit :rebindUnit:firstUnit
   198 sensor *tmp51 :rebindUnit:firstUnit @dead
   199 jump *label54 equal *tmp51 0
   200 label *label56
 
   248 label *label70
   249 ubind *tmp2
   250 set :rebindUnit.1:firstUnit @unit
-    * jump *label74 equal :rebindUnit.1:firstUnit null
+  251 jump __start__ equal :rebindUnit.1:firstUnit null
   252 label *label76
   253 sensor *tmp84 @unit @controlled
   254 jump *label69 equal *tmp84 0
   255 ubind *tmp2
-    * jump *label78 equal @unit :rebindUnit.1:firstUnit
+  256 jump __start__ equal @unit :rebindUnit.1:firstUnit
   257 sensor *tmp88 :rebindUnit.1:firstUnit @dead
   258 jump *label76 equal *tmp88 0
   259 label *label78
 
   292 jump *label96 lessThan *tmp106 .UNIT_CAPACITY
   293 ucontrol approach .VAULT_X .VAULT_Y 6
   294 set :processUnit:state 3
-    * jump *label97 always
+  295 jump *label95 always
   296 label *label96
   297 set .MSG ", loading\n"
   298 label *label97
 
   315 ucontrol itemDrop .VAULT .UNIT_CAPACITY
   316 set .MSG ", supplying\n"
   317 sensor *tmp120 @unit @totalItems
-    * jump *label102 greaterThan *tmp120 0
+  318 jump *label101 greaterThan *tmp120 0
   319 ucontrol approach .CORE_X .CORE_Y 6
   320 set :processUnit:state 2
   321 label *label102
 
   363 set :areUnitsAvailable.2:occupied 0
   364 ubind UNIT_TYPE
   365 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label117 equal :areUnitsAvailable.2:firstUnit null
+  366 jump *label127 equal :areUnitsAvailable.2:firstUnit null
   367 label *label119
   368 sensor *tmp144 @unit @controlled
   369 jump *label124 equal *tmp144 0
 
   375 label *label122
   376 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
   377 ubind UNIT_TYPE
-    * jump *label121 equal @unit :areUnitsAvailable.2:firstUnit
+  378 jump *label127 equal @unit :areUnitsAvailable.2:firstUnit
   379 sensor *tmp150 :areUnitsAvailable.2:firstUnit @dead
   380 jump *label119 equal *tmp150 0
   381 label *label121

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-2 instructions):
 
   184 label *label201
   185 printflush message1
   186 jump *label4 always
-    * jump *label48 always
   187 label *label48
   188 ubind *tmp2
   189 set :rebindUnit:firstUnit @unit
 
   370 jump *label127 equal @unit :areUnitsAvailable.2:firstUnit
   371 sensor *tmp150 :areUnitsAvailable.2:firstUnit @dead
   372 jump *label119 equal *tmp150 0
-    * jump *label127 always
   373 label *label127
   374 set *tmp140 false
   375 label *label116

Modifications by Final phase, Temp Variables Elimination, iteration 1 (-1 instructions):
 
   206 print "[gold]Locating core..."
   207 printflush message1
   208 label *label60
-    * ulocate building core false @copper *tmp57 *tmp58 *tmp59 .CORE
+  209 ulocate building core false @copper 0 0 0 .CORE
   210 jump *label60 equal .CORE null
   211 sensor .CORE_X .CORE @x
   212 sensor .CORE_Y .CORE @y
 
   342 label *label104
   343 print .MSG
   344 label *label105
-    * set *tmp71 @unit
-    * set .UNIT *tmp71
+  345 set .UNIT @unit
   346 jump *label106 notEqual :processUnit:state 2
   347 sensor *tmp134 .VAULT @thorium
   348 jump *label106 lessThan *tmp134 500

Modifications by Final phase, Print Merging, iteration 1 (-26 instructions):
 
    13 label *label2
    14 label *label4
    15 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   16 print "[gold]Looking for suitable unit type:[]\n"
    17 set :areUnitsAvailable:occupied 0
    18 ubind UNIT_TYPE
    19 set :areUnitsAvailable:firstUnit @unit
 
    35 label *label14
    36 label *label10
    37 print UNIT_TYPE
-    * print " "
-    * print "occupied: "
+   38 print " occupied: "
    39 print :areUnitsAvailable:occupied
    40 print "\n"
    41 set *tmp3 false
 
    65 jump *label131 equal *tmp30 0
    66 label *label136
    67 label *label137
-    * print @flare
-    * print " "
-    * print "occupied: "
+   68 print "flare occupied: "
    69 print :areUnitsAvailable.1:occupied
    70 print "\n"
    71 set *tmp20 false
 
    97 jump *label150 equal *tmp30 0
    98 label *label155
    99 label *label156
-    * print @poly
-    * print " "
-    * print "occupied: "
+  100 print "poly occupied: "
   101 print :areUnitsAvailable.1:occupied
   102 print "\n"
   103 set *tmp20 false
 
   129 jump *label169 equal *tmp30 0
   130 label *label174
   131 label *label175
-    * print @mega
-    * print " "
-    * print "occupied: "
+  132 print "mega occupied: "
   133 print :areUnitsAvailable.1:occupied
   134 print "\n"
   135 set *tmp20 false
 
   161 jump *label188 equal *tmp30 0
   162 label *label193
   163 label *label194
-    * print @mono
-    * print " "
-    * print "occupied: "
+  164 print "mono occupied: "
   165 print :areUnitsAvailable.1:occupied
   166 print "\n"
   167 set *tmp20 false
 
   205 op add :unitCheck @time 5000
   206 label *label63
   207 set :start @time
-    * print " === [gold]Supplying Power Plant[] === "
-    * print "\n"
-    * print "\n"
   208 sensor *tmp67 .VAULT @thorium
-    * print "\n"
-    * print "[gold]Thorium[] status: [green]"
+  209 print " === [gold]Supplying Power Plant[] === \n\n\n[gold]Thorium[] status: [green]"
   210 print *tmp67
-    * print "["
-    * print "]"
-    * print "\n"
+  211 print "[]\n"
   212 sensor *tmp68 .VAULT @thorium
   213 jump *label66 greaterThanEq *tmp68 500
-    * print "\n"
-    * print "Unit type: [green]"
+  214 print "\nUnit type: [green]"
   215 print *tmp2
-    * print "["
-    * print "]"
-    * print "\n"
+  216 print "[]\n"
   217 jump *label70 equal .UNIT null
   218 ubind .UNIT
   219 sensor *tmp75 @unit @dead
 
   307 label *label98
   308 ucontrol flag :processUnit:state
   309 sensor *tmp130 @unit @totalItems
-    * print "["
-    * print "gold"
-    * print "]"
+  310 print "[gold]"
   311 print *tmp130
-    * print "["
-    * print "]"
+  312 print "[]"
   313 jump *label104 lessThan :processUnit:distance 0
   314 print .MSG
   315 print :processUnit:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  316 print "[] sec\n"
   317 jump *label105 always
   318 label *label104
   319 print .MSG
 
   357 label *label66
   358 op sub *tmp155 @time :start
   359 op floor *tmp156 *tmp155
-    * print "\n"
-    * print "[lightgray]Loop time: "
+  360 print "\n[lightgray]Loop time: "
   361 print *tmp156
-    * print " "
-    * print "ms"
+  362 print " ms"
   363 printflush message1
   364 jump *label63 always

Final code before resolving virtual instructions:

        label __start__
    0:  remark "This is the preferred unit type to use for bringing  /// This is the preferred unit type to use for bringing in supplies.
    2:  remark "If no units of this type exist, we'll try using othe /// If no units of this type exist, we'll try using other types.
    3:  set UNIT_TYPE @poly                                          param UNIT_TYPE         = @poly;  // Which unit to use
    4:  remark "Do not modify anything below this line."             /// Do not modify anything below this line.
    6:  set .MSG ""                                                  MSG = "";
    7:  set .VAULT vault1                                            VAULT = vault1;
    8:  sensor *tmp0 vault1 @dead                                    while VAULT.@dead != 0 do
    9:  jump *label2 equal *tmp0 0                                   ...
        label *label129                                              ...
   10:  set .VAULT vault1                                            VAULT = vault1;
   11:  sensor *tmp0 vault1 @dead                                    while VAULT.@dead != 0 do
   12:  jump *label129 notEqual *tmp0 0                              ...
        label *label2                                                ...
        label *label4                                                while true do
   13:  printflush null                                              printflush(null);       // empty text buffer
   14:  print "[gold]Looking for suitable unit type:[]\n"            println("[gold]Looking for suitable unit type:[]");
   15:  set :areUnitsAvailable:occupied 0                            occupied = 0;
   16:  ubind UNIT_TYPE                                              firstUnit = ubind(type);
   17:  set :areUnitsAvailable:firstUnit @unit                       ...
   18:  jump *label10 equal :areUnitsAvailable:firstUnit null        if firstUnit != null then
        label *label12                                               do
   19:  sensor *tmp7 @unit @controlled                               if @unit.@controlled == 0 or @unit.@controller == @this then
   20:  jump *label17 equal *tmp7 0                                  ...
   21:  sensor *tmp9 @unit @controller                               ...
   22:  jump *label15 notEqual *tmp9 @this                           ...
        label *label17                                               ...
   23:  set *tmp3 true                                               return true;
   24:  jump *label9 always 0 0                                      ...
        label *label15                                               if @unit.@controlled == 0 or @unit.@controller == @this then
   25:  op add :areUnitsAvailable:occupied :areUnitsAvailable:occupi occupied += 1;
   26:  ubind UNIT_TYPE                                              ubind(type);
   27:  jump *label14 equal @unit :areUnitsAvailable:firstUnit       while @unit != firstUnit and firstUnit.@dead == 0;
   28:  sensor *tmp13 :areUnitsAvailable:firstUnit @dead             ...
   29:  jump *label12 equal *tmp13 0                                 ...
        label *label14                                               do
        label *label10                                               if firstUnit != null then
   30:  print UNIT_TYPE                                              print($"$type occupied: $occupied");
   31:  print " occupied: "                                          ...
   32:  print :areUnitsAvailable:occupied                            ...
   33:  print "\n"                                                   println();
   34:  set *tmp3 false                                              return false;
        label *label9                                                if areUnitsAvailable(UNIT_TYPE, true) then
   35:  jump *label7 equal *tmp3 false                               ...
   36:  set *tmp2 UNIT_TYPE                                          return UNIT_TYPE;
   37:  jump *label48 always 0 0                                     ...
        label *label7                                                if areUnitsAvailable(UNIT_TYPE, true) then
   38:  jump *label144 equal @flare UNIT_TYPE                        if type != UNIT_TYPE then
   39:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
   40:  ubind @flare                                                 firstUnit = ubind(type);
   41:  set :areUnitsAvailable.1:firstUnit @unit                     ...
   42:  jump *label137 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label131                                              do
   43:  sensor *tmp24 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
   44:  jump *label132 equal *tmp24 0                                ...
   45:  sensor *tmp26 @unit @controller                              ...
   46:  jump *label133 notEqual *tmp26 @this                         ...
        label *label132                                              ...
   47:  set *tmp20 true                                              return true;
   48:  jump *label141 always 0 0                                    ...
        label *label133                                              if @unit.@controlled == 0 or @unit.@controller == @this then
   49:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
   50:  ubind @flare                                                 ubind(type);
   51:  jump *label136 equal @unit :areUnitsAvailable.1:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
   52:  sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead           ...
   53:  jump *label131 equal *tmp30 0                                ...
        label *label136                                              do
        label *label137                                              if firstUnit != null then
   54:  print "flare occupied: "                                     print($"$type occupied: $occupied");
   55:  print :areUnitsAvailable.1:occupied                          ...
   56:  print "\n"                                                   println();
   57:  set *tmp20 false                                             return false;
        label *label141                                              if areUnitsAvailable(type, true) then
   58:  jump *label142 equal *tmp20 false                            ...
   59:  printflush null                                              printflush(null);
   60:  set *tmp2 @flare                                             return type;
   61:  jump *label48 always 0 0                                     ...
        label *label142                                              if areUnitsAvailable(type, true) then
        label *label144                                              if type != UNIT_TYPE then
   62:  jump *label163 equal @poly UNIT_TYPE                         ...
   63:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
   64:  ubind @poly                                                  firstUnit = ubind(type);
   65:  set :areUnitsAvailable.1:firstUnit @unit                     ...
   66:  jump *label156 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label150                                              do
   67:  sensor *tmp24 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
   68:  jump *label151 equal *tmp24 0                                ...
   69:  sensor *tmp26 @unit @controller                              ...
   70:  jump *label152 notEqual *tmp26 @this                         ...
        label *label151                                              ...
   71:  set *tmp20 true                                              return true;
   72:  jump *label160 always 0 0                                    ...
        label *label152                                              if @unit.@controlled == 0 or @unit.@controller == @this then
   73:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
   74:  ubind @poly                                                  ubind(type);
   75:  jump *label155 equal @unit :areUnitsAvailable.1:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
   76:  sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead           ...
   77:  jump *label150 equal *tmp30 0                                ...
        label *label155                                              do
        label *label156                                              if firstUnit != null then
   78:  print "poly occupied: "                                      print($"$type occupied: $occupied");
   79:  print :areUnitsAvailable.1:occupied                          ...
   80:  print "\n"                                                   println();
   81:  set *tmp20 false                                             return false;
        label *label160                                              if areUnitsAvailable(type, true) then
   82:  jump *label161 equal *tmp20 false                            ...
   83:  printflush null                                              printflush(null);
   84:  set *tmp2 @poly                                              return type;
   85:  jump *label48 always 0 0                                     ...
        label *label161                                              if areUnitsAvailable(type, true) then
        label *label163                                              if type != UNIT_TYPE then
   86:  jump *label182 equal @mega UNIT_TYPE                         ...
   87:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
   88:  ubind @mega                                                  firstUnit = ubind(type);
   89:  set :areUnitsAvailable.1:firstUnit @unit                     ...
   90:  jump *label175 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label169                                              do
   91:  sensor *tmp24 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
   92:  jump *label170 equal *tmp24 0                                ...
   93:  sensor *tmp26 @unit @controller                              ...
   94:  jump *label171 notEqual *tmp26 @this                         ...
        label *label170                                              ...
   95:  set *tmp20 true                                              return true;
   96:  jump *label179 always 0 0                                    ...
        label *label171                                              if @unit.@controlled == 0 or @unit.@controller == @this then
   97:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
   98:  ubind @mega                                                  ubind(type);
   99:  jump *label174 equal @unit :areUnitsAvailable.1:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
  100:  sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead           ...
  101:  jump *label169 equal *tmp30 0                                ...
        label *label174                                              do
        label *label175                                              if firstUnit != null then
  102:  print "mega occupied: "                                      print($"$type occupied: $occupied");
  103:  print :areUnitsAvailable.1:occupied                          ...
  104:  print "\n"                                                   println();
  105:  set *tmp20 false                                             return false;
        label *label179                                              if areUnitsAvailable(type, true) then
  106:  jump *label180 equal *tmp20 false                            ...
  107:  printflush null                                              printflush(null);
  108:  set *tmp2 @mega                                              return type;
  109:  jump *label48 always 0 0                                     ...
        label *label180                                              if areUnitsAvailable(type, true) then
        label *label182                                              if type != UNIT_TYPE then
  110:  jump *label201 equal @mono UNIT_TYPE                         ...
  111:  set :areUnitsAvailable.1:occupied 0                          occupied = 0;
  112:  ubind @mono                                                  firstUnit = ubind(type);
  113:  set :areUnitsAvailable.1:firstUnit @unit                     ...
  114:  jump *label194 equal :areUnitsAvailable.1:firstUnit null     if firstUnit != null then
        label *label188                                              do
  115:  sensor *tmp24 @unit @controlled                              if @unit.@controlled == 0 or @unit.@controller == @this then
  116:  jump *label189 equal *tmp24 0                                ...
  117:  sensor *tmp26 @unit @controller                              ...
  118:  jump *label190 notEqual *tmp26 @this                         ...
        label *label189                                              ...
  119:  set *tmp20 true                                              return true;
  120:  jump *label198 always 0 0                                    ...
        label *label190                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  121:  op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:oc occupied += 1;
  122:  ubind @mono                                                  ubind(type);
  123:  jump *label193 equal @unit :areUnitsAvailable.1:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
  124:  sensor *tmp30 :areUnitsAvailable.1:firstUnit @dead           ...
  125:  jump *label188 equal *tmp30 0                                ...
        label *label193                                              do
        label *label194                                              if firstUnit != null then
  126:  print "mono occupied: "                                      print($"$type occupied: $occupied");
  127:  print :areUnitsAvailable.1:occupied                          ...
  128:  print "\n"                                                   println();
  129:  set *tmp20 false                                             return false;
        label *label198                                              if areUnitsAvailable(type, true) then
  130:  jump *label199 equal *tmp20 false                            ...
  131:  printflush null                                              printflush(null);
  132:  set *tmp2 @mono                                              return type;
  133:  jump *label48 always 0 0                                     ...
        label *label199                                              if areUnitsAvailable(type, true) then
        label *label201                                              if type != UNIT_TYPE then
  134:  printflush message1                                          printflush(message1);
  135:  jump *label4 always 0 0                                      while true do
        label *label48                                               if currentUnit != null then
  136:  ubind *tmp2                                                  firstUnit = ubind(TYPE);
  137:  set :rebindUnit:firstUnit @unit                              ...
  138:  jump __start__ equal :rebindUnit:firstUnit null              if firstUnit != null then
        label *label54                                               do
  139:  sensor *tmp47 @unit @controlled                              if @unit.@controlled == 0 then
  140:  jump *label47 equal *tmp47 0                                 ...
  141:  ubind *tmp2                                                  ubind(TYPE);
  142:  jump __start__ equal @unit :rebindUnit:firstUnit             while @unit != firstUnit and firstUnit.@dead == 0;
  143:  sensor *tmp51 :rebindUnit:firstUnit @dead                    ...
  144:  jump *label54 equal *tmp51 0                                 ...
  145:  end                                                          end();
        label *label47                                               rebindUnit(currentUnit);
  146:  ucontrol flag 1 0 0 0 0                                      flag(S_INIT);
  147:  set *tmp34 @unit                                             return @unit;
  148:  set .UNIT *tmp34                                             UNIT = acquireUnit(UNIT);
  149:  sensor .UNIT_CAPACITY *tmp34 @itemCapacity                   UNIT_CAPACITY = UNIT.@itemCapacity;
  150:  sensor .SPEED *tmp34 @speed                                  SPEED = UNIT.@speed;
  151:  op div .SPEED_TENTHS .SPEED 10                               SPEED_TENTHS = SPEED / 10;
  152:  print "[gold]Locating core..."                               print("[gold]Locating core...");
  153:  printflush message1                                          printflush(message1);
        label *label60                                               do
  154:  ulocate building core false @copper 0 0 0 .CORE              CORE = ulocate(:building, :core, false);
  155:  jump *label60 equal .CORE null                               do
  156:  sensor .CORE_X .CORE @x                                      CORE_X = CORE.@x;
  157:  sensor .CORE_Y .CORE @y                                      CORE_Y = CORE.@y;
  158:  sensor .VAULT_X .VAULT @x                                    VAULT_X = VAULT.@x;
  159:  sensor .VAULT_Y .VAULT @y                                    VAULT_Y = VAULT.@y;
  160:  op add :unitCheck @time 5000                                 unitCheck = @time + UNIT_CHECK_TIME;
        label *label63                                               while true do
  161:  set :start @time                                             start = @time;
  162:  sensor *tmp67 .VAULT @thorium                                println($"\n[gold]Thorium[] status: [green]$[]", VAULT.sensor(ITEM));
  163:  print " === [gold]Supplying Power Plant[] === \n\n\n[gold]Th ...
  164:  print *tmp67                                                 ...
  165:  print "[]\n"                                                 ...
  166:  sensor *tmp68 .VAULT @thorium                                if VAULT.sensor(ITEM) < 500 then
  167:  jump *label66 greaterThanEq *tmp68 500                       ...
  168:  print "\nUnit type: [green]"                                 println($"\nUnit type: [green]$TYPE[]");
  169:  print *tmp2                                                  ...
  170:  print "[]\n"                                                 ...
  171:  jump *label70 equal .UNIT null                               if currentUnit != null then
  172:  ubind .UNIT                                                  ubind(currentUnit);
  173:  sensor *tmp75 @unit @dead                                    if @unit.@dead == 0 && @unit.@controller == @this then
  174:  op equal *tmp76 *tmp75 0                                     ...
  175:  sensor *tmp77 @unit @controller                              ...
  176:  op equal *tmp78 *tmp77 @this                                 ...
  177:  op land *tmp79 *tmp76 *tmp78                                 ...
  178:  jump *label69 notEqual *tmp79 false                          ...
        label *label70                                               if currentUnit != null then
  179:  ubind *tmp2                                                  firstUnit = ubind(TYPE);
  180:  set :rebindUnit.1:firstUnit @unit                            ...
  181:  jump __start__ equal :rebindUnit.1:firstUnit null            if firstUnit != null then
        label *label76                                               do
  182:  sensor *tmp84 @unit @controlled                              if @unit.@controlled == 0 then
  183:  jump *label69 equal *tmp84 0                                 ...
  184:  ubind *tmp2                                                  ubind(TYPE);
  185:  jump __start__ equal @unit :rebindUnit.1:firstUnit           while @unit != firstUnit and firstUnit.@dead == 0;
  186:  sensor *tmp88 :rebindUnit.1:firstUnit @dead                  ...
  187:  jump *label76 equal *tmp88 0                                 ...
  188:  end                                                          end();
        label *label69                                               unit = rebindUnit(unit);
  189:  sensor :processUnit:state @unit @flag                        state = @unit.@flag;
  190:  set :processUnit:distance -1                                 distance = -1;
  191:  jump *label84 lessThan :processUnit:state 2                  if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  192:  jump *label82 lessThanEq :processUnit:state 3                ...
        label *label84                                               ...
  193:  sensor *tmp94 @unit @firstItem                               if @unit.@firstItem == ITEM then
  194:  jump *label86 notEqual *tmp94 @thorium                       ...
  195:  set :processUnit:state 3                                     state = S_APPROACH_DST;
  196:  jump *label87 always 0 0                                     if @unit.@firstItem == ITEM then
        label *label86                                               ...
  197:  sensor *tmp97 @unit @totalItems                              elsif @unit.@totalItems == 0 then
  198:  jump *label88 notEqual *tmp97 0                              ...
  199:  set :processUnit:state 2                                     state = S_APPROACH_SRC;
  200:  jump *label89 always 0 0                                     elsif @unit.@totalItems == 0 then
        label *label88                                               ...
  201:  set .MSG ", initializing\n"                                  MSG = ", initializing\n";
  202:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  203:  ucontrol within .CORE_X .CORE_Y 8 *tmp100 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  204:  jump *label90 equal *tmp100 false                            ...
  205:  ucontrol itemDrop .CORE .UNIT_CAPACITY 0 0 0                 itemDrop(CORE, UNIT_CAPACITY);
        label *label90                                               if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label89                                               elsif @unit.@totalItems == 0 then
        label *label87                                               if @unit.@firstItem == ITEM then
        label *label82                                               if state < S_APPROACH_SRC or state > S_APPROACH_DST then
  206:  jump *label92 notEqual :processUnit:state 2                  if state == S_APPROACH_SRC then
  207:  ucontrol within .CORE_X .CORE_Y 8 *tmp104 0                  if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
  208:  jump *label94 equal *tmp104 false                            ...
  209:  ucontrol itemTake .CORE @thorium .UNIT_CAPACITY 0 0          itemTake(CORE, ITEM, UNIT_CAPACITY);
  210:  sensor *tmp106 @unit @totalItems                             if @unit.@totalItems >= UNIT_CAPACITY then
  211:  jump *label96 lessThan *tmp106 .UNIT_CAPACITY                ...
  212:  ucontrol approach .VAULT_X .VAULT_Y 6 0 0                    approach(VAULT_X, VAULT_Y, RADIUS_APPROACH);
  213:  set :processUnit:state 3                                     state = S_APPROACH_DST;
  214:  jump *label95 always 0 0                                     if @unit.@totalItems >= UNIT_CAPACITY then
        label *label96                                               ...
  215:  set .MSG ", loading\n"                                       MSG = ", loading\n";
  216:  jump *label95 always 0 0                                     if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label94                                               ...
  217:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  218:  set .MSG ", fetching in [gold]"                              MSG = ", fetching in [gold]";
  219:  sensor *tmp109 @unit @x                                      distance = len(CORE_X - @unit.@x, CORE_Y - @unit.@y) \ SPEED_TENTHS / 10;
  220:  op sub *tmp110 .CORE_X *tmp109                               ...
  221:  sensor *tmp111 @unit @y                                      ...
  222:  op sub *tmp112 .CORE_Y *tmp111                               ...
  223:  op len *tmp113 *tmp110 *tmp112                               ...
  224:  op idiv *tmp114 *tmp113 .SPEED_TENTHS                        ...
  225:  op div :processUnit:distance *tmp114 10                      ...
        label *label95                                               if within(CORE_X, CORE_Y, RADIUS_WITHIN) then
        label *label92                                               if state == S_APPROACH_SRC then
  226:  jump *label98 notEqual :processUnit:state 3                  if state == S_APPROACH_DST then
  227:  ucontrol within .VAULT_X .VAULT_Y 8 *tmp118 0                if within(VAULT_X, VAULT_Y, RADIUS_WITHIN) then
  228:  jump *label100 equal *tmp118 false                           ...
  229:  ucontrol itemDrop .VAULT .UNIT_CAPACITY 0 0 0                itemDrop(VAULT, UNIT_CAPACITY);
  230:  set .MSG ", supplying\n"                                     MSG = ", supplying\n";
  231:  sensor *tmp120 @unit @totalItems                             if @unit.@totalItems <= 0 then
  232:  jump *label101 greaterThan *tmp120 0                         ...
  233:  ucontrol approach .CORE_X .CORE_Y 6 0 0                      approach(CORE_X, CORE_Y, RADIUS_APPROACH);
  234:  set :processUnit:state 2                                     state = S_APPROACH_SRC;
  235:  jump *label101 always 0 0                                    if within(VAULT_X, VAULT_Y, RADIUS_WITHIN) then
        label *label100                                              ...
  236:  ucontrol approach .VAULT_X .VAULT_Y 6 0 0                    approach(VAULT_X, VAULT_Y, RADIUS_APPROACH);
  237:  set .MSG ", returning in [gold]"                             MSG = ", returning in [gold]";
  238:  sensor *tmp123 @unit @x                                      distance = len(VAULT_X - @unit.@x, VAULT_Y - @unit.@y) \ SPEED_TENTHS / 10;
  239:  op sub *tmp124 .VAULT_X *tmp123                              ...
  240:  sensor *tmp125 @unit @y                                      ...
  241:  op sub *tmp126 .VAULT_Y *tmp125                              ...
  242:  op len *tmp127 *tmp124 *tmp126                               ...
  243:  op idiv *tmp128 *tmp127 .SPEED_TENTHS                        ...
  244:  op div :processUnit:distance *tmp128 10                      ...
        label *label101                                              if within(VAULT_X, VAULT_Y, RADIUS_WITHIN) then
        label *label98                                               if state == S_APPROACH_DST then
  245:  ucontrol flag :processUnit:state 0 0 0 0                     flag(state);
  246:  sensor *tmp130 @unit @totalItems                             print($"[$color]$[]", @unit.@totalItems);
  247:  print "[gold]"                                               ...
  248:  print *tmp130                                                ...
  249:  print "[]"                                                   ...
  250:  jump *label104 lessThan :processUnit:distance 0              if distance >= 0 then
  251:  print .MSG                                                   println($"$MSG$distance[] sec");
  252:  print :processUnit:distance                                  ...
  253:  print "[] sec\n"                                             ...
  254:  jump *label105 always 0 0                                    if distance >= 0 then
        label *label104                                              ...
  255:  print .MSG                                                   print(MSG);
        label *label105                                              if distance >= 0 then
  256:  set .UNIT @unit                                              UNIT = processUnit(UNIT, out state);
  257:  jump *label106 notEqual :processUnit:state 2                 if state == S_APPROACH_SRC and VAULT.sensor(ITEM) >= 500 then
  258:  sensor *tmp134 .VAULT @thorium                               ...
  259:  jump *label106 lessThan *tmp134 500                          ...
  260:  ucontrol unbind 0 0 0 0 0                                    unbind();
  261:  jump *label107 always 0 0                                    if state == S_APPROACH_SRC and VAULT.sensor(ITEM) >= 500 then
        label *label106                                              ...
  262:  jump *label110 equal *tmp2 UNIT_TYPE                         elsif TYPE != UNIT_TYPE and unitCheck > @time then
  263:  jump *label110 lessThanEq :unitCheck @time                   ...
  264:  set :areUnitsAvailable.2:occupied 0                          occupied = 0;
  265:  ubind UNIT_TYPE                                              firstUnit = ubind(type);
  266:  set :areUnitsAvailable.2:firstUnit @unit                     ...
  267:  jump *label127 equal :areUnitsAvailable.2:firstUnit null     if firstUnit != null then
        label *label119                                              do
  268:  sensor *tmp144 @unit @controlled                             if @unit.@controlled == 0 or @unit.@controller == @this then
  269:  jump *label124 equal *tmp144 0                               ...
  270:  sensor *tmp146 @unit @controller                             ...
  271:  jump *label122 notEqual *tmp146 @this                        ...
        label *label124                                              ...
  272:  set *tmp140 true                                             return true;
  273:  jump *label116 always 0 0                                    ...
        label *label122                                              if @unit.@controlled == 0 or @unit.@controller == @this then
  274:  op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:oc occupied += 1;
  275:  ubind UNIT_TYPE                                              ubind(type);
  276:  jump *label127 equal @unit :areUnitsAvailable.2:firstUnit    while @unit != firstUnit and firstUnit.@dead == 0;
  277:  sensor *tmp150 :areUnitsAvailable.2:firstUnit @dead          ...
  278:  jump *label119 equal *tmp150 0                               ...
        label *label127                                              if output then
  279:  set *tmp140 false                                            return false;
        label *label116                                              if areUnitsAvailable(UNIT_TYPE, false) then
  280:  jump *label114 equal *tmp140 false                           ...
  281:  end                                                          end();
        label *label114                                              if areUnitsAvailable(UNIT_TYPE, false) then
  282:  op add :unitCheck @time 5000                                 unitCheck = @time + UNIT_CHECK_TIME;
        label *label110                                              elsif TYPE != UNIT_TYPE and unitCheck > @time then
        label *label107                                              if state == S_APPROACH_SRC and VAULT.sensor(ITEM) >= 500 then
        label *label66                                               if VAULT.sensor(ITEM) < 500 then
  283:  op sub *tmp155 @time :start                                  print($"\n[lightgray]Loop time: $ ms", floor(@time - start));
  284:  op floor *tmp156 *tmp155 0                                   ...
  285:  print "\n[lightgray]Loop time: "                             ...
  286:  print *tmp156                                                ...
  287:  print " ms"                                                  ...
  288:  printflush message1                                          printflush(message1);
  289:  jump *label63 always 0 0                                     while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   112     6x     18,7  inline def areUnitsAvailable(in type, in output)
    67     1x     67,0  inline def processUnit(in unit, out state)
    55     1x     55,0  <no function>
    28     2x     14,0  inline def rebindUnit(in currentUnit)
    27     1x     27,0  inline def chooseUnitType()
     2     1x      2,0  inline def acquireUnit(in currentUnit)

Performance: parsed in 250 ms, compiled in 326 ms, optimized in 507 ms, run in 16 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (6 steps):
The program didn't generate any output.
Execution exception at instruction 8: sensor *tmp0 vault1 @dead:
Instruction not supported by Mindcode emulator.
(Use the '#set err-unsupported-opcode = false;' directive or the '--err-unsupported-opcode false' command line option to ignore this exception.)
