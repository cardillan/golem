   425 instructions before optimizations.
    47 instructions eliminated by Temp Variables Elimination (8 iterations).
     1 instructions eliminated by Case Expression Optimization.
    44 instructions eliminated by Dead Code Elimination (6 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 7 iterations).
    23 instructions eliminated by Jump Optimization (7 iterations).
    15 instructions eliminated by Single Step Elimination (2 passes, 9 iterations).
     4 instructions eliminated by Expression Optimization (3 passes, 5 iterations).
     4 instructions eliminated by If Expression Optimization (2 passes, 7 iterations).
    51 instructions eliminated by Data Flow Optimization (8 passes, 26 iterations).
     2 loops improved by Loop Hoisting.
     3 instructions eliminated by Loop Optimization (5 iterations).
     5 loops improved by Loop Optimization.
   741 instructions added by Loop Unrolling (11 iterations).
     4 loops unrolled by Loop Unrolling.
    11 instructions added by Function Inlining (11 iterations).
     4 function calls inlined by Function Inlining.
    68 instructions eliminated by Jump Straightening (2 passes, 7 iterations).
     6 instructions updated by Jump Threading.
     6 instructions eliminated by Unreachable Code Elimination (2 iterations).
     7 instructions eliminated by Print Merging.
   901 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 751):
    Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity
  * Unroll iteration loop at *blocks:68:13                       size    -9, benefit     9375.0, efficiency   Infinity (-3 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
    Unroll loop at mandelbrot-compute.mnd:139:5                  size  +679, benefit 24609375.0, efficiency  36243.557
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107

Pass 1: speed optimization selection (cost limit 754):
    Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity
  * Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity (-2 instructions)
    Unroll loop at mandelbrot-compute.mnd:139:5                  size  +679, benefit 24609375.0, efficiency  36243.557
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107

Pass 1: speed optimization selection (cost limit 756):
  * Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll loop at mandelbrot-compute.mnd:139:5                  size  +679, benefit 24609375.0, efficiency  36243.557
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107

Pass 1: speed optimization selection (cost limit 760):
  * Unroll loop at mandelbrot-compute.mnd:139:5                  size  +679, benefit 24609375.0, efficiency  36243.557 (+743 instructions)
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107

Pass 1: speed optimization selection (cost limit 17):
  * Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625 (+1 instructions)
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107

Pass 1: speed optimization selection (cost limit 16):
  * Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000 (+7 instructions)
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   338 set *tmp88 :drawPixel:color
   339 jump *label73 always
   340 label *label72
-    * set *tmp90 .PALETTE
-    * jump *label76 equal *tmp90 2
+  341 jump *label76 equal .PALETTE 2
   342 jump *label75 always
   343 label *label76
   344 op sub *tmp91 32 :drawPixel:iterations
 
   364 set *tmp89 :drawPixel:color
   365 jump *label74 always
   366 label *label75
-    * jump *label78 equal *tmp90 3
+  367 jump *label78 equal .PALETTE 3
   368 jump *label77 always
   369 label *label78
   370 op div *tmp107 :drawPixel:iterations 63
 
   386 set *tmp89 :drawPixel:color
   387 jump *label74 always
   388 label *label77
-    * jump *label80 equal *tmp90 4
+  389 jump *label80 equal .PALETTE 4
   390 jump *label79 always
   391 label *label80
   392 op mul *tmp119 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-30 instructions):
 
    65 label *label22
    66 set *tmp21 null
    67 label *label23
-    * set *tmp19 *tmp21
    68 jump *label21 always
    69 label *label20
-    * set *tmp19 null
    70 label *label21
    71 label *label16
    72 multijump *tmp17 0 0 (m:marker1)
 
    98 print :findLinkedBlocks:variable
    99 jump *label29 equal :findLinkedBlocks:required false
   100 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * set *tmp23 :findLinkedBlocks:foundAll
   101 jump *label30 always
   102 label *label29
-    * set *tmp23 null
   103 label *label30
   104 label *label25
   105 multijump *tmp22 0 0 (m:marker2)
 
   187 jump *label48 equal .JULIA false
   188 set :compute:cx .JULIA_X
   189 set :compute:cy .JULIA_Y
-    * set *tmp46 :compute:cy
   190 jump *label49 always
   191 label *label48
   192 set :compute:cx :compute:zx
 
   202 jump *label50 equal *tmp53 false
   203 set *tmp41 63
   204 jump *label47 always
-    * set *tmp54 null
   205 jump *label51 always
   206 label *label50
-    * set *tmp54 null
   207 label *label51
   208 op add *tmp55 :compute:cx 1
   209 op len *tmp56 *tmp55 :compute:cy
 
   216 label *label52
   217 set *tmp58 null
   218 label *label53
-    * set *tmp46 *tmp58
   219 label *label49
   220 set :compute:i 0
   221 label *label54
 
   236 op greaterThanEq *tmp67 :compute:dist 64
   237 jump *label57 equal *tmp67 false
   238 jump *label56 always
-    * set *tmp68 null
   239 jump *label58 always
   240 label *label57
-    * set *tmp68 null
   241 label *label58
   242 label *label55
   243 op add :compute:i :compute:i 1
 
   253 op sub *tmp76 4 *tmp75
   254 set :compute:correction *tmp76
   255 op add :compute:i :compute:i :compute:correction
-    * set *tmp71 :compute:i
   256 jump *label60 always
   257 label *label59
-    * set *tmp71 null
   258 label *label60
   259 set *tmp41 :compute:i
   260 jump *label47 always
 
   272 op notEqual *tmp79 *tmp78 .PROCESSOR_ID
   273 jump *label62 equal *tmp79 false
   274 jump *label46 always
-    * set *tmp80 null
   275 jump *label63 always
   276 label *label62
-    * set *tmp80 null
   277 label *label63
   278 read *tmp1 .memory 65
   279 op notEqual *tmp81 .stop *tmp1
   280 jump *label64 equal *tmp81 false
   281 jump *label32 always
-    * set *tmp82 null
   282 jump *label65 always
   283 label *label64
-    * set *tmp82 null
   284 label *label65
   285 label *label45
   286 op add :y :y 1
   287 jump *label44 always
   288 label *label46
-    * set *tmp38 null
   289 jump *label43 always
   290 label *label42
-    * set *tmp38 null
   291 label *label43
   292 op add :line :line :increment
   293 op greaterThan *tmp83 :line 176
 
   296 set :increment :next_increment
   297 op div *tmp85 :increment 2
   298 set :line *tmp85
-    * set *tmp84 :line
   299 jump *label67 always
   300 label *label66
-    * set *tmp84 null
   301 label *label67
   302 label *label40
   303 op add :lines :lines 1
 
   391 label *label74
   392 set *tmp88 *tmp89
   393 label *label73
-    * set *tmp86 *tmp88
   394 jump *label71 always
   395 label *label70
   396 set *tmp129 :drawPixel:iterations
   397 read *tmp130 .memory *tmp129
   398 set :drawPixel:color *tmp130
-    * set *tmp86 :drawPixel:color
   399 label *label71
   400 op greaterThanEq *tmp131 .localBuffer 254
   401 jump *label81 equal *tmp131 false
   402 setaddr :flushLocalBuffer*retaddr *label83 (h:*label83)
   403 call *label1 *invalid :flushLocalBuffer*retval (m:*label83) (h:*label83)
   404 label *label83
-    * set *tmp132 null
   405 jump *label82 always
   406 label *label81
-    * set *tmp132 null
   407 label *label82
   408 draw col :drawPixel:color
   409 draw rect :drawPixel:x :drawPixel:y 1 1
 
   420 jump *label84 equal *tmp139 false
   421 drawflush .display
   422 set .localBuffer 0
-    * set *tmp140 .localBuffer
   423 jump *label85 always
   424 label *label84
   425 op div *tmp141 1800 .localBuffer
 
   432 label *label86
   433 set *tmp143 null
   434 label *label87
-    * set *tmp140 *tmp143
   435 label *label85
   436 label *label69
   437 return :drawPixel*retaddr
 
   452 op greaterThan *tmp149 *tmp148 250
   453 jump *label94 notEqual *tmp149 false
   454 label *label96
-    * set *tmp147 null
   455 jump *label93 always
   456 label *label92
-    * set *tmp147 null
   457 label *label93
   458 drawflush .display
   459 set .localBuffer 0
 
   471 set *tmp155 .PROC_STATE_INDEX
   472 write :setState:state .memory *tmp155
   473 jump *label100 always
-    * set *tmp154 null
   474 jump *label102 always
   475 label *label101
   476 set *tmp157 .PROC_ID_INDEX
 
   489 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
   490 set *tmp160 .PROC_STATE_INDEX
   491 label *label104
-    * set *tmp154 *tmp160
   492 label *label102
   493 label *label99
   494 jump *label98 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-10 instructions):
 
    60 op equal *tmp20 :findLinkedBlocks:requested @message
    61 jump *label22 equal *tmp20 false
    62 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * set *tmp21 :findLinkedBlocks:message
    63 jump *label23 always
    64 label *label22
-    * set *tmp21 null
    65 label *label23
    66 jump *label21 always
    67 label *label20
 
   209 jump *label52 equal *tmp57 false
   210 set *tmp41 63
   211 jump *label47 always
-    * set *tmp58 null
   212 jump *label53 always
   213 label *label52
-    * set *tmp58 null
   214 label *label53
   215 label *label49
   216 set :compute:i 0
 
   311 op equal *tmp87 :drawPixel:iterations 63
   312 jump *label72 equal *tmp87 false
   313 set :drawPixel:color %[black]
-    * set *tmp88 :drawPixel:color
   314 jump *label73 always
   315 label *label72
   316 jump *label76 equal .PALETTE 2
 
   384 set :drawPixel:color *tmp128
   385 set *tmp89 :drawPixel:color
   386 label *label74
-    * set *tmp88 *tmp89
   387 label *label73
   388 jump *label71 always
   389 label *label70
 
   421 jump *label86 equal *tmp142 false
   422 drawflush .display
   423 set .localBuffer 0
-    * set *tmp143 .localBuffer
   424 jump *label87 always
   425 label *label86
-    * set *tmp143 null
   426 label *label87
   427 label *label85
   428 label *label69
 
   474 set *tmp163 .PROC_STATE_INDEX
   475 write :setState:state .memory *tmp163
   476 jump *label100 always
-    * set *tmp160 null
   477 jump *label104 always
   478 label *label103
   479 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   480 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * set *tmp160 .PROC_STATE_INDEX
   481 label *label104
   482 label *label102
   483 label *label99

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   336 set :drawPixel:b *tmp105
   337 packcolor *tmp106 :drawPixel:r :drawPixel:g :drawPixel:b 1
   338 set :drawPixel:color *tmp106
-    * set *tmp89 :drawPixel:color
   339 jump *label74 always
   340 label *label75
   341 jump *label78 equal .PALETTE 3
 
   357 set :drawPixel:b *tmp117
   358 packcolor *tmp118 :drawPixel:r :drawPixel:g :drawPixel:b 1
   359 set :drawPixel:color *tmp118
-    * set *tmp89 :drawPixel:color
   360 jump *label74 always
   361 label *label77
   362 jump *label80 equal .PALETTE 4
 
   371 set :drawPixel:g *tmp123
   372 packcolor *tmp124 :drawPixel:r :drawPixel:g 0 1
   373 set :drawPixel:color *tmp124
-    * set *tmp89 :drawPixel:color
   374 jump *label74 always
   375 label *label79
   376 op mul *tmp125 4 :drawPixel:iterations
 
   379 set :drawPixel:r *tmp127
   380 packcolor *tmp128 :drawPixel:r :drawPixel:r 0 1
   381 set :drawPixel:color *tmp128
-    * set *tmp89 :drawPixel:color
   382 label *label74
   383 label *label73
   384 jump *label71 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-47 instructions):
     0 sensor *tmp9 @this @x
     1 sensor *tmp10 @this @y
     2 op mul *tmp11 10000 *tmp10
-    * op add *tmp12 *tmp9 *tmp11
-    * set .PROCESSOR_ID *tmp12
+    3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
 
    33 op greaterThan *tmp14 :findLinkedBlocks:n 0
    34 jump *label14 equal *tmp14 false
    35 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
-    * getlink *tmp15 :findLinkedBlocks:n
-    * set :findLinkedBlocks:block *tmp15
+   36 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    37 print "\nFound: "
    38 print :findLinkedBlocks:block
-    * sensor *tmp16 :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:type *tmp16
+   39 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    40 set :findLinkedBlocks:requested @large-logic-display
    41 set :findLinkedBlocks:name "Display"
    42 set :findLinkedBlocks:variable .display
 
   129 setaddr :setState*retaddr *label38 (h:*label38)
   130 call *label2 *invalid :setState*retval (m:*label38) (h:*label38)
   131 label *label38
-    * read *tmp4 .memory 68
-    * set .ZOOM *tmp4
+  132 read .ZOOM .memory 68
   133 op div *tmp26 -88 .ZOOM
   134 read *tmp2 .memory 66
-    * op add *tmp27 *tmp26 *tmp2
-    * set .OFFSET_X *tmp27
+  135 op add .OFFSET_X *tmp26 *tmp2
   136 op div *tmp28 -88 .ZOOM
   137 read *tmp3 .memory 67
-    * op add *tmp29 *tmp28 *tmp3
-    * set .OFFSET_Y *tmp29
-    * read *tmp5 .memory 69
-    * set .JULIA *tmp5
-    * read *tmp6 .memory 70
-    * set .JULIA_X *tmp6
-    * read *tmp7 .memory 71
-    * set .JULIA_Y *tmp7
-    * read *tmp8 .memory 72
-    * set .PALETTE *tmp8
-    * op greaterThan *tmp30 .PALETTE 1
-    * set .SMOOTH *tmp30
+  138 op add .OFFSET_Y *tmp28 *tmp3
+  139 read .JULIA .memory 69
+  140 read .JULIA_X .memory 70
+  141 read .JULIA_Y .memory 71
+  142 read .PALETTE .memory 72
+  143 op greaterThan .SMOOTH .PALETTE 1
   144 set :line 8
   145 set :increment 8
   146 set :next_increment 16
 
   150 label *label39
   151 jump *label41 greaterThanEq :lines 176
   152 op mul *tmp32 17 :line
-    * op mod *tmp33 *tmp32 176
-    * set :x *tmp33
-    * op add *tmp34 :x 158
-    * set :position *tmp34
-    * set *tmp35 :position
-    * read *tmp36 .memory *tmp35
+  153 op mod :x *tmp32 176
+  154 op add :position :x 158
+  155 read *tmp36 .memory :position
   156 op equal *tmp37 *tmp36 0
   157 jump *label42 equal *tmp37 false
-    * set *tmp39 :position
-    * write .PROCESSOR_ID .memory *tmp39
+  158 write .PROCESSOR_ID .memory :position
   159 set :y 0
   160 label *label44
   161 jump *label46 greaterThanEq :y 176
   162 set :compute:x :x
   163 set :compute:y :y
   164 op div *tmp42 :compute:x .ZOOM
-    * op add *tmp43 *tmp42 .OFFSET_X
-    * set :compute:zx *tmp43
+  165 op add :compute:zx *tmp42 .OFFSET_X
   166 op div *tmp44 :compute:y .ZOOM
-    * op add *tmp45 *tmp44 .OFFSET_Y
-    * set :compute:zy *tmp45
+  167 op add :compute:zy *tmp44 .OFFSET_Y
   168 jump *label48 equal .JULIA false
   169 set :compute:cx .JULIA_X
   170 set :compute:cy .JULIA_Y
 
   173 set :compute:cx :compute:zx
   174 set :compute:cy :compute:zy
   175 op sub *tmp47 :compute:cx 0.25
-    * op len *tmp48 *tmp47 :compute:cy
-    * set :compute:p *tmp48
+  176 op len :compute:p *tmp47 :compute:cy
   177 op mul *tmp49 2 :compute:p
   178 op mul *tmp50 *tmp49 :compute:p
   179 op sub *tmp51 :compute:p *tmp50
 
   203 op mul *tmp59 :compute:x1 :compute:x1
   204 op mul *tmp60 :compute:y1 :compute:y1
   205 op sub *tmp61 *tmp59 *tmp60
-    * op add *tmp62 *tmp61 :compute:cx
-    * set :compute:zx *tmp62
+  206 op add :compute:zx *tmp61 :compute:cx
   207 op mul *tmp63 2 :compute:x1
   208 op mul *tmp64 *tmp63 :compute:y1
-    * op add *tmp65 *tmp64 :compute:cy
-    * set :compute:zy *tmp65
-    * op len *tmp66 :compute:zx :compute:zy
-    * set :compute:dist *tmp66
+  209 op add :compute:zy *tmp64 :compute:cy
+  210 op len :compute:dist :compute:zx :compute:zy
   211 op greaterThanEq *tmp67 :compute:dist 64
   212 jump *label57 equal *tmp67 false
   213 jump *label56 always
 
   225 op mul *tmp73 *tmp72 0.36067376022224085
   226 op log *tmp74 *tmp73
   227 op mul *tmp75 *tmp74 1.4426950408889634
-    * op sub *tmp76 4 *tmp75
-    * set :compute:correction *tmp76
+  228 op sub :compute:correction 4 *tmp75
   229 op add :compute:i :compute:i :compute:correction
   230 jump *label60 always
   231 label *label59
 
   241 setaddr :drawPixel*retaddr *label61 (h:*label61)
   242 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   243 label *label61
-    * set *tmp77 :position
-    * read *tmp78 .memory *tmp77
+  244 read *tmp78 .memory :position
   245 op notEqual *tmp79 *tmp78 .PROCESSOR_ID
   246 jump *label62 equal *tmp79 false
   247 jump *label46 always
 
   267 jump *label66 equal *tmp83 false
   268 op div :next_increment :next_increment 2
   269 set :increment :next_increment
-    * op div *tmp85 :increment 2
-    * set :line *tmp85
+  270 op div :line :increment 2
   271 jump *label67 always
   272 label *label66
   273 label *label67
 
   296 op abs *tmp92 *tmp91
   297 op mul *tmp93 7 *tmp92
   298 op div *tmp94 *tmp93 255
-    * op sub *tmp95 1 *tmp94
-    * set :drawPixel:r *tmp95
+  299 op sub :drawPixel:r 1 *tmp94
   300 op sub *tmp96 :drawPixel:iterations 32
   301 op abs *tmp97 *tmp96
   302 op mul *tmp98 6 *tmp97
   303 op div *tmp99 *tmp98 255
-    * op sub *tmp100 0.9411764705882353 *tmp99
-    * set :drawPixel:g *tmp100
+  304 op sub :drawPixel:g 0.9411764705882353 *tmp99
   305 op sub *tmp101 32 :drawPixel:iterations
   306 op abs *tmp102 *tmp101
   307 op mul *tmp103 4 *tmp102
   308 op div *tmp104 *tmp103 255
-    * op add *tmp105 0.47058823529411764 *tmp104
-    * set :drawPixel:b *tmp105
-    * packcolor *tmp106 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp106
+  309 op add :drawPixel:b 0.47058823529411764 *tmp104
+  310 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   311 jump *label74 always
   312 label *label75
   313 jump *label78 equal .PALETTE 3
 
   315 label *label78
   316 op div *tmp107 :drawPixel:iterations 63
   317 op mul *tmp108 *tmp107 360
-    * op sin *tmp109 *tmp108
-    * set :drawPixel:r *tmp109
+  318 op sin :drawPixel:r *tmp108
   319 op div *tmp110 :drawPixel:iterations 63
   320 op mul *tmp111 *tmp110 360
-    * op cos *tmp112 *tmp111
-    * set :drawPixel:g *tmp112
+  321 op cos :drawPixel:g *tmp111
   322 op sub *tmp113 :drawPixel:iterations 32
   323 op abs *tmp114 *tmp113
   324 op mul *tmp115 4 *tmp114
   325 op div *tmp116 *tmp115 255
-    * op add *tmp117 0.39215686274509803 *tmp116
-    * set :drawPixel:b *tmp117
-    * packcolor *tmp118 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp118
+  326 op add :drawPixel:b 0.39215686274509803 *tmp116
+  327 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   328 jump *label74 always
   329 label *label77
   330 jump *label80 equal .PALETTE 4
   331 jump *label79 always
   332 label *label80
   333 op mul *tmp119 4 :drawPixel:iterations
-    * op div *tmp120 *tmp119 255
-    * set :drawPixel:r *tmp120
+  334 op div :drawPixel:r *tmp119 255
   335 op mul *tmp121 1.5 :drawPixel:iterations
   336 op div *tmp122 *tmp121 255
-    * op add *tmp123 96 *tmp122
-    * set :drawPixel:g *tmp123
-    * packcolor *tmp124 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp124
+  337 op add :drawPixel:g 96 *tmp122
+  338 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   339 jump *label74 always
   340 label *label79
   341 op mul *tmp125 4 :drawPixel:iterations
   342 op div *tmp126 *tmp125 255
-    * op sub *tmp127 1 *tmp126
-    * set :drawPixel:r *tmp127
-    * packcolor *tmp128 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp128
+  343 op sub :drawPixel:r 1 *tmp126
+  344 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   345 label *label74
   346 label *label73
   347 jump *label71 always
   348 label *label70
-    * set *tmp129 :drawPixel:iterations
-    * read *tmp130 .memory *tmp129
-    * set :drawPixel:color *tmp130
+  349 read :drawPixel:color .memory :drawPixel:iterations
   350 label *label71
   351 op greaterThanEq *tmp131 .localBuffer 254
   352 jump *label81 equal *tmp131 false
 
   359 draw col :drawPixel:color
   360 draw rect :drawPixel:x :drawPixel:y 1 1
   361 op add .localBuffer .localBuffer 2
-    * set *tmp133 .display
-    * sensor *tmp134 *tmp133 @enabled
-    * op sub *tmp135 1 *tmp134
-    * set :drawPixel:disabled *tmp135
+  362 sensor *tmp134 .display @enabled
+  363 op sub :drawPixel:disabled 1 *tmp134
   364 sensor *tmp136 .display @bufferSize
   365 op mul *tmp137 :drawPixel:disabled 900
-    * op add *tmp138 *tmp136 *tmp137
-    * set :drawPixel:usage *tmp138
+  366 op add :drawPixel:usage *tmp136 *tmp137
   367 op lessThan *tmp139 :drawPixel:usage 100
   368 jump *label84 equal *tmp139 false
   369 drawflush .display
 
   410 label *label98
   411 op lessThan *tmp150 .PROC_STATE_INDEX 512
   412 jump *label100 equal *tmp150 false
-    * set *tmp151 .PROC_ID_INDEX
-    * read *tmp152 .memory *tmp151
+  413 read *tmp152 .memory .PROC_ID_INDEX
   414 op equal *tmp153 *tmp152 .PROCESSOR_ID
   415 jump *label101 equal *tmp153 false
-    * set *tmp155 .PROC_STATE_INDEX
-    * write :setState:state .memory *tmp155
+  416 write :setState:state .memory .PROC_STATE_INDEX
   417 jump *label100 always
   418 jump *label102 always
   419 label *label101
-    * set *tmp157 .PROC_ID_INDEX
-    * read *tmp158 .memory *tmp157
+  420 read *tmp158 .memory .PROC_ID_INDEX
   421 op equal *tmp159 *tmp158 0
   422 jump *label103 equal *tmp159 false
-    * set *tmp161 .PROC_ID_INDEX
-    * write .PROCESSOR_ID .memory *tmp161
-    * set *tmp163 .PROC_STATE_INDEX
-    * write :setState:state .memory *tmp163
+  423 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  424 write :setState:state .memory .PROC_STATE_INDEX
   425 jump *label100 always
   426 jump *label104 always
   427 label *label103

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
   108 label *label6
   109 label *label3
   110 label *label31
-    * jump *label33 equal true false
   111 set .localBuffer 0
   112 drawflush null
   113 label *label34

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   288 set :drawPixel:color %[black]
   289 jump *label73 always
   290 label *label72
-    * jump *label76 equal .PALETTE 2
-    * jump *label75 always
+  291 jump *label75 notEqual .PALETTE 2
   292 label *label76
   293 op sub *tmp91 32 :drawPixel:iterations
   294 op abs *tmp92 *tmp91
 
   308 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   309 jump *label74 always
   310 label *label75
-    * jump *label78 equal .PALETTE 3
-    * jump *label77 always
+  311 jump *label77 notEqual .PALETTE 3
   312 label *label78
   313 op div *tmp107 :drawPixel:iterations 63
   314 op mul *tmp108 *tmp107 360
 
   324 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   325 jump *label74 always
   326 label *label77
-    * jump *label80 equal .PALETTE 4
-    * jump *label79 always
+  327 jump *label79 notEqual .PALETTE 4
   328 label *label80
   329 op mul *tmp119 4 :drawPixel:iterations
   330 op div :drawPixel:r *tmp119 255

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-23 instructions):
 
    30 print :findLinkedBlocks:title
    31 set :findLinkedBlocks:n @links
    32 label *label12
-    * op greaterThan *tmp14 :findLinkedBlocks:n 0
-    * jump *label14 equal *tmp14 false
+   33 jump *label14 lessThanEq :findLinkedBlocks:n 0
    34 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    35 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    36 print "\nFound: "
 
    50 set :findLinkedBlocks:required true
    51 setaddr *tmp17 *label19
    52 label *label15
-    * op equal *tmp18 :findLinkedBlocks:requested :findLinkedBlocks:type
-    * jump *label20 equal *tmp18 false
+   53 jump *label20 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    54 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * op equal *tmp20 :findLinkedBlocks:requested @message
-    * jump *label22 equal *tmp20 false
+   55 jump *label22 notEqual :findLinkedBlocks:requested @message
    56 set :findLinkedBlocks:message :findLinkedBlocks:block
    57 jump *label23 always
    58 label *label22
 
   100 label *label26
   101 printflush :findLinkedBlocks:message
   102 label *label5
-    * op equal *tmp24 :findLinkedBlocks:foundAll false
-    * jump *label4 notEqual *tmp24 false
+  103 jump *label4 equal :findLinkedBlocks:foundAll false
   104 label *label6
   105 label *label3
   106 label *label31
 
   113 label *label37
   114 label *label35
   115 read *tmp0 .memory 64
-    * op equal *tmp25 .start *tmp0
-    * jump *label34 notEqual *tmp25 false
+  116 jump *label34 equal .start *tmp0
   117 label *label36
   118 read *tmp0 .memory 64
   119 set .start *tmp0
 
   147 op mod :x *tmp32 176
   148 op add :position :x 158
   149 read *tmp36 .memory :position
-    * op equal *tmp37 *tmp36 0
-    * jump *label42 equal *tmp37 false
+  150 jump *label42 notEqual *tmp36 0
   151 write .PROCESSOR_ID .memory :position
   152 set :y 0
   153 label *label44
 
   171 op mul *tmp50 *tmp49 :compute:p
   172 op sub *tmp51 :compute:p *tmp50
   173 op add *tmp52 *tmp51 0.25
-    * op lessThanEq *tmp53 :compute:cx *tmp52
-    * jump *label50 equal *tmp53 false
+  174 jump *label50 greaterThan :compute:cx *tmp52
   175 set *tmp41 63
   176 jump *label47 always
   177 jump *label51 always
 
   179 label *label51
   180 op add *tmp55 :compute:cx 1
   181 op len *tmp56 *tmp55 :compute:cy
-    * op lessThanEq *tmp57 *tmp56 0.25
-    * jump *label52 equal *tmp57 false
+  182 jump *label52 greaterThan *tmp56 0.25
   183 set *tmp41 63
   184 jump *label47 always
   185 jump *label53 always
 
   199 op mul *tmp64 *tmp63 :compute:y1
   200 op add :compute:zy *tmp64 :compute:cy
   201 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp67 :compute:dist 64
-    * jump *label57 equal *tmp67 false
+  202 jump *label57 lessThan :compute:dist 64
   203 jump *label56 always
   204 jump *label58 always
   205 label *label57
 
   209 jump *label54 always
   210 label *label56
   211 op mul *tmp69 .SMOOTH 63
-    * op lessThan *tmp70 :compute:i *tmp69
-    * jump *label59 equal *tmp70 false
+  212 jump *label59 greaterThanEq :compute:i *tmp69
   213 op log *tmp72 :compute:dist
   214 op mul *tmp73 *tmp72 0.36067376022224085
   215 op log *tmp74 *tmp73
 
   231 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   232 label *label61
   233 read *tmp78 .memory :position
-    * op notEqual *tmp79 *tmp78 .PROCESSOR_ID
-    * jump *label62 equal *tmp79 false
+  234 jump *label62 equal *tmp78 .PROCESSOR_ID
   235 jump *label46 always
   236 jump *label63 always
   237 label *label62
   238 label *label63
   239 read *tmp1 .memory 65
-    * op notEqual *tmp81 .stop *tmp1
-    * jump *label64 equal *tmp81 false
+  240 jump *label64 equal .stop *tmp1
   241 jump *label32 always
   242 jump *label65 always
   243 label *label64
 
   250 label *label42
   251 label *label43
   252 op add :line :line :increment
-    * op greaterThan *tmp83 :line 176
-    * jump *label66 equal *tmp83 false
+  253 jump *label66 lessThanEq :line 176
   254 op div :next_increment :next_increment 2
   255 set :increment :next_increment
   256 op div :line :increment 2
 
   270 end
   271 label *label0
   272 jump *label70 equal .SMOOTH false
-    * op equal *tmp87 :drawPixel:iterations 63
-    * jump *label72 equal *tmp87 false
+  273 jump *label72 notEqual :drawPixel:iterations 63
   274 set :drawPixel:color %[black]
   275 jump *label73 always
   276 label *label72
 
   330 label *label70
   331 read :drawPixel:color .memory :drawPixel:iterations
   332 label *label71
-    * op greaterThanEq *tmp131 .localBuffer 254
-    * jump *label81 equal *tmp131 false
+  333 jump *label81 lessThan .localBuffer 254
   334 setaddr :flushLocalBuffer*retaddr *label83 (h:*label83)
   335 call *label1 *invalid :flushLocalBuffer*retval (m:*label83) (h:*label83)
   336 label *label83
 
   345 sensor *tmp136 .display @bufferSize
   346 op mul *tmp137 :drawPixel:disabled 900
   347 op add :drawPixel:usage *tmp136 *tmp137
-    * op lessThan *tmp139 :drawPixel:usage 100
-    * jump *label84 equal *tmp139 false
+  348 jump *label84 greaterThanEq :drawPixel:usage 100
   349 drawflush .display
   350 set .localBuffer 0
   351 jump *label85 always
   352 label *label84
   353 op div *tmp141 1800 .localBuffer
-    * op lessThan *tmp142 :drawPixel:usage *tmp141
-    * jump *label86 equal *tmp142 false
+  354 jump *label86 greaterThanEq :drawPixel:usage *tmp141
   355 drawflush .display
   356 set .localBuffer 0
   357 jump *label87 always
 
   365 label *label89
   366 label *label90
   367 sensor *tmp144 .display @enabled
-    * op equal *tmp145 *tmp144 false
-    * jump *label89 notEqual *tmp145 false
+  368 jump *label89 equal *tmp144 false
   369 label *label91
-    * op greaterThan *tmp146 .localBuffer 4
-    * jump *label92 equal *tmp146 false
+  370 jump *label92 lessThanEq .localBuffer 4
   371 label *label94
   372 wait 0.0001
   373 label *label95
   374 sensor *tmp148 .display @bufferSize
-    * op greaterThan *tmp149 *tmp148 250
-    * jump *label94 notEqual *tmp149 false
+  375 jump *label94 greaterThan *tmp148 250
   376 label *label96
   377 jump *label93 always
   378 label *label92
 
   384 end
   385 label *label2
   386 label *label98
-    * op lessThan *tmp150 .PROC_STATE_INDEX 512
-    * jump *label100 equal *tmp150 false
+  387 jump *label100 greaterThanEq .PROC_STATE_INDEX 512
   388 read *tmp152 .memory .PROC_ID_INDEX
-    * op equal *tmp153 *tmp152 .PROCESSOR_ID
-    * jump *label101 equal *tmp153 false
+  389 jump *label101 notEqual *tmp152 .PROCESSOR_ID
   390 write :setState:state .memory .PROC_STATE_INDEX
   391 jump *label100 always
   392 jump *label102 always
   393 label *label101
   394 read *tmp158 .memory .PROC_ID_INDEX
-    * op equal *tmp159 *tmp158 0
-    * jump *label103 equal *tmp159 false
+  395 jump *label103 notEqual *tmp158 0
   396 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   397 write :setState:state .memory .PROC_STATE_INDEX
   398 jump *label100 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-14 instructions):
 
    54 set :findLinkedBlocks:variable :findLinkedBlocks:block
    55 jump *label22 notEqual :findLinkedBlocks:requested @message
    56 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * jump *label23 always
    57 label *label22
    58 label *label23
-    * jump *label21 always
    59 label *label20
    60 label *label21
    61 label *label16
 
    88 print :findLinkedBlocks:variable
    89 jump *label29 equal :findLinkedBlocks:required false
    90 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * jump *label30 always
    91 label *label29
    92 label *label30
    93 label *label25
 
   171 jump *label50 greaterThan :compute:cx *tmp52
   172 set *tmp41 63
   173 jump *label47 always
-    * jump *label51 always
   174 label *label50
   175 label *label51
   176 op add *tmp55 :compute:cx 1
 
   178 jump *label52 greaterThan *tmp56 0.25
   179 set *tmp41 63
   180 jump *label47 always
-    * jump *label53 always
   181 label *label52
   182 label *label53
   183 label *label49
 
   196 op len :compute:dist :compute:zx :compute:zy
   197 jump *label57 lessThan :compute:dist 64
   198 jump *label56 always
-    * jump *label58 always
   199 label *label57
   200 label *label58
   201 label *label55
 
   210 op mul *tmp75 *tmp74 1.4426950408889634
   211 op sub :compute:correction 4 *tmp75
   212 op add :compute:i :compute:i :compute:correction
-    * jump *label60 always
   213 label *label59
   214 label *label60
   215 set *tmp41 :compute:i
 
   226 read *tmp78 .memory :position
   227 jump *label62 equal *tmp78 .PROCESSOR_ID
   228 jump *label46 always
-    * jump *label63 always
   229 label *label62
   230 label *label63
   231 read *tmp1 .memory 65
   232 jump *label64 equal .stop *tmp1
   233 jump *label32 always
-    * jump *label65 always
   234 label *label64
   235 label *label65
   236 label *label45
   237 op add :y :y 1
   238 jump *label44 always
   239 label *label46
-    * jump *label43 always
   240 label *label42
   241 label *label43
   242 op add :line :line :increment
 
   244 op div :next_increment :next_increment 2
   245 set :increment :next_increment
   246 op div :line :increment 2
-    * jump *label67 always
   247 label *label66
   248 label *label67
   249 label *label40
 
   323 setaddr :flushLocalBuffer*retaddr *label83 (h:*label83)
   324 call *label1 *invalid :flushLocalBuffer*retval (m:*label83) (h:*label83)
   325 label *label83
-    * jump *label82 always
   326 label *label81
   327 label *label82
   328 draw col :drawPixel:color
 
   342 jump *label86 greaterThanEq :drawPixel:usage *tmp141
   343 drawflush .display
   344 set .localBuffer 0
-    * jump *label87 always
   345 label *label86
   346 label *label87
   347 label *label85
 
   361 sensor *tmp148 .display @bufferSize
   362 jump *label94 greaterThan *tmp148 250
   363 label *label96
-    * jump *label93 always
   364 label *label92
   365 label *label93
   366 drawflush .display

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
-    * sensor *tmp9 @this @x
-    * sensor *tmp10 @this @y
+    0 set *tmp9 @thisx
+    1 set *tmp10 @thisy
     2 op mul *tmp11 10000 *tmp10
     3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
     0 set *tmp9 @thisx
     1 set *tmp10 @thisy
-    * op mul *tmp11 10000 *tmp10
-    * op add .PROCESSOR_ID *tmp9 *tmp11
+    2 op mul *tmp11 10000 @thisy
+    3 op add .PROCESSOR_ID @thisx *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
     7 set :findLinkedBlocks:title "Mandelbrot Generator"
     8 set :findLinkedBlocks:message null
     9 label *label4
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    10 setaddr *tmp13 *label10
    11 jump *label7 always
    12 multilabel *label10 (m:marker0)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
+   13 set .display null
    14 setaddr *tmp13 *label11
    15 label *label7
    16 set :findLinkedBlocks:variable null
    17 label *label8
    18 multijump *tmp13 0 0 (m:marker0)
    19 multilabel *label11 (m:marker0)
-    * set .memory :findLinkedBlocks:variable
+   20 set .memory null
    21 label *label9
-    * print :findLinkedBlocks:title
+   22 print "Mandelbrot Generator"
    23 set :findLinkedBlocks:n @links
    24 label *label12
    25 jump *label14 lessThanEq :findLinkedBlocks:n 0
 
    29 print :findLinkedBlocks:block
    30 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    31 set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
    32 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    33 setaddr *tmp17 *label18
    34 jump *label15 always
    35 multilabel *label18 (m:marker1)
    36 set .display :findLinkedBlocks:variable
    37 set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
    38 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    39 setaddr *tmp17 *label19
    40 label *label15
    41 jump *label20 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
 
    55 jump *label12 always
    56 label *label14
    57 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:requested @large-logic-display
    58 set :findLinkedBlocks:name "Display"
    59 set :findLinkedBlocks:variable .display
    60 set :findLinkedBlocks:required true
 
    62 jump *label24 always
    63 multilabel *label27 (m:marker2)
    64 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    65 set :findLinkedBlocks:name "Memory"
    66 set :findLinkedBlocks:variable .memory
    67 set :findLinkedBlocks:required true
 
    72 print ":"
    73 print " "
    74 print :findLinkedBlocks:variable
-    * jump *label29 equal :findLinkedBlocks:required false
+   75 jump *label29 equal true false
    76 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
    77 label *label29
    78 label *label30
 
   102 set .start *tmp0
   103 read *tmp1 .memory 65
   104 set .stop *tmp1
-    * set :setState:state .start
+  105 set :setState:state *tmp0
   106 setaddr :setState*retaddr *label38 (h:*label38)
   107 call *label2 *invalid :setState*retval (m:*label38) (h:*label38)
   108 label *label38
 
   112 op add .OFFSET_X *tmp26 *tmp2
   113 op div *tmp28 -88 .ZOOM
   114 read *tmp3 .memory 67
-    * op add .OFFSET_Y *tmp28 *tmp3
+  115 op add .OFFSET_Y *tmp26 *tmp3
   116 read .JULIA .memory 69
   117 read .JULIA_X .memory 70
   118 read .JULIA_Y .memory 71
 
   137 jump *label46 greaterThanEq :y 176
   138 set :compute:x :x
   139 set :compute:y :y
-    * op div *tmp42 :compute:x .ZOOM
+  140 op div *tmp42 :x .ZOOM
   141 op add :compute:zx *tmp42 .OFFSET_X
-    * op div *tmp44 :compute:y .ZOOM
+  142 op div *tmp44 :y .ZOOM
   143 op add :compute:zy *tmp44 .OFFSET_Y
   144 jump *label48 equal .JULIA false
   145 set :compute:cx .JULIA_X
 
   148 label *label48
   149 set :compute:cx :compute:zx
   150 set :compute:cy :compute:zy
-    * op sub *tmp47 :compute:cx 0.25
-    * op len :compute:p *tmp47 :compute:cy
+  151 op sub *tmp47 :compute:zx 0.25
+  152 op len :compute:p *tmp47 :compute:zy
   153 op mul *tmp49 2 :compute:p
   154 op mul *tmp50 *tmp49 :compute:p
   155 op sub *tmp51 :compute:p *tmp50
   156 op add *tmp52 *tmp51 0.25
-    * jump *label50 greaterThan :compute:cx *tmp52
+  157 jump *label50 greaterThan :compute:zx *tmp52
   158 set *tmp41 63
   159 jump *label47 always
   160 label *label50
   161 label *label51
-    * op add *tmp55 :compute:cx 1
-    * op len *tmp56 *tmp55 :compute:cy
+  162 op add *tmp55 :compute:zx 1
+  163 op len *tmp56 *tmp55 :compute:zy
   164 jump *label52 greaterThan *tmp56 0.25
   165 set *tmp41 63
   166 jump *label47 always
 
   172 jump *label56 greaterThanEq :compute:i 63
   173 set :compute:x1 :compute:zx
   174 set :compute:y1 :compute:zy
-    * op mul *tmp59 :compute:x1 :compute:x1
-    * op mul *tmp60 :compute:y1 :compute:y1
+  175 op mul *tmp59 :compute:zx :compute:zx
+  176 op mul *tmp60 :compute:zy :compute:zy
   177 op sub *tmp61 *tmp59 *tmp60
   178 op add :compute:zx *tmp61 :compute:cx
   179 op mul *tmp63 2 :compute:x1
-    * op mul *tmp64 *tmp63 :compute:y1
+  180 op mul *tmp64 *tmp63 :compute:zy
   181 op add :compute:zy *tmp64 :compute:cy
   182 op len :compute:dist :compute:zx :compute:zy
   183 jump *label57 lessThan :compute:dist 64
 
   200 label *label60
   201 set *tmp41 :compute:i
   202 jump *label47 always
-    * set *tmp41 null
   203 label *label47
   204 set :iterations *tmp41
   205 set :drawPixel:x :x
   206 set :drawPixel:y :y
-    * set :drawPixel:iterations :iterations
+  207 set :drawPixel:iterations *tmp41
   208 setaddr :drawPixel*retaddr *label61 (h:*label61)
   209 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   210 label *label61
 
   228 jump *label66 lessThanEq :line 176
   229 op div :next_increment :next_increment 2
   230 set :increment :next_increment
-    * op div :line :increment 2
+  231 op div :line :next_increment 2
   232 label *label66
   233 label *label67
   234 label *label40
 
   253 op sub *tmp91 32 :drawPixel:iterations
   254 op abs *tmp92 *tmp91
   255 op mul *tmp93 7 *tmp92
-    * op div *tmp94 *tmp93 255
+  256 op div *tmp94 *tmp92 36.42857142857143
   257 op sub :drawPixel:r 1 *tmp94
   258 op sub *tmp96 :drawPixel:iterations 32
   259 op abs *tmp97 *tmp96
   260 op mul *tmp98 6 *tmp97
-    * op div *tmp99 *tmp98 255
+  261 op div *tmp99 *tmp97 42.5
   262 op sub :drawPixel:g 0.9411764705882353 *tmp99
   263 op sub *tmp101 32 :drawPixel:iterations
-    * op abs *tmp102 *tmp101
-    * op mul *tmp103 4 *tmp102
-    * op div *tmp104 *tmp103 255
+  264 op abs *tmp102 *tmp91
+  265 op mul *tmp103 4 *tmp92
+  266 op div *tmp104 *tmp102 63.75
   267 op add :drawPixel:b 0.47058823529411764 *tmp104
   268 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   269 jump *label74 always
 
   271 jump *label77 notEqual .PALETTE 3
   272 label *label78
   273 op div *tmp107 :drawPixel:iterations 63
-    * op mul *tmp108 *tmp107 360
+  274 op div *tmp108 :drawPixel:iterations 0.175
   275 op sin :drawPixel:r *tmp108
   276 op div *tmp110 :drawPixel:iterations 63
-    * op mul *tmp111 *tmp110 360
-    * op cos :drawPixel:g *tmp111
+  277 op mul *tmp111 *tmp107 360
+  278 op cos :drawPixel:g *tmp108
   279 op sub *tmp113 :drawPixel:iterations 32
   280 op abs *tmp114 *tmp113
   281 op mul *tmp115 4 *tmp114
-    * op div *tmp116 *tmp115 255
+  282 op div *tmp116 *tmp114 63.75
   283 op add :drawPixel:b 0.39215686274509803 *tmp116
   284 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   285 jump *label74 always
 
   287 jump *label79 notEqual .PALETTE 4
   288 label *label80
   289 op mul *tmp119 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp119 255
+  290 op div :drawPixel:r :drawPixel:iterations 63.75
   291 op mul *tmp121 1.5 :drawPixel:iterations
-    * op div *tmp122 *tmp121 255
+  292 op div *tmp122 :drawPixel:iterations 170
   293 op add :drawPixel:g 96 *tmp122
   294 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   295 jump *label74 always
   296 label *label79
   297 op mul *tmp125 4 :drawPixel:iterations
-    * op div *tmp126 *tmp125 255
+  298 op div *tmp126 :drawPixel:iterations 63.75
   299 op sub :drawPixel:r 1 *tmp126
   300 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   301 label *label74

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-20 instructions):
-    * set *tmp9 @thisx
-    * set *tmp10 @thisy
     0 op mul *tmp11 10000 @thisy
     1 op add .PROCESSOR_ID @thisx *tmp11
     2 set .PROC_ID_INDEX 334
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
-    * set :findLinkedBlocks:title "Mandelbrot Generator"
     5 set :findLinkedBlocks:message null
     6 label *label4
     7 setaddr *tmp13 *label10
 
    10 set .display null
    11 setaddr *tmp13 *label11
    12 label *label7
-    * set :findLinkedBlocks:variable null
    13 label *label8
    14 multijump *tmp13 0 0 (m:marker0)
    15 multilabel *label11 (m:marker0)
 
    53 set :findLinkedBlocks:foundAll 1
    54 set :findLinkedBlocks:name "Display"
    55 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    56 setaddr *tmp22 *label27
    57 jump *label24 always
    58 multilabel *label27 (m:marker2)
    59 set .display :findLinkedBlocks:variable
    60 set :findLinkedBlocks:name "Memory"
    61 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    62 setaddr *tmp22 *label28
    63 label *label24
    64 print "\n"
 
   104 op div *tmp26 -88 .ZOOM
   105 read *tmp2 .memory 66
   106 op add .OFFSET_X *tmp26 *tmp2
-    * op div *tmp28 -88 .ZOOM
   107 read *tmp3 .memory 67
   108 op add .OFFSET_Y *tmp26 *tmp3
   109 read .JULIA .memory 69
 
   128 set :y 0
   129 label *label44
   130 jump *label46 greaterThanEq :y 176
-    * set :compute:x :x
-    * set :compute:y :y
   131 op div *tmp42 :x .ZOOM
   132 op add :compute:zx *tmp42 .OFFSET_X
   133 op div *tmp44 :y .ZOOM
 
   162 label *label54
   163 jump *label56 greaterThanEq :compute:i 63
   164 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   165 op mul *tmp59 :compute:zx :compute:zx
   166 op mul *tmp60 :compute:zy :compute:zy
   167 op sub *tmp61 *tmp59 *tmp60
 
   191 set *tmp41 :compute:i
   192 jump *label47 always
   193 label *label47
-    * set :iterations *tmp41
   194 set :drawPixel:x :x
   195 set :drawPixel:y :y
   196 set :drawPixel:iterations *tmp41
 
   241 label *label76
   242 op sub *tmp91 32 :drawPixel:iterations
   243 op abs *tmp92 *tmp91
-    * op mul *tmp93 7 *tmp92
   244 op div *tmp94 *tmp92 36.42857142857143
   245 op sub :drawPixel:r 1 *tmp94
   246 op sub *tmp96 :drawPixel:iterations 32
   247 op abs *tmp97 *tmp96
-    * op mul *tmp98 6 *tmp97
   248 op div *tmp99 *tmp97 42.5
   249 op sub :drawPixel:g 0.9411764705882353 *tmp99
-    * op sub *tmp101 32 :drawPixel:iterations
   250 op abs *tmp102 *tmp91
-    * op mul *tmp103 4 *tmp92
-    * op div *tmp104 *tmp102 63.75
+  251 op div *tmp104 *tmp92 63.75
   252 op add :drawPixel:b 0.47058823529411764 *tmp104
   253 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   254 jump *label74 always
 
   258 op div *tmp107 :drawPixel:iterations 63
   259 op div *tmp108 :drawPixel:iterations 0.175
   260 op sin :drawPixel:r *tmp108
-    * op div *tmp110 :drawPixel:iterations 63
-    * op mul *tmp111 *tmp107 360
+  261 op div *tmp111 :drawPixel:iterations 0.175
   262 op cos :drawPixel:g *tmp108
   263 op sub *tmp113 :drawPixel:iterations 32
   264 op abs *tmp114 *tmp113
-    * op mul *tmp115 4 *tmp114
   265 op div *tmp116 *tmp114 63.75
   266 op add :drawPixel:b 0.39215686274509803 *tmp116
   267 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   269 label *label77
   270 jump *label79 notEqual .PALETTE 4
   271 label *label80
-    * op mul *tmp119 4 :drawPixel:iterations
   272 op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp121 1.5 :drawPixel:iterations
   273 op div *tmp122 :drawPixel:iterations 170
   274 op add :drawPixel:g 96 *tmp122
   275 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   276 jump *label74 always
   277 label *label79
-    * op mul *tmp125 4 :drawPixel:iterations
   278 op div *tmp126 :drawPixel:iterations 63.75
   279 op sub :drawPixel:r 1 *tmp126
   280 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
   247 op abs *tmp97 *tmp96
   248 op div *tmp99 *tmp97 42.5
   249 op sub :drawPixel:g 0.9411764705882353 *tmp99
-    * op abs *tmp102 *tmp91
   250 op div *tmp104 *tmp92 63.75
   251 op add :drawPixel:b 0.47058823529411764 *tmp104
   252 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   254 label *label75
   255 jump *label77 notEqual .PALETTE 3
   256 label *label78
-    * op div *tmp107 :drawPixel:iterations 63
   257 op div *tmp108 :drawPixel:iterations 0.175
   258 op sin :drawPixel:r *tmp108
-    * op div *tmp111 :drawPixel:iterations 0.175
   259 op cos :drawPixel:g *tmp108
   260 op sub *tmp113 :drawPixel:iterations 32
   261 op abs *tmp114 *tmp113

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    83 label *label31
    84 set .localBuffer 0
    85 drawflush null
+   86 set :setState:state 0
+   87 setaddr :setState*retaddr *label37 (h:*label37)
    88 label *label34
-    * set :setState:state 0
-    * setaddr :setState*retaddr *label37 (h:*label37)
    89 call *label2 *invalid :setState*retval (m:*label37) (h:*label37)
    90 label *label37
    91 label *label35
 
   126 jump *label42 notEqual *tmp36 0
   127 write .PROCESSOR_ID .memory :position
   128 set :y 0
+  129 set :drawPixel:x :x
+  130 setaddr :drawPixel*retaddr *label61 (h:*label61)
   131 label *label44
   132 jump *label46 greaterThanEq :y 176
   133 op div *tmp42 :x .ZOOM
 
   193 set *tmp41 :compute:i
   194 jump *label47 always
   195 label *label47
-    * set :drawPixel:x :x
   196 set :drawPixel:y :y
   197 set :drawPixel:iterations *tmp41
-    * setaddr :drawPixel*retaddr *label61 (h:*label61)
   198 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   199 label *label61
   200 read *tmp78 .memory :position

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-3 instructions):
 
    19 set :findLinkedBlocks:n @links
    20 label *label12
    21 jump *label14 lessThanEq :findLinkedBlocks:n 0
+   22 label *label105
    23 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    24 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    25 print "\nFound: "
 
    49 set .memory :findLinkedBlocks:variable
    50 label *label17
    51 label *label13
-    * jump *label12 always
+   52 jump *label105 greaterThan :findLinkedBlocks:n 0
    53 label *label14
    54 set :findLinkedBlocks:foundAll 1
    55 set :findLinkedBlocks:name "Display"
 
   119 wait *tmp31
   120 set :lines 0
   121 label *label39
-    * jump *label41 greaterThanEq :lines 176
+  122 label *label106
   123 op mul *tmp32 17 :line
   124 op mod :x *tmp32 176
   125 op add :position :x 158
 
   130 set :drawPixel:x :x
   131 setaddr :drawPixel*retaddr *label61 (h:*label61)
   132 label *label44
-    * jump *label46 greaterThanEq :y 176
+  133 label *label107
   134 op div *tmp42 :x .ZOOM
   135 op add :compute:zx *tmp42 .OFFSET_X
   136 op div *tmp44 :y .ZOOM
 
   163 label *label49
   164 set :compute:i 0
   165 label *label54
-    * jump *label56 greaterThanEq :compute:i 63
+  166 label *label108
   167 set :compute:x1 :compute:zx
   168 op mul *tmp59 :compute:zx :compute:zx
   169 op mul *tmp60 :compute:zy :compute:zy
 
   179 label *label58
   180 label *label55
   181 op add :compute:i :compute:i 1
-    * jump *label54 always
+  182 jump *label108 lessThan :compute:i 63
   183 label *label56
   184 op mul *tmp69 .SMOOTH 63
   185 jump *label59 greaterThanEq :compute:i *tmp69
 
   210 label *label65
   211 label *label45
   212 op add :y :y 1
-    * jump *label44 always
+  213 jump *label107 lessThan :y 176
   214 label *label46
   215 label *label42
   216 label *label43
 
   223 label *label67
   224 label *label40
   225 op add :lines :lines 1
-    * jump *label39 always
+  226 jump *label106 lessThan :lines 176
   227 label *label41
   228 setaddr :flushLocalBuffer*retaddr *label68 (h:*label68)
   229 call *label1 *invalid :flushLocalBuffer*retval (m:*label68) (h:*label68)
 
   334 label *label2
   335 label *label98
   336 jump *label100 greaterThanEq .PROC_STATE_INDEX 512
+  337 label *label109
   338 read *tmp152 .memory .PROC_ID_INDEX
   339 jump *label101 notEqual *tmp152 .PROCESSOR_ID
   340 write :setState:state .memory .PROC_STATE_INDEX
 
   353 label *label104
   354 label *label102
   355 label *label99
-    * jump *label98 always
+  356 jump *label109 lessThan .PROC_STATE_INDEX 512
   357 label *label100
   358 label *label97
   359 return :setState*retaddr

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    37 label *label15
    38 jump *label20 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    39 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label22 notEqual :findLinkedBlocks:requested @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
-    * label *label22
-    * label *label23
+   40 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
    41 label *label20
    42 label *label21
    43 label *label16

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 2 (-1 instructions):
 
   231 end
   232 label *label0
   233 jump *label70 equal .SMOOTH false
-    * jump *label72 notEqual :drawPixel:iterations 63
   234 set :drawPixel:color %[black]
-    * jump *label73 always
+  235 jump *label73 equal :drawPixel:iterations 63
   236 label *label72
   237 jump *label75 notEqual .PALETTE 2
   238 label *label76

Modifications by Unroll iteration loop at *blocks:68:13 (-1 instructions):
 
    25 print "\nFound: "
    26 print :findLinkedBlocks:block
    27 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp17 *label18
-    * jump *label15 always
-    * multilabel *label18 (m:marker1)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp17 *label19
-    * label *label15
-    * jump *label20 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
-    * label *label20
-    * label *label21
-    * label *label16
-    * multijump *tmp17 0 0 (m:marker1)
-    * multilabel *label19 (m:marker1)
-    * set .memory :findLinkedBlocks:variable
-    * label *label17
+   28 set :findLinkedBlocks:requested @large-logic-display
+   29 set :findLinkedBlocks:variable .display
+   30 label *label110
+   31 jump *label111 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   32 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   33 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   34 label *label111
+   35 label *label112
+   36 label *label113
+   37 set .display :findLinkedBlocks:variable
+   38 set :findLinkedBlocks:requested @memory-bank
+   39 set :findLinkedBlocks:variable .memory
+   40 label *label116
+   41 jump *label117 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   42 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   43 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   44 label *label117
+   45 label *label118
+   46 label *label119
+   47 set .memory :findLinkedBlocks:variable
+   48 label *label17
    49 label *label13
    50 jump *label105 greaterThan :findLinkedBlocks:n 0
    51 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    28 set :findLinkedBlocks:requested @large-logic-display
    29 set :findLinkedBlocks:variable .display
    30 label *label110
-    * jump *label111 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   31 jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
    32 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   33 select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
    34 label *label111
    35 label *label112
    36 label *label113
 
    38 set :findLinkedBlocks:requested @memory-bank
    39 set :findLinkedBlocks:variable .memory
    40 label *label116
-    * jump *label117 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   41 jump *label117 notEqual @memory-bank :findLinkedBlocks:type
    42 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   43 select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
    44 label *label117
    45 label *label118
    46 label *label119

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    25 print "\nFound: "
    26 print :findLinkedBlocks:block
    27 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
    28 set :findLinkedBlocks:variable .display
    29 label *label110
    30 jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
 
    34 label *label112
    35 label *label113
    36 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    37 set :findLinkedBlocks:variable .memory
    38 label *label116
    39 jump *label117 notEqual @memory-bank :findLinkedBlocks:type

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    48 jump *label105 greaterThan :findLinkedBlocks:n 0
    49 label *label14
    50 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp22 *label27
-    * jump *label24 always
-    * multilabel *label27 (m:marker2)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp22 *label28
-    * label *label24
-    * print "\n"
-    * print :findLinkedBlocks:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks:variable
-    * jump *label29 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * label *label29
-    * label *label30
-    * label *label25
-    * multijump *tmp22 0 0 (m:marker2)
-    * multilabel *label28 (m:marker2)
-    * set .memory :findLinkedBlocks:variable
-    * label *label26
+   51 set :findLinkedBlocks:name "Display"
+   52 set :findLinkedBlocks:variable .display
+   53 label *label123
+   54 print "\n"
+   55 print :findLinkedBlocks:name
+   56 print ":"
+   57 print " "
+   58 print :findLinkedBlocks:variable
+   59 jump *label124 equal true false
+   60 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   61 label *label124
+   62 label *label125
+   63 label *label126
+   64 set .display :findLinkedBlocks:variable
+   65 set :findLinkedBlocks:name "Memory"
+   66 set :findLinkedBlocks:variable .memory
+   67 label *label129
+   68 print "\n"
+   69 print :findLinkedBlocks:name
+   70 print ":"
+   71 print " "
+   72 print :findLinkedBlocks:variable
+   73 jump *label130 equal true false
+   74 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   75 label *label130
+   76 label *label131
+   77 label *label132
+   78 set .memory :findLinkedBlocks:variable
+   79 label *label26
    80 printflush :findLinkedBlocks:message
    81 label *label5
    82 jump *label4 equal :findLinkedBlocks:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    52 set :findLinkedBlocks:variable .display
    53 label *label123
    54 print "\n"
-    * print :findLinkedBlocks:name
+   55 print "Display"
    56 print ":"
    57 print " "
-    * print :findLinkedBlocks:variable
+   58 print .display
    59 jump *label124 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   60 op and :findLinkedBlocks:foundAll 1 .display
    61 label *label124
    62 label *label125
    63 label *label126
-    * set .display :findLinkedBlocks:variable
+   64 set .display .display
    65 set :findLinkedBlocks:name "Memory"
    66 set :findLinkedBlocks:variable .memory
    67 label *label129
    68 print "\n"
-    * print :findLinkedBlocks:name
+   69 print "Memory"
    70 print ":"
    71 print " "
-    * print :findLinkedBlocks:variable
+   72 print .memory
    73 jump *label130 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   74 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    75 label *label130
    76 label *label131
    77 label *label132
-    * set .memory :findLinkedBlocks:variable
+   78 set .memory .memory
    79 label *label26
    80 printflush :findLinkedBlocks:message
    81 label *label5

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    47 label *label13
    48 jump *label105 greaterThan :findLinkedBlocks:n 0
    49 label *label14
-    * set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
    50 label *label123
    51 print "\n"
    52 print "Display"
 
    59 label *label125
    60 label *label126
    61 set .display .display
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
    62 label *label129
    63 print "\n"
    64 print "Memory"

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
 
     4 set .start 0
     5 set :findLinkedBlocks:message null
     6 label *label4
-    * setaddr *tmp13 *label10
-    * jump *label7 always
-    * multilabel *label10 (m:marker0)
-    * set .display null
-    * setaddr *tmp13 *label11
-    * label *label7
-    * label *label8
-    * multijump *tmp13 0 0 (m:marker0)
-    * multilabel *label11 (m:marker0)
-    * set .memory null
-    * label *label9
+    7 label *label136
+    8 label *label137
+    9 set .display null
+   10 label *label140
+   11 label *label141
+   12 set .memory null
+   13 label *label9
    14 print "Mandelbrot Generator"
    15 set :findLinkedBlocks:n @links
    16 label *label12

Modifications by Unroll loop at mandelbrot-compute.mnd:139:5 (+743 instructions):
 
   153 label *label52
   154 label *label53
   155 label *label49
-    * set :compute:i 0
-    * label *label54
-    * label *label108
-    * set :compute:x1 :compute:zx
-    * op mul *tmp59 :compute:zx :compute:zx
-    * op mul *tmp60 :compute:zy :compute:zy
-    * op sub *tmp61 *tmp59 *tmp60
-    * op add :compute:zx *tmp61 :compute:cx
-    * op mul *tmp63 2 :compute:x1
-    * op mul *tmp64 *tmp63 :compute:zy
-    * op add :compute:zy *tmp64 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label57 lessThan :compute:dist 64
-    * jump *label56 always
-    * label *label57
-    * label *label58
-    * label *label55
-    * op add :compute:i :compute:i 1
-    * jump *label108 lessThan :compute:i 63
-    * label *label56
+  156 set :compute:i 0
+  157 label *label145
+  158 label *label146
+  159 set :compute:x1 :compute:zx
+  160 op mul *tmp59 :compute:zx :compute:zx
+  161 op mul *tmp60 :compute:zy :compute:zy
+  162 op sub *tmp61 *tmp59 *tmp60
+  163 op add :compute:zx *tmp61 :compute:cx
+  164 op mul *tmp63 2 :compute:x1
+  165 op mul *tmp64 *tmp63 :compute:zy
+  166 op add :compute:zy *tmp64 :compute:cy
+  167 op len :compute:dist :compute:zx :compute:zy
+  168 jump *label147 lessThan :compute:dist 64
+  169 jump *label56 always
+  170 label *label147
+  171 label *label148
+  172 label *label149
+  173 op add :compute:i :compute:i 1
+  174 label *label150
+  175 set :compute:x1 :compute:zx
+  176 op mul *tmp59 :compute:zx :compute:zx
+  177 op mul *tmp60 :compute:zy :compute:zy
+  178 op sub *tmp61 *tmp59 *tmp60
+  179 op add :compute:zx *tmp61 :compute:cx
+  180 op mul *tmp63 2 :compute:x1
+  181 op mul *tmp64 *tmp63 :compute:zy
+  182 op add :compute:zy *tmp64 :compute:cy
+  183 op len :compute:dist :compute:zx :compute:zy
+  184 jump *label151 lessThan :compute:dist 64
+  185 jump *label56 always
+  186 label *label151
+  187 label *label152
+  188 label *label153
+  189 op add :compute:i :compute:i 1
+  190 label *label154
+  191 set :compute:x1 :compute:zx
+  192 op mul *tmp59 :compute:zx :compute:zx
+  193 op mul *tmp60 :compute:zy :compute:zy
+  194 op sub *tmp61 *tmp59 *tmp60
+  195 op add :compute:zx *tmp61 :compute:cx
+  196 op mul *tmp63 2 :compute:x1
+  197 op mul *tmp64 *tmp63 :compute:zy
+  198 op add :compute:zy *tmp64 :compute:cy
+  199 op len :compute:dist :compute:zx :compute:zy
+  200 jump *label155 lessThan :compute:dist 64
+  201 jump *label56 always
+  202 label *label155
+  203 label *label156
+  204 label *label157
+  205 op add :compute:i :compute:i 1
+  206 label *label158
+  207 set :compute:x1 :compute:zx
+  208 op mul *tmp59 :compute:zx :compute:zx
+  209 op mul *tmp60 :compute:zy :compute:zy
+  210 op sub *tmp61 *tmp59 *tmp60
+  211 op add :compute:zx *tmp61 :compute:cx
+  212 op mul *tmp63 2 :compute:x1
+  213 op mul *tmp64 *tmp63 :compute:zy
+  214 op add :compute:zy *tmp64 :compute:cy
+  215 op len :compute:dist :compute:zx :compute:zy
+  216 jump *label159 lessThan :compute:dist 64
+  217 jump *label56 always
+  218 label *label159
+  219 label *label160
+  220 label *label161
+  221 op add :compute:i :compute:i 1
+  222 label *label162
+  223 set :compute:x1 :compute:zx
+  224 op mul *tmp59 :compute:zx :compute:zx
+  225 op mul *tmp60 :compute:zy :compute:zy
+  226 op sub *tmp61 *tmp59 *tmp60
+  227 op add :compute:zx *tmp61 :compute:cx
+  228 op mul *tmp63 2 :compute:x1
+  229 op mul *tmp64 *tmp63 :compute:zy
+  230 op add :compute:zy *tmp64 :compute:cy
+  231 op len :compute:dist :compute:zx :compute:zy
+  232 jump *label163 lessThan :compute:dist 64
+  233 jump *label56 always
+  234 label *label163
+  235 label *label164
+  236 label *label165
+  237 op add :compute:i :compute:i 1
+  238 label *label166
+  239 set :compute:x1 :compute:zx
+  240 op mul *tmp59 :compute:zx :compute:zx
+  241 op mul *tmp60 :compute:zy :compute:zy
+  242 op sub *tmp61 *tmp59 *tmp60
+  243 op add :compute:zx *tmp61 :compute:cx
+  244 op mul *tmp63 2 :compute:x1
+  245 op mul *tmp64 *tmp63 :compute:zy
+  246 op add :compute:zy *tmp64 :compute:cy
+  247 op len :compute:dist :compute:zx :compute:zy
+  248 jump *label167 lessThan :compute:dist 64
+  249 jump *label56 always
+  250 label *label167
+  251 label *label168
+  252 label *label169
+  253 op add :compute:i :compute:i 1
+  254 label *label170
+  255 set :compute:x1 :compute:zx
+  256 op mul *tmp59 :compute:zx :compute:zx
+  257 op mul *tmp60 :compute:zy :compute:zy
+  258 op sub *tmp61 *tmp59 *tmp60
+  259 op add :compute:zx *tmp61 :compute:cx
+  260 op mul *tmp63 2 :compute:x1
+  261 op mul *tmp64 *tmp63 :compute:zy
+  262 op add :compute:zy *tmp64 :compute:cy
+  263 op len :compute:dist :compute:zx :compute:zy
+  264 jump *label171 lessThan :compute:dist 64
+  265 jump *label56 always
+  266 label *label171
+  267 label *label172
+  268 label *label173
+  269 op add :compute:i :compute:i 1
+  270 label *label174
+  271 set :compute:x1 :compute:zx
+  272 op mul *tmp59 :compute:zx :compute:zx
+  273 op mul *tmp60 :compute:zy :compute:zy
+  274 op sub *tmp61 *tmp59 *tmp60
+  275 op add :compute:zx *tmp61 :compute:cx
+  276 op mul *tmp63 2 :compute:x1
+  277 op mul *tmp64 *tmp63 :compute:zy
+  278 op add :compute:zy *tmp64 :compute:cy
+  279 op len :compute:dist :compute:zx :compute:zy
+  280 jump *label175 lessThan :compute:dist 64
+  281 jump *label56 always
+  282 label *label175
+  283 label *label176
+  284 label *label177
+  285 op add :compute:i :compute:i 1
+  286 label *label178
+  287 set :compute:x1 :compute:zx
+  288 op mul *tmp59 :compute:zx :compute:zx
+  289 op mul *tmp60 :compute:zy :compute:zy
+  290 op sub *tmp61 *tmp59 *tmp60
+  291 op add :compute:zx *tmp61 :compute:cx
+  292 op mul *tmp63 2 :compute:x1
+  293 op mul *tmp64 *tmp63 :compute:zy
+  294 op add :compute:zy *tmp64 :compute:cy
+  295 op len :compute:dist :compute:zx :compute:zy
+  296 jump *label179 lessThan :compute:dist 64
+  297 jump *label56 always
+  298 label *label179
+  299 label *label180
+  300 label *label181
+  301 op add :compute:i :compute:i 1
+  302 label *label182
+  303 set :compute:x1 :compute:zx
+  304 op mul *tmp59 :compute:zx :compute:zx
+  305 op mul *tmp60 :compute:zy :compute:zy
+  306 op sub *tmp61 *tmp59 *tmp60
+  307 op add :compute:zx *tmp61 :compute:cx
+  308 op mul *tmp63 2 :compute:x1
+  309 op mul *tmp64 *tmp63 :compute:zy
+  310 op add :compute:zy *tmp64 :compute:cy
+  311 op len :compute:dist :compute:zx :compute:zy
+  312 jump *label183 lessThan :compute:dist 64
+  313 jump *label56 always
+  314 label *label183
+  315 label *label184
+  316 label *label185
+  317 op add :compute:i :compute:i 1
+  318 label *label186
+  319 set :compute:x1 :compute:zx
+  320 op mul *tmp59 :compute:zx :compute:zx
+  321 op mul *tmp60 :compute:zy :compute:zy
+  322 op sub *tmp61 *tmp59 *tmp60
+  323 op add :compute:zx *tmp61 :compute:cx
+  324 op mul *tmp63 2 :compute:x1
+  325 op mul *tmp64 *tmp63 :compute:zy
+  326 op add :compute:zy *tmp64 :compute:cy
+  327 op len :compute:dist :compute:zx :compute:zy
+  328 jump *label187 lessThan :compute:dist 64
+  329 jump *label56 always
+  330 label *label187
+  331 label *label188
+  332 label *label189
+  333 op add :compute:i :compute:i 1
+  334 label *label190
+  335 set :compute:x1 :compute:zx
+  336 op mul *tmp59 :compute:zx :compute:zx
+  337 op mul *tmp60 :compute:zy :compute:zy
+  338 op sub *tmp61 *tmp59 *tmp60
+  339 op add :compute:zx *tmp61 :compute:cx
+  340 op mul *tmp63 2 :compute:x1
+  341 op mul *tmp64 *tmp63 :compute:zy
+  342 op add :compute:zy *tmp64 :compute:cy
+  343 op len :compute:dist :compute:zx :compute:zy
+  344 jump *label191 lessThan :compute:dist 64
+  345 jump *label56 always
+  346 label *label191
+  347 label *label192
+  348 label *label193
+  349 op add :compute:i :compute:i 1
+  350 label *label194
+  351 set :compute:x1 :compute:zx
+  352 op mul *tmp59 :compute:zx :compute:zx
+  353 op mul *tmp60 :compute:zy :compute:zy
+  354 op sub *tmp61 *tmp59 *tmp60
+  355 op add :compute:zx *tmp61 :compute:cx
+  356 op mul *tmp63 2 :compute:x1
+  357 op mul *tmp64 *tmp63 :compute:zy
+  358 op add :compute:zy *tmp64 :compute:cy
+  359 op len :compute:dist :compute:zx :compute:zy
+  360 jump *label195 lessThan :compute:dist 64
+  361 jump *label56 always
+  362 label *label195
+  363 label *label196
+  364 label *label197
+  365 op add :compute:i :compute:i 1
+  366 label *label198
+  367 set :compute:x1 :compute:zx
+  368 op mul *tmp59 :compute:zx :compute:zx
+  369 op mul *tmp60 :compute:zy :compute:zy
+  370 op sub *tmp61 *tmp59 *tmp60
+  371 op add :compute:zx *tmp61 :compute:cx
+  372 op mul *tmp63 2 :compute:x1
+  373 op mul *tmp64 *tmp63 :compute:zy
+  374 op add :compute:zy *tmp64 :compute:cy
+  375 op len :compute:dist :compute:zx :compute:zy
+  376 jump *label199 lessThan :compute:dist 64
+  377 jump *label56 always
+  378 label *label199
+  379 label *label200
+  380 label *label201
+  381 op add :compute:i :compute:i 1
+  382 label *label202
+  383 set :compute:x1 :compute:zx
+  384 op mul *tmp59 :compute:zx :compute:zx
+  385 op mul *tmp60 :compute:zy :compute:zy
+  386 op sub *tmp61 *tmp59 *tmp60
+  387 op add :compute:zx *tmp61 :compute:cx
+  388 op mul *tmp63 2 :compute:x1
+  389 op mul *tmp64 *tmp63 :compute:zy
+  390 op add :compute:zy *tmp64 :compute:cy
+  391 op len :compute:dist :compute:zx :compute:zy
+  392 jump *label203 lessThan :compute:dist 64
+  393 jump *label56 always
+  394 label *label203
+  395 label *label204
+  396 label *label205
+  397 op add :compute:i :compute:i 1
+  398 label *label206
+  399 set :compute:x1 :compute:zx
+  400 op mul *tmp59 :compute:zx :compute:zx
+  401 op mul *tmp60 :compute:zy :compute:zy
+  402 op sub *tmp61 *tmp59 *tmp60
+  403 op add :compute:zx *tmp61 :compute:cx
+  404 op mul *tmp63 2 :compute:x1
+  405 op mul *tmp64 *tmp63 :compute:zy
+  406 op add :compute:zy *tmp64 :compute:cy
+  407 op len :compute:dist :compute:zx :compute:zy
+  408 jump *label207 lessThan :compute:dist 64
+  409 jump *label56 always
+  410 label *label207
+  411 label *label208
+  412 label *label209
+  413 op add :compute:i :compute:i 1
+  414 label *label210
+  415 set :compute:x1 :compute:zx
+  416 op mul *tmp59 :compute:zx :compute:zx
+  417 op mul *tmp60 :compute:zy :compute:zy
+  418 op sub *tmp61 *tmp59 *tmp60
+  419 op add :compute:zx *tmp61 :compute:cx
+  420 op mul *tmp63 2 :compute:x1
+  421 op mul *tmp64 *tmp63 :compute:zy
+  422 op add :compute:zy *tmp64 :compute:cy
+  423 op len :compute:dist :compute:zx :compute:zy
+  424 jump *label211 lessThan :compute:dist 64
+  425 jump *label56 always
+  426 label *label211
+  427 label *label212
+  428 label *label213
+  429 op add :compute:i :compute:i 1
+  430 label *label214
+  431 set :compute:x1 :compute:zx
+  432 op mul *tmp59 :compute:zx :compute:zx
+  433 op mul *tmp60 :compute:zy :compute:zy
+  434 op sub *tmp61 *tmp59 *tmp60
+  435 op add :compute:zx *tmp61 :compute:cx
+  436 op mul *tmp63 2 :compute:x1
+  437 op mul *tmp64 *tmp63 :compute:zy
+  438 op add :compute:zy *tmp64 :compute:cy
+  439 op len :compute:dist :compute:zx :compute:zy
+  440 jump *label215 lessThan :compute:dist 64
+  441 jump *label56 always
+  442 label *label215
+  443 label *label216
+  444 label *label217
+  445 op add :compute:i :compute:i 1
+  446 label *label218
+  447 set :compute:x1 :compute:zx
+  448 op mul *tmp59 :compute:zx :compute:zx
+  449 op mul *tmp60 :compute:zy :compute:zy
+  450 op sub *tmp61 *tmp59 *tmp60
+  451 op add :compute:zx *tmp61 :compute:cx
+  452 op mul *tmp63 2 :compute:x1
+  453 op mul *tmp64 *tmp63 :compute:zy
+  454 op add :compute:zy *tmp64 :compute:cy
+  455 op len :compute:dist :compute:zx :compute:zy
+  456 jump *label219 lessThan :compute:dist 64
+  457 jump *label56 always
+  458 label *label219
+  459 label *label220
+  460 label *label221
+  461 op add :compute:i :compute:i 1
+  462 label *label222
+  463 set :compute:x1 :compute:zx
+  464 op mul *tmp59 :compute:zx :compute:zx
+  465 op mul *tmp60 :compute:zy :compute:zy
+  466 op sub *tmp61 *tmp59 *tmp60
+  467 op add :compute:zx *tmp61 :compute:cx
+  468 op mul *tmp63 2 :compute:x1
+  469 op mul *tmp64 *tmp63 :compute:zy
+  470 op add :compute:zy *tmp64 :compute:cy
+  471 op len :compute:dist :compute:zx :compute:zy
+  472 jump *label223 lessThan :compute:dist 64
+  473 jump *label56 always
+  474 label *label223
+  475 label *label224
+  476 label *label225
+  477 op add :compute:i :compute:i 1
+  478 label *label226
+  479 set :compute:x1 :compute:zx
+  480 op mul *tmp59 :compute:zx :compute:zx
+  481 op mul *tmp60 :compute:zy :compute:zy
+  482 op sub *tmp61 *tmp59 *tmp60
+  483 op add :compute:zx *tmp61 :compute:cx
+  484 op mul *tmp63 2 :compute:x1
+  485 op mul *tmp64 *tmp63 :compute:zy
+  486 op add :compute:zy *tmp64 :compute:cy
+  487 op len :compute:dist :compute:zx :compute:zy
+  488 jump *label227 lessThan :compute:dist 64
+  489 jump *label56 always
+  490 label *label227
+  491 label *label228
+  492 label *label229
+  493 op add :compute:i :compute:i 1
+  494 label *label230
+  495 set :compute:x1 :compute:zx
+  496 op mul *tmp59 :compute:zx :compute:zx
+  497 op mul *tmp60 :compute:zy :compute:zy
+  498 op sub *tmp61 *tmp59 *tmp60
+  499 op add :compute:zx *tmp61 :compute:cx
+  500 op mul *tmp63 2 :compute:x1
+  501 op mul *tmp64 *tmp63 :compute:zy
+  502 op add :compute:zy *tmp64 :compute:cy
+  503 op len :compute:dist :compute:zx :compute:zy
+  504 jump *label231 lessThan :compute:dist 64
+  505 jump *label56 always
+  506 label *label231
+  507 label *label232
+  508 label *label233
+  509 op add :compute:i :compute:i 1
+  510 label *label234
+  511 set :compute:x1 :compute:zx
+  512 op mul *tmp59 :compute:zx :compute:zx
+  513 op mul *tmp60 :compute:zy :compute:zy
+  514 op sub *tmp61 *tmp59 *tmp60
+  515 op add :compute:zx *tmp61 :compute:cx
+  516 op mul *tmp63 2 :compute:x1
+  517 op mul *tmp64 *tmp63 :compute:zy
+  518 op add :compute:zy *tmp64 :compute:cy
+  519 op len :compute:dist :compute:zx :compute:zy
+  520 jump *label235 lessThan :compute:dist 64
+  521 jump *label56 always
+  522 label *label235
+  523 label *label236
+  524 label *label237
+  525 op add :compute:i :compute:i 1
+  526 label *label238
+  527 set :compute:x1 :compute:zx
+  528 op mul *tmp59 :compute:zx :compute:zx
+  529 op mul *tmp60 :compute:zy :compute:zy
+  530 op sub *tmp61 *tmp59 *tmp60
+  531 op add :compute:zx *tmp61 :compute:cx
+  532 op mul *tmp63 2 :compute:x1
+  533 op mul *tmp64 *tmp63 :compute:zy
+  534 op add :compute:zy *tmp64 :compute:cy
+  535 op len :compute:dist :compute:zx :compute:zy
+  536 jump *label239 lessThan :compute:dist 64
+  537 jump *label56 always
+  538 label *label239
+  539 label *label240
+  540 label *label241
+  541 op add :compute:i :compute:i 1
+  542 label *label242
+  543 set :compute:x1 :compute:zx
+  544 op mul *tmp59 :compute:zx :compute:zx
+  545 op mul *tmp60 :compute:zy :compute:zy
+  546 op sub *tmp61 *tmp59 *tmp60
+  547 op add :compute:zx *tmp61 :compute:cx
+  548 op mul *tmp63 2 :compute:x1
+  549 op mul *tmp64 *tmp63 :compute:zy
+  550 op add :compute:zy *tmp64 :compute:cy
+  551 op len :compute:dist :compute:zx :compute:zy
+  552 jump *label243 lessThan :compute:dist 64
+  553 jump *label56 always
+  554 label *label243
+  555 label *label244
+  556 label *label245
+  557 op add :compute:i :compute:i 1
+  558 label *label246
+  559 set :compute:x1 :compute:zx
+  560 op mul *tmp59 :compute:zx :compute:zx
+  561 op mul *tmp60 :compute:zy :compute:zy
+  562 op sub *tmp61 *tmp59 *tmp60
+  563 op add :compute:zx *tmp61 :compute:cx
+  564 op mul *tmp63 2 :compute:x1
+  565 op mul *tmp64 *tmp63 :compute:zy
+  566 op add :compute:zy *tmp64 :compute:cy
+  567 op len :compute:dist :compute:zx :compute:zy
+  568 jump *label247 lessThan :compute:dist 64
+  569 jump *label56 always
+  570 label *label247
+  571 label *label248
+  572 label *label249
+  573 op add :compute:i :compute:i 1
+  574 label *label250
+  575 set :compute:x1 :compute:zx
+  576 op mul *tmp59 :compute:zx :compute:zx
+  577 op mul *tmp60 :compute:zy :compute:zy
+  578 op sub *tmp61 *tmp59 *tmp60
+  579 op add :compute:zx *tmp61 :compute:cx
+  580 op mul *tmp63 2 :compute:x1
+  581 op mul *tmp64 *tmp63 :compute:zy
+  582 op add :compute:zy *tmp64 :compute:cy
+  583 op len :compute:dist :compute:zx :compute:zy
+  584 jump *label251 lessThan :compute:dist 64
+  585 jump *label56 always
+  586 label *label251
+  587 label *label252
+  588 label *label253
+  589 op add :compute:i :compute:i 1
+  590 label *label254
+  591 set :compute:x1 :compute:zx
+  592 op mul *tmp59 :compute:zx :compute:zx
+  593 op mul *tmp60 :compute:zy :compute:zy
+  594 op sub *tmp61 *tmp59 *tmp60
+  595 op add :compute:zx *tmp61 :compute:cx
+  596 op mul *tmp63 2 :compute:x1
+  597 op mul *tmp64 *tmp63 :compute:zy
+  598 op add :compute:zy *tmp64 :compute:cy
+  599 op len :compute:dist :compute:zx :compute:zy
+  600 jump *label255 lessThan :compute:dist 64
+  601 jump *label56 always
+  602 label *label255
+  603 label *label256
+  604 label *label257
+  605 op add :compute:i :compute:i 1
+  606 label *label258
+  607 set :compute:x1 :compute:zx
+  608 op mul *tmp59 :compute:zx :compute:zx
+  609 op mul *tmp60 :compute:zy :compute:zy
+  610 op sub *tmp61 *tmp59 *tmp60
+  611 op add :compute:zx *tmp61 :compute:cx
+  612 op mul *tmp63 2 :compute:x1
+  613 op mul *tmp64 *tmp63 :compute:zy
+  614 op add :compute:zy *tmp64 :compute:cy
+  615 op len :compute:dist :compute:zx :compute:zy
+  616 jump *label259 lessThan :compute:dist 64
+  617 jump *label56 always
+  618 label *label259
+  619 label *label260
+  620 label *label261
+  621 op add :compute:i :compute:i 1
+  622 label *label262
+  623 set :compute:x1 :compute:zx
+  624 op mul *tmp59 :compute:zx :compute:zx
+  625 op mul *tmp60 :compute:zy :compute:zy
+  626 op sub *tmp61 *tmp59 *tmp60
+  627 op add :compute:zx *tmp61 :compute:cx
+  628 op mul *tmp63 2 :compute:x1
+  629 op mul *tmp64 *tmp63 :compute:zy
+  630 op add :compute:zy *tmp64 :compute:cy
+  631 op len :compute:dist :compute:zx :compute:zy
+  632 jump *label263 lessThan :compute:dist 64
+  633 jump *label56 always
+  634 label *label263
+  635 label *label264
+  636 label *label265
+  637 op add :compute:i :compute:i 1
+  638 label *label266
+  639 set :compute:x1 :compute:zx
+  640 op mul *tmp59 :compute:zx :compute:zx
+  641 op mul *tmp60 :compute:zy :compute:zy
+  642 op sub *tmp61 *tmp59 *tmp60
+  643 op add :compute:zx *tmp61 :compute:cx
+  644 op mul *tmp63 2 :compute:x1
+  645 op mul *tmp64 *tmp63 :compute:zy
+  646 op add :compute:zy *tmp64 :compute:cy
+  647 op len :compute:dist :compute:zx :compute:zy
+  648 jump *label267 lessThan :compute:dist 64
+  649 jump *label56 always
+  650 label *label267
+  651 label *label268
+  652 label *label269
+  653 op add :compute:i :compute:i 1
+  654 label *label270
+  655 set :compute:x1 :compute:zx
+  656 op mul *tmp59 :compute:zx :compute:zx
+  657 op mul *tmp60 :compute:zy :compute:zy
+  658 op sub *tmp61 *tmp59 *tmp60
+  659 op add :compute:zx *tmp61 :compute:cx
+  660 op mul *tmp63 2 :compute:x1
+  661 op mul *tmp64 *tmp63 :compute:zy
+  662 op add :compute:zy *tmp64 :compute:cy
+  663 op len :compute:dist :compute:zx :compute:zy
+  664 jump *label271 lessThan :compute:dist 64
+  665 jump *label56 always
+  666 label *label271
+  667 label *label272
+  668 label *label273
+  669 op add :compute:i :compute:i 1
+  670 label *label274
+  671 set :compute:x1 :compute:zx
+  672 op mul *tmp59 :compute:zx :compute:zx
+  673 op mul *tmp60 :compute:zy :compute:zy
+  674 op sub *tmp61 *tmp59 *tmp60
+  675 op add :compute:zx *tmp61 :compute:cx
+  676 op mul *tmp63 2 :compute:x1
+  677 op mul *tmp64 *tmp63 :compute:zy
+  678 op add :compute:zy *tmp64 :compute:cy
+  679 op len :compute:dist :compute:zx :compute:zy
+  680 jump *label275 lessThan :compute:dist 64
+  681 jump *label56 always
+  682 label *label275
+  683 label *label276
+  684 label *label277
+  685 op add :compute:i :compute:i 1
+  686 label *label278
+  687 set :compute:x1 :compute:zx
+  688 op mul *tmp59 :compute:zx :compute:zx
+  689 op mul *tmp60 :compute:zy :compute:zy
+  690 op sub *tmp61 *tmp59 *tmp60
+  691 op add :compute:zx *tmp61 :compute:cx
+  692 op mul *tmp63 2 :compute:x1
+  693 op mul *tmp64 *tmp63 :compute:zy
+  694 op add :compute:zy *tmp64 :compute:cy
+  695 op len :compute:dist :compute:zx :compute:zy
+  696 jump *label279 lessThan :compute:dist 64
+  697 jump *label56 always
+  698 label *label279
+  699 label *label280
+  700 label *label281
+  701 op add :compute:i :compute:i 1
+  702 label *label282
+  703 set :compute:x1 :compute:zx
+  704 op mul *tmp59 :compute:zx :compute:zx
+  705 op mul *tmp60 :compute:zy :compute:zy
+  706 op sub *tmp61 *tmp59 *tmp60
+  707 op add :compute:zx *tmp61 :compute:cx
+  708 op mul *tmp63 2 :compute:x1
+  709 op mul *tmp64 *tmp63 :compute:zy
+  710 op add :compute:zy *tmp64 :compute:cy
+  711 op len :compute:dist :compute:zx :compute:zy
+  712 jump *label283 lessThan :compute:dist 64
+  713 jump *label56 always
+  714 label *label283
+  715 label *label284
+  716 label *label285
+  717 op add :compute:i :compute:i 1
+  718 label *label286
+  719 set :compute:x1 :compute:zx
+  720 op mul *tmp59 :compute:zx :compute:zx
+  721 op mul *tmp60 :compute:zy :compute:zy
+  722 op sub *tmp61 *tmp59 *tmp60
+  723 op add :compute:zx *tmp61 :compute:cx
+  724 op mul *tmp63 2 :compute:x1
+  725 op mul *tmp64 *tmp63 :compute:zy
+  726 op add :compute:zy *tmp64 :compute:cy
+  727 op len :compute:dist :compute:zx :compute:zy
+  728 jump *label287 lessThan :compute:dist 64
+  729 jump *label56 always
+  730 label *label287
+  731 label *label288
+  732 label *label289
+  733 op add :compute:i :compute:i 1
+  734 label *label290
+  735 set :compute:x1 :compute:zx
+  736 op mul *tmp59 :compute:zx :compute:zx
+  737 op mul *tmp60 :compute:zy :compute:zy
+  738 op sub *tmp61 *tmp59 *tmp60
+  739 op add :compute:zx *tmp61 :compute:cx
+  740 op mul *tmp63 2 :compute:x1
+  741 op mul *tmp64 *tmp63 :compute:zy
+  742 op add :compute:zy *tmp64 :compute:cy
+  743 op len :compute:dist :compute:zx :compute:zy
+  744 jump *label291 lessThan :compute:dist 64
+  745 jump *label56 always
+  746 label *label291
+  747 label *label292
+  748 label *label293
+  749 op add :compute:i :compute:i 1
+  750 label *label294
+  751 set :compute:x1 :compute:zx
+  752 op mul *tmp59 :compute:zx :compute:zx
+  753 op mul *tmp60 :compute:zy :compute:zy
+  754 op sub *tmp61 *tmp59 *tmp60
+  755 op add :compute:zx *tmp61 :compute:cx
+  756 op mul *tmp63 2 :compute:x1
+  757 op mul *tmp64 *tmp63 :compute:zy
+  758 op add :compute:zy *tmp64 :compute:cy
+  759 op len :compute:dist :compute:zx :compute:zy
+  760 jump *label295 lessThan :compute:dist 64
+  761 jump *label56 always
+  762 label *label295
+  763 label *label296
+  764 label *label297
+  765 op add :compute:i :compute:i 1
+  766 label *label298
+  767 set :compute:x1 :compute:zx
+  768 op mul *tmp59 :compute:zx :compute:zx
+  769 op mul *tmp60 :compute:zy :compute:zy
+  770 op sub *tmp61 *tmp59 *tmp60
+  771 op add :compute:zx *tmp61 :compute:cx
+  772 op mul *tmp63 2 :compute:x1
+  773 op mul *tmp64 *tmp63 :compute:zy
+  774 op add :compute:zy *tmp64 :compute:cy
+  775 op len :compute:dist :compute:zx :compute:zy
+  776 jump *label299 lessThan :compute:dist 64
+  777 jump *label56 always
+  778 label *label299
+  779 label *label300
+  780 label *label301
+  781 op add :compute:i :compute:i 1
+  782 label *label302
+  783 set :compute:x1 :compute:zx
+  784 op mul *tmp59 :compute:zx :compute:zx
+  785 op mul *tmp60 :compute:zy :compute:zy
+  786 op sub *tmp61 *tmp59 *tmp60
+  787 op add :compute:zx *tmp61 :compute:cx
+  788 op mul *tmp63 2 :compute:x1
+  789 op mul *tmp64 *tmp63 :compute:zy
+  790 op add :compute:zy *tmp64 :compute:cy
+  791 op len :compute:dist :compute:zx :compute:zy
+  792 jump *label303 lessThan :compute:dist 64
+  793 jump *label56 always
+  794 label *label303
+  795 label *label304
+  796 label *label305
+  797 op add :compute:i :compute:i 1
+  798 label *label306
+  799 set :compute:x1 :compute:zx
+  800 op mul *tmp59 :compute:zx :compute:zx
+  801 op mul *tmp60 :compute:zy :compute:zy
+  802 op sub *tmp61 *tmp59 *tmp60
+  803 op add :compute:zx *tmp61 :compute:cx
+  804 op mul *tmp63 2 :compute:x1
+  805 op mul *tmp64 *tmp63 :compute:zy
+  806 op add :compute:zy *tmp64 :compute:cy
+  807 op len :compute:dist :compute:zx :compute:zy
+  808 jump *label307 lessThan :compute:dist 64
+  809 jump *label56 always
+  810 label *label307
+  811 label *label308
+  812 label *label309
+  813 op add :compute:i :compute:i 1
+  814 label *label310
+  815 set :compute:x1 :compute:zx
+  816 op mul *tmp59 :compute:zx :compute:zx
+  817 op mul *tmp60 :compute:zy :compute:zy
+  818 op sub *tmp61 *tmp59 *tmp60
+  819 op add :compute:zx *tmp61 :compute:cx
+  820 op mul *tmp63 2 :compute:x1
+  821 op mul *tmp64 *tmp63 :compute:zy
+  822 op add :compute:zy *tmp64 :compute:cy
+  823 op len :compute:dist :compute:zx :compute:zy
+  824 jump *label311 lessThan :compute:dist 64
+  825 jump *label56 always
+  826 label *label311
+  827 label *label312
+  828 label *label313
+  829 op add :compute:i :compute:i 1
+  830 label *label314
+  831 set :compute:x1 :compute:zx
+  832 op mul *tmp59 :compute:zx :compute:zx
+  833 op mul *tmp60 :compute:zy :compute:zy
+  834 op sub *tmp61 *tmp59 *tmp60
+  835 op add :compute:zx *tmp61 :compute:cx
+  836 op mul *tmp63 2 :compute:x1
+  837 op mul *tmp64 *tmp63 :compute:zy
+  838 op add :compute:zy *tmp64 :compute:cy
+  839 op len :compute:dist :compute:zx :compute:zy
+  840 jump *label315 lessThan :compute:dist 64
+  841 jump *label56 always
+  842 label *label315
+  843 label *label316
+  844 label *label317
+  845 op add :compute:i :compute:i 1
+  846 label *label318
+  847 set :compute:x1 :compute:zx
+  848 op mul *tmp59 :compute:zx :compute:zx
+  849 op mul *tmp60 :compute:zy :compute:zy
+  850 op sub *tmp61 *tmp59 *tmp60
+  851 op add :compute:zx *tmp61 :compute:cx
+  852 op mul *tmp63 2 :compute:x1
+  853 op mul *tmp64 *tmp63 :compute:zy
+  854 op add :compute:zy *tmp64 :compute:cy
+  855 op len :compute:dist :compute:zx :compute:zy
+  856 jump *label319 lessThan :compute:dist 64
+  857 jump *label56 always
+  858 label *label319
+  859 label *label320
+  860 label *label321
+  861 op add :compute:i :compute:i 1
+  862 label *label322
+  863 set :compute:x1 :compute:zx
+  864 op mul *tmp59 :compute:zx :compute:zx
+  865 op mul *tmp60 :compute:zy :compute:zy
+  866 op sub *tmp61 *tmp59 *tmp60
+  867 op add :compute:zx *tmp61 :compute:cx
+  868 op mul *tmp63 2 :compute:x1
+  869 op mul *tmp64 *tmp63 :compute:zy
+  870 op add :compute:zy *tmp64 :compute:cy
+  871 op len :compute:dist :compute:zx :compute:zy
+  872 jump *label323 lessThan :compute:dist 64
+  873 jump *label56 always
+  874 label *label323
+  875 label *label324
+  876 label *label325
+  877 op add :compute:i :compute:i 1
+  878 label *label326
+  879 set :compute:x1 :compute:zx
+  880 op mul *tmp59 :compute:zx :compute:zx
+  881 op mul *tmp60 :compute:zy :compute:zy
+  882 op sub *tmp61 *tmp59 *tmp60
+  883 op add :compute:zx *tmp61 :compute:cx
+  884 op mul *tmp63 2 :compute:x1
+  885 op mul *tmp64 *tmp63 :compute:zy
+  886 op add :compute:zy *tmp64 :compute:cy
+  887 op len :compute:dist :compute:zx :compute:zy
+  888 jump *label327 lessThan :compute:dist 64
+  889 jump *label56 always
+  890 label *label327
+  891 label *label328
+  892 label *label329
+  893 op add :compute:i :compute:i 1
+  894 label *label330
+  895 set :compute:x1 :compute:zx
+  896 op mul *tmp59 :compute:zx :compute:zx
+  897 op mul *tmp60 :compute:zy :compute:zy
+  898 op sub *tmp61 *tmp59 *tmp60
+  899 op add :compute:zx *tmp61 :compute:cx
+  900 op mul *tmp63 2 :compute:x1
+  901 op mul *tmp64 *tmp63 :compute:zy
+  902 op add :compute:zy *tmp64 :compute:cy
+  903 op len :compute:dist :compute:zx :compute:zy
+  904 jump *label331 lessThan :compute:dist 64
+  905 jump *label56 always
+  906 label *label331
+  907 label *label332
+  908 label *label333
+  909 op add :compute:i :compute:i 1
+  910 label *label334
+  911 set :compute:x1 :compute:zx
+  912 op mul *tmp59 :compute:zx :compute:zx
+  913 op mul *tmp60 :compute:zy :compute:zy
+  914 op sub *tmp61 *tmp59 *tmp60
+  915 op add :compute:zx *tmp61 :compute:cx
+  916 op mul *tmp63 2 :compute:x1
+  917 op mul *tmp64 *tmp63 :compute:zy
+  918 op add :compute:zy *tmp64 :compute:cy
+  919 op len :compute:dist :compute:zx :compute:zy
+  920 jump *label335 lessThan :compute:dist 64
+  921 jump *label56 always
+  922 label *label335
+  923 label *label336
+  924 label *label337
+  925 op add :compute:i :compute:i 1
+  926 label *label338
+  927 set :compute:x1 :compute:zx
+  928 op mul *tmp59 :compute:zx :compute:zx
+  929 op mul *tmp60 :compute:zy :compute:zy
+  930 op sub *tmp61 *tmp59 *tmp60
+  931 op add :compute:zx *tmp61 :compute:cx
+  932 op mul *tmp63 2 :compute:x1
+  933 op mul *tmp64 *tmp63 :compute:zy
+  934 op add :compute:zy *tmp64 :compute:cy
+  935 op len :compute:dist :compute:zx :compute:zy
+  936 jump *label339 lessThan :compute:dist 64
+  937 jump *label56 always
+  938 label *label339
+  939 label *label340
+  940 label *label341
+  941 op add :compute:i :compute:i 1
+  942 label *label342
+  943 set :compute:x1 :compute:zx
+  944 op mul *tmp59 :compute:zx :compute:zx
+  945 op mul *tmp60 :compute:zy :compute:zy
+  946 op sub *tmp61 *tmp59 *tmp60
+  947 op add :compute:zx *tmp61 :compute:cx
+  948 op mul *tmp63 2 :compute:x1
+  949 op mul *tmp64 *tmp63 :compute:zy
+  950 op add :compute:zy *tmp64 :compute:cy
+  951 op len :compute:dist :compute:zx :compute:zy
+  952 jump *label343 lessThan :compute:dist 64
+  953 jump *label56 always
+  954 label *label343
+  955 label *label344
+  956 label *label345
+  957 op add :compute:i :compute:i 1
+  958 label *label346
+  959 set :compute:x1 :compute:zx
+  960 op mul *tmp59 :compute:zx :compute:zx
+  961 op mul *tmp60 :compute:zy :compute:zy
+  962 op sub *tmp61 *tmp59 *tmp60
+  963 op add :compute:zx *tmp61 :compute:cx
+  964 op mul *tmp63 2 :compute:x1
+  965 op mul *tmp64 *tmp63 :compute:zy
+  966 op add :compute:zy *tmp64 :compute:cy
+  967 op len :compute:dist :compute:zx :compute:zy
+  968 jump *label347 lessThan :compute:dist 64
+  969 jump *label56 always
+  970 label *label347
+  971 label *label348
+  972 label *label349
+  973 op add :compute:i :compute:i 1
+  974 label *label350
+  975 set :compute:x1 :compute:zx
+  976 op mul *tmp59 :compute:zx :compute:zx
+  977 op mul *tmp60 :compute:zy :compute:zy
+  978 op sub *tmp61 *tmp59 *tmp60
+  979 op add :compute:zx *tmp61 :compute:cx
+  980 op mul *tmp63 2 :compute:x1
+  981 op mul *tmp64 *tmp63 :compute:zy
+  982 op add :compute:zy *tmp64 :compute:cy
+  983 op len :compute:dist :compute:zx :compute:zy
+  984 jump *label351 lessThan :compute:dist 64
+  985 jump *label56 always
+  986 label *label351
+  987 label *label352
+  988 label *label353
+  989 op add :compute:i :compute:i 1
+  990 label *label354
+  991 set :compute:x1 :compute:zx
+  992 op mul *tmp59 :compute:zx :compute:zx
+  993 op mul *tmp60 :compute:zy :compute:zy
+  994 op sub *tmp61 *tmp59 *tmp60
+  995 op add :compute:zx *tmp61 :compute:cx
+  996 op mul *tmp63 2 :compute:x1
+  997 op mul *tmp64 *tmp63 :compute:zy
+  998 op add :compute:zy *tmp64 :compute:cy
+  999 op len :compute:dist :compute:zx :compute:zy
+ 1000 jump *label355 lessThan :compute:dist 64
+ 1001 jump *label56 always
+ 1002 label *label355
+ 1003 label *label356
+ 1004 label *label357
+ 1005 op add :compute:i :compute:i 1
+ 1006 label *label358
+ 1007 set :compute:x1 :compute:zx
+ 1008 op mul *tmp59 :compute:zx :compute:zx
+ 1009 op mul *tmp60 :compute:zy :compute:zy
+ 1010 op sub *tmp61 *tmp59 *tmp60
+ 1011 op add :compute:zx *tmp61 :compute:cx
+ 1012 op mul *tmp63 2 :compute:x1
+ 1013 op mul *tmp64 *tmp63 :compute:zy
+ 1014 op add :compute:zy *tmp64 :compute:cy
+ 1015 op len :compute:dist :compute:zx :compute:zy
+ 1016 jump *label359 lessThan :compute:dist 64
+ 1017 jump *label56 always
+ 1018 label *label359
+ 1019 label *label360
+ 1020 label *label361
+ 1021 op add :compute:i :compute:i 1
+ 1022 label *label362
+ 1023 set :compute:x1 :compute:zx
+ 1024 op mul *tmp59 :compute:zx :compute:zx
+ 1025 op mul *tmp60 :compute:zy :compute:zy
+ 1026 op sub *tmp61 *tmp59 *tmp60
+ 1027 op add :compute:zx *tmp61 :compute:cx
+ 1028 op mul *tmp63 2 :compute:x1
+ 1029 op mul *tmp64 *tmp63 :compute:zy
+ 1030 op add :compute:zy *tmp64 :compute:cy
+ 1031 op len :compute:dist :compute:zx :compute:zy
+ 1032 jump *label363 lessThan :compute:dist 64
+ 1033 jump *label56 always
+ 1034 label *label363
+ 1035 label *label364
+ 1036 label *label365
+ 1037 op add :compute:i :compute:i 1
+ 1038 label *label366
+ 1039 set :compute:x1 :compute:zx
+ 1040 op mul *tmp59 :compute:zx :compute:zx
+ 1041 op mul *tmp60 :compute:zy :compute:zy
+ 1042 op sub *tmp61 *tmp59 *tmp60
+ 1043 op add :compute:zx *tmp61 :compute:cx
+ 1044 op mul *tmp63 2 :compute:x1
+ 1045 op mul *tmp64 *tmp63 :compute:zy
+ 1046 op add :compute:zy *tmp64 :compute:cy
+ 1047 op len :compute:dist :compute:zx :compute:zy
+ 1048 jump *label367 lessThan :compute:dist 64
+ 1049 jump *label56 always
+ 1050 label *label367
+ 1051 label *label368
+ 1052 label *label369
+ 1053 op add :compute:i :compute:i 1
+ 1054 label *label370
+ 1055 set :compute:x1 :compute:zx
+ 1056 op mul *tmp59 :compute:zx :compute:zx
+ 1057 op mul *tmp60 :compute:zy :compute:zy
+ 1058 op sub *tmp61 *tmp59 *tmp60
+ 1059 op add :compute:zx *tmp61 :compute:cx
+ 1060 op mul *tmp63 2 :compute:x1
+ 1061 op mul *tmp64 *tmp63 :compute:zy
+ 1062 op add :compute:zy *tmp64 :compute:cy
+ 1063 op len :compute:dist :compute:zx :compute:zy
+ 1064 jump *label371 lessThan :compute:dist 64
+ 1065 jump *label56 always
+ 1066 label *label371
+ 1067 label *label372
+ 1068 label *label373
+ 1069 op add :compute:i :compute:i 1
+ 1070 label *label374
+ 1071 set :compute:x1 :compute:zx
+ 1072 op mul *tmp59 :compute:zx :compute:zx
+ 1073 op mul *tmp60 :compute:zy :compute:zy
+ 1074 op sub *tmp61 *tmp59 *tmp60
+ 1075 op add :compute:zx *tmp61 :compute:cx
+ 1076 op mul *tmp63 2 :compute:x1
+ 1077 op mul *tmp64 *tmp63 :compute:zy
+ 1078 op add :compute:zy *tmp64 :compute:cy
+ 1079 op len :compute:dist :compute:zx :compute:zy
+ 1080 jump *label375 lessThan :compute:dist 64
+ 1081 jump *label56 always
+ 1082 label *label375
+ 1083 label *label376
+ 1084 label *label377
+ 1085 op add :compute:i :compute:i 1
+ 1086 label *label378
+ 1087 set :compute:x1 :compute:zx
+ 1088 op mul *tmp59 :compute:zx :compute:zx
+ 1089 op mul *tmp60 :compute:zy :compute:zy
+ 1090 op sub *tmp61 *tmp59 *tmp60
+ 1091 op add :compute:zx *tmp61 :compute:cx
+ 1092 op mul *tmp63 2 :compute:x1
+ 1093 op mul *tmp64 *tmp63 :compute:zy
+ 1094 op add :compute:zy *tmp64 :compute:cy
+ 1095 op len :compute:dist :compute:zx :compute:zy
+ 1096 jump *label379 lessThan :compute:dist 64
+ 1097 jump *label56 always
+ 1098 label *label379
+ 1099 label *label380
+ 1100 label *label381
+ 1101 op add :compute:i :compute:i 1
+ 1102 label *label382
+ 1103 set :compute:x1 :compute:zx
+ 1104 op mul *tmp59 :compute:zx :compute:zx
+ 1105 op mul *tmp60 :compute:zy :compute:zy
+ 1106 op sub *tmp61 *tmp59 *tmp60
+ 1107 op add :compute:zx *tmp61 :compute:cx
+ 1108 op mul *tmp63 2 :compute:x1
+ 1109 op mul *tmp64 *tmp63 :compute:zy
+ 1110 op add :compute:zy *tmp64 :compute:cy
+ 1111 op len :compute:dist :compute:zx :compute:zy
+ 1112 jump *label383 lessThan :compute:dist 64
+ 1113 jump *label56 always
+ 1114 label *label383
+ 1115 label *label384
+ 1116 label *label385
+ 1117 op add :compute:i :compute:i 1
+ 1118 label *label386
+ 1119 set :compute:x1 :compute:zx
+ 1120 op mul *tmp59 :compute:zx :compute:zx
+ 1121 op mul *tmp60 :compute:zy :compute:zy
+ 1122 op sub *tmp61 *tmp59 *tmp60
+ 1123 op add :compute:zx *tmp61 :compute:cx
+ 1124 op mul *tmp63 2 :compute:x1
+ 1125 op mul *tmp64 *tmp63 :compute:zy
+ 1126 op add :compute:zy *tmp64 :compute:cy
+ 1127 op len :compute:dist :compute:zx :compute:zy
+ 1128 jump *label387 lessThan :compute:dist 64
+ 1129 jump *label56 always
+ 1130 label *label387
+ 1131 label *label388
+ 1132 label *label389
+ 1133 op add :compute:i :compute:i 1
+ 1134 label *label390
+ 1135 set :compute:x1 :compute:zx
+ 1136 op mul *tmp59 :compute:zx :compute:zx
+ 1137 op mul *tmp60 :compute:zy :compute:zy
+ 1138 op sub *tmp61 *tmp59 *tmp60
+ 1139 op add :compute:zx *tmp61 :compute:cx
+ 1140 op mul *tmp63 2 :compute:x1
+ 1141 op mul *tmp64 *tmp63 :compute:zy
+ 1142 op add :compute:zy *tmp64 :compute:cy
+ 1143 op len :compute:dist :compute:zx :compute:zy
+ 1144 jump *label391 lessThan :compute:dist 64
+ 1145 jump *label56 always
+ 1146 label *label391
+ 1147 label *label392
+ 1148 label *label393
+ 1149 op add :compute:i :compute:i 1
+ 1150 label *label394
+ 1151 set :compute:x1 :compute:zx
+ 1152 op mul *tmp59 :compute:zx :compute:zx
+ 1153 op mul *tmp60 :compute:zy :compute:zy
+ 1154 op sub *tmp61 *tmp59 *tmp60
+ 1155 op add :compute:zx *tmp61 :compute:cx
+ 1156 op mul *tmp63 2 :compute:x1
+ 1157 op mul *tmp64 *tmp63 :compute:zy
+ 1158 op add :compute:zy *tmp64 :compute:cy
+ 1159 op len :compute:dist :compute:zx :compute:zy
+ 1160 jump *label395 lessThan :compute:dist 64
+ 1161 jump *label56 always
+ 1162 label *label395
+ 1163 label *label396
+ 1164 label *label397
+ 1165 op add :compute:i :compute:i 1
+ 1166 label *label56
  1167 op mul *tmp69 .SMOOTH 63
  1168 jump *label59 greaterThanEq :compute:i *tmp69
  1169 op log *tmp72 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   170 label *label147
   171 label *label148
   172 label *label149
-    * op add :compute:i :compute:i 1
+  173 op add :compute:i 0 1
   174 label *label150
   175 set :compute:x1 :compute:zx
   176 op mul *tmp59 :compute:zx :compute:zx
 
   186 label *label151
   187 label *label152
   188 label *label153
-    * op add :compute:i :compute:i 1
+  189 op add :compute:i 1 1
   190 label *label154
   191 set :compute:x1 :compute:zx
   192 op mul *tmp59 :compute:zx :compute:zx
 
   202 label *label155
   203 label *label156
   204 label *label157
-    * op add :compute:i :compute:i 1
+  205 op add :compute:i 2 1
   206 label *label158
   207 set :compute:x1 :compute:zx
   208 op mul *tmp59 :compute:zx :compute:zx
 
   218 label *label159
   219 label *label160
   220 label *label161
-    * op add :compute:i :compute:i 1
+  221 op add :compute:i 3 1
   222 label *label162
   223 set :compute:x1 :compute:zx
   224 op mul *tmp59 :compute:zx :compute:zx
 
   234 label *label163
   235 label *label164
   236 label *label165
-    * op add :compute:i :compute:i 1
+  237 op add :compute:i 4 1
   238 label *label166
   239 set :compute:x1 :compute:zx
   240 op mul *tmp59 :compute:zx :compute:zx
 
   250 label *label167
   251 label *label168
   252 label *label169
-    * op add :compute:i :compute:i 1
+  253 op add :compute:i 5 1
   254 label *label170
   255 set :compute:x1 :compute:zx
   256 op mul *tmp59 :compute:zx :compute:zx
 
   266 label *label171
   267 label *label172
   268 label *label173
-    * op add :compute:i :compute:i 1
+  269 op add :compute:i 6 1
   270 label *label174
   271 set :compute:x1 :compute:zx
   272 op mul *tmp59 :compute:zx :compute:zx
 
   282 label *label175
   283 label *label176
   284 label *label177
-    * op add :compute:i :compute:i 1
+  285 op add :compute:i 7 1
   286 label *label178
   287 set :compute:x1 :compute:zx
   288 op mul *tmp59 :compute:zx :compute:zx
 
   298 label *label179
   299 label *label180
   300 label *label181
-    * op add :compute:i :compute:i 1
+  301 op add :compute:i 8 1
   302 label *label182
   303 set :compute:x1 :compute:zx
   304 op mul *tmp59 :compute:zx :compute:zx
 
   314 label *label183
   315 label *label184
   316 label *label185
-    * op add :compute:i :compute:i 1
+  317 op add :compute:i 9 1
   318 label *label186
   319 set :compute:x1 :compute:zx
   320 op mul *tmp59 :compute:zx :compute:zx
 
   330 label *label187
   331 label *label188
   332 label *label189
-    * op add :compute:i :compute:i 1
+  333 op add :compute:i 10 1
   334 label *label190
   335 set :compute:x1 :compute:zx
   336 op mul *tmp59 :compute:zx :compute:zx
 
   346 label *label191
   347 label *label192
   348 label *label193
-    * op add :compute:i :compute:i 1
+  349 op add :compute:i 11 1
   350 label *label194
   351 set :compute:x1 :compute:zx
   352 op mul *tmp59 :compute:zx :compute:zx
 
   362 label *label195
   363 label *label196
   364 label *label197
-    * op add :compute:i :compute:i 1
+  365 op add :compute:i 12 1
   366 label *label198
   367 set :compute:x1 :compute:zx
   368 op mul *tmp59 :compute:zx :compute:zx
 
   378 label *label199
   379 label *label200
   380 label *label201
-    * op add :compute:i :compute:i 1
+  381 op add :compute:i 13 1
   382 label *label202
   383 set :compute:x1 :compute:zx
   384 op mul *tmp59 :compute:zx :compute:zx
 
   394 label *label203
   395 label *label204
   396 label *label205
-    * op add :compute:i :compute:i 1
+  397 op add :compute:i 14 1
   398 label *label206
   399 set :compute:x1 :compute:zx
   400 op mul *tmp59 :compute:zx :compute:zx
 
   410 label *label207
   411 label *label208
   412 label *label209
-    * op add :compute:i :compute:i 1
+  413 op add :compute:i 15 1
   414 label *label210
   415 set :compute:x1 :compute:zx
   416 op mul *tmp59 :compute:zx :compute:zx
 
   426 label *label211
   427 label *label212
   428 label *label213
-    * op add :compute:i :compute:i 1
+  429 op add :compute:i 16 1
   430 label *label214
   431 set :compute:x1 :compute:zx
   432 op mul *tmp59 :compute:zx :compute:zx
 
   442 label *label215
   443 label *label216
   444 label *label217
-    * op add :compute:i :compute:i 1
+  445 op add :compute:i 17 1
   446 label *label218
   447 set :compute:x1 :compute:zx
   448 op mul *tmp59 :compute:zx :compute:zx
 
   458 label *label219
   459 label *label220
   460 label *label221
-    * op add :compute:i :compute:i 1
+  461 op add :compute:i 18 1
   462 label *label222
   463 set :compute:x1 :compute:zx
   464 op mul *tmp59 :compute:zx :compute:zx
 
   474 label *label223
   475 label *label224
   476 label *label225
-    * op add :compute:i :compute:i 1
+  477 op add :compute:i 19 1
   478 label *label226
   479 set :compute:x1 :compute:zx
   480 op mul *tmp59 :compute:zx :compute:zx
 
   490 label *label227
   491 label *label228
   492 label *label229
-    * op add :compute:i :compute:i 1
+  493 op add :compute:i 20 1
   494 label *label230
   495 set :compute:x1 :compute:zx
   496 op mul *tmp59 :compute:zx :compute:zx
 
   506 label *label231
   507 label *label232
   508 label *label233
-    * op add :compute:i :compute:i 1
+  509 op add :compute:i 21 1
   510 label *label234
   511 set :compute:x1 :compute:zx
   512 op mul *tmp59 :compute:zx :compute:zx
 
   522 label *label235
   523 label *label236
   524 label *label237
-    * op add :compute:i :compute:i 1
+  525 op add :compute:i 22 1
   526 label *label238
   527 set :compute:x1 :compute:zx
   528 op mul *tmp59 :compute:zx :compute:zx
 
   538 label *label239
   539 label *label240
   540 label *label241
-    * op add :compute:i :compute:i 1
+  541 op add :compute:i 23 1
   542 label *label242
   543 set :compute:x1 :compute:zx
   544 op mul *tmp59 :compute:zx :compute:zx
 
   554 label *label243
   555 label *label244
   556 label *label245
-    * op add :compute:i :compute:i 1
+  557 op add :compute:i 24 1
   558 label *label246
   559 set :compute:x1 :compute:zx
   560 op mul *tmp59 :compute:zx :compute:zx
 
   570 label *label247
   571 label *label248
   572 label *label249
-    * op add :compute:i :compute:i 1
+  573 op add :compute:i 25 1
   574 label *label250
   575 set :compute:x1 :compute:zx
   576 op mul *tmp59 :compute:zx :compute:zx
 
   586 label *label251
   587 label *label252
   588 label *label253
-    * op add :compute:i :compute:i 1
+  589 op add :compute:i 26 1
   590 label *label254
   591 set :compute:x1 :compute:zx
   592 op mul *tmp59 :compute:zx :compute:zx
 
   602 label *label255
   603 label *label256
   604 label *label257
-    * op add :compute:i :compute:i 1
+  605 op add :compute:i 27 1
   606 label *label258
   607 set :compute:x1 :compute:zx
   608 op mul *tmp59 :compute:zx :compute:zx
 
   618 label *label259
   619 label *label260
   620 label *label261
-    * op add :compute:i :compute:i 1
+  621 op add :compute:i 28 1
   622 label *label262
   623 set :compute:x1 :compute:zx
   624 op mul *tmp59 :compute:zx :compute:zx
 
   634 label *label263
   635 label *label264
   636 label *label265
-    * op add :compute:i :compute:i 1
+  637 op add :compute:i 29 1
   638 label *label266
   639 set :compute:x1 :compute:zx
   640 op mul *tmp59 :compute:zx :compute:zx
 
   650 label *label267
   651 label *label268
   652 label *label269
-    * op add :compute:i :compute:i 1
+  653 op add :compute:i 30 1
   654 label *label270
   655 set :compute:x1 :compute:zx
   656 op mul *tmp59 :compute:zx :compute:zx
 
   666 label *label271
   667 label *label272
   668 label *label273
-    * op add :compute:i :compute:i 1
+  669 op add :compute:i 31 1
   670 label *label274
   671 set :compute:x1 :compute:zx
   672 op mul *tmp59 :compute:zx :compute:zx
 
   682 label *label275
   683 label *label276
   684 label *label277
-    * op add :compute:i :compute:i 1
+  685 op add :compute:i 32 1
   686 label *label278
   687 set :compute:x1 :compute:zx
   688 op mul *tmp59 :compute:zx :compute:zx
 
   698 label *label279
   699 label *label280
   700 label *label281
-    * op add :compute:i :compute:i 1
+  701 op add :compute:i 33 1
   702 label *label282
   703 set :compute:x1 :compute:zx
   704 op mul *tmp59 :compute:zx :compute:zx
 
   714 label *label283
   715 label *label284
   716 label *label285
-    * op add :compute:i :compute:i 1
+  717 op add :compute:i 34 1
   718 label *label286
   719 set :compute:x1 :compute:zx
   720 op mul *tmp59 :compute:zx :compute:zx
 
   730 label *label287
   731 label *label288
   732 label *label289
-    * op add :compute:i :compute:i 1
+  733 op add :compute:i 35 1
   734 label *label290
   735 set :compute:x1 :compute:zx
   736 op mul *tmp59 :compute:zx :compute:zx
 
   746 label *label291
   747 label *label292
   748 label *label293
-    * op add :compute:i :compute:i 1
+  749 op add :compute:i 36 1
   750 label *label294
   751 set :compute:x1 :compute:zx
   752 op mul *tmp59 :compute:zx :compute:zx
 
   762 label *label295
   763 label *label296
   764 label *label297
-    * op add :compute:i :compute:i 1
+  765 op add :compute:i 37 1
   766 label *label298
   767 set :compute:x1 :compute:zx
   768 op mul *tmp59 :compute:zx :compute:zx
 
   778 label *label299
   779 label *label300
   780 label *label301
-    * op add :compute:i :compute:i 1
+  781 op add :compute:i 38 1
   782 label *label302
   783 set :compute:x1 :compute:zx
   784 op mul *tmp59 :compute:zx :compute:zx
 
   794 label *label303
   795 label *label304
   796 label *label305
-    * op add :compute:i :compute:i 1
+  797 op add :compute:i 39 1
   798 label *label306
   799 set :compute:x1 :compute:zx
   800 op mul *tmp59 :compute:zx :compute:zx
 
   810 label *label307
   811 label *label308
   812 label *label309
-    * op add :compute:i :compute:i 1
+  813 op add :compute:i 40 1
   814 label *label310
   815 set :compute:x1 :compute:zx
   816 op mul *tmp59 :compute:zx :compute:zx
 
   826 label *label311
   827 label *label312
   828 label *label313
-    * op add :compute:i :compute:i 1
+  829 op add :compute:i 41 1
   830 label *label314
   831 set :compute:x1 :compute:zx
   832 op mul *tmp59 :compute:zx :compute:zx
 
   842 label *label315
   843 label *label316
   844 label *label317
-    * op add :compute:i :compute:i 1
+  845 op add :compute:i 42 1
   846 label *label318
   847 set :compute:x1 :compute:zx
   848 op mul *tmp59 :compute:zx :compute:zx
 
   858 label *label319
   859 label *label320
   860 label *label321
-    * op add :compute:i :compute:i 1
+  861 op add :compute:i 43 1
   862 label *label322
   863 set :compute:x1 :compute:zx
   864 op mul *tmp59 :compute:zx :compute:zx
 
   874 label *label323
   875 label *label324
   876 label *label325
-    * op add :compute:i :compute:i 1
+  877 op add :compute:i 44 1
   878 label *label326
   879 set :compute:x1 :compute:zx
   880 op mul *tmp59 :compute:zx :compute:zx
 
   890 label *label327
   891 label *label328
   892 label *label329
-    * op add :compute:i :compute:i 1
+  893 op add :compute:i 45 1
   894 label *label330
   895 set :compute:x1 :compute:zx
   896 op mul *tmp59 :compute:zx :compute:zx
 
   906 label *label331
   907 label *label332
   908 label *label333
-    * op add :compute:i :compute:i 1
+  909 op add :compute:i 46 1
   910 label *label334
   911 set :compute:x1 :compute:zx
   912 op mul *tmp59 :compute:zx :compute:zx
 
   922 label *label335
   923 label *label336
   924 label *label337
-    * op add :compute:i :compute:i 1
+  925 op add :compute:i 47 1
   926 label *label338
   927 set :compute:x1 :compute:zx
   928 op mul *tmp59 :compute:zx :compute:zx
 
   938 label *label339
   939 label *label340
   940 label *label341
-    * op add :compute:i :compute:i 1
+  941 op add :compute:i 48 1
   942 label *label342
   943 set :compute:x1 :compute:zx
   944 op mul *tmp59 :compute:zx :compute:zx
 
   954 label *label343
   955 label *label344
   956 label *label345
-    * op add :compute:i :compute:i 1
+  957 op add :compute:i 49 1
   958 label *label346
   959 set :compute:x1 :compute:zx
   960 op mul *tmp59 :compute:zx :compute:zx
 
   970 label *label347
   971 label *label348
   972 label *label349
-    * op add :compute:i :compute:i 1
+  973 op add :compute:i 50 1
   974 label *label350
   975 set :compute:x1 :compute:zx
   976 op mul *tmp59 :compute:zx :compute:zx
 
   986 label *label351
   987 label *label352
   988 label *label353
-    * op add :compute:i :compute:i 1
+  989 op add :compute:i 51 1
   990 label *label354
   991 set :compute:x1 :compute:zx
   992 op mul *tmp59 :compute:zx :compute:zx
 
  1002 label *label355
  1003 label *label356
  1004 label *label357
-    * op add :compute:i :compute:i 1
+ 1005 op add :compute:i 52 1
  1006 label *label358
  1007 set :compute:x1 :compute:zx
  1008 op mul *tmp59 :compute:zx :compute:zx
 
  1018 label *label359
  1019 label *label360
  1020 label *label361
-    * op add :compute:i :compute:i 1
+ 1021 op add :compute:i 53 1
  1022 label *label362
  1023 set :compute:x1 :compute:zx
  1024 op mul *tmp59 :compute:zx :compute:zx
 
  1034 label *label363
  1035 label *label364
  1036 label *label365
-    * op add :compute:i :compute:i 1
+ 1037 op add :compute:i 54 1
  1038 label *label366
  1039 set :compute:x1 :compute:zx
  1040 op mul *tmp59 :compute:zx :compute:zx
 
  1050 label *label367
  1051 label *label368
  1052 label *label369
-    * op add :compute:i :compute:i 1
+ 1053 op add :compute:i 55 1
  1054 label *label370
  1055 set :compute:x1 :compute:zx
  1056 op mul *tmp59 :compute:zx :compute:zx
 
  1066 label *label371
  1067 label *label372
  1068 label *label373
-    * op add :compute:i :compute:i 1
+ 1069 op add :compute:i 56 1
  1070 label *label374
  1071 set :compute:x1 :compute:zx
  1072 op mul *tmp59 :compute:zx :compute:zx
 
  1082 label *label375
  1083 label *label376
  1084 label *label377
-    * op add :compute:i :compute:i 1
+ 1085 op add :compute:i 57 1
  1086 label *label378
  1087 set :compute:x1 :compute:zx
  1088 op mul *tmp59 :compute:zx :compute:zx
 
  1098 label *label379
  1099 label *label380
  1100 label *label381
-    * op add :compute:i :compute:i 1
+ 1101 op add :compute:i 58 1
  1102 label *label382
  1103 set :compute:x1 :compute:zx
  1104 op mul *tmp59 :compute:zx :compute:zx
 
  1114 label *label383
  1115 label *label384
  1116 label *label385
-    * op add :compute:i :compute:i 1
+ 1117 op add :compute:i 59 1
  1118 label *label386
  1119 set :compute:x1 :compute:zx
  1120 op mul *tmp59 :compute:zx :compute:zx
 
  1130 label *label387
  1131 label *label388
  1132 label *label389
-    * op add :compute:i :compute:i 1
+ 1133 op add :compute:i 60 1
  1134 label *label390
  1135 set :compute:x1 :compute:zx
  1136 op mul *tmp59 :compute:zx :compute:zx
 
  1146 label *label391
  1147 label *label392
  1148 label *label393
-    * op add :compute:i :compute:i 1
+ 1149 op add :compute:i 61 1
  1150 label *label394
  1151 set :compute:x1 :compute:zx
  1152 op mul *tmp59 :compute:zx :compute:zx
 
  1162 label *label395
  1163 label *label396
  1164 label *label397
-    * op add :compute:i :compute:i 1
+ 1165 op add :compute:i 62 1
  1166 label *label56
  1167 op mul *tmp69 .SMOOTH 63
  1168 jump *label59 greaterThanEq :compute:i *tmp69

Modifications by Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 (+2 instructions):
 
  1208 op add :lines :lines 1
  1209 jump *label106 lessThan :lines 176
  1210 label *label41
-    * setaddr :flushLocalBuffer*retaddr *label68 (h:*label68)
-    * call *label1 *invalid :flushLocalBuffer*retval (m:*label68) (h:*label68)
-    * label *label68
+ 1211 label *label398
+ 1212 label *label399
+ 1213 label *label400
+ 1214 sensor *tmp144 .display @enabled
+ 1215 jump *label399 equal *tmp144 false
+ 1216 label *label401
+ 1217 jump *label405 lessThanEq .localBuffer 4
+ 1218 label *label402
+ 1219 wait 0.0001
+ 1220 label *label403
+ 1221 sensor *tmp148 .display @bufferSize
+ 1222 jump *label402 greaterThan *tmp148 250
+ 1223 label *label404
+ 1224 label *label405
+ 1225 label *label406
+ 1226 drawflush .display
+ 1227 set .localBuffer 0
+ 1228 label *label407
  1229 label *label32
  1230 jump *label31 always
  1231 label *label33
 
  1280 read :drawPixel:color .memory :drawPixel:iterations
  1281 label *label71
  1282 jump *label81 lessThan .localBuffer 254
-    * setaddr :flushLocalBuffer*retaddr *label83 (h:*label83)
-    * call *label1 *invalid :flushLocalBuffer*retval (m:*label83) (h:*label83)
-    * label *label83
+ 1283 label *label408
+ 1284 label *label409
+ 1285 label *label410
+ 1286 sensor *tmp144 .display @enabled
+ 1287 jump *label409 equal *tmp144 false
+ 1288 label *label411
+ 1289 jump *label415 lessThanEq .localBuffer 4
+ 1290 label *label412
+ 1291 wait 0.0001
+ 1292 label *label413
+ 1293 sensor *tmp148 .display @bufferSize
+ 1294 jump *label412 greaterThan *tmp148 250
+ 1295 label *label414
+ 1296 label *label415
+ 1297 label *label416
+ 1298 drawflush .display
+ 1299 set .localBuffer 0
+ 1300 label *label417
  1301 label *label81
  1302 label *label82
  1303 draw col :drawPixel:color
 
  1323 label *label69
  1324 return :drawPixel*retaddr
  1325 end
-    * label *label1
-    * label *label89
-    * label *label90
-    * sensor *tmp144 .display @enabled
-    * jump *label89 equal *tmp144 false
-    * label *label91
-    * jump *label92 lessThanEq .localBuffer 4
-    * label *label94
-    * wait 0.0001
-    * label *label95
-    * sensor *tmp148 .display @bufferSize
-    * jump *label94 greaterThan *tmp148 250
-    * label *label96
-    * label *label92
-    * label *label93
-    * drawflush .display
-    * set .localBuffer 0
-    * label *label88
-    * return :flushLocalBuffer*retaddr
-    * end
  1326 label *label2
  1327 label *label98
  1328 jump *label100 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
  1224 label *label405
  1225 label *label406
  1226 drawflush .display
-    * set .localBuffer 0
  1227 label *label407
  1228 label *label32
  1229 jump *label31 always

Modifications by Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 (+9 instructions):
 
    77 set .localBuffer 0
    78 drawflush null
    79 set :setState:state 0
-    * setaddr :setState*retaddr *label37 (h:*label37)
    80 label *label34
-    * call *label2 *invalid :setState*retval (m:*label37) (h:*label37)
-    * label *label37
+   81 label *label418
+   82 label *label419
+   83 jump *label426 greaterThanEq .PROC_STATE_INDEX 512
+   84 label *label420
+   85 read *tmp152 .memory .PROC_ID_INDEX
+   86 jump *label421 notEqual *tmp152 .PROCESSOR_ID
+   87 write :setState:state .memory .PROC_STATE_INDEX
+   88 jump *label426 always
+   89 jump *label424 always
+   90 label *label421
+   91 read *tmp158 .memory .PROC_ID_INDEX
+   92 jump *label422 notEqual *tmp158 0
+   93 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+   94 write :setState:state .memory .PROC_STATE_INDEX
+   95 jump *label426 always
+   96 jump *label423 always
+   97 label *label422
+   98 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+   99 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  100 label *label423
+  101 label *label424
+  102 label *label425
+  103 jump *label420 lessThan .PROC_STATE_INDEX 512
+  104 label *label426
+  105 label *label427
   106 label *label35
   107 read *tmp0 .memory 64
   108 jump *label34 equal .start *tmp0
 
   112 read *tmp1 .memory 65
   113 set .stop *tmp1
   114 set :setState:state *tmp0
-    * setaddr :setState*retaddr *label38 (h:*label38)
-    * call *label2 *invalid :setState*retval (m:*label38) (h:*label38)
-    * label *label38
+  115 label *label428
+  116 label *label429
+  117 jump *label436 greaterThanEq .PROC_STATE_INDEX 512
+  118 label *label430
+  119 read *tmp152 .memory .PROC_ID_INDEX
+  120 jump *label431 notEqual *tmp152 .PROCESSOR_ID
+  121 write :setState:state .memory .PROC_STATE_INDEX
+  122 jump *label436 always
+  123 jump *label434 always
+  124 label *label431
+  125 read *tmp158 .memory .PROC_ID_INDEX
+  126 jump *label432 notEqual *tmp158 0
+  127 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  128 write :setState:state .memory .PROC_STATE_INDEX
+  129 jump *label436 always
+  130 jump *label433 always
+  131 label *label432
+  132 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  133 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  134 label *label433
+  135 label *label434
+  136 label *label435
+  137 jump *label430 lessThan .PROC_STATE_INDEX 512
+  138 label *label436
+  139 label *label437
   140 read .ZOOM .memory 68
   141 op div *tmp26 -88 .ZOOM
   142 read *tmp2 .memory 66
 
  1366 label *label69
  1367 return :drawPixel*retaddr
  1368 end
-    * label *label2
-    * label *label98
-    * jump *label100 greaterThanEq .PROC_STATE_INDEX 512
-    * label *label109
-    * read *tmp152 .memory .PROC_ID_INDEX
-    * jump *label101 notEqual *tmp152 .PROCESSOR_ID
-    * write :setState:state .memory .PROC_STATE_INDEX
-    * jump *label100 always
-    * jump *label102 always
-    * label *label101
-    * read *tmp158 .memory .PROC_ID_INDEX
-    * jump *label103 notEqual *tmp158 0
-    * write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState:state .memory .PROC_STATE_INDEX
-    * jump *label100 always
-    * jump *label104 always
-    * label *label103
-    * op add .PROC_ID_INDEX .PROC_ID_INDEX 2
-    * op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label104
-    * label *label102
-    * label *label99
-    * jump *label109 lessThan .PROC_STATE_INDEX 512
-    * label *label100
-    * label *label97
-    * return :setState*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    84 label *label420
    85 read *tmp152 .memory .PROC_ID_INDEX
    86 jump *label421 notEqual *tmp152 .PROCESSOR_ID
-    * write :setState:state .memory .PROC_STATE_INDEX
+   87 write 0 .memory .PROC_STATE_INDEX
    88 jump *label426 always
    89 jump *label424 always
    90 label *label421
    91 read *tmp158 .memory .PROC_ID_INDEX
    92 jump *label422 notEqual *tmp158 0
    93 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState:state .memory .PROC_STATE_INDEX
+   94 write 0 .memory .PROC_STATE_INDEX
    95 jump *label426 always
    96 jump *label423 always
    97 label *label422
 
   118 label *label430
   119 read *tmp152 .memory .PROC_ID_INDEX
   120 jump *label431 notEqual *tmp152 .PROCESSOR_ID
-    * write :setState:state .memory .PROC_STATE_INDEX
+  121 write *tmp0 .memory .PROC_STATE_INDEX
   122 jump *label436 always
   123 jump *label434 always
   124 label *label431
   125 read *tmp158 .memory .PROC_ID_INDEX
   126 jump *label432 notEqual *tmp158 0
   127 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState:state .memory .PROC_STATE_INDEX
+  128 write *tmp0 .memory .PROC_STATE_INDEX
   129 jump *label436 always
   130 jump *label433 always
   131 label *label432

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    76 label *label31
    77 set .localBuffer 0
    78 drawflush null
-    * set :setState:state 0
    79 label *label34
    80 label *label418
    81 label *label419
 
   110 set .start *tmp0
   111 read *tmp1 .memory 65
   112 set .stop *tmp1
-    * set :setState:state *tmp0
   113 label *label428
   114 label *label429
   115 jump *label436 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    49 print ":"
    50 print " "
    51 print .display
-    * jump *label124 equal true false
    52 op and :findLinkedBlocks:foundAll 1 .display
    53 label *label124
    54 label *label125
 
    60 print ":"
    61 print " "
    62 print .memory
-    * jump *label130 equal true false
    63 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    64 label *label130
    65 label *label131

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
  1215 label *label59
  1216 label *label60
  1217 set *tmp41 :compute:i
-    * jump *label47 always
  1218 label *label47
  1219 set :drawPixel:y :y
  1220 set :drawPixel:iterations *tmp41

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-2 instructions):
 
    25 label *label110
    26 jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
    27 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
+   28 set :findLinkedBlocks:message :findLinkedBlocks:message
    29 label *label111
    30 label *label112
    31 label *label113
 
    34 label *label116
    35 jump *label117 notEqual @memory-bank :findLinkedBlocks:type
    36 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
+   37 set :findLinkedBlocks:message :findLinkedBlocks:message
    38 label *label117
    39 label *label118
    40 label *label119
 
    53 label *label124
    54 label *label125
    55 label *label126
-    * set .display .display
    56 label *label129
    57 print "\n"
    58 print "Memory"
 
    63 label *label130
    64 label *label131
    65 label *label132
-    * set .memory .memory
    66 label *label26
    67 printflush :findLinkedBlocks:message
    68 label *label5
 
   208 label *label147
   209 label *label148
   210 label *label149
-    * op add :compute:i 0 1
+  211 set :compute:i 1
   212 label *label150
   213 set :compute:x1 :compute:zx
   214 op mul *tmp59 :compute:zx :compute:zx

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1 (-2 instructions):
 
    25 label *label110
    26 jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
    27 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    28 label *label111
    29 label *label112
    30 label *label113
 
    33 label *label116
    34 jump *label117 notEqual @memory-bank :findLinkedBlocks:type
    35 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    36 label *label117
    37 label *label118
    38 label *label119

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1:
 
    62 label *label131
    63 label *label132
    64 label *label26
-    * printflush :findLinkedBlocks:message
+   65 printflush null
    66 label *label5
    67 jump *label4 equal :findLinkedBlocks:foundAll false
    68 label *label6

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 2 (-1 instructions):
 
     2 set .PROC_ID_INDEX 334
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
-    * set :findLinkedBlocks:message null
     5 label *label4
     6 label *label136
     7 label *label137

Modifications by Iterated phase, If Expression Optimization, pass 3, iteration 1 (-2 instructions):
 
    22 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    23 set :findLinkedBlocks:variable .display
    24 label *label110
-    * jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label111
-    * label *label112
+   25 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    26 label *label113
    27 set .display :findLinkedBlocks:variable
    28 set :findLinkedBlocks:variable .memory
    29 label *label116
-    * jump *label117 notEqual @memory-bank :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label117
-    * label *label118
+   30 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    31 label *label119
    32 set .memory :findLinkedBlocks:variable
    33 label *label17

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 1:
 
    22 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    23 set :findLinkedBlocks:variable .display
    24 label *label110
-    * select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   25 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    26 label *label113
    27 set .display :findLinkedBlocks:variable
    28 set :findLinkedBlocks:variable .memory
    29 label *label116
-    * select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   30 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    31 label *label119
    32 set .memory :findLinkedBlocks:variable
    33 label *label17

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 2 (-2 instructions):
 
    20 print "\nFound: "
    21 print :findLinkedBlocks:block
    22 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:variable .display
    23 label *label110
    24 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    25 label *label113
    26 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:variable .memory
    27 label *label116
    28 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    29 label *label119

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
     5 label *label4
-    * label *label136
-    * label *label137
     6 set .display null
-    * label *label140
-    * label *label141
     7 set .memory null
-    * label *label9
     8 print "Mandelbrot Generator"
     9 set :findLinkedBlocks:n @links
-    * label *label12
    10 jump *label14 lessThanEq :findLinkedBlocks:n 0
    11 label *label105
    12 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
 
    14 print "\nFound: "
    15 print :findLinkedBlocks:block
    16 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * label *label110
    17 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
-    * label *label113
    18 set .display :findLinkedBlocks:variable
-    * label *label116
    19 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
-    * label *label119
    20 set .memory :findLinkedBlocks:variable
-    * label *label17
-    * label *label13
    21 jump *label105 greaterThan :findLinkedBlocks:n 0
    22 label *label14
-    * label *label123
    23 print "\n"
    24 print "Display"
    25 print ":"
    26 print " "
    27 print .display
    28 op and :findLinkedBlocks:foundAll 1 .display
-    * label *label124
-    * label *label125
-    * label *label126
-    * label *label129
    29 print "\n"
    30 print "Memory"
    31 print ":"
    32 print " "
    33 print .memory
    34 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
-    * label *label130
-    * label *label131
-    * label *label132
-    * label *label26
    35 printflush null
-    * label *label5
    36 jump *label4 equal :findLinkedBlocks:foundAll false
-    * label *label6
-    * label *label3
    37 label *label31
    38 set .localBuffer 0
    39 drawflush null
    40 label *label34
-    * label *label418
-    * label *label419
    41 jump *label426 greaterThanEq .PROC_STATE_INDEX 512
    42 label *label420
    43 read *tmp152 .memory .PROC_ID_INDEX
 
    57 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
    58 label *label423
    59 label *label424
-    * label *label425
    60 jump *label420 lessThan .PROC_STATE_INDEX 512
    61 label *label426
-    * label *label427
-    * label *label35
    62 read *tmp0 .memory 64
    63 jump *label34 equal .start *tmp0
-    * label *label36
    64 read *tmp0 .memory 64
    65 set .start *tmp0
    66 read *tmp1 .memory 65
    67 set .stop *tmp1
-    * label *label428
-    * label *label429
    68 jump *label436 greaterThanEq .PROC_STATE_INDEX 512
    69 label *label430
    70 read *tmp152 .memory .PROC_ID_INDEX
 
    84 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
    85 label *label433
    86 label *label434
-    * label *label435
    87 jump *label430 lessThan .PROC_STATE_INDEX 512
    88 label *label436
-    * label *label437
    89 read .ZOOM .memory 68
    90 op div *tmp26 -88 .ZOOM
    91 read *tmp2 .memory 66
 
   103 op rand *tmp31 0.1
   104 wait *tmp31
   105 set :lines 0
-    * label *label39
   106 label *label106
   107 op mul *tmp32 17 :line
   108 op mod :x *tmp32 176
 
   113 set :y 0
   114 set :drawPixel:x :x
   115 setaddr :drawPixel*retaddr *label61 (h:*label61)
-    * label *label44
   116 label *label107
   117 op div *tmp42 :x .ZOOM
   118 op add :compute:zx *tmp42 .OFFSET_X
 
   135 set *tmp41 63
   136 jump *label47 always
   137 label *label50
-    * label *label51
   138 op add *tmp55 :compute:zx 1
   139 op len *tmp56 *tmp55 :compute:zy
   140 jump *label52 greaterThan *tmp56 0.25
   141 set *tmp41 63
   142 jump *label47 always
   143 label *label52
-    * label *label53
   144 label *label49
   145 set :compute:i 0
-    * label *label145
-    * label *label146
   146 set :compute:x1 :compute:zx
   147 op mul *tmp59 :compute:zx :compute:zx
   148 op mul *tmp60 :compute:zy :compute:zy
 
   155 jump *label147 lessThan :compute:dist 64
   156 jump *label56 always
   157 label *label147
-    * label *label148
-    * label *label149
   158 set :compute:i 1
-    * label *label150
   159 set :compute:x1 :compute:zx
   160 op mul *tmp59 :compute:zx :compute:zx
   161 op mul *tmp60 :compute:zy :compute:zy
 
   168 jump *label151 lessThan :compute:dist 64
   169 jump *label56 always
   170 label *label151
-    * label *label152
-    * label *label153
   171 op add :compute:i 1 1
-    * label *label154
   172 set :compute:x1 :compute:zx
   173 op mul *tmp59 :compute:zx :compute:zx
   174 op mul *tmp60 :compute:zy :compute:zy
 
   181 jump *label155 lessThan :compute:dist 64
   182 jump *label56 always
   183 label *label155
-    * label *label156
-    * label *label157
   184 op add :compute:i 2 1
-    * label *label158
   185 set :compute:x1 :compute:zx
   186 op mul *tmp59 :compute:zx :compute:zx
   187 op mul *tmp60 :compute:zy :compute:zy
 
   194 jump *label159 lessThan :compute:dist 64
   195 jump *label56 always
   196 label *label159
-    * label *label160
-    * label *label161
   197 op add :compute:i 3 1
-    * label *label162
   198 set :compute:x1 :compute:zx
   199 op mul *tmp59 :compute:zx :compute:zx
   200 op mul *tmp60 :compute:zy :compute:zy
 
   207 jump *label163 lessThan :compute:dist 64
   208 jump *label56 always
   209 label *label163
-    * label *label164
-    * label *label165
   210 op add :compute:i 4 1
-    * label *label166
   211 set :compute:x1 :compute:zx
   212 op mul *tmp59 :compute:zx :compute:zx
   213 op mul *tmp60 :compute:zy :compute:zy
 
   220 jump *label167 lessThan :compute:dist 64
   221 jump *label56 always
   222 label *label167
-    * label *label168
-    * label *label169
   223 op add :compute:i 5 1
-    * label *label170
   224 set :compute:x1 :compute:zx
   225 op mul *tmp59 :compute:zx :compute:zx
   226 op mul *tmp60 :compute:zy :compute:zy
 
   233 jump *label171 lessThan :compute:dist 64
   234 jump *label56 always
   235 label *label171
-    * label *label172
-    * label *label173
   236 op add :compute:i 6 1
-    * label *label174
   237 set :compute:x1 :compute:zx
   238 op mul *tmp59 :compute:zx :compute:zx
   239 op mul *tmp60 :compute:zy :compute:zy
 
   246 jump *label175 lessThan :compute:dist 64
   247 jump *label56 always
   248 label *label175
-    * label *label176
-    * label *label177
   249 op add :compute:i 7 1
-    * label *label178
   250 set :compute:x1 :compute:zx
   251 op mul *tmp59 :compute:zx :compute:zx
   252 op mul *tmp60 :compute:zy :compute:zy
 
   259 jump *label179 lessThan :compute:dist 64
   260 jump *label56 always
   261 label *label179
-    * label *label180
-    * label *label181
   262 op add :compute:i 8 1
-    * label *label182
   263 set :compute:x1 :compute:zx
   264 op mul *tmp59 :compute:zx :compute:zx
   265 op mul *tmp60 :compute:zy :compute:zy
 
   272 jump *label183 lessThan :compute:dist 64
   273 jump *label56 always
   274 label *label183
-    * label *label184
-    * label *label185
   275 op add :compute:i 9 1
-    * label *label186
   276 set :compute:x1 :compute:zx
   277 op mul *tmp59 :compute:zx :compute:zx
   278 op mul *tmp60 :compute:zy :compute:zy
 
   285 jump *label187 lessThan :compute:dist 64
   286 jump *label56 always
   287 label *label187
-    * label *label188
-    * label *label189
   288 op add :compute:i 10 1
-    * label *label190
   289 set :compute:x1 :compute:zx
   290 op mul *tmp59 :compute:zx :compute:zx
   291 op mul *tmp60 :compute:zy :compute:zy
 
   298 jump *label191 lessThan :compute:dist 64
   299 jump *label56 always
   300 label *label191
-    * label *label192
-    * label *label193
   301 op add :compute:i 11 1
-    * label *label194
   302 set :compute:x1 :compute:zx
   303 op mul *tmp59 :compute:zx :compute:zx
   304 op mul *tmp60 :compute:zy :compute:zy
 
   311 jump *label195 lessThan :compute:dist 64
   312 jump *label56 always
   313 label *label195
-    * label *label196
-    * label *label197
   314 op add :compute:i 12 1
-    * label *label198
   315 set :compute:x1 :compute:zx
   316 op mul *tmp59 :compute:zx :compute:zx
   317 op mul *tmp60 :compute:zy :compute:zy
 
   324 jump *label199 lessThan :compute:dist 64
   325 jump *label56 always
   326 label *label199
-    * label *label200
-    * label *label201
   327 op add :compute:i 13 1
-    * label *label202
   328 set :compute:x1 :compute:zx
   329 op mul *tmp59 :compute:zx :compute:zx
   330 op mul *tmp60 :compute:zy :compute:zy
 
   337 jump *label203 lessThan :compute:dist 64
   338 jump *label56 always
   339 label *label203
-    * label *label204
-    * label *label205
   340 op add :compute:i 14 1
-    * label *label206
   341 set :compute:x1 :compute:zx
   342 op mul *tmp59 :compute:zx :compute:zx
   343 op mul *tmp60 :compute:zy :compute:zy
 
   350 jump *label207 lessThan :compute:dist 64
   351 jump *label56 always
   352 label *label207
-    * label *label208
-    * label *label209
   353 op add :compute:i 15 1
-    * label *label210
   354 set :compute:x1 :compute:zx
   355 op mul *tmp59 :compute:zx :compute:zx
   356 op mul *tmp60 :compute:zy :compute:zy
 
   363 jump *label211 lessThan :compute:dist 64
   364 jump *label56 always
   365 label *label211
-    * label *label212
-    * label *label213
   366 op add :compute:i 16 1
-    * label *label214
   367 set :compute:x1 :compute:zx
   368 op mul *tmp59 :compute:zx :compute:zx
   369 op mul *tmp60 :compute:zy :compute:zy
 
   376 jump *label215 lessThan :compute:dist 64
   377 jump *label56 always
   378 label *label215
-    * label *label216
-    * label *label217
   379 op add :compute:i 17 1
-    * label *label218
   380 set :compute:x1 :compute:zx
   381 op mul *tmp59 :compute:zx :compute:zx
   382 op mul *tmp60 :compute:zy :compute:zy
 
   389 jump *label219 lessThan :compute:dist 64
   390 jump *label56 always
   391 label *label219
-    * label *label220
-    * label *label221
   392 op add :compute:i 18 1
-    * label *label222
   393 set :compute:x1 :compute:zx
   394 op mul *tmp59 :compute:zx :compute:zx
   395 op mul *tmp60 :compute:zy :compute:zy
 
   402 jump *label223 lessThan :compute:dist 64
   403 jump *label56 always
   404 label *label223
-    * label *label224
-    * label *label225
   405 op add :compute:i 19 1
-    * label *label226
   406 set :compute:x1 :compute:zx
   407 op mul *tmp59 :compute:zx :compute:zx
   408 op mul *tmp60 :compute:zy :compute:zy
 
   415 jump *label227 lessThan :compute:dist 64
   416 jump *label56 always
   417 label *label227
-    * label *label228
-    * label *label229
   418 op add :compute:i 20 1
-    * label *label230
   419 set :compute:x1 :compute:zx
   420 op mul *tmp59 :compute:zx :compute:zx
   421 op mul *tmp60 :compute:zy :compute:zy
 
   428 jump *label231 lessThan :compute:dist 64
   429 jump *label56 always
   430 label *label231
-    * label *label232
-    * label *label233
   431 op add :compute:i 21 1
-    * label *label234
   432 set :compute:x1 :compute:zx
   433 op mul *tmp59 :compute:zx :compute:zx
   434 op mul *tmp60 :compute:zy :compute:zy
 
   441 jump *label235 lessThan :compute:dist 64
   442 jump *label56 always
   443 label *label235
-    * label *label236
-    * label *label237
   444 op add :compute:i 22 1
-    * label *label238
   445 set :compute:x1 :compute:zx
   446 op mul *tmp59 :compute:zx :compute:zx
   447 op mul *tmp60 :compute:zy :compute:zy
 
   454 jump *label239 lessThan :compute:dist 64
   455 jump *label56 always
   456 label *label239
-    * label *label240
-    * label *label241
   457 op add :compute:i 23 1
-    * label *label242
   458 set :compute:x1 :compute:zx
   459 op mul *tmp59 :compute:zx :compute:zx
   460 op mul *tmp60 :compute:zy :compute:zy
 
   467 jump *label243 lessThan :compute:dist 64
   468 jump *label56 always
   469 label *label243
-    * label *label244
-    * label *label245
   470 op add :compute:i 24 1
-    * label *label246
   471 set :compute:x1 :compute:zx
   472 op mul *tmp59 :compute:zx :compute:zx
   473 op mul *tmp60 :compute:zy :compute:zy
 
   480 jump *label247 lessThan :compute:dist 64
   481 jump *label56 always
   482 label *label247
-    * label *label248
-    * label *label249
   483 op add :compute:i 25 1
-    * label *label250
   484 set :compute:x1 :compute:zx
   485 op mul *tmp59 :compute:zx :compute:zx
   486 op mul *tmp60 :compute:zy :compute:zy
 
   493 jump *label251 lessThan :compute:dist 64
   494 jump *label56 always
   495 label *label251
-    * label *label252
-    * label *label253
   496 op add :compute:i 26 1
-    * label *label254
   497 set :compute:x1 :compute:zx
   498 op mul *tmp59 :compute:zx :compute:zx
   499 op mul *tmp60 :compute:zy :compute:zy
 
   506 jump *label255 lessThan :compute:dist 64
   507 jump *label56 always
   508 label *label255
-    * label *label256
-    * label *label257
   509 op add :compute:i 27 1
-    * label *label258
   510 set :compute:x1 :compute:zx
   511 op mul *tmp59 :compute:zx :compute:zx
   512 op mul *tmp60 :compute:zy :compute:zy
 
   519 jump *label259 lessThan :compute:dist 64
   520 jump *label56 always
   521 label *label259
-    * label *label260
-    * label *label261
   522 op add :compute:i 28 1
-    * label *label262
   523 set :compute:x1 :compute:zx
   524 op mul *tmp59 :compute:zx :compute:zx
   525 op mul *tmp60 :compute:zy :compute:zy
 
   532 jump *label263 lessThan :compute:dist 64
   533 jump *label56 always
   534 label *label263
-    * label *label264
-    * label *label265
   535 op add :compute:i 29 1
-    * label *label266
   536 set :compute:x1 :compute:zx
   537 op mul *tmp59 :compute:zx :compute:zx
   538 op mul *tmp60 :compute:zy :compute:zy
 
   545 jump *label267 lessThan :compute:dist 64
   546 jump *label56 always
   547 label *label267
-    * label *label268
-    * label *label269
   548 op add :compute:i 30 1
-    * label *label270
   549 set :compute:x1 :compute:zx
   550 op mul *tmp59 :compute:zx :compute:zx
   551 op mul *tmp60 :compute:zy :compute:zy
 
   558 jump *label271 lessThan :compute:dist 64
   559 jump *label56 always
   560 label *label271
-    * label *label272
-    * label *label273
   561 op add :compute:i 31 1
-    * label *label274
   562 set :compute:x1 :compute:zx
   563 op mul *tmp59 :compute:zx :compute:zx
   564 op mul *tmp60 :compute:zy :compute:zy
 
   571 jump *label275 lessThan :compute:dist 64
   572 jump *label56 always
   573 label *label275
-    * label *label276
-    * label *label277
   574 op add :compute:i 32 1
-    * label *label278
   575 set :compute:x1 :compute:zx
   576 op mul *tmp59 :compute:zx :compute:zx
   577 op mul *tmp60 :compute:zy :compute:zy
 
   584 jump *label279 lessThan :compute:dist 64
   585 jump *label56 always
   586 label *label279
-    * label *label280
-    * label *label281
   587 op add :compute:i 33 1
-    * label *label282
   588 set :compute:x1 :compute:zx
   589 op mul *tmp59 :compute:zx :compute:zx
   590 op mul *tmp60 :compute:zy :compute:zy
 
   597 jump *label283 lessThan :compute:dist 64
   598 jump *label56 always
   599 label *label283
-    * label *label284
-    * label *label285
   600 op add :compute:i 34 1
-    * label *label286
   601 set :compute:x1 :compute:zx
   602 op mul *tmp59 :compute:zx :compute:zx
   603 op mul *tmp60 :compute:zy :compute:zy
 
   610 jump *label287 lessThan :compute:dist 64
   611 jump *label56 always
   612 label *label287
-    * label *label288
-    * label *label289
   613 op add :compute:i 35 1
-    * label *label290
   614 set :compute:x1 :compute:zx
   615 op mul *tmp59 :compute:zx :compute:zx
   616 op mul *tmp60 :compute:zy :compute:zy
 
   623 jump *label291 lessThan :compute:dist 64
   624 jump *label56 always
   625 label *label291
-    * label *label292
-    * label *label293
   626 op add :compute:i 36 1
-    * label *label294
   627 set :compute:x1 :compute:zx
   628 op mul *tmp59 :compute:zx :compute:zx
   629 op mul *tmp60 :compute:zy :compute:zy
 
   636 jump *label295 lessThan :compute:dist 64
   637 jump *label56 always
   638 label *label295
-    * label *label296
-    * label *label297
   639 op add :compute:i 37 1
-    * label *label298
   640 set :compute:x1 :compute:zx
   641 op mul *tmp59 :compute:zx :compute:zx
   642 op mul *tmp60 :compute:zy :compute:zy
 
   649 jump *label299 lessThan :compute:dist 64
   650 jump *label56 always
   651 label *label299
-    * label *label300
-    * label *label301
   652 op add :compute:i 38 1
-    * label *label302
   653 set :compute:x1 :compute:zx
   654 op mul *tmp59 :compute:zx :compute:zx
   655 op mul *tmp60 :compute:zy :compute:zy
 
   662 jump *label303 lessThan :compute:dist 64
   663 jump *label56 always
   664 label *label303
-    * label *label304
-    * label *label305
   665 op add :compute:i 39 1
-    * label *label306
   666 set :compute:x1 :compute:zx
   667 op mul *tmp59 :compute:zx :compute:zx
   668 op mul *tmp60 :compute:zy :compute:zy
 
   675 jump *label307 lessThan :compute:dist 64
   676 jump *label56 always
   677 label *label307
-    * label *label308
-    * label *label309
   678 op add :compute:i 40 1
-    * label *label310
   679 set :compute:x1 :compute:zx
   680 op mul *tmp59 :compute:zx :compute:zx
   681 op mul *tmp60 :compute:zy :compute:zy
 
   688 jump *label311 lessThan :compute:dist 64
   689 jump *label56 always
   690 label *label311
-    * label *label312
-    * label *label313
   691 op add :compute:i 41 1
-    * label *label314
   692 set :compute:x1 :compute:zx
   693 op mul *tmp59 :compute:zx :compute:zx
   694 op mul *tmp60 :compute:zy :compute:zy
 
   701 jump *label315 lessThan :compute:dist 64
   702 jump *label56 always
   703 label *label315
-    * label *label316
-    * label *label317
   704 op add :compute:i 42 1
-    * label *label318
   705 set :compute:x1 :compute:zx
   706 op mul *tmp59 :compute:zx :compute:zx
   707 op mul *tmp60 :compute:zy :compute:zy
 
   714 jump *label319 lessThan :compute:dist 64
   715 jump *label56 always
   716 label *label319
-    * label *label320
-    * label *label321
   717 op add :compute:i 43 1
-    * label *label322
   718 set :compute:x1 :compute:zx
   719 op mul *tmp59 :compute:zx :compute:zx
   720 op mul *tmp60 :compute:zy :compute:zy
 
   727 jump *label323 lessThan :compute:dist 64
   728 jump *label56 always
   729 label *label323
-    * label *label324
-    * label *label325
   730 op add :compute:i 44 1
-    * label *label326
   731 set :compute:x1 :compute:zx
   732 op mul *tmp59 :compute:zx :compute:zx
   733 op mul *tmp60 :compute:zy :compute:zy
 
   740 jump *label327 lessThan :compute:dist 64
   741 jump *label56 always
   742 label *label327
-    * label *label328
-    * label *label329
   743 op add :compute:i 45 1
-    * label *label330
   744 set :compute:x1 :compute:zx
   745 op mul *tmp59 :compute:zx :compute:zx
   746 op mul *tmp60 :compute:zy :compute:zy
 
   753 jump *label331 lessThan :compute:dist 64
   754 jump *label56 always
   755 label *label331
-    * label *label332
-    * label *label333
   756 op add :compute:i 46 1
-    * label *label334
   757 set :compute:x1 :compute:zx
   758 op mul *tmp59 :compute:zx :compute:zx
   759 op mul *tmp60 :compute:zy :compute:zy
 
   766 jump *label335 lessThan :compute:dist 64
   767 jump *label56 always
   768 label *label335
-    * label *label336
-    * label *label337
   769 op add :compute:i 47 1
-    * label *label338
   770 set :compute:x1 :compute:zx
   771 op mul *tmp59 :compute:zx :compute:zx
   772 op mul *tmp60 :compute:zy :compute:zy
 
   779 jump *label339 lessThan :compute:dist 64
   780 jump *label56 always
   781 label *label339
-    * label *label340
-    * label *label341
   782 op add :compute:i 48 1
-    * label *label342
   783 set :compute:x1 :compute:zx
   784 op mul *tmp59 :compute:zx :compute:zx
   785 op mul *tmp60 :compute:zy :compute:zy
 
   792 jump *label343 lessThan :compute:dist 64
   793 jump *label56 always
   794 label *label343
-    * label *label344
-    * label *label345
   795 op add :compute:i 49 1
-    * label *label346
   796 set :compute:x1 :compute:zx
   797 op mul *tmp59 :compute:zx :compute:zx
   798 op mul *tmp60 :compute:zy :compute:zy
 
   805 jump *label347 lessThan :compute:dist 64
   806 jump *label56 always
   807 label *label347
-    * label *label348
-    * label *label349
   808 op add :compute:i 50 1
-    * label *label350
   809 set :compute:x1 :compute:zx
   810 op mul *tmp59 :compute:zx :compute:zx
   811 op mul *tmp60 :compute:zy :compute:zy
 
   818 jump *label351 lessThan :compute:dist 64
   819 jump *label56 always
   820 label *label351
-    * label *label352
-    * label *label353
   821 op add :compute:i 51 1
-    * label *label354
   822 set :compute:x1 :compute:zx
   823 op mul *tmp59 :compute:zx :compute:zx
   824 op mul *tmp60 :compute:zy :compute:zy
 
   831 jump *label355 lessThan :compute:dist 64
   832 jump *label56 always
   833 label *label355
-    * label *label356
-    * label *label357
   834 op add :compute:i 52 1
-    * label *label358
   835 set :compute:x1 :compute:zx
   836 op mul *tmp59 :compute:zx :compute:zx
   837 op mul *tmp60 :compute:zy :compute:zy
 
   844 jump *label359 lessThan :compute:dist 64
   845 jump *label56 always
   846 label *label359
-    * label *label360
-    * label *label361
   847 op add :compute:i 53 1
-    * label *label362
   848 set :compute:x1 :compute:zx
   849 op mul *tmp59 :compute:zx :compute:zx
   850 op mul *tmp60 :compute:zy :compute:zy
 
   857 jump *label363 lessThan :compute:dist 64
   858 jump *label56 always
   859 label *label363
-    * label *label364
-    * label *label365
   860 op add :compute:i 54 1
-    * label *label366
   861 set :compute:x1 :compute:zx
   862 op mul *tmp59 :compute:zx :compute:zx
   863 op mul *tmp60 :compute:zy :compute:zy
 
   870 jump *label367 lessThan :compute:dist 64
   871 jump *label56 always
   872 label *label367
-    * label *label368
-    * label *label369
   873 op add :compute:i 55 1
-    * label *label370
   874 set :compute:x1 :compute:zx
   875 op mul *tmp59 :compute:zx :compute:zx
   876 op mul *tmp60 :compute:zy :compute:zy
 
   883 jump *label371 lessThan :compute:dist 64
   884 jump *label56 always
   885 label *label371
-    * label *label372
-    * label *label373
   886 op add :compute:i 56 1
-    * label *label374
   887 set :compute:x1 :compute:zx
   888 op mul *tmp59 :compute:zx :compute:zx
   889 op mul *tmp60 :compute:zy :compute:zy
 
   896 jump *label375 lessThan :compute:dist 64
   897 jump *label56 always
   898 label *label375
-    * label *label376
-    * label *label377
   899 op add :compute:i 57 1
-    * label *label378
   900 set :compute:x1 :compute:zx
   901 op mul *tmp59 :compute:zx :compute:zx
   902 op mul *tmp60 :compute:zy :compute:zy
 
   909 jump *label379 lessThan :compute:dist 64
   910 jump *label56 always
   911 label *label379
-    * label *label380
-    * label *label381
   912 op add :compute:i 58 1
-    * label *label382
   913 set :compute:x1 :compute:zx
   914 op mul *tmp59 :compute:zx :compute:zx
   915 op mul *tmp60 :compute:zy :compute:zy
 
   922 jump *label383 lessThan :compute:dist 64
   923 jump *label56 always
   924 label *label383
-    * label *label384
-    * label *label385
   925 op add :compute:i 59 1
-    * label *label386
   926 set :compute:x1 :compute:zx
   927 op mul *tmp59 :compute:zx :compute:zx
   928 op mul *tmp60 :compute:zy :compute:zy
 
   935 jump *label387 lessThan :compute:dist 64
   936 jump *label56 always
   937 label *label387
-    * label *label388
-    * label *label389
   938 op add :compute:i 60 1
-    * label *label390
   939 set :compute:x1 :compute:zx
   940 op mul *tmp59 :compute:zx :compute:zx
   941 op mul *tmp60 :compute:zy :compute:zy
 
   948 jump *label391 lessThan :compute:dist 64
   949 jump *label56 always
   950 label *label391
-    * label *label392
-    * label *label393
   951 op add :compute:i 61 1
-    * label *label394
   952 set :compute:x1 :compute:zx
   953 op mul *tmp59 :compute:zx :compute:zx
   954 op mul *tmp60 :compute:zy :compute:zy
 
   961 jump *label395 lessThan :compute:dist 64
   962 jump *label56 always
   963 label *label395
-    * label *label396
-    * label *label397
   964 op add :compute:i 62 1
   965 label *label56
   966 op mul *tmp69 .SMOOTH 63
 
   972 op sub :compute:correction 4 *tmp75
   973 op add :compute:i :compute:i :compute:correction
   974 label *label59
-    * label *label60
   975 set *tmp41 :compute:i
   976 label *label47
   977 set :drawPixel:y :y
 
   982 jump *label62 equal *tmp78 .PROCESSOR_ID
   983 jump *label46 always
   984 label *label62
-    * label *label63
   985 read *tmp1 .memory 65
   986 jump *label64 equal .stop *tmp1
   987 jump *label32 always
   988 label *label64
-    * label *label65
-    * label *label45
   989 op add :y :y 1
   990 jump *label107 lessThan :y 176
   991 label *label46
   992 label *label42
-    * label *label43
   993 op add :line :line :increment
   994 jump *label66 lessThanEq :line 176
   995 op div :next_increment :next_increment 2
   996 set :increment :next_increment
   997 op div :line :next_increment 2
   998 label *label66
-    * label *label67
-    * label *label40
   999 op add :lines :lines 1
  1000 jump *label106 lessThan :lines 176
-    * label *label41
-    * label *label398
  1001 label *label399
-    * label *label400
  1002 sensor *tmp144 .display @enabled
  1003 jump *label399 equal *tmp144 false
-    * label *label401
  1004 jump *label405 lessThanEq .localBuffer 4
  1005 label *label402
  1006 wait 0.0001
-    * label *label403
  1007 sensor *tmp148 .display @bufferSize
  1008 jump *label402 greaterThan *tmp148 250
-    * label *label404
  1009 label *label405
-    * label *label406
  1010 drawflush .display
-    * label *label407
  1011 label *label32
  1012 jump *label31 always
-    * label *label33
  1013 end
  1014 label *label0
  1015 jump *label70 equal .SMOOTH false
  1016 set :drawPixel:color %[black]
  1017 jump *label73 equal :drawPixel:iterations 63
-    * label *label72
  1018 jump *label75 notEqual .PALETTE 2
-    * label *label76
  1019 op sub *tmp91 32 :drawPixel:iterations
  1020 op abs *tmp92 *tmp91
  1021 op div *tmp94 *tmp92 36.42857142857143
 
  1030 jump *label74 always
  1031 label *label75
  1032 jump *label77 notEqual .PALETTE 3
-    * label *label78
  1033 op div *tmp108 :drawPixel:iterations 0.175
  1034 op sin :drawPixel:r *tmp108
  1035 op cos :drawPixel:g *tmp108
 
  1041 jump *label74 always
  1042 label *label77
  1043 jump *label79 notEqual .PALETTE 4
-    * label *label80
  1044 op div :drawPixel:r :drawPixel:iterations 63.75
  1045 op div *tmp122 :drawPixel:iterations 170
  1046 op add :drawPixel:g 96 *tmp122
 
  1057 read :drawPixel:color .memory :drawPixel:iterations
  1058 label *label71
  1059 jump *label81 lessThan .localBuffer 254
-    * label *label408
  1060 label *label409
-    * label *label410
  1061 sensor *tmp144 .display @enabled
  1062 jump *label409 equal *tmp144 false
-    * label *label411
  1063 jump *label415 lessThanEq .localBuffer 4
  1064 label *label412
  1065 wait 0.0001
-    * label *label413
  1066 sensor *tmp148 .display @bufferSize
  1067 jump *label412 greaterThan *tmp148 250
-    * label *label414
  1068 label *label415
-    * label *label416
  1069 drawflush .display
  1070 set .localBuffer 0
-    * label *label417
  1071 label *label81
-    * label *label82
  1072 draw col :drawPixel:color
  1073 draw rect :drawPixel:x :drawPixel:y 1 1
  1074 op add .localBuffer .localBuffer 2
 
  1087 drawflush .display
  1088 set .localBuffer 0
  1089 label *label86
-    * label *label87
  1090 label *label85
-    * label *label69
  1091 return :drawPixel*retaddr
  1092 end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-65 instructions):
 
   152 op mul *tmp64 *tmp63 :compute:zy
   153 op add :compute:zy *tmp64 :compute:cy
   154 op len :compute:dist :compute:zx :compute:zy
-    * jump *label147 lessThan :compute:dist 64
-    * jump *label56 always
+  155 jump *label56 greaterThanEq :compute:dist 64
   156 label *label147
   157 set :compute:i 1
   158 set :compute:x1 :compute:zx
 
   164 op mul *tmp64 *tmp63 :compute:zy
   165 op add :compute:zy *tmp64 :compute:cy
   166 op len :compute:dist :compute:zx :compute:zy
-    * jump *label151 lessThan :compute:dist 64
-    * jump *label56 always
+  167 jump *label56 greaterThanEq :compute:dist 64
   168 label *label151
   169 op add :compute:i 1 1
   170 set :compute:x1 :compute:zx
 
   176 op mul *tmp64 *tmp63 :compute:zy
   177 op add :compute:zy *tmp64 :compute:cy
   178 op len :compute:dist :compute:zx :compute:zy
-    * jump *label155 lessThan :compute:dist 64
-    * jump *label56 always
+  179 jump *label56 greaterThanEq :compute:dist 64
   180 label *label155
   181 op add :compute:i 2 1
   182 set :compute:x1 :compute:zx
 
   188 op mul *tmp64 *tmp63 :compute:zy
   189 op add :compute:zy *tmp64 :compute:cy
   190 op len :compute:dist :compute:zx :compute:zy
-    * jump *label159 lessThan :compute:dist 64
-    * jump *label56 always
+  191 jump *label56 greaterThanEq :compute:dist 64
   192 label *label159
   193 op add :compute:i 3 1
   194 set :compute:x1 :compute:zx
 
   200 op mul *tmp64 *tmp63 :compute:zy
   201 op add :compute:zy *tmp64 :compute:cy
   202 op len :compute:dist :compute:zx :compute:zy
-    * jump *label163 lessThan :compute:dist 64
-    * jump *label56 always
+  203 jump *label56 greaterThanEq :compute:dist 64
   204 label *label163
   205 op add :compute:i 4 1
   206 set :compute:x1 :compute:zx
 
   212 op mul *tmp64 *tmp63 :compute:zy
   213 op add :compute:zy *tmp64 :compute:cy
   214 op len :compute:dist :compute:zx :compute:zy
-    * jump *label167 lessThan :compute:dist 64
-    * jump *label56 always
+  215 jump *label56 greaterThanEq :compute:dist 64
   216 label *label167
   217 op add :compute:i 5 1
   218 set :compute:x1 :compute:zx
 
   224 op mul *tmp64 *tmp63 :compute:zy
   225 op add :compute:zy *tmp64 :compute:cy
   226 op len :compute:dist :compute:zx :compute:zy
-    * jump *label171 lessThan :compute:dist 64
-    * jump *label56 always
+  227 jump *label56 greaterThanEq :compute:dist 64
   228 label *label171
   229 op add :compute:i 6 1
   230 set :compute:x1 :compute:zx
 
   236 op mul *tmp64 *tmp63 :compute:zy
   237 op add :compute:zy *tmp64 :compute:cy
   238 op len :compute:dist :compute:zx :compute:zy
-    * jump *label175 lessThan :compute:dist 64
-    * jump *label56 always
+  239 jump *label56 greaterThanEq :compute:dist 64
   240 label *label175
   241 op add :compute:i 7 1
   242 set :compute:x1 :compute:zx
 
   248 op mul *tmp64 *tmp63 :compute:zy
   249 op add :compute:zy *tmp64 :compute:cy
   250 op len :compute:dist :compute:zx :compute:zy
-    * jump *label179 lessThan :compute:dist 64
-    * jump *label56 always
+  251 jump *label56 greaterThanEq :compute:dist 64
   252 label *label179
   253 op add :compute:i 8 1
   254 set :compute:x1 :compute:zx
 
   260 op mul *tmp64 *tmp63 :compute:zy
   261 op add :compute:zy *tmp64 :compute:cy
   262 op len :compute:dist :compute:zx :compute:zy
-    * jump *label183 lessThan :compute:dist 64
-    * jump *label56 always
+  263 jump *label56 greaterThanEq :compute:dist 64
   264 label *label183
   265 op add :compute:i 9 1
   266 set :compute:x1 :compute:zx
 
   272 op mul *tmp64 *tmp63 :compute:zy
   273 op add :compute:zy *tmp64 :compute:cy
   274 op len :compute:dist :compute:zx :compute:zy
-    * jump *label187 lessThan :compute:dist 64
-    * jump *label56 always
+  275 jump *label56 greaterThanEq :compute:dist 64
   276 label *label187
   277 op add :compute:i 10 1
   278 set :compute:x1 :compute:zx
 
   284 op mul *tmp64 *tmp63 :compute:zy
   285 op add :compute:zy *tmp64 :compute:cy
   286 op len :compute:dist :compute:zx :compute:zy
-    * jump *label191 lessThan :compute:dist 64
-    * jump *label56 always
+  287 jump *label56 greaterThanEq :compute:dist 64
   288 label *label191
   289 op add :compute:i 11 1
   290 set :compute:x1 :compute:zx
 
   296 op mul *tmp64 *tmp63 :compute:zy
   297 op add :compute:zy *tmp64 :compute:cy
   298 op len :compute:dist :compute:zx :compute:zy
-    * jump *label195 lessThan :compute:dist 64
-    * jump *label56 always
+  299 jump *label56 greaterThanEq :compute:dist 64
   300 label *label195
   301 op add :compute:i 12 1
   302 set :compute:x1 :compute:zx
 
   308 op mul *tmp64 *tmp63 :compute:zy
   309 op add :compute:zy *tmp64 :compute:cy
   310 op len :compute:dist :compute:zx :compute:zy
-    * jump *label199 lessThan :compute:dist 64
-    * jump *label56 always
+  311 jump *label56 greaterThanEq :compute:dist 64
   312 label *label199
   313 op add :compute:i 13 1
   314 set :compute:x1 :compute:zx
 
   320 op mul *tmp64 *tmp63 :compute:zy
   321 op add :compute:zy *tmp64 :compute:cy
   322 op len :compute:dist :compute:zx :compute:zy
-    * jump *label203 lessThan :compute:dist 64
-    * jump *label56 always
+  323 jump *label56 greaterThanEq :compute:dist 64
   324 label *label203
   325 op add :compute:i 14 1
   326 set :compute:x1 :compute:zx
 
   332 op mul *tmp64 *tmp63 :compute:zy
   333 op add :compute:zy *tmp64 :compute:cy
   334 op len :compute:dist :compute:zx :compute:zy
-    * jump *label207 lessThan :compute:dist 64
-    * jump *label56 always
+  335 jump *label56 greaterThanEq :compute:dist 64
   336 label *label207
   337 op add :compute:i 15 1
   338 set :compute:x1 :compute:zx
 
   344 op mul *tmp64 *tmp63 :compute:zy
   345 op add :compute:zy *tmp64 :compute:cy
   346 op len :compute:dist :compute:zx :compute:zy
-    * jump *label211 lessThan :compute:dist 64
-    * jump *label56 always
+  347 jump *label56 greaterThanEq :compute:dist 64
   348 label *label211
   349 op add :compute:i 16 1
   350 set :compute:x1 :compute:zx
 
   356 op mul *tmp64 *tmp63 :compute:zy
   357 op add :compute:zy *tmp64 :compute:cy
   358 op len :compute:dist :compute:zx :compute:zy
-    * jump *label215 lessThan :compute:dist 64
-    * jump *label56 always
+  359 jump *label56 greaterThanEq :compute:dist 64
   360 label *label215
   361 op add :compute:i 17 1
   362 set :compute:x1 :compute:zx
 
   368 op mul *tmp64 *tmp63 :compute:zy
   369 op add :compute:zy *tmp64 :compute:cy
   370 op len :compute:dist :compute:zx :compute:zy
-    * jump *label219 lessThan :compute:dist 64
-    * jump *label56 always
+  371 jump *label56 greaterThanEq :compute:dist 64
   372 label *label219
   373 op add :compute:i 18 1
   374 set :compute:x1 :compute:zx
 
   380 op mul *tmp64 *tmp63 :compute:zy
   381 op add :compute:zy *tmp64 :compute:cy
   382 op len :compute:dist :compute:zx :compute:zy
-    * jump *label223 lessThan :compute:dist 64
-    * jump *label56 always
+  383 jump *label56 greaterThanEq :compute:dist 64
   384 label *label223
   385 op add :compute:i 19 1
   386 set :compute:x1 :compute:zx
 
   392 op mul *tmp64 *tmp63 :compute:zy
   393 op add :compute:zy *tmp64 :compute:cy
   394 op len :compute:dist :compute:zx :compute:zy
-    * jump *label227 lessThan :compute:dist 64
-    * jump *label56 always
+  395 jump *label56 greaterThanEq :compute:dist 64
   396 label *label227
   397 op add :compute:i 20 1
   398 set :compute:x1 :compute:zx
 
   404 op mul *tmp64 *tmp63 :compute:zy
   405 op add :compute:zy *tmp64 :compute:cy
   406 op len :compute:dist :compute:zx :compute:zy
-    * jump *label231 lessThan :compute:dist 64
-    * jump *label56 always
+  407 jump *label56 greaterThanEq :compute:dist 64
   408 label *label231
   409 op add :compute:i 21 1
   410 set :compute:x1 :compute:zx
 
   416 op mul *tmp64 *tmp63 :compute:zy
   417 op add :compute:zy *tmp64 :compute:cy
   418 op len :compute:dist :compute:zx :compute:zy
-    * jump *label235 lessThan :compute:dist 64
-    * jump *label56 always
+  419 jump *label56 greaterThanEq :compute:dist 64
   420 label *label235
   421 op add :compute:i 22 1
   422 set :compute:x1 :compute:zx
 
   428 op mul *tmp64 *tmp63 :compute:zy
   429 op add :compute:zy *tmp64 :compute:cy
   430 op len :compute:dist :compute:zx :compute:zy
-    * jump *label239 lessThan :compute:dist 64
-    * jump *label56 always
+  431 jump *label56 greaterThanEq :compute:dist 64
   432 label *label239
   433 op add :compute:i 23 1
   434 set :compute:x1 :compute:zx
 
   440 op mul *tmp64 *tmp63 :compute:zy
   441 op add :compute:zy *tmp64 :compute:cy
   442 op len :compute:dist :compute:zx :compute:zy
-    * jump *label243 lessThan :compute:dist 64
-    * jump *label56 always
+  443 jump *label56 greaterThanEq :compute:dist 64
   444 label *label243
   445 op add :compute:i 24 1
   446 set :compute:x1 :compute:zx
 
   452 op mul *tmp64 *tmp63 :compute:zy
   453 op add :compute:zy *tmp64 :compute:cy
   454 op len :compute:dist :compute:zx :compute:zy
-    * jump *label247 lessThan :compute:dist 64
-    * jump *label56 always
+  455 jump *label56 greaterThanEq :compute:dist 64
   456 label *label247
   457 op add :compute:i 25 1
   458 set :compute:x1 :compute:zx
 
   464 op mul *tmp64 *tmp63 :compute:zy
   465 op add :compute:zy *tmp64 :compute:cy
   466 op len :compute:dist :compute:zx :compute:zy
-    * jump *label251 lessThan :compute:dist 64
-    * jump *label56 always
+  467 jump *label56 greaterThanEq :compute:dist 64
   468 label *label251
   469 op add :compute:i 26 1
   470 set :compute:x1 :compute:zx
 
   476 op mul *tmp64 *tmp63 :compute:zy
   477 op add :compute:zy *tmp64 :compute:cy
   478 op len :compute:dist :compute:zx :compute:zy
-    * jump *label255 lessThan :compute:dist 64
-    * jump *label56 always
+  479 jump *label56 greaterThanEq :compute:dist 64
   480 label *label255
   481 op add :compute:i 27 1
   482 set :compute:x1 :compute:zx
 
   488 op mul *tmp64 *tmp63 :compute:zy
   489 op add :compute:zy *tmp64 :compute:cy
   490 op len :compute:dist :compute:zx :compute:zy
-    * jump *label259 lessThan :compute:dist 64
-    * jump *label56 always
+  491 jump *label56 greaterThanEq :compute:dist 64
   492 label *label259
   493 op add :compute:i 28 1
   494 set :compute:x1 :compute:zx
 
   500 op mul *tmp64 *tmp63 :compute:zy
   501 op add :compute:zy *tmp64 :compute:cy
   502 op len :compute:dist :compute:zx :compute:zy
-    * jump *label263 lessThan :compute:dist 64
-    * jump *label56 always
+  503 jump *label56 greaterThanEq :compute:dist 64
   504 label *label263
   505 op add :compute:i 29 1
   506 set :compute:x1 :compute:zx
 
   512 op mul *tmp64 *tmp63 :compute:zy
   513 op add :compute:zy *tmp64 :compute:cy
   514 op len :compute:dist :compute:zx :compute:zy
-    * jump *label267 lessThan :compute:dist 64
-    * jump *label56 always
+  515 jump *label56 greaterThanEq :compute:dist 64
   516 label *label267
   517 op add :compute:i 30 1
   518 set :compute:x1 :compute:zx
 
   524 op mul *tmp64 *tmp63 :compute:zy
   525 op add :compute:zy *tmp64 :compute:cy
   526 op len :compute:dist :compute:zx :compute:zy
-    * jump *label271 lessThan :compute:dist 64
-    * jump *label56 always
+  527 jump *label56 greaterThanEq :compute:dist 64
   528 label *label271
   529 op add :compute:i 31 1
   530 set :compute:x1 :compute:zx
 
   536 op mul *tmp64 *tmp63 :compute:zy
   537 op add :compute:zy *tmp64 :compute:cy
   538 op len :compute:dist :compute:zx :compute:zy
-    * jump *label275 lessThan :compute:dist 64
-    * jump *label56 always
+  539 jump *label56 greaterThanEq :compute:dist 64
   540 label *label275
   541 op add :compute:i 32 1
   542 set :compute:x1 :compute:zx
 
   548 op mul *tmp64 *tmp63 :compute:zy
   549 op add :compute:zy *tmp64 :compute:cy
   550 op len :compute:dist :compute:zx :compute:zy
-    * jump *label279 lessThan :compute:dist 64
-    * jump *label56 always
+  551 jump *label56 greaterThanEq :compute:dist 64
   552 label *label279
   553 op add :compute:i 33 1
   554 set :compute:x1 :compute:zx
 
   560 op mul *tmp64 *tmp63 :compute:zy
   561 op add :compute:zy *tmp64 :compute:cy
   562 op len :compute:dist :compute:zx :compute:zy
-    * jump *label283 lessThan :compute:dist 64
-    * jump *label56 always
+  563 jump *label56 greaterThanEq :compute:dist 64
   564 label *label283
   565 op add :compute:i 34 1
   566 set :compute:x1 :compute:zx
 
   572 op mul *tmp64 *tmp63 :compute:zy
   573 op add :compute:zy *tmp64 :compute:cy
   574 op len :compute:dist :compute:zx :compute:zy
-    * jump *label287 lessThan :compute:dist 64
-    * jump *label56 always
+  575 jump *label56 greaterThanEq :compute:dist 64
   576 label *label287
   577 op add :compute:i 35 1
   578 set :compute:x1 :compute:zx
 
   584 op mul *tmp64 *tmp63 :compute:zy
   585 op add :compute:zy *tmp64 :compute:cy
   586 op len :compute:dist :compute:zx :compute:zy
-    * jump *label291 lessThan :compute:dist 64
-    * jump *label56 always
+  587 jump *label56 greaterThanEq :compute:dist 64
   588 label *label291
   589 op add :compute:i 36 1
   590 set :compute:x1 :compute:zx
 
   596 op mul *tmp64 *tmp63 :compute:zy
   597 op add :compute:zy *tmp64 :compute:cy
   598 op len :compute:dist :compute:zx :compute:zy
-    * jump *label295 lessThan :compute:dist 64
-    * jump *label56 always
+  599 jump *label56 greaterThanEq :compute:dist 64
   600 label *label295
   601 op add :compute:i 37 1
   602 set :compute:x1 :compute:zx
 
   608 op mul *tmp64 *tmp63 :compute:zy
   609 op add :compute:zy *tmp64 :compute:cy
   610 op len :compute:dist :compute:zx :compute:zy
-    * jump *label299 lessThan :compute:dist 64
-    * jump *label56 always
+  611 jump *label56 greaterThanEq :compute:dist 64
   612 label *label299
   613 op add :compute:i 38 1
   614 set :compute:x1 :compute:zx
 
   620 op mul *tmp64 *tmp63 :compute:zy
   621 op add :compute:zy *tmp64 :compute:cy
   622 op len :compute:dist :compute:zx :compute:zy
-    * jump *label303 lessThan :compute:dist 64
-    * jump *label56 always
+  623 jump *label56 greaterThanEq :compute:dist 64
   624 label *label303
   625 op add :compute:i 39 1
   626 set :compute:x1 :compute:zx
 
   632 op mul *tmp64 *tmp63 :compute:zy
   633 op add :compute:zy *tmp64 :compute:cy
   634 op len :compute:dist :compute:zx :compute:zy
-    * jump *label307 lessThan :compute:dist 64
-    * jump *label56 always
+  635 jump *label56 greaterThanEq :compute:dist 64
   636 label *label307
   637 op add :compute:i 40 1
   638 set :compute:x1 :compute:zx
 
   644 op mul *tmp64 *tmp63 :compute:zy
   645 op add :compute:zy *tmp64 :compute:cy
   646 op len :compute:dist :compute:zx :compute:zy
-    * jump *label311 lessThan :compute:dist 64
-    * jump *label56 always
+  647 jump *label56 greaterThanEq :compute:dist 64
   648 label *label311
   649 op add :compute:i 41 1
   650 set :compute:x1 :compute:zx
 
   656 op mul *tmp64 *tmp63 :compute:zy
   657 op add :compute:zy *tmp64 :compute:cy
   658 op len :compute:dist :compute:zx :compute:zy
-    * jump *label315 lessThan :compute:dist 64
-    * jump *label56 always
+  659 jump *label56 greaterThanEq :compute:dist 64
   660 label *label315
   661 op add :compute:i 42 1
   662 set :compute:x1 :compute:zx
 
   668 op mul *tmp64 *tmp63 :compute:zy
   669 op add :compute:zy *tmp64 :compute:cy
   670 op len :compute:dist :compute:zx :compute:zy
-    * jump *label319 lessThan :compute:dist 64
-    * jump *label56 always
+  671 jump *label56 greaterThanEq :compute:dist 64
   672 label *label319
   673 op add :compute:i 43 1
   674 set :compute:x1 :compute:zx
 
   680 op mul *tmp64 *tmp63 :compute:zy
   681 op add :compute:zy *tmp64 :compute:cy
   682 op len :compute:dist :compute:zx :compute:zy
-    * jump *label323 lessThan :compute:dist 64
-    * jump *label56 always
+  683 jump *label56 greaterThanEq :compute:dist 64
   684 label *label323
   685 op add :compute:i 44 1
   686 set :compute:x1 :compute:zx
 
   692 op mul *tmp64 *tmp63 :compute:zy
   693 op add :compute:zy *tmp64 :compute:cy
   694 op len :compute:dist :compute:zx :compute:zy
-    * jump *label327 lessThan :compute:dist 64
-    * jump *label56 always
+  695 jump *label56 greaterThanEq :compute:dist 64
   696 label *label327
   697 op add :compute:i 45 1
   698 set :compute:x1 :compute:zx
 
   704 op mul *tmp64 *tmp63 :compute:zy
   705 op add :compute:zy *tmp64 :compute:cy
   706 op len :compute:dist :compute:zx :compute:zy
-    * jump *label331 lessThan :compute:dist 64
-    * jump *label56 always
+  707 jump *label56 greaterThanEq :compute:dist 64
   708 label *label331
   709 op add :compute:i 46 1
   710 set :compute:x1 :compute:zx
 
   716 op mul *tmp64 *tmp63 :compute:zy
   717 op add :compute:zy *tmp64 :compute:cy
   718 op len :compute:dist :compute:zx :compute:zy
-    * jump *label335 lessThan :compute:dist 64
-    * jump *label56 always
+  719 jump *label56 greaterThanEq :compute:dist 64
   720 label *label335
   721 op add :compute:i 47 1
   722 set :compute:x1 :compute:zx
 
   728 op mul *tmp64 *tmp63 :compute:zy
   729 op add :compute:zy *tmp64 :compute:cy
   730 op len :compute:dist :compute:zx :compute:zy
-    * jump *label339 lessThan :compute:dist 64
-    * jump *label56 always
+  731 jump *label56 greaterThanEq :compute:dist 64
   732 label *label339
   733 op add :compute:i 48 1
   734 set :compute:x1 :compute:zx
 
   740 op mul *tmp64 *tmp63 :compute:zy
   741 op add :compute:zy *tmp64 :compute:cy
   742 op len :compute:dist :compute:zx :compute:zy
-    * jump *label343 lessThan :compute:dist 64
-    * jump *label56 always
+  743 jump *label56 greaterThanEq :compute:dist 64
   744 label *label343
   745 op add :compute:i 49 1
   746 set :compute:x1 :compute:zx
 
   752 op mul *tmp64 *tmp63 :compute:zy
   753 op add :compute:zy *tmp64 :compute:cy
   754 op len :compute:dist :compute:zx :compute:zy
-    * jump *label347 lessThan :compute:dist 64
-    * jump *label56 always
+  755 jump *label56 greaterThanEq :compute:dist 64
   756 label *label347
   757 op add :compute:i 50 1
   758 set :compute:x1 :compute:zx
 
   764 op mul *tmp64 *tmp63 :compute:zy
   765 op add :compute:zy *tmp64 :compute:cy
   766 op len :compute:dist :compute:zx :compute:zy
-    * jump *label351 lessThan :compute:dist 64
-    * jump *label56 always
+  767 jump *label56 greaterThanEq :compute:dist 64
   768 label *label351
   769 op add :compute:i 51 1
   770 set :compute:x1 :compute:zx
 
   776 op mul *tmp64 *tmp63 :compute:zy
   777 op add :compute:zy *tmp64 :compute:cy
   778 op len :compute:dist :compute:zx :compute:zy
-    * jump *label355 lessThan :compute:dist 64
-    * jump *label56 always
+  779 jump *label56 greaterThanEq :compute:dist 64
   780 label *label355
   781 op add :compute:i 52 1
   782 set :compute:x1 :compute:zx
 
   788 op mul *tmp64 *tmp63 :compute:zy
   789 op add :compute:zy *tmp64 :compute:cy
   790 op len :compute:dist :compute:zx :compute:zy
-    * jump *label359 lessThan :compute:dist 64
-    * jump *label56 always
+  791 jump *label56 greaterThanEq :compute:dist 64
   792 label *label359
   793 op add :compute:i 53 1
   794 set :compute:x1 :compute:zx
 
   800 op mul *tmp64 *tmp63 :compute:zy
   801 op add :compute:zy *tmp64 :compute:cy
   802 op len :compute:dist :compute:zx :compute:zy
-    * jump *label363 lessThan :compute:dist 64
-    * jump *label56 always
+  803 jump *label56 greaterThanEq :compute:dist 64
   804 label *label363
   805 op add :compute:i 54 1
   806 set :compute:x1 :compute:zx
 
   812 op mul *tmp64 *tmp63 :compute:zy
   813 op add :compute:zy *tmp64 :compute:cy
   814 op len :compute:dist :compute:zx :compute:zy
-    * jump *label367 lessThan :compute:dist 64
-    * jump *label56 always
+  815 jump *label56 greaterThanEq :compute:dist 64
   816 label *label367
   817 op add :compute:i 55 1
   818 set :compute:x1 :compute:zx
 
   824 op mul *tmp64 *tmp63 :compute:zy
   825 op add :compute:zy *tmp64 :compute:cy
   826 op len :compute:dist :compute:zx :compute:zy
-    * jump *label371 lessThan :compute:dist 64
-    * jump *label56 always
+  827 jump *label56 greaterThanEq :compute:dist 64
   828 label *label371
   829 op add :compute:i 56 1
   830 set :compute:x1 :compute:zx
 
   836 op mul *tmp64 *tmp63 :compute:zy
   837 op add :compute:zy *tmp64 :compute:cy
   838 op len :compute:dist :compute:zx :compute:zy
-    * jump *label375 lessThan :compute:dist 64
-    * jump *label56 always
+  839 jump *label56 greaterThanEq :compute:dist 64
   840 label *label375
   841 op add :compute:i 57 1
   842 set :compute:x1 :compute:zx
 
   848 op mul *tmp64 *tmp63 :compute:zy
   849 op add :compute:zy *tmp64 :compute:cy
   850 op len :compute:dist :compute:zx :compute:zy
-    * jump *label379 lessThan :compute:dist 64
-    * jump *label56 always
+  851 jump *label56 greaterThanEq :compute:dist 64
   852 label *label379
   853 op add :compute:i 58 1
   854 set :compute:x1 :compute:zx
 
   860 op mul *tmp64 *tmp63 :compute:zy
   861 op add :compute:zy *tmp64 :compute:cy
   862 op len :compute:dist :compute:zx :compute:zy
-    * jump *label383 lessThan :compute:dist 64
-    * jump *label56 always
+  863 jump *label56 greaterThanEq :compute:dist 64
   864 label *label383
   865 op add :compute:i 59 1
   866 set :compute:x1 :compute:zx
 
   872 op mul *tmp64 *tmp63 :compute:zy
   873 op add :compute:zy *tmp64 :compute:cy
   874 op len :compute:dist :compute:zx :compute:zy
-    * jump *label387 lessThan :compute:dist 64
-    * jump *label56 always
+  875 jump *label56 greaterThanEq :compute:dist 64
   876 label *label387
   877 op add :compute:i 60 1
   878 set :compute:x1 :compute:zx
 
   884 op mul *tmp64 *tmp63 :compute:zy
   885 op add :compute:zy *tmp64 :compute:cy
   886 op len :compute:dist :compute:zx :compute:zy
-    * jump *label391 lessThan :compute:dist 64
-    * jump *label56 always
+  887 jump *label56 greaterThanEq :compute:dist 64
   888 label *label391
   889 op add :compute:i 61 1
   890 set :compute:x1 :compute:zx
 
   896 op mul *tmp64 *tmp63 :compute:zy
   897 op add :compute:zy *tmp64 :compute:cy
   898 op len :compute:dist :compute:zx :compute:zy
-    * jump *label395 lessThan :compute:dist 64
-    * jump *label56 always
+  899 jump *label56 greaterThanEq :compute:dist 64
   900 label *label395
   901 op add :compute:i 62 1
   902 label *label56
 
   916 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   917 label *label61
   918 read *tmp78 .memory :position
-    * jump *label62 equal *tmp78 .PROCESSOR_ID
-    * jump *label46 always
+  919 jump *label46 notEqual *tmp78 .PROCESSOR_ID
   920 label *label62
   921 read *tmp1 .memory 65
-    * jump *label64 equal .stop *tmp1
-    * jump *label32 always
+  922 jump *label32 notEqual .stop *tmp1
   923 label *label64
   924 op add :y :y 1
   925 jump *label107 lessThan :y 176

Modifications by Jumps phase, Jump Optimization, pass 6, iteration 1:
 
   153 op add :compute:zy *tmp64 :compute:cy
   154 op len :compute:dist :compute:zx :compute:zy
   155 jump *label56 greaterThanEq :compute:dist 64
-    * label *label147
   156 set :compute:i 1
   157 set :compute:x1 :compute:zx
   158 op mul *tmp59 :compute:zx :compute:zx
 
   164 op add :compute:zy *tmp64 :compute:cy
   165 op len :compute:dist :compute:zx :compute:zy
   166 jump *label56 greaterThanEq :compute:dist 64
-    * label *label151
   167 op add :compute:i 1 1
   168 set :compute:x1 :compute:zx
   169 op mul *tmp59 :compute:zx :compute:zx
 
   175 op add :compute:zy *tmp64 :compute:cy
   176 op len :compute:dist :compute:zx :compute:zy
   177 jump *label56 greaterThanEq :compute:dist 64
-    * label *label155
   178 op add :compute:i 2 1
   179 set :compute:x1 :compute:zx
   180 op mul *tmp59 :compute:zx :compute:zx
 
   186 op add :compute:zy *tmp64 :compute:cy
   187 op len :compute:dist :compute:zx :compute:zy
   188 jump *label56 greaterThanEq :compute:dist 64
-    * label *label159
   189 op add :compute:i 3 1
   190 set :compute:x1 :compute:zx
   191 op mul *tmp59 :compute:zx :compute:zx
 
   197 op add :compute:zy *tmp64 :compute:cy
   198 op len :compute:dist :compute:zx :compute:zy
   199 jump *label56 greaterThanEq :compute:dist 64
-    * label *label163
   200 op add :compute:i 4 1
   201 set :compute:x1 :compute:zx
   202 op mul *tmp59 :compute:zx :compute:zx
 
   208 op add :compute:zy *tmp64 :compute:cy
   209 op len :compute:dist :compute:zx :compute:zy
   210 jump *label56 greaterThanEq :compute:dist 64
-    * label *label167
   211 op add :compute:i 5 1
   212 set :compute:x1 :compute:zx
   213 op mul *tmp59 :compute:zx :compute:zx
 
   219 op add :compute:zy *tmp64 :compute:cy
   220 op len :compute:dist :compute:zx :compute:zy
   221 jump *label56 greaterThanEq :compute:dist 64
-    * label *label171
   222 op add :compute:i 6 1
   223 set :compute:x1 :compute:zx
   224 op mul *tmp59 :compute:zx :compute:zx
 
   230 op add :compute:zy *tmp64 :compute:cy
   231 op len :compute:dist :compute:zx :compute:zy
   232 jump *label56 greaterThanEq :compute:dist 64
-    * label *label175
   233 op add :compute:i 7 1
   234 set :compute:x1 :compute:zx
   235 op mul *tmp59 :compute:zx :compute:zx
 
   241 op add :compute:zy *tmp64 :compute:cy
   242 op len :compute:dist :compute:zx :compute:zy
   243 jump *label56 greaterThanEq :compute:dist 64
-    * label *label179
   244 op add :compute:i 8 1
   245 set :compute:x1 :compute:zx
   246 op mul *tmp59 :compute:zx :compute:zx
 
   252 op add :compute:zy *tmp64 :compute:cy
   253 op len :compute:dist :compute:zx :compute:zy
   254 jump *label56 greaterThanEq :compute:dist 64
-    * label *label183
   255 op add :compute:i 9 1
   256 set :compute:x1 :compute:zx
   257 op mul *tmp59 :compute:zx :compute:zx
 
   263 op add :compute:zy *tmp64 :compute:cy
   264 op len :compute:dist :compute:zx :compute:zy
   265 jump *label56 greaterThanEq :compute:dist 64
-    * label *label187
   266 op add :compute:i 10 1
   267 set :compute:x1 :compute:zx
   268 op mul *tmp59 :compute:zx :compute:zx
 
   274 op add :compute:zy *tmp64 :compute:cy
   275 op len :compute:dist :compute:zx :compute:zy
   276 jump *label56 greaterThanEq :compute:dist 64
-    * label *label191
   277 op add :compute:i 11 1
   278 set :compute:x1 :compute:zx
   279 op mul *tmp59 :compute:zx :compute:zx
 
   285 op add :compute:zy *tmp64 :compute:cy
   286 op len :compute:dist :compute:zx :compute:zy
   287 jump *label56 greaterThanEq :compute:dist 64
-    * label *label195
   288 op add :compute:i 12 1
   289 set :compute:x1 :compute:zx
   290 op mul *tmp59 :compute:zx :compute:zx
 
   296 op add :compute:zy *tmp64 :compute:cy
   297 op len :compute:dist :compute:zx :compute:zy
   298 jump *label56 greaterThanEq :compute:dist 64
-    * label *label199
   299 op add :compute:i 13 1
   300 set :compute:x1 :compute:zx
   301 op mul *tmp59 :compute:zx :compute:zx
 
   307 op add :compute:zy *tmp64 :compute:cy
   308 op len :compute:dist :compute:zx :compute:zy
   309 jump *label56 greaterThanEq :compute:dist 64
-    * label *label203
   310 op add :compute:i 14 1
   311 set :compute:x1 :compute:zx
   312 op mul *tmp59 :compute:zx :compute:zx
 
   318 op add :compute:zy *tmp64 :compute:cy
   319 op len :compute:dist :compute:zx :compute:zy
   320 jump *label56 greaterThanEq :compute:dist 64
-    * label *label207
   321 op add :compute:i 15 1
   322 set :compute:x1 :compute:zx
   323 op mul *tmp59 :compute:zx :compute:zx
 
   329 op add :compute:zy *tmp64 :compute:cy
   330 op len :compute:dist :compute:zx :compute:zy
   331 jump *label56 greaterThanEq :compute:dist 64
-    * label *label211
   332 op add :compute:i 16 1
   333 set :compute:x1 :compute:zx
   334 op mul *tmp59 :compute:zx :compute:zx
 
   340 op add :compute:zy *tmp64 :compute:cy
   341 op len :compute:dist :compute:zx :compute:zy
   342 jump *label56 greaterThanEq :compute:dist 64
-    * label *label215
   343 op add :compute:i 17 1
   344 set :compute:x1 :compute:zx
   345 op mul *tmp59 :compute:zx :compute:zx
 
   351 op add :compute:zy *tmp64 :compute:cy
   352 op len :compute:dist :compute:zx :compute:zy
   353 jump *label56 greaterThanEq :compute:dist 64
-    * label *label219
   354 op add :compute:i 18 1
   355 set :compute:x1 :compute:zx
   356 op mul *tmp59 :compute:zx :compute:zx
 
   362 op add :compute:zy *tmp64 :compute:cy
   363 op len :compute:dist :compute:zx :compute:zy
   364 jump *label56 greaterThanEq :compute:dist 64
-    * label *label223
   365 op add :compute:i 19 1
   366 set :compute:x1 :compute:zx
   367 op mul *tmp59 :compute:zx :compute:zx
 
   373 op add :compute:zy *tmp64 :compute:cy
   374 op len :compute:dist :compute:zx :compute:zy
   375 jump *label56 greaterThanEq :compute:dist 64
-    * label *label227
   376 op add :compute:i 20 1
   377 set :compute:x1 :compute:zx
   378 op mul *tmp59 :compute:zx :compute:zx
 
   384 op add :compute:zy *tmp64 :compute:cy
   385 op len :compute:dist :compute:zx :compute:zy
   386 jump *label56 greaterThanEq :compute:dist 64
-    * label *label231
   387 op add :compute:i 21 1
   388 set :compute:x1 :compute:zx
   389 op mul *tmp59 :compute:zx :compute:zx
 
   395 op add :compute:zy *tmp64 :compute:cy
   396 op len :compute:dist :compute:zx :compute:zy
   397 jump *label56 greaterThanEq :compute:dist 64
-    * label *label235
   398 op add :compute:i 22 1
   399 set :compute:x1 :compute:zx
   400 op mul *tmp59 :compute:zx :compute:zx
 
   406 op add :compute:zy *tmp64 :compute:cy
   407 op len :compute:dist :compute:zx :compute:zy
   408 jump *label56 greaterThanEq :compute:dist 64
-    * label *label239
   409 op add :compute:i 23 1
   410 set :compute:x1 :compute:zx
   411 op mul *tmp59 :compute:zx :compute:zx
 
   417 op add :compute:zy *tmp64 :compute:cy
   418 op len :compute:dist :compute:zx :compute:zy
   419 jump *label56 greaterThanEq :compute:dist 64
-    * label *label243
   420 op add :compute:i 24 1
   421 set :compute:x1 :compute:zx
   422 op mul *tmp59 :compute:zx :compute:zx
 
   428 op add :compute:zy *tmp64 :compute:cy
   429 op len :compute:dist :compute:zx :compute:zy
   430 jump *label56 greaterThanEq :compute:dist 64
-    * label *label247
   431 op add :compute:i 25 1
   432 set :compute:x1 :compute:zx
   433 op mul *tmp59 :compute:zx :compute:zx
 
   439 op add :compute:zy *tmp64 :compute:cy
   440 op len :compute:dist :compute:zx :compute:zy
   441 jump *label56 greaterThanEq :compute:dist 64
-    * label *label251
   442 op add :compute:i 26 1
   443 set :compute:x1 :compute:zx
   444 op mul *tmp59 :compute:zx :compute:zx
 
   450 op add :compute:zy *tmp64 :compute:cy
   451 op len :compute:dist :compute:zx :compute:zy
   452 jump *label56 greaterThanEq :compute:dist 64
-    * label *label255
   453 op add :compute:i 27 1
   454 set :compute:x1 :compute:zx
   455 op mul *tmp59 :compute:zx :compute:zx
 
   461 op add :compute:zy *tmp64 :compute:cy
   462 op len :compute:dist :compute:zx :compute:zy
   463 jump *label56 greaterThanEq :compute:dist 64
-    * label *label259
   464 op add :compute:i 28 1
   465 set :compute:x1 :compute:zx
   466 op mul *tmp59 :compute:zx :compute:zx
 
   472 op add :compute:zy *tmp64 :compute:cy
   473 op len :compute:dist :compute:zx :compute:zy
   474 jump *label56 greaterThanEq :compute:dist 64
-    * label *label263
   475 op add :compute:i 29 1
   476 set :compute:x1 :compute:zx
   477 op mul *tmp59 :compute:zx :compute:zx
 
   483 op add :compute:zy *tmp64 :compute:cy
   484 op len :compute:dist :compute:zx :compute:zy
   485 jump *label56 greaterThanEq :compute:dist 64
-    * label *label267
   486 op add :compute:i 30 1
   487 set :compute:x1 :compute:zx
   488 op mul *tmp59 :compute:zx :compute:zx
 
   494 op add :compute:zy *tmp64 :compute:cy
   495 op len :compute:dist :compute:zx :compute:zy
   496 jump *label56 greaterThanEq :compute:dist 64
-    * label *label271
   497 op add :compute:i 31 1
   498 set :compute:x1 :compute:zx
   499 op mul *tmp59 :compute:zx :compute:zx
 
   505 op add :compute:zy *tmp64 :compute:cy
   506 op len :compute:dist :compute:zx :compute:zy
   507 jump *label56 greaterThanEq :compute:dist 64
-    * label *label275
   508 op add :compute:i 32 1
   509 set :compute:x1 :compute:zx
   510 op mul *tmp59 :compute:zx :compute:zx
 
   516 op add :compute:zy *tmp64 :compute:cy
   517 op len :compute:dist :compute:zx :compute:zy
   518 jump *label56 greaterThanEq :compute:dist 64
-    * label *label279
   519 op add :compute:i 33 1
   520 set :compute:x1 :compute:zx
   521 op mul *tmp59 :compute:zx :compute:zx
 
   527 op add :compute:zy *tmp64 :compute:cy
   528 op len :compute:dist :compute:zx :compute:zy
   529 jump *label56 greaterThanEq :compute:dist 64
-    * label *label283
   530 op add :compute:i 34 1
   531 set :compute:x1 :compute:zx
   532 op mul *tmp59 :compute:zx :compute:zx
 
   538 op add :compute:zy *tmp64 :compute:cy
   539 op len :compute:dist :compute:zx :compute:zy
   540 jump *label56 greaterThanEq :compute:dist 64
-    * label *label287
   541 op add :compute:i 35 1
   542 set :compute:x1 :compute:zx
   543 op mul *tmp59 :compute:zx :compute:zx
 
   549 op add :compute:zy *tmp64 :compute:cy
   550 op len :compute:dist :compute:zx :compute:zy
   551 jump *label56 greaterThanEq :compute:dist 64
-    * label *label291
   552 op add :compute:i 36 1
   553 set :compute:x1 :compute:zx
   554 op mul *tmp59 :compute:zx :compute:zx
 
   560 op add :compute:zy *tmp64 :compute:cy
   561 op len :compute:dist :compute:zx :compute:zy
   562 jump *label56 greaterThanEq :compute:dist 64
-    * label *label295
   563 op add :compute:i 37 1
   564 set :compute:x1 :compute:zx
   565 op mul *tmp59 :compute:zx :compute:zx
 
   571 op add :compute:zy *tmp64 :compute:cy
   572 op len :compute:dist :compute:zx :compute:zy
   573 jump *label56 greaterThanEq :compute:dist 64
-    * label *label299
   574 op add :compute:i 38 1
   575 set :compute:x1 :compute:zx
   576 op mul *tmp59 :compute:zx :compute:zx
 
   582 op add :compute:zy *tmp64 :compute:cy
   583 op len :compute:dist :compute:zx :compute:zy
   584 jump *label56 greaterThanEq :compute:dist 64
-    * label *label303
   585 op add :compute:i 39 1
   586 set :compute:x1 :compute:zx
   587 op mul *tmp59 :compute:zx :compute:zx
 
   593 op add :compute:zy *tmp64 :compute:cy
   594 op len :compute:dist :compute:zx :compute:zy
   595 jump *label56 greaterThanEq :compute:dist 64
-    * label *label307
   596 op add :compute:i 40 1
   597 set :compute:x1 :compute:zx
   598 op mul *tmp59 :compute:zx :compute:zx
 
   604 op add :compute:zy *tmp64 :compute:cy
   605 op len :compute:dist :compute:zx :compute:zy
   606 jump *label56 greaterThanEq :compute:dist 64
-    * label *label311
   607 op add :compute:i 41 1
   608 set :compute:x1 :compute:zx
   609 op mul *tmp59 :compute:zx :compute:zx
 
   615 op add :compute:zy *tmp64 :compute:cy
   616 op len :compute:dist :compute:zx :compute:zy
   617 jump *label56 greaterThanEq :compute:dist 64
-    * label *label315
   618 op add :compute:i 42 1
   619 set :compute:x1 :compute:zx
   620 op mul *tmp59 :compute:zx :compute:zx
 
   626 op add :compute:zy *tmp64 :compute:cy
   627 op len :compute:dist :compute:zx :compute:zy
   628 jump *label56 greaterThanEq :compute:dist 64
-    * label *label319
   629 op add :compute:i 43 1
   630 set :compute:x1 :compute:zx
   631 op mul *tmp59 :compute:zx :compute:zx
 
   637 op add :compute:zy *tmp64 :compute:cy
   638 op len :compute:dist :compute:zx :compute:zy
   639 jump *label56 greaterThanEq :compute:dist 64
-    * label *label323
   640 op add :compute:i 44 1
   641 set :compute:x1 :compute:zx
   642 op mul *tmp59 :compute:zx :compute:zx
 
   648 op add :compute:zy *tmp64 :compute:cy
   649 op len :compute:dist :compute:zx :compute:zy
   650 jump *label56 greaterThanEq :compute:dist 64
-    * label *label327
   651 op add :compute:i 45 1
   652 set :compute:x1 :compute:zx
   653 op mul *tmp59 :compute:zx :compute:zx
 
   659 op add :compute:zy *tmp64 :compute:cy
   660 op len :compute:dist :compute:zx :compute:zy
   661 jump *label56 greaterThanEq :compute:dist 64
-    * label *label331
   662 op add :compute:i 46 1
   663 set :compute:x1 :compute:zx
   664 op mul *tmp59 :compute:zx :compute:zx
 
   670 op add :compute:zy *tmp64 :compute:cy
   671 op len :compute:dist :compute:zx :compute:zy
   672 jump *label56 greaterThanEq :compute:dist 64
-    * label *label335
   673 op add :compute:i 47 1
   674 set :compute:x1 :compute:zx
   675 op mul *tmp59 :compute:zx :compute:zx
 
   681 op add :compute:zy *tmp64 :compute:cy
   682 op len :compute:dist :compute:zx :compute:zy
   683 jump *label56 greaterThanEq :compute:dist 64
-    * label *label339
   684 op add :compute:i 48 1
   685 set :compute:x1 :compute:zx
   686 op mul *tmp59 :compute:zx :compute:zx
 
   692 op add :compute:zy *tmp64 :compute:cy
   693 op len :compute:dist :compute:zx :compute:zy
   694 jump *label56 greaterThanEq :compute:dist 64
-    * label *label343
   695 op add :compute:i 49 1
   696 set :compute:x1 :compute:zx
   697 op mul *tmp59 :compute:zx :compute:zx
 
   703 op add :compute:zy *tmp64 :compute:cy
   704 op len :compute:dist :compute:zx :compute:zy
   705 jump *label56 greaterThanEq :compute:dist 64
-    * label *label347
   706 op add :compute:i 50 1
   707 set :compute:x1 :compute:zx
   708 op mul *tmp59 :compute:zx :compute:zx
 
   714 op add :compute:zy *tmp64 :compute:cy
   715 op len :compute:dist :compute:zx :compute:zy
   716 jump *label56 greaterThanEq :compute:dist 64
-    * label *label351
   717 op add :compute:i 51 1
   718 set :compute:x1 :compute:zx
   719 op mul *tmp59 :compute:zx :compute:zx
 
   725 op add :compute:zy *tmp64 :compute:cy
   726 op len :compute:dist :compute:zx :compute:zy
   727 jump *label56 greaterThanEq :compute:dist 64
-    * label *label355
   728 op add :compute:i 52 1
   729 set :compute:x1 :compute:zx
   730 op mul *tmp59 :compute:zx :compute:zx
 
   736 op add :compute:zy *tmp64 :compute:cy
   737 op len :compute:dist :compute:zx :compute:zy
   738 jump *label56 greaterThanEq :compute:dist 64
-    * label *label359
   739 op add :compute:i 53 1
   740 set :compute:x1 :compute:zx
   741 op mul *tmp59 :compute:zx :compute:zx
 
   747 op add :compute:zy *tmp64 :compute:cy
   748 op len :compute:dist :compute:zx :compute:zy
   749 jump *label56 greaterThanEq :compute:dist 64
-    * label *label363
   750 op add :compute:i 54 1
   751 set :compute:x1 :compute:zx
   752 op mul *tmp59 :compute:zx :compute:zx
 
   758 op add :compute:zy *tmp64 :compute:cy
   759 op len :compute:dist :compute:zx :compute:zy
   760 jump *label56 greaterThanEq :compute:dist 64
-    * label *label367
   761 op add :compute:i 55 1
   762 set :compute:x1 :compute:zx
   763 op mul *tmp59 :compute:zx :compute:zx
 
   769 op add :compute:zy *tmp64 :compute:cy
   770 op len :compute:dist :compute:zx :compute:zy
   771 jump *label56 greaterThanEq :compute:dist 64
-    * label *label371
   772 op add :compute:i 56 1
   773 set :compute:x1 :compute:zx
   774 op mul *tmp59 :compute:zx :compute:zx
 
   780 op add :compute:zy *tmp64 :compute:cy
   781 op len :compute:dist :compute:zx :compute:zy
   782 jump *label56 greaterThanEq :compute:dist 64
-    * label *label375
   783 op add :compute:i 57 1
   784 set :compute:x1 :compute:zx
   785 op mul *tmp59 :compute:zx :compute:zx
 
   791 op add :compute:zy *tmp64 :compute:cy
   792 op len :compute:dist :compute:zx :compute:zy
   793 jump *label56 greaterThanEq :compute:dist 64
-    * label *label379
   794 op add :compute:i 58 1
   795 set :compute:x1 :compute:zx
   796 op mul *tmp59 :compute:zx :compute:zx
 
   802 op add :compute:zy *tmp64 :compute:cy
   803 op len :compute:dist :compute:zx :compute:zy
   804 jump *label56 greaterThanEq :compute:dist 64
-    * label *label383
   805 op add :compute:i 59 1
   806 set :compute:x1 :compute:zx
   807 op mul *tmp59 :compute:zx :compute:zx
 
   813 op add :compute:zy *tmp64 :compute:cy
   814 op len :compute:dist :compute:zx :compute:zy
   815 jump *label56 greaterThanEq :compute:dist 64
-    * label *label387
   816 op add :compute:i 60 1
   817 set :compute:x1 :compute:zx
   818 op mul *tmp59 :compute:zx :compute:zx
 
   824 op add :compute:zy *tmp64 :compute:cy
   825 op len :compute:dist :compute:zx :compute:zy
   826 jump *label56 greaterThanEq :compute:dist 64
-    * label *label391
   827 op add :compute:i 61 1
   828 set :compute:x1 :compute:zx
   829 op mul *tmp59 :compute:zx :compute:zx
 
   835 op add :compute:zy *tmp64 :compute:cy
   836 op len :compute:dist :compute:zx :compute:zy
   837 jump *label56 greaterThanEq :compute:dist 64
-    * label *label395
   838 op add :compute:i 62 1
   839 label *label56
   840 op mul *tmp69 .SMOOTH 63
 
   854 label *label61
   855 read *tmp78 .memory :position
   856 jump *label46 notEqual *tmp78 .PROCESSOR_ID
-    * label *label62
   857 read *tmp1 .memory 65
   858 jump *label32 notEqual .stop *tmp1
-    * label *label64
   859 op add :y :y 1
   860 jump *label107 lessThan :y 176
   861 label *label46

Modifications by Jumps phase, Jump Threading, pass 6, iteration 1:
 
   855 read *tmp78 .memory :position
   856 jump *label46 notEqual *tmp78 .PROCESSOR_ID
   857 read *tmp1 .memory 65
-    * jump *label32 notEqual .stop *tmp1
+  858 jump *label31 notEqual .stop *tmp1
   859 op add :y :y 1
   860 jump *label107 lessThan :y 176
   861 label *label46
 
   884 label *label0
   885 jump *label70 equal .SMOOTH false
   886 set :drawPixel:color %[black]
-    * jump *label73 equal :drawPixel:iterations 63
+  887 jump *label71 equal :drawPixel:iterations 63
   888 jump *label75 notEqual .PALETTE 2
   889 op sub *tmp91 32 :drawPixel:iterations
   890 op abs *tmp92 *tmp91
 
   897 op div *tmp104 *tmp92 63.75
   898 op add :drawPixel:b 0.47058823529411764 *tmp104
   899 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label74 always
+  900 jump *label71 always
   901 label *label75
   902 jump *label77 notEqual .PALETTE 3
   903 op div *tmp108 :drawPixel:iterations 0.175
 
   908 op div *tmp116 *tmp114 63.75
   909 op add :drawPixel:b 0.39215686274509803 *tmp116
   910 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label74 always
+  911 jump *label71 always
   912 label *label77
   913 jump *label79 notEqual .PALETTE 4
   914 op div :drawPixel:r :drawPixel:iterations 63.75
   915 op div *tmp122 :drawPixel:iterations 170
   916 op add :drawPixel:g 96 *tmp122
   917 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label74 always
+  918 jump *label71 always
   919 label *label79
   920 op div *tmp126 :drawPixel:iterations 63.75
   921 op sub :drawPixel:r 1 *tmp126
 
   950 jump *label84 greaterThanEq :drawPixel:usage 100
   951 drawflush .display
   952 set .localBuffer 0
-    * jump *label85 always
+  953 return :drawPixel*retaddr
   954 label *label84
   955 op div *tmp141 1800 .localBuffer
   956 jump *label86 greaterThanEq :drawPixel:usage *tmp141

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-6 instructions):
 
    44 jump *label421 notEqual *tmp152 .PROCESSOR_ID
    45 write 0 .memory .PROC_STATE_INDEX
    46 jump *label426 always
-    * jump *label424 always
    47 label *label421
    48 read *tmp158 .memory .PROC_ID_INDEX
    49 jump *label422 notEqual *tmp158 0
    50 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    51 write 0 .memory .PROC_STATE_INDEX
    52 jump *label426 always
-    * jump *label423 always
    53 label *label422
    54 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    55 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
    69 jump *label431 notEqual *tmp152 .PROCESSOR_ID
    70 write *tmp0 .memory .PROC_STATE_INDEX
    71 jump *label436 always
-    * jump *label434 always
    72 label *label431
    73 read *tmp158 .memory .PROC_ID_INDEX
    74 jump *label432 notEqual *tmp158 0
    75 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    76 write *tmp0 .memory .PROC_STATE_INDEX
    77 jump *label436 always
-    * jump *label433 always
    78 label *label432
    79 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    80 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
   874 jump *label402 greaterThan *tmp148 250
   875 label *label405
   876 drawflush .display
-    * label *label32
   877 jump *label31 always
-    * end
   878 label *label0
   879 jump *label70 equal .SMOOTH false
   880 set :drawPixel:color %[black]
 
   914 op div *tmp126 :drawPixel:iterations 63.75
   915 op sub :drawPixel:r 1 *tmp126
   916 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * label *label74
-    * label *label73
   917 jump *label71 always
   918 label *label70
   919 read :drawPixel:color .memory :drawPixel:iterations
 
   949 drawflush .display
   950 set .localBuffer 0
   951 label *label86
-    * label *label85
   952 return :drawPixel*retaddr
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 6, iteration 1:
 
    53 label *label422
    54 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    55 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label423
-    * label *label424
    56 jump *label420 lessThan .PROC_STATE_INDEX 512
    57 label *label426
    58 read *tmp0 .memory 64
 
    76 label *label432
    77 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    78 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label433
-    * label *label434
    79 jump *label430 lessThan .PROC_STATE_INDEX 512
    80 label *label436
    81 read .ZOOM .memory 68

Modifications by Final phase, Print Merging, iteration 1 (-7 instructions):
 
    20 set .memory :findLinkedBlocks:variable
    21 jump *label105 greaterThan :findLinkedBlocks:n 0
    22 label *label14
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
-    * print .display
+   23 print "\nDisplay: {0}\nMemory: "
+   24 format .display
    25 op and :findLinkedBlocks:foundAll 1 .display
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
    26 print .memory
    27 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    28 printflush null

Final code before resolving virtual instructions:

    0:  op mul *tmp11 10000 @thisy                                   mandelbrot-compute.mnd: var PROCESSOR_ID = @this.@x + 10000 * @this.@y;
    1:  op add .PROCESSOR_ID @thisx *tmp11                           ...
    2:  set .PROC_ID_INDEX 334                                       mandelbrot-compute.mnd: var PROC_ID_INDEX = PROCESSORS;
    3:  set .PROC_STATE_INDEX 335                                    mandelbrot-compute.mnd: var PROC_STATE_INDEX = PROCESSORS + 1;
    4:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label4                                                *blocks: do
    5:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    6:  set .memory null                                             ...
    7:  print "Mandelbrot Generator"                                 *blocks: print(title);
    8:  set :findLinkedBlocks:n @links                               *blocks: var n = @links;
    9:  jump *label14 lessThanEq :findLinkedBlocks:n 0               *blocks: while n > 0 do
        label *label105                                              ...
   10:  op sub :findLinkedBlocks:n :findLinkedBlocks:n 1             *blocks: var block = getlink(--n);
   11:  getlink :findLinkedBlocks:block :findLinkedBlocks:n          ...
   12:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
   13:  print :findLinkedBlocks:block                                ...
   14:  sensor :findLinkedBlocks:type :findLinkedBlocks:block @type  *blocks: var type = block.@type;
   15:  select :findLinkedBlocks:variable equal @large-logic-display *blocks: if requested == type then
   16:  set .display :findLinkedBlocks:variable                      *blocks: for requested, name, out variable, required in linkMap do
   17:  select :findLinkedBlocks:variable equal @memory-bank :findLi *blocks: if requested == type then
   18:  set .memory :findLinkedBlocks:variable                       *blocks: for requested, name, out variable, required in linkMap do
   19:  jump *label105 greaterThan :findLinkedBlocks:n 0             *blocks: while n > 0 do
        label *label14                                               ...
   20:  print "\nDisplay: {0}\nMemory: "                             *blocks: print($"\n$name: $variable");
   21:  format .display                                              ...
   22:  op and :findLinkedBlocks:foundAll 1 .display                 *blocks: if required then foundAll &= variable; end;
   23:  print .memory                                                *blocks: print($"\n$name: $variable");
   24:  op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll *blocks: if required then foundAll &= variable; end;
   25:  printflush null                                              *blocks: printflush(message);
   26:  jump *label4 equal :findLinkedBlocks:foundAll false          *blocks: do
        label *label31                                               mandelbrot-compute.mnd: MainLoop:
   27:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   28:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
        label *label34                                               mandelbrot-compute.mnd: do
   29:  jump *label426 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label420                                              ...
   30:  read *tmp152 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   31:  jump *label421 notEqual *tmp152 .PROCESSOR_ID                ...
   32:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   33:  jump *label426 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label421                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   34:  read *tmp158 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   35:  jump *label422 notEqual *tmp158 0                            ...
   36:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   37:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   38:  jump *label426 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label422                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   39:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   40:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   41:  jump *label420 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label426                                              ...
   42:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: while start == $START;
   43:  jump *label34 equal .start *tmp0                             mandelbrot-compute.mnd: do
   44:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: start = $START;
   45:  set .start *tmp0                                             ...
   46:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: stop = $STOP;
   47:  set .stop *tmp1                                              ...
   48:  jump *label436 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label430                                              ...
   49:  read *tmp152 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   50:  jump *label431 notEqual *tmp152 .PROCESSOR_ID                ...
   51:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   52:  jump *label436 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label431                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   53:  read *tmp158 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   54:  jump *label432 notEqual *tmp158 0                            ...
   55:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   56:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   57:  jump *label436 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label432                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   58:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   59:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   60:  jump *label430 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label436                                              ...
   61:  read .ZOOM .memory 68                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   62:  op div *tmp26 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   63:  read *tmp2 .memory 66                                        ...
   64:  op add .OFFSET_X *tmp26 *tmp2                                ...
   65:  read *tmp3 .memory 67                                        mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   66:  op add .OFFSET_Y *tmp26 *tmp3                                ...
   67:  read .JULIA .memory 69                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   68:  read .JULIA_X .memory 70                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   69:  read .JULIA_Y .memory 71                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   70:  read .PALETTE .memory 72                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   71:  op greaterThan .SMOOTH .PALETTE 1                            mandelbrot-compute.mnd: SMOOTH   = PALETTE > 1;
   72:  set :line 8                                                  mandelbrot-compute.mnd: var line = 8;
   73:  set :increment 8                                             mandelbrot-compute.mnd: var increment = 8;
   74:  set :next_increment 16                                       mandelbrot-compute.mnd: var next_increment = 16;
   75:  op rand *tmp31 0.1 0                                         mandelbrot-compute.mnd: wait(rand(0.1));
   76:  wait *tmp31                                                  ...
   77:  set :lines 0                                                 mandelbrot-compute.mnd: for var lines in 0 ... DISPLAY_SIZE_LARGE do
        label *label106                                              ...
   78:  op mul *tmp32 17 :line                                       mandelbrot-compute.mnd: var x = (SKIP * line) % DISPLAY_SIZE_LARGE;
   79:  op mod :x *tmp32 176                                         ...
   80:  op add :position :x 158                                      mandelbrot-compute.mnd: var position = x + SLOTS;
   81:  read *tmp36 .memory :position                                mandelbrot-compute.mnd: if memory[position] == 0 then
   82:  jump *label42 notEqual *tmp36 0                              ...
   83:  write .PROCESSOR_ID .memory :position                        mandelbrot-compute.mnd: memory[position] = PROCESSOR_ID;
   84:  set :y 0                                                     mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
   85:  set :drawPixel:x :x                                          ...
   86:  setaddr :drawPixel*retaddr *label61                          ...
        label *label107                                              ...
   87:  op div *tmp42 :x .ZOOM                                       mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   88:  op add :compute:zx *tmp42 .OFFSET_X                          ...
   89:  op div *tmp44 :y .ZOOM                                       mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   90:  op add :compute:zy *tmp44 .OFFSET_Y                          ...
   91:  jump *label48 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   92:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
   93:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
   94:  jump *label49 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label48                                               ...
   95:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
   96:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
   97:  op sub *tmp47 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   98:  op len :compute:p *tmp47 :compute:zy                         ...
   99:  op mul *tmp49 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  100:  op mul *tmp50 *tmp49 :compute:p                              ...
  101:  op sub *tmp51 :compute:p *tmp50                              ...
  102:  op add *tmp52 *tmp51 0.25                                    ...
  103:  jump *label50 greaterThan :compute:zx *tmp52                 ...
  104:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  105:  jump *label47 always 0 0                                     ...
        label *label50                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  106:  op add *tmp55 :compute:zx 1                                  mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  107:  op len *tmp56 *tmp55 :compute:zy                             ...
  108:  jump *label52 greaterThan *tmp56 0.25                        ...
  109:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  110:  jump *label47 always 0 0                                     ...
        label *label52                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label49                                               mandelbrot-compute.mnd: if JULIA then
  111:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  112:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  113:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  114:  op mul *tmp60 :compute:zy :compute:zy                        ...
  115:  op sub *tmp61 *tmp59 *tmp60                                  ...
  116:  op add :compute:zx *tmp61 :compute:cx                        ...
  117:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  118:  op mul *tmp64 *tmp63 :compute:zy                             ...
  119:  op add :compute:zy *tmp64 :compute:cy                        ...
  120:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  121:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  122:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  123:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  124:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  125:  op mul *tmp60 :compute:zy :compute:zy                        ...
  126:  op sub *tmp61 *tmp59 *tmp60                                  ...
  127:  op add :compute:zx *tmp61 :compute:cx                        ...
  128:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  129:  op mul *tmp64 *tmp63 :compute:zy                             ...
  130:  op add :compute:zy *tmp64 :compute:cy                        ...
  131:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  132:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  133:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  134:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  135:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  136:  op mul *tmp60 :compute:zy :compute:zy                        ...
  137:  op sub *tmp61 *tmp59 *tmp60                                  ...
  138:  op add :compute:zx *tmp61 :compute:cx                        ...
  139:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  140:  op mul *tmp64 *tmp63 :compute:zy                             ...
  141:  op add :compute:zy *tmp64 :compute:cy                        ...
  142:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  143:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  144:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  145:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  146:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  147:  op mul *tmp60 :compute:zy :compute:zy                        ...
  148:  op sub *tmp61 *tmp59 *tmp60                                  ...
  149:  op add :compute:zx *tmp61 :compute:cx                        ...
  150:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  151:  op mul *tmp64 *tmp63 :compute:zy                             ...
  152:  op add :compute:zy *tmp64 :compute:cy                        ...
  153:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  154:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  155:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  156:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  157:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  158:  op mul *tmp60 :compute:zy :compute:zy                        ...
  159:  op sub *tmp61 *tmp59 *tmp60                                  ...
  160:  op add :compute:zx *tmp61 :compute:cx                        ...
  161:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  162:  op mul *tmp64 *tmp63 :compute:zy                             ...
  163:  op add :compute:zy *tmp64 :compute:cy                        ...
  164:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  165:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  166:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  167:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  168:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  169:  op mul *tmp60 :compute:zy :compute:zy                        ...
  170:  op sub *tmp61 *tmp59 *tmp60                                  ...
  171:  op add :compute:zx *tmp61 :compute:cx                        ...
  172:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  173:  op mul *tmp64 *tmp63 :compute:zy                             ...
  174:  op add :compute:zy *tmp64 :compute:cy                        ...
  175:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  176:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  177:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  178:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  179:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  180:  op mul *tmp60 :compute:zy :compute:zy                        ...
  181:  op sub *tmp61 *tmp59 *tmp60                                  ...
  182:  op add :compute:zx *tmp61 :compute:cx                        ...
  183:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  184:  op mul *tmp64 *tmp63 :compute:zy                             ...
  185:  op add :compute:zy *tmp64 :compute:cy                        ...
  186:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  187:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  188:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  189:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  190:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  191:  op mul *tmp60 :compute:zy :compute:zy                        ...
  192:  op sub *tmp61 *tmp59 *tmp60                                  ...
  193:  op add :compute:zx *tmp61 :compute:cx                        ...
  194:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  195:  op mul *tmp64 *tmp63 :compute:zy                             ...
  196:  op add :compute:zy *tmp64 :compute:cy                        ...
  197:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  198:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  199:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  200:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  201:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  202:  op mul *tmp60 :compute:zy :compute:zy                        ...
  203:  op sub *tmp61 *tmp59 *tmp60                                  ...
  204:  op add :compute:zx *tmp61 :compute:cx                        ...
  205:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  206:  op mul *tmp64 *tmp63 :compute:zy                             ...
  207:  op add :compute:zy *tmp64 :compute:cy                        ...
  208:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  209:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  210:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  211:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  212:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  213:  op mul *tmp60 :compute:zy :compute:zy                        ...
  214:  op sub *tmp61 *tmp59 *tmp60                                  ...
  215:  op add :compute:zx *tmp61 :compute:cx                        ...
  216:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  217:  op mul *tmp64 *tmp63 :compute:zy                             ...
  218:  op add :compute:zy *tmp64 :compute:cy                        ...
  219:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  220:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  221:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  222:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  223:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  224:  op mul *tmp60 :compute:zy :compute:zy                        ...
  225:  op sub *tmp61 *tmp59 *tmp60                                  ...
  226:  op add :compute:zx *tmp61 :compute:cx                        ...
  227:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  228:  op mul *tmp64 *tmp63 :compute:zy                             ...
  229:  op add :compute:zy *tmp64 :compute:cy                        ...
  230:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  231:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  232:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  233:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  234:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  235:  op mul *tmp60 :compute:zy :compute:zy                        ...
  236:  op sub *tmp61 *tmp59 *tmp60                                  ...
  237:  op add :compute:zx *tmp61 :compute:cx                        ...
  238:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  239:  op mul *tmp64 *tmp63 :compute:zy                             ...
  240:  op add :compute:zy *tmp64 :compute:cy                        ...
  241:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  242:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  243:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  244:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  245:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  246:  op mul *tmp60 :compute:zy :compute:zy                        ...
  247:  op sub *tmp61 *tmp59 *tmp60                                  ...
  248:  op add :compute:zx *tmp61 :compute:cx                        ...
  249:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  250:  op mul *tmp64 *tmp63 :compute:zy                             ...
  251:  op add :compute:zy *tmp64 :compute:cy                        ...
  252:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  253:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  254:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  255:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  256:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  257:  op mul *tmp60 :compute:zy :compute:zy                        ...
  258:  op sub *tmp61 *tmp59 *tmp60                                  ...
  259:  op add :compute:zx *tmp61 :compute:cx                        ...
  260:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  261:  op mul *tmp64 *tmp63 :compute:zy                             ...
  262:  op add :compute:zy *tmp64 :compute:cy                        ...
  263:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  264:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  265:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  266:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  267:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  268:  op mul *tmp60 :compute:zy :compute:zy                        ...
  269:  op sub *tmp61 *tmp59 *tmp60                                  ...
  270:  op add :compute:zx *tmp61 :compute:cx                        ...
  271:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  272:  op mul *tmp64 *tmp63 :compute:zy                             ...
  273:  op add :compute:zy *tmp64 :compute:cy                        ...
  274:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  275:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  276:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  277:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  278:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  279:  op mul *tmp60 :compute:zy :compute:zy                        ...
  280:  op sub *tmp61 *tmp59 *tmp60                                  ...
  281:  op add :compute:zx *tmp61 :compute:cx                        ...
  282:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  283:  op mul *tmp64 *tmp63 :compute:zy                             ...
  284:  op add :compute:zy *tmp64 :compute:cy                        ...
  285:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  286:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  287:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  288:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  289:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  290:  op mul *tmp60 :compute:zy :compute:zy                        ...
  291:  op sub *tmp61 *tmp59 *tmp60                                  ...
  292:  op add :compute:zx *tmp61 :compute:cx                        ...
  293:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  294:  op mul *tmp64 *tmp63 :compute:zy                             ...
  295:  op add :compute:zy *tmp64 :compute:cy                        ...
  296:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  297:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  298:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  299:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  300:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  301:  op mul *tmp60 :compute:zy :compute:zy                        ...
  302:  op sub *tmp61 *tmp59 *tmp60                                  ...
  303:  op add :compute:zx *tmp61 :compute:cx                        ...
  304:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  305:  op mul *tmp64 *tmp63 :compute:zy                             ...
  306:  op add :compute:zy *tmp64 :compute:cy                        ...
  307:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  308:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  309:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  310:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  311:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  312:  op mul *tmp60 :compute:zy :compute:zy                        ...
  313:  op sub *tmp61 *tmp59 *tmp60                                  ...
  314:  op add :compute:zx *tmp61 :compute:cx                        ...
  315:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  316:  op mul *tmp64 *tmp63 :compute:zy                             ...
  317:  op add :compute:zy *tmp64 :compute:cy                        ...
  318:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  319:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  320:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  321:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  322:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  323:  op mul *tmp60 :compute:zy :compute:zy                        ...
  324:  op sub *tmp61 *tmp59 *tmp60                                  ...
  325:  op add :compute:zx *tmp61 :compute:cx                        ...
  326:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  327:  op mul *tmp64 *tmp63 :compute:zy                             ...
  328:  op add :compute:zy *tmp64 :compute:cy                        ...
  329:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  330:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  331:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  332:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  333:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  334:  op mul *tmp60 :compute:zy :compute:zy                        ...
  335:  op sub *tmp61 *tmp59 *tmp60                                  ...
  336:  op add :compute:zx *tmp61 :compute:cx                        ...
  337:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  338:  op mul *tmp64 *tmp63 :compute:zy                             ...
  339:  op add :compute:zy *tmp64 :compute:cy                        ...
  340:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  341:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  342:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  343:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  344:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  345:  op mul *tmp60 :compute:zy :compute:zy                        ...
  346:  op sub *tmp61 *tmp59 *tmp60                                  ...
  347:  op add :compute:zx *tmp61 :compute:cx                        ...
  348:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  349:  op mul *tmp64 *tmp63 :compute:zy                             ...
  350:  op add :compute:zy *tmp64 :compute:cy                        ...
  351:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  352:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  353:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  354:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  355:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  356:  op mul *tmp60 :compute:zy :compute:zy                        ...
  357:  op sub *tmp61 *tmp59 *tmp60                                  ...
  358:  op add :compute:zx *tmp61 :compute:cx                        ...
  359:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  360:  op mul *tmp64 *tmp63 :compute:zy                             ...
  361:  op add :compute:zy *tmp64 :compute:cy                        ...
  362:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  363:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  364:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  365:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  366:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  367:  op mul *tmp60 :compute:zy :compute:zy                        ...
  368:  op sub *tmp61 *tmp59 *tmp60                                  ...
  369:  op add :compute:zx *tmp61 :compute:cx                        ...
  370:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  371:  op mul *tmp64 *tmp63 :compute:zy                             ...
  372:  op add :compute:zy *tmp64 :compute:cy                        ...
  373:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  374:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  375:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  376:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  377:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  378:  op mul *tmp60 :compute:zy :compute:zy                        ...
  379:  op sub *tmp61 *tmp59 *tmp60                                  ...
  380:  op add :compute:zx *tmp61 :compute:cx                        ...
  381:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  382:  op mul *tmp64 *tmp63 :compute:zy                             ...
  383:  op add :compute:zy *tmp64 :compute:cy                        ...
  384:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  385:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  386:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  387:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  388:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  389:  op mul *tmp60 :compute:zy :compute:zy                        ...
  390:  op sub *tmp61 *tmp59 *tmp60                                  ...
  391:  op add :compute:zx *tmp61 :compute:cx                        ...
  392:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  393:  op mul *tmp64 *tmp63 :compute:zy                             ...
  394:  op add :compute:zy *tmp64 :compute:cy                        ...
  395:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  396:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  397:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  398:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  399:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  400:  op mul *tmp60 :compute:zy :compute:zy                        ...
  401:  op sub *tmp61 *tmp59 *tmp60                                  ...
  402:  op add :compute:zx *tmp61 :compute:cx                        ...
  403:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  404:  op mul *tmp64 *tmp63 :compute:zy                             ...
  405:  op add :compute:zy *tmp64 :compute:cy                        ...
  406:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  407:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  408:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  409:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  410:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  411:  op mul *tmp60 :compute:zy :compute:zy                        ...
  412:  op sub *tmp61 *tmp59 *tmp60                                  ...
  413:  op add :compute:zx *tmp61 :compute:cx                        ...
  414:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  415:  op mul *tmp64 *tmp63 :compute:zy                             ...
  416:  op add :compute:zy *tmp64 :compute:cy                        ...
  417:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  418:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  419:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  420:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  421:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  422:  op mul *tmp60 :compute:zy :compute:zy                        ...
  423:  op sub *tmp61 *tmp59 *tmp60                                  ...
  424:  op add :compute:zx *tmp61 :compute:cx                        ...
  425:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  426:  op mul *tmp64 *tmp63 :compute:zy                             ...
  427:  op add :compute:zy *tmp64 :compute:cy                        ...
  428:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  429:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  430:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  431:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  432:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  433:  op mul *tmp60 :compute:zy :compute:zy                        ...
  434:  op sub *tmp61 *tmp59 *tmp60                                  ...
  435:  op add :compute:zx *tmp61 :compute:cx                        ...
  436:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  437:  op mul *tmp64 *tmp63 :compute:zy                             ...
  438:  op add :compute:zy *tmp64 :compute:cy                        ...
  439:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  440:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  441:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  442:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  443:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  444:  op mul *tmp60 :compute:zy :compute:zy                        ...
  445:  op sub *tmp61 *tmp59 *tmp60                                  ...
  446:  op add :compute:zx *tmp61 :compute:cx                        ...
  447:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  448:  op mul *tmp64 *tmp63 :compute:zy                             ...
  449:  op add :compute:zy *tmp64 :compute:cy                        ...
  450:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  451:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  452:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  453:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  454:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  455:  op mul *tmp60 :compute:zy :compute:zy                        ...
  456:  op sub *tmp61 *tmp59 *tmp60                                  ...
  457:  op add :compute:zx *tmp61 :compute:cx                        ...
  458:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  459:  op mul *tmp64 *tmp63 :compute:zy                             ...
  460:  op add :compute:zy *tmp64 :compute:cy                        ...
  461:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  462:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  463:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  464:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  465:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  466:  op mul *tmp60 :compute:zy :compute:zy                        ...
  467:  op sub *tmp61 *tmp59 *tmp60                                  ...
  468:  op add :compute:zx *tmp61 :compute:cx                        ...
  469:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  470:  op mul *tmp64 *tmp63 :compute:zy                             ...
  471:  op add :compute:zy *tmp64 :compute:cy                        ...
  472:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  473:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  474:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  475:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  476:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  477:  op mul *tmp60 :compute:zy :compute:zy                        ...
  478:  op sub *tmp61 *tmp59 *tmp60                                  ...
  479:  op add :compute:zx *tmp61 :compute:cx                        ...
  480:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  481:  op mul *tmp64 *tmp63 :compute:zy                             ...
  482:  op add :compute:zy *tmp64 :compute:cy                        ...
  483:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  484:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  485:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  486:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  487:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  488:  op mul *tmp60 :compute:zy :compute:zy                        ...
  489:  op sub *tmp61 *tmp59 *tmp60                                  ...
  490:  op add :compute:zx *tmp61 :compute:cx                        ...
  491:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  492:  op mul *tmp64 *tmp63 :compute:zy                             ...
  493:  op add :compute:zy *tmp64 :compute:cy                        ...
  494:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  495:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  496:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  497:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  498:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  499:  op mul *tmp60 :compute:zy :compute:zy                        ...
  500:  op sub *tmp61 *tmp59 *tmp60                                  ...
  501:  op add :compute:zx *tmp61 :compute:cx                        ...
  502:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  503:  op mul *tmp64 *tmp63 :compute:zy                             ...
  504:  op add :compute:zy *tmp64 :compute:cy                        ...
  505:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  506:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  507:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  508:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  509:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  510:  op mul *tmp60 :compute:zy :compute:zy                        ...
  511:  op sub *tmp61 *tmp59 *tmp60                                  ...
  512:  op add :compute:zx *tmp61 :compute:cx                        ...
  513:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  514:  op mul *tmp64 *tmp63 :compute:zy                             ...
  515:  op add :compute:zy *tmp64 :compute:cy                        ...
  516:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  517:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  518:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  519:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  520:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  521:  op mul *tmp60 :compute:zy :compute:zy                        ...
  522:  op sub *tmp61 *tmp59 *tmp60                                  ...
  523:  op add :compute:zx *tmp61 :compute:cx                        ...
  524:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  525:  op mul *tmp64 *tmp63 :compute:zy                             ...
  526:  op add :compute:zy *tmp64 :compute:cy                        ...
  527:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  528:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  529:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  530:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  531:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  532:  op mul *tmp60 :compute:zy :compute:zy                        ...
  533:  op sub *tmp61 *tmp59 *tmp60                                  ...
  534:  op add :compute:zx *tmp61 :compute:cx                        ...
  535:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  536:  op mul *tmp64 *tmp63 :compute:zy                             ...
  537:  op add :compute:zy *tmp64 :compute:cy                        ...
  538:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  539:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  540:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  541:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  542:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  543:  op mul *tmp60 :compute:zy :compute:zy                        ...
  544:  op sub *tmp61 *tmp59 *tmp60                                  ...
  545:  op add :compute:zx *tmp61 :compute:cx                        ...
  546:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  547:  op mul *tmp64 *tmp63 :compute:zy                             ...
  548:  op add :compute:zy *tmp64 :compute:cy                        ...
  549:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  550:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  551:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  552:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  553:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  554:  op mul *tmp60 :compute:zy :compute:zy                        ...
  555:  op sub *tmp61 *tmp59 *tmp60                                  ...
  556:  op add :compute:zx *tmp61 :compute:cx                        ...
  557:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  558:  op mul *tmp64 *tmp63 :compute:zy                             ...
  559:  op add :compute:zy *tmp64 :compute:cy                        ...
  560:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  561:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  562:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  563:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  564:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  565:  op mul *tmp60 :compute:zy :compute:zy                        ...
  566:  op sub *tmp61 *tmp59 *tmp60                                  ...
  567:  op add :compute:zx *tmp61 :compute:cx                        ...
  568:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  569:  op mul *tmp64 *tmp63 :compute:zy                             ...
  570:  op add :compute:zy *tmp64 :compute:cy                        ...
  571:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  572:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  573:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  574:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  575:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  576:  op mul *tmp60 :compute:zy :compute:zy                        ...
  577:  op sub *tmp61 *tmp59 *tmp60                                  ...
  578:  op add :compute:zx *tmp61 :compute:cx                        ...
  579:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  580:  op mul *tmp64 *tmp63 :compute:zy                             ...
  581:  op add :compute:zy *tmp64 :compute:cy                        ...
  582:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  583:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  584:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  585:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  586:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  587:  op mul *tmp60 :compute:zy :compute:zy                        ...
  588:  op sub *tmp61 *tmp59 *tmp60                                  ...
  589:  op add :compute:zx *tmp61 :compute:cx                        ...
  590:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  591:  op mul *tmp64 *tmp63 :compute:zy                             ...
  592:  op add :compute:zy *tmp64 :compute:cy                        ...
  593:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  594:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  595:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  596:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  597:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  598:  op mul *tmp60 :compute:zy :compute:zy                        ...
  599:  op sub *tmp61 *tmp59 *tmp60                                  ...
  600:  op add :compute:zx *tmp61 :compute:cx                        ...
  601:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  602:  op mul *tmp64 *tmp63 :compute:zy                             ...
  603:  op add :compute:zy *tmp64 :compute:cy                        ...
  604:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  605:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  606:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  607:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  608:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  609:  op mul *tmp60 :compute:zy :compute:zy                        ...
  610:  op sub *tmp61 *tmp59 *tmp60                                  ...
  611:  op add :compute:zx *tmp61 :compute:cx                        ...
  612:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  613:  op mul *tmp64 *tmp63 :compute:zy                             ...
  614:  op add :compute:zy *tmp64 :compute:cy                        ...
  615:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  616:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  617:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  618:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  619:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  620:  op mul *tmp60 :compute:zy :compute:zy                        ...
  621:  op sub *tmp61 *tmp59 *tmp60                                  ...
  622:  op add :compute:zx *tmp61 :compute:cx                        ...
  623:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  624:  op mul *tmp64 *tmp63 :compute:zy                             ...
  625:  op add :compute:zy *tmp64 :compute:cy                        ...
  626:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  627:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  628:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  629:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  630:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  631:  op mul *tmp60 :compute:zy :compute:zy                        ...
  632:  op sub *tmp61 *tmp59 *tmp60                                  ...
  633:  op add :compute:zx *tmp61 :compute:cx                        ...
  634:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  635:  op mul *tmp64 *tmp63 :compute:zy                             ...
  636:  op add :compute:zy *tmp64 :compute:cy                        ...
  637:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  638:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  639:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  640:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  641:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  642:  op mul *tmp60 :compute:zy :compute:zy                        ...
  643:  op sub *tmp61 *tmp59 *tmp60                                  ...
  644:  op add :compute:zx *tmp61 :compute:cx                        ...
  645:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  646:  op mul *tmp64 *tmp63 :compute:zy                             ...
  647:  op add :compute:zy *tmp64 :compute:cy                        ...
  648:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  649:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  650:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  651:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  652:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  653:  op mul *tmp60 :compute:zy :compute:zy                        ...
  654:  op sub *tmp61 *tmp59 *tmp60                                  ...
  655:  op add :compute:zx *tmp61 :compute:cx                        ...
  656:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  657:  op mul *tmp64 *tmp63 :compute:zy                             ...
  658:  op add :compute:zy *tmp64 :compute:cy                        ...
  659:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  660:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  661:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  662:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  663:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  664:  op mul *tmp60 :compute:zy :compute:zy                        ...
  665:  op sub *tmp61 *tmp59 *tmp60                                  ...
  666:  op add :compute:zx *tmp61 :compute:cx                        ...
  667:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  668:  op mul *tmp64 *tmp63 :compute:zy                             ...
  669:  op add :compute:zy *tmp64 :compute:cy                        ...
  670:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  671:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  672:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  673:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  674:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  675:  op mul *tmp60 :compute:zy :compute:zy                        ...
  676:  op sub *tmp61 *tmp59 *tmp60                                  ...
  677:  op add :compute:zx *tmp61 :compute:cx                        ...
  678:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  679:  op mul *tmp64 *tmp63 :compute:zy                             ...
  680:  op add :compute:zy *tmp64 :compute:cy                        ...
  681:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  682:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  683:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  684:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  685:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  686:  op mul *tmp60 :compute:zy :compute:zy                        ...
  687:  op sub *tmp61 *tmp59 *tmp60                                  ...
  688:  op add :compute:zx *tmp61 :compute:cx                        ...
  689:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  690:  op mul *tmp64 *tmp63 :compute:zy                             ...
  691:  op add :compute:zy *tmp64 :compute:cy                        ...
  692:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  693:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  694:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  695:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  696:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  697:  op mul *tmp60 :compute:zy :compute:zy                        ...
  698:  op sub *tmp61 *tmp59 *tmp60                                  ...
  699:  op add :compute:zx *tmp61 :compute:cx                        ...
  700:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  701:  op mul *tmp64 *tmp63 :compute:zy                             ...
  702:  op add :compute:zy *tmp64 :compute:cy                        ...
  703:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  704:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  705:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  706:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  707:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  708:  op mul *tmp60 :compute:zy :compute:zy                        ...
  709:  op sub *tmp61 *tmp59 *tmp60                                  ...
  710:  op add :compute:zx *tmp61 :compute:cx                        ...
  711:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  712:  op mul *tmp64 *tmp63 :compute:zy                             ...
  713:  op add :compute:zy *tmp64 :compute:cy                        ...
  714:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  715:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  716:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  717:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  718:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  719:  op mul *tmp60 :compute:zy :compute:zy                        ...
  720:  op sub *tmp61 *tmp59 *tmp60                                  ...
  721:  op add :compute:zx *tmp61 :compute:cx                        ...
  722:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  723:  op mul *tmp64 *tmp63 :compute:zy                             ...
  724:  op add :compute:zy *tmp64 :compute:cy                        ...
  725:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  726:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  727:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  728:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  729:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  730:  op mul *tmp60 :compute:zy :compute:zy                        ...
  731:  op sub *tmp61 *tmp59 *tmp60                                  ...
  732:  op add :compute:zx *tmp61 :compute:cx                        ...
  733:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  734:  op mul *tmp64 *tmp63 :compute:zy                             ...
  735:  op add :compute:zy *tmp64 :compute:cy                        ...
  736:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  737:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  738:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  739:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  740:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  741:  op mul *tmp60 :compute:zy :compute:zy                        ...
  742:  op sub *tmp61 *tmp59 *tmp60                                  ...
  743:  op add :compute:zx *tmp61 :compute:cx                        ...
  744:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  745:  op mul *tmp64 *tmp63 :compute:zy                             ...
  746:  op add :compute:zy *tmp64 :compute:cy                        ...
  747:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  748:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  749:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  750:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  751:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  752:  op mul *tmp60 :compute:zy :compute:zy                        ...
  753:  op sub *tmp61 *tmp59 *tmp60                                  ...
  754:  op add :compute:zx *tmp61 :compute:cx                        ...
  755:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  756:  op mul *tmp64 *tmp63 :compute:zy                             ...
  757:  op add :compute:zy *tmp64 :compute:cy                        ...
  758:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  759:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  760:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  761:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  762:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  763:  op mul *tmp60 :compute:zy :compute:zy                        ...
  764:  op sub *tmp61 *tmp59 *tmp60                                  ...
  765:  op add :compute:zx *tmp61 :compute:cx                        ...
  766:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  767:  op mul *tmp64 *tmp63 :compute:zy                             ...
  768:  op add :compute:zy *tmp64 :compute:cy                        ...
  769:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  770:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  771:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  772:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  773:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  774:  op mul *tmp60 :compute:zy :compute:zy                        ...
  775:  op sub *tmp61 *tmp59 *tmp60                                  ...
  776:  op add :compute:zx *tmp61 :compute:cx                        ...
  777:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  778:  op mul *tmp64 *tmp63 :compute:zy                             ...
  779:  op add :compute:zy *tmp64 :compute:cy                        ...
  780:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  781:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  782:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  783:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  784:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  785:  op mul *tmp60 :compute:zy :compute:zy                        ...
  786:  op sub *tmp61 *tmp59 *tmp60                                  ...
  787:  op add :compute:zx *tmp61 :compute:cx                        ...
  788:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  789:  op mul *tmp64 *tmp63 :compute:zy                             ...
  790:  op add :compute:zy *tmp64 :compute:cy                        ...
  791:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  792:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  793:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  794:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  795:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  796:  op mul *tmp60 :compute:zy :compute:zy                        ...
  797:  op sub *tmp61 *tmp59 *tmp60                                  ...
  798:  op add :compute:zx *tmp61 :compute:cx                        ...
  799:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  800:  op mul *tmp64 *tmp63 :compute:zy                             ...
  801:  op add :compute:zy *tmp64 :compute:cy                        ...
  802:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  803:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  804:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label56                                               ...
  805:  op mul *tmp69 .SMOOTH 63                                     mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  806:  jump *label59 greaterThanEq :compute:i *tmp69                ...
  807:  op log *tmp72 :compute:dist 0                                mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  808:  op mul *tmp73 *tmp72 0.36067376022224085                     ...
  809:  op log *tmp74 *tmp73 0                                       ...
  810:  op mul *tmp75 *tmp74 1.4426950408889634                      ...
  811:  op sub :compute:correction 4 *tmp75                          ...
  812:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label59                                               mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  813:  set *tmp41 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label47                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  814:  set :drawPixel:y :y                                          mandelbrot-compute.mnd: drawPixel(x, y, iterations);
  815:  set :drawPixel:iterations *tmp41                             ...
  816:  call *label0 *invalid :drawPixel*retval                      ...
        label *label61                                               ...
  817:  read *tmp78 .memory :position                                mandelbrot-compute.mnd: if memory[position] != PROCESSOR_ID then
  818:  jump *label46 notEqual *tmp78 .PROCESSOR_ID                  ...
  819:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: if stop != $STOP then
  820:  jump *label31 notEqual .stop *tmp1                           ...
  821:  op add :y :y 1                                               mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
  822:  jump *label107 lessThan :y 176                               ...
        label *label46                                               ...
        label *label42                                               mandelbrot-compute.mnd: if memory[position] == 0 then
  823:  op add :line :line :increment                                mandelbrot-compute.mnd: line += increment;
  824:  jump *label66 lessThanEq :line 176                           mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  825:  op div :next_increment :next_increment 2                     mandelbrot-compute.mnd: increment = next_increment /= 2;
  826:  set :increment :next_increment                               ...
  827:  op div :line :next_increment 2                               mandelbrot-compute.mnd: line = increment / 2;
        label *label66                                               mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  828:  op add :lines :lines 1                                       mandelbrot-compute.mnd: for var lines in 0 ... DISPLAY_SIZE_LARGE do
  829:  jump *label106 lessThan :lines 176                           ...
        label *label399                                              mandelbrot-compute.mnd: do while !display.@enabled;
  830:  sensor *tmp144 .display @enabled                             ...
  831:  jump *label399 equal *tmp144 false                           ...
  832:  jump *label405 lessThanEq .localBuffer 4                     mandelbrot-compute.mnd: if localBuffer > 4 then
        label *label402                                              mandelbrot-compute.mnd: do
  833:  wait 0.0001                                                  mandelbrot-compute.mnd: wait(1e-4);
  834:  sensor *tmp148 .display @bufferSize                          mandelbrot-compute.mnd: while display.@bufferSize > 250;
  835:  jump *label402 greaterThan *tmp148 250                       mandelbrot-compute.mnd: do
        label *label405                                              mandelbrot-compute.mnd: if localBuffer > 4 then
  836:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  837:  jump *label31 always 0 0                                     mandelbrot-compute.mnd: MainLoop:
        label *label0                                                mandelbrot-compute.mnd: noinline void drawPixel(x, y, iterations)
  838:  jump *label70 equal .SMOOTH false                            mandelbrot-compute.mnd: if SMOOTH then
  839:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  840:  jump *label71 equal :drawPixel:iterations 63                 mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  841:  jump *label75 notEqual .PALETTE 2                            mandelbrot-compute.mnd: case PALETTE
  842:  op sub *tmp91 32 :drawPixel:iterations                       mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  843:  op abs *tmp92 *tmp91 0                                       ...
  844:  op div *tmp94 *tmp92 36.42857142857143                       ...
  845:  op sub :drawPixel:r 1 *tmp94                                 ...
  846:  op sub *tmp96 :drawPixel:iterations 32                       mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  847:  op abs *tmp97 *tmp96 0                                       ...
  848:  op div *tmp99 *tmp97 42.5                                    ...
  849:  op sub :drawPixel:g 0.9411764705882353 *tmp99                ...
  850:  op div *tmp104 *tmp92 63.75                                  mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  851:  op add :drawPixel:b 0.47058823529411764 *tmp104              ...
  852:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  853:  jump *label71 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label75                                               ...
  854:  jump *label77 notEqual .PALETTE 3                            ...
  855:  op div *tmp108 :drawPixel:iterations 0.175                   mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  856:  op sin :drawPixel:r *tmp108 0                                ...
  857:  op cos :drawPixel:g *tmp108 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  858:  op sub *tmp113 :drawPixel:iterations 32                      mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  859:  op abs *tmp114 *tmp113 0                                     ...
  860:  op div *tmp116 *tmp114 63.75                                 ...
  861:  op add :drawPixel:b 0.39215686274509803 *tmp116              ...
  862:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  863:  jump *label71 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label77                                               ...
  864:  jump *label79 notEqual .PALETTE 4                            ...
  865:  op div :drawPixel:r :drawPixel:iterations 63.75              mandelbrot-compute.mnd: r = 4 * iterations / 255;
  866:  op div *tmp122 :drawPixel:iterations 170                     mandelbrot-compute.mnd: g = 96 + 1.5 * iterations / 255;
  867:  op add :drawPixel:g 96 *tmp122                               ...
  868:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  869:  jump *label71 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label79                                               ...
  870:  op div *tmp126 :drawPixel:iterations 63.75                   mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  871:  op sub :drawPixel:r 1 *tmp126                                ...
  872:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  873:  jump *label71 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label70                                               ...
  874:  read :drawPixel:color .memory :drawPixel:iterations          mandelbrot-compute.mnd: color = memory[iterations];
        label *label71                                               mandelbrot-compute.mnd: if SMOOTH then
  875:  jump *label81 lessThan .localBuffer 254                      mandelbrot-compute.mnd: if localBuffer >= 254 then
        label *label409                                              mandelbrot-compute.mnd: do while !display.@enabled;
  876:  sensor *tmp144 .display @enabled                             ...
  877:  jump *label409 equal *tmp144 false                           ...
  878:  jump *label415 lessThanEq .localBuffer 4                     mandelbrot-compute.mnd: if localBuffer > 4 then
        label *label412                                              mandelbrot-compute.mnd: do
  879:  wait 0.0001                                                  mandelbrot-compute.mnd: wait(1e-4);
  880:  sensor *tmp148 .display @bufferSize                          mandelbrot-compute.mnd: while display.@bufferSize > 250;
  881:  jump *label412 greaterThan *tmp148 250                       mandelbrot-compute.mnd: do
        label *label415                                              mandelbrot-compute.mnd: if localBuffer > 4 then
  882:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  883:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
        label *label81                                               mandelbrot-compute.mnd: if localBuffer >= 254 then
  884:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  885:  draw rect :drawPixel:x :drawPixel:y 1 1 0 0                  mandelbrot-compute.mnd: rect(x, y, 1, 1);
  886:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
  887:  sensor *tmp134 .display @enabled                             mandelbrot-compute.mnd: var disabled = 1 - display.enabled;
  888:  op sub :drawPixel:disabled 1 *tmp134                         ...
  889:  sensor *tmp136 .display @bufferSize                          mandelbrot-compute.mnd: var usage = display.@bufferSize + disabled * 900;
  890:  op mul *tmp137 :drawPixel:disabled 900                       ...
  891:  op add :drawPixel:usage *tmp136 *tmp137                      ...
  892:  jump *label84 greaterThanEq :drawPixel:usage 100             mandelbrot-compute.mnd: if usage < 100 then
  893:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  894:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
  895:  return :drawPixel*retaddr                                    mandelbrot-compute.mnd: if usage < 100 then
        label *label84                                               ...
  896:  op div *tmp141 1800 .localBuffer                             mandelbrot-compute.mnd: elsif usage < 1800 / localBuffer then
  897:  jump *label86 greaterThanEq :drawPixel:usage *tmp141         ...
  898:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  899:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
        label *label86                                               mandelbrot-compute.mnd: elsif usage < 1800 / localBuffer then
  900:  return :drawPixel*retaddr                                    mandelbrot-compute.mnd: noinline void drawPixel(x, y, iterations)


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   727     1x    727,0  def compute(in x, in y)
    56     1x     56,0  <no function>
    56     1x     56,0  noinline void drawPixel(in x, in y, in iterations)
    26     2x     13,0  void setState(in state)
    22     1x     22,0  inline void findLinkedBlocks(in title, in message, in linkMap...)
    15     2x      7,5  void flushLocalBuffer()

Performance: parsed in 278 ms, compiled in 287 ms, optimized in 2,039 ms, run in 41 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Display: display
Memory: bank
Execution step limit of 100000 exceeded.
