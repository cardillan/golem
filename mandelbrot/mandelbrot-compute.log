   362 instructions before optimizations.
    30 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    36 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 4 iterations).
    17 instructions eliminated by Jump Optimization (4 iterations).
    14 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     8 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
    53 instructions eliminated by Data Flow Optimization (5 passes, 20 iterations).
     3 instructions eliminated by Loop Optimization (3 iterations).
     5 loops improved by Loop Optimization.
   742 instructions added by Loop Unrolling (8 iterations).
     4 loops unrolled by Loop Unrolling.
     9 instructions added by Function Inlining (8 iterations).
     2 function calls inlined by Function Inlining.
    68 instructions eliminated by Jump Straightening (2 passes, 4 iterations).
     4 instructions updated by JumpThreading.
     5 instructions eliminated by Unreachable Code Elimination.
     6 instructions eliminated by Print Merging.
   869 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 783):
  * Unroll iteration loop at *blocks:59:9                        cost     0, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:68:13                       cost     0, benefit     9375.0, efficiency   Infinity
    Unroll iteration loop at *blocks:77:9                        cost     0, benefit      375.0, efficiency   Infinity
    Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 787):
  * Unroll iteration loop at *blocks:68:13                       cost     0, benefit     9375.0, efficiency   Infinity (-5 instructions)
    Unroll iteration loop at *blocks:77:9                        cost     0, benefit      375.0, efficiency   Infinity
    Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 792):
  * Unroll iteration loop at *blocks:77:9                        cost     0, benefit      375.0, efficiency   Infinity (+0 instructions)
    Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 792):
  * Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6 (+743 instructions)
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 49):
  * Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0 (+7 instructions)
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   281 set *tmp79 null
   282 jump *label63 always
   283 label *label62
-    * set *tmp81 .PALETTE
-    * jump *label66 equal *tmp81 2
+  284 jump *label66 equal .PALETTE 2
   285 jump *label65 always
   286 label *label66
   287 op sub *tmp82 32 :drawPixel.0:iterations
 
   303 set *tmp80 null
   304 jump *label64 always
   305 label *label65
-    * jump *label68 equal *tmp81 3
+  306 jump *label68 equal .PALETTE 3
   307 jump *label67 always
   308 label *label68
   309 op div *tmp94 :drawPixel.0:iterations 63
 
   325 set *tmp80 null
   326 jump *label64 always
   327 label *label67
-    * jump *label70 equal *tmp81 4
+  328 jump *label70 equal .PALETTE 4
   329 jump *label69 always
   330 label *label70
   331 op mul *tmp106 4 :drawPixel.0:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-24 instructions):
 
    65 label *label20
    66 set *tmp21 null
    67 label *label21
-    * set *tmp19 *tmp21
    68 jump *label19 always
    69 label *label18
-    * set *tmp19 null
    70 label *label19
    71 label *label14
    72 multijump *tmp17 0 0 marker1
 
    98 print :findLinkedBlocks.0:variable
    99 jump *label27 equal :findLinkedBlocks.0:required false
   100 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
-    * set *tmp23 :findLinkedBlocks.0:foundAll
   101 jump *label28 always
   102 label *label27
-    * set *tmp23 null
   103 label *label28
   104 label *label23
   105 multijump *tmp22 0 0 marker2
 
   185 jump *label46 equal .JULIA false
   186 set :compute.0:cx .JULIA_X
   187 set :compute.0:cy .JULIA_Y
-    * set *tmp46 :compute.0:cy
   188 jump *label47 always
   189 label *label46
   190 set :compute.0:cx :compute.0:zx
 
   200 jump *label48 equal *tmp53 false
   201 set *tmp41 63
   202 jump *label45 always
-    * set *tmp54 null
   203 jump *label49 always
   204 label *label48
-    * set *tmp54 null
   205 label *label49
   206 op add *tmp55 :compute.0:cx 1
   207 op len *tmp56 *tmp55 :compute.0:cy
 
   214 label *label50
   215 set *tmp58 null
   216 label *label51
-    * set *tmp46 *tmp58
   217 label *label47
   218 set :compute.0:i 0
   219 label *label52
 
   234 op greaterThanEq *tmp67 :compute.0:dist 64
   235 jump *label55 equal *tmp67 false
   236 jump *label54 always
-    * set *tmp68 null
   237 jump *label56 always
   238 label *label55
-    * set *tmp68 null
   239 label *label56
   240 label *label53
   241 op add :compute.0:i :compute.0:i 1
 
   251 op sub *tmp76 4 *tmp75
   252 set :compute.0:correction *tmp76
   253 op add :compute.0:i :compute.0:i :compute.0:correction
-    * set *tmp71 :compute.0:i
   254 jump *label58 always
   255 label *label57
-    * set *tmp71 null
   256 label *label58
   257 set *tmp41 :compute.0:i
   258 jump *label45 always
 
   333 label *label64
   334 set *tmp79 *tmp80
   335 label *label63
-    * set *tmp77 *tmp79
   336 jump *label61 always
   337 label *label60
   338 set *tmp111 :drawPixel.0:iterations
   339 read *tmp112 .memory *tmp111
   340 draw col *tmp112
-    * set *tmp77 null
   341 label *label61
   342 draw rect :drawPixel.0:x :drawPixel.0:y 1 1
   343 drawflush .display
 
   347 op notEqual *tmp115 *tmp114 .PROCESSOR_ID
   348 jump *label71 equal *tmp115 false
   349 jump *label44 always
-    * set *tmp116 null
   350 jump *label72 always
   351 label *label71
-    * set *tmp116 null
   352 label *label72
   353 read *tmp1 .memory 65
   354 op notEqual *tmp117 .stop *tmp1
   355 jump *label73 equal *tmp117 false
   356 jump *label39 always
-    * set *tmp118 null
   357 jump *label74 always
   358 label *label73
-    * set *tmp118 null
   359 label *label74
   360 label *label43
   361 op add :y :y 1
   362 jump *label42 always
   363 label *label44
-    * set *tmp38 null
   364 jump *label41 always
   365 label *label40
-    * set *tmp38 null
   366 label *label41
   367 op add :line :line :increment
   368 op greaterThan *tmp119 :line 176
 
   371 set :increment :next_increment
   372 op div *tmp121 :increment 2
   373 set :line *tmp121
-    * set *tmp120 :line
   374 jump *label76 always
   375 label *label75
-    * set *tmp120 null
   376 label *label76
   377 label *label38
   378 op add :lines :lines 1
 
   394 set *tmp127 .PROC_STATE_INDEX
   395 write :setState.0:state .memory *tmp127
   396 jump *label80 always
-    * set *tmp126 null
   397 jump *label82 always
   398 label *label81
   399 set *tmp129 .PROC_ID_INDEX
 
   412 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
   413 set *tmp132 .PROC_STATE_INDEX
   414 label *label84
-    * set *tmp126 *tmp132
   415 label *label82
   416 label *label79
   417 jump *label78 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-8 instructions):
 
    60 op equal *tmp20 :findLinkedBlocks.0:requested @message
    61 jump *label20 equal *tmp20 false
    62 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
-    * set *tmp21 :findLinkedBlocks.0:message
    63 jump *label21 always
    64 label *label20
-    * set *tmp21 null
    65 label *label21
    66 jump *label19 always
    67 label *label18
 
   207 jump *label50 equal *tmp57 false
   208 set *tmp41 63
   209 jump *label45 always
-    * set *tmp58 null
   210 jump *label51 always
   211 label *label50
-    * set *tmp58 null
   212 label *label51
   213 label *label47
   214 set :compute.0:i 0
 
   262 op equal *tmp78 :drawPixel.0:iterations 63
   263 jump *label62 equal *tmp78 false
   264 draw color 0 0 0 255
-    * set *tmp79 null
   265 jump *label63 always
   266 label *label62
   267 jump *label66 equal .PALETTE 2
 
   326 draw color :drawPixel.0:r :drawPixel.0:r 0 255
   327 set *tmp80 null
   328 label *label64
-    * set *tmp79 *tmp80
   329 label *label63
   330 jump *label61 always
   331 label *label60
 
   399 set *tmp135 .PROC_STATE_INDEX
   400 write :setState.0:state .memory *tmp135
   401 jump *label80 always
-    * set *tmp132 null
   402 jump *label84 always
   403 label *label83
   404 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   405 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * set *tmp132 .PROC_STATE_INDEX
   406 label *label84
   407 label *label82
   408 label *label79

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   283 op add *tmp93 120 *tmp92
   284 set :drawPixel.0:b *tmp93
   285 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
-    * set *tmp80 null
   286 jump *label64 always
   287 label *label65
   288 jump *label68 equal .PALETTE 3
 
   304 op add *tmp105 100 *tmp104
   305 set :drawPixel.0:b *tmp105
   306 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
-    * set *tmp80 null
   307 jump *label64 always
   308 label *label67
   309 jump *label70 equal .PALETTE 4
 
   315 op add *tmp108 96 *tmp107
   316 set :drawPixel.0:g *tmp108
   317 draw color :drawPixel.0:r :drawPixel.0:g 0 255
-    * set *tmp80 null
   318 jump *label64 always
   319 label *label69
   320 op mul *tmp109 4 :drawPixel.0:iterations
   321 op sub *tmp110 255 *tmp109
   322 set :drawPixel.0:r *tmp110
   323 draw color :drawPixel.0:r :drawPixel.0:r 0 255
-    * set *tmp80 null
   324 label *label64
   325 label *label63
   326 jump *label61 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-30 instructions):
     0 sensor *tmp9 @this @x
     1 sensor *tmp10 @this @y
     2 op mul *tmp11 10000 *tmp10
-    * op add *tmp12 *tmp9 *tmp11
-    * set .PROCESSOR_ID *tmp12
+    3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
 
    33 op greaterThan *tmp14 :findLinkedBlocks.0:n 0
    34 jump *label12 equal *tmp14 false
    35 op sub :findLinkedBlocks.0:n :findLinkedBlocks.0:n 1
-    * getlink *tmp15 :findLinkedBlocks.0:n
-    * set :findLinkedBlocks.0:block *tmp15
+   36 getlink :findLinkedBlocks.0:block :findLinkedBlocks.0:n
    37 print "\nFound: "
    38 print :findLinkedBlocks.0:block
-    * sensor *tmp16 :findLinkedBlocks.0:block @type
-    * set :findLinkedBlocks.0:type *tmp16
+   39 sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @type
    40 setaddr *tmp17 *label16
    41 set :findLinkedBlocks.0:requested @large-logic-display
    42 set :findLinkedBlocks.0:name "Display"
 
   127 setaddr :setState.0*retaddr *label36
   128 call *label0 :setState.0*retval
   129 label *label36
-    * read *tmp4 .memory 68
-    * set .ZOOM *tmp4
+  130 read .ZOOM .memory 68
   131 op div *tmp26 -88 .ZOOM
   132 read *tmp2 .memory 66
-    * op add *tmp27 *tmp26 *tmp2
-    * set .OFFSET_X *tmp27
+  133 op add .OFFSET_X *tmp26 *tmp2
   134 op div *tmp28 -88 .ZOOM
   135 read *tmp3 .memory 67
-    * op add *tmp29 *tmp28 *tmp3
-    * set .OFFSET_Y *tmp29
-    * read *tmp5 .memory 69
-    * set .JULIA *tmp5
-    * read *tmp6 .memory 70
-    * set .JULIA_X *tmp6
-    * read *tmp7 .memory 71
-    * set .JULIA_Y *tmp7
-    * read *tmp8 .memory 72
-    * set .PALETTE *tmp8
-    * op greaterThan *tmp30 .PALETTE 1
-    * set .SMOOTH *tmp30
+  136 op add .OFFSET_Y *tmp28 *tmp3
+  137 read .JULIA .memory 69
+  138 read .JULIA_X .memory 70
+  139 read .JULIA_Y .memory 71
+  140 read .PALETTE .memory 72
+  141 op greaterThan .SMOOTH .PALETTE 1
   142 set :line 8
   143 set :increment 8
   144 set :next_increment 16
 
   148 label *label37
   149 jump *label39 greaterThanEq :lines 176
   150 op mul *tmp32 17 :line
-    * op mod *tmp33 *tmp32 176
-    * set :x *tmp33
-    * op add *tmp34 :x 158
-    * set :position *tmp34
+  151 op mod :x *tmp32 176
+  152 op add :position :x 158
   153 set *tmp35 :position
   154 read *tmp36 .memory *tmp35
   155 op equal *tmp37 *tmp36 0
 
   162 set :compute.0:x :x
   163 set :compute.0:y :y
   164 op div *tmp42 :compute.0:x .ZOOM
-    * op add *tmp43 *tmp42 .OFFSET_X
-    * set :compute.0:zx *tmp43
+  165 op add :compute.0:zx *tmp42 .OFFSET_X
   166 op div *tmp44 :compute.0:y .ZOOM
-    * op add *tmp45 *tmp44 .OFFSET_Y
-    * set :compute.0:zy *tmp45
+  167 op add :compute.0:zy *tmp44 .OFFSET_Y
   168 jump *label46 equal .JULIA false
   169 set :compute.0:cx .JULIA_X
   170 set :compute.0:cy .JULIA_Y
 
   173 set :compute.0:cx :compute.0:zx
   174 set :compute.0:cy :compute.0:zy
   175 op sub *tmp47 :compute.0:cx 0.25
-    * op len *tmp48 *tmp47 :compute.0:cy
-    * set :compute.0:p *tmp48
+  176 op len :compute.0:p *tmp47 :compute.0:cy
   177 op mul *tmp49 2 :compute.0:p
   178 op mul *tmp50 *tmp49 :compute.0:p
   179 op sub *tmp51 :compute.0:p *tmp50
 
   203 op mul *tmp59 :compute.0:x1 :compute.0:x1
   204 op mul *tmp60 :compute.0:y1 :compute.0:y1
   205 op sub *tmp61 *tmp59 *tmp60
-    * op add *tmp62 *tmp61 :compute.0:cx
-    * set :compute.0:zx *tmp62
+  206 op add :compute.0:zx *tmp61 :compute.0:cx
   207 op mul *tmp63 2 :compute.0:x1
   208 op mul *tmp64 *tmp63 :compute.0:y1
-    * op add *tmp65 *tmp64 :compute.0:cy
-    * set :compute.0:zy *tmp65
-    * op len *tmp66 :compute.0:zx :compute.0:zy
-    * set :compute.0:dist *tmp66
+  209 op add :compute.0:zy *tmp64 :compute.0:cy
+  210 op len :compute.0:dist :compute.0:zx :compute.0:zy
   211 op greaterThanEq *tmp67 :compute.0:dist 64
   212 jump *label55 equal *tmp67 false
   213 jump *label54 always
 
   225 op mul *tmp73 *tmp72 0.36067376022224085
   226 op log *tmp74 *tmp73
   227 op mul *tmp75 *tmp74 1.4426950408889634
-    * op sub *tmp76 4 *tmp75
-    * set :compute.0:correction *tmp76
+  228 op sub :compute.0:correction 4 *tmp75
   229 op add :compute.0:i :compute.0:i :compute.0:correction
   230 jump *label58 always
   231 label *label57
 
   250 op sub *tmp82 32 :drawPixel.0:iterations
   251 op abs *tmp83 *tmp82
   252 op mul *tmp84 7 *tmp83
-    * op sub *tmp85 255 *tmp84
-    * set :drawPixel.0:r *tmp85
+  253 op sub :drawPixel.0:r 255 *tmp84
   254 op sub *tmp86 :drawPixel.0:iterations 32
   255 op abs *tmp87 *tmp86
   256 op mul *tmp88 6 *tmp87
-    * op sub *tmp89 240 *tmp88
-    * set :drawPixel.0:g *tmp89
+  257 op sub :drawPixel.0:g 240 *tmp88
   258 op sub *tmp90 32 :drawPixel.0:iterations
   259 op abs *tmp91 *tmp90
   260 op mul *tmp92 4 *tmp91
-    * op add *tmp93 120 *tmp92
-    * set :drawPixel.0:b *tmp93
+  261 op add :drawPixel.0:b 120 *tmp92
   262 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   263 jump *label64 always
   264 label *label65
 
   268 op div *tmp94 :drawPixel.0:iterations 63
   269 op mul *tmp95 *tmp94 360
   270 op sin *tmp96 *tmp95
-    * op mul *tmp97 255 *tmp96
-    * set :drawPixel.0:r *tmp97
+  271 op mul :drawPixel.0:r 255 *tmp96
   272 op div *tmp98 :drawPixel.0:iterations 63
   273 op mul *tmp99 *tmp98 360
   274 op cos *tmp100 *tmp99
-    * op mul *tmp101 255 *tmp100
-    * set :drawPixel.0:g *tmp101
+  275 op mul :drawPixel.0:g 255 *tmp100
   276 op sub *tmp102 :drawPixel.0:iterations 32
   277 op abs *tmp103 *tmp102
   278 op mul *tmp104 4 *tmp103
-    * op add *tmp105 100 *tmp104
-    * set :drawPixel.0:b *tmp105
+  279 op add :drawPixel.0:b 100 *tmp104
   280 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   281 jump *label64 always
   282 label *label67
   283 jump *label70 equal .PALETTE 4
   284 jump *label69 always
   285 label *label70
-    * op mul *tmp106 4 :drawPixel.0:iterations
-    * set :drawPixel.0:r *tmp106
+  286 op mul :drawPixel.0:r 4 :drawPixel.0:iterations
   287 op mul *tmp107 1.5 :drawPixel.0:iterations
-    * op add *tmp108 96 *tmp107
-    * set :drawPixel.0:g *tmp108
+  288 op add :drawPixel.0:g 96 *tmp107
   289 draw color :drawPixel.0:r :drawPixel.0:g 0 255
   290 jump *label64 always
   291 label *label69
   292 op mul *tmp109 4 :drawPixel.0:iterations
-    * op sub *tmp110 255 *tmp109
-    * set :drawPixel.0:r *tmp110
+  293 op sub :drawPixel.0:r 255 *tmp109
   294 draw color :drawPixel.0:r :drawPixel.0:r 0 255
   295 label *label64
   296 label *label63
 
   330 jump *label75 equal *tmp119 false
   331 op div :next_increment :next_increment 2
   332 set :increment :next_increment
-    * op div *tmp121 :increment 2
-    * set :line *tmp121
+  333 op div :line :increment 2
   334 jump *label76 always
   335 label *label75
   336 label *label76

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
   108 label *label4
   109 label *label1
   110 label *label29
-    * jump *label31 equal true false
   111 label *label32
   112 set :setState.0:state 0
   113 setaddr :setState.0*retaddr *label35

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   243 draw color 0 0 0 255
   244 jump *label63 always
   245 label *label62
-    * jump *label66 equal .PALETTE 2
-    * jump *label65 always
+  246 jump *label65 notEqual .PALETTE 2
   247 label *label66
   248 op sub *tmp82 32 :drawPixel.0:iterations
   249 op abs *tmp83 *tmp82
 
   260 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   261 jump *label64 always
   262 label *label65
-    * jump *label68 equal .PALETTE 3
-    * jump *label67 always
+  263 jump *label67 notEqual .PALETTE 3
   264 label *label68
   265 op div *tmp94 :drawPixel.0:iterations 63
   266 op mul *tmp95 *tmp94 360
 
   277 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   278 jump *label64 always
   279 label *label67
-    * jump *label70 equal .PALETTE 4
-    * jump *label69 always
+  280 jump *label69 notEqual .PALETTE 4
   281 label *label70
   282 op mul :drawPixel.0:r 4 :drawPixel.0:iterations
   283 op mul *tmp107 1.5 :drawPixel.0:iterations

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-17 instructions):
 
    30 print :findLinkedBlocks.0:title
    31 set :findLinkedBlocks.0:n @links
    32 label *label10
-    * op greaterThan *tmp14 :findLinkedBlocks.0:n 0
-    * jump *label12 equal *tmp14 false
+   33 jump *label12 lessThanEq :findLinkedBlocks.0:n 0
    34 op sub :findLinkedBlocks.0:n :findLinkedBlocks.0:n 1
    35 getlink :findLinkedBlocks.0:block :findLinkedBlocks.0:n
    36 print "\nFound: "
 
    50 set :findLinkedBlocks.0:variable .memory
    51 set :findLinkedBlocks.0:required true
    52 label *label13
-    * op equal *tmp18 :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
-    * jump *label18 equal *tmp18 false
+   53 jump *label18 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
    54 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * op equal *tmp20 :findLinkedBlocks.0:requested @message
-    * jump *label20 equal *tmp20 false
+   55 jump *label20 notEqual :findLinkedBlocks.0:requested @message
    56 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    57 jump *label21 always
    58 label *label20
 
   100 label *label24
   101 printflush :findLinkedBlocks.0:message
   102 label *label3
-    * op equal *tmp24 :findLinkedBlocks.0:foundAll false
-    * jump *label2 notEqual *tmp24 false
+  103 jump *label2 equal :findLinkedBlocks.0:foundAll false
   104 label *label4
   105 label *label1
   106 label *label29
 
   111 label *label35
   112 label *label33
   113 read *tmp0 .memory 64
-    * op equal *tmp25 .start *tmp0
-    * jump *label32 notEqual *tmp25 false
+  114 jump *label32 equal .start *tmp0
   115 label *label34
   116 read *tmp0 .memory 64
   117 set .start *tmp0
 
   146 op add :position :x 158
   147 set *tmp35 :position
   148 read *tmp36 .memory *tmp35
-    * op equal *tmp37 *tmp36 0
-    * jump *label40 equal *tmp37 false
+  149 jump *label40 notEqual *tmp36 0
   150 set *tmp39 :position
   151 write .PROCESSOR_ID .memory *tmp39
   152 set :y 0
 
   171 op mul *tmp50 *tmp49 :compute.0:p
   172 op sub *tmp51 :compute.0:p *tmp50
   173 op add *tmp52 *tmp51 0.25
-    * op lessThanEq *tmp53 :compute.0:cx *tmp52
-    * jump *label48 equal *tmp53 false
+  174 jump *label48 greaterThan :compute.0:cx *tmp52
   175 set *tmp41 63
   176 jump *label45 always
   177 jump *label49 always
 
   179 label *label49
   180 op add *tmp55 :compute.0:cx 1
   181 op len *tmp56 *tmp55 :compute.0:cy
-    * op lessThanEq *tmp57 *tmp56 0.25
-    * jump *label50 equal *tmp57 false
+  182 jump *label50 greaterThan *tmp56 0.25
   183 set *tmp41 63
   184 jump *label45 always
   185 jump *label51 always
 
   199 op mul *tmp64 *tmp63 :compute.0:y1
   200 op add :compute.0:zy *tmp64 :compute.0:cy
   201 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * op greaterThanEq *tmp67 :compute.0:dist 64
-    * jump *label55 equal *tmp67 false
+  202 jump *label55 lessThan :compute.0:dist 64
   203 jump *label54 always
   204 jump *label56 always
   205 label *label55
 
   209 jump *label52 always
   210 label *label54
   211 op mul *tmp69 .SMOOTH 63
-    * op lessThan *tmp70 :compute.0:i *tmp69
-    * jump *label57 equal *tmp70 false
+  212 jump *label57 greaterThanEq :compute.0:i *tmp69
   213 op log *tmp72 :compute.0:dist
   214 op mul *tmp73 *tmp72 0.36067376022224085
   215 op log *tmp74 *tmp73
 
   228 set :drawPixel.0:y :y
   229 set :drawPixel.0:iterations :iterations
   230 jump *label60 equal .SMOOTH false
-    * op equal *tmp78 :drawPixel.0:iterations 63
-    * jump *label62 equal *tmp78 false
+  231 jump *label62 notEqual :drawPixel.0:iterations 63
   232 draw color 0 0 0 255
   233 jump *label63 always
   234 label *label62
 
   290 label *label59
   291 set *tmp113 :position
   292 read *tmp114 .memory *tmp113
-    * op notEqual *tmp115 *tmp114 .PROCESSOR_ID
-    * jump *label71 equal *tmp115 false
+  293 jump *label71 equal *tmp114 .PROCESSOR_ID
   294 jump *label44 always
   295 jump *label72 always
   296 label *label71
   297 label *label72
   298 read *tmp1 .memory 65
-    * op notEqual *tmp117 .stop *tmp1
-    * jump *label73 equal *tmp117 false
+  299 jump *label73 equal .stop *tmp1
   300 jump *label39 always
   301 jump *label74 always
   302 label *label73
 
   309 label *label40
   310 label *label41
   311 op add :line :line :increment
-    * op greaterThan *tmp119 :line 176
-    * jump *label75 equal *tmp119 false
+  312 jump *label75 lessThanEq :line 176
   313 op div :next_increment :next_increment 2
   314 set :increment :next_increment
   315 op div :line :increment 2
 
   327 end
   328 label *label0
   329 label *label78
-    * op lessThan *tmp122 .PROC_STATE_INDEX 512
-    * jump *label80 equal *tmp122 false
+  330 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
   331 set *tmp123 .PROC_ID_INDEX
   332 read *tmp124 .memory *tmp123
-    * op equal *tmp125 *tmp124 .PROCESSOR_ID
-    * jump *label81 equal *tmp125 false
+  333 jump *label81 notEqual *tmp124 .PROCESSOR_ID
   334 set *tmp127 .PROC_STATE_INDEX
   335 write :setState.0:state .memory *tmp127
   336 jump *label80 always
 
   338 label *label81
   339 set *tmp129 .PROC_ID_INDEX
   340 read *tmp130 .memory *tmp129
-    * op equal *tmp131 *tmp130 0
-    * jump *label83 equal *tmp131 false
+  341 jump *label83 notEqual *tmp130 0
   342 set *tmp133 .PROC_ID_INDEX
   343 write .PROCESSOR_ID .memory *tmp133
   344 set *tmp135 .PROC_STATE_INDEX

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-11 instructions):
 
    54 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
    55 jump *label20 notEqual :findLinkedBlocks.0:requested @message
    56 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
-    * jump *label21 always
    57 label *label20
    58 label *label21
-    * jump *label19 always
    59 label *label18
    60 label *label19
    61 label *label14
 
    88 print :findLinkedBlocks.0:variable
    89 jump *label27 equal :findLinkedBlocks.0:required false
    90 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
-    * jump *label28 always
    91 label *label27
    92 label *label28
    93 label *label23
 
   171 jump *label48 greaterThan :compute.0:cx *tmp52
   172 set *tmp41 63
   173 jump *label45 always
-    * jump *label49 always
   174 label *label48
   175 label *label49
   176 op add *tmp55 :compute.0:cx 1
 
   178 jump *label50 greaterThan *tmp56 0.25
   179 set *tmp41 63
   180 jump *label45 always
-    * jump *label51 always
   181 label *label50
   182 label *label51
   183 label *label47
 
   196 op len :compute.0:dist :compute.0:zx :compute.0:zy
   197 jump *label55 lessThan :compute.0:dist 64
   198 jump *label54 always
-    * jump *label56 always
   199 label *label55
   200 label *label56
   201 label *label53
 
   210 op mul *tmp75 *tmp74 1.4426950408889634
   211 op sub :compute.0:correction 4 *tmp75
   212 op add :compute.0:i :compute.0:i :compute.0:correction
-    * jump *label58 always
   213 label *label57
   214 label *label58
   215 set *tmp41 :compute.0:i
 
   285 read *tmp114 .memory *tmp113
   286 jump *label71 equal *tmp114 .PROCESSOR_ID
   287 jump *label44 always
-    * jump *label72 always
   288 label *label71
   289 label *label72
   290 read *tmp1 .memory 65
   291 jump *label73 equal .stop *tmp1
   292 jump *label39 always
-    * jump *label74 always
   293 label *label73
   294 label *label74
   295 label *label43
   296 op add :y :y 1
   297 jump *label42 always
   298 label *label44
-    * jump *label41 always
   299 label *label40
   300 label *label41
   301 op add :line :line :increment
 
   303 op div :next_increment :next_increment 2
   304 set :increment :next_increment
   305 op div :line :increment 2
-    * jump *label76 always
   306 label *label75
   307 label *label76
   308 label *label38

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
-    * sensor *tmp9 @this @x
-    * sensor *tmp10 @this @y
+    0 set *tmp9 @thisx
+    1 set *tmp10 @thisy
     2 op mul *tmp11 10000 *tmp10
     3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
     0 set *tmp9 @thisx
     1 set *tmp10 @thisy
-    * op mul *tmp11 10000 *tmp10
-    * op add .PROCESSOR_ID *tmp9 *tmp11
+    2 op mul *tmp11 10000 @thisy
+    3 op add .PROCESSOR_ID @thisx *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
 
     8 set :findLinkedBlocks.0:message null
     9 label *label2
    10 setaddr *tmp13 *label8
-    * set :findLinkedBlocks.0:requested @large-logic-display
-    * set :findLinkedBlocks.0:name "Display"
-    * set :findLinkedBlocks.0:variable .display
-    * set :findLinkedBlocks.0:required true
    11 jump *label5 always
    12 multilabel *label8 marker0
-    * set .display :findLinkedBlocks.0:variable
+   13 set .display null
    14 setaddr *tmp13 *label9
-    * set :findLinkedBlocks.0:requested @memory-bank
-    * set :findLinkedBlocks.0:name "Memory"
-    * set :findLinkedBlocks.0:variable .memory
-    * set :findLinkedBlocks.0:required true
    15 label *label5
    16 set :findLinkedBlocks.0:variable null
    17 label *label6
    18 multijump *tmp13 0 0 marker0
    19 multilabel *label9 marker0
-    * set .memory :findLinkedBlocks.0:variable
+   20 set .memory null
    21 label *label7
-    * print :findLinkedBlocks.0:title
+   22 print "Mandelbrot Generator"
    23 set :findLinkedBlocks.0:n @links
    24 label *label10
    25 jump *label12 lessThanEq :findLinkedBlocks.0:n 0
 
    30 sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @type
    31 setaddr *tmp17 *label16
    32 set :findLinkedBlocks.0:requested @large-logic-display
-    * set :findLinkedBlocks.0:name "Display"
    33 set :findLinkedBlocks.0:variable .display
-    * set :findLinkedBlocks.0:required true
    34 jump *label13 always
    35 multilabel *label16 marker1
    36 set .display :findLinkedBlocks.0:variable
    37 setaddr *tmp17 *label17
    38 set :findLinkedBlocks.0:requested @memory-bank
-    * set :findLinkedBlocks.0:name "Memory"
    39 set :findLinkedBlocks.0:variable .memory
-    * set :findLinkedBlocks.0:required true
    40 label *label13
    41 jump *label18 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
    42 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
 
    56 label *label12
    57 set :findLinkedBlocks.0:foundAll 1
    58 setaddr *tmp22 *label25
-    * set :findLinkedBlocks.0:requested @large-logic-display
    59 set :findLinkedBlocks.0:name "Display"
    60 set :findLinkedBlocks.0:variable .display
    61 set :findLinkedBlocks.0:required true
 
    63 multilabel *label25 marker2
    64 set .display :findLinkedBlocks.0:variable
    65 setaddr *tmp22 *label26
-    * set :findLinkedBlocks.0:requested @memory-bank
    66 set :findLinkedBlocks.0:name "Memory"
    67 set :findLinkedBlocks.0:variable .memory
    68 set :findLinkedBlocks.0:required true
 
    72 print ":"
    73 print " "
    74 print :findLinkedBlocks.0:variable
-    * jump *label27 equal :findLinkedBlocks.0:required false
+   75 jump *label27 equal true false
    76 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
    77 label *label27
    78 label *label28
 
   100 set .start *tmp0
   101 read *tmp1 .memory 65
   102 set .stop *tmp1
-    * set :setState.0:state .start
+  103 set :setState.0:state *tmp0
   104 setaddr :setState.0*retaddr *label36
   105 call *label0 :setState.0*retval
   106 label *label36
 
   110 op add .OFFSET_X *tmp26 *tmp2
   111 op div *tmp28 -88 .ZOOM
   112 read *tmp3 .memory 67
-    * op add .OFFSET_Y *tmp28 *tmp3
+  113 op add .OFFSET_Y *tmp26 *tmp3
   114 read .JULIA .memory 69
   115 read .JULIA_X .memory 70
   116 read .JULIA_Y .memory 71
 
   128 op mod :x *tmp32 176
   129 op add :position :x 158
   130 set *tmp35 :position
-    * read *tmp36 .memory *tmp35
+  131 read *tmp36 .memory :position
   132 jump *label40 notEqual *tmp36 0
   133 set *tmp39 :position
-    * write .PROCESSOR_ID .memory *tmp39
+  134 write .PROCESSOR_ID .memory :position
   135 set :y 0
   136 label *label42
   137 jump *label44 greaterThanEq :y 176
   138 set :compute.0:x :x
   139 set :compute.0:y :y
-    * op div *tmp42 :compute.0:x .ZOOM
+  140 op div *tmp42 :x .ZOOM
   141 op add :compute.0:zx *tmp42 .OFFSET_X
-    * op div *tmp44 :compute.0:y .ZOOM
+  142 op div *tmp44 :y .ZOOM
   143 op add :compute.0:zy *tmp44 .OFFSET_Y
   144 jump *label46 equal .JULIA false
   145 set :compute.0:cx .JULIA_X
 
   148 label *label46
   149 set :compute.0:cx :compute.0:zx
   150 set :compute.0:cy :compute.0:zy
-    * op sub *tmp47 :compute.0:cx 0.25
-    * op len :compute.0:p *tmp47 :compute.0:cy
+  151 op sub *tmp47 :compute.0:zx 0.25
+  152 op len :compute.0:p *tmp47 :compute.0:zy
   153 op mul *tmp49 2 :compute.0:p
   154 op mul *tmp50 *tmp49 :compute.0:p
   155 op sub *tmp51 :compute.0:p *tmp50
   156 op add *tmp52 *tmp51 0.25
-    * jump *label48 greaterThan :compute.0:cx *tmp52
+  157 jump *label48 greaterThan :compute.0:zx *tmp52
   158 set *tmp41 63
   159 jump *label45 always
   160 label *label48
   161 label *label49
-    * op add *tmp55 :compute.0:cx 1
-    * op len *tmp56 *tmp55 :compute.0:cy
+  162 op add *tmp55 :compute.0:zx 1
+  163 op len *tmp56 *tmp55 :compute.0:zy
   164 jump *label50 greaterThan *tmp56 0.25
   165 set *tmp41 63
   166 jump *label45 always
 
   172 jump *label54 greaterThanEq :compute.0:i 63
   173 set :compute.0:x1 :compute.0:zx
   174 set :compute.0:y1 :compute.0:zy
-    * op mul *tmp59 :compute.0:x1 :compute.0:x1
-    * op mul *tmp60 :compute.0:y1 :compute.0:y1
+  175 op mul *tmp59 :compute.0:zx :compute.0:zx
+  176 op mul *tmp60 :compute.0:zy :compute.0:zy
   177 op sub *tmp61 *tmp59 *tmp60
   178 op add :compute.0:zx *tmp61 :compute.0:cx
   179 op mul *tmp63 2 :compute.0:x1
-    * op mul *tmp64 *tmp63 :compute.0:y1
+  180 op mul *tmp64 *tmp63 :compute.0:zy
   181 op add :compute.0:zy *tmp64 :compute.0:cy
   182 op len :compute.0:dist :compute.0:zx :compute.0:zy
   183 jump *label55 lessThan :compute.0:dist 64
 
   200 label *label58
   201 set *tmp41 :compute.0:i
   202 jump *label45 always
-    * set *tmp41 null
   203 label *label45
   204 set :iterations *tmp41
   205 set :drawPixel.0:x :x
   206 set :drawPixel.0:y :y
-    * set :drawPixel.0:iterations :iterations
+  207 set :drawPixel.0:iterations *tmp41
   208 jump *label60 equal .SMOOTH false
-    * jump *label62 notEqual :drawPixel.0:iterations 63
+  209 jump *label62 notEqual :iterations 63
   210 draw color 0 0 0 255
   211 jump *label63 always
   212 label *label62
   213 jump *label65 notEqual .PALETTE 2
   214 label *label66
-    * op sub *tmp82 32 :drawPixel.0:iterations
+  215 op sub *tmp82 32 :iterations
   216 op abs *tmp83 *tmp82
   217 op mul *tmp84 7 *tmp83
   218 op sub :drawPixel.0:r 255 *tmp84
-    * op sub *tmp86 :drawPixel.0:iterations 32
+  219 op sub *tmp86 :iterations 32
   220 op abs *tmp87 *tmp86
   221 op mul *tmp88 6 *tmp87
   222 op sub :drawPixel.0:g 240 *tmp88
-    * op sub *tmp90 32 :drawPixel.0:iterations
-    * op abs *tmp91 *tmp90
-    * op mul *tmp92 4 *tmp91
+  223 op sub *tmp90 32 :iterations
+  224 op abs *tmp91 *tmp82
+  225 op mul *tmp92 4 *tmp83
   226 op add :drawPixel.0:b 120 *tmp92
   227 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   228 jump *label64 always
   229 label *label65
   230 jump *label67 notEqual .PALETTE 3
   231 label *label68
-    * op div *tmp94 :drawPixel.0:iterations 63
-    * op mul *tmp95 *tmp94 360
+  232 op div *tmp94 :iterations 63
+  233 op div *tmp95 :drawPixel.0:iterations 0.175
   234 op sin *tmp96 *tmp95
   235 op mul :drawPixel.0:r 255 *tmp96
-    * op div *tmp98 :drawPixel.0:iterations 63
-    * op mul *tmp99 *tmp98 360
-    * op cos *tmp100 *tmp99
+  236 op div *tmp98 :iterations 63
+  237 op mul *tmp99 *tmp94 360
+  238 op cos *tmp100 *tmp95
   239 op mul :drawPixel.0:g 255 *tmp100
-    * op sub *tmp102 :drawPixel.0:iterations 32
+  240 op sub *tmp102 :iterations 32
   241 op abs *tmp103 *tmp102
   242 op mul *tmp104 4 *tmp103
   243 op add :drawPixel.0:b 100 *tmp104
 
   246 label *label67
   247 jump *label69 notEqual .PALETTE 4
   248 label *label70
-    * op mul :drawPixel.0:r 4 :drawPixel.0:iterations
-    * op mul *tmp107 1.5 :drawPixel.0:iterations
+  249 op mul :drawPixel.0:r 4 :iterations
+  250 op mul *tmp107 1.5 :iterations
   251 op add :drawPixel.0:g 96 *tmp107
   252 draw color :drawPixel.0:r :drawPixel.0:g 0 255
   253 jump *label64 always
   254 label *label69
-    * op mul *tmp109 4 :drawPixel.0:iterations
+  255 op mul *tmp109 4 :iterations
   256 op sub :drawPixel.0:r 255 *tmp109
   257 draw color :drawPixel.0:r :drawPixel.0:r 0 255
   258 label *label64
   259 label *label63
   260 jump *label61 always
   261 label *label60
-    * set *tmp111 :drawPixel.0:iterations
-    * read *tmp112 .memory *tmp111
+  262 set *tmp111 :iterations
+  263 read *tmp112 .memory :drawPixel.0:iterations
   264 draw col *tmp112
   265 label *label61
-    * draw rect :drawPixel.0:x :drawPixel.0:y 1 1
+  266 draw rect :x :y 1 1
   267 drawflush .display
   268 label *label59
   269 set *tmp113 :position
-    * read *tmp114 .memory *tmp113
+  270 read *tmp114 .memory :position
   271 jump *label71 equal *tmp114 .PROCESSOR_ID
   272 jump *label44 always
   273 label *label71
 
   287 jump *label75 lessThanEq :line 176
   288 op div :next_increment :next_increment 2
   289 set :increment :next_increment
-    * op div :line :increment 2
+  290 op div :line :next_increment 2
   291 label *label75
   292 label *label76
   293 label *label38
 
   303 label *label78
   304 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
   305 set *tmp123 .PROC_ID_INDEX
-    * read *tmp124 .memory *tmp123
+  306 read *tmp124 .memory .PROC_ID_INDEX
   307 jump *label81 notEqual *tmp124 .PROCESSOR_ID
   308 set *tmp127 .PROC_STATE_INDEX
-    * write :setState.0:state .memory *tmp127
+  309 write :setState.0:state .memory .PROC_STATE_INDEX
   310 jump *label80 always
   311 jump *label82 always
   312 label *label81
   313 set *tmp129 .PROC_ID_INDEX
-    * read *tmp130 .memory *tmp129
+  314 read *tmp130 .memory .PROC_ID_INDEX
   315 jump *label83 notEqual *tmp130 0
   316 set *tmp133 .PROC_ID_INDEX
-    * write .PROCESSOR_ID .memory *tmp133
+  317 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   318 set *tmp135 .PROC_STATE_INDEX
-    * write :setState.0:state .memory *tmp135
+  319 write :setState.0:state .memory .PROC_STATE_INDEX
   320 jump *label80 always
   321 jump *label84 always
   322 label *label83

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-21 instructions):
-    * set *tmp9 @thisx
-    * set *tmp10 @thisy
     0 op mul *tmp11 10000 @thisy
     1 op add .PROCESSOR_ID @thisx *tmp11
     2 set .PROC_ID_INDEX 334
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
-    * set :findLinkedBlocks.0:title "Mandelbrot Generator"
     5 set :findLinkedBlocks.0:message null
     6 label *label2
     7 setaddr *tmp13 *label8
 
    10 set .display null
    11 setaddr *tmp13 *label9
    12 label *label5
-    * set :findLinkedBlocks.0:variable null
    13 label *label6
    14 multijump *tmp13 0 0 marker0
    15 multilabel *label9 marker0
 
    54 setaddr *tmp22 *label25
    55 set :findLinkedBlocks.0:name "Display"
    56 set :findLinkedBlocks.0:variable .display
-    * set :findLinkedBlocks.0:required true
    57 jump *label22 always
    58 multilabel *label25 marker2
    59 set .display :findLinkedBlocks.0:variable
    60 setaddr *tmp22 *label26
    61 set :findLinkedBlocks.0:name "Memory"
    62 set :findLinkedBlocks.0:variable .memory
-    * set :findLinkedBlocks.0:required true
    63 label *label22
    64 print "\n"
    65 print :findLinkedBlocks.0:name
 
   102 op div *tmp26 -88 .ZOOM
   103 read *tmp2 .memory 66
   104 op add .OFFSET_X *tmp26 *tmp2
-    * op div *tmp28 -88 .ZOOM
   105 read *tmp3 .memory 67
   106 op add .OFFSET_Y *tmp26 *tmp3
   107 read .JULIA .memory 69
 
   120 op mul *tmp32 17 :line
   121 op mod :x *tmp32 176
   122 op add :position :x 158
-    * set *tmp35 :position
   123 read *tmp36 .memory :position
   124 jump *label40 notEqual *tmp36 0
-    * set *tmp39 :position
   125 write .PROCESSOR_ID .memory :position
   126 set :y 0
   127 label *label42
   128 jump *label44 greaterThanEq :y 176
-    * set :compute.0:x :x
-    * set :compute.0:y :y
   129 op div *tmp42 :x .ZOOM
   130 op add :compute.0:zx *tmp42 .OFFSET_X
   131 op div *tmp44 :y .ZOOM
 
   160 label *label52
   161 jump *label54 greaterThanEq :compute.0:i 63
   162 set :compute.0:x1 :compute.0:zx
-    * set :compute.0:y1 :compute.0:zy
   163 op mul *tmp59 :compute.0:zx :compute.0:zx
   164 op mul *tmp60 :compute.0:zy :compute.0:zy
   165 op sub *tmp61 *tmp59 *tmp60
 
   190 jump *label45 always
   191 label *label45
   192 set :iterations *tmp41
-    * set :drawPixel.0:x :x
-    * set :drawPixel.0:y :y
   193 set :drawPixel.0:iterations *tmp41
   194 jump *label60 equal .SMOOTH false
-    * jump *label62 notEqual :iterations 63
+  195 jump *label62 notEqual *tmp41 63
   196 draw color 0 0 0 255
   197 jump *label63 always
   198 label *label62
   199 jump *label65 notEqual .PALETTE 2
   200 label *label66
-    * op sub *tmp82 32 :iterations
+  201 op sub *tmp82 32 *tmp41
   202 op abs *tmp83 *tmp82
   203 op mul *tmp84 7 *tmp83
   204 op sub :drawPixel.0:r 255 *tmp84
-    * op sub *tmp86 :iterations 32
+  205 op sub *tmp86 *tmp41 32
   206 op abs *tmp87 *tmp86
   207 op mul *tmp88 6 *tmp87
   208 op sub :drawPixel.0:g 240 *tmp88
-    * op sub *tmp90 32 :iterations
-    * op abs *tmp91 *tmp82
+  209 op sub *tmp90 32 *tmp41
   210 op mul *tmp92 4 *tmp83
   211 op add :drawPixel.0:b 120 *tmp92
   212 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
 
   214 label *label65
   215 jump *label67 notEqual .PALETTE 3
   216 label *label68
-    * op div *tmp94 :iterations 63
-    * op div *tmp95 :drawPixel.0:iterations 0.175
+  217 op div *tmp94 *tmp41 63
+  218 op div *tmp95 *tmp41 0.175
   219 op sin *tmp96 *tmp95
   220 op mul :drawPixel.0:r 255 *tmp96
-    * op div *tmp98 :iterations 63
-    * op mul *tmp99 *tmp94 360
+  221 op div *tmp98 *tmp41 63
+  222 op div *tmp99 :iterations 0.175
   223 op cos *tmp100 *tmp95
   224 op mul :drawPixel.0:g 255 *tmp100
-    * op sub *tmp102 :iterations 32
+  225 op sub *tmp102 *tmp41 32
   226 op abs *tmp103 *tmp102
   227 op mul *tmp104 4 *tmp103
   228 op add :drawPixel.0:b 100 *tmp104
 
   231 label *label67
   232 jump *label69 notEqual .PALETTE 4
   233 label *label70
-    * op mul :drawPixel.0:r 4 :iterations
-    * op mul *tmp107 1.5 :iterations
+  234 op mul :drawPixel.0:r 4 *tmp41
+  235 op mul *tmp107 1.5 *tmp41
   236 op add :drawPixel.0:g 96 *tmp107
   237 draw color :drawPixel.0:r :drawPixel.0:g 0 255
   238 jump *label64 always
   239 label *label69
-    * op mul *tmp109 4 :iterations
+  240 op mul *tmp109 4 *tmp41
   241 op sub :drawPixel.0:r 255 *tmp109
   242 draw color :drawPixel.0:r :drawPixel.0:r 0 255
   243 label *label64
   244 label *label63
   245 jump *label61 always
   246 label *label60
-    * set *tmp111 :iterations
-    * read *tmp112 .memory :drawPixel.0:iterations
+  247 set *tmp111 *tmp41
+  248 read *tmp112 .memory *tmp41
   249 draw col *tmp112
   250 label *label61
   251 draw rect :x :y 1 1
   252 drawflush .display
   253 label *label59
-    * set *tmp113 :position
   254 read *tmp114 .memory :position
   255 jump *label71 equal *tmp114 .PROCESSOR_ID
   256 jump *label44 always
 
   286 label *label0
   287 label *label78
   288 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
-    * set *tmp123 .PROC_ID_INDEX
   289 read *tmp124 .memory .PROC_ID_INDEX
   290 jump *label81 notEqual *tmp124 .PROCESSOR_ID
-    * set *tmp127 .PROC_STATE_INDEX
   291 write :setState.0:state .memory .PROC_STATE_INDEX
   292 jump *label80 always
   293 jump *label82 always
   294 label *label81
-    * set *tmp129 .PROC_ID_INDEX
   295 read *tmp130 .memory .PROC_ID_INDEX
   296 jump *label83 notEqual *tmp130 0
-    * set *tmp133 .PROC_ID_INDEX
   297 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * set *tmp135 .PROC_STATE_INDEX
   298 write :setState.0:state .memory .PROC_STATE_INDEX
   299 jump *label80 always
   300 jump *label84 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-5 instructions):
 
   190 jump *label45 always
   191 label *label45
   192 set :iterations *tmp41
-    * set :drawPixel.0:iterations *tmp41
   193 jump *label60 equal .SMOOTH false
   194 jump *label62 notEqual *tmp41 63
   195 draw color 0 0 0 255
 
   205 op abs *tmp87 *tmp86
   206 op mul *tmp88 6 *tmp87
   207 op sub :drawPixel.0:g 240 *tmp88
-    * op sub *tmp90 32 *tmp41
   208 op mul *tmp92 4 *tmp83
   209 op add :drawPixel.0:b 120 *tmp92
   210 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
 
   212 label *label65
   213 jump *label67 notEqual .PALETTE 3
   214 label *label68
-    * op div *tmp94 *tmp41 63
   215 op div *tmp95 *tmp41 0.175
   216 op sin *tmp96 *tmp95
   217 op mul :drawPixel.0:r 255 *tmp96
-    * op div *tmp98 *tmp41 63
-    * op div *tmp99 :iterations 0.175
+  218 op div *tmp99 *tmp41 0.175
   219 op cos *tmp100 *tmp95
   220 op mul :drawPixel.0:g 255 *tmp100
   221 op sub *tmp102 *tmp41 32
 
   240 label *label63
   241 jump *label61 always
   242 label *label60
-    * set *tmp111 *tmp41
   243 read *tmp112 .memory *tmp41
   244 draw col *tmp112
   245 label *label61

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   189 set *tmp41 :compute.0:i
   190 jump *label45 always
   191 label *label45
-    * set :iterations *tmp41
   192 jump *label60 equal .SMOOTH false
   193 jump *label62 notEqual *tmp41 63
   194 draw color 0 0 0 255
 
   214 op div *tmp95 *tmp41 0.175
   215 op sin *tmp96 *tmp95
   216 op mul :drawPixel.0:r 255 *tmp96
-    * op div *tmp99 *tmp41 0.175
   217 op cos *tmp100 *tmp95
   218 op mul :drawPixel.0:g 255 *tmp100
   219 op sub *tmp102 *tmp41 32

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-3 instructions):
 
    19 set :findLinkedBlocks.0:n @links
    20 label *label10
    21 jump *label12 lessThanEq :findLinkedBlocks.0:n 0
+   22 label *label85
    23 op sub :findLinkedBlocks.0:n :findLinkedBlocks.0:n 1
    24 getlink :findLinkedBlocks.0:block :findLinkedBlocks.0:n
    25 print "\nFound: "
 
    49 set .memory :findLinkedBlocks.0:variable
    50 label *label15
    51 label *label11
-    * jump *label10 always
+   52 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    53 label *label12
    54 set :findLinkedBlocks.0:foundAll 1
    55 setaddr *tmp22 *label25
 
   117 wait *tmp31
   118 set :lines 0
   119 label *label37
-    * jump *label39 greaterThanEq :lines 176
+  120 label *label86
   121 op mul *tmp32 17 :line
   122 op mod :x *tmp32 176
   123 op add :position :x 158
 
   126 write .PROCESSOR_ID .memory :position
   127 set :y 0
   128 label *label42
-    * jump *label44 greaterThanEq :y 176
+  129 label *label87
   130 op div *tmp42 :x .ZOOM
   131 op add :compute.0:zx *tmp42 .OFFSET_X
   132 op div *tmp44 :y .ZOOM
 
   159 label *label47
   160 set :compute.0:i 0
   161 label *label52
-    * jump *label54 greaterThanEq :compute.0:i 63
+  162 label *label88
   163 set :compute.0:x1 :compute.0:zx
   164 op mul *tmp59 :compute.0:zx :compute.0:zx
   165 op mul *tmp60 :compute.0:zy :compute.0:zy
 
   175 label *label56
   176 label *label53
   177 op add :compute.0:i :compute.0:i 1
-    * jump *label52 always
+  178 jump *label88 lessThan :compute.0:i 63
   179 label *label54
   180 op mul *tmp69 .SMOOTH 63
   181 jump *label57 greaterThanEq :compute.0:i *tmp69
 
   257 label *label74
   258 label *label43
   259 op add :y :y 1
-    * jump *label42 always
+  260 jump *label87 lessThan :y 176
   261 label *label44
   262 label *label40
   263 label *label41
 
   270 label *label76
   271 label *label38
   272 op add :lines :lines 1
-    * jump *label37 always
+  273 jump *label86 lessThan :lines 176
   274 label *label39
   275 drawflush .display
   276 label *label30
 
   280 label *label0
   281 label *label78
   282 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
+  283 label *label89
   284 read *tmp124 .memory .PROC_ID_INDEX
   285 jump *label81 notEqual *tmp124 .PROCESSOR_ID
   286 write :setState.0:state .memory .PROC_STATE_INDEX
 
   299 label *label84
   300 label *label82
   301 label *label79
-    * jump *label78 always
+  302 jump *label89 lessThan .PROC_STATE_INDEX 512
   303 label *label80
   304 label *label77
   305 return :setState.0*retaddr

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
 
     4 set .start 0
     5 set :findLinkedBlocks.0:message null
     6 label *label2
-    * setaddr *tmp13 *label8
-    * jump *label5 always
-    * multilabel *label8 marker0
-    * set .display null
-    * setaddr *tmp13 *label9
-    * label *label5
-    * label *label6
-    * multijump *tmp13 0 0 marker0
-    * multilabel *label9 marker0
-    * set .memory null
-    * label *label7
+    7 label *label90
+    8 label *label91
+    9 set .display null
+   10 label *label94
+   11 label *label95
+   12 set .memory null
+   13 label *label7
    14 print "Mandelbrot Generator"
    15 set :findLinkedBlocks.0:n @links
    16 label *label10

Modifications by Unroll iteration loop at *blocks:68:13:
 
    21 print "\nFound: "
    22 print :findLinkedBlocks.0:block
    23 sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @type
-    * setaddr *tmp17 *label16
-    * set :findLinkedBlocks.0:requested @large-logic-display
-    * set :findLinkedBlocks.0:variable .display
-    * jump *label13 always
-    * multilabel *label16 marker1
-    * set .display :findLinkedBlocks.0:variable
-    * setaddr *tmp17 *label17
-    * set :findLinkedBlocks.0:requested @memory-bank
-    * set :findLinkedBlocks.0:variable .memory
-    * label *label13
-    * jump *label18 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
-    * set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * jump *label20 notEqual :findLinkedBlocks.0:requested @message
-    * set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
-    * label *label20
-    * label *label21
-    * label *label18
-    * label *label19
-    * label *label14
-    * multijump *tmp17 0 0 marker1
-    * multilabel *label17 marker1
-    * set .memory :findLinkedBlocks.0:variable
-    * label *label15
+   24 set :findLinkedBlocks.0:requested @large-logic-display
+   25 set .display .display
+   26 label *label99
+   27 jump *label102 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
+   28 set .display :findLinkedBlocks.0:block
+   29 jump *label100 notEqual :findLinkedBlocks.0:requested @message
+   30 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
+   31 label *label100
+   32 label *label101
+   33 label *label102
+   34 label *label103
+   35 label *label104
+   36 set .display .display
+   37 set :findLinkedBlocks.0:requested @memory-bank
+   38 set .memory .memory
+   39 label *label107
+   40 jump *label110 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
+   41 set .memory :findLinkedBlocks.0:block
+   42 jump *label108 notEqual :findLinkedBlocks.0:requested @message
+   43 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
+   44 label *label108
+   45 label *label109
+   46 label *label110
+   47 label *label111
+   48 label *label112
+   49 set .memory .memory
+   50 label *label15
    51 label *label11
    52 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    53 label *label12

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    24 set :findLinkedBlocks.0:requested @large-logic-display
    25 set .display .display
    26 label *label99
-    * jump *label102 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
+   27 jump *label102 notEqual @large-logic-display :findLinkedBlocks.0:type
    28 set .display :findLinkedBlocks.0:block
-    * jump *label100 notEqual :findLinkedBlocks.0:requested @message
+   29 jump *label100 notEqual @large-logic-display @message
    30 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    31 label *label100
    32 label *label101
 
    37 set :findLinkedBlocks.0:requested @memory-bank
    38 set .memory .memory
    39 label *label107
-    * jump *label110 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
+   40 jump *label110 notEqual @memory-bank :findLinkedBlocks.0:type
    41 set .memory :findLinkedBlocks.0:block
-    * jump *label108 notEqual :findLinkedBlocks.0:requested @message
+   42 jump *label108 notEqual @memory-bank @message
    43 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    44 label *label108
    45 label *label109

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks.0:block
    23 sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @type
-    * set :findLinkedBlocks.0:requested @large-logic-display
    24 set .display .display
    25 label *label99
    26 jump *label102 notEqual @large-logic-display :findLinkedBlocks.0:type
    27 set .display :findLinkedBlocks.0:block
    28 jump *label100 notEqual @large-logic-display @message
-    * set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    29 label *label100
    30 label *label101
    31 label *label102
    32 label *label103
    33 label *label104
    34 set .display .display
-    * set :findLinkedBlocks.0:requested @memory-bank
    35 set .memory .memory
    36 label *label107
    37 jump *label110 notEqual @memory-bank :findLinkedBlocks.0:type
    38 set .memory :findLinkedBlocks.0:block
    39 jump *label108 notEqual @memory-bank @message
-    * set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    40 label *label108
    41 label *label109
    42 label *label110
 
    72 multilabel *label26 marker2
    73 set .memory :findLinkedBlocks.0:variable
    74 label *label24
-    * printflush :findLinkedBlocks.0:message
+   75 printflush null
    76 label *label3
    77 jump *label2 equal :findLinkedBlocks.0:foundAll false
    78 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
     2 set .PROC_ID_INDEX 334
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
-    * set :findLinkedBlocks.0:message null
     5 label *label2
     6 label *label90
     7 label *label91

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    47 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    48 label *label12
    49 set :findLinkedBlocks.0:foundAll 1
-    * setaddr *tmp22 *label25
-    * set :findLinkedBlocks.0:name "Display"
-    * set :findLinkedBlocks.0:variable .display
-    * jump *label22 always
-    * multilabel *label25 marker2
-    * set .display :findLinkedBlocks.0:variable
-    * setaddr *tmp22 *label26
-    * set :findLinkedBlocks.0:name "Memory"
-    * set :findLinkedBlocks.0:variable .memory
-    * label *label22
-    * print "\n"
-    * print :findLinkedBlocks.0:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks.0:variable
-    * jump *label27 equal true false
-    * op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
-    * label *label27
-    * label *label28
-    * label *label23
-    * multijump *tmp22 0 0 marker2
-    * multilabel *label26 marker2
-    * set .memory :findLinkedBlocks.0:variable
-    * label *label24
+   50 set :findLinkedBlocks.0:name "Display"
+   51 set .display .display
+   52 label *label116
+   53 print "\n"
+   54 print :findLinkedBlocks.0:name
+   55 print ":"
+   56 print " "
+   57 print .display
+   58 jump *label117 equal true false
+   59 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll .display
+   60 label *label117
+   61 label *label118
+   62 label *label119
+   63 set .display .display
+   64 set :findLinkedBlocks.0:name "Memory"
+   65 set .memory .memory
+   66 label *label122
+   67 print "\n"
+   68 print :findLinkedBlocks.0:name
+   69 print ":"
+   70 print " "
+   71 print .memory
+   72 jump *label123 equal true false
+   73 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll .memory
+   74 label *label123
+   75 label *label124
+   76 label *label125
+   77 set .memory .memory
+   78 label *label24
    79 printflush null
    80 label *label3
    81 jump *label2 equal :findLinkedBlocks.0:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    51 set .display .display
    52 label *label116
    53 print "\n"
-    * print :findLinkedBlocks.0:name
+   54 print "Display"
    55 print ":"
    56 print " "
    57 print .display
    58 jump *label117 equal true false
-    * op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll .display
+   59 op and :findLinkedBlocks.0:foundAll 1 .display
    60 label *label117
    61 label *label118
    62 label *label119
 
    65 set .memory .memory
    66 label *label122
    67 print "\n"
-    * print :findLinkedBlocks.0:name
+   68 print "Memory"
    69 print ":"
    70 print " "
    71 print .memory

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    46 label *label11
    47 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    48 label *label12
-    * set :findLinkedBlocks.0:foundAll 1
-    * set :findLinkedBlocks.0:name "Display"
    49 set .display .display
    50 label *label116
    51 print "\n"
 
    59 label *label118
    60 label *label119
    61 set .display .display
-    * set :findLinkedBlocks.0:name "Memory"
    62 set .memory .memory
    63 label *label122
    64 print "\n"

Modifications by Unroll loop at mandelbrot-compute.mnd:132:5 (+743 instructions):
 
   154 label *label50
   155 label *label51
   156 label *label47
-    * set :compute.0:i 0
-    * label *label52
-    * label *label88
-    * set :compute.0:x1 :compute.0:zx
-    * op mul *tmp59 :compute.0:zx :compute.0:zx
-    * op mul *tmp60 :compute.0:zy :compute.0:zy
-    * op sub *tmp61 *tmp59 *tmp60
-    * op add :compute.0:zx *tmp61 :compute.0:cx
-    * op mul *tmp63 2 :compute.0:x1
-    * op mul *tmp64 *tmp63 :compute.0:zy
-    * op add :compute.0:zy *tmp64 :compute.0:cy
-    * op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label55 lessThan :compute.0:dist 64
-    * jump *label54 always
-    * label *label55
-    * label *label56
-    * label *label53
-    * op add :compute.0:i :compute.0:i 1
-    * jump *label88 lessThan :compute.0:i 63
-    * label *label54
+  157 set :compute.0:i 0
+  158 label *label129
+  159 label *label130
+  160 set :compute.0:x1 :compute.0:zx
+  161 op mul *tmp59 :compute.0:zx :compute.0:zx
+  162 op mul *tmp60 :compute.0:zy :compute.0:zy
+  163 op sub *tmp61 *tmp59 *tmp60
+  164 op add :compute.0:zx *tmp61 :compute.0:cx
+  165 op mul *tmp63 2 :compute.0:x1
+  166 op mul *tmp64 *tmp63 :compute.0:zy
+  167 op add :compute.0:zy *tmp64 :compute.0:cy
+  168 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  169 jump *label131 lessThan :compute.0:dist 64
+  170 jump *label54 always
+  171 label *label131
+  172 label *label132
+  173 label *label133
+  174 op add :compute.0:i :compute.0:i 1
+  175 label *label134
+  176 set :compute.0:x1 :compute.0:zx
+  177 op mul *tmp59 :compute.0:zx :compute.0:zx
+  178 op mul *tmp60 :compute.0:zy :compute.0:zy
+  179 op sub *tmp61 *tmp59 *tmp60
+  180 op add :compute.0:zx *tmp61 :compute.0:cx
+  181 op mul *tmp63 2 :compute.0:x1
+  182 op mul *tmp64 *tmp63 :compute.0:zy
+  183 op add :compute.0:zy *tmp64 :compute.0:cy
+  184 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  185 jump *label135 lessThan :compute.0:dist 64
+  186 jump *label54 always
+  187 label *label135
+  188 label *label136
+  189 label *label137
+  190 op add :compute.0:i :compute.0:i 1
+  191 label *label138
+  192 set :compute.0:x1 :compute.0:zx
+  193 op mul *tmp59 :compute.0:zx :compute.0:zx
+  194 op mul *tmp60 :compute.0:zy :compute.0:zy
+  195 op sub *tmp61 *tmp59 *tmp60
+  196 op add :compute.0:zx *tmp61 :compute.0:cx
+  197 op mul *tmp63 2 :compute.0:x1
+  198 op mul *tmp64 *tmp63 :compute.0:zy
+  199 op add :compute.0:zy *tmp64 :compute.0:cy
+  200 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  201 jump *label139 lessThan :compute.0:dist 64
+  202 jump *label54 always
+  203 label *label139
+  204 label *label140
+  205 label *label141
+  206 op add :compute.0:i :compute.0:i 1
+  207 label *label142
+  208 set :compute.0:x1 :compute.0:zx
+  209 op mul *tmp59 :compute.0:zx :compute.0:zx
+  210 op mul *tmp60 :compute.0:zy :compute.0:zy
+  211 op sub *tmp61 *tmp59 *tmp60
+  212 op add :compute.0:zx *tmp61 :compute.0:cx
+  213 op mul *tmp63 2 :compute.0:x1
+  214 op mul *tmp64 *tmp63 :compute.0:zy
+  215 op add :compute.0:zy *tmp64 :compute.0:cy
+  216 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  217 jump *label143 lessThan :compute.0:dist 64
+  218 jump *label54 always
+  219 label *label143
+  220 label *label144
+  221 label *label145
+  222 op add :compute.0:i :compute.0:i 1
+  223 label *label146
+  224 set :compute.0:x1 :compute.0:zx
+  225 op mul *tmp59 :compute.0:zx :compute.0:zx
+  226 op mul *tmp60 :compute.0:zy :compute.0:zy
+  227 op sub *tmp61 *tmp59 *tmp60
+  228 op add :compute.0:zx *tmp61 :compute.0:cx
+  229 op mul *tmp63 2 :compute.0:x1
+  230 op mul *tmp64 *tmp63 :compute.0:zy
+  231 op add :compute.0:zy *tmp64 :compute.0:cy
+  232 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  233 jump *label147 lessThan :compute.0:dist 64
+  234 jump *label54 always
+  235 label *label147
+  236 label *label148
+  237 label *label149
+  238 op add :compute.0:i :compute.0:i 1
+  239 label *label150
+  240 set :compute.0:x1 :compute.0:zx
+  241 op mul *tmp59 :compute.0:zx :compute.0:zx
+  242 op mul *tmp60 :compute.0:zy :compute.0:zy
+  243 op sub *tmp61 *tmp59 *tmp60
+  244 op add :compute.0:zx *tmp61 :compute.0:cx
+  245 op mul *tmp63 2 :compute.0:x1
+  246 op mul *tmp64 *tmp63 :compute.0:zy
+  247 op add :compute.0:zy *tmp64 :compute.0:cy
+  248 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  249 jump *label151 lessThan :compute.0:dist 64
+  250 jump *label54 always
+  251 label *label151
+  252 label *label152
+  253 label *label153
+  254 op add :compute.0:i :compute.0:i 1
+  255 label *label154
+  256 set :compute.0:x1 :compute.0:zx
+  257 op mul *tmp59 :compute.0:zx :compute.0:zx
+  258 op mul *tmp60 :compute.0:zy :compute.0:zy
+  259 op sub *tmp61 *tmp59 *tmp60
+  260 op add :compute.0:zx *tmp61 :compute.0:cx
+  261 op mul *tmp63 2 :compute.0:x1
+  262 op mul *tmp64 *tmp63 :compute.0:zy
+  263 op add :compute.0:zy *tmp64 :compute.0:cy
+  264 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  265 jump *label155 lessThan :compute.0:dist 64
+  266 jump *label54 always
+  267 label *label155
+  268 label *label156
+  269 label *label157
+  270 op add :compute.0:i :compute.0:i 1
+  271 label *label158
+  272 set :compute.0:x1 :compute.0:zx
+  273 op mul *tmp59 :compute.0:zx :compute.0:zx
+  274 op mul *tmp60 :compute.0:zy :compute.0:zy
+  275 op sub *tmp61 *tmp59 *tmp60
+  276 op add :compute.0:zx *tmp61 :compute.0:cx
+  277 op mul *tmp63 2 :compute.0:x1
+  278 op mul *tmp64 *tmp63 :compute.0:zy
+  279 op add :compute.0:zy *tmp64 :compute.0:cy
+  280 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  281 jump *label159 lessThan :compute.0:dist 64
+  282 jump *label54 always
+  283 label *label159
+  284 label *label160
+  285 label *label161
+  286 op add :compute.0:i :compute.0:i 1
+  287 label *label162
+  288 set :compute.0:x1 :compute.0:zx
+  289 op mul *tmp59 :compute.0:zx :compute.0:zx
+  290 op mul *tmp60 :compute.0:zy :compute.0:zy
+  291 op sub *tmp61 *tmp59 *tmp60
+  292 op add :compute.0:zx *tmp61 :compute.0:cx
+  293 op mul *tmp63 2 :compute.0:x1
+  294 op mul *tmp64 *tmp63 :compute.0:zy
+  295 op add :compute.0:zy *tmp64 :compute.0:cy
+  296 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  297 jump *label163 lessThan :compute.0:dist 64
+  298 jump *label54 always
+  299 label *label163
+  300 label *label164
+  301 label *label165
+  302 op add :compute.0:i :compute.0:i 1
+  303 label *label166
+  304 set :compute.0:x1 :compute.0:zx
+  305 op mul *tmp59 :compute.0:zx :compute.0:zx
+  306 op mul *tmp60 :compute.0:zy :compute.0:zy
+  307 op sub *tmp61 *tmp59 *tmp60
+  308 op add :compute.0:zx *tmp61 :compute.0:cx
+  309 op mul *tmp63 2 :compute.0:x1
+  310 op mul *tmp64 *tmp63 :compute.0:zy
+  311 op add :compute.0:zy *tmp64 :compute.0:cy
+  312 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  313 jump *label167 lessThan :compute.0:dist 64
+  314 jump *label54 always
+  315 label *label167
+  316 label *label168
+  317 label *label169
+  318 op add :compute.0:i :compute.0:i 1
+  319 label *label170
+  320 set :compute.0:x1 :compute.0:zx
+  321 op mul *tmp59 :compute.0:zx :compute.0:zx
+  322 op mul *tmp60 :compute.0:zy :compute.0:zy
+  323 op sub *tmp61 *tmp59 *tmp60
+  324 op add :compute.0:zx *tmp61 :compute.0:cx
+  325 op mul *tmp63 2 :compute.0:x1
+  326 op mul *tmp64 *tmp63 :compute.0:zy
+  327 op add :compute.0:zy *tmp64 :compute.0:cy
+  328 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  329 jump *label171 lessThan :compute.0:dist 64
+  330 jump *label54 always
+  331 label *label171
+  332 label *label172
+  333 label *label173
+  334 op add :compute.0:i :compute.0:i 1
+  335 label *label174
+  336 set :compute.0:x1 :compute.0:zx
+  337 op mul *tmp59 :compute.0:zx :compute.0:zx
+  338 op mul *tmp60 :compute.0:zy :compute.0:zy
+  339 op sub *tmp61 *tmp59 *tmp60
+  340 op add :compute.0:zx *tmp61 :compute.0:cx
+  341 op mul *tmp63 2 :compute.0:x1
+  342 op mul *tmp64 *tmp63 :compute.0:zy
+  343 op add :compute.0:zy *tmp64 :compute.0:cy
+  344 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  345 jump *label175 lessThan :compute.0:dist 64
+  346 jump *label54 always
+  347 label *label175
+  348 label *label176
+  349 label *label177
+  350 op add :compute.0:i :compute.0:i 1
+  351 label *label178
+  352 set :compute.0:x1 :compute.0:zx
+  353 op mul *tmp59 :compute.0:zx :compute.0:zx
+  354 op mul *tmp60 :compute.0:zy :compute.0:zy
+  355 op sub *tmp61 *tmp59 *tmp60
+  356 op add :compute.0:zx *tmp61 :compute.0:cx
+  357 op mul *tmp63 2 :compute.0:x1
+  358 op mul *tmp64 *tmp63 :compute.0:zy
+  359 op add :compute.0:zy *tmp64 :compute.0:cy
+  360 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  361 jump *label179 lessThan :compute.0:dist 64
+  362 jump *label54 always
+  363 label *label179
+  364 label *label180
+  365 label *label181
+  366 op add :compute.0:i :compute.0:i 1
+  367 label *label182
+  368 set :compute.0:x1 :compute.0:zx
+  369 op mul *tmp59 :compute.0:zx :compute.0:zx
+  370 op mul *tmp60 :compute.0:zy :compute.0:zy
+  371 op sub *tmp61 *tmp59 *tmp60
+  372 op add :compute.0:zx *tmp61 :compute.0:cx
+  373 op mul *tmp63 2 :compute.0:x1
+  374 op mul *tmp64 *tmp63 :compute.0:zy
+  375 op add :compute.0:zy *tmp64 :compute.0:cy
+  376 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  377 jump *label183 lessThan :compute.0:dist 64
+  378 jump *label54 always
+  379 label *label183
+  380 label *label184
+  381 label *label185
+  382 op add :compute.0:i :compute.0:i 1
+  383 label *label186
+  384 set :compute.0:x1 :compute.0:zx
+  385 op mul *tmp59 :compute.0:zx :compute.0:zx
+  386 op mul *tmp60 :compute.0:zy :compute.0:zy
+  387 op sub *tmp61 *tmp59 *tmp60
+  388 op add :compute.0:zx *tmp61 :compute.0:cx
+  389 op mul *tmp63 2 :compute.0:x1
+  390 op mul *tmp64 *tmp63 :compute.0:zy
+  391 op add :compute.0:zy *tmp64 :compute.0:cy
+  392 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  393 jump *label187 lessThan :compute.0:dist 64
+  394 jump *label54 always
+  395 label *label187
+  396 label *label188
+  397 label *label189
+  398 op add :compute.0:i :compute.0:i 1
+  399 label *label190
+  400 set :compute.0:x1 :compute.0:zx
+  401 op mul *tmp59 :compute.0:zx :compute.0:zx
+  402 op mul *tmp60 :compute.0:zy :compute.0:zy
+  403 op sub *tmp61 *tmp59 *tmp60
+  404 op add :compute.0:zx *tmp61 :compute.0:cx
+  405 op mul *tmp63 2 :compute.0:x1
+  406 op mul *tmp64 *tmp63 :compute.0:zy
+  407 op add :compute.0:zy *tmp64 :compute.0:cy
+  408 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  409 jump *label191 lessThan :compute.0:dist 64
+  410 jump *label54 always
+  411 label *label191
+  412 label *label192
+  413 label *label193
+  414 op add :compute.0:i :compute.0:i 1
+  415 label *label194
+  416 set :compute.0:x1 :compute.0:zx
+  417 op mul *tmp59 :compute.0:zx :compute.0:zx
+  418 op mul *tmp60 :compute.0:zy :compute.0:zy
+  419 op sub *tmp61 *tmp59 *tmp60
+  420 op add :compute.0:zx *tmp61 :compute.0:cx
+  421 op mul *tmp63 2 :compute.0:x1
+  422 op mul *tmp64 *tmp63 :compute.0:zy
+  423 op add :compute.0:zy *tmp64 :compute.0:cy
+  424 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  425 jump *label195 lessThan :compute.0:dist 64
+  426 jump *label54 always
+  427 label *label195
+  428 label *label196
+  429 label *label197
+  430 op add :compute.0:i :compute.0:i 1
+  431 label *label198
+  432 set :compute.0:x1 :compute.0:zx
+  433 op mul *tmp59 :compute.0:zx :compute.0:zx
+  434 op mul *tmp60 :compute.0:zy :compute.0:zy
+  435 op sub *tmp61 *tmp59 *tmp60
+  436 op add :compute.0:zx *tmp61 :compute.0:cx
+  437 op mul *tmp63 2 :compute.0:x1
+  438 op mul *tmp64 *tmp63 :compute.0:zy
+  439 op add :compute.0:zy *tmp64 :compute.0:cy
+  440 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  441 jump *label199 lessThan :compute.0:dist 64
+  442 jump *label54 always
+  443 label *label199
+  444 label *label200
+  445 label *label201
+  446 op add :compute.0:i :compute.0:i 1
+  447 label *label202
+  448 set :compute.0:x1 :compute.0:zx
+  449 op mul *tmp59 :compute.0:zx :compute.0:zx
+  450 op mul *tmp60 :compute.0:zy :compute.0:zy
+  451 op sub *tmp61 *tmp59 *tmp60
+  452 op add :compute.0:zx *tmp61 :compute.0:cx
+  453 op mul *tmp63 2 :compute.0:x1
+  454 op mul *tmp64 *tmp63 :compute.0:zy
+  455 op add :compute.0:zy *tmp64 :compute.0:cy
+  456 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  457 jump *label203 lessThan :compute.0:dist 64
+  458 jump *label54 always
+  459 label *label203
+  460 label *label204
+  461 label *label205
+  462 op add :compute.0:i :compute.0:i 1
+  463 label *label206
+  464 set :compute.0:x1 :compute.0:zx
+  465 op mul *tmp59 :compute.0:zx :compute.0:zx
+  466 op mul *tmp60 :compute.0:zy :compute.0:zy
+  467 op sub *tmp61 *tmp59 *tmp60
+  468 op add :compute.0:zx *tmp61 :compute.0:cx
+  469 op mul *tmp63 2 :compute.0:x1
+  470 op mul *tmp64 *tmp63 :compute.0:zy
+  471 op add :compute.0:zy *tmp64 :compute.0:cy
+  472 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  473 jump *label207 lessThan :compute.0:dist 64
+  474 jump *label54 always
+  475 label *label207
+  476 label *label208
+  477 label *label209
+  478 op add :compute.0:i :compute.0:i 1
+  479 label *label210
+  480 set :compute.0:x1 :compute.0:zx
+  481 op mul *tmp59 :compute.0:zx :compute.0:zx
+  482 op mul *tmp60 :compute.0:zy :compute.0:zy
+  483 op sub *tmp61 *tmp59 *tmp60
+  484 op add :compute.0:zx *tmp61 :compute.0:cx
+  485 op mul *tmp63 2 :compute.0:x1
+  486 op mul *tmp64 *tmp63 :compute.0:zy
+  487 op add :compute.0:zy *tmp64 :compute.0:cy
+  488 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  489 jump *label211 lessThan :compute.0:dist 64
+  490 jump *label54 always
+  491 label *label211
+  492 label *label212
+  493 label *label213
+  494 op add :compute.0:i :compute.0:i 1
+  495 label *label214
+  496 set :compute.0:x1 :compute.0:zx
+  497 op mul *tmp59 :compute.0:zx :compute.0:zx
+  498 op mul *tmp60 :compute.0:zy :compute.0:zy
+  499 op sub *tmp61 *tmp59 *tmp60
+  500 op add :compute.0:zx *tmp61 :compute.0:cx
+  501 op mul *tmp63 2 :compute.0:x1
+  502 op mul *tmp64 *tmp63 :compute.0:zy
+  503 op add :compute.0:zy *tmp64 :compute.0:cy
+  504 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  505 jump *label215 lessThan :compute.0:dist 64
+  506 jump *label54 always
+  507 label *label215
+  508 label *label216
+  509 label *label217
+  510 op add :compute.0:i :compute.0:i 1
+  511 label *label218
+  512 set :compute.0:x1 :compute.0:zx
+  513 op mul *tmp59 :compute.0:zx :compute.0:zx
+  514 op mul *tmp60 :compute.0:zy :compute.0:zy
+  515 op sub *tmp61 *tmp59 *tmp60
+  516 op add :compute.0:zx *tmp61 :compute.0:cx
+  517 op mul *tmp63 2 :compute.0:x1
+  518 op mul *tmp64 *tmp63 :compute.0:zy
+  519 op add :compute.0:zy *tmp64 :compute.0:cy
+  520 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  521 jump *label219 lessThan :compute.0:dist 64
+  522 jump *label54 always
+  523 label *label219
+  524 label *label220
+  525 label *label221
+  526 op add :compute.0:i :compute.0:i 1
+  527 label *label222
+  528 set :compute.0:x1 :compute.0:zx
+  529 op mul *tmp59 :compute.0:zx :compute.0:zx
+  530 op mul *tmp60 :compute.0:zy :compute.0:zy
+  531 op sub *tmp61 *tmp59 *tmp60
+  532 op add :compute.0:zx *tmp61 :compute.0:cx
+  533 op mul *tmp63 2 :compute.0:x1
+  534 op mul *tmp64 *tmp63 :compute.0:zy
+  535 op add :compute.0:zy *tmp64 :compute.0:cy
+  536 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  537 jump *label223 lessThan :compute.0:dist 64
+  538 jump *label54 always
+  539 label *label223
+  540 label *label224
+  541 label *label225
+  542 op add :compute.0:i :compute.0:i 1
+  543 label *label226
+  544 set :compute.0:x1 :compute.0:zx
+  545 op mul *tmp59 :compute.0:zx :compute.0:zx
+  546 op mul *tmp60 :compute.0:zy :compute.0:zy
+  547 op sub *tmp61 *tmp59 *tmp60
+  548 op add :compute.0:zx *tmp61 :compute.0:cx
+  549 op mul *tmp63 2 :compute.0:x1
+  550 op mul *tmp64 *tmp63 :compute.0:zy
+  551 op add :compute.0:zy *tmp64 :compute.0:cy
+  552 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  553 jump *label227 lessThan :compute.0:dist 64
+  554 jump *label54 always
+  555 label *label227
+  556 label *label228
+  557 label *label229
+  558 op add :compute.0:i :compute.0:i 1
+  559 label *label230
+  560 set :compute.0:x1 :compute.0:zx
+  561 op mul *tmp59 :compute.0:zx :compute.0:zx
+  562 op mul *tmp60 :compute.0:zy :compute.0:zy
+  563 op sub *tmp61 *tmp59 *tmp60
+  564 op add :compute.0:zx *tmp61 :compute.0:cx
+  565 op mul *tmp63 2 :compute.0:x1
+  566 op mul *tmp64 *tmp63 :compute.0:zy
+  567 op add :compute.0:zy *tmp64 :compute.0:cy
+  568 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  569 jump *label231 lessThan :compute.0:dist 64
+  570 jump *label54 always
+  571 label *label231
+  572 label *label232
+  573 label *label233
+  574 op add :compute.0:i :compute.0:i 1
+  575 label *label234
+  576 set :compute.0:x1 :compute.0:zx
+  577 op mul *tmp59 :compute.0:zx :compute.0:zx
+  578 op mul *tmp60 :compute.0:zy :compute.0:zy
+  579 op sub *tmp61 *tmp59 *tmp60
+  580 op add :compute.0:zx *tmp61 :compute.0:cx
+  581 op mul *tmp63 2 :compute.0:x1
+  582 op mul *tmp64 *tmp63 :compute.0:zy
+  583 op add :compute.0:zy *tmp64 :compute.0:cy
+  584 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  585 jump *label235 lessThan :compute.0:dist 64
+  586 jump *label54 always
+  587 label *label235
+  588 label *label236
+  589 label *label237
+  590 op add :compute.0:i :compute.0:i 1
+  591 label *label238
+  592 set :compute.0:x1 :compute.0:zx
+  593 op mul *tmp59 :compute.0:zx :compute.0:zx
+  594 op mul *tmp60 :compute.0:zy :compute.0:zy
+  595 op sub *tmp61 *tmp59 *tmp60
+  596 op add :compute.0:zx *tmp61 :compute.0:cx
+  597 op mul *tmp63 2 :compute.0:x1
+  598 op mul *tmp64 *tmp63 :compute.0:zy
+  599 op add :compute.0:zy *tmp64 :compute.0:cy
+  600 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  601 jump *label239 lessThan :compute.0:dist 64
+  602 jump *label54 always
+  603 label *label239
+  604 label *label240
+  605 label *label241
+  606 op add :compute.0:i :compute.0:i 1
+  607 label *label242
+  608 set :compute.0:x1 :compute.0:zx
+  609 op mul *tmp59 :compute.0:zx :compute.0:zx
+  610 op mul *tmp60 :compute.0:zy :compute.0:zy
+  611 op sub *tmp61 *tmp59 *tmp60
+  612 op add :compute.0:zx *tmp61 :compute.0:cx
+  613 op mul *tmp63 2 :compute.0:x1
+  614 op mul *tmp64 *tmp63 :compute.0:zy
+  615 op add :compute.0:zy *tmp64 :compute.0:cy
+  616 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  617 jump *label243 lessThan :compute.0:dist 64
+  618 jump *label54 always
+  619 label *label243
+  620 label *label244
+  621 label *label245
+  622 op add :compute.0:i :compute.0:i 1
+  623 label *label246
+  624 set :compute.0:x1 :compute.0:zx
+  625 op mul *tmp59 :compute.0:zx :compute.0:zx
+  626 op mul *tmp60 :compute.0:zy :compute.0:zy
+  627 op sub *tmp61 *tmp59 *tmp60
+  628 op add :compute.0:zx *tmp61 :compute.0:cx
+  629 op mul *tmp63 2 :compute.0:x1
+  630 op mul *tmp64 *tmp63 :compute.0:zy
+  631 op add :compute.0:zy *tmp64 :compute.0:cy
+  632 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  633 jump *label247 lessThan :compute.0:dist 64
+  634 jump *label54 always
+  635 label *label247
+  636 label *label248
+  637 label *label249
+  638 op add :compute.0:i :compute.0:i 1
+  639 label *label250
+  640 set :compute.0:x1 :compute.0:zx
+  641 op mul *tmp59 :compute.0:zx :compute.0:zx
+  642 op mul *tmp60 :compute.0:zy :compute.0:zy
+  643 op sub *tmp61 *tmp59 *tmp60
+  644 op add :compute.0:zx *tmp61 :compute.0:cx
+  645 op mul *tmp63 2 :compute.0:x1
+  646 op mul *tmp64 *tmp63 :compute.0:zy
+  647 op add :compute.0:zy *tmp64 :compute.0:cy
+  648 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  649 jump *label251 lessThan :compute.0:dist 64
+  650 jump *label54 always
+  651 label *label251
+  652 label *label252
+  653 label *label253
+  654 op add :compute.0:i :compute.0:i 1
+  655 label *label254
+  656 set :compute.0:x1 :compute.0:zx
+  657 op mul *tmp59 :compute.0:zx :compute.0:zx
+  658 op mul *tmp60 :compute.0:zy :compute.0:zy
+  659 op sub *tmp61 *tmp59 *tmp60
+  660 op add :compute.0:zx *tmp61 :compute.0:cx
+  661 op mul *tmp63 2 :compute.0:x1
+  662 op mul *tmp64 *tmp63 :compute.0:zy
+  663 op add :compute.0:zy *tmp64 :compute.0:cy
+  664 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  665 jump *label255 lessThan :compute.0:dist 64
+  666 jump *label54 always
+  667 label *label255
+  668 label *label256
+  669 label *label257
+  670 op add :compute.0:i :compute.0:i 1
+  671 label *label258
+  672 set :compute.0:x1 :compute.0:zx
+  673 op mul *tmp59 :compute.0:zx :compute.0:zx
+  674 op mul *tmp60 :compute.0:zy :compute.0:zy
+  675 op sub *tmp61 *tmp59 *tmp60
+  676 op add :compute.0:zx *tmp61 :compute.0:cx
+  677 op mul *tmp63 2 :compute.0:x1
+  678 op mul *tmp64 *tmp63 :compute.0:zy
+  679 op add :compute.0:zy *tmp64 :compute.0:cy
+  680 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  681 jump *label259 lessThan :compute.0:dist 64
+  682 jump *label54 always
+  683 label *label259
+  684 label *label260
+  685 label *label261
+  686 op add :compute.0:i :compute.0:i 1
+  687 label *label262
+  688 set :compute.0:x1 :compute.0:zx
+  689 op mul *tmp59 :compute.0:zx :compute.0:zx
+  690 op mul *tmp60 :compute.0:zy :compute.0:zy
+  691 op sub *tmp61 *tmp59 *tmp60
+  692 op add :compute.0:zx *tmp61 :compute.0:cx
+  693 op mul *tmp63 2 :compute.0:x1
+  694 op mul *tmp64 *tmp63 :compute.0:zy
+  695 op add :compute.0:zy *tmp64 :compute.0:cy
+  696 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  697 jump *label263 lessThan :compute.0:dist 64
+  698 jump *label54 always
+  699 label *label263
+  700 label *label264
+  701 label *label265
+  702 op add :compute.0:i :compute.0:i 1
+  703 label *label266
+  704 set :compute.0:x1 :compute.0:zx
+  705 op mul *tmp59 :compute.0:zx :compute.0:zx
+  706 op mul *tmp60 :compute.0:zy :compute.0:zy
+  707 op sub *tmp61 *tmp59 *tmp60
+  708 op add :compute.0:zx *tmp61 :compute.0:cx
+  709 op mul *tmp63 2 :compute.0:x1
+  710 op mul *tmp64 *tmp63 :compute.0:zy
+  711 op add :compute.0:zy *tmp64 :compute.0:cy
+  712 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  713 jump *label267 lessThan :compute.0:dist 64
+  714 jump *label54 always
+  715 label *label267
+  716 label *label268
+  717 label *label269
+  718 op add :compute.0:i :compute.0:i 1
+  719 label *label270
+  720 set :compute.0:x1 :compute.0:zx
+  721 op mul *tmp59 :compute.0:zx :compute.0:zx
+  722 op mul *tmp60 :compute.0:zy :compute.0:zy
+  723 op sub *tmp61 *tmp59 *tmp60
+  724 op add :compute.0:zx *tmp61 :compute.0:cx
+  725 op mul *tmp63 2 :compute.0:x1
+  726 op mul *tmp64 *tmp63 :compute.0:zy
+  727 op add :compute.0:zy *tmp64 :compute.0:cy
+  728 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  729 jump *label271 lessThan :compute.0:dist 64
+  730 jump *label54 always
+  731 label *label271
+  732 label *label272
+  733 label *label273
+  734 op add :compute.0:i :compute.0:i 1
+  735 label *label274
+  736 set :compute.0:x1 :compute.0:zx
+  737 op mul *tmp59 :compute.0:zx :compute.0:zx
+  738 op mul *tmp60 :compute.0:zy :compute.0:zy
+  739 op sub *tmp61 *tmp59 *tmp60
+  740 op add :compute.0:zx *tmp61 :compute.0:cx
+  741 op mul *tmp63 2 :compute.0:x1
+  742 op mul *tmp64 *tmp63 :compute.0:zy
+  743 op add :compute.0:zy *tmp64 :compute.0:cy
+  744 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  745 jump *label275 lessThan :compute.0:dist 64
+  746 jump *label54 always
+  747 label *label275
+  748 label *label276
+  749 label *label277
+  750 op add :compute.0:i :compute.0:i 1
+  751 label *label278
+  752 set :compute.0:x1 :compute.0:zx
+  753 op mul *tmp59 :compute.0:zx :compute.0:zx
+  754 op mul *tmp60 :compute.0:zy :compute.0:zy
+  755 op sub *tmp61 *tmp59 *tmp60
+  756 op add :compute.0:zx *tmp61 :compute.0:cx
+  757 op mul *tmp63 2 :compute.0:x1
+  758 op mul *tmp64 *tmp63 :compute.0:zy
+  759 op add :compute.0:zy *tmp64 :compute.0:cy
+  760 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  761 jump *label279 lessThan :compute.0:dist 64
+  762 jump *label54 always
+  763 label *label279
+  764 label *label280
+  765 label *label281
+  766 op add :compute.0:i :compute.0:i 1
+  767 label *label282
+  768 set :compute.0:x1 :compute.0:zx
+  769 op mul *tmp59 :compute.0:zx :compute.0:zx
+  770 op mul *tmp60 :compute.0:zy :compute.0:zy
+  771 op sub *tmp61 *tmp59 *tmp60
+  772 op add :compute.0:zx *tmp61 :compute.0:cx
+  773 op mul *tmp63 2 :compute.0:x1
+  774 op mul *tmp64 *tmp63 :compute.0:zy
+  775 op add :compute.0:zy *tmp64 :compute.0:cy
+  776 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  777 jump *label283 lessThan :compute.0:dist 64
+  778 jump *label54 always
+  779 label *label283
+  780 label *label284
+  781 label *label285
+  782 op add :compute.0:i :compute.0:i 1
+  783 label *label286
+  784 set :compute.0:x1 :compute.0:zx
+  785 op mul *tmp59 :compute.0:zx :compute.0:zx
+  786 op mul *tmp60 :compute.0:zy :compute.0:zy
+  787 op sub *tmp61 *tmp59 *tmp60
+  788 op add :compute.0:zx *tmp61 :compute.0:cx
+  789 op mul *tmp63 2 :compute.0:x1
+  790 op mul *tmp64 *tmp63 :compute.0:zy
+  791 op add :compute.0:zy *tmp64 :compute.0:cy
+  792 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  793 jump *label287 lessThan :compute.0:dist 64
+  794 jump *label54 always
+  795 label *label287
+  796 label *label288
+  797 label *label289
+  798 op add :compute.0:i :compute.0:i 1
+  799 label *label290
+  800 set :compute.0:x1 :compute.0:zx
+  801 op mul *tmp59 :compute.0:zx :compute.0:zx
+  802 op mul *tmp60 :compute.0:zy :compute.0:zy
+  803 op sub *tmp61 *tmp59 *tmp60
+  804 op add :compute.0:zx *tmp61 :compute.0:cx
+  805 op mul *tmp63 2 :compute.0:x1
+  806 op mul *tmp64 *tmp63 :compute.0:zy
+  807 op add :compute.0:zy *tmp64 :compute.0:cy
+  808 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  809 jump *label291 lessThan :compute.0:dist 64
+  810 jump *label54 always
+  811 label *label291
+  812 label *label292
+  813 label *label293
+  814 op add :compute.0:i :compute.0:i 1
+  815 label *label294
+  816 set :compute.0:x1 :compute.0:zx
+  817 op mul *tmp59 :compute.0:zx :compute.0:zx
+  818 op mul *tmp60 :compute.0:zy :compute.0:zy
+  819 op sub *tmp61 *tmp59 *tmp60
+  820 op add :compute.0:zx *tmp61 :compute.0:cx
+  821 op mul *tmp63 2 :compute.0:x1
+  822 op mul *tmp64 *tmp63 :compute.0:zy
+  823 op add :compute.0:zy *tmp64 :compute.0:cy
+  824 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  825 jump *label295 lessThan :compute.0:dist 64
+  826 jump *label54 always
+  827 label *label295
+  828 label *label296
+  829 label *label297
+  830 op add :compute.0:i :compute.0:i 1
+  831 label *label298
+  832 set :compute.0:x1 :compute.0:zx
+  833 op mul *tmp59 :compute.0:zx :compute.0:zx
+  834 op mul *tmp60 :compute.0:zy :compute.0:zy
+  835 op sub *tmp61 *tmp59 *tmp60
+  836 op add :compute.0:zx *tmp61 :compute.0:cx
+  837 op mul *tmp63 2 :compute.0:x1
+  838 op mul *tmp64 *tmp63 :compute.0:zy
+  839 op add :compute.0:zy *tmp64 :compute.0:cy
+  840 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  841 jump *label299 lessThan :compute.0:dist 64
+  842 jump *label54 always
+  843 label *label299
+  844 label *label300
+  845 label *label301
+  846 op add :compute.0:i :compute.0:i 1
+  847 label *label302
+  848 set :compute.0:x1 :compute.0:zx
+  849 op mul *tmp59 :compute.0:zx :compute.0:zx
+  850 op mul *tmp60 :compute.0:zy :compute.0:zy
+  851 op sub *tmp61 *tmp59 *tmp60
+  852 op add :compute.0:zx *tmp61 :compute.0:cx
+  853 op mul *tmp63 2 :compute.0:x1
+  854 op mul *tmp64 *tmp63 :compute.0:zy
+  855 op add :compute.0:zy *tmp64 :compute.0:cy
+  856 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  857 jump *label303 lessThan :compute.0:dist 64
+  858 jump *label54 always
+  859 label *label303
+  860 label *label304
+  861 label *label305
+  862 op add :compute.0:i :compute.0:i 1
+  863 label *label306
+  864 set :compute.0:x1 :compute.0:zx
+  865 op mul *tmp59 :compute.0:zx :compute.0:zx
+  866 op mul *tmp60 :compute.0:zy :compute.0:zy
+  867 op sub *tmp61 *tmp59 *tmp60
+  868 op add :compute.0:zx *tmp61 :compute.0:cx
+  869 op mul *tmp63 2 :compute.0:x1
+  870 op mul *tmp64 *tmp63 :compute.0:zy
+  871 op add :compute.0:zy *tmp64 :compute.0:cy
+  872 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  873 jump *label307 lessThan :compute.0:dist 64
+  874 jump *label54 always
+  875 label *label307
+  876 label *label308
+  877 label *label309
+  878 op add :compute.0:i :compute.0:i 1
+  879 label *label310
+  880 set :compute.0:x1 :compute.0:zx
+  881 op mul *tmp59 :compute.0:zx :compute.0:zx
+  882 op mul *tmp60 :compute.0:zy :compute.0:zy
+  883 op sub *tmp61 *tmp59 *tmp60
+  884 op add :compute.0:zx *tmp61 :compute.0:cx
+  885 op mul *tmp63 2 :compute.0:x1
+  886 op mul *tmp64 *tmp63 :compute.0:zy
+  887 op add :compute.0:zy *tmp64 :compute.0:cy
+  888 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  889 jump *label311 lessThan :compute.0:dist 64
+  890 jump *label54 always
+  891 label *label311
+  892 label *label312
+  893 label *label313
+  894 op add :compute.0:i :compute.0:i 1
+  895 label *label314
+  896 set :compute.0:x1 :compute.0:zx
+  897 op mul *tmp59 :compute.0:zx :compute.0:zx
+  898 op mul *tmp60 :compute.0:zy :compute.0:zy
+  899 op sub *tmp61 *tmp59 *tmp60
+  900 op add :compute.0:zx *tmp61 :compute.0:cx
+  901 op mul *tmp63 2 :compute.0:x1
+  902 op mul *tmp64 *tmp63 :compute.0:zy
+  903 op add :compute.0:zy *tmp64 :compute.0:cy
+  904 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  905 jump *label315 lessThan :compute.0:dist 64
+  906 jump *label54 always
+  907 label *label315
+  908 label *label316
+  909 label *label317
+  910 op add :compute.0:i :compute.0:i 1
+  911 label *label318
+  912 set :compute.0:x1 :compute.0:zx
+  913 op mul *tmp59 :compute.0:zx :compute.0:zx
+  914 op mul *tmp60 :compute.0:zy :compute.0:zy
+  915 op sub *tmp61 *tmp59 *tmp60
+  916 op add :compute.0:zx *tmp61 :compute.0:cx
+  917 op mul *tmp63 2 :compute.0:x1
+  918 op mul *tmp64 *tmp63 :compute.0:zy
+  919 op add :compute.0:zy *tmp64 :compute.0:cy
+  920 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  921 jump *label319 lessThan :compute.0:dist 64
+  922 jump *label54 always
+  923 label *label319
+  924 label *label320
+  925 label *label321
+  926 op add :compute.0:i :compute.0:i 1
+  927 label *label322
+  928 set :compute.0:x1 :compute.0:zx
+  929 op mul *tmp59 :compute.0:zx :compute.0:zx
+  930 op mul *tmp60 :compute.0:zy :compute.0:zy
+  931 op sub *tmp61 *tmp59 *tmp60
+  932 op add :compute.0:zx *tmp61 :compute.0:cx
+  933 op mul *tmp63 2 :compute.0:x1
+  934 op mul *tmp64 *tmp63 :compute.0:zy
+  935 op add :compute.0:zy *tmp64 :compute.0:cy
+  936 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  937 jump *label323 lessThan :compute.0:dist 64
+  938 jump *label54 always
+  939 label *label323
+  940 label *label324
+  941 label *label325
+  942 op add :compute.0:i :compute.0:i 1
+  943 label *label326
+  944 set :compute.0:x1 :compute.0:zx
+  945 op mul *tmp59 :compute.0:zx :compute.0:zx
+  946 op mul *tmp60 :compute.0:zy :compute.0:zy
+  947 op sub *tmp61 *tmp59 *tmp60
+  948 op add :compute.0:zx *tmp61 :compute.0:cx
+  949 op mul *tmp63 2 :compute.0:x1
+  950 op mul *tmp64 *tmp63 :compute.0:zy
+  951 op add :compute.0:zy *tmp64 :compute.0:cy
+  952 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  953 jump *label327 lessThan :compute.0:dist 64
+  954 jump *label54 always
+  955 label *label327
+  956 label *label328
+  957 label *label329
+  958 op add :compute.0:i :compute.0:i 1
+  959 label *label330
+  960 set :compute.0:x1 :compute.0:zx
+  961 op mul *tmp59 :compute.0:zx :compute.0:zx
+  962 op mul *tmp60 :compute.0:zy :compute.0:zy
+  963 op sub *tmp61 *tmp59 *tmp60
+  964 op add :compute.0:zx *tmp61 :compute.0:cx
+  965 op mul *tmp63 2 :compute.0:x1
+  966 op mul *tmp64 *tmp63 :compute.0:zy
+  967 op add :compute.0:zy *tmp64 :compute.0:cy
+  968 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  969 jump *label331 lessThan :compute.0:dist 64
+  970 jump *label54 always
+  971 label *label331
+  972 label *label332
+  973 label *label333
+  974 op add :compute.0:i :compute.0:i 1
+  975 label *label334
+  976 set :compute.0:x1 :compute.0:zx
+  977 op mul *tmp59 :compute.0:zx :compute.0:zx
+  978 op mul *tmp60 :compute.0:zy :compute.0:zy
+  979 op sub *tmp61 *tmp59 *tmp60
+  980 op add :compute.0:zx *tmp61 :compute.0:cx
+  981 op mul *tmp63 2 :compute.0:x1
+  982 op mul *tmp64 *tmp63 :compute.0:zy
+  983 op add :compute.0:zy *tmp64 :compute.0:cy
+  984 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  985 jump *label335 lessThan :compute.0:dist 64
+  986 jump *label54 always
+  987 label *label335
+  988 label *label336
+  989 label *label337
+  990 op add :compute.0:i :compute.0:i 1
+  991 label *label338
+  992 set :compute.0:x1 :compute.0:zx
+  993 op mul *tmp59 :compute.0:zx :compute.0:zx
+  994 op mul *tmp60 :compute.0:zy :compute.0:zy
+  995 op sub *tmp61 *tmp59 *tmp60
+  996 op add :compute.0:zx *tmp61 :compute.0:cx
+  997 op mul *tmp63 2 :compute.0:x1
+  998 op mul *tmp64 *tmp63 :compute.0:zy
+  999 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1000 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1001 jump *label339 lessThan :compute.0:dist 64
+ 1002 jump *label54 always
+ 1003 label *label339
+ 1004 label *label340
+ 1005 label *label341
+ 1006 op add :compute.0:i :compute.0:i 1
+ 1007 label *label342
+ 1008 set :compute.0:x1 :compute.0:zx
+ 1009 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1010 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1011 op sub *tmp61 *tmp59 *tmp60
+ 1012 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1013 op mul *tmp63 2 :compute.0:x1
+ 1014 op mul *tmp64 *tmp63 :compute.0:zy
+ 1015 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1016 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1017 jump *label343 lessThan :compute.0:dist 64
+ 1018 jump *label54 always
+ 1019 label *label343
+ 1020 label *label344
+ 1021 label *label345
+ 1022 op add :compute.0:i :compute.0:i 1
+ 1023 label *label346
+ 1024 set :compute.0:x1 :compute.0:zx
+ 1025 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1026 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1027 op sub *tmp61 *tmp59 *tmp60
+ 1028 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1029 op mul *tmp63 2 :compute.0:x1
+ 1030 op mul *tmp64 *tmp63 :compute.0:zy
+ 1031 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1032 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1033 jump *label347 lessThan :compute.0:dist 64
+ 1034 jump *label54 always
+ 1035 label *label347
+ 1036 label *label348
+ 1037 label *label349
+ 1038 op add :compute.0:i :compute.0:i 1
+ 1039 label *label350
+ 1040 set :compute.0:x1 :compute.0:zx
+ 1041 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1042 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1043 op sub *tmp61 *tmp59 *tmp60
+ 1044 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1045 op mul *tmp63 2 :compute.0:x1
+ 1046 op mul *tmp64 *tmp63 :compute.0:zy
+ 1047 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1048 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1049 jump *label351 lessThan :compute.0:dist 64
+ 1050 jump *label54 always
+ 1051 label *label351
+ 1052 label *label352
+ 1053 label *label353
+ 1054 op add :compute.0:i :compute.0:i 1
+ 1055 label *label354
+ 1056 set :compute.0:x1 :compute.0:zx
+ 1057 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1058 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1059 op sub *tmp61 *tmp59 *tmp60
+ 1060 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1061 op mul *tmp63 2 :compute.0:x1
+ 1062 op mul *tmp64 *tmp63 :compute.0:zy
+ 1063 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1064 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1065 jump *label355 lessThan :compute.0:dist 64
+ 1066 jump *label54 always
+ 1067 label *label355
+ 1068 label *label356
+ 1069 label *label357
+ 1070 op add :compute.0:i :compute.0:i 1
+ 1071 label *label358
+ 1072 set :compute.0:x1 :compute.0:zx
+ 1073 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1074 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1075 op sub *tmp61 *tmp59 *tmp60
+ 1076 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1077 op mul *tmp63 2 :compute.0:x1
+ 1078 op mul *tmp64 *tmp63 :compute.0:zy
+ 1079 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1080 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1081 jump *label359 lessThan :compute.0:dist 64
+ 1082 jump *label54 always
+ 1083 label *label359
+ 1084 label *label360
+ 1085 label *label361
+ 1086 op add :compute.0:i :compute.0:i 1
+ 1087 label *label362
+ 1088 set :compute.0:x1 :compute.0:zx
+ 1089 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1090 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1091 op sub *tmp61 *tmp59 *tmp60
+ 1092 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1093 op mul *tmp63 2 :compute.0:x1
+ 1094 op mul *tmp64 *tmp63 :compute.0:zy
+ 1095 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1096 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1097 jump *label363 lessThan :compute.0:dist 64
+ 1098 jump *label54 always
+ 1099 label *label363
+ 1100 label *label364
+ 1101 label *label365
+ 1102 op add :compute.0:i :compute.0:i 1
+ 1103 label *label366
+ 1104 set :compute.0:x1 :compute.0:zx
+ 1105 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1106 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1107 op sub *tmp61 *tmp59 *tmp60
+ 1108 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1109 op mul *tmp63 2 :compute.0:x1
+ 1110 op mul *tmp64 *tmp63 :compute.0:zy
+ 1111 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1112 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1113 jump *label367 lessThan :compute.0:dist 64
+ 1114 jump *label54 always
+ 1115 label *label367
+ 1116 label *label368
+ 1117 label *label369
+ 1118 op add :compute.0:i :compute.0:i 1
+ 1119 label *label370
+ 1120 set :compute.0:x1 :compute.0:zx
+ 1121 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1122 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1123 op sub *tmp61 *tmp59 *tmp60
+ 1124 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1125 op mul *tmp63 2 :compute.0:x1
+ 1126 op mul *tmp64 *tmp63 :compute.0:zy
+ 1127 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1128 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1129 jump *label371 lessThan :compute.0:dist 64
+ 1130 jump *label54 always
+ 1131 label *label371
+ 1132 label *label372
+ 1133 label *label373
+ 1134 op add :compute.0:i :compute.0:i 1
+ 1135 label *label374
+ 1136 set :compute.0:x1 :compute.0:zx
+ 1137 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1138 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1139 op sub *tmp61 *tmp59 *tmp60
+ 1140 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1141 op mul *tmp63 2 :compute.0:x1
+ 1142 op mul *tmp64 *tmp63 :compute.0:zy
+ 1143 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1144 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1145 jump *label375 lessThan :compute.0:dist 64
+ 1146 jump *label54 always
+ 1147 label *label375
+ 1148 label *label376
+ 1149 label *label377
+ 1150 op add :compute.0:i :compute.0:i 1
+ 1151 label *label378
+ 1152 set :compute.0:x1 :compute.0:zx
+ 1153 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1154 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1155 op sub *tmp61 *tmp59 *tmp60
+ 1156 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1157 op mul *tmp63 2 :compute.0:x1
+ 1158 op mul *tmp64 *tmp63 :compute.0:zy
+ 1159 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1160 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1161 jump *label379 lessThan :compute.0:dist 64
+ 1162 jump *label54 always
+ 1163 label *label379
+ 1164 label *label380
+ 1165 label *label381
+ 1166 op add :compute.0:i :compute.0:i 1
+ 1167 label *label54
  1168 op mul *tmp69 .SMOOTH 63
  1169 jump *label57 greaterThanEq :compute.0:i *tmp69
  1170 op log *tmp72 :compute.0:dist

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   171 label *label131
   172 label *label132
   173 label *label133
-    * op add :compute.0:i :compute.0:i 1
+  174 op add :compute.0:i 0 1
   175 label *label134
   176 set :compute.0:x1 :compute.0:zx
   177 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   187 label *label135
   188 label *label136
   189 label *label137
-    * op add :compute.0:i :compute.0:i 1
+  190 op add :compute.0:i 1 1
   191 label *label138
   192 set :compute.0:x1 :compute.0:zx
   193 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   203 label *label139
   204 label *label140
   205 label *label141
-    * op add :compute.0:i :compute.0:i 1
+  206 op add :compute.0:i 2 1
   207 label *label142
   208 set :compute.0:x1 :compute.0:zx
   209 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   219 label *label143
   220 label *label144
   221 label *label145
-    * op add :compute.0:i :compute.0:i 1
+  222 op add :compute.0:i 3 1
   223 label *label146
   224 set :compute.0:x1 :compute.0:zx
   225 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   235 label *label147
   236 label *label148
   237 label *label149
-    * op add :compute.0:i :compute.0:i 1
+  238 op add :compute.0:i 4 1
   239 label *label150
   240 set :compute.0:x1 :compute.0:zx
   241 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   251 label *label151
   252 label *label152
   253 label *label153
-    * op add :compute.0:i :compute.0:i 1
+  254 op add :compute.0:i 5 1
   255 label *label154
   256 set :compute.0:x1 :compute.0:zx
   257 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   267 label *label155
   268 label *label156
   269 label *label157
-    * op add :compute.0:i :compute.0:i 1
+  270 op add :compute.0:i 6 1
   271 label *label158
   272 set :compute.0:x1 :compute.0:zx
   273 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   283 label *label159
   284 label *label160
   285 label *label161
-    * op add :compute.0:i :compute.0:i 1
+  286 op add :compute.0:i 7 1
   287 label *label162
   288 set :compute.0:x1 :compute.0:zx
   289 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   299 label *label163
   300 label *label164
   301 label *label165
-    * op add :compute.0:i :compute.0:i 1
+  302 op add :compute.0:i 8 1
   303 label *label166
   304 set :compute.0:x1 :compute.0:zx
   305 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   315 label *label167
   316 label *label168
   317 label *label169
-    * op add :compute.0:i :compute.0:i 1
+  318 op add :compute.0:i 9 1
   319 label *label170
   320 set :compute.0:x1 :compute.0:zx
   321 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   331 label *label171
   332 label *label172
   333 label *label173
-    * op add :compute.0:i :compute.0:i 1
+  334 op add :compute.0:i 10 1
   335 label *label174
   336 set :compute.0:x1 :compute.0:zx
   337 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   347 label *label175
   348 label *label176
   349 label *label177
-    * op add :compute.0:i :compute.0:i 1
+  350 op add :compute.0:i 11 1
   351 label *label178
   352 set :compute.0:x1 :compute.0:zx
   353 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   363 label *label179
   364 label *label180
   365 label *label181
-    * op add :compute.0:i :compute.0:i 1
+  366 op add :compute.0:i 12 1
   367 label *label182
   368 set :compute.0:x1 :compute.0:zx
   369 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   379 label *label183
   380 label *label184
   381 label *label185
-    * op add :compute.0:i :compute.0:i 1
+  382 op add :compute.0:i 13 1
   383 label *label186
   384 set :compute.0:x1 :compute.0:zx
   385 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   395 label *label187
   396 label *label188
   397 label *label189
-    * op add :compute.0:i :compute.0:i 1
+  398 op add :compute.0:i 14 1
   399 label *label190
   400 set :compute.0:x1 :compute.0:zx
   401 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   411 label *label191
   412 label *label192
   413 label *label193
-    * op add :compute.0:i :compute.0:i 1
+  414 op add :compute.0:i 15 1
   415 label *label194
   416 set :compute.0:x1 :compute.0:zx
   417 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   427 label *label195
   428 label *label196
   429 label *label197
-    * op add :compute.0:i :compute.0:i 1
+  430 op add :compute.0:i 16 1
   431 label *label198
   432 set :compute.0:x1 :compute.0:zx
   433 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   443 label *label199
   444 label *label200
   445 label *label201
-    * op add :compute.0:i :compute.0:i 1
+  446 op add :compute.0:i 17 1
   447 label *label202
   448 set :compute.0:x1 :compute.0:zx
   449 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   459 label *label203
   460 label *label204
   461 label *label205
-    * op add :compute.0:i :compute.0:i 1
+  462 op add :compute.0:i 18 1
   463 label *label206
   464 set :compute.0:x1 :compute.0:zx
   465 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   475 label *label207
   476 label *label208
   477 label *label209
-    * op add :compute.0:i :compute.0:i 1
+  478 op add :compute.0:i 19 1
   479 label *label210
   480 set :compute.0:x1 :compute.0:zx
   481 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   491 label *label211
   492 label *label212
   493 label *label213
-    * op add :compute.0:i :compute.0:i 1
+  494 op add :compute.0:i 20 1
   495 label *label214
   496 set :compute.0:x1 :compute.0:zx
   497 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   507 label *label215
   508 label *label216
   509 label *label217
-    * op add :compute.0:i :compute.0:i 1
+  510 op add :compute.0:i 21 1
   511 label *label218
   512 set :compute.0:x1 :compute.0:zx
   513 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   523 label *label219
   524 label *label220
   525 label *label221
-    * op add :compute.0:i :compute.0:i 1
+  526 op add :compute.0:i 22 1
   527 label *label222
   528 set :compute.0:x1 :compute.0:zx
   529 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   539 label *label223
   540 label *label224
   541 label *label225
-    * op add :compute.0:i :compute.0:i 1
+  542 op add :compute.0:i 23 1
   543 label *label226
   544 set :compute.0:x1 :compute.0:zx
   545 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   555 label *label227
   556 label *label228
   557 label *label229
-    * op add :compute.0:i :compute.0:i 1
+  558 op add :compute.0:i 24 1
   559 label *label230
   560 set :compute.0:x1 :compute.0:zx
   561 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   571 label *label231
   572 label *label232
   573 label *label233
-    * op add :compute.0:i :compute.0:i 1
+  574 op add :compute.0:i 25 1
   575 label *label234
   576 set :compute.0:x1 :compute.0:zx
   577 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   587 label *label235
   588 label *label236
   589 label *label237
-    * op add :compute.0:i :compute.0:i 1
+  590 op add :compute.0:i 26 1
   591 label *label238
   592 set :compute.0:x1 :compute.0:zx
   593 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   603 label *label239
   604 label *label240
   605 label *label241
-    * op add :compute.0:i :compute.0:i 1
+  606 op add :compute.0:i 27 1
   607 label *label242
   608 set :compute.0:x1 :compute.0:zx
   609 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   619 label *label243
   620 label *label244
   621 label *label245
-    * op add :compute.0:i :compute.0:i 1
+  622 op add :compute.0:i 28 1
   623 label *label246
   624 set :compute.0:x1 :compute.0:zx
   625 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   635 label *label247
   636 label *label248
   637 label *label249
-    * op add :compute.0:i :compute.0:i 1
+  638 op add :compute.0:i 29 1
   639 label *label250
   640 set :compute.0:x1 :compute.0:zx
   641 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   651 label *label251
   652 label *label252
   653 label *label253
-    * op add :compute.0:i :compute.0:i 1
+  654 op add :compute.0:i 30 1
   655 label *label254
   656 set :compute.0:x1 :compute.0:zx
   657 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   667 label *label255
   668 label *label256
   669 label *label257
-    * op add :compute.0:i :compute.0:i 1
+  670 op add :compute.0:i 31 1
   671 label *label258
   672 set :compute.0:x1 :compute.0:zx
   673 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   683 label *label259
   684 label *label260
   685 label *label261
-    * op add :compute.0:i :compute.0:i 1
+  686 op add :compute.0:i 32 1
   687 label *label262
   688 set :compute.0:x1 :compute.0:zx
   689 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   699 label *label263
   700 label *label264
   701 label *label265
-    * op add :compute.0:i :compute.0:i 1
+  702 op add :compute.0:i 33 1
   703 label *label266
   704 set :compute.0:x1 :compute.0:zx
   705 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   715 label *label267
   716 label *label268
   717 label *label269
-    * op add :compute.0:i :compute.0:i 1
+  718 op add :compute.0:i 34 1
   719 label *label270
   720 set :compute.0:x1 :compute.0:zx
   721 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   731 label *label271
   732 label *label272
   733 label *label273
-    * op add :compute.0:i :compute.0:i 1
+  734 op add :compute.0:i 35 1
   735 label *label274
   736 set :compute.0:x1 :compute.0:zx
   737 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   747 label *label275
   748 label *label276
   749 label *label277
-    * op add :compute.0:i :compute.0:i 1
+  750 op add :compute.0:i 36 1
   751 label *label278
   752 set :compute.0:x1 :compute.0:zx
   753 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   763 label *label279
   764 label *label280
   765 label *label281
-    * op add :compute.0:i :compute.0:i 1
+  766 op add :compute.0:i 37 1
   767 label *label282
   768 set :compute.0:x1 :compute.0:zx
   769 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   779 label *label283
   780 label *label284
   781 label *label285
-    * op add :compute.0:i :compute.0:i 1
+  782 op add :compute.0:i 38 1
   783 label *label286
   784 set :compute.0:x1 :compute.0:zx
   785 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   795 label *label287
   796 label *label288
   797 label *label289
-    * op add :compute.0:i :compute.0:i 1
+  798 op add :compute.0:i 39 1
   799 label *label290
   800 set :compute.0:x1 :compute.0:zx
   801 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   811 label *label291
   812 label *label292
   813 label *label293
-    * op add :compute.0:i :compute.0:i 1
+  814 op add :compute.0:i 40 1
   815 label *label294
   816 set :compute.0:x1 :compute.0:zx
   817 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   827 label *label295
   828 label *label296
   829 label *label297
-    * op add :compute.0:i :compute.0:i 1
+  830 op add :compute.0:i 41 1
   831 label *label298
   832 set :compute.0:x1 :compute.0:zx
   833 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   843 label *label299
   844 label *label300
   845 label *label301
-    * op add :compute.0:i :compute.0:i 1
+  846 op add :compute.0:i 42 1
   847 label *label302
   848 set :compute.0:x1 :compute.0:zx
   849 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   859 label *label303
   860 label *label304
   861 label *label305
-    * op add :compute.0:i :compute.0:i 1
+  862 op add :compute.0:i 43 1
   863 label *label306
   864 set :compute.0:x1 :compute.0:zx
   865 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   875 label *label307
   876 label *label308
   877 label *label309
-    * op add :compute.0:i :compute.0:i 1
+  878 op add :compute.0:i 44 1
   879 label *label310
   880 set :compute.0:x1 :compute.0:zx
   881 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   891 label *label311
   892 label *label312
   893 label *label313
-    * op add :compute.0:i :compute.0:i 1
+  894 op add :compute.0:i 45 1
   895 label *label314
   896 set :compute.0:x1 :compute.0:zx
   897 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   907 label *label315
   908 label *label316
   909 label *label317
-    * op add :compute.0:i :compute.0:i 1
+  910 op add :compute.0:i 46 1
   911 label *label318
   912 set :compute.0:x1 :compute.0:zx
   913 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   923 label *label319
   924 label *label320
   925 label *label321
-    * op add :compute.0:i :compute.0:i 1
+  926 op add :compute.0:i 47 1
   927 label *label322
   928 set :compute.0:x1 :compute.0:zx
   929 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   939 label *label323
   940 label *label324
   941 label *label325
-    * op add :compute.0:i :compute.0:i 1
+  942 op add :compute.0:i 48 1
   943 label *label326
   944 set :compute.0:x1 :compute.0:zx
   945 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   955 label *label327
   956 label *label328
   957 label *label329
-    * op add :compute.0:i :compute.0:i 1
+  958 op add :compute.0:i 49 1
   959 label *label330
   960 set :compute.0:x1 :compute.0:zx
   961 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   971 label *label331
   972 label *label332
   973 label *label333
-    * op add :compute.0:i :compute.0:i 1
+  974 op add :compute.0:i 50 1
   975 label *label334
   976 set :compute.0:x1 :compute.0:zx
   977 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   987 label *label335
   988 label *label336
   989 label *label337
-    * op add :compute.0:i :compute.0:i 1
+  990 op add :compute.0:i 51 1
   991 label *label338
   992 set :compute.0:x1 :compute.0:zx
   993 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1003 label *label339
  1004 label *label340
  1005 label *label341
-    * op add :compute.0:i :compute.0:i 1
+ 1006 op add :compute.0:i 52 1
  1007 label *label342
  1008 set :compute.0:x1 :compute.0:zx
  1009 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1019 label *label343
  1020 label *label344
  1021 label *label345
-    * op add :compute.0:i :compute.0:i 1
+ 1022 op add :compute.0:i 53 1
  1023 label *label346
  1024 set :compute.0:x1 :compute.0:zx
  1025 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1035 label *label347
  1036 label *label348
  1037 label *label349
-    * op add :compute.0:i :compute.0:i 1
+ 1038 op add :compute.0:i 54 1
  1039 label *label350
  1040 set :compute.0:x1 :compute.0:zx
  1041 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1051 label *label351
  1052 label *label352
  1053 label *label353
-    * op add :compute.0:i :compute.0:i 1
+ 1054 op add :compute.0:i 55 1
  1055 label *label354
  1056 set :compute.0:x1 :compute.0:zx
  1057 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1067 label *label355
  1068 label *label356
  1069 label *label357
-    * op add :compute.0:i :compute.0:i 1
+ 1070 op add :compute.0:i 56 1
  1071 label *label358
  1072 set :compute.0:x1 :compute.0:zx
  1073 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1083 label *label359
  1084 label *label360
  1085 label *label361
-    * op add :compute.0:i :compute.0:i 1
+ 1086 op add :compute.0:i 57 1
  1087 label *label362
  1088 set :compute.0:x1 :compute.0:zx
  1089 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1099 label *label363
  1100 label *label364
  1101 label *label365
-    * op add :compute.0:i :compute.0:i 1
+ 1102 op add :compute.0:i 58 1
  1103 label *label366
  1104 set :compute.0:x1 :compute.0:zx
  1105 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1115 label *label367
  1116 label *label368
  1117 label *label369
-    * op add :compute.0:i :compute.0:i 1
+ 1118 op add :compute.0:i 59 1
  1119 label *label370
  1120 set :compute.0:x1 :compute.0:zx
  1121 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1131 label *label371
  1132 label *label372
  1133 label *label373
-    * op add :compute.0:i :compute.0:i 1
+ 1134 op add :compute.0:i 60 1
  1135 label *label374
  1136 set :compute.0:x1 :compute.0:zx
  1137 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1147 label *label375
  1148 label *label376
  1149 label *label377
-    * op add :compute.0:i :compute.0:i 1
+ 1150 op add :compute.0:i 61 1
  1151 label *label378
  1152 set :compute.0:x1 :compute.0:zx
  1153 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1163 label *label379
  1164 label *label380
  1165 label *label381
-    * op add :compute.0:i :compute.0:i 1
+ 1166 op add :compute.0:i 62 1
  1167 label *label54
  1168 op mul *tmp69 .SMOOTH 63
  1169 jump *label57 greaterThanEq :compute.0:i *tmp69

Modifications by Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 (+9 instructions):
 
    81 label *label29
    82 label *label32
    83 set :setState.0:state 0
-    * setaddr :setState.0*retaddr *label35
-    * call *label0 :setState.0*retval
-    * label *label35
+   84 label *label382
+   85 label *label383
+   86 jump *label390 greaterThanEq .PROC_STATE_INDEX 512
+   87 label *label384
+   88 read *tmp124 .memory .PROC_ID_INDEX
+   89 jump *label385 notEqual *tmp124 .PROCESSOR_ID
+   90 write :setState.0:state .memory .PROC_STATE_INDEX
+   91 jump *label390 always
+   92 jump *label388 always
+   93 label *label385
+   94 read *tmp130 .memory .PROC_ID_INDEX
+   95 jump *label386 notEqual *tmp130 0
+   96 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+   97 write :setState.0:state .memory .PROC_STATE_INDEX
+   98 jump *label390 always
+   99 jump *label387 always
+  100 label *label386
+  101 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  102 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  103 label *label387
+  104 label *label388
+  105 label *label389
+  106 jump *label384 lessThan .PROC_STATE_INDEX 512
+  107 label *label390
+  108 label *label391
   109 label *label33
   110 read *tmp0 .memory 64
   111 jump *label32 equal .start *tmp0
 
   115 read *tmp1 .memory 65
   116 set .stop *tmp1
   117 set :setState.0:state *tmp0
-    * setaddr :setState.0*retaddr *label36
-    * call *label0 :setState.0*retval
-    * label *label36
+  118 label *label392
+  119 label *label393
+  120 jump *label400 greaterThanEq .PROC_STATE_INDEX 512
+  121 label *label394
+  122 read *tmp124 .memory .PROC_ID_INDEX
+  123 jump *label395 notEqual *tmp124 .PROCESSOR_ID
+  124 write :setState.0:state .memory .PROC_STATE_INDEX
+  125 jump *label400 always
+  126 jump *label398 always
+  127 label *label395
+  128 read *tmp130 .memory .PROC_ID_INDEX
+  129 jump *label396 notEqual *tmp130 0
+  130 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  131 write :setState.0:state .memory .PROC_STATE_INDEX
+  132 jump *label400 always
+  133 jump *label397 always
+  134 label *label396
+  135 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  136 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  137 label *label397
+  138 label *label398
+  139 label *label399
+  140 jump *label394 lessThan .PROC_STATE_INDEX 512
+  141 label *label400
+  142 label *label401
   143 read .ZOOM .memory 68
   144 op div *tmp26 -88 .ZOOM
   145 read *tmp2 .memory 66
 
  1309 jump *label29 always
  1310 label *label31
  1311 end
-    * label *label0
-    * label *label78
-    * jump *label80 greaterThanEq .PROC_STATE_INDEX 512
-    * label *label89
-    * read *tmp124 .memory .PROC_ID_INDEX
-    * jump *label81 notEqual *tmp124 .PROCESSOR_ID
-    * write :setState.0:state .memory .PROC_STATE_INDEX
-    * jump *label80 always
-    * jump *label82 always
-    * label *label81
-    * read *tmp130 .memory .PROC_ID_INDEX
-    * jump *label83 notEqual *tmp130 0
-    * write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState.0:state .memory .PROC_STATE_INDEX
-    * jump *label80 always
-    * jump *label84 always
-    * label *label83
-    * op add .PROC_ID_INDEX .PROC_ID_INDEX 2
-    * op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label84
-    * label *label82
-    * label *label79
-    * jump *label89 lessThan .PROC_STATE_INDEX 512
-    * label *label80
-    * label *label77
-    * return :setState.0*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    87 label *label384
    88 read *tmp124 .memory .PROC_ID_INDEX
    89 jump *label385 notEqual *tmp124 .PROCESSOR_ID
-    * write :setState.0:state .memory .PROC_STATE_INDEX
+   90 write 0 .memory .PROC_STATE_INDEX
    91 jump *label390 always
    92 jump *label388 always
    93 label *label385
    94 read *tmp130 .memory .PROC_ID_INDEX
    95 jump *label386 notEqual *tmp130 0
    96 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState.0:state .memory .PROC_STATE_INDEX
+   97 write 0 .memory .PROC_STATE_INDEX
    98 jump *label390 always
    99 jump *label387 always
   100 label *label386
 
   121 label *label394
   122 read *tmp124 .memory .PROC_ID_INDEX
   123 jump *label395 notEqual *tmp124 .PROCESSOR_ID
-    * write :setState.0:state .memory .PROC_STATE_INDEX
+  124 write *tmp0 .memory .PROC_STATE_INDEX
   125 jump *label400 always
   126 jump *label398 always
   127 label *label395
   128 read *tmp130 .memory .PROC_ID_INDEX
   129 jump *label396 notEqual *tmp130 0
   130 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState.0:state .memory .PROC_STATE_INDEX
+  131 write *tmp0 .memory .PROC_STATE_INDEX
   132 jump *label400 always
   133 jump *label397 always
   134 label *label396

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    80 label *label1
    81 label *label29
    82 label *label32
-    * set :setState.0:state 0
    83 label *label382
    84 label *label383
    85 jump *label390 greaterThanEq .PROC_STATE_INDEX 512
 
   113 set .start *tmp0
   114 read *tmp1 .memory 65
   115 set .stop *tmp1
-    * set :setState.0:state *tmp0
   116 label *label392
   117 label *label393
   118 jump *label400 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    24 label *label99
    25 jump *label102 notEqual @large-logic-display :findLinkedBlocks.0:type
    26 set .display :findLinkedBlocks.0:block
-    * jump *label100 notEqual @large-logic-display @message
+   27 jump *label100 always
    28 label *label100
    29 label *label101
    30 label *label102
 
    35 label *label107
    36 jump *label110 notEqual @memory-bank :findLinkedBlocks.0:type
    37 set .memory :findLinkedBlocks.0:block
-    * jump *label108 notEqual @memory-bank @message
+   38 jump *label108 always
    39 label *label108
    40 label *label109
    41 label *label110
 
    53 print ":"
    54 print " "
    55 print .display
-    * jump *label117 equal true false
    56 op and :findLinkedBlocks.0:foundAll 1 .display
    57 label *label117
    58 label *label118
 
    65 print ":"
    66 print " "
    67 print .memory
-    * jump *label123 equal true false
    68 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll .memory
    69 label *label123
    70 label *label124

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
    24 label *label99
    25 jump *label102 notEqual @large-logic-display :findLinkedBlocks.0:type
    26 set .display :findLinkedBlocks.0:block
-    * jump *label100 always
    27 label *label100
    28 label *label101
    29 label *label102
 
    34 label *label107
    35 jump *label110 notEqual @memory-bank :findLinkedBlocks.0:type
    36 set .memory :findLinkedBlocks.0:block
-    * jump *label108 always
    37 label *label108
    38 label *label109
    39 label *label110
 
  1214 label *label57
  1215 label *label58
  1216 set *tmp41 :compute.0:i
-    * jump *label45 always
  1217 label *label45
  1218 jump *label60 equal .SMOOTH false
  1219 jump *label62 notEqual *tmp41 63

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-8 instructions):
 
    20 print "\nFound: "
    21 print :findLinkedBlocks.0:block
    22 sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @type
-    * set .display .display
    23 label *label99
    24 jump *label102 notEqual @large-logic-display :findLinkedBlocks.0:type
    25 set .display :findLinkedBlocks.0:block
 
    28 label *label102
    29 label *label103
    30 label *label104
-    * set .display .display
-    * set .memory .memory
    31 label *label107
    32 jump *label110 notEqual @memory-bank :findLinkedBlocks.0:type
    33 set .memory :findLinkedBlocks.0:block
 
    36 label *label110
    37 label *label111
    38 label *label112
-    * set .memory .memory
    39 label *label15
    40 label *label11
    41 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    42 label *label12
-    * set .display .display
    43 label *label116
    44 print "\n"
    45 print "Display"
 
    50 label *label117
    51 label *label118
    52 label *label119
-    * set .display .display
-    * set .memory .memory
    53 label *label122
    54 print "\n"
    55 print "Memory"
 
    60 label *label123
    61 label *label124
    62 label *label125
-    * set .memory .memory
    63 label *label24
    64 printflush null
    65 label *label3
 
   201 label *label131
   202 label *label132
   203 label *label133
-    * op add :compute.0:i 0 1
+  204 set :compute.0:i 1
   205 label *label134
   206 set :compute.0:x1 :compute.0:zx
   207 op mul *tmp59 :compute.0:zx :compute.0:zx

Modifications by Final phase, Jump Straightening, iteration 1 (-65 instructions):
 
   196 op mul *tmp64 *tmp63 :compute.0:zy
   197 op add :compute.0:zy *tmp64 :compute.0:cy
   198 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label131 lessThan :compute.0:dist 64
-    * jump *label54 always
+  199 jump *label54 greaterThanEq :compute.0:dist 64
   200 label *label131
   201 label *label132
   202 label *label133
 
   211 op mul *tmp64 *tmp63 :compute.0:zy
   212 op add :compute.0:zy *tmp64 :compute.0:cy
   213 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label135 lessThan :compute.0:dist 64
-    * jump *label54 always
+  214 jump *label54 greaterThanEq :compute.0:dist 64
   215 label *label135
   216 label *label136
   217 label *label137
 
   226 op mul *tmp64 *tmp63 :compute.0:zy
   227 op add :compute.0:zy *tmp64 :compute.0:cy
   228 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label139 lessThan :compute.0:dist 64
-    * jump *label54 always
+  229 jump *label54 greaterThanEq :compute.0:dist 64
   230 label *label139
   231 label *label140
   232 label *label141
 
   241 op mul *tmp64 *tmp63 :compute.0:zy
   242 op add :compute.0:zy *tmp64 :compute.0:cy
   243 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label143 lessThan :compute.0:dist 64
-    * jump *label54 always
+  244 jump *label54 greaterThanEq :compute.0:dist 64
   245 label *label143
   246 label *label144
   247 label *label145
 
   256 op mul *tmp64 *tmp63 :compute.0:zy
   257 op add :compute.0:zy *tmp64 :compute.0:cy
   258 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label147 lessThan :compute.0:dist 64
-    * jump *label54 always
+  259 jump *label54 greaterThanEq :compute.0:dist 64
   260 label *label147
   261 label *label148
   262 label *label149
 
   271 op mul *tmp64 *tmp63 :compute.0:zy
   272 op add :compute.0:zy *tmp64 :compute.0:cy
   273 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label151 lessThan :compute.0:dist 64
-    * jump *label54 always
+  274 jump *label54 greaterThanEq :compute.0:dist 64
   275 label *label151
   276 label *label152
   277 label *label153
 
   286 op mul *tmp64 *tmp63 :compute.0:zy
   287 op add :compute.0:zy *tmp64 :compute.0:cy
   288 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label155 lessThan :compute.0:dist 64
-    * jump *label54 always
+  289 jump *label54 greaterThanEq :compute.0:dist 64
   290 label *label155
   291 label *label156
   292 label *label157
 
   301 op mul *tmp64 *tmp63 :compute.0:zy
   302 op add :compute.0:zy *tmp64 :compute.0:cy
   303 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label159 lessThan :compute.0:dist 64
-    * jump *label54 always
+  304 jump *label54 greaterThanEq :compute.0:dist 64
   305 label *label159
   306 label *label160
   307 label *label161
 
   316 op mul *tmp64 *tmp63 :compute.0:zy
   317 op add :compute.0:zy *tmp64 :compute.0:cy
   318 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label163 lessThan :compute.0:dist 64
-    * jump *label54 always
+  319 jump *label54 greaterThanEq :compute.0:dist 64
   320 label *label163
   321 label *label164
   322 label *label165
 
   331 op mul *tmp64 *tmp63 :compute.0:zy
   332 op add :compute.0:zy *tmp64 :compute.0:cy
   333 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label167 lessThan :compute.0:dist 64
-    * jump *label54 always
+  334 jump *label54 greaterThanEq :compute.0:dist 64
   335 label *label167
   336 label *label168
   337 label *label169
 
   346 op mul *tmp64 *tmp63 :compute.0:zy
   347 op add :compute.0:zy *tmp64 :compute.0:cy
   348 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label171 lessThan :compute.0:dist 64
-    * jump *label54 always
+  349 jump *label54 greaterThanEq :compute.0:dist 64
   350 label *label171
   351 label *label172
   352 label *label173
 
   361 op mul *tmp64 *tmp63 :compute.0:zy
   362 op add :compute.0:zy *tmp64 :compute.0:cy
   363 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label175 lessThan :compute.0:dist 64
-    * jump *label54 always
+  364 jump *label54 greaterThanEq :compute.0:dist 64
   365 label *label175
   366 label *label176
   367 label *label177
 
   376 op mul *tmp64 *tmp63 :compute.0:zy
   377 op add :compute.0:zy *tmp64 :compute.0:cy
   378 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label179 lessThan :compute.0:dist 64
-    * jump *label54 always
+  379 jump *label54 greaterThanEq :compute.0:dist 64
   380 label *label179
   381 label *label180
   382 label *label181
 
   391 op mul *tmp64 *tmp63 :compute.0:zy
   392 op add :compute.0:zy *tmp64 :compute.0:cy
   393 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label183 lessThan :compute.0:dist 64
-    * jump *label54 always
+  394 jump *label54 greaterThanEq :compute.0:dist 64
   395 label *label183
   396 label *label184
   397 label *label185
 
   406 op mul *tmp64 *tmp63 :compute.0:zy
   407 op add :compute.0:zy *tmp64 :compute.0:cy
   408 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label187 lessThan :compute.0:dist 64
-    * jump *label54 always
+  409 jump *label54 greaterThanEq :compute.0:dist 64
   410 label *label187
   411 label *label188
   412 label *label189
 
   421 op mul *tmp64 *tmp63 :compute.0:zy
   422 op add :compute.0:zy *tmp64 :compute.0:cy
   423 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label191 lessThan :compute.0:dist 64
-    * jump *label54 always
+  424 jump *label54 greaterThanEq :compute.0:dist 64
   425 label *label191
   426 label *label192
   427 label *label193
 
   436 op mul *tmp64 *tmp63 :compute.0:zy
   437 op add :compute.0:zy *tmp64 :compute.0:cy
   438 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label195 lessThan :compute.0:dist 64
-    * jump *label54 always
+  439 jump *label54 greaterThanEq :compute.0:dist 64
   440 label *label195
   441 label *label196
   442 label *label197
 
   451 op mul *tmp64 *tmp63 :compute.0:zy
   452 op add :compute.0:zy *tmp64 :compute.0:cy
   453 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label199 lessThan :compute.0:dist 64
-    * jump *label54 always
+  454 jump *label54 greaterThanEq :compute.0:dist 64
   455 label *label199
   456 label *label200
   457 label *label201
 
   466 op mul *tmp64 *tmp63 :compute.0:zy
   467 op add :compute.0:zy *tmp64 :compute.0:cy
   468 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label203 lessThan :compute.0:dist 64
-    * jump *label54 always
+  469 jump *label54 greaterThanEq :compute.0:dist 64
   470 label *label203
   471 label *label204
   472 label *label205
 
   481 op mul *tmp64 *tmp63 :compute.0:zy
   482 op add :compute.0:zy *tmp64 :compute.0:cy
   483 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label207 lessThan :compute.0:dist 64
-    * jump *label54 always
+  484 jump *label54 greaterThanEq :compute.0:dist 64
   485 label *label207
   486 label *label208
   487 label *label209
 
   496 op mul *tmp64 *tmp63 :compute.0:zy
   497 op add :compute.0:zy *tmp64 :compute.0:cy
   498 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label211 lessThan :compute.0:dist 64
-    * jump *label54 always
+  499 jump *label54 greaterThanEq :compute.0:dist 64
   500 label *label211
   501 label *label212
   502 label *label213
 
   511 op mul *tmp64 *tmp63 :compute.0:zy
   512 op add :compute.0:zy *tmp64 :compute.0:cy
   513 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label215 lessThan :compute.0:dist 64
-    * jump *label54 always
+  514 jump *label54 greaterThanEq :compute.0:dist 64
   515 label *label215
   516 label *label216
   517 label *label217
 
   526 op mul *tmp64 *tmp63 :compute.0:zy
   527 op add :compute.0:zy *tmp64 :compute.0:cy
   528 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label219 lessThan :compute.0:dist 64
-    * jump *label54 always
+  529 jump *label54 greaterThanEq :compute.0:dist 64
   530 label *label219
   531 label *label220
   532 label *label221
 
   541 op mul *tmp64 *tmp63 :compute.0:zy
   542 op add :compute.0:zy *tmp64 :compute.0:cy
   543 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label223 lessThan :compute.0:dist 64
-    * jump *label54 always
+  544 jump *label54 greaterThanEq :compute.0:dist 64
   545 label *label223
   546 label *label224
   547 label *label225
 
   556 op mul *tmp64 *tmp63 :compute.0:zy
   557 op add :compute.0:zy *tmp64 :compute.0:cy
   558 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label227 lessThan :compute.0:dist 64
-    * jump *label54 always
+  559 jump *label54 greaterThanEq :compute.0:dist 64
   560 label *label227
   561 label *label228
   562 label *label229
 
   571 op mul *tmp64 *tmp63 :compute.0:zy
   572 op add :compute.0:zy *tmp64 :compute.0:cy
   573 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label231 lessThan :compute.0:dist 64
-    * jump *label54 always
+  574 jump *label54 greaterThanEq :compute.0:dist 64
   575 label *label231
   576 label *label232
   577 label *label233
 
   586 op mul *tmp64 *tmp63 :compute.0:zy
   587 op add :compute.0:zy *tmp64 :compute.0:cy
   588 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label235 lessThan :compute.0:dist 64
-    * jump *label54 always
+  589 jump *label54 greaterThanEq :compute.0:dist 64
   590 label *label235
   591 label *label236
   592 label *label237
 
   601 op mul *tmp64 *tmp63 :compute.0:zy
   602 op add :compute.0:zy *tmp64 :compute.0:cy
   603 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label239 lessThan :compute.0:dist 64
-    * jump *label54 always
+  604 jump *label54 greaterThanEq :compute.0:dist 64
   605 label *label239
   606 label *label240
   607 label *label241
 
   616 op mul *tmp64 *tmp63 :compute.0:zy
   617 op add :compute.0:zy *tmp64 :compute.0:cy
   618 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label243 lessThan :compute.0:dist 64
-    * jump *label54 always
+  619 jump *label54 greaterThanEq :compute.0:dist 64
   620 label *label243
   621 label *label244
   622 label *label245
 
   631 op mul *tmp64 *tmp63 :compute.0:zy
   632 op add :compute.0:zy *tmp64 :compute.0:cy
   633 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label247 lessThan :compute.0:dist 64
-    * jump *label54 always
+  634 jump *label54 greaterThanEq :compute.0:dist 64
   635 label *label247
   636 label *label248
   637 label *label249
 
   646 op mul *tmp64 *tmp63 :compute.0:zy
   647 op add :compute.0:zy *tmp64 :compute.0:cy
   648 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label251 lessThan :compute.0:dist 64
-    * jump *label54 always
+  649 jump *label54 greaterThanEq :compute.0:dist 64
   650 label *label251
   651 label *label252
   652 label *label253
 
   661 op mul *tmp64 *tmp63 :compute.0:zy
   662 op add :compute.0:zy *tmp64 :compute.0:cy
   663 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label255 lessThan :compute.0:dist 64
-    * jump *label54 always
+  664 jump *label54 greaterThanEq :compute.0:dist 64
   665 label *label255
   666 label *label256
   667 label *label257
 
   676 op mul *tmp64 *tmp63 :compute.0:zy
   677 op add :compute.0:zy *tmp64 :compute.0:cy
   678 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label259 lessThan :compute.0:dist 64
-    * jump *label54 always
+  679 jump *label54 greaterThanEq :compute.0:dist 64
   680 label *label259
   681 label *label260
   682 label *label261
 
   691 op mul *tmp64 *tmp63 :compute.0:zy
   692 op add :compute.0:zy *tmp64 :compute.0:cy
   693 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label263 lessThan :compute.0:dist 64
-    * jump *label54 always
+  694 jump *label54 greaterThanEq :compute.0:dist 64
   695 label *label263
   696 label *label264
   697 label *label265
 
   706 op mul *tmp64 *tmp63 :compute.0:zy
   707 op add :compute.0:zy *tmp64 :compute.0:cy
   708 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label267 lessThan :compute.0:dist 64
-    * jump *label54 always
+  709 jump *label54 greaterThanEq :compute.0:dist 64
   710 label *label267
   711 label *label268
   712 label *label269
 
   721 op mul *tmp64 *tmp63 :compute.0:zy
   722 op add :compute.0:zy *tmp64 :compute.0:cy
   723 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label271 lessThan :compute.0:dist 64
-    * jump *label54 always
+  724 jump *label54 greaterThanEq :compute.0:dist 64
   725 label *label271
   726 label *label272
   727 label *label273
 
   736 op mul *tmp64 *tmp63 :compute.0:zy
   737 op add :compute.0:zy *tmp64 :compute.0:cy
   738 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label275 lessThan :compute.0:dist 64
-    * jump *label54 always
+  739 jump *label54 greaterThanEq :compute.0:dist 64
   740 label *label275
   741 label *label276
   742 label *label277
 
   751 op mul *tmp64 *tmp63 :compute.0:zy
   752 op add :compute.0:zy *tmp64 :compute.0:cy
   753 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label279 lessThan :compute.0:dist 64
-    * jump *label54 always
+  754 jump *label54 greaterThanEq :compute.0:dist 64
   755 label *label279
   756 label *label280
   757 label *label281
 
   766 op mul *tmp64 *tmp63 :compute.0:zy
   767 op add :compute.0:zy *tmp64 :compute.0:cy
   768 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label283 lessThan :compute.0:dist 64
-    * jump *label54 always
+  769 jump *label54 greaterThanEq :compute.0:dist 64
   770 label *label283
   771 label *label284
   772 label *label285
 
   781 op mul *tmp64 *tmp63 :compute.0:zy
   782 op add :compute.0:zy *tmp64 :compute.0:cy
   783 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label287 lessThan :compute.0:dist 64
-    * jump *label54 always
+  784 jump *label54 greaterThanEq :compute.0:dist 64
   785 label *label287
   786 label *label288
   787 label *label289
 
   796 op mul *tmp64 *tmp63 :compute.0:zy
   797 op add :compute.0:zy *tmp64 :compute.0:cy
   798 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label291 lessThan :compute.0:dist 64
-    * jump *label54 always
+  799 jump *label54 greaterThanEq :compute.0:dist 64
   800 label *label291
   801 label *label292
   802 label *label293
 
   811 op mul *tmp64 *tmp63 :compute.0:zy
   812 op add :compute.0:zy *tmp64 :compute.0:cy
   813 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label295 lessThan :compute.0:dist 64
-    * jump *label54 always
+  814 jump *label54 greaterThanEq :compute.0:dist 64
   815 label *label295
   816 label *label296
   817 label *label297
 
   826 op mul *tmp64 *tmp63 :compute.0:zy
   827 op add :compute.0:zy *tmp64 :compute.0:cy
   828 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label299 lessThan :compute.0:dist 64
-    * jump *label54 always
+  829 jump *label54 greaterThanEq :compute.0:dist 64
   830 label *label299
   831 label *label300
   832 label *label301
 
   841 op mul *tmp64 *tmp63 :compute.0:zy
   842 op add :compute.0:zy *tmp64 :compute.0:cy
   843 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label303 lessThan :compute.0:dist 64
-    * jump *label54 always
+  844 jump *label54 greaterThanEq :compute.0:dist 64
   845 label *label303
   846 label *label304
   847 label *label305
 
   856 op mul *tmp64 *tmp63 :compute.0:zy
   857 op add :compute.0:zy *tmp64 :compute.0:cy
   858 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label307 lessThan :compute.0:dist 64
-    * jump *label54 always
+  859 jump *label54 greaterThanEq :compute.0:dist 64
   860 label *label307
   861 label *label308
   862 label *label309
 
   871 op mul *tmp64 *tmp63 :compute.0:zy
   872 op add :compute.0:zy *tmp64 :compute.0:cy
   873 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label311 lessThan :compute.0:dist 64
-    * jump *label54 always
+  874 jump *label54 greaterThanEq :compute.0:dist 64
   875 label *label311
   876 label *label312
   877 label *label313
 
   886 op mul *tmp64 *tmp63 :compute.0:zy
   887 op add :compute.0:zy *tmp64 :compute.0:cy
   888 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label315 lessThan :compute.0:dist 64
-    * jump *label54 always
+  889 jump *label54 greaterThanEq :compute.0:dist 64
   890 label *label315
   891 label *label316
   892 label *label317
 
   901 op mul *tmp64 *tmp63 :compute.0:zy
   902 op add :compute.0:zy *tmp64 :compute.0:cy
   903 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label319 lessThan :compute.0:dist 64
-    * jump *label54 always
+  904 jump *label54 greaterThanEq :compute.0:dist 64
   905 label *label319
   906 label *label320
   907 label *label321
 
   916 op mul *tmp64 *tmp63 :compute.0:zy
   917 op add :compute.0:zy *tmp64 :compute.0:cy
   918 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label323 lessThan :compute.0:dist 64
-    * jump *label54 always
+  919 jump *label54 greaterThanEq :compute.0:dist 64
   920 label *label323
   921 label *label324
   922 label *label325
 
   931 op mul *tmp64 *tmp63 :compute.0:zy
   932 op add :compute.0:zy *tmp64 :compute.0:cy
   933 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label327 lessThan :compute.0:dist 64
-    * jump *label54 always
+  934 jump *label54 greaterThanEq :compute.0:dist 64
   935 label *label327
   936 label *label328
   937 label *label329
 
   946 op mul *tmp64 *tmp63 :compute.0:zy
   947 op add :compute.0:zy *tmp64 :compute.0:cy
   948 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label331 lessThan :compute.0:dist 64
-    * jump *label54 always
+  949 jump *label54 greaterThanEq :compute.0:dist 64
   950 label *label331
   951 label *label332
   952 label *label333
 
   961 op mul *tmp64 *tmp63 :compute.0:zy
   962 op add :compute.0:zy *tmp64 :compute.0:cy
   963 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label335 lessThan :compute.0:dist 64
-    * jump *label54 always
+  964 jump *label54 greaterThanEq :compute.0:dist 64
   965 label *label335
   966 label *label336
   967 label *label337
 
   976 op mul *tmp64 *tmp63 :compute.0:zy
   977 op add :compute.0:zy *tmp64 :compute.0:cy
   978 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label339 lessThan :compute.0:dist 64
-    * jump *label54 always
+  979 jump *label54 greaterThanEq :compute.0:dist 64
   980 label *label339
   981 label *label340
   982 label *label341
 
   991 op mul *tmp64 *tmp63 :compute.0:zy
   992 op add :compute.0:zy *tmp64 :compute.0:cy
   993 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label343 lessThan :compute.0:dist 64
-    * jump *label54 always
+  994 jump *label54 greaterThanEq :compute.0:dist 64
   995 label *label343
   996 label *label344
   997 label *label345
 
  1006 op mul *tmp64 *tmp63 :compute.0:zy
  1007 op add :compute.0:zy *tmp64 :compute.0:cy
  1008 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label347 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1009 jump *label54 greaterThanEq :compute.0:dist 64
  1010 label *label347
  1011 label *label348
  1012 label *label349
 
  1021 op mul *tmp64 *tmp63 :compute.0:zy
  1022 op add :compute.0:zy *tmp64 :compute.0:cy
  1023 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label351 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1024 jump *label54 greaterThanEq :compute.0:dist 64
  1025 label *label351
  1026 label *label352
  1027 label *label353
 
  1036 op mul *tmp64 *tmp63 :compute.0:zy
  1037 op add :compute.0:zy *tmp64 :compute.0:cy
  1038 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label355 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1039 jump *label54 greaterThanEq :compute.0:dist 64
  1040 label *label355
  1041 label *label356
  1042 label *label357
 
  1051 op mul *tmp64 *tmp63 :compute.0:zy
  1052 op add :compute.0:zy *tmp64 :compute.0:cy
  1053 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label359 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1054 jump *label54 greaterThanEq :compute.0:dist 64
  1055 label *label359
  1056 label *label360
  1057 label *label361
 
  1066 op mul *tmp64 *tmp63 :compute.0:zy
  1067 op add :compute.0:zy *tmp64 :compute.0:cy
  1068 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label363 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1069 jump *label54 greaterThanEq :compute.0:dist 64
  1070 label *label363
  1071 label *label364
  1072 label *label365
 
  1081 op mul *tmp64 *tmp63 :compute.0:zy
  1082 op add :compute.0:zy *tmp64 :compute.0:cy
  1083 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label367 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1084 jump *label54 greaterThanEq :compute.0:dist 64
  1085 label *label367
  1086 label *label368
  1087 label *label369
 
  1096 op mul *tmp64 *tmp63 :compute.0:zy
  1097 op add :compute.0:zy *tmp64 :compute.0:cy
  1098 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label371 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1099 jump *label54 greaterThanEq :compute.0:dist 64
  1100 label *label371
  1101 label *label372
  1102 label *label373
 
  1111 op mul *tmp64 *tmp63 :compute.0:zy
  1112 op add :compute.0:zy *tmp64 :compute.0:cy
  1113 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label375 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1114 jump *label54 greaterThanEq :compute.0:dist 64
  1115 label *label375
  1116 label *label376
  1117 label *label377
 
  1126 op mul *tmp64 *tmp63 :compute.0:zy
  1127 op add :compute.0:zy *tmp64 :compute.0:cy
  1128 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label379 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1129 jump *label54 greaterThanEq :compute.0:dist 64
  1130 label *label379
  1131 label *label380
  1132 label *label381
 
  1200 drawflush .display
  1201 label *label59
  1202 read *tmp114 .memory :position
-    * jump *label71 equal *tmp114 .PROCESSOR_ID
-    * jump *label44 always
+ 1203 jump *label44 notEqual *tmp114 .PROCESSOR_ID
  1204 label *label71
  1205 label *label72
  1206 read *tmp1 .memory 65
-    * jump *label73 equal .stop *tmp1
-    * jump *label39 always
+ 1207 jump *label39 notEqual .stop *tmp1
  1208 label *label73
  1209 label *label74
  1210 label *label43

Modifications by Final phase, Jump Threading, iteration 1:
 
  1147 jump *label60 equal .SMOOTH false
  1148 jump *label62 notEqual *tmp41 63
  1149 draw color 0 0 0 255
-    * jump *label63 always
+ 1150 jump *label61 always
  1151 label *label62
  1152 jump *label65 notEqual .PALETTE 2
  1153 label *label66
 
  1162 op mul *tmp92 4 *tmp83
  1163 op add :drawPixel.0:b 120 *tmp92
  1164 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
-    * jump *label64 always
+ 1165 jump *label61 always
  1166 label *label65
  1167 jump *label67 notEqual .PALETTE 3
  1168 label *label68
 
  1176 op mul *tmp104 4 *tmp103
  1177 op add :drawPixel.0:b 100 *tmp104
  1178 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
-    * jump *label64 always
+ 1179 jump *label61 always
  1180 label *label67
  1181 jump *label69 notEqual .PALETTE 4
  1182 label *label70
 
  1184 op mul *tmp107 1.5 *tmp41
  1185 op add :drawPixel.0:g 96 *tmp107
  1186 draw color :drawPixel.0:r :drawPixel.0:g 0 255
-    * jump *label64 always
+ 1187 jump *label61 always
  1188 label *label69
  1189 op mul *tmp109 4 *tmp41
  1190 op sub :drawPixel.0:r 255 *tmp109

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-5 instructions):
 
    76 jump *label385 notEqual *tmp124 .PROCESSOR_ID
    77 write 0 .memory .PROC_STATE_INDEX
    78 jump *label390 always
-    * jump *label388 always
    79 label *label385
    80 read *tmp130 .memory .PROC_ID_INDEX
    81 jump *label386 notEqual *tmp130 0
    82 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    83 write 0 .memory .PROC_STATE_INDEX
    84 jump *label390 always
-    * jump *label387 always
    85 label *label386
    86 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    87 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
   107 jump *label395 notEqual *tmp124 .PROCESSOR_ID
   108 write *tmp0 .memory .PROC_STATE_INDEX
   109 jump *label400 always
-    * jump *label398 always
   110 label *label395
   111 read *tmp130 .memory .PROC_ID_INDEX
   112 jump *label396 notEqual *tmp130 0
   113 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   114 write *tmp0 .memory .PROC_STATE_INDEX
   115 jump *label400 always
-    * jump *label397 always
   116 label *label396
   117 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   118 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
  1223 drawflush .display
  1224 label *label30
  1225 jump *label29 always
-    * label *label31
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-6 instructions):
 
    41 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    42 label *label12
    43 label *label116
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
+   44 print "\nDisplay: "
    45 print .display
    46 op and :findLinkedBlocks.0:foundAll 1 .display
    47 label *label117
    48 label *label118
    49 label *label119
    50 label *label122
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
+   51 print "\nMemory: "
    52 print .memory
    53 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll .memory
    54 label *label123

Final code before resolving virtual instructions:

    0:  op mul *tmp11 10000 @thisy                                   mandelbrot-compute.mnd: var PROCESSOR_ID = @this.@x + 10000 * @this.@y;
    1:  op add .PROCESSOR_ID @thisx *tmp11                           ...
    2:  set .PROC_ID_INDEX 334                                       mandelbrot-compute.mnd: var PROC_ID_INDEX = PROCESSORS;
    3:  set .PROC_STATE_INDEX 335                                    mandelbrot-compute.mnd: var PROC_STATE_INDEX = PROCESSORS + 1;
    4:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label2                                                *blocks: do
    5:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    6:  set .memory null                                             ...
    7:  print "Mandelbrot Generator"                                 *blocks: print(title);
    8:  set :findLinkedBlocks.0:n @links                             *blocks: var n = @links;
    9:  jump *label12 lessThanEq :findLinkedBlocks.0:n 0             *blocks: while n > 0 do
        label *label85                                               ...
   10:  op sub :findLinkedBlocks.0:n :findLinkedBlocks.0:n 1         *blocks: var block = getlink(--n);
   11:  getlink :findLinkedBlocks.0:block :findLinkedBlocks.0:n      ...
   12:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
   13:  print :findLinkedBlocks.0:block                              ...
   14:  sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @t *blocks: var type = block.@type;
   15:  jump *label102 notEqual @large-logic-display :findLinkedBloc *blocks: if requested == type then
   16:  set .display :findLinkedBlocks.0:block                       *blocks: variable = block;
        label *label102                                              *blocks: if requested == type then
   17:  jump *label110 notEqual @memory-bank :findLinkedBlocks.0:typ ...
   18:  set .memory :findLinkedBlocks.0:block                        *blocks: variable = block;
        label *label110                                              *blocks: if requested == type then
   19:  jump *label85 greaterThan :findLinkedBlocks.0:n 0            *blocks: while n > 0 do
        label *label12                                               ...
   20:  print "\nDisplay: "                                          *blocks: print($"\n$name: $variable");
   21:  print .display                                               ...
   22:  op and :findLinkedBlocks.0:foundAll 1 .display               *blocks: if required then foundAll &= variable; end;
   23:  print "\nMemory: "                                           *blocks: print($"\n$name: $variable");
   24:  print .memory                                                ...
   25:  op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foun *blocks: if required then foundAll &= variable; end;
   26:  printflush null                                              *blocks: printflush(message);
   27:  jump *label2 equal :findLinkedBlocks.0:foundAll false        *blocks: do
        label *label29                                               mandelbrot-compute.mnd: while true do
        label *label32                                               mandelbrot-compute.mnd: do
   28:  jump *label390 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label384                                              ...
   29:  read *tmp124 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   30:  jump *label385 notEqual *tmp124 .PROCESSOR_ID                ...
   31:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   32:  jump *label390 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label385                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   33:  read *tmp130 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   34:  jump *label386 notEqual *tmp130 0                            ...
   35:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   36:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   37:  jump *label390 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label386                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   38:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   39:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   40:  jump *label384 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label390                                              ...
   41:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: while start == $START;
   42:  jump *label32 equal .start *tmp0                             mandelbrot-compute.mnd: do
   43:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: start = $START;
   44:  set .start *tmp0                                             ...
   45:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: stop = $STOP;
   46:  set .stop *tmp1                                              ...
   47:  jump *label400 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label394                                              ...
   48:  read *tmp124 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   49:  jump *label395 notEqual *tmp124 .PROCESSOR_ID                ...
   50:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   51:  jump *label400 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label395                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   52:  read *tmp130 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   53:  jump *label396 notEqual *tmp130 0                            ...
   54:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   55:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   56:  jump *label400 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label396                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   57:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   58:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   59:  jump *label394 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label400                                              ...
   60:  read .ZOOM .memory 68                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   61:  op div *tmp26 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   62:  read *tmp2 .memory 66                                        ...
   63:  op add .OFFSET_X *tmp26 *tmp2                                ...
   64:  read *tmp3 .memory 67                                        mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   65:  op add .OFFSET_Y *tmp26 *tmp3                                ...
   66:  read .JULIA .memory 69                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   67:  read .JULIA_X .memory 70                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   68:  read .JULIA_Y .memory 71                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   69:  read .PALETTE .memory 72                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   70:  op greaterThan .SMOOTH .PALETTE 1                            mandelbrot-compute.mnd: SMOOTH   = PALETTE > 1;
   71:  set :line 8                                                  mandelbrot-compute.mnd: var line = 8;
   72:  set :increment 8                                             mandelbrot-compute.mnd: var increment = 8;
   73:  set :next_increment 16                                       mandelbrot-compute.mnd: var next_increment = 16;
   74:  op rand *tmp31 0.1 0                                         mandelbrot-compute.mnd: wait(rand(0.1));
   75:  wait *tmp31                                                  ...
   76:  set :lines 0                                                 mandelbrot-compute.mnd: MasterLoop:
        label *label86                                               ...
   77:  op mul *tmp32 17 :line                                       mandelbrot-compute.mnd: var x = (SKIP * line) % DISPLAY_SIZE_LARGE;
   78:  op mod :x *tmp32 176                                         ...
   79:  op add :position :x 158                                      mandelbrot-compute.mnd: var position = x + SLOTS;
   80:  read *tmp36 .memory :position                                mandelbrot-compute.mnd: if memory[position] == 0 then
   81:  jump *label40 notEqual *tmp36 0                              ...
   82:  write .PROCESSOR_ID .memory :position                        mandelbrot-compute.mnd: memory[position] = PROCESSOR_ID;
   83:  set :y 0                                                     mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
        label *label87                                               ...
   84:  op div *tmp42 :x .ZOOM                                       mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   85:  op add :compute.0:zx *tmp42 .OFFSET_X                        ...
   86:  op div *tmp44 :y .ZOOM                                       mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   87:  op add :compute.0:zy *tmp44 .OFFSET_Y                        ...
   88:  jump *label46 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   89:  set :compute.0:cx .JULIA_X                                   mandelbrot-compute.mnd: cx = JULIA_X;
   90:  set :compute.0:cy .JULIA_Y                                   mandelbrot-compute.mnd: cy = JULIA_Y;
   91:  jump *label47 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label46                                               ...
   92:  set :compute.0:cx :compute.0:zx                              mandelbrot-compute.mnd: cx = zx;
   93:  set :compute.0:cy :compute.0:zy                              mandelbrot-compute.mnd: cy = zy;
   94:  op sub *tmp47 :compute.0:zx 0.25                             mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   95:  op len :compute.0:p *tmp47 :compute.0:zy                     ...
   96:  op mul *tmp49 2 :compute.0:p                                 mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
   97:  op mul *tmp50 *tmp49 :compute.0:p                            ...
   98:  op sub *tmp51 :compute.0:p *tmp50                            ...
   99:  op add *tmp52 *tmp51 0.25                                    ...
  100:  jump *label48 greaterThan :compute.0:zx *tmp52               ...
  101:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  102:  jump *label45 always 0 0                                     ...
        label *label48                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  103:  op add *tmp55 :compute.0:zx 1                                mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  104:  op len *tmp56 *tmp55 :compute.0:zy                           ...
  105:  jump *label50 greaterThan *tmp56 0.25                        ...
  106:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  107:  jump *label45 always 0 0                                     ...
        label *label50                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label47                                               mandelbrot-compute.mnd: if JULIA then
  108:  set :compute.0:i 0                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  109:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  110:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  111:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  112:  op sub *tmp61 *tmp59 *tmp60                                  ...
  113:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  114:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  115:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  116:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  117:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  118:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  119:  set :compute.0:i 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  120:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  121:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  122:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  123:  op sub *tmp61 *tmp59 *tmp60                                  ...
  124:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  125:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  126:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  127:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  128:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  129:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  130:  op add :compute.0:i 1 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  131:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  132:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  133:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  134:  op sub *tmp61 *tmp59 *tmp60                                  ...
  135:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  136:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  137:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  138:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  139:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  140:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  141:  op add :compute.0:i 2 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  142:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  143:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  144:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  145:  op sub *tmp61 *tmp59 *tmp60                                  ...
  146:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  147:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  148:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  149:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  150:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  151:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  152:  op add :compute.0:i 3 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  153:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  154:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  155:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  156:  op sub *tmp61 *tmp59 *tmp60                                  ...
  157:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  158:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  159:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  160:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  161:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  162:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  163:  op add :compute.0:i 4 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  164:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  165:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  166:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  167:  op sub *tmp61 *tmp59 *tmp60                                  ...
  168:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  169:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  170:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  171:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  172:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  173:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  174:  op add :compute.0:i 5 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  175:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  176:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  177:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  178:  op sub *tmp61 *tmp59 *tmp60                                  ...
  179:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  180:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  181:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  182:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  183:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  184:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  185:  op add :compute.0:i 6 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  186:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  187:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  188:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  189:  op sub *tmp61 *tmp59 *tmp60                                  ...
  190:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  191:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  192:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  193:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  194:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  195:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  196:  op add :compute.0:i 7 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  197:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  198:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  199:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  200:  op sub *tmp61 *tmp59 *tmp60                                  ...
  201:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  202:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  203:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  204:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  205:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  206:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  207:  op add :compute.0:i 8 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  208:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  209:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  210:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  211:  op sub *tmp61 *tmp59 *tmp60                                  ...
  212:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  213:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  214:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  215:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  216:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  217:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  218:  op add :compute.0:i 9 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  219:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  220:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  221:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  222:  op sub *tmp61 *tmp59 *tmp60                                  ...
  223:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  224:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  225:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  226:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  227:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  228:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  229:  op add :compute.0:i 10 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  230:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  231:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  232:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  233:  op sub *tmp61 *tmp59 *tmp60                                  ...
  234:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  235:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  236:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  237:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  238:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  239:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  240:  op add :compute.0:i 11 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  241:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  242:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  243:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  244:  op sub *tmp61 *tmp59 *tmp60                                  ...
  245:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  246:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  247:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  248:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  249:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  250:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  251:  op add :compute.0:i 12 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  252:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  253:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  254:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  255:  op sub *tmp61 *tmp59 *tmp60                                  ...
  256:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  257:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  258:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  259:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  260:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  261:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  262:  op add :compute.0:i 13 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  263:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  264:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  265:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  266:  op sub *tmp61 *tmp59 *tmp60                                  ...
  267:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  268:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  269:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  270:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  271:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  272:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  273:  op add :compute.0:i 14 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  274:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  275:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  276:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  277:  op sub *tmp61 *tmp59 *tmp60                                  ...
  278:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  279:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  280:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  281:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  282:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  283:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  284:  op add :compute.0:i 15 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  285:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  286:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  287:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  288:  op sub *tmp61 *tmp59 *tmp60                                  ...
  289:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  290:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  291:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  292:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  293:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  294:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  295:  op add :compute.0:i 16 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  296:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  297:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  298:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  299:  op sub *tmp61 *tmp59 *tmp60                                  ...
  300:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  301:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  302:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  303:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  304:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  305:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  306:  op add :compute.0:i 17 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  307:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  308:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  309:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  310:  op sub *tmp61 *tmp59 *tmp60                                  ...
  311:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  312:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  313:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  314:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  315:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  316:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  317:  op add :compute.0:i 18 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  318:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  319:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  320:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  321:  op sub *tmp61 *tmp59 *tmp60                                  ...
  322:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  323:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  324:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  325:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  326:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  327:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  328:  op add :compute.0:i 19 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  329:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  330:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  331:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  332:  op sub *tmp61 *tmp59 *tmp60                                  ...
  333:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  334:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  335:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  336:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  337:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  338:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  339:  op add :compute.0:i 20 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  340:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  341:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  342:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  343:  op sub *tmp61 *tmp59 *tmp60                                  ...
  344:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  345:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  346:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  347:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  348:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  349:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  350:  op add :compute.0:i 21 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  351:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  352:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  353:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  354:  op sub *tmp61 *tmp59 *tmp60                                  ...
  355:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  356:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  357:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  358:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  359:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  360:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  361:  op add :compute.0:i 22 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  362:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  363:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  364:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  365:  op sub *tmp61 *tmp59 *tmp60                                  ...
  366:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  367:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  368:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  369:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  370:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  371:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  372:  op add :compute.0:i 23 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  373:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  374:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  375:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  376:  op sub *tmp61 *tmp59 *tmp60                                  ...
  377:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  378:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  379:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  380:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  381:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  382:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  383:  op add :compute.0:i 24 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  384:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  385:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  386:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  387:  op sub *tmp61 *tmp59 *tmp60                                  ...
  388:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  389:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  390:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  391:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  392:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  393:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  394:  op add :compute.0:i 25 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  395:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  396:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  397:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  398:  op sub *tmp61 *tmp59 *tmp60                                  ...
  399:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  400:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  401:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  402:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  403:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  404:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  405:  op add :compute.0:i 26 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  406:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  407:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  408:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  409:  op sub *tmp61 *tmp59 *tmp60                                  ...
  410:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  411:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  412:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  413:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  414:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  415:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  416:  op add :compute.0:i 27 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  417:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  418:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  419:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  420:  op sub *tmp61 *tmp59 *tmp60                                  ...
  421:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  422:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  423:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  424:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  425:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  426:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  427:  op add :compute.0:i 28 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  428:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  429:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  430:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  431:  op sub *tmp61 *tmp59 *tmp60                                  ...
  432:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  433:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  434:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  435:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  436:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  437:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  438:  op add :compute.0:i 29 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  439:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  440:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  441:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  442:  op sub *tmp61 *tmp59 *tmp60                                  ...
  443:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  444:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  445:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  446:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  447:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  448:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  449:  op add :compute.0:i 30 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  450:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  451:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  452:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  453:  op sub *tmp61 *tmp59 *tmp60                                  ...
  454:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  455:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  456:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  457:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  458:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  459:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  460:  op add :compute.0:i 31 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  461:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  462:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  463:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  464:  op sub *tmp61 *tmp59 *tmp60                                  ...
  465:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  466:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  467:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  468:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  469:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  470:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  471:  op add :compute.0:i 32 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  472:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  473:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  474:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  475:  op sub *tmp61 *tmp59 *tmp60                                  ...
  476:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  477:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  478:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  479:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  480:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  481:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  482:  op add :compute.0:i 33 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  483:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  484:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  485:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  486:  op sub *tmp61 *tmp59 *tmp60                                  ...
  487:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  488:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  489:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  490:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  491:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  492:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  493:  op add :compute.0:i 34 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  494:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  495:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  496:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  497:  op sub *tmp61 *tmp59 *tmp60                                  ...
  498:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  499:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  500:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  501:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  502:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  503:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  504:  op add :compute.0:i 35 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  505:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  506:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  507:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  508:  op sub *tmp61 *tmp59 *tmp60                                  ...
  509:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  510:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  511:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  512:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  513:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  514:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  515:  op add :compute.0:i 36 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  516:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  517:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  518:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  519:  op sub *tmp61 *tmp59 *tmp60                                  ...
  520:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  521:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  522:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  523:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  524:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  525:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  526:  op add :compute.0:i 37 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  527:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  528:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  529:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  530:  op sub *tmp61 *tmp59 *tmp60                                  ...
  531:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  532:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  533:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  534:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  535:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  536:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  537:  op add :compute.0:i 38 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  538:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  539:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  540:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  541:  op sub *tmp61 *tmp59 *tmp60                                  ...
  542:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  543:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  544:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  545:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  546:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  547:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  548:  op add :compute.0:i 39 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  549:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  550:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  551:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  552:  op sub *tmp61 *tmp59 *tmp60                                  ...
  553:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  554:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  555:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  556:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  557:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  558:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  559:  op add :compute.0:i 40 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  560:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  561:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  562:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  563:  op sub *tmp61 *tmp59 *tmp60                                  ...
  564:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  565:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  566:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  567:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  568:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  569:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  570:  op add :compute.0:i 41 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  571:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  572:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  573:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  574:  op sub *tmp61 *tmp59 *tmp60                                  ...
  575:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  576:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  577:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  578:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  579:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  580:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  581:  op add :compute.0:i 42 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  582:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  583:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  584:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  585:  op sub *tmp61 *tmp59 *tmp60                                  ...
  586:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  587:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  588:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  589:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  590:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  591:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  592:  op add :compute.0:i 43 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  593:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  594:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  595:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  596:  op sub *tmp61 *tmp59 *tmp60                                  ...
  597:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  598:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  599:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  600:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  601:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  602:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  603:  op add :compute.0:i 44 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  604:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  605:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  606:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  607:  op sub *tmp61 *tmp59 *tmp60                                  ...
  608:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  609:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  610:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  611:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  612:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  613:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  614:  op add :compute.0:i 45 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  615:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  616:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  617:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  618:  op sub *tmp61 *tmp59 *tmp60                                  ...
  619:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  620:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  621:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  622:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  623:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  624:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  625:  op add :compute.0:i 46 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  626:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  627:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  628:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  629:  op sub *tmp61 *tmp59 *tmp60                                  ...
  630:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  631:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  632:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  633:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  634:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  635:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  636:  op add :compute.0:i 47 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  637:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  638:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  639:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  640:  op sub *tmp61 *tmp59 *tmp60                                  ...
  641:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  642:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  643:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  644:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  645:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  646:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  647:  op add :compute.0:i 48 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  648:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  649:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  650:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  651:  op sub *tmp61 *tmp59 *tmp60                                  ...
  652:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  653:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  654:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  655:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  656:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  657:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  658:  op add :compute.0:i 49 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  659:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  660:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  661:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  662:  op sub *tmp61 *tmp59 *tmp60                                  ...
  663:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  664:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  665:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  666:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  667:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  668:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  669:  op add :compute.0:i 50 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  670:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  671:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  672:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  673:  op sub *tmp61 *tmp59 *tmp60                                  ...
  674:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  675:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  676:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  677:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  678:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  679:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  680:  op add :compute.0:i 51 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  681:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  682:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  683:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  684:  op sub *tmp61 *tmp59 *tmp60                                  ...
  685:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  686:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  687:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  688:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  689:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  690:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  691:  op add :compute.0:i 52 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  692:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  693:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  694:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  695:  op sub *tmp61 *tmp59 *tmp60                                  ...
  696:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  697:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  698:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  699:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  700:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  701:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  702:  op add :compute.0:i 53 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  703:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  704:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  705:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  706:  op sub *tmp61 *tmp59 *tmp60                                  ...
  707:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  708:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  709:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  710:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  711:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  712:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  713:  op add :compute.0:i 54 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  714:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  715:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  716:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  717:  op sub *tmp61 *tmp59 *tmp60                                  ...
  718:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  719:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  720:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  721:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  722:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  723:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  724:  op add :compute.0:i 55 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  725:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  726:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  727:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  728:  op sub *tmp61 *tmp59 *tmp60                                  ...
  729:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  730:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  731:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  732:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  733:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  734:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  735:  op add :compute.0:i 56 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  736:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  737:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  738:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  739:  op sub *tmp61 *tmp59 *tmp60                                  ...
  740:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  741:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  742:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  743:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  744:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  745:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  746:  op add :compute.0:i 57 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  747:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  748:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  749:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  750:  op sub *tmp61 *tmp59 *tmp60                                  ...
  751:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  752:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  753:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  754:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  755:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  756:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  757:  op add :compute.0:i 58 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  758:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  759:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  760:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  761:  op sub *tmp61 *tmp59 *tmp60                                  ...
  762:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  763:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  764:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  765:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  766:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  767:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  768:  op add :compute.0:i 59 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  769:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  770:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  771:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  772:  op sub *tmp61 *tmp59 *tmp60                                  ...
  773:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  774:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  775:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  776:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  777:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  778:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  779:  op add :compute.0:i 60 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  780:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  781:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  782:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  783:  op sub *tmp61 *tmp59 *tmp60                                  ...
  784:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  785:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  786:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  787:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  788:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  789:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  790:  op add :compute.0:i 61 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  791:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  792:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  793:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  794:  op sub *tmp61 *tmp59 *tmp60                                  ...
  795:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  796:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  797:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  798:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  799:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  800:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  801:  op add :compute.0:i 62 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label54                                               ...
  802:  op mul *tmp69 .SMOOTH 63                                     mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  803:  jump *label57 greaterThanEq :compute.0:i *tmp69              ...
  804:  op log *tmp72 :compute.0:dist 0                              mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  805:  op mul *tmp73 *tmp72 0.36067376022224085                     ...
  806:  op log *tmp74 *tmp73 0                                       ...
  807:  op mul *tmp75 *tmp74 1.4426950408889634                      ...
  808:  op sub :compute.0:correction 4 *tmp75                        ...
  809:  op add :compute.0:i :compute.0:i :compute.0:correction       mandelbrot-compute.mnd: i += correction;
        label *label57                                               mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  810:  set *tmp41 :compute.0:i                                      mandelbrot-compute.mnd: return i;
        label *label45                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  811:  jump *label60 equal .SMOOTH false                            mandelbrot-compute.mnd: if SMOOTH then
  812:  jump *label62 notEqual *tmp41 63                             mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  813:  draw color 0 0 0 255 0 0                                     mandelbrot-compute.mnd: color(0, 0, 0, 255);
  814:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
        label *label62                                               ...
  815:  jump *label65 notEqual .PALETTE 2                            mandelbrot-compute.mnd: case PALETTE
  816:  op sub *tmp82 32 *tmp41                                      mandelbrot-compute.mnd: r = 255 - 7 * abs(32 - iterations);
  817:  op abs *tmp83 *tmp82 0                                       ...
  818:  op mul *tmp84 7 *tmp83                                       ...
  819:  op sub :drawPixel.0:r 255 *tmp84                             ...
  820:  op sub *tmp86 *tmp41 32                                      mandelbrot-compute.mnd: g = 240 - 6 * abs(iterations - 32);
  821:  op abs *tmp87 *tmp86 0                                       ...
  822:  op mul *tmp88 6 *tmp87                                       ...
  823:  op sub :drawPixel.0:g 240 *tmp88                             ...
  824:  op mul *tmp92 4 *tmp83                                       mandelbrot-compute.mnd: b = 120 + 4 * abs(32 - iterations);
  825:  op add :drawPixel.0:b 120 *tmp92                             ...
  826:  draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255  mandelbrot-compute.mnd: color(r, g, b, 255);
  827:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label65                                               ...
  828:  jump *label67 notEqual .PALETTE 3                            ...
  829:  op div *tmp95 *tmp41 0.175                                   mandelbrot-compute.mnd: r = 255 * sin(iterations / MAX_DEPTH * 360);
  830:  op sin *tmp96 *tmp95 0                                       ...
  831:  op mul :drawPixel.0:r 255 *tmp96                             ...
  832:  op cos *tmp100 *tmp95 0                                      mandelbrot-compute.mnd: g = 255 * cos(iterations / MAX_DEPTH * 360);
  833:  op mul :drawPixel.0:g 255 *tmp100                            ...
  834:  op sub *tmp102 *tmp41 32                                     mandelbrot-compute.mnd: b = 100 + 4 * abs(iterations - 32);
  835:  op abs *tmp103 *tmp102 0                                     ...
  836:  op mul *tmp104 4 *tmp103                                     ...
  837:  op add :drawPixel.0:b 100 *tmp104                            ...
  838:  draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255  mandelbrot-compute.mnd: color(r, g, b, 255);
  839:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label67                                               ...
  840:  jump *label69 notEqual .PALETTE 4                            ...
  841:  op mul :drawPixel.0:r 4 *tmp41                               mandelbrot-compute.mnd: r = 4 * iterations;
  842:  op mul *tmp107 1.5 *tmp41                                    mandelbrot-compute.mnd: g = 96 + 1.5 * iterations;
  843:  op add :drawPixel.0:g 96 *tmp107                             ...
  844:  draw color :drawPixel.0:r :drawPixel.0:g 0 255 0 0           mandelbrot-compute.mnd: color(r, g, 0, 255);
  845:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label69                                               ...
  846:  op mul *tmp109 4 *tmp41                                      mandelbrot-compute.mnd: r = 255 - 4 * iterations;
  847:  op sub :drawPixel.0:r 255 *tmp109                            ...
  848:  draw color :drawPixel.0:r :drawPixel.0:r 0 255 0 0           mandelbrot-compute.mnd: color(r, r, 0, 255);
  849:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label60                                               ...
  850:  read *tmp112 .memory *tmp41                                  mandelbrot-compute.mnd: col(memory[iterations]);
  851:  draw col *tmp112 0 0 0 0 0                                   ...
        label *label61                                               mandelbrot-compute.mnd: if SMOOTH then
  852:  draw rect :x :y 1 1 0 0                                      mandelbrot-compute.mnd: rect(x, y, 1, 1);
  853:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  854:  read *tmp114 .memory :position                               mandelbrot-compute.mnd: if memory[position] != PROCESSOR_ID then
  855:  jump *label44 notEqual *tmp114 .PROCESSOR_ID                 ...
  856:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: if stop != $STOP then
  857:  jump *label39 notEqual .stop *tmp1                           ...
  858:  op add :y :y 1                                               mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
  859:  jump *label87 lessThan :y 176                                ...
        label *label44                                               ...
        label *label40                                               mandelbrot-compute.mnd: if memory[position] == 0 then
  860:  op add :line :line :increment                                mandelbrot-compute.mnd: line += increment;
  861:  jump *label75 lessThanEq :line 176                           mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  862:  op div :next_increment :next_increment 2                     mandelbrot-compute.mnd: increment = next_increment /= 2;
  863:  set :increment :next_increment                               ...
  864:  op div :line :next_increment 2                               mandelbrot-compute.mnd: line = increment / 2;
        label *label75                                               mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  865:  op add :lines :lines 1                                       mandelbrot-compute.mnd: MasterLoop:
  866:  jump *label86 lessThan :lines 176                            ...
        label *label39                                               ...
  867:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  868:  jump *label29 always 0 0                                     mandelbrot-compute.mnd: while true do


Performance: parsed in 239 ms, compiled in 239 ms, optimized in 1,261 ms, run in 39 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Display: display
Memory: bank
Execution step limit of 100 000 exceeded.
