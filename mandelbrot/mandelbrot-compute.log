   425 instructions before optimizations.
    47 instructions eliminated by Temp Variables Elimination (8 iterations).
     1 instructions eliminated by Case Expression Optimization.
    44 instructions eliminated by Dead Code Elimination (6 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 7 iterations).
    23 instructions eliminated by Condition Optimization (8 iterations).
    15 instructions eliminated by Single Step Elimination (2 passes, 9 iterations).
     4 instructions eliminated by Expression Optimization (3 passes, 5 iterations).
     3 instructions eliminated by Boolean Optimization (2 passes, 9 iterations).
       3 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by If Expression Optimization (5 iterations).
    51 instructions eliminated by Data Flow Optimization (8 passes, 27 iterations).
     2 loops improved by Loop Hoisting.
     3 instructions eliminated by Loop Rotation (5 iterations).
       3 loop conditions were fully rotated.
       2 loop conditions were partially rotated.
   741 instructions added by Loop Unrolling (12 iterations).
     4 loops unrolled by Loop Unrolling.
    11 instructions added by Function Inlining (12 iterations).
     4 function calls inlined by Function Inlining.
     2 instructions eliminated by Case Switching (12 iterations).
     1 case expressions converted to fast dispatch by Case Switching.
    68 instructions eliminated by Jump Straightening (2 passes, 9 iterations).
     6 instructions updated by Jump Threading.
     6 instructions eliminated by Unreachable Code Elimination (2 iterations).
     7 instructions eliminated by Print Merging.
   899 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 751):
    Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity
  * Unroll iteration loop at *blocks:68:13                       size    -9, benefit     9375.0, efficiency   Infinity (-3 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
    Unroll loop at mandelbrot-compute.mnd:139:5                  size  +679, benefit 24609375.0, efficiency  36243.557
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107
    Fast-dispatch case at mandelbrot-compute.mnd:166:13          size    -2, benefit     1953.1, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 754):
  * Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
    Unroll loop at mandelbrot-compute.mnd:139:5                  size  +679, benefit 24609375.0, efficiency  36243.557
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107
  o Fast-dispatch case at mandelbrot-compute.mnd:166:13          size    -2, benefit     1953.1, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 758):
  * Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity (-2 instructions)
    Unroll loop at mandelbrot-compute.mnd:139:5                  size  +679, benefit 24609375.0, efficiency  36243.557
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107
  o Fast-dispatch case at mandelbrot-compute.mnd:166:13          size    -2, benefit     1953.1, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 760):
  * Unroll loop at mandelbrot-compute.mnd:139:5                  size  +679, benefit 24609375.0, efficiency  36243.557 (+743 instructions)
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107
  o Fast-dispatch case at mandelbrot-compute.mnd:166:13          size    -2, benefit     1953.1, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 17):
  * Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 size    +6, benefit    11793.8, efficiency   1965.625 (+1 instructions)
    Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:110:9         size    +7, benefit       75.0, efficiency     10.714
    Inline function call at mandelbrot-compute.mnd:196:9         size    +7, benefit    11718.8, efficiency   1674.107
  o Fast-dispatch case at mandelbrot-compute.mnd:166:13          size    -2, benefit     1953.1, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 16):
  * Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 size   +13, benefit     2275.0, efficiency    175.000 (+7 instructions)
    Inline function call at mandelbrot-compute.mnd:56:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:64:9          size   +14, benefit       87.5, efficiency      6.250
  o Fast-dispatch case at mandelbrot-compute.mnd:166:13          size    -2, benefit     1953.1, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 9):
  * Fast-dispatch case at mandelbrot-compute.mnd:166:13          size    -2, benefit     1953.1, efficiency   Infinity (-2 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   338 set *tmp88 :drawPixel:color
   339 jump *label73 always
   340 label *label72
-    * set *tmp90 .PALETTE
-    * jump *label76 equal *tmp90 2
+  341 jump *label76 equal .PALETTE 2
   342 jump *label75 always
   343 label *label76
   344 op sub *tmp91 32 :drawPixel:iterations
 
   364 set *tmp89 :drawPixel:color
   365 jump *label74 always
   366 label *label75
-    * jump *label78 equal *tmp90 3
+  367 jump *label78 equal .PALETTE 3
   368 jump *label77 always
   369 label *label78
   370 op div *tmp107 :drawPixel:iterations 63
 
   386 set *tmp89 :drawPixel:color
   387 jump *label74 always
   388 label *label77
-    * jump *label80 equal *tmp90 4
+  389 jump *label80 equal .PALETTE 4
   390 jump *label79 always
   391 label *label80
   392 op mul *tmp119 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-30 instructions):
 
    65 label *label22
    66 set *tmp21 null
    67 label *label23
-    * set *tmp19 *tmp21
    68 jump *label21 always
    69 label *label20
-    * set *tmp19 null
    70 label *label21
    71 label *label16
    72 multijump *tmp17 0 0 (m:marker1)
 
    98 print :findLinkedBlocks:variable
    99 jump *label29 equal :findLinkedBlocks:required false
   100 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * set *tmp23 :findLinkedBlocks:foundAll
   101 jump *label30 always
   102 label *label29
-    * set *tmp23 null
   103 label *label30
   104 label *label25
   105 multijump *tmp22 0 0 (m:marker2)
 
   187 jump *label48 equal .JULIA false
   188 set :compute:cx .JULIA_X
   189 set :compute:cy .JULIA_Y
-    * set *tmp46 :compute:cy
   190 jump *label49 always
   191 label *label48
   192 set :compute:cx :compute:zx
 
   202 jump *label50 equal *tmp53 false
   203 set *tmp41 63
   204 jump *label47 always
-    * set *tmp54 null
   205 jump *label51 always
   206 label *label50
-    * set *tmp54 null
   207 label *label51
   208 op add *tmp55 :compute:cx 1
   209 op len *tmp56 *tmp55 :compute:cy
 
   216 label *label52
   217 set *tmp58 null
   218 label *label53
-    * set *tmp46 *tmp58
   219 label *label49
   220 set :compute:i 0
   221 label *label54
 
   236 op greaterThanEq *tmp67 :compute:dist 64
   237 jump *label57 equal *tmp67 false
   238 jump *label56 always
-    * set *tmp68 null
   239 jump *label58 always
   240 label *label57
-    * set *tmp68 null
   241 label *label58
   242 label *label55
   243 op add :compute:i :compute:i 1
 
   253 op sub *tmp76 4 *tmp75
   254 set :compute:correction *tmp76
   255 op add :compute:i :compute:i :compute:correction
-    * set *tmp71 :compute:i
   256 jump *label60 always
   257 label *label59
-    * set *tmp71 null
   258 label *label60
   259 set *tmp41 :compute:i
   260 jump *label47 always
 
   272 op notEqual *tmp79 *tmp78 .PROCESSOR_ID
   273 jump *label62 equal *tmp79 false
   274 jump *label46 always
-    * set *tmp80 null
   275 jump *label63 always
   276 label *label62
-    * set *tmp80 null
   277 label *label63
   278 read *tmp1 .memory 65
   279 op notEqual *tmp81 .stop *tmp1
   280 jump *label64 equal *tmp81 false
   281 jump *label32 always
-    * set *tmp82 null
   282 jump *label65 always
   283 label *label64
-    * set *tmp82 null
   284 label *label65
   285 label *label45
   286 op add :y :y 1
   287 jump *label44 always
   288 label *label46
-    * set *tmp38 null
   289 jump *label43 always
   290 label *label42
-    * set *tmp38 null
   291 label *label43
   292 op add :line :line :increment
   293 op greaterThan *tmp83 :line 176
 
   296 set :increment :next_increment
   297 op div *tmp85 :increment 2
   298 set :line *tmp85
-    * set *tmp84 :line
   299 jump *label67 always
   300 label *label66
-    * set *tmp84 null
   301 label *label67
   302 label *label40
   303 op add :lines :lines 1
 
   391 label *label74
   392 set *tmp88 *tmp89
   393 label *label73
-    * set *tmp86 *tmp88
   394 jump *label71 always
   395 label *label70
   396 set *tmp129 :drawPixel:iterations
   397 read *tmp130 .memory *tmp129
   398 set :drawPixel:color *tmp130
-    * set *tmp86 :drawPixel:color
   399 label *label71
   400 op greaterThanEq *tmp131 .localBuffer 254
   401 jump *label81 equal *tmp131 false
   402 setaddr :flushLocalBuffer*retaddr *label83 (h:*label83)
   403 call *label1 *invalid :flushLocalBuffer*retval (m:*label83) (h:*label83)
   404 label *label83
-    * set *tmp132 null
   405 jump *label82 always
   406 label *label81
-    * set *tmp132 null
   407 label *label82
   408 draw col :drawPixel:color
   409 draw rect :drawPixel:x :drawPixel:y 1 1
 
   420 jump *label84 equal *tmp139 false
   421 drawflush .display
   422 set .localBuffer 0
-    * set *tmp140 .localBuffer
   423 jump *label85 always
   424 label *label84
   425 op div *tmp141 1800 .localBuffer
 
   432 label *label86
   433 set *tmp143 null
   434 label *label87
-    * set *tmp140 *tmp143
   435 label *label85
   436 label *label69
   437 return :drawPixel*retaddr
 
   452 op greaterThan *tmp149 *tmp148 250
   453 jump *label94 notEqual *tmp149 false
   454 label *label96
-    * set *tmp147 null
   455 jump *label93 always
   456 label *label92
-    * set *tmp147 null
   457 label *label93
   458 drawflush .display
   459 set .localBuffer 0
 
   471 set *tmp155 .PROC_STATE_INDEX
   472 write :setState:state .memory *tmp155
   473 jump *label100 always
-    * set *tmp154 null
   474 jump *label102 always
   475 label *label101
   476 set *tmp157 .PROC_ID_INDEX
 
   489 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
   490 set *tmp160 .PROC_STATE_INDEX
   491 label *label104
-    * set *tmp154 *tmp160
   492 label *label102
   493 label *label99
   494 jump *label98 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-10 instructions):
 
    60 op equal *tmp20 :findLinkedBlocks:requested @message
    61 jump *label22 equal *tmp20 false
    62 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * set *tmp21 :findLinkedBlocks:message
    63 jump *label23 always
    64 label *label22
-    * set *tmp21 null
    65 label *label23
    66 jump *label21 always
    67 label *label20
 
   209 jump *label52 equal *tmp57 false
   210 set *tmp41 63
   211 jump *label47 always
-    * set *tmp58 null
   212 jump *label53 always
   213 label *label52
-    * set *tmp58 null
   214 label *label53
   215 label *label49
   216 set :compute:i 0
 
   311 op equal *tmp87 :drawPixel:iterations 63
   312 jump *label72 equal *tmp87 false
   313 set :drawPixel:color %[black]
-    * set *tmp88 :drawPixel:color
   314 jump *label73 always
   315 label *label72
   316 jump *label76 equal .PALETTE 2
 
   384 set :drawPixel:color *tmp128
   385 set *tmp89 :drawPixel:color
   386 label *label74
-    * set *tmp88 *tmp89
   387 label *label73
   388 jump *label71 always
   389 label *label70
 
   421 jump *label86 equal *tmp142 false
   422 drawflush .display
   423 set .localBuffer 0
-    * set *tmp143 .localBuffer
   424 jump *label87 always
   425 label *label86
-    * set *tmp143 null
   426 label *label87
   427 label *label85
   428 label *label69
 
   474 set *tmp163 .PROC_STATE_INDEX
   475 write :setState:state .memory *tmp163
   476 jump *label100 always
-    * set *tmp160 null
   477 jump *label104 always
   478 label *label103
   479 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   480 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * set *tmp160 .PROC_STATE_INDEX
   481 label *label104
   482 label *label102
   483 label *label99

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   336 set :drawPixel:b *tmp105
   337 packcolor *tmp106 :drawPixel:r :drawPixel:g :drawPixel:b 1
   338 set :drawPixel:color *tmp106
-    * set *tmp89 :drawPixel:color
   339 jump *label74 always
   340 label *label75
   341 jump *label78 equal .PALETTE 3
 
   357 set :drawPixel:b *tmp117
   358 packcolor *tmp118 :drawPixel:r :drawPixel:g :drawPixel:b 1
   359 set :drawPixel:color *tmp118
-    * set *tmp89 :drawPixel:color
   360 jump *label74 always
   361 label *label77
   362 jump *label80 equal .PALETTE 4
 
   371 set :drawPixel:g *tmp123
   372 packcolor *tmp124 :drawPixel:r :drawPixel:g 0 1
   373 set :drawPixel:color *tmp124
-    * set *tmp89 :drawPixel:color
   374 jump *label74 always
   375 label *label79
   376 op mul *tmp125 4 :drawPixel:iterations
 
   379 set :drawPixel:r *tmp127
   380 packcolor *tmp128 :drawPixel:r :drawPixel:r 0 1
   381 set :drawPixel:color *tmp128
-    * set *tmp89 :drawPixel:color
   382 label *label74
   383 label *label73
   384 jump *label71 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-47 instructions):
     0 sensor *tmp9 @this @x
     1 sensor *tmp10 @this @y
     2 op mul *tmp11 10000 *tmp10
-    * op add *tmp12 *tmp9 *tmp11
-    * set .PROCESSOR_ID *tmp12
+    3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
 
    33 op greaterThan *tmp14 :findLinkedBlocks:n 0
    34 jump *label14 equal *tmp14 false
    35 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
-    * getlink *tmp15 :findLinkedBlocks:n
-    * set :findLinkedBlocks:block *tmp15
+   36 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    37 print "\nFound: "
    38 print :findLinkedBlocks:block
-    * sensor *tmp16 :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:type *tmp16
+   39 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    40 set :findLinkedBlocks:requested @large-logic-display
    41 set :findLinkedBlocks:name "Display"
    42 set :findLinkedBlocks:variable .display
 
   129 setaddr :setState*retaddr *label38 (h:*label38)
   130 call *label2 *invalid :setState*retval (m:*label38) (h:*label38)
   131 label *label38
-    * read *tmp4 .memory 68
-    * set .ZOOM *tmp4
+  132 read .ZOOM .memory 68
   133 op div *tmp26 -88 .ZOOM
   134 read *tmp2 .memory 66
-    * op add *tmp27 *tmp26 *tmp2
-    * set .OFFSET_X *tmp27
+  135 op add .OFFSET_X *tmp26 *tmp2
   136 op div *tmp28 -88 .ZOOM
   137 read *tmp3 .memory 67
-    * op add *tmp29 *tmp28 *tmp3
-    * set .OFFSET_Y *tmp29
-    * read *tmp5 .memory 69
-    * set .JULIA *tmp5
-    * read *tmp6 .memory 70
-    * set .JULIA_X *tmp6
-    * read *tmp7 .memory 71
-    * set .JULIA_Y *tmp7
-    * read *tmp8 .memory 72
-    * set .PALETTE *tmp8
-    * op greaterThan *tmp30 .PALETTE 1
-    * set .SMOOTH *tmp30
+  138 op add .OFFSET_Y *tmp28 *tmp3
+  139 read .JULIA .memory 69
+  140 read .JULIA_X .memory 70
+  141 read .JULIA_Y .memory 71
+  142 read .PALETTE .memory 72
+  143 op greaterThan .SMOOTH .PALETTE 1
   144 set :line 8
   145 set :increment 8
   146 set :next_increment 16
 
   150 label *label39
   151 jump *label41 greaterThanEq :lines 176
   152 op mul *tmp32 17 :line
-    * op mod *tmp33 *tmp32 176
-    * set :x *tmp33
-    * op add *tmp34 :x 158
-    * set :position *tmp34
-    * set *tmp35 :position
-    * read *tmp36 .memory *tmp35
+  153 op mod :x *tmp32 176
+  154 op add :position :x 158
+  155 read *tmp36 .memory :position
   156 op equal *tmp37 *tmp36 0
   157 jump *label42 equal *tmp37 false
-    * set *tmp39 :position
-    * write .PROCESSOR_ID .memory *tmp39
+  158 write .PROCESSOR_ID .memory :position
   159 set :y 0
   160 label *label44
   161 jump *label46 greaterThanEq :y 176
   162 set :compute:x :x
   163 set :compute:y :y
   164 op div *tmp42 :compute:x .ZOOM
-    * op add *tmp43 *tmp42 .OFFSET_X
-    * set :compute:zx *tmp43
+  165 op add :compute:zx *tmp42 .OFFSET_X
   166 op div *tmp44 :compute:y .ZOOM
-    * op add *tmp45 *tmp44 .OFFSET_Y
-    * set :compute:zy *tmp45
+  167 op add :compute:zy *tmp44 .OFFSET_Y
   168 jump *label48 equal .JULIA false
   169 set :compute:cx .JULIA_X
   170 set :compute:cy .JULIA_Y
 
   173 set :compute:cx :compute:zx
   174 set :compute:cy :compute:zy
   175 op sub *tmp47 :compute:cx 0.25
-    * op len *tmp48 *tmp47 :compute:cy
-    * set :compute:p *tmp48
+  176 op len :compute:p *tmp47 :compute:cy
   177 op mul *tmp49 2 :compute:p
   178 op mul *tmp50 *tmp49 :compute:p
   179 op sub *tmp51 :compute:p *tmp50
 
   203 op mul *tmp59 :compute:x1 :compute:x1
   204 op mul *tmp60 :compute:y1 :compute:y1
   205 op sub *tmp61 *tmp59 *tmp60
-    * op add *tmp62 *tmp61 :compute:cx
-    * set :compute:zx *tmp62
+  206 op add :compute:zx *tmp61 :compute:cx
   207 op mul *tmp63 2 :compute:x1
   208 op mul *tmp64 *tmp63 :compute:y1
-    * op add *tmp65 *tmp64 :compute:cy
-    * set :compute:zy *tmp65
-    * op len *tmp66 :compute:zx :compute:zy
-    * set :compute:dist *tmp66
+  209 op add :compute:zy *tmp64 :compute:cy
+  210 op len :compute:dist :compute:zx :compute:zy
   211 op greaterThanEq *tmp67 :compute:dist 64
   212 jump *label57 equal *tmp67 false
   213 jump *label56 always
 
   225 op mul *tmp73 *tmp72 0.36067376022224085
   226 op log *tmp74 *tmp73
   227 op mul *tmp75 *tmp74 1.4426950408889634
-    * op sub *tmp76 4 *tmp75
-    * set :compute:correction *tmp76
+  228 op sub :compute:correction 4 *tmp75
   229 op add :compute:i :compute:i :compute:correction
   230 jump *label60 always
   231 label *label59
 
   241 setaddr :drawPixel*retaddr *label61 (h:*label61)
   242 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   243 label *label61
-    * set *tmp77 :position
-    * read *tmp78 .memory *tmp77
+  244 read *tmp78 .memory :position
   245 op notEqual *tmp79 *tmp78 .PROCESSOR_ID
   246 jump *label62 equal *tmp79 false
   247 jump *label46 always
 
   267 jump *label66 equal *tmp83 false
   268 op div :next_increment :next_increment 2
   269 set :increment :next_increment
-    * op div *tmp85 :increment 2
-    * set :line *tmp85
+  270 op div :line :increment 2
   271 jump *label67 always
   272 label *label66
   273 label *label67
 
   296 op abs *tmp92 *tmp91
   297 op mul *tmp93 7 *tmp92
   298 op div *tmp94 *tmp93 255
-    * op sub *tmp95 1 *tmp94
-    * set :drawPixel:r *tmp95
+  299 op sub :drawPixel:r 1 *tmp94
   300 op sub *tmp96 :drawPixel:iterations 32
   301 op abs *tmp97 *tmp96
   302 op mul *tmp98 6 *tmp97
   303 op div *tmp99 *tmp98 255
-    * op sub *tmp100 0.9411764705882353 *tmp99
-    * set :drawPixel:g *tmp100
+  304 op sub :drawPixel:g 0.9411764705882353 *tmp99
   305 op sub *tmp101 32 :drawPixel:iterations
   306 op abs *tmp102 *tmp101
   307 op mul *tmp103 4 *tmp102
   308 op div *tmp104 *tmp103 255
-    * op add *tmp105 0.47058823529411764 *tmp104
-    * set :drawPixel:b *tmp105
-    * packcolor *tmp106 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp106
+  309 op add :drawPixel:b 0.47058823529411764 *tmp104
+  310 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   311 jump *label74 always
   312 label *label75
   313 jump *label78 equal .PALETTE 3
 
   315 label *label78
   316 op div *tmp107 :drawPixel:iterations 63
   317 op mul *tmp108 *tmp107 360
-    * op sin *tmp109 *tmp108
-    * set :drawPixel:r *tmp109
+  318 op sin :drawPixel:r *tmp108
   319 op div *tmp110 :drawPixel:iterations 63
   320 op mul *tmp111 *tmp110 360
-    * op cos *tmp112 *tmp111
-    * set :drawPixel:g *tmp112
+  321 op cos :drawPixel:g *tmp111
   322 op sub *tmp113 :drawPixel:iterations 32
   323 op abs *tmp114 *tmp113
   324 op mul *tmp115 4 *tmp114
   325 op div *tmp116 *tmp115 255
-    * op add *tmp117 0.39215686274509803 *tmp116
-    * set :drawPixel:b *tmp117
-    * packcolor *tmp118 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp118
+  326 op add :drawPixel:b 0.39215686274509803 *tmp116
+  327 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   328 jump *label74 always
   329 label *label77
   330 jump *label80 equal .PALETTE 4
   331 jump *label79 always
   332 label *label80
   333 op mul *tmp119 4 :drawPixel:iterations
-    * op div *tmp120 *tmp119 255
-    * set :drawPixel:r *tmp120
+  334 op div :drawPixel:r *tmp119 255
   335 op mul *tmp121 1.5 :drawPixel:iterations
   336 op div *tmp122 *tmp121 255
-    * op add *tmp123 96 *tmp122
-    * set :drawPixel:g *tmp123
-    * packcolor *tmp124 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp124
+  337 op add :drawPixel:g 96 *tmp122
+  338 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   339 jump *label74 always
   340 label *label79
   341 op mul *tmp125 4 :drawPixel:iterations
   342 op div *tmp126 *tmp125 255
-    * op sub *tmp127 1 *tmp126
-    * set :drawPixel:r *tmp127
-    * packcolor *tmp128 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp128
+  343 op sub :drawPixel:r 1 *tmp126
+  344 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   345 label *label74
   346 label *label73
   347 jump *label71 always
   348 label *label70
-    * set *tmp129 :drawPixel:iterations
-    * read *tmp130 .memory *tmp129
-    * set :drawPixel:color *tmp130
+  349 read :drawPixel:color .memory :drawPixel:iterations
   350 label *label71
   351 op greaterThanEq *tmp131 .localBuffer 254
   352 jump *label81 equal *tmp131 false
 
   359 draw col :drawPixel:color
   360 draw rect :drawPixel:x :drawPixel:y 1 1
   361 op add .localBuffer .localBuffer 2
-    * set *tmp133 .display
-    * sensor *tmp134 *tmp133 @enabled
-    * op sub *tmp135 1 *tmp134
-    * set :drawPixel:disabled *tmp135
+  362 sensor *tmp134 .display @enabled
+  363 op sub :drawPixel:disabled 1 *tmp134
   364 sensor *tmp136 .display @bufferSize
   365 op mul *tmp137 :drawPixel:disabled 900
-    * op add *tmp138 *tmp136 *tmp137
-    * set :drawPixel:usage *tmp138
+  366 op add :drawPixel:usage *tmp136 *tmp137
   367 op lessThan *tmp139 :drawPixel:usage 100
   368 jump *label84 equal *tmp139 false
   369 drawflush .display
 
   410 label *label98
   411 op lessThan *tmp150 .PROC_STATE_INDEX 512
   412 jump *label100 equal *tmp150 false
-    * set *tmp151 .PROC_ID_INDEX
-    * read *tmp152 .memory *tmp151
+  413 read *tmp152 .memory .PROC_ID_INDEX
   414 op equal *tmp153 *tmp152 .PROCESSOR_ID
   415 jump *label101 equal *tmp153 false
-    * set *tmp155 .PROC_STATE_INDEX
-    * write :setState:state .memory *tmp155
+  416 write :setState:state .memory .PROC_STATE_INDEX
   417 jump *label100 always
   418 jump *label102 always
   419 label *label101
-    * set *tmp157 .PROC_ID_INDEX
-    * read *tmp158 .memory *tmp157
+  420 read *tmp158 .memory .PROC_ID_INDEX
   421 op equal *tmp159 *tmp158 0
   422 jump *label103 equal *tmp159 false
-    * set *tmp161 .PROC_ID_INDEX
-    * write .PROCESSOR_ID .memory *tmp161
-    * set *tmp163 .PROC_STATE_INDEX
-    * write :setState:state .memory *tmp163
+  423 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  424 write :setState:state .memory .PROC_STATE_INDEX
   425 jump *label100 always
   426 jump *label104 always
   427 label *label103

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
   108 label *label6
   109 label *label3
   110 label *label31
-    * jump *label33 equal true false
   111 set .localBuffer 0
   112 drawflush null
   113 label *label34

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   288 set :drawPixel:color %[black]
   289 jump *label73 always
   290 label *label72
-    * jump *label76 equal .PALETTE 2
-    * jump *label75 always
+  291 jump *label75 notEqual .PALETTE 2
   292 label *label76
   293 op sub *tmp91 32 :drawPixel:iterations
   294 op abs *tmp92 *tmp91
 
   308 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   309 jump *label74 always
   310 label *label75
-    * jump *label78 equal .PALETTE 3
-    * jump *label77 always
+  311 jump *label77 notEqual .PALETTE 3
   312 label *label78
   313 op div *tmp107 :drawPixel:iterations 63
   314 op mul *tmp108 *tmp107 360
 
   324 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   325 jump *label74 always
   326 label *label77
-    * jump *label80 equal .PALETTE 4
-    * jump *label79 always
+  327 jump *label79 notEqual .PALETTE 4
   328 label *label80
   329 op mul *tmp119 4 :drawPixel:iterations
   330 op div :drawPixel:r *tmp119 255

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-23 instructions):
 
    30 print :findLinkedBlocks:title
    31 set :findLinkedBlocks:n @links
    32 label *label12
-    * op greaterThan *tmp14 :findLinkedBlocks:n 0
-    * jump *label14 equal *tmp14 false
+   33 jump *label14 lessThanEq :findLinkedBlocks:n 0
    34 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    35 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    36 print "\nFound: "
 
    50 set :findLinkedBlocks:required true
    51 setaddr *tmp17 *label19
    52 label *label15
-    * op equal *tmp18 :findLinkedBlocks:requested :findLinkedBlocks:type
-    * jump *label20 equal *tmp18 false
+   53 jump *label20 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    54 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * op equal *tmp20 :findLinkedBlocks:requested @message
-    * jump *label22 equal *tmp20 false
+   55 jump *label22 notEqual :findLinkedBlocks:requested @message
    56 set :findLinkedBlocks:message :findLinkedBlocks:block
    57 jump *label23 always
    58 label *label22
 
   100 label *label26
   101 printflush :findLinkedBlocks:message
   102 label *label5
-    * op equal *tmp24 :findLinkedBlocks:foundAll false
-    * jump *label4 notEqual *tmp24 false
+  103 jump *label4 equal :findLinkedBlocks:foundAll false
   104 label *label6
   105 label *label3
   106 label *label31
 
   113 label *label37
   114 label *label35
   115 read *tmp0 .memory 64
-    * op equal *tmp25 .start *tmp0
-    * jump *label34 notEqual *tmp25 false
+  116 jump *label34 equal .start *tmp0
   117 label *label36
   118 read *tmp0 .memory 64
   119 set .start *tmp0
 
   147 op mod :x *tmp32 176
   148 op add :position :x 158
   149 read *tmp36 .memory :position
-    * op equal *tmp37 *tmp36 0
-    * jump *label42 equal *tmp37 false
+  150 jump *label42 notEqual *tmp36 0
   151 write .PROCESSOR_ID .memory :position
   152 set :y 0
   153 label *label44
 
   171 op mul *tmp50 *tmp49 :compute:p
   172 op sub *tmp51 :compute:p *tmp50
   173 op add *tmp52 *tmp51 0.25
-    * op lessThanEq *tmp53 :compute:cx *tmp52
-    * jump *label50 equal *tmp53 false
+  174 jump *label50 greaterThan :compute:cx *tmp52
   175 set *tmp41 63
   176 jump *label47 always
   177 jump *label51 always
 
   179 label *label51
   180 op add *tmp55 :compute:cx 1
   181 op len *tmp56 *tmp55 :compute:cy
-    * op lessThanEq *tmp57 *tmp56 0.25
-    * jump *label52 equal *tmp57 false
+  182 jump *label52 greaterThan *tmp56 0.25
   183 set *tmp41 63
   184 jump *label47 always
   185 jump *label53 always
 
   199 op mul *tmp64 *tmp63 :compute:y1
   200 op add :compute:zy *tmp64 :compute:cy
   201 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp67 :compute:dist 64
-    * jump *label57 equal *tmp67 false
+  202 jump *label57 lessThan :compute:dist 64
   203 jump *label56 always
   204 jump *label58 always
   205 label *label57
 
   209 jump *label54 always
   210 label *label56
   211 op mul *tmp69 .SMOOTH 63
-    * op lessThan *tmp70 :compute:i *tmp69
-    * jump *label59 equal *tmp70 false
+  212 jump *label59 greaterThanEq :compute:i *tmp69
   213 op log *tmp72 :compute:dist
   214 op mul *tmp73 *tmp72 0.36067376022224085
   215 op log *tmp74 *tmp73
 
   231 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   232 label *label61
   233 read *tmp78 .memory :position
-    * op notEqual *tmp79 *tmp78 .PROCESSOR_ID
-    * jump *label62 equal *tmp79 false
+  234 jump *label62 equal *tmp78 .PROCESSOR_ID
   235 jump *label46 always
   236 jump *label63 always
   237 label *label62
   238 label *label63
   239 read *tmp1 .memory 65
-    * op notEqual *tmp81 .stop *tmp1
-    * jump *label64 equal *tmp81 false
+  240 jump *label64 equal .stop *tmp1
   241 jump *label32 always
   242 jump *label65 always
   243 label *label64
 
   250 label *label42
   251 label *label43
   252 op add :line :line :increment
-    * op greaterThan *tmp83 :line 176
-    * jump *label66 equal *tmp83 false
+  253 jump *label66 lessThanEq :line 176
   254 op div :next_increment :next_increment 2
   255 set :increment :next_increment
   256 op div :line :increment 2
 
   270 end
   271 label *label0
   272 jump *label70 equal .SMOOTH false
-    * op equal *tmp87 :drawPixel:iterations 63
-    * jump *label72 equal *tmp87 false
+  273 jump *label72 notEqual :drawPixel:iterations 63
   274 set :drawPixel:color %[black]
   275 jump *label73 always
   276 label *label72
 
   330 label *label70
   331 read :drawPixel:color .memory :drawPixel:iterations
   332 label *label71
-    * op greaterThanEq *tmp131 .localBuffer 254
-    * jump *label81 equal *tmp131 false
+  333 jump *label81 lessThan .localBuffer 254
   334 setaddr :flushLocalBuffer*retaddr *label83 (h:*label83)
   335 call *label1 *invalid :flushLocalBuffer*retval (m:*label83) (h:*label83)
   336 label *label83
 
   345 sensor *tmp136 .display @bufferSize
   346 op mul *tmp137 :drawPixel:disabled 900
   347 op add :drawPixel:usage *tmp136 *tmp137
-    * op lessThan *tmp139 :drawPixel:usage 100
-    * jump *label84 equal *tmp139 false
+  348 jump *label84 greaterThanEq :drawPixel:usage 100
   349 drawflush .display
   350 set .localBuffer 0
   351 jump *label85 always
   352 label *label84
   353 op div *tmp141 1800 .localBuffer
-    * op lessThan *tmp142 :drawPixel:usage *tmp141
-    * jump *label86 equal *tmp142 false
+  354 jump *label86 greaterThanEq :drawPixel:usage *tmp141
   355 drawflush .display
   356 set .localBuffer 0
   357 jump *label87 always
 
   365 label *label89
   366 label *label90
   367 sensor *tmp144 .display @enabled
-    * op equal *tmp145 *tmp144 false
-    * jump *label89 notEqual *tmp145 false
+  368 jump *label89 equal *tmp144 false
   369 label *label91
-    * op greaterThan *tmp146 .localBuffer 4
-    * jump *label92 equal *tmp146 false
+  370 jump *label92 lessThanEq .localBuffer 4
   371 label *label94
   372 wait 0.0001
   373 label *label95
   374 sensor *tmp148 .display @bufferSize
-    * op greaterThan *tmp149 *tmp148 250
-    * jump *label94 notEqual *tmp149 false
+  375 jump *label94 greaterThan *tmp148 250
   376 label *label96
   377 jump *label93 always
   378 label *label92
 
   384 end
   385 label *label2
   386 label *label98
-    * op lessThan *tmp150 .PROC_STATE_INDEX 512
-    * jump *label100 equal *tmp150 false
+  387 jump *label100 greaterThanEq .PROC_STATE_INDEX 512
   388 read *tmp152 .memory .PROC_ID_INDEX
-    * op equal *tmp153 *tmp152 .PROCESSOR_ID
-    * jump *label101 equal *tmp153 false
+  389 jump *label101 notEqual *tmp152 .PROCESSOR_ID
   390 write :setState:state .memory .PROC_STATE_INDEX
   391 jump *label100 always
   392 jump *label102 always
   393 label *label101
   394 read *tmp158 .memory .PROC_ID_INDEX
-    * op equal *tmp159 *tmp158 0
-    * jump *label103 equal *tmp159 false
+  395 jump *label103 notEqual *tmp158 0
   396 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   397 write :setState:state .memory .PROC_STATE_INDEX
   398 jump *label100 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-14 instructions):
 
    54 set :findLinkedBlocks:variable :findLinkedBlocks:block
    55 jump *label22 notEqual :findLinkedBlocks:requested @message
    56 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * jump *label23 always
    57 label *label22
    58 label *label23
-    * jump *label21 always
    59 label *label20
    60 label *label21
    61 label *label16
 
    88 print :findLinkedBlocks:variable
    89 jump *label29 equal :findLinkedBlocks:required false
    90 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * jump *label30 always
    91 label *label29
    92 label *label30
    93 label *label25
 
   171 jump *label50 greaterThan :compute:cx *tmp52
   172 set *tmp41 63
   173 jump *label47 always
-    * jump *label51 always
   174 label *label50
   175 label *label51
   176 op add *tmp55 :compute:cx 1
 
   178 jump *label52 greaterThan *tmp56 0.25
   179 set *tmp41 63
   180 jump *label47 always
-    * jump *label53 always
   181 label *label52
   182 label *label53
   183 label *label49
 
   196 op len :compute:dist :compute:zx :compute:zy
   197 jump *label57 lessThan :compute:dist 64
   198 jump *label56 always
-    * jump *label58 always
   199 label *label57
   200 label *label58
   201 label *label55
 
   210 op mul *tmp75 *tmp74 1.4426950408889634
   211 op sub :compute:correction 4 *tmp75
   212 op add :compute:i :compute:i :compute:correction
-    * jump *label60 always
   213 label *label59
   214 label *label60
   215 set *tmp41 :compute:i
 
   226 read *tmp78 .memory :position
   227 jump *label62 equal *tmp78 .PROCESSOR_ID
   228 jump *label46 always
-    * jump *label63 always
   229 label *label62
   230 label *label63
   231 read *tmp1 .memory 65
   232 jump *label64 equal .stop *tmp1
   233 jump *label32 always
-    * jump *label65 always
   234 label *label64
   235 label *label65
   236 label *label45
   237 op add :y :y 1
   238 jump *label44 always
   239 label *label46
-    * jump *label43 always
   240 label *label42
   241 label *label43
   242 op add :line :line :increment
 
   244 op div :next_increment :next_increment 2
   245 set :increment :next_increment
   246 op div :line :increment 2
-    * jump *label67 always
   247 label *label66
   248 label *label67
   249 label *label40
 
   323 setaddr :flushLocalBuffer*retaddr *label83 (h:*label83)
   324 call *label1 *invalid :flushLocalBuffer*retval (m:*label83) (h:*label83)
   325 label *label83
-    * jump *label82 always
   326 label *label81
   327 label *label82
   328 draw col :drawPixel:color
 
   342 jump *label86 greaterThanEq :drawPixel:usage *tmp141
   343 drawflush .display
   344 set .localBuffer 0
-    * jump *label87 always
   345 label *label86
   346 label *label87
   347 label *label85
 
   361 sensor *tmp148 .display @bufferSize
   362 jump *label94 greaterThan *tmp148 250
   363 label *label96
-    * jump *label93 always
   364 label *label92
   365 label *label93
   366 drawflush .display

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
-    * sensor *tmp9 @this @x
-    * sensor *tmp10 @this @y
+    0 set *tmp9 @thisx
+    1 set *tmp10 @thisy
     2 op mul *tmp11 10000 *tmp10
     3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
     0 set *tmp9 @thisx
     1 set *tmp10 @thisy
-    * op mul *tmp11 10000 *tmp10
-    * op add .PROCESSOR_ID *tmp9 *tmp11
+    2 op mul *tmp11 10000 @thisy
+    3 op add .PROCESSOR_ID @thisx *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
     7 set :findLinkedBlocks:title "Mandelbrot Generator"
     8 set :findLinkedBlocks:message null
     9 label *label4
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    10 setaddr *tmp13 *label10
    11 jump *label7 always
    12 multilabel *label10 (m:marker0)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
+   13 set .display null
    14 setaddr *tmp13 *label11
    15 label *label7
    16 set :findLinkedBlocks:variable null
    17 label *label8
    18 multijump *tmp13 0 0 (m:marker0)
    19 multilabel *label11 (m:marker0)
-    * set .memory :findLinkedBlocks:variable
+   20 set .memory null
    21 label *label9
-    * print :findLinkedBlocks:title
+   22 print "Mandelbrot Generator"
    23 set :findLinkedBlocks:n @links
    24 label *label12
    25 jump *label14 lessThanEq :findLinkedBlocks:n 0
 
    29 print :findLinkedBlocks:block
    30 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    31 set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
    32 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    33 setaddr *tmp17 *label18
    34 jump *label15 always
    35 multilabel *label18 (m:marker1)
    36 set .display :findLinkedBlocks:variable
    37 set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
    38 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    39 setaddr *tmp17 *label19
    40 label *label15
    41 jump *label20 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
 
    55 jump *label12 always
    56 label *label14
    57 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:requested @large-logic-display
    58 set :findLinkedBlocks:name "Display"
    59 set :findLinkedBlocks:variable .display
    60 set :findLinkedBlocks:required true
 
    62 jump *label24 always
    63 multilabel *label27 (m:marker2)
    64 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    65 set :findLinkedBlocks:name "Memory"
    66 set :findLinkedBlocks:variable .memory
    67 set :findLinkedBlocks:required true
 
    72 print ":"
    73 print " "
    74 print :findLinkedBlocks:variable
-    * jump *label29 equal :findLinkedBlocks:required false
+   75 jump *label29 equal true false
    76 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
    77 label *label29
    78 label *label30
 
   102 set .start *tmp0
   103 read *tmp1 .memory 65
   104 set .stop *tmp1
-    * set :setState:state .start
+  105 set :setState:state *tmp0
   106 setaddr :setState*retaddr *label38 (h:*label38)
   107 call *label2 *invalid :setState*retval (m:*label38) (h:*label38)
   108 label *label38
 
   112 op add .OFFSET_X *tmp26 *tmp2
   113 op div *tmp28 -88 .ZOOM
   114 read *tmp3 .memory 67
-    * op add .OFFSET_Y *tmp28 *tmp3
+  115 op add .OFFSET_Y *tmp26 *tmp3
   116 read .JULIA .memory 69
   117 read .JULIA_X .memory 70
   118 read .JULIA_Y .memory 71
 
   137 jump *label46 greaterThanEq :y 176
   138 set :compute:x :x
   139 set :compute:y :y
-    * op div *tmp42 :compute:x .ZOOM
+  140 op div *tmp42 :x .ZOOM
   141 op add :compute:zx *tmp42 .OFFSET_X
-    * op div *tmp44 :compute:y .ZOOM
+  142 op div *tmp44 :y .ZOOM
   143 op add :compute:zy *tmp44 .OFFSET_Y
   144 jump *label48 equal .JULIA false
   145 set :compute:cx .JULIA_X
 
   148 label *label48
   149 set :compute:cx :compute:zx
   150 set :compute:cy :compute:zy
-    * op sub *tmp47 :compute:cx 0.25
-    * op len :compute:p *tmp47 :compute:cy
+  151 op sub *tmp47 :compute:zx 0.25
+  152 op len :compute:p *tmp47 :compute:zy
   153 op mul *tmp49 2 :compute:p
   154 op mul *tmp50 *tmp49 :compute:p
   155 op sub *tmp51 :compute:p *tmp50
   156 op add *tmp52 *tmp51 0.25
-    * jump *label50 greaterThan :compute:cx *tmp52
+  157 jump *label50 greaterThan :compute:zx *tmp52
   158 set *tmp41 63
   159 jump *label47 always
   160 label *label50
   161 label *label51
-    * op add *tmp55 :compute:cx 1
-    * op len *tmp56 *tmp55 :compute:cy
+  162 op add *tmp55 :compute:zx 1
+  163 op len *tmp56 *tmp55 :compute:zy
   164 jump *label52 greaterThan *tmp56 0.25
   165 set *tmp41 63
   166 jump *label47 always
 
   172 jump *label56 greaterThanEq :compute:i 63
   173 set :compute:x1 :compute:zx
   174 set :compute:y1 :compute:zy
-    * op mul *tmp59 :compute:x1 :compute:x1
-    * op mul *tmp60 :compute:y1 :compute:y1
+  175 op mul *tmp59 :compute:zx :compute:zx
+  176 op mul *tmp60 :compute:zy :compute:zy
   177 op sub *tmp61 *tmp59 *tmp60
   178 op add :compute:zx *tmp61 :compute:cx
   179 op mul *tmp63 2 :compute:x1
-    * op mul *tmp64 *tmp63 :compute:y1
+  180 op mul *tmp64 *tmp63 :compute:zy
   181 op add :compute:zy *tmp64 :compute:cy
   182 op len :compute:dist :compute:zx :compute:zy
   183 jump *label57 lessThan :compute:dist 64
 
   200 label *label60
   201 set *tmp41 :compute:i
   202 jump *label47 always
-    * set *tmp41 null
   203 label *label47
   204 set :iterations *tmp41
   205 set :drawPixel:x :x
   206 set :drawPixel:y :y
-    * set :drawPixel:iterations :iterations
+  207 set :drawPixel:iterations *tmp41
   208 setaddr :drawPixel*retaddr *label61 (h:*label61)
   209 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   210 label *label61
 
   228 jump *label66 lessThanEq :line 176
   229 op div :next_increment :next_increment 2
   230 set :increment :next_increment
-    * op div :line :increment 2
+  231 op div :line :next_increment 2
   232 label *label66
   233 label *label67
   234 label *label40
 
   253 op sub *tmp91 32 :drawPixel:iterations
   254 op abs *tmp92 *tmp91
   255 op mul *tmp93 7 *tmp92
-    * op div *tmp94 *tmp93 255
+  256 op div *tmp94 *tmp92 36.42857142857143
   257 op sub :drawPixel:r 1 *tmp94
   258 op sub *tmp96 :drawPixel:iterations 32
   259 op abs *tmp97 *tmp96
   260 op mul *tmp98 6 *tmp97
-    * op div *tmp99 *tmp98 255
+  261 op div *tmp99 *tmp97 42.5
   262 op sub :drawPixel:g 0.9411764705882353 *tmp99
   263 op sub *tmp101 32 :drawPixel:iterations
-    * op abs *tmp102 *tmp101
-    * op mul *tmp103 4 *tmp102
-    * op div *tmp104 *tmp103 255
+  264 op abs *tmp102 *tmp91
+  265 op mul *tmp103 4 *tmp92
+  266 op div *tmp104 *tmp102 63.75
   267 op add :drawPixel:b 0.47058823529411764 *tmp104
   268 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   269 jump *label74 always
 
   271 jump *label77 notEqual .PALETTE 3
   272 label *label78
   273 op div *tmp107 :drawPixel:iterations 63
-    * op mul *tmp108 *tmp107 360
+  274 op div *tmp108 :drawPixel:iterations 0.175
   275 op sin :drawPixel:r *tmp108
   276 op div *tmp110 :drawPixel:iterations 63
-    * op mul *tmp111 *tmp110 360
-    * op cos :drawPixel:g *tmp111
+  277 op mul *tmp111 *tmp107 360
+  278 op cos :drawPixel:g *tmp108
   279 op sub *tmp113 :drawPixel:iterations 32
   280 op abs *tmp114 *tmp113
   281 op mul *tmp115 4 *tmp114
-    * op div *tmp116 *tmp115 255
+  282 op div *tmp116 *tmp114 63.75
   283 op add :drawPixel:b 0.39215686274509803 *tmp116
   284 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   285 jump *label74 always
 
   287 jump *label79 notEqual .PALETTE 4
   288 label *label80
   289 op mul *tmp119 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp119 255
+  290 op div :drawPixel:r :drawPixel:iterations 63.75
   291 op mul *tmp121 1.5 :drawPixel:iterations
-    * op div *tmp122 *tmp121 255
+  292 op div *tmp122 :drawPixel:iterations 170
   293 op add :drawPixel:g 96 *tmp122
   294 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   295 jump *label74 always
   296 label *label79
   297 op mul *tmp125 4 :drawPixel:iterations
-    * op div *tmp126 *tmp125 255
+  298 op div *tmp126 :drawPixel:iterations 63.75
   299 op sub :drawPixel:r 1 *tmp126
   300 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   301 label *label74

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-20 instructions):
-    * set *tmp9 @thisx
-    * set *tmp10 @thisy
     0 op mul *tmp11 10000 @thisy
     1 op add .PROCESSOR_ID @thisx *tmp11
     2 set .PROC_ID_INDEX 334
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
-    * set :findLinkedBlocks:title "Mandelbrot Generator"
     5 set :findLinkedBlocks:message null
     6 label *label4
     7 setaddr *tmp13 *label10
 
    10 set .display null
    11 setaddr *tmp13 *label11
    12 label *label7
-    * set :findLinkedBlocks:variable null
    13 label *label8
    14 multijump *tmp13 0 0 (m:marker0)
    15 multilabel *label11 (m:marker0)
 
    53 set :findLinkedBlocks:foundAll 1
    54 set :findLinkedBlocks:name "Display"
    55 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    56 setaddr *tmp22 *label27
    57 jump *label24 always
    58 multilabel *label27 (m:marker2)
    59 set .display :findLinkedBlocks:variable
    60 set :findLinkedBlocks:name "Memory"
    61 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    62 setaddr *tmp22 *label28
    63 label *label24
    64 print "\n"
 
   104 op div *tmp26 -88 .ZOOM
   105 read *tmp2 .memory 66
   106 op add .OFFSET_X *tmp26 *tmp2
-    * op div *tmp28 -88 .ZOOM
   107 read *tmp3 .memory 67
   108 op add .OFFSET_Y *tmp26 *tmp3
   109 read .JULIA .memory 69
 
   128 set :y 0
   129 label *label44
   130 jump *label46 greaterThanEq :y 176
-    * set :compute:x :x
-    * set :compute:y :y
   131 op div *tmp42 :x .ZOOM
   132 op add :compute:zx *tmp42 .OFFSET_X
   133 op div *tmp44 :y .ZOOM
 
   162 label *label54
   163 jump *label56 greaterThanEq :compute:i 63
   164 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   165 op mul *tmp59 :compute:zx :compute:zx
   166 op mul *tmp60 :compute:zy :compute:zy
   167 op sub *tmp61 *tmp59 *tmp60
 
   191 set *tmp41 :compute:i
   192 jump *label47 always
   193 label *label47
-    * set :iterations *tmp41
   194 set :drawPixel:x :x
   195 set :drawPixel:y :y
   196 set :drawPixel:iterations *tmp41
 
   241 label *label76
   242 op sub *tmp91 32 :drawPixel:iterations
   243 op abs *tmp92 *tmp91
-    * op mul *tmp93 7 *tmp92
   244 op div *tmp94 *tmp92 36.42857142857143
   245 op sub :drawPixel:r 1 *tmp94
   246 op sub *tmp96 :drawPixel:iterations 32
   247 op abs *tmp97 *tmp96
-    * op mul *tmp98 6 *tmp97
   248 op div *tmp99 *tmp97 42.5
   249 op sub :drawPixel:g 0.9411764705882353 *tmp99
-    * op sub *tmp101 32 :drawPixel:iterations
   250 op abs *tmp102 *tmp91
-    * op mul *tmp103 4 *tmp92
-    * op div *tmp104 *tmp102 63.75
+  251 op div *tmp104 *tmp92 63.75
   252 op add :drawPixel:b 0.47058823529411764 *tmp104
   253 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   254 jump *label74 always
 
   258 op div *tmp107 :drawPixel:iterations 63
   259 op div *tmp108 :drawPixel:iterations 0.175
   260 op sin :drawPixel:r *tmp108
-    * op div *tmp110 :drawPixel:iterations 63
-    * op mul *tmp111 *tmp107 360
+  261 op div *tmp111 :drawPixel:iterations 0.175
   262 op cos :drawPixel:g *tmp108
   263 op sub *tmp113 :drawPixel:iterations 32
   264 op abs *tmp114 *tmp113
-    * op mul *tmp115 4 *tmp114
   265 op div *tmp116 *tmp114 63.75
   266 op add :drawPixel:b 0.39215686274509803 *tmp116
   267 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   269 label *label77
   270 jump *label79 notEqual .PALETTE 4
   271 label *label80
-    * op mul *tmp119 4 :drawPixel:iterations
   272 op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp121 1.5 :drawPixel:iterations
   273 op div *tmp122 :drawPixel:iterations 170
   274 op add :drawPixel:g 96 *tmp122
   275 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   276 jump *label74 always
   277 label *label79
-    * op mul *tmp125 4 :drawPixel:iterations
   278 op div *tmp126 :drawPixel:iterations 63.75
   279 op sub :drawPixel:r 1 *tmp126
   280 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
   247 op abs *tmp97 *tmp96
   248 op div *tmp99 *tmp97 42.5
   249 op sub :drawPixel:g 0.9411764705882353 *tmp99
-    * op abs *tmp102 *tmp91
   250 op div *tmp104 *tmp92 63.75
   251 op add :drawPixel:b 0.47058823529411764 *tmp104
   252 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   254 label *label75
   255 jump *label77 notEqual .PALETTE 3
   256 label *label78
-    * op div *tmp107 :drawPixel:iterations 63
   257 op div *tmp108 :drawPixel:iterations 0.175
   258 op sin :drawPixel:r *tmp108
-    * op div *tmp111 :drawPixel:iterations 0.175
   259 op cos :drawPixel:g *tmp108
   260 op sub *tmp113 :drawPixel:iterations 32
   261 op abs *tmp114 *tmp113

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    83 label *label31
    84 set .localBuffer 0
    85 drawflush null
+   86 set :setState:state 0
+   87 setaddr :setState*retaddr *label37 (h:*label37)
    88 label *label34
-    * set :setState:state 0
-    * setaddr :setState*retaddr *label37 (h:*label37)
    89 call *label2 *invalid :setState*retval (m:*label37) (h:*label37)
    90 label *label37
    91 label *label35
 
   126 jump *label42 notEqual *tmp36 0
   127 write .PROCESSOR_ID .memory :position
   128 set :y 0
+  129 set :drawPixel:x :x
+  130 setaddr :drawPixel*retaddr *label61 (h:*label61)
   131 label *label44
   132 jump *label46 greaterThanEq :y 176
   133 op div *tmp42 :x .ZOOM
 
   193 set *tmp41 :compute:i
   194 jump *label47 always
   195 label *label47
-    * set :drawPixel:x :x
   196 set :drawPixel:y :y
   197 set :drawPixel:iterations *tmp41
-    * setaddr :drawPixel*retaddr *label61 (h:*label61)
   198 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   199 label *label61
   200 read *tmp78 .memory :position

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1 (-3 instructions):
 
    19 set :findLinkedBlocks:n @links
    20 label *label12
    21 jump *label14 lessThanEq :findLinkedBlocks:n 0
+   22 label *label105
    23 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    24 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    25 print "\nFound: "
 
    49 set .memory :findLinkedBlocks:variable
    50 label *label17
    51 label *label13
-    * jump *label12 always
+   52 jump *label105 greaterThan :findLinkedBlocks:n 0
    53 label *label14
    54 set :findLinkedBlocks:foundAll 1
    55 set :findLinkedBlocks:name "Display"
 
   119 wait *tmp31
   120 set :lines 0
   121 label *label39
-    * jump *label41 greaterThanEq :lines 176
+  122 label *label106
   123 op mul *tmp32 17 :line
   124 op mod :x *tmp32 176
   125 op add :position :x 158
 
   130 set :drawPixel:x :x
   131 setaddr :drawPixel*retaddr *label61 (h:*label61)
   132 label *label44
-    * jump *label46 greaterThanEq :y 176
+  133 label *label107
   134 op div *tmp42 :x .ZOOM
   135 op add :compute:zx *tmp42 .OFFSET_X
   136 op div *tmp44 :y .ZOOM
 
   163 label *label49
   164 set :compute:i 0
   165 label *label54
-    * jump *label56 greaterThanEq :compute:i 63
+  166 label *label108
   167 set :compute:x1 :compute:zx
   168 op mul *tmp59 :compute:zx :compute:zx
   169 op mul *tmp60 :compute:zy :compute:zy
 
   179 label *label58
   180 label *label55
   181 op add :compute:i :compute:i 1
-    * jump *label54 always
+  182 jump *label108 lessThan :compute:i 63
   183 label *label56
   184 op mul *tmp69 .SMOOTH 63
   185 jump *label59 greaterThanEq :compute:i *tmp69
 
   210 label *label65
   211 label *label45
   212 op add :y :y 1
-    * jump *label44 always
+  213 jump *label107 lessThan :y 176
   214 label *label46
   215 label *label42
   216 label *label43
 
   223 label *label67
   224 label *label40
   225 op add :lines :lines 1
-    * jump *label39 always
+  226 jump *label106 lessThan :lines 176
   227 label *label41
   228 setaddr :flushLocalBuffer*retaddr *label68 (h:*label68)
   229 call *label1 *invalid :flushLocalBuffer*retval (m:*label68) (h:*label68)
 
   334 label *label2
   335 label *label98
   336 jump *label100 greaterThanEq .PROC_STATE_INDEX 512
+  337 label *label109
   338 read *tmp152 .memory .PROC_ID_INDEX
   339 jump *label101 notEqual *tmp152 .PROCESSOR_ID
   340 write :setState:state .memory .PROC_STATE_INDEX
 
   353 label *label104
   354 label *label102
   355 label *label99
-    * jump *label98 always
+  356 jump *label109 lessThan .PROC_STATE_INDEX 512
   357 label *label100
   358 label *label97
   359 return :setState*retaddr

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
    37 label *label15
    38 jump *label20 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    39 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label22 notEqual :findLinkedBlocks:requested @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
-    * label *label22
-    * label *label23
+   40 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
    41 label *label20
    42 label *label21
    43 label *label16

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   231 end
   232 label *label0
   233 jump *label70 equal .SMOOTH false
-    * jump *label72 notEqual :drawPixel:iterations 63
   234 set :drawPixel:color %[black]
-    * jump *label73 always
+  235 jump *label73 equal :drawPixel:iterations 63
   236 label *label72
   237 jump *label75 notEqual .PALETTE 2
   238 label *label76

Modifications by Unroll iteration loop at *blocks:68:13 (-1 instructions):
 
    25 print "\nFound: "
    26 print :findLinkedBlocks:block
    27 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp17 *label18
-    * jump *label15 always
-    * multilabel *label18 (m:marker1)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp17 *label19
-    * label *label15
-    * jump *label20 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
-    * label *label20
-    * label *label21
-    * label *label16
-    * multijump *tmp17 0 0 (m:marker1)
-    * multilabel *label19 (m:marker1)
-    * set .memory :findLinkedBlocks:variable
-    * label *label17
+   28 set :findLinkedBlocks:requested @large-logic-display
+   29 set :findLinkedBlocks:variable .display
+   30 label *label110
+   31 jump *label111 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   32 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   33 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   34 label *label111
+   35 label *label112
+   36 label *label113
+   37 set .display :findLinkedBlocks:variable
+   38 set :findLinkedBlocks:requested @memory-bank
+   39 set :findLinkedBlocks:variable .memory
+   40 label *label116
+   41 jump *label117 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   42 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   43 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   44 label *label117
+   45 label *label118
+   46 label *label119
+   47 set .memory :findLinkedBlocks:variable
+   48 label *label17
    49 label *label13
    50 jump *label105 greaterThan :findLinkedBlocks:n 0
    51 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    28 set :findLinkedBlocks:requested @large-logic-display
    29 set :findLinkedBlocks:variable .display
    30 label *label110
-    * jump *label111 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   31 jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
    32 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   33 select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
    34 label *label111
    35 label *label112
    36 label *label113
 
    38 set :findLinkedBlocks:requested @memory-bank
    39 set :findLinkedBlocks:variable .memory
    40 label *label116
-    * jump *label117 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   41 jump *label117 notEqual @memory-bank :findLinkedBlocks:type
    42 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   43 select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
    44 label *label117
    45 label *label118
    46 label *label119

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    25 print "\nFound: "
    26 print :findLinkedBlocks:block
    27 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
    28 set :findLinkedBlocks:variable .display
    29 label *label110
    30 jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
 
    34 label *label112
    35 label *label113
    36 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    37 set :findLinkedBlocks:variable .memory
    38 label *label116
    39 jump *label117 notEqual @memory-bank :findLinkedBlocks:type

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
 
     4 set .start 0
     5 set :findLinkedBlocks:message null
     6 label *label4
-    * setaddr *tmp13 *label10
-    * jump *label7 always
-    * multilabel *label10 (m:marker0)
-    * set .display null
-    * setaddr *tmp13 *label11
-    * label *label7
-    * label *label8
-    * multijump *tmp13 0 0 (m:marker0)
-    * multilabel *label11 (m:marker0)
-    * set .memory null
-    * label *label9
+    7 label *label123
+    8 label *label124
+    9 set .display null
+   10 label *label127
+   11 label *label128
+   12 set .memory null
+   13 label *label9
    14 print "Mandelbrot Generator"
    15 set :findLinkedBlocks:n @links
    16 label *label12

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    44 jump *label105 greaterThan :findLinkedBlocks:n 0
    45 label *label14
    46 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp22 *label27
-    * jump *label24 always
-    * multilabel *label27 (m:marker2)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp22 *label28
-    * label *label24
-    * print "\n"
-    * print :findLinkedBlocks:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks:variable
-    * jump *label29 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * label *label29
-    * label *label30
-    * label *label25
-    * multijump *tmp22 0 0 (m:marker2)
-    * multilabel *label28 (m:marker2)
-    * set .memory :findLinkedBlocks:variable
-    * label *label26
+   47 set :findLinkedBlocks:name "Display"
+   48 set :findLinkedBlocks:variable .display
+   49 label *label132
+   50 print "\n"
+   51 print :findLinkedBlocks:name
+   52 print ":"
+   53 print " "
+   54 print :findLinkedBlocks:variable
+   55 jump *label133 equal true false
+   56 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   57 label *label133
+   58 label *label134
+   59 label *label135
+   60 set .display :findLinkedBlocks:variable
+   61 set :findLinkedBlocks:name "Memory"
+   62 set :findLinkedBlocks:variable .memory
+   63 label *label138
+   64 print "\n"
+   65 print :findLinkedBlocks:name
+   66 print ":"
+   67 print " "
+   68 print :findLinkedBlocks:variable
+   69 jump *label139 equal true false
+   70 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   71 label *label139
+   72 label *label140
+   73 label *label141
+   74 set .memory :findLinkedBlocks:variable
+   75 label *label26
    76 printflush :findLinkedBlocks:message
    77 label *label5
    78 jump *label4 equal :findLinkedBlocks:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    48 set :findLinkedBlocks:variable .display
    49 label *label132
    50 print "\n"
-    * print :findLinkedBlocks:name
+   51 print "Display"
    52 print ":"
    53 print " "
-    * print :findLinkedBlocks:variable
+   54 print .display
    55 jump *label133 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   56 op and :findLinkedBlocks:foundAll 1 .display
    57 label *label133
    58 label *label134
    59 label *label135
-    * set .display :findLinkedBlocks:variable
+   60 set .display .display
    61 set :findLinkedBlocks:name "Memory"
    62 set :findLinkedBlocks:variable .memory
    63 label *label138
    64 print "\n"
-    * print :findLinkedBlocks:name
+   65 print "Memory"
    66 print ":"
    67 print " "
-    * print :findLinkedBlocks:variable
+   68 print .memory
    69 jump *label139 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   70 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    71 label *label139
    72 label *label140
    73 label *label141
-    * set .memory :findLinkedBlocks:variable
+   74 set .memory .memory
    75 label *label26
    76 printflush :findLinkedBlocks:message
    77 label *label5

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    43 label *label13
    44 jump *label105 greaterThan :findLinkedBlocks:n 0
    45 label *label14
-    * set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
    46 label *label132
    47 print "\n"
    48 print "Display"
 
    55 label *label134
    56 label *label135
    57 set .display .display
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
    58 label *label138
    59 print "\n"
    60 print "Memory"

Modifications by Unroll loop at mandelbrot-compute.mnd:139:5 (+743 instructions):
 
   153 label *label52
   154 label *label53
   155 label *label49
-    * set :compute:i 0
-    * label *label54
-    * label *label108
-    * set :compute:x1 :compute:zx
-    * op mul *tmp59 :compute:zx :compute:zx
-    * op mul *tmp60 :compute:zy :compute:zy
-    * op sub *tmp61 *tmp59 *tmp60
-    * op add :compute:zx *tmp61 :compute:cx
-    * op mul *tmp63 2 :compute:x1
-    * op mul *tmp64 *tmp63 :compute:zy
-    * op add :compute:zy *tmp64 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label57 lessThan :compute:dist 64
-    * jump *label56 always
-    * label *label57
-    * label *label58
-    * label *label55
-    * op add :compute:i :compute:i 1
-    * jump *label108 lessThan :compute:i 63
-    * label *label56
+  156 set :compute:i 0
+  157 label *label145
+  158 label *label146
+  159 set :compute:x1 :compute:zx
+  160 op mul *tmp59 :compute:zx :compute:zx
+  161 op mul *tmp60 :compute:zy :compute:zy
+  162 op sub *tmp61 *tmp59 *tmp60
+  163 op add :compute:zx *tmp61 :compute:cx
+  164 op mul *tmp63 2 :compute:x1
+  165 op mul *tmp64 *tmp63 :compute:zy
+  166 op add :compute:zy *tmp64 :compute:cy
+  167 op len :compute:dist :compute:zx :compute:zy
+  168 jump *label147 lessThan :compute:dist 64
+  169 jump *label56 always
+  170 label *label147
+  171 label *label148
+  172 label *label149
+  173 op add :compute:i :compute:i 1
+  174 set :compute:x1 :compute:zx
+  175 op mul *tmp59 :compute:zx :compute:zx
+  176 op mul *tmp60 :compute:zy :compute:zy
+  177 op sub *tmp61 *tmp59 *tmp60
+  178 op add :compute:zx *tmp61 :compute:cx
+  179 op mul *tmp63 2 :compute:x1
+  180 op mul *tmp64 *tmp63 :compute:zy
+  181 op add :compute:zy *tmp64 :compute:cy
+  182 op len :compute:dist :compute:zx :compute:zy
+  183 jump *label150 lessThan :compute:dist 64
+  184 jump *label56 always
+  185 label *label150
+  186 label *label151
+  187 label *label152
+  188 op add :compute:i :compute:i 1
+  189 set :compute:x1 :compute:zx
+  190 op mul *tmp59 :compute:zx :compute:zx
+  191 op mul *tmp60 :compute:zy :compute:zy
+  192 op sub *tmp61 *tmp59 *tmp60
+  193 op add :compute:zx *tmp61 :compute:cx
+  194 op mul *tmp63 2 :compute:x1
+  195 op mul *tmp64 *tmp63 :compute:zy
+  196 op add :compute:zy *tmp64 :compute:cy
+  197 op len :compute:dist :compute:zx :compute:zy
+  198 jump *label153 lessThan :compute:dist 64
+  199 jump *label56 always
+  200 label *label153
+  201 label *label154
+  202 label *label155
+  203 op add :compute:i :compute:i 1
+  204 set :compute:x1 :compute:zx
+  205 op mul *tmp59 :compute:zx :compute:zx
+  206 op mul *tmp60 :compute:zy :compute:zy
+  207 op sub *tmp61 *tmp59 *tmp60
+  208 op add :compute:zx *tmp61 :compute:cx
+  209 op mul *tmp63 2 :compute:x1
+  210 op mul *tmp64 *tmp63 :compute:zy
+  211 op add :compute:zy *tmp64 :compute:cy
+  212 op len :compute:dist :compute:zx :compute:zy
+  213 jump *label156 lessThan :compute:dist 64
+  214 jump *label56 always
+  215 label *label156
+  216 label *label157
+  217 label *label158
+  218 op add :compute:i :compute:i 1
+  219 set :compute:x1 :compute:zx
+  220 op mul *tmp59 :compute:zx :compute:zx
+  221 op mul *tmp60 :compute:zy :compute:zy
+  222 op sub *tmp61 *tmp59 *tmp60
+  223 op add :compute:zx *tmp61 :compute:cx
+  224 op mul *tmp63 2 :compute:x1
+  225 op mul *tmp64 *tmp63 :compute:zy
+  226 op add :compute:zy *tmp64 :compute:cy
+  227 op len :compute:dist :compute:zx :compute:zy
+  228 jump *label159 lessThan :compute:dist 64
+  229 jump *label56 always
+  230 label *label159
+  231 label *label160
+  232 label *label161
+  233 op add :compute:i :compute:i 1
+  234 set :compute:x1 :compute:zx
+  235 op mul *tmp59 :compute:zx :compute:zx
+  236 op mul *tmp60 :compute:zy :compute:zy
+  237 op sub *tmp61 *tmp59 *tmp60
+  238 op add :compute:zx *tmp61 :compute:cx
+  239 op mul *tmp63 2 :compute:x1
+  240 op mul *tmp64 *tmp63 :compute:zy
+  241 op add :compute:zy *tmp64 :compute:cy
+  242 op len :compute:dist :compute:zx :compute:zy
+  243 jump *label162 lessThan :compute:dist 64
+  244 jump *label56 always
+  245 label *label162
+  246 label *label163
+  247 label *label164
+  248 op add :compute:i :compute:i 1
+  249 set :compute:x1 :compute:zx
+  250 op mul *tmp59 :compute:zx :compute:zx
+  251 op mul *tmp60 :compute:zy :compute:zy
+  252 op sub *tmp61 *tmp59 *tmp60
+  253 op add :compute:zx *tmp61 :compute:cx
+  254 op mul *tmp63 2 :compute:x1
+  255 op mul *tmp64 *tmp63 :compute:zy
+  256 op add :compute:zy *tmp64 :compute:cy
+  257 op len :compute:dist :compute:zx :compute:zy
+  258 jump *label165 lessThan :compute:dist 64
+  259 jump *label56 always
+  260 label *label165
+  261 label *label166
+  262 label *label167
+  263 op add :compute:i :compute:i 1
+  264 set :compute:x1 :compute:zx
+  265 op mul *tmp59 :compute:zx :compute:zx
+  266 op mul *tmp60 :compute:zy :compute:zy
+  267 op sub *tmp61 *tmp59 *tmp60
+  268 op add :compute:zx *tmp61 :compute:cx
+  269 op mul *tmp63 2 :compute:x1
+  270 op mul *tmp64 *tmp63 :compute:zy
+  271 op add :compute:zy *tmp64 :compute:cy
+  272 op len :compute:dist :compute:zx :compute:zy
+  273 jump *label168 lessThan :compute:dist 64
+  274 jump *label56 always
+  275 label *label168
+  276 label *label169
+  277 label *label170
+  278 op add :compute:i :compute:i 1
+  279 set :compute:x1 :compute:zx
+  280 op mul *tmp59 :compute:zx :compute:zx
+  281 op mul *tmp60 :compute:zy :compute:zy
+  282 op sub *tmp61 *tmp59 *tmp60
+  283 op add :compute:zx *tmp61 :compute:cx
+  284 op mul *tmp63 2 :compute:x1
+  285 op mul *tmp64 *tmp63 :compute:zy
+  286 op add :compute:zy *tmp64 :compute:cy
+  287 op len :compute:dist :compute:zx :compute:zy
+  288 jump *label171 lessThan :compute:dist 64
+  289 jump *label56 always
+  290 label *label171
+  291 label *label172
+  292 label *label173
+  293 op add :compute:i :compute:i 1
+  294 set :compute:x1 :compute:zx
+  295 op mul *tmp59 :compute:zx :compute:zx
+  296 op mul *tmp60 :compute:zy :compute:zy
+  297 op sub *tmp61 *tmp59 *tmp60
+  298 op add :compute:zx *tmp61 :compute:cx
+  299 op mul *tmp63 2 :compute:x1
+  300 op mul *tmp64 *tmp63 :compute:zy
+  301 op add :compute:zy *tmp64 :compute:cy
+  302 op len :compute:dist :compute:zx :compute:zy
+  303 jump *label174 lessThan :compute:dist 64
+  304 jump *label56 always
+  305 label *label174
+  306 label *label175
+  307 label *label176
+  308 op add :compute:i :compute:i 1
+  309 set :compute:x1 :compute:zx
+  310 op mul *tmp59 :compute:zx :compute:zx
+  311 op mul *tmp60 :compute:zy :compute:zy
+  312 op sub *tmp61 *tmp59 *tmp60
+  313 op add :compute:zx *tmp61 :compute:cx
+  314 op mul *tmp63 2 :compute:x1
+  315 op mul *tmp64 *tmp63 :compute:zy
+  316 op add :compute:zy *tmp64 :compute:cy
+  317 op len :compute:dist :compute:zx :compute:zy
+  318 jump *label177 lessThan :compute:dist 64
+  319 jump *label56 always
+  320 label *label177
+  321 label *label178
+  322 label *label179
+  323 op add :compute:i :compute:i 1
+  324 set :compute:x1 :compute:zx
+  325 op mul *tmp59 :compute:zx :compute:zx
+  326 op mul *tmp60 :compute:zy :compute:zy
+  327 op sub *tmp61 *tmp59 *tmp60
+  328 op add :compute:zx *tmp61 :compute:cx
+  329 op mul *tmp63 2 :compute:x1
+  330 op mul *tmp64 *tmp63 :compute:zy
+  331 op add :compute:zy *tmp64 :compute:cy
+  332 op len :compute:dist :compute:zx :compute:zy
+  333 jump *label180 lessThan :compute:dist 64
+  334 jump *label56 always
+  335 label *label180
+  336 label *label181
+  337 label *label182
+  338 op add :compute:i :compute:i 1
+  339 set :compute:x1 :compute:zx
+  340 op mul *tmp59 :compute:zx :compute:zx
+  341 op mul *tmp60 :compute:zy :compute:zy
+  342 op sub *tmp61 *tmp59 *tmp60
+  343 op add :compute:zx *tmp61 :compute:cx
+  344 op mul *tmp63 2 :compute:x1
+  345 op mul *tmp64 *tmp63 :compute:zy
+  346 op add :compute:zy *tmp64 :compute:cy
+  347 op len :compute:dist :compute:zx :compute:zy
+  348 jump *label183 lessThan :compute:dist 64
+  349 jump *label56 always
+  350 label *label183
+  351 label *label184
+  352 label *label185
+  353 op add :compute:i :compute:i 1
+  354 set :compute:x1 :compute:zx
+  355 op mul *tmp59 :compute:zx :compute:zx
+  356 op mul *tmp60 :compute:zy :compute:zy
+  357 op sub *tmp61 *tmp59 *tmp60
+  358 op add :compute:zx *tmp61 :compute:cx
+  359 op mul *tmp63 2 :compute:x1
+  360 op mul *tmp64 *tmp63 :compute:zy
+  361 op add :compute:zy *tmp64 :compute:cy
+  362 op len :compute:dist :compute:zx :compute:zy
+  363 jump *label186 lessThan :compute:dist 64
+  364 jump *label56 always
+  365 label *label186
+  366 label *label187
+  367 label *label188
+  368 op add :compute:i :compute:i 1
+  369 set :compute:x1 :compute:zx
+  370 op mul *tmp59 :compute:zx :compute:zx
+  371 op mul *tmp60 :compute:zy :compute:zy
+  372 op sub *tmp61 *tmp59 *tmp60
+  373 op add :compute:zx *tmp61 :compute:cx
+  374 op mul *tmp63 2 :compute:x1
+  375 op mul *tmp64 *tmp63 :compute:zy
+  376 op add :compute:zy *tmp64 :compute:cy
+  377 op len :compute:dist :compute:zx :compute:zy
+  378 jump *label189 lessThan :compute:dist 64
+  379 jump *label56 always
+  380 label *label189
+  381 label *label190
+  382 label *label191
+  383 op add :compute:i :compute:i 1
+  384 set :compute:x1 :compute:zx
+  385 op mul *tmp59 :compute:zx :compute:zx
+  386 op mul *tmp60 :compute:zy :compute:zy
+  387 op sub *tmp61 *tmp59 *tmp60
+  388 op add :compute:zx *tmp61 :compute:cx
+  389 op mul *tmp63 2 :compute:x1
+  390 op mul *tmp64 *tmp63 :compute:zy
+  391 op add :compute:zy *tmp64 :compute:cy
+  392 op len :compute:dist :compute:zx :compute:zy
+  393 jump *label192 lessThan :compute:dist 64
+  394 jump *label56 always
+  395 label *label192
+  396 label *label193
+  397 label *label194
+  398 op add :compute:i :compute:i 1
+  399 set :compute:x1 :compute:zx
+  400 op mul *tmp59 :compute:zx :compute:zx
+  401 op mul *tmp60 :compute:zy :compute:zy
+  402 op sub *tmp61 *tmp59 *tmp60
+  403 op add :compute:zx *tmp61 :compute:cx
+  404 op mul *tmp63 2 :compute:x1
+  405 op mul *tmp64 *tmp63 :compute:zy
+  406 op add :compute:zy *tmp64 :compute:cy
+  407 op len :compute:dist :compute:zx :compute:zy
+  408 jump *label195 lessThan :compute:dist 64
+  409 jump *label56 always
+  410 label *label195
+  411 label *label196
+  412 label *label197
+  413 op add :compute:i :compute:i 1
+  414 set :compute:x1 :compute:zx
+  415 op mul *tmp59 :compute:zx :compute:zx
+  416 op mul *tmp60 :compute:zy :compute:zy
+  417 op sub *tmp61 *tmp59 *tmp60
+  418 op add :compute:zx *tmp61 :compute:cx
+  419 op mul *tmp63 2 :compute:x1
+  420 op mul *tmp64 *tmp63 :compute:zy
+  421 op add :compute:zy *tmp64 :compute:cy
+  422 op len :compute:dist :compute:zx :compute:zy
+  423 jump *label198 lessThan :compute:dist 64
+  424 jump *label56 always
+  425 label *label198
+  426 label *label199
+  427 label *label200
+  428 op add :compute:i :compute:i 1
+  429 set :compute:x1 :compute:zx
+  430 op mul *tmp59 :compute:zx :compute:zx
+  431 op mul *tmp60 :compute:zy :compute:zy
+  432 op sub *tmp61 *tmp59 *tmp60
+  433 op add :compute:zx *tmp61 :compute:cx
+  434 op mul *tmp63 2 :compute:x1
+  435 op mul *tmp64 *tmp63 :compute:zy
+  436 op add :compute:zy *tmp64 :compute:cy
+  437 op len :compute:dist :compute:zx :compute:zy
+  438 jump *label201 lessThan :compute:dist 64
+  439 jump *label56 always
+  440 label *label201
+  441 label *label202
+  442 label *label203
+  443 op add :compute:i :compute:i 1
+  444 set :compute:x1 :compute:zx
+  445 op mul *tmp59 :compute:zx :compute:zx
+  446 op mul *tmp60 :compute:zy :compute:zy
+  447 op sub *tmp61 *tmp59 *tmp60
+  448 op add :compute:zx *tmp61 :compute:cx
+  449 op mul *tmp63 2 :compute:x1
+  450 op mul *tmp64 *tmp63 :compute:zy
+  451 op add :compute:zy *tmp64 :compute:cy
+  452 op len :compute:dist :compute:zx :compute:zy
+  453 jump *label204 lessThan :compute:dist 64
+  454 jump *label56 always
+  455 label *label204
+  456 label *label205
+  457 label *label206
+  458 op add :compute:i :compute:i 1
+  459 set :compute:x1 :compute:zx
+  460 op mul *tmp59 :compute:zx :compute:zx
+  461 op mul *tmp60 :compute:zy :compute:zy
+  462 op sub *tmp61 *tmp59 *tmp60
+  463 op add :compute:zx *tmp61 :compute:cx
+  464 op mul *tmp63 2 :compute:x1
+  465 op mul *tmp64 *tmp63 :compute:zy
+  466 op add :compute:zy *tmp64 :compute:cy
+  467 op len :compute:dist :compute:zx :compute:zy
+  468 jump *label207 lessThan :compute:dist 64
+  469 jump *label56 always
+  470 label *label207
+  471 label *label208
+  472 label *label209
+  473 op add :compute:i :compute:i 1
+  474 set :compute:x1 :compute:zx
+  475 op mul *tmp59 :compute:zx :compute:zx
+  476 op mul *tmp60 :compute:zy :compute:zy
+  477 op sub *tmp61 *tmp59 *tmp60
+  478 op add :compute:zx *tmp61 :compute:cx
+  479 op mul *tmp63 2 :compute:x1
+  480 op mul *tmp64 *tmp63 :compute:zy
+  481 op add :compute:zy *tmp64 :compute:cy
+  482 op len :compute:dist :compute:zx :compute:zy
+  483 jump *label210 lessThan :compute:dist 64
+  484 jump *label56 always
+  485 label *label210
+  486 label *label211
+  487 label *label212
+  488 op add :compute:i :compute:i 1
+  489 set :compute:x1 :compute:zx
+  490 op mul *tmp59 :compute:zx :compute:zx
+  491 op mul *tmp60 :compute:zy :compute:zy
+  492 op sub *tmp61 *tmp59 *tmp60
+  493 op add :compute:zx *tmp61 :compute:cx
+  494 op mul *tmp63 2 :compute:x1
+  495 op mul *tmp64 *tmp63 :compute:zy
+  496 op add :compute:zy *tmp64 :compute:cy
+  497 op len :compute:dist :compute:zx :compute:zy
+  498 jump *label213 lessThan :compute:dist 64
+  499 jump *label56 always
+  500 label *label213
+  501 label *label214
+  502 label *label215
+  503 op add :compute:i :compute:i 1
+  504 set :compute:x1 :compute:zx
+  505 op mul *tmp59 :compute:zx :compute:zx
+  506 op mul *tmp60 :compute:zy :compute:zy
+  507 op sub *tmp61 *tmp59 *tmp60
+  508 op add :compute:zx *tmp61 :compute:cx
+  509 op mul *tmp63 2 :compute:x1
+  510 op mul *tmp64 *tmp63 :compute:zy
+  511 op add :compute:zy *tmp64 :compute:cy
+  512 op len :compute:dist :compute:zx :compute:zy
+  513 jump *label216 lessThan :compute:dist 64
+  514 jump *label56 always
+  515 label *label216
+  516 label *label217
+  517 label *label218
+  518 op add :compute:i :compute:i 1
+  519 set :compute:x1 :compute:zx
+  520 op mul *tmp59 :compute:zx :compute:zx
+  521 op mul *tmp60 :compute:zy :compute:zy
+  522 op sub *tmp61 *tmp59 *tmp60
+  523 op add :compute:zx *tmp61 :compute:cx
+  524 op mul *tmp63 2 :compute:x1
+  525 op mul *tmp64 *tmp63 :compute:zy
+  526 op add :compute:zy *tmp64 :compute:cy
+  527 op len :compute:dist :compute:zx :compute:zy
+  528 jump *label219 lessThan :compute:dist 64
+  529 jump *label56 always
+  530 label *label219
+  531 label *label220
+  532 label *label221
+  533 op add :compute:i :compute:i 1
+  534 set :compute:x1 :compute:zx
+  535 op mul *tmp59 :compute:zx :compute:zx
+  536 op mul *tmp60 :compute:zy :compute:zy
+  537 op sub *tmp61 *tmp59 *tmp60
+  538 op add :compute:zx *tmp61 :compute:cx
+  539 op mul *tmp63 2 :compute:x1
+  540 op mul *tmp64 *tmp63 :compute:zy
+  541 op add :compute:zy *tmp64 :compute:cy
+  542 op len :compute:dist :compute:zx :compute:zy
+  543 jump *label222 lessThan :compute:dist 64
+  544 jump *label56 always
+  545 label *label222
+  546 label *label223
+  547 label *label224
+  548 op add :compute:i :compute:i 1
+  549 set :compute:x1 :compute:zx
+  550 op mul *tmp59 :compute:zx :compute:zx
+  551 op mul *tmp60 :compute:zy :compute:zy
+  552 op sub *tmp61 *tmp59 *tmp60
+  553 op add :compute:zx *tmp61 :compute:cx
+  554 op mul *tmp63 2 :compute:x1
+  555 op mul *tmp64 *tmp63 :compute:zy
+  556 op add :compute:zy *tmp64 :compute:cy
+  557 op len :compute:dist :compute:zx :compute:zy
+  558 jump *label225 lessThan :compute:dist 64
+  559 jump *label56 always
+  560 label *label225
+  561 label *label226
+  562 label *label227
+  563 op add :compute:i :compute:i 1
+  564 set :compute:x1 :compute:zx
+  565 op mul *tmp59 :compute:zx :compute:zx
+  566 op mul *tmp60 :compute:zy :compute:zy
+  567 op sub *tmp61 *tmp59 *tmp60
+  568 op add :compute:zx *tmp61 :compute:cx
+  569 op mul *tmp63 2 :compute:x1
+  570 op mul *tmp64 *tmp63 :compute:zy
+  571 op add :compute:zy *tmp64 :compute:cy
+  572 op len :compute:dist :compute:zx :compute:zy
+  573 jump *label228 lessThan :compute:dist 64
+  574 jump *label56 always
+  575 label *label228
+  576 label *label229
+  577 label *label230
+  578 op add :compute:i :compute:i 1
+  579 set :compute:x1 :compute:zx
+  580 op mul *tmp59 :compute:zx :compute:zx
+  581 op mul *tmp60 :compute:zy :compute:zy
+  582 op sub *tmp61 *tmp59 *tmp60
+  583 op add :compute:zx *tmp61 :compute:cx
+  584 op mul *tmp63 2 :compute:x1
+  585 op mul *tmp64 *tmp63 :compute:zy
+  586 op add :compute:zy *tmp64 :compute:cy
+  587 op len :compute:dist :compute:zx :compute:zy
+  588 jump *label231 lessThan :compute:dist 64
+  589 jump *label56 always
+  590 label *label231
+  591 label *label232
+  592 label *label233
+  593 op add :compute:i :compute:i 1
+  594 set :compute:x1 :compute:zx
+  595 op mul *tmp59 :compute:zx :compute:zx
+  596 op mul *tmp60 :compute:zy :compute:zy
+  597 op sub *tmp61 *tmp59 *tmp60
+  598 op add :compute:zx *tmp61 :compute:cx
+  599 op mul *tmp63 2 :compute:x1
+  600 op mul *tmp64 *tmp63 :compute:zy
+  601 op add :compute:zy *tmp64 :compute:cy
+  602 op len :compute:dist :compute:zx :compute:zy
+  603 jump *label234 lessThan :compute:dist 64
+  604 jump *label56 always
+  605 label *label234
+  606 label *label235
+  607 label *label236
+  608 op add :compute:i :compute:i 1
+  609 set :compute:x1 :compute:zx
+  610 op mul *tmp59 :compute:zx :compute:zx
+  611 op mul *tmp60 :compute:zy :compute:zy
+  612 op sub *tmp61 *tmp59 *tmp60
+  613 op add :compute:zx *tmp61 :compute:cx
+  614 op mul *tmp63 2 :compute:x1
+  615 op mul *tmp64 *tmp63 :compute:zy
+  616 op add :compute:zy *tmp64 :compute:cy
+  617 op len :compute:dist :compute:zx :compute:zy
+  618 jump *label237 lessThan :compute:dist 64
+  619 jump *label56 always
+  620 label *label237
+  621 label *label238
+  622 label *label239
+  623 op add :compute:i :compute:i 1
+  624 set :compute:x1 :compute:zx
+  625 op mul *tmp59 :compute:zx :compute:zx
+  626 op mul *tmp60 :compute:zy :compute:zy
+  627 op sub *tmp61 *tmp59 *tmp60
+  628 op add :compute:zx *tmp61 :compute:cx
+  629 op mul *tmp63 2 :compute:x1
+  630 op mul *tmp64 *tmp63 :compute:zy
+  631 op add :compute:zy *tmp64 :compute:cy
+  632 op len :compute:dist :compute:zx :compute:zy
+  633 jump *label240 lessThan :compute:dist 64
+  634 jump *label56 always
+  635 label *label240
+  636 label *label241
+  637 label *label242
+  638 op add :compute:i :compute:i 1
+  639 set :compute:x1 :compute:zx
+  640 op mul *tmp59 :compute:zx :compute:zx
+  641 op mul *tmp60 :compute:zy :compute:zy
+  642 op sub *tmp61 *tmp59 *tmp60
+  643 op add :compute:zx *tmp61 :compute:cx
+  644 op mul *tmp63 2 :compute:x1
+  645 op mul *tmp64 *tmp63 :compute:zy
+  646 op add :compute:zy *tmp64 :compute:cy
+  647 op len :compute:dist :compute:zx :compute:zy
+  648 jump *label243 lessThan :compute:dist 64
+  649 jump *label56 always
+  650 label *label243
+  651 label *label244
+  652 label *label245
+  653 op add :compute:i :compute:i 1
+  654 set :compute:x1 :compute:zx
+  655 op mul *tmp59 :compute:zx :compute:zx
+  656 op mul *tmp60 :compute:zy :compute:zy
+  657 op sub *tmp61 *tmp59 *tmp60
+  658 op add :compute:zx *tmp61 :compute:cx
+  659 op mul *tmp63 2 :compute:x1
+  660 op mul *tmp64 *tmp63 :compute:zy
+  661 op add :compute:zy *tmp64 :compute:cy
+  662 op len :compute:dist :compute:zx :compute:zy
+  663 jump *label246 lessThan :compute:dist 64
+  664 jump *label56 always
+  665 label *label246
+  666 label *label247
+  667 label *label248
+  668 op add :compute:i :compute:i 1
+  669 set :compute:x1 :compute:zx
+  670 op mul *tmp59 :compute:zx :compute:zx
+  671 op mul *tmp60 :compute:zy :compute:zy
+  672 op sub *tmp61 *tmp59 *tmp60
+  673 op add :compute:zx *tmp61 :compute:cx
+  674 op mul *tmp63 2 :compute:x1
+  675 op mul *tmp64 *tmp63 :compute:zy
+  676 op add :compute:zy *tmp64 :compute:cy
+  677 op len :compute:dist :compute:zx :compute:zy
+  678 jump *label249 lessThan :compute:dist 64
+  679 jump *label56 always
+  680 label *label249
+  681 label *label250
+  682 label *label251
+  683 op add :compute:i :compute:i 1
+  684 set :compute:x1 :compute:zx
+  685 op mul *tmp59 :compute:zx :compute:zx
+  686 op mul *tmp60 :compute:zy :compute:zy
+  687 op sub *tmp61 *tmp59 *tmp60
+  688 op add :compute:zx *tmp61 :compute:cx
+  689 op mul *tmp63 2 :compute:x1
+  690 op mul *tmp64 *tmp63 :compute:zy
+  691 op add :compute:zy *tmp64 :compute:cy
+  692 op len :compute:dist :compute:zx :compute:zy
+  693 jump *label252 lessThan :compute:dist 64
+  694 jump *label56 always
+  695 label *label252
+  696 label *label253
+  697 label *label254
+  698 op add :compute:i :compute:i 1
+  699 set :compute:x1 :compute:zx
+  700 op mul *tmp59 :compute:zx :compute:zx
+  701 op mul *tmp60 :compute:zy :compute:zy
+  702 op sub *tmp61 *tmp59 *tmp60
+  703 op add :compute:zx *tmp61 :compute:cx
+  704 op mul *tmp63 2 :compute:x1
+  705 op mul *tmp64 *tmp63 :compute:zy
+  706 op add :compute:zy *tmp64 :compute:cy
+  707 op len :compute:dist :compute:zx :compute:zy
+  708 jump *label255 lessThan :compute:dist 64
+  709 jump *label56 always
+  710 label *label255
+  711 label *label256
+  712 label *label257
+  713 op add :compute:i :compute:i 1
+  714 set :compute:x1 :compute:zx
+  715 op mul *tmp59 :compute:zx :compute:zx
+  716 op mul *tmp60 :compute:zy :compute:zy
+  717 op sub *tmp61 *tmp59 *tmp60
+  718 op add :compute:zx *tmp61 :compute:cx
+  719 op mul *tmp63 2 :compute:x1
+  720 op mul *tmp64 *tmp63 :compute:zy
+  721 op add :compute:zy *tmp64 :compute:cy
+  722 op len :compute:dist :compute:zx :compute:zy
+  723 jump *label258 lessThan :compute:dist 64
+  724 jump *label56 always
+  725 label *label258
+  726 label *label259
+  727 label *label260
+  728 op add :compute:i :compute:i 1
+  729 set :compute:x1 :compute:zx
+  730 op mul *tmp59 :compute:zx :compute:zx
+  731 op mul *tmp60 :compute:zy :compute:zy
+  732 op sub *tmp61 *tmp59 *tmp60
+  733 op add :compute:zx *tmp61 :compute:cx
+  734 op mul *tmp63 2 :compute:x1
+  735 op mul *tmp64 *tmp63 :compute:zy
+  736 op add :compute:zy *tmp64 :compute:cy
+  737 op len :compute:dist :compute:zx :compute:zy
+  738 jump *label261 lessThan :compute:dist 64
+  739 jump *label56 always
+  740 label *label261
+  741 label *label262
+  742 label *label263
+  743 op add :compute:i :compute:i 1
+  744 set :compute:x1 :compute:zx
+  745 op mul *tmp59 :compute:zx :compute:zx
+  746 op mul *tmp60 :compute:zy :compute:zy
+  747 op sub *tmp61 *tmp59 *tmp60
+  748 op add :compute:zx *tmp61 :compute:cx
+  749 op mul *tmp63 2 :compute:x1
+  750 op mul *tmp64 *tmp63 :compute:zy
+  751 op add :compute:zy *tmp64 :compute:cy
+  752 op len :compute:dist :compute:zx :compute:zy
+  753 jump *label264 lessThan :compute:dist 64
+  754 jump *label56 always
+  755 label *label264
+  756 label *label265
+  757 label *label266
+  758 op add :compute:i :compute:i 1
+  759 set :compute:x1 :compute:zx
+  760 op mul *tmp59 :compute:zx :compute:zx
+  761 op mul *tmp60 :compute:zy :compute:zy
+  762 op sub *tmp61 *tmp59 *tmp60
+  763 op add :compute:zx *tmp61 :compute:cx
+  764 op mul *tmp63 2 :compute:x1
+  765 op mul *tmp64 *tmp63 :compute:zy
+  766 op add :compute:zy *tmp64 :compute:cy
+  767 op len :compute:dist :compute:zx :compute:zy
+  768 jump *label267 lessThan :compute:dist 64
+  769 jump *label56 always
+  770 label *label267
+  771 label *label268
+  772 label *label269
+  773 op add :compute:i :compute:i 1
+  774 set :compute:x1 :compute:zx
+  775 op mul *tmp59 :compute:zx :compute:zx
+  776 op mul *tmp60 :compute:zy :compute:zy
+  777 op sub *tmp61 *tmp59 *tmp60
+  778 op add :compute:zx *tmp61 :compute:cx
+  779 op mul *tmp63 2 :compute:x1
+  780 op mul *tmp64 *tmp63 :compute:zy
+  781 op add :compute:zy *tmp64 :compute:cy
+  782 op len :compute:dist :compute:zx :compute:zy
+  783 jump *label270 lessThan :compute:dist 64
+  784 jump *label56 always
+  785 label *label270
+  786 label *label271
+  787 label *label272
+  788 op add :compute:i :compute:i 1
+  789 set :compute:x1 :compute:zx
+  790 op mul *tmp59 :compute:zx :compute:zx
+  791 op mul *tmp60 :compute:zy :compute:zy
+  792 op sub *tmp61 *tmp59 *tmp60
+  793 op add :compute:zx *tmp61 :compute:cx
+  794 op mul *tmp63 2 :compute:x1
+  795 op mul *tmp64 *tmp63 :compute:zy
+  796 op add :compute:zy *tmp64 :compute:cy
+  797 op len :compute:dist :compute:zx :compute:zy
+  798 jump *label273 lessThan :compute:dist 64
+  799 jump *label56 always
+  800 label *label273
+  801 label *label274
+  802 label *label275
+  803 op add :compute:i :compute:i 1
+  804 set :compute:x1 :compute:zx
+  805 op mul *tmp59 :compute:zx :compute:zx
+  806 op mul *tmp60 :compute:zy :compute:zy
+  807 op sub *tmp61 *tmp59 *tmp60
+  808 op add :compute:zx *tmp61 :compute:cx
+  809 op mul *tmp63 2 :compute:x1
+  810 op mul *tmp64 *tmp63 :compute:zy
+  811 op add :compute:zy *tmp64 :compute:cy
+  812 op len :compute:dist :compute:zx :compute:zy
+  813 jump *label276 lessThan :compute:dist 64
+  814 jump *label56 always
+  815 label *label276
+  816 label *label277
+  817 label *label278
+  818 op add :compute:i :compute:i 1
+  819 set :compute:x1 :compute:zx
+  820 op mul *tmp59 :compute:zx :compute:zx
+  821 op mul *tmp60 :compute:zy :compute:zy
+  822 op sub *tmp61 *tmp59 *tmp60
+  823 op add :compute:zx *tmp61 :compute:cx
+  824 op mul *tmp63 2 :compute:x1
+  825 op mul *tmp64 *tmp63 :compute:zy
+  826 op add :compute:zy *tmp64 :compute:cy
+  827 op len :compute:dist :compute:zx :compute:zy
+  828 jump *label279 lessThan :compute:dist 64
+  829 jump *label56 always
+  830 label *label279
+  831 label *label280
+  832 label *label281
+  833 op add :compute:i :compute:i 1
+  834 set :compute:x1 :compute:zx
+  835 op mul *tmp59 :compute:zx :compute:zx
+  836 op mul *tmp60 :compute:zy :compute:zy
+  837 op sub *tmp61 *tmp59 *tmp60
+  838 op add :compute:zx *tmp61 :compute:cx
+  839 op mul *tmp63 2 :compute:x1
+  840 op mul *tmp64 *tmp63 :compute:zy
+  841 op add :compute:zy *tmp64 :compute:cy
+  842 op len :compute:dist :compute:zx :compute:zy
+  843 jump *label282 lessThan :compute:dist 64
+  844 jump *label56 always
+  845 label *label282
+  846 label *label283
+  847 label *label284
+  848 op add :compute:i :compute:i 1
+  849 set :compute:x1 :compute:zx
+  850 op mul *tmp59 :compute:zx :compute:zx
+  851 op mul *tmp60 :compute:zy :compute:zy
+  852 op sub *tmp61 *tmp59 *tmp60
+  853 op add :compute:zx *tmp61 :compute:cx
+  854 op mul *tmp63 2 :compute:x1
+  855 op mul *tmp64 *tmp63 :compute:zy
+  856 op add :compute:zy *tmp64 :compute:cy
+  857 op len :compute:dist :compute:zx :compute:zy
+  858 jump *label285 lessThan :compute:dist 64
+  859 jump *label56 always
+  860 label *label285
+  861 label *label286
+  862 label *label287
+  863 op add :compute:i :compute:i 1
+  864 set :compute:x1 :compute:zx
+  865 op mul *tmp59 :compute:zx :compute:zx
+  866 op mul *tmp60 :compute:zy :compute:zy
+  867 op sub *tmp61 *tmp59 *tmp60
+  868 op add :compute:zx *tmp61 :compute:cx
+  869 op mul *tmp63 2 :compute:x1
+  870 op mul *tmp64 *tmp63 :compute:zy
+  871 op add :compute:zy *tmp64 :compute:cy
+  872 op len :compute:dist :compute:zx :compute:zy
+  873 jump *label288 lessThan :compute:dist 64
+  874 jump *label56 always
+  875 label *label288
+  876 label *label289
+  877 label *label290
+  878 op add :compute:i :compute:i 1
+  879 set :compute:x1 :compute:zx
+  880 op mul *tmp59 :compute:zx :compute:zx
+  881 op mul *tmp60 :compute:zy :compute:zy
+  882 op sub *tmp61 *tmp59 *tmp60
+  883 op add :compute:zx *tmp61 :compute:cx
+  884 op mul *tmp63 2 :compute:x1
+  885 op mul *tmp64 *tmp63 :compute:zy
+  886 op add :compute:zy *tmp64 :compute:cy
+  887 op len :compute:dist :compute:zx :compute:zy
+  888 jump *label291 lessThan :compute:dist 64
+  889 jump *label56 always
+  890 label *label291
+  891 label *label292
+  892 label *label293
+  893 op add :compute:i :compute:i 1
+  894 set :compute:x1 :compute:zx
+  895 op mul *tmp59 :compute:zx :compute:zx
+  896 op mul *tmp60 :compute:zy :compute:zy
+  897 op sub *tmp61 *tmp59 *tmp60
+  898 op add :compute:zx *tmp61 :compute:cx
+  899 op mul *tmp63 2 :compute:x1
+  900 op mul *tmp64 *tmp63 :compute:zy
+  901 op add :compute:zy *tmp64 :compute:cy
+  902 op len :compute:dist :compute:zx :compute:zy
+  903 jump *label294 lessThan :compute:dist 64
+  904 jump *label56 always
+  905 label *label294
+  906 label *label295
+  907 label *label296
+  908 op add :compute:i :compute:i 1
+  909 set :compute:x1 :compute:zx
+  910 op mul *tmp59 :compute:zx :compute:zx
+  911 op mul *tmp60 :compute:zy :compute:zy
+  912 op sub *tmp61 *tmp59 *tmp60
+  913 op add :compute:zx *tmp61 :compute:cx
+  914 op mul *tmp63 2 :compute:x1
+  915 op mul *tmp64 *tmp63 :compute:zy
+  916 op add :compute:zy *tmp64 :compute:cy
+  917 op len :compute:dist :compute:zx :compute:zy
+  918 jump *label297 lessThan :compute:dist 64
+  919 jump *label56 always
+  920 label *label297
+  921 label *label298
+  922 label *label299
+  923 op add :compute:i :compute:i 1
+  924 set :compute:x1 :compute:zx
+  925 op mul *tmp59 :compute:zx :compute:zx
+  926 op mul *tmp60 :compute:zy :compute:zy
+  927 op sub *tmp61 *tmp59 *tmp60
+  928 op add :compute:zx *tmp61 :compute:cx
+  929 op mul *tmp63 2 :compute:x1
+  930 op mul *tmp64 *tmp63 :compute:zy
+  931 op add :compute:zy *tmp64 :compute:cy
+  932 op len :compute:dist :compute:zx :compute:zy
+  933 jump *label300 lessThan :compute:dist 64
+  934 jump *label56 always
+  935 label *label300
+  936 label *label301
+  937 label *label302
+  938 op add :compute:i :compute:i 1
+  939 set :compute:x1 :compute:zx
+  940 op mul *tmp59 :compute:zx :compute:zx
+  941 op mul *tmp60 :compute:zy :compute:zy
+  942 op sub *tmp61 *tmp59 *tmp60
+  943 op add :compute:zx *tmp61 :compute:cx
+  944 op mul *tmp63 2 :compute:x1
+  945 op mul *tmp64 *tmp63 :compute:zy
+  946 op add :compute:zy *tmp64 :compute:cy
+  947 op len :compute:dist :compute:zx :compute:zy
+  948 jump *label303 lessThan :compute:dist 64
+  949 jump *label56 always
+  950 label *label303
+  951 label *label304
+  952 label *label305
+  953 op add :compute:i :compute:i 1
+  954 set :compute:x1 :compute:zx
+  955 op mul *tmp59 :compute:zx :compute:zx
+  956 op mul *tmp60 :compute:zy :compute:zy
+  957 op sub *tmp61 *tmp59 *tmp60
+  958 op add :compute:zx *tmp61 :compute:cx
+  959 op mul *tmp63 2 :compute:x1
+  960 op mul *tmp64 *tmp63 :compute:zy
+  961 op add :compute:zy *tmp64 :compute:cy
+  962 op len :compute:dist :compute:zx :compute:zy
+  963 jump *label306 lessThan :compute:dist 64
+  964 jump *label56 always
+  965 label *label306
+  966 label *label307
+  967 label *label308
+  968 op add :compute:i :compute:i 1
+  969 set :compute:x1 :compute:zx
+  970 op mul *tmp59 :compute:zx :compute:zx
+  971 op mul *tmp60 :compute:zy :compute:zy
+  972 op sub *tmp61 *tmp59 *tmp60
+  973 op add :compute:zx *tmp61 :compute:cx
+  974 op mul *tmp63 2 :compute:x1
+  975 op mul *tmp64 *tmp63 :compute:zy
+  976 op add :compute:zy *tmp64 :compute:cy
+  977 op len :compute:dist :compute:zx :compute:zy
+  978 jump *label309 lessThan :compute:dist 64
+  979 jump *label56 always
+  980 label *label309
+  981 label *label310
+  982 label *label311
+  983 op add :compute:i :compute:i 1
+  984 set :compute:x1 :compute:zx
+  985 op mul *tmp59 :compute:zx :compute:zx
+  986 op mul *tmp60 :compute:zy :compute:zy
+  987 op sub *tmp61 *tmp59 *tmp60
+  988 op add :compute:zx *tmp61 :compute:cx
+  989 op mul *tmp63 2 :compute:x1
+  990 op mul *tmp64 *tmp63 :compute:zy
+  991 op add :compute:zy *tmp64 :compute:cy
+  992 op len :compute:dist :compute:zx :compute:zy
+  993 jump *label312 lessThan :compute:dist 64
+  994 jump *label56 always
+  995 label *label312
+  996 label *label313
+  997 label *label314
+  998 op add :compute:i :compute:i 1
+  999 set :compute:x1 :compute:zx
+ 1000 op mul *tmp59 :compute:zx :compute:zx
+ 1001 op mul *tmp60 :compute:zy :compute:zy
+ 1002 op sub *tmp61 *tmp59 *tmp60
+ 1003 op add :compute:zx *tmp61 :compute:cx
+ 1004 op mul *tmp63 2 :compute:x1
+ 1005 op mul *tmp64 *tmp63 :compute:zy
+ 1006 op add :compute:zy *tmp64 :compute:cy
+ 1007 op len :compute:dist :compute:zx :compute:zy
+ 1008 jump *label315 lessThan :compute:dist 64
+ 1009 jump *label56 always
+ 1010 label *label315
+ 1011 label *label316
+ 1012 label *label317
+ 1013 op add :compute:i :compute:i 1
+ 1014 set :compute:x1 :compute:zx
+ 1015 op mul *tmp59 :compute:zx :compute:zx
+ 1016 op mul *tmp60 :compute:zy :compute:zy
+ 1017 op sub *tmp61 *tmp59 *tmp60
+ 1018 op add :compute:zx *tmp61 :compute:cx
+ 1019 op mul *tmp63 2 :compute:x1
+ 1020 op mul *tmp64 *tmp63 :compute:zy
+ 1021 op add :compute:zy *tmp64 :compute:cy
+ 1022 op len :compute:dist :compute:zx :compute:zy
+ 1023 jump *label318 lessThan :compute:dist 64
+ 1024 jump *label56 always
+ 1025 label *label318
+ 1026 label *label319
+ 1027 label *label320
+ 1028 op add :compute:i :compute:i 1
+ 1029 set :compute:x1 :compute:zx
+ 1030 op mul *tmp59 :compute:zx :compute:zx
+ 1031 op mul *tmp60 :compute:zy :compute:zy
+ 1032 op sub *tmp61 *tmp59 *tmp60
+ 1033 op add :compute:zx *tmp61 :compute:cx
+ 1034 op mul *tmp63 2 :compute:x1
+ 1035 op mul *tmp64 *tmp63 :compute:zy
+ 1036 op add :compute:zy *tmp64 :compute:cy
+ 1037 op len :compute:dist :compute:zx :compute:zy
+ 1038 jump *label321 lessThan :compute:dist 64
+ 1039 jump *label56 always
+ 1040 label *label321
+ 1041 label *label322
+ 1042 label *label323
+ 1043 op add :compute:i :compute:i 1
+ 1044 set :compute:x1 :compute:zx
+ 1045 op mul *tmp59 :compute:zx :compute:zx
+ 1046 op mul *tmp60 :compute:zy :compute:zy
+ 1047 op sub *tmp61 *tmp59 *tmp60
+ 1048 op add :compute:zx *tmp61 :compute:cx
+ 1049 op mul *tmp63 2 :compute:x1
+ 1050 op mul *tmp64 *tmp63 :compute:zy
+ 1051 op add :compute:zy *tmp64 :compute:cy
+ 1052 op len :compute:dist :compute:zx :compute:zy
+ 1053 jump *label324 lessThan :compute:dist 64
+ 1054 jump *label56 always
+ 1055 label *label324
+ 1056 label *label325
+ 1057 label *label326
+ 1058 op add :compute:i :compute:i 1
+ 1059 set :compute:x1 :compute:zx
+ 1060 op mul *tmp59 :compute:zx :compute:zx
+ 1061 op mul *tmp60 :compute:zy :compute:zy
+ 1062 op sub *tmp61 *tmp59 *tmp60
+ 1063 op add :compute:zx *tmp61 :compute:cx
+ 1064 op mul *tmp63 2 :compute:x1
+ 1065 op mul *tmp64 *tmp63 :compute:zy
+ 1066 op add :compute:zy *tmp64 :compute:cy
+ 1067 op len :compute:dist :compute:zx :compute:zy
+ 1068 jump *label327 lessThan :compute:dist 64
+ 1069 jump *label56 always
+ 1070 label *label327
+ 1071 label *label328
+ 1072 label *label329
+ 1073 op add :compute:i :compute:i 1
+ 1074 set :compute:x1 :compute:zx
+ 1075 op mul *tmp59 :compute:zx :compute:zx
+ 1076 op mul *tmp60 :compute:zy :compute:zy
+ 1077 op sub *tmp61 *tmp59 *tmp60
+ 1078 op add :compute:zx *tmp61 :compute:cx
+ 1079 op mul *tmp63 2 :compute:x1
+ 1080 op mul *tmp64 *tmp63 :compute:zy
+ 1081 op add :compute:zy *tmp64 :compute:cy
+ 1082 op len :compute:dist :compute:zx :compute:zy
+ 1083 jump *label330 lessThan :compute:dist 64
+ 1084 jump *label56 always
+ 1085 label *label330
+ 1086 label *label331
+ 1087 label *label332
+ 1088 op add :compute:i :compute:i 1
+ 1089 set :compute:x1 :compute:zx
+ 1090 op mul *tmp59 :compute:zx :compute:zx
+ 1091 op mul *tmp60 :compute:zy :compute:zy
+ 1092 op sub *tmp61 *tmp59 *tmp60
+ 1093 op add :compute:zx *tmp61 :compute:cx
+ 1094 op mul *tmp63 2 :compute:x1
+ 1095 op mul *tmp64 *tmp63 :compute:zy
+ 1096 op add :compute:zy *tmp64 :compute:cy
+ 1097 op len :compute:dist :compute:zx :compute:zy
+ 1098 jump *label333 lessThan :compute:dist 64
+ 1099 jump *label56 always
+ 1100 label *label333
+ 1101 label *label334
+ 1102 label *label335
+ 1103 op add :compute:i :compute:i 1
+ 1104 label *label56
  1105 op mul *tmp69 .SMOOTH 63
  1106 jump *label59 greaterThanEq :compute:i *tmp69
  1107 op log *tmp72 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   170 label *label147
   171 label *label148
   172 label *label149
-    * op add :compute:i :compute:i 1
+  173 op add :compute:i 0 1
   174 set :compute:x1 :compute:zx
   175 op mul *tmp59 :compute:zx :compute:zx
   176 op mul *tmp60 :compute:zy :compute:zy
 
   185 label *label150
   186 label *label151
   187 label *label152
-    * op add :compute:i :compute:i 1
+  188 op add :compute:i 1 1
   189 set :compute:x1 :compute:zx
   190 op mul *tmp59 :compute:zx :compute:zx
   191 op mul *tmp60 :compute:zy :compute:zy
 
   200 label *label153
   201 label *label154
   202 label *label155
-    * op add :compute:i :compute:i 1
+  203 op add :compute:i 2 1
   204 set :compute:x1 :compute:zx
   205 op mul *tmp59 :compute:zx :compute:zx
   206 op mul *tmp60 :compute:zy :compute:zy
 
   215 label *label156
   216 label *label157
   217 label *label158
-    * op add :compute:i :compute:i 1
+  218 op add :compute:i 3 1
   219 set :compute:x1 :compute:zx
   220 op mul *tmp59 :compute:zx :compute:zx
   221 op mul *tmp60 :compute:zy :compute:zy
 
   230 label *label159
   231 label *label160
   232 label *label161
-    * op add :compute:i :compute:i 1
+  233 op add :compute:i 4 1
   234 set :compute:x1 :compute:zx
   235 op mul *tmp59 :compute:zx :compute:zx
   236 op mul *tmp60 :compute:zy :compute:zy
 
   245 label *label162
   246 label *label163
   247 label *label164
-    * op add :compute:i :compute:i 1
+  248 op add :compute:i 5 1
   249 set :compute:x1 :compute:zx
   250 op mul *tmp59 :compute:zx :compute:zx
   251 op mul *tmp60 :compute:zy :compute:zy
 
   260 label *label165
   261 label *label166
   262 label *label167
-    * op add :compute:i :compute:i 1
+  263 op add :compute:i 6 1
   264 set :compute:x1 :compute:zx
   265 op mul *tmp59 :compute:zx :compute:zx
   266 op mul *tmp60 :compute:zy :compute:zy
 
   275 label *label168
   276 label *label169
   277 label *label170
-    * op add :compute:i :compute:i 1
+  278 op add :compute:i 7 1
   279 set :compute:x1 :compute:zx
   280 op mul *tmp59 :compute:zx :compute:zx
   281 op mul *tmp60 :compute:zy :compute:zy
 
   290 label *label171
   291 label *label172
   292 label *label173
-    * op add :compute:i :compute:i 1
+  293 op add :compute:i 8 1
   294 set :compute:x1 :compute:zx
   295 op mul *tmp59 :compute:zx :compute:zx
   296 op mul *tmp60 :compute:zy :compute:zy
 
   305 label *label174
   306 label *label175
   307 label *label176
-    * op add :compute:i :compute:i 1
+  308 op add :compute:i 9 1
   309 set :compute:x1 :compute:zx
   310 op mul *tmp59 :compute:zx :compute:zx
   311 op mul *tmp60 :compute:zy :compute:zy
 
   320 label *label177
   321 label *label178
   322 label *label179
-    * op add :compute:i :compute:i 1
+  323 op add :compute:i 10 1
   324 set :compute:x1 :compute:zx
   325 op mul *tmp59 :compute:zx :compute:zx
   326 op mul *tmp60 :compute:zy :compute:zy
 
   335 label *label180
   336 label *label181
   337 label *label182
-    * op add :compute:i :compute:i 1
+  338 op add :compute:i 11 1
   339 set :compute:x1 :compute:zx
   340 op mul *tmp59 :compute:zx :compute:zx
   341 op mul *tmp60 :compute:zy :compute:zy
 
   350 label *label183
   351 label *label184
   352 label *label185
-    * op add :compute:i :compute:i 1
+  353 op add :compute:i 12 1
   354 set :compute:x1 :compute:zx
   355 op mul *tmp59 :compute:zx :compute:zx
   356 op mul *tmp60 :compute:zy :compute:zy
 
   365 label *label186
   366 label *label187
   367 label *label188
-    * op add :compute:i :compute:i 1
+  368 op add :compute:i 13 1
   369 set :compute:x1 :compute:zx
   370 op mul *tmp59 :compute:zx :compute:zx
   371 op mul *tmp60 :compute:zy :compute:zy
 
   380 label *label189
   381 label *label190
   382 label *label191
-    * op add :compute:i :compute:i 1
+  383 op add :compute:i 14 1
   384 set :compute:x1 :compute:zx
   385 op mul *tmp59 :compute:zx :compute:zx
   386 op mul *tmp60 :compute:zy :compute:zy
 
   395 label *label192
   396 label *label193
   397 label *label194
-    * op add :compute:i :compute:i 1
+  398 op add :compute:i 15 1
   399 set :compute:x1 :compute:zx
   400 op mul *tmp59 :compute:zx :compute:zx
   401 op mul *tmp60 :compute:zy :compute:zy
 
   410 label *label195
   411 label *label196
   412 label *label197
-    * op add :compute:i :compute:i 1
+  413 op add :compute:i 16 1
   414 set :compute:x1 :compute:zx
   415 op mul *tmp59 :compute:zx :compute:zx
   416 op mul *tmp60 :compute:zy :compute:zy
 
   425 label *label198
   426 label *label199
   427 label *label200
-    * op add :compute:i :compute:i 1
+  428 op add :compute:i 17 1
   429 set :compute:x1 :compute:zx
   430 op mul *tmp59 :compute:zx :compute:zx
   431 op mul *tmp60 :compute:zy :compute:zy
 
   440 label *label201
   441 label *label202
   442 label *label203
-    * op add :compute:i :compute:i 1
+  443 op add :compute:i 18 1
   444 set :compute:x1 :compute:zx
   445 op mul *tmp59 :compute:zx :compute:zx
   446 op mul *tmp60 :compute:zy :compute:zy
 
   455 label *label204
   456 label *label205
   457 label *label206
-    * op add :compute:i :compute:i 1
+  458 op add :compute:i 19 1
   459 set :compute:x1 :compute:zx
   460 op mul *tmp59 :compute:zx :compute:zx
   461 op mul *tmp60 :compute:zy :compute:zy
 
   470 label *label207
   471 label *label208
   472 label *label209
-    * op add :compute:i :compute:i 1
+  473 op add :compute:i 20 1
   474 set :compute:x1 :compute:zx
   475 op mul *tmp59 :compute:zx :compute:zx
   476 op mul *tmp60 :compute:zy :compute:zy
 
   485 label *label210
   486 label *label211
   487 label *label212
-    * op add :compute:i :compute:i 1
+  488 op add :compute:i 21 1
   489 set :compute:x1 :compute:zx
   490 op mul *tmp59 :compute:zx :compute:zx
   491 op mul *tmp60 :compute:zy :compute:zy
 
   500 label *label213
   501 label *label214
   502 label *label215
-    * op add :compute:i :compute:i 1
+  503 op add :compute:i 22 1
   504 set :compute:x1 :compute:zx
   505 op mul *tmp59 :compute:zx :compute:zx
   506 op mul *tmp60 :compute:zy :compute:zy
 
   515 label *label216
   516 label *label217
   517 label *label218
-    * op add :compute:i :compute:i 1
+  518 op add :compute:i 23 1
   519 set :compute:x1 :compute:zx
   520 op mul *tmp59 :compute:zx :compute:zx
   521 op mul *tmp60 :compute:zy :compute:zy
 
   530 label *label219
   531 label *label220
   532 label *label221
-    * op add :compute:i :compute:i 1
+  533 op add :compute:i 24 1
   534 set :compute:x1 :compute:zx
   535 op mul *tmp59 :compute:zx :compute:zx
   536 op mul *tmp60 :compute:zy :compute:zy
 
   545 label *label222
   546 label *label223
   547 label *label224
-    * op add :compute:i :compute:i 1
+  548 op add :compute:i 25 1
   549 set :compute:x1 :compute:zx
   550 op mul *tmp59 :compute:zx :compute:zx
   551 op mul *tmp60 :compute:zy :compute:zy
 
   560 label *label225
   561 label *label226
   562 label *label227
-    * op add :compute:i :compute:i 1
+  563 op add :compute:i 26 1
   564 set :compute:x1 :compute:zx
   565 op mul *tmp59 :compute:zx :compute:zx
   566 op mul *tmp60 :compute:zy :compute:zy
 
   575 label *label228
   576 label *label229
   577 label *label230
-    * op add :compute:i :compute:i 1
+  578 op add :compute:i 27 1
   579 set :compute:x1 :compute:zx
   580 op mul *tmp59 :compute:zx :compute:zx
   581 op mul *tmp60 :compute:zy :compute:zy
 
   590 label *label231
   591 label *label232
   592 label *label233
-    * op add :compute:i :compute:i 1
+  593 op add :compute:i 28 1
   594 set :compute:x1 :compute:zx
   595 op mul *tmp59 :compute:zx :compute:zx
   596 op mul *tmp60 :compute:zy :compute:zy
 
   605 label *label234
   606 label *label235
   607 label *label236
-    * op add :compute:i :compute:i 1
+  608 op add :compute:i 29 1
   609 set :compute:x1 :compute:zx
   610 op mul *tmp59 :compute:zx :compute:zx
   611 op mul *tmp60 :compute:zy :compute:zy
 
   620 label *label237
   621 label *label238
   622 label *label239
-    * op add :compute:i :compute:i 1
+  623 op add :compute:i 30 1
   624 set :compute:x1 :compute:zx
   625 op mul *tmp59 :compute:zx :compute:zx
   626 op mul *tmp60 :compute:zy :compute:zy
 
   635 label *label240
   636 label *label241
   637 label *label242
-    * op add :compute:i :compute:i 1
+  638 op add :compute:i 31 1
   639 set :compute:x1 :compute:zx
   640 op mul *tmp59 :compute:zx :compute:zx
   641 op mul *tmp60 :compute:zy :compute:zy
 
   650 label *label243
   651 label *label244
   652 label *label245
-    * op add :compute:i :compute:i 1
+  653 op add :compute:i 32 1
   654 set :compute:x1 :compute:zx
   655 op mul *tmp59 :compute:zx :compute:zx
   656 op mul *tmp60 :compute:zy :compute:zy
 
   665 label *label246
   666 label *label247
   667 label *label248
-    * op add :compute:i :compute:i 1
+  668 op add :compute:i 33 1
   669 set :compute:x1 :compute:zx
   670 op mul *tmp59 :compute:zx :compute:zx
   671 op mul *tmp60 :compute:zy :compute:zy
 
   680 label *label249
   681 label *label250
   682 label *label251
-    * op add :compute:i :compute:i 1
+  683 op add :compute:i 34 1
   684 set :compute:x1 :compute:zx
   685 op mul *tmp59 :compute:zx :compute:zx
   686 op mul *tmp60 :compute:zy :compute:zy
 
   695 label *label252
   696 label *label253
   697 label *label254
-    * op add :compute:i :compute:i 1
+  698 op add :compute:i 35 1
   699 set :compute:x1 :compute:zx
   700 op mul *tmp59 :compute:zx :compute:zx
   701 op mul *tmp60 :compute:zy :compute:zy
 
   710 label *label255
   711 label *label256
   712 label *label257
-    * op add :compute:i :compute:i 1
+  713 op add :compute:i 36 1
   714 set :compute:x1 :compute:zx
   715 op mul *tmp59 :compute:zx :compute:zx
   716 op mul *tmp60 :compute:zy :compute:zy
 
   725 label *label258
   726 label *label259
   727 label *label260
-    * op add :compute:i :compute:i 1
+  728 op add :compute:i 37 1
   729 set :compute:x1 :compute:zx
   730 op mul *tmp59 :compute:zx :compute:zx
   731 op mul *tmp60 :compute:zy :compute:zy
 
   740 label *label261
   741 label *label262
   742 label *label263
-    * op add :compute:i :compute:i 1
+  743 op add :compute:i 38 1
   744 set :compute:x1 :compute:zx
   745 op mul *tmp59 :compute:zx :compute:zx
   746 op mul *tmp60 :compute:zy :compute:zy
 
   755 label *label264
   756 label *label265
   757 label *label266
-    * op add :compute:i :compute:i 1
+  758 op add :compute:i 39 1
   759 set :compute:x1 :compute:zx
   760 op mul *tmp59 :compute:zx :compute:zx
   761 op mul *tmp60 :compute:zy :compute:zy
 
   770 label *label267
   771 label *label268
   772 label *label269
-    * op add :compute:i :compute:i 1
+  773 op add :compute:i 40 1
   774 set :compute:x1 :compute:zx
   775 op mul *tmp59 :compute:zx :compute:zx
   776 op mul *tmp60 :compute:zy :compute:zy
 
   785 label *label270
   786 label *label271
   787 label *label272
-    * op add :compute:i :compute:i 1
+  788 op add :compute:i 41 1
   789 set :compute:x1 :compute:zx
   790 op mul *tmp59 :compute:zx :compute:zx
   791 op mul *tmp60 :compute:zy :compute:zy
 
   800 label *label273
   801 label *label274
   802 label *label275
-    * op add :compute:i :compute:i 1
+  803 op add :compute:i 42 1
   804 set :compute:x1 :compute:zx
   805 op mul *tmp59 :compute:zx :compute:zx
   806 op mul *tmp60 :compute:zy :compute:zy
 
   815 label *label276
   816 label *label277
   817 label *label278
-    * op add :compute:i :compute:i 1
+  818 op add :compute:i 43 1
   819 set :compute:x1 :compute:zx
   820 op mul *tmp59 :compute:zx :compute:zx
   821 op mul *tmp60 :compute:zy :compute:zy
 
   830 label *label279
   831 label *label280
   832 label *label281
-    * op add :compute:i :compute:i 1
+  833 op add :compute:i 44 1
   834 set :compute:x1 :compute:zx
   835 op mul *tmp59 :compute:zx :compute:zx
   836 op mul *tmp60 :compute:zy :compute:zy
 
   845 label *label282
   846 label *label283
   847 label *label284
-    * op add :compute:i :compute:i 1
+  848 op add :compute:i 45 1
   849 set :compute:x1 :compute:zx
   850 op mul *tmp59 :compute:zx :compute:zx
   851 op mul *tmp60 :compute:zy :compute:zy
 
   860 label *label285
   861 label *label286
   862 label *label287
-    * op add :compute:i :compute:i 1
+  863 op add :compute:i 46 1
   864 set :compute:x1 :compute:zx
   865 op mul *tmp59 :compute:zx :compute:zx
   866 op mul *tmp60 :compute:zy :compute:zy
 
   875 label *label288
   876 label *label289
   877 label *label290
-    * op add :compute:i :compute:i 1
+  878 op add :compute:i 47 1
   879 set :compute:x1 :compute:zx
   880 op mul *tmp59 :compute:zx :compute:zx
   881 op mul *tmp60 :compute:zy :compute:zy
 
   890 label *label291
   891 label *label292
   892 label *label293
-    * op add :compute:i :compute:i 1
+  893 op add :compute:i 48 1
   894 set :compute:x1 :compute:zx
   895 op mul *tmp59 :compute:zx :compute:zx
   896 op mul *tmp60 :compute:zy :compute:zy
 
   905 label *label294
   906 label *label295
   907 label *label296
-    * op add :compute:i :compute:i 1
+  908 op add :compute:i 49 1
   909 set :compute:x1 :compute:zx
   910 op mul *tmp59 :compute:zx :compute:zx
   911 op mul *tmp60 :compute:zy :compute:zy
 
   920 label *label297
   921 label *label298
   922 label *label299
-    * op add :compute:i :compute:i 1
+  923 op add :compute:i 50 1
   924 set :compute:x1 :compute:zx
   925 op mul *tmp59 :compute:zx :compute:zx
   926 op mul *tmp60 :compute:zy :compute:zy
 
   935 label *label300
   936 label *label301
   937 label *label302
-    * op add :compute:i :compute:i 1
+  938 op add :compute:i 51 1
   939 set :compute:x1 :compute:zx
   940 op mul *tmp59 :compute:zx :compute:zx
   941 op mul *tmp60 :compute:zy :compute:zy
 
   950 label *label303
   951 label *label304
   952 label *label305
-    * op add :compute:i :compute:i 1
+  953 op add :compute:i 52 1
   954 set :compute:x1 :compute:zx
   955 op mul *tmp59 :compute:zx :compute:zx
   956 op mul *tmp60 :compute:zy :compute:zy
 
   965 label *label306
   966 label *label307
   967 label *label308
-    * op add :compute:i :compute:i 1
+  968 op add :compute:i 53 1
   969 set :compute:x1 :compute:zx
   970 op mul *tmp59 :compute:zx :compute:zx
   971 op mul *tmp60 :compute:zy :compute:zy
 
   980 label *label309
   981 label *label310
   982 label *label311
-    * op add :compute:i :compute:i 1
+  983 op add :compute:i 54 1
   984 set :compute:x1 :compute:zx
   985 op mul *tmp59 :compute:zx :compute:zx
   986 op mul *tmp60 :compute:zy :compute:zy
 
   995 label *label312
   996 label *label313
   997 label *label314
-    * op add :compute:i :compute:i 1
+  998 op add :compute:i 55 1
   999 set :compute:x1 :compute:zx
  1000 op mul *tmp59 :compute:zx :compute:zx
  1001 op mul *tmp60 :compute:zy :compute:zy
 
  1010 label *label315
  1011 label *label316
  1012 label *label317
-    * op add :compute:i :compute:i 1
+ 1013 op add :compute:i 56 1
  1014 set :compute:x1 :compute:zx
  1015 op mul *tmp59 :compute:zx :compute:zx
  1016 op mul *tmp60 :compute:zy :compute:zy
 
  1025 label *label318
  1026 label *label319
  1027 label *label320
-    * op add :compute:i :compute:i 1
+ 1028 op add :compute:i 57 1
  1029 set :compute:x1 :compute:zx
  1030 op mul *tmp59 :compute:zx :compute:zx
  1031 op mul *tmp60 :compute:zy :compute:zy
 
  1040 label *label321
  1041 label *label322
  1042 label *label323
-    * op add :compute:i :compute:i 1
+ 1043 op add :compute:i 58 1
  1044 set :compute:x1 :compute:zx
  1045 op mul *tmp59 :compute:zx :compute:zx
  1046 op mul *tmp60 :compute:zy :compute:zy
 
  1055 label *label324
  1056 label *label325
  1057 label *label326
-    * op add :compute:i :compute:i 1
+ 1058 op add :compute:i 59 1
  1059 set :compute:x1 :compute:zx
  1060 op mul *tmp59 :compute:zx :compute:zx
  1061 op mul *tmp60 :compute:zy :compute:zy
 
  1070 label *label327
  1071 label *label328
  1072 label *label329
-    * op add :compute:i :compute:i 1
+ 1073 op add :compute:i 60 1
  1074 set :compute:x1 :compute:zx
  1075 op mul *tmp59 :compute:zx :compute:zx
  1076 op mul *tmp60 :compute:zy :compute:zy
 
  1085 label *label330
  1086 label *label331
  1087 label *label332
-    * op add :compute:i :compute:i 1
+ 1088 op add :compute:i 61 1
  1089 set :compute:x1 :compute:zx
  1090 op mul *tmp59 :compute:zx :compute:zx
  1091 op mul *tmp60 :compute:zy :compute:zy
 
  1100 label *label333
  1101 label *label334
  1102 label *label335
-    * op add :compute:i :compute:i 1
+ 1103 op add :compute:i 62 1
  1104 label *label56
  1105 op mul *tmp69 .SMOOTH 63
  1106 jump *label59 greaterThanEq :compute:i *tmp69

Modifications by Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:214:1 (+2 instructions):
 
  1146 op add :lines :lines 1
  1147 jump *label106 lessThan :lines 176
  1148 label *label41
-    * setaddr :flushLocalBuffer*retaddr *label68 (h:*label68)
-    * call *label1 *invalid :flushLocalBuffer*retval (m:*label68) (h:*label68)
-    * label *label68
+ 1149 label *label336
+ 1150 label *label337
+ 1151 label *label338
+ 1152 sensor *tmp144 .display @enabled
+ 1153 jump *label337 equal *tmp144 false
+ 1154 label *label339
+ 1155 jump *label343 lessThanEq .localBuffer 4
+ 1156 label *label340
+ 1157 wait 0.0001
+ 1158 label *label341
+ 1159 sensor *tmp148 .display @bufferSize
+ 1160 jump *label340 greaterThan *tmp148 250
+ 1161 label *label342
+ 1162 label *label343
+ 1163 label *label344
+ 1164 drawflush .display
+ 1165 set .localBuffer 0
+ 1166 label *label345
  1167 label *label32
  1168 jump *label31 always
  1169 label *label33
 
  1218 read :drawPixel:color .memory :drawPixel:iterations
  1219 label *label71
  1220 jump *label81 lessThan .localBuffer 254
-    * setaddr :flushLocalBuffer*retaddr *label83 (h:*label83)
-    * call *label1 *invalid :flushLocalBuffer*retval (m:*label83) (h:*label83)
-    * label *label83
+ 1221 label *label346
+ 1222 label *label347
+ 1223 label *label348
+ 1224 sensor *tmp144 .display @enabled
+ 1225 jump *label347 equal *tmp144 false
+ 1226 label *label349
+ 1227 jump *label353 lessThanEq .localBuffer 4
+ 1228 label *label350
+ 1229 wait 0.0001
+ 1230 label *label351
+ 1231 sensor *tmp148 .display @bufferSize
+ 1232 jump *label350 greaterThan *tmp148 250
+ 1233 label *label352
+ 1234 label *label353
+ 1235 label *label354
+ 1236 drawflush .display
+ 1237 set .localBuffer 0
+ 1238 label *label355
  1239 label *label81
  1240 label *label82
  1241 draw col :drawPixel:color
 
  1261 label *label69
  1262 return :drawPixel*retaddr
  1263 end
-    * label *label1
-    * label *label89
-    * label *label90
-    * sensor *tmp144 .display @enabled
-    * jump *label89 equal *tmp144 false
-    * label *label91
-    * jump *label92 lessThanEq .localBuffer 4
-    * label *label94
-    * wait 0.0001
-    * label *label95
-    * sensor *tmp148 .display @bufferSize
-    * jump *label94 greaterThan *tmp148 250
-    * label *label96
-    * label *label92
-    * label *label93
-    * drawflush .display
-    * set .localBuffer 0
-    * label *label88
-    * return :flushLocalBuffer*retaddr
-    * end
  1264 label *label2
  1265 label *label98
  1266 jump *label100 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
  1162 label *label343
  1163 label *label344
  1164 drawflush .display
-    * set .localBuffer 0
  1165 label *label345
  1166 label *label32
  1167 jump *label31 always

Modifications by Inline function 'setState' defined at mandelbrot-compute.mnd:225:1 (+9 instructions):
 
    77 set .localBuffer 0
    78 drawflush null
    79 set :setState:state 0
-    * setaddr :setState*retaddr *label37 (h:*label37)
    80 label *label34
-    * call *label2 *invalid :setState*retval (m:*label37) (h:*label37)
-    * label *label37
+   81 label *label356
+   82 label *label357
+   83 jump *label364 greaterThanEq .PROC_STATE_INDEX 512
+   84 label *label358
+   85 read *tmp152 .memory .PROC_ID_INDEX
+   86 jump *label359 notEqual *tmp152 .PROCESSOR_ID
+   87 write :setState:state .memory .PROC_STATE_INDEX
+   88 jump *label364 always
+   89 jump *label362 always
+   90 label *label359
+   91 read *tmp158 .memory .PROC_ID_INDEX
+   92 jump *label360 notEqual *tmp158 0
+   93 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+   94 write :setState:state .memory .PROC_STATE_INDEX
+   95 jump *label364 always
+   96 jump *label361 always
+   97 label *label360
+   98 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+   99 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  100 label *label361
+  101 label *label362
+  102 label *label363
+  103 jump *label358 lessThan .PROC_STATE_INDEX 512
+  104 label *label364
+  105 label *label365
   106 label *label35
   107 read *tmp0 .memory 64
   108 jump *label34 equal .start *tmp0
 
   112 read *tmp1 .memory 65
   113 set .stop *tmp1
   114 set :setState:state *tmp0
-    * setaddr :setState*retaddr *label38 (h:*label38)
-    * call *label2 *invalid :setState*retval (m:*label38) (h:*label38)
-    * label *label38
+  115 label *label366
+  116 label *label367
+  117 jump *label374 greaterThanEq .PROC_STATE_INDEX 512
+  118 label *label368
+  119 read *tmp152 .memory .PROC_ID_INDEX
+  120 jump *label369 notEqual *tmp152 .PROCESSOR_ID
+  121 write :setState:state .memory .PROC_STATE_INDEX
+  122 jump *label374 always
+  123 jump *label372 always
+  124 label *label369
+  125 read *tmp158 .memory .PROC_ID_INDEX
+  126 jump *label370 notEqual *tmp158 0
+  127 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  128 write :setState:state .memory .PROC_STATE_INDEX
+  129 jump *label374 always
+  130 jump *label371 always
+  131 label *label370
+  132 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  133 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  134 label *label371
+  135 label *label372
+  136 label *label373
+  137 jump *label368 lessThan .PROC_STATE_INDEX 512
+  138 label *label374
+  139 label *label375
   140 read .ZOOM .memory 68
   141 op div *tmp26 -88 .ZOOM
   142 read *tmp2 .memory 66
 
  1304 label *label69
  1305 return :drawPixel*retaddr
  1306 end
-    * label *label2
-    * label *label98
-    * jump *label100 greaterThanEq .PROC_STATE_INDEX 512
-    * label *label109
-    * read *tmp152 .memory .PROC_ID_INDEX
-    * jump *label101 notEqual *tmp152 .PROCESSOR_ID
-    * write :setState:state .memory .PROC_STATE_INDEX
-    * jump *label100 always
-    * jump *label102 always
-    * label *label101
-    * read *tmp158 .memory .PROC_ID_INDEX
-    * jump *label103 notEqual *tmp158 0
-    * write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState:state .memory .PROC_STATE_INDEX
-    * jump *label100 always
-    * jump *label104 always
-    * label *label103
-    * op add .PROC_ID_INDEX .PROC_ID_INDEX 2
-    * op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label104
-    * label *label102
-    * label *label99
-    * jump *label109 lessThan .PROC_STATE_INDEX 512
-    * label *label100
-    * label *label97
-    * return :setState*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    84 label *label358
    85 read *tmp152 .memory .PROC_ID_INDEX
    86 jump *label359 notEqual *tmp152 .PROCESSOR_ID
-    * write :setState:state .memory .PROC_STATE_INDEX
+   87 write 0 .memory .PROC_STATE_INDEX
    88 jump *label364 always
    89 jump *label362 always
    90 label *label359
    91 read *tmp158 .memory .PROC_ID_INDEX
    92 jump *label360 notEqual *tmp158 0
    93 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState:state .memory .PROC_STATE_INDEX
+   94 write 0 .memory .PROC_STATE_INDEX
    95 jump *label364 always
    96 jump *label361 always
    97 label *label360
 
   118 label *label368
   119 read *tmp152 .memory .PROC_ID_INDEX
   120 jump *label369 notEqual *tmp152 .PROCESSOR_ID
-    * write :setState:state .memory .PROC_STATE_INDEX
+  121 write *tmp0 .memory .PROC_STATE_INDEX
   122 jump *label374 always
   123 jump *label372 always
   124 label *label369
   125 read *tmp158 .memory .PROC_ID_INDEX
   126 jump *label370 notEqual *tmp158 0
   127 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState:state .memory .PROC_STATE_INDEX
+  128 write *tmp0 .memory .PROC_STATE_INDEX
   129 jump *label374 always
   130 jump *label371 always
   131 label *label370

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    76 label *label31
    77 set .localBuffer 0
    78 drawflush null
-    * set :setState:state 0
    79 label *label34
    80 label *label356
    81 label *label357
 
   110 set .start *tmp0
   111 read *tmp1 .memory 65
   112 set .stop *tmp1
-    * set :setState:state *tmp0
   113 label *label366
   114 label *label367
   115 jump *label374 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:166:13 (-2 instructions):
 
  1214 set :drawPixel:color %[black]
  1215 jump *label73 equal :drawPixel:iterations 63
  1216 label *label72
-    * jump *label75 notEqual .PALETTE 2
+ 1217 multijump .PALETTE 0 0 (m:*label377)
+ 1218 multilabel *label382 (m:*label377)
+ 1219 multilabel *label378 (m:*label377)
+ 1220 label *label376
+ 1221 op div *tmp126 :drawPixel:iterations 63.75
+ 1222 op sub :drawPixel:r 1 *tmp126
+ 1223 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
+ 1224 jump *label74 always
+ 1225 multilabel *label379 (m:*label377)
  1226 label *label76
  1227 op sub *tmp91 32 :drawPixel:iterations
  1228 op abs *tmp92 *tmp91
 
  1237 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1238 jump *label74 always
  1239 label *label75
-    * jump *label77 notEqual .PALETTE 3
+ 1240 multilabel *label380 (m:*label377)
  1241 label *label78
  1242 op div *tmp108 :drawPixel:iterations 0.175
  1243 op sin :drawPixel:r *tmp108
 
  1249 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1250 jump *label74 always
  1251 label *label77
-    * jump *label79 notEqual .PALETTE 4
+ 1252 multilabel *label381 (m:*label377)
  1253 label *label80
  1254 op div :drawPixel:r :drawPixel:iterations 63.75
  1255 op div *tmp122 :drawPixel:iterations 170
  1256 op add :drawPixel:g 96 *tmp122
  1257 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label74 always
-    * label *label79
-    * op div *tmp126 :drawPixel:iterations 63.75
-    * op sub :drawPixel:r 1 *tmp126
-    * packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
  1258 label *label74
  1259 label *label73
  1260 jump *label71 always

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    49 print ":"
    50 print " "
    51 print .display
-    * jump *label133 equal true false
    52 op and :findLinkedBlocks:foundAll 1 .display
    53 label *label133
    54 label *label134
 
    60 print ":"
    61 print " "
    62 print .memory
-    * jump *label139 equal true false
    63 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    64 label *label139
    65 label *label140

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
  1153 label *label59
  1154 label *label60
  1155 set *tmp41 :compute:i
-    * jump *label47 always
  1156 label *label47
  1157 set :drawPixel:y :y
  1158 set :drawPixel:iterations *tmp41

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-2 instructions):
 
    25 label *label110
    26 jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
    27 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
+   28 set :findLinkedBlocks:message :findLinkedBlocks:message
    29 label *label111
    30 label *label112
    31 label *label113
 
    34 label *label116
    35 jump *label117 notEqual @memory-bank :findLinkedBlocks:type
    36 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
+   37 set :findLinkedBlocks:message :findLinkedBlocks:message
    38 label *label117
    39 label *label118
    40 label *label119
 
    53 label *label133
    54 label *label134
    55 label *label135
-    * set .display .display
    56 label *label138
    57 print "\n"
    58 print "Memory"
 
    63 label *label139
    64 label *label140
    65 label *label141
-    * set .memory .memory
    66 label *label26
    67 printflush :findLinkedBlocks:message
    68 label *label5
 
   208 label *label147
   209 label *label148
   210 label *label149
-    * op add :compute:i 0 1
+  211 set :compute:i 1
   212 set :compute:x1 :compute:zx
   213 op mul *tmp59 :compute:zx :compute:zx
   214 op mul *tmp60 :compute:zy :compute:zy

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1 (-2 instructions):
 
    25 label *label110
    26 jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
    27 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    28 label *label111
    29 label *label112
    30 label *label113
 
    33 label *label116
    34 jump *label117 notEqual @memory-bank :findLinkedBlocks:type
    35 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    36 label *label117
    37 label *label118
    38 label *label119

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1:
 
    62 label *label140
    63 label *label141
    64 label *label26
-    * printflush :findLinkedBlocks:message
+   65 printflush null
    66 label *label5
    67 jump *label4 equal :findLinkedBlocks:foundAll false
    68 label *label6

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 2 (-1 instructions):
 
     2 set .PROC_ID_INDEX 334
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
-    * set :findLinkedBlocks:message null
     5 label *label4
     6 label *label123
     7 label *label124

Modifications by Iterated phase, Boolean Optimization, pass 3, iteration 1 (-2 instructions):
 
    22 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    23 set :findLinkedBlocks:variable .display
    24 label *label110
-    * jump *label111 notEqual @large-logic-display :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label111
-    * label *label112
+   25 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    26 label *label113
    27 set .display :findLinkedBlocks:variable
    28 set :findLinkedBlocks:variable .memory
    29 label *label116
-    * jump *label117 notEqual @memory-bank :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label117
-    * label *label118
+   30 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    31 label *label119
    32 set .memory :findLinkedBlocks:variable
    33 label *label17

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 1:
 
    22 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    23 set :findLinkedBlocks:variable .display
    24 label *label110
-    * select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   25 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    26 label *label113
    27 set .display :findLinkedBlocks:variable
    28 set :findLinkedBlocks:variable .memory
    29 label *label116
-    * select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   30 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    31 label *label119
    32 set .memory :findLinkedBlocks:variable
    33 label *label17

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 2 (-2 instructions):
 
    20 print "\nFound: "
    21 print :findLinkedBlocks:block
    22 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:variable .display
    23 label *label110
    24 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    25 label *label113
    26 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:variable .memory
    27 label *label116
    28 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    29 label *label119

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-6 instructions):
 
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
     5 label *label4
-    * label *label123
-    * label *label124
     6 set .display null
-    * label *label127
-    * label *label128
     7 set .memory null
-    * label *label9
     8 print "Mandelbrot Generator"
     9 set :findLinkedBlocks:n @links
-    * label *label12
    10 jump *label14 lessThanEq :findLinkedBlocks:n 0
    11 label *label105
    12 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
 
    14 print "\nFound: "
    15 print :findLinkedBlocks:block
    16 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * label *label110
    17 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
-    * label *label113
    18 set .display :findLinkedBlocks:variable
-    * label *label116
    19 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
-    * label *label119
    20 set .memory :findLinkedBlocks:variable
-    * label *label17
-    * label *label13
    21 jump *label105 greaterThan :findLinkedBlocks:n 0
    22 label *label14
-    * label *label132
    23 print "\n"
    24 print "Display"
    25 print ":"
    26 print " "
    27 print .display
    28 op and :findLinkedBlocks:foundAll 1 .display
-    * label *label133
-    * label *label134
-    * label *label135
-    * label *label138
    29 print "\n"
    30 print "Memory"
    31 print ":"
    32 print " "
    33 print .memory
    34 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
-    * label *label139
-    * label *label140
-    * label *label141
-    * label *label26
    35 printflush null
-    * label *label5
    36 jump *label4 equal :findLinkedBlocks:foundAll false
-    * label *label6
-    * label *label3
    37 label *label31
    38 set .localBuffer 0
    39 drawflush null
    40 label *label34
-    * label *label356
-    * label *label357
    41 jump *label364 greaterThanEq .PROC_STATE_INDEX 512
    42 label *label358
    43 read *tmp152 .memory .PROC_ID_INDEX
    44 jump *label359 notEqual *tmp152 .PROCESSOR_ID
    45 write 0 .memory .PROC_STATE_INDEX
    46 jump *label364 always
-    * jump *label362 always
    47 label *label359
    48 read *tmp158 .memory .PROC_ID_INDEX
    49 jump *label360 notEqual *tmp158 0
    50 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    51 write 0 .memory .PROC_STATE_INDEX
    52 jump *label364 always
-    * jump *label361 always
    53 label *label360
    54 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    55 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
    56 label *label361
    57 label *label362
-    * label *label363
    58 jump *label358 lessThan .PROC_STATE_INDEX 512
    59 label *label364
-    * label *label365
-    * label *label35
    60 read *tmp0 .memory 64
    61 jump *label34 equal .start *tmp0
-    * label *label36
    62 read *tmp0 .memory 64
    63 set .start *tmp0
    64 read *tmp1 .memory 65
    65 set .stop *tmp1
-    * label *label366
-    * label *label367
    66 jump *label374 greaterThanEq .PROC_STATE_INDEX 512
    67 label *label368
    68 read *tmp152 .memory .PROC_ID_INDEX
    69 jump *label369 notEqual *tmp152 .PROCESSOR_ID
    70 write *tmp0 .memory .PROC_STATE_INDEX
    71 jump *label374 always
-    * jump *label372 always
    72 label *label369
    73 read *tmp158 .memory .PROC_ID_INDEX
    74 jump *label370 notEqual *tmp158 0
    75 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    76 write *tmp0 .memory .PROC_STATE_INDEX
    77 jump *label374 always
-    * jump *label371 always
    78 label *label370
    79 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    80 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
    81 label *label371
    82 label *label372
-    * label *label373
    83 jump *label368 lessThan .PROC_STATE_INDEX 512
    84 label *label374
-    * label *label375
    85 read .ZOOM .memory 68
    86 op div *tmp26 -88 .ZOOM
    87 read *tmp2 .memory 66
 
    99 op rand *tmp31 0.1
   100 wait *tmp31
   101 set :lines 0
-    * label *label39
   102 label *label106
   103 op mul *tmp32 17 :line
   104 op mod :x *tmp32 176
 
   109 set :y 0
   110 set :drawPixel:x :x
   111 setaddr :drawPixel*retaddr *label61 (h:*label61)
-    * label *label44
   112 label *label107
   113 op div *tmp42 :x .ZOOM
   114 op add :compute:zx *tmp42 .OFFSET_X
 
   131 set *tmp41 63
   132 jump *label47 always
   133 label *label50
-    * label *label51
   134 op add *tmp55 :compute:zx 1
   135 op len *tmp56 *tmp55 :compute:zy
   136 jump *label52 greaterThan *tmp56 0.25
   137 set *tmp41 63
   138 jump *label47 always
   139 label *label52
-    * label *label53
   140 label *label49
   141 set :compute:i 0
-    * label *label145
-    * label *label146
   142 set :compute:x1 :compute:zx
   143 op mul *tmp59 :compute:zx :compute:zx
   144 op mul *tmp60 :compute:zy :compute:zy
 
   151 jump *label147 lessThan :compute:dist 64
   152 jump *label56 always
   153 label *label147
-    * label *label148
-    * label *label149
   154 set :compute:i 1
   155 set :compute:x1 :compute:zx
   156 op mul *tmp59 :compute:zx :compute:zx
 
   164 jump *label150 lessThan :compute:dist 64
   165 jump *label56 always
   166 label *label150
-    * label *label151
-    * label *label152
   167 op add :compute:i 1 1
   168 set :compute:x1 :compute:zx
   169 op mul *tmp59 :compute:zx :compute:zx
 
   177 jump *label153 lessThan :compute:dist 64
   178 jump *label56 always
   179 label *label153
-    * label *label154
-    * label *label155
   180 op add :compute:i 2 1
   181 set :compute:x1 :compute:zx
   182 op mul *tmp59 :compute:zx :compute:zx
 
   190 jump *label156 lessThan :compute:dist 64
   191 jump *label56 always
   192 label *label156
-    * label *label157
-    * label *label158
   193 op add :compute:i 3 1
   194 set :compute:x1 :compute:zx
   195 op mul *tmp59 :compute:zx :compute:zx
 
   203 jump *label159 lessThan :compute:dist 64
   204 jump *label56 always
   205 label *label159
-    * label *label160
-    * label *label161
   206 op add :compute:i 4 1
   207 set :compute:x1 :compute:zx
   208 op mul *tmp59 :compute:zx :compute:zx
 
   216 jump *label162 lessThan :compute:dist 64
   217 jump *label56 always
   218 label *label162
-    * label *label163
-    * label *label164
   219 op add :compute:i 5 1
   220 set :compute:x1 :compute:zx
   221 op mul *tmp59 :compute:zx :compute:zx
 
   229 jump *label165 lessThan :compute:dist 64
   230 jump *label56 always
   231 label *label165
-    * label *label166
-    * label *label167
   232 op add :compute:i 6 1
   233 set :compute:x1 :compute:zx
   234 op mul *tmp59 :compute:zx :compute:zx
 
   242 jump *label168 lessThan :compute:dist 64
   243 jump *label56 always
   244 label *label168
-    * label *label169
-    * label *label170
   245 op add :compute:i 7 1
   246 set :compute:x1 :compute:zx
   247 op mul *tmp59 :compute:zx :compute:zx
 
   255 jump *label171 lessThan :compute:dist 64
   256 jump *label56 always
   257 label *label171
-    * label *label172
-    * label *label173
   258 op add :compute:i 8 1
   259 set :compute:x1 :compute:zx
   260 op mul *tmp59 :compute:zx :compute:zx
 
   268 jump *label174 lessThan :compute:dist 64
   269 jump *label56 always
   270 label *label174
-    * label *label175
-    * label *label176
   271 op add :compute:i 9 1
   272 set :compute:x1 :compute:zx
   273 op mul *tmp59 :compute:zx :compute:zx
 
   281 jump *label177 lessThan :compute:dist 64
   282 jump *label56 always
   283 label *label177
-    * label *label178
-    * label *label179
   284 op add :compute:i 10 1
   285 set :compute:x1 :compute:zx
   286 op mul *tmp59 :compute:zx :compute:zx
 
   294 jump *label180 lessThan :compute:dist 64
   295 jump *label56 always
   296 label *label180
-    * label *label181
-    * label *label182
   297 op add :compute:i 11 1
   298 set :compute:x1 :compute:zx
   299 op mul *tmp59 :compute:zx :compute:zx
 
   307 jump *label183 lessThan :compute:dist 64
   308 jump *label56 always
   309 label *label183
-    * label *label184
-    * label *label185
   310 op add :compute:i 12 1
   311 set :compute:x1 :compute:zx
   312 op mul *tmp59 :compute:zx :compute:zx
 
   320 jump *label186 lessThan :compute:dist 64
   321 jump *label56 always
   322 label *label186
-    * label *label187
-    * label *label188
   323 op add :compute:i 13 1
   324 set :compute:x1 :compute:zx
   325 op mul *tmp59 :compute:zx :compute:zx
 
   333 jump *label189 lessThan :compute:dist 64
   334 jump *label56 always
   335 label *label189
-    * label *label190
-    * label *label191
   336 op add :compute:i 14 1
   337 set :compute:x1 :compute:zx
   338 op mul *tmp59 :compute:zx :compute:zx
 
   346 jump *label192 lessThan :compute:dist 64
   347 jump *label56 always
   348 label *label192
-    * label *label193
-    * label *label194
   349 op add :compute:i 15 1
   350 set :compute:x1 :compute:zx
   351 op mul *tmp59 :compute:zx :compute:zx
 
   359 jump *label195 lessThan :compute:dist 64
   360 jump *label56 always
   361 label *label195
-    * label *label196
-    * label *label197
   362 op add :compute:i 16 1
   363 set :compute:x1 :compute:zx
   364 op mul *tmp59 :compute:zx :compute:zx
 
   372 jump *label198 lessThan :compute:dist 64
   373 jump *label56 always
   374 label *label198
-    * label *label199
-    * label *label200
   375 op add :compute:i 17 1
   376 set :compute:x1 :compute:zx
   377 op mul *tmp59 :compute:zx :compute:zx
 
   385 jump *label201 lessThan :compute:dist 64
   386 jump *label56 always
   387 label *label201
-    * label *label202
-    * label *label203
   388 op add :compute:i 18 1
   389 set :compute:x1 :compute:zx
   390 op mul *tmp59 :compute:zx :compute:zx
 
   398 jump *label204 lessThan :compute:dist 64
   399 jump *label56 always
   400 label *label204
-    * label *label205
-    * label *label206
   401 op add :compute:i 19 1
   402 set :compute:x1 :compute:zx
   403 op mul *tmp59 :compute:zx :compute:zx
 
   411 jump *label207 lessThan :compute:dist 64
   412 jump *label56 always
   413 label *label207
-    * label *label208
-    * label *label209
   414 op add :compute:i 20 1
   415 set :compute:x1 :compute:zx
   416 op mul *tmp59 :compute:zx :compute:zx
 
   424 jump *label210 lessThan :compute:dist 64
   425 jump *label56 always
   426 label *label210
-    * label *label211
-    * label *label212
   427 op add :compute:i 21 1
   428 set :compute:x1 :compute:zx
   429 op mul *tmp59 :compute:zx :compute:zx
 
   437 jump *label213 lessThan :compute:dist 64
   438 jump *label56 always
   439 label *label213
-    * label *label214
-    * label *label215
   440 op add :compute:i 22 1
   441 set :compute:x1 :compute:zx
   442 op mul *tmp59 :compute:zx :compute:zx
 
   450 jump *label216 lessThan :compute:dist 64
   451 jump *label56 always
   452 label *label216
-    * label *label217
-    * label *label218
   453 op add :compute:i 23 1
   454 set :compute:x1 :compute:zx
   455 op mul *tmp59 :compute:zx :compute:zx
 
   463 jump *label219 lessThan :compute:dist 64
   464 jump *label56 always
   465 label *label219
-    * label *label220
-    * label *label221
   466 op add :compute:i 24 1
   467 set :compute:x1 :compute:zx
   468 op mul *tmp59 :compute:zx :compute:zx
 
   476 jump *label222 lessThan :compute:dist 64
   477 jump *label56 always
   478 label *label222
-    * label *label223
-    * label *label224
   479 op add :compute:i 25 1
   480 set :compute:x1 :compute:zx
   481 op mul *tmp59 :compute:zx :compute:zx
 
   489 jump *label225 lessThan :compute:dist 64
   490 jump *label56 always
   491 label *label225
-    * label *label226
-    * label *label227
   492 op add :compute:i 26 1
   493 set :compute:x1 :compute:zx
   494 op mul *tmp59 :compute:zx :compute:zx
 
   502 jump *label228 lessThan :compute:dist 64
   503 jump *label56 always
   504 label *label228
-    * label *label229
-    * label *label230
   505 op add :compute:i 27 1
   506 set :compute:x1 :compute:zx
   507 op mul *tmp59 :compute:zx :compute:zx
 
   515 jump *label231 lessThan :compute:dist 64
   516 jump *label56 always
   517 label *label231
-    * label *label232
-    * label *label233
   518 op add :compute:i 28 1
   519 set :compute:x1 :compute:zx
   520 op mul *tmp59 :compute:zx :compute:zx
 
   528 jump *label234 lessThan :compute:dist 64
   529 jump *label56 always
   530 label *label234
-    * label *label235
-    * label *label236
   531 op add :compute:i 29 1
   532 set :compute:x1 :compute:zx
   533 op mul *tmp59 :compute:zx :compute:zx
 
   541 jump *label237 lessThan :compute:dist 64
   542 jump *label56 always
   543 label *label237
-    * label *label238
-    * label *label239
   544 op add :compute:i 30 1
   545 set :compute:x1 :compute:zx
   546 op mul *tmp59 :compute:zx :compute:zx
 
   554 jump *label240 lessThan :compute:dist 64
   555 jump *label56 always
   556 label *label240
-    * label *label241
-    * label *label242
   557 op add :compute:i 31 1
   558 set :compute:x1 :compute:zx
   559 op mul *tmp59 :compute:zx :compute:zx
 
   567 jump *label243 lessThan :compute:dist 64
   568 jump *label56 always
   569 label *label243
-    * label *label244
-    * label *label245
   570 op add :compute:i 32 1
   571 set :compute:x1 :compute:zx
   572 op mul *tmp59 :compute:zx :compute:zx
 
   580 jump *label246 lessThan :compute:dist 64
   581 jump *label56 always
   582 label *label246
-    * label *label247
-    * label *label248
   583 op add :compute:i 33 1
   584 set :compute:x1 :compute:zx
   585 op mul *tmp59 :compute:zx :compute:zx
 
   593 jump *label249 lessThan :compute:dist 64
   594 jump *label56 always
   595 label *label249
-    * label *label250
-    * label *label251
   596 op add :compute:i 34 1
   597 set :compute:x1 :compute:zx
   598 op mul *tmp59 :compute:zx :compute:zx
 
   606 jump *label252 lessThan :compute:dist 64
   607 jump *label56 always
   608 label *label252
-    * label *label253
-    * label *label254
   609 op add :compute:i 35 1
   610 set :compute:x1 :compute:zx
   611 op mul *tmp59 :compute:zx :compute:zx
 
   619 jump *label255 lessThan :compute:dist 64
   620 jump *label56 always
   621 label *label255
-    * label *label256
-    * label *label257
   622 op add :compute:i 36 1
   623 set :compute:x1 :compute:zx
   624 op mul *tmp59 :compute:zx :compute:zx
 
   632 jump *label258 lessThan :compute:dist 64
   633 jump *label56 always
   634 label *label258
-    * label *label259
-    * label *label260
   635 op add :compute:i 37 1
   636 set :compute:x1 :compute:zx
   637 op mul *tmp59 :compute:zx :compute:zx
 
   645 jump *label261 lessThan :compute:dist 64
   646 jump *label56 always
   647 label *label261
-    * label *label262
-    * label *label263
   648 op add :compute:i 38 1
   649 set :compute:x1 :compute:zx
   650 op mul *tmp59 :compute:zx :compute:zx
 
   658 jump *label264 lessThan :compute:dist 64
   659 jump *label56 always
   660 label *label264
-    * label *label265
-    * label *label266
   661 op add :compute:i 39 1
   662 set :compute:x1 :compute:zx
   663 op mul *tmp59 :compute:zx :compute:zx
 
   671 jump *label267 lessThan :compute:dist 64
   672 jump *label56 always
   673 label *label267
-    * label *label268
-    * label *label269
   674 op add :compute:i 40 1
   675 set :compute:x1 :compute:zx
   676 op mul *tmp59 :compute:zx :compute:zx
 
   684 jump *label270 lessThan :compute:dist 64
   685 jump *label56 always
   686 label *label270
-    * label *label271
-    * label *label272
   687 op add :compute:i 41 1
   688 set :compute:x1 :compute:zx
   689 op mul *tmp59 :compute:zx :compute:zx
 
   697 jump *label273 lessThan :compute:dist 64
   698 jump *label56 always
   699 label *label273
-    * label *label274
-    * label *label275
   700 op add :compute:i 42 1
   701 set :compute:x1 :compute:zx
   702 op mul *tmp59 :compute:zx :compute:zx
 
   710 jump *label276 lessThan :compute:dist 64
   711 jump *label56 always
   712 label *label276
-    * label *label277
-    * label *label278
   713 op add :compute:i 43 1
   714 set :compute:x1 :compute:zx
   715 op mul *tmp59 :compute:zx :compute:zx
 
   723 jump *label279 lessThan :compute:dist 64
   724 jump *label56 always
   725 label *label279
-    * label *label280
-    * label *label281
   726 op add :compute:i 44 1
   727 set :compute:x1 :compute:zx
   728 op mul *tmp59 :compute:zx :compute:zx
 
   736 jump *label282 lessThan :compute:dist 64
   737 jump *label56 always
   738 label *label282
-    * label *label283
-    * label *label284
   739 op add :compute:i 45 1
   740 set :compute:x1 :compute:zx
   741 op mul *tmp59 :compute:zx :compute:zx
 
   749 jump *label285 lessThan :compute:dist 64
   750 jump *label56 always
   751 label *label285
-    * label *label286
-    * label *label287
   752 op add :compute:i 46 1
   753 set :compute:x1 :compute:zx
   754 op mul *tmp59 :compute:zx :compute:zx
 
   762 jump *label288 lessThan :compute:dist 64
   763 jump *label56 always
   764 label *label288
-    * label *label289
-    * label *label290
   765 op add :compute:i 47 1
   766 set :compute:x1 :compute:zx
   767 op mul *tmp59 :compute:zx :compute:zx
 
   775 jump *label291 lessThan :compute:dist 64
   776 jump *label56 always
   777 label *label291
-    * label *label292
-    * label *label293
   778 op add :compute:i 48 1
   779 set :compute:x1 :compute:zx
   780 op mul *tmp59 :compute:zx :compute:zx
 
   788 jump *label294 lessThan :compute:dist 64
   789 jump *label56 always
   790 label *label294
-    * label *label295
-    * label *label296
   791 op add :compute:i 49 1
   792 set :compute:x1 :compute:zx
   793 op mul *tmp59 :compute:zx :compute:zx
 
   801 jump *label297 lessThan :compute:dist 64
   802 jump *label56 always
   803 label *label297
-    * label *label298
-    * label *label299
   804 op add :compute:i 50 1
   805 set :compute:x1 :compute:zx
   806 op mul *tmp59 :compute:zx :compute:zx
 
   814 jump *label300 lessThan :compute:dist 64
   815 jump *label56 always
   816 label *label300
-    * label *label301
-    * label *label302
   817 op add :compute:i 51 1
   818 set :compute:x1 :compute:zx
   819 op mul *tmp59 :compute:zx :compute:zx
 
   827 jump *label303 lessThan :compute:dist 64
   828 jump *label56 always
   829 label *label303
-    * label *label304
-    * label *label305
   830 op add :compute:i 52 1
   831 set :compute:x1 :compute:zx
   832 op mul *tmp59 :compute:zx :compute:zx
 
   840 jump *label306 lessThan :compute:dist 64
   841 jump *label56 always
   842 label *label306
-    * label *label307
-    * label *label308
   843 op add :compute:i 53 1
   844 set :compute:x1 :compute:zx
   845 op mul *tmp59 :compute:zx :compute:zx
 
   853 jump *label309 lessThan :compute:dist 64
   854 jump *label56 always
   855 label *label309
-    * label *label310
-    * label *label311
   856 op add :compute:i 54 1
   857 set :compute:x1 :compute:zx
   858 op mul *tmp59 :compute:zx :compute:zx
 
   866 jump *label312 lessThan :compute:dist 64
   867 jump *label56 always
   868 label *label312
-    * label *label313
-    * label *label314
   869 op add :compute:i 55 1
   870 set :compute:x1 :compute:zx
   871 op mul *tmp59 :compute:zx :compute:zx
 
   879 jump *label315 lessThan :compute:dist 64
   880 jump *label56 always
   881 label *label315
-    * label *label316
-    * label *label317
   882 op add :compute:i 56 1
   883 set :compute:x1 :compute:zx
   884 op mul *tmp59 :compute:zx :compute:zx
 
   892 jump *label318 lessThan :compute:dist 64
   893 jump *label56 always
   894 label *label318
-    * label *label319
-    * label *label320
   895 op add :compute:i 57 1
   896 set :compute:x1 :compute:zx
   897 op mul *tmp59 :compute:zx :compute:zx
 
   905 jump *label321 lessThan :compute:dist 64
   906 jump *label56 always
   907 label *label321
-    * label *label322
-    * label *label323
   908 op add :compute:i 58 1
   909 set :compute:x1 :compute:zx
   910 op mul *tmp59 :compute:zx :compute:zx
 
   918 jump *label324 lessThan :compute:dist 64
   919 jump *label56 always
   920 label *label324
-    * label *label325
-    * label *label326
   921 op add :compute:i 59 1
   922 set :compute:x1 :compute:zx
   923 op mul *tmp59 :compute:zx :compute:zx
 
   931 jump *label327 lessThan :compute:dist 64
   932 jump *label56 always
   933 label *label327
-    * label *label328
-    * label *label329
   934 op add :compute:i 60 1
   935 set :compute:x1 :compute:zx
   936 op mul *tmp59 :compute:zx :compute:zx
 
   944 jump *label330 lessThan :compute:dist 64
   945 jump *label56 always
   946 label *label330
-    * label *label331
-    * label *label332
   947 op add :compute:i 61 1
   948 set :compute:x1 :compute:zx
   949 op mul *tmp59 :compute:zx :compute:zx
 
   957 jump *label333 lessThan :compute:dist 64
   958 jump *label56 always
   959 label *label333
-    * label *label334
-    * label *label335
   960 op add :compute:i 62 1
   961 label *label56
   962 op mul *tmp69 .SMOOTH 63
 
   968 op sub :compute:correction 4 *tmp75
   969 op add :compute:i :compute:i :compute:correction
   970 label *label59
-    * label *label60
   971 set *tmp41 :compute:i
   972 label *label47
   973 set :drawPixel:y :y
 
   978 jump *label62 equal *tmp78 .PROCESSOR_ID
   979 jump *label46 always
   980 label *label62
-    * label *label63
   981 read *tmp1 .memory 65
   982 jump *label64 equal .stop *tmp1
   983 jump *label32 always
   984 label *label64
-    * label *label65
-    * label *label45
   985 op add :y :y 1
   986 jump *label107 lessThan :y 176
   987 label *label46
   988 label *label42
-    * label *label43
   989 op add :line :line :increment
   990 jump *label66 lessThanEq :line 176
   991 op div :next_increment :next_increment 2
   992 set :increment :next_increment
   993 op div :line :next_increment 2
   994 label *label66
-    * label *label67
-    * label *label40
   995 op add :lines :lines 1
   996 jump *label106 lessThan :lines 176
-    * label *label41
-    * label *label336
   997 label *label337
-    * label *label338
   998 sensor *tmp144 .display @enabled
   999 jump *label337 equal *tmp144 false
-    * label *label339
  1000 jump *label343 lessThanEq .localBuffer 4
  1001 label *label340
  1002 wait 0.0001
-    * label *label341
  1003 sensor *tmp148 .display @bufferSize
  1004 jump *label340 greaterThan *tmp148 250
-    * label *label342
  1005 label *label343
-    * label *label344
  1006 drawflush .display
-    * label *label345
  1007 label *label32
  1008 jump *label31 always
-    * label *label33
-    * end
  1009 label *label0
  1010 jump *label70 equal .SMOOTH false
  1011 set :drawPixel:color %[black]
  1012 jump *label73 equal :drawPixel:iterations 63
-    * label *label72
  1013 multijump .PALETTE 0 0 (m:*label377)
  1014 multilabel *label382 (m:*label377)
  1015 multilabel *label378 (m:*label377)
-    * label *label376
  1016 op div *tmp126 :drawPixel:iterations 63.75
  1017 op sub :drawPixel:r 1 *tmp126
  1018 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
  1019 jump *label74 always
  1020 multilabel *label379 (m:*label377)
-    * label *label76
  1021 op sub *tmp91 32 :drawPixel:iterations
  1022 op abs *tmp92 *tmp91
  1023 op div *tmp94 *tmp92 36.42857142857143
 
  1030 op add :drawPixel:b 0.47058823529411764 *tmp104
  1031 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1032 jump *label74 always
-    * label *label75
  1033 multilabel *label380 (m:*label377)
-    * label *label78
  1034 op div *tmp108 :drawPixel:iterations 0.175
  1035 op sin :drawPixel:r *tmp108
  1036 op cos :drawPixel:g *tmp108
 
  1040 op add :drawPixel:b 0.39215686274509803 *tmp116
  1041 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1042 jump *label74 always
-    * label *label77
  1043 multilabel *label381 (m:*label377)
-    * label *label80
  1044 op div :drawPixel:r :drawPixel:iterations 63.75
  1045 op div *tmp122 :drawPixel:iterations 170
  1046 op add :drawPixel:g 96 *tmp122
 
  1052 read :drawPixel:color .memory :drawPixel:iterations
  1053 label *label71
  1054 jump *label81 lessThan .localBuffer 254
-    * label *label346
  1055 label *label347
-    * label *label348
  1056 sensor *tmp144 .display @enabled
  1057 jump *label347 equal *tmp144 false
-    * label *label349
  1058 jump *label353 lessThanEq .localBuffer 4
  1059 label *label350
  1060 wait 0.0001
-    * label *label351
  1061 sensor *tmp148 .display @bufferSize
  1062 jump *label350 greaterThan *tmp148 250
-    * label *label352
  1063 label *label353
-    * label *label354
  1064 drawflush .display
  1065 set .localBuffer 0
-    * label *label355
  1066 label *label81
-    * label *label82
  1067 draw col :drawPixel:color
  1068 draw rect :drawPixel:x :drawPixel:y 1 1
  1069 op add .localBuffer .localBuffer 2
 
  1082 drawflush .display
  1083 set .localBuffer 0
  1084 label *label86
-    * label *label87
  1085 label *label85
-    * label *label69
  1086 return :drawPixel*retaddr
-    * end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-65 instructions):
 
   144 op mul *tmp64 *tmp63 :compute:zy
   145 op add :compute:zy *tmp64 :compute:cy
   146 op len :compute:dist :compute:zx :compute:zy
-    * jump *label147 lessThan :compute:dist 64
-    * jump *label56 always
+  147 jump *label56 greaterThanEq :compute:dist 64
   148 label *label147
   149 set :compute:i 1
   150 set :compute:x1 :compute:zx
 
   156 op mul *tmp64 *tmp63 :compute:zy
   157 op add :compute:zy *tmp64 :compute:cy
   158 op len :compute:dist :compute:zx :compute:zy
-    * jump *label150 lessThan :compute:dist 64
-    * jump *label56 always
+  159 jump *label56 greaterThanEq :compute:dist 64
   160 label *label150
   161 op add :compute:i 1 1
   162 set :compute:x1 :compute:zx
 
   168 op mul *tmp64 *tmp63 :compute:zy
   169 op add :compute:zy *tmp64 :compute:cy
   170 op len :compute:dist :compute:zx :compute:zy
-    * jump *label153 lessThan :compute:dist 64
-    * jump *label56 always
+  171 jump *label56 greaterThanEq :compute:dist 64
   172 label *label153
   173 op add :compute:i 2 1
   174 set :compute:x1 :compute:zx
 
   180 op mul *tmp64 *tmp63 :compute:zy
   181 op add :compute:zy *tmp64 :compute:cy
   182 op len :compute:dist :compute:zx :compute:zy
-    * jump *label156 lessThan :compute:dist 64
-    * jump *label56 always
+  183 jump *label56 greaterThanEq :compute:dist 64
   184 label *label156
   185 op add :compute:i 3 1
   186 set :compute:x1 :compute:zx
 
   192 op mul *tmp64 *tmp63 :compute:zy
   193 op add :compute:zy *tmp64 :compute:cy
   194 op len :compute:dist :compute:zx :compute:zy
-    * jump *label159 lessThan :compute:dist 64
-    * jump *label56 always
+  195 jump *label56 greaterThanEq :compute:dist 64
   196 label *label159
   197 op add :compute:i 4 1
   198 set :compute:x1 :compute:zx
 
   204 op mul *tmp64 *tmp63 :compute:zy
   205 op add :compute:zy *tmp64 :compute:cy
   206 op len :compute:dist :compute:zx :compute:zy
-    * jump *label162 lessThan :compute:dist 64
-    * jump *label56 always
+  207 jump *label56 greaterThanEq :compute:dist 64
   208 label *label162
   209 op add :compute:i 5 1
   210 set :compute:x1 :compute:zx
 
   216 op mul *tmp64 *tmp63 :compute:zy
   217 op add :compute:zy *tmp64 :compute:cy
   218 op len :compute:dist :compute:zx :compute:zy
-    * jump *label165 lessThan :compute:dist 64
-    * jump *label56 always
+  219 jump *label56 greaterThanEq :compute:dist 64
   220 label *label165
   221 op add :compute:i 6 1
   222 set :compute:x1 :compute:zx
 
   228 op mul *tmp64 *tmp63 :compute:zy
   229 op add :compute:zy *tmp64 :compute:cy
   230 op len :compute:dist :compute:zx :compute:zy
-    * jump *label168 lessThan :compute:dist 64
-    * jump *label56 always
+  231 jump *label56 greaterThanEq :compute:dist 64
   232 label *label168
   233 op add :compute:i 7 1
   234 set :compute:x1 :compute:zx
 
   240 op mul *tmp64 *tmp63 :compute:zy
   241 op add :compute:zy *tmp64 :compute:cy
   242 op len :compute:dist :compute:zx :compute:zy
-    * jump *label171 lessThan :compute:dist 64
-    * jump *label56 always
+  243 jump *label56 greaterThanEq :compute:dist 64
   244 label *label171
   245 op add :compute:i 8 1
   246 set :compute:x1 :compute:zx
 
   252 op mul *tmp64 *tmp63 :compute:zy
   253 op add :compute:zy *tmp64 :compute:cy
   254 op len :compute:dist :compute:zx :compute:zy
-    * jump *label174 lessThan :compute:dist 64
-    * jump *label56 always
+  255 jump *label56 greaterThanEq :compute:dist 64
   256 label *label174
   257 op add :compute:i 9 1
   258 set :compute:x1 :compute:zx
 
   264 op mul *tmp64 *tmp63 :compute:zy
   265 op add :compute:zy *tmp64 :compute:cy
   266 op len :compute:dist :compute:zx :compute:zy
-    * jump *label177 lessThan :compute:dist 64
-    * jump *label56 always
+  267 jump *label56 greaterThanEq :compute:dist 64
   268 label *label177
   269 op add :compute:i 10 1
   270 set :compute:x1 :compute:zx
 
   276 op mul *tmp64 *tmp63 :compute:zy
   277 op add :compute:zy *tmp64 :compute:cy
   278 op len :compute:dist :compute:zx :compute:zy
-    * jump *label180 lessThan :compute:dist 64
-    * jump *label56 always
+  279 jump *label56 greaterThanEq :compute:dist 64
   280 label *label180
   281 op add :compute:i 11 1
   282 set :compute:x1 :compute:zx
 
   288 op mul *tmp64 *tmp63 :compute:zy
   289 op add :compute:zy *tmp64 :compute:cy
   290 op len :compute:dist :compute:zx :compute:zy
-    * jump *label183 lessThan :compute:dist 64
-    * jump *label56 always
+  291 jump *label56 greaterThanEq :compute:dist 64
   292 label *label183
   293 op add :compute:i 12 1
   294 set :compute:x1 :compute:zx
 
   300 op mul *tmp64 *tmp63 :compute:zy
   301 op add :compute:zy *tmp64 :compute:cy
   302 op len :compute:dist :compute:zx :compute:zy
-    * jump *label186 lessThan :compute:dist 64
-    * jump *label56 always
+  303 jump *label56 greaterThanEq :compute:dist 64
   304 label *label186
   305 op add :compute:i 13 1
   306 set :compute:x1 :compute:zx
 
   312 op mul *tmp64 *tmp63 :compute:zy
   313 op add :compute:zy *tmp64 :compute:cy
   314 op len :compute:dist :compute:zx :compute:zy
-    * jump *label189 lessThan :compute:dist 64
-    * jump *label56 always
+  315 jump *label56 greaterThanEq :compute:dist 64
   316 label *label189
   317 op add :compute:i 14 1
   318 set :compute:x1 :compute:zx
 
   324 op mul *tmp64 *tmp63 :compute:zy
   325 op add :compute:zy *tmp64 :compute:cy
   326 op len :compute:dist :compute:zx :compute:zy
-    * jump *label192 lessThan :compute:dist 64
-    * jump *label56 always
+  327 jump *label56 greaterThanEq :compute:dist 64
   328 label *label192
   329 op add :compute:i 15 1
   330 set :compute:x1 :compute:zx
 
   336 op mul *tmp64 *tmp63 :compute:zy
   337 op add :compute:zy *tmp64 :compute:cy
   338 op len :compute:dist :compute:zx :compute:zy
-    * jump *label195 lessThan :compute:dist 64
-    * jump *label56 always
+  339 jump *label56 greaterThanEq :compute:dist 64
   340 label *label195
   341 op add :compute:i 16 1
   342 set :compute:x1 :compute:zx
 
   348 op mul *tmp64 *tmp63 :compute:zy
   349 op add :compute:zy *tmp64 :compute:cy
   350 op len :compute:dist :compute:zx :compute:zy
-    * jump *label198 lessThan :compute:dist 64
-    * jump *label56 always
+  351 jump *label56 greaterThanEq :compute:dist 64
   352 label *label198
   353 op add :compute:i 17 1
   354 set :compute:x1 :compute:zx
 
   360 op mul *tmp64 *tmp63 :compute:zy
   361 op add :compute:zy *tmp64 :compute:cy
   362 op len :compute:dist :compute:zx :compute:zy
-    * jump *label201 lessThan :compute:dist 64
-    * jump *label56 always
+  363 jump *label56 greaterThanEq :compute:dist 64
   364 label *label201
   365 op add :compute:i 18 1
   366 set :compute:x1 :compute:zx
 
   372 op mul *tmp64 *tmp63 :compute:zy
   373 op add :compute:zy *tmp64 :compute:cy
   374 op len :compute:dist :compute:zx :compute:zy
-    * jump *label204 lessThan :compute:dist 64
-    * jump *label56 always
+  375 jump *label56 greaterThanEq :compute:dist 64
   376 label *label204
   377 op add :compute:i 19 1
   378 set :compute:x1 :compute:zx
 
   384 op mul *tmp64 *tmp63 :compute:zy
   385 op add :compute:zy *tmp64 :compute:cy
   386 op len :compute:dist :compute:zx :compute:zy
-    * jump *label207 lessThan :compute:dist 64
-    * jump *label56 always
+  387 jump *label56 greaterThanEq :compute:dist 64
   388 label *label207
   389 op add :compute:i 20 1
   390 set :compute:x1 :compute:zx
 
   396 op mul *tmp64 *tmp63 :compute:zy
   397 op add :compute:zy *tmp64 :compute:cy
   398 op len :compute:dist :compute:zx :compute:zy
-    * jump *label210 lessThan :compute:dist 64
-    * jump *label56 always
+  399 jump *label56 greaterThanEq :compute:dist 64
   400 label *label210
   401 op add :compute:i 21 1
   402 set :compute:x1 :compute:zx
 
   408 op mul *tmp64 *tmp63 :compute:zy
   409 op add :compute:zy *tmp64 :compute:cy
   410 op len :compute:dist :compute:zx :compute:zy
-    * jump *label213 lessThan :compute:dist 64
-    * jump *label56 always
+  411 jump *label56 greaterThanEq :compute:dist 64
   412 label *label213
   413 op add :compute:i 22 1
   414 set :compute:x1 :compute:zx
 
   420 op mul *tmp64 *tmp63 :compute:zy
   421 op add :compute:zy *tmp64 :compute:cy
   422 op len :compute:dist :compute:zx :compute:zy
-    * jump *label216 lessThan :compute:dist 64
-    * jump *label56 always
+  423 jump *label56 greaterThanEq :compute:dist 64
   424 label *label216
   425 op add :compute:i 23 1
   426 set :compute:x1 :compute:zx
 
   432 op mul *tmp64 *tmp63 :compute:zy
   433 op add :compute:zy *tmp64 :compute:cy
   434 op len :compute:dist :compute:zx :compute:zy
-    * jump *label219 lessThan :compute:dist 64
-    * jump *label56 always
+  435 jump *label56 greaterThanEq :compute:dist 64
   436 label *label219
   437 op add :compute:i 24 1
   438 set :compute:x1 :compute:zx
 
   444 op mul *tmp64 *tmp63 :compute:zy
   445 op add :compute:zy *tmp64 :compute:cy
   446 op len :compute:dist :compute:zx :compute:zy
-    * jump *label222 lessThan :compute:dist 64
-    * jump *label56 always
+  447 jump *label56 greaterThanEq :compute:dist 64
   448 label *label222
   449 op add :compute:i 25 1
   450 set :compute:x1 :compute:zx
 
   456 op mul *tmp64 *tmp63 :compute:zy
   457 op add :compute:zy *tmp64 :compute:cy
   458 op len :compute:dist :compute:zx :compute:zy
-    * jump *label225 lessThan :compute:dist 64
-    * jump *label56 always
+  459 jump *label56 greaterThanEq :compute:dist 64
   460 label *label225
   461 op add :compute:i 26 1
   462 set :compute:x1 :compute:zx
 
   468 op mul *tmp64 *tmp63 :compute:zy
   469 op add :compute:zy *tmp64 :compute:cy
   470 op len :compute:dist :compute:zx :compute:zy
-    * jump *label228 lessThan :compute:dist 64
-    * jump *label56 always
+  471 jump *label56 greaterThanEq :compute:dist 64
   472 label *label228
   473 op add :compute:i 27 1
   474 set :compute:x1 :compute:zx
 
   480 op mul *tmp64 *tmp63 :compute:zy
   481 op add :compute:zy *tmp64 :compute:cy
   482 op len :compute:dist :compute:zx :compute:zy
-    * jump *label231 lessThan :compute:dist 64
-    * jump *label56 always
+  483 jump *label56 greaterThanEq :compute:dist 64
   484 label *label231
   485 op add :compute:i 28 1
   486 set :compute:x1 :compute:zx
 
   492 op mul *tmp64 *tmp63 :compute:zy
   493 op add :compute:zy *tmp64 :compute:cy
   494 op len :compute:dist :compute:zx :compute:zy
-    * jump *label234 lessThan :compute:dist 64
-    * jump *label56 always
+  495 jump *label56 greaterThanEq :compute:dist 64
   496 label *label234
   497 op add :compute:i 29 1
   498 set :compute:x1 :compute:zx
 
   504 op mul *tmp64 *tmp63 :compute:zy
   505 op add :compute:zy *tmp64 :compute:cy
   506 op len :compute:dist :compute:zx :compute:zy
-    * jump *label237 lessThan :compute:dist 64
-    * jump *label56 always
+  507 jump *label56 greaterThanEq :compute:dist 64
   508 label *label237
   509 op add :compute:i 30 1
   510 set :compute:x1 :compute:zx
 
   516 op mul *tmp64 *tmp63 :compute:zy
   517 op add :compute:zy *tmp64 :compute:cy
   518 op len :compute:dist :compute:zx :compute:zy
-    * jump *label240 lessThan :compute:dist 64
-    * jump *label56 always
+  519 jump *label56 greaterThanEq :compute:dist 64
   520 label *label240
   521 op add :compute:i 31 1
   522 set :compute:x1 :compute:zx
 
   528 op mul *tmp64 *tmp63 :compute:zy
   529 op add :compute:zy *tmp64 :compute:cy
   530 op len :compute:dist :compute:zx :compute:zy
-    * jump *label243 lessThan :compute:dist 64
-    * jump *label56 always
+  531 jump *label56 greaterThanEq :compute:dist 64
   532 label *label243
   533 op add :compute:i 32 1
   534 set :compute:x1 :compute:zx
 
   540 op mul *tmp64 *tmp63 :compute:zy
   541 op add :compute:zy *tmp64 :compute:cy
   542 op len :compute:dist :compute:zx :compute:zy
-    * jump *label246 lessThan :compute:dist 64
-    * jump *label56 always
+  543 jump *label56 greaterThanEq :compute:dist 64
   544 label *label246
   545 op add :compute:i 33 1
   546 set :compute:x1 :compute:zx
 
   552 op mul *tmp64 *tmp63 :compute:zy
   553 op add :compute:zy *tmp64 :compute:cy
   554 op len :compute:dist :compute:zx :compute:zy
-    * jump *label249 lessThan :compute:dist 64
-    * jump *label56 always
+  555 jump *label56 greaterThanEq :compute:dist 64
   556 label *label249
   557 op add :compute:i 34 1
   558 set :compute:x1 :compute:zx
 
   564 op mul *tmp64 *tmp63 :compute:zy
   565 op add :compute:zy *tmp64 :compute:cy
   566 op len :compute:dist :compute:zx :compute:zy
-    * jump *label252 lessThan :compute:dist 64
-    * jump *label56 always
+  567 jump *label56 greaterThanEq :compute:dist 64
   568 label *label252
   569 op add :compute:i 35 1
   570 set :compute:x1 :compute:zx
 
   576 op mul *tmp64 *tmp63 :compute:zy
   577 op add :compute:zy *tmp64 :compute:cy
   578 op len :compute:dist :compute:zx :compute:zy
-    * jump *label255 lessThan :compute:dist 64
-    * jump *label56 always
+  579 jump *label56 greaterThanEq :compute:dist 64
   580 label *label255
   581 op add :compute:i 36 1
   582 set :compute:x1 :compute:zx
 
   588 op mul *tmp64 *tmp63 :compute:zy
   589 op add :compute:zy *tmp64 :compute:cy
   590 op len :compute:dist :compute:zx :compute:zy
-    * jump *label258 lessThan :compute:dist 64
-    * jump *label56 always
+  591 jump *label56 greaterThanEq :compute:dist 64
   592 label *label258
   593 op add :compute:i 37 1
   594 set :compute:x1 :compute:zx
 
   600 op mul *tmp64 *tmp63 :compute:zy
   601 op add :compute:zy *tmp64 :compute:cy
   602 op len :compute:dist :compute:zx :compute:zy
-    * jump *label261 lessThan :compute:dist 64
-    * jump *label56 always
+  603 jump *label56 greaterThanEq :compute:dist 64
   604 label *label261
   605 op add :compute:i 38 1
   606 set :compute:x1 :compute:zx
 
   612 op mul *tmp64 *tmp63 :compute:zy
   613 op add :compute:zy *tmp64 :compute:cy
   614 op len :compute:dist :compute:zx :compute:zy
-    * jump *label264 lessThan :compute:dist 64
-    * jump *label56 always
+  615 jump *label56 greaterThanEq :compute:dist 64
   616 label *label264
   617 op add :compute:i 39 1
   618 set :compute:x1 :compute:zx
 
   624 op mul *tmp64 *tmp63 :compute:zy
   625 op add :compute:zy *tmp64 :compute:cy
   626 op len :compute:dist :compute:zx :compute:zy
-    * jump *label267 lessThan :compute:dist 64
-    * jump *label56 always
+  627 jump *label56 greaterThanEq :compute:dist 64
   628 label *label267
   629 op add :compute:i 40 1
   630 set :compute:x1 :compute:zx
 
   636 op mul *tmp64 *tmp63 :compute:zy
   637 op add :compute:zy *tmp64 :compute:cy
   638 op len :compute:dist :compute:zx :compute:zy
-    * jump *label270 lessThan :compute:dist 64
-    * jump *label56 always
+  639 jump *label56 greaterThanEq :compute:dist 64
   640 label *label270
   641 op add :compute:i 41 1
   642 set :compute:x1 :compute:zx
 
   648 op mul *tmp64 *tmp63 :compute:zy
   649 op add :compute:zy *tmp64 :compute:cy
   650 op len :compute:dist :compute:zx :compute:zy
-    * jump *label273 lessThan :compute:dist 64
-    * jump *label56 always
+  651 jump *label56 greaterThanEq :compute:dist 64
   652 label *label273
   653 op add :compute:i 42 1
   654 set :compute:x1 :compute:zx
 
   660 op mul *tmp64 *tmp63 :compute:zy
   661 op add :compute:zy *tmp64 :compute:cy
   662 op len :compute:dist :compute:zx :compute:zy
-    * jump *label276 lessThan :compute:dist 64
-    * jump *label56 always
+  663 jump *label56 greaterThanEq :compute:dist 64
   664 label *label276
   665 op add :compute:i 43 1
   666 set :compute:x1 :compute:zx
 
   672 op mul *tmp64 *tmp63 :compute:zy
   673 op add :compute:zy *tmp64 :compute:cy
   674 op len :compute:dist :compute:zx :compute:zy
-    * jump *label279 lessThan :compute:dist 64
-    * jump *label56 always
+  675 jump *label56 greaterThanEq :compute:dist 64
   676 label *label279
   677 op add :compute:i 44 1
   678 set :compute:x1 :compute:zx
 
   684 op mul *tmp64 *tmp63 :compute:zy
   685 op add :compute:zy *tmp64 :compute:cy
   686 op len :compute:dist :compute:zx :compute:zy
-    * jump *label282 lessThan :compute:dist 64
-    * jump *label56 always
+  687 jump *label56 greaterThanEq :compute:dist 64
   688 label *label282
   689 op add :compute:i 45 1
   690 set :compute:x1 :compute:zx
 
   696 op mul *tmp64 *tmp63 :compute:zy
   697 op add :compute:zy *tmp64 :compute:cy
   698 op len :compute:dist :compute:zx :compute:zy
-    * jump *label285 lessThan :compute:dist 64
-    * jump *label56 always
+  699 jump *label56 greaterThanEq :compute:dist 64
   700 label *label285
   701 op add :compute:i 46 1
   702 set :compute:x1 :compute:zx
 
   708 op mul *tmp64 *tmp63 :compute:zy
   709 op add :compute:zy *tmp64 :compute:cy
   710 op len :compute:dist :compute:zx :compute:zy
-    * jump *label288 lessThan :compute:dist 64
-    * jump *label56 always
+  711 jump *label56 greaterThanEq :compute:dist 64
   712 label *label288
   713 op add :compute:i 47 1
   714 set :compute:x1 :compute:zx
 
   720 op mul *tmp64 *tmp63 :compute:zy
   721 op add :compute:zy *tmp64 :compute:cy
   722 op len :compute:dist :compute:zx :compute:zy
-    * jump *label291 lessThan :compute:dist 64
-    * jump *label56 always
+  723 jump *label56 greaterThanEq :compute:dist 64
   724 label *label291
   725 op add :compute:i 48 1
   726 set :compute:x1 :compute:zx
 
   732 op mul *tmp64 *tmp63 :compute:zy
   733 op add :compute:zy *tmp64 :compute:cy
   734 op len :compute:dist :compute:zx :compute:zy
-    * jump *label294 lessThan :compute:dist 64
-    * jump *label56 always
+  735 jump *label56 greaterThanEq :compute:dist 64
   736 label *label294
   737 op add :compute:i 49 1
   738 set :compute:x1 :compute:zx
 
   744 op mul *tmp64 *tmp63 :compute:zy
   745 op add :compute:zy *tmp64 :compute:cy
   746 op len :compute:dist :compute:zx :compute:zy
-    * jump *label297 lessThan :compute:dist 64
-    * jump *label56 always
+  747 jump *label56 greaterThanEq :compute:dist 64
   748 label *label297
   749 op add :compute:i 50 1
   750 set :compute:x1 :compute:zx
 
   756 op mul *tmp64 *tmp63 :compute:zy
   757 op add :compute:zy *tmp64 :compute:cy
   758 op len :compute:dist :compute:zx :compute:zy
-    * jump *label300 lessThan :compute:dist 64
-    * jump *label56 always
+  759 jump *label56 greaterThanEq :compute:dist 64
   760 label *label300
   761 op add :compute:i 51 1
   762 set :compute:x1 :compute:zx
 
   768 op mul *tmp64 *tmp63 :compute:zy
   769 op add :compute:zy *tmp64 :compute:cy
   770 op len :compute:dist :compute:zx :compute:zy
-    * jump *label303 lessThan :compute:dist 64
-    * jump *label56 always
+  771 jump *label56 greaterThanEq :compute:dist 64
   772 label *label303
   773 op add :compute:i 52 1
   774 set :compute:x1 :compute:zx
 
   780 op mul *tmp64 *tmp63 :compute:zy
   781 op add :compute:zy *tmp64 :compute:cy
   782 op len :compute:dist :compute:zx :compute:zy
-    * jump *label306 lessThan :compute:dist 64
-    * jump *label56 always
+  783 jump *label56 greaterThanEq :compute:dist 64
   784 label *label306
   785 op add :compute:i 53 1
   786 set :compute:x1 :compute:zx
 
   792 op mul *tmp64 *tmp63 :compute:zy
   793 op add :compute:zy *tmp64 :compute:cy
   794 op len :compute:dist :compute:zx :compute:zy
-    * jump *label309 lessThan :compute:dist 64
-    * jump *label56 always
+  795 jump *label56 greaterThanEq :compute:dist 64
   796 label *label309
   797 op add :compute:i 54 1
   798 set :compute:x1 :compute:zx
 
   804 op mul *tmp64 *tmp63 :compute:zy
   805 op add :compute:zy *tmp64 :compute:cy
   806 op len :compute:dist :compute:zx :compute:zy
-    * jump *label312 lessThan :compute:dist 64
-    * jump *label56 always
+  807 jump *label56 greaterThanEq :compute:dist 64
   808 label *label312
   809 op add :compute:i 55 1
   810 set :compute:x1 :compute:zx
 
   816 op mul *tmp64 *tmp63 :compute:zy
   817 op add :compute:zy *tmp64 :compute:cy
   818 op len :compute:dist :compute:zx :compute:zy
-    * jump *label315 lessThan :compute:dist 64
-    * jump *label56 always
+  819 jump *label56 greaterThanEq :compute:dist 64
   820 label *label315
   821 op add :compute:i 56 1
   822 set :compute:x1 :compute:zx
 
   828 op mul *tmp64 *tmp63 :compute:zy
   829 op add :compute:zy *tmp64 :compute:cy
   830 op len :compute:dist :compute:zx :compute:zy
-    * jump *label318 lessThan :compute:dist 64
-    * jump *label56 always
+  831 jump *label56 greaterThanEq :compute:dist 64
   832 label *label318
   833 op add :compute:i 57 1
   834 set :compute:x1 :compute:zx
 
   840 op mul *tmp64 *tmp63 :compute:zy
   841 op add :compute:zy *tmp64 :compute:cy
   842 op len :compute:dist :compute:zx :compute:zy
-    * jump *label321 lessThan :compute:dist 64
-    * jump *label56 always
+  843 jump *label56 greaterThanEq :compute:dist 64
   844 label *label321
   845 op add :compute:i 58 1
   846 set :compute:x1 :compute:zx
 
   852 op mul *tmp64 *tmp63 :compute:zy
   853 op add :compute:zy *tmp64 :compute:cy
   854 op len :compute:dist :compute:zx :compute:zy
-    * jump *label324 lessThan :compute:dist 64
-    * jump *label56 always
+  855 jump *label56 greaterThanEq :compute:dist 64
   856 label *label324
   857 op add :compute:i 59 1
   858 set :compute:x1 :compute:zx
 
   864 op mul *tmp64 *tmp63 :compute:zy
   865 op add :compute:zy *tmp64 :compute:cy
   866 op len :compute:dist :compute:zx :compute:zy
-    * jump *label327 lessThan :compute:dist 64
-    * jump *label56 always
+  867 jump *label56 greaterThanEq :compute:dist 64
   868 label *label327
   869 op add :compute:i 60 1
   870 set :compute:x1 :compute:zx
 
   876 op mul *tmp64 *tmp63 :compute:zy
   877 op add :compute:zy *tmp64 :compute:cy
   878 op len :compute:dist :compute:zx :compute:zy
-    * jump *label330 lessThan :compute:dist 64
-    * jump *label56 always
+  879 jump *label56 greaterThanEq :compute:dist 64
   880 label *label330
   881 op add :compute:i 61 1
   882 set :compute:x1 :compute:zx
 
   888 op mul *tmp64 *tmp63 :compute:zy
   889 op add :compute:zy *tmp64 :compute:cy
   890 op len :compute:dist :compute:zx :compute:zy
-    * jump *label333 lessThan :compute:dist 64
-    * jump *label56 always
+  891 jump *label56 greaterThanEq :compute:dist 64
   892 label *label333
   893 op add :compute:i 62 1
   894 label *label56
 
   908 call *label0 *invalid :drawPixel*retval (m:*label61) (h:*label61)
   909 label *label61
   910 read *tmp78 .memory :position
-    * jump *label62 equal *tmp78 .PROCESSOR_ID
-    * jump *label46 always
+  911 jump *label46 notEqual *tmp78 .PROCESSOR_ID
   912 label *label62
   913 read *tmp1 .memory 65
-    * jump *label64 equal .stop *tmp1
-    * jump *label32 always
+  914 jump *label32 notEqual .stop *tmp1
   915 label *label64
   916 op add :y :y 1
   917 jump *label107 lessThan :y 176

Modifications by Jumps phase, Jump Threading, pass 6, iteration 1:
 
   847 read *tmp78 .memory :position
   848 jump *label46 notEqual *tmp78 .PROCESSOR_ID
   849 read *tmp1 .memory 65
-    * jump *label32 notEqual .stop *tmp1
+  850 jump *label31 notEqual .stop *tmp1
   851 op add :y :y 1
   852 jump *label107 lessThan :y 176
   853 label *label46
 
   875 label *label0
   876 jump *label70 equal .SMOOTH false
   877 set :drawPixel:color %[black]
-    * jump *label73 equal :drawPixel:iterations 63
+  878 jump *label71 equal :drawPixel:iterations 63
   879 multijump .PALETTE 0 0 (m:*label377)
   880 multilabel *label382 (m:*label377)
   881 multilabel *label378 (m:*label377)
   882 op div *tmp126 :drawPixel:iterations 63.75
   883 op sub :drawPixel:r 1 *tmp126
   884 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * jump *label74 always
+  885 jump *label71 always
   886 multilabel *label379 (m:*label377)
   887 op sub *tmp91 32 :drawPixel:iterations
   888 op abs *tmp92 *tmp91
 
   895 op div *tmp104 *tmp92 63.75
   896 op add :drawPixel:b 0.47058823529411764 *tmp104
   897 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label74 always
+  898 jump *label71 always
   899 multilabel *label380 (m:*label377)
   900 op div *tmp108 :drawPixel:iterations 0.175
   901 op sin :drawPixel:r *tmp108
 
   905 op div *tmp116 *tmp114 63.75
   906 op add :drawPixel:b 0.39215686274509803 *tmp116
   907 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label74 always
+  908 jump *label71 always
   909 multilabel *label381 (m:*label377)
   910 op div :drawPixel:r :drawPixel:iterations 63.75
   911 op div *tmp122 :drawPixel:iterations 170
 
   941 jump *label84 greaterThanEq :drawPixel:usage 100
   942 drawflush .display
   943 set .localBuffer 0
-    * jump *label85 always
+  944 return :drawPixel*retaddr
   945 label *label84
   946 op div *tmp141 1800 .localBuffer
   947 jump *label86 greaterThanEq :drawPixel:usage *tmp141

Modifications by Final phase, Print Merging, iteration 1 (-7 instructions):
 
    20 set .memory :findLinkedBlocks:variable
    21 jump *label105 greaterThan :findLinkedBlocks:n 0
    22 label *label14
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
-    * print .display
+   23 print "\nDisplay: {0}\nMemory: "
+   24 format .display
    25 op and :findLinkedBlocks:foundAll 1 .display
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
    26 print .memory
    27 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    28 printflush null

Final code before resolving virtual instructions:

    0:  op mul *tmp11 10000 @thisy                                   mandelbrot-compute.mnd: var PROCESSOR_ID = @this.@x + 10000 * @this.@y;
    1:  op add .PROCESSOR_ID @thisx *tmp11                           ...
    2:  set .PROC_ID_INDEX 334                                       mandelbrot-compute.mnd: var PROC_ID_INDEX = PROCESSORS;
    3:  set .PROC_STATE_INDEX 335                                    mandelbrot-compute.mnd: var PROC_STATE_INDEX = PROCESSORS + 1;
    4:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label4                                                *blocks: do
    5:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    6:  set .memory null                                             ...
    7:  print "Mandelbrot Generator"                                 *blocks: print(title);
    8:  set :findLinkedBlocks:n @links                               *blocks: var n = @links;
    9:  jump *label14 lessThanEq :findLinkedBlocks:n 0               *blocks: while n > 0 do
        label *label105                                              ...
   10:  op sub :findLinkedBlocks:n :findLinkedBlocks:n 1             *blocks: var block = getlink(--n);
   11:  getlink :findLinkedBlocks:block :findLinkedBlocks:n          ...
   12:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
   13:  print :findLinkedBlocks:block                                ...
   14:  sensor :findLinkedBlocks:type :findLinkedBlocks:block @type  *blocks: var type = block.@type;
   15:  select :findLinkedBlocks:variable equal @large-logic-display *blocks: if requested == type then
   16:  set .display :findLinkedBlocks:variable                      *blocks: for requested, name, out variable, required in linkMap do
   17:  select :findLinkedBlocks:variable equal @memory-bank :findLi *blocks: if requested == type then
   18:  set .memory :findLinkedBlocks:variable                       *blocks: for requested, name, out variable, required in linkMap do
   19:  jump *label105 greaterThan :findLinkedBlocks:n 0             *blocks: while n > 0 do
        label *label14                                               ...
   20:  print "\nDisplay: {0}\nMemory: "                             *blocks: print($"\n$name: $variable");
   21:  format .display                                              ...
   22:  op and :findLinkedBlocks:foundAll 1 .display                 *blocks: if required then foundAll &= variable; end;
   23:  print .memory                                                *blocks: print($"\n$name: $variable");
   24:  op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll *blocks: if required then foundAll &= variable; end;
   25:  printflush null                                              *blocks: printflush(message);
   26:  jump *label4 equal :findLinkedBlocks:foundAll false          *blocks: do
        label *label31                                               mandelbrot-compute.mnd: MainLoop:
   27:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   28:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
        label *label34                                               mandelbrot-compute.mnd: do
   29:  jump *label364 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label358                                              ...
   30:  read *tmp152 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   31:  jump *label359 notEqual *tmp152 .PROCESSOR_ID                ...
   32:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   33:  jump *label364 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label359                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   34:  read *tmp158 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   35:  jump *label360 notEqual *tmp158 0                            ...
   36:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   37:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   38:  jump *label364 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label360                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   39:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   40:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   41:  jump *label358 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label364                                              ...
   42:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: while start == $START;
   43:  jump *label34 equal .start *tmp0                             mandelbrot-compute.mnd: do
   44:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: start = $START;
   45:  set .start *tmp0                                             ...
   46:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: stop = $STOP;
   47:  set .stop *tmp1                                              ...
   48:  jump *label374 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label368                                              ...
   49:  read *tmp152 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   50:  jump *label369 notEqual *tmp152 .PROCESSOR_ID                ...
   51:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   52:  jump *label374 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label369                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   53:  read *tmp158 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   54:  jump *label370 notEqual *tmp158 0                            ...
   55:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   56:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   57:  jump *label374 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label370                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   58:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   59:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   60:  jump *label368 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label374                                              ...
   61:  read .ZOOM .memory 68                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   62:  op div *tmp26 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   63:  read *tmp2 .memory 66                                        ...
   64:  op add .OFFSET_X *tmp26 *tmp2                                ...
   65:  read *tmp3 .memory 67                                        mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   66:  op add .OFFSET_Y *tmp26 *tmp3                                ...
   67:  read .JULIA .memory 69                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   68:  read .JULIA_X .memory 70                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   69:  read .JULIA_Y .memory 71                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   70:  read .PALETTE .memory 72                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   71:  op greaterThan .SMOOTH .PALETTE 1                            mandelbrot-compute.mnd: SMOOTH   = PALETTE > 1;
   72:  set :line 8                                                  mandelbrot-compute.mnd: var line = 8;
   73:  set :increment 8                                             mandelbrot-compute.mnd: var increment = 8;
   74:  set :next_increment 16                                       mandelbrot-compute.mnd: var next_increment = 16;
   75:  op rand *tmp31 0.1 0                                         mandelbrot-compute.mnd: wait(rand(0.1));
   76:  wait *tmp31                                                  ...
   77:  set :lines 0                                                 mandelbrot-compute.mnd: for var lines in 0 ... DISPLAY_SIZE_LARGE do
        label *label106                                              ...
   78:  op mul *tmp32 17 :line                                       mandelbrot-compute.mnd: var x = (SKIP * line) % DISPLAY_SIZE_LARGE;
   79:  op mod :x *tmp32 176                                         ...
   80:  op add :position :x 158                                      mandelbrot-compute.mnd: var position = x + SLOTS;
   81:  read *tmp36 .memory :position                                mandelbrot-compute.mnd: if memory[position] == 0 then
   82:  jump *label42 notEqual *tmp36 0                              ...
   83:  write .PROCESSOR_ID .memory :position                        mandelbrot-compute.mnd: memory[position] = PROCESSOR_ID;
   84:  set :y 0                                                     mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
   85:  set :drawPixel:x :x                                          ...
   86:  setaddr :drawPixel*retaddr *label61                          ...
        label *label107                                              ...
   87:  op div *tmp42 :x .ZOOM                                       mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   88:  op add :compute:zx *tmp42 .OFFSET_X                          ...
   89:  op div *tmp44 :y .ZOOM                                       mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   90:  op add :compute:zy *tmp44 .OFFSET_Y                          ...
   91:  jump *label48 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   92:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
   93:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
   94:  jump *label49 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label48                                               ...
   95:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
   96:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
   97:  op sub *tmp47 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   98:  op len :compute:p *tmp47 :compute:zy                         ...
   99:  op mul *tmp49 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  100:  op mul *tmp50 *tmp49 :compute:p                              ...
  101:  op sub *tmp51 :compute:p *tmp50                              ...
  102:  op add *tmp52 *tmp51 0.25                                    ...
  103:  jump *label50 greaterThan :compute:zx *tmp52                 ...
  104:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  105:  jump *label47 always 0 0                                     ...
        label *label50                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  106:  op add *tmp55 :compute:zx 1                                  mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  107:  op len *tmp56 *tmp55 :compute:zy                             ...
  108:  jump *label52 greaterThan *tmp56 0.25                        ...
  109:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  110:  jump *label47 always 0 0                                     ...
        label *label52                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label49                                               mandelbrot-compute.mnd: if JULIA then
  111:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  112:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  113:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  114:  op mul *tmp60 :compute:zy :compute:zy                        ...
  115:  op sub *tmp61 *tmp59 *tmp60                                  ...
  116:  op add :compute:zx *tmp61 :compute:cx                        ...
  117:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  118:  op mul *tmp64 *tmp63 :compute:zy                             ...
  119:  op add :compute:zy *tmp64 :compute:cy                        ...
  120:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  121:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  122:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  123:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  124:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  125:  op mul *tmp60 :compute:zy :compute:zy                        ...
  126:  op sub *tmp61 *tmp59 *tmp60                                  ...
  127:  op add :compute:zx *tmp61 :compute:cx                        ...
  128:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  129:  op mul *tmp64 *tmp63 :compute:zy                             ...
  130:  op add :compute:zy *tmp64 :compute:cy                        ...
  131:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  132:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  133:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  134:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  135:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  136:  op mul *tmp60 :compute:zy :compute:zy                        ...
  137:  op sub *tmp61 *tmp59 *tmp60                                  ...
  138:  op add :compute:zx *tmp61 :compute:cx                        ...
  139:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  140:  op mul *tmp64 *tmp63 :compute:zy                             ...
  141:  op add :compute:zy *tmp64 :compute:cy                        ...
  142:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  143:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  144:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  145:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  146:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  147:  op mul *tmp60 :compute:zy :compute:zy                        ...
  148:  op sub *tmp61 *tmp59 *tmp60                                  ...
  149:  op add :compute:zx *tmp61 :compute:cx                        ...
  150:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  151:  op mul *tmp64 *tmp63 :compute:zy                             ...
  152:  op add :compute:zy *tmp64 :compute:cy                        ...
  153:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  154:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  155:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  156:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  157:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  158:  op mul *tmp60 :compute:zy :compute:zy                        ...
  159:  op sub *tmp61 *tmp59 *tmp60                                  ...
  160:  op add :compute:zx *tmp61 :compute:cx                        ...
  161:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  162:  op mul *tmp64 *tmp63 :compute:zy                             ...
  163:  op add :compute:zy *tmp64 :compute:cy                        ...
  164:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  165:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  166:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  167:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  168:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  169:  op mul *tmp60 :compute:zy :compute:zy                        ...
  170:  op sub *tmp61 *tmp59 *tmp60                                  ...
  171:  op add :compute:zx *tmp61 :compute:cx                        ...
  172:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  173:  op mul *tmp64 *tmp63 :compute:zy                             ...
  174:  op add :compute:zy *tmp64 :compute:cy                        ...
  175:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  176:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  177:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  178:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  179:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  180:  op mul *tmp60 :compute:zy :compute:zy                        ...
  181:  op sub *tmp61 *tmp59 *tmp60                                  ...
  182:  op add :compute:zx *tmp61 :compute:cx                        ...
  183:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  184:  op mul *tmp64 *tmp63 :compute:zy                             ...
  185:  op add :compute:zy *tmp64 :compute:cy                        ...
  186:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  187:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  188:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  189:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  190:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  191:  op mul *tmp60 :compute:zy :compute:zy                        ...
  192:  op sub *tmp61 *tmp59 *tmp60                                  ...
  193:  op add :compute:zx *tmp61 :compute:cx                        ...
  194:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  195:  op mul *tmp64 *tmp63 :compute:zy                             ...
  196:  op add :compute:zy *tmp64 :compute:cy                        ...
  197:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  198:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  199:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  200:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  201:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  202:  op mul *tmp60 :compute:zy :compute:zy                        ...
  203:  op sub *tmp61 *tmp59 *tmp60                                  ...
  204:  op add :compute:zx *tmp61 :compute:cx                        ...
  205:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  206:  op mul *tmp64 *tmp63 :compute:zy                             ...
  207:  op add :compute:zy *tmp64 :compute:cy                        ...
  208:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  209:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  210:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  211:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  212:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  213:  op mul *tmp60 :compute:zy :compute:zy                        ...
  214:  op sub *tmp61 *tmp59 *tmp60                                  ...
  215:  op add :compute:zx *tmp61 :compute:cx                        ...
  216:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  217:  op mul *tmp64 *tmp63 :compute:zy                             ...
  218:  op add :compute:zy *tmp64 :compute:cy                        ...
  219:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  220:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  221:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  222:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  223:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  224:  op mul *tmp60 :compute:zy :compute:zy                        ...
  225:  op sub *tmp61 *tmp59 *tmp60                                  ...
  226:  op add :compute:zx *tmp61 :compute:cx                        ...
  227:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  228:  op mul *tmp64 *tmp63 :compute:zy                             ...
  229:  op add :compute:zy *tmp64 :compute:cy                        ...
  230:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  231:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  232:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  233:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  234:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  235:  op mul *tmp60 :compute:zy :compute:zy                        ...
  236:  op sub *tmp61 *tmp59 *tmp60                                  ...
  237:  op add :compute:zx *tmp61 :compute:cx                        ...
  238:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  239:  op mul *tmp64 *tmp63 :compute:zy                             ...
  240:  op add :compute:zy *tmp64 :compute:cy                        ...
  241:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  242:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  243:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  244:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  245:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  246:  op mul *tmp60 :compute:zy :compute:zy                        ...
  247:  op sub *tmp61 *tmp59 *tmp60                                  ...
  248:  op add :compute:zx *tmp61 :compute:cx                        ...
  249:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  250:  op mul *tmp64 *tmp63 :compute:zy                             ...
  251:  op add :compute:zy *tmp64 :compute:cy                        ...
  252:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  253:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  254:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  255:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  256:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  257:  op mul *tmp60 :compute:zy :compute:zy                        ...
  258:  op sub *tmp61 *tmp59 *tmp60                                  ...
  259:  op add :compute:zx *tmp61 :compute:cx                        ...
  260:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  261:  op mul *tmp64 *tmp63 :compute:zy                             ...
  262:  op add :compute:zy *tmp64 :compute:cy                        ...
  263:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  264:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  265:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  266:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  267:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  268:  op mul *tmp60 :compute:zy :compute:zy                        ...
  269:  op sub *tmp61 *tmp59 *tmp60                                  ...
  270:  op add :compute:zx *tmp61 :compute:cx                        ...
  271:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  272:  op mul *tmp64 *tmp63 :compute:zy                             ...
  273:  op add :compute:zy *tmp64 :compute:cy                        ...
  274:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  275:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  276:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  277:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  278:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  279:  op mul *tmp60 :compute:zy :compute:zy                        ...
  280:  op sub *tmp61 *tmp59 *tmp60                                  ...
  281:  op add :compute:zx *tmp61 :compute:cx                        ...
  282:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  283:  op mul *tmp64 *tmp63 :compute:zy                             ...
  284:  op add :compute:zy *tmp64 :compute:cy                        ...
  285:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  286:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  287:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  288:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  289:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  290:  op mul *tmp60 :compute:zy :compute:zy                        ...
  291:  op sub *tmp61 *tmp59 *tmp60                                  ...
  292:  op add :compute:zx *tmp61 :compute:cx                        ...
  293:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  294:  op mul *tmp64 *tmp63 :compute:zy                             ...
  295:  op add :compute:zy *tmp64 :compute:cy                        ...
  296:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  297:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  298:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  299:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  300:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  301:  op mul *tmp60 :compute:zy :compute:zy                        ...
  302:  op sub *tmp61 *tmp59 *tmp60                                  ...
  303:  op add :compute:zx *tmp61 :compute:cx                        ...
  304:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  305:  op mul *tmp64 *tmp63 :compute:zy                             ...
  306:  op add :compute:zy *tmp64 :compute:cy                        ...
  307:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  308:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  309:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  310:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  311:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  312:  op mul *tmp60 :compute:zy :compute:zy                        ...
  313:  op sub *tmp61 *tmp59 *tmp60                                  ...
  314:  op add :compute:zx *tmp61 :compute:cx                        ...
  315:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  316:  op mul *tmp64 *tmp63 :compute:zy                             ...
  317:  op add :compute:zy *tmp64 :compute:cy                        ...
  318:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  319:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  320:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  321:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  322:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  323:  op mul *tmp60 :compute:zy :compute:zy                        ...
  324:  op sub *tmp61 *tmp59 *tmp60                                  ...
  325:  op add :compute:zx *tmp61 :compute:cx                        ...
  326:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  327:  op mul *tmp64 *tmp63 :compute:zy                             ...
  328:  op add :compute:zy *tmp64 :compute:cy                        ...
  329:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  330:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  331:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  332:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  333:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  334:  op mul *tmp60 :compute:zy :compute:zy                        ...
  335:  op sub *tmp61 *tmp59 *tmp60                                  ...
  336:  op add :compute:zx *tmp61 :compute:cx                        ...
  337:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  338:  op mul *tmp64 *tmp63 :compute:zy                             ...
  339:  op add :compute:zy *tmp64 :compute:cy                        ...
  340:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  341:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  342:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  343:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  344:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  345:  op mul *tmp60 :compute:zy :compute:zy                        ...
  346:  op sub *tmp61 *tmp59 *tmp60                                  ...
  347:  op add :compute:zx *tmp61 :compute:cx                        ...
  348:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  349:  op mul *tmp64 *tmp63 :compute:zy                             ...
  350:  op add :compute:zy *tmp64 :compute:cy                        ...
  351:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  352:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  353:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  354:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  355:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  356:  op mul *tmp60 :compute:zy :compute:zy                        ...
  357:  op sub *tmp61 *tmp59 *tmp60                                  ...
  358:  op add :compute:zx *tmp61 :compute:cx                        ...
  359:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  360:  op mul *tmp64 *tmp63 :compute:zy                             ...
  361:  op add :compute:zy *tmp64 :compute:cy                        ...
  362:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  363:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  364:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  365:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  366:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  367:  op mul *tmp60 :compute:zy :compute:zy                        ...
  368:  op sub *tmp61 *tmp59 *tmp60                                  ...
  369:  op add :compute:zx *tmp61 :compute:cx                        ...
  370:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  371:  op mul *tmp64 *tmp63 :compute:zy                             ...
  372:  op add :compute:zy *tmp64 :compute:cy                        ...
  373:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  374:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  375:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  376:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  377:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  378:  op mul *tmp60 :compute:zy :compute:zy                        ...
  379:  op sub *tmp61 *tmp59 *tmp60                                  ...
  380:  op add :compute:zx *tmp61 :compute:cx                        ...
  381:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  382:  op mul *tmp64 *tmp63 :compute:zy                             ...
  383:  op add :compute:zy *tmp64 :compute:cy                        ...
  384:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  385:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  386:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  387:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  388:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  389:  op mul *tmp60 :compute:zy :compute:zy                        ...
  390:  op sub *tmp61 *tmp59 *tmp60                                  ...
  391:  op add :compute:zx *tmp61 :compute:cx                        ...
  392:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  393:  op mul *tmp64 *tmp63 :compute:zy                             ...
  394:  op add :compute:zy *tmp64 :compute:cy                        ...
  395:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  396:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  397:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  398:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  399:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  400:  op mul *tmp60 :compute:zy :compute:zy                        ...
  401:  op sub *tmp61 *tmp59 *tmp60                                  ...
  402:  op add :compute:zx *tmp61 :compute:cx                        ...
  403:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  404:  op mul *tmp64 *tmp63 :compute:zy                             ...
  405:  op add :compute:zy *tmp64 :compute:cy                        ...
  406:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  407:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  408:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  409:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  410:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  411:  op mul *tmp60 :compute:zy :compute:zy                        ...
  412:  op sub *tmp61 *tmp59 *tmp60                                  ...
  413:  op add :compute:zx *tmp61 :compute:cx                        ...
  414:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  415:  op mul *tmp64 *tmp63 :compute:zy                             ...
  416:  op add :compute:zy *tmp64 :compute:cy                        ...
  417:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  418:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  419:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  420:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  421:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  422:  op mul *tmp60 :compute:zy :compute:zy                        ...
  423:  op sub *tmp61 *tmp59 *tmp60                                  ...
  424:  op add :compute:zx *tmp61 :compute:cx                        ...
  425:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  426:  op mul *tmp64 *tmp63 :compute:zy                             ...
  427:  op add :compute:zy *tmp64 :compute:cy                        ...
  428:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  429:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  430:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  431:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  432:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  433:  op mul *tmp60 :compute:zy :compute:zy                        ...
  434:  op sub *tmp61 *tmp59 *tmp60                                  ...
  435:  op add :compute:zx *tmp61 :compute:cx                        ...
  436:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  437:  op mul *tmp64 *tmp63 :compute:zy                             ...
  438:  op add :compute:zy *tmp64 :compute:cy                        ...
  439:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  440:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  441:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  442:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  443:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  444:  op mul *tmp60 :compute:zy :compute:zy                        ...
  445:  op sub *tmp61 *tmp59 *tmp60                                  ...
  446:  op add :compute:zx *tmp61 :compute:cx                        ...
  447:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  448:  op mul *tmp64 *tmp63 :compute:zy                             ...
  449:  op add :compute:zy *tmp64 :compute:cy                        ...
  450:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  451:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  452:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  453:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  454:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  455:  op mul *tmp60 :compute:zy :compute:zy                        ...
  456:  op sub *tmp61 *tmp59 *tmp60                                  ...
  457:  op add :compute:zx *tmp61 :compute:cx                        ...
  458:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  459:  op mul *tmp64 *tmp63 :compute:zy                             ...
  460:  op add :compute:zy *tmp64 :compute:cy                        ...
  461:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  462:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  463:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  464:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  465:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  466:  op mul *tmp60 :compute:zy :compute:zy                        ...
  467:  op sub *tmp61 *tmp59 *tmp60                                  ...
  468:  op add :compute:zx *tmp61 :compute:cx                        ...
  469:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  470:  op mul *tmp64 *tmp63 :compute:zy                             ...
  471:  op add :compute:zy *tmp64 :compute:cy                        ...
  472:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  473:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  474:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  475:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  476:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  477:  op mul *tmp60 :compute:zy :compute:zy                        ...
  478:  op sub *tmp61 *tmp59 *tmp60                                  ...
  479:  op add :compute:zx *tmp61 :compute:cx                        ...
  480:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  481:  op mul *tmp64 *tmp63 :compute:zy                             ...
  482:  op add :compute:zy *tmp64 :compute:cy                        ...
  483:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  484:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  485:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  486:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  487:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  488:  op mul *tmp60 :compute:zy :compute:zy                        ...
  489:  op sub *tmp61 *tmp59 *tmp60                                  ...
  490:  op add :compute:zx *tmp61 :compute:cx                        ...
  491:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  492:  op mul *tmp64 *tmp63 :compute:zy                             ...
  493:  op add :compute:zy *tmp64 :compute:cy                        ...
  494:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  495:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  496:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  497:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  498:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  499:  op mul *tmp60 :compute:zy :compute:zy                        ...
  500:  op sub *tmp61 *tmp59 *tmp60                                  ...
  501:  op add :compute:zx *tmp61 :compute:cx                        ...
  502:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  503:  op mul *tmp64 *tmp63 :compute:zy                             ...
  504:  op add :compute:zy *tmp64 :compute:cy                        ...
  505:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  506:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  507:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  508:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  509:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  510:  op mul *tmp60 :compute:zy :compute:zy                        ...
  511:  op sub *tmp61 *tmp59 *tmp60                                  ...
  512:  op add :compute:zx *tmp61 :compute:cx                        ...
  513:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  514:  op mul *tmp64 *tmp63 :compute:zy                             ...
  515:  op add :compute:zy *tmp64 :compute:cy                        ...
  516:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  517:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  518:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  519:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  520:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  521:  op mul *tmp60 :compute:zy :compute:zy                        ...
  522:  op sub *tmp61 *tmp59 *tmp60                                  ...
  523:  op add :compute:zx *tmp61 :compute:cx                        ...
  524:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  525:  op mul *tmp64 *tmp63 :compute:zy                             ...
  526:  op add :compute:zy *tmp64 :compute:cy                        ...
  527:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  528:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  529:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  530:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  531:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  532:  op mul *tmp60 :compute:zy :compute:zy                        ...
  533:  op sub *tmp61 *tmp59 *tmp60                                  ...
  534:  op add :compute:zx *tmp61 :compute:cx                        ...
  535:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  536:  op mul *tmp64 *tmp63 :compute:zy                             ...
  537:  op add :compute:zy *tmp64 :compute:cy                        ...
  538:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  539:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  540:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  541:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  542:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  543:  op mul *tmp60 :compute:zy :compute:zy                        ...
  544:  op sub *tmp61 *tmp59 *tmp60                                  ...
  545:  op add :compute:zx *tmp61 :compute:cx                        ...
  546:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  547:  op mul *tmp64 *tmp63 :compute:zy                             ...
  548:  op add :compute:zy *tmp64 :compute:cy                        ...
  549:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  550:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  551:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  552:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  553:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  554:  op mul *tmp60 :compute:zy :compute:zy                        ...
  555:  op sub *tmp61 *tmp59 *tmp60                                  ...
  556:  op add :compute:zx *tmp61 :compute:cx                        ...
  557:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  558:  op mul *tmp64 *tmp63 :compute:zy                             ...
  559:  op add :compute:zy *tmp64 :compute:cy                        ...
  560:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  561:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  562:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  563:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  564:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  565:  op mul *tmp60 :compute:zy :compute:zy                        ...
  566:  op sub *tmp61 *tmp59 *tmp60                                  ...
  567:  op add :compute:zx *tmp61 :compute:cx                        ...
  568:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  569:  op mul *tmp64 *tmp63 :compute:zy                             ...
  570:  op add :compute:zy *tmp64 :compute:cy                        ...
  571:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  572:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  573:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  574:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  575:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  576:  op mul *tmp60 :compute:zy :compute:zy                        ...
  577:  op sub *tmp61 *tmp59 *tmp60                                  ...
  578:  op add :compute:zx *tmp61 :compute:cx                        ...
  579:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  580:  op mul *tmp64 *tmp63 :compute:zy                             ...
  581:  op add :compute:zy *tmp64 :compute:cy                        ...
  582:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  583:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  584:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  585:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  586:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  587:  op mul *tmp60 :compute:zy :compute:zy                        ...
  588:  op sub *tmp61 *tmp59 *tmp60                                  ...
  589:  op add :compute:zx *tmp61 :compute:cx                        ...
  590:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  591:  op mul *tmp64 *tmp63 :compute:zy                             ...
  592:  op add :compute:zy *tmp64 :compute:cy                        ...
  593:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  594:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  595:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  596:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  597:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  598:  op mul *tmp60 :compute:zy :compute:zy                        ...
  599:  op sub *tmp61 *tmp59 *tmp60                                  ...
  600:  op add :compute:zx *tmp61 :compute:cx                        ...
  601:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  602:  op mul *tmp64 *tmp63 :compute:zy                             ...
  603:  op add :compute:zy *tmp64 :compute:cy                        ...
  604:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  605:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  606:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  607:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  608:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  609:  op mul *tmp60 :compute:zy :compute:zy                        ...
  610:  op sub *tmp61 *tmp59 *tmp60                                  ...
  611:  op add :compute:zx *tmp61 :compute:cx                        ...
  612:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  613:  op mul *tmp64 *tmp63 :compute:zy                             ...
  614:  op add :compute:zy *tmp64 :compute:cy                        ...
  615:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  616:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  617:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  618:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  619:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  620:  op mul *tmp60 :compute:zy :compute:zy                        ...
  621:  op sub *tmp61 *tmp59 *tmp60                                  ...
  622:  op add :compute:zx *tmp61 :compute:cx                        ...
  623:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  624:  op mul *tmp64 *tmp63 :compute:zy                             ...
  625:  op add :compute:zy *tmp64 :compute:cy                        ...
  626:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  627:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  628:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  629:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  630:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  631:  op mul *tmp60 :compute:zy :compute:zy                        ...
  632:  op sub *tmp61 *tmp59 *tmp60                                  ...
  633:  op add :compute:zx *tmp61 :compute:cx                        ...
  634:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  635:  op mul *tmp64 *tmp63 :compute:zy                             ...
  636:  op add :compute:zy *tmp64 :compute:cy                        ...
  637:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  638:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  639:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  640:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  641:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  642:  op mul *tmp60 :compute:zy :compute:zy                        ...
  643:  op sub *tmp61 *tmp59 *tmp60                                  ...
  644:  op add :compute:zx *tmp61 :compute:cx                        ...
  645:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  646:  op mul *tmp64 *tmp63 :compute:zy                             ...
  647:  op add :compute:zy *tmp64 :compute:cy                        ...
  648:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  649:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  650:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  651:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  652:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  653:  op mul *tmp60 :compute:zy :compute:zy                        ...
  654:  op sub *tmp61 *tmp59 *tmp60                                  ...
  655:  op add :compute:zx *tmp61 :compute:cx                        ...
  656:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  657:  op mul *tmp64 *tmp63 :compute:zy                             ...
  658:  op add :compute:zy *tmp64 :compute:cy                        ...
  659:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  660:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  661:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  662:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  663:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  664:  op mul *tmp60 :compute:zy :compute:zy                        ...
  665:  op sub *tmp61 *tmp59 *tmp60                                  ...
  666:  op add :compute:zx *tmp61 :compute:cx                        ...
  667:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  668:  op mul *tmp64 *tmp63 :compute:zy                             ...
  669:  op add :compute:zy *tmp64 :compute:cy                        ...
  670:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  671:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  672:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  673:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  674:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  675:  op mul *tmp60 :compute:zy :compute:zy                        ...
  676:  op sub *tmp61 *tmp59 *tmp60                                  ...
  677:  op add :compute:zx *tmp61 :compute:cx                        ...
  678:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  679:  op mul *tmp64 *tmp63 :compute:zy                             ...
  680:  op add :compute:zy *tmp64 :compute:cy                        ...
  681:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  682:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  683:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  684:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  685:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  686:  op mul *tmp60 :compute:zy :compute:zy                        ...
  687:  op sub *tmp61 *tmp59 *tmp60                                  ...
  688:  op add :compute:zx *tmp61 :compute:cx                        ...
  689:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  690:  op mul *tmp64 *tmp63 :compute:zy                             ...
  691:  op add :compute:zy *tmp64 :compute:cy                        ...
  692:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  693:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  694:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  695:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  696:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  697:  op mul *tmp60 :compute:zy :compute:zy                        ...
  698:  op sub *tmp61 *tmp59 *tmp60                                  ...
  699:  op add :compute:zx *tmp61 :compute:cx                        ...
  700:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  701:  op mul *tmp64 *tmp63 :compute:zy                             ...
  702:  op add :compute:zy *tmp64 :compute:cy                        ...
  703:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  704:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  705:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  706:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  707:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  708:  op mul *tmp60 :compute:zy :compute:zy                        ...
  709:  op sub *tmp61 *tmp59 *tmp60                                  ...
  710:  op add :compute:zx *tmp61 :compute:cx                        ...
  711:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  712:  op mul *tmp64 *tmp63 :compute:zy                             ...
  713:  op add :compute:zy *tmp64 :compute:cy                        ...
  714:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  715:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  716:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  717:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  718:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  719:  op mul *tmp60 :compute:zy :compute:zy                        ...
  720:  op sub *tmp61 *tmp59 *tmp60                                  ...
  721:  op add :compute:zx *tmp61 :compute:cx                        ...
  722:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  723:  op mul *tmp64 *tmp63 :compute:zy                             ...
  724:  op add :compute:zy *tmp64 :compute:cy                        ...
  725:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  726:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  727:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  728:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  729:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  730:  op mul *tmp60 :compute:zy :compute:zy                        ...
  731:  op sub *tmp61 *tmp59 *tmp60                                  ...
  732:  op add :compute:zx *tmp61 :compute:cx                        ...
  733:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  734:  op mul *tmp64 *tmp63 :compute:zy                             ...
  735:  op add :compute:zy *tmp64 :compute:cy                        ...
  736:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  737:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  738:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  739:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  740:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  741:  op mul *tmp60 :compute:zy :compute:zy                        ...
  742:  op sub *tmp61 *tmp59 *tmp60                                  ...
  743:  op add :compute:zx *tmp61 :compute:cx                        ...
  744:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  745:  op mul *tmp64 *tmp63 :compute:zy                             ...
  746:  op add :compute:zy *tmp64 :compute:cy                        ...
  747:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  748:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  749:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  750:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  751:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  752:  op mul *tmp60 :compute:zy :compute:zy                        ...
  753:  op sub *tmp61 *tmp59 *tmp60                                  ...
  754:  op add :compute:zx *tmp61 :compute:cx                        ...
  755:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  756:  op mul *tmp64 *tmp63 :compute:zy                             ...
  757:  op add :compute:zy *tmp64 :compute:cy                        ...
  758:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  759:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  760:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  761:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  762:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  763:  op mul *tmp60 :compute:zy :compute:zy                        ...
  764:  op sub *tmp61 *tmp59 *tmp60                                  ...
  765:  op add :compute:zx *tmp61 :compute:cx                        ...
  766:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  767:  op mul *tmp64 *tmp63 :compute:zy                             ...
  768:  op add :compute:zy *tmp64 :compute:cy                        ...
  769:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  770:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  771:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  772:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  773:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  774:  op mul *tmp60 :compute:zy :compute:zy                        ...
  775:  op sub *tmp61 *tmp59 *tmp60                                  ...
  776:  op add :compute:zx *tmp61 :compute:cx                        ...
  777:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  778:  op mul *tmp64 *tmp63 :compute:zy                             ...
  779:  op add :compute:zy *tmp64 :compute:cy                        ...
  780:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  781:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  782:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  783:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  784:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  785:  op mul *tmp60 :compute:zy :compute:zy                        ...
  786:  op sub *tmp61 *tmp59 *tmp60                                  ...
  787:  op add :compute:zx *tmp61 :compute:cx                        ...
  788:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  789:  op mul *tmp64 *tmp63 :compute:zy                             ...
  790:  op add :compute:zy *tmp64 :compute:cy                        ...
  791:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  792:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  793:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  794:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  795:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  796:  op mul *tmp60 :compute:zy :compute:zy                        ...
  797:  op sub *tmp61 *tmp59 *tmp60                                  ...
  798:  op add :compute:zx *tmp61 :compute:cx                        ...
  799:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  800:  op mul *tmp64 *tmp63 :compute:zy                             ...
  801:  op add :compute:zy *tmp64 :compute:cy                        ...
  802:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  803:  jump *label56 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  804:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label56                                               ...
  805:  op mul *tmp69 .SMOOTH 63                                     mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  806:  jump *label59 greaterThanEq :compute:i *tmp69                ...
  807:  op log *tmp72 :compute:dist 0                                mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  808:  op mul *tmp73 *tmp72 0.36067376022224085                     ...
  809:  op log *tmp74 *tmp73 0                                       ...
  810:  op mul *tmp75 *tmp74 1.4426950408889634                      ...
  811:  op sub :compute:correction 4 *tmp75                          ...
  812:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label59                                               mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  813:  set *tmp41 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label47                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  814:  set :drawPixel:y :y                                          mandelbrot-compute.mnd: drawPixel(x, y, iterations);
  815:  set :drawPixel:iterations *tmp41                             ...
  816:  call *label0 *invalid :drawPixel*retval                      ...
        label *label61                                               ...
  817:  read *tmp78 .memory :position                                mandelbrot-compute.mnd: if memory[position] != PROCESSOR_ID then
  818:  jump *label46 notEqual *tmp78 .PROCESSOR_ID                  ...
  819:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: if stop != $STOP then
  820:  jump *label31 notEqual .stop *tmp1                           ...
  821:  op add :y :y 1                                               mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
  822:  jump *label107 lessThan :y 176                               ...
        label *label46                                               ...
        label *label42                                               mandelbrot-compute.mnd: if memory[position] == 0 then
  823:  op add :line :line :increment                                mandelbrot-compute.mnd: line += increment;
  824:  jump *label66 lessThanEq :line 176                           mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  825:  op div :next_increment :next_increment 2                     mandelbrot-compute.mnd: increment = next_increment /= 2;
  826:  set :increment :next_increment                               ...
  827:  op div :line :next_increment 2                               mandelbrot-compute.mnd: line = increment / 2;
        label *label66                                               mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  828:  op add :lines :lines 1                                       mandelbrot-compute.mnd: for var lines in 0 ... DISPLAY_SIZE_LARGE do
  829:  jump *label106 lessThan :lines 176                           ...
        label *label337                                              mandelbrot-compute.mnd: do while !display.@enabled;
  830:  sensor *tmp144 .display @enabled                             ...
  831:  jump *label337 equal *tmp144 false                           ...
  832:  jump *label343 lessThanEq .localBuffer 4                     mandelbrot-compute.mnd: if localBuffer > 4 then
        label *label340                                              mandelbrot-compute.mnd: do
  833:  wait 0.0001                                                  mandelbrot-compute.mnd: wait(1e-4);
  834:  sensor *tmp148 .display @bufferSize                          mandelbrot-compute.mnd: while display.@bufferSize > 250;
  835:  jump *label340 greaterThan *tmp148 250                       mandelbrot-compute.mnd: do
        label *label343                                              mandelbrot-compute.mnd: if localBuffer > 4 then
  836:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  837:  jump *label31 always 0 0                                     mandelbrot-compute.mnd: MainLoop:
        label *label0                                                mandelbrot-compute.mnd: noinline void drawPixel(x, y, iterations)
  838:  jump *label70 equal .SMOOTH false                            mandelbrot-compute.mnd: if SMOOTH then
  839:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  840:  jump *label71 equal :drawPixel:iterations 63                 mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  841:  multijump .PALETTE 0 0                                       mandelbrot-compute.mnd: case PALETTE
        multilabel *label382                                         ...
        multilabel *label378                                         ...
  842:  op div *tmp126 :drawPixel:iterations 63.75                   mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  843:  op sub :drawPixel:r 1 *tmp126                                ...
  844:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  845:  jump *label71 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label379                                         ...
  846:  op sub *tmp91 32 :drawPixel:iterations                       mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  847:  op abs *tmp92 *tmp91 0                                       ...
  848:  op div *tmp94 *tmp92 36.42857142857143                       ...
  849:  op sub :drawPixel:r 1 *tmp94                                 ...
  850:  op sub *tmp96 :drawPixel:iterations 32                       mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  851:  op abs *tmp97 *tmp96 0                                       ...
  852:  op div *tmp99 *tmp97 42.5                                    ...
  853:  op sub :drawPixel:g 0.9411764705882353 *tmp99                ...
  854:  op div *tmp104 *tmp92 63.75                                  mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  855:  op add :drawPixel:b 0.47058823529411764 *tmp104              ...
  856:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  857:  jump *label71 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label380                                         ...
  858:  op div *tmp108 :drawPixel:iterations 0.175                   mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  859:  op sin :drawPixel:r *tmp108 0                                ...
  860:  op cos :drawPixel:g *tmp108 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  861:  op sub *tmp113 :drawPixel:iterations 32                      mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  862:  op abs *tmp114 *tmp113 0                                     ...
  863:  op div *tmp116 *tmp114 63.75                                 ...
  864:  op add :drawPixel:b 0.39215686274509803 *tmp116              ...
  865:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  866:  jump *label71 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label381                                         ...
  867:  op div :drawPixel:r :drawPixel:iterations 63.75              mandelbrot-compute.mnd: r = 4 * iterations / 255;
  868:  op div *tmp122 :drawPixel:iterations 170                     mandelbrot-compute.mnd: g = 96 + 1.5 * iterations / 255;
  869:  op add :drawPixel:g 96 *tmp122                               ...
  870:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  871:  jump *label71 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label70                                               ...
  872:  read :drawPixel:color .memory :drawPixel:iterations          mandelbrot-compute.mnd: color = memory[iterations];
        label *label71                                               mandelbrot-compute.mnd: if SMOOTH then
  873:  jump *label81 lessThan .localBuffer 254                      mandelbrot-compute.mnd: if localBuffer >= 254 then
        label *label347                                              mandelbrot-compute.mnd: do while !display.@enabled;
  874:  sensor *tmp144 .display @enabled                             ...
  875:  jump *label347 equal *tmp144 false                           ...
  876:  jump *label353 lessThanEq .localBuffer 4                     mandelbrot-compute.mnd: if localBuffer > 4 then
        label *label350                                              mandelbrot-compute.mnd: do
  877:  wait 0.0001                                                  mandelbrot-compute.mnd: wait(1e-4);
  878:  sensor *tmp148 .display @bufferSize                          mandelbrot-compute.mnd: while display.@bufferSize > 250;
  879:  jump *label350 greaterThan *tmp148 250                       mandelbrot-compute.mnd: do
        label *label353                                              mandelbrot-compute.mnd: if localBuffer > 4 then
  880:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  881:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
        label *label81                                               mandelbrot-compute.mnd: if localBuffer >= 254 then
  882:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  883:  draw rect :drawPixel:x :drawPixel:y 1 1 0 0                  mandelbrot-compute.mnd: rect(x, y, 1, 1);
  884:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
  885:  sensor *tmp134 .display @enabled                             mandelbrot-compute.mnd: var disabled = 1 - display.enabled;
  886:  op sub :drawPixel:disabled 1 *tmp134                         ...
  887:  sensor *tmp136 .display @bufferSize                          mandelbrot-compute.mnd: var usage = display.@bufferSize + disabled * 900;
  888:  op mul *tmp137 :drawPixel:disabled 900                       ...
  889:  op add :drawPixel:usage *tmp136 *tmp137                      ...
  890:  jump *label84 greaterThanEq :drawPixel:usage 100             mandelbrot-compute.mnd: if usage < 100 then
  891:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  892:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
  893:  return :drawPixel*retaddr                                    mandelbrot-compute.mnd: if usage < 100 then
        label *label84                                               ...
  894:  op div *tmp141 1800 .localBuffer                             mandelbrot-compute.mnd: elsif usage < 1800 / localBuffer then
  895:  jump *label86 greaterThanEq :drawPixel:usage *tmp141         ...
  896:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  897:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
        label *label86                                               mandelbrot-compute.mnd: elsif usage < 1800 / localBuffer then
  898:  return :drawPixel*retaddr                                    mandelbrot-compute.mnd: noinline void drawPixel(x, y, iterations)


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   727     1x    727,0  def compute(in x, in y)
    56     1x     56,0  <no function>
    54     1x     54,0  noinline void drawPixel(in x, in y, in iterations)
    26     2x     13,0  void setState(in state)
    22     1x     22,0  inline void findLinkedBlocks(in title, in message, in linkMap...)
    15     2x      7,5  void flushLocalBuffer()

Performance: parsed in 302 ms, compiled in 305 ms, optimized in 1,884 ms, run in 47 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Display: display
Memory: bank
Execution step limit of 100000 exceeded.
