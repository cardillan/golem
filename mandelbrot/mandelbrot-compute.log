   422 instructions before optimizations.
    40 instructions eliminated by Temp Variables Elimination (8 iterations).
     2 instructions eliminated by Case Expression Optimization.
    48 instructions eliminated by Dead Code Elimination (7 iterations).
     6 instructions eliminated by Jump Normalization (2 passes, 8 iterations).
    22 instructions eliminated by Condition Optimization (2 passes, 10 iterations).
    21 instructions eliminated by Single Step Elimination (2 passes, 10 iterations).
     4 instructions eliminated by Expression Optimization (2 passes, 5 iterations).
     3 instructions eliminated by Boolean Optimization (2 passes, 10 iterations).
       3 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by If Expression Optimization (5 iterations).
    55 instructions eliminated by Data Flow Optimization (6 passes, 24 iterations).
       5 loop conditions were partially rotated.
   741 instructions added by Loop Unrolling (11 iterations).
     4 loops unrolled by Loop Unrolling.
     9 instructions eliminated by Case Switching (11 iterations).
     2 case expressions converted to fast dispatch by Case Switching.
    69 instructions eliminated by Jump Straightening (2 passes, 10 iterations).
     9 instructions updated by Jump Threading.
     2 instructions eliminated by Unreachable Code Elimination (2 passes, 3 iterations).
     7 instructions eliminated by Print Merging.
   874 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 760):
    Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity
  * Unroll iteration loop at *blocks:68:13                       size    -9, benefit     9375.0, efficiency   Infinity (-3 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
    Fast-dispatch case at mandelbrot-compute.mnd:82:25           size    -8, benefit     6250.0, efficiency   Infinity
    Fast-dispatch case at mandelbrot-compute.mnd:158:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 763):
  * Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:82:25           size    -8, benefit     6250.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:158:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 767):
  * Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity (-2 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:82:25           size    -8, benefit     6250.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:158:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 769):
  * Fast-dispatch case at mandelbrot-compute.mnd:82:25           size    -8, benefit     6250.0, efficiency   Infinity (-7 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:158:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 776):
  * Fast-dispatch case at mandelbrot-compute.mnd:158:13          size    -2, benefit     3906.3, efficiency   Infinity (-2 instructions)

Pass 2: speed optimization selection (cost limit 787):
  * Unroll loop at mandelbrot-compute.mnd:131:5                  size  +679, benefit 49218750.0, efficiency  72487.113 (+743 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
   170 label *label39
   171 set *tmp45 null
   172 label *label40
-    * set *tmp47 :batch
-    * jump *label44 lessThan *tmp47 0
-    * jump *label43 lessThan *tmp47 22
+  173 jump *label44 lessThan :batch 0
+  174 jump *label43 lessThan :batch 22
   175 label *label44
   176 jump *label42 always
   177 label *label43
 
   179 set *tmp46 *tmp48
   180 jump *label41 always
   181 label *label42
-    * jump *label47 lessThan *tmp47 22
-    * jump *label46 lessThan *tmp47 44
+  182 jump *label47 lessThan :batch 22
+  183 jump *label46 lessThan :batch 44
   184 label *label47
   185 jump *label45 always
   186 label *label46
 
   190 set *tmp46 *tmp51
   191 jump *label41 always
   192 label *label45
-    * jump *label50 lessThan *tmp47 44
-    * jump *label49 lessThan *tmp47 88
+  193 jump *label50 lessThan :batch 44
+  194 jump *label49 lessThan :batch 88
   195 label *label50
   196 jump *label48 always
   197 label *label49
 
   323 set *tmp100 :drawPixel:color
   324 jump *label74 always
   325 label *label73
-    * set *tmp102 .PALETTE
-    * jump *label77 equal *tmp102 2
+  326 jump *label77 equal .PALETTE 2
   327 jump *label76 always
   328 label *label77
   329 op sub *tmp103 32 :drawPixel:iterations
 
   349 set *tmp101 :drawPixel:color
   350 jump *label75 always
   351 label *label76
-    * jump *label79 equal *tmp102 3
+  352 jump *label79 equal .PALETTE 3
   353 jump *label78 always
   354 label *label79
   355 op div *tmp119 :drawPixel:iterations 63
 
   371 set *tmp101 :drawPixel:color
   372 jump *label75 always
   373 label *label78
-    * jump *label81 equal *tmp102 4
+  374 jump *label81 equal .PALETTE 4
   375 jump *label80 always
   376 label *label81
   377 op mul *tmp131 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-31 instructions):
 
    58 label *label19
    59 set *tmp19 null
    60 label *label20
-    * set *tmp17 *tmp19
    61 jump *label18 always
    62 label *label17
-    * set *tmp17 null
    63 label *label18
    64 label *label13
    65 multijump *tmp15 0 0 (m:marker1)
 
    91 print :findLinkedBlocks:variable
    92 jump *label26 equal :findLinkedBlocks:required false
    93 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * set *tmp21 :findLinkedBlocks:foundAll
    94 jump *label27 always
    95 label *label26
-    * set *tmp21 null
    96 label *label27
    97 label *label22
    98 multijump *tmp20 0 0 (m:marker2)
 
   148 op notEqual *tmp39 .stop *tmp40
   149 jump *label37 equal *tmp39 false
   150 jump *label29 always
-    * set *tmp41 null
   151 jump *label38 always
   152 label *label37
-    * set *tmp41 null
   153 label *label38
   154 read *tmp42 .memory 64
   155 set *tmp43 *tmp42
 
   159 op greaterThanEq *tmp44 :batch 2816
   160 jump *label39 equal *tmp44 false
   161 jump *label36 always
-    * set *tmp45 null
   162 jump *label40 always
   163 label *label39
-    * set *tmp45 null
   164 label *label40
   165 jump *label44 lessThan :batch 0
   166 jump *label43 lessThan :batch 22
 
   220 jump *label55 equal .JULIA false
   221 set :compute:cx .JULIA_X
   222 set :compute:cy .JULIA_Y
-    * set *tmp68 :compute:cy
   223 jump *label56 always
   224 label *label55
   225 set :compute:cx :compute:zx
 
   235 jump *label57 equal *tmp75 false
   236 set *tmp63 63
   237 jump *label54 always
-    * set *tmp76 null
   238 jump *label58 always
   239 label *label57
-    * set *tmp76 null
   240 label *label58
   241 op add *tmp77 :compute:cx 1
   242 op len *tmp78 *tmp77 :compute:cy
 
   249 label *label59
   250 set *tmp80 null
   251 label *label60
-    * set *tmp68 *tmp80
   252 label *label56
   253 set :compute:i 0
   254 label *label61
 
   269 op greaterThanEq *tmp89 :compute:dist 64
   270 jump *label64 equal *tmp89 false
   271 jump *label63 always
-    * set *tmp90 null
   272 jump *label65 always
   273 label *label64
-    * set *tmp90 null
   274 label *label65
   275 label *label62
   276 op add :compute:i :compute:i 1
 
   289 op sub *tmp97 4 *tmp96
   290 set :compute:correction *tmp97
   291 op add :compute:i :compute:i :compute:correction
-    * set *tmp92 :compute:i
   292 jump *label67 always
   293 label *label66
-    * set *tmp92 null
   294 label *label67
   295 set *tmp63 :compute:i
   296 jump *label54 always
 
   380 label *label75
   381 set *tmp100 *tmp101
   382 label *label74
-    * set *tmp98 *tmp100
   383 jump *label72 always
   384 label *label71
   385 set *tmp141 :drawPixel:iterations
   386 read *tmp143 .memory *tmp141
   387 set :drawPixel:color *tmp143
-    * set *tmp98 :drawPixel:color
   388 label *label72
   389 op greaterThanEq *tmp144 .localBuffer 254
   390 jump *label82 equal *tmp144 false
 
   405 label *label91
   406 set *tmp152 null
   407 label *label92
-    * set *tmp148 *tmp152
   408 jump *label90 always
   409 label *label89
-    * set *tmp148 null
   410 label *label90
   411 label *label88
   412 label *label86
   413 jump *label85 always
   414 label *label87
   415 label *label84
-    * set *tmp145 null
   416 jump *label83 always
   417 label *label82
-    * set *tmp145 null
   418 label *label83
   419 op greaterThan *tmp153 .localBuffer 0
   420 jump *label93 equal *tmp153 false
 
   426 draw rect :drawPixel:x :drawPixel:y 1 1
   427 set *tmp156 .localBuffer
   428 op add .localBuffer .localBuffer 1
-    * set *tmp155 *tmp156
   429 jump *label94 always
   430 label *label93
   431 draw col :drawPixel:color
   432 draw rect :drawPixel:x :drawPixel:y 1 1
   433 set .lastColor :drawPixel:color
   434 op add .localBuffer .localBuffer 2
-    * set *tmp155 .localBuffer
   435 label *label94
   436 wait 0
   437 sensor *tmp157 .display @enabled
 
   447 label *label100
   448 set *tmp162 null
   449 label *label101
-    * set *tmp158 *tmp162
   450 jump *label99 always
   451 label *label98
-    * set *tmp158 null
   452 label *label99
   453 label *label97
   454 label *label70
   455 wait 0
   456 read *tmp163 .memory 65
-    * set *tmp164 *tmp163
   457 op add *tmp1 *tmp163 1
   458 write *tmp1 .memory 65
   459 read *tmp166 .memory 67
   460 op notEqual *tmp165 .stop *tmp166
   461 jump *label102 equal *tmp165 false
   462 jump *label29 always
-    * set *tmp167 null
   463 jump *label103 always
   464 label *label102
-    * set *tmp167 null
   465 label *label103
   466 label *label52
   467 op add :i :i 1
 
   484 label *label111
   485 set *tmp174 null
   486 label *label112
-    * set *tmp170 *tmp174
   487 jump *label110 always
   488 label *label109
-    * set *tmp170 null
   489 label *label110
   490 label *label108
   491 label *label106

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-13 instructions):
 
    53 op equal *tmp18 :findLinkedBlocks:requested @message
    54 jump *label19 equal *tmp18 false
    55 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * set *tmp19 :findLinkedBlocks:message
    56 jump *label20 always
    57 label *label19
-    * set *tmp19 null
    58 label *label20
    59 jump *label18 always
    60 label *label17
 
   242 jump *label59 equal *tmp79 false
   243 set *tmp63 63
   244 jump *label54 always
-    * set *tmp80 null
   245 jump *label60 always
   246 label *label59
-    * set *tmp80 null
   247 label *label60
   248 label *label56
   249 set :compute:i 0
 
   300 op equal *tmp99 :drawPixel:iterations 63
   301 jump *label73 equal *tmp99 false
   302 set :drawPixel:color %[black]
-    * set *tmp100 :drawPixel:color
   303 jump *label74 always
   304 label *label73
   305 jump *label77 equal .PALETTE 2
 
   373 set :drawPixel:color *tmp140
   374 set *tmp101 :drawPixel:color
   375 label *label75
-    * set *tmp100 *tmp101
   376 label *label74
   377 jump *label72 always
   378 label *label71
 
   394 jump *label91 equal *tmp151 false
   395 drawflush .display
   396 set .localBuffer 0
-    * set *tmp152 .localBuffer
   397 jump *label92 always
   398 label *label91
-    * set *tmp152 null
   399 label *label92
   400 jump *label90 always
   401 label *label89
 
   416 jump *label95 always
   417 label *label95
   418 draw rect :drawPixel:x :drawPixel:y 1 1
-    * set *tmp156 .localBuffer
   419 op add .localBuffer .localBuffer 1
   420 jump *label94 always
   421 label *label93
 
   433 jump *label100 equal *tmp161 false
   434 drawflush .display
   435 set .localBuffer 0
-    * set *tmp162 .localBuffer
   436 jump *label101 always
   437 label *label100
-    * set *tmp162 null
   438 label *label101
   439 jump *label99 always
   440 label *label98
 
   468 jump *label111 equal *tmp173 false
   469 drawflush .display
   470 set .localBuffer 0
-    * set *tmp174 .localBuffer
   471 jump *label112 always
   472 label *label111
-    * set *tmp174 null
   473 label *label112
   474 jump *label110 always
   475 label *label109

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   325 set :drawPixel:b *tmp117
   326 packcolor *tmp118 :drawPixel:r :drawPixel:g :drawPixel:b 1
   327 set :drawPixel:color *tmp118
-    * set *tmp101 :drawPixel:color
   328 jump *label75 always
   329 label *label76
   330 jump *label79 equal .PALETTE 3
 
   346 set :drawPixel:b *tmp129
   347 packcolor *tmp130 :drawPixel:r :drawPixel:g :drawPixel:b 1
   348 set :drawPixel:color *tmp130
-    * set *tmp101 :drawPixel:color
   349 jump *label75 always
   350 label *label78
   351 jump *label81 equal .PALETTE 4
 
   360 set :drawPixel:g *tmp135
   361 packcolor *tmp136 :drawPixel:r :drawPixel:g 0 1
   362 set :drawPixel:color *tmp136
-    * set *tmp101 :drawPixel:color
   363 jump *label75 always
   364 label *label80
   365 op mul *tmp137 4 :drawPixel:iterations
 
   368 set :drawPixel:r *tmp139
   369 packcolor *tmp140 :drawPixel:r :drawPixel:r 0 1
   370 set :drawPixel:color *tmp140
-    * set *tmp101 :drawPixel:color
   371 label *label75
   372 label *label74
   373 jump *label72 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-40 instructions):
 
    27 op greaterThan *tmp12 :findLinkedBlocks:n 0
    28 jump *label11 equal *tmp12 false
    29 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
-    * getlink *tmp13 :findLinkedBlocks:n
-    * set :findLinkedBlocks:block *tmp13
+   30 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    31 print "\nFound: "
    32 print :findLinkedBlocks:block
-    * sensor *tmp14 :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:type *tmp14
+   33 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    34 set :findLinkedBlocks:requested @large-logic-display
    35 set :findLinkedBlocks:name "Display"
    36 set :findLinkedBlocks:variable .display
 
   110 op equal *tmp23 .start *tmp24
   111 jump *label31 notEqual *tmp23 false
   112 label *label33
-    * read *tmp25 .memory 66
-    * set .start *tmp25
-    * read *tmp26 .memory 67
-    * set .stop *tmp26
+  113 read .start .memory 66
+  114 read .stop .memory 67
   115 set .lastColor -1
   116 set .localBuffer 0
   117 drawflush null
-    * read *tmp27 .memory 70
-    * set .ZOOM *tmp27
+  118 read .ZOOM .memory 70
   119 op div *tmp28 -88 .ZOOM
   120 read *tmp30 .memory 68
-    * op add *tmp29 *tmp28 *tmp30
-    * set .OFFSET_X *tmp29
+  121 op add .OFFSET_X *tmp28 *tmp30
   122 op div *tmp31 -88 .ZOOM
   123 read *tmp33 .memory 69
-    * op add *tmp32 *tmp31 *tmp33
-    * set .OFFSET_Y *tmp32
-    * read *tmp34 .memory 71
-    * set .JULIA *tmp34
-    * read *tmp35 .memory 72
-    * set .JULIA_X *tmp35
-    * read *tmp36 .memory 73
-    * set .JULIA_Y *tmp36
-    * read *tmp37 .memory 74
-    * set .PALETTE *tmp37
-    * op greaterThan *tmp38 .PALETTE 1
-    * set .SMOOTH *tmp38
+  124 op add .OFFSET_Y *tmp31 *tmp33
+  125 read .JULIA .memory 71
+  126 read .JULIA_X .memory 72
+  127 read .JULIA_Y .memory 73
+  128 read .PALETTE .memory 74
+  129 op greaterThan .SMOOTH .PALETTE 1
   130 label *label34
   131 jump *label36 equal true false
   132 wait 0
 
   153 label *label44
   154 jump *label42 always
   155 label *label43
-    * op mul *tmp48 8 :batch
-    * set *tmp46 *tmp48
+  156 op mul *tmp46 8 :batch
   157 jump *label41 always
   158 label *label42
   159 jump *label47 lessThan :batch 22
 
   163 label *label46
   164 op mul *tmp49 8 :batch
   165 op sub *tmp50 *tmp49 176
-    * op add *tmp51 *tmp50 4
-    * set *tmp46 *tmp51
+  166 op add *tmp46 *tmp50 4
   167 jump *label41 always
   168 label *label45
   169 jump *label50 lessThan :batch 44
 
   173 label *label49
   174 op mul *tmp52 4 :batch
   175 op sub *tmp53 *tmp52 176
-    * op add *tmp54 *tmp53 2
-    * set *tmp46 *tmp54
+  176 op add *tmp46 *tmp53 2
   177 jump *label41 always
   178 label *label48
   179 op mul *tmp55 2 :batch
   180 op sub *tmp56 *tmp55 176
-    * op add *tmp57 *tmp56 1
-    * set *tmp46 *tmp57
+  181 op add *tmp46 *tmp56 1
   182 label *label41
   183 set :strip *tmp46
   184 op idiv *tmp58 :strip 16
   185 op mul *tmp59 *tmp58 17
-    * op mod *tmp60 *tmp59 176
-    * set :x *tmp60
-    * op mod *tmp61 :strip 16
-    * set :y *tmp61
+  186 op mod :x *tmp59 176
+  187 op mod :y :strip 16
   188 set :i 0
   189 label *label51
   190 jump *label53 greaterThanEq :i 16
 
   192 set :compute:x :x
   193 set :compute:y *tmp62
   194 op div *tmp64 :compute:x .ZOOM
-    * op add *tmp65 *tmp64 .OFFSET_X
-    * set :compute:zx *tmp65
+  195 op add :compute:zx *tmp64 .OFFSET_X
   196 op div *tmp66 :compute:y .ZOOM
-    * op add *tmp67 *tmp66 .OFFSET_Y
-    * set :compute:zy *tmp67
+  197 op add :compute:zy *tmp66 .OFFSET_Y
   198 jump *label55 equal .JULIA false
   199 set :compute:cx .JULIA_X
   200 set :compute:cy .JULIA_Y
 
   203 set :compute:cx :compute:zx
   204 set :compute:cy :compute:zy
   205 op sub *tmp69 :compute:cx 0.25
-    * op len *tmp70 *tmp69 :compute:cy
-    * set :compute:p *tmp70
+  206 op len :compute:p *tmp69 :compute:cy
   207 op mul *tmp71 2 :compute:p
   208 op mul *tmp72 *tmp71 :compute:p
   209 op sub *tmp73 :compute:p *tmp72
 
   233 op mul *tmp81 :compute:x1 :compute:x1
   234 op mul *tmp82 :compute:y1 :compute:y1
   235 op sub *tmp83 *tmp81 *tmp82
-    * op add *tmp84 *tmp83 :compute:cx
-    * set :compute:zx *tmp84
+  236 op add :compute:zx *tmp83 :compute:cx
   237 op mul *tmp85 2 :compute:x1
   238 op mul *tmp86 *tmp85 :compute:y1
-    * op add *tmp87 *tmp86 :compute:cy
-    * set :compute:zy *tmp87
-    * op len *tmp88 :compute:zx :compute:zy
-    * set :compute:dist *tmp88
+  239 op add :compute:zy *tmp86 :compute:cy
+  240 op len :compute:dist :compute:zx :compute:zy
   241 op greaterThanEq *tmp89 :compute:dist 64
   242 jump *label64 equal *tmp89 false
   243 jump *label63 always
 
   258 op mul *tmp94 *tmp93 0.36067376022224085
   259 op log *tmp95 *tmp94
   260 op mul *tmp96 *tmp95 1.4426950408889634
-    * op sub *tmp97 4 *tmp96
-    * set :compute:correction *tmp97
+  261 op sub :compute:correction 4 *tmp96
   262 op add :compute:i :compute:i :compute:correction
   263 jump *label67 always
   264 label *label66
 
   284 op abs *tmp104 *tmp103
   285 op mul *tmp105 7 *tmp104
   286 op div *tmp106 *tmp105 255
-    * op sub *tmp107 1 *tmp106
-    * set :drawPixel:r *tmp107
+  287 op sub :drawPixel:r 1 *tmp106
   288 op sub *tmp108 :drawPixel:iterations 32
   289 op abs *tmp109 *tmp108
   290 op mul *tmp110 6 *tmp109
   291 op div *tmp111 *tmp110 255
-    * op sub *tmp112 0.9411764705882353 *tmp111
-    * set :drawPixel:g *tmp112
+  292 op sub :drawPixel:g 0.9411764705882353 *tmp111
   293 op sub *tmp113 32 :drawPixel:iterations
   294 op abs *tmp114 *tmp113
   295 op mul *tmp115 4 *tmp114
   296 op div *tmp116 *tmp115 255
-    * op add *tmp117 0.47058823529411764 *tmp116
-    * set :drawPixel:b *tmp117
-    * packcolor *tmp118 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp118
+  297 op add :drawPixel:b 0.47058823529411764 *tmp116
+  298 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   299 jump *label75 always
   300 label *label76
   301 jump *label79 equal .PALETTE 3
 
   303 label *label79
   304 op div *tmp119 :drawPixel:iterations 63
   305 op mul *tmp120 *tmp119 360
-    * op sin *tmp121 *tmp120
-    * set :drawPixel:r *tmp121
+  306 op sin :drawPixel:r *tmp120
   307 op div *tmp122 :drawPixel:iterations 63
   308 op mul *tmp123 *tmp122 360
-    * op cos *tmp124 *tmp123
-    * set :drawPixel:g *tmp124
+  309 op cos :drawPixel:g *tmp123
   310 op sub *tmp125 :drawPixel:iterations 32
   311 op abs *tmp126 *tmp125
   312 op mul *tmp127 4 *tmp126
   313 op div *tmp128 *tmp127 255
-    * op add *tmp129 0.39215686274509803 *tmp128
-    * set :drawPixel:b *tmp129
-    * packcolor *tmp130 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp130
+  314 op add :drawPixel:b 0.39215686274509803 *tmp128
+  315 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   316 jump *label75 always
   317 label *label78
   318 jump *label81 equal .PALETTE 4
   319 jump *label80 always
   320 label *label81
   321 op mul *tmp131 4 :drawPixel:iterations
-    * op div *tmp132 *tmp131 255
-    * set :drawPixel:r *tmp132
+  322 op div :drawPixel:r *tmp131 255
   323 op mul *tmp133 1.5 :drawPixel:iterations
   324 op div *tmp134 *tmp133 255
-    * op add *tmp135 96 *tmp134
-    * set :drawPixel:g *tmp135
-    * packcolor *tmp136 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp136
+  325 op add :drawPixel:g 96 *tmp134
+  326 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   327 jump *label75 always
   328 label *label80
   329 op mul *tmp137 4 :drawPixel:iterations
   330 op div *tmp138 *tmp137 255
-    * op sub *tmp139 1 *tmp138
-    * set :drawPixel:r *tmp139
-    * packcolor *tmp140 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp140
+  331 op sub :drawPixel:r 1 *tmp138
+  332 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   333 label *label75
   334 label *label74
   335 jump *label72 always
   336 label *label71
-    * set *tmp141 :drawPixel:iterations
-    * read *tmp143 .memory *tmp141
-    * set :drawPixel:color *tmp143
+  337 read :drawPixel:color .memory :drawPixel:iterations
   338 label *label72
   339 op greaterThanEq *tmp144 .localBuffer 254
   340 jump *label82 equal *tmp144 false

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
   102 label *label3
   103 label *label0
   104 label *label28
-    * jump *label30 equal true false
   105 label *label31
   106 wait 0
   107 label *label32
 
   127 read .PALETTE .memory 74
   128 op greaterThan .SMOOTH .PALETTE 1
   129 label *label34
-    * jump *label36 equal true false
   130 wait 0
   131 read *tmp40 .memory 67
   132 op notEqual *tmp39 .stop *tmp40

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   275 set :drawPixel:color %[black]
   276 jump *label74 always
   277 label *label73
-    * jump *label77 equal .PALETTE 2
-    * jump *label76 always
+  278 jump *label76 notEqual .PALETTE 2
   279 label *label77
   280 op sub *tmp103 32 :drawPixel:iterations
   281 op abs *tmp104 *tmp103
 
   295 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   296 jump *label75 always
   297 label *label76
-    * jump *label79 equal .PALETTE 3
-    * jump *label78 always
+  298 jump *label78 notEqual .PALETTE 3
   299 label *label79
   300 op div *tmp119 :drawPixel:iterations 63
   301 op mul *tmp120 *tmp119 360
 
   311 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   312 jump *label75 always
   313 label *label78
-    * jump *label81 equal .PALETTE 4
-    * jump *label80 always
+  314 jump *label80 notEqual .PALETTE 4
   315 label *label81
   316 op mul *tmp131 4 :drawPixel:iterations
   317 op div :drawPixel:r *tmp131 255

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-21 instructions):
 
    24 print :findLinkedBlocks:title
    25 set :findLinkedBlocks:n @links
    26 label *label9
-    * op greaterThan *tmp12 :findLinkedBlocks:n 0
-    * jump *label11 equal *tmp12 false
+   27 jump *label11 lessThanEq :findLinkedBlocks:n 0
    28 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    29 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    30 print "\nFound: "
 
    44 set :findLinkedBlocks:required true
    45 setaddr *tmp15 *label16
    46 label *label12
-    * op equal *tmp16 :findLinkedBlocks:requested :findLinkedBlocks:type
-    * jump *label17 equal *tmp16 false
+   47 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * op equal *tmp18 :findLinkedBlocks:requested @message
-    * jump *label19 equal *tmp18 false
+   49 jump *label19 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
    51 jump *label20 always
    52 label *label19
 
    94 label *label23
    95 printflush :findLinkedBlocks:message
    96 label *label2
-    * op equal *tmp22 :findLinkedBlocks:foundAll false
-    * jump *label1 notEqual *tmp22 false
+   97 jump *label1 equal :findLinkedBlocks:foundAll false
    98 label *label3
    99 label *label0
   100 label *label28
 
   102 wait 0
   103 label *label32
   104 read *tmp24 .memory 66
-    * op equal *tmp23 .start *tmp24
-    * jump *label31 notEqual *tmp23 false
+  105 jump *label31 equal .start *tmp24
   106 label *label33
   107 read .start .memory 66
   108 read .stop .memory 67
 
   124 label *label34
   125 wait 0
   126 read *tmp40 .memory 67
-    * op notEqual *tmp39 .stop *tmp40
-    * jump *label37 equal *tmp39 false
+  127 jump *label37 equal .stop *tmp40
   128 jump *label29 always
   129 jump *label38 always
   130 label *label37
 
   134 op add *tmp0 *tmp42 1
   135 write *tmp0 .memory 64
   136 set :batch *tmp43
-    * op greaterThanEq *tmp44 :batch 2816
-    * jump *label39 equal *tmp44 false
+  137 jump *label39 lessThan :batch 2816
   138 jump *label36 always
   139 jump *label40 always
   140 label *label39
 
   199 op mul *tmp72 *tmp71 :compute:p
   200 op sub *tmp73 :compute:p *tmp72
   201 op add *tmp74 *tmp73 0.25
-    * op lessThanEq *tmp75 :compute:cx *tmp74
-    * jump *label57 equal *tmp75 false
+  202 jump *label57 greaterThan :compute:cx *tmp74
   203 set *tmp63 63
   204 jump *label54 always
   205 jump *label58 always
 
   207 label *label58
   208 op add *tmp77 :compute:cx 1
   209 op len *tmp78 *tmp77 :compute:cy
-    * op lessThanEq *tmp79 *tmp78 0.25
-    * jump *label59 equal *tmp79 false
+  210 jump *label59 greaterThan *tmp78 0.25
   211 set *tmp63 63
   212 jump *label54 always
   213 jump *label60 always
 
   227 op mul *tmp86 *tmp85 :compute:y1
   228 op add :compute:zy *tmp86 :compute:cy
   229 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp89 :compute:dist 64
-    * jump *label64 equal *tmp89 false
+  230 jump *label64 lessThan :compute:dist 64
   231 jump *label63 always
   232 jump *label65 always
   233 label *label64
 
   238 label *label63
   239 jump *label66 equal .SMOOTH false
   240 label *label69
-    * op lessThan *tmp91 :compute:i 63
-    * jump *label66 equal *tmp91 false
+  241 jump *label66 greaterThanEq :compute:i 63
   242 jump *label68 always
   243 label *label68
   244 op log *tmp93 :compute:dist
 
   259 set :drawPixel:y :y
   260 set :drawPixel:iterations :iterations
   261 jump *label71 equal .SMOOTH false
-    * op equal *tmp99 :drawPixel:iterations 63
-    * jump *label73 equal *tmp99 false
+  262 jump *label73 notEqual :drawPixel:iterations 63
   263 set :drawPixel:color %[black]
   264 jump *label74 always
   265 label *label73
 
   319 label *label71
   320 read :drawPixel:color .memory :drawPixel:iterations
   321 label *label72
-    * op greaterThanEq *tmp144 .localBuffer 254
-    * jump *label82 equal *tmp144 false
+  322 jump *label82 lessThan .localBuffer 254
   323 label *label85
-    * op greaterThan *tmp146 .localBuffer 0
-    * jump *label87 equal *tmp146 false
+  324 jump *label87 lessThanEq .localBuffer 0
   325 wait 0
   326 sensor *tmp147 .display @enabled
   327 jump *label89 equal *tmp147 false
   328 sensor *tmp149 .display @bufferSize
   329 op sub *tmp150 1024 *tmp149
-    * op lessThan *tmp151 .localBuffer *tmp150
-    * jump *label91 equal *tmp151 false
+  330 jump *label91 greaterThanEq .localBuffer *tmp150
   331 drawflush .display
   332 set .localBuffer 0
   333 jump *label92 always
 
   344 jump *label83 always
   345 label *label82
   346 label *label83
-    * op greaterThan *tmp153 .localBuffer 0
-    * jump *label93 equal *tmp153 false
+  347 jump *label93 lessThanEq .localBuffer 0
   348 label *label96
-    * op strictEqual *tmp154 :drawPixel:color .lastColor
-    * jump *label93 equal *tmp154 false
+  349 jump *label93 strictNotEqual :drawPixel:color .lastColor
   350 jump *label95 always
   351 label *label95
   352 draw rect :drawPixel:x :drawPixel:y 1 1
 
   363 jump *label98 equal *tmp157 false
   364 sensor *tmp159 .display @bufferSize
   365 op sub *tmp160 1024 *tmp159
-    * op lessThan *tmp161 .localBuffer *tmp160
-    * jump *label100 equal *tmp161 false
+  366 jump *label100 greaterThanEq .localBuffer *tmp160
   367 drawflush .display
   368 set .localBuffer 0
   369 jump *label101 always
 
   379 op add *tmp1 *tmp163 1
   380 write *tmp1 .memory 65
   381 read *tmp166 .memory 67
-    * op notEqual *tmp165 .stop *tmp166
-    * jump *label102 equal *tmp165 false
+  382 jump *label102 equal .stop *tmp166
   383 jump *label29 always
   384 jump *label103 always
   385 label *label102
 
   389 jump *label51 always
   390 label *label53
   391 label *label105
-    * op greaterThan *tmp168 .localBuffer 0
-    * jump *label107 equal *tmp168 false
+  392 jump *label107 lessThanEq .localBuffer 0
   393 wait 0
   394 sensor *tmp169 .display @enabled
   395 jump *label109 equal *tmp169 false
   396 sensor *tmp171 .display @bufferSize
   397 op sub *tmp172 1024 *tmp171
-    * op lessThan *tmp173 .localBuffer *tmp172
-    * jump *label111 equal *tmp173 false
+  398 jump *label111 greaterThanEq .localBuffer *tmp172
   399 drawflush .display
   400 set .localBuffer 0
   401 jump *label112 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-19 instructions):
 
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
    49 jump *label19 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * jump *label20 always
    51 label *label19
    52 label *label20
-    * jump *label18 always
    53 label *label17
    54 label *label18
    55 label *label13
 
    82 print :findLinkedBlocks:variable
    83 jump *label26 equal :findLinkedBlocks:required false
    84 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * jump *label27 always
    85 label *label26
    86 label *label27
    87 label *label22
 
   123 read *tmp40 .memory 67
   124 jump *label37 equal .stop *tmp40
   125 jump *label29 always
-    * jump *label38 always
   126 label *label37
   127 label *label38
   128 read *tmp42 .memory 64
 
   132 set :batch *tmp43
   133 jump *label39 lessThan :batch 2816
   134 jump *label36 always
-    * jump *label40 always
   135 label *label39
   136 label *label40
   137 jump *label44 lessThan :batch 0
 
   197 jump *label57 greaterThan :compute:cx *tmp74
   198 set *tmp63 63
   199 jump *label54 always
-    * jump *label58 always
   200 label *label57
   201 label *label58
   202 op add *tmp77 :compute:cx 1
 
   204 jump *label59 greaterThan *tmp78 0.25
   205 set *tmp63 63
   206 jump *label54 always
-    * jump *label60 always
   207 label *label59
   208 label *label60
   209 label *label56
 
   222 op len :compute:dist :compute:zx :compute:zy
   223 jump *label64 lessThan :compute:dist 64
   224 jump *label63 always
-    * jump *label65 always
   225 label *label64
   226 label *label65
   227 label *label62
 
   231 jump *label66 equal .SMOOTH false
   232 label *label69
   233 jump *label66 greaterThanEq :compute:i 63
-    * jump *label68 always
   234 label *label68
   235 op log *tmp93 :compute:dist
   236 op mul *tmp94 *tmp93 0.36067376022224085
 
   238 op mul *tmp96 *tmp95 1.4426950408889634
   239 op sub :compute:correction 4 *tmp96
   240 op add :compute:i :compute:i :compute:correction
-    * jump *label67 always
   241 label *label66
   242 label *label67
   243 set *tmp63 :compute:i
 
   320 jump *label91 greaterThanEq .localBuffer *tmp150
   321 drawflush .display
   322 set .localBuffer 0
-    * jump *label92 always
   323 label *label91
   324 label *label92
-    * jump *label90 always
   325 label *label89
   326 label *label90
   327 label *label88
 
   329 jump *label85 always
   330 label *label87
   331 label *label84
-    * jump *label83 always
   332 label *label82
   333 label *label83
   334 jump *label93 lessThanEq .localBuffer 0
   335 label *label96
   336 jump *label93 strictNotEqual :drawPixel:color .lastColor
-    * jump *label95 always
   337 label *label95
   338 draw rect :drawPixel:x :drawPixel:y 1 1
   339 op add .localBuffer .localBuffer 1
 
   352 jump *label100 greaterThanEq .localBuffer *tmp160
   353 drawflush .display
   354 set .localBuffer 0
-    * jump *label101 always
   355 label *label100
   356 label *label101
-    * jump *label99 always
   357 label *label98
   358 label *label99
   359 label *label97
 
   365 read *tmp166 .memory 67
   366 jump *label102 equal .stop *tmp166
   367 jump *label29 always
-    * jump *label103 always
   368 label *label102
   369 label *label103
   370 label *label52
 
   381 jump *label111 greaterThanEq .localBuffer *tmp172
   382 drawflush .display
   383 set .localBuffer 0
-    * jump *label112 always
   384 label *label111
   385 label *label112
-    * jump *label110 always
   386 label *label109
   387 label *label110
   388 label *label108

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     1 set :findLinkedBlocks:title "Mandelbrot Generator"
     2 set :findLinkedBlocks:message null
     3 label *label1
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
     4 setaddr *tmp11 *label7
     5 jump *label4 always
     6 multilabel *label7 (m:marker0)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
+    7 set .display null
     8 setaddr *tmp11 *label8
     9 label *label4
    10 set :findLinkedBlocks:variable null
    11 label *label5
    12 multijump *tmp11 0 0 (m:marker0)
    13 multilabel *label8 (m:marker0)
-    * set .memory :findLinkedBlocks:variable
+   14 set .memory null
    15 label *label6
-    * print :findLinkedBlocks:title
+   16 print "Mandelbrot Generator"
    17 set :findLinkedBlocks:n @links
    18 label *label9
    19 jump *label11 lessThanEq :findLinkedBlocks:n 0
 
    23 print :findLinkedBlocks:block
    24 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    25 set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
    26 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    27 setaddr *tmp15 *label15
    28 jump *label12 always
    29 multilabel *label15 (m:marker1)
    30 set .display :findLinkedBlocks:variable
    31 set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
    32 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    33 setaddr *tmp15 *label16
    34 label *label12
    35 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
 
    49 jump *label9 always
    50 label *label11
    51 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:requested @large-logic-display
    52 set :findLinkedBlocks:name "Display"
    53 set :findLinkedBlocks:variable .display
    54 set :findLinkedBlocks:required true
 
    56 jump *label21 always
    57 multilabel *label24 (m:marker2)
    58 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    59 set :findLinkedBlocks:name "Memory"
    60 set :findLinkedBlocks:variable .memory
    61 set :findLinkedBlocks:required true
 
    66 print ":"
    67 print " "
    68 print :findLinkedBlocks:variable
-    * jump *label26 equal :findLinkedBlocks:required false
+   69 jump *label26 equal true false
    70 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
    71 label *label26
    72 label *label27
 
    98 op add .OFFSET_X *tmp28 *tmp30
    99 op div *tmp31 -88 .ZOOM
   100 read *tmp33 .memory 69
-    * op add .OFFSET_Y *tmp31 *tmp33
+  101 op add .OFFSET_Y *tmp28 *tmp33
   102 read .JULIA .memory 71
   103 read .JULIA_X .memory 72
   104 read .JULIA_Y .memory 73
 
   115 set *tmp43 *tmp42
   116 op add *tmp0 *tmp42 1
   117 write *tmp0 .memory 64
-    * set :batch *tmp43
-    * jump *label39 lessThan :batch 2816
+  118 set :batch *tmp42
+  119 jump *label39 lessThan *tmp43 2816
   120 jump *label36 always
   121 label *label39
   122 label *label40
-    * jump *label44 lessThan :batch 0
-    * jump *label43 lessThan :batch 22
+  123 jump *label44 lessThan *tmp43 0
+  124 jump *label43 lessThan *tmp43 22
   125 label *label44
   126 jump *label42 always
   127 label *label43
-    * op mul *tmp46 8 :batch
+  128 op mul *tmp46 8 *tmp43
   129 jump *label41 always
   130 label *label42
-    * jump *label47 lessThan :batch 22
-    * jump *label46 lessThan :batch 44
+  131 jump *label47 lessThan *tmp43 22
+  132 jump *label46 lessThan *tmp43 44
   133 label *label47
   134 jump *label45 always
   135 label *label46
-    * op mul *tmp49 8 :batch
+  136 op mul *tmp49 8 *tmp43
   137 op sub *tmp50 *tmp49 176
-    * op add *tmp46 *tmp50 4
+  138 op sub *tmp46 *tmp49 172
   139 jump *label41 always
   140 label *label45
-    * jump *label50 lessThan :batch 44
-    * jump *label49 lessThan :batch 88
+  141 jump *label50 lessThan *tmp43 44
+  142 jump *label49 lessThan *tmp43 88
   143 label *label50
   144 jump *label48 always
   145 label *label49
-    * op mul *tmp52 4 :batch
+  146 op mul *tmp52 4 *tmp43
   147 op sub *tmp53 *tmp52 176
-    * op add *tmp46 *tmp53 2
+  148 op sub *tmp46 *tmp52 174
   149 jump *label41 always
   150 label *label48
-    * op mul *tmp55 2 :batch
+  151 op mul *tmp55 2 *tmp43
   152 op sub *tmp56 *tmp55 176
-    * op add *tmp46 *tmp56 1
+  153 op sub *tmp46 *tmp55 175
   154 label *label41
   155 set :strip *tmp46
-    * op idiv *tmp58 :strip 16
+  156 op idiv *tmp58 *tmp46 16
   157 op mul *tmp59 *tmp58 17
   158 op mod :x *tmp59 176
-    * op mod :y :strip 16
+  159 op mod :y *tmp46 16
   160 set :i 0
   161 label *label51
   162 jump *label53 greaterThanEq :i 16
   163 op add *tmp62 :y :i
   164 set :compute:x :x
   165 set :compute:y *tmp62
-    * op div *tmp64 :compute:x .ZOOM
+  166 op div *tmp64 :x .ZOOM
   167 op add :compute:zx *tmp64 .OFFSET_X
-    * op div *tmp66 :compute:y .ZOOM
+  168 op div *tmp66 *tmp62 .ZOOM
   169 op add :compute:zy *tmp66 .OFFSET_Y
   170 jump *label55 equal .JULIA false
   171 set :compute:cx .JULIA_X
 
   174 label *label55
   175 set :compute:cx :compute:zx
   176 set :compute:cy :compute:zy
-    * op sub *tmp69 :compute:cx 0.25
-    * op len :compute:p *tmp69 :compute:cy
+  177 op sub *tmp69 :compute:zx 0.25
+  178 op len :compute:p *tmp69 :compute:zy
   179 op mul *tmp71 2 :compute:p
   180 op mul *tmp72 *tmp71 :compute:p
   181 op sub *tmp73 :compute:p *tmp72
   182 op add *tmp74 *tmp73 0.25
-    * jump *label57 greaterThan :compute:cx *tmp74
+  183 jump *label57 greaterThan :compute:zx *tmp74
   184 set *tmp63 63
   185 jump *label54 always
   186 label *label57
   187 label *label58
-    * op add *tmp77 :compute:cx 1
-    * op len *tmp78 *tmp77 :compute:cy
+  188 op add *tmp77 :compute:zx 1
+  189 op len *tmp78 *tmp77 :compute:zy
   190 jump *label59 greaterThan *tmp78 0.25
   191 set *tmp63 63
   192 jump *label54 always
 
   198 jump *label63 greaterThanEq :compute:i 63
   199 set :compute:x1 :compute:zx
   200 set :compute:y1 :compute:zy
-    * op mul *tmp81 :compute:x1 :compute:x1
-    * op mul *tmp82 :compute:y1 :compute:y1
+  201 op mul *tmp81 :compute:zx :compute:zx
+  202 op mul *tmp82 :compute:zy :compute:zy
   203 op sub *tmp83 *tmp81 *tmp82
   204 op add :compute:zx *tmp83 :compute:cx
   205 op mul *tmp85 2 :compute:x1
-    * op mul *tmp86 *tmp85 :compute:y1
+  206 op mul *tmp86 *tmp85 :compute:zy
   207 op add :compute:zy *tmp86 :compute:cy
   208 op len :compute:dist :compute:zx :compute:zy
   209 jump *label64 lessThan :compute:dist 64
 
   228 label *label67
   229 set *tmp63 :compute:i
   230 jump *label54 always
-    * set *tmp63 null
   231 label *label54
   232 set :iterations *tmp63
   233 set :drawPixel:x :x
   234 set :drawPixel:y :y
-    * set :drawPixel:iterations :iterations
+  235 set :drawPixel:iterations *tmp63
   236 jump *label71 equal .SMOOTH false
-    * jump *label73 notEqual :drawPixel:iterations 63
+  237 jump *label73 notEqual :iterations 63
   238 set :drawPixel:color %[black]
   239 jump *label74 always
   240 label *label73
   241 jump *label76 notEqual .PALETTE 2
   242 label *label77
-    * op sub *tmp103 32 :drawPixel:iterations
+  243 op sub *tmp103 32 :iterations
   244 op abs *tmp104 *tmp103
   245 op mul *tmp105 7 *tmp104
-    * op div *tmp106 *tmp105 255
+  246 op div *tmp106 *tmp104 36.42857142857143
   247 op sub :drawPixel:r 1 *tmp106
-    * op sub *tmp108 :drawPixel:iterations 32
+  248 op sub *tmp108 :iterations 32
   249 op abs *tmp109 *tmp108
   250 op mul *tmp110 6 *tmp109
-    * op div *tmp111 *tmp110 255
+  251 op div *tmp111 *tmp109 42.5
   252 op sub :drawPixel:g 0.9411764705882353 *tmp111
-    * op sub *tmp113 32 :drawPixel:iterations
-    * op abs *tmp114 *tmp113
-    * op mul *tmp115 4 *tmp114
-    * op div *tmp116 *tmp115 255
+  253 op sub *tmp113 32 :iterations
+  254 op abs *tmp114 *tmp103
+  255 op mul *tmp115 4 *tmp104
+  256 op div *tmp116 *tmp114 63.75
   257 op add :drawPixel:b 0.47058823529411764 *tmp116
   258 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   259 jump *label75 always
   260 label *label76
   261 jump *label78 notEqual .PALETTE 3
   262 label *label79
-    * op div *tmp119 :drawPixel:iterations 63
-    * op mul *tmp120 *tmp119 360
+  263 op div *tmp119 :iterations 63
+  264 op div *tmp120 :drawPixel:iterations 0.175
   265 op sin :drawPixel:r *tmp120
-    * op div *tmp122 :drawPixel:iterations 63
-    * op mul *tmp123 *tmp122 360
-    * op cos :drawPixel:g *tmp123
-    * op sub *tmp125 :drawPixel:iterations 32
+  266 op div *tmp122 :iterations 63
+  267 op mul *tmp123 *tmp119 360
+  268 op cos :drawPixel:g *tmp120
+  269 op sub *tmp125 :iterations 32
   270 op abs *tmp126 *tmp125
   271 op mul *tmp127 4 *tmp126
-    * op div *tmp128 *tmp127 255
+  272 op div *tmp128 *tmp126 63.75
   273 op add :drawPixel:b 0.39215686274509803 *tmp128
   274 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   275 jump *label75 always
   276 label *label78
   277 jump *label80 notEqual .PALETTE 4
   278 label *label81
-    * op mul *tmp131 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp131 255
-    * op mul *tmp133 1.5 :drawPixel:iterations
-    * op div *tmp134 *tmp133 255
+  279 op mul *tmp131 4 :iterations
+  280 op div :drawPixel:r :drawPixel:iterations 63.75
+  281 op mul *tmp133 1.5 :iterations
+  282 op div *tmp134 :drawPixel:iterations 170
   283 op add :drawPixel:g 96 *tmp134
   284 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   285 jump *label75 always
   286 label *label80
-    * op mul *tmp137 4 :drawPixel:iterations
-    * op div *tmp138 *tmp137 255
+  287 op mul *tmp137 4 :iterations
+  288 op div *tmp138 :drawPixel:iterations 63.75
   289 op sub :drawPixel:r 1 *tmp138
   290 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   291 label *label75
   292 label *label74
   293 jump *label72 always
   294 label *label71
-    * read :drawPixel:color .memory :drawPixel:iterations
+  295 read :drawPixel:color .memory :iterations
   296 label *label72
   297 jump *label82 lessThan .localBuffer 254
   298 label *label85
 
   320 label *label96
   321 jump *label93 strictNotEqual :drawPixel:color .lastColor
   322 label *label95
-    * draw rect :drawPixel:x :drawPixel:y 1 1
+  323 draw rect :x :y 1 1
   324 op add .localBuffer .localBuffer 1
   325 jump *label94 always
   326 label *label93
   327 draw col :drawPixel:color
-    * draw rect :drawPixel:x :drawPixel:y 1 1
+  328 draw rect :x :y 1 1
   329 set .lastColor :drawPixel:color
   330 op add .localBuffer .localBuffer 2
   331 label *label94

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-19 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:title "Mandelbrot Generator"
     1 set :findLinkedBlocks:message null
     2 label *label1
     3 setaddr *tmp11 *label7
 
     6 set .display null
     7 setaddr *tmp11 *label8
     8 label *label4
-    * set :findLinkedBlocks:variable null
     9 label *label5
    10 multijump *tmp11 0 0 (m:marker0)
    11 multilabel *label8 (m:marker0)
 
    49 set :findLinkedBlocks:foundAll 1
    50 set :findLinkedBlocks:name "Display"
    51 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    52 setaddr *tmp20 *label24
    53 jump *label21 always
    54 multilabel *label24 (m:marker2)
    55 set .display :findLinkedBlocks:variable
    56 set :findLinkedBlocks:name "Memory"
    57 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    58 setaddr *tmp20 *label25
    59 label *label21
    60 print "\n"
 
    92 op div *tmp28 -88 .ZOOM
    93 read *tmp30 .memory 68
    94 op add .OFFSET_X *tmp28 *tmp30
-    * op div *tmp31 -88 .ZOOM
    95 read *tmp33 .memory 69
    96 op add .OFFSET_Y *tmp28 *tmp33
    97 read .JULIA .memory 71
 
   110 set *tmp43 *tmp42
   111 op add *tmp0 *tmp42 1
   112 write *tmp0 .memory 64
-    * set :batch *tmp42
-    * jump *label39 lessThan *tmp43 2816
+  113 jump *label39 lessThan *tmp42 2816
   114 jump *label36 always
   115 label *label39
   116 label *label40
-    * jump *label44 lessThan *tmp43 0
-    * jump *label43 lessThan *tmp43 22
+  117 jump *label44 lessThan *tmp42 0
+  118 jump *label43 lessThan *tmp42 22
   119 label *label44
   120 jump *label42 always
   121 label *label43
-    * op mul *tmp46 8 *tmp43
+  122 op mul *tmp46 8 *tmp42
   123 jump *label41 always
   124 label *label42
-    * jump *label47 lessThan *tmp43 22
-    * jump *label46 lessThan *tmp43 44
+  125 jump *label47 lessThan *tmp42 22
+  126 jump *label46 lessThan *tmp42 44
   127 label *label47
   128 jump *label45 always
   129 label *label46
-    * op mul *tmp49 8 *tmp43
-    * op sub *tmp50 *tmp49 176
+  130 op mul *tmp49 8 *tmp42
   131 op sub *tmp46 *tmp49 172
   132 jump *label41 always
   133 label *label45
-    * jump *label50 lessThan *tmp43 44
-    * jump *label49 lessThan *tmp43 88
+  134 jump *label50 lessThan *tmp42 44
+  135 jump *label49 lessThan *tmp42 88
   136 label *label50
   137 jump *label48 always
   138 label *label49
-    * op mul *tmp52 4 *tmp43
-    * op sub *tmp53 *tmp52 176
+  139 op mul *tmp52 4 *tmp42
   140 op sub *tmp46 *tmp52 174
   141 jump *label41 always
   142 label *label48
-    * op mul *tmp55 2 *tmp43
-    * op sub *tmp56 *tmp55 176
+  143 op mul *tmp55 2 *tmp42
   144 op sub *tmp46 *tmp55 175
   145 label *label41
-    * set :strip *tmp46
   146 op idiv *tmp58 *tmp46 16
   147 op mul *tmp59 *tmp58 17
   148 op mod :x *tmp59 176
 
   151 label *label51
   152 jump *label53 greaterThanEq :i 16
   153 op add *tmp62 :y :i
-    * set :compute:x :x
-    * set :compute:y *tmp62
   154 op div *tmp64 :x .ZOOM
   155 op add :compute:zx *tmp64 .OFFSET_X
   156 op div *tmp66 *tmp62 .ZOOM
 
   185 label *label61
   186 jump *label63 greaterThanEq :compute:i 63
   187 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   188 op mul *tmp81 :compute:zx :compute:zx
   189 op mul *tmp82 :compute:zy :compute:zy
   190 op sub *tmp83 *tmp81 *tmp82
 
   217 jump *label54 always
   218 label *label54
   219 set :iterations *tmp63
-    * set :drawPixel:x :x
-    * set :drawPixel:y :y
   220 set :drawPixel:iterations *tmp63
   221 jump *label71 equal .SMOOTH false
-    * jump *label73 notEqual :iterations 63
+  222 jump *label73 notEqual *tmp63 63
   223 set :drawPixel:color %[black]
   224 jump *label74 always
   225 label *label73
   226 jump *label76 notEqual .PALETTE 2
   227 label *label77
-    * op sub *tmp103 32 :iterations
+  228 op sub *tmp103 32 *tmp63
   229 op abs *tmp104 *tmp103
-    * op mul *tmp105 7 *tmp104
   230 op div *tmp106 *tmp104 36.42857142857143
   231 op sub :drawPixel:r 1 *tmp106
-    * op sub *tmp108 :iterations 32
+  232 op sub *tmp108 *tmp63 32
   233 op abs *tmp109 *tmp108
-    * op mul *tmp110 6 *tmp109
   234 op div *tmp111 *tmp109 42.5
   235 op sub :drawPixel:g 0.9411764705882353 *tmp111
-    * op sub *tmp113 32 :iterations
+  236 op sub *tmp113 32 *tmp63
   237 op abs *tmp114 *tmp103
-    * op mul *tmp115 4 *tmp104
-    * op div *tmp116 *tmp114 63.75
+  238 op div *tmp116 *tmp104 63.75
   239 op add :drawPixel:b 0.47058823529411764 *tmp116
   240 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   241 jump *label75 always
   242 label *label76
   243 jump *label78 notEqual .PALETTE 3
   244 label *label79
-    * op div *tmp119 :iterations 63
-    * op div *tmp120 :drawPixel:iterations 0.175
+  245 op div *tmp119 *tmp63 63
+  246 op div *tmp120 *tmp63 0.175
   247 op sin :drawPixel:r *tmp120
-    * op div *tmp122 :iterations 63
-    * op mul *tmp123 *tmp119 360
+  248 op div *tmp122 *tmp63 63
+  249 op div *tmp123 :iterations 0.175
   250 op cos :drawPixel:g *tmp120
-    * op sub *tmp125 :iterations 32
+  251 op sub *tmp125 *tmp63 32
   252 op abs *tmp126 *tmp125
-    * op mul *tmp127 4 *tmp126
   253 op div *tmp128 *tmp126 63.75
   254 op add :drawPixel:b 0.39215686274509803 *tmp128
   255 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   257 label *label78
   258 jump *label80 notEqual .PALETTE 4
   259 label *label81
-    * op mul *tmp131 4 :iterations
-    * op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp133 1.5 :iterations
-    * op div *tmp134 :drawPixel:iterations 170
+  260 op mul *tmp131 4 *tmp63
+  261 op div :drawPixel:r *tmp63 63.75
+  262 op mul *tmp133 1.5 *tmp63
+  263 op div *tmp134 *tmp63 170
   264 op add :drawPixel:g 96 *tmp134
   265 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   266 jump *label75 always
   267 label *label80
-    * op mul *tmp137 4 :iterations
-    * op div *tmp138 :drawPixel:iterations 63.75
+  268 op mul *tmp137 4 *tmp63
+  269 op div *tmp138 *tmp63 63.75
   270 op sub :drawPixel:r 1 *tmp138
   271 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   272 label *label75
   273 label *label74
   274 jump *label72 always
   275 label *label71
-    * read :drawPixel:color .memory :iterations
+  276 read :drawPixel:color .memory *tmp63
   277 label *label72
   278 jump *label82 lessThan .localBuffer 254
   279 label *label85

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-9 instructions):
 
   107 label *label37
   108 label *label38
   109 read *tmp42 .memory 64
-    * set *tmp43 *tmp42
   110 op add *tmp0 *tmp42 1
   111 write *tmp0 .memory 64
   112 jump *label39 lessThan *tmp42 2816
 
   216 jump *label54 always
   217 label *label54
   218 set :iterations *tmp63
-    * set :drawPixel:iterations *tmp63
   219 jump *label71 equal .SMOOTH false
   220 jump *label73 notEqual *tmp63 63
   221 set :drawPixel:color %[black]
 
   231 op abs *tmp109 *tmp108
   232 op div *tmp111 *tmp109 42.5
   233 op sub :drawPixel:g 0.9411764705882353 *tmp111
-    * op sub *tmp113 32 *tmp63
-    * op abs *tmp114 *tmp103
   234 op div *tmp116 *tmp104 63.75
   235 op add :drawPixel:b 0.47058823529411764 *tmp116
   236 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   238 label *label76
   239 jump *label78 notEqual .PALETTE 3
   240 label *label79
-    * op div *tmp119 *tmp63 63
   241 op div *tmp120 *tmp63 0.175
   242 op sin :drawPixel:r *tmp120
-    * op div *tmp122 *tmp63 63
-    * op div *tmp123 :iterations 0.175
+  243 op div *tmp123 *tmp63 0.175
   244 op cos :drawPixel:g *tmp120
   245 op sub *tmp125 *tmp63 32
   246 op abs *tmp126 *tmp125
 
   251 label *label78
   252 jump *label80 notEqual .PALETTE 4
   253 label *label81
-    * op mul *tmp131 4 *tmp63
   254 op div :drawPixel:r *tmp63 63.75
-    * op mul *tmp133 1.5 *tmp63
   255 op div *tmp134 *tmp63 170
   256 op add :drawPixel:g 96 *tmp134
   257 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   258 jump *label75 always
   259 label *label80
-    * op mul *tmp137 4 *tmp63
   260 op div *tmp138 *tmp63 63.75
   261 op sub :drawPixel:r 1 *tmp138
   262 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   215 set *tmp63 :compute:i
   216 jump *label54 always
   217 label *label54
-    * set :iterations *tmp63
   218 jump *label71 equal .SMOOTH false
   219 jump *label73 notEqual *tmp63 63
   220 set :drawPixel:color %[black]
 
   239 label *label79
   240 op div *tmp120 *tmp63 0.175
   241 op sin :drawPixel:r *tmp120
-    * op div *tmp123 *tmp63 0.175
   242 op cos :drawPixel:g *tmp120
   243 op sub *tmp125 *tmp63 32
   244 op abs *tmp126 *tmp125

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
    15 set :findLinkedBlocks:n @links
    16 label *label9
    17 jump *label11 lessThanEq :findLinkedBlocks:n 0
+   18 label *label113
    19 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    20 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    21 print "\nFound: "
 
    45 set .memory :findLinkedBlocks:variable
    46 label *label14
    47 label *label10
-    * jump *label9 always
+   48 jump *label113 greaterThan :findLinkedBlocks:n 0
    49 label *label11
    50 set :findLinkedBlocks:foundAll 1
    51 set :findLinkedBlocks:name "Display"
 
   150 set :i 0
   151 label *label51
   152 jump *label53 greaterThanEq :i 16
+  153 label *label114
   154 op add *tmp62 :y :i
   155 op div *tmp64 :x .ZOOM
   156 op add :compute:zx *tmp64 .OFFSET_X
 
   185 set :compute:i 0
   186 label *label61
   187 jump *label63 greaterThanEq :compute:i 63
+  188 label *label115
   189 set :compute:x1 :compute:zx
   190 op mul *tmp81 :compute:zx :compute:zx
   191 op mul *tmp82 :compute:zy :compute:zy
 
   201 label *label65
   202 label *label62
   203 op add :compute:i :compute:i 1
-    * jump *label61 always
+  204 jump *label115 lessThan :compute:i 63
   205 label *label63
   206 jump *label66 equal .SMOOTH false
   207 label *label69
 
   270 jump *label82 lessThan .localBuffer 254
   271 label *label85
   272 jump *label87 lessThanEq .localBuffer 0
+  273 label *label116
   274 wait 0
   275 sensor *tmp147 .display @enabled
   276 jump *label89 equal *tmp147 false
 
   285 label *label90
   286 label *label88
   287 label *label86
-    * jump *label85 always
+  288 jump *label116 greaterThan .localBuffer 0
   289 label *label87
   290 label *label84
   291 label *label82
 
   328 label *label103
   329 label *label52
   330 op add :i :i 1
-    * jump *label51 always
+  331 jump *label114 lessThan :i 16
   332 label *label53
   333 label *label105
   334 jump *label107 lessThanEq .localBuffer 0
+  335 label *label117
   336 wait 0
   337 sensor *tmp169 .display @enabled
   338 jump *label109 equal *tmp169 false
 
   347 label *label110
   348 label *label108
   349 label *label106
-    * jump *label105 always
+  350 jump *label117 greaterThan .localBuffer 0
   351 label *label107
   352 label *label104
   353 label *label35

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
    33 label *label12
    34 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    35 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label19 notEqual :findLinkedBlocks:requested @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
-    * label *label19
-    * label *label20
+   36 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
    37 label *label17
    38 label *label18
    39 label *label13
 
   201 jump *label115 lessThan :compute:i 63
   202 label *label63
   203 jump *label66 equal .SMOOTH false
-    * label *label69
   204 jump *label66 greaterThanEq :compute:i 63
-    * label *label68
   205 op log *tmp93 :compute:dist
   206 op mul *tmp94 *tmp93 0.36067376022224085
   207 op log *tmp95 *tmp94
 
   286 label *label82
   287 label *label83
   288 jump *label93 lessThanEq .localBuffer 0
-    * label *label96
   289 jump *label93 strictNotEqual :drawPixel:color .lastColor
-    * label *label95
   290 draw rect :x :y 1 1
   291 op add .localBuffer .localBuffer 1
   292 jump *label94 always

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   214 jump *label54 always
   215 label *label54
   216 jump *label71 equal .SMOOTH false
-    * jump *label73 notEqual *tmp63 63
   217 set :drawPixel:color %[black]
-    * jump *label74 always
+  218 jump *label74 equal *tmp63 63
   219 label *label73
   220 jump *label76 notEqual .PALETTE 2
   221 label *label77

Modifications by Unroll iteration loop at *blocks:68:13 (-1 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp15 *label15
-    * jump *label12 always
-    * multilabel *label15 (m:marker1)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp15 *label16
-    * label *label12
-    * jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
-    * label *label17
-    * label *label18
-    * label *label13
-    * multijump *tmp15 0 0 (m:marker1)
-    * multilabel *label16 (m:marker1)
-    * set .memory :findLinkedBlocks:variable
-    * label *label14
+   24 set :findLinkedBlocks:requested @large-logic-display
+   25 set :findLinkedBlocks:variable .display
+   26 label *label118
+   27 jump *label119 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   28 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   29 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   30 label *label119
+   31 label *label120
+   32 label *label121
+   33 set .display :findLinkedBlocks:variable
+   34 set :findLinkedBlocks:requested @memory-bank
+   35 set :findLinkedBlocks:variable .memory
+   36 label *label124
+   37 jump *label125 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   38 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   39 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   40 label *label125
+   41 label *label126
+   42 label *label127
+   43 set .memory :findLinkedBlocks:variable
+   44 label *label14
    45 label *label10
    46 jump *label113 greaterThan :findLinkedBlocks:n 0
    47 label *label11

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    24 set :findLinkedBlocks:requested @large-logic-display
    25 set :findLinkedBlocks:variable .display
    26 label *label118
-    * jump *label119 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   27 jump *label119 notEqual @large-logic-display :findLinkedBlocks:type
    28 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   29 select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
    30 label *label119
    31 label *label120
    32 label *label121
 
    34 set :findLinkedBlocks:requested @memory-bank
    35 set :findLinkedBlocks:variable .memory
    36 label *label124
-    * jump *label125 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   37 jump *label125 notEqual @memory-bank :findLinkedBlocks:type
    38 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   39 select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
    40 label *label125
    41 label *label126
    42 label *label127
 
   147 op mod :y *tmp46 16
   148 set :i 0
   149 label *label51
-    * jump *label53 greaterThanEq :i 16
+  150 jump *label53 greaterThanEq 0 16
   151 label *label114
   152 op add *tmp62 :y :i
   153 op div *tmp64 :x .ZOOM
 
   182 label *label56
   183 set :compute:i 0
   184 label *label61
-    * jump *label63 greaterThanEq :compute:i 63
+  185 jump *label63 greaterThanEq 0 63
   186 label *label115
   187 set :compute:x1 :compute:zx
   188 op mul *tmp81 :compute:zx :compute:zx

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
    24 set :findLinkedBlocks:variable .display
    25 label *label118
    26 jump *label119 notEqual @large-logic-display :findLinkedBlocks:type
 
    30 label *label120
    31 label *label121
    32 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    33 set :findLinkedBlocks:variable .memory
    34 label *label124
    35 jump *label125 notEqual @memory-bank :findLinkedBlocks:type

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
     0 set .start 0
     1 set :findLinkedBlocks:message null
     2 label *label1
-    * setaddr *tmp11 *label7
-    * jump *label4 always
-    * multilabel *label7 (m:marker0)
-    * set .display null
-    * setaddr *tmp11 *label8
-    * label *label4
-    * label *label5
-    * multijump *tmp11 0 0 (m:marker0)
-    * multilabel *label8 (m:marker0)
-    * set .memory null
-    * label *label6
+    3 label *label131
+    4 label *label132
+    5 set .display null
+    6 label *label135
+    7 label *label136
+    8 set .memory null
+    9 label *label6
    10 print "Mandelbrot Generator"
    11 set :findLinkedBlocks:n @links
    12 label *label9

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    40 jump *label113 greaterThan :findLinkedBlocks:n 0
    41 label *label11
    42 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp20 *label24
-    * jump *label21 always
-    * multilabel *label24 (m:marker2)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp20 *label25
-    * label *label21
-    * print "\n"
-    * print :findLinkedBlocks:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks:variable
-    * jump *label26 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * label *label26
-    * label *label27
-    * label *label22
-    * multijump *tmp20 0 0 (m:marker2)
-    * multilabel *label25 (m:marker2)
-    * set .memory :findLinkedBlocks:variable
-    * label *label23
+   43 set :findLinkedBlocks:name "Display"
+   44 set :findLinkedBlocks:variable .display
+   45 label *label140
+   46 print "\n"
+   47 print :findLinkedBlocks:name
+   48 print ":"
+   49 print " "
+   50 print :findLinkedBlocks:variable
+   51 jump *label141 equal true false
+   52 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   53 label *label141
+   54 label *label142
+   55 label *label143
+   56 set .display :findLinkedBlocks:variable
+   57 set :findLinkedBlocks:name "Memory"
+   58 set :findLinkedBlocks:variable .memory
+   59 label *label146
+   60 print "\n"
+   61 print :findLinkedBlocks:name
+   62 print ":"
+   63 print " "
+   64 print :findLinkedBlocks:variable
+   65 jump *label147 equal true false
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   67 label *label147
+   68 label *label148
+   69 label *label149
+   70 set .memory :findLinkedBlocks:variable
+   71 label *label23
    72 printflush :findLinkedBlocks:message
    73 label *label2
    74 jump *label1 equal :findLinkedBlocks:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    44 set :findLinkedBlocks:variable .display
    45 label *label140
    46 print "\n"
-    * print :findLinkedBlocks:name
+   47 print "Display"
    48 print ":"
    49 print " "
-    * print :findLinkedBlocks:variable
+   50 print .display
    51 jump *label141 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   52 op and :findLinkedBlocks:foundAll 1 .display
    53 label *label141
    54 label *label142
    55 label *label143
-    * set .display :findLinkedBlocks:variable
+   56 set .display .display
    57 set :findLinkedBlocks:name "Memory"
    58 set :findLinkedBlocks:variable .memory
    59 label *label146
    60 print "\n"
-    * print :findLinkedBlocks:name
+   61 print "Memory"
    62 print ":"
    63 print " "
-    * print :findLinkedBlocks:variable
+   64 print .memory
    65 jump *label147 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    67 label *label147
    68 label *label148
    69 label *label149
-    * set .memory :findLinkedBlocks:variable
+   70 set .memory .memory
    71 label *label23
    72 printflush :findLinkedBlocks:message
    73 label *label2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    39 label *label10
    40 jump *label113 greaterThan :findLinkedBlocks:n 0
    41 label *label11
-    * set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
    42 label *label140
    43 print "\n"
    44 print "Display"
 
    51 label *label142
    52 label *label143
    53 set .display .display
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
    54 label *label146
    55 print "\n"
    56 print "Memory"

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:82:25 (-7 instructions):
 
   106 jump *label36 always
   107 label *label39
   108 label *label40
-    * jump *label44 lessThan *tmp42 0
-    * jump *label43 lessThan *tmp42 22
-    * label *label44
-    * jump *label42 always
+  109 multijump *tmp42 0 0 (m:*label154)
+  110 multilabel *label158 (m:*label154)
+  111 label *label153
+  112 op mul *tmp55 2 *tmp42
+  113 op sub *tmp46 *tmp55 175
+  114 jump *label41 always
+  115 multilabel *label155 (m:*label154)
   116 label *label43
   117 op mul *tmp46 8 *tmp42
   118 jump *label41 always
   119 label *label42
-    * jump *label47 lessThan *tmp42 22
-    * jump *label46 lessThan *tmp42 44
-    * label *label47
-    * jump *label45 always
+  120 multilabel *label156 (m:*label154)
   121 label *label46
   122 op mul *tmp49 8 *tmp42
   123 op sub *tmp46 *tmp49 172
   124 jump *label41 always
   125 label *label45
-    * jump *label50 lessThan *tmp42 44
-    * jump *label49 lessThan *tmp42 88
-    * label *label50
-    * jump *label48 always
+  126 jump *label41 always
+  127 multilabel *label157 (m:*label154)
   128 label *label49
   129 op mul *tmp52 4 *tmp42
   130 op sub *tmp46 *tmp52 174
-    * jump *label41 always
-    * label *label48
-    * op mul *tmp55 2 *tmp42
-    * op sub *tmp46 *tmp55 175
   131 label *label41
   132 op idiv *tmp58 *tmp46 16
   133 op mul *tmp59 *tmp58 17

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:158:13 (-2 instructions):
 
   206 set :drawPixel:color %[black]
   207 jump *label74 equal *tmp63 63
   208 label *label73
-    * jump *label76 notEqual .PALETTE 2
+  209 multijump .PALETTE 0 0 (m:*label160)
+  210 multilabel *label165 (m:*label160)
+  211 multilabel *label161 (m:*label160)
+  212 label *label159
+  213 op div *tmp138 *tmp63 63.75
+  214 op sub :drawPixel:r 1 *tmp138
+  215 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
+  216 jump *label75 always
+  217 multilabel *label162 (m:*label160)
   218 label *label77
   219 op sub *tmp103 32 *tmp63
   220 op abs *tmp104 *tmp103
 
   229 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   230 jump *label75 always
   231 label *label76
-    * jump *label78 notEqual .PALETTE 3
+  232 multilabel *label163 (m:*label160)
   233 label *label79
   234 op div *tmp120 *tmp63 0.175
   235 op sin :drawPixel:r *tmp120
 
   241 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   242 jump *label75 always
   243 label *label78
-    * jump *label80 notEqual .PALETTE 4
+  244 multilabel *label164 (m:*label160)
   245 label *label81
   246 op div :drawPixel:r *tmp63 63.75
   247 op div *tmp134 *tmp63 170
   248 op add :drawPixel:g 96 *tmp134
   249 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label75 always
-    * label *label80
-    * op div *tmp138 *tmp63 63.75
-    * op sub :drawPixel:r 1 *tmp138
-    * packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   250 label *label75
   251 label *label74
   252 jump *label72 always

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-4 instructions):
 
    45 print ":"
    46 print " "
    47 print .display
-    * jump *label141 equal true false
    48 op and :findLinkedBlocks:foundAll 1 .display
    49 label *label141
    50 label *label142
 
    56 print ":"
    57 print " "
    58 print .memory
-    * jump *label147 equal true false
    59 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    60 label *label147
    61 label *label148
 
   133 op mod :y *tmp46 16
   134 set :i 0
   135 label *label51
-    * jump *label53 greaterThanEq 0 16
   136 label *label114
   137 op add *tmp62 :y :i
   138 op div *tmp64 :x .ZOOM
 
   167 label *label56
   168 set :compute:i 0
   169 label *label61
-    * jump *label63 greaterThanEq 0 63
   170 label *label115
   171 set :compute:x1 :compute:zx
   172 op mul *tmp81 :compute:zx :compute:zx

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-1 instructions):
 
    89 read .JULIA_X .memory 72
    90 read .JULIA_Y .memory 73
    91 read .PALETTE .memory 74
-    * op greaterThan .SMOOTH .PALETTE 1
    92 label *label34
    93 wait 0
    94 read *tmp40 .memory 67
 
   184 op add :compute:i :compute:i 1
   185 jump *label115 lessThan :compute:i 63
   186 label *label63
-    * jump *label66 equal .SMOOTH false
+  187 jump *label66 lessThanEq .PALETTE 1
   188 jump *label66 greaterThanEq :compute:i 63
   189 op log *tmp93 :compute:dist
   190 op mul *tmp94 *tmp93 0.36067376022224085
 
   197 set *tmp63 :compute:i
   198 jump *label54 always
   199 label *label54
-    * jump *label71 equal .SMOOTH false
+  200 jump *label71 lessThanEq .PALETTE 1
   201 set :drawPixel:color %[black]
   202 jump *label74 equal *tmp63 63
   203 label *label73

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   118 label *label46
   119 op mul *tmp49 8 *tmp42
   120 op sub *tmp46 *tmp49 172
-    * jump *label41 always
   121 label *label45
   122 jump *label41 always
   123 multilabel *label157 (m:*label154)
 
   194 label *label66
   195 label *label67
   196 set *tmp63 :compute:i
-    * jump *label54 always
   197 label *label54
   198 jump *label71 lessThanEq .PALETTE 1
   199 set :drawPixel:color %[black]

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-2 instructions):
 
    21 label *label118
    22 jump *label119 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
+   24 set :findLinkedBlocks:message :findLinkedBlocks:message
    25 label *label119
    26 label *label120
    27 label *label121
 
    30 label *label124
    31 jump *label125 notEqual @memory-bank :findLinkedBlocks:type
    32 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
+   33 set :findLinkedBlocks:message :findLinkedBlocks:message
    34 label *label125
    35 label *label126
    36 label *label127
 
    49 label *label141
    50 label *label142
    51 label *label143
-    * set .display .display
    52 label *label146
    53 print "\n"
    54 print "Memory"
 
    59 label *label147
    60 label *label148
    61 label *label149
-    * set .memory .memory
    62 label *label23
    63 printflush :findLinkedBlocks:message
    64 label *label2

Modifications by Unroll loop at mandelbrot-compute.mnd:131:5 (+743 instructions):
 
   161 label *label59
   162 label *label60
   163 label *label56
-    * set :compute:i 0
-    * label *label61
-    * label *label115
-    * set :compute:x1 :compute:zx
-    * op mul *tmp81 :compute:zx :compute:zx
-    * op mul *tmp82 :compute:zy :compute:zy
-    * op sub *tmp83 *tmp81 *tmp82
-    * op add :compute:zx *tmp83 :compute:cx
-    * op mul *tmp85 2 :compute:x1
-    * op mul *tmp86 *tmp85 :compute:zy
-    * op add :compute:zy *tmp86 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label64 lessThan :compute:dist 64
-    * jump *label63 always
-    * label *label64
-    * label *label65
-    * label *label62
-    * op add :compute:i :compute:i 1
-    * jump *label115 lessThan :compute:i 63
-    * label *label63
+  164 set :compute:i 0
+  165 label *label166
+  166 set :compute:x1 :compute:zx
+  167 op mul *tmp81 :compute:zx :compute:zx
+  168 op mul *tmp82 :compute:zy :compute:zy
+  169 op sub *tmp83 *tmp81 *tmp82
+  170 op add :compute:zx *tmp83 :compute:cx
+  171 op mul *tmp85 2 :compute:x1
+  172 op mul *tmp86 *tmp85 :compute:zy
+  173 op add :compute:zy *tmp86 :compute:cy
+  174 op len :compute:dist :compute:zx :compute:zy
+  175 jump *label167 lessThan :compute:dist 64
+  176 jump *label63 always
+  177 label *label167
+  178 label *label168
+  179 label *label169
+  180 op add :compute:i :compute:i 1
+  181 set :compute:x1 :compute:zx
+  182 op mul *tmp81 :compute:zx :compute:zx
+  183 op mul *tmp82 :compute:zy :compute:zy
+  184 op sub *tmp83 *tmp81 *tmp82
+  185 op add :compute:zx *tmp83 :compute:cx
+  186 op mul *tmp85 2 :compute:x1
+  187 op mul *tmp86 *tmp85 :compute:zy
+  188 op add :compute:zy *tmp86 :compute:cy
+  189 op len :compute:dist :compute:zx :compute:zy
+  190 jump *label170 lessThan :compute:dist 64
+  191 jump *label63 always
+  192 label *label170
+  193 label *label171
+  194 label *label172
+  195 op add :compute:i :compute:i 1
+  196 set :compute:x1 :compute:zx
+  197 op mul *tmp81 :compute:zx :compute:zx
+  198 op mul *tmp82 :compute:zy :compute:zy
+  199 op sub *tmp83 *tmp81 *tmp82
+  200 op add :compute:zx *tmp83 :compute:cx
+  201 op mul *tmp85 2 :compute:x1
+  202 op mul *tmp86 *tmp85 :compute:zy
+  203 op add :compute:zy *tmp86 :compute:cy
+  204 op len :compute:dist :compute:zx :compute:zy
+  205 jump *label173 lessThan :compute:dist 64
+  206 jump *label63 always
+  207 label *label173
+  208 label *label174
+  209 label *label175
+  210 op add :compute:i :compute:i 1
+  211 set :compute:x1 :compute:zx
+  212 op mul *tmp81 :compute:zx :compute:zx
+  213 op mul *tmp82 :compute:zy :compute:zy
+  214 op sub *tmp83 *tmp81 *tmp82
+  215 op add :compute:zx *tmp83 :compute:cx
+  216 op mul *tmp85 2 :compute:x1
+  217 op mul *tmp86 *tmp85 :compute:zy
+  218 op add :compute:zy *tmp86 :compute:cy
+  219 op len :compute:dist :compute:zx :compute:zy
+  220 jump *label176 lessThan :compute:dist 64
+  221 jump *label63 always
+  222 label *label176
+  223 label *label177
+  224 label *label178
+  225 op add :compute:i :compute:i 1
+  226 set :compute:x1 :compute:zx
+  227 op mul *tmp81 :compute:zx :compute:zx
+  228 op mul *tmp82 :compute:zy :compute:zy
+  229 op sub *tmp83 *tmp81 *tmp82
+  230 op add :compute:zx *tmp83 :compute:cx
+  231 op mul *tmp85 2 :compute:x1
+  232 op mul *tmp86 *tmp85 :compute:zy
+  233 op add :compute:zy *tmp86 :compute:cy
+  234 op len :compute:dist :compute:zx :compute:zy
+  235 jump *label179 lessThan :compute:dist 64
+  236 jump *label63 always
+  237 label *label179
+  238 label *label180
+  239 label *label181
+  240 op add :compute:i :compute:i 1
+  241 set :compute:x1 :compute:zx
+  242 op mul *tmp81 :compute:zx :compute:zx
+  243 op mul *tmp82 :compute:zy :compute:zy
+  244 op sub *tmp83 *tmp81 *tmp82
+  245 op add :compute:zx *tmp83 :compute:cx
+  246 op mul *tmp85 2 :compute:x1
+  247 op mul *tmp86 *tmp85 :compute:zy
+  248 op add :compute:zy *tmp86 :compute:cy
+  249 op len :compute:dist :compute:zx :compute:zy
+  250 jump *label182 lessThan :compute:dist 64
+  251 jump *label63 always
+  252 label *label182
+  253 label *label183
+  254 label *label184
+  255 op add :compute:i :compute:i 1
+  256 set :compute:x1 :compute:zx
+  257 op mul *tmp81 :compute:zx :compute:zx
+  258 op mul *tmp82 :compute:zy :compute:zy
+  259 op sub *tmp83 *tmp81 *tmp82
+  260 op add :compute:zx *tmp83 :compute:cx
+  261 op mul *tmp85 2 :compute:x1
+  262 op mul *tmp86 *tmp85 :compute:zy
+  263 op add :compute:zy *tmp86 :compute:cy
+  264 op len :compute:dist :compute:zx :compute:zy
+  265 jump *label185 lessThan :compute:dist 64
+  266 jump *label63 always
+  267 label *label185
+  268 label *label186
+  269 label *label187
+  270 op add :compute:i :compute:i 1
+  271 set :compute:x1 :compute:zx
+  272 op mul *tmp81 :compute:zx :compute:zx
+  273 op mul *tmp82 :compute:zy :compute:zy
+  274 op sub *tmp83 *tmp81 *tmp82
+  275 op add :compute:zx *tmp83 :compute:cx
+  276 op mul *tmp85 2 :compute:x1
+  277 op mul *tmp86 *tmp85 :compute:zy
+  278 op add :compute:zy *tmp86 :compute:cy
+  279 op len :compute:dist :compute:zx :compute:zy
+  280 jump *label188 lessThan :compute:dist 64
+  281 jump *label63 always
+  282 label *label188
+  283 label *label189
+  284 label *label190
+  285 op add :compute:i :compute:i 1
+  286 set :compute:x1 :compute:zx
+  287 op mul *tmp81 :compute:zx :compute:zx
+  288 op mul *tmp82 :compute:zy :compute:zy
+  289 op sub *tmp83 *tmp81 *tmp82
+  290 op add :compute:zx *tmp83 :compute:cx
+  291 op mul *tmp85 2 :compute:x1
+  292 op mul *tmp86 *tmp85 :compute:zy
+  293 op add :compute:zy *tmp86 :compute:cy
+  294 op len :compute:dist :compute:zx :compute:zy
+  295 jump *label191 lessThan :compute:dist 64
+  296 jump *label63 always
+  297 label *label191
+  298 label *label192
+  299 label *label193
+  300 op add :compute:i :compute:i 1
+  301 set :compute:x1 :compute:zx
+  302 op mul *tmp81 :compute:zx :compute:zx
+  303 op mul *tmp82 :compute:zy :compute:zy
+  304 op sub *tmp83 *tmp81 *tmp82
+  305 op add :compute:zx *tmp83 :compute:cx
+  306 op mul *tmp85 2 :compute:x1
+  307 op mul *tmp86 *tmp85 :compute:zy
+  308 op add :compute:zy *tmp86 :compute:cy
+  309 op len :compute:dist :compute:zx :compute:zy
+  310 jump *label194 lessThan :compute:dist 64
+  311 jump *label63 always
+  312 label *label194
+  313 label *label195
+  314 label *label196
+  315 op add :compute:i :compute:i 1
+  316 set :compute:x1 :compute:zx
+  317 op mul *tmp81 :compute:zx :compute:zx
+  318 op mul *tmp82 :compute:zy :compute:zy
+  319 op sub *tmp83 *tmp81 *tmp82
+  320 op add :compute:zx *tmp83 :compute:cx
+  321 op mul *tmp85 2 :compute:x1
+  322 op mul *tmp86 *tmp85 :compute:zy
+  323 op add :compute:zy *tmp86 :compute:cy
+  324 op len :compute:dist :compute:zx :compute:zy
+  325 jump *label197 lessThan :compute:dist 64
+  326 jump *label63 always
+  327 label *label197
+  328 label *label198
+  329 label *label199
+  330 op add :compute:i :compute:i 1
+  331 set :compute:x1 :compute:zx
+  332 op mul *tmp81 :compute:zx :compute:zx
+  333 op mul *tmp82 :compute:zy :compute:zy
+  334 op sub *tmp83 *tmp81 *tmp82
+  335 op add :compute:zx *tmp83 :compute:cx
+  336 op mul *tmp85 2 :compute:x1
+  337 op mul *tmp86 *tmp85 :compute:zy
+  338 op add :compute:zy *tmp86 :compute:cy
+  339 op len :compute:dist :compute:zx :compute:zy
+  340 jump *label200 lessThan :compute:dist 64
+  341 jump *label63 always
+  342 label *label200
+  343 label *label201
+  344 label *label202
+  345 op add :compute:i :compute:i 1
+  346 set :compute:x1 :compute:zx
+  347 op mul *tmp81 :compute:zx :compute:zx
+  348 op mul *tmp82 :compute:zy :compute:zy
+  349 op sub *tmp83 *tmp81 *tmp82
+  350 op add :compute:zx *tmp83 :compute:cx
+  351 op mul *tmp85 2 :compute:x1
+  352 op mul *tmp86 *tmp85 :compute:zy
+  353 op add :compute:zy *tmp86 :compute:cy
+  354 op len :compute:dist :compute:zx :compute:zy
+  355 jump *label203 lessThan :compute:dist 64
+  356 jump *label63 always
+  357 label *label203
+  358 label *label204
+  359 label *label205
+  360 op add :compute:i :compute:i 1
+  361 set :compute:x1 :compute:zx
+  362 op mul *tmp81 :compute:zx :compute:zx
+  363 op mul *tmp82 :compute:zy :compute:zy
+  364 op sub *tmp83 *tmp81 *tmp82
+  365 op add :compute:zx *tmp83 :compute:cx
+  366 op mul *tmp85 2 :compute:x1
+  367 op mul *tmp86 *tmp85 :compute:zy
+  368 op add :compute:zy *tmp86 :compute:cy
+  369 op len :compute:dist :compute:zx :compute:zy
+  370 jump *label206 lessThan :compute:dist 64
+  371 jump *label63 always
+  372 label *label206
+  373 label *label207
+  374 label *label208
+  375 op add :compute:i :compute:i 1
+  376 set :compute:x1 :compute:zx
+  377 op mul *tmp81 :compute:zx :compute:zx
+  378 op mul *tmp82 :compute:zy :compute:zy
+  379 op sub *tmp83 *tmp81 *tmp82
+  380 op add :compute:zx *tmp83 :compute:cx
+  381 op mul *tmp85 2 :compute:x1
+  382 op mul *tmp86 *tmp85 :compute:zy
+  383 op add :compute:zy *tmp86 :compute:cy
+  384 op len :compute:dist :compute:zx :compute:zy
+  385 jump *label209 lessThan :compute:dist 64
+  386 jump *label63 always
+  387 label *label209
+  388 label *label210
+  389 label *label211
+  390 op add :compute:i :compute:i 1
+  391 set :compute:x1 :compute:zx
+  392 op mul *tmp81 :compute:zx :compute:zx
+  393 op mul *tmp82 :compute:zy :compute:zy
+  394 op sub *tmp83 *tmp81 *tmp82
+  395 op add :compute:zx *tmp83 :compute:cx
+  396 op mul *tmp85 2 :compute:x1
+  397 op mul *tmp86 *tmp85 :compute:zy
+  398 op add :compute:zy *tmp86 :compute:cy
+  399 op len :compute:dist :compute:zx :compute:zy
+  400 jump *label212 lessThan :compute:dist 64
+  401 jump *label63 always
+  402 label *label212
+  403 label *label213
+  404 label *label214
+  405 op add :compute:i :compute:i 1
+  406 set :compute:x1 :compute:zx
+  407 op mul *tmp81 :compute:zx :compute:zx
+  408 op mul *tmp82 :compute:zy :compute:zy
+  409 op sub *tmp83 *tmp81 *tmp82
+  410 op add :compute:zx *tmp83 :compute:cx
+  411 op mul *tmp85 2 :compute:x1
+  412 op mul *tmp86 *tmp85 :compute:zy
+  413 op add :compute:zy *tmp86 :compute:cy
+  414 op len :compute:dist :compute:zx :compute:zy
+  415 jump *label215 lessThan :compute:dist 64
+  416 jump *label63 always
+  417 label *label215
+  418 label *label216
+  419 label *label217
+  420 op add :compute:i :compute:i 1
+  421 set :compute:x1 :compute:zx
+  422 op mul *tmp81 :compute:zx :compute:zx
+  423 op mul *tmp82 :compute:zy :compute:zy
+  424 op sub *tmp83 *tmp81 *tmp82
+  425 op add :compute:zx *tmp83 :compute:cx
+  426 op mul *tmp85 2 :compute:x1
+  427 op mul *tmp86 *tmp85 :compute:zy
+  428 op add :compute:zy *tmp86 :compute:cy
+  429 op len :compute:dist :compute:zx :compute:zy
+  430 jump *label218 lessThan :compute:dist 64
+  431 jump *label63 always
+  432 label *label218
+  433 label *label219
+  434 label *label220
+  435 op add :compute:i :compute:i 1
+  436 set :compute:x1 :compute:zx
+  437 op mul *tmp81 :compute:zx :compute:zx
+  438 op mul *tmp82 :compute:zy :compute:zy
+  439 op sub *tmp83 *tmp81 *tmp82
+  440 op add :compute:zx *tmp83 :compute:cx
+  441 op mul *tmp85 2 :compute:x1
+  442 op mul *tmp86 *tmp85 :compute:zy
+  443 op add :compute:zy *tmp86 :compute:cy
+  444 op len :compute:dist :compute:zx :compute:zy
+  445 jump *label221 lessThan :compute:dist 64
+  446 jump *label63 always
+  447 label *label221
+  448 label *label222
+  449 label *label223
+  450 op add :compute:i :compute:i 1
+  451 set :compute:x1 :compute:zx
+  452 op mul *tmp81 :compute:zx :compute:zx
+  453 op mul *tmp82 :compute:zy :compute:zy
+  454 op sub *tmp83 *tmp81 *tmp82
+  455 op add :compute:zx *tmp83 :compute:cx
+  456 op mul *tmp85 2 :compute:x1
+  457 op mul *tmp86 *tmp85 :compute:zy
+  458 op add :compute:zy *tmp86 :compute:cy
+  459 op len :compute:dist :compute:zx :compute:zy
+  460 jump *label224 lessThan :compute:dist 64
+  461 jump *label63 always
+  462 label *label224
+  463 label *label225
+  464 label *label226
+  465 op add :compute:i :compute:i 1
+  466 set :compute:x1 :compute:zx
+  467 op mul *tmp81 :compute:zx :compute:zx
+  468 op mul *tmp82 :compute:zy :compute:zy
+  469 op sub *tmp83 *tmp81 *tmp82
+  470 op add :compute:zx *tmp83 :compute:cx
+  471 op mul *tmp85 2 :compute:x1
+  472 op mul *tmp86 *tmp85 :compute:zy
+  473 op add :compute:zy *tmp86 :compute:cy
+  474 op len :compute:dist :compute:zx :compute:zy
+  475 jump *label227 lessThan :compute:dist 64
+  476 jump *label63 always
+  477 label *label227
+  478 label *label228
+  479 label *label229
+  480 op add :compute:i :compute:i 1
+  481 set :compute:x1 :compute:zx
+  482 op mul *tmp81 :compute:zx :compute:zx
+  483 op mul *tmp82 :compute:zy :compute:zy
+  484 op sub *tmp83 *tmp81 *tmp82
+  485 op add :compute:zx *tmp83 :compute:cx
+  486 op mul *tmp85 2 :compute:x1
+  487 op mul *tmp86 *tmp85 :compute:zy
+  488 op add :compute:zy *tmp86 :compute:cy
+  489 op len :compute:dist :compute:zx :compute:zy
+  490 jump *label230 lessThan :compute:dist 64
+  491 jump *label63 always
+  492 label *label230
+  493 label *label231
+  494 label *label232
+  495 op add :compute:i :compute:i 1
+  496 set :compute:x1 :compute:zx
+  497 op mul *tmp81 :compute:zx :compute:zx
+  498 op mul *tmp82 :compute:zy :compute:zy
+  499 op sub *tmp83 *tmp81 *tmp82
+  500 op add :compute:zx *tmp83 :compute:cx
+  501 op mul *tmp85 2 :compute:x1
+  502 op mul *tmp86 *tmp85 :compute:zy
+  503 op add :compute:zy *tmp86 :compute:cy
+  504 op len :compute:dist :compute:zx :compute:zy
+  505 jump *label233 lessThan :compute:dist 64
+  506 jump *label63 always
+  507 label *label233
+  508 label *label234
+  509 label *label235
+  510 op add :compute:i :compute:i 1
+  511 set :compute:x1 :compute:zx
+  512 op mul *tmp81 :compute:zx :compute:zx
+  513 op mul *tmp82 :compute:zy :compute:zy
+  514 op sub *tmp83 *tmp81 *tmp82
+  515 op add :compute:zx *tmp83 :compute:cx
+  516 op mul *tmp85 2 :compute:x1
+  517 op mul *tmp86 *tmp85 :compute:zy
+  518 op add :compute:zy *tmp86 :compute:cy
+  519 op len :compute:dist :compute:zx :compute:zy
+  520 jump *label236 lessThan :compute:dist 64
+  521 jump *label63 always
+  522 label *label236
+  523 label *label237
+  524 label *label238
+  525 op add :compute:i :compute:i 1
+  526 set :compute:x1 :compute:zx
+  527 op mul *tmp81 :compute:zx :compute:zx
+  528 op mul *tmp82 :compute:zy :compute:zy
+  529 op sub *tmp83 *tmp81 *tmp82
+  530 op add :compute:zx *tmp83 :compute:cx
+  531 op mul *tmp85 2 :compute:x1
+  532 op mul *tmp86 *tmp85 :compute:zy
+  533 op add :compute:zy *tmp86 :compute:cy
+  534 op len :compute:dist :compute:zx :compute:zy
+  535 jump *label239 lessThan :compute:dist 64
+  536 jump *label63 always
+  537 label *label239
+  538 label *label240
+  539 label *label241
+  540 op add :compute:i :compute:i 1
+  541 set :compute:x1 :compute:zx
+  542 op mul *tmp81 :compute:zx :compute:zx
+  543 op mul *tmp82 :compute:zy :compute:zy
+  544 op sub *tmp83 *tmp81 *tmp82
+  545 op add :compute:zx *tmp83 :compute:cx
+  546 op mul *tmp85 2 :compute:x1
+  547 op mul *tmp86 *tmp85 :compute:zy
+  548 op add :compute:zy *tmp86 :compute:cy
+  549 op len :compute:dist :compute:zx :compute:zy
+  550 jump *label242 lessThan :compute:dist 64
+  551 jump *label63 always
+  552 label *label242
+  553 label *label243
+  554 label *label244
+  555 op add :compute:i :compute:i 1
+  556 set :compute:x1 :compute:zx
+  557 op mul *tmp81 :compute:zx :compute:zx
+  558 op mul *tmp82 :compute:zy :compute:zy
+  559 op sub *tmp83 *tmp81 *tmp82
+  560 op add :compute:zx *tmp83 :compute:cx
+  561 op mul *tmp85 2 :compute:x1
+  562 op mul *tmp86 *tmp85 :compute:zy
+  563 op add :compute:zy *tmp86 :compute:cy
+  564 op len :compute:dist :compute:zx :compute:zy
+  565 jump *label245 lessThan :compute:dist 64
+  566 jump *label63 always
+  567 label *label245
+  568 label *label246
+  569 label *label247
+  570 op add :compute:i :compute:i 1
+  571 set :compute:x1 :compute:zx
+  572 op mul *tmp81 :compute:zx :compute:zx
+  573 op mul *tmp82 :compute:zy :compute:zy
+  574 op sub *tmp83 *tmp81 *tmp82
+  575 op add :compute:zx *tmp83 :compute:cx
+  576 op mul *tmp85 2 :compute:x1
+  577 op mul *tmp86 *tmp85 :compute:zy
+  578 op add :compute:zy *tmp86 :compute:cy
+  579 op len :compute:dist :compute:zx :compute:zy
+  580 jump *label248 lessThan :compute:dist 64
+  581 jump *label63 always
+  582 label *label248
+  583 label *label249
+  584 label *label250
+  585 op add :compute:i :compute:i 1
+  586 set :compute:x1 :compute:zx
+  587 op mul *tmp81 :compute:zx :compute:zx
+  588 op mul *tmp82 :compute:zy :compute:zy
+  589 op sub *tmp83 *tmp81 *tmp82
+  590 op add :compute:zx *tmp83 :compute:cx
+  591 op mul *tmp85 2 :compute:x1
+  592 op mul *tmp86 *tmp85 :compute:zy
+  593 op add :compute:zy *tmp86 :compute:cy
+  594 op len :compute:dist :compute:zx :compute:zy
+  595 jump *label251 lessThan :compute:dist 64
+  596 jump *label63 always
+  597 label *label251
+  598 label *label252
+  599 label *label253
+  600 op add :compute:i :compute:i 1
+  601 set :compute:x1 :compute:zx
+  602 op mul *tmp81 :compute:zx :compute:zx
+  603 op mul *tmp82 :compute:zy :compute:zy
+  604 op sub *tmp83 *tmp81 *tmp82
+  605 op add :compute:zx *tmp83 :compute:cx
+  606 op mul *tmp85 2 :compute:x1
+  607 op mul *tmp86 *tmp85 :compute:zy
+  608 op add :compute:zy *tmp86 :compute:cy
+  609 op len :compute:dist :compute:zx :compute:zy
+  610 jump *label254 lessThan :compute:dist 64
+  611 jump *label63 always
+  612 label *label254
+  613 label *label255
+  614 label *label256
+  615 op add :compute:i :compute:i 1
+  616 set :compute:x1 :compute:zx
+  617 op mul *tmp81 :compute:zx :compute:zx
+  618 op mul *tmp82 :compute:zy :compute:zy
+  619 op sub *tmp83 *tmp81 *tmp82
+  620 op add :compute:zx *tmp83 :compute:cx
+  621 op mul *tmp85 2 :compute:x1
+  622 op mul *tmp86 *tmp85 :compute:zy
+  623 op add :compute:zy *tmp86 :compute:cy
+  624 op len :compute:dist :compute:zx :compute:zy
+  625 jump *label257 lessThan :compute:dist 64
+  626 jump *label63 always
+  627 label *label257
+  628 label *label258
+  629 label *label259
+  630 op add :compute:i :compute:i 1
+  631 set :compute:x1 :compute:zx
+  632 op mul *tmp81 :compute:zx :compute:zx
+  633 op mul *tmp82 :compute:zy :compute:zy
+  634 op sub *tmp83 *tmp81 *tmp82
+  635 op add :compute:zx *tmp83 :compute:cx
+  636 op mul *tmp85 2 :compute:x1
+  637 op mul *tmp86 *tmp85 :compute:zy
+  638 op add :compute:zy *tmp86 :compute:cy
+  639 op len :compute:dist :compute:zx :compute:zy
+  640 jump *label260 lessThan :compute:dist 64
+  641 jump *label63 always
+  642 label *label260
+  643 label *label261
+  644 label *label262
+  645 op add :compute:i :compute:i 1
+  646 set :compute:x1 :compute:zx
+  647 op mul *tmp81 :compute:zx :compute:zx
+  648 op mul *tmp82 :compute:zy :compute:zy
+  649 op sub *tmp83 *tmp81 *tmp82
+  650 op add :compute:zx *tmp83 :compute:cx
+  651 op mul *tmp85 2 :compute:x1
+  652 op mul *tmp86 *tmp85 :compute:zy
+  653 op add :compute:zy *tmp86 :compute:cy
+  654 op len :compute:dist :compute:zx :compute:zy
+  655 jump *label263 lessThan :compute:dist 64
+  656 jump *label63 always
+  657 label *label263
+  658 label *label264
+  659 label *label265
+  660 op add :compute:i :compute:i 1
+  661 set :compute:x1 :compute:zx
+  662 op mul *tmp81 :compute:zx :compute:zx
+  663 op mul *tmp82 :compute:zy :compute:zy
+  664 op sub *tmp83 *tmp81 *tmp82
+  665 op add :compute:zx *tmp83 :compute:cx
+  666 op mul *tmp85 2 :compute:x1
+  667 op mul *tmp86 *tmp85 :compute:zy
+  668 op add :compute:zy *tmp86 :compute:cy
+  669 op len :compute:dist :compute:zx :compute:zy
+  670 jump *label266 lessThan :compute:dist 64
+  671 jump *label63 always
+  672 label *label266
+  673 label *label267
+  674 label *label268
+  675 op add :compute:i :compute:i 1
+  676 set :compute:x1 :compute:zx
+  677 op mul *tmp81 :compute:zx :compute:zx
+  678 op mul *tmp82 :compute:zy :compute:zy
+  679 op sub *tmp83 *tmp81 *tmp82
+  680 op add :compute:zx *tmp83 :compute:cx
+  681 op mul *tmp85 2 :compute:x1
+  682 op mul *tmp86 *tmp85 :compute:zy
+  683 op add :compute:zy *tmp86 :compute:cy
+  684 op len :compute:dist :compute:zx :compute:zy
+  685 jump *label269 lessThan :compute:dist 64
+  686 jump *label63 always
+  687 label *label269
+  688 label *label270
+  689 label *label271
+  690 op add :compute:i :compute:i 1
+  691 set :compute:x1 :compute:zx
+  692 op mul *tmp81 :compute:zx :compute:zx
+  693 op mul *tmp82 :compute:zy :compute:zy
+  694 op sub *tmp83 *tmp81 *tmp82
+  695 op add :compute:zx *tmp83 :compute:cx
+  696 op mul *tmp85 2 :compute:x1
+  697 op mul *tmp86 *tmp85 :compute:zy
+  698 op add :compute:zy *tmp86 :compute:cy
+  699 op len :compute:dist :compute:zx :compute:zy
+  700 jump *label272 lessThan :compute:dist 64
+  701 jump *label63 always
+  702 label *label272
+  703 label *label273
+  704 label *label274
+  705 op add :compute:i :compute:i 1
+  706 set :compute:x1 :compute:zx
+  707 op mul *tmp81 :compute:zx :compute:zx
+  708 op mul *tmp82 :compute:zy :compute:zy
+  709 op sub *tmp83 *tmp81 *tmp82
+  710 op add :compute:zx *tmp83 :compute:cx
+  711 op mul *tmp85 2 :compute:x1
+  712 op mul *tmp86 *tmp85 :compute:zy
+  713 op add :compute:zy *tmp86 :compute:cy
+  714 op len :compute:dist :compute:zx :compute:zy
+  715 jump *label275 lessThan :compute:dist 64
+  716 jump *label63 always
+  717 label *label275
+  718 label *label276
+  719 label *label277
+  720 op add :compute:i :compute:i 1
+  721 set :compute:x1 :compute:zx
+  722 op mul *tmp81 :compute:zx :compute:zx
+  723 op mul *tmp82 :compute:zy :compute:zy
+  724 op sub *tmp83 *tmp81 *tmp82
+  725 op add :compute:zx *tmp83 :compute:cx
+  726 op mul *tmp85 2 :compute:x1
+  727 op mul *tmp86 *tmp85 :compute:zy
+  728 op add :compute:zy *tmp86 :compute:cy
+  729 op len :compute:dist :compute:zx :compute:zy
+  730 jump *label278 lessThan :compute:dist 64
+  731 jump *label63 always
+  732 label *label278
+  733 label *label279
+  734 label *label280
+  735 op add :compute:i :compute:i 1
+  736 set :compute:x1 :compute:zx
+  737 op mul *tmp81 :compute:zx :compute:zx
+  738 op mul *tmp82 :compute:zy :compute:zy
+  739 op sub *tmp83 *tmp81 *tmp82
+  740 op add :compute:zx *tmp83 :compute:cx
+  741 op mul *tmp85 2 :compute:x1
+  742 op mul *tmp86 *tmp85 :compute:zy
+  743 op add :compute:zy *tmp86 :compute:cy
+  744 op len :compute:dist :compute:zx :compute:zy
+  745 jump *label281 lessThan :compute:dist 64
+  746 jump *label63 always
+  747 label *label281
+  748 label *label282
+  749 label *label283
+  750 op add :compute:i :compute:i 1
+  751 set :compute:x1 :compute:zx
+  752 op mul *tmp81 :compute:zx :compute:zx
+  753 op mul *tmp82 :compute:zy :compute:zy
+  754 op sub *tmp83 *tmp81 *tmp82
+  755 op add :compute:zx *tmp83 :compute:cx
+  756 op mul *tmp85 2 :compute:x1
+  757 op mul *tmp86 *tmp85 :compute:zy
+  758 op add :compute:zy *tmp86 :compute:cy
+  759 op len :compute:dist :compute:zx :compute:zy
+  760 jump *label284 lessThan :compute:dist 64
+  761 jump *label63 always
+  762 label *label284
+  763 label *label285
+  764 label *label286
+  765 op add :compute:i :compute:i 1
+  766 set :compute:x1 :compute:zx
+  767 op mul *tmp81 :compute:zx :compute:zx
+  768 op mul *tmp82 :compute:zy :compute:zy
+  769 op sub *tmp83 *tmp81 *tmp82
+  770 op add :compute:zx *tmp83 :compute:cx
+  771 op mul *tmp85 2 :compute:x1
+  772 op mul *tmp86 *tmp85 :compute:zy
+  773 op add :compute:zy *tmp86 :compute:cy
+  774 op len :compute:dist :compute:zx :compute:zy
+  775 jump *label287 lessThan :compute:dist 64
+  776 jump *label63 always
+  777 label *label287
+  778 label *label288
+  779 label *label289
+  780 op add :compute:i :compute:i 1
+  781 set :compute:x1 :compute:zx
+  782 op mul *tmp81 :compute:zx :compute:zx
+  783 op mul *tmp82 :compute:zy :compute:zy
+  784 op sub *tmp83 *tmp81 *tmp82
+  785 op add :compute:zx *tmp83 :compute:cx
+  786 op mul *tmp85 2 :compute:x1
+  787 op mul *tmp86 *tmp85 :compute:zy
+  788 op add :compute:zy *tmp86 :compute:cy
+  789 op len :compute:dist :compute:zx :compute:zy
+  790 jump *label290 lessThan :compute:dist 64
+  791 jump *label63 always
+  792 label *label290
+  793 label *label291
+  794 label *label292
+  795 op add :compute:i :compute:i 1
+  796 set :compute:x1 :compute:zx
+  797 op mul *tmp81 :compute:zx :compute:zx
+  798 op mul *tmp82 :compute:zy :compute:zy
+  799 op sub *tmp83 *tmp81 *tmp82
+  800 op add :compute:zx *tmp83 :compute:cx
+  801 op mul *tmp85 2 :compute:x1
+  802 op mul *tmp86 *tmp85 :compute:zy
+  803 op add :compute:zy *tmp86 :compute:cy
+  804 op len :compute:dist :compute:zx :compute:zy
+  805 jump *label293 lessThan :compute:dist 64
+  806 jump *label63 always
+  807 label *label293
+  808 label *label294
+  809 label *label295
+  810 op add :compute:i :compute:i 1
+  811 set :compute:x1 :compute:zx
+  812 op mul *tmp81 :compute:zx :compute:zx
+  813 op mul *tmp82 :compute:zy :compute:zy
+  814 op sub *tmp83 *tmp81 *tmp82
+  815 op add :compute:zx *tmp83 :compute:cx
+  816 op mul *tmp85 2 :compute:x1
+  817 op mul *tmp86 *tmp85 :compute:zy
+  818 op add :compute:zy *tmp86 :compute:cy
+  819 op len :compute:dist :compute:zx :compute:zy
+  820 jump *label296 lessThan :compute:dist 64
+  821 jump *label63 always
+  822 label *label296
+  823 label *label297
+  824 label *label298
+  825 op add :compute:i :compute:i 1
+  826 set :compute:x1 :compute:zx
+  827 op mul *tmp81 :compute:zx :compute:zx
+  828 op mul *tmp82 :compute:zy :compute:zy
+  829 op sub *tmp83 *tmp81 *tmp82
+  830 op add :compute:zx *tmp83 :compute:cx
+  831 op mul *tmp85 2 :compute:x1
+  832 op mul *tmp86 *tmp85 :compute:zy
+  833 op add :compute:zy *tmp86 :compute:cy
+  834 op len :compute:dist :compute:zx :compute:zy
+  835 jump *label299 lessThan :compute:dist 64
+  836 jump *label63 always
+  837 label *label299
+  838 label *label300
+  839 label *label301
+  840 op add :compute:i :compute:i 1
+  841 set :compute:x1 :compute:zx
+  842 op mul *tmp81 :compute:zx :compute:zx
+  843 op mul *tmp82 :compute:zy :compute:zy
+  844 op sub *tmp83 *tmp81 *tmp82
+  845 op add :compute:zx *tmp83 :compute:cx
+  846 op mul *tmp85 2 :compute:x1
+  847 op mul *tmp86 *tmp85 :compute:zy
+  848 op add :compute:zy *tmp86 :compute:cy
+  849 op len :compute:dist :compute:zx :compute:zy
+  850 jump *label302 lessThan :compute:dist 64
+  851 jump *label63 always
+  852 label *label302
+  853 label *label303
+  854 label *label304
+  855 op add :compute:i :compute:i 1
+  856 set :compute:x1 :compute:zx
+  857 op mul *tmp81 :compute:zx :compute:zx
+  858 op mul *tmp82 :compute:zy :compute:zy
+  859 op sub *tmp83 *tmp81 *tmp82
+  860 op add :compute:zx *tmp83 :compute:cx
+  861 op mul *tmp85 2 :compute:x1
+  862 op mul *tmp86 *tmp85 :compute:zy
+  863 op add :compute:zy *tmp86 :compute:cy
+  864 op len :compute:dist :compute:zx :compute:zy
+  865 jump *label305 lessThan :compute:dist 64
+  866 jump *label63 always
+  867 label *label305
+  868 label *label306
+  869 label *label307
+  870 op add :compute:i :compute:i 1
+  871 set :compute:x1 :compute:zx
+  872 op mul *tmp81 :compute:zx :compute:zx
+  873 op mul *tmp82 :compute:zy :compute:zy
+  874 op sub *tmp83 *tmp81 *tmp82
+  875 op add :compute:zx *tmp83 :compute:cx
+  876 op mul *tmp85 2 :compute:x1
+  877 op mul *tmp86 *tmp85 :compute:zy
+  878 op add :compute:zy *tmp86 :compute:cy
+  879 op len :compute:dist :compute:zx :compute:zy
+  880 jump *label308 lessThan :compute:dist 64
+  881 jump *label63 always
+  882 label *label308
+  883 label *label309
+  884 label *label310
+  885 op add :compute:i :compute:i 1
+  886 set :compute:x1 :compute:zx
+  887 op mul *tmp81 :compute:zx :compute:zx
+  888 op mul *tmp82 :compute:zy :compute:zy
+  889 op sub *tmp83 *tmp81 *tmp82
+  890 op add :compute:zx *tmp83 :compute:cx
+  891 op mul *tmp85 2 :compute:x1
+  892 op mul *tmp86 *tmp85 :compute:zy
+  893 op add :compute:zy *tmp86 :compute:cy
+  894 op len :compute:dist :compute:zx :compute:zy
+  895 jump *label311 lessThan :compute:dist 64
+  896 jump *label63 always
+  897 label *label311
+  898 label *label312
+  899 label *label313
+  900 op add :compute:i :compute:i 1
+  901 set :compute:x1 :compute:zx
+  902 op mul *tmp81 :compute:zx :compute:zx
+  903 op mul *tmp82 :compute:zy :compute:zy
+  904 op sub *tmp83 *tmp81 *tmp82
+  905 op add :compute:zx *tmp83 :compute:cx
+  906 op mul *tmp85 2 :compute:x1
+  907 op mul *tmp86 *tmp85 :compute:zy
+  908 op add :compute:zy *tmp86 :compute:cy
+  909 op len :compute:dist :compute:zx :compute:zy
+  910 jump *label314 lessThan :compute:dist 64
+  911 jump *label63 always
+  912 label *label314
+  913 label *label315
+  914 label *label316
+  915 op add :compute:i :compute:i 1
+  916 set :compute:x1 :compute:zx
+  917 op mul *tmp81 :compute:zx :compute:zx
+  918 op mul *tmp82 :compute:zy :compute:zy
+  919 op sub *tmp83 *tmp81 *tmp82
+  920 op add :compute:zx *tmp83 :compute:cx
+  921 op mul *tmp85 2 :compute:x1
+  922 op mul *tmp86 *tmp85 :compute:zy
+  923 op add :compute:zy *tmp86 :compute:cy
+  924 op len :compute:dist :compute:zx :compute:zy
+  925 jump *label317 lessThan :compute:dist 64
+  926 jump *label63 always
+  927 label *label317
+  928 label *label318
+  929 label *label319
+  930 op add :compute:i :compute:i 1
+  931 set :compute:x1 :compute:zx
+  932 op mul *tmp81 :compute:zx :compute:zx
+  933 op mul *tmp82 :compute:zy :compute:zy
+  934 op sub *tmp83 *tmp81 *tmp82
+  935 op add :compute:zx *tmp83 :compute:cx
+  936 op mul *tmp85 2 :compute:x1
+  937 op mul *tmp86 *tmp85 :compute:zy
+  938 op add :compute:zy *tmp86 :compute:cy
+  939 op len :compute:dist :compute:zx :compute:zy
+  940 jump *label320 lessThan :compute:dist 64
+  941 jump *label63 always
+  942 label *label320
+  943 label *label321
+  944 label *label322
+  945 op add :compute:i :compute:i 1
+  946 set :compute:x1 :compute:zx
+  947 op mul *tmp81 :compute:zx :compute:zx
+  948 op mul *tmp82 :compute:zy :compute:zy
+  949 op sub *tmp83 *tmp81 *tmp82
+  950 op add :compute:zx *tmp83 :compute:cx
+  951 op mul *tmp85 2 :compute:x1
+  952 op mul *tmp86 *tmp85 :compute:zy
+  953 op add :compute:zy *tmp86 :compute:cy
+  954 op len :compute:dist :compute:zx :compute:zy
+  955 jump *label323 lessThan :compute:dist 64
+  956 jump *label63 always
+  957 label *label323
+  958 label *label324
+  959 label *label325
+  960 op add :compute:i :compute:i 1
+  961 set :compute:x1 :compute:zx
+  962 op mul *tmp81 :compute:zx :compute:zx
+  963 op mul *tmp82 :compute:zy :compute:zy
+  964 op sub *tmp83 *tmp81 *tmp82
+  965 op add :compute:zx *tmp83 :compute:cx
+  966 op mul *tmp85 2 :compute:x1
+  967 op mul *tmp86 *tmp85 :compute:zy
+  968 op add :compute:zy *tmp86 :compute:cy
+  969 op len :compute:dist :compute:zx :compute:zy
+  970 jump *label326 lessThan :compute:dist 64
+  971 jump *label63 always
+  972 label *label326
+  973 label *label327
+  974 label *label328
+  975 op add :compute:i :compute:i 1
+  976 set :compute:x1 :compute:zx
+  977 op mul *tmp81 :compute:zx :compute:zx
+  978 op mul *tmp82 :compute:zy :compute:zy
+  979 op sub *tmp83 *tmp81 *tmp82
+  980 op add :compute:zx *tmp83 :compute:cx
+  981 op mul *tmp85 2 :compute:x1
+  982 op mul *tmp86 *tmp85 :compute:zy
+  983 op add :compute:zy *tmp86 :compute:cy
+  984 op len :compute:dist :compute:zx :compute:zy
+  985 jump *label329 lessThan :compute:dist 64
+  986 jump *label63 always
+  987 label *label329
+  988 label *label330
+  989 label *label331
+  990 op add :compute:i :compute:i 1
+  991 set :compute:x1 :compute:zx
+  992 op mul *tmp81 :compute:zx :compute:zx
+  993 op mul *tmp82 :compute:zy :compute:zy
+  994 op sub *tmp83 *tmp81 *tmp82
+  995 op add :compute:zx *tmp83 :compute:cx
+  996 op mul *tmp85 2 :compute:x1
+  997 op mul *tmp86 *tmp85 :compute:zy
+  998 op add :compute:zy *tmp86 :compute:cy
+  999 op len :compute:dist :compute:zx :compute:zy
+ 1000 jump *label332 lessThan :compute:dist 64
+ 1001 jump *label63 always
+ 1002 label *label332
+ 1003 label *label333
+ 1004 label *label334
+ 1005 op add :compute:i :compute:i 1
+ 1006 set :compute:x1 :compute:zx
+ 1007 op mul *tmp81 :compute:zx :compute:zx
+ 1008 op mul *tmp82 :compute:zy :compute:zy
+ 1009 op sub *tmp83 *tmp81 *tmp82
+ 1010 op add :compute:zx *tmp83 :compute:cx
+ 1011 op mul *tmp85 2 :compute:x1
+ 1012 op mul *tmp86 *tmp85 :compute:zy
+ 1013 op add :compute:zy *tmp86 :compute:cy
+ 1014 op len :compute:dist :compute:zx :compute:zy
+ 1015 jump *label335 lessThan :compute:dist 64
+ 1016 jump *label63 always
+ 1017 label *label335
+ 1018 label *label336
+ 1019 label *label337
+ 1020 op add :compute:i :compute:i 1
+ 1021 set :compute:x1 :compute:zx
+ 1022 op mul *tmp81 :compute:zx :compute:zx
+ 1023 op mul *tmp82 :compute:zy :compute:zy
+ 1024 op sub *tmp83 *tmp81 *tmp82
+ 1025 op add :compute:zx *tmp83 :compute:cx
+ 1026 op mul *tmp85 2 :compute:x1
+ 1027 op mul *tmp86 *tmp85 :compute:zy
+ 1028 op add :compute:zy *tmp86 :compute:cy
+ 1029 op len :compute:dist :compute:zx :compute:zy
+ 1030 jump *label338 lessThan :compute:dist 64
+ 1031 jump *label63 always
+ 1032 label *label338
+ 1033 label *label339
+ 1034 label *label340
+ 1035 op add :compute:i :compute:i 1
+ 1036 set :compute:x1 :compute:zx
+ 1037 op mul *tmp81 :compute:zx :compute:zx
+ 1038 op mul *tmp82 :compute:zy :compute:zy
+ 1039 op sub *tmp83 *tmp81 *tmp82
+ 1040 op add :compute:zx *tmp83 :compute:cx
+ 1041 op mul *tmp85 2 :compute:x1
+ 1042 op mul *tmp86 *tmp85 :compute:zy
+ 1043 op add :compute:zy *tmp86 :compute:cy
+ 1044 op len :compute:dist :compute:zx :compute:zy
+ 1045 jump *label341 lessThan :compute:dist 64
+ 1046 jump *label63 always
+ 1047 label *label341
+ 1048 label *label342
+ 1049 label *label343
+ 1050 op add :compute:i :compute:i 1
+ 1051 set :compute:x1 :compute:zx
+ 1052 op mul *tmp81 :compute:zx :compute:zx
+ 1053 op mul *tmp82 :compute:zy :compute:zy
+ 1054 op sub *tmp83 *tmp81 *tmp82
+ 1055 op add :compute:zx *tmp83 :compute:cx
+ 1056 op mul *tmp85 2 :compute:x1
+ 1057 op mul *tmp86 *tmp85 :compute:zy
+ 1058 op add :compute:zy *tmp86 :compute:cy
+ 1059 op len :compute:dist :compute:zx :compute:zy
+ 1060 jump *label344 lessThan :compute:dist 64
+ 1061 jump *label63 always
+ 1062 label *label344
+ 1063 label *label345
+ 1064 label *label346
+ 1065 op add :compute:i :compute:i 1
+ 1066 set :compute:x1 :compute:zx
+ 1067 op mul *tmp81 :compute:zx :compute:zx
+ 1068 op mul *tmp82 :compute:zy :compute:zy
+ 1069 op sub *tmp83 *tmp81 *tmp82
+ 1070 op add :compute:zx *tmp83 :compute:cx
+ 1071 op mul *tmp85 2 :compute:x1
+ 1072 op mul *tmp86 *tmp85 :compute:zy
+ 1073 op add :compute:zy *tmp86 :compute:cy
+ 1074 op len :compute:dist :compute:zx :compute:zy
+ 1075 jump *label347 lessThan :compute:dist 64
+ 1076 jump *label63 always
+ 1077 label *label347
+ 1078 label *label348
+ 1079 label *label349
+ 1080 op add :compute:i :compute:i 1
+ 1081 set :compute:x1 :compute:zx
+ 1082 op mul *tmp81 :compute:zx :compute:zx
+ 1083 op mul *tmp82 :compute:zy :compute:zy
+ 1084 op sub *tmp83 *tmp81 *tmp82
+ 1085 op add :compute:zx *tmp83 :compute:cx
+ 1086 op mul *tmp85 2 :compute:x1
+ 1087 op mul *tmp86 *tmp85 :compute:zy
+ 1088 op add :compute:zy *tmp86 :compute:cy
+ 1089 op len :compute:dist :compute:zx :compute:zy
+ 1090 jump *label350 lessThan :compute:dist 64
+ 1091 jump *label63 always
+ 1092 label *label350
+ 1093 label *label351
+ 1094 label *label352
+ 1095 op add :compute:i :compute:i 1
+ 1096 set :compute:x1 :compute:zx
+ 1097 op mul *tmp81 :compute:zx :compute:zx
+ 1098 op mul *tmp82 :compute:zy :compute:zy
+ 1099 op sub *tmp83 *tmp81 *tmp82
+ 1100 op add :compute:zx *tmp83 :compute:cx
+ 1101 op mul *tmp85 2 :compute:x1
+ 1102 op mul *tmp86 *tmp85 :compute:zy
+ 1103 op add :compute:zy *tmp86 :compute:cy
+ 1104 op len :compute:dist :compute:zx :compute:zy
+ 1105 jump *label353 lessThan :compute:dist 64
+ 1106 jump *label63 always
+ 1107 label *label353
+ 1108 label *label354
+ 1109 label *label355
+ 1110 op add :compute:i :compute:i 1
+ 1111 label *label63
  1112 jump *label66 lessThanEq .PALETTE 1
  1113 jump *label66 greaterThanEq :compute:i 63
  1114 op log *tmp93 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   177 label *label167
   178 label *label168
   179 label *label169
-    * op add :compute:i :compute:i 1
+  180 op add :compute:i 0 1
   181 set :compute:x1 :compute:zx
   182 op mul *tmp81 :compute:zx :compute:zx
   183 op mul *tmp82 :compute:zy :compute:zy
 
   192 label *label170
   193 label *label171
   194 label *label172
-    * op add :compute:i :compute:i 1
+  195 op add :compute:i 1 1
   196 set :compute:x1 :compute:zx
   197 op mul *tmp81 :compute:zx :compute:zx
   198 op mul *tmp82 :compute:zy :compute:zy
 
   207 label *label173
   208 label *label174
   209 label *label175
-    * op add :compute:i :compute:i 1
+  210 op add :compute:i 2 1
   211 set :compute:x1 :compute:zx
   212 op mul *tmp81 :compute:zx :compute:zx
   213 op mul *tmp82 :compute:zy :compute:zy
 
   222 label *label176
   223 label *label177
   224 label *label178
-    * op add :compute:i :compute:i 1
+  225 op add :compute:i 3 1
   226 set :compute:x1 :compute:zx
   227 op mul *tmp81 :compute:zx :compute:zx
   228 op mul *tmp82 :compute:zy :compute:zy
 
   237 label *label179
   238 label *label180
   239 label *label181
-    * op add :compute:i :compute:i 1
+  240 op add :compute:i 4 1
   241 set :compute:x1 :compute:zx
   242 op mul *tmp81 :compute:zx :compute:zx
   243 op mul *tmp82 :compute:zy :compute:zy
 
   252 label *label182
   253 label *label183
   254 label *label184
-    * op add :compute:i :compute:i 1
+  255 op add :compute:i 5 1
   256 set :compute:x1 :compute:zx
   257 op mul *tmp81 :compute:zx :compute:zx
   258 op mul *tmp82 :compute:zy :compute:zy
 
   267 label *label185
   268 label *label186
   269 label *label187
-    * op add :compute:i :compute:i 1
+  270 op add :compute:i 6 1
   271 set :compute:x1 :compute:zx
   272 op mul *tmp81 :compute:zx :compute:zx
   273 op mul *tmp82 :compute:zy :compute:zy
 
   282 label *label188
   283 label *label189
   284 label *label190
-    * op add :compute:i :compute:i 1
+  285 op add :compute:i 7 1
   286 set :compute:x1 :compute:zx
   287 op mul *tmp81 :compute:zx :compute:zx
   288 op mul *tmp82 :compute:zy :compute:zy
 
   297 label *label191
   298 label *label192
   299 label *label193
-    * op add :compute:i :compute:i 1
+  300 op add :compute:i 8 1
   301 set :compute:x1 :compute:zx
   302 op mul *tmp81 :compute:zx :compute:zx
   303 op mul *tmp82 :compute:zy :compute:zy
 
   312 label *label194
   313 label *label195
   314 label *label196
-    * op add :compute:i :compute:i 1
+  315 op add :compute:i 9 1
   316 set :compute:x1 :compute:zx
   317 op mul *tmp81 :compute:zx :compute:zx
   318 op mul *tmp82 :compute:zy :compute:zy
 
   327 label *label197
   328 label *label198
   329 label *label199
-    * op add :compute:i :compute:i 1
+  330 op add :compute:i 10 1
   331 set :compute:x1 :compute:zx
   332 op mul *tmp81 :compute:zx :compute:zx
   333 op mul *tmp82 :compute:zy :compute:zy
 
   342 label *label200
   343 label *label201
   344 label *label202
-    * op add :compute:i :compute:i 1
+  345 op add :compute:i 11 1
   346 set :compute:x1 :compute:zx
   347 op mul *tmp81 :compute:zx :compute:zx
   348 op mul *tmp82 :compute:zy :compute:zy
 
   357 label *label203
   358 label *label204
   359 label *label205
-    * op add :compute:i :compute:i 1
+  360 op add :compute:i 12 1
   361 set :compute:x1 :compute:zx
   362 op mul *tmp81 :compute:zx :compute:zx
   363 op mul *tmp82 :compute:zy :compute:zy
 
   372 label *label206
   373 label *label207
   374 label *label208
-    * op add :compute:i :compute:i 1
+  375 op add :compute:i 13 1
   376 set :compute:x1 :compute:zx
   377 op mul *tmp81 :compute:zx :compute:zx
   378 op mul *tmp82 :compute:zy :compute:zy
 
   387 label *label209
   388 label *label210
   389 label *label211
-    * op add :compute:i :compute:i 1
+  390 op add :compute:i 14 1
   391 set :compute:x1 :compute:zx
   392 op mul *tmp81 :compute:zx :compute:zx
   393 op mul *tmp82 :compute:zy :compute:zy
 
   402 label *label212
   403 label *label213
   404 label *label214
-    * op add :compute:i :compute:i 1
+  405 op add :compute:i 15 1
   406 set :compute:x1 :compute:zx
   407 op mul *tmp81 :compute:zx :compute:zx
   408 op mul *tmp82 :compute:zy :compute:zy
 
   417 label *label215
   418 label *label216
   419 label *label217
-    * op add :compute:i :compute:i 1
+  420 op add :compute:i 16 1
   421 set :compute:x1 :compute:zx
   422 op mul *tmp81 :compute:zx :compute:zx
   423 op mul *tmp82 :compute:zy :compute:zy
 
   432 label *label218
   433 label *label219
   434 label *label220
-    * op add :compute:i :compute:i 1
+  435 op add :compute:i 17 1
   436 set :compute:x1 :compute:zx
   437 op mul *tmp81 :compute:zx :compute:zx
   438 op mul *tmp82 :compute:zy :compute:zy
 
   447 label *label221
   448 label *label222
   449 label *label223
-    * op add :compute:i :compute:i 1
+  450 op add :compute:i 18 1
   451 set :compute:x1 :compute:zx
   452 op mul *tmp81 :compute:zx :compute:zx
   453 op mul *tmp82 :compute:zy :compute:zy
 
   462 label *label224
   463 label *label225
   464 label *label226
-    * op add :compute:i :compute:i 1
+  465 op add :compute:i 19 1
   466 set :compute:x1 :compute:zx
   467 op mul *tmp81 :compute:zx :compute:zx
   468 op mul *tmp82 :compute:zy :compute:zy
 
   477 label *label227
   478 label *label228
   479 label *label229
-    * op add :compute:i :compute:i 1
+  480 op add :compute:i 20 1
   481 set :compute:x1 :compute:zx
   482 op mul *tmp81 :compute:zx :compute:zx
   483 op mul *tmp82 :compute:zy :compute:zy
 
   492 label *label230
   493 label *label231
   494 label *label232
-    * op add :compute:i :compute:i 1
+  495 op add :compute:i 21 1
   496 set :compute:x1 :compute:zx
   497 op mul *tmp81 :compute:zx :compute:zx
   498 op mul *tmp82 :compute:zy :compute:zy
 
   507 label *label233
   508 label *label234
   509 label *label235
-    * op add :compute:i :compute:i 1
+  510 op add :compute:i 22 1
   511 set :compute:x1 :compute:zx
   512 op mul *tmp81 :compute:zx :compute:zx
   513 op mul *tmp82 :compute:zy :compute:zy
 
   522 label *label236
   523 label *label237
   524 label *label238
-    * op add :compute:i :compute:i 1
+  525 op add :compute:i 23 1
   526 set :compute:x1 :compute:zx
   527 op mul *tmp81 :compute:zx :compute:zx
   528 op mul *tmp82 :compute:zy :compute:zy
 
   537 label *label239
   538 label *label240
   539 label *label241
-    * op add :compute:i :compute:i 1
+  540 op add :compute:i 24 1
   541 set :compute:x1 :compute:zx
   542 op mul *tmp81 :compute:zx :compute:zx
   543 op mul *tmp82 :compute:zy :compute:zy
 
   552 label *label242
   553 label *label243
   554 label *label244
-    * op add :compute:i :compute:i 1
+  555 op add :compute:i 25 1
   556 set :compute:x1 :compute:zx
   557 op mul *tmp81 :compute:zx :compute:zx
   558 op mul *tmp82 :compute:zy :compute:zy
 
   567 label *label245
   568 label *label246
   569 label *label247
-    * op add :compute:i :compute:i 1
+  570 op add :compute:i 26 1
   571 set :compute:x1 :compute:zx
   572 op mul *tmp81 :compute:zx :compute:zx
   573 op mul *tmp82 :compute:zy :compute:zy
 
   582 label *label248
   583 label *label249
   584 label *label250
-    * op add :compute:i :compute:i 1
+  585 op add :compute:i 27 1
   586 set :compute:x1 :compute:zx
   587 op mul *tmp81 :compute:zx :compute:zx
   588 op mul *tmp82 :compute:zy :compute:zy
 
   597 label *label251
   598 label *label252
   599 label *label253
-    * op add :compute:i :compute:i 1
+  600 op add :compute:i 28 1
   601 set :compute:x1 :compute:zx
   602 op mul *tmp81 :compute:zx :compute:zx
   603 op mul *tmp82 :compute:zy :compute:zy
 
   612 label *label254
   613 label *label255
   614 label *label256
-    * op add :compute:i :compute:i 1
+  615 op add :compute:i 29 1
   616 set :compute:x1 :compute:zx
   617 op mul *tmp81 :compute:zx :compute:zx
   618 op mul *tmp82 :compute:zy :compute:zy
 
   627 label *label257
   628 label *label258
   629 label *label259
-    * op add :compute:i :compute:i 1
+  630 op add :compute:i 30 1
   631 set :compute:x1 :compute:zx
   632 op mul *tmp81 :compute:zx :compute:zx
   633 op mul *tmp82 :compute:zy :compute:zy
 
   642 label *label260
   643 label *label261
   644 label *label262
-    * op add :compute:i :compute:i 1
+  645 op add :compute:i 31 1
   646 set :compute:x1 :compute:zx
   647 op mul *tmp81 :compute:zx :compute:zx
   648 op mul *tmp82 :compute:zy :compute:zy
 
   657 label *label263
   658 label *label264
   659 label *label265
-    * op add :compute:i :compute:i 1
+  660 op add :compute:i 32 1
   661 set :compute:x1 :compute:zx
   662 op mul *tmp81 :compute:zx :compute:zx
   663 op mul *tmp82 :compute:zy :compute:zy
 
   672 label *label266
   673 label *label267
   674 label *label268
-    * op add :compute:i :compute:i 1
+  675 op add :compute:i 33 1
   676 set :compute:x1 :compute:zx
   677 op mul *tmp81 :compute:zx :compute:zx
   678 op mul *tmp82 :compute:zy :compute:zy
 
   687 label *label269
   688 label *label270
   689 label *label271
-    * op add :compute:i :compute:i 1
+  690 op add :compute:i 34 1
   691 set :compute:x1 :compute:zx
   692 op mul *tmp81 :compute:zx :compute:zx
   693 op mul *tmp82 :compute:zy :compute:zy
 
   702 label *label272
   703 label *label273
   704 label *label274
-    * op add :compute:i :compute:i 1
+  705 op add :compute:i 35 1
   706 set :compute:x1 :compute:zx
   707 op mul *tmp81 :compute:zx :compute:zx
   708 op mul *tmp82 :compute:zy :compute:zy
 
   717 label *label275
   718 label *label276
   719 label *label277
-    * op add :compute:i :compute:i 1
+  720 op add :compute:i 36 1
   721 set :compute:x1 :compute:zx
   722 op mul *tmp81 :compute:zx :compute:zx
   723 op mul *tmp82 :compute:zy :compute:zy
 
   732 label *label278
   733 label *label279
   734 label *label280
-    * op add :compute:i :compute:i 1
+  735 op add :compute:i 37 1
   736 set :compute:x1 :compute:zx
   737 op mul *tmp81 :compute:zx :compute:zx
   738 op mul *tmp82 :compute:zy :compute:zy
 
   747 label *label281
   748 label *label282
   749 label *label283
-    * op add :compute:i :compute:i 1
+  750 op add :compute:i 38 1
   751 set :compute:x1 :compute:zx
   752 op mul *tmp81 :compute:zx :compute:zx
   753 op mul *tmp82 :compute:zy :compute:zy
 
   762 label *label284
   763 label *label285
   764 label *label286
-    * op add :compute:i :compute:i 1
+  765 op add :compute:i 39 1
   766 set :compute:x1 :compute:zx
   767 op mul *tmp81 :compute:zx :compute:zx
   768 op mul *tmp82 :compute:zy :compute:zy
 
   777 label *label287
   778 label *label288
   779 label *label289
-    * op add :compute:i :compute:i 1
+  780 op add :compute:i 40 1
   781 set :compute:x1 :compute:zx
   782 op mul *tmp81 :compute:zx :compute:zx
   783 op mul *tmp82 :compute:zy :compute:zy
 
   792 label *label290
   793 label *label291
   794 label *label292
-    * op add :compute:i :compute:i 1
+  795 op add :compute:i 41 1
   796 set :compute:x1 :compute:zx
   797 op mul *tmp81 :compute:zx :compute:zx
   798 op mul *tmp82 :compute:zy :compute:zy
 
   807 label *label293
   808 label *label294
   809 label *label295
-    * op add :compute:i :compute:i 1
+  810 op add :compute:i 42 1
   811 set :compute:x1 :compute:zx
   812 op mul *tmp81 :compute:zx :compute:zx
   813 op mul *tmp82 :compute:zy :compute:zy
 
   822 label *label296
   823 label *label297
   824 label *label298
-    * op add :compute:i :compute:i 1
+  825 op add :compute:i 43 1
   826 set :compute:x1 :compute:zx
   827 op mul *tmp81 :compute:zx :compute:zx
   828 op mul *tmp82 :compute:zy :compute:zy
 
   837 label *label299
   838 label *label300
   839 label *label301
-    * op add :compute:i :compute:i 1
+  840 op add :compute:i 44 1
   841 set :compute:x1 :compute:zx
   842 op mul *tmp81 :compute:zx :compute:zx
   843 op mul *tmp82 :compute:zy :compute:zy
 
   852 label *label302
   853 label *label303
   854 label *label304
-    * op add :compute:i :compute:i 1
+  855 op add :compute:i 45 1
   856 set :compute:x1 :compute:zx
   857 op mul *tmp81 :compute:zx :compute:zx
   858 op mul *tmp82 :compute:zy :compute:zy
 
   867 label *label305
   868 label *label306
   869 label *label307
-    * op add :compute:i :compute:i 1
+  870 op add :compute:i 46 1
   871 set :compute:x1 :compute:zx
   872 op mul *tmp81 :compute:zx :compute:zx
   873 op mul *tmp82 :compute:zy :compute:zy
 
   882 label *label308
   883 label *label309
   884 label *label310
-    * op add :compute:i :compute:i 1
+  885 op add :compute:i 47 1
   886 set :compute:x1 :compute:zx
   887 op mul *tmp81 :compute:zx :compute:zx
   888 op mul *tmp82 :compute:zy :compute:zy
 
   897 label *label311
   898 label *label312
   899 label *label313
-    * op add :compute:i :compute:i 1
+  900 op add :compute:i 48 1
   901 set :compute:x1 :compute:zx
   902 op mul *tmp81 :compute:zx :compute:zx
   903 op mul *tmp82 :compute:zy :compute:zy
 
   912 label *label314
   913 label *label315
   914 label *label316
-    * op add :compute:i :compute:i 1
+  915 op add :compute:i 49 1
   916 set :compute:x1 :compute:zx
   917 op mul *tmp81 :compute:zx :compute:zx
   918 op mul *tmp82 :compute:zy :compute:zy
 
   927 label *label317
   928 label *label318
   929 label *label319
-    * op add :compute:i :compute:i 1
+  930 op add :compute:i 50 1
   931 set :compute:x1 :compute:zx
   932 op mul *tmp81 :compute:zx :compute:zx
   933 op mul *tmp82 :compute:zy :compute:zy
 
   942 label *label320
   943 label *label321
   944 label *label322
-    * op add :compute:i :compute:i 1
+  945 op add :compute:i 51 1
   946 set :compute:x1 :compute:zx
   947 op mul *tmp81 :compute:zx :compute:zx
   948 op mul *tmp82 :compute:zy :compute:zy
 
   957 label *label323
   958 label *label324
   959 label *label325
-    * op add :compute:i :compute:i 1
+  960 op add :compute:i 52 1
   961 set :compute:x1 :compute:zx
   962 op mul *tmp81 :compute:zx :compute:zx
   963 op mul *tmp82 :compute:zy :compute:zy
 
   972 label *label326
   973 label *label327
   974 label *label328
-    * op add :compute:i :compute:i 1
+  975 op add :compute:i 53 1
   976 set :compute:x1 :compute:zx
   977 op mul *tmp81 :compute:zx :compute:zx
   978 op mul *tmp82 :compute:zy :compute:zy
 
   987 label *label329
   988 label *label330
   989 label *label331
-    * op add :compute:i :compute:i 1
+  990 op add :compute:i 54 1
   991 set :compute:x1 :compute:zx
   992 op mul *tmp81 :compute:zx :compute:zx
   993 op mul *tmp82 :compute:zy :compute:zy
 
  1002 label *label332
  1003 label *label333
  1004 label *label334
-    * op add :compute:i :compute:i 1
+ 1005 op add :compute:i 55 1
  1006 set :compute:x1 :compute:zx
  1007 op mul *tmp81 :compute:zx :compute:zx
  1008 op mul *tmp82 :compute:zy :compute:zy
 
  1017 label *label335
  1018 label *label336
  1019 label *label337
-    * op add :compute:i :compute:i 1
+ 1020 op add :compute:i 56 1
  1021 set :compute:x1 :compute:zx
  1022 op mul *tmp81 :compute:zx :compute:zx
  1023 op mul *tmp82 :compute:zy :compute:zy
 
  1032 label *label338
  1033 label *label339
  1034 label *label340
-    * op add :compute:i :compute:i 1
+ 1035 op add :compute:i 57 1
  1036 set :compute:x1 :compute:zx
  1037 op mul *tmp81 :compute:zx :compute:zx
  1038 op mul *tmp82 :compute:zy :compute:zy
 
  1047 label *label341
  1048 label *label342
  1049 label *label343
-    * op add :compute:i :compute:i 1
+ 1050 op add :compute:i 58 1
  1051 set :compute:x1 :compute:zx
  1052 op mul *tmp81 :compute:zx :compute:zx
  1053 op mul *tmp82 :compute:zy :compute:zy
 
  1062 label *label344
  1063 label *label345
  1064 label *label346
-    * op add :compute:i :compute:i 1
+ 1065 op add :compute:i 59 1
  1066 set :compute:x1 :compute:zx
  1067 op mul *tmp81 :compute:zx :compute:zx
  1068 op mul *tmp82 :compute:zy :compute:zy
 
  1077 label *label347
  1078 label *label348
  1079 label *label349
-    * op add :compute:i :compute:i 1
+ 1080 op add :compute:i 60 1
  1081 set :compute:x1 :compute:zx
  1082 op mul *tmp81 :compute:zx :compute:zx
  1083 op mul *tmp82 :compute:zy :compute:zy
 
  1092 label *label350
  1093 label *label351
  1094 label *label352
-    * op add :compute:i :compute:i 1
+ 1095 op add :compute:i 61 1
  1096 set :compute:x1 :compute:zx
  1097 op mul *tmp81 :compute:zx :compute:zx
  1098 op mul *tmp82 :compute:zy :compute:zy
 
  1107 label *label353
  1108 label *label354
  1109 label *label355
-    * op add :compute:i :compute:i 1
+ 1110 op add :compute:i 62 1
  1111 label *label63
  1112 jump *label66 lessThanEq .PALETTE 1
  1113 jump *label66 greaterThanEq :compute:i 63

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1 (-2 instructions):
 
    21 label *label118
    22 jump *label119 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    24 label *label119
    25 label *label120
    26 label *label121
 
    29 label *label124
    30 jump *label125 notEqual @memory-bank :findLinkedBlocks:type
    31 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    32 label *label125
    33 label *label126
    34 label *label127
 
   175 label *label167
   176 label *label168
   177 label *label169
-    * op add :compute:i 0 1
+  178 set :compute:i 1
   179 set :compute:x1 :compute:zx
   180 op mul *tmp81 :compute:zx :compute:zx
   181 op mul *tmp82 :compute:zy :compute:zy

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1:
 
    58 label *label148
    59 label *label149
    60 label *label23
-    * printflush :findLinkedBlocks:message
+   61 printflush null
    62 label *label2
    63 jump *label1 equal :findLinkedBlocks:foundAll false
    64 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 2 (-1 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:message null
     1 label *label1
     2 label *label131
     3 label *label132

Modifications by Iterated phase, Boolean Optimization, pass 3, iteration 1 (-2 instructions):
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label118
-    * jump *label119 notEqual @large-logic-display :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label119
-    * label *label120
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    22 label *label121
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label124
-    * jump *label125 notEqual @memory-bank :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label125
-    * label *label126
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    27 label *label127
    28 set .memory :findLinkedBlocks:variable
    29 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 1:
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label118
-    * select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    22 label *label121
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label124
-    * select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    27 label *label127
    28 set .memory :findLinkedBlocks:variable
    29 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 2 (-2 instructions):
 
    16 print "\nFound: "
    17 print :findLinkedBlocks:block
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:variable .display
    19 label *label118
    20 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    21 label *label121
    22 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:variable .memory
    23 label *label124
    24 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    25 label *label127

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-1 instructions):
     0 set .start 0
     1 label *label1
-    * label *label131
-    * label *label132
     2 set .display null
-    * label *label135
-    * label *label136
     3 set .memory null
-    * label *label6
     4 print "Mandelbrot Generator"
     5 set :findLinkedBlocks:n @links
-    * label *label9
     6 jump *label11 lessThanEq :findLinkedBlocks:n 0
     7 label *label113
     8 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
 
    10 print "\nFound: "
    11 print :findLinkedBlocks:block
    12 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * label *label118
    13 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
-    * label *label121
    14 set .display :findLinkedBlocks:variable
-    * label *label124
    15 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
-    * label *label127
    16 set .memory :findLinkedBlocks:variable
-    * label *label14
-    * label *label10
    17 jump *label113 greaterThan :findLinkedBlocks:n 0
    18 label *label11
-    * label *label140
    19 print "\n"
    20 print "Display"
    21 print ":"
    22 print " "
    23 print .display
    24 op and :findLinkedBlocks:foundAll 1 .display
-    * label *label141
-    * label *label142
-    * label *label143
-    * label *label146
    25 print "\n"
    26 print "Memory"
    27 print ":"
    28 print " "
    29 print .memory
    30 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
-    * label *label147
-    * label *label148
-    * label *label149
-    * label *label23
    31 printflush null
-    * label *label2
    32 jump *label1 equal :findLinkedBlocks:foundAll false
-    * label *label3
-    * label *label0
    33 label *label28
    34 label *label31
    35 wait 0
-    * label *label32
    36 read *tmp24 .memory 66
    37 jump *label31 equal .start *tmp24
-    * label *label33
    38 read .start .memory 66
    39 read .stop .memory 67
    40 set .lastColor -1
 
    56 jump *label37 equal .stop *tmp40
    57 jump *label29 always
    58 label *label37
-    * label *label38
    59 read *tmp42 .memory 64
    60 op add *tmp0 *tmp42 1
    61 write *tmp0 .memory 64
    62 jump *label39 lessThan *tmp42 2816
    63 jump *label36 always
    64 label *label39
-    * label *label40
    65 multijump *tmp42 0 0 (m:*label154)
    66 multilabel *label158 (m:*label154)
-    * label *label153
    67 op mul *tmp55 2 *tmp42
    68 op sub *tmp46 *tmp55 175
    69 jump *label41 always
    70 multilabel *label155 (m:*label154)
-    * label *label43
    71 op mul *tmp46 8 *tmp42
    72 jump *label41 always
-    * label *label42
    73 multilabel *label156 (m:*label154)
-    * label *label46
    74 op mul *tmp49 8 *tmp42
    75 op sub *tmp46 *tmp49 172
-    * label *label45
    76 jump *label41 always
    77 multilabel *label157 (m:*label154)
-    * label *label49
    78 op mul *tmp52 4 *tmp42
    79 op sub *tmp46 *tmp52 174
    80 label *label41
 
    83 op mod :x *tmp59 176
    84 op mod :y *tmp46 16
    85 set :i 0
-    * label *label51
    86 label *label114
    87 op add *tmp62 :y :i
    88 op div *tmp64 :x .ZOOM
 
   106 set *tmp63 63
   107 jump *label54 always
   108 label *label57
-    * label *label58
   109 op add *tmp77 :compute:zx 1
   110 op len *tmp78 *tmp77 :compute:zy
   111 jump *label59 greaterThan *tmp78 0.25
   112 set *tmp63 63
   113 jump *label54 always
   114 label *label59
-    * label *label60
   115 label *label56
   116 set :compute:i 0
-    * label *label166
   117 set :compute:x1 :compute:zx
   118 op mul *tmp81 :compute:zx :compute:zx
   119 op mul *tmp82 :compute:zy :compute:zy
 
   126 jump *label167 lessThan :compute:dist 64
   127 jump *label63 always
   128 label *label167
-    * label *label168
-    * label *label169
   129 set :compute:i 1
   130 set :compute:x1 :compute:zx
   131 op mul *tmp81 :compute:zx :compute:zx
 
   139 jump *label170 lessThan :compute:dist 64
   140 jump *label63 always
   141 label *label170
-    * label *label171
-    * label *label172
   142 op add :compute:i 1 1
   143 set :compute:x1 :compute:zx
   144 op mul *tmp81 :compute:zx :compute:zx
 
   152 jump *label173 lessThan :compute:dist 64
   153 jump *label63 always
   154 label *label173
-    * label *label174
-    * label *label175
   155 op add :compute:i 2 1
   156 set :compute:x1 :compute:zx
   157 op mul *tmp81 :compute:zx :compute:zx
 
   165 jump *label176 lessThan :compute:dist 64
   166 jump *label63 always
   167 label *label176
-    * label *label177
-    * label *label178
   168 op add :compute:i 3 1
   169 set :compute:x1 :compute:zx
   170 op mul *tmp81 :compute:zx :compute:zx
 
   178 jump *label179 lessThan :compute:dist 64
   179 jump *label63 always
   180 label *label179
-    * label *label180
-    * label *label181
   181 op add :compute:i 4 1
   182 set :compute:x1 :compute:zx
   183 op mul *tmp81 :compute:zx :compute:zx
 
   191 jump *label182 lessThan :compute:dist 64
   192 jump *label63 always
   193 label *label182
-    * label *label183
-    * label *label184
   194 op add :compute:i 5 1
   195 set :compute:x1 :compute:zx
   196 op mul *tmp81 :compute:zx :compute:zx
 
   204 jump *label185 lessThan :compute:dist 64
   205 jump *label63 always
   206 label *label185
-    * label *label186
-    * label *label187
   207 op add :compute:i 6 1
   208 set :compute:x1 :compute:zx
   209 op mul *tmp81 :compute:zx :compute:zx
 
   217 jump *label188 lessThan :compute:dist 64
   218 jump *label63 always
   219 label *label188
-    * label *label189
-    * label *label190
   220 op add :compute:i 7 1
   221 set :compute:x1 :compute:zx
   222 op mul *tmp81 :compute:zx :compute:zx
 
   230 jump *label191 lessThan :compute:dist 64
   231 jump *label63 always
   232 label *label191
-    * label *label192
-    * label *label193
   233 op add :compute:i 8 1
   234 set :compute:x1 :compute:zx
   235 op mul *tmp81 :compute:zx :compute:zx
 
   243 jump *label194 lessThan :compute:dist 64
   244 jump *label63 always
   245 label *label194
-    * label *label195
-    * label *label196
   246 op add :compute:i 9 1
   247 set :compute:x1 :compute:zx
   248 op mul *tmp81 :compute:zx :compute:zx
 
   256 jump *label197 lessThan :compute:dist 64
   257 jump *label63 always
   258 label *label197
-    * label *label198
-    * label *label199
   259 op add :compute:i 10 1
   260 set :compute:x1 :compute:zx
   261 op mul *tmp81 :compute:zx :compute:zx
 
   269 jump *label200 lessThan :compute:dist 64
   270 jump *label63 always
   271 label *label200
-    * label *label201
-    * label *label202
   272 op add :compute:i 11 1
   273 set :compute:x1 :compute:zx
   274 op mul *tmp81 :compute:zx :compute:zx
 
   282 jump *label203 lessThan :compute:dist 64
   283 jump *label63 always
   284 label *label203
-    * label *label204
-    * label *label205
   285 op add :compute:i 12 1
   286 set :compute:x1 :compute:zx
   287 op mul *tmp81 :compute:zx :compute:zx
 
   295 jump *label206 lessThan :compute:dist 64
   296 jump *label63 always
   297 label *label206
-    * label *label207
-    * label *label208
   298 op add :compute:i 13 1
   299 set :compute:x1 :compute:zx
   300 op mul *tmp81 :compute:zx :compute:zx
 
   308 jump *label209 lessThan :compute:dist 64
   309 jump *label63 always
   310 label *label209
-    * label *label210
-    * label *label211
   311 op add :compute:i 14 1
   312 set :compute:x1 :compute:zx
   313 op mul *tmp81 :compute:zx :compute:zx
 
   321 jump *label212 lessThan :compute:dist 64
   322 jump *label63 always
   323 label *label212
-    * label *label213
-    * label *label214
   324 op add :compute:i 15 1
   325 set :compute:x1 :compute:zx
   326 op mul *tmp81 :compute:zx :compute:zx
 
   334 jump *label215 lessThan :compute:dist 64
   335 jump *label63 always
   336 label *label215
-    * label *label216
-    * label *label217
   337 op add :compute:i 16 1
   338 set :compute:x1 :compute:zx
   339 op mul *tmp81 :compute:zx :compute:zx
 
   347 jump *label218 lessThan :compute:dist 64
   348 jump *label63 always
   349 label *label218
-    * label *label219
-    * label *label220
   350 op add :compute:i 17 1
   351 set :compute:x1 :compute:zx
   352 op mul *tmp81 :compute:zx :compute:zx
 
   360 jump *label221 lessThan :compute:dist 64
   361 jump *label63 always
   362 label *label221
-    * label *label222
-    * label *label223
   363 op add :compute:i 18 1
   364 set :compute:x1 :compute:zx
   365 op mul *tmp81 :compute:zx :compute:zx
 
   373 jump *label224 lessThan :compute:dist 64
   374 jump *label63 always
   375 label *label224
-    * label *label225
-    * label *label226
   376 op add :compute:i 19 1
   377 set :compute:x1 :compute:zx
   378 op mul *tmp81 :compute:zx :compute:zx
 
   386 jump *label227 lessThan :compute:dist 64
   387 jump *label63 always
   388 label *label227
-    * label *label228
-    * label *label229
   389 op add :compute:i 20 1
   390 set :compute:x1 :compute:zx
   391 op mul *tmp81 :compute:zx :compute:zx
 
   399 jump *label230 lessThan :compute:dist 64
   400 jump *label63 always
   401 label *label230
-    * label *label231
-    * label *label232
   402 op add :compute:i 21 1
   403 set :compute:x1 :compute:zx
   404 op mul *tmp81 :compute:zx :compute:zx
 
   412 jump *label233 lessThan :compute:dist 64
   413 jump *label63 always
   414 label *label233
-    * label *label234
-    * label *label235
   415 op add :compute:i 22 1
   416 set :compute:x1 :compute:zx
   417 op mul *tmp81 :compute:zx :compute:zx
 
   425 jump *label236 lessThan :compute:dist 64
   426 jump *label63 always
   427 label *label236
-    * label *label237
-    * label *label238
   428 op add :compute:i 23 1
   429 set :compute:x1 :compute:zx
   430 op mul *tmp81 :compute:zx :compute:zx
 
   438 jump *label239 lessThan :compute:dist 64
   439 jump *label63 always
   440 label *label239
-    * label *label240
-    * label *label241
   441 op add :compute:i 24 1
   442 set :compute:x1 :compute:zx
   443 op mul *tmp81 :compute:zx :compute:zx
 
   451 jump *label242 lessThan :compute:dist 64
   452 jump *label63 always
   453 label *label242
-    * label *label243
-    * label *label244
   454 op add :compute:i 25 1
   455 set :compute:x1 :compute:zx
   456 op mul *tmp81 :compute:zx :compute:zx
 
   464 jump *label245 lessThan :compute:dist 64
   465 jump *label63 always
   466 label *label245
-    * label *label246
-    * label *label247
   467 op add :compute:i 26 1
   468 set :compute:x1 :compute:zx
   469 op mul *tmp81 :compute:zx :compute:zx
 
   477 jump *label248 lessThan :compute:dist 64
   478 jump *label63 always
   479 label *label248
-    * label *label249
-    * label *label250
   480 op add :compute:i 27 1
   481 set :compute:x1 :compute:zx
   482 op mul *tmp81 :compute:zx :compute:zx
 
   490 jump *label251 lessThan :compute:dist 64
   491 jump *label63 always
   492 label *label251
-    * label *label252
-    * label *label253
   493 op add :compute:i 28 1
   494 set :compute:x1 :compute:zx
   495 op mul *tmp81 :compute:zx :compute:zx
 
   503 jump *label254 lessThan :compute:dist 64
   504 jump *label63 always
   505 label *label254
-    * label *label255
-    * label *label256
   506 op add :compute:i 29 1
   507 set :compute:x1 :compute:zx
   508 op mul *tmp81 :compute:zx :compute:zx
 
   516 jump *label257 lessThan :compute:dist 64
   517 jump *label63 always
   518 label *label257
-    * label *label258
-    * label *label259
   519 op add :compute:i 30 1
   520 set :compute:x1 :compute:zx
   521 op mul *tmp81 :compute:zx :compute:zx
 
   529 jump *label260 lessThan :compute:dist 64
   530 jump *label63 always
   531 label *label260
-    * label *label261
-    * label *label262
   532 op add :compute:i 31 1
   533 set :compute:x1 :compute:zx
   534 op mul *tmp81 :compute:zx :compute:zx
 
   542 jump *label263 lessThan :compute:dist 64
   543 jump *label63 always
   544 label *label263
-    * label *label264
-    * label *label265
   545 op add :compute:i 32 1
   546 set :compute:x1 :compute:zx
   547 op mul *tmp81 :compute:zx :compute:zx
 
   555 jump *label266 lessThan :compute:dist 64
   556 jump *label63 always
   557 label *label266
-    * label *label267
-    * label *label268
   558 op add :compute:i 33 1
   559 set :compute:x1 :compute:zx
   560 op mul *tmp81 :compute:zx :compute:zx
 
   568 jump *label269 lessThan :compute:dist 64
   569 jump *label63 always
   570 label *label269
-    * label *label270
-    * label *label271
   571 op add :compute:i 34 1
   572 set :compute:x1 :compute:zx
   573 op mul *tmp81 :compute:zx :compute:zx
 
   581 jump *label272 lessThan :compute:dist 64
   582 jump *label63 always
   583 label *label272
-    * label *label273
-    * label *label274
   584 op add :compute:i 35 1
   585 set :compute:x1 :compute:zx
   586 op mul *tmp81 :compute:zx :compute:zx
 
   594 jump *label275 lessThan :compute:dist 64
   595 jump *label63 always
   596 label *label275
-    * label *label276
-    * label *label277
   597 op add :compute:i 36 1
   598 set :compute:x1 :compute:zx
   599 op mul *tmp81 :compute:zx :compute:zx
 
   607 jump *label278 lessThan :compute:dist 64
   608 jump *label63 always
   609 label *label278
-    * label *label279
-    * label *label280
   610 op add :compute:i 37 1
   611 set :compute:x1 :compute:zx
   612 op mul *tmp81 :compute:zx :compute:zx
 
   620 jump *label281 lessThan :compute:dist 64
   621 jump *label63 always
   622 label *label281
-    * label *label282
-    * label *label283
   623 op add :compute:i 38 1
   624 set :compute:x1 :compute:zx
   625 op mul *tmp81 :compute:zx :compute:zx
 
   633 jump *label284 lessThan :compute:dist 64
   634 jump *label63 always
   635 label *label284
-    * label *label285
-    * label *label286
   636 op add :compute:i 39 1
   637 set :compute:x1 :compute:zx
   638 op mul *tmp81 :compute:zx :compute:zx
 
   646 jump *label287 lessThan :compute:dist 64
   647 jump *label63 always
   648 label *label287
-    * label *label288
-    * label *label289
   649 op add :compute:i 40 1
   650 set :compute:x1 :compute:zx
   651 op mul *tmp81 :compute:zx :compute:zx
 
   659 jump *label290 lessThan :compute:dist 64
   660 jump *label63 always
   661 label *label290
-    * label *label291
-    * label *label292
   662 op add :compute:i 41 1
   663 set :compute:x1 :compute:zx
   664 op mul *tmp81 :compute:zx :compute:zx
 
   672 jump *label293 lessThan :compute:dist 64
   673 jump *label63 always
   674 label *label293
-    * label *label294
-    * label *label295
   675 op add :compute:i 42 1
   676 set :compute:x1 :compute:zx
   677 op mul *tmp81 :compute:zx :compute:zx
 
   685 jump *label296 lessThan :compute:dist 64
   686 jump *label63 always
   687 label *label296
-    * label *label297
-    * label *label298
   688 op add :compute:i 43 1
   689 set :compute:x1 :compute:zx
   690 op mul *tmp81 :compute:zx :compute:zx
 
   698 jump *label299 lessThan :compute:dist 64
   699 jump *label63 always
   700 label *label299
-    * label *label300
-    * label *label301
   701 op add :compute:i 44 1
   702 set :compute:x1 :compute:zx
   703 op mul *tmp81 :compute:zx :compute:zx
 
   711 jump *label302 lessThan :compute:dist 64
   712 jump *label63 always
   713 label *label302
-    * label *label303
-    * label *label304
   714 op add :compute:i 45 1
   715 set :compute:x1 :compute:zx
   716 op mul *tmp81 :compute:zx :compute:zx
 
   724 jump *label305 lessThan :compute:dist 64
   725 jump *label63 always
   726 label *label305
-    * label *label306
-    * label *label307
   727 op add :compute:i 46 1
   728 set :compute:x1 :compute:zx
   729 op mul *tmp81 :compute:zx :compute:zx
 
   737 jump *label308 lessThan :compute:dist 64
   738 jump *label63 always
   739 label *label308
-    * label *label309
-    * label *label310
   740 op add :compute:i 47 1
   741 set :compute:x1 :compute:zx
   742 op mul *tmp81 :compute:zx :compute:zx
 
   750 jump *label311 lessThan :compute:dist 64
   751 jump *label63 always
   752 label *label311
-    * label *label312
-    * label *label313
   753 op add :compute:i 48 1
   754 set :compute:x1 :compute:zx
   755 op mul *tmp81 :compute:zx :compute:zx
 
   763 jump *label314 lessThan :compute:dist 64
   764 jump *label63 always
   765 label *label314
-    * label *label315
-    * label *label316
   766 op add :compute:i 49 1
   767 set :compute:x1 :compute:zx
   768 op mul *tmp81 :compute:zx :compute:zx
 
   776 jump *label317 lessThan :compute:dist 64
   777 jump *label63 always
   778 label *label317
-    * label *label318
-    * label *label319
   779 op add :compute:i 50 1
   780 set :compute:x1 :compute:zx
   781 op mul *tmp81 :compute:zx :compute:zx
 
   789 jump *label320 lessThan :compute:dist 64
   790 jump *label63 always
   791 label *label320
-    * label *label321
-    * label *label322
   792 op add :compute:i 51 1
   793 set :compute:x1 :compute:zx
   794 op mul *tmp81 :compute:zx :compute:zx
 
   802 jump *label323 lessThan :compute:dist 64
   803 jump *label63 always
   804 label *label323
-    * label *label324
-    * label *label325
   805 op add :compute:i 52 1
   806 set :compute:x1 :compute:zx
   807 op mul *tmp81 :compute:zx :compute:zx
 
   815 jump *label326 lessThan :compute:dist 64
   816 jump *label63 always
   817 label *label326
-    * label *label327
-    * label *label328
   818 op add :compute:i 53 1
   819 set :compute:x1 :compute:zx
   820 op mul *tmp81 :compute:zx :compute:zx
 
   828 jump *label329 lessThan :compute:dist 64
   829 jump *label63 always
   830 label *label329
-    * label *label330
-    * label *label331
   831 op add :compute:i 54 1
   832 set :compute:x1 :compute:zx
   833 op mul *tmp81 :compute:zx :compute:zx
 
   841 jump *label332 lessThan :compute:dist 64
   842 jump *label63 always
   843 label *label332
-    * label *label333
-    * label *label334
   844 op add :compute:i 55 1
   845 set :compute:x1 :compute:zx
   846 op mul *tmp81 :compute:zx :compute:zx
 
   854 jump *label335 lessThan :compute:dist 64
   855 jump *label63 always
   856 label *label335
-    * label *label336
-    * label *label337
   857 op add :compute:i 56 1
   858 set :compute:x1 :compute:zx
   859 op mul *tmp81 :compute:zx :compute:zx
 
   867 jump *label338 lessThan :compute:dist 64
   868 jump *label63 always
   869 label *label338
-    * label *label339
-    * label *label340
   870 op add :compute:i 57 1
   871 set :compute:x1 :compute:zx
   872 op mul *tmp81 :compute:zx :compute:zx
 
   880 jump *label341 lessThan :compute:dist 64
   881 jump *label63 always
   882 label *label341
-    * label *label342
-    * label *label343
   883 op add :compute:i 58 1
   884 set :compute:x1 :compute:zx
   885 op mul *tmp81 :compute:zx :compute:zx
 
   893 jump *label344 lessThan :compute:dist 64
   894 jump *label63 always
   895 label *label344
-    * label *label345
-    * label *label346
   896 op add :compute:i 59 1
   897 set :compute:x1 :compute:zx
   898 op mul *tmp81 :compute:zx :compute:zx
 
   906 jump *label347 lessThan :compute:dist 64
   907 jump *label63 always
   908 label *label347
-    * label *label348
-    * label *label349
   909 op add :compute:i 60 1
   910 set :compute:x1 :compute:zx
   911 op mul *tmp81 :compute:zx :compute:zx
 
   919 jump *label350 lessThan :compute:dist 64
   920 jump *label63 always
   921 label *label350
-    * label *label351
-    * label *label352
   922 op add :compute:i 61 1
   923 set :compute:x1 :compute:zx
   924 op mul *tmp81 :compute:zx :compute:zx
 
   932 jump *label353 lessThan :compute:dist 64
   933 jump *label63 always
   934 label *label353
-    * label *label354
-    * label *label355
   935 op add :compute:i 62 1
   936 label *label63
   937 jump *label66 lessThanEq .PALETTE 1
 
   943 op sub :compute:correction 4 *tmp96
   944 op add :compute:i :compute:i :compute:correction
   945 label *label66
-    * label *label67
   946 set *tmp63 :compute:i
   947 label *label54
   948 jump *label71 lessThanEq .PALETTE 1
   949 set :drawPixel:color %[black]
   950 jump *label74 equal *tmp63 63
-    * label *label73
   951 multijump .PALETTE 0 0 (m:*label160)
   952 multilabel *label165 (m:*label160)
   953 multilabel *label161 (m:*label160)
-    * label *label159
   954 op div *tmp138 *tmp63 63.75
   955 op sub :drawPixel:r 1 *tmp138
   956 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   957 jump *label75 always
   958 multilabel *label162 (m:*label160)
-    * label *label77
   959 op sub *tmp103 32 *tmp63
   960 op abs *tmp104 *tmp103
   961 op div *tmp106 *tmp104 36.42857142857143
 
   968 op add :drawPixel:b 0.47058823529411764 *tmp116
   969 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   970 jump *label75 always
-    * label *label76
   971 multilabel *label163 (m:*label160)
-    * label *label79
   972 op div *tmp120 *tmp63 0.175
   973 op sin :drawPixel:r *tmp120
   974 op cos :drawPixel:g *tmp120
 
   978 op add :drawPixel:b 0.39215686274509803 *tmp128
   979 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   980 jump *label75 always
-    * label *label78
   981 multilabel *label164 (m:*label160)
-    * label *label81
   982 op div :drawPixel:r *tmp63 63.75
   983 op div *tmp134 *tmp63 170
   984 op add :drawPixel:g 96 *tmp134
 
   990 read :drawPixel:color .memory *tmp63
   991 label *label72
   992 jump *label82 lessThan .localBuffer 254
-    * label *label85
   993 jump *label87 lessThanEq .localBuffer 0
   994 label *label116
   995 wait 0
 
  1001 drawflush .display
  1002 set .localBuffer 0
  1003 label *label91
-    * label *label92
  1004 label *label89
-    * label *label90
-    * label *label88
-    * label *label86
  1005 jump *label116 greaterThan .localBuffer 0
  1006 label *label87
-    * label *label84
  1007 label *label82
-    * label *label83
  1008 jump *label93 lessThanEq .localBuffer 0
  1009 jump *label93 strictNotEqual :drawPixel:color .lastColor
  1010 draw rect :x :y 1 1
 
  1025 drawflush .display
  1026 set .localBuffer 0
  1027 label *label100
-    * label *label101
  1028 label *label98
-    * label *label99
-    * label *label97
-    * label *label70
  1029 wait 0
  1030 read *tmp163 .memory 65
  1031 op add *tmp1 *tmp163 1
 
  1034 jump *label102 equal .stop *tmp166
  1035 jump *label29 always
  1036 label *label102
-    * label *label103
-    * label *label52
  1037 op add :i :i 1
  1038 jump *label114 lessThan :i 16
-    * label *label53
-    * label *label105
  1039 jump *label107 lessThanEq .localBuffer 0
  1040 label *label117
  1041 wait 0
 
  1047 drawflush .display
  1048 set .localBuffer 0
  1049 label *label111
-    * label *label112
  1050 label *label109
-    * label *label110
-    * label *label108
-    * label *label106
  1051 jump *label117 greaterThan .localBuffer 0
  1052 label *label107
-    * label *label104
-    * label *label35
  1053 jump *label34 always
  1054 label *label36
  1055 label *label29
  1056 jump *label28 always
-    * label *label30
-    * end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-66 instructions):
 
    53 label *label34
    54 wait 0
    55 read *tmp40 .memory 67
-    * jump *label37 equal .stop *tmp40
-    * jump *label29 always
+   56 jump *label29 notEqual .stop *tmp40
    57 label *label37
    58 read *tmp42 .memory 64
    59 op add *tmp0 *tmp42 1
    60 write *tmp0 .memory 64
-    * jump *label39 lessThan *tmp42 2816
-    * jump *label36 always
+   61 jump *label36 greaterThanEq *tmp42 2816
    62 label *label39
    63 multijump *tmp42 0 0 (m:*label154)
    64 multilabel *label158 (m:*label154)
 
   121 op mul *tmp86 *tmp85 :compute:zy
   122 op add :compute:zy *tmp86 :compute:cy
   123 op len :compute:dist :compute:zx :compute:zy
-    * jump *label167 lessThan :compute:dist 64
-    * jump *label63 always
+  124 jump *label63 greaterThanEq :compute:dist 64
   125 label *label167
   126 set :compute:i 1
   127 set :compute:x1 :compute:zx
 
   133 op mul *tmp86 *tmp85 :compute:zy
   134 op add :compute:zy *tmp86 :compute:cy
   135 op len :compute:dist :compute:zx :compute:zy
-    * jump *label170 lessThan :compute:dist 64
-    * jump *label63 always
+  136 jump *label63 greaterThanEq :compute:dist 64
   137 label *label170
   138 op add :compute:i 1 1
   139 set :compute:x1 :compute:zx
 
   145 op mul *tmp86 *tmp85 :compute:zy
   146 op add :compute:zy *tmp86 :compute:cy
   147 op len :compute:dist :compute:zx :compute:zy
-    * jump *label173 lessThan :compute:dist 64
-    * jump *label63 always
+  148 jump *label63 greaterThanEq :compute:dist 64
   149 label *label173
   150 op add :compute:i 2 1
   151 set :compute:x1 :compute:zx
 
   157 op mul *tmp86 *tmp85 :compute:zy
   158 op add :compute:zy *tmp86 :compute:cy
   159 op len :compute:dist :compute:zx :compute:zy
-    * jump *label176 lessThan :compute:dist 64
-    * jump *label63 always
+  160 jump *label63 greaterThanEq :compute:dist 64
   161 label *label176
   162 op add :compute:i 3 1
   163 set :compute:x1 :compute:zx
 
   169 op mul *tmp86 *tmp85 :compute:zy
   170 op add :compute:zy *tmp86 :compute:cy
   171 op len :compute:dist :compute:zx :compute:zy
-    * jump *label179 lessThan :compute:dist 64
-    * jump *label63 always
+  172 jump *label63 greaterThanEq :compute:dist 64
   173 label *label179
   174 op add :compute:i 4 1
   175 set :compute:x1 :compute:zx
 
   181 op mul *tmp86 *tmp85 :compute:zy
   182 op add :compute:zy *tmp86 :compute:cy
   183 op len :compute:dist :compute:zx :compute:zy
-    * jump *label182 lessThan :compute:dist 64
-    * jump *label63 always
+  184 jump *label63 greaterThanEq :compute:dist 64
   185 label *label182
   186 op add :compute:i 5 1
   187 set :compute:x1 :compute:zx
 
   193 op mul *tmp86 *tmp85 :compute:zy
   194 op add :compute:zy *tmp86 :compute:cy
   195 op len :compute:dist :compute:zx :compute:zy
-    * jump *label185 lessThan :compute:dist 64
-    * jump *label63 always
+  196 jump *label63 greaterThanEq :compute:dist 64
   197 label *label185
   198 op add :compute:i 6 1
   199 set :compute:x1 :compute:zx
 
   205 op mul *tmp86 *tmp85 :compute:zy
   206 op add :compute:zy *tmp86 :compute:cy
   207 op len :compute:dist :compute:zx :compute:zy
-    * jump *label188 lessThan :compute:dist 64
-    * jump *label63 always
+  208 jump *label63 greaterThanEq :compute:dist 64
   209 label *label188
   210 op add :compute:i 7 1
   211 set :compute:x1 :compute:zx
 
   217 op mul *tmp86 *tmp85 :compute:zy
   218 op add :compute:zy *tmp86 :compute:cy
   219 op len :compute:dist :compute:zx :compute:zy
-    * jump *label191 lessThan :compute:dist 64
-    * jump *label63 always
+  220 jump *label63 greaterThanEq :compute:dist 64
   221 label *label191
   222 op add :compute:i 8 1
   223 set :compute:x1 :compute:zx
 
   229 op mul *tmp86 *tmp85 :compute:zy
   230 op add :compute:zy *tmp86 :compute:cy
   231 op len :compute:dist :compute:zx :compute:zy
-    * jump *label194 lessThan :compute:dist 64
-    * jump *label63 always
+  232 jump *label63 greaterThanEq :compute:dist 64
   233 label *label194
   234 op add :compute:i 9 1
   235 set :compute:x1 :compute:zx
 
   241 op mul *tmp86 *tmp85 :compute:zy
   242 op add :compute:zy *tmp86 :compute:cy
   243 op len :compute:dist :compute:zx :compute:zy
-    * jump *label197 lessThan :compute:dist 64
-    * jump *label63 always
+  244 jump *label63 greaterThanEq :compute:dist 64
   245 label *label197
   246 op add :compute:i 10 1
   247 set :compute:x1 :compute:zx
 
   253 op mul *tmp86 *tmp85 :compute:zy
   254 op add :compute:zy *tmp86 :compute:cy
   255 op len :compute:dist :compute:zx :compute:zy
-    * jump *label200 lessThan :compute:dist 64
-    * jump *label63 always
+  256 jump *label63 greaterThanEq :compute:dist 64
   257 label *label200
   258 op add :compute:i 11 1
   259 set :compute:x1 :compute:zx
 
   265 op mul *tmp86 *tmp85 :compute:zy
   266 op add :compute:zy *tmp86 :compute:cy
   267 op len :compute:dist :compute:zx :compute:zy
-    * jump *label203 lessThan :compute:dist 64
-    * jump *label63 always
+  268 jump *label63 greaterThanEq :compute:dist 64
   269 label *label203
   270 op add :compute:i 12 1
   271 set :compute:x1 :compute:zx
 
   277 op mul *tmp86 *tmp85 :compute:zy
   278 op add :compute:zy *tmp86 :compute:cy
   279 op len :compute:dist :compute:zx :compute:zy
-    * jump *label206 lessThan :compute:dist 64
-    * jump *label63 always
+  280 jump *label63 greaterThanEq :compute:dist 64
   281 label *label206
   282 op add :compute:i 13 1
   283 set :compute:x1 :compute:zx
 
   289 op mul *tmp86 *tmp85 :compute:zy
   290 op add :compute:zy *tmp86 :compute:cy
   291 op len :compute:dist :compute:zx :compute:zy
-    * jump *label209 lessThan :compute:dist 64
-    * jump *label63 always
+  292 jump *label63 greaterThanEq :compute:dist 64
   293 label *label209
   294 op add :compute:i 14 1
   295 set :compute:x1 :compute:zx
 
   301 op mul *tmp86 *tmp85 :compute:zy
   302 op add :compute:zy *tmp86 :compute:cy
   303 op len :compute:dist :compute:zx :compute:zy
-    * jump *label212 lessThan :compute:dist 64
-    * jump *label63 always
+  304 jump *label63 greaterThanEq :compute:dist 64
   305 label *label212
   306 op add :compute:i 15 1
   307 set :compute:x1 :compute:zx
 
   313 op mul *tmp86 *tmp85 :compute:zy
   314 op add :compute:zy *tmp86 :compute:cy
   315 op len :compute:dist :compute:zx :compute:zy
-    * jump *label215 lessThan :compute:dist 64
-    * jump *label63 always
+  316 jump *label63 greaterThanEq :compute:dist 64
   317 label *label215
   318 op add :compute:i 16 1
   319 set :compute:x1 :compute:zx
 
   325 op mul *tmp86 *tmp85 :compute:zy
   326 op add :compute:zy *tmp86 :compute:cy
   327 op len :compute:dist :compute:zx :compute:zy
-    * jump *label218 lessThan :compute:dist 64
-    * jump *label63 always
+  328 jump *label63 greaterThanEq :compute:dist 64
   329 label *label218
   330 op add :compute:i 17 1
   331 set :compute:x1 :compute:zx
 
   337 op mul *tmp86 *tmp85 :compute:zy
   338 op add :compute:zy *tmp86 :compute:cy
   339 op len :compute:dist :compute:zx :compute:zy
-    * jump *label221 lessThan :compute:dist 64
-    * jump *label63 always
+  340 jump *label63 greaterThanEq :compute:dist 64
   341 label *label221
   342 op add :compute:i 18 1
   343 set :compute:x1 :compute:zx
 
   349 op mul *tmp86 *tmp85 :compute:zy
   350 op add :compute:zy *tmp86 :compute:cy
   351 op len :compute:dist :compute:zx :compute:zy
-    * jump *label224 lessThan :compute:dist 64
-    * jump *label63 always
+  352 jump *label63 greaterThanEq :compute:dist 64
   353 label *label224
   354 op add :compute:i 19 1
   355 set :compute:x1 :compute:zx
 
   361 op mul *tmp86 *tmp85 :compute:zy
   362 op add :compute:zy *tmp86 :compute:cy
   363 op len :compute:dist :compute:zx :compute:zy
-    * jump *label227 lessThan :compute:dist 64
-    * jump *label63 always
+  364 jump *label63 greaterThanEq :compute:dist 64
   365 label *label227
   366 op add :compute:i 20 1
   367 set :compute:x1 :compute:zx
 
   373 op mul *tmp86 *tmp85 :compute:zy
   374 op add :compute:zy *tmp86 :compute:cy
   375 op len :compute:dist :compute:zx :compute:zy
-    * jump *label230 lessThan :compute:dist 64
-    * jump *label63 always
+  376 jump *label63 greaterThanEq :compute:dist 64
   377 label *label230
   378 op add :compute:i 21 1
   379 set :compute:x1 :compute:zx
 
   385 op mul *tmp86 *tmp85 :compute:zy
   386 op add :compute:zy *tmp86 :compute:cy
   387 op len :compute:dist :compute:zx :compute:zy
-    * jump *label233 lessThan :compute:dist 64
-    * jump *label63 always
+  388 jump *label63 greaterThanEq :compute:dist 64
   389 label *label233
   390 op add :compute:i 22 1
   391 set :compute:x1 :compute:zx
 
   397 op mul *tmp86 *tmp85 :compute:zy
   398 op add :compute:zy *tmp86 :compute:cy
   399 op len :compute:dist :compute:zx :compute:zy
-    * jump *label236 lessThan :compute:dist 64
-    * jump *label63 always
+  400 jump *label63 greaterThanEq :compute:dist 64
   401 label *label236
   402 op add :compute:i 23 1
   403 set :compute:x1 :compute:zx
 
   409 op mul *tmp86 *tmp85 :compute:zy
   410 op add :compute:zy *tmp86 :compute:cy
   411 op len :compute:dist :compute:zx :compute:zy
-    * jump *label239 lessThan :compute:dist 64
-    * jump *label63 always
+  412 jump *label63 greaterThanEq :compute:dist 64
   413 label *label239
   414 op add :compute:i 24 1
   415 set :compute:x1 :compute:zx
 
   421 op mul *tmp86 *tmp85 :compute:zy
   422 op add :compute:zy *tmp86 :compute:cy
   423 op len :compute:dist :compute:zx :compute:zy
-    * jump *label242 lessThan :compute:dist 64
-    * jump *label63 always
+  424 jump *label63 greaterThanEq :compute:dist 64
   425 label *label242
   426 op add :compute:i 25 1
   427 set :compute:x1 :compute:zx
 
   433 op mul *tmp86 *tmp85 :compute:zy
   434 op add :compute:zy *tmp86 :compute:cy
   435 op len :compute:dist :compute:zx :compute:zy
-    * jump *label245 lessThan :compute:dist 64
-    * jump *label63 always
+  436 jump *label63 greaterThanEq :compute:dist 64
   437 label *label245
   438 op add :compute:i 26 1
   439 set :compute:x1 :compute:zx
 
   445 op mul *tmp86 *tmp85 :compute:zy
   446 op add :compute:zy *tmp86 :compute:cy
   447 op len :compute:dist :compute:zx :compute:zy
-    * jump *label248 lessThan :compute:dist 64
-    * jump *label63 always
+  448 jump *label63 greaterThanEq :compute:dist 64
   449 label *label248
   450 op add :compute:i 27 1
   451 set :compute:x1 :compute:zx
 
   457 op mul *tmp86 *tmp85 :compute:zy
   458 op add :compute:zy *tmp86 :compute:cy
   459 op len :compute:dist :compute:zx :compute:zy
-    * jump *label251 lessThan :compute:dist 64
-    * jump *label63 always
+  460 jump *label63 greaterThanEq :compute:dist 64
   461 label *label251
   462 op add :compute:i 28 1
   463 set :compute:x1 :compute:zx
 
   469 op mul *tmp86 *tmp85 :compute:zy
   470 op add :compute:zy *tmp86 :compute:cy
   471 op len :compute:dist :compute:zx :compute:zy
-    * jump *label254 lessThan :compute:dist 64
-    * jump *label63 always
+  472 jump *label63 greaterThanEq :compute:dist 64
   473 label *label254
   474 op add :compute:i 29 1
   475 set :compute:x1 :compute:zx
 
   481 op mul *tmp86 *tmp85 :compute:zy
   482 op add :compute:zy *tmp86 :compute:cy
   483 op len :compute:dist :compute:zx :compute:zy
-    * jump *label257 lessThan :compute:dist 64
-    * jump *label63 always
+  484 jump *label63 greaterThanEq :compute:dist 64
   485 label *label257
   486 op add :compute:i 30 1
   487 set :compute:x1 :compute:zx
 
   493 op mul *tmp86 *tmp85 :compute:zy
   494 op add :compute:zy *tmp86 :compute:cy
   495 op len :compute:dist :compute:zx :compute:zy
-    * jump *label260 lessThan :compute:dist 64
-    * jump *label63 always
+  496 jump *label63 greaterThanEq :compute:dist 64
   497 label *label260
   498 op add :compute:i 31 1
   499 set :compute:x1 :compute:zx
 
   505 op mul *tmp86 *tmp85 :compute:zy
   506 op add :compute:zy *tmp86 :compute:cy
   507 op len :compute:dist :compute:zx :compute:zy
-    * jump *label263 lessThan :compute:dist 64
-    * jump *label63 always
+  508 jump *label63 greaterThanEq :compute:dist 64
   509 label *label263
   510 op add :compute:i 32 1
   511 set :compute:x1 :compute:zx
 
   517 op mul *tmp86 *tmp85 :compute:zy
   518 op add :compute:zy *tmp86 :compute:cy
   519 op len :compute:dist :compute:zx :compute:zy
-    * jump *label266 lessThan :compute:dist 64
-    * jump *label63 always
+  520 jump *label63 greaterThanEq :compute:dist 64
   521 label *label266
   522 op add :compute:i 33 1
   523 set :compute:x1 :compute:zx
 
   529 op mul *tmp86 *tmp85 :compute:zy
   530 op add :compute:zy *tmp86 :compute:cy
   531 op len :compute:dist :compute:zx :compute:zy
-    * jump *label269 lessThan :compute:dist 64
-    * jump *label63 always
+  532 jump *label63 greaterThanEq :compute:dist 64
   533 label *label269
   534 op add :compute:i 34 1
   535 set :compute:x1 :compute:zx
 
   541 op mul *tmp86 *tmp85 :compute:zy
   542 op add :compute:zy *tmp86 :compute:cy
   543 op len :compute:dist :compute:zx :compute:zy
-    * jump *label272 lessThan :compute:dist 64
-    * jump *label63 always
+  544 jump *label63 greaterThanEq :compute:dist 64
   545 label *label272
   546 op add :compute:i 35 1
   547 set :compute:x1 :compute:zx
 
   553 op mul *tmp86 *tmp85 :compute:zy
   554 op add :compute:zy *tmp86 :compute:cy
   555 op len :compute:dist :compute:zx :compute:zy
-    * jump *label275 lessThan :compute:dist 64
-    * jump *label63 always
+  556 jump *label63 greaterThanEq :compute:dist 64
   557 label *label275
   558 op add :compute:i 36 1
   559 set :compute:x1 :compute:zx
 
   565 op mul *tmp86 *tmp85 :compute:zy
   566 op add :compute:zy *tmp86 :compute:cy
   567 op len :compute:dist :compute:zx :compute:zy
-    * jump *label278 lessThan :compute:dist 64
-    * jump *label63 always
+  568 jump *label63 greaterThanEq :compute:dist 64
   569 label *label278
   570 op add :compute:i 37 1
   571 set :compute:x1 :compute:zx
 
   577 op mul *tmp86 *tmp85 :compute:zy
   578 op add :compute:zy *tmp86 :compute:cy
   579 op len :compute:dist :compute:zx :compute:zy
-    * jump *label281 lessThan :compute:dist 64
-    * jump *label63 always
+  580 jump *label63 greaterThanEq :compute:dist 64
   581 label *label281
   582 op add :compute:i 38 1
   583 set :compute:x1 :compute:zx
 
   589 op mul *tmp86 *tmp85 :compute:zy
   590 op add :compute:zy *tmp86 :compute:cy
   591 op len :compute:dist :compute:zx :compute:zy
-    * jump *label284 lessThan :compute:dist 64
-    * jump *label63 always
+  592 jump *label63 greaterThanEq :compute:dist 64
   593 label *label284
   594 op add :compute:i 39 1
   595 set :compute:x1 :compute:zx
 
   601 op mul *tmp86 *tmp85 :compute:zy
   602 op add :compute:zy *tmp86 :compute:cy
   603 op len :compute:dist :compute:zx :compute:zy
-    * jump *label287 lessThan :compute:dist 64
-    * jump *label63 always
+  604 jump *label63 greaterThanEq :compute:dist 64
   605 label *label287
   606 op add :compute:i 40 1
   607 set :compute:x1 :compute:zx
 
   613 op mul *tmp86 *tmp85 :compute:zy
   614 op add :compute:zy *tmp86 :compute:cy
   615 op len :compute:dist :compute:zx :compute:zy
-    * jump *label290 lessThan :compute:dist 64
-    * jump *label63 always
+  616 jump *label63 greaterThanEq :compute:dist 64
   617 label *label290
   618 op add :compute:i 41 1
   619 set :compute:x1 :compute:zx
 
   625 op mul *tmp86 *tmp85 :compute:zy
   626 op add :compute:zy *tmp86 :compute:cy
   627 op len :compute:dist :compute:zx :compute:zy
-    * jump *label293 lessThan :compute:dist 64
-    * jump *label63 always
+  628 jump *label63 greaterThanEq :compute:dist 64
   629 label *label293
   630 op add :compute:i 42 1
   631 set :compute:x1 :compute:zx
 
   637 op mul *tmp86 *tmp85 :compute:zy
   638 op add :compute:zy *tmp86 :compute:cy
   639 op len :compute:dist :compute:zx :compute:zy
-    * jump *label296 lessThan :compute:dist 64
-    * jump *label63 always
+  640 jump *label63 greaterThanEq :compute:dist 64
   641 label *label296
   642 op add :compute:i 43 1
   643 set :compute:x1 :compute:zx
 
   649 op mul *tmp86 *tmp85 :compute:zy
   650 op add :compute:zy *tmp86 :compute:cy
   651 op len :compute:dist :compute:zx :compute:zy
-    * jump *label299 lessThan :compute:dist 64
-    * jump *label63 always
+  652 jump *label63 greaterThanEq :compute:dist 64
   653 label *label299
   654 op add :compute:i 44 1
   655 set :compute:x1 :compute:zx
 
   661 op mul *tmp86 *tmp85 :compute:zy
   662 op add :compute:zy *tmp86 :compute:cy
   663 op len :compute:dist :compute:zx :compute:zy
-    * jump *label302 lessThan :compute:dist 64
-    * jump *label63 always
+  664 jump *label63 greaterThanEq :compute:dist 64
   665 label *label302
   666 op add :compute:i 45 1
   667 set :compute:x1 :compute:zx
 
   673 op mul *tmp86 *tmp85 :compute:zy
   674 op add :compute:zy *tmp86 :compute:cy
   675 op len :compute:dist :compute:zx :compute:zy
-    * jump *label305 lessThan :compute:dist 64
-    * jump *label63 always
+  676 jump *label63 greaterThanEq :compute:dist 64
   677 label *label305
   678 op add :compute:i 46 1
   679 set :compute:x1 :compute:zx
 
   685 op mul *tmp86 *tmp85 :compute:zy
   686 op add :compute:zy *tmp86 :compute:cy
   687 op len :compute:dist :compute:zx :compute:zy
-    * jump *label308 lessThan :compute:dist 64
-    * jump *label63 always
+  688 jump *label63 greaterThanEq :compute:dist 64
   689 label *label308
   690 op add :compute:i 47 1
   691 set :compute:x1 :compute:zx
 
   697 op mul *tmp86 *tmp85 :compute:zy
   698 op add :compute:zy *tmp86 :compute:cy
   699 op len :compute:dist :compute:zx :compute:zy
-    * jump *label311 lessThan :compute:dist 64
-    * jump *label63 always
+  700 jump *label63 greaterThanEq :compute:dist 64
   701 label *label311
   702 op add :compute:i 48 1
   703 set :compute:x1 :compute:zx
 
   709 op mul *tmp86 *tmp85 :compute:zy
   710 op add :compute:zy *tmp86 :compute:cy
   711 op len :compute:dist :compute:zx :compute:zy
-    * jump *label314 lessThan :compute:dist 64
-    * jump *label63 always
+  712 jump *label63 greaterThanEq :compute:dist 64
   713 label *label314
   714 op add :compute:i 49 1
   715 set :compute:x1 :compute:zx
 
   721 op mul *tmp86 *tmp85 :compute:zy
   722 op add :compute:zy *tmp86 :compute:cy
   723 op len :compute:dist :compute:zx :compute:zy
-    * jump *label317 lessThan :compute:dist 64
-    * jump *label63 always
+  724 jump *label63 greaterThanEq :compute:dist 64
   725 label *label317
   726 op add :compute:i 50 1
   727 set :compute:x1 :compute:zx
 
   733 op mul *tmp86 *tmp85 :compute:zy
   734 op add :compute:zy *tmp86 :compute:cy
   735 op len :compute:dist :compute:zx :compute:zy
-    * jump *label320 lessThan :compute:dist 64
-    * jump *label63 always
+  736 jump *label63 greaterThanEq :compute:dist 64
   737 label *label320
   738 op add :compute:i 51 1
   739 set :compute:x1 :compute:zx
 
   745 op mul *tmp86 *tmp85 :compute:zy
   746 op add :compute:zy *tmp86 :compute:cy
   747 op len :compute:dist :compute:zx :compute:zy
-    * jump *label323 lessThan :compute:dist 64
-    * jump *label63 always
+  748 jump *label63 greaterThanEq :compute:dist 64
   749 label *label323
   750 op add :compute:i 52 1
   751 set :compute:x1 :compute:zx
 
   757 op mul *tmp86 *tmp85 :compute:zy
   758 op add :compute:zy *tmp86 :compute:cy
   759 op len :compute:dist :compute:zx :compute:zy
-    * jump *label326 lessThan :compute:dist 64
-    * jump *label63 always
+  760 jump *label63 greaterThanEq :compute:dist 64
   761 label *label326
   762 op add :compute:i 53 1
   763 set :compute:x1 :compute:zx
 
   769 op mul *tmp86 *tmp85 :compute:zy
   770 op add :compute:zy *tmp86 :compute:cy
   771 op len :compute:dist :compute:zx :compute:zy
-    * jump *label329 lessThan :compute:dist 64
-    * jump *label63 always
+  772 jump *label63 greaterThanEq :compute:dist 64
   773 label *label329
   774 op add :compute:i 54 1
   775 set :compute:x1 :compute:zx
 
   781 op mul *tmp86 *tmp85 :compute:zy
   782 op add :compute:zy *tmp86 :compute:cy
   783 op len :compute:dist :compute:zx :compute:zy
-    * jump *label332 lessThan :compute:dist 64
-    * jump *label63 always
+  784 jump *label63 greaterThanEq :compute:dist 64
   785 label *label332
   786 op add :compute:i 55 1
   787 set :compute:x1 :compute:zx
 
   793 op mul *tmp86 *tmp85 :compute:zy
   794 op add :compute:zy *tmp86 :compute:cy
   795 op len :compute:dist :compute:zx :compute:zy
-    * jump *label335 lessThan :compute:dist 64
-    * jump *label63 always
+  796 jump *label63 greaterThanEq :compute:dist 64
   797 label *label335
   798 op add :compute:i 56 1
   799 set :compute:x1 :compute:zx
 
   805 op mul *tmp86 *tmp85 :compute:zy
   806 op add :compute:zy *tmp86 :compute:cy
   807 op len :compute:dist :compute:zx :compute:zy
-    * jump *label338 lessThan :compute:dist 64
-    * jump *label63 always
+  808 jump *label63 greaterThanEq :compute:dist 64
   809 label *label338
   810 op add :compute:i 57 1
   811 set :compute:x1 :compute:zx
 
   817 op mul *tmp86 *tmp85 :compute:zy
   818 op add :compute:zy *tmp86 :compute:cy
   819 op len :compute:dist :compute:zx :compute:zy
-    * jump *label341 lessThan :compute:dist 64
-    * jump *label63 always
+  820 jump *label63 greaterThanEq :compute:dist 64
   821 label *label341
   822 op add :compute:i 58 1
   823 set :compute:x1 :compute:zx
 
   829 op mul *tmp86 *tmp85 :compute:zy
   830 op add :compute:zy *tmp86 :compute:cy
   831 op len :compute:dist :compute:zx :compute:zy
-    * jump *label344 lessThan :compute:dist 64
-    * jump *label63 always
+  832 jump *label63 greaterThanEq :compute:dist 64
   833 label *label344
   834 op add :compute:i 59 1
   835 set :compute:x1 :compute:zx
 
   841 op mul *tmp86 *tmp85 :compute:zy
   842 op add :compute:zy *tmp86 :compute:cy
   843 op len :compute:dist :compute:zx :compute:zy
-    * jump *label347 lessThan :compute:dist 64
-    * jump *label63 always
+  844 jump *label63 greaterThanEq :compute:dist 64
   845 label *label347
   846 op add :compute:i 60 1
   847 set :compute:x1 :compute:zx
 
   853 op mul *tmp86 *tmp85 :compute:zy
   854 op add :compute:zy *tmp86 :compute:cy
   855 op len :compute:dist :compute:zx :compute:zy
-    * jump *label350 lessThan :compute:dist 64
-    * jump *label63 always
+  856 jump *label63 greaterThanEq :compute:dist 64
   857 label *label350
   858 op add :compute:i 61 1
   859 set :compute:x1 :compute:zx
 
   865 op mul *tmp86 *tmp85 :compute:zy
   866 op add :compute:zy *tmp86 :compute:cy
   867 op len :compute:dist :compute:zx :compute:zy
-    * jump *label353 lessThan :compute:dist 64
-    * jump *label63 always
+  868 jump *label63 greaterThanEq :compute:dist 64
   869 label *label353
   870 op add :compute:i 62 1
   871 label *label63
 
   966 op add *tmp1 *tmp163 1
   967 write *tmp1 .memory 65
   968 read *tmp166 .memory 67
-    * jump *label102 equal .stop *tmp166
-    * jump *label29 always
+  969 jump *label29 notEqual .stop *tmp166
   970 label *label102
   971 op add :i :i 1
   972 jump *label114 lessThan :i 16

Modifications by Jumps phase, Jump Threading, pass 6, iteration 1:
 
    53 label *label34
    54 wait 0
    55 read *tmp40 .memory 67
-    * jump *label29 notEqual .stop *tmp40
+   56 jump *label28 notEqual .stop *tmp40
    57 read *tmp42 .memory 64
    58 op add *tmp0 *tmp42 1
    59 write *tmp0 .memory 64
-    * jump *label36 greaterThanEq *tmp42 2816
+   60 jump *label28 greaterThanEq *tmp42 2816
    61 multijump *tmp42 0 0 (m:*label154)
    62 multilabel *label158 (m:*label154)
    63 op mul *tmp55 2 *tmp42
 
   817 label *label54
   818 jump *label71 lessThanEq .PALETTE 1
   819 set :drawPixel:color %[black]
-    * jump *label74 equal *tmp63 63
+  820 jump *label72 equal *tmp63 63
   821 multijump .PALETTE 0 0 (m:*label160)
   822 multilabel *label165 (m:*label160)
   823 multilabel *label161 (m:*label160)
   824 op div *tmp138 *tmp63 63.75
   825 op sub :drawPixel:r 1 *tmp138
   826 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * jump *label75 always
+  827 jump *label72 always
   828 multilabel *label162 (m:*label160)
   829 op sub *tmp103 32 *tmp63
   830 op abs *tmp104 *tmp103
 
   837 op div *tmp116 *tmp104 63.75
   838 op add :drawPixel:b 0.47058823529411764 *tmp116
   839 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label75 always
+  840 jump *label72 always
   841 multilabel *label163 (m:*label160)
   842 op div *tmp120 *tmp63 0.175
   843 op sin :drawPixel:r *tmp120
 
   847 op div *tmp128 *tmp126 63.75
   848 op add :drawPixel:b 0.39215686274509803 *tmp128
   849 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label75 always
+  850 jump *label72 always
   851 multilabel *label164 (m:*label160)
   852 op div :drawPixel:r *tmp63 63.75
   853 op div *tmp134 *tmp63 170
 
   860 read :drawPixel:color .memory *tmp63
   861 label *label72
   862 jump *label82 lessThan .localBuffer 254
-    * jump *label87 lessThanEq .localBuffer 0
+  863 jump *label93 lessThanEq .localBuffer 0
   864 label *label116
   865 wait 0
   866 sensor *tmp147 .display @enabled
 
   901 op add *tmp1 *tmp163 1
   902 write *tmp1 .memory 65
   903 read *tmp166 .memory 67
-    * jump *label29 notEqual .stop *tmp166
+  904 jump *label28 notEqual .stop *tmp166
   905 op add :i :i 1
   906 jump *label114 lessThan :i 16
-    * jump *label107 lessThanEq .localBuffer 0
+  907 jump *label34 lessThanEq .localBuffer 0
   908 label *label117
   909 wait 0
   910 sensor *tmp169 .display @enabled

Modifications by Jumps phase, Unreachable Code Elimination, pass 7, iteration 1 (-1 instructions):
 
   915 label *label109
   916 jump *label117 greaterThan .localBuffer 0
   917 jump *label34 always
-    * jump *label28 always

Modifications by Final phase, Print Merging, iteration 1 (-7 instructions):
 
    16 set .memory :findLinkedBlocks:variable
    17 jump *label113 greaterThan :findLinkedBlocks:n 0
    18 label *label11
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
-    * print .display
+   19 print "\nDisplay: {0}\nMemory: "
+   20 format .display
    21 op and :findLinkedBlocks:foundAll 1 .display
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
    22 print .memory
    23 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    24 printflush null

Final code before resolving virtual instructions:

    0:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label1                                                *blocks: do
    1:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    2:  set .memory null                                             ...
    3:  print "Mandelbrot Generator"                                 *blocks: print(title);
    4:  set :findLinkedBlocks:n @links                               *blocks: var n = @links;
    5:  jump *label11 lessThanEq :findLinkedBlocks:n 0               *blocks: while n > 0 do
        label *label113                                              ...
    6:  op sub :findLinkedBlocks:n :findLinkedBlocks:n 1             *blocks: var block = getlink(--n);
    7:  getlink :findLinkedBlocks:block :findLinkedBlocks:n          ...
    8:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
    9:  print :findLinkedBlocks:block                                ...
   10:  sensor :findLinkedBlocks:type :findLinkedBlocks:block @type  *blocks: var type = block.@type;
   11:  select :findLinkedBlocks:variable equal @large-logic-display *blocks: if requested == type then
   12:  set .display :findLinkedBlocks:variable                      *blocks: for requested, name, out variable, required in linkMap do
   13:  select :findLinkedBlocks:variable equal @memory-bank :findLi *blocks: if requested == type then
   14:  set .memory :findLinkedBlocks:variable                       *blocks: for requested, name, out variable, required in linkMap do
   15:  jump *label113 greaterThan :findLinkedBlocks:n 0             *blocks: while n > 0 do
        label *label11                                               ...
   16:  print "\nDisplay: {0}\nMemory: "                             *blocks: print($"\n$name: $variable");
   17:  format .display                                              ...
   18:  op and :findLinkedBlocks:foundAll 1 .display                 *blocks: if required then foundAll &= variable; end;
   19:  print .memory                                                *blocks: print($"\n$name: $variable");
   20:  op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll *blocks: if required then foundAll &= variable; end;
   21:  printflush null                                              *blocks: printflush(message);
   22:  jump *label1 equal :findLinkedBlocks:foundAll false          *blocks: do
        label *label28                                               mandelbrot-compute.mnd: MainLoop:
        label *label31                                               mandelbrot-compute.mnd: do wait(0); while start == $START;
   23:  wait 0                                                       ...
   24:  read *tmp24 .memory 66                                       ...
   25:  jump *label31 equal .start *tmp24                            ...
   26:  read .start .memory 66                                       mandelbrot-compute.mnd: start = $START;
   27:  read .stop .memory 67                                        mandelbrot-compute.mnd: stop = $STOP;
   28:  set .lastColor -1                                            mandelbrot-compute.mnd: lastColor = -1;
   29:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   30:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
   31:  read .ZOOM .memory 70                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   32:  op div *tmp28 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   33:  read *tmp30 .memory 68                                       ...
   34:  op add .OFFSET_X *tmp28 *tmp30                               ...
   35:  read *tmp33 .memory 69                                       mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   36:  op add .OFFSET_Y *tmp28 *tmp33                               ...
   37:  read .JULIA .memory 71                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   38:  read .JULIA_X .memory 72                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   39:  read .JULIA_Y .memory 73                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   40:  read .PALETTE .memory 74                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
        label *label34                                               mandelbrot-compute.mnd: while true do
   41:  wait 0.004                              # 0.240 ticks for at mandelbrot-compute.mnd: atomic
   42:  read *tmp40 .memory 67                                       mandelbrot-compute.mnd: if stop != $STOP then
   43:  jump *label28 notEqual .stop *tmp40                          ...
   44:  read *tmp42 .memory 64                                       mandelbrot-compute.mnd: batch = $LINE++;
   45:  op add *tmp0 *tmp42 1                                        ...
   46:  write *tmp0 .memory 64                  # The last atomic bl ...
   47:  jump *label28 greaterThanEq *tmp42 2816                      mandelbrot-compute.mnd: if batch >= BATCH * DISPLAY_SIZE_LARGE then
   48:  multijump *tmp42 0 0                                         mandelbrot-compute.mnd: var strip = case batch
        multilabel *label158                                         ...
   49:  op mul *tmp55 2 *tmp42                                       mandelbrot-compute.mnd: else 2 * batch - 2 * 88 + 1;
   50:  op sub *tmp46 *tmp55 175                                     ...
   51:  jump *label41 always 0 0                                     mandelbrot-compute.mnd: var strip = case batch
        multilabel *label155                                         ...
   52:  op mul *tmp46 8 *tmp42                                       mandelbrot-compute.mnd: when 0 ... 22 then 8 * batch;
   53:  jump *label41 always 0 0                                     mandelbrot-compute.mnd: var strip = case batch
        multilabel *label156                                         ...
   54:  op mul *tmp49 8 *tmp42                                       mandelbrot-compute.mnd: when 22 ... 44 then 8 * batch - 8 * 22 + 4;
   55:  op sub *tmp46 *tmp49 172                                     ...
   56:  jump *label41 always 0 0                                     mandelbrot-compute.mnd: var strip = case batch
        multilabel *label157                                         ...
   57:  op mul *tmp52 4 *tmp42                                       mandelbrot-compute.mnd: when 44 ... 88 then 4 * batch - 4 * 44 + 2;
   58:  op sub *tmp46 *tmp52 174                                     ...
        label *label41                                               mandelbrot-compute.mnd: var strip = case batch
   59:  op idiv *tmp58 *tmp46 16                                     mandelbrot-compute.mnd: var x = ((strip \ 16) * SKIP) % DISPLAY_SIZE_LARGE;
   60:  op mul *tmp59 *tmp58 17                                      ...
   61:  op mod :x *tmp59 176                                         ...
   62:  op mod :y *tmp46 16                                          mandelbrot-compute.mnd: var y = strip % 16;
   63:  set :i 0                                                     mandelbrot-compute.mnd: for var i in 0 ... BATCH do
        label *label114                                              ...
   64:  op add *tmp62 :y :i                                          mandelbrot-compute.mnd: var iterations = compute(x, y + i);
   65:  op div *tmp64 :x .ZOOM                                       mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   66:  op add :compute:zx *tmp64 .OFFSET_X                          ...
   67:  op div *tmp66 *tmp62 .ZOOM                                   mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   68:  op add :compute:zy *tmp66 .OFFSET_Y                          ...
   69:  jump *label55 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   70:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
   71:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
   72:  jump *label56 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label55                                               ...
   73:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
   74:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
   75:  op sub *tmp69 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   76:  op len :compute:p *tmp69 :compute:zy                         ...
   77:  op mul *tmp71 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
   78:  op mul *tmp72 *tmp71 :compute:p                              ...
   79:  op sub *tmp73 :compute:p *tmp72                              ...
   80:  op add *tmp74 *tmp73 0.25                                    ...
   81:  jump *label57 greaterThan :compute:zx *tmp74                 ...
   82:  set *tmp63 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
   83:  jump *label54 always 0 0                                     ...
        label *label57                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
   84:  op add *tmp77 :compute:zx 1                                  mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
   85:  op len *tmp78 *tmp77 :compute:zy                             ...
   86:  jump *label59 greaterThan *tmp78 0.25                        ...
   87:  set *tmp63 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
   88:  jump *label54 always 0 0                                     ...
        label *label59                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label56                                               mandelbrot-compute.mnd: if JULIA then
   89:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
   90:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
   91:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
   92:  op mul *tmp82 :compute:zy :compute:zy                        ...
   93:  op sub *tmp83 *tmp81 *tmp82                                  ...
   94:  op add :compute:zx *tmp83 :compute:cx                        ...
   95:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
   96:  op mul *tmp86 *tmp85 :compute:zy                             ...
   97:  op add :compute:zy *tmp86 :compute:cy                        ...
   98:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
   99:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  100:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  101:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  102:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  103:  op mul *tmp82 :compute:zy :compute:zy                        ...
  104:  op sub *tmp83 *tmp81 *tmp82                                  ...
  105:  op add :compute:zx *tmp83 :compute:cx                        ...
  106:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  107:  op mul *tmp86 *tmp85 :compute:zy                             ...
  108:  op add :compute:zy *tmp86 :compute:cy                        ...
  109:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  110:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  111:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  112:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  113:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  114:  op mul *tmp82 :compute:zy :compute:zy                        ...
  115:  op sub *tmp83 *tmp81 *tmp82                                  ...
  116:  op add :compute:zx *tmp83 :compute:cx                        ...
  117:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  118:  op mul *tmp86 *tmp85 :compute:zy                             ...
  119:  op add :compute:zy *tmp86 :compute:cy                        ...
  120:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  121:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  122:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  123:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  124:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  125:  op mul *tmp82 :compute:zy :compute:zy                        ...
  126:  op sub *tmp83 *tmp81 *tmp82                                  ...
  127:  op add :compute:zx *tmp83 :compute:cx                        ...
  128:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  129:  op mul *tmp86 *tmp85 :compute:zy                             ...
  130:  op add :compute:zy *tmp86 :compute:cy                        ...
  131:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  132:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  133:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  134:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  135:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  136:  op mul *tmp82 :compute:zy :compute:zy                        ...
  137:  op sub *tmp83 *tmp81 *tmp82                                  ...
  138:  op add :compute:zx *tmp83 :compute:cx                        ...
  139:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  140:  op mul *tmp86 *tmp85 :compute:zy                             ...
  141:  op add :compute:zy *tmp86 :compute:cy                        ...
  142:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  143:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  144:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  145:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  146:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  147:  op mul *tmp82 :compute:zy :compute:zy                        ...
  148:  op sub *tmp83 *tmp81 *tmp82                                  ...
  149:  op add :compute:zx *tmp83 :compute:cx                        ...
  150:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  151:  op mul *tmp86 *tmp85 :compute:zy                             ...
  152:  op add :compute:zy *tmp86 :compute:cy                        ...
  153:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  154:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  155:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  156:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  157:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  158:  op mul *tmp82 :compute:zy :compute:zy                        ...
  159:  op sub *tmp83 *tmp81 *tmp82                                  ...
  160:  op add :compute:zx *tmp83 :compute:cx                        ...
  161:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  162:  op mul *tmp86 *tmp85 :compute:zy                             ...
  163:  op add :compute:zy *tmp86 :compute:cy                        ...
  164:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  165:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  166:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  167:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  168:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  169:  op mul *tmp82 :compute:zy :compute:zy                        ...
  170:  op sub *tmp83 *tmp81 *tmp82                                  ...
  171:  op add :compute:zx *tmp83 :compute:cx                        ...
  172:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  173:  op mul *tmp86 *tmp85 :compute:zy                             ...
  174:  op add :compute:zy *tmp86 :compute:cy                        ...
  175:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  176:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  177:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  178:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  179:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  180:  op mul *tmp82 :compute:zy :compute:zy                        ...
  181:  op sub *tmp83 *tmp81 *tmp82                                  ...
  182:  op add :compute:zx *tmp83 :compute:cx                        ...
  183:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  184:  op mul *tmp86 *tmp85 :compute:zy                             ...
  185:  op add :compute:zy *tmp86 :compute:cy                        ...
  186:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  187:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  188:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  189:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  190:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  191:  op mul *tmp82 :compute:zy :compute:zy                        ...
  192:  op sub *tmp83 *tmp81 *tmp82                                  ...
  193:  op add :compute:zx *tmp83 :compute:cx                        ...
  194:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  195:  op mul *tmp86 *tmp85 :compute:zy                             ...
  196:  op add :compute:zy *tmp86 :compute:cy                        ...
  197:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  198:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  199:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  200:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  201:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  202:  op mul *tmp82 :compute:zy :compute:zy                        ...
  203:  op sub *tmp83 *tmp81 *tmp82                                  ...
  204:  op add :compute:zx *tmp83 :compute:cx                        ...
  205:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  206:  op mul *tmp86 *tmp85 :compute:zy                             ...
  207:  op add :compute:zy *tmp86 :compute:cy                        ...
  208:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  209:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  210:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  211:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  212:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  213:  op mul *tmp82 :compute:zy :compute:zy                        ...
  214:  op sub *tmp83 *tmp81 *tmp82                                  ...
  215:  op add :compute:zx *tmp83 :compute:cx                        ...
  216:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  217:  op mul *tmp86 *tmp85 :compute:zy                             ...
  218:  op add :compute:zy *tmp86 :compute:cy                        ...
  219:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  220:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  221:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  222:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  223:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  224:  op mul *tmp82 :compute:zy :compute:zy                        ...
  225:  op sub *tmp83 *tmp81 *tmp82                                  ...
  226:  op add :compute:zx *tmp83 :compute:cx                        ...
  227:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  228:  op mul *tmp86 *tmp85 :compute:zy                             ...
  229:  op add :compute:zy *tmp86 :compute:cy                        ...
  230:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  231:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  232:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  233:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  234:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  235:  op mul *tmp82 :compute:zy :compute:zy                        ...
  236:  op sub *tmp83 *tmp81 *tmp82                                  ...
  237:  op add :compute:zx *tmp83 :compute:cx                        ...
  238:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  239:  op mul *tmp86 *tmp85 :compute:zy                             ...
  240:  op add :compute:zy *tmp86 :compute:cy                        ...
  241:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  242:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  243:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  244:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  245:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  246:  op mul *tmp82 :compute:zy :compute:zy                        ...
  247:  op sub *tmp83 *tmp81 *tmp82                                  ...
  248:  op add :compute:zx *tmp83 :compute:cx                        ...
  249:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  250:  op mul *tmp86 *tmp85 :compute:zy                             ...
  251:  op add :compute:zy *tmp86 :compute:cy                        ...
  252:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  253:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  254:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  255:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  256:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  257:  op mul *tmp82 :compute:zy :compute:zy                        ...
  258:  op sub *tmp83 *tmp81 *tmp82                                  ...
  259:  op add :compute:zx *tmp83 :compute:cx                        ...
  260:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  261:  op mul *tmp86 *tmp85 :compute:zy                             ...
  262:  op add :compute:zy *tmp86 :compute:cy                        ...
  263:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  264:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  265:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  266:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  267:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  268:  op mul *tmp82 :compute:zy :compute:zy                        ...
  269:  op sub *tmp83 *tmp81 *tmp82                                  ...
  270:  op add :compute:zx *tmp83 :compute:cx                        ...
  271:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  272:  op mul *tmp86 *tmp85 :compute:zy                             ...
  273:  op add :compute:zy *tmp86 :compute:cy                        ...
  274:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  275:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  276:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  277:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  278:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  279:  op mul *tmp82 :compute:zy :compute:zy                        ...
  280:  op sub *tmp83 *tmp81 *tmp82                                  ...
  281:  op add :compute:zx *tmp83 :compute:cx                        ...
  282:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  283:  op mul *tmp86 *tmp85 :compute:zy                             ...
  284:  op add :compute:zy *tmp86 :compute:cy                        ...
  285:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  286:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  287:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  288:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  289:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  290:  op mul *tmp82 :compute:zy :compute:zy                        ...
  291:  op sub *tmp83 *tmp81 *tmp82                                  ...
  292:  op add :compute:zx *tmp83 :compute:cx                        ...
  293:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  294:  op mul *tmp86 *tmp85 :compute:zy                             ...
  295:  op add :compute:zy *tmp86 :compute:cy                        ...
  296:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  297:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  298:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  299:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  300:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  301:  op mul *tmp82 :compute:zy :compute:zy                        ...
  302:  op sub *tmp83 *tmp81 *tmp82                                  ...
  303:  op add :compute:zx *tmp83 :compute:cx                        ...
  304:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  305:  op mul *tmp86 *tmp85 :compute:zy                             ...
  306:  op add :compute:zy *tmp86 :compute:cy                        ...
  307:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  308:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  309:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  310:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  311:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  312:  op mul *tmp82 :compute:zy :compute:zy                        ...
  313:  op sub *tmp83 *tmp81 *tmp82                                  ...
  314:  op add :compute:zx *tmp83 :compute:cx                        ...
  315:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  316:  op mul *tmp86 *tmp85 :compute:zy                             ...
  317:  op add :compute:zy *tmp86 :compute:cy                        ...
  318:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  319:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  320:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  321:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  322:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  323:  op mul *tmp82 :compute:zy :compute:zy                        ...
  324:  op sub *tmp83 *tmp81 *tmp82                                  ...
  325:  op add :compute:zx *tmp83 :compute:cx                        ...
  326:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  327:  op mul *tmp86 *tmp85 :compute:zy                             ...
  328:  op add :compute:zy *tmp86 :compute:cy                        ...
  329:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  330:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  331:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  332:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  333:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  334:  op mul *tmp82 :compute:zy :compute:zy                        ...
  335:  op sub *tmp83 *tmp81 *tmp82                                  ...
  336:  op add :compute:zx *tmp83 :compute:cx                        ...
  337:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  338:  op mul *tmp86 *tmp85 :compute:zy                             ...
  339:  op add :compute:zy *tmp86 :compute:cy                        ...
  340:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  341:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  342:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  343:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  344:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  345:  op mul *tmp82 :compute:zy :compute:zy                        ...
  346:  op sub *tmp83 *tmp81 *tmp82                                  ...
  347:  op add :compute:zx *tmp83 :compute:cx                        ...
  348:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  349:  op mul *tmp86 *tmp85 :compute:zy                             ...
  350:  op add :compute:zy *tmp86 :compute:cy                        ...
  351:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  352:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  353:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  354:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  355:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  356:  op mul *tmp82 :compute:zy :compute:zy                        ...
  357:  op sub *tmp83 *tmp81 *tmp82                                  ...
  358:  op add :compute:zx *tmp83 :compute:cx                        ...
  359:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  360:  op mul *tmp86 *tmp85 :compute:zy                             ...
  361:  op add :compute:zy *tmp86 :compute:cy                        ...
  362:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  363:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  364:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  365:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  366:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  367:  op mul *tmp82 :compute:zy :compute:zy                        ...
  368:  op sub *tmp83 *tmp81 *tmp82                                  ...
  369:  op add :compute:zx *tmp83 :compute:cx                        ...
  370:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  371:  op mul *tmp86 *tmp85 :compute:zy                             ...
  372:  op add :compute:zy *tmp86 :compute:cy                        ...
  373:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  374:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  375:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  376:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  377:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  378:  op mul *tmp82 :compute:zy :compute:zy                        ...
  379:  op sub *tmp83 *tmp81 *tmp82                                  ...
  380:  op add :compute:zx *tmp83 :compute:cx                        ...
  381:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  382:  op mul *tmp86 *tmp85 :compute:zy                             ...
  383:  op add :compute:zy *tmp86 :compute:cy                        ...
  384:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  385:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  386:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  387:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  388:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  389:  op mul *tmp82 :compute:zy :compute:zy                        ...
  390:  op sub *tmp83 *tmp81 *tmp82                                  ...
  391:  op add :compute:zx *tmp83 :compute:cx                        ...
  392:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  393:  op mul *tmp86 *tmp85 :compute:zy                             ...
  394:  op add :compute:zy *tmp86 :compute:cy                        ...
  395:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  396:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  397:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  398:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  399:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  400:  op mul *tmp82 :compute:zy :compute:zy                        ...
  401:  op sub *tmp83 *tmp81 *tmp82                                  ...
  402:  op add :compute:zx *tmp83 :compute:cx                        ...
  403:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  404:  op mul *tmp86 *tmp85 :compute:zy                             ...
  405:  op add :compute:zy *tmp86 :compute:cy                        ...
  406:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  407:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  408:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  409:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  410:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  411:  op mul *tmp82 :compute:zy :compute:zy                        ...
  412:  op sub *tmp83 *tmp81 *tmp82                                  ...
  413:  op add :compute:zx *tmp83 :compute:cx                        ...
  414:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  415:  op mul *tmp86 *tmp85 :compute:zy                             ...
  416:  op add :compute:zy *tmp86 :compute:cy                        ...
  417:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  418:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  419:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  420:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  421:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  422:  op mul *tmp82 :compute:zy :compute:zy                        ...
  423:  op sub *tmp83 *tmp81 *tmp82                                  ...
  424:  op add :compute:zx *tmp83 :compute:cx                        ...
  425:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  426:  op mul *tmp86 *tmp85 :compute:zy                             ...
  427:  op add :compute:zy *tmp86 :compute:cy                        ...
  428:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  429:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  430:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  431:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  432:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  433:  op mul *tmp82 :compute:zy :compute:zy                        ...
  434:  op sub *tmp83 *tmp81 *tmp82                                  ...
  435:  op add :compute:zx *tmp83 :compute:cx                        ...
  436:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  437:  op mul *tmp86 *tmp85 :compute:zy                             ...
  438:  op add :compute:zy *tmp86 :compute:cy                        ...
  439:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  440:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  441:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  442:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  443:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  444:  op mul *tmp82 :compute:zy :compute:zy                        ...
  445:  op sub *tmp83 *tmp81 *tmp82                                  ...
  446:  op add :compute:zx *tmp83 :compute:cx                        ...
  447:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  448:  op mul *tmp86 *tmp85 :compute:zy                             ...
  449:  op add :compute:zy *tmp86 :compute:cy                        ...
  450:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  451:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  452:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  453:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  454:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  455:  op mul *tmp82 :compute:zy :compute:zy                        ...
  456:  op sub *tmp83 *tmp81 *tmp82                                  ...
  457:  op add :compute:zx *tmp83 :compute:cx                        ...
  458:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  459:  op mul *tmp86 *tmp85 :compute:zy                             ...
  460:  op add :compute:zy *tmp86 :compute:cy                        ...
  461:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  462:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  463:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  464:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  465:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  466:  op mul *tmp82 :compute:zy :compute:zy                        ...
  467:  op sub *tmp83 *tmp81 *tmp82                                  ...
  468:  op add :compute:zx *tmp83 :compute:cx                        ...
  469:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  470:  op mul *tmp86 *tmp85 :compute:zy                             ...
  471:  op add :compute:zy *tmp86 :compute:cy                        ...
  472:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  473:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  474:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  475:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  476:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  477:  op mul *tmp82 :compute:zy :compute:zy                        ...
  478:  op sub *tmp83 *tmp81 *tmp82                                  ...
  479:  op add :compute:zx *tmp83 :compute:cx                        ...
  480:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  481:  op mul *tmp86 *tmp85 :compute:zy                             ...
  482:  op add :compute:zy *tmp86 :compute:cy                        ...
  483:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  484:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  485:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  486:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  487:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  488:  op mul *tmp82 :compute:zy :compute:zy                        ...
  489:  op sub *tmp83 *tmp81 *tmp82                                  ...
  490:  op add :compute:zx *tmp83 :compute:cx                        ...
  491:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  492:  op mul *tmp86 *tmp85 :compute:zy                             ...
  493:  op add :compute:zy *tmp86 :compute:cy                        ...
  494:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  495:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  496:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  497:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  498:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  499:  op mul *tmp82 :compute:zy :compute:zy                        ...
  500:  op sub *tmp83 *tmp81 *tmp82                                  ...
  501:  op add :compute:zx *tmp83 :compute:cx                        ...
  502:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  503:  op mul *tmp86 *tmp85 :compute:zy                             ...
  504:  op add :compute:zy *tmp86 :compute:cy                        ...
  505:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  506:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  507:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  508:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  509:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  510:  op mul *tmp82 :compute:zy :compute:zy                        ...
  511:  op sub *tmp83 *tmp81 *tmp82                                  ...
  512:  op add :compute:zx *tmp83 :compute:cx                        ...
  513:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  514:  op mul *tmp86 *tmp85 :compute:zy                             ...
  515:  op add :compute:zy *tmp86 :compute:cy                        ...
  516:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  517:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  518:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  519:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  520:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  521:  op mul *tmp82 :compute:zy :compute:zy                        ...
  522:  op sub *tmp83 *tmp81 *tmp82                                  ...
  523:  op add :compute:zx *tmp83 :compute:cx                        ...
  524:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  525:  op mul *tmp86 *tmp85 :compute:zy                             ...
  526:  op add :compute:zy *tmp86 :compute:cy                        ...
  527:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  528:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  529:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  530:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  531:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  532:  op mul *tmp82 :compute:zy :compute:zy                        ...
  533:  op sub *tmp83 *tmp81 *tmp82                                  ...
  534:  op add :compute:zx *tmp83 :compute:cx                        ...
  535:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  536:  op mul *tmp86 *tmp85 :compute:zy                             ...
  537:  op add :compute:zy *tmp86 :compute:cy                        ...
  538:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  539:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  540:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  541:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  542:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  543:  op mul *tmp82 :compute:zy :compute:zy                        ...
  544:  op sub *tmp83 *tmp81 *tmp82                                  ...
  545:  op add :compute:zx *tmp83 :compute:cx                        ...
  546:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  547:  op mul *tmp86 *tmp85 :compute:zy                             ...
  548:  op add :compute:zy *tmp86 :compute:cy                        ...
  549:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  550:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  551:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  552:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  553:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  554:  op mul *tmp82 :compute:zy :compute:zy                        ...
  555:  op sub *tmp83 *tmp81 *tmp82                                  ...
  556:  op add :compute:zx *tmp83 :compute:cx                        ...
  557:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  558:  op mul *tmp86 *tmp85 :compute:zy                             ...
  559:  op add :compute:zy *tmp86 :compute:cy                        ...
  560:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  561:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  562:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  563:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  564:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  565:  op mul *tmp82 :compute:zy :compute:zy                        ...
  566:  op sub *tmp83 *tmp81 *tmp82                                  ...
  567:  op add :compute:zx *tmp83 :compute:cx                        ...
  568:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  569:  op mul *tmp86 *tmp85 :compute:zy                             ...
  570:  op add :compute:zy *tmp86 :compute:cy                        ...
  571:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  572:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  573:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  574:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  575:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  576:  op mul *tmp82 :compute:zy :compute:zy                        ...
  577:  op sub *tmp83 *tmp81 *tmp82                                  ...
  578:  op add :compute:zx *tmp83 :compute:cx                        ...
  579:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  580:  op mul *tmp86 *tmp85 :compute:zy                             ...
  581:  op add :compute:zy *tmp86 :compute:cy                        ...
  582:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  583:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  584:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  585:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  586:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  587:  op mul *tmp82 :compute:zy :compute:zy                        ...
  588:  op sub *tmp83 *tmp81 *tmp82                                  ...
  589:  op add :compute:zx *tmp83 :compute:cx                        ...
  590:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  591:  op mul *tmp86 *tmp85 :compute:zy                             ...
  592:  op add :compute:zy *tmp86 :compute:cy                        ...
  593:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  594:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  595:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  596:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  597:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  598:  op mul *tmp82 :compute:zy :compute:zy                        ...
  599:  op sub *tmp83 *tmp81 *tmp82                                  ...
  600:  op add :compute:zx *tmp83 :compute:cx                        ...
  601:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  602:  op mul *tmp86 *tmp85 :compute:zy                             ...
  603:  op add :compute:zy *tmp86 :compute:cy                        ...
  604:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  605:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  606:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  607:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  608:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  609:  op mul *tmp82 :compute:zy :compute:zy                        ...
  610:  op sub *tmp83 *tmp81 *tmp82                                  ...
  611:  op add :compute:zx *tmp83 :compute:cx                        ...
  612:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  613:  op mul *tmp86 *tmp85 :compute:zy                             ...
  614:  op add :compute:zy *tmp86 :compute:cy                        ...
  615:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  616:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  617:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  618:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  619:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  620:  op mul *tmp82 :compute:zy :compute:zy                        ...
  621:  op sub *tmp83 *tmp81 *tmp82                                  ...
  622:  op add :compute:zx *tmp83 :compute:cx                        ...
  623:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  624:  op mul *tmp86 *tmp85 :compute:zy                             ...
  625:  op add :compute:zy *tmp86 :compute:cy                        ...
  626:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  627:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  628:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  629:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  630:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  631:  op mul *tmp82 :compute:zy :compute:zy                        ...
  632:  op sub *tmp83 *tmp81 *tmp82                                  ...
  633:  op add :compute:zx *tmp83 :compute:cx                        ...
  634:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  635:  op mul *tmp86 *tmp85 :compute:zy                             ...
  636:  op add :compute:zy *tmp86 :compute:cy                        ...
  637:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  638:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  639:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  640:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  641:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  642:  op mul *tmp82 :compute:zy :compute:zy                        ...
  643:  op sub *tmp83 *tmp81 *tmp82                                  ...
  644:  op add :compute:zx *tmp83 :compute:cx                        ...
  645:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  646:  op mul *tmp86 *tmp85 :compute:zy                             ...
  647:  op add :compute:zy *tmp86 :compute:cy                        ...
  648:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  649:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  650:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  651:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  652:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  653:  op mul *tmp82 :compute:zy :compute:zy                        ...
  654:  op sub *tmp83 *tmp81 *tmp82                                  ...
  655:  op add :compute:zx *tmp83 :compute:cx                        ...
  656:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  657:  op mul *tmp86 *tmp85 :compute:zy                             ...
  658:  op add :compute:zy *tmp86 :compute:cy                        ...
  659:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  660:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  661:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  662:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  663:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  664:  op mul *tmp82 :compute:zy :compute:zy                        ...
  665:  op sub *tmp83 *tmp81 *tmp82                                  ...
  666:  op add :compute:zx *tmp83 :compute:cx                        ...
  667:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  668:  op mul *tmp86 *tmp85 :compute:zy                             ...
  669:  op add :compute:zy *tmp86 :compute:cy                        ...
  670:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  671:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  672:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  673:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  674:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  675:  op mul *tmp82 :compute:zy :compute:zy                        ...
  676:  op sub *tmp83 *tmp81 *tmp82                                  ...
  677:  op add :compute:zx *tmp83 :compute:cx                        ...
  678:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  679:  op mul *tmp86 *tmp85 :compute:zy                             ...
  680:  op add :compute:zy *tmp86 :compute:cy                        ...
  681:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  682:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  683:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  684:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  685:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  686:  op mul *tmp82 :compute:zy :compute:zy                        ...
  687:  op sub *tmp83 *tmp81 *tmp82                                  ...
  688:  op add :compute:zx *tmp83 :compute:cx                        ...
  689:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  690:  op mul *tmp86 *tmp85 :compute:zy                             ...
  691:  op add :compute:zy *tmp86 :compute:cy                        ...
  692:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  693:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  694:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  695:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  696:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  697:  op mul *tmp82 :compute:zy :compute:zy                        ...
  698:  op sub *tmp83 *tmp81 *tmp82                                  ...
  699:  op add :compute:zx *tmp83 :compute:cx                        ...
  700:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  701:  op mul *tmp86 *tmp85 :compute:zy                             ...
  702:  op add :compute:zy *tmp86 :compute:cy                        ...
  703:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  704:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  705:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  706:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  707:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  708:  op mul *tmp82 :compute:zy :compute:zy                        ...
  709:  op sub *tmp83 *tmp81 *tmp82                                  ...
  710:  op add :compute:zx *tmp83 :compute:cx                        ...
  711:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  712:  op mul *tmp86 *tmp85 :compute:zy                             ...
  713:  op add :compute:zy *tmp86 :compute:cy                        ...
  714:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  715:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  716:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  717:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  718:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  719:  op mul *tmp82 :compute:zy :compute:zy                        ...
  720:  op sub *tmp83 *tmp81 *tmp82                                  ...
  721:  op add :compute:zx *tmp83 :compute:cx                        ...
  722:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  723:  op mul *tmp86 *tmp85 :compute:zy                             ...
  724:  op add :compute:zy *tmp86 :compute:cy                        ...
  725:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  726:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  727:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  728:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  729:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  730:  op mul *tmp82 :compute:zy :compute:zy                        ...
  731:  op sub *tmp83 *tmp81 *tmp82                                  ...
  732:  op add :compute:zx *tmp83 :compute:cx                        ...
  733:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  734:  op mul *tmp86 *tmp85 :compute:zy                             ...
  735:  op add :compute:zy *tmp86 :compute:cy                        ...
  736:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  737:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  738:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  739:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  740:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  741:  op mul *tmp82 :compute:zy :compute:zy                        ...
  742:  op sub *tmp83 *tmp81 *tmp82                                  ...
  743:  op add :compute:zx *tmp83 :compute:cx                        ...
  744:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  745:  op mul *tmp86 *tmp85 :compute:zy                             ...
  746:  op add :compute:zy *tmp86 :compute:cy                        ...
  747:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  748:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  749:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  750:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  751:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  752:  op mul *tmp82 :compute:zy :compute:zy                        ...
  753:  op sub *tmp83 *tmp81 *tmp82                                  ...
  754:  op add :compute:zx *tmp83 :compute:cx                        ...
  755:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  756:  op mul *tmp86 *tmp85 :compute:zy                             ...
  757:  op add :compute:zy *tmp86 :compute:cy                        ...
  758:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  759:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  760:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  761:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  762:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  763:  op mul *tmp82 :compute:zy :compute:zy                        ...
  764:  op sub *tmp83 *tmp81 *tmp82                                  ...
  765:  op add :compute:zx *tmp83 :compute:cx                        ...
  766:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  767:  op mul *tmp86 *tmp85 :compute:zy                             ...
  768:  op add :compute:zy *tmp86 :compute:cy                        ...
  769:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  770:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  771:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  772:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  773:  op mul *tmp81 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  774:  op mul *tmp82 :compute:zy :compute:zy                        ...
  775:  op sub *tmp83 *tmp81 *tmp82                                  ...
  776:  op add :compute:zx *tmp83 :compute:cx                        ...
  777:  op mul *tmp85 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  778:  op mul *tmp86 *tmp85 :compute:zy                             ...
  779:  op add :compute:zy *tmp86 :compute:cy                        ...
  780:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  781:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  782:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label63                                               ...
  783:  jump *label66 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  784:  jump *label66 greaterThanEq :compute:i 63                    ...
  785:  op log *tmp93 :compute:dist 0                                mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  786:  op mul *tmp94 *tmp93 0.36067376022224085                     ...
  787:  op log *tmp95 *tmp94 0                                       ...
  788:  op mul *tmp96 *tmp95 1.4426950408889634                      ...
  789:  op sub :compute:correction 4 *tmp96                          ...
  790:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label66                                               mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  791:  set *tmp63 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label54                                               mandelbrot-compute.mnd: var iterations = compute(x, y + i);
  792:  jump *label71 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH then
  793:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  794:  jump *label72 equal *tmp63 63                                mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  795:  multijump .PALETTE 0 0                                       mandelbrot-compute.mnd: case PALETTE
        multilabel *label165                                         ...
        multilabel *label161                                         ...
  796:  op div *tmp138 *tmp63 63.75                                  mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  797:  op sub :drawPixel:r 1 *tmp138                                ...
  798:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  799:  jump *label72 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label162                                         ...
  800:  op sub *tmp103 32 *tmp63                                     mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  801:  op abs *tmp104 *tmp103 0                                     ...
  802:  op div *tmp106 *tmp104 36.42857142857143                     ...
  803:  op sub :drawPixel:r 1 *tmp106                                ...
  804:  op sub *tmp108 *tmp63 32                                     mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  805:  op abs *tmp109 *tmp108 0                                     ...
  806:  op div *tmp111 *tmp109 42.5                                  ...
  807:  op sub :drawPixel:g 0.9411764705882353 *tmp111               ...
  808:  op div *tmp116 *tmp104 63.75                                 mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  809:  op add :drawPixel:b 0.47058823529411764 *tmp116              ...
  810:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  811:  jump *label72 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label163                                         ...
  812:  op div *tmp120 *tmp63 0.175                                  mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  813:  op sin :drawPixel:r *tmp120 0                                ...
  814:  op cos :drawPixel:g *tmp120 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  815:  op sub *tmp125 *tmp63 32                                     mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  816:  op abs *tmp126 *tmp125 0                                     ...
  817:  op div *tmp128 *tmp126 63.75                                 ...
  818:  op add :drawPixel:b 0.39215686274509803 *tmp128              ...
  819:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  820:  jump *label72 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label164                                         ...
  821:  op div :drawPixel:r *tmp63 63.75                             mandelbrot-compute.mnd: r = 4 * iterations / 255;
  822:  op div *tmp134 *tmp63 170                                    mandelbrot-compute.mnd: g = 96 + 1.5 * iterations / 255;
  823:  op add :drawPixel:g 96 *tmp134                               ...
  824:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  825:  jump *label72 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label71                                               ...
  826:  read :drawPixel:color .memory *tmp63                         mandelbrot-compute.mnd: color = memory[iterations];
        label *label72                                               mandelbrot-compute.mnd: if SMOOTH then
  827:  jump *label82 lessThan .localBuffer 254                      mandelbrot-compute.mnd: if localBuffer >= 254 then
  828:  jump *label93 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: while localBuffer > 0 do
        label *label116                                              ...
  829:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  830:  sensor *tmp147 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled then
  831:  jump *label89 equal *tmp147 false                            ...
  832:  sensor *tmp149 .display @bufferSize                          mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  833:  op sub *tmp150 1024 *tmp149                                  ...
  834:  jump *label91 greaterThanEq .localBuffer *tmp150             ...
  835:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  836:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label91                                               mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label89                                               mandelbrot-compute.mnd: if display.@enabled then
  837:  jump *label116 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 do
        label *label82                                               mandelbrot-compute.mnd: if localBuffer >= 254 then
  838:  jump *label93 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  839:  jump *label93 strictNotEqual :drawPixel:color .lastColor     ...
  840:  draw rect :x :y 1 1 0 0                                      mandelbrot-compute.mnd: rect(x, y, 1, 1);
  841:  op add .localBuffer .localBuffer 1                           mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  842:  jump *label94 always 0 0                                     ...
        label *label93                                               ...
  843:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  844:  draw rect :x :y 1 1 0 0                                      mandelbrot-compute.mnd: rect(x, y, 1, 1);
  845:  set .lastColor :drawPixel:color                              mandelbrot-compute.mnd: lastColor = color;
  846:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
        label *label94                                               mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  847:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  848:  sensor *tmp157 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled then
  849:  jump *label98 equal *tmp157 false                            ...
  850:  sensor *tmp159 .display @bufferSize                          mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  851:  op sub *tmp160 1024 *tmp159                                  ...
  852:  jump *label100 greaterThanEq .localBuffer *tmp160            ...
  853:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  854:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label100                                              mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label98                                               mandelbrot-compute.mnd: if display.@enabled then
  855:  wait 0.002667                           # 0.160 ticks for at mandelbrot-compute.mnd: atomic $COMPLETED++; end;
  856:  read *tmp163 .memory 65                                      ...
  857:  op add *tmp1 *tmp163 1                                       ...
  858:  write *tmp1 .memory 65                  # The last atomic bl ...
  859:  read *tmp166 .memory 67                                      mandelbrot-compute.mnd: if stop != $STOP then
  860:  jump *label28 notEqual .stop *tmp166                         ...
  861:  op add :i :i 1                                               mandelbrot-compute.mnd: for var i in 0 ... BATCH do
  862:  jump *label114 lessThan :i 16                                ...
  863:  jump *label34 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: while localBuffer > 0 do
        label *label117                                              ...
  864:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  865:  sensor *tmp169 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled then
  866:  jump *label109 equal *tmp169 false                           ...
  867:  sensor *tmp171 .display @bufferSize                          mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  868:  op sub *tmp172 1024 *tmp171                                  ...
  869:  jump *label111 greaterThanEq .localBuffer *tmp172            ...
  870:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  871:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label111                                              mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label109                                              mandelbrot-compute.mnd: if display.@enabled then
  872:  jump *label117 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 do
  873:  jump *label34 always 0 0                                     mandelbrot-compute.mnd: while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   727     1x    727,0  inline def compute(in x, in y)
    53     1x     53,0  <no function>
    45     1x     45,0  inline void drawPixel(in x, in y, in iterations)
    24     3x      8,0  inline void flushLocalBuffer()
    22     1x     22,0  inline void findLinkedBlocks(in title, in message, in linkMap...)
     4     2x      2,0  inline void emptyLocalBuffer()
Runtime error at instruction #24: 'read *tmp24 .memory 66':
Execution step limit of 100,000 exceeded.

Performance: parsed in 314 ms, compiled in 301 ms, optimized in 1,574 ms, run in 92 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Display: large-logic-display
Memory: memory-bank
