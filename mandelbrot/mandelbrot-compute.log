   457 instructions before optimizations.
    50 instructions eliminated by Temp Variables Elimination (2 passes, 8 iterations).
     2 instructions eliminated by Case Expression Optimization.
    47 instructions eliminated by Dead Code Elimination (6 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 6 iterations).
    25 instructions eliminated by Condition Optimization (2 passes, 8 iterations).
    25 instructions eliminated by Single Step Elimination (2 passes, 8 iterations).
     1 instructions eliminated by Expression Optimization (2 passes, 4 iterations).
    18 instructions eliminated by Boolean Optimization (7 iterations).
       7 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by If Expression Optimization (4 iterations).
    28 instructions eliminated by Data Flow Optimization (3 passes, 13 iterations).
     1 loops improved by Loop Hoisting.
       4 loop conditions were partially rotated.
   743 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
    12 instructions eliminated by Case Switching (7 iterations).
     2 case expressions converted to fast dispatch by Case Switching.
    69 instructions eliminated by Jump Straightening (2 passes, 8 iterations).
     9 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
   918 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 738):
  * Fast-dispatch case at mandelbrot-compute.mnd:132:5           size   -11, benefit   242187.5, efficiency   Infinity (-10 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:221:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 748):
  * Fast-dispatch case at mandelbrot-compute.mnd:221:13          size    -2, benefit     3906.3, efficiency   Infinity (-2 instructions)

Pass 2: speed optimization selection (cost limit 758):
  * Unroll loop at mandelbrot-compute.mnd:193:5                  size  +679, benefit 49218750.0, efficiency  72487.113 (+743 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
    88 op add *tmp48 *tmp47 :i
    89 set :adam5:index *tmp48
    90 op idiv *tmp50 :adam5:index 16
-    * set *tmp51 *tmp50
-    * jump *label25 lessThan *tmp51 0
-    * jump *label24 lessThan *tmp51 121
+   91 jump *label25 lessThan *tmp50 0
+   92 jump *label24 lessThan *tmp50 121
    93 label *label25
    94 jump *label23 always
    95 label *label24
 
   110 set *tmp49 :adam5:dx
   111 jump *label22 always
   112 label *label23
-    * jump *label30 lessThan *tmp51 121
-    * jump *label29 lessThan *tmp51 242
+  113 jump *label30 lessThan *tmp50 121
+  114 jump *label29 lessThan *tmp50 242
   115 label *label30
   116 jump *label28 always
   117 label *label29
 
   140 set *tmp49 :adam5:dy
   141 jump *label22 always
   142 label *label28
-    * jump *label37 lessThan *tmp51 242
-    * jump *label36 lessThan *tmp51 484
+  143 jump *label37 lessThan *tmp50 242
+  144 jump *label36 lessThan *tmp50 484
   145 label *label37
   146 jump *label35 always
   147 label *label36
 
   164 set *tmp49 :adam5:dx
   165 jump *label22 always
   166 label *label35
-    * jump *label42 lessThan *tmp51 484
-    * jump *label41 lessThan *tmp51 968
+  167 jump *label42 lessThan *tmp50 484
+  168 jump *label41 lessThan *tmp50 968
   169 label *label42
   170 jump *label40 always
   171 label *label41
 
   346 set *tmp125 :drawPixel:color
   347 jump *label74 always
   348 label *label73
-    * set *tmp127 .PALETTE
-    * jump *label77 equal *tmp127 2
+  349 jump *label77 equal .PALETTE 2
   350 jump *label76 always
   351 label *label77
   352 op sub *tmp128 32 :drawPixel:iterations
 
   372 set *tmp126 :drawPixel:color
   373 jump *label75 always
   374 label *label76
-    * jump *label79 equal *tmp127 3
+  375 jump *label79 equal .PALETTE 3
   376 jump *label78 always
   377 label *label79
   378 op div *tmp144 :drawPixel:iterations 63
 
   394 set *tmp126 :drawPixel:color
   395 jump *label75 always
   396 label *label78
-    * jump *label81 equal *tmp127 4
+  397 jump *label81 equal .PALETTE 4
   398 jump *label80 always
   399 label *label81
   400 op mul *tmp156 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-38 instructions):
 
    61 op notEqual *tmp37 .stop *tmp38
    62 jump *label14 equal *tmp37 false
    63 jump *label4 always
-    * set *tmp39 null
    64 jump *label15 always
    65 label *label14
-    * set *tmp39 null
    66 label *label15
    67 read *tmp40 .memory 64
    68 set :batch *tmp40
 
    72 op greaterThanEq *tmp43 :batch 2816
    73 jump *label16 equal *tmp43 false
    74 jump *label13 always
-    * set *tmp44 null
    75 jump *label17 always
    76 label *label16
-    * set *tmp44 null
    77 label *label17
    78 op mul *tmp45 11 :multiple
    79 set *tmp46 *tmp45
 
   103 label *label27
   104 set :adam5:dy *tmp56
   105 set :adam5:dx :adam5:dy
-    * set *tmp49 :adam5:dx
   106 jump *label22 always
   107 label *label23
   108 jump *label30 lessThan *tmp50 121
 
   132 set *tmp63 2
   133 label *label34
   134 set :adam5:dy *tmp63
-    * set *tmp49 :adam5:dy
   135 jump *label22 always
   136 label *label28
   137 jump *label37 lessThan *tmp50 242
 
   155 label *label39
   156 set :adam5:dy *tmp69
   157 set :adam5:dx :adam5:dy
-    * set *tmp49 :adam5:dx
   158 jump *label22 always
   159 label *label35
   160 jump *label42 lessThan *tmp50 484
 
   178 set *tmp75 1
   179 label *label44
   180 set :adam5:dy *tmp75
-    * set *tmp49 :adam5:dy
   181 jump *label22 always
   182 label *label40
   183 op sub :adam5:index :adam5:index 15488
 
   189 set :adam5:y *tmp79
   190 set :adam5:dy 1
   191 set :adam5:dx :adam5:dy
-    * set *tmp49 :adam5:dx
   192 label *label22
   193 label *label21
   194 set :x :adam5:x
 
   218 label *label52
   219 drawflush .display
   220 set .localBuffer 0
-    * set *tmp87 .localBuffer
   221 jump *label51 always
   222 label *label50
-    * set *tmp87 null
   223 label *label51
   224 label *label49
-    * set *tmp82 null
   225 jump *label46 always
   226 label *label45
-    * set *tmp82 null
   227 label *label46
   228 set :compute:x :x
   229 set :compute:y :y
 
   236 jump *label55 equal .JULIA false
   237 set :compute:cx .JULIA_X
   238 set :compute:cy .JULIA_Y
-    * set *tmp93 :compute:cy
   239 jump *label56 always
   240 label *label55
   241 set :compute:cx :compute:zx
 
   251 jump *label57 equal *tmp100 false
   252 set *tmp88 63
   253 jump *label54 always
-    * set *tmp101 null
   254 jump *label58 always
   255 label *label57
-    * set *tmp101 null
   256 label *label58
   257 op add *tmp102 :compute:cx 1
   258 op len *tmp103 *tmp102 :compute:cy
 
   265 label *label59
   266 set *tmp105 null
   267 label *label60
-    * set *tmp93 *tmp105
   268 label *label56
   269 set :compute:i 0
   270 label *label61
 
   285 op greaterThanEq *tmp114 :compute:dist 64
   286 jump *label64 equal *tmp114 false
   287 jump *label63 always
-    * set *tmp115 null
   288 jump *label65 always
   289 label *label64
-    * set *tmp115 null
   290 label *label65
   291 label *label62
   292 op add :compute:i :compute:i 1
 
   305 op sub *tmp122 4 *tmp121
   306 set :compute:correction *tmp122
   307 op add :compute:i :compute:i :compute:correction
-    * set *tmp117 :compute:i
   308 jump *label67 always
   309 label *label66
-    * set *tmp117 null
   310 label *label67
   311 set *tmp88 :compute:i
   312 jump *label54 always
 
   397 label *label75
   398 set *tmp125 *tmp126
   399 label *label74
-    * set *tmp123 *tmp125
   400 jump *label72 always
   401 label *label71
   402 set *tmp165 :drawPixel:iterations
   403 read *tmp167 .memory *tmp165
   404 set :drawPixel:color *tmp167
-    * set *tmp123 :drawPixel:color
   405 label *label72
   406 op greaterThanEq *tmp168 .localBuffer 254
   407 jump *label82 equal *tmp168 false
 
   426 label *label93
   427 drawflush .display
   428 set .localBuffer 0
-    * set *tmp177 .localBuffer
   429 jump *label92 always
   430 label *label91
-    * set *tmp177 null
   431 label *label92
   432 label *label90
   433 label *label86
   434 jump *label85 always
   435 label *label87
   436 label *label84
-    * set *tmp169 null
   437 jump *label83 always
   438 label *label82
-    * set *tmp169 null
   439 label *label83
   440 op greaterThan *tmp178 .localBuffer 0
   441 jump *label95 equal *tmp178 false
 
   447 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   448 set *tmp181 .localBuffer
   449 op add .localBuffer .localBuffer 1
-    * set *tmp180 *tmp181
   450 jump *label96 always
   451 label *label95
   452 draw col :drawPixel:color
   453 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   454 set .lastColor :drawPixel:color
   455 op add .localBuffer .localBuffer 2
-    * set *tmp180 .localBuffer
   456 label *label96
   457 wait 0
   458 sensor *tmp182 .display @enabled
 
   466 label *label102
   467 drawflush .display
   468 set .localBuffer 0
-    * set *tmp186 .localBuffer
   469 jump *label101 always
   470 label *label100
-    * set *tmp186 null
   471 label *label101
   472 label *label99
   473 label *label70
 
   476 op notEqual *tmp187 .stop *tmp188
   477 jump *label104 equal *tmp187 false
   478 jump *label4 always
-    * set *tmp189 null
   479 jump *label105 always
   480 label *label104
-    * set *tmp189 null
   481 label *label105
   482 read *tmp190 .memory 66
-    * set *tmp191 *tmp190
   483 op add *tmp2 *tmp190 1
   484 write *tmp2 .memory 66
   485 read *tmp192 .memory 65
 
   492 op greaterThanEq *tmp194 :batch 1337.6
   493 jump *label106 equal *tmp194 false
   494 set :multiple 1
-    * set *tmp195 :multiple
   495 jump *label107 always
   496 label *label106
-    * set *tmp195 null
   497 label *label107
   498 label *label12
   499 jump *label11 always
 
   519 label *label117
   520 drawflush .display
   521 set .localBuffer 0
-    * set *tmp203 .localBuffer
   522 jump *label116 always
   523 label *label115
-    * set *tmp203 null
   524 label *label116
   525 label *label114
   526 label *label110

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
   260 jump *label59 equal *tmp104 false
   261 set *tmp88 63
   262 jump *label54 always
-    * set *tmp105 null
   263 jump *label60 always
   264 label *label59
-    * set *tmp105 null
   265 label *label60
   266 label *label56
   267 set :compute:i 0
 
   320 op equal *tmp124 :drawPixel:iterations 63
   321 jump *label73 equal *tmp124 false
   322 set :drawPixel:color %[black]
-    * set *tmp125 :drawPixel:color
   323 jump *label74 always
   324 label *label73
   325 jump *label77 equal .PALETTE 2
 
   392 set :drawPixel:color *tmp164
   393 set *tmp126 :drawPixel:color
   394 label *label75
-    * set *tmp125 *tmp126
   395 label *label74
   396 jump *label72 always
   397 label *label71
 
   441 jump *label97 always
   442 label *label97
   443 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
-    * set *tmp181 .localBuffer
   444 op add .localBuffer .localBuffer 1
   445 jump *label96 always
   446 label *label95

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   345 set :drawPixel:b *tmp142
   346 packcolor *tmp143 :drawPixel:r :drawPixel:g :drawPixel:b 1
   347 set :drawPixel:color *tmp143
-    * set *tmp126 :drawPixel:color
   348 jump *label75 always
   349 label *label76
   350 jump *label79 equal .PALETTE 3
 
   366 set :drawPixel:b *tmp154
   367 packcolor *tmp155 :drawPixel:r :drawPixel:g :drawPixel:b 1
   368 set :drawPixel:color *tmp155
-    * set *tmp126 :drawPixel:color
   369 jump *label75 always
   370 label *label78
   371 jump *label81 equal .PALETTE 4
 
   379 set :drawPixel:g *tmp159
   380 packcolor *tmp160 :drawPixel:r :drawPixel:g 0 1
   381 set :drawPixel:color *tmp160
-    * set *tmp126 :drawPixel:color
   382 jump *label75 always
   383 label *label80
   384 op mul *tmp161 4 :drawPixel:iterations
 
   387 set :drawPixel:r *tmp163
   388 packcolor *tmp164 :drawPixel:r :drawPixel:r 0 1
   389 set :drawPixel:color *tmp164
-    * set *tmp126 :drawPixel:color
   390 label *label75
   391 label *label74
   392 jump *label72 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-47 instructions):
 
    14 op equal *tmp17 .start *tmp18
    15 jump *label6 notEqual *tmp17 false
    16 label *label8
-    * read *tmp19 .memory 67
-    * set .start *tmp19
-    * read *tmp20 .memory 68
-    * set .stop *tmp20
+   17 read .start .memory 67
+   18 read .stop .memory 68
    19 set .lastColor -1
    20 set .localBuffer 0
    21 drawflush null
    22 drawflush .display
-    * read *tmp21 .memory 71
-    * set .ZOOM *tmp21
+   23 read .ZOOM .memory 71
    24 op div *tmp22 -88 .ZOOM
    25 read *tmp24 .memory 69
-    * op add *tmp23 *tmp22 *tmp24
-    * set .OFFSET_X *tmp23
+   26 op add .OFFSET_X *tmp22 *tmp24
    27 op div *tmp25 -88 .ZOOM
    28 read *tmp27 .memory 70
-    * op add *tmp26 *tmp25 *tmp27
-    * set .OFFSET_Y *tmp26
-    * read *tmp28 .memory 72
-    * set .JULIA *tmp28
-    * read *tmp29 .memory 73
-    * set .JULIA_X *tmp29
-    * read *tmp30 .memory 74
-    * set .JULIA_Y *tmp30
-    * read *tmp31 .memory 75
-    * set .PALETTE *tmp31
-    * op greaterThan *tmp32 .PALETTE 1
-    * set .SMOOTH *tmp32
-    * read *tmp33 .memory 76
-    * set .ALL_PASS_COLORING *tmp33
+   29 op add .OFFSET_Y *tmp25 *tmp27
+   30 read .JULIA .memory 72
+   31 read .JULIA_X .memory 73
+   32 read .JULIA_Y .memory 74
+   33 read .PALETTE .memory 75
+   34 op greaterThan .SMOOTH .PALETTE 1
+   35 read .ALL_PASS_COLORING .memory 76
    36 read *tmp34 .memory 77
    37 jump *label9 equal *tmp34 false
-    * op sub *tmp36 1 .ALL_PASS_COLORING
-    * set *tmp35 *tmp36
+   38 op sub *tmp35 1 .ALL_PASS_COLORING
    39 jump *label10 always
    40 label *label9
    41 set *tmp35 99
 
    52 jump *label15 always
    53 label *label14
    54 label *label15
-    * read *tmp40 .memory 64
-    * set :batch *tmp40
+   55 read :batch .memory 64
    56 read *tmp41 .memory 64
    57 op add *tmp42 *tmp41 :multiple
    58 write *tmp42 .memory 64
 
    62 jump *label17 always
    63 label *label16
    64 label *label17
-    * op mul *tmp45 11 :multiple
-    * set *tmp46 *tmp45
+   65 op mul *tmp46 11 :multiple
    66 set :i 0
    67 label *label18
    68 jump *label20 greaterThanEq :i *tmp46
    69 op mul *tmp47 :batch 11
-    * op add *tmp48 *tmp47 :i
-    * set :adam5:index *tmp48
+   70 op add :adam5:index *tmp47 :i
    71 op idiv *tmp50 :adam5:index 16
    72 jump *label25 lessThan *tmp50 0
    73 jump *label24 lessThan *tmp50 121
 
    75 jump *label23 always
    76 label *label24
    77 op mod *tmp52 :adam5:index 44
-    * op mul *tmp53 4 *tmp52
-    * set :adam5:x *tmp53
+   78 op mul :adam5:x 4 *tmp52
    79 op idiv *tmp54 :adam5:index 44
-    * op mul *tmp55 4 *tmp54
-    * set :adam5:y *tmp55
+   80 op mul :adam5:y 4 *tmp54
    81 jump *label26 equal .ALL_PASS_COLORING false
    82 set *tmp56 4
    83 jump *label27 always
 
    96 op sub :adam5:index :adam5:index 1936
    97 op mod *tmp57 :adam5:index 44
    98 op mul *tmp58 4 *tmp57
-    * op add *tmp59 *tmp58 2
-    * set :adam5:x *tmp59
+   99 op add :adam5:x *tmp58 2
   100 op idiv *tmp60 :adam5:index 44
-    * op mul *tmp61 4 *tmp60
-    * set :adam5:y *tmp61
+  101 op mul :adam5:y 4 *tmp60
   102 jump *label31 equal .ALL_PASS_COLORING false
   103 set *tmp62 2
   104 jump *label32 always
 
   122 label *label36
   123 op sub :adam5:index :adam5:index 3872
   124 op mod *tmp64 :adam5:index 88
-    * op mul *tmp65 2 *tmp64
-    * set :adam5:x *tmp65
+  125 op mul :adam5:x 2 *tmp64
   126 op idiv *tmp66 :adam5:index 88
   127 op mul *tmp67 4 *tmp66
-    * op add *tmp68 *tmp67 2
-    * set :adam5:y *tmp68
+  128 op add :adam5:y *tmp67 2
   129 jump *label38 equal .ALL_PASS_COLORING false
   130 set *tmp69 2
   131 jump *label39 always
 
   144 op sub :adam5:index :adam5:index 7744
   145 op mod *tmp70 :adam5:index 88
   146 op mul *tmp71 2 *tmp70
-    * op add *tmp72 *tmp71 1
-    * set :adam5:x *tmp72
+  147 op add :adam5:x *tmp71 1
   148 op idiv *tmp73 :adam5:index 88
-    * op mul *tmp74 2 *tmp73
-    * set :adam5:y *tmp74
+  149 op mul :adam5:y 2 *tmp73
   150 set :adam5:dx 1
   151 jump *label43 equal .ALL_PASS_COLORING false
   152 set *tmp75 2
 
   158 jump *label22 always
   159 label *label40
   160 op sub :adam5:index :adam5:index 15488
-    * op mod *tmp76 :adam5:index 176
-    * set :adam5:x *tmp76
+  161 op mod :adam5:x :adam5:index 176
   162 op idiv *tmp77 :adam5:index 176
   163 op mul *tmp78 2 *tmp77
-    * op add *tmp79 *tmp78 1
-    * set :adam5:y *tmp79
+  164 op add :adam5:y *tmp78 1
   165 set :adam5:dy 1
   166 set :adam5:dx :adam5:dy
   167 label *label22
 
   203 set :compute:x :x
   204 set :compute:y :y
   205 op div *tmp89 :compute:x .ZOOM
-    * op add *tmp90 *tmp89 .OFFSET_X
-    * set :compute:zx *tmp90
+  206 op add :compute:zx *tmp89 .OFFSET_X
   207 op div *tmp91 :compute:y .ZOOM
-    * op add *tmp92 *tmp91 .OFFSET_Y
-    * set :compute:zy *tmp92
+  208 op add :compute:zy *tmp91 .OFFSET_Y
   209 jump *label55 equal .JULIA false
   210 set :compute:cx .JULIA_X
   211 set :compute:cy .JULIA_Y
 
   214 set :compute:cx :compute:zx
   215 set :compute:cy :compute:zy
   216 op sub *tmp94 :compute:cx 0.25
-    * op len *tmp95 *tmp94 :compute:cy
-    * set :compute:p *tmp95
+  217 op len :compute:p *tmp94 :compute:cy
   218 op mul *tmp96 2 :compute:p
   219 op mul *tmp97 *tmp96 :compute:p
   220 op sub *tmp98 :compute:p *tmp97
 
   244 op mul *tmp106 :compute:x1 :compute:x1
   245 op mul *tmp107 :compute:y1 :compute:y1
   246 op sub *tmp108 *tmp106 *tmp107
-    * op add *tmp109 *tmp108 :compute:cx
-    * set :compute:zx *tmp109
+  247 op add :compute:zx *tmp108 :compute:cx
   248 op mul *tmp110 2 :compute:x1
   249 op mul *tmp111 *tmp110 :compute:y1
-    * op add *tmp112 *tmp111 :compute:cy
-    * set :compute:zy *tmp112
-    * op len *tmp113 :compute:zx :compute:zy
-    * set :compute:dist *tmp113
+  250 op add :compute:zy *tmp111 :compute:cy
+  251 op len :compute:dist :compute:zx :compute:zy
   252 op greaterThanEq *tmp114 :compute:dist 64
   253 jump *label64 equal *tmp114 false
   254 jump *label63 always
 
   269 op mul *tmp119 *tmp118 0.36067376022224085
   270 op log *tmp120 *tmp119
   271 op mul *tmp121 *tmp120 1.4426950408889634
-    * op sub *tmp122 4 *tmp121
-    * set :compute:correction *tmp122
+  272 op sub :compute:correction 4 *tmp121
   273 op add :compute:i :compute:i :compute:correction
   274 jump *label67 always
   275 label *label66
 
   297 op abs *tmp129 *tmp128
   298 op mul *tmp130 7 *tmp129
   299 op div *tmp131 *tmp130 255
-    * op sub *tmp132 1 *tmp131
-    * set :drawPixel:r *tmp132
+  300 op sub :drawPixel:r 1 *tmp131
   301 op sub *tmp133 :drawPixel:iterations 32
   302 op abs *tmp134 *tmp133
   303 op mul *tmp135 6 *tmp134
   304 op div *tmp136 *tmp135 255
-    * op sub *tmp137 0.9411764705882353 *tmp136
-    * set :drawPixel:g *tmp137
+  305 op sub :drawPixel:g 0.9411764705882353 *tmp136
   306 op sub *tmp138 32 :drawPixel:iterations
   307 op abs *tmp139 *tmp138
   308 op mul *tmp140 4 *tmp139
   309 op div *tmp141 *tmp140 255
-    * op add *tmp142 0.47058823529411764 *tmp141
-    * set :drawPixel:b *tmp142
-    * packcolor *tmp143 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp143
+  310 op add :drawPixel:b 0.47058823529411764 *tmp141
+  311 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   312 jump *label75 always
   313 label *label76
   314 jump *label79 equal .PALETTE 3
 
   316 label *label79
   317 op div *tmp144 :drawPixel:iterations 63
   318 op mul *tmp145 *tmp144 360
-    * op sin *tmp146 *tmp145
-    * set :drawPixel:r *tmp146
+  319 op sin :drawPixel:r *tmp145
   320 op div *tmp147 :drawPixel:iterations 63
   321 op mul *tmp148 *tmp147 360
-    * op cos *tmp149 *tmp148
-    * set :drawPixel:g *tmp149
+  322 op cos :drawPixel:g *tmp148
   323 op sub *tmp150 :drawPixel:iterations 32
   324 op abs *tmp151 *tmp150
   325 op mul *tmp152 4 *tmp151
   326 op div *tmp153 *tmp152 255
-    * op add *tmp154 0.39215686274509803 *tmp153
-    * set :drawPixel:b *tmp154
-    * packcolor *tmp155 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp155
+  327 op add :drawPixel:b 0.39215686274509803 *tmp153
+  328 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   329 jump *label75 always
   330 label *label78
   331 jump *label81 equal .PALETTE 4
   332 jump *label80 always
   333 label *label81
   334 op mul *tmp156 4 :drawPixel:iterations
-    * op div *tmp157 *tmp156 255
-    * set :drawPixel:r *tmp157
+  335 op div :drawPixel:r *tmp156 255
   336 op mul *tmp158 1.5 :drawPixel:iterations
-    * op div *tmp159 *tmp158 255
-    * set :drawPixel:g *tmp159
-    * packcolor *tmp160 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp160
+  337 op div :drawPixel:g *tmp158 255
+  338 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   339 jump *label75 always
   340 label *label80
   341 op mul *tmp161 4 :drawPixel:iterations
   342 op div *tmp162 *tmp161 255
-    * op sub *tmp163 1 *tmp162
-    * set :drawPixel:r *tmp163
-    * packcolor *tmp164 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp164
+  343 op sub :drawPixel:r 1 *tmp162
+  344 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   345 label *label75
   346 label *label74
   347 jump *label72 always
   348 label *label71
-    * set *tmp165 :drawPixel:iterations
-    * read *tmp167 .memory *tmp165
-    * set :drawPixel:color *tmp167
+  349 read :drawPixel:color .memory :drawPixel:iterations
   350 label *label72
   351 op greaterThanEq *tmp168 .localBuffer 254
   352 jump *label82 equal *tmp168 false

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
     6 jump *label0 notEqual *tmp16 false
     7 label *label2
     8 label *label3
-    * jump *label5 equal true false
     9 label *label6
    10 wait 0
    11 label *label7
 
    42 set :leaderLimit *tmp35
    43 set :multiple 4
    44 label *label11
-    * jump *label13 equal true false
    45 wait 0
    46 read *tmp38 .memory 68
    47 op notEqual *tmp37 .stop *tmp38

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   288 set :drawPixel:color %[black]
   289 jump *label74 always
   290 label *label73
-    * jump *label77 equal .PALETTE 2
-    * jump *label76 always
+  291 jump *label76 notEqual .PALETTE 2
   292 label *label77
   293 op sub *tmp128 32 :drawPixel:iterations
   294 op abs *tmp129 *tmp128
 
   308 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   309 jump *label75 always
   310 label *label76
-    * jump *label79 equal .PALETTE 3
-    * jump *label78 always
+  311 jump *label78 notEqual .PALETTE 3
   312 label *label79
   313 op div *tmp144 :drawPixel:iterations 63
   314 op mul *tmp145 *tmp144 360
 
   324 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   325 jump *label75 always
   326 label *label78
-    * jump *label81 equal .PALETTE 4
-    * jump *label80 always
+  327 jump *label80 notEqual .PALETTE 4
   328 label *label81
   329 op mul *tmp156 4 :drawPixel:iterations
   330 op div :drawPixel:r *tmp156 255

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-23 instructions):
 
    10 wait 0
    11 label *label7
    12 read *tmp18 .memory 67
-    * op equal *tmp17 .start *tmp18
-    * jump *label6 notEqual *tmp17 false
+   13 jump *label6 equal .start *tmp18
    14 label *label8
    15 read .start .memory 67
    16 read .stop .memory 68
 
    43 label *label11
    44 wait 0
    45 read *tmp38 .memory 68
-    * op notEqual *tmp37 .stop *tmp38
-    * jump *label14 equal *tmp37 false
+   46 jump *label14 equal .stop *tmp38
    47 jump *label4 always
    48 jump *label15 always
    49 label *label14
 
    52 read *tmp41 .memory 64
    53 op add *tmp42 *tmp41 :multiple
    54 write *tmp42 .memory 64
-    * op greaterThanEq *tmp43 :batch 2816
-    * jump *label16 equal *tmp43 false
+   55 jump *label16 lessThan :batch 2816
    56 jump *label13 always
    57 jump *label17 always
    58 label *label16
 
   165 set :y :adam5:y
   166 set :dx :adam5:dx
   167 set :dy :adam5:dy
-    * op greaterThan *tmp80 :multiple :leaderLimit
-    * jump *label45 equal *tmp80 false
+  168 jump *label45 lessThanEq :multiple :leaderLimit
   169 label *label48
-    * op equal *tmp81 .localBuffer 0
-    * jump *label45 equal *tmp81 false
+  170 jump *label45 notEqual .localBuffer 0
   171 jump *label47 always
   172 label *label47
   173 draw col %[white]
 
   180 label *label53
   181 sensor *tmp84 .display @bufferSize
   182 op sub *tmp85 1024 *tmp84
-    * op lessThan *tmp86 .localBuffer *tmp85
-    * jump *label50 equal *tmp86 false
+  183 jump *label50 greaterThanEq .localBuffer *tmp85
   184 jump *label52 always
   185 label *label52
   186 drawflush .display
 
   211 op mul *tmp97 *tmp96 :compute:p
   212 op sub *tmp98 :compute:p *tmp97
   213 op add *tmp99 *tmp98 0.25
-    * op lessThanEq *tmp100 :compute:cx *tmp99
-    * jump *label57 equal *tmp100 false
+  214 jump *label57 greaterThan :compute:cx *tmp99
   215 set *tmp88 63
   216 jump *label54 always
   217 jump *label58 always
 
   219 label *label58
   220 op add *tmp102 :compute:cx 1
   221 op len *tmp103 *tmp102 :compute:cy
-    * op lessThanEq *tmp104 *tmp103 0.25
-    * jump *label59 equal *tmp104 false
+  222 jump *label59 greaterThan *tmp103 0.25
   223 set *tmp88 63
   224 jump *label54 always
   225 jump *label60 always
 
   239 op mul *tmp111 *tmp110 :compute:y1
   240 op add :compute:zy *tmp111 :compute:cy
   241 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp114 :compute:dist 64
-    * jump *label64 equal *tmp114 false
+  242 jump *label64 lessThan :compute:dist 64
   243 jump *label63 always
   244 jump *label65 always
   245 label *label64
 
   250 label *label63
   251 jump *label66 equal .SMOOTH false
   252 label *label69
-    * op lessThan *tmp116 :compute:i 63
-    * jump *label66 equal *tmp116 false
+  253 jump *label66 greaterThanEq :compute:i 63
   254 jump *label68 always
   255 label *label68
   256 op log *tmp118 :compute:dist
 
   273 set :drawPixel:dy :dy
   274 set :drawPixel:iterations :iterations
   275 jump *label71 equal .SMOOTH false
-    * op equal *tmp124 :drawPixel:iterations 63
-    * jump *label73 equal *tmp124 false
+  276 jump *label73 notEqual :drawPixel:iterations 63
   277 set :drawPixel:color %[black]
   278 jump *label74 always
   279 label *label73
 
   332 label *label71
   333 read :drawPixel:color .memory :drawPixel:iterations
   334 label *label72
-    * op greaterThanEq *tmp168 .localBuffer 254
-    * jump *label82 equal *tmp168 false
+  335 jump *label82 lessThan .localBuffer 254
   336 label *label85
-    * op greaterThan *tmp170 .localBuffer 0
-    * jump *label87 equal *tmp170 false
+  337 jump *label87 lessThanEq .localBuffer 0
   338 label *label89
   339 read *tmp172 .memory 68
-    * op equal *tmp171 .stop *tmp172
-    * jump *label87 equal *tmp171 false
+  340 jump *label87 notEqual .stop *tmp172
   341 jump *label88 always
   342 label *label88
   343 wait 0
 
   346 label *label94
   347 sensor *tmp174 .display @bufferSize
   348 op sub *tmp175 1024 *tmp174
-    * op lessThan *tmp176 .localBuffer *tmp175
-    * jump *label91 equal *tmp176 false
+  349 jump *label91 greaterThanEq .localBuffer *tmp175
   350 jump *label93 always
   351 label *label93
   352 drawflush .display
 
   362 jump *label83 always
   363 label *label82
   364 label *label83
-    * op greaterThan *tmp178 .localBuffer 0
-    * jump *label95 equal *tmp178 false
+  365 jump *label95 lessThanEq .localBuffer 0
   366 label *label98
-    * op strictEqual *tmp179 :drawPixel:color .lastColor
-    * jump *label95 equal *tmp179 false
+  367 jump *label95 strictNotEqual :drawPixel:color .lastColor
   368 jump *label97 always
   369 label *label97
   370 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
 
   382 label *label103
   383 sensor *tmp183 .display @bufferSize
   384 op sub *tmp184 1024 *tmp183
-    * op lessThan *tmp185 .localBuffer *tmp184
-    * jump *label100 equal *tmp185 false
+  385 jump *label100 greaterThanEq .localBuffer *tmp184
   386 jump *label102 always
   387 label *label102
   388 drawflush .display
 
   394 label *label70
   395 wait 0
   396 read *tmp188 .memory 68
-    * op notEqual *tmp187 .stop *tmp188
-    * jump *label104 equal *tmp187 false
+  397 jump *label104 equal .stop *tmp188
   398 jump *label4 always
   399 jump *label105 always
   400 label *label104
 
   409 op add :i :i 1
   410 jump *label18 always
   411 label *label20
-    * op greaterThanEq *tmp194 :batch 1337.6
-    * jump *label106 equal *tmp194 false
+  412 jump *label106 lessThan :batch 1337.6
   413 set :multiple 1
   414 jump *label107 always
   415 label *label106
 
   418 jump *label11 always
   419 label *label13
   420 label *label109
-    * op greaterThan *tmp196 .localBuffer 0
-    * jump *label111 equal *tmp196 false
+  421 jump *label111 lessThanEq .localBuffer 0
   422 label *label113
   423 read *tmp198 .memory 68
-    * op equal *tmp197 .stop *tmp198
-    * jump *label111 equal *tmp197 false
+  424 jump *label111 notEqual .stop *tmp198
   425 jump *label112 always
   426 label *label112
   427 wait 0
 
   430 label *label118
   431 sensor *tmp200 .display @bufferSize
   432 op sub *tmp201 1024 *tmp200
-    * op lessThan *tmp202 .localBuffer *tmp201
-    * jump *label115 equal *tmp202 false
+  433 jump *label115 greaterThanEq .localBuffer *tmp201
   434 jump *label117 always
   435 label *label117
   436 drawflush .display

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-23 instructions):
 
    45 read *tmp38 .memory 68
    46 jump *label14 equal .stop *tmp38
    47 jump *label4 always
-    * jump *label15 always
    48 label *label14
    49 label *label15
    50 read :batch .memory 64
 
    53 write *tmp42 .memory 64
    54 jump *label16 lessThan :batch 2816
    55 jump *label13 always
-    * jump *label17 always
    56 label *label16
    57 label *label17
    58 op mul *tmp46 11 :multiple
 
   166 jump *label45 lessThanEq :multiple :leaderLimit
   167 label *label48
   168 jump *label45 notEqual .localBuffer 0
-    * jump *label47 always
   169 label *label47
   170 draw col %[white]
   171 draw rect :x :y :dx :dx
 
   178 sensor *tmp84 .display @bufferSize
   179 op sub *tmp85 1024 *tmp84
   180 jump *label50 greaterThanEq .localBuffer *tmp85
-    * jump *label52 always
   181 label *label52
   182 drawflush .display
   183 set .localBuffer 0
-    * jump *label51 always
   184 label *label50
   185 label *label51
   186 label *label49
-    * jump *label46 always
   187 label *label45
   188 label *label46
   189 set :compute:x :x
 
   208 jump *label57 greaterThan :compute:cx *tmp99
   209 set *tmp88 63
   210 jump *label54 always
-    * jump *label58 always
   211 label *label57
   212 label *label58
   213 op add *tmp102 :compute:cx 1
 
   215 jump *label59 greaterThan *tmp103 0.25
   216 set *tmp88 63
   217 jump *label54 always
-    * jump *label60 always
   218 label *label59
   219 label *label60
   220 label *label56
 
   233 op len :compute:dist :compute:zx :compute:zy
   234 jump *label64 lessThan :compute:dist 64
   235 jump *label63 always
-    * jump *label65 always
   236 label *label64
   237 label *label65
   238 label *label62
 
   242 jump *label66 equal .SMOOTH false
   243 label *label69
   244 jump *label66 greaterThanEq :compute:i 63
-    * jump *label68 always
   245 label *label68
   246 op log *tmp118 :compute:dist
   247 op mul *tmp119 *tmp118 0.36067376022224085
 
   249 op mul *tmp121 *tmp120 1.4426950408889634
   250 op sub :compute:correction 4 *tmp121
   251 op add :compute:i :compute:i :compute:correction
-    * jump *label67 always
   252 label *label66
   253 label *label67
   254 set *tmp88 :compute:i
 
   327 label *label89
   328 read *tmp172 .memory 68
   329 jump *label87 notEqual .stop *tmp172
-    * jump *label88 always
   330 label *label88
   331 wait 0
   332 sensor *tmp173 .display @enabled
 
   335 sensor *tmp174 .display @bufferSize
   336 op sub *tmp175 1024 *tmp174
   337 jump *label91 greaterThanEq .localBuffer *tmp175
-    * jump *label93 always
   338 label *label93
   339 drawflush .display
   340 set .localBuffer 0
-    * jump *label92 always
   341 label *label91
   342 label *label92
   343 label *label90
 
   345 jump *label85 always
   346 label *label87
   347 label *label84
-    * jump *label83 always
   348 label *label82
   349 label *label83
   350 jump *label95 lessThanEq .localBuffer 0
   351 label *label98
   352 jump *label95 strictNotEqual :drawPixel:color .lastColor
-    * jump *label97 always
   353 label *label97
   354 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   355 op add .localBuffer .localBuffer 1
 
   367 sensor *tmp183 .display @bufferSize
   368 op sub *tmp184 1024 *tmp183
   369 jump *label100 greaterThanEq .localBuffer *tmp184
-    * jump *label102 always
   370 label *label102
   371 drawflush .display
   372 set .localBuffer 0
-    * jump *label101 always
   373 label *label100
   374 label *label101
   375 label *label99
 
   378 read *tmp188 .memory 68
   379 jump *label104 equal .stop *tmp188
   380 jump *label4 always
-    * jump *label105 always
   381 label *label104
   382 label *label105
   383 read *tmp190 .memory 66
 
   392 label *label20
   393 jump *label106 lessThan :batch 1337.6
   394 set :multiple 1
-    * jump *label107 always
   395 label *label106
   396 label *label107
   397 label *label12
 
   402 label *label113
   403 read *tmp198 .memory 68
   404 jump *label111 notEqual .stop *tmp198
-    * jump *label112 always
   405 label *label112
   406 wait 0
   407 sensor *tmp199 .display @enabled
 
   410 sensor *tmp200 .display @bufferSize
   411 op sub *tmp201 1024 *tmp200
   412 jump *label115 greaterThanEq .localBuffer *tmp201
-    * jump *label117 always
   413 label *label117
   414 drawflush .display
   415 set .localBuffer 0
-    * jump *label116 always
   416 label *label115
   417 label *label116
   418 label *label114

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
     2 label *label1
     3 op equal *tmp14 .display null
     4 op equal *tmp15 .memory null
-    * op lor *tmp16 *tmp14 *tmp15
+    5 op or *tmp16 *tmp14 *tmp15
     6 jump *label0 notEqual *tmp16 false
     7 label *label2
     8 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    24 op add .OFFSET_X *tmp22 *tmp24
    25 op div *tmp25 -88 .ZOOM
    26 read *tmp27 .memory 70
-    * op add .OFFSET_Y *tmp25 *tmp27
+   27 op add .OFFSET_Y *tmp22 *tmp27
    28 read .JULIA .memory 72
    29 read .JULIA_X .memory 73
    30 read .JULIA_Y .memory 74
 
    78 set *tmp56 2
    79 label *label27
    80 set :adam5:dy *tmp56
-    * set :adam5:dx :adam5:dy
+   81 set :adam5:dx *tmp56
    82 jump *label22 always
    83 label *label23
    84 jump *label30 lessThan *tmp50 121
 
   126 set *tmp69 1
   127 label *label39
   128 set :adam5:dy *tmp69
-    * set :adam5:dx :adam5:dy
+  129 set :adam5:dx *tmp69
   130 jump *label22 always
   131 label *label35
   132 jump *label42 lessThan *tmp50 484
 
   156 op mul *tmp78 2 *tmp77
   157 op add :adam5:y *tmp78 1
   158 set :adam5:dy 1
-    * set :adam5:dx :adam5:dy
+  159 set :adam5:dx 1
   160 label *label22
   161 label *label21
   162 set :x :adam5:x
   163 set :y :adam5:y
   164 set :dx :adam5:dx
   165 set :dy :adam5:dy
-    * jump *label45 lessThanEq :multiple :leaderLimit
+  166 jump *label45 lessThanEq :multiple *tmp35
   167 label *label48
   168 jump *label45 notEqual .localBuffer 0
   169 label *label47
   170 draw col %[white]
-    * draw rect :x :y :dx :dx
+  171 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx
   172 set .lastColor %[white]
   173 set .localBuffer 2
   174 wait 0
 
   177 label *label53
   178 sensor *tmp84 .display @bufferSize
   179 op sub *tmp85 1024 *tmp84
-    * jump *label50 greaterThanEq .localBuffer *tmp85
+  180 jump *label50 greaterThanEq 2 *tmp85
   181 label *label52
   182 drawflush .display
   183 set .localBuffer 0
 
   186 label *label49
   187 label *label45
   188 label *label46
-    * set :compute:x :x
-    * set :compute:y :y
-    * op div *tmp89 :compute:x .ZOOM
+  189 set :compute:x :adam5:x
+  190 set :compute:y :adam5:y
+  191 op div *tmp89 :x .ZOOM
   192 op add :compute:zx *tmp89 .OFFSET_X
-    * op div *tmp91 :compute:y .ZOOM
+  193 op div *tmp91 :y .ZOOM
   194 op add :compute:zy *tmp91 .OFFSET_Y
   195 jump *label55 equal .JULIA false
   196 set :compute:cx .JULIA_X
 
   199 label *label55
   200 set :compute:cx :compute:zx
   201 set :compute:cy :compute:zy
-    * op sub *tmp94 :compute:cx 0.25
-    * op len :compute:p *tmp94 :compute:cy
+  202 op sub *tmp94 :compute:zx 0.25
+  203 op len :compute:p *tmp94 :compute:zy
   204 op mul *tmp96 2 :compute:p
   205 op mul *tmp97 *tmp96 :compute:p
   206 op sub *tmp98 :compute:p *tmp97
   207 op add *tmp99 *tmp98 0.25
-    * jump *label57 greaterThan :compute:cx *tmp99
+  208 jump *label57 greaterThan :compute:zx *tmp99
   209 set *tmp88 63
   210 jump *label54 always
   211 label *label57
   212 label *label58
-    * op add *tmp102 :compute:cx 1
-    * op len *tmp103 *tmp102 :compute:cy
+  213 op add *tmp102 :compute:zx 1
+  214 op len *tmp103 *tmp102 :compute:zy
   215 jump *label59 greaterThan *tmp103 0.25
   216 set *tmp88 63
   217 jump *label54 always
 
   223 jump *label63 greaterThanEq :compute:i 63
   224 set :compute:x1 :compute:zx
   225 set :compute:y1 :compute:zy
-    * op mul *tmp106 :compute:x1 :compute:x1
-    * op mul *tmp107 :compute:y1 :compute:y1
+  226 op mul *tmp106 :compute:zx :compute:zx
+  227 op mul *tmp107 :compute:zy :compute:zy
   228 op sub *tmp108 *tmp106 *tmp107
   229 op add :compute:zx *tmp108 :compute:cx
   230 op mul *tmp110 2 :compute:x1
-    * op mul *tmp111 *tmp110 :compute:y1
+  231 op mul *tmp111 *tmp110 :compute:zy
   232 op add :compute:zy *tmp111 :compute:cy
   233 op len :compute:dist :compute:zx :compute:zy
   234 jump *label64 lessThan :compute:dist 64
 
   253 label *label67
   254 set *tmp88 :compute:i
   255 jump *label54 always
-    * set *tmp88 null
   256 label *label54
   257 set :iterations *tmp88
-    * set :drawPixel:x :x
-    * set :drawPixel:y :y
-    * set :drawPixel:dx :dx
-    * set :drawPixel:dy :dy
-    * set :drawPixel:iterations :iterations
+  258 set :drawPixel:x :adam5:x
+  259 set :drawPixel:y :adam5:y
+  260 set :drawPixel:dx :adam5:dx
+  261 set :drawPixel:dy :adam5:dy
+  262 set :drawPixel:iterations *tmp88
   263 jump *label71 equal .SMOOTH false
-    * jump *label73 notEqual :drawPixel:iterations 63
+  264 jump *label73 notEqual :iterations 63
   265 set :drawPixel:color %[black]
   266 jump *label74 always
   267 label *label73
   268 jump *label76 notEqual .PALETTE 2
   269 label *label77
-    * op sub *tmp128 32 :drawPixel:iterations
+  270 op sub *tmp128 32 :iterations
   271 op abs *tmp129 *tmp128
   272 op mul *tmp130 7 *tmp129
-    * op div *tmp131 *tmp130 255
+  273 op div *tmp131 *tmp129 36.42857142857143
   274 op sub :drawPixel:r 1 *tmp131
-    * op sub *tmp133 :drawPixel:iterations 32
+  275 op sub *tmp133 :iterations 32
   276 op abs *tmp134 *tmp133
   277 op mul *tmp135 6 *tmp134
-    * op div *tmp136 *tmp135 255
+  278 op div *tmp136 *tmp134 42.5
   279 op sub :drawPixel:g 0.9411764705882353 *tmp136
-    * op sub *tmp138 32 :drawPixel:iterations
-    * op abs *tmp139 *tmp138
-    * op mul *tmp140 4 *tmp139
-    * op div *tmp141 *tmp140 255
+  280 op sub *tmp138 32 :iterations
+  281 op abs *tmp139 *tmp128
+  282 op mul *tmp140 4 *tmp129
+  283 op div *tmp141 *tmp139 63.75
   284 op add :drawPixel:b 0.47058823529411764 *tmp141
   285 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   286 jump *label75 always
   287 label *label76
   288 jump *label78 notEqual .PALETTE 3
   289 label *label79
-    * op div *tmp144 :drawPixel:iterations 63
-    * op mul *tmp145 *tmp144 360
+  290 op div *tmp144 :iterations 63
+  291 op div *tmp145 :drawPixel:iterations 0.175
   292 op sin :drawPixel:r *tmp145
-    * op div *tmp147 :drawPixel:iterations 63
-    * op mul *tmp148 *tmp147 360
-    * op cos :drawPixel:g *tmp148
-    * op sub *tmp150 :drawPixel:iterations 32
+  293 op div *tmp147 :iterations 63
+  294 op mul *tmp148 *tmp144 360
+  295 op cos :drawPixel:g *tmp145
+  296 op sub *tmp150 :iterations 32
   297 op abs *tmp151 *tmp150
   298 op mul *tmp152 4 *tmp151
-    * op div *tmp153 *tmp152 255
+  299 op div *tmp153 *tmp151 63.75
   300 op add :drawPixel:b 0.39215686274509803 *tmp153
   301 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   302 jump *label75 always
   303 label *label78
   304 jump *label80 notEqual .PALETTE 4
   305 label *label81
-    * op mul *tmp156 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp156 255
-    * op mul *tmp158 1.5 :drawPixel:iterations
-    * op div :drawPixel:g *tmp158 255
+  306 op mul *tmp156 4 :iterations
+  307 op div :drawPixel:r :drawPixel:iterations 63.75
+  308 op mul *tmp158 1.5 :iterations
+  309 op div :drawPixel:g :drawPixel:iterations 170
   310 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   311 jump *label75 always
   312 label *label80
-    * op mul *tmp161 4 :drawPixel:iterations
-    * op div *tmp162 *tmp161 255
+  313 op mul *tmp161 4 :iterations
+  314 op div *tmp162 :drawPixel:iterations 63.75
   315 op sub :drawPixel:r 1 *tmp162
   316 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   317 label *label75
   318 label *label74
   319 jump *label72 always
   320 label *label71
-    * read :drawPixel:color .memory :drawPixel:iterations
+  321 read :drawPixel:color .memory :iterations
   322 label *label72
   323 jump *label82 lessThan .localBuffer 254
   324 label *label85
 
   350 label *label98
   351 jump *label95 strictNotEqual :drawPixel:color .lastColor
   352 label *label97
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  353 draw rect :x :y :dx :dy
   354 op add .localBuffer .localBuffer 1
   355 jump *label96 always
   356 label *label95
   357 draw col :drawPixel:color
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  358 draw rect :x :y :dx :dy
   359 set .lastColor :drawPixel:color
   360 op add .localBuffer .localBuffer 2
   361 label *label96
 
   383 op add *tmp2 *tmp190 1
   384 write *tmp2 .memory 66
   385 read *tmp192 .memory 65
-    * op add *tmp193 *tmp192 :iterations
+  386 op add *tmp193 *tmp192 *tmp88
   387 write *tmp193 .memory 65
   388 label *label19
   389 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-13 instructions):
 
    22 op div *tmp22 -88 .ZOOM
    23 read *tmp24 .memory 69
    24 op add .OFFSET_X *tmp22 *tmp24
-    * op div *tmp25 -88 .ZOOM
    25 read *tmp27 .memory 70
    26 op add .OFFSET_Y *tmp22 *tmp27
    27 read .JULIA .memory 72
 
    37 label *label9
    38 set *tmp35 99
    39 label *label10
-    * set :leaderLimit *tmp35
    40 set :multiple 4
    41 label *label11
    42 wait 0
 
   184 label *label49
   185 label *label45
   186 label *label46
-    * set :compute:x :adam5:x
-    * set :compute:y :adam5:y
-    * op div *tmp89 :x .ZOOM
+  187 op div *tmp89 :adam5:x .ZOOM
   188 op add :compute:zx *tmp89 .OFFSET_X
-    * op div *tmp91 :y .ZOOM
+  189 op div *tmp91 :adam5:y .ZOOM
   190 op add :compute:zy *tmp91 .OFFSET_Y
   191 jump *label55 equal .JULIA false
   192 set :compute:cx .JULIA_X
 
   218 label *label61
   219 jump *label63 greaterThanEq :compute:i 63
   220 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   221 op mul *tmp106 :compute:zx :compute:zx
   222 op mul *tmp107 :compute:zy :compute:zy
   223 op sub *tmp108 *tmp106 *tmp107
 
   250 jump *label54 always
   251 label *label54
   252 set :iterations *tmp88
-    * set :drawPixel:x :adam5:x
-    * set :drawPixel:y :adam5:y
-    * set :drawPixel:dx :adam5:dx
-    * set :drawPixel:dy :adam5:dy
   253 set :drawPixel:iterations *tmp88
   254 jump *label71 equal .SMOOTH false
-    * jump *label73 notEqual :iterations 63
+  255 jump *label73 notEqual *tmp88 63
   256 set :drawPixel:color %[black]
   257 jump *label74 always
   258 label *label73
   259 jump *label76 notEqual .PALETTE 2
   260 label *label77
-    * op sub *tmp128 32 :iterations
+  261 op sub *tmp128 32 *tmp88
   262 op abs *tmp129 *tmp128
-    * op mul *tmp130 7 *tmp129
   263 op div *tmp131 *tmp129 36.42857142857143
   264 op sub :drawPixel:r 1 *tmp131
-    * op sub *tmp133 :iterations 32
+  265 op sub *tmp133 *tmp88 32
   266 op abs *tmp134 *tmp133
-    * op mul *tmp135 6 *tmp134
   267 op div *tmp136 *tmp134 42.5
   268 op sub :drawPixel:g 0.9411764705882353 *tmp136
-    * op sub *tmp138 32 :iterations
+  269 op sub *tmp138 32 *tmp88
   270 op abs *tmp139 *tmp128
-    * op mul *tmp140 4 *tmp129
-    * op div *tmp141 *tmp139 63.75
+  271 op div *tmp141 *tmp129 63.75
   272 op add :drawPixel:b 0.47058823529411764 *tmp141
   273 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   274 jump *label75 always
   275 label *label76
   276 jump *label78 notEqual .PALETTE 3
   277 label *label79
-    * op div *tmp144 :iterations 63
-    * op div *tmp145 :drawPixel:iterations 0.175
+  278 op div *tmp144 *tmp88 63
+  279 op div *tmp145 *tmp88 0.175
   280 op sin :drawPixel:r *tmp145
-    * op div *tmp147 :iterations 63
-    * op mul *tmp148 *tmp144 360
+  281 op div *tmp147 *tmp88 63
+  282 op div *tmp148 :iterations 0.175
   283 op cos :drawPixel:g *tmp145
-    * op sub *tmp150 :iterations 32
+  284 op sub *tmp150 *tmp88 32
   285 op abs *tmp151 *tmp150
-    * op mul *tmp152 4 *tmp151
   286 op div *tmp153 *tmp151 63.75
   287 op add :drawPixel:b 0.39215686274509803 *tmp153
   288 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   290 label *label78
   291 jump *label80 notEqual .PALETTE 4
   292 label *label81
-    * op mul *tmp156 4 :iterations
-    * op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp158 1.5 :iterations
-    * op div :drawPixel:g :drawPixel:iterations 170
+  293 op mul *tmp156 4 *tmp88
+  294 op div :drawPixel:r *tmp88 63.75
+  295 op mul *tmp158 1.5 *tmp88
+  296 op div :drawPixel:g *tmp88 170
   297 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   298 jump *label75 always
   299 label *label80
-    * op mul *tmp161 4 :iterations
-    * op div *tmp162 :drawPixel:iterations 63.75
+  300 op mul *tmp161 4 *tmp88
+  301 op div *tmp162 *tmp88 63.75
   302 op sub :drawPixel:r 1 *tmp162
   303 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   304 label *label75
   305 label *label74
   306 jump *label72 always
   307 label *label71
-    * read :drawPixel:color .memory :iterations
+  308 read :drawPixel:color .memory *tmp88
   309 label *label72
   310 jump *label82 lessThan .localBuffer 254
   311 label *label85
 
   337 label *label98
   338 jump *label95 strictNotEqual :drawPixel:color .lastColor
   339 label *label97
-    * draw rect :x :y :dx :dy
+  340 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   341 op add .localBuffer .localBuffer 1
   342 jump *label96 always
   343 label *label95
   344 draw col :drawPixel:color
-    * draw rect :x :y :dx :dy
+  345 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   346 set .lastColor :drawPixel:color
   347 op add .localBuffer .localBuffer 2
   348 label *label96

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   157 set :adam5:dx 1
   158 label *label22
   159 label *label21
-    * set :x :adam5:x
-    * set :y :adam5:y
-    * set :dx :adam5:dx
-    * set :dy :adam5:dy
   160 jump *label45 lessThanEq :multiple *tmp35
   161 label *label48
   162 jump *label45 notEqual .localBuffer 0
 
   246 jump *label54 always
   247 label *label54
   248 set :iterations *tmp88
-    * set :drawPixel:iterations *tmp88
   249 jump *label71 equal .SMOOTH false
   250 jump *label73 notEqual *tmp88 63
   251 set :drawPixel:color %[black]
 
   261 op abs *tmp134 *tmp133
   262 op div *tmp136 *tmp134 42.5
   263 op sub :drawPixel:g 0.9411764705882353 *tmp136
-    * op sub *tmp138 32 *tmp88
-    * op abs *tmp139 *tmp128
   264 op div *tmp141 *tmp129 63.75
   265 op add :drawPixel:b 0.47058823529411764 *tmp141
   266 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   268 label *label76
   269 jump *label78 notEqual .PALETTE 3
   270 label *label79
-    * op div *tmp144 *tmp88 63
   271 op div *tmp145 *tmp88 0.175
   272 op sin :drawPixel:r *tmp145
-    * op div *tmp147 *tmp88 63
-    * op div *tmp148 :iterations 0.175
+  273 op div *tmp148 *tmp88 0.175
   274 op cos :drawPixel:g *tmp145
   275 op sub *tmp150 *tmp88 32
   276 op abs *tmp151 *tmp150
 
   281 label *label78
   282 jump *label80 notEqual .PALETTE 4
   283 label *label81
-    * op mul *tmp156 4 *tmp88
   284 op div :drawPixel:r *tmp88 63.75
-    * op mul *tmp158 1.5 *tmp88
   285 op div :drawPixel:g *tmp88 170
   286 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   287 jump *label75 always
   288 label *label80
-    * op mul *tmp161 4 *tmp88
   289 op div *tmp162 *tmp88 63.75
   290 op sub :drawPixel:r 1 *tmp162
   291 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   245 set *tmp88 :compute:i
   246 jump *label54 always
   247 label *label54
-    * set :iterations *tmp88
   248 jump *label71 equal .SMOOTH false
   249 jump *label73 notEqual *tmp88 63
   250 set :drawPixel:color %[black]
 
   269 label *label79
   270 op div *tmp145 *tmp88 0.175
   271 op sin :drawPixel:r *tmp145
-    * op div *tmp148 *tmp88 0.175
   272 op cos :drawPixel:g *tmp145
   273 op sub *tmp150 *tmp88 32
   274 op abs *tmp151 *tmp150

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    55 label *label17
    56 op mul *tmp46 11 :multiple
    57 set :i 0
+   58 op mul *tmp47 :batch 11
    59 label *label18
    60 jump *label20 greaterThanEq :i *tmp46
-    * op mul *tmp47 :batch 11
    61 op add :adam5:index *tmp47 :i
    62 op idiv *tmp50 :adam5:index 16
    63 jump *label25 lessThan *tmp50 0

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
    58 op mul *tmp47 :batch 11
    59 label *label18
    60 jump *label20 greaterThanEq :i *tmp46
+   61 label *label119
    62 op add :adam5:index *tmp47 :i
    63 op idiv *tmp50 :adam5:index 16
    64 jump *label25 lessThan *tmp50 0
 
   214 set :compute:i 0
   215 label *label61
   216 jump *label63 greaterThanEq :compute:i 63
+  217 label *label120
   218 set :compute:x1 :compute:zx
   219 op mul *tmp106 :compute:zx :compute:zx
   220 op mul *tmp107 :compute:zy :compute:zy
 
   230 label *label65
   231 label *label62
   232 op add :compute:i :compute:i 1
-    * jump *label61 always
+  233 jump *label120 lessThan :compute:i 63
   234 label *label63
   235 jump *label66 equal .SMOOTH false
   236 label *label69
 
   298 jump *label82 lessThan .localBuffer 254
   299 label *label85
   300 jump *label87 lessThanEq .localBuffer 0
-    * label *label89
+  301 label *label121
   302 read *tmp172 .memory 68
   303 jump *label87 notEqual .stop *tmp172
-    * label *label88
   304 wait 0
   305 sensor *tmp173 .display @enabled
   306 jump *label91 equal *tmp173 false
 
   315 label *label92
   316 label *label90
   317 label *label86
-    * jump *label85 always
+  318 jump *label121 greaterThan .localBuffer 0
   319 label *label87
   320 label *label84
   321 label *label82
 
   361 write *tmp193 .memory 65
   362 label *label19
   363 op add :i :i 1
-    * jump *label18 always
+  364 jump *label119 lessThan :i *tmp46
   365 label *label20
   366 jump *label106 lessThan :batch 1337.6
   367 set :multiple 1
 
   372 label *label13
   373 label *label109
   374 jump *label111 lessThanEq .localBuffer 0
-    * label *label113
+  375 label *label122
   376 read *tmp198 .memory 68
   377 jump *label111 notEqual .stop *tmp198
-    * label *label112
   378 wait 0
   379 sensor *tmp199 .display @enabled
   380 jump *label115 equal *tmp199 false
 
   389 label *label116
   390 label *label114
   391 label *label110
-    * jump *label109 always
+  392 jump *label122 greaterThan .localBuffer 0
   393 label *label111
   394 label *label108
   395 label *label4

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-18 instructions):
 
    30 read .PALETTE .memory 75
    31 op greaterThan .SMOOTH .PALETTE 1
    32 read .ALL_PASS_COLORING .memory 76
-    * read *tmp34 .memory 77
-    * jump *label9 equal *tmp34 false
-    * op sub *tmp35 1 .ALL_PASS_COLORING
-    * jump *label10 always
-    * label *label9
-    * set *tmp35 99
-    * label *label10
+   33 read *tmp34 .memory 77
+   34 op sub *tmp204 1 .ALL_PASS_COLORING
+   35 select *tmp35 notEqual *tmp34 false *tmp204 99
    36 set :multiple 4
    37 label *label11
    38 wait 0
 
    66 op mul :adam5:x 4 *tmp52
    67 op idiv *tmp54 :adam5:index 44
    68 op mul :adam5:y 4 *tmp54
-    * jump *label26 equal .ALL_PASS_COLORING false
-    * set *tmp56 4
-    * jump *label27 always
-    * label *label26
-    * set *tmp56 2
-    * label *label27
+   69 select *tmp56 notEqual .ALL_PASS_COLORING false 4 2
    70 set :adam5:dy *tmp56
    71 set :adam5:dx *tmp56
    72 jump *label22 always
 
    82 op add :adam5:x *tmp58 2
    83 op idiv *tmp60 :adam5:index 44
    84 op mul :adam5:y 4 *tmp60
-    * jump *label31 equal .ALL_PASS_COLORING false
-    * set *tmp62 2
-    * jump *label32 always
-    * label *label31
-    * set *tmp62 1
-    * label *label32
+   85 select *tmp62 notEqual .ALL_PASS_COLORING false 2 1
    86 set :adam5:dx *tmp62
-    * jump *label33 equal .ALL_PASS_COLORING false
-    * set *tmp63 4
-    * jump *label34 always
-    * label *label33
-    * set *tmp63 2
-    * label *label34
+   87 select *tmp63 notEqual .ALL_PASS_COLORING false 4 2
    88 set :adam5:dy *tmp63
    89 jump *label22 always
    90 label *label28
 
    99 op idiv *tmp66 :adam5:index 88
   100 op mul *tmp67 4 *tmp66
   101 op add :adam5:y *tmp67 2
-    * jump *label38 equal .ALL_PASS_COLORING false
-    * set *tmp69 2
-    * jump *label39 always
-    * label *label38
-    * set *tmp69 1
-    * label *label39
+  102 select *tmp69 notEqual .ALL_PASS_COLORING false 2 1
   103 set :adam5:dy *tmp69
   104 set :adam5:dx *tmp69
   105 jump *label22 always
 
   116 op idiv *tmp73 :adam5:index 88
   117 op mul :adam5:y 2 *tmp73
   118 set :adam5:dx 1
-    * jump *label43 equal .ALL_PASS_COLORING false
-    * set *tmp75 2
-    * jump *label44 always
-    * label *label43
-    * set *tmp75 1
-    * label *label44
+  119 select *tmp75 notEqual .ALL_PASS_COLORING false 2 1
   120 set :adam5:dy *tmp75
   121 jump *label22 always
   122 label *label40
 
   130 label *label22
   131 label *label21
   132 jump *label45 lessThanEq :multiple *tmp35
-    * label *label48
   133 jump *label45 notEqual .localBuffer 0
-    * label *label47
   134 draw col %[white]
   135 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx
   136 set .lastColor %[white]
 
   138 wait 0
   139 sensor *tmp83 .display @enabled
   140 jump *label50 equal *tmp83 false
-    * label *label53
   141 sensor *tmp84 .display @bufferSize
   142 op sub *tmp85 1024 *tmp84
   143 jump *label50 greaterThanEq 2 *tmp85
-    * label *label52
   144 drawflush .display
   145 set .localBuffer 0
   146 label *label50
 
   200 jump *label120 lessThan :compute:i 63
   201 label *label63
   202 jump *label66 equal .SMOOTH false
-    * label *label69
   203 jump *label66 greaterThanEq :compute:i 63
-    * label *label68
   204 op log *tmp118 :compute:dist
   205 op mul *tmp119 *tmp118 0.36067376022224085
   206 op log *tmp120 *tmp119
 
   269 wait 0
   270 sensor *tmp173 .display @enabled
   271 jump *label91 equal *tmp173 false
-    * label *label94
   272 sensor *tmp174 .display @bufferSize
   273 op sub *tmp175 1024 *tmp174
   274 jump *label91 greaterThanEq .localBuffer *tmp175
-    * label *label93
   275 drawflush .display
   276 set .localBuffer 0
   277 label *label91
 
   284 label *label82
   285 label *label83
   286 jump *label95 lessThanEq .localBuffer 0
-    * label *label98
   287 jump *label95 strictNotEqual :drawPixel:color .lastColor
-    * label *label97
   288 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   289 op add .localBuffer .localBuffer 1
   290 jump *label96 always
 
   297 wait 0
   298 sensor *tmp182 .display @enabled
   299 jump *label100 equal *tmp182 false
-    * label *label103
   300 sensor *tmp183 .display @bufferSize
   301 op sub *tmp184 1024 *tmp183
   302 jump *label100 greaterThanEq .localBuffer *tmp184
-    * label *label102
   303 drawflush .display
   304 set .localBuffer 0
   305 label *label100
 
   322 op add :i :i 1
   323 jump *label119 lessThan :i *tmp46
   324 label *label20
-    * jump *label106 lessThan :batch 1337.6
-    * set :multiple 1
-    * label *label106
-    * label *label107
+  325 select :multiple greaterThanEq :batch 1337.6 1 :multiple
   326 label *label12
   327 jump *label11 always
   328 label *label13
 
   334 wait 0
   335 sensor *tmp199 .display @enabled
   336 jump *label115 equal *tmp199 false
-    * label *label118
   337 sensor *tmp200 .display @bufferSize
   338 op sub *tmp201 1024 *tmp200
   339 jump *label115 greaterThanEq .localBuffer *tmp201
-    * label *label117
   340 drawflush .display
   341 set .localBuffer 0
   342 label *label115

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   213 jump *label54 always
   214 label *label54
   215 jump *label71 equal .SMOOTH false
-    * jump *label73 notEqual *tmp88 63
   216 set :drawPixel:color %[black]
-    * jump *label74 always
+  217 jump *label74 equal *tmp88 63
   218 label *label73
   219 jump *label76 notEqual .PALETTE 2
   220 label *label77

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:132:5 (-10 instructions):
 
    57 label *label119
    58 op add :adam5:index *tmp47 :i
    59 op idiv *tmp50 :adam5:index 16
-    * jump *label25 lessThan *tmp50 0
-    * jump *label24 lessThan *tmp50 121
-    * label *label25
-    * jump *label23 always
+   60 multijump *tmp50 0 0 (m:*label124)
+   61 multilabel *label129 (m:*label124)
+   62 label *label123
+   63 op sub :adam5:index :adam5:index 15488
+   64 op mod :adam5:x :adam5:index 176
+   65 op idiv *tmp77 :adam5:index 176
+   66 op mul *tmp78 2 *tmp77
+   67 op add :adam5:y *tmp78 1
+   68 set :adam5:dy 1
+   69 set :adam5:dx 1
+   70 jump *label22 always
+   71 multilabel *label125 (m:*label124)
    72 label *label24
    73 op mod *tmp52 :adam5:index 44
    74 op mul :adam5:x 4 *tmp52
 
    79 set :adam5:dx *tmp56
    80 jump *label22 always
    81 label *label23
-    * jump *label30 lessThan *tmp50 121
-    * jump *label29 lessThan *tmp50 242
-    * label *label30
-    * jump *label28 always
+   82 multilabel *label126 (m:*label124)
    83 label *label29
    84 op sub :adam5:index :adam5:index 1936
    85 op mod *tmp57 :adam5:index 44
 
    93 set :adam5:dy *tmp63
    94 jump *label22 always
    95 label *label28
-    * jump *label37 lessThan *tmp50 242
-    * jump *label36 lessThan *tmp50 484
-    * label *label37
-    * jump *label35 always
+   96 multilabel *label127 (m:*label124)
    97 label *label36
    98 op sub :adam5:index :adam5:index 3872
    99 op mod *tmp64 :adam5:index 88
 
   106 set :adam5:dx *tmp69
   107 jump *label22 always
   108 label *label35
-    * jump *label42 lessThan *tmp50 484
-    * jump *label41 lessThan *tmp50 968
-    * label *label42
-    * jump *label40 always
+  109 jump *label22 always
+  110 multilabel *label128 (m:*label124)
   111 label *label41
   112 op sub :adam5:index :adam5:index 7744
   113 op mod *tmp70 :adam5:index 88
 
   118 set :adam5:dx 1
   119 select *tmp75 notEqual .ALL_PASS_COLORING false 2 1
   120 set :adam5:dy *tmp75
-    * jump *label22 always
-    * label *label40
-    * op sub :adam5:index :adam5:index 15488
-    * op mod :adam5:x :adam5:index 176
-    * op idiv *tmp77 :adam5:index 176
-    * op mul *tmp78 2 *tmp77
-    * op add :adam5:y *tmp78 1
-    * set :adam5:dy 1
-    * set :adam5:dx 1
   121 label *label22
   122 label *label21
   123 jump *label45 lessThanEq :multiple *tmp35

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    53 set :i 0
    54 op mul *tmp47 :batch 11
    55 label *label18
-    * jump *label20 greaterThanEq :i *tmp46
+   56 jump *label20 greaterThanEq 0 *tmp46
    57 label *label119
    58 op add :adam5:index *tmp47 :i
    59 op idiv *tmp50 :adam5:index 16
 
   171 label *label56
   172 set :compute:i 0
   173 label *label61
-    * jump *label63 greaterThanEq :compute:i 63
+  174 jump *label63 greaterThanEq 0 63
   175 label *label120
   176 set :compute:x1 :compute:zx
   177 op mul *tmp106 :compute:zx :compute:zx

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:221:13 (-2 instructions):
 
   207 set :drawPixel:color %[black]
   208 jump *label74 equal *tmp88 63
   209 label *label73
-    * jump *label76 notEqual .PALETTE 2
+  210 multijump .PALETTE 0 0 (m:*label131)
+  211 multilabel *label136 (m:*label131)
+  212 multilabel *label132 (m:*label131)
+  213 label *label130
+  214 op div *tmp162 *tmp88 63.75
+  215 op sub :drawPixel:r 1 *tmp162
+  216 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
+  217 jump *label75 always
+  218 multilabel *label133 (m:*label131)
   219 label *label77
   220 op sub *tmp128 32 *tmp88
   221 op abs *tmp129 *tmp128
 
   230 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   231 jump *label75 always
   232 label *label76
-    * jump *label78 notEqual .PALETTE 3
+  233 multilabel *label134 (m:*label131)
   234 label *label79
   235 op div *tmp145 *tmp88 0.175
   236 op sin :drawPixel:r *tmp145
 
   242 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   243 jump *label75 always
   244 label *label78
-    * jump *label80 notEqual .PALETTE 4
+  245 multilabel *label135 (m:*label131)
   246 label *label81
   247 op div :drawPixel:r *tmp88 63.75
   248 op div :drawPixel:g *tmp88 170
   249 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label75 always
-    * label *label80
-    * op div *tmp162 *tmp88 63.75
-    * op sub :drawPixel:r 1 *tmp162
-    * packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   250 label *label75
   251 label *label74
   252 jump *label72 always

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   171 label *label56
   172 set :compute:i 0
   173 label *label61
-    * jump *label63 greaterThanEq 0 63
   174 label *label120
   175 set :compute:x1 :compute:zx
   176 op mul *tmp106 :compute:zx :compute:zx

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-2 instructions):
 
    28 read .JULIA_X .memory 73
    29 read .JULIA_Y .memory 74
    30 read .PALETTE .memory 75
-    * op greaterThan .SMOOTH .PALETTE 1
    31 read .ALL_PASS_COLORING .memory 76
    32 read *tmp34 .memory 77
    33 op sub *tmp204 1 .ALL_PASS_COLORING
 
    52 set :i 0
    53 op mul *tmp47 :batch 11
    54 label *label18
-    * jump *label20 greaterThanEq 0 *tmp46
+   55 jump *label20 lessThanEq :multiple 0
    56 label *label119
    57 op add :adam5:index *tmp47 :i
    58 op idiv *tmp50 :adam5:index 16
 
   129 sensor *tmp83 .display @enabled
   130 jump *label50 equal *tmp83 false
   131 sensor *tmp84 .display @bufferSize
-    * op sub *tmp85 1024 *tmp84
-    * jump *label50 greaterThanEq 2 *tmp85
+  132 jump *label50 greaterThanEq *tmp84 1022
   133 drawflush .display
   134 set .localBuffer 0
   135 label *label50
 
   187 op add :compute:i :compute:i 1
   188 jump *label120 lessThan :compute:i 63
   189 label *label63
-    * jump *label66 equal .SMOOTH false
+  190 jump *label66 lessThanEq .PALETTE 1
   191 jump *label66 greaterThanEq :compute:i 63
   192 op log *tmp118 :compute:dist
   193 op mul *tmp119 *tmp118 0.36067376022224085
 
   200 set *tmp88 :compute:i
   201 jump *label54 always
   202 label *label54
-    * jump *label71 equal .SMOOTH false
+  203 jump *label71 lessThanEq .PALETTE 1
   204 set :drawPixel:color %[black]
   205 jump *label74 equal *tmp88 63
   206 label *label73

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   103 select *tmp69 notEqual .ALL_PASS_COLORING false 2 1
   104 set :adam5:dy *tmp69
   105 set :adam5:dx *tmp69
-    * jump *label22 always
   106 label *label35
   107 jump *label22 always
   108 multilabel *label128 (m:*label124)
 
   197 label *label66
   198 label *label67
   199 set *tmp88 :compute:i
-    * jump *label54 always
   200 label *label54
   201 jump *label71 lessThanEq .PALETTE 1
   202 set :drawPixel:color %[black]

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-3 instructions):
 
    86 op add :adam5:x *tmp58 2
    87 op idiv *tmp60 :adam5:index 44
    88 op mul :adam5:y 4 *tmp60
-    * select *tmp62 notEqual .ALL_PASS_COLORING false 2 1
-    * set :adam5:dx *tmp62
-    * select *tmp63 notEqual .ALL_PASS_COLORING false 4 2
-    * set :adam5:dy *tmp63
+   89 select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1
+   90 select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2
    91 jump *label22 always
    92 label *label28
    93 multilabel *label127 (m:*label124)
 
   112 op idiv *tmp73 :adam5:index 88
   113 op mul :adam5:y 2 *tmp73
   114 set :adam5:dx 1
-    * select *tmp75 notEqual .ALL_PASS_COLORING false 2 1
-    * set :adam5:dy *tmp75
+  115 select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1
   116 label *label22
   117 label *label21
   118 jump *label45 lessThanEq :multiple *tmp35

Modifications by Unroll loop at mandelbrot-compute.mnd:193:5 (+743 instructions):
 
   163 label *label59
   164 label *label60
   165 label *label56
-    * set :compute:i 0
-    * label *label61
-    * label *label120
-    * set :compute:x1 :compute:zx
-    * op mul *tmp106 :compute:zx :compute:zx
-    * op mul *tmp107 :compute:zy :compute:zy
-    * op sub *tmp108 *tmp106 *tmp107
-    * op add :compute:zx *tmp108 :compute:cx
-    * op mul *tmp110 2 :compute:x1
-    * op mul *tmp111 *tmp110 :compute:zy
-    * op add :compute:zy *tmp111 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label64 lessThan :compute:dist 64
-    * jump *label63 always
-    * label *label64
-    * label *label65
-    * label *label62
-    * op add :compute:i :compute:i 1
-    * jump *label120 lessThan :compute:i 63
-    * label *label63
+  166 set :compute:i 0
+  167 label *label137
+  168 set :compute:x1 :compute:zx
+  169 op mul *tmp106 :compute:zx :compute:zx
+  170 op mul *tmp107 :compute:zy :compute:zy
+  171 op sub *tmp108 *tmp106 *tmp107
+  172 op add :compute:zx *tmp108 :compute:cx
+  173 op mul *tmp110 2 :compute:x1
+  174 op mul *tmp111 *tmp110 :compute:zy
+  175 op add :compute:zy *tmp111 :compute:cy
+  176 op len :compute:dist :compute:zx :compute:zy
+  177 jump *label138 lessThan :compute:dist 64
+  178 jump *label63 always
+  179 label *label138
+  180 label *label139
+  181 label *label140
+  182 op add :compute:i :compute:i 1
+  183 set :compute:x1 :compute:zx
+  184 op mul *tmp106 :compute:zx :compute:zx
+  185 op mul *tmp107 :compute:zy :compute:zy
+  186 op sub *tmp108 *tmp106 *tmp107
+  187 op add :compute:zx *tmp108 :compute:cx
+  188 op mul *tmp110 2 :compute:x1
+  189 op mul *tmp111 *tmp110 :compute:zy
+  190 op add :compute:zy *tmp111 :compute:cy
+  191 op len :compute:dist :compute:zx :compute:zy
+  192 jump *label141 lessThan :compute:dist 64
+  193 jump *label63 always
+  194 label *label141
+  195 label *label142
+  196 label *label143
+  197 op add :compute:i :compute:i 1
+  198 set :compute:x1 :compute:zx
+  199 op mul *tmp106 :compute:zx :compute:zx
+  200 op mul *tmp107 :compute:zy :compute:zy
+  201 op sub *tmp108 *tmp106 *tmp107
+  202 op add :compute:zx *tmp108 :compute:cx
+  203 op mul *tmp110 2 :compute:x1
+  204 op mul *tmp111 *tmp110 :compute:zy
+  205 op add :compute:zy *tmp111 :compute:cy
+  206 op len :compute:dist :compute:zx :compute:zy
+  207 jump *label144 lessThan :compute:dist 64
+  208 jump *label63 always
+  209 label *label144
+  210 label *label145
+  211 label *label146
+  212 op add :compute:i :compute:i 1
+  213 set :compute:x1 :compute:zx
+  214 op mul *tmp106 :compute:zx :compute:zx
+  215 op mul *tmp107 :compute:zy :compute:zy
+  216 op sub *tmp108 *tmp106 *tmp107
+  217 op add :compute:zx *tmp108 :compute:cx
+  218 op mul *tmp110 2 :compute:x1
+  219 op mul *tmp111 *tmp110 :compute:zy
+  220 op add :compute:zy *tmp111 :compute:cy
+  221 op len :compute:dist :compute:zx :compute:zy
+  222 jump *label147 lessThan :compute:dist 64
+  223 jump *label63 always
+  224 label *label147
+  225 label *label148
+  226 label *label149
+  227 op add :compute:i :compute:i 1
+  228 set :compute:x1 :compute:zx
+  229 op mul *tmp106 :compute:zx :compute:zx
+  230 op mul *tmp107 :compute:zy :compute:zy
+  231 op sub *tmp108 *tmp106 *tmp107
+  232 op add :compute:zx *tmp108 :compute:cx
+  233 op mul *tmp110 2 :compute:x1
+  234 op mul *tmp111 *tmp110 :compute:zy
+  235 op add :compute:zy *tmp111 :compute:cy
+  236 op len :compute:dist :compute:zx :compute:zy
+  237 jump *label150 lessThan :compute:dist 64
+  238 jump *label63 always
+  239 label *label150
+  240 label *label151
+  241 label *label152
+  242 op add :compute:i :compute:i 1
+  243 set :compute:x1 :compute:zx
+  244 op mul *tmp106 :compute:zx :compute:zx
+  245 op mul *tmp107 :compute:zy :compute:zy
+  246 op sub *tmp108 *tmp106 *tmp107
+  247 op add :compute:zx *tmp108 :compute:cx
+  248 op mul *tmp110 2 :compute:x1
+  249 op mul *tmp111 *tmp110 :compute:zy
+  250 op add :compute:zy *tmp111 :compute:cy
+  251 op len :compute:dist :compute:zx :compute:zy
+  252 jump *label153 lessThan :compute:dist 64
+  253 jump *label63 always
+  254 label *label153
+  255 label *label154
+  256 label *label155
+  257 op add :compute:i :compute:i 1
+  258 set :compute:x1 :compute:zx
+  259 op mul *tmp106 :compute:zx :compute:zx
+  260 op mul *tmp107 :compute:zy :compute:zy
+  261 op sub *tmp108 *tmp106 *tmp107
+  262 op add :compute:zx *tmp108 :compute:cx
+  263 op mul *tmp110 2 :compute:x1
+  264 op mul *tmp111 *tmp110 :compute:zy
+  265 op add :compute:zy *tmp111 :compute:cy
+  266 op len :compute:dist :compute:zx :compute:zy
+  267 jump *label156 lessThan :compute:dist 64
+  268 jump *label63 always
+  269 label *label156
+  270 label *label157
+  271 label *label158
+  272 op add :compute:i :compute:i 1
+  273 set :compute:x1 :compute:zx
+  274 op mul *tmp106 :compute:zx :compute:zx
+  275 op mul *tmp107 :compute:zy :compute:zy
+  276 op sub *tmp108 *tmp106 *tmp107
+  277 op add :compute:zx *tmp108 :compute:cx
+  278 op mul *tmp110 2 :compute:x1
+  279 op mul *tmp111 *tmp110 :compute:zy
+  280 op add :compute:zy *tmp111 :compute:cy
+  281 op len :compute:dist :compute:zx :compute:zy
+  282 jump *label159 lessThan :compute:dist 64
+  283 jump *label63 always
+  284 label *label159
+  285 label *label160
+  286 label *label161
+  287 op add :compute:i :compute:i 1
+  288 set :compute:x1 :compute:zx
+  289 op mul *tmp106 :compute:zx :compute:zx
+  290 op mul *tmp107 :compute:zy :compute:zy
+  291 op sub *tmp108 *tmp106 *tmp107
+  292 op add :compute:zx *tmp108 :compute:cx
+  293 op mul *tmp110 2 :compute:x1
+  294 op mul *tmp111 *tmp110 :compute:zy
+  295 op add :compute:zy *tmp111 :compute:cy
+  296 op len :compute:dist :compute:zx :compute:zy
+  297 jump *label162 lessThan :compute:dist 64
+  298 jump *label63 always
+  299 label *label162
+  300 label *label163
+  301 label *label164
+  302 op add :compute:i :compute:i 1
+  303 set :compute:x1 :compute:zx
+  304 op mul *tmp106 :compute:zx :compute:zx
+  305 op mul *tmp107 :compute:zy :compute:zy
+  306 op sub *tmp108 *tmp106 *tmp107
+  307 op add :compute:zx *tmp108 :compute:cx
+  308 op mul *tmp110 2 :compute:x1
+  309 op mul *tmp111 *tmp110 :compute:zy
+  310 op add :compute:zy *tmp111 :compute:cy
+  311 op len :compute:dist :compute:zx :compute:zy
+  312 jump *label165 lessThan :compute:dist 64
+  313 jump *label63 always
+  314 label *label165
+  315 label *label166
+  316 label *label167
+  317 op add :compute:i :compute:i 1
+  318 set :compute:x1 :compute:zx
+  319 op mul *tmp106 :compute:zx :compute:zx
+  320 op mul *tmp107 :compute:zy :compute:zy
+  321 op sub *tmp108 *tmp106 *tmp107
+  322 op add :compute:zx *tmp108 :compute:cx
+  323 op mul *tmp110 2 :compute:x1
+  324 op mul *tmp111 *tmp110 :compute:zy
+  325 op add :compute:zy *tmp111 :compute:cy
+  326 op len :compute:dist :compute:zx :compute:zy
+  327 jump *label168 lessThan :compute:dist 64
+  328 jump *label63 always
+  329 label *label168
+  330 label *label169
+  331 label *label170
+  332 op add :compute:i :compute:i 1
+  333 set :compute:x1 :compute:zx
+  334 op mul *tmp106 :compute:zx :compute:zx
+  335 op mul *tmp107 :compute:zy :compute:zy
+  336 op sub *tmp108 *tmp106 *tmp107
+  337 op add :compute:zx *tmp108 :compute:cx
+  338 op mul *tmp110 2 :compute:x1
+  339 op mul *tmp111 *tmp110 :compute:zy
+  340 op add :compute:zy *tmp111 :compute:cy
+  341 op len :compute:dist :compute:zx :compute:zy
+  342 jump *label171 lessThan :compute:dist 64
+  343 jump *label63 always
+  344 label *label171
+  345 label *label172
+  346 label *label173
+  347 op add :compute:i :compute:i 1
+  348 set :compute:x1 :compute:zx
+  349 op mul *tmp106 :compute:zx :compute:zx
+  350 op mul *tmp107 :compute:zy :compute:zy
+  351 op sub *tmp108 *tmp106 *tmp107
+  352 op add :compute:zx *tmp108 :compute:cx
+  353 op mul *tmp110 2 :compute:x1
+  354 op mul *tmp111 *tmp110 :compute:zy
+  355 op add :compute:zy *tmp111 :compute:cy
+  356 op len :compute:dist :compute:zx :compute:zy
+  357 jump *label174 lessThan :compute:dist 64
+  358 jump *label63 always
+  359 label *label174
+  360 label *label175
+  361 label *label176
+  362 op add :compute:i :compute:i 1
+  363 set :compute:x1 :compute:zx
+  364 op mul *tmp106 :compute:zx :compute:zx
+  365 op mul *tmp107 :compute:zy :compute:zy
+  366 op sub *tmp108 *tmp106 *tmp107
+  367 op add :compute:zx *tmp108 :compute:cx
+  368 op mul *tmp110 2 :compute:x1
+  369 op mul *tmp111 *tmp110 :compute:zy
+  370 op add :compute:zy *tmp111 :compute:cy
+  371 op len :compute:dist :compute:zx :compute:zy
+  372 jump *label177 lessThan :compute:dist 64
+  373 jump *label63 always
+  374 label *label177
+  375 label *label178
+  376 label *label179
+  377 op add :compute:i :compute:i 1
+  378 set :compute:x1 :compute:zx
+  379 op mul *tmp106 :compute:zx :compute:zx
+  380 op mul *tmp107 :compute:zy :compute:zy
+  381 op sub *tmp108 *tmp106 *tmp107
+  382 op add :compute:zx *tmp108 :compute:cx
+  383 op mul *tmp110 2 :compute:x1
+  384 op mul *tmp111 *tmp110 :compute:zy
+  385 op add :compute:zy *tmp111 :compute:cy
+  386 op len :compute:dist :compute:zx :compute:zy
+  387 jump *label180 lessThan :compute:dist 64
+  388 jump *label63 always
+  389 label *label180
+  390 label *label181
+  391 label *label182
+  392 op add :compute:i :compute:i 1
+  393 set :compute:x1 :compute:zx
+  394 op mul *tmp106 :compute:zx :compute:zx
+  395 op mul *tmp107 :compute:zy :compute:zy
+  396 op sub *tmp108 *tmp106 *tmp107
+  397 op add :compute:zx *tmp108 :compute:cx
+  398 op mul *tmp110 2 :compute:x1
+  399 op mul *tmp111 *tmp110 :compute:zy
+  400 op add :compute:zy *tmp111 :compute:cy
+  401 op len :compute:dist :compute:zx :compute:zy
+  402 jump *label183 lessThan :compute:dist 64
+  403 jump *label63 always
+  404 label *label183
+  405 label *label184
+  406 label *label185
+  407 op add :compute:i :compute:i 1
+  408 set :compute:x1 :compute:zx
+  409 op mul *tmp106 :compute:zx :compute:zx
+  410 op mul *tmp107 :compute:zy :compute:zy
+  411 op sub *tmp108 *tmp106 *tmp107
+  412 op add :compute:zx *tmp108 :compute:cx
+  413 op mul *tmp110 2 :compute:x1
+  414 op mul *tmp111 *tmp110 :compute:zy
+  415 op add :compute:zy *tmp111 :compute:cy
+  416 op len :compute:dist :compute:zx :compute:zy
+  417 jump *label186 lessThan :compute:dist 64
+  418 jump *label63 always
+  419 label *label186
+  420 label *label187
+  421 label *label188
+  422 op add :compute:i :compute:i 1
+  423 set :compute:x1 :compute:zx
+  424 op mul *tmp106 :compute:zx :compute:zx
+  425 op mul *tmp107 :compute:zy :compute:zy
+  426 op sub *tmp108 *tmp106 *tmp107
+  427 op add :compute:zx *tmp108 :compute:cx
+  428 op mul *tmp110 2 :compute:x1
+  429 op mul *tmp111 *tmp110 :compute:zy
+  430 op add :compute:zy *tmp111 :compute:cy
+  431 op len :compute:dist :compute:zx :compute:zy
+  432 jump *label189 lessThan :compute:dist 64
+  433 jump *label63 always
+  434 label *label189
+  435 label *label190
+  436 label *label191
+  437 op add :compute:i :compute:i 1
+  438 set :compute:x1 :compute:zx
+  439 op mul *tmp106 :compute:zx :compute:zx
+  440 op mul *tmp107 :compute:zy :compute:zy
+  441 op sub *tmp108 *tmp106 *tmp107
+  442 op add :compute:zx *tmp108 :compute:cx
+  443 op mul *tmp110 2 :compute:x1
+  444 op mul *tmp111 *tmp110 :compute:zy
+  445 op add :compute:zy *tmp111 :compute:cy
+  446 op len :compute:dist :compute:zx :compute:zy
+  447 jump *label192 lessThan :compute:dist 64
+  448 jump *label63 always
+  449 label *label192
+  450 label *label193
+  451 label *label194
+  452 op add :compute:i :compute:i 1
+  453 set :compute:x1 :compute:zx
+  454 op mul *tmp106 :compute:zx :compute:zx
+  455 op mul *tmp107 :compute:zy :compute:zy
+  456 op sub *tmp108 *tmp106 *tmp107
+  457 op add :compute:zx *tmp108 :compute:cx
+  458 op mul *tmp110 2 :compute:x1
+  459 op mul *tmp111 *tmp110 :compute:zy
+  460 op add :compute:zy *tmp111 :compute:cy
+  461 op len :compute:dist :compute:zx :compute:zy
+  462 jump *label195 lessThan :compute:dist 64
+  463 jump *label63 always
+  464 label *label195
+  465 label *label196
+  466 label *label197
+  467 op add :compute:i :compute:i 1
+  468 set :compute:x1 :compute:zx
+  469 op mul *tmp106 :compute:zx :compute:zx
+  470 op mul *tmp107 :compute:zy :compute:zy
+  471 op sub *tmp108 *tmp106 *tmp107
+  472 op add :compute:zx *tmp108 :compute:cx
+  473 op mul *tmp110 2 :compute:x1
+  474 op mul *tmp111 *tmp110 :compute:zy
+  475 op add :compute:zy *tmp111 :compute:cy
+  476 op len :compute:dist :compute:zx :compute:zy
+  477 jump *label198 lessThan :compute:dist 64
+  478 jump *label63 always
+  479 label *label198
+  480 label *label199
+  481 label *label200
+  482 op add :compute:i :compute:i 1
+  483 set :compute:x1 :compute:zx
+  484 op mul *tmp106 :compute:zx :compute:zx
+  485 op mul *tmp107 :compute:zy :compute:zy
+  486 op sub *tmp108 *tmp106 *tmp107
+  487 op add :compute:zx *tmp108 :compute:cx
+  488 op mul *tmp110 2 :compute:x1
+  489 op mul *tmp111 *tmp110 :compute:zy
+  490 op add :compute:zy *tmp111 :compute:cy
+  491 op len :compute:dist :compute:zx :compute:zy
+  492 jump *label201 lessThan :compute:dist 64
+  493 jump *label63 always
+  494 label *label201
+  495 label *label202
+  496 label *label203
+  497 op add :compute:i :compute:i 1
+  498 set :compute:x1 :compute:zx
+  499 op mul *tmp106 :compute:zx :compute:zx
+  500 op mul *tmp107 :compute:zy :compute:zy
+  501 op sub *tmp108 *tmp106 *tmp107
+  502 op add :compute:zx *tmp108 :compute:cx
+  503 op mul *tmp110 2 :compute:x1
+  504 op mul *tmp111 *tmp110 :compute:zy
+  505 op add :compute:zy *tmp111 :compute:cy
+  506 op len :compute:dist :compute:zx :compute:zy
+  507 jump *label204 lessThan :compute:dist 64
+  508 jump *label63 always
+  509 label *label204
+  510 label *label205
+  511 label *label206
+  512 op add :compute:i :compute:i 1
+  513 set :compute:x1 :compute:zx
+  514 op mul *tmp106 :compute:zx :compute:zx
+  515 op mul *tmp107 :compute:zy :compute:zy
+  516 op sub *tmp108 *tmp106 *tmp107
+  517 op add :compute:zx *tmp108 :compute:cx
+  518 op mul *tmp110 2 :compute:x1
+  519 op mul *tmp111 *tmp110 :compute:zy
+  520 op add :compute:zy *tmp111 :compute:cy
+  521 op len :compute:dist :compute:zx :compute:zy
+  522 jump *label207 lessThan :compute:dist 64
+  523 jump *label63 always
+  524 label *label207
+  525 label *label208
+  526 label *label209
+  527 op add :compute:i :compute:i 1
+  528 set :compute:x1 :compute:zx
+  529 op mul *tmp106 :compute:zx :compute:zx
+  530 op mul *tmp107 :compute:zy :compute:zy
+  531 op sub *tmp108 *tmp106 *tmp107
+  532 op add :compute:zx *tmp108 :compute:cx
+  533 op mul *tmp110 2 :compute:x1
+  534 op mul *tmp111 *tmp110 :compute:zy
+  535 op add :compute:zy *tmp111 :compute:cy
+  536 op len :compute:dist :compute:zx :compute:zy
+  537 jump *label210 lessThan :compute:dist 64
+  538 jump *label63 always
+  539 label *label210
+  540 label *label211
+  541 label *label212
+  542 op add :compute:i :compute:i 1
+  543 set :compute:x1 :compute:zx
+  544 op mul *tmp106 :compute:zx :compute:zx
+  545 op mul *tmp107 :compute:zy :compute:zy
+  546 op sub *tmp108 *tmp106 *tmp107
+  547 op add :compute:zx *tmp108 :compute:cx
+  548 op mul *tmp110 2 :compute:x1
+  549 op mul *tmp111 *tmp110 :compute:zy
+  550 op add :compute:zy *tmp111 :compute:cy
+  551 op len :compute:dist :compute:zx :compute:zy
+  552 jump *label213 lessThan :compute:dist 64
+  553 jump *label63 always
+  554 label *label213
+  555 label *label214
+  556 label *label215
+  557 op add :compute:i :compute:i 1
+  558 set :compute:x1 :compute:zx
+  559 op mul *tmp106 :compute:zx :compute:zx
+  560 op mul *tmp107 :compute:zy :compute:zy
+  561 op sub *tmp108 *tmp106 *tmp107
+  562 op add :compute:zx *tmp108 :compute:cx
+  563 op mul *tmp110 2 :compute:x1
+  564 op mul *tmp111 *tmp110 :compute:zy
+  565 op add :compute:zy *tmp111 :compute:cy
+  566 op len :compute:dist :compute:zx :compute:zy
+  567 jump *label216 lessThan :compute:dist 64
+  568 jump *label63 always
+  569 label *label216
+  570 label *label217
+  571 label *label218
+  572 op add :compute:i :compute:i 1
+  573 set :compute:x1 :compute:zx
+  574 op mul *tmp106 :compute:zx :compute:zx
+  575 op mul *tmp107 :compute:zy :compute:zy
+  576 op sub *tmp108 *tmp106 *tmp107
+  577 op add :compute:zx *tmp108 :compute:cx
+  578 op mul *tmp110 2 :compute:x1
+  579 op mul *tmp111 *tmp110 :compute:zy
+  580 op add :compute:zy *tmp111 :compute:cy
+  581 op len :compute:dist :compute:zx :compute:zy
+  582 jump *label219 lessThan :compute:dist 64
+  583 jump *label63 always
+  584 label *label219
+  585 label *label220
+  586 label *label221
+  587 op add :compute:i :compute:i 1
+  588 set :compute:x1 :compute:zx
+  589 op mul *tmp106 :compute:zx :compute:zx
+  590 op mul *tmp107 :compute:zy :compute:zy
+  591 op sub *tmp108 *tmp106 *tmp107
+  592 op add :compute:zx *tmp108 :compute:cx
+  593 op mul *tmp110 2 :compute:x1
+  594 op mul *tmp111 *tmp110 :compute:zy
+  595 op add :compute:zy *tmp111 :compute:cy
+  596 op len :compute:dist :compute:zx :compute:zy
+  597 jump *label222 lessThan :compute:dist 64
+  598 jump *label63 always
+  599 label *label222
+  600 label *label223
+  601 label *label224
+  602 op add :compute:i :compute:i 1
+  603 set :compute:x1 :compute:zx
+  604 op mul *tmp106 :compute:zx :compute:zx
+  605 op mul *tmp107 :compute:zy :compute:zy
+  606 op sub *tmp108 *tmp106 *tmp107
+  607 op add :compute:zx *tmp108 :compute:cx
+  608 op mul *tmp110 2 :compute:x1
+  609 op mul *tmp111 *tmp110 :compute:zy
+  610 op add :compute:zy *tmp111 :compute:cy
+  611 op len :compute:dist :compute:zx :compute:zy
+  612 jump *label225 lessThan :compute:dist 64
+  613 jump *label63 always
+  614 label *label225
+  615 label *label226
+  616 label *label227
+  617 op add :compute:i :compute:i 1
+  618 set :compute:x1 :compute:zx
+  619 op mul *tmp106 :compute:zx :compute:zx
+  620 op mul *tmp107 :compute:zy :compute:zy
+  621 op sub *tmp108 *tmp106 *tmp107
+  622 op add :compute:zx *tmp108 :compute:cx
+  623 op mul *tmp110 2 :compute:x1
+  624 op mul *tmp111 *tmp110 :compute:zy
+  625 op add :compute:zy *tmp111 :compute:cy
+  626 op len :compute:dist :compute:zx :compute:zy
+  627 jump *label228 lessThan :compute:dist 64
+  628 jump *label63 always
+  629 label *label228
+  630 label *label229
+  631 label *label230
+  632 op add :compute:i :compute:i 1
+  633 set :compute:x1 :compute:zx
+  634 op mul *tmp106 :compute:zx :compute:zx
+  635 op mul *tmp107 :compute:zy :compute:zy
+  636 op sub *tmp108 *tmp106 *tmp107
+  637 op add :compute:zx *tmp108 :compute:cx
+  638 op mul *tmp110 2 :compute:x1
+  639 op mul *tmp111 *tmp110 :compute:zy
+  640 op add :compute:zy *tmp111 :compute:cy
+  641 op len :compute:dist :compute:zx :compute:zy
+  642 jump *label231 lessThan :compute:dist 64
+  643 jump *label63 always
+  644 label *label231
+  645 label *label232
+  646 label *label233
+  647 op add :compute:i :compute:i 1
+  648 set :compute:x1 :compute:zx
+  649 op mul *tmp106 :compute:zx :compute:zx
+  650 op mul *tmp107 :compute:zy :compute:zy
+  651 op sub *tmp108 *tmp106 *tmp107
+  652 op add :compute:zx *tmp108 :compute:cx
+  653 op mul *tmp110 2 :compute:x1
+  654 op mul *tmp111 *tmp110 :compute:zy
+  655 op add :compute:zy *tmp111 :compute:cy
+  656 op len :compute:dist :compute:zx :compute:zy
+  657 jump *label234 lessThan :compute:dist 64
+  658 jump *label63 always
+  659 label *label234
+  660 label *label235
+  661 label *label236
+  662 op add :compute:i :compute:i 1
+  663 set :compute:x1 :compute:zx
+  664 op mul *tmp106 :compute:zx :compute:zx
+  665 op mul *tmp107 :compute:zy :compute:zy
+  666 op sub *tmp108 *tmp106 *tmp107
+  667 op add :compute:zx *tmp108 :compute:cx
+  668 op mul *tmp110 2 :compute:x1
+  669 op mul *tmp111 *tmp110 :compute:zy
+  670 op add :compute:zy *tmp111 :compute:cy
+  671 op len :compute:dist :compute:zx :compute:zy
+  672 jump *label237 lessThan :compute:dist 64
+  673 jump *label63 always
+  674 label *label237
+  675 label *label238
+  676 label *label239
+  677 op add :compute:i :compute:i 1
+  678 set :compute:x1 :compute:zx
+  679 op mul *tmp106 :compute:zx :compute:zx
+  680 op mul *tmp107 :compute:zy :compute:zy
+  681 op sub *tmp108 *tmp106 *tmp107
+  682 op add :compute:zx *tmp108 :compute:cx
+  683 op mul *tmp110 2 :compute:x1
+  684 op mul *tmp111 *tmp110 :compute:zy
+  685 op add :compute:zy *tmp111 :compute:cy
+  686 op len :compute:dist :compute:zx :compute:zy
+  687 jump *label240 lessThan :compute:dist 64
+  688 jump *label63 always
+  689 label *label240
+  690 label *label241
+  691 label *label242
+  692 op add :compute:i :compute:i 1
+  693 set :compute:x1 :compute:zx
+  694 op mul *tmp106 :compute:zx :compute:zx
+  695 op mul *tmp107 :compute:zy :compute:zy
+  696 op sub *tmp108 *tmp106 *tmp107
+  697 op add :compute:zx *tmp108 :compute:cx
+  698 op mul *tmp110 2 :compute:x1
+  699 op mul *tmp111 *tmp110 :compute:zy
+  700 op add :compute:zy *tmp111 :compute:cy
+  701 op len :compute:dist :compute:zx :compute:zy
+  702 jump *label243 lessThan :compute:dist 64
+  703 jump *label63 always
+  704 label *label243
+  705 label *label244
+  706 label *label245
+  707 op add :compute:i :compute:i 1
+  708 set :compute:x1 :compute:zx
+  709 op mul *tmp106 :compute:zx :compute:zx
+  710 op mul *tmp107 :compute:zy :compute:zy
+  711 op sub *tmp108 *tmp106 *tmp107
+  712 op add :compute:zx *tmp108 :compute:cx
+  713 op mul *tmp110 2 :compute:x1
+  714 op mul *tmp111 *tmp110 :compute:zy
+  715 op add :compute:zy *tmp111 :compute:cy
+  716 op len :compute:dist :compute:zx :compute:zy
+  717 jump *label246 lessThan :compute:dist 64
+  718 jump *label63 always
+  719 label *label246
+  720 label *label247
+  721 label *label248
+  722 op add :compute:i :compute:i 1
+  723 set :compute:x1 :compute:zx
+  724 op mul *tmp106 :compute:zx :compute:zx
+  725 op mul *tmp107 :compute:zy :compute:zy
+  726 op sub *tmp108 *tmp106 *tmp107
+  727 op add :compute:zx *tmp108 :compute:cx
+  728 op mul *tmp110 2 :compute:x1
+  729 op mul *tmp111 *tmp110 :compute:zy
+  730 op add :compute:zy *tmp111 :compute:cy
+  731 op len :compute:dist :compute:zx :compute:zy
+  732 jump *label249 lessThan :compute:dist 64
+  733 jump *label63 always
+  734 label *label249
+  735 label *label250
+  736 label *label251
+  737 op add :compute:i :compute:i 1
+  738 set :compute:x1 :compute:zx
+  739 op mul *tmp106 :compute:zx :compute:zx
+  740 op mul *tmp107 :compute:zy :compute:zy
+  741 op sub *tmp108 *tmp106 *tmp107
+  742 op add :compute:zx *tmp108 :compute:cx
+  743 op mul *tmp110 2 :compute:x1
+  744 op mul *tmp111 *tmp110 :compute:zy
+  745 op add :compute:zy *tmp111 :compute:cy
+  746 op len :compute:dist :compute:zx :compute:zy
+  747 jump *label252 lessThan :compute:dist 64
+  748 jump *label63 always
+  749 label *label252
+  750 label *label253
+  751 label *label254
+  752 op add :compute:i :compute:i 1
+  753 set :compute:x1 :compute:zx
+  754 op mul *tmp106 :compute:zx :compute:zx
+  755 op mul *tmp107 :compute:zy :compute:zy
+  756 op sub *tmp108 *tmp106 *tmp107
+  757 op add :compute:zx *tmp108 :compute:cx
+  758 op mul *tmp110 2 :compute:x1
+  759 op mul *tmp111 *tmp110 :compute:zy
+  760 op add :compute:zy *tmp111 :compute:cy
+  761 op len :compute:dist :compute:zx :compute:zy
+  762 jump *label255 lessThan :compute:dist 64
+  763 jump *label63 always
+  764 label *label255
+  765 label *label256
+  766 label *label257
+  767 op add :compute:i :compute:i 1
+  768 set :compute:x1 :compute:zx
+  769 op mul *tmp106 :compute:zx :compute:zx
+  770 op mul *tmp107 :compute:zy :compute:zy
+  771 op sub *tmp108 *tmp106 *tmp107
+  772 op add :compute:zx *tmp108 :compute:cx
+  773 op mul *tmp110 2 :compute:x1
+  774 op mul *tmp111 *tmp110 :compute:zy
+  775 op add :compute:zy *tmp111 :compute:cy
+  776 op len :compute:dist :compute:zx :compute:zy
+  777 jump *label258 lessThan :compute:dist 64
+  778 jump *label63 always
+  779 label *label258
+  780 label *label259
+  781 label *label260
+  782 op add :compute:i :compute:i 1
+  783 set :compute:x1 :compute:zx
+  784 op mul *tmp106 :compute:zx :compute:zx
+  785 op mul *tmp107 :compute:zy :compute:zy
+  786 op sub *tmp108 *tmp106 *tmp107
+  787 op add :compute:zx *tmp108 :compute:cx
+  788 op mul *tmp110 2 :compute:x1
+  789 op mul *tmp111 *tmp110 :compute:zy
+  790 op add :compute:zy *tmp111 :compute:cy
+  791 op len :compute:dist :compute:zx :compute:zy
+  792 jump *label261 lessThan :compute:dist 64
+  793 jump *label63 always
+  794 label *label261
+  795 label *label262
+  796 label *label263
+  797 op add :compute:i :compute:i 1
+  798 set :compute:x1 :compute:zx
+  799 op mul *tmp106 :compute:zx :compute:zx
+  800 op mul *tmp107 :compute:zy :compute:zy
+  801 op sub *tmp108 *tmp106 *tmp107
+  802 op add :compute:zx *tmp108 :compute:cx
+  803 op mul *tmp110 2 :compute:x1
+  804 op mul *tmp111 *tmp110 :compute:zy
+  805 op add :compute:zy *tmp111 :compute:cy
+  806 op len :compute:dist :compute:zx :compute:zy
+  807 jump *label264 lessThan :compute:dist 64
+  808 jump *label63 always
+  809 label *label264
+  810 label *label265
+  811 label *label266
+  812 op add :compute:i :compute:i 1
+  813 set :compute:x1 :compute:zx
+  814 op mul *tmp106 :compute:zx :compute:zx
+  815 op mul *tmp107 :compute:zy :compute:zy
+  816 op sub *tmp108 *tmp106 *tmp107
+  817 op add :compute:zx *tmp108 :compute:cx
+  818 op mul *tmp110 2 :compute:x1
+  819 op mul *tmp111 *tmp110 :compute:zy
+  820 op add :compute:zy *tmp111 :compute:cy
+  821 op len :compute:dist :compute:zx :compute:zy
+  822 jump *label267 lessThan :compute:dist 64
+  823 jump *label63 always
+  824 label *label267
+  825 label *label268
+  826 label *label269
+  827 op add :compute:i :compute:i 1
+  828 set :compute:x1 :compute:zx
+  829 op mul *tmp106 :compute:zx :compute:zx
+  830 op mul *tmp107 :compute:zy :compute:zy
+  831 op sub *tmp108 *tmp106 *tmp107
+  832 op add :compute:zx *tmp108 :compute:cx
+  833 op mul *tmp110 2 :compute:x1
+  834 op mul *tmp111 *tmp110 :compute:zy
+  835 op add :compute:zy *tmp111 :compute:cy
+  836 op len :compute:dist :compute:zx :compute:zy
+  837 jump *label270 lessThan :compute:dist 64
+  838 jump *label63 always
+  839 label *label270
+  840 label *label271
+  841 label *label272
+  842 op add :compute:i :compute:i 1
+  843 set :compute:x1 :compute:zx
+  844 op mul *tmp106 :compute:zx :compute:zx
+  845 op mul *tmp107 :compute:zy :compute:zy
+  846 op sub *tmp108 *tmp106 *tmp107
+  847 op add :compute:zx *tmp108 :compute:cx
+  848 op mul *tmp110 2 :compute:x1
+  849 op mul *tmp111 *tmp110 :compute:zy
+  850 op add :compute:zy *tmp111 :compute:cy
+  851 op len :compute:dist :compute:zx :compute:zy
+  852 jump *label273 lessThan :compute:dist 64
+  853 jump *label63 always
+  854 label *label273
+  855 label *label274
+  856 label *label275
+  857 op add :compute:i :compute:i 1
+  858 set :compute:x1 :compute:zx
+  859 op mul *tmp106 :compute:zx :compute:zx
+  860 op mul *tmp107 :compute:zy :compute:zy
+  861 op sub *tmp108 *tmp106 *tmp107
+  862 op add :compute:zx *tmp108 :compute:cx
+  863 op mul *tmp110 2 :compute:x1
+  864 op mul *tmp111 *tmp110 :compute:zy
+  865 op add :compute:zy *tmp111 :compute:cy
+  866 op len :compute:dist :compute:zx :compute:zy
+  867 jump *label276 lessThan :compute:dist 64
+  868 jump *label63 always
+  869 label *label276
+  870 label *label277
+  871 label *label278
+  872 op add :compute:i :compute:i 1
+  873 set :compute:x1 :compute:zx
+  874 op mul *tmp106 :compute:zx :compute:zx
+  875 op mul *tmp107 :compute:zy :compute:zy
+  876 op sub *tmp108 *tmp106 *tmp107
+  877 op add :compute:zx *tmp108 :compute:cx
+  878 op mul *tmp110 2 :compute:x1
+  879 op mul *tmp111 *tmp110 :compute:zy
+  880 op add :compute:zy *tmp111 :compute:cy
+  881 op len :compute:dist :compute:zx :compute:zy
+  882 jump *label279 lessThan :compute:dist 64
+  883 jump *label63 always
+  884 label *label279
+  885 label *label280
+  886 label *label281
+  887 op add :compute:i :compute:i 1
+  888 set :compute:x1 :compute:zx
+  889 op mul *tmp106 :compute:zx :compute:zx
+  890 op mul *tmp107 :compute:zy :compute:zy
+  891 op sub *tmp108 *tmp106 *tmp107
+  892 op add :compute:zx *tmp108 :compute:cx
+  893 op mul *tmp110 2 :compute:x1
+  894 op mul *tmp111 *tmp110 :compute:zy
+  895 op add :compute:zy *tmp111 :compute:cy
+  896 op len :compute:dist :compute:zx :compute:zy
+  897 jump *label282 lessThan :compute:dist 64
+  898 jump *label63 always
+  899 label *label282
+  900 label *label283
+  901 label *label284
+  902 op add :compute:i :compute:i 1
+  903 set :compute:x1 :compute:zx
+  904 op mul *tmp106 :compute:zx :compute:zx
+  905 op mul *tmp107 :compute:zy :compute:zy
+  906 op sub *tmp108 *tmp106 *tmp107
+  907 op add :compute:zx *tmp108 :compute:cx
+  908 op mul *tmp110 2 :compute:x1
+  909 op mul *tmp111 *tmp110 :compute:zy
+  910 op add :compute:zy *tmp111 :compute:cy
+  911 op len :compute:dist :compute:zx :compute:zy
+  912 jump *label285 lessThan :compute:dist 64
+  913 jump *label63 always
+  914 label *label285
+  915 label *label286
+  916 label *label287
+  917 op add :compute:i :compute:i 1
+  918 set :compute:x1 :compute:zx
+  919 op mul *tmp106 :compute:zx :compute:zx
+  920 op mul *tmp107 :compute:zy :compute:zy
+  921 op sub *tmp108 *tmp106 *tmp107
+  922 op add :compute:zx *tmp108 :compute:cx
+  923 op mul *tmp110 2 :compute:x1
+  924 op mul *tmp111 *tmp110 :compute:zy
+  925 op add :compute:zy *tmp111 :compute:cy
+  926 op len :compute:dist :compute:zx :compute:zy
+  927 jump *label288 lessThan :compute:dist 64
+  928 jump *label63 always
+  929 label *label288
+  930 label *label289
+  931 label *label290
+  932 op add :compute:i :compute:i 1
+  933 set :compute:x1 :compute:zx
+  934 op mul *tmp106 :compute:zx :compute:zx
+  935 op mul *tmp107 :compute:zy :compute:zy
+  936 op sub *tmp108 *tmp106 *tmp107
+  937 op add :compute:zx *tmp108 :compute:cx
+  938 op mul *tmp110 2 :compute:x1
+  939 op mul *tmp111 *tmp110 :compute:zy
+  940 op add :compute:zy *tmp111 :compute:cy
+  941 op len :compute:dist :compute:zx :compute:zy
+  942 jump *label291 lessThan :compute:dist 64
+  943 jump *label63 always
+  944 label *label291
+  945 label *label292
+  946 label *label293
+  947 op add :compute:i :compute:i 1
+  948 set :compute:x1 :compute:zx
+  949 op mul *tmp106 :compute:zx :compute:zx
+  950 op mul *tmp107 :compute:zy :compute:zy
+  951 op sub *tmp108 *tmp106 *tmp107
+  952 op add :compute:zx *tmp108 :compute:cx
+  953 op mul *tmp110 2 :compute:x1
+  954 op mul *tmp111 *tmp110 :compute:zy
+  955 op add :compute:zy *tmp111 :compute:cy
+  956 op len :compute:dist :compute:zx :compute:zy
+  957 jump *label294 lessThan :compute:dist 64
+  958 jump *label63 always
+  959 label *label294
+  960 label *label295
+  961 label *label296
+  962 op add :compute:i :compute:i 1
+  963 set :compute:x1 :compute:zx
+  964 op mul *tmp106 :compute:zx :compute:zx
+  965 op mul *tmp107 :compute:zy :compute:zy
+  966 op sub *tmp108 *tmp106 *tmp107
+  967 op add :compute:zx *tmp108 :compute:cx
+  968 op mul *tmp110 2 :compute:x1
+  969 op mul *tmp111 *tmp110 :compute:zy
+  970 op add :compute:zy *tmp111 :compute:cy
+  971 op len :compute:dist :compute:zx :compute:zy
+  972 jump *label297 lessThan :compute:dist 64
+  973 jump *label63 always
+  974 label *label297
+  975 label *label298
+  976 label *label299
+  977 op add :compute:i :compute:i 1
+  978 set :compute:x1 :compute:zx
+  979 op mul *tmp106 :compute:zx :compute:zx
+  980 op mul *tmp107 :compute:zy :compute:zy
+  981 op sub *tmp108 *tmp106 *tmp107
+  982 op add :compute:zx *tmp108 :compute:cx
+  983 op mul *tmp110 2 :compute:x1
+  984 op mul *tmp111 *tmp110 :compute:zy
+  985 op add :compute:zy *tmp111 :compute:cy
+  986 op len :compute:dist :compute:zx :compute:zy
+  987 jump *label300 lessThan :compute:dist 64
+  988 jump *label63 always
+  989 label *label300
+  990 label *label301
+  991 label *label302
+  992 op add :compute:i :compute:i 1
+  993 set :compute:x1 :compute:zx
+  994 op mul *tmp106 :compute:zx :compute:zx
+  995 op mul *tmp107 :compute:zy :compute:zy
+  996 op sub *tmp108 *tmp106 *tmp107
+  997 op add :compute:zx *tmp108 :compute:cx
+  998 op mul *tmp110 2 :compute:x1
+  999 op mul *tmp111 *tmp110 :compute:zy
+ 1000 op add :compute:zy *tmp111 :compute:cy
+ 1001 op len :compute:dist :compute:zx :compute:zy
+ 1002 jump *label303 lessThan :compute:dist 64
+ 1003 jump *label63 always
+ 1004 label *label303
+ 1005 label *label304
+ 1006 label *label305
+ 1007 op add :compute:i :compute:i 1
+ 1008 set :compute:x1 :compute:zx
+ 1009 op mul *tmp106 :compute:zx :compute:zx
+ 1010 op mul *tmp107 :compute:zy :compute:zy
+ 1011 op sub *tmp108 *tmp106 *tmp107
+ 1012 op add :compute:zx *tmp108 :compute:cx
+ 1013 op mul *tmp110 2 :compute:x1
+ 1014 op mul *tmp111 *tmp110 :compute:zy
+ 1015 op add :compute:zy *tmp111 :compute:cy
+ 1016 op len :compute:dist :compute:zx :compute:zy
+ 1017 jump *label306 lessThan :compute:dist 64
+ 1018 jump *label63 always
+ 1019 label *label306
+ 1020 label *label307
+ 1021 label *label308
+ 1022 op add :compute:i :compute:i 1
+ 1023 set :compute:x1 :compute:zx
+ 1024 op mul *tmp106 :compute:zx :compute:zx
+ 1025 op mul *tmp107 :compute:zy :compute:zy
+ 1026 op sub *tmp108 *tmp106 *tmp107
+ 1027 op add :compute:zx *tmp108 :compute:cx
+ 1028 op mul *tmp110 2 :compute:x1
+ 1029 op mul *tmp111 *tmp110 :compute:zy
+ 1030 op add :compute:zy *tmp111 :compute:cy
+ 1031 op len :compute:dist :compute:zx :compute:zy
+ 1032 jump *label309 lessThan :compute:dist 64
+ 1033 jump *label63 always
+ 1034 label *label309
+ 1035 label *label310
+ 1036 label *label311
+ 1037 op add :compute:i :compute:i 1
+ 1038 set :compute:x1 :compute:zx
+ 1039 op mul *tmp106 :compute:zx :compute:zx
+ 1040 op mul *tmp107 :compute:zy :compute:zy
+ 1041 op sub *tmp108 *tmp106 *tmp107
+ 1042 op add :compute:zx *tmp108 :compute:cx
+ 1043 op mul *tmp110 2 :compute:x1
+ 1044 op mul *tmp111 *tmp110 :compute:zy
+ 1045 op add :compute:zy *tmp111 :compute:cy
+ 1046 op len :compute:dist :compute:zx :compute:zy
+ 1047 jump *label312 lessThan :compute:dist 64
+ 1048 jump *label63 always
+ 1049 label *label312
+ 1050 label *label313
+ 1051 label *label314
+ 1052 op add :compute:i :compute:i 1
+ 1053 set :compute:x1 :compute:zx
+ 1054 op mul *tmp106 :compute:zx :compute:zx
+ 1055 op mul *tmp107 :compute:zy :compute:zy
+ 1056 op sub *tmp108 *tmp106 *tmp107
+ 1057 op add :compute:zx *tmp108 :compute:cx
+ 1058 op mul *tmp110 2 :compute:x1
+ 1059 op mul *tmp111 *tmp110 :compute:zy
+ 1060 op add :compute:zy *tmp111 :compute:cy
+ 1061 op len :compute:dist :compute:zx :compute:zy
+ 1062 jump *label315 lessThan :compute:dist 64
+ 1063 jump *label63 always
+ 1064 label *label315
+ 1065 label *label316
+ 1066 label *label317
+ 1067 op add :compute:i :compute:i 1
+ 1068 set :compute:x1 :compute:zx
+ 1069 op mul *tmp106 :compute:zx :compute:zx
+ 1070 op mul *tmp107 :compute:zy :compute:zy
+ 1071 op sub *tmp108 *tmp106 *tmp107
+ 1072 op add :compute:zx *tmp108 :compute:cx
+ 1073 op mul *tmp110 2 :compute:x1
+ 1074 op mul *tmp111 *tmp110 :compute:zy
+ 1075 op add :compute:zy *tmp111 :compute:cy
+ 1076 op len :compute:dist :compute:zx :compute:zy
+ 1077 jump *label318 lessThan :compute:dist 64
+ 1078 jump *label63 always
+ 1079 label *label318
+ 1080 label *label319
+ 1081 label *label320
+ 1082 op add :compute:i :compute:i 1
+ 1083 set :compute:x1 :compute:zx
+ 1084 op mul *tmp106 :compute:zx :compute:zx
+ 1085 op mul *tmp107 :compute:zy :compute:zy
+ 1086 op sub *tmp108 *tmp106 *tmp107
+ 1087 op add :compute:zx *tmp108 :compute:cx
+ 1088 op mul *tmp110 2 :compute:x1
+ 1089 op mul *tmp111 *tmp110 :compute:zy
+ 1090 op add :compute:zy *tmp111 :compute:cy
+ 1091 op len :compute:dist :compute:zx :compute:zy
+ 1092 jump *label321 lessThan :compute:dist 64
+ 1093 jump *label63 always
+ 1094 label *label321
+ 1095 label *label322
+ 1096 label *label323
+ 1097 op add :compute:i :compute:i 1
+ 1098 set :compute:x1 :compute:zx
+ 1099 op mul *tmp106 :compute:zx :compute:zx
+ 1100 op mul *tmp107 :compute:zy :compute:zy
+ 1101 op sub *tmp108 *tmp106 *tmp107
+ 1102 op add :compute:zx *tmp108 :compute:cx
+ 1103 op mul *tmp110 2 :compute:x1
+ 1104 op mul *tmp111 *tmp110 :compute:zy
+ 1105 op add :compute:zy *tmp111 :compute:cy
+ 1106 op len :compute:dist :compute:zx :compute:zy
+ 1107 jump *label324 lessThan :compute:dist 64
+ 1108 jump *label63 always
+ 1109 label *label324
+ 1110 label *label325
+ 1111 label *label326
+ 1112 op add :compute:i :compute:i 1
+ 1113 label *label63
  1114 jump *label66 lessThanEq .PALETTE 1
  1115 jump *label66 greaterThanEq :compute:i 63
  1116 op log *tmp118 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   179 label *label138
   180 label *label139
   181 label *label140
-    * op add :compute:i :compute:i 1
+  182 op add :compute:i 0 1
   183 set :compute:x1 :compute:zx
   184 op mul *tmp106 :compute:zx :compute:zx
   185 op mul *tmp107 :compute:zy :compute:zy
 
   194 label *label141
   195 label *label142
   196 label *label143
-    * op add :compute:i :compute:i 1
+  197 op add :compute:i 1 1
   198 set :compute:x1 :compute:zx
   199 op mul *tmp106 :compute:zx :compute:zx
   200 op mul *tmp107 :compute:zy :compute:zy
 
   209 label *label144
   210 label *label145
   211 label *label146
-    * op add :compute:i :compute:i 1
+  212 op add :compute:i 2 1
   213 set :compute:x1 :compute:zx
   214 op mul *tmp106 :compute:zx :compute:zx
   215 op mul *tmp107 :compute:zy :compute:zy
 
   224 label *label147
   225 label *label148
   226 label *label149
-    * op add :compute:i :compute:i 1
+  227 op add :compute:i 3 1
   228 set :compute:x1 :compute:zx
   229 op mul *tmp106 :compute:zx :compute:zx
   230 op mul *tmp107 :compute:zy :compute:zy
 
   239 label *label150
   240 label *label151
   241 label *label152
-    * op add :compute:i :compute:i 1
+  242 op add :compute:i 4 1
   243 set :compute:x1 :compute:zx
   244 op mul *tmp106 :compute:zx :compute:zx
   245 op mul *tmp107 :compute:zy :compute:zy
 
   254 label *label153
   255 label *label154
   256 label *label155
-    * op add :compute:i :compute:i 1
+  257 op add :compute:i 5 1
   258 set :compute:x1 :compute:zx
   259 op mul *tmp106 :compute:zx :compute:zx
   260 op mul *tmp107 :compute:zy :compute:zy
 
   269 label *label156
   270 label *label157
   271 label *label158
-    * op add :compute:i :compute:i 1
+  272 op add :compute:i 6 1
   273 set :compute:x1 :compute:zx
   274 op mul *tmp106 :compute:zx :compute:zx
   275 op mul *tmp107 :compute:zy :compute:zy
 
   284 label *label159
   285 label *label160
   286 label *label161
-    * op add :compute:i :compute:i 1
+  287 op add :compute:i 7 1
   288 set :compute:x1 :compute:zx
   289 op mul *tmp106 :compute:zx :compute:zx
   290 op mul *tmp107 :compute:zy :compute:zy
 
   299 label *label162
   300 label *label163
   301 label *label164
-    * op add :compute:i :compute:i 1
+  302 op add :compute:i 8 1
   303 set :compute:x1 :compute:zx
   304 op mul *tmp106 :compute:zx :compute:zx
   305 op mul *tmp107 :compute:zy :compute:zy
 
   314 label *label165
   315 label *label166
   316 label *label167
-    * op add :compute:i :compute:i 1
+  317 op add :compute:i 9 1
   318 set :compute:x1 :compute:zx
   319 op mul *tmp106 :compute:zx :compute:zx
   320 op mul *tmp107 :compute:zy :compute:zy
 
   329 label *label168
   330 label *label169
   331 label *label170
-    * op add :compute:i :compute:i 1
+  332 op add :compute:i 10 1
   333 set :compute:x1 :compute:zx
   334 op mul *tmp106 :compute:zx :compute:zx
   335 op mul *tmp107 :compute:zy :compute:zy
 
   344 label *label171
   345 label *label172
   346 label *label173
-    * op add :compute:i :compute:i 1
+  347 op add :compute:i 11 1
   348 set :compute:x1 :compute:zx
   349 op mul *tmp106 :compute:zx :compute:zx
   350 op mul *tmp107 :compute:zy :compute:zy
 
   359 label *label174
   360 label *label175
   361 label *label176
-    * op add :compute:i :compute:i 1
+  362 op add :compute:i 12 1
   363 set :compute:x1 :compute:zx
   364 op mul *tmp106 :compute:zx :compute:zx
   365 op mul *tmp107 :compute:zy :compute:zy
 
   374 label *label177
   375 label *label178
   376 label *label179
-    * op add :compute:i :compute:i 1
+  377 op add :compute:i 13 1
   378 set :compute:x1 :compute:zx
   379 op mul *tmp106 :compute:zx :compute:zx
   380 op mul *tmp107 :compute:zy :compute:zy
 
   389 label *label180
   390 label *label181
   391 label *label182
-    * op add :compute:i :compute:i 1
+  392 op add :compute:i 14 1
   393 set :compute:x1 :compute:zx
   394 op mul *tmp106 :compute:zx :compute:zx
   395 op mul *tmp107 :compute:zy :compute:zy
 
   404 label *label183
   405 label *label184
   406 label *label185
-    * op add :compute:i :compute:i 1
+  407 op add :compute:i 15 1
   408 set :compute:x1 :compute:zx
   409 op mul *tmp106 :compute:zx :compute:zx
   410 op mul *tmp107 :compute:zy :compute:zy
 
   419 label *label186
   420 label *label187
   421 label *label188
-    * op add :compute:i :compute:i 1
+  422 op add :compute:i 16 1
   423 set :compute:x1 :compute:zx
   424 op mul *tmp106 :compute:zx :compute:zx
   425 op mul *tmp107 :compute:zy :compute:zy
 
   434 label *label189
   435 label *label190
   436 label *label191
-    * op add :compute:i :compute:i 1
+  437 op add :compute:i 17 1
   438 set :compute:x1 :compute:zx
   439 op mul *tmp106 :compute:zx :compute:zx
   440 op mul *tmp107 :compute:zy :compute:zy
 
   449 label *label192
   450 label *label193
   451 label *label194
-    * op add :compute:i :compute:i 1
+  452 op add :compute:i 18 1
   453 set :compute:x1 :compute:zx
   454 op mul *tmp106 :compute:zx :compute:zx
   455 op mul *tmp107 :compute:zy :compute:zy
 
   464 label *label195
   465 label *label196
   466 label *label197
-    * op add :compute:i :compute:i 1
+  467 op add :compute:i 19 1
   468 set :compute:x1 :compute:zx
   469 op mul *tmp106 :compute:zx :compute:zx
   470 op mul *tmp107 :compute:zy :compute:zy
 
   479 label *label198
   480 label *label199
   481 label *label200
-    * op add :compute:i :compute:i 1
+  482 op add :compute:i 20 1
   483 set :compute:x1 :compute:zx
   484 op mul *tmp106 :compute:zx :compute:zx
   485 op mul *tmp107 :compute:zy :compute:zy
 
   494 label *label201
   495 label *label202
   496 label *label203
-    * op add :compute:i :compute:i 1
+  497 op add :compute:i 21 1
   498 set :compute:x1 :compute:zx
   499 op mul *tmp106 :compute:zx :compute:zx
   500 op mul *tmp107 :compute:zy :compute:zy
 
   509 label *label204
   510 label *label205
   511 label *label206
-    * op add :compute:i :compute:i 1
+  512 op add :compute:i 22 1
   513 set :compute:x1 :compute:zx
   514 op mul *tmp106 :compute:zx :compute:zx
   515 op mul *tmp107 :compute:zy :compute:zy
 
   524 label *label207
   525 label *label208
   526 label *label209
-    * op add :compute:i :compute:i 1
+  527 op add :compute:i 23 1
   528 set :compute:x1 :compute:zx
   529 op mul *tmp106 :compute:zx :compute:zx
   530 op mul *tmp107 :compute:zy :compute:zy
 
   539 label *label210
   540 label *label211
   541 label *label212
-    * op add :compute:i :compute:i 1
+  542 op add :compute:i 24 1
   543 set :compute:x1 :compute:zx
   544 op mul *tmp106 :compute:zx :compute:zx
   545 op mul *tmp107 :compute:zy :compute:zy
 
   554 label *label213
   555 label *label214
   556 label *label215
-    * op add :compute:i :compute:i 1
+  557 op add :compute:i 25 1
   558 set :compute:x1 :compute:zx
   559 op mul *tmp106 :compute:zx :compute:zx
   560 op mul *tmp107 :compute:zy :compute:zy
 
   569 label *label216
   570 label *label217
   571 label *label218
-    * op add :compute:i :compute:i 1
+  572 op add :compute:i 26 1
   573 set :compute:x1 :compute:zx
   574 op mul *tmp106 :compute:zx :compute:zx
   575 op mul *tmp107 :compute:zy :compute:zy
 
   584 label *label219
   585 label *label220
   586 label *label221
-    * op add :compute:i :compute:i 1
+  587 op add :compute:i 27 1
   588 set :compute:x1 :compute:zx
   589 op mul *tmp106 :compute:zx :compute:zx
   590 op mul *tmp107 :compute:zy :compute:zy
 
   599 label *label222
   600 label *label223
   601 label *label224
-    * op add :compute:i :compute:i 1
+  602 op add :compute:i 28 1
   603 set :compute:x1 :compute:zx
   604 op mul *tmp106 :compute:zx :compute:zx
   605 op mul *tmp107 :compute:zy :compute:zy
 
   614 label *label225
   615 label *label226
   616 label *label227
-    * op add :compute:i :compute:i 1
+  617 op add :compute:i 29 1
   618 set :compute:x1 :compute:zx
   619 op mul *tmp106 :compute:zx :compute:zx
   620 op mul *tmp107 :compute:zy :compute:zy
 
   629 label *label228
   630 label *label229
   631 label *label230
-    * op add :compute:i :compute:i 1
+  632 op add :compute:i 30 1
   633 set :compute:x1 :compute:zx
   634 op mul *tmp106 :compute:zx :compute:zx
   635 op mul *tmp107 :compute:zy :compute:zy
 
   644 label *label231
   645 label *label232
   646 label *label233
-    * op add :compute:i :compute:i 1
+  647 op add :compute:i 31 1
   648 set :compute:x1 :compute:zx
   649 op mul *tmp106 :compute:zx :compute:zx
   650 op mul *tmp107 :compute:zy :compute:zy
 
   659 label *label234
   660 label *label235
   661 label *label236
-    * op add :compute:i :compute:i 1
+  662 op add :compute:i 32 1
   663 set :compute:x1 :compute:zx
   664 op mul *tmp106 :compute:zx :compute:zx
   665 op mul *tmp107 :compute:zy :compute:zy
 
   674 label *label237
   675 label *label238
   676 label *label239
-    * op add :compute:i :compute:i 1
+  677 op add :compute:i 33 1
   678 set :compute:x1 :compute:zx
   679 op mul *tmp106 :compute:zx :compute:zx
   680 op mul *tmp107 :compute:zy :compute:zy
 
   689 label *label240
   690 label *label241
   691 label *label242
-    * op add :compute:i :compute:i 1
+  692 op add :compute:i 34 1
   693 set :compute:x1 :compute:zx
   694 op mul *tmp106 :compute:zx :compute:zx
   695 op mul *tmp107 :compute:zy :compute:zy
 
   704 label *label243
   705 label *label244
   706 label *label245
-    * op add :compute:i :compute:i 1
+  707 op add :compute:i 35 1
   708 set :compute:x1 :compute:zx
   709 op mul *tmp106 :compute:zx :compute:zx
   710 op mul *tmp107 :compute:zy :compute:zy
 
   719 label *label246
   720 label *label247
   721 label *label248
-    * op add :compute:i :compute:i 1
+  722 op add :compute:i 36 1
   723 set :compute:x1 :compute:zx
   724 op mul *tmp106 :compute:zx :compute:zx
   725 op mul *tmp107 :compute:zy :compute:zy
 
   734 label *label249
   735 label *label250
   736 label *label251
-    * op add :compute:i :compute:i 1
+  737 op add :compute:i 37 1
   738 set :compute:x1 :compute:zx
   739 op mul *tmp106 :compute:zx :compute:zx
   740 op mul *tmp107 :compute:zy :compute:zy
 
   749 label *label252
   750 label *label253
   751 label *label254
-    * op add :compute:i :compute:i 1
+  752 op add :compute:i 38 1
   753 set :compute:x1 :compute:zx
   754 op mul *tmp106 :compute:zx :compute:zx
   755 op mul *tmp107 :compute:zy :compute:zy
 
   764 label *label255
   765 label *label256
   766 label *label257
-    * op add :compute:i :compute:i 1
+  767 op add :compute:i 39 1
   768 set :compute:x1 :compute:zx
   769 op mul *tmp106 :compute:zx :compute:zx
   770 op mul *tmp107 :compute:zy :compute:zy
 
   779 label *label258
   780 label *label259
   781 label *label260
-    * op add :compute:i :compute:i 1
+  782 op add :compute:i 40 1
   783 set :compute:x1 :compute:zx
   784 op mul *tmp106 :compute:zx :compute:zx
   785 op mul *tmp107 :compute:zy :compute:zy
 
   794 label *label261
   795 label *label262
   796 label *label263
-    * op add :compute:i :compute:i 1
+  797 op add :compute:i 41 1
   798 set :compute:x1 :compute:zx
   799 op mul *tmp106 :compute:zx :compute:zx
   800 op mul *tmp107 :compute:zy :compute:zy
 
   809 label *label264
   810 label *label265
   811 label *label266
-    * op add :compute:i :compute:i 1
+  812 op add :compute:i 42 1
   813 set :compute:x1 :compute:zx
   814 op mul *tmp106 :compute:zx :compute:zx
   815 op mul *tmp107 :compute:zy :compute:zy
 
   824 label *label267
   825 label *label268
   826 label *label269
-    * op add :compute:i :compute:i 1
+  827 op add :compute:i 43 1
   828 set :compute:x1 :compute:zx
   829 op mul *tmp106 :compute:zx :compute:zx
   830 op mul *tmp107 :compute:zy :compute:zy
 
   839 label *label270
   840 label *label271
   841 label *label272
-    * op add :compute:i :compute:i 1
+  842 op add :compute:i 44 1
   843 set :compute:x1 :compute:zx
   844 op mul *tmp106 :compute:zx :compute:zx
   845 op mul *tmp107 :compute:zy :compute:zy
 
   854 label *label273
   855 label *label274
   856 label *label275
-    * op add :compute:i :compute:i 1
+  857 op add :compute:i 45 1
   858 set :compute:x1 :compute:zx
   859 op mul *tmp106 :compute:zx :compute:zx
   860 op mul *tmp107 :compute:zy :compute:zy
 
   869 label *label276
   870 label *label277
   871 label *label278
-    * op add :compute:i :compute:i 1
+  872 op add :compute:i 46 1
   873 set :compute:x1 :compute:zx
   874 op mul *tmp106 :compute:zx :compute:zx
   875 op mul *tmp107 :compute:zy :compute:zy
 
   884 label *label279
   885 label *label280
   886 label *label281
-    * op add :compute:i :compute:i 1
+  887 op add :compute:i 47 1
   888 set :compute:x1 :compute:zx
   889 op mul *tmp106 :compute:zx :compute:zx
   890 op mul *tmp107 :compute:zy :compute:zy
 
   899 label *label282
   900 label *label283
   901 label *label284
-    * op add :compute:i :compute:i 1
+  902 op add :compute:i 48 1
   903 set :compute:x1 :compute:zx
   904 op mul *tmp106 :compute:zx :compute:zx
   905 op mul *tmp107 :compute:zy :compute:zy
 
   914 label *label285
   915 label *label286
   916 label *label287
-    * op add :compute:i :compute:i 1
+  917 op add :compute:i 49 1
   918 set :compute:x1 :compute:zx
   919 op mul *tmp106 :compute:zx :compute:zx
   920 op mul *tmp107 :compute:zy :compute:zy
 
   929 label *label288
   930 label *label289
   931 label *label290
-    * op add :compute:i :compute:i 1
+  932 op add :compute:i 50 1
   933 set :compute:x1 :compute:zx
   934 op mul *tmp106 :compute:zx :compute:zx
   935 op mul *tmp107 :compute:zy :compute:zy
 
   944 label *label291
   945 label *label292
   946 label *label293
-    * op add :compute:i :compute:i 1
+  947 op add :compute:i 51 1
   948 set :compute:x1 :compute:zx
   949 op mul *tmp106 :compute:zx :compute:zx
   950 op mul *tmp107 :compute:zy :compute:zy
 
   959 label *label294
   960 label *label295
   961 label *label296
-    * op add :compute:i :compute:i 1
+  962 op add :compute:i 52 1
   963 set :compute:x1 :compute:zx
   964 op mul *tmp106 :compute:zx :compute:zx
   965 op mul *tmp107 :compute:zy :compute:zy
 
   974 label *label297
   975 label *label298
   976 label *label299
-    * op add :compute:i :compute:i 1
+  977 op add :compute:i 53 1
   978 set :compute:x1 :compute:zx
   979 op mul *tmp106 :compute:zx :compute:zx
   980 op mul *tmp107 :compute:zy :compute:zy
 
   989 label *label300
   990 label *label301
   991 label *label302
-    * op add :compute:i :compute:i 1
+  992 op add :compute:i 54 1
   993 set :compute:x1 :compute:zx
   994 op mul *tmp106 :compute:zx :compute:zx
   995 op mul *tmp107 :compute:zy :compute:zy
 
  1004 label *label303
  1005 label *label304
  1006 label *label305
-    * op add :compute:i :compute:i 1
+ 1007 op add :compute:i 55 1
  1008 set :compute:x1 :compute:zx
  1009 op mul *tmp106 :compute:zx :compute:zx
  1010 op mul *tmp107 :compute:zy :compute:zy
 
  1019 label *label306
  1020 label *label307
  1021 label *label308
-    * op add :compute:i :compute:i 1
+ 1022 op add :compute:i 56 1
  1023 set :compute:x1 :compute:zx
  1024 op mul *tmp106 :compute:zx :compute:zx
  1025 op mul *tmp107 :compute:zy :compute:zy
 
  1034 label *label309
  1035 label *label310
  1036 label *label311
-    * op add :compute:i :compute:i 1
+ 1037 op add :compute:i 57 1
  1038 set :compute:x1 :compute:zx
  1039 op mul *tmp106 :compute:zx :compute:zx
  1040 op mul *tmp107 :compute:zy :compute:zy
 
  1049 label *label312
  1050 label *label313
  1051 label *label314
-    * op add :compute:i :compute:i 1
+ 1052 op add :compute:i 58 1
  1053 set :compute:x1 :compute:zx
  1054 op mul *tmp106 :compute:zx :compute:zx
  1055 op mul *tmp107 :compute:zy :compute:zy
 
  1064 label *label315
  1065 label *label316
  1066 label *label317
-    * op add :compute:i :compute:i 1
+ 1067 op add :compute:i 59 1
  1068 set :compute:x1 :compute:zx
  1069 op mul *tmp106 :compute:zx :compute:zx
  1070 op mul *tmp107 :compute:zy :compute:zy
 
  1079 label *label318
  1080 label *label319
  1081 label *label320
-    * op add :compute:i :compute:i 1
+ 1082 op add :compute:i 60 1
  1083 set :compute:x1 :compute:zx
  1084 op mul *tmp106 :compute:zx :compute:zx
  1085 op mul *tmp107 :compute:zy :compute:zy
 
  1094 label *label321
  1095 label *label322
  1096 label *label323
-    * op add :compute:i :compute:i 1
+ 1097 op add :compute:i 61 1
  1098 set :compute:x1 :compute:zx
  1099 op mul *tmp106 :compute:zx :compute:zx
  1100 op mul *tmp107 :compute:zy :compute:zy
 
  1109 label *label324
  1110 label *label325
  1111 label *label326
-    * op add :compute:i :compute:i 1
+ 1112 op add :compute:i 62 1
  1113 label *label63
  1114 jump *label66 lessThanEq .PALETTE 1
  1115 jump *label66 greaterThanEq :compute:i 63

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1:
 
   179 label *label138
   180 label *label139
   181 label *label140
-    * op add :compute:i 0 1
+  182 set :compute:i 1
   183 set :compute:x1 :compute:zx
   184 op mul *tmp106 :compute:zx :compute:zx
   185 op mul *tmp107 :compute:zy :compute:zy

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-1 instructions):
     0 set .start 0
     1 label *label0
-    * label *label1
     2 op equal *tmp14 .display null
     3 op equal *tmp15 .memory null
     4 op or *tmp16 *tmp14 *tmp15
     5 jump *label0 notEqual *tmp16 false
-    * label *label2
     6 label *label3
     7 label *label6
     8 wait 0
-    * label *label7
     9 read *tmp18 .memory 67
    10 jump *label6 equal .start *tmp18
-    * label *label8
    11 read .start .memory 67
    12 read .stop .memory 68
    13 set .lastColor -1
 
    35 jump *label14 equal .stop *tmp38
    36 jump *label4 always
    37 label *label14
-    * label *label15
    38 read :batch .memory 64
    39 read *tmp41 .memory 64
    40 op add *tmp42 *tmp41 :multiple
 
    42 jump *label16 lessThan :batch 2816
    43 jump *label13 always
    44 label *label16
-    * label *label17
    45 op mul *tmp46 11 :multiple
    46 set :i 0
    47 op mul *tmp47 :batch 11
-    * label *label18
    48 jump *label20 lessThanEq :multiple 0
    49 label *label119
    50 op add :adam5:index *tmp47 :i
    51 op idiv *tmp50 :adam5:index 16
    52 multijump *tmp50 0 0 (m:*label124)
    53 multilabel *label129 (m:*label124)
-    * label *label123
    54 op sub :adam5:index :adam5:index 15488
    55 op mod :adam5:x :adam5:index 176
    56 op idiv *tmp77 :adam5:index 176
 
    60 set :adam5:dx 1
    61 jump *label22 always
    62 multilabel *label125 (m:*label124)
-    * label *label24
    63 op mod *tmp52 :adam5:index 44
    64 op mul :adam5:x 4 *tmp52
    65 op idiv *tmp54 :adam5:index 44
 
    68 set :adam5:dy *tmp56
    69 set :adam5:dx *tmp56
    70 jump *label22 always
-    * label *label23
    71 multilabel *label126 (m:*label124)
-    * label *label29
    72 op sub :adam5:index :adam5:index 1936
    73 op mod *tmp57 :adam5:index 44
    74 op mul *tmp58 4 *tmp57
 
    78 select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1
    79 select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2
    80 jump *label22 always
-    * label *label28
    81 multilabel *label127 (m:*label124)
-    * label *label36
    82 op sub :adam5:index :adam5:index 3872
    83 op mod *tmp64 :adam5:index 88
    84 op mul :adam5:x 2 *tmp64
 
    88 select *tmp69 notEqual .ALL_PASS_COLORING false 2 1
    89 set :adam5:dy *tmp69
    90 set :adam5:dx *tmp69
-    * label *label35
    91 jump *label22 always
    92 multilabel *label128 (m:*label124)
-    * label *label41
    93 op sub :adam5:index :adam5:index 7744
    94 op mod *tmp70 :adam5:index 88
    95 op mul *tmp71 2 *tmp70
 
    99 set :adam5:dx 1
   100 select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1
   101 label *label22
-    * label *label21
   102 jump *label45 lessThanEq :multiple *tmp35
   103 jump *label45 notEqual .localBuffer 0
   104 draw col %[white]
 
   113 drawflush .display
   114 set .localBuffer 0
   115 label *label50
-    * label *label51
-    * label *label49
   116 label *label45
-    * label *label46
   117 op div *tmp89 :adam5:x .ZOOM
   118 op add :compute:zx *tmp89 .OFFSET_X
   119 op div *tmp91 :adam5:y .ZOOM
 
   135 set *tmp88 63
   136 jump *label54 always
   137 label *label57
-    * label *label58
   138 op add *tmp102 :compute:zx 1
   139 op len *tmp103 *tmp102 :compute:zy
   140 jump *label59 greaterThan *tmp103 0.25
   141 set *tmp88 63
   142 jump *label54 always
   143 label *label59
-    * label *label60
   144 label *label56
   145 set :compute:i 0
-    * label *label137
   146 set :compute:x1 :compute:zx
   147 op mul *tmp106 :compute:zx :compute:zx
   148 op mul *tmp107 :compute:zy :compute:zy
 
   155 jump *label138 lessThan :compute:dist 64
   156 jump *label63 always
   157 label *label138
-    * label *label139
-    * label *label140
   158 set :compute:i 1
   159 set :compute:x1 :compute:zx
   160 op mul *tmp106 :compute:zx :compute:zx
 
   168 jump *label141 lessThan :compute:dist 64
   169 jump *label63 always
   170 label *label141
-    * label *label142
-    * label *label143
   171 op add :compute:i 1 1
   172 set :compute:x1 :compute:zx
   173 op mul *tmp106 :compute:zx :compute:zx
 
   181 jump *label144 lessThan :compute:dist 64
   182 jump *label63 always
   183 label *label144
-    * label *label145
-    * label *label146
   184 op add :compute:i 2 1
   185 set :compute:x1 :compute:zx
   186 op mul *tmp106 :compute:zx :compute:zx
 
   194 jump *label147 lessThan :compute:dist 64
   195 jump *label63 always
   196 label *label147
-    * label *label148
-    * label *label149
   197 op add :compute:i 3 1
   198 set :compute:x1 :compute:zx
   199 op mul *tmp106 :compute:zx :compute:zx
 
   207 jump *label150 lessThan :compute:dist 64
   208 jump *label63 always
   209 label *label150
-    * label *label151
-    * label *label152
   210 op add :compute:i 4 1
   211 set :compute:x1 :compute:zx
   212 op mul *tmp106 :compute:zx :compute:zx
 
   220 jump *label153 lessThan :compute:dist 64
   221 jump *label63 always
   222 label *label153
-    * label *label154
-    * label *label155
   223 op add :compute:i 5 1
   224 set :compute:x1 :compute:zx
   225 op mul *tmp106 :compute:zx :compute:zx
 
   233 jump *label156 lessThan :compute:dist 64
   234 jump *label63 always
   235 label *label156
-    * label *label157
-    * label *label158
   236 op add :compute:i 6 1
   237 set :compute:x1 :compute:zx
   238 op mul *tmp106 :compute:zx :compute:zx
 
   246 jump *label159 lessThan :compute:dist 64
   247 jump *label63 always
   248 label *label159
-    * label *label160
-    * label *label161
   249 op add :compute:i 7 1
   250 set :compute:x1 :compute:zx
   251 op mul *tmp106 :compute:zx :compute:zx
 
   259 jump *label162 lessThan :compute:dist 64
   260 jump *label63 always
   261 label *label162
-    * label *label163
-    * label *label164
   262 op add :compute:i 8 1
   263 set :compute:x1 :compute:zx
   264 op mul *tmp106 :compute:zx :compute:zx
 
   272 jump *label165 lessThan :compute:dist 64
   273 jump *label63 always
   274 label *label165
-    * label *label166
-    * label *label167
   275 op add :compute:i 9 1
   276 set :compute:x1 :compute:zx
   277 op mul *tmp106 :compute:zx :compute:zx
 
   285 jump *label168 lessThan :compute:dist 64
   286 jump *label63 always
   287 label *label168
-    * label *label169
-    * label *label170
   288 op add :compute:i 10 1
   289 set :compute:x1 :compute:zx
   290 op mul *tmp106 :compute:zx :compute:zx
 
   298 jump *label171 lessThan :compute:dist 64
   299 jump *label63 always
   300 label *label171
-    * label *label172
-    * label *label173
   301 op add :compute:i 11 1
   302 set :compute:x1 :compute:zx
   303 op mul *tmp106 :compute:zx :compute:zx
 
   311 jump *label174 lessThan :compute:dist 64
   312 jump *label63 always
   313 label *label174
-    * label *label175
-    * label *label176
   314 op add :compute:i 12 1
   315 set :compute:x1 :compute:zx
   316 op mul *tmp106 :compute:zx :compute:zx
 
   324 jump *label177 lessThan :compute:dist 64
   325 jump *label63 always
   326 label *label177
-    * label *label178
-    * label *label179
   327 op add :compute:i 13 1
   328 set :compute:x1 :compute:zx
   329 op mul *tmp106 :compute:zx :compute:zx
 
   337 jump *label180 lessThan :compute:dist 64
   338 jump *label63 always
   339 label *label180
-    * label *label181
-    * label *label182
   340 op add :compute:i 14 1
   341 set :compute:x1 :compute:zx
   342 op mul *tmp106 :compute:zx :compute:zx
 
   350 jump *label183 lessThan :compute:dist 64
   351 jump *label63 always
   352 label *label183
-    * label *label184
-    * label *label185
   353 op add :compute:i 15 1
   354 set :compute:x1 :compute:zx
   355 op mul *tmp106 :compute:zx :compute:zx
 
   363 jump *label186 lessThan :compute:dist 64
   364 jump *label63 always
   365 label *label186
-    * label *label187
-    * label *label188
   366 op add :compute:i 16 1
   367 set :compute:x1 :compute:zx
   368 op mul *tmp106 :compute:zx :compute:zx
 
   376 jump *label189 lessThan :compute:dist 64
   377 jump *label63 always
   378 label *label189
-    * label *label190
-    * label *label191
   379 op add :compute:i 17 1
   380 set :compute:x1 :compute:zx
   381 op mul *tmp106 :compute:zx :compute:zx
 
   389 jump *label192 lessThan :compute:dist 64
   390 jump *label63 always
   391 label *label192
-    * label *label193
-    * label *label194
   392 op add :compute:i 18 1
   393 set :compute:x1 :compute:zx
   394 op mul *tmp106 :compute:zx :compute:zx
 
   402 jump *label195 lessThan :compute:dist 64
   403 jump *label63 always
   404 label *label195
-    * label *label196
-    * label *label197
   405 op add :compute:i 19 1
   406 set :compute:x1 :compute:zx
   407 op mul *tmp106 :compute:zx :compute:zx
 
   415 jump *label198 lessThan :compute:dist 64
   416 jump *label63 always
   417 label *label198
-    * label *label199
-    * label *label200
   418 op add :compute:i 20 1
   419 set :compute:x1 :compute:zx
   420 op mul *tmp106 :compute:zx :compute:zx
 
   428 jump *label201 lessThan :compute:dist 64
   429 jump *label63 always
   430 label *label201
-    * label *label202
-    * label *label203
   431 op add :compute:i 21 1
   432 set :compute:x1 :compute:zx
   433 op mul *tmp106 :compute:zx :compute:zx
 
   441 jump *label204 lessThan :compute:dist 64
   442 jump *label63 always
   443 label *label204
-    * label *label205
-    * label *label206
   444 op add :compute:i 22 1
   445 set :compute:x1 :compute:zx
   446 op mul *tmp106 :compute:zx :compute:zx
 
   454 jump *label207 lessThan :compute:dist 64
   455 jump *label63 always
   456 label *label207
-    * label *label208
-    * label *label209
   457 op add :compute:i 23 1
   458 set :compute:x1 :compute:zx
   459 op mul *tmp106 :compute:zx :compute:zx
 
   467 jump *label210 lessThan :compute:dist 64
   468 jump *label63 always
   469 label *label210
-    * label *label211
-    * label *label212
   470 op add :compute:i 24 1
   471 set :compute:x1 :compute:zx
   472 op mul *tmp106 :compute:zx :compute:zx
 
   480 jump *label213 lessThan :compute:dist 64
   481 jump *label63 always
   482 label *label213
-    * label *label214
-    * label *label215
   483 op add :compute:i 25 1
   484 set :compute:x1 :compute:zx
   485 op mul *tmp106 :compute:zx :compute:zx
 
   493 jump *label216 lessThan :compute:dist 64
   494 jump *label63 always
   495 label *label216
-    * label *label217
-    * label *label218
   496 op add :compute:i 26 1
   497 set :compute:x1 :compute:zx
   498 op mul *tmp106 :compute:zx :compute:zx
 
   506 jump *label219 lessThan :compute:dist 64
   507 jump *label63 always
   508 label *label219
-    * label *label220
-    * label *label221
   509 op add :compute:i 27 1
   510 set :compute:x1 :compute:zx
   511 op mul *tmp106 :compute:zx :compute:zx
 
   519 jump *label222 lessThan :compute:dist 64
   520 jump *label63 always
   521 label *label222
-    * label *label223
-    * label *label224
   522 op add :compute:i 28 1
   523 set :compute:x1 :compute:zx
   524 op mul *tmp106 :compute:zx :compute:zx
 
   532 jump *label225 lessThan :compute:dist 64
   533 jump *label63 always
   534 label *label225
-    * label *label226
-    * label *label227
   535 op add :compute:i 29 1
   536 set :compute:x1 :compute:zx
   537 op mul *tmp106 :compute:zx :compute:zx
 
   545 jump *label228 lessThan :compute:dist 64
   546 jump *label63 always
   547 label *label228
-    * label *label229
-    * label *label230
   548 op add :compute:i 30 1
   549 set :compute:x1 :compute:zx
   550 op mul *tmp106 :compute:zx :compute:zx
 
   558 jump *label231 lessThan :compute:dist 64
   559 jump *label63 always
   560 label *label231
-    * label *label232
-    * label *label233
   561 op add :compute:i 31 1
   562 set :compute:x1 :compute:zx
   563 op mul *tmp106 :compute:zx :compute:zx
 
   571 jump *label234 lessThan :compute:dist 64
   572 jump *label63 always
   573 label *label234
-    * label *label235
-    * label *label236
   574 op add :compute:i 32 1
   575 set :compute:x1 :compute:zx
   576 op mul *tmp106 :compute:zx :compute:zx
 
   584 jump *label237 lessThan :compute:dist 64
   585 jump *label63 always
   586 label *label237
-    * label *label238
-    * label *label239
   587 op add :compute:i 33 1
   588 set :compute:x1 :compute:zx
   589 op mul *tmp106 :compute:zx :compute:zx
 
   597 jump *label240 lessThan :compute:dist 64
   598 jump *label63 always
   599 label *label240
-    * label *label241
-    * label *label242
   600 op add :compute:i 34 1
   601 set :compute:x1 :compute:zx
   602 op mul *tmp106 :compute:zx :compute:zx
 
   610 jump *label243 lessThan :compute:dist 64
   611 jump *label63 always
   612 label *label243
-    * label *label244
-    * label *label245
   613 op add :compute:i 35 1
   614 set :compute:x1 :compute:zx
   615 op mul *tmp106 :compute:zx :compute:zx
 
   623 jump *label246 lessThan :compute:dist 64
   624 jump *label63 always
   625 label *label246
-    * label *label247
-    * label *label248
   626 op add :compute:i 36 1
   627 set :compute:x1 :compute:zx
   628 op mul *tmp106 :compute:zx :compute:zx
 
   636 jump *label249 lessThan :compute:dist 64
   637 jump *label63 always
   638 label *label249
-    * label *label250
-    * label *label251
   639 op add :compute:i 37 1
   640 set :compute:x1 :compute:zx
   641 op mul *tmp106 :compute:zx :compute:zx
 
   649 jump *label252 lessThan :compute:dist 64
   650 jump *label63 always
   651 label *label252
-    * label *label253
-    * label *label254
   652 op add :compute:i 38 1
   653 set :compute:x1 :compute:zx
   654 op mul *tmp106 :compute:zx :compute:zx
 
   662 jump *label255 lessThan :compute:dist 64
   663 jump *label63 always
   664 label *label255
-    * label *label256
-    * label *label257
   665 op add :compute:i 39 1
   666 set :compute:x1 :compute:zx
   667 op mul *tmp106 :compute:zx :compute:zx
 
   675 jump *label258 lessThan :compute:dist 64
   676 jump *label63 always
   677 label *label258
-    * label *label259
-    * label *label260
   678 op add :compute:i 40 1
   679 set :compute:x1 :compute:zx
   680 op mul *tmp106 :compute:zx :compute:zx
 
   688 jump *label261 lessThan :compute:dist 64
   689 jump *label63 always
   690 label *label261
-    * label *label262
-    * label *label263
   691 op add :compute:i 41 1
   692 set :compute:x1 :compute:zx
   693 op mul *tmp106 :compute:zx :compute:zx
 
   701 jump *label264 lessThan :compute:dist 64
   702 jump *label63 always
   703 label *label264
-    * label *label265
-    * label *label266
   704 op add :compute:i 42 1
   705 set :compute:x1 :compute:zx
   706 op mul *tmp106 :compute:zx :compute:zx
 
   714 jump *label267 lessThan :compute:dist 64
   715 jump *label63 always
   716 label *label267
-    * label *label268
-    * label *label269
   717 op add :compute:i 43 1
   718 set :compute:x1 :compute:zx
   719 op mul *tmp106 :compute:zx :compute:zx
 
   727 jump *label270 lessThan :compute:dist 64
   728 jump *label63 always
   729 label *label270
-    * label *label271
-    * label *label272
   730 op add :compute:i 44 1
   731 set :compute:x1 :compute:zx
   732 op mul *tmp106 :compute:zx :compute:zx
 
   740 jump *label273 lessThan :compute:dist 64
   741 jump *label63 always
   742 label *label273
-    * label *label274
-    * label *label275
   743 op add :compute:i 45 1
   744 set :compute:x1 :compute:zx
   745 op mul *tmp106 :compute:zx :compute:zx
 
   753 jump *label276 lessThan :compute:dist 64
   754 jump *label63 always
   755 label *label276
-    * label *label277
-    * label *label278
   756 op add :compute:i 46 1
   757 set :compute:x1 :compute:zx
   758 op mul *tmp106 :compute:zx :compute:zx
 
   766 jump *label279 lessThan :compute:dist 64
   767 jump *label63 always
   768 label *label279
-    * label *label280
-    * label *label281
   769 op add :compute:i 47 1
   770 set :compute:x1 :compute:zx
   771 op mul *tmp106 :compute:zx :compute:zx
 
   779 jump *label282 lessThan :compute:dist 64
   780 jump *label63 always
   781 label *label282
-    * label *label283
-    * label *label284
   782 op add :compute:i 48 1
   783 set :compute:x1 :compute:zx
   784 op mul *tmp106 :compute:zx :compute:zx
 
   792 jump *label285 lessThan :compute:dist 64
   793 jump *label63 always
   794 label *label285
-    * label *label286
-    * label *label287
   795 op add :compute:i 49 1
   796 set :compute:x1 :compute:zx
   797 op mul *tmp106 :compute:zx :compute:zx
 
   805 jump *label288 lessThan :compute:dist 64
   806 jump *label63 always
   807 label *label288
-    * label *label289
-    * label *label290
   808 op add :compute:i 50 1
   809 set :compute:x1 :compute:zx
   810 op mul *tmp106 :compute:zx :compute:zx
 
   818 jump *label291 lessThan :compute:dist 64
   819 jump *label63 always
   820 label *label291
-    * label *label292
-    * label *label293
   821 op add :compute:i 51 1
   822 set :compute:x1 :compute:zx
   823 op mul *tmp106 :compute:zx :compute:zx
 
   831 jump *label294 lessThan :compute:dist 64
   832 jump *label63 always
   833 label *label294
-    * label *label295
-    * label *label296
   834 op add :compute:i 52 1
   835 set :compute:x1 :compute:zx
   836 op mul *tmp106 :compute:zx :compute:zx
 
   844 jump *label297 lessThan :compute:dist 64
   845 jump *label63 always
   846 label *label297
-    * label *label298
-    * label *label299
   847 op add :compute:i 53 1
   848 set :compute:x1 :compute:zx
   849 op mul *tmp106 :compute:zx :compute:zx
 
   857 jump *label300 lessThan :compute:dist 64
   858 jump *label63 always
   859 label *label300
-    * label *label301
-    * label *label302
   860 op add :compute:i 54 1
   861 set :compute:x1 :compute:zx
   862 op mul *tmp106 :compute:zx :compute:zx
 
   870 jump *label303 lessThan :compute:dist 64
   871 jump *label63 always
   872 label *label303
-    * label *label304
-    * label *label305
   873 op add :compute:i 55 1
   874 set :compute:x1 :compute:zx
   875 op mul *tmp106 :compute:zx :compute:zx
 
   883 jump *label306 lessThan :compute:dist 64
   884 jump *label63 always
   885 label *label306
-    * label *label307
-    * label *label308
   886 op add :compute:i 56 1
   887 set :compute:x1 :compute:zx
   888 op mul *tmp106 :compute:zx :compute:zx
 
   896 jump *label309 lessThan :compute:dist 64
   897 jump *label63 always
   898 label *label309
-    * label *label310
-    * label *label311
   899 op add :compute:i 57 1
   900 set :compute:x1 :compute:zx
   901 op mul *tmp106 :compute:zx :compute:zx
 
   909 jump *label312 lessThan :compute:dist 64
   910 jump *label63 always
   911 label *label312
-    * label *label313
-    * label *label314
   912 op add :compute:i 58 1
   913 set :compute:x1 :compute:zx
   914 op mul *tmp106 :compute:zx :compute:zx
 
   922 jump *label315 lessThan :compute:dist 64
   923 jump *label63 always
   924 label *label315
-    * label *label316
-    * label *label317
   925 op add :compute:i 59 1
   926 set :compute:x1 :compute:zx
   927 op mul *tmp106 :compute:zx :compute:zx
 
   935 jump *label318 lessThan :compute:dist 64
   936 jump *label63 always
   937 label *label318
-    * label *label319
-    * label *label320
   938 op add :compute:i 60 1
   939 set :compute:x1 :compute:zx
   940 op mul *tmp106 :compute:zx :compute:zx
 
   948 jump *label321 lessThan :compute:dist 64
   949 jump *label63 always
   950 label *label321
-    * label *label322
-    * label *label323
   951 op add :compute:i 61 1
   952 set :compute:x1 :compute:zx
   953 op mul *tmp106 :compute:zx :compute:zx
 
   961 jump *label324 lessThan :compute:dist 64
   962 jump *label63 always
   963 label *label324
-    * label *label325
-    * label *label326
   964 op add :compute:i 62 1
   965 label *label63
   966 jump *label66 lessThanEq .PALETTE 1
 
   972 op sub :compute:correction 4 *tmp121
   973 op add :compute:i :compute:i :compute:correction
   974 label *label66
-    * label *label67
   975 set *tmp88 :compute:i
   976 label *label54
   977 jump *label71 lessThanEq .PALETTE 1
   978 set :drawPixel:color %[black]
   979 jump *label74 equal *tmp88 63
-    * label *label73
   980 multijump .PALETTE 0 0 (m:*label131)
   981 multilabel *label136 (m:*label131)
   982 multilabel *label132 (m:*label131)
-    * label *label130
   983 op div *tmp162 *tmp88 63.75
   984 op sub :drawPixel:r 1 *tmp162
   985 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   986 jump *label75 always
   987 multilabel *label133 (m:*label131)
-    * label *label77
   988 op sub *tmp128 32 *tmp88
   989 op abs *tmp129 *tmp128
   990 op div *tmp131 *tmp129 36.42857142857143
 
   997 op add :drawPixel:b 0.47058823529411764 *tmp141
   998 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   999 jump *label75 always
-    * label *label76
  1000 multilabel *label134 (m:*label131)
-    * label *label79
  1001 op div *tmp145 *tmp88 0.175
  1002 op sin :drawPixel:r *tmp145
  1003 op cos :drawPixel:g *tmp145
 
  1007 op add :drawPixel:b 0.39215686274509803 *tmp153
  1008 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1009 jump *label75 always
-    * label *label78
  1010 multilabel *label135 (m:*label131)
-    * label *label81
  1011 op div :drawPixel:r *tmp88 63.75
  1012 op div :drawPixel:g *tmp88 170
  1013 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
 
  1018 read :drawPixel:color .memory *tmp88
  1019 label *label72
  1020 jump *label82 lessThan .localBuffer 254
-    * label *label85
  1021 jump *label87 lessThanEq .localBuffer 0
  1022 label *label121
  1023 read *tmp172 .memory 68
 
  1031 drawflush .display
  1032 set .localBuffer 0
  1033 label *label91
-    * label *label92
-    * label *label90
-    * label *label86
  1034 jump *label121 greaterThan .localBuffer 0
  1035 label *label87
-    * label *label84
  1036 label *label82
-    * label *label83
  1037 jump *label95 lessThanEq .localBuffer 0
  1038 jump *label95 strictNotEqual :drawPixel:color .lastColor
  1039 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
 
  1054 drawflush .display
  1055 set .localBuffer 0
  1056 label *label100
-    * label *label101
-    * label *label99
-    * label *label70
  1057 wait 0
  1058 read *tmp188 .memory 68
  1059 jump *label104 equal .stop *tmp188
  1060 jump *label4 always
  1061 label *label104
-    * label *label105
  1062 read *tmp190 .memory 66
  1063 op add *tmp2 *tmp190 1
  1064 write *tmp2 .memory 66
  1065 read *tmp192 .memory 65
  1066 op add *tmp193 *tmp192 *tmp88
  1067 write *tmp193 .memory 65
-    * label *label19
  1068 op add :i :i 1
  1069 jump *label119 lessThan :i *tmp46
  1070 label *label20
  1071 select :multiple greaterThanEq :batch 1337.6 1 :multiple
-    * label *label12
  1072 jump *label11 always
  1073 label *label13
-    * label *label109
  1074 jump *label111 lessThanEq .localBuffer 0
  1075 label *label122
  1076 read *tmp198 .memory 68
 
  1084 drawflush .display
  1085 set .localBuffer 0
  1086 label *label115
-    * label *label116
-    * label *label114
-    * label *label110
  1087 jump *label122 greaterThan .localBuffer 0
  1088 label *label111
-    * label *label108
  1089 label *label4
  1090 jump *label3 always
-    * label *label5
-    * end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-66 instructions):
 
    32 label *label11
    33 wait 0
    34 read *tmp38 .memory 68
-    * jump *label14 equal .stop *tmp38
-    * jump *label4 always
+   35 jump *label4 notEqual .stop *tmp38
    36 label *label14
    37 read :batch .memory 64
    38 read *tmp41 .memory 64
    39 op add *tmp42 *tmp41 :multiple
    40 write *tmp42 .memory 64
-    * jump *label16 lessThan :batch 2816
-    * jump *label13 always
+   41 jump *label13 greaterThanEq :batch 2816
    42 label *label16
    43 op mul *tmp46 11 :multiple
    44 set :i 0
 
   150 op mul *tmp111 *tmp110 :compute:zy
   151 op add :compute:zy *tmp111 :compute:cy
   152 op len :compute:dist :compute:zx :compute:zy
-    * jump *label138 lessThan :compute:dist 64
-    * jump *label63 always
+  153 jump *label63 greaterThanEq :compute:dist 64
   154 label *label138
   155 set :compute:i 1
   156 set :compute:x1 :compute:zx
 
   162 op mul *tmp111 *tmp110 :compute:zy
   163 op add :compute:zy *tmp111 :compute:cy
   164 op len :compute:dist :compute:zx :compute:zy
-    * jump *label141 lessThan :compute:dist 64
-    * jump *label63 always
+  165 jump *label63 greaterThanEq :compute:dist 64
   166 label *label141
   167 op add :compute:i 1 1
   168 set :compute:x1 :compute:zx
 
   174 op mul *tmp111 *tmp110 :compute:zy
   175 op add :compute:zy *tmp111 :compute:cy
   176 op len :compute:dist :compute:zx :compute:zy
-    * jump *label144 lessThan :compute:dist 64
-    * jump *label63 always
+  177 jump *label63 greaterThanEq :compute:dist 64
   178 label *label144
   179 op add :compute:i 2 1
   180 set :compute:x1 :compute:zx
 
   186 op mul *tmp111 *tmp110 :compute:zy
   187 op add :compute:zy *tmp111 :compute:cy
   188 op len :compute:dist :compute:zx :compute:zy
-    * jump *label147 lessThan :compute:dist 64
-    * jump *label63 always
+  189 jump *label63 greaterThanEq :compute:dist 64
   190 label *label147
   191 op add :compute:i 3 1
   192 set :compute:x1 :compute:zx
 
   198 op mul *tmp111 *tmp110 :compute:zy
   199 op add :compute:zy *tmp111 :compute:cy
   200 op len :compute:dist :compute:zx :compute:zy
-    * jump *label150 lessThan :compute:dist 64
-    * jump *label63 always
+  201 jump *label63 greaterThanEq :compute:dist 64
   202 label *label150
   203 op add :compute:i 4 1
   204 set :compute:x1 :compute:zx
 
   210 op mul *tmp111 *tmp110 :compute:zy
   211 op add :compute:zy *tmp111 :compute:cy
   212 op len :compute:dist :compute:zx :compute:zy
-    * jump *label153 lessThan :compute:dist 64
-    * jump *label63 always
+  213 jump *label63 greaterThanEq :compute:dist 64
   214 label *label153
   215 op add :compute:i 5 1
   216 set :compute:x1 :compute:zx
 
   222 op mul *tmp111 *tmp110 :compute:zy
   223 op add :compute:zy *tmp111 :compute:cy
   224 op len :compute:dist :compute:zx :compute:zy
-    * jump *label156 lessThan :compute:dist 64
-    * jump *label63 always
+  225 jump *label63 greaterThanEq :compute:dist 64
   226 label *label156
   227 op add :compute:i 6 1
   228 set :compute:x1 :compute:zx
 
   234 op mul *tmp111 *tmp110 :compute:zy
   235 op add :compute:zy *tmp111 :compute:cy
   236 op len :compute:dist :compute:zx :compute:zy
-    * jump *label159 lessThan :compute:dist 64
-    * jump *label63 always
+  237 jump *label63 greaterThanEq :compute:dist 64
   238 label *label159
   239 op add :compute:i 7 1
   240 set :compute:x1 :compute:zx
 
   246 op mul *tmp111 *tmp110 :compute:zy
   247 op add :compute:zy *tmp111 :compute:cy
   248 op len :compute:dist :compute:zx :compute:zy
-    * jump *label162 lessThan :compute:dist 64
-    * jump *label63 always
+  249 jump *label63 greaterThanEq :compute:dist 64
   250 label *label162
   251 op add :compute:i 8 1
   252 set :compute:x1 :compute:zx
 
   258 op mul *tmp111 *tmp110 :compute:zy
   259 op add :compute:zy *tmp111 :compute:cy
   260 op len :compute:dist :compute:zx :compute:zy
-    * jump *label165 lessThan :compute:dist 64
-    * jump *label63 always
+  261 jump *label63 greaterThanEq :compute:dist 64
   262 label *label165
   263 op add :compute:i 9 1
   264 set :compute:x1 :compute:zx
 
   270 op mul *tmp111 *tmp110 :compute:zy
   271 op add :compute:zy *tmp111 :compute:cy
   272 op len :compute:dist :compute:zx :compute:zy
-    * jump *label168 lessThan :compute:dist 64
-    * jump *label63 always
+  273 jump *label63 greaterThanEq :compute:dist 64
   274 label *label168
   275 op add :compute:i 10 1
   276 set :compute:x1 :compute:zx
 
   282 op mul *tmp111 *tmp110 :compute:zy
   283 op add :compute:zy *tmp111 :compute:cy
   284 op len :compute:dist :compute:zx :compute:zy
-    * jump *label171 lessThan :compute:dist 64
-    * jump *label63 always
+  285 jump *label63 greaterThanEq :compute:dist 64
   286 label *label171
   287 op add :compute:i 11 1
   288 set :compute:x1 :compute:zx
 
   294 op mul *tmp111 *tmp110 :compute:zy
   295 op add :compute:zy *tmp111 :compute:cy
   296 op len :compute:dist :compute:zx :compute:zy
-    * jump *label174 lessThan :compute:dist 64
-    * jump *label63 always
+  297 jump *label63 greaterThanEq :compute:dist 64
   298 label *label174
   299 op add :compute:i 12 1
   300 set :compute:x1 :compute:zx
 
   306 op mul *tmp111 *tmp110 :compute:zy
   307 op add :compute:zy *tmp111 :compute:cy
   308 op len :compute:dist :compute:zx :compute:zy
-    * jump *label177 lessThan :compute:dist 64
-    * jump *label63 always
+  309 jump *label63 greaterThanEq :compute:dist 64
   310 label *label177
   311 op add :compute:i 13 1
   312 set :compute:x1 :compute:zx
 
   318 op mul *tmp111 *tmp110 :compute:zy
   319 op add :compute:zy *tmp111 :compute:cy
   320 op len :compute:dist :compute:zx :compute:zy
-    * jump *label180 lessThan :compute:dist 64
-    * jump *label63 always
+  321 jump *label63 greaterThanEq :compute:dist 64
   322 label *label180
   323 op add :compute:i 14 1
   324 set :compute:x1 :compute:zx
 
   330 op mul *tmp111 *tmp110 :compute:zy
   331 op add :compute:zy *tmp111 :compute:cy
   332 op len :compute:dist :compute:zx :compute:zy
-    * jump *label183 lessThan :compute:dist 64
-    * jump *label63 always
+  333 jump *label63 greaterThanEq :compute:dist 64
   334 label *label183
   335 op add :compute:i 15 1
   336 set :compute:x1 :compute:zx
 
   342 op mul *tmp111 *tmp110 :compute:zy
   343 op add :compute:zy *tmp111 :compute:cy
   344 op len :compute:dist :compute:zx :compute:zy
-    * jump *label186 lessThan :compute:dist 64
-    * jump *label63 always
+  345 jump *label63 greaterThanEq :compute:dist 64
   346 label *label186
   347 op add :compute:i 16 1
   348 set :compute:x1 :compute:zx
 
   354 op mul *tmp111 *tmp110 :compute:zy
   355 op add :compute:zy *tmp111 :compute:cy
   356 op len :compute:dist :compute:zx :compute:zy
-    * jump *label189 lessThan :compute:dist 64
-    * jump *label63 always
+  357 jump *label63 greaterThanEq :compute:dist 64
   358 label *label189
   359 op add :compute:i 17 1
   360 set :compute:x1 :compute:zx
 
   366 op mul *tmp111 *tmp110 :compute:zy
   367 op add :compute:zy *tmp111 :compute:cy
   368 op len :compute:dist :compute:zx :compute:zy
-    * jump *label192 lessThan :compute:dist 64
-    * jump *label63 always
+  369 jump *label63 greaterThanEq :compute:dist 64
   370 label *label192
   371 op add :compute:i 18 1
   372 set :compute:x1 :compute:zx
 
   378 op mul *tmp111 *tmp110 :compute:zy
   379 op add :compute:zy *tmp111 :compute:cy
   380 op len :compute:dist :compute:zx :compute:zy
-    * jump *label195 lessThan :compute:dist 64
-    * jump *label63 always
+  381 jump *label63 greaterThanEq :compute:dist 64
   382 label *label195
   383 op add :compute:i 19 1
   384 set :compute:x1 :compute:zx
 
   390 op mul *tmp111 *tmp110 :compute:zy
   391 op add :compute:zy *tmp111 :compute:cy
   392 op len :compute:dist :compute:zx :compute:zy
-    * jump *label198 lessThan :compute:dist 64
-    * jump *label63 always
+  393 jump *label63 greaterThanEq :compute:dist 64
   394 label *label198
   395 op add :compute:i 20 1
   396 set :compute:x1 :compute:zx
 
   402 op mul *tmp111 *tmp110 :compute:zy
   403 op add :compute:zy *tmp111 :compute:cy
   404 op len :compute:dist :compute:zx :compute:zy
-    * jump *label201 lessThan :compute:dist 64
-    * jump *label63 always
+  405 jump *label63 greaterThanEq :compute:dist 64
   406 label *label201
   407 op add :compute:i 21 1
   408 set :compute:x1 :compute:zx
 
   414 op mul *tmp111 *tmp110 :compute:zy
   415 op add :compute:zy *tmp111 :compute:cy
   416 op len :compute:dist :compute:zx :compute:zy
-    * jump *label204 lessThan :compute:dist 64
-    * jump *label63 always
+  417 jump *label63 greaterThanEq :compute:dist 64
   418 label *label204
   419 op add :compute:i 22 1
   420 set :compute:x1 :compute:zx
 
   426 op mul *tmp111 *tmp110 :compute:zy
   427 op add :compute:zy *tmp111 :compute:cy
   428 op len :compute:dist :compute:zx :compute:zy
-    * jump *label207 lessThan :compute:dist 64
-    * jump *label63 always
+  429 jump *label63 greaterThanEq :compute:dist 64
   430 label *label207
   431 op add :compute:i 23 1
   432 set :compute:x1 :compute:zx
 
   438 op mul *tmp111 *tmp110 :compute:zy
   439 op add :compute:zy *tmp111 :compute:cy
   440 op len :compute:dist :compute:zx :compute:zy
-    * jump *label210 lessThan :compute:dist 64
-    * jump *label63 always
+  441 jump *label63 greaterThanEq :compute:dist 64
   442 label *label210
   443 op add :compute:i 24 1
   444 set :compute:x1 :compute:zx
 
   450 op mul *tmp111 *tmp110 :compute:zy
   451 op add :compute:zy *tmp111 :compute:cy
   452 op len :compute:dist :compute:zx :compute:zy
-    * jump *label213 lessThan :compute:dist 64
-    * jump *label63 always
+  453 jump *label63 greaterThanEq :compute:dist 64
   454 label *label213
   455 op add :compute:i 25 1
   456 set :compute:x1 :compute:zx
 
   462 op mul *tmp111 *tmp110 :compute:zy
   463 op add :compute:zy *tmp111 :compute:cy
   464 op len :compute:dist :compute:zx :compute:zy
-    * jump *label216 lessThan :compute:dist 64
-    * jump *label63 always
+  465 jump *label63 greaterThanEq :compute:dist 64
   466 label *label216
   467 op add :compute:i 26 1
   468 set :compute:x1 :compute:zx
 
   474 op mul *tmp111 *tmp110 :compute:zy
   475 op add :compute:zy *tmp111 :compute:cy
   476 op len :compute:dist :compute:zx :compute:zy
-    * jump *label219 lessThan :compute:dist 64
-    * jump *label63 always
+  477 jump *label63 greaterThanEq :compute:dist 64
   478 label *label219
   479 op add :compute:i 27 1
   480 set :compute:x1 :compute:zx
 
   486 op mul *tmp111 *tmp110 :compute:zy
   487 op add :compute:zy *tmp111 :compute:cy
   488 op len :compute:dist :compute:zx :compute:zy
-    * jump *label222 lessThan :compute:dist 64
-    * jump *label63 always
+  489 jump *label63 greaterThanEq :compute:dist 64
   490 label *label222
   491 op add :compute:i 28 1
   492 set :compute:x1 :compute:zx
 
   498 op mul *tmp111 *tmp110 :compute:zy
   499 op add :compute:zy *tmp111 :compute:cy
   500 op len :compute:dist :compute:zx :compute:zy
-    * jump *label225 lessThan :compute:dist 64
-    * jump *label63 always
+  501 jump *label63 greaterThanEq :compute:dist 64
   502 label *label225
   503 op add :compute:i 29 1
   504 set :compute:x1 :compute:zx
 
   510 op mul *tmp111 *tmp110 :compute:zy
   511 op add :compute:zy *tmp111 :compute:cy
   512 op len :compute:dist :compute:zx :compute:zy
-    * jump *label228 lessThan :compute:dist 64
-    * jump *label63 always
+  513 jump *label63 greaterThanEq :compute:dist 64
   514 label *label228
   515 op add :compute:i 30 1
   516 set :compute:x1 :compute:zx
 
   522 op mul *tmp111 *tmp110 :compute:zy
   523 op add :compute:zy *tmp111 :compute:cy
   524 op len :compute:dist :compute:zx :compute:zy
-    * jump *label231 lessThan :compute:dist 64
-    * jump *label63 always
+  525 jump *label63 greaterThanEq :compute:dist 64
   526 label *label231
   527 op add :compute:i 31 1
   528 set :compute:x1 :compute:zx
 
   534 op mul *tmp111 *tmp110 :compute:zy
   535 op add :compute:zy *tmp111 :compute:cy
   536 op len :compute:dist :compute:zx :compute:zy
-    * jump *label234 lessThan :compute:dist 64
-    * jump *label63 always
+  537 jump *label63 greaterThanEq :compute:dist 64
   538 label *label234
   539 op add :compute:i 32 1
   540 set :compute:x1 :compute:zx
 
   546 op mul *tmp111 *tmp110 :compute:zy
   547 op add :compute:zy *tmp111 :compute:cy
   548 op len :compute:dist :compute:zx :compute:zy
-    * jump *label237 lessThan :compute:dist 64
-    * jump *label63 always
+  549 jump *label63 greaterThanEq :compute:dist 64
   550 label *label237
   551 op add :compute:i 33 1
   552 set :compute:x1 :compute:zx
 
   558 op mul *tmp111 *tmp110 :compute:zy
   559 op add :compute:zy *tmp111 :compute:cy
   560 op len :compute:dist :compute:zx :compute:zy
-    * jump *label240 lessThan :compute:dist 64
-    * jump *label63 always
+  561 jump *label63 greaterThanEq :compute:dist 64
   562 label *label240
   563 op add :compute:i 34 1
   564 set :compute:x1 :compute:zx
 
   570 op mul *tmp111 *tmp110 :compute:zy
   571 op add :compute:zy *tmp111 :compute:cy
   572 op len :compute:dist :compute:zx :compute:zy
-    * jump *label243 lessThan :compute:dist 64
-    * jump *label63 always
+  573 jump *label63 greaterThanEq :compute:dist 64
   574 label *label243
   575 op add :compute:i 35 1
   576 set :compute:x1 :compute:zx
 
   582 op mul *tmp111 *tmp110 :compute:zy
   583 op add :compute:zy *tmp111 :compute:cy
   584 op len :compute:dist :compute:zx :compute:zy
-    * jump *label246 lessThan :compute:dist 64
-    * jump *label63 always
+  585 jump *label63 greaterThanEq :compute:dist 64
   586 label *label246
   587 op add :compute:i 36 1
   588 set :compute:x1 :compute:zx
 
   594 op mul *tmp111 *tmp110 :compute:zy
   595 op add :compute:zy *tmp111 :compute:cy
   596 op len :compute:dist :compute:zx :compute:zy
-    * jump *label249 lessThan :compute:dist 64
-    * jump *label63 always
+  597 jump *label63 greaterThanEq :compute:dist 64
   598 label *label249
   599 op add :compute:i 37 1
   600 set :compute:x1 :compute:zx
 
   606 op mul *tmp111 *tmp110 :compute:zy
   607 op add :compute:zy *tmp111 :compute:cy
   608 op len :compute:dist :compute:zx :compute:zy
-    * jump *label252 lessThan :compute:dist 64
-    * jump *label63 always
+  609 jump *label63 greaterThanEq :compute:dist 64
   610 label *label252
   611 op add :compute:i 38 1
   612 set :compute:x1 :compute:zx
 
   618 op mul *tmp111 *tmp110 :compute:zy
   619 op add :compute:zy *tmp111 :compute:cy
   620 op len :compute:dist :compute:zx :compute:zy
-    * jump *label255 lessThan :compute:dist 64
-    * jump *label63 always
+  621 jump *label63 greaterThanEq :compute:dist 64
   622 label *label255
   623 op add :compute:i 39 1
   624 set :compute:x1 :compute:zx
 
   630 op mul *tmp111 *tmp110 :compute:zy
   631 op add :compute:zy *tmp111 :compute:cy
   632 op len :compute:dist :compute:zx :compute:zy
-    * jump *label258 lessThan :compute:dist 64
-    * jump *label63 always
+  633 jump *label63 greaterThanEq :compute:dist 64
   634 label *label258
   635 op add :compute:i 40 1
   636 set :compute:x1 :compute:zx
 
   642 op mul *tmp111 *tmp110 :compute:zy
   643 op add :compute:zy *tmp111 :compute:cy
   644 op len :compute:dist :compute:zx :compute:zy
-    * jump *label261 lessThan :compute:dist 64
-    * jump *label63 always
+  645 jump *label63 greaterThanEq :compute:dist 64
   646 label *label261
   647 op add :compute:i 41 1
   648 set :compute:x1 :compute:zx
 
   654 op mul *tmp111 *tmp110 :compute:zy
   655 op add :compute:zy *tmp111 :compute:cy
   656 op len :compute:dist :compute:zx :compute:zy
-    * jump *label264 lessThan :compute:dist 64
-    * jump *label63 always
+  657 jump *label63 greaterThanEq :compute:dist 64
   658 label *label264
   659 op add :compute:i 42 1
   660 set :compute:x1 :compute:zx
 
   666 op mul *tmp111 *tmp110 :compute:zy
   667 op add :compute:zy *tmp111 :compute:cy
   668 op len :compute:dist :compute:zx :compute:zy
-    * jump *label267 lessThan :compute:dist 64
-    * jump *label63 always
+  669 jump *label63 greaterThanEq :compute:dist 64
   670 label *label267
   671 op add :compute:i 43 1
   672 set :compute:x1 :compute:zx
 
   678 op mul *tmp111 *tmp110 :compute:zy
   679 op add :compute:zy *tmp111 :compute:cy
   680 op len :compute:dist :compute:zx :compute:zy
-    * jump *label270 lessThan :compute:dist 64
-    * jump *label63 always
+  681 jump *label63 greaterThanEq :compute:dist 64
   682 label *label270
   683 op add :compute:i 44 1
   684 set :compute:x1 :compute:zx
 
   690 op mul *tmp111 *tmp110 :compute:zy
   691 op add :compute:zy *tmp111 :compute:cy
   692 op len :compute:dist :compute:zx :compute:zy
-    * jump *label273 lessThan :compute:dist 64
-    * jump *label63 always
+  693 jump *label63 greaterThanEq :compute:dist 64
   694 label *label273
   695 op add :compute:i 45 1
   696 set :compute:x1 :compute:zx
 
   702 op mul *tmp111 *tmp110 :compute:zy
   703 op add :compute:zy *tmp111 :compute:cy
   704 op len :compute:dist :compute:zx :compute:zy
-    * jump *label276 lessThan :compute:dist 64
-    * jump *label63 always
+  705 jump *label63 greaterThanEq :compute:dist 64
   706 label *label276
   707 op add :compute:i 46 1
   708 set :compute:x1 :compute:zx
 
   714 op mul *tmp111 *tmp110 :compute:zy
   715 op add :compute:zy *tmp111 :compute:cy
   716 op len :compute:dist :compute:zx :compute:zy
-    * jump *label279 lessThan :compute:dist 64
-    * jump *label63 always
+  717 jump *label63 greaterThanEq :compute:dist 64
   718 label *label279
   719 op add :compute:i 47 1
   720 set :compute:x1 :compute:zx
 
   726 op mul *tmp111 *tmp110 :compute:zy
   727 op add :compute:zy *tmp111 :compute:cy
   728 op len :compute:dist :compute:zx :compute:zy
-    * jump *label282 lessThan :compute:dist 64
-    * jump *label63 always
+  729 jump *label63 greaterThanEq :compute:dist 64
   730 label *label282
   731 op add :compute:i 48 1
   732 set :compute:x1 :compute:zx
 
   738 op mul *tmp111 *tmp110 :compute:zy
   739 op add :compute:zy *tmp111 :compute:cy
   740 op len :compute:dist :compute:zx :compute:zy
-    * jump *label285 lessThan :compute:dist 64
-    * jump *label63 always
+  741 jump *label63 greaterThanEq :compute:dist 64
   742 label *label285
   743 op add :compute:i 49 1
   744 set :compute:x1 :compute:zx
 
   750 op mul *tmp111 *tmp110 :compute:zy
   751 op add :compute:zy *tmp111 :compute:cy
   752 op len :compute:dist :compute:zx :compute:zy
-    * jump *label288 lessThan :compute:dist 64
-    * jump *label63 always
+  753 jump *label63 greaterThanEq :compute:dist 64
   754 label *label288
   755 op add :compute:i 50 1
   756 set :compute:x1 :compute:zx
 
   762 op mul *tmp111 *tmp110 :compute:zy
   763 op add :compute:zy *tmp111 :compute:cy
   764 op len :compute:dist :compute:zx :compute:zy
-    * jump *label291 lessThan :compute:dist 64
-    * jump *label63 always
+  765 jump *label63 greaterThanEq :compute:dist 64
   766 label *label291
   767 op add :compute:i 51 1
   768 set :compute:x1 :compute:zx
 
   774 op mul *tmp111 *tmp110 :compute:zy
   775 op add :compute:zy *tmp111 :compute:cy
   776 op len :compute:dist :compute:zx :compute:zy
-    * jump *label294 lessThan :compute:dist 64
-    * jump *label63 always
+  777 jump *label63 greaterThanEq :compute:dist 64
   778 label *label294
   779 op add :compute:i 52 1
   780 set :compute:x1 :compute:zx
 
   786 op mul *tmp111 *tmp110 :compute:zy
   787 op add :compute:zy *tmp111 :compute:cy
   788 op len :compute:dist :compute:zx :compute:zy
-    * jump *label297 lessThan :compute:dist 64
-    * jump *label63 always
+  789 jump *label63 greaterThanEq :compute:dist 64
   790 label *label297
   791 op add :compute:i 53 1
   792 set :compute:x1 :compute:zx
 
   798 op mul *tmp111 *tmp110 :compute:zy
   799 op add :compute:zy *tmp111 :compute:cy
   800 op len :compute:dist :compute:zx :compute:zy
-    * jump *label300 lessThan :compute:dist 64
-    * jump *label63 always
+  801 jump *label63 greaterThanEq :compute:dist 64
   802 label *label300
   803 op add :compute:i 54 1
   804 set :compute:x1 :compute:zx
 
   810 op mul *tmp111 *tmp110 :compute:zy
   811 op add :compute:zy *tmp111 :compute:cy
   812 op len :compute:dist :compute:zx :compute:zy
-    * jump *label303 lessThan :compute:dist 64
-    * jump *label63 always
+  813 jump *label63 greaterThanEq :compute:dist 64
   814 label *label303
   815 op add :compute:i 55 1
   816 set :compute:x1 :compute:zx
 
   822 op mul *tmp111 *tmp110 :compute:zy
   823 op add :compute:zy *tmp111 :compute:cy
   824 op len :compute:dist :compute:zx :compute:zy
-    * jump *label306 lessThan :compute:dist 64
-    * jump *label63 always
+  825 jump *label63 greaterThanEq :compute:dist 64
   826 label *label306
   827 op add :compute:i 56 1
   828 set :compute:x1 :compute:zx
 
   834 op mul *tmp111 *tmp110 :compute:zy
   835 op add :compute:zy *tmp111 :compute:cy
   836 op len :compute:dist :compute:zx :compute:zy
-    * jump *label309 lessThan :compute:dist 64
-    * jump *label63 always
+  837 jump *label63 greaterThanEq :compute:dist 64
   838 label *label309
   839 op add :compute:i 57 1
   840 set :compute:x1 :compute:zx
 
   846 op mul *tmp111 *tmp110 :compute:zy
   847 op add :compute:zy *tmp111 :compute:cy
   848 op len :compute:dist :compute:zx :compute:zy
-    * jump *label312 lessThan :compute:dist 64
-    * jump *label63 always
+  849 jump *label63 greaterThanEq :compute:dist 64
   850 label *label312
   851 op add :compute:i 58 1
   852 set :compute:x1 :compute:zx
 
   858 op mul *tmp111 *tmp110 :compute:zy
   859 op add :compute:zy *tmp111 :compute:cy
   860 op len :compute:dist :compute:zx :compute:zy
-    * jump *label315 lessThan :compute:dist 64
-    * jump *label63 always
+  861 jump *label63 greaterThanEq :compute:dist 64
   862 label *label315
   863 op add :compute:i 59 1
   864 set :compute:x1 :compute:zx
 
   870 op mul *tmp111 *tmp110 :compute:zy
   871 op add :compute:zy *tmp111 :compute:cy
   872 op len :compute:dist :compute:zx :compute:zy
-    * jump *label318 lessThan :compute:dist 64
-    * jump *label63 always
+  873 jump *label63 greaterThanEq :compute:dist 64
   874 label *label318
   875 op add :compute:i 60 1
   876 set :compute:x1 :compute:zx
 
   882 op mul *tmp111 *tmp110 :compute:zy
   883 op add :compute:zy *tmp111 :compute:cy
   884 op len :compute:dist :compute:zx :compute:zy
-    * jump *label321 lessThan :compute:dist 64
-    * jump *label63 always
+  885 jump *label63 greaterThanEq :compute:dist 64
   886 label *label321
   887 op add :compute:i 61 1
   888 set :compute:x1 :compute:zx
 
   894 op mul *tmp111 *tmp110 :compute:zy
   895 op add :compute:zy *tmp111 :compute:cy
   896 op len :compute:dist :compute:zx :compute:zy
-    * jump *label324 lessThan :compute:dist 64
-    * jump *label63 always
+  897 jump *label63 greaterThanEq :compute:dist 64
   898 label *label324
   899 op add :compute:i 62 1
   900 label *label63
 
   991 label *label100
   992 wait 0
   993 read *tmp188 .memory 68
-    * jump *label104 equal .stop *tmp188
-    * jump *label4 always
+  994 jump *label4 notEqual .stop *tmp188
   995 label *label104
   996 read *tmp190 .memory 66
   997 op add *tmp2 *tmp190 1

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
 
    32 label *label11
    33 wait 0
    34 read *tmp38 .memory 68
-    * jump *label4 notEqual .stop *tmp38
+   35 jump *label3 notEqual .stop *tmp38
    36 read :batch .memory 64
    37 read *tmp41 .memory 64
    38 op add *tmp42 *tmp41 :multiple
 
   846 label *label54
   847 jump *label71 lessThanEq .PALETTE 1
   848 set :drawPixel:color %[black]
-    * jump *label74 equal *tmp88 63
+  849 jump *label72 equal *tmp88 63
   850 multijump .PALETTE 0 0 (m:*label131)
   851 multilabel *label136 (m:*label131)
   852 multilabel *label132 (m:*label131)
   853 op div *tmp162 *tmp88 63.75
   854 op sub :drawPixel:r 1 *tmp162
   855 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * jump *label75 always
+  856 jump *label72 always
   857 multilabel *label133 (m:*label131)
   858 op sub *tmp128 32 *tmp88
   859 op abs *tmp129 *tmp128
 
   866 op div *tmp141 *tmp129 63.75
   867 op add :drawPixel:b 0.47058823529411764 *tmp141
   868 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label75 always
+  869 jump *label72 always
   870 multilabel *label134 (m:*label131)
   871 op div *tmp145 *tmp88 0.175
   872 op sin :drawPixel:r *tmp145
 
   876 op div *tmp153 *tmp151 63.75
   877 op add :drawPixel:b 0.39215686274509803 *tmp153
   878 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label75 always
+  879 jump *label72 always
   880 multilabel *label135 (m:*label131)
   881 op div :drawPixel:r *tmp88 63.75
   882 op div :drawPixel:g *tmp88 170
 
   888 read :drawPixel:color .memory *tmp88
   889 label *label72
   890 jump *label82 lessThan .localBuffer 254
-    * jump *label87 lessThanEq .localBuffer 0
+  891 jump *label95 lessThanEq .localBuffer 0
   892 label *label121
   893 read *tmp172 .memory 68
   894 jump *label87 notEqual .stop *tmp172
 
   926 label *label100
   927 wait 0
   928 read *tmp188 .memory 68
-    * jump *label4 notEqual .stop *tmp188
+  929 jump *label3 notEqual .stop *tmp188
   930 read *tmp190 .memory 66
   931 op add *tmp2 *tmp190 1
   932 write *tmp2 .memory 66
 
   939 select :multiple greaterThanEq :batch 1337.6 1 :multiple
   940 jump *label11 always
   941 label *label13
-    * jump *label111 lessThanEq .localBuffer 0
+  942 jump *label3 lessThanEq .localBuffer 0
   943 label *label122
   944 read *tmp198 .memory 68
-    * jump *label111 notEqual .stop *tmp198
+  945 jump *label3 notEqual .stop *tmp198
   946 wait 0
   947 sensor *tmp199 .display @enabled
   948 jump *label115 equal *tmp199 false

Final code before resolving virtual instructions:

    0:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label0                                                mandelbrot-compute.mnd: do while display == null || memory == null;
    1:  op equal *tmp14 .display null                                ...
    2:  op equal *tmp15 .memory null                                 ...
    3:  op or *tmp16 *tmp14 *tmp15                                   ...
    4:  jump *label0 notEqual *tmp16 false                           ...
        label *label3                                                mandelbrot-compute.mnd: MainLoop:
        label *label6                                                mandelbrot-compute.mnd: do wait(0); while start == $START;
    5:  wait 0                                                       ...
    6:  read *tmp18 .memory 67                                       ...
    7:  jump *label6 equal .start *tmp18                             ...
    8:  read .start .memory 67                                       mandelbrot-compute.mnd: start = $START;
    9:  read .stop .memory 68                                        mandelbrot-compute.mnd: stop = $STOP;
   10:  set .lastColor -1                                            mandelbrot-compute.mnd: lastColor = -1;
   11:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   12:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
   13:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
   14:  read .ZOOM .memory 71                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   15:  op div *tmp22 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   16:  read *tmp24 .memory 69                                       ...
   17:  op add .OFFSET_X *tmp22 *tmp24                               ...
   18:  read *tmp27 .memory 70                                       mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   19:  op add .OFFSET_Y *tmp22 *tmp27                               ...
   20:  read .JULIA .memory 72                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   21:  read .JULIA_X .memory 73                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   22:  read .JULIA_Y .memory 74                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   23:  read .PALETTE .memory 75                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   24:  read .ALL_PASS_COLORING .memory 76                           mandelbrot-compute.mnd: ALL_PASS_COLORING = $ALL_PASS_COLORING;
   25:  read *tmp34 .memory 77                                       mandelbrot-compute.mnd: var leaderLimit = $SHOW_LEADER ? 1 - ALL_PASS_COLORING : 99;
   26:  op sub *tmp204 1 .ALL_PASS_COLORING                          ...
   27:  select *tmp35 notEqual *tmp34 false *tmp204 99               ...
   28:  set :multiple 4                                              mandelbrot-compute.mnd: var multiple = 4;
        label *label11                                               mandelbrot-compute.mnd: while true do
   29:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
   30:  read *tmp38 .memory 68                                       mandelbrot-compute.mnd: if stop != $STOP then
   31:  jump *label3 notEqual .stop *tmp38                           ...
   32:  read :batch .memory 64                                       mandelbrot-compute.mnd: batch = $LINE;
   33:  read *tmp41 .memory 64                                       mandelbrot-compute.mnd: $LINE += multiple;
   34:  op add *tmp42 *tmp41 :multiple                               ...
   35:  write *tmp42 .memory 64                 # The last atomic bl ...
   36:  jump *label13 greaterThanEq :batch 2816                      mandelbrot-compute.mnd: if batch >= TOTAL_BATCHES then
   37:  op mul *tmp46 11 :multiple                                   mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
   38:  set :i 0                                                     ...
   39:  op mul *tmp47 :batch 11                                      ...
   40:  jump *label20 lessThanEq :multiple 0                         ...
        label *label119                                              ...
   41:  op add :adam5:index *tmp47 :i                                mandelbrot-compute.mnd: adam5(batch * BATCH_SIZE + i, out x, out y, out dx, out dy);
   42:  op idiv *tmp50 :adam5:index 16                               mandelbrot-compute.mnd: case index \ 16
   43:  multijump *tmp50 0 0                                         ...
        multilabel *label129                                         ...
   44:  op sub :adam5:index :adam5:index 15488                       mandelbrot-compute.mnd: index -= 8 * PASS_SIZE;
   45:  op mod :adam5:x :adam5:index 176                             mandelbrot-compute.mnd: x = (index % SIZE1);
   46:  op idiv *tmp77 :adam5:index 176                              mandelbrot-compute.mnd: y = 2 * (index \ SIZE1) + 1;
   47:  op mul *tmp78 2 *tmp77                                       ...
   48:  op add :adam5:y *tmp78 1                                     ...
   49:  set :adam5:dy 1                                              mandelbrot-compute.mnd: dx = dy = 1;
   50:  set :adam5:dx 1                                              ...
   51:  jump *label22 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label125                                         ...
   52:  op mod *tmp52 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4);
   53:  op mul :adam5:x 4 *tmp52                                     ...
   54:  op idiv *tmp54 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   55:  op mul :adam5:y 4 *tmp54                                     ...
   56:  select *tmp56 notEqual .ALL_PASS_COLORING false 4 2          mandelbrot-compute.mnd: dx = dy = ALL_PASS_COLORING ? 4 : 2;
   57:  set :adam5:dy *tmp56                                         ...
   58:  set :adam5:dx *tmp56                                         ...
   59:  jump *label22 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label126                                         ...
   60:  op sub :adam5:index :adam5:index 1936                        mandelbrot-compute.mnd: index -= PASS_SIZE;
   61:  op mod *tmp57 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4) + 2;
   62:  op mul *tmp58 4 *tmp57                                       ...
   63:  op add :adam5:x *tmp58 2                                     ...
   64:  op idiv *tmp60 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   65:  op mul :adam5:y 4 *tmp60                                     ...
   66:  select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1       mandelbrot-compute.mnd: dx = ALL_PASS_COLORING ? 2 : 1;
   67:  select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2       mandelbrot-compute.mnd: dy = ALL_PASS_COLORING ? 4 : 2;
   68:  jump *label22 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label127                                         ...
   69:  op sub :adam5:index :adam5:index 3872                        mandelbrot-compute.mnd: index -= 2 * PASS_SIZE;
   70:  op mod *tmp64 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2);
   71:  op mul :adam5:x 2 *tmp64                                     ...
   72:  op idiv *tmp66 :adam5:index 88                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE2) + 2;
   73:  op mul *tmp67 4 *tmp66                                       ...
   74:  op add :adam5:y *tmp67 2                                     ...
   75:  select *tmp69 notEqual .ALL_PASS_COLORING false 2 1          mandelbrot-compute.mnd: dx = dy = ALL_PASS_COLORING ? 2 : 1;
   76:  set :adam5:dy *tmp69                                         ...
   77:  set :adam5:dx *tmp69                                         ...
   78:  jump *label22 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label128                                         ...
   79:  op sub :adam5:index :adam5:index 7744                        mandelbrot-compute.mnd: index -= 4 * PASS_SIZE;
   80:  op mod *tmp70 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2) + 1;
   81:  op mul *tmp71 2 *tmp70                                       ...
   82:  op add :adam5:x *tmp71 1                                     ...
   83:  op idiv *tmp73 :adam5:index 88                               mandelbrot-compute.mnd: y = 2 * (index \ SIZE2);
   84:  op mul :adam5:y 2 *tmp73                                     ...
   85:  set :adam5:dx 1                                              mandelbrot-compute.mnd: dx = 1; dy = ALL_PASS_COLORING ? 2 : 1;
   86:  select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1       ...
        label *label22                                               mandelbrot-compute.mnd: case index \ 16
   87:  jump *label45 lessThanEq :multiple *tmp35                    mandelbrot-compute.mnd: if multiple > leaderLimit and localBuffer == 0 then
   88:  jump *label45 notEqual .localBuffer 0                        ...
   89:  draw col %[white] 0 0 0 0 0                                  mandelbrot-compute.mnd: col(%[white]);
   90:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dx);
   91:  set .lastColor %[white]                                      mandelbrot-compute.mnd: lastColor = %[white];
   92:  set .localBuffer 2                                           mandelbrot-compute.mnd: localBuffer = 2;
   93:  wait 0.004                              # 0.240 ticks for at mandelbrot-compute.mnd: atomic
   94:  sensor *tmp83 .display @enabled                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
   95:  jump *label50 equal *tmp83 false                             ...
   96:  sensor *tmp84 .display @bufferSize                           ...
   97:  jump *label50 greaterThanEq *tmp84 1022                      ...
   98:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
   99:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label50                                               mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label45                                               mandelbrot-compute.mnd: if multiple > leaderLimit and localBuffer == 0 then
  100:  op div *tmp89 :adam5:x .ZOOM                                 mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
  101:  op add :compute:zx *tmp89 .OFFSET_X                          ...
  102:  op div *tmp91 :adam5:y .ZOOM                                 mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
  103:  op add :compute:zy *tmp91 .OFFSET_Y                          ...
  104:  jump *label55 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
  105:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
  106:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
  107:  jump *label56 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label55                                               ...
  108:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
  109:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
  110:  op sub *tmp94 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
  111:  op len :compute:p *tmp94 :compute:zy                         ...
  112:  op mul *tmp96 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  113:  op mul *tmp97 *tmp96 :compute:p                              ...
  114:  op sub *tmp98 :compute:p *tmp97                              ...
  115:  op add *tmp99 *tmp98 0.25                                    ...
  116:  jump *label57 greaterThan :compute:zx *tmp99                 ...
  117:  set *tmp88 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  118:  jump *label54 always 0 0                                     ...
        label *label57                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  119:  op add *tmp102 :compute:zx 1                                 mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  120:  op len *tmp103 *tmp102 :compute:zy                           ...
  121:  jump *label59 greaterThan *tmp103 0.25                       ...
  122:  set *tmp88 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  123:  jump *label54 always 0 0                                     ...
        label *label59                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label56                                               mandelbrot-compute.mnd: if JULIA then
  124:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  125:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  126:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  127:  op mul *tmp107 :compute:zy :compute:zy                       ...
  128:  op sub *tmp108 *tmp106 *tmp107                               ...
  129:  op add :compute:zx *tmp108 :compute:cx                       ...
  130:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  131:  op mul *tmp111 *tmp110 :compute:zy                           ...
  132:  op add :compute:zy *tmp111 :compute:cy                       ...
  133:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  134:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  135:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  136:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  137:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  138:  op mul *tmp107 :compute:zy :compute:zy                       ...
  139:  op sub *tmp108 *tmp106 *tmp107                               ...
  140:  op add :compute:zx *tmp108 :compute:cx                       ...
  141:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  142:  op mul *tmp111 *tmp110 :compute:zy                           ...
  143:  op add :compute:zy *tmp111 :compute:cy                       ...
  144:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  145:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  146:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  147:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  148:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  149:  op mul *tmp107 :compute:zy :compute:zy                       ...
  150:  op sub *tmp108 *tmp106 *tmp107                               ...
  151:  op add :compute:zx *tmp108 :compute:cx                       ...
  152:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  153:  op mul *tmp111 *tmp110 :compute:zy                           ...
  154:  op add :compute:zy *tmp111 :compute:cy                       ...
  155:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  156:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  157:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  158:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  159:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  160:  op mul *tmp107 :compute:zy :compute:zy                       ...
  161:  op sub *tmp108 *tmp106 *tmp107                               ...
  162:  op add :compute:zx *tmp108 :compute:cx                       ...
  163:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  164:  op mul *tmp111 *tmp110 :compute:zy                           ...
  165:  op add :compute:zy *tmp111 :compute:cy                       ...
  166:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  167:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  168:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  169:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  170:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  171:  op mul *tmp107 :compute:zy :compute:zy                       ...
  172:  op sub *tmp108 *tmp106 *tmp107                               ...
  173:  op add :compute:zx *tmp108 :compute:cx                       ...
  174:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  175:  op mul *tmp111 *tmp110 :compute:zy                           ...
  176:  op add :compute:zy *tmp111 :compute:cy                       ...
  177:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  178:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  179:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  180:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  181:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  182:  op mul *tmp107 :compute:zy :compute:zy                       ...
  183:  op sub *tmp108 *tmp106 *tmp107                               ...
  184:  op add :compute:zx *tmp108 :compute:cx                       ...
  185:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  186:  op mul *tmp111 *tmp110 :compute:zy                           ...
  187:  op add :compute:zy *tmp111 :compute:cy                       ...
  188:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  189:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  190:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  191:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  192:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  193:  op mul *tmp107 :compute:zy :compute:zy                       ...
  194:  op sub *tmp108 *tmp106 *tmp107                               ...
  195:  op add :compute:zx *tmp108 :compute:cx                       ...
  196:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  197:  op mul *tmp111 *tmp110 :compute:zy                           ...
  198:  op add :compute:zy *tmp111 :compute:cy                       ...
  199:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  200:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  201:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  202:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  203:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  204:  op mul *tmp107 :compute:zy :compute:zy                       ...
  205:  op sub *tmp108 *tmp106 *tmp107                               ...
  206:  op add :compute:zx *tmp108 :compute:cx                       ...
  207:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  208:  op mul *tmp111 *tmp110 :compute:zy                           ...
  209:  op add :compute:zy *tmp111 :compute:cy                       ...
  210:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  211:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  212:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  213:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  214:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  215:  op mul *tmp107 :compute:zy :compute:zy                       ...
  216:  op sub *tmp108 *tmp106 *tmp107                               ...
  217:  op add :compute:zx *tmp108 :compute:cx                       ...
  218:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  219:  op mul *tmp111 *tmp110 :compute:zy                           ...
  220:  op add :compute:zy *tmp111 :compute:cy                       ...
  221:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  222:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  223:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  224:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  225:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  226:  op mul *tmp107 :compute:zy :compute:zy                       ...
  227:  op sub *tmp108 *tmp106 *tmp107                               ...
  228:  op add :compute:zx *tmp108 :compute:cx                       ...
  229:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  230:  op mul *tmp111 *tmp110 :compute:zy                           ...
  231:  op add :compute:zy *tmp111 :compute:cy                       ...
  232:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  233:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  234:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  235:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  236:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  237:  op mul *tmp107 :compute:zy :compute:zy                       ...
  238:  op sub *tmp108 *tmp106 *tmp107                               ...
  239:  op add :compute:zx *tmp108 :compute:cx                       ...
  240:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  241:  op mul *tmp111 *tmp110 :compute:zy                           ...
  242:  op add :compute:zy *tmp111 :compute:cy                       ...
  243:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  244:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  245:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  246:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  247:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  248:  op mul *tmp107 :compute:zy :compute:zy                       ...
  249:  op sub *tmp108 *tmp106 *tmp107                               ...
  250:  op add :compute:zx *tmp108 :compute:cx                       ...
  251:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  252:  op mul *tmp111 *tmp110 :compute:zy                           ...
  253:  op add :compute:zy *tmp111 :compute:cy                       ...
  254:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  255:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  256:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  257:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  258:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  259:  op mul *tmp107 :compute:zy :compute:zy                       ...
  260:  op sub *tmp108 *tmp106 *tmp107                               ...
  261:  op add :compute:zx *tmp108 :compute:cx                       ...
  262:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  263:  op mul *tmp111 *tmp110 :compute:zy                           ...
  264:  op add :compute:zy *tmp111 :compute:cy                       ...
  265:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  266:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  267:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  268:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  269:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  270:  op mul *tmp107 :compute:zy :compute:zy                       ...
  271:  op sub *tmp108 *tmp106 *tmp107                               ...
  272:  op add :compute:zx *tmp108 :compute:cx                       ...
  273:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  274:  op mul *tmp111 *tmp110 :compute:zy                           ...
  275:  op add :compute:zy *tmp111 :compute:cy                       ...
  276:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  277:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  278:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  279:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  280:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  281:  op mul *tmp107 :compute:zy :compute:zy                       ...
  282:  op sub *tmp108 *tmp106 *tmp107                               ...
  283:  op add :compute:zx *tmp108 :compute:cx                       ...
  284:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  285:  op mul *tmp111 *tmp110 :compute:zy                           ...
  286:  op add :compute:zy *tmp111 :compute:cy                       ...
  287:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  288:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  289:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  290:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  291:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  292:  op mul *tmp107 :compute:zy :compute:zy                       ...
  293:  op sub *tmp108 *tmp106 *tmp107                               ...
  294:  op add :compute:zx *tmp108 :compute:cx                       ...
  295:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  296:  op mul *tmp111 *tmp110 :compute:zy                           ...
  297:  op add :compute:zy *tmp111 :compute:cy                       ...
  298:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  299:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  300:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  301:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  302:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  303:  op mul *tmp107 :compute:zy :compute:zy                       ...
  304:  op sub *tmp108 *tmp106 *tmp107                               ...
  305:  op add :compute:zx *tmp108 :compute:cx                       ...
  306:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  307:  op mul *tmp111 *tmp110 :compute:zy                           ...
  308:  op add :compute:zy *tmp111 :compute:cy                       ...
  309:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  310:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  311:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  312:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  313:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  314:  op mul *tmp107 :compute:zy :compute:zy                       ...
  315:  op sub *tmp108 *tmp106 *tmp107                               ...
  316:  op add :compute:zx *tmp108 :compute:cx                       ...
  317:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  318:  op mul *tmp111 *tmp110 :compute:zy                           ...
  319:  op add :compute:zy *tmp111 :compute:cy                       ...
  320:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  321:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  322:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  323:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  324:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  325:  op mul *tmp107 :compute:zy :compute:zy                       ...
  326:  op sub *tmp108 *tmp106 *tmp107                               ...
  327:  op add :compute:zx *tmp108 :compute:cx                       ...
  328:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  329:  op mul *tmp111 *tmp110 :compute:zy                           ...
  330:  op add :compute:zy *tmp111 :compute:cy                       ...
  331:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  332:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  333:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  334:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  335:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  336:  op mul *tmp107 :compute:zy :compute:zy                       ...
  337:  op sub *tmp108 *tmp106 *tmp107                               ...
  338:  op add :compute:zx *tmp108 :compute:cx                       ...
  339:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  340:  op mul *tmp111 *tmp110 :compute:zy                           ...
  341:  op add :compute:zy *tmp111 :compute:cy                       ...
  342:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  343:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  344:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  345:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  346:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  347:  op mul *tmp107 :compute:zy :compute:zy                       ...
  348:  op sub *tmp108 *tmp106 *tmp107                               ...
  349:  op add :compute:zx *tmp108 :compute:cx                       ...
  350:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  351:  op mul *tmp111 *tmp110 :compute:zy                           ...
  352:  op add :compute:zy *tmp111 :compute:cy                       ...
  353:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  354:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  355:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  356:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  357:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  358:  op mul *tmp107 :compute:zy :compute:zy                       ...
  359:  op sub *tmp108 *tmp106 *tmp107                               ...
  360:  op add :compute:zx *tmp108 :compute:cx                       ...
  361:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  362:  op mul *tmp111 *tmp110 :compute:zy                           ...
  363:  op add :compute:zy *tmp111 :compute:cy                       ...
  364:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  365:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  366:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  367:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  368:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  369:  op mul *tmp107 :compute:zy :compute:zy                       ...
  370:  op sub *tmp108 *tmp106 *tmp107                               ...
  371:  op add :compute:zx *tmp108 :compute:cx                       ...
  372:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  373:  op mul *tmp111 *tmp110 :compute:zy                           ...
  374:  op add :compute:zy *tmp111 :compute:cy                       ...
  375:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  376:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  377:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  378:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  379:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  380:  op mul *tmp107 :compute:zy :compute:zy                       ...
  381:  op sub *tmp108 *tmp106 *tmp107                               ...
  382:  op add :compute:zx *tmp108 :compute:cx                       ...
  383:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  384:  op mul *tmp111 *tmp110 :compute:zy                           ...
  385:  op add :compute:zy *tmp111 :compute:cy                       ...
  386:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  387:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  388:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  389:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  390:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  391:  op mul *tmp107 :compute:zy :compute:zy                       ...
  392:  op sub *tmp108 *tmp106 *tmp107                               ...
  393:  op add :compute:zx *tmp108 :compute:cx                       ...
  394:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  395:  op mul *tmp111 *tmp110 :compute:zy                           ...
  396:  op add :compute:zy *tmp111 :compute:cy                       ...
  397:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  398:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  399:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  400:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  401:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  402:  op mul *tmp107 :compute:zy :compute:zy                       ...
  403:  op sub *tmp108 *tmp106 *tmp107                               ...
  404:  op add :compute:zx *tmp108 :compute:cx                       ...
  405:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  406:  op mul *tmp111 *tmp110 :compute:zy                           ...
  407:  op add :compute:zy *tmp111 :compute:cy                       ...
  408:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  409:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  410:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  411:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  412:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  413:  op mul *tmp107 :compute:zy :compute:zy                       ...
  414:  op sub *tmp108 *tmp106 *tmp107                               ...
  415:  op add :compute:zx *tmp108 :compute:cx                       ...
  416:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  417:  op mul *tmp111 *tmp110 :compute:zy                           ...
  418:  op add :compute:zy *tmp111 :compute:cy                       ...
  419:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  420:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  421:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  422:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  423:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  424:  op mul *tmp107 :compute:zy :compute:zy                       ...
  425:  op sub *tmp108 *tmp106 *tmp107                               ...
  426:  op add :compute:zx *tmp108 :compute:cx                       ...
  427:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  428:  op mul *tmp111 *tmp110 :compute:zy                           ...
  429:  op add :compute:zy *tmp111 :compute:cy                       ...
  430:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  431:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  432:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  433:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  434:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  435:  op mul *tmp107 :compute:zy :compute:zy                       ...
  436:  op sub *tmp108 *tmp106 *tmp107                               ...
  437:  op add :compute:zx *tmp108 :compute:cx                       ...
  438:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  439:  op mul *tmp111 *tmp110 :compute:zy                           ...
  440:  op add :compute:zy *tmp111 :compute:cy                       ...
  441:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  442:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  443:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  444:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  445:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  446:  op mul *tmp107 :compute:zy :compute:zy                       ...
  447:  op sub *tmp108 *tmp106 *tmp107                               ...
  448:  op add :compute:zx *tmp108 :compute:cx                       ...
  449:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  450:  op mul *tmp111 *tmp110 :compute:zy                           ...
  451:  op add :compute:zy *tmp111 :compute:cy                       ...
  452:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  453:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  454:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  455:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  456:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  457:  op mul *tmp107 :compute:zy :compute:zy                       ...
  458:  op sub *tmp108 *tmp106 *tmp107                               ...
  459:  op add :compute:zx *tmp108 :compute:cx                       ...
  460:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  461:  op mul *tmp111 *tmp110 :compute:zy                           ...
  462:  op add :compute:zy *tmp111 :compute:cy                       ...
  463:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  464:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  465:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  466:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  467:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  468:  op mul *tmp107 :compute:zy :compute:zy                       ...
  469:  op sub *tmp108 *tmp106 *tmp107                               ...
  470:  op add :compute:zx *tmp108 :compute:cx                       ...
  471:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  472:  op mul *tmp111 *tmp110 :compute:zy                           ...
  473:  op add :compute:zy *tmp111 :compute:cy                       ...
  474:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  475:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  476:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  477:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  478:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  479:  op mul *tmp107 :compute:zy :compute:zy                       ...
  480:  op sub *tmp108 *tmp106 *tmp107                               ...
  481:  op add :compute:zx *tmp108 :compute:cx                       ...
  482:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  483:  op mul *tmp111 *tmp110 :compute:zy                           ...
  484:  op add :compute:zy *tmp111 :compute:cy                       ...
  485:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  486:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  487:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  488:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  489:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  490:  op mul *tmp107 :compute:zy :compute:zy                       ...
  491:  op sub *tmp108 *tmp106 *tmp107                               ...
  492:  op add :compute:zx *tmp108 :compute:cx                       ...
  493:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  494:  op mul *tmp111 *tmp110 :compute:zy                           ...
  495:  op add :compute:zy *tmp111 :compute:cy                       ...
  496:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  497:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  498:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  499:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  500:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  501:  op mul *tmp107 :compute:zy :compute:zy                       ...
  502:  op sub *tmp108 *tmp106 *tmp107                               ...
  503:  op add :compute:zx *tmp108 :compute:cx                       ...
  504:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  505:  op mul *tmp111 *tmp110 :compute:zy                           ...
  506:  op add :compute:zy *tmp111 :compute:cy                       ...
  507:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  508:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  509:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  510:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  511:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  512:  op mul *tmp107 :compute:zy :compute:zy                       ...
  513:  op sub *tmp108 *tmp106 *tmp107                               ...
  514:  op add :compute:zx *tmp108 :compute:cx                       ...
  515:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  516:  op mul *tmp111 *tmp110 :compute:zy                           ...
  517:  op add :compute:zy *tmp111 :compute:cy                       ...
  518:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  519:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  520:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  521:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  522:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  523:  op mul *tmp107 :compute:zy :compute:zy                       ...
  524:  op sub *tmp108 *tmp106 *tmp107                               ...
  525:  op add :compute:zx *tmp108 :compute:cx                       ...
  526:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  527:  op mul *tmp111 *tmp110 :compute:zy                           ...
  528:  op add :compute:zy *tmp111 :compute:cy                       ...
  529:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  530:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  531:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  532:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  533:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  534:  op mul *tmp107 :compute:zy :compute:zy                       ...
  535:  op sub *tmp108 *tmp106 *tmp107                               ...
  536:  op add :compute:zx *tmp108 :compute:cx                       ...
  537:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  538:  op mul *tmp111 *tmp110 :compute:zy                           ...
  539:  op add :compute:zy *tmp111 :compute:cy                       ...
  540:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  541:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  542:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  543:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  544:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  545:  op mul *tmp107 :compute:zy :compute:zy                       ...
  546:  op sub *tmp108 *tmp106 *tmp107                               ...
  547:  op add :compute:zx *tmp108 :compute:cx                       ...
  548:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  549:  op mul *tmp111 *tmp110 :compute:zy                           ...
  550:  op add :compute:zy *tmp111 :compute:cy                       ...
  551:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  552:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  553:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  554:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  555:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  556:  op mul *tmp107 :compute:zy :compute:zy                       ...
  557:  op sub *tmp108 *tmp106 *tmp107                               ...
  558:  op add :compute:zx *tmp108 :compute:cx                       ...
  559:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  560:  op mul *tmp111 *tmp110 :compute:zy                           ...
  561:  op add :compute:zy *tmp111 :compute:cy                       ...
  562:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  563:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  564:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  565:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  566:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  567:  op mul *tmp107 :compute:zy :compute:zy                       ...
  568:  op sub *tmp108 *tmp106 *tmp107                               ...
  569:  op add :compute:zx *tmp108 :compute:cx                       ...
  570:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  571:  op mul *tmp111 *tmp110 :compute:zy                           ...
  572:  op add :compute:zy *tmp111 :compute:cy                       ...
  573:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  574:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  575:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  576:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  577:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  578:  op mul *tmp107 :compute:zy :compute:zy                       ...
  579:  op sub *tmp108 *tmp106 *tmp107                               ...
  580:  op add :compute:zx *tmp108 :compute:cx                       ...
  581:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  582:  op mul *tmp111 *tmp110 :compute:zy                           ...
  583:  op add :compute:zy *tmp111 :compute:cy                       ...
  584:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  585:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  586:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  587:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  588:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  589:  op mul *tmp107 :compute:zy :compute:zy                       ...
  590:  op sub *tmp108 *tmp106 *tmp107                               ...
  591:  op add :compute:zx *tmp108 :compute:cx                       ...
  592:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  593:  op mul *tmp111 *tmp110 :compute:zy                           ...
  594:  op add :compute:zy *tmp111 :compute:cy                       ...
  595:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  596:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  597:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  598:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  599:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  600:  op mul *tmp107 :compute:zy :compute:zy                       ...
  601:  op sub *tmp108 *tmp106 *tmp107                               ...
  602:  op add :compute:zx *tmp108 :compute:cx                       ...
  603:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  604:  op mul *tmp111 *tmp110 :compute:zy                           ...
  605:  op add :compute:zy *tmp111 :compute:cy                       ...
  606:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  607:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  608:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  609:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  610:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  611:  op mul *tmp107 :compute:zy :compute:zy                       ...
  612:  op sub *tmp108 *tmp106 *tmp107                               ...
  613:  op add :compute:zx *tmp108 :compute:cx                       ...
  614:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  615:  op mul *tmp111 *tmp110 :compute:zy                           ...
  616:  op add :compute:zy *tmp111 :compute:cy                       ...
  617:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  618:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  619:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  620:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  621:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  622:  op mul *tmp107 :compute:zy :compute:zy                       ...
  623:  op sub *tmp108 *tmp106 *tmp107                               ...
  624:  op add :compute:zx *tmp108 :compute:cx                       ...
  625:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  626:  op mul *tmp111 *tmp110 :compute:zy                           ...
  627:  op add :compute:zy *tmp111 :compute:cy                       ...
  628:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  629:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  630:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  631:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  632:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  633:  op mul *tmp107 :compute:zy :compute:zy                       ...
  634:  op sub *tmp108 *tmp106 *tmp107                               ...
  635:  op add :compute:zx *tmp108 :compute:cx                       ...
  636:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  637:  op mul *tmp111 *tmp110 :compute:zy                           ...
  638:  op add :compute:zy *tmp111 :compute:cy                       ...
  639:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  640:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  641:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  642:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  643:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  644:  op mul *tmp107 :compute:zy :compute:zy                       ...
  645:  op sub *tmp108 *tmp106 *tmp107                               ...
  646:  op add :compute:zx *tmp108 :compute:cx                       ...
  647:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  648:  op mul *tmp111 *tmp110 :compute:zy                           ...
  649:  op add :compute:zy *tmp111 :compute:cy                       ...
  650:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  651:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  652:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  653:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  654:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  655:  op mul *tmp107 :compute:zy :compute:zy                       ...
  656:  op sub *tmp108 *tmp106 *tmp107                               ...
  657:  op add :compute:zx *tmp108 :compute:cx                       ...
  658:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  659:  op mul *tmp111 *tmp110 :compute:zy                           ...
  660:  op add :compute:zy *tmp111 :compute:cy                       ...
  661:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  662:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  663:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  664:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  665:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  666:  op mul *tmp107 :compute:zy :compute:zy                       ...
  667:  op sub *tmp108 *tmp106 *tmp107                               ...
  668:  op add :compute:zx *tmp108 :compute:cx                       ...
  669:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  670:  op mul *tmp111 *tmp110 :compute:zy                           ...
  671:  op add :compute:zy *tmp111 :compute:cy                       ...
  672:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  673:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  674:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  675:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  676:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  677:  op mul *tmp107 :compute:zy :compute:zy                       ...
  678:  op sub *tmp108 *tmp106 *tmp107                               ...
  679:  op add :compute:zx *tmp108 :compute:cx                       ...
  680:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  681:  op mul *tmp111 *tmp110 :compute:zy                           ...
  682:  op add :compute:zy *tmp111 :compute:cy                       ...
  683:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  684:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  685:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  686:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  687:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  688:  op mul *tmp107 :compute:zy :compute:zy                       ...
  689:  op sub *tmp108 *tmp106 *tmp107                               ...
  690:  op add :compute:zx *tmp108 :compute:cx                       ...
  691:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  692:  op mul *tmp111 *tmp110 :compute:zy                           ...
  693:  op add :compute:zy *tmp111 :compute:cy                       ...
  694:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  695:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  696:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  697:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  698:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  699:  op mul *tmp107 :compute:zy :compute:zy                       ...
  700:  op sub *tmp108 *tmp106 *tmp107                               ...
  701:  op add :compute:zx *tmp108 :compute:cx                       ...
  702:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  703:  op mul *tmp111 *tmp110 :compute:zy                           ...
  704:  op add :compute:zy *tmp111 :compute:cy                       ...
  705:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  706:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  707:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  708:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  709:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  710:  op mul *tmp107 :compute:zy :compute:zy                       ...
  711:  op sub *tmp108 *tmp106 *tmp107                               ...
  712:  op add :compute:zx *tmp108 :compute:cx                       ...
  713:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  714:  op mul *tmp111 *tmp110 :compute:zy                           ...
  715:  op add :compute:zy *tmp111 :compute:cy                       ...
  716:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  717:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  718:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  719:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  720:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  721:  op mul *tmp107 :compute:zy :compute:zy                       ...
  722:  op sub *tmp108 *tmp106 *tmp107                               ...
  723:  op add :compute:zx *tmp108 :compute:cx                       ...
  724:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  725:  op mul *tmp111 *tmp110 :compute:zy                           ...
  726:  op add :compute:zy *tmp111 :compute:cy                       ...
  727:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  728:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  729:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  730:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  731:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  732:  op mul *tmp107 :compute:zy :compute:zy                       ...
  733:  op sub *tmp108 *tmp106 *tmp107                               ...
  734:  op add :compute:zx *tmp108 :compute:cx                       ...
  735:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  736:  op mul *tmp111 *tmp110 :compute:zy                           ...
  737:  op add :compute:zy *tmp111 :compute:cy                       ...
  738:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  739:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  740:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  741:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  742:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  743:  op mul *tmp107 :compute:zy :compute:zy                       ...
  744:  op sub *tmp108 *tmp106 *tmp107                               ...
  745:  op add :compute:zx *tmp108 :compute:cx                       ...
  746:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  747:  op mul *tmp111 *tmp110 :compute:zy                           ...
  748:  op add :compute:zy *tmp111 :compute:cy                       ...
  749:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  750:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  751:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  752:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  753:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  754:  op mul *tmp107 :compute:zy :compute:zy                       ...
  755:  op sub *tmp108 *tmp106 *tmp107                               ...
  756:  op add :compute:zx *tmp108 :compute:cx                       ...
  757:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  758:  op mul *tmp111 *tmp110 :compute:zy                           ...
  759:  op add :compute:zy *tmp111 :compute:cy                       ...
  760:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  761:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  762:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  763:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  764:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  765:  op mul *tmp107 :compute:zy :compute:zy                       ...
  766:  op sub *tmp108 *tmp106 *tmp107                               ...
  767:  op add :compute:zx *tmp108 :compute:cx                       ...
  768:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  769:  op mul *tmp111 *tmp110 :compute:zy                           ...
  770:  op add :compute:zy *tmp111 :compute:cy                       ...
  771:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  772:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  773:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  774:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  775:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  776:  op mul *tmp107 :compute:zy :compute:zy                       ...
  777:  op sub *tmp108 *tmp106 *tmp107                               ...
  778:  op add :compute:zx *tmp108 :compute:cx                       ...
  779:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  780:  op mul *tmp111 *tmp110 :compute:zy                           ...
  781:  op add :compute:zy *tmp111 :compute:cy                       ...
  782:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  783:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  784:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  785:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  786:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  787:  op mul *tmp107 :compute:zy :compute:zy                       ...
  788:  op sub *tmp108 *tmp106 *tmp107                               ...
  789:  op add :compute:zx *tmp108 :compute:cx                       ...
  790:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  791:  op mul *tmp111 *tmp110 :compute:zy                           ...
  792:  op add :compute:zy *tmp111 :compute:cy                       ...
  793:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  794:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  795:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  796:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  797:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  798:  op mul *tmp107 :compute:zy :compute:zy                       ...
  799:  op sub *tmp108 *tmp106 *tmp107                               ...
  800:  op add :compute:zx *tmp108 :compute:cx                       ...
  801:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  802:  op mul *tmp111 *tmp110 :compute:zy                           ...
  803:  op add :compute:zy *tmp111 :compute:cy                       ...
  804:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  805:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  806:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  807:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  808:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  809:  op mul *tmp107 :compute:zy :compute:zy                       ...
  810:  op sub *tmp108 *tmp106 *tmp107                               ...
  811:  op add :compute:zx *tmp108 :compute:cx                       ...
  812:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  813:  op mul *tmp111 *tmp110 :compute:zy                           ...
  814:  op add :compute:zy *tmp111 :compute:cy                       ...
  815:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  816:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  817:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label63                                               ...
  818:  jump *label66 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  819:  jump *label66 greaterThanEq :compute:i 63                    ...
  820:  op log *tmp118 :compute:dist 0                               mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  821:  op mul *tmp119 *tmp118 0.36067376022224085                   ...
  822:  op log *tmp120 *tmp119 0                                     ...
  823:  op mul *tmp121 *tmp120 1.4426950408889634                    ...
  824:  op sub :compute:correction 4 *tmp121                         ...
  825:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label66                                               mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  826:  set *tmp88 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label54                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  827:  jump *label71 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH then
  828:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  829:  jump *label72 equal *tmp88 63                                mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  830:  multijump .PALETTE 0 0                                       mandelbrot-compute.mnd: case PALETTE
        multilabel *label136                                         ...
        multilabel *label132                                         ...
  831:  op div *tmp162 *tmp88 63.75                                  mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  832:  op sub :drawPixel:r 1 *tmp162                                ...
  833:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  834:  jump *label72 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label133                                         ...
  835:  op sub *tmp128 32 *tmp88                                     mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  836:  op abs *tmp129 *tmp128 0                                     ...
  837:  op div *tmp131 *tmp129 36.42857142857143                     ...
  838:  op sub :drawPixel:r 1 *tmp131                                ...
  839:  op sub *tmp133 *tmp88 32                                     mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  840:  op abs *tmp134 *tmp133 0                                     ...
  841:  op div *tmp136 *tmp134 42.5                                  ...
  842:  op sub :drawPixel:g 0.9411764705882353 *tmp136               ...
  843:  op div *tmp141 *tmp129 63.75                                 mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  844:  op add :drawPixel:b 0.47058823529411764 *tmp141              ...
  845:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  846:  jump *label72 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label134                                         ...
  847:  op div *tmp145 *tmp88 0.175                                  mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  848:  op sin :drawPixel:r *tmp145 0                                ...
  849:  op cos :drawPixel:g *tmp145 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  850:  op sub *tmp150 *tmp88 32                                     mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  851:  op abs *tmp151 *tmp150 0                                     ...
  852:  op div *tmp153 *tmp151 63.75                                 ...
  853:  op add :drawPixel:b 0.39215686274509803 *tmp153              ...
  854:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  855:  jump *label72 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label135                                         ...
  856:  op div :drawPixel:r *tmp88 63.75                             mandelbrot-compute.mnd: r = 4 * iterations / 255;
  857:  op div :drawPixel:g *tmp88 170                               mandelbrot-compute.mnd: g = 1.5 * iterations / 255;
  858:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  859:  jump *label72 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label71                                               ...
  860:  read :drawPixel:color .memory *tmp88                         mandelbrot-compute.mnd: color = memory[iterations];
        label *label72                                               mandelbrot-compute.mnd: if SMOOTH then
  861:  jump *label82 lessThan .localBuffer 254                      mandelbrot-compute.mnd: if localBuffer >= 254 then
  862:  jump *label95 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label121                                              ...
  863:  read *tmp172 .memory 68                                      ...
  864:  jump *label87 notEqual .stop *tmp172                         ...
  865:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  866:  sensor *tmp173 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  867:  jump *label91 equal *tmp173 false                            ...
  868:  sensor *tmp174 .display @bufferSize                          ...
  869:  op sub *tmp175 1024 *tmp174                                  ...
  870:  jump *label91 greaterThanEq .localBuffer *tmp175             ...
  871:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  872:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label91                                               mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  873:  jump *label121 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label87                                               ...
        label *label82                                               mandelbrot-compute.mnd: if localBuffer >= 254 then
  874:  jump *label95 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  875:  jump *label95 strictNotEqual :drawPixel:color .lastColor     ...
  876:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  877:  op add .localBuffer .localBuffer 1                           mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  878:  jump *label96 always 0 0                                     ...
        label *label95                                               ...
  879:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  880:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  881:  set .lastColor :drawPixel:color                              mandelbrot-compute.mnd: lastColor = color;
  882:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
        label *label96                                               mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  883:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  884:  sensor *tmp182 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  885:  jump *label100 equal *tmp182 false                           ...
  886:  sensor *tmp183 .display @bufferSize                          ...
  887:  op sub *tmp184 1024 *tmp183                                  ...
  888:  jump *label100 greaterThanEq .localBuffer *tmp184            ...
  889:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  890:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label100                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  891:  wait 0.006                              # 0.360 ticks for at mandelbrot-compute.mnd: atomic
  892:  read *tmp188 .memory 68                                      mandelbrot-compute.mnd: if stop != $STOP then
  893:  jump *label3 notEqual .stop *tmp188                          ...
  894:  read *tmp190 .memory 66                                      mandelbrot-compute.mnd: atomic
  895:  op add *tmp2 *tmp190 1                                       ...
  896:  write *tmp2 .memory 66                                       ...
  897:  read *tmp192 .memory 65                                      mandelbrot-compute.mnd: $ITERATIONS += iterations;
  898:  op add *tmp193 *tmp192 *tmp88                                ...
  899:  write *tmp193 .memory 65                # The last atomic bl ...
  900:  op add :i :i 1                                               mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
  901:  jump *label119 lessThan :i *tmp46                            ...
        label *label20                                               ...
  902:  select :multiple greaterThanEq :batch 1337.6 1 :multiple     mandelbrot-compute.mnd: if batch >= TOTAL_BATCHES * 0.475 then multiple = 1; end;
  903:  jump *label11 always 0 0                                     mandelbrot-compute.mnd: while true do
        label *label13                                               ...
  904:  jump *label3 lessThanEq .localBuffer 0                       mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label122                                              ...
  905:  read *tmp198 .memory 68                                      ...
  906:  jump *label3 notEqual .stop *tmp198                          ...
  907:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  908:  sensor *tmp199 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  909:  jump *label115 equal *tmp199 false                           ...
  910:  sensor *tmp200 .display @bufferSize                          ...
  911:  op sub *tmp201 1024 *tmp200                                  ...
  912:  jump *label115 greaterThanEq .localBuffer *tmp201            ...
  913:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  914:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label115                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  915:  jump *label122 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
  916:  jump *label3 always 0 0                                      mandelbrot-compute.mnd: MainLoop:


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   727     1x    727,0  inline def compute(in x, in y)
    63     1x     63,0  <no function>
    45     1x     45,0  void adam5(in index, out x, out y, out dx, out dy)
    44     1x     44,0  inline void drawPixel(in x, in y, in dx, in dy, in iterations)
    31     4x      7,8  inline void tryFlush()
     8     2x      4,0  inline void flush()
Runtime error at instruction #2: 'op equal *tmp15 .memory null':
Execution step limit of 100,000 exceeded.

Performance: parsed in 303 ms, compiled in 302 ms, optimized in 1,382 ms, run in 92 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (100,000 steps):
The program didn't generate any output.
