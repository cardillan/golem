   417 instructions before optimizations.
    39 instructions eliminated by Temp Variables Elimination (8 iterations).
     2 instructions eliminated by Case Expression Optimization.
    48 instructions eliminated by Dead Code Elimination (7 iterations).
     6 instructions eliminated by Jump Normalization (2 passes, 8 iterations).
    21 instructions eliminated by Condition Optimization (2 passes, 10 iterations).
    20 instructions eliminated by Single Step Elimination (2 passes, 10 iterations).
     4 instructions eliminated by Expression Optimization (2 passes, 5 iterations).
     3 instructions eliminated by Boolean Optimization (2 passes, 10 iterations).
       3 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by If Expression Optimization (5 iterations).
    55 instructions eliminated by Data Flow Optimization (6 passes, 24 iterations).
       5 loop conditions were partially rotated.
   741 instructions added by Loop Unrolling (11 iterations).
     4 loops unrolled by Loop Unrolling.
     9 instructions eliminated by Case Switching (11 iterations).
     2 case expressions converted to fast dispatch by Case Switching.
    69 instructions eliminated by Jump Straightening (2 passes, 10 iterations).
     9 instructions updated by Jump Threading.
     2 instructions eliminated by Unreachable Code Elimination (2 passes, 3 iterations).
     7 instructions eliminated by Print Merging.
   872 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 763):
    Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity
  * Unroll iteration loop at *blocks:68:13                       size    -9, benefit     9375.0, efficiency   Infinity (-3 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
    Fast-dispatch case at mandelbrot-compute.mnd:80:25           size    -8, benefit     6250.0, efficiency   Infinity
    Fast-dispatch case at mandelbrot-compute.mnd:155:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 766):
  * Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:80:25           size    -8, benefit     6250.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:155:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 770):
  * Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity (-2 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:80:25           size    -8, benefit     6250.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:155:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 772):
  * Fast-dispatch case at mandelbrot-compute.mnd:80:25           size    -8, benefit     6250.0, efficiency   Infinity (-7 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:155:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 779):
  * Fast-dispatch case at mandelbrot-compute.mnd:155:13          size    -2, benefit     3906.3, efficiency   Infinity (-2 instructions)

Pass 2: speed optimization selection (cost limit 789):
  * Unroll loop at mandelbrot-compute.mnd:128:5                  size  +679, benefit 49218750.0, efficiency  72487.113 (+743 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
   170 label *label39
   171 set *tmp45 null
   172 label *label40
-    * set *tmp47 :line
-    * jump *label44 lessThan *tmp47 0
-    * jump *label43 lessThan *tmp47 22
+  173 jump *label44 lessThan :line 0
+  174 jump *label43 lessThan :line 22
   175 label *label44
   176 jump *label42 always
   177 label *label43
 
   179 set *tmp46 *tmp48
   180 jump *label41 always
   181 label *label42
-    * jump *label47 lessThan *tmp47 22
-    * jump *label46 lessThan *tmp47 44
+  182 jump *label47 lessThan :line 22
+  183 jump *label46 lessThan :line 44
   184 label *label47
   185 jump *label45 always
   186 label *label46
 
   190 set *tmp46 *tmp51
   191 jump *label41 always
   192 label *label45
-    * jump *label50 lessThan *tmp47 44
-    * jump *label49 lessThan *tmp47 88
+  193 jump *label50 lessThan :line 44
+  194 jump *label49 lessThan :line 88
   195 label *label50
   196 jump *label48 always
   197 label *label49
 
   316 set *tmp98 :drawPixel:color
   317 jump *label72 always
   318 label *label71
-    * set *tmp100 .PALETTE
-    * jump *label75 equal *tmp100 2
+  319 jump *label75 equal .PALETTE 2
   320 jump *label74 always
   321 label *label75
   322 op sub *tmp101 32 :drawPixel:iterations
 
   342 set *tmp99 :drawPixel:color
   343 jump *label73 always
   344 label *label74
-    * jump *label77 equal *tmp100 3
+  345 jump *label77 equal .PALETTE 3
   346 jump *label76 always
   347 label *label77
   348 op div *tmp117 :drawPixel:iterations 63
 
   364 set *tmp99 :drawPixel:color
   365 jump *label73 always
   366 label *label76
-    * jump *label79 equal *tmp100 4
+  367 jump *label79 equal .PALETTE 4
   368 jump *label78 always
   369 label *label79
   370 op mul *tmp129 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-31 instructions):
 
    58 label *label19
    59 set *tmp19 null
    60 label *label20
-    * set *tmp17 *tmp19
    61 jump *label18 always
    62 label *label17
-    * set *tmp17 null
    63 label *label18
    64 label *label13
    65 multijump *tmp15 0 0 (m:marker1)
 
    91 print :findLinkedBlocks:variable
    92 jump *label26 equal :findLinkedBlocks:required false
    93 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * set *tmp21 :findLinkedBlocks:foundAll
    94 jump *label27 always
    95 label *label26
-    * set *tmp21 null
    96 label *label27
    97 label *label22
    98 multijump *tmp20 0 0 (m:marker2)
 
   148 op notEqual *tmp39 .stop *tmp40
   149 jump *label37 equal *tmp39 false
   150 jump *label29 always
-    * set *tmp41 null
   151 jump *label38 always
   152 label *label37
-    * set *tmp41 null
   153 label *label38
   154 read *tmp42 .memory 64
   155 set *tmp43 *tmp42
 
   159 op greaterThanEq *tmp44 :line 176
   160 jump *label39 equal *tmp44 false
   161 jump *label36 always
-    * set *tmp45 null
   162 jump *label40 always
   163 label *label39
-    * set *tmp45 null
   164 label *label40
   165 jump *label44 lessThan :line 0
   166 jump *label43 lessThan :line 22
 
   216 jump *label55 equal .JULIA false
   217 set :compute:cx .JULIA_X
   218 set :compute:cy .JULIA_Y
-    * set *tmp65 :compute:cy
   219 jump *label56 always
   220 label *label55
   221 set :compute:cx :compute:zx
 
   231 jump *label57 equal *tmp72 false
   232 set *tmp60 63
   233 jump *label54 always
-    * set *tmp73 null
   234 jump *label58 always
   235 label *label57
-    * set *tmp73 null
   236 label *label58
   237 op add *tmp74 :compute:cx 1
   238 op len *tmp75 *tmp74 :compute:cy
 
   245 label *label59
   246 set *tmp77 null
   247 label *label60
-    * set *tmp65 *tmp77
   248 label *label56
   249 set :compute:i 0
   250 label *label61
 
   265 op greaterThanEq *tmp86 :compute:dist 64
   266 jump *label64 equal *tmp86 false
   267 jump *label63 always
-    * set *tmp87 null
   268 jump *label65 always
   269 label *label64
-    * set *tmp87 null
   270 label *label65
   271 label *label62
   272 op add :compute:i :compute:i 1
 
   282 op sub *tmp95 4 *tmp94
   283 set :compute:correction *tmp95
   284 op add :compute:i :compute:i :compute:correction
-    * set *tmp90 :compute:i
   285 jump *label67 always
   286 label *label66
-    * set *tmp90 null
   287 label *label67
   288 set *tmp60 :compute:i
   289 jump *label54 always
 
   373 label *label73
   374 set *tmp98 *tmp99
   375 label *label72
-    * set *tmp96 *tmp98
   376 jump *label70 always
   377 label *label69
   378 set *tmp139 :drawPixel:iterations
   379 read *tmp141 .memory *tmp139
   380 set :drawPixel:color *tmp141
-    * set *tmp96 :drawPixel:color
   381 label *label70
   382 op greaterThanEq *tmp142 .localBuffer 254
   383 jump *label80 equal *tmp142 false
 
   398 label *label89
   399 set *tmp150 null
   400 label *label90
-    * set *tmp146 *tmp150
   401 jump *label88 always
   402 label *label87
-    * set *tmp146 null
   403 label *label88
   404 label *label86
   405 label *label84
   406 jump *label83 always
   407 label *label85
   408 label *label82
-    * set *tmp143 null
   409 jump *label81 always
   410 label *label80
-    * set *tmp143 null
   411 label *label81
   412 op greaterThan *tmp151 .localBuffer 0
   413 jump *label91 equal *tmp151 false
 
   419 draw rect :drawPixel:x :drawPixel:y 1 1
   420 set *tmp154 .localBuffer
   421 op add .localBuffer .localBuffer 1
-    * set *tmp153 *tmp154
   422 jump *label92 always
   423 label *label91
   424 draw col :drawPixel:color
   425 draw rect :drawPixel:x :drawPixel:y 1 1
   426 set .lastColor :drawPixel:color
   427 op add .localBuffer .localBuffer 2
-    * set *tmp153 .localBuffer
   428 label *label92
   429 wait 0
   430 sensor *tmp155 .display @enabled
 
   440 label *label98
   441 set *tmp160 null
   442 label *label99
-    * set *tmp156 *tmp160
   443 jump *label97 always
   444 label *label96
-    * set *tmp156 null
   445 label *label97
   446 label *label95
   447 label *label68
   448 wait 0
   449 read *tmp161 .memory 65
-    * set *tmp162 *tmp161
   450 op add *tmp1 *tmp161 1
   451 write *tmp1 .memory 65
   452 read *tmp164 .memory 67
   453 op notEqual *tmp163 .stop *tmp164
   454 jump *label100 equal *tmp163 false
   455 jump *label29 always
-    * set *tmp165 null
   456 jump *label101 always
   457 label *label100
-    * set *tmp165 null
   458 label *label101
   459 label *label52
   460 op add :y :y 1
 
   477 label *label109
   478 set *tmp172 null
   479 label *label110
-    * set *tmp168 *tmp172
   480 jump *label108 always
   481 label *label107
-    * set *tmp168 null
   482 label *label108
   483 label *label106
   484 label *label104

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-13 instructions):
 
    53 op equal *tmp18 :findLinkedBlocks:requested @message
    54 jump *label19 equal *tmp18 false
    55 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * set *tmp19 :findLinkedBlocks:message
    56 jump *label20 always
    57 label *label19
-    * set *tmp19 null
    58 label *label20
    59 jump *label18 always
    60 label *label17
 
   238 jump *label59 equal *tmp76 false
   239 set *tmp60 63
   240 jump *label54 always
-    * set *tmp77 null
   241 jump *label60 always
   242 label *label59
-    * set *tmp77 null
   243 label *label60
   244 label *label56
   245 set :compute:i 0
 
   293 op equal *tmp97 :drawPixel:iterations 63
   294 jump *label71 equal *tmp97 false
   295 set :drawPixel:color %[black]
-    * set *tmp98 :drawPixel:color
   296 jump *label72 always
   297 label *label71
   298 jump *label75 equal .PALETTE 2
 
   366 set :drawPixel:color *tmp138
   367 set *tmp99 :drawPixel:color
   368 label *label73
-    * set *tmp98 *tmp99
   369 label *label72
   370 jump *label70 always
   371 label *label69
 
   387 jump *label89 equal *tmp149 false
   388 drawflush .display
   389 set .localBuffer 0
-    * set *tmp150 .localBuffer
   390 jump *label90 always
   391 label *label89
-    * set *tmp150 null
   392 label *label90
   393 jump *label88 always
   394 label *label87
 
   409 jump *label93 always
   410 label *label93
   411 draw rect :drawPixel:x :drawPixel:y 1 1
-    * set *tmp154 .localBuffer
   412 op add .localBuffer .localBuffer 1
   413 jump *label92 always
   414 label *label91
 
   426 jump *label98 equal *tmp159 false
   427 drawflush .display
   428 set .localBuffer 0
-    * set *tmp160 .localBuffer
   429 jump *label99 always
   430 label *label98
-    * set *tmp160 null
   431 label *label99
   432 jump *label97 always
   433 label *label96
 
   461 jump *label109 equal *tmp171 false
   462 drawflush .display
   463 set .localBuffer 0
-    * set *tmp172 .localBuffer
   464 jump *label110 always
   465 label *label109
-    * set *tmp172 null
   466 label *label110
   467 jump *label108 always
   468 label *label107

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   318 set :drawPixel:b *tmp115
   319 packcolor *tmp116 :drawPixel:r :drawPixel:g :drawPixel:b 1
   320 set :drawPixel:color *tmp116
-    * set *tmp99 :drawPixel:color
   321 jump *label73 always
   322 label *label74
   323 jump *label77 equal .PALETTE 3
 
   339 set :drawPixel:b *tmp127
   340 packcolor *tmp128 :drawPixel:r :drawPixel:g :drawPixel:b 1
   341 set :drawPixel:color *tmp128
-    * set *tmp99 :drawPixel:color
   342 jump *label73 always
   343 label *label76
   344 jump *label79 equal .PALETTE 4
 
   353 set :drawPixel:g *tmp133
   354 packcolor *tmp134 :drawPixel:r :drawPixel:g 0 1
   355 set :drawPixel:color *tmp134
-    * set *tmp99 :drawPixel:color
   356 jump *label73 always
   357 label *label78
   358 op mul *tmp135 4 :drawPixel:iterations
 
   361 set :drawPixel:r *tmp137
   362 packcolor *tmp138 :drawPixel:r :drawPixel:r 0 1
   363 set :drawPixel:color *tmp138
-    * set *tmp99 :drawPixel:color
   364 label *label73
   365 label *label72
   366 jump *label70 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-39 instructions):
 
    27 op greaterThan *tmp12 :findLinkedBlocks:n 0
    28 jump *label11 equal *tmp12 false
    29 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
-    * getlink *tmp13 :findLinkedBlocks:n
-    * set :findLinkedBlocks:block *tmp13
+   30 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    31 print "\nFound: "
    32 print :findLinkedBlocks:block
-    * sensor *tmp14 :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:type *tmp14
+   33 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    34 set :findLinkedBlocks:requested @large-logic-display
    35 set :findLinkedBlocks:name "Display"
    36 set :findLinkedBlocks:variable .display
 
   110 op equal *tmp23 .start *tmp24
   111 jump *label31 notEqual *tmp23 false
   112 label *label33
-    * read *tmp25 .memory 66
-    * set .start *tmp25
-    * read *tmp26 .memory 67
-    * set .stop *tmp26
+  113 read .start .memory 66
+  114 read .stop .memory 67
   115 set .lastColor -1
   116 set .localBuffer 0
   117 drawflush null
-    * read *tmp27 .memory 70
-    * set .ZOOM *tmp27
+  118 read .ZOOM .memory 70
   119 op div *tmp28 -88 .ZOOM
   120 read *tmp30 .memory 68
-    * op add *tmp29 *tmp28 *tmp30
-    * set .OFFSET_X *tmp29
+  121 op add .OFFSET_X *tmp28 *tmp30
   122 op div *tmp31 -88 .ZOOM
   123 read *tmp33 .memory 69
-    * op add *tmp32 *tmp31 *tmp33
-    * set .OFFSET_Y *tmp32
-    * read *tmp34 .memory 71
-    * set .JULIA *tmp34
-    * read *tmp35 .memory 72
-    * set .JULIA_X *tmp35
-    * read *tmp36 .memory 73
-    * set .JULIA_Y *tmp36
-    * read *tmp37 .memory 74
-    * set .PALETTE *tmp37
-    * op greaterThan *tmp38 .PALETTE 1
-    * set .SMOOTH *tmp38
+  124 op add .OFFSET_Y *tmp31 *tmp33
+  125 read .JULIA .memory 71
+  126 read .JULIA_X .memory 72
+  127 read .JULIA_Y .memory 73
+  128 read .PALETTE .memory 74
+  129 op greaterThan .SMOOTH .PALETTE 1
   130 label *label34
   131 jump *label36 equal true false
   132 wait 0
 
   153 label *label44
   154 jump *label42 always
   155 label *label43
-    * op mul *tmp48 8 :line
-    * set *tmp46 *tmp48
+  156 op mul *tmp46 8 :line
   157 jump *label41 always
   158 label *label42
   159 jump *label47 lessThan :line 22
 
   163 label *label46
   164 op mul *tmp49 8 :line
   165 op sub *tmp50 *tmp49 176
-    * op add *tmp51 *tmp50 4
-    * set *tmp46 *tmp51
+  166 op add *tmp46 *tmp50 4
   167 jump *label41 always
   168 label *label45
   169 jump *label50 lessThan :line 44
 
   173 label *label49
   174 op mul *tmp52 4 :line
   175 op sub *tmp53 *tmp52 176
-    * op add *tmp54 *tmp53 2
-    * set *tmp46 *tmp54
+  176 op add *tmp46 *tmp53 2
   177 jump *label41 always
   178 label *label48
   179 op mul *tmp55 2 :line
   180 op sub *tmp56 *tmp55 176
-    * op add *tmp57 *tmp56 1
-    * set *tmp46 *tmp57
+  181 op add *tmp46 *tmp56 1
   182 label *label41
   183 set :strip *tmp46
   184 op mul *tmp58 17 :strip
-    * op mod *tmp59 *tmp58 176
-    * set :x *tmp59
+  185 op mod :x *tmp58 176
   186 set :y 0
   187 label *label51
   188 jump *label53 greaterThanEq :y 176
   189 set :compute:x :x
   190 set :compute:y :y
   191 op div *tmp61 :compute:x .ZOOM
-    * op add *tmp62 *tmp61 .OFFSET_X
-    * set :compute:zx *tmp62
+  192 op add :compute:zx *tmp61 .OFFSET_X
   193 op div *tmp63 :compute:y .ZOOM
-    * op add *tmp64 *tmp63 .OFFSET_Y
-    * set :compute:zy *tmp64
+  194 op add :compute:zy *tmp63 .OFFSET_Y
   195 jump *label55 equal .JULIA false
   196 set :compute:cx .JULIA_X
   197 set :compute:cy .JULIA_Y
 
   200 set :compute:cx :compute:zx
   201 set :compute:cy :compute:zy
   202 op sub *tmp66 :compute:cx 0.25
-    * op len *tmp67 *tmp66 :compute:cy
-    * set :compute:p *tmp67
+  203 op len :compute:p *tmp66 :compute:cy
   204 op mul *tmp68 2 :compute:p
   205 op mul *tmp69 *tmp68 :compute:p
   206 op sub *tmp70 :compute:p *tmp69
 
   230 op mul *tmp78 :compute:x1 :compute:x1
   231 op mul *tmp79 :compute:y1 :compute:y1
   232 op sub *tmp80 *tmp78 *tmp79
-    * op add *tmp81 *tmp80 :compute:cx
-    * set :compute:zx *tmp81
+  233 op add :compute:zx *tmp80 :compute:cx
   234 op mul *tmp82 2 :compute:x1
   235 op mul *tmp83 *tmp82 :compute:y1
-    * op add *tmp84 *tmp83 :compute:cy
-    * set :compute:zy *tmp84
-    * op len *tmp85 :compute:zx :compute:zy
-    * set :compute:dist *tmp85
+  236 op add :compute:zy *tmp83 :compute:cy
+  237 op len :compute:dist :compute:zx :compute:zy
   238 op greaterThanEq *tmp86 :compute:dist 64
   239 jump *label64 equal *tmp86 false
   240 jump *label63 always
 
   252 op mul *tmp92 *tmp91 0.36067376022224085
   253 op log *tmp93 *tmp92
   254 op mul *tmp94 *tmp93 1.4426950408889634
-    * op sub *tmp95 4 *tmp94
-    * set :compute:correction *tmp95
+  255 op sub :compute:correction 4 *tmp94
   256 op add :compute:i :compute:i :compute:correction
   257 jump *label67 always
   258 label *label66
 
   278 op abs *tmp102 *tmp101
   279 op mul *tmp103 7 *tmp102
   280 op div *tmp104 *tmp103 255
-    * op sub *tmp105 1 *tmp104
-    * set :drawPixel:r *tmp105
+  281 op sub :drawPixel:r 1 *tmp104
   282 op sub *tmp106 :drawPixel:iterations 32
   283 op abs *tmp107 *tmp106
   284 op mul *tmp108 6 *tmp107
   285 op div *tmp109 *tmp108 255
-    * op sub *tmp110 0.9411764705882353 *tmp109
-    * set :drawPixel:g *tmp110
+  286 op sub :drawPixel:g 0.9411764705882353 *tmp109
   287 op sub *tmp111 32 :drawPixel:iterations
   288 op abs *tmp112 *tmp111
   289 op mul *tmp113 4 *tmp112
   290 op div *tmp114 *tmp113 255
-    * op add *tmp115 0.47058823529411764 *tmp114
-    * set :drawPixel:b *tmp115
-    * packcolor *tmp116 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp116
+  291 op add :drawPixel:b 0.47058823529411764 *tmp114
+  292 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   293 jump *label73 always
   294 label *label74
   295 jump *label77 equal .PALETTE 3
 
   297 label *label77
   298 op div *tmp117 :drawPixel:iterations 63
   299 op mul *tmp118 *tmp117 360
-    * op sin *tmp119 *tmp118
-    * set :drawPixel:r *tmp119
+  300 op sin :drawPixel:r *tmp118
   301 op div *tmp120 :drawPixel:iterations 63
   302 op mul *tmp121 *tmp120 360
-    * op cos *tmp122 *tmp121
-    * set :drawPixel:g *tmp122
+  303 op cos :drawPixel:g *tmp121
   304 op sub *tmp123 :drawPixel:iterations 32
   305 op abs *tmp124 *tmp123
   306 op mul *tmp125 4 *tmp124
   307 op div *tmp126 *tmp125 255
-    * op add *tmp127 0.39215686274509803 *tmp126
-    * set :drawPixel:b *tmp127
-    * packcolor *tmp128 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp128
+  308 op add :drawPixel:b 0.39215686274509803 *tmp126
+  309 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   310 jump *label73 always
   311 label *label76
   312 jump *label79 equal .PALETTE 4
   313 jump *label78 always
   314 label *label79
   315 op mul *tmp129 4 :drawPixel:iterations
-    * op div *tmp130 *tmp129 255
-    * set :drawPixel:r *tmp130
+  316 op div :drawPixel:r *tmp129 255
   317 op mul *tmp131 1.5 :drawPixel:iterations
   318 op div *tmp132 *tmp131 255
-    * op add *tmp133 96 *tmp132
-    * set :drawPixel:g *tmp133
-    * packcolor *tmp134 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp134
+  319 op add :drawPixel:g 96 *tmp132
+  320 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   321 jump *label73 always
   322 label *label78
   323 op mul *tmp135 4 :drawPixel:iterations
   324 op div *tmp136 *tmp135 255
-    * op sub *tmp137 1 *tmp136
-    * set :drawPixel:r *tmp137
-    * packcolor *tmp138 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp138
+  325 op sub :drawPixel:r 1 *tmp136
+  326 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   327 label *label73
   328 label *label72
   329 jump *label70 always
   330 label *label69
-    * set *tmp139 :drawPixel:iterations
-    * read *tmp141 .memory *tmp139
-    * set :drawPixel:color *tmp141
+  331 read :drawPixel:color .memory :drawPixel:iterations
   332 label *label70
   333 op greaterThanEq *tmp142 .localBuffer 254
   334 jump *label80 equal *tmp142 false

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
   102 label *label3
   103 label *label0
   104 label *label28
-    * jump *label30 equal true false
   105 label *label31
   106 wait 0
   107 label *label32
 
   127 read .PALETTE .memory 74
   128 op greaterThan .SMOOTH .PALETTE 1
   129 label *label34
-    * jump *label36 equal true false
   130 wait 0
   131 read *tmp40 .memory 67
   132 op notEqual *tmp39 .stop *tmp40

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   269 set :drawPixel:color %[black]
   270 jump *label72 always
   271 label *label71
-    * jump *label75 equal .PALETTE 2
-    * jump *label74 always
+  272 jump *label74 notEqual .PALETTE 2
   273 label *label75
   274 op sub *tmp101 32 :drawPixel:iterations
   275 op abs *tmp102 *tmp101
 
   289 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   290 jump *label73 always
   291 label *label74
-    * jump *label77 equal .PALETTE 3
-    * jump *label76 always
+  292 jump *label76 notEqual .PALETTE 3
   293 label *label77
   294 op div *tmp117 :drawPixel:iterations 63
   295 op mul *tmp118 *tmp117 360
 
   305 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   306 jump *label73 always
   307 label *label76
-    * jump *label79 equal .PALETTE 4
-    * jump *label78 always
+  308 jump *label78 notEqual .PALETTE 4
   309 label *label79
   310 op mul *tmp129 4 :drawPixel:iterations
   311 op div :drawPixel:r *tmp129 255

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-21 instructions):
 
    24 print :findLinkedBlocks:title
    25 set :findLinkedBlocks:n @links
    26 label *label9
-    * op greaterThan *tmp12 :findLinkedBlocks:n 0
-    * jump *label11 equal *tmp12 false
+   27 jump *label11 lessThanEq :findLinkedBlocks:n 0
    28 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    29 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    30 print "\nFound: "
 
    44 set :findLinkedBlocks:required true
    45 setaddr *tmp15 *label16
    46 label *label12
-    * op equal *tmp16 :findLinkedBlocks:requested :findLinkedBlocks:type
-    * jump *label17 equal *tmp16 false
+   47 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * op equal *tmp18 :findLinkedBlocks:requested @message
-    * jump *label19 equal *tmp18 false
+   49 jump *label19 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
    51 jump *label20 always
    52 label *label19
 
    94 label *label23
    95 printflush :findLinkedBlocks:message
    96 label *label2
-    * op equal *tmp22 :findLinkedBlocks:foundAll false
-    * jump *label1 notEqual *tmp22 false
+   97 jump *label1 equal :findLinkedBlocks:foundAll false
    98 label *label3
    99 label *label0
   100 label *label28
 
   102 wait 0
   103 label *label32
   104 read *tmp24 .memory 66
-    * op equal *tmp23 .start *tmp24
-    * jump *label31 notEqual *tmp23 false
+  105 jump *label31 equal .start *tmp24
   106 label *label33
   107 read .start .memory 66
   108 read .stop .memory 67
 
   124 label *label34
   125 wait 0
   126 read *tmp40 .memory 67
-    * op notEqual *tmp39 .stop *tmp40
-    * jump *label37 equal *tmp39 false
+  127 jump *label37 equal .stop *tmp40
   128 jump *label29 always
   129 jump *label38 always
   130 label *label37
 
   134 op add *tmp0 *tmp42 1
   135 write *tmp0 .memory 64
   136 set :line *tmp43
-    * op greaterThanEq *tmp44 :line 176
-    * jump *label39 equal *tmp44 false
+  137 jump *label39 lessThan :line 176
   138 jump *label36 always
   139 jump *label40 always
   140 label *label39
 
   196 op mul *tmp69 *tmp68 :compute:p
   197 op sub *tmp70 :compute:p *tmp69
   198 op add *tmp71 *tmp70 0.25
-    * op lessThanEq *tmp72 :compute:cx *tmp71
-    * jump *label57 equal *tmp72 false
+  199 jump *label57 greaterThan :compute:cx *tmp71
   200 set *tmp60 63
   201 jump *label54 always
   202 jump *label58 always
 
   204 label *label58
   205 op add *tmp74 :compute:cx 1
   206 op len *tmp75 *tmp74 :compute:cy
-    * op lessThanEq *tmp76 *tmp75 0.25
-    * jump *label59 equal *tmp76 false
+  207 jump *label59 greaterThan *tmp75 0.25
   208 set *tmp60 63
   209 jump *label54 always
   210 jump *label60 always
 
   224 op mul *tmp83 *tmp82 :compute:y1
   225 op add :compute:zy *tmp83 :compute:cy
   226 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp86 :compute:dist 64
-    * jump *label64 equal *tmp86 false
+  227 jump *label64 lessThan :compute:dist 64
   228 jump *label63 always
   229 jump *label65 always
   230 label *label64
 
   234 jump *label61 always
   235 label *label63
   236 op mul *tmp88 .SMOOTH 63
-    * op lessThan *tmp89 :compute:i *tmp88
-    * jump *label66 equal *tmp89 false
+  237 jump *label66 greaterThanEq :compute:i *tmp88
   238 op log *tmp91 :compute:dist
   239 op mul *tmp92 *tmp91 0.36067376022224085
   240 op log *tmp93 *tmp92
 
   253 set :drawPixel:y :y
   254 set :drawPixel:iterations :iterations
   255 jump *label69 equal .SMOOTH false
-    * op equal *tmp97 :drawPixel:iterations 63
-    * jump *label71 equal *tmp97 false
+  256 jump *label71 notEqual :drawPixel:iterations 63
   257 set :drawPixel:color %[black]
   258 jump *label72 always
   259 label *label71
 
   313 label *label69
   314 read :drawPixel:color .memory :drawPixel:iterations
   315 label *label70
-    * op greaterThanEq *tmp142 .localBuffer 254
-    * jump *label80 equal *tmp142 false
+  316 jump *label80 lessThan .localBuffer 254
   317 label *label83
-    * op greaterThan *tmp144 .localBuffer 0
-    * jump *label85 equal *tmp144 false
+  318 jump *label85 lessThanEq .localBuffer 0
   319 wait 0
   320 sensor *tmp145 .display @enabled
   321 jump *label87 equal *tmp145 false
   322 sensor *tmp147 .display @bufferSize
   323 op sub *tmp148 1024 *tmp147
-    * op lessThan *tmp149 .localBuffer *tmp148
-    * jump *label89 equal *tmp149 false
+  324 jump *label89 greaterThanEq .localBuffer *tmp148
   325 drawflush .display
   326 set .localBuffer 0
   327 jump *label90 always
 
   338 jump *label81 always
   339 label *label80
   340 label *label81
-    * op greaterThan *tmp151 .localBuffer 0
-    * jump *label91 equal *tmp151 false
+  341 jump *label91 lessThanEq .localBuffer 0
   342 label *label94
-    * op strictEqual *tmp152 :drawPixel:color .lastColor
-    * jump *label91 equal *tmp152 false
+  343 jump *label91 strictNotEqual :drawPixel:color .lastColor
   344 jump *label93 always
   345 label *label93
   346 draw rect :drawPixel:x :drawPixel:y 1 1
 
   357 jump *label96 equal *tmp155 false
   358 sensor *tmp157 .display @bufferSize
   359 op sub *tmp158 1024 *tmp157
-    * op lessThan *tmp159 .localBuffer *tmp158
-    * jump *label98 equal *tmp159 false
+  360 jump *label98 greaterThanEq .localBuffer *tmp158
   361 drawflush .display
   362 set .localBuffer 0
   363 jump *label99 always
 
   373 op add *tmp1 *tmp161 1
   374 write *tmp1 .memory 65
   375 read *tmp164 .memory 67
-    * op notEqual *tmp163 .stop *tmp164
-    * jump *label100 equal *tmp163 false
+  376 jump *label100 equal .stop *tmp164
   377 jump *label29 always
   378 jump *label101 always
   379 label *label100
 
   383 jump *label51 always
   384 label *label53
   385 label *label103
-    * op greaterThan *tmp166 .localBuffer 0
-    * jump *label105 equal *tmp166 false
+  386 jump *label105 lessThanEq .localBuffer 0
   387 wait 0
   388 sensor *tmp167 .display @enabled
   389 jump *label107 equal *tmp167 false
   390 sensor *tmp169 .display @bufferSize
   391 op sub *tmp170 1024 *tmp169
-    * op lessThan *tmp171 .localBuffer *tmp170
-    * jump *label109 equal *tmp171 false
+  392 jump *label109 greaterThanEq .localBuffer *tmp170
   393 drawflush .display
   394 set .localBuffer 0
   395 jump *label110 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-18 instructions):
 
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
    49 jump *label19 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * jump *label20 always
    51 label *label19
    52 label *label20
-    * jump *label18 always
    53 label *label17
    54 label *label18
    55 label *label13
 
    82 print :findLinkedBlocks:variable
    83 jump *label26 equal :findLinkedBlocks:required false
    84 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * jump *label27 always
    85 label *label26
    86 label *label27
    87 label *label22
 
   123 read *tmp40 .memory 67
   124 jump *label37 equal .stop *tmp40
   125 jump *label29 always
-    * jump *label38 always
   126 label *label37
   127 label *label38
   128 read *tmp42 .memory 64
 
   132 set :line *tmp43
   133 jump *label39 lessThan :line 176
   134 jump *label36 always
-    * jump *label40 always
   135 label *label39
   136 label *label40
   137 jump *label44 lessThan :line 0
 
   194 jump *label57 greaterThan :compute:cx *tmp71
   195 set *tmp60 63
   196 jump *label54 always
-    * jump *label58 always
   197 label *label57
   198 label *label58
   199 op add *tmp74 :compute:cx 1
 
   201 jump *label59 greaterThan *tmp75 0.25
   202 set *tmp60 63
   203 jump *label54 always
-    * jump *label60 always
   204 label *label59
   205 label *label60
   206 label *label56
 
   219 op len :compute:dist :compute:zx :compute:zy
   220 jump *label64 lessThan :compute:dist 64
   221 jump *label63 always
-    * jump *label65 always
   222 label *label64
   223 label *label65
   224 label *label62
 
   233 op mul *tmp94 *tmp93 1.4426950408889634
   234 op sub :compute:correction 4 *tmp94
   235 op add :compute:i :compute:i :compute:correction
-    * jump *label67 always
   236 label *label66
   237 label *label67
   238 set *tmp60 :compute:i
 
   315 jump *label89 greaterThanEq .localBuffer *tmp148
   316 drawflush .display
   317 set .localBuffer 0
-    * jump *label90 always
   318 label *label89
   319 label *label90
-    * jump *label88 always
   320 label *label87
   321 label *label88
   322 label *label86
 
   324 jump *label83 always
   325 label *label85
   326 label *label82
-    * jump *label81 always
   327 label *label80
   328 label *label81
   329 jump *label91 lessThanEq .localBuffer 0
   330 label *label94
   331 jump *label91 strictNotEqual :drawPixel:color .lastColor
-    * jump *label93 always
   332 label *label93
   333 draw rect :drawPixel:x :drawPixel:y 1 1
   334 op add .localBuffer .localBuffer 1
 
   347 jump *label98 greaterThanEq .localBuffer *tmp158
   348 drawflush .display
   349 set .localBuffer 0
-    * jump *label99 always
   350 label *label98
   351 label *label99
-    * jump *label97 always
   352 label *label96
   353 label *label97
   354 label *label95
 
   360 read *tmp164 .memory 67
   361 jump *label100 equal .stop *tmp164
   362 jump *label29 always
-    * jump *label101 always
   363 label *label100
   364 label *label101
   365 label *label52
 
   376 jump *label109 greaterThanEq .localBuffer *tmp170
   377 drawflush .display
   378 set .localBuffer 0
-    * jump *label110 always
   379 label *label109
   380 label *label110
-    * jump *label108 always
   381 label *label107
   382 label *label108
   383 label *label106

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     1 set :findLinkedBlocks:title "Mandelbrot Generator"
     2 set :findLinkedBlocks:message null
     3 label *label1
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
     4 setaddr *tmp11 *label7
     5 jump *label4 always
     6 multilabel *label7 (m:marker0)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
+    7 set .display null
     8 setaddr *tmp11 *label8
     9 label *label4
    10 set :findLinkedBlocks:variable null
    11 label *label5
    12 multijump *tmp11 0 0 (m:marker0)
    13 multilabel *label8 (m:marker0)
-    * set .memory :findLinkedBlocks:variable
+   14 set .memory null
    15 label *label6
-    * print :findLinkedBlocks:title
+   16 print "Mandelbrot Generator"
    17 set :findLinkedBlocks:n @links
    18 label *label9
    19 jump *label11 lessThanEq :findLinkedBlocks:n 0
 
    23 print :findLinkedBlocks:block
    24 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    25 set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
    26 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    27 setaddr *tmp15 *label15
    28 jump *label12 always
    29 multilabel *label15 (m:marker1)
    30 set .display :findLinkedBlocks:variable
    31 set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
    32 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    33 setaddr *tmp15 *label16
    34 label *label12
    35 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
 
    49 jump *label9 always
    50 label *label11
    51 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:requested @large-logic-display
    52 set :findLinkedBlocks:name "Display"
    53 set :findLinkedBlocks:variable .display
    54 set :findLinkedBlocks:required true
 
    56 jump *label21 always
    57 multilabel *label24 (m:marker2)
    58 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    59 set :findLinkedBlocks:name "Memory"
    60 set :findLinkedBlocks:variable .memory
    61 set :findLinkedBlocks:required true
 
    66 print ":"
    67 print " "
    68 print :findLinkedBlocks:variable
-    * jump *label26 equal :findLinkedBlocks:required false
+   69 jump *label26 equal true false
    70 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
    71 label *label26
    72 label *label27
 
    98 op add .OFFSET_X *tmp28 *tmp30
    99 op div *tmp31 -88 .ZOOM
   100 read *tmp33 .memory 69
-    * op add .OFFSET_Y *tmp31 *tmp33
+  101 op add .OFFSET_Y *tmp28 *tmp33
   102 read .JULIA .memory 71
   103 read .JULIA_X .memory 72
   104 read .JULIA_Y .memory 73
 
   115 set *tmp43 *tmp42
   116 op add *tmp0 *tmp42 1
   117 write *tmp0 .memory 64
-    * set :line *tmp43
-    * jump *label39 lessThan :line 176
+  118 set :line *tmp42
+  119 jump *label39 lessThan *tmp43 176
   120 jump *label36 always
   121 label *label39
   122 label *label40
-    * jump *label44 lessThan :line 0
-    * jump *label43 lessThan :line 22
+  123 jump *label44 lessThan *tmp43 0
+  124 jump *label43 lessThan *tmp43 22
   125 label *label44
   126 jump *label42 always
   127 label *label43
-    * op mul *tmp46 8 :line
+  128 op mul *tmp46 8 *tmp43
   129 jump *label41 always
   130 label *label42
-    * jump *label47 lessThan :line 22
-    * jump *label46 lessThan :line 44
+  131 jump *label47 lessThan *tmp43 22
+  132 jump *label46 lessThan *tmp43 44
   133 label *label47
   134 jump *label45 always
   135 label *label46
-    * op mul *tmp49 8 :line
+  136 op mul *tmp49 8 *tmp43
   137 op sub *tmp50 *tmp49 176
-    * op add *tmp46 *tmp50 4
+  138 op sub *tmp46 *tmp49 172
   139 jump *label41 always
   140 label *label45
-    * jump *label50 lessThan :line 44
-    * jump *label49 lessThan :line 88
+  141 jump *label50 lessThan *tmp43 44
+  142 jump *label49 lessThan *tmp43 88
   143 label *label50
   144 jump *label48 always
   145 label *label49
-    * op mul *tmp52 4 :line
+  146 op mul *tmp52 4 *tmp43
   147 op sub *tmp53 *tmp52 176
-    * op add *tmp46 *tmp53 2
+  148 op sub *tmp46 *tmp52 174
   149 jump *label41 always
   150 label *label48
-    * op mul *tmp55 2 :line
+  151 op mul *tmp55 2 *tmp43
   152 op sub *tmp56 *tmp55 176
-    * op add *tmp46 *tmp56 1
+  153 op sub *tmp46 *tmp55 175
   154 label *label41
   155 set :strip *tmp46
-    * op mul *tmp58 17 :strip
+  156 op mul *tmp58 17 *tmp46
   157 op mod :x *tmp58 176
   158 set :y 0
   159 label *label51
   160 jump *label53 greaterThanEq :y 176
   161 set :compute:x :x
   162 set :compute:y :y
-    * op div *tmp61 :compute:x .ZOOM
+  163 op div *tmp61 :x .ZOOM
   164 op add :compute:zx *tmp61 .OFFSET_X
-    * op div *tmp63 :compute:y .ZOOM
+  165 op div *tmp63 :y .ZOOM
   166 op add :compute:zy *tmp63 .OFFSET_Y
   167 jump *label55 equal .JULIA false
   168 set :compute:cx .JULIA_X
 
   171 label *label55
   172 set :compute:cx :compute:zx
   173 set :compute:cy :compute:zy
-    * op sub *tmp66 :compute:cx 0.25
-    * op len :compute:p *tmp66 :compute:cy
+  174 op sub *tmp66 :compute:zx 0.25
+  175 op len :compute:p *tmp66 :compute:zy
   176 op mul *tmp68 2 :compute:p
   177 op mul *tmp69 *tmp68 :compute:p
   178 op sub *tmp70 :compute:p *tmp69
   179 op add *tmp71 *tmp70 0.25
-    * jump *label57 greaterThan :compute:cx *tmp71
+  180 jump *label57 greaterThan :compute:zx *tmp71
   181 set *tmp60 63
   182 jump *label54 always
   183 label *label57
   184 label *label58
-    * op add *tmp74 :compute:cx 1
-    * op len *tmp75 *tmp74 :compute:cy
+  185 op add *tmp74 :compute:zx 1
+  186 op len *tmp75 *tmp74 :compute:zy
   187 jump *label59 greaterThan *tmp75 0.25
   188 set *tmp60 63
   189 jump *label54 always
 
   195 jump *label63 greaterThanEq :compute:i 63
   196 set :compute:x1 :compute:zx
   197 set :compute:y1 :compute:zy
-    * op mul *tmp78 :compute:x1 :compute:x1
-    * op mul *tmp79 :compute:y1 :compute:y1
+  198 op mul *tmp78 :compute:zx :compute:zx
+  199 op mul *tmp79 :compute:zy :compute:zy
   200 op sub *tmp80 *tmp78 *tmp79
   201 op add :compute:zx *tmp80 :compute:cx
   202 op mul *tmp82 2 :compute:x1
-    * op mul *tmp83 *tmp82 :compute:y1
+  203 op mul *tmp83 *tmp82 :compute:zy
   204 op add :compute:zy *tmp83 :compute:cy
   205 op len :compute:dist :compute:zx :compute:zy
   206 jump *label64 lessThan :compute:dist 64
 
   223 label *label67
   224 set *tmp60 :compute:i
   225 jump *label54 always
-    * set *tmp60 null
   226 label *label54
   227 set :iterations *tmp60
   228 set :drawPixel:x :x
   229 set :drawPixel:y :y
-    * set :drawPixel:iterations :iterations
+  230 set :drawPixel:iterations *tmp60
   231 jump *label69 equal .SMOOTH false
-    * jump *label71 notEqual :drawPixel:iterations 63
+  232 jump *label71 notEqual :iterations 63
   233 set :drawPixel:color %[black]
   234 jump *label72 always
   235 label *label71
   236 jump *label74 notEqual .PALETTE 2
   237 label *label75
-    * op sub *tmp101 32 :drawPixel:iterations
+  238 op sub *tmp101 32 :iterations
   239 op abs *tmp102 *tmp101
   240 op mul *tmp103 7 *tmp102
-    * op div *tmp104 *tmp103 255
+  241 op div *tmp104 *tmp102 36.42857142857143
   242 op sub :drawPixel:r 1 *tmp104
-    * op sub *tmp106 :drawPixel:iterations 32
+  243 op sub *tmp106 :iterations 32
   244 op abs *tmp107 *tmp106
   245 op mul *tmp108 6 *tmp107
-    * op div *tmp109 *tmp108 255
+  246 op div *tmp109 *tmp107 42.5
   247 op sub :drawPixel:g 0.9411764705882353 *tmp109
-    * op sub *tmp111 32 :drawPixel:iterations
-    * op abs *tmp112 *tmp111
-    * op mul *tmp113 4 *tmp112
-    * op div *tmp114 *tmp113 255
+  248 op sub *tmp111 32 :iterations
+  249 op abs *tmp112 *tmp101
+  250 op mul *tmp113 4 *tmp102
+  251 op div *tmp114 *tmp112 63.75
   252 op add :drawPixel:b 0.47058823529411764 *tmp114
   253 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   254 jump *label73 always
   255 label *label74
   256 jump *label76 notEqual .PALETTE 3
   257 label *label77
-    * op div *tmp117 :drawPixel:iterations 63
-    * op mul *tmp118 *tmp117 360
+  258 op div *tmp117 :iterations 63
+  259 op div *tmp118 :drawPixel:iterations 0.175
   260 op sin :drawPixel:r *tmp118
-    * op div *tmp120 :drawPixel:iterations 63
-    * op mul *tmp121 *tmp120 360
-    * op cos :drawPixel:g *tmp121
-    * op sub *tmp123 :drawPixel:iterations 32
+  261 op div *tmp120 :iterations 63
+  262 op mul *tmp121 *tmp117 360
+  263 op cos :drawPixel:g *tmp118
+  264 op sub *tmp123 :iterations 32
   265 op abs *tmp124 *tmp123
   266 op mul *tmp125 4 *tmp124
-    * op div *tmp126 *tmp125 255
+  267 op div *tmp126 *tmp124 63.75
   268 op add :drawPixel:b 0.39215686274509803 *tmp126
   269 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   270 jump *label73 always
   271 label *label76
   272 jump *label78 notEqual .PALETTE 4
   273 label *label79
-    * op mul *tmp129 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp129 255
-    * op mul *tmp131 1.5 :drawPixel:iterations
-    * op div *tmp132 *tmp131 255
+  274 op mul *tmp129 4 :iterations
+  275 op div :drawPixel:r :drawPixel:iterations 63.75
+  276 op mul *tmp131 1.5 :iterations
+  277 op div *tmp132 :drawPixel:iterations 170
   278 op add :drawPixel:g 96 *tmp132
   279 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   280 jump *label73 always
   281 label *label78
-    * op mul *tmp135 4 :drawPixel:iterations
-    * op div *tmp136 *tmp135 255
+  282 op mul *tmp135 4 :iterations
+  283 op div *tmp136 :drawPixel:iterations 63.75
   284 op sub :drawPixel:r 1 *tmp136
   285 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   286 label *label73
   287 label *label72
   288 jump *label70 always
   289 label *label69
-    * read :drawPixel:color .memory :drawPixel:iterations
+  290 read :drawPixel:color .memory :iterations
   291 label *label70
   292 jump *label80 lessThan .localBuffer 254
   293 label *label83
 
   315 label *label94
   316 jump *label91 strictNotEqual :drawPixel:color .lastColor
   317 label *label93
-    * draw rect :drawPixel:x :drawPixel:y 1 1
+  318 draw rect :x :y 1 1
   319 op add .localBuffer .localBuffer 1
   320 jump *label92 always
   321 label *label91
   322 draw col :drawPixel:color
-    * draw rect :drawPixel:x :drawPixel:y 1 1
+  323 draw rect :x :y 1 1
   324 set .lastColor :drawPixel:color
   325 op add .localBuffer .localBuffer 2
   326 label *label92

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-19 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:title "Mandelbrot Generator"
     1 set :findLinkedBlocks:message null
     2 label *label1
     3 setaddr *tmp11 *label7
 
     6 set .display null
     7 setaddr *tmp11 *label8
     8 label *label4
-    * set :findLinkedBlocks:variable null
     9 label *label5
    10 multijump *tmp11 0 0 (m:marker0)
    11 multilabel *label8 (m:marker0)
 
    49 set :findLinkedBlocks:foundAll 1
    50 set :findLinkedBlocks:name "Display"
    51 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    52 setaddr *tmp20 *label24
    53 jump *label21 always
    54 multilabel *label24 (m:marker2)
    55 set .display :findLinkedBlocks:variable
    56 set :findLinkedBlocks:name "Memory"
    57 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    58 setaddr *tmp20 *label25
    59 label *label21
    60 print "\n"
 
    92 op div *tmp28 -88 .ZOOM
    93 read *tmp30 .memory 68
    94 op add .OFFSET_X *tmp28 *tmp30
-    * op div *tmp31 -88 .ZOOM
    95 read *tmp33 .memory 69
    96 op add .OFFSET_Y *tmp28 *tmp33
    97 read .JULIA .memory 71
 
   110 set *tmp43 *tmp42
   111 op add *tmp0 *tmp42 1
   112 write *tmp0 .memory 64
-    * set :line *tmp42
-    * jump *label39 lessThan *tmp43 176
+  113 jump *label39 lessThan *tmp42 176
   114 jump *label36 always
   115 label *label39
   116 label *label40
-    * jump *label44 lessThan *tmp43 0
-    * jump *label43 lessThan *tmp43 22
+  117 jump *label44 lessThan *tmp42 0
+  118 jump *label43 lessThan *tmp42 22
   119 label *label44
   120 jump *label42 always
   121 label *label43
-    * op mul *tmp46 8 *tmp43
+  122 op mul *tmp46 8 *tmp42
   123 jump *label41 always
   124 label *label42
-    * jump *label47 lessThan *tmp43 22
-    * jump *label46 lessThan *tmp43 44
+  125 jump *label47 lessThan *tmp42 22
+  126 jump *label46 lessThan *tmp42 44
   127 label *label47
   128 jump *label45 always
   129 label *label46
-    * op mul *tmp49 8 *tmp43
-    * op sub *tmp50 *tmp49 176
+  130 op mul *tmp49 8 *tmp42
   131 op sub *tmp46 *tmp49 172
   132 jump *label41 always
   133 label *label45
-    * jump *label50 lessThan *tmp43 44
-    * jump *label49 lessThan *tmp43 88
+  134 jump *label50 lessThan *tmp42 44
+  135 jump *label49 lessThan *tmp42 88
   136 label *label50
   137 jump *label48 always
   138 label *label49
-    * op mul *tmp52 4 *tmp43
-    * op sub *tmp53 *tmp52 176
+  139 op mul *tmp52 4 *tmp42
   140 op sub *tmp46 *tmp52 174
   141 jump *label41 always
   142 label *label48
-    * op mul *tmp55 2 *tmp43
-    * op sub *tmp56 *tmp55 176
+  143 op mul *tmp55 2 *tmp42
   144 op sub *tmp46 *tmp55 175
   145 label *label41
-    * set :strip *tmp46
   146 op mul *tmp58 17 *tmp46
   147 op mod :x *tmp58 176
   148 set :y 0
   149 label *label51
   150 jump *label53 greaterThanEq :y 176
-    * set :compute:x :x
-    * set :compute:y :y
   151 op div *tmp61 :x .ZOOM
   152 op add :compute:zx *tmp61 .OFFSET_X
   153 op div *tmp63 :y .ZOOM
 
   182 label *label61
   183 jump *label63 greaterThanEq :compute:i 63
   184 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   185 op mul *tmp78 :compute:zx :compute:zx
   186 op mul *tmp79 :compute:zy :compute:zy
   187 op sub *tmp80 *tmp78 *tmp79
 
   212 jump *label54 always
   213 label *label54
   214 set :iterations *tmp60
-    * set :drawPixel:x :x
-    * set :drawPixel:y :y
   215 set :drawPixel:iterations *tmp60
   216 jump *label69 equal .SMOOTH false
-    * jump *label71 notEqual :iterations 63
+  217 jump *label71 notEqual *tmp60 63
   218 set :drawPixel:color %[black]
   219 jump *label72 always
   220 label *label71
   221 jump *label74 notEqual .PALETTE 2
   222 label *label75
-    * op sub *tmp101 32 :iterations
+  223 op sub *tmp101 32 *tmp60
   224 op abs *tmp102 *tmp101
-    * op mul *tmp103 7 *tmp102
   225 op div *tmp104 *tmp102 36.42857142857143
   226 op sub :drawPixel:r 1 *tmp104
-    * op sub *tmp106 :iterations 32
+  227 op sub *tmp106 *tmp60 32
   228 op abs *tmp107 *tmp106
-    * op mul *tmp108 6 *tmp107
   229 op div *tmp109 *tmp107 42.5
   230 op sub :drawPixel:g 0.9411764705882353 *tmp109
-    * op sub *tmp111 32 :iterations
+  231 op sub *tmp111 32 *tmp60
   232 op abs *tmp112 *tmp101
-    * op mul *tmp113 4 *tmp102
-    * op div *tmp114 *tmp112 63.75
+  233 op div *tmp114 *tmp102 63.75
   234 op add :drawPixel:b 0.47058823529411764 *tmp114
   235 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   236 jump *label73 always
   237 label *label74
   238 jump *label76 notEqual .PALETTE 3
   239 label *label77
-    * op div *tmp117 :iterations 63
-    * op div *tmp118 :drawPixel:iterations 0.175
+  240 op div *tmp117 *tmp60 63
+  241 op div *tmp118 *tmp60 0.175
   242 op sin :drawPixel:r *tmp118
-    * op div *tmp120 :iterations 63
-    * op mul *tmp121 *tmp117 360
+  243 op div *tmp120 *tmp60 63
+  244 op div *tmp121 :iterations 0.175
   245 op cos :drawPixel:g *tmp118
-    * op sub *tmp123 :iterations 32
+  246 op sub *tmp123 *tmp60 32
   247 op abs *tmp124 *tmp123
-    * op mul *tmp125 4 *tmp124
   248 op div *tmp126 *tmp124 63.75
   249 op add :drawPixel:b 0.39215686274509803 *tmp126
   250 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   252 label *label76
   253 jump *label78 notEqual .PALETTE 4
   254 label *label79
-    * op mul *tmp129 4 :iterations
-    * op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp131 1.5 :iterations
-    * op div *tmp132 :drawPixel:iterations 170
+  255 op mul *tmp129 4 *tmp60
+  256 op div :drawPixel:r *tmp60 63.75
+  257 op mul *tmp131 1.5 *tmp60
+  258 op div *tmp132 *tmp60 170
   259 op add :drawPixel:g 96 *tmp132
   260 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   261 jump *label73 always
   262 label *label78
-    * op mul *tmp135 4 :iterations
-    * op div *tmp136 :drawPixel:iterations 63.75
+  263 op mul *tmp135 4 *tmp60
+  264 op div *tmp136 *tmp60 63.75
   265 op sub :drawPixel:r 1 *tmp136
   266 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   267 label *label73
   268 label *label72
   269 jump *label70 always
   270 label *label69
-    * read :drawPixel:color .memory :iterations
+  271 read :drawPixel:color .memory *tmp60
   272 label *label70
   273 jump *label80 lessThan .localBuffer 254
   274 label *label83

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-9 instructions):
 
   107 label *label37
   108 label *label38
   109 read *tmp42 .memory 64
-    * set *tmp43 *tmp42
   110 op add *tmp0 *tmp42 1
   111 write *tmp0 .memory 64
   112 jump *label39 lessThan *tmp42 176
 
   211 jump *label54 always
   212 label *label54
   213 set :iterations *tmp60
-    * set :drawPixel:iterations *tmp60
   214 jump *label69 equal .SMOOTH false
   215 jump *label71 notEqual *tmp60 63
   216 set :drawPixel:color %[black]
 
   226 op abs *tmp107 *tmp106
   227 op div *tmp109 *tmp107 42.5
   228 op sub :drawPixel:g 0.9411764705882353 *tmp109
-    * op sub *tmp111 32 *tmp60
-    * op abs *tmp112 *tmp101
   229 op div *tmp114 *tmp102 63.75
   230 op add :drawPixel:b 0.47058823529411764 *tmp114
   231 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   233 label *label74
   234 jump *label76 notEqual .PALETTE 3
   235 label *label77
-    * op div *tmp117 *tmp60 63
   236 op div *tmp118 *tmp60 0.175
   237 op sin :drawPixel:r *tmp118
-    * op div *tmp120 *tmp60 63
-    * op div *tmp121 :iterations 0.175
+  238 op div *tmp121 *tmp60 0.175
   239 op cos :drawPixel:g *tmp118
   240 op sub *tmp123 *tmp60 32
   241 op abs *tmp124 *tmp123
 
   246 label *label76
   247 jump *label78 notEqual .PALETTE 4
   248 label *label79
-    * op mul *tmp129 4 *tmp60
   249 op div :drawPixel:r *tmp60 63.75
-    * op mul *tmp131 1.5 *tmp60
   250 op div *tmp132 *tmp60 170
   251 op add :drawPixel:g 96 *tmp132
   252 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   253 jump *label73 always
   254 label *label78
-    * op mul *tmp135 4 *tmp60
   255 op div *tmp136 *tmp60 63.75
   256 op sub :drawPixel:r 1 *tmp136
   257 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   210 set *tmp60 :compute:i
   211 jump *label54 always
   212 label *label54
-    * set :iterations *tmp60
   213 jump *label69 equal .SMOOTH false
   214 jump *label71 notEqual *tmp60 63
   215 set :drawPixel:color %[black]
 
   234 label *label77
   235 op div *tmp118 *tmp60 0.175
   236 op sin :drawPixel:r *tmp118
-    * op div *tmp121 *tmp60 0.175
   237 op cos :drawPixel:g *tmp118
   238 op sub *tmp123 *tmp60 32
   239 op abs *tmp124 *tmp123

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
    15 set :findLinkedBlocks:n @links
    16 label *label9
    17 jump *label11 lessThanEq :findLinkedBlocks:n 0
+   18 label *label111
    19 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    20 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    21 print "\nFound: "
 
    45 set .memory :findLinkedBlocks:variable
    46 label *label14
    47 label *label10
-    * jump *label9 always
+   48 jump *label111 greaterThan :findLinkedBlocks:n 0
    49 label *label11
    50 set :findLinkedBlocks:foundAll 1
    51 set :findLinkedBlocks:name "Display"
 
   148 set :y 0
   149 label *label51
   150 jump *label53 greaterThanEq :y 176
+  151 label *label112
   152 op div *tmp61 :x .ZOOM
   153 op add :compute:zx *tmp61 .OFFSET_X
   154 op div *tmp63 :y .ZOOM
 
   182 set :compute:i 0
   183 label *label61
   184 jump *label63 greaterThanEq :compute:i 63
+  185 label *label113
   186 set :compute:x1 :compute:zx
   187 op mul *tmp78 :compute:zx :compute:zx
   188 op mul *tmp79 :compute:zy :compute:zy
 
   198 label *label65
   199 label *label62
   200 op add :compute:i :compute:i 1
-    * jump *label61 always
+  201 jump *label113 lessThan :compute:i 63
   202 label *label63
   203 op mul *tmp88 .SMOOTH 63
   204 jump *label66 greaterThanEq :compute:i *tmp88
 
   265 jump *label80 lessThan .localBuffer 254
   266 label *label83
   267 jump *label85 lessThanEq .localBuffer 0
+  268 label *label114
   269 wait 0
   270 sensor *tmp145 .display @enabled
   271 jump *label87 equal *tmp145 false
 
   280 label *label88
   281 label *label86
   282 label *label84
-    * jump *label83 always
+  283 jump *label114 greaterThan .localBuffer 0
   284 label *label85
   285 label *label82
   286 label *label80
 
   323 label *label101
   324 label *label52
   325 op add :y :y 1
-    * jump *label51 always
+  326 jump *label112 lessThan :y 176
   327 label *label53
   328 label *label103
   329 jump *label105 lessThanEq .localBuffer 0
+  330 label *label115
   331 wait 0
   332 sensor *tmp167 .display @enabled
   333 jump *label107 equal *tmp167 false
 
   342 label *label108
   343 label *label106
   344 label *label104
-    * jump *label103 always
+  345 jump *label115 greaterThan .localBuffer 0
   346 label *label105
   347 label *label102
   348 label *label35

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
    33 label *label12
    34 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    35 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label19 notEqual :findLinkedBlocks:requested @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
-    * label *label19
-    * label *label20
+   36 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
    37 label *label17
    38 label *label18
    39 label *label13
 
   283 label *label80
   284 label *label81
   285 jump *label91 lessThanEq .localBuffer 0
-    * label *label94
   286 jump *label91 strictNotEqual :drawPixel:color .lastColor
-    * label *label93
   287 draw rect :x :y 1 1
   288 op add .localBuffer .localBuffer 1
   289 jump *label92 always

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   211 jump *label54 always
   212 label *label54
   213 jump *label69 equal .SMOOTH false
-    * jump *label71 notEqual *tmp60 63
   214 set :drawPixel:color %[black]
-    * jump *label72 always
+  215 jump *label72 equal *tmp60 63
   216 label *label71
   217 jump *label74 notEqual .PALETTE 2
   218 label *label75

Modifications by Unroll iteration loop at *blocks:68:13 (-1 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp15 *label15
-    * jump *label12 always
-    * multilabel *label15 (m:marker1)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp15 *label16
-    * label *label12
-    * jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
-    * label *label17
-    * label *label18
-    * label *label13
-    * multijump *tmp15 0 0 (m:marker1)
-    * multilabel *label16 (m:marker1)
-    * set .memory :findLinkedBlocks:variable
-    * label *label14
+   24 set :findLinkedBlocks:requested @large-logic-display
+   25 set :findLinkedBlocks:variable .display
+   26 label *label116
+   27 jump *label117 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   28 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   29 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   30 label *label117
+   31 label *label118
+   32 label *label119
+   33 set .display :findLinkedBlocks:variable
+   34 set :findLinkedBlocks:requested @memory-bank
+   35 set :findLinkedBlocks:variable .memory
+   36 label *label122
+   37 jump *label123 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   38 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   39 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   40 label *label123
+   41 label *label124
+   42 label *label125
+   43 set .memory :findLinkedBlocks:variable
+   44 label *label14
    45 label *label10
    46 jump *label111 greaterThan :findLinkedBlocks:n 0
    47 label *label11

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    24 set :findLinkedBlocks:requested @large-logic-display
    25 set :findLinkedBlocks:variable .display
    26 label *label116
-    * jump *label117 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   27 jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
    28 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   29 select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
    30 label *label117
    31 label *label118
    32 label *label119
 
    34 set :findLinkedBlocks:requested @memory-bank
    35 set :findLinkedBlocks:variable .memory
    36 label *label122
-    * jump *label123 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   37 jump *label123 notEqual @memory-bank :findLinkedBlocks:type
    38 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   39 select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
    40 label *label123
    41 label *label124
    42 label *label125
 
   145 op mod :x *tmp58 176
   146 set :y 0
   147 label *label51
-    * jump *label53 greaterThanEq :y 176
+  148 jump *label53 greaterThanEq 0 176
   149 label *label112
   150 op div *tmp61 :x .ZOOM
   151 op add :compute:zx *tmp61 .OFFSET_X
 
   179 label *label56
   180 set :compute:i 0
   181 label *label61
-    * jump *label63 greaterThanEq :compute:i 63
+  182 jump *label63 greaterThanEq 0 63
   183 label *label113
   184 set :compute:x1 :compute:zx
   185 op mul *tmp78 :compute:zx :compute:zx

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
    24 set :findLinkedBlocks:variable .display
    25 label *label116
    26 jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
 
    30 label *label118
    31 label *label119
    32 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    33 set :findLinkedBlocks:variable .memory
    34 label *label122
    35 jump *label123 notEqual @memory-bank :findLinkedBlocks:type

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
     0 set .start 0
     1 set :findLinkedBlocks:message null
     2 label *label1
-    * setaddr *tmp11 *label7
-    * jump *label4 always
-    * multilabel *label7 (m:marker0)
-    * set .display null
-    * setaddr *tmp11 *label8
-    * label *label4
-    * label *label5
-    * multijump *tmp11 0 0 (m:marker0)
-    * multilabel *label8 (m:marker0)
-    * set .memory null
-    * label *label6
+    3 label *label129
+    4 label *label130
+    5 set .display null
+    6 label *label133
+    7 label *label134
+    8 set .memory null
+    9 label *label6
    10 print "Mandelbrot Generator"
    11 set :findLinkedBlocks:n @links
    12 label *label9

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    40 jump *label111 greaterThan :findLinkedBlocks:n 0
    41 label *label11
    42 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp20 *label24
-    * jump *label21 always
-    * multilabel *label24 (m:marker2)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp20 *label25
-    * label *label21
-    * print "\n"
-    * print :findLinkedBlocks:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks:variable
-    * jump *label26 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * label *label26
-    * label *label27
-    * label *label22
-    * multijump *tmp20 0 0 (m:marker2)
-    * multilabel *label25 (m:marker2)
-    * set .memory :findLinkedBlocks:variable
-    * label *label23
+   43 set :findLinkedBlocks:name "Display"
+   44 set :findLinkedBlocks:variable .display
+   45 label *label138
+   46 print "\n"
+   47 print :findLinkedBlocks:name
+   48 print ":"
+   49 print " "
+   50 print :findLinkedBlocks:variable
+   51 jump *label139 equal true false
+   52 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   53 label *label139
+   54 label *label140
+   55 label *label141
+   56 set .display :findLinkedBlocks:variable
+   57 set :findLinkedBlocks:name "Memory"
+   58 set :findLinkedBlocks:variable .memory
+   59 label *label144
+   60 print "\n"
+   61 print :findLinkedBlocks:name
+   62 print ":"
+   63 print " "
+   64 print :findLinkedBlocks:variable
+   65 jump *label145 equal true false
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   67 label *label145
+   68 label *label146
+   69 label *label147
+   70 set .memory :findLinkedBlocks:variable
+   71 label *label23
    72 printflush :findLinkedBlocks:message
    73 label *label2
    74 jump *label1 equal :findLinkedBlocks:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    44 set :findLinkedBlocks:variable .display
    45 label *label138
    46 print "\n"
-    * print :findLinkedBlocks:name
+   47 print "Display"
    48 print ":"
    49 print " "
-    * print :findLinkedBlocks:variable
+   50 print .display
    51 jump *label139 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   52 op and :findLinkedBlocks:foundAll 1 .display
    53 label *label139
    54 label *label140
    55 label *label141
-    * set .display :findLinkedBlocks:variable
+   56 set .display .display
    57 set :findLinkedBlocks:name "Memory"
    58 set :findLinkedBlocks:variable .memory
    59 label *label144
    60 print "\n"
-    * print :findLinkedBlocks:name
+   61 print "Memory"
    62 print ":"
    63 print " "
-    * print :findLinkedBlocks:variable
+   64 print .memory
    65 jump *label145 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    67 label *label145
    68 label *label146
    69 label *label147
-    * set .memory :findLinkedBlocks:variable
+   70 set .memory .memory
    71 label *label23
    72 printflush :findLinkedBlocks:message
    73 label *label2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    39 label *label10
    40 jump *label111 greaterThan :findLinkedBlocks:n 0
    41 label *label11
-    * set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
    42 label *label138
    43 print "\n"
    44 print "Display"
 
    51 label *label140
    52 label *label141
    53 set .display .display
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
    54 label *label144
    55 print "\n"
    56 print "Memory"

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:80:25 (-7 instructions):
 
   106 jump *label36 always
   107 label *label39
   108 label *label40
-    * jump *label44 lessThan *tmp42 0
-    * jump *label43 lessThan *tmp42 22
-    * label *label44
-    * jump *label42 always
+  109 multijump *tmp42 0 0 (m:*label152)
+  110 multilabel *label156 (m:*label152)
+  111 label *label151
+  112 op mul *tmp55 2 *tmp42
+  113 op sub *tmp46 *tmp55 175
+  114 jump *label41 always
+  115 multilabel *label153 (m:*label152)
   116 label *label43
   117 op mul *tmp46 8 *tmp42
   118 jump *label41 always
   119 label *label42
-    * jump *label47 lessThan *tmp42 22
-    * jump *label46 lessThan *tmp42 44
-    * label *label47
-    * jump *label45 always
+  120 multilabel *label154 (m:*label152)
   121 label *label46
   122 op mul *tmp49 8 *tmp42
   123 op sub *tmp46 *tmp49 172
   124 jump *label41 always
   125 label *label45
-    * jump *label50 lessThan *tmp42 44
-    * jump *label49 lessThan *tmp42 88
-    * label *label50
-    * jump *label48 always
+  126 jump *label41 always
+  127 multilabel *label155 (m:*label152)
   128 label *label49
   129 op mul *tmp52 4 *tmp42
   130 op sub *tmp46 *tmp52 174
-    * jump *label41 always
-    * label *label48
-    * op mul *tmp55 2 *tmp42
-    * op sub *tmp46 *tmp55 175
   131 label *label41
   132 op mul *tmp58 17 *tmp46
   133 op mod :x *tmp58 176

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:155:13 (-2 instructions):
 
   203 set :drawPixel:color %[black]
   204 jump *label72 equal *tmp60 63
   205 label *label71
-    * jump *label74 notEqual .PALETTE 2
+  206 multijump .PALETTE 0 0 (m:*label158)
+  207 multilabel *label163 (m:*label158)
+  208 multilabel *label159 (m:*label158)
+  209 label *label157
+  210 op div *tmp136 *tmp60 63.75
+  211 op sub :drawPixel:r 1 *tmp136
+  212 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
+  213 jump *label73 always
+  214 multilabel *label160 (m:*label158)
   215 label *label75
   216 op sub *tmp101 32 *tmp60
   217 op abs *tmp102 *tmp101
 
   226 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   227 jump *label73 always
   228 label *label74
-    * jump *label76 notEqual .PALETTE 3
+  229 multilabel *label161 (m:*label158)
   230 label *label77
   231 op div *tmp118 *tmp60 0.175
   232 op sin :drawPixel:r *tmp118
 
   238 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   239 jump *label73 always
   240 label *label76
-    * jump *label78 notEqual .PALETTE 4
+  241 multilabel *label162 (m:*label158)
   242 label *label79
   243 op div :drawPixel:r *tmp60 63.75
   244 op div *tmp132 *tmp60 170
   245 op add :drawPixel:g 96 *tmp132
   246 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label73 always
-    * label *label78
-    * op div *tmp136 *tmp60 63.75
-    * op sub :drawPixel:r 1 *tmp136
-    * packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   247 label *label73
   248 label *label72
   249 jump *label70 always

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-4 instructions):
 
    45 print ":"
    46 print " "
    47 print .display
-    * jump *label139 equal true false
    48 op and :findLinkedBlocks:foundAll 1 .display
    49 label *label139
    50 label *label140
 
    56 print ":"
    57 print " "
    58 print .memory
-    * jump *label145 equal true false
    59 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    60 label *label145
    61 label *label146
 
   131 op mod :x *tmp58 176
   132 set :y 0
   133 label *label51
-    * jump *label53 greaterThanEq 0 176
   134 label *label112
   135 op div *tmp61 :x .ZOOM
   136 op add :compute:zx *tmp61 .OFFSET_X
 
   164 label *label56
   165 set :compute:i 0
   166 label *label61
-    * jump *label63 greaterThanEq 0 63
   167 label *label113
   168 set :compute:x1 :compute:zx
   169 op mul *tmp78 :compute:zx :compute:zx

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1:
 
   195 set *tmp60 :compute:i
   196 jump *label54 always
   197 label *label54
-    * jump *label69 equal .SMOOTH false
+  198 jump *label69 lessThanEq .PALETTE 1
   199 set :drawPixel:color %[black]
   200 jump *label72 equal *tmp60 63
   201 label *label71

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   119 label *label46
   120 op mul *tmp49 8 *tmp42
   121 op sub *tmp46 *tmp49 172
-    * jump *label41 always
   122 label *label45
   123 jump *label41 always
   124 multilabel *label155 (m:*label152)
 
   192 label *label66
   193 label *label67
   194 set *tmp60 :compute:i
-    * jump *label54 always
   195 label *label54
   196 jump *label69 lessThanEq .PALETTE 1
   197 set :drawPixel:color %[black]

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-2 instructions):
 
    21 label *label116
    22 jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
+   24 set :findLinkedBlocks:message :findLinkedBlocks:message
    25 label *label117
    26 label *label118
    27 label *label119
 
    30 label *label122
    31 jump *label123 notEqual @memory-bank :findLinkedBlocks:type
    32 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
+   33 set :findLinkedBlocks:message :findLinkedBlocks:message
    34 label *label123
    35 label *label124
    36 label *label125
 
    49 label *label139
    50 label *label140
    51 label *label141
-    * set .display .display
    52 label *label144
    53 print "\n"
    54 print "Memory"
 
    59 label *label145
    60 label *label146
    61 label *label147
-    * set .memory .memory
    62 label *label23
    63 printflush :findLinkedBlocks:message
    64 label *label2

Modifications by Unroll loop at mandelbrot-compute.mnd:128:5 (+743 instructions):
 
   159 label *label59
   160 label *label60
   161 label *label56
-    * set :compute:i 0
-    * label *label61
-    * label *label113
-    * set :compute:x1 :compute:zx
-    * op mul *tmp78 :compute:zx :compute:zx
-    * op mul *tmp79 :compute:zy :compute:zy
-    * op sub *tmp80 *tmp78 *tmp79
-    * op add :compute:zx *tmp80 :compute:cx
-    * op mul *tmp82 2 :compute:x1
-    * op mul *tmp83 *tmp82 :compute:zy
-    * op add :compute:zy *tmp83 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label64 lessThan :compute:dist 64
-    * jump *label63 always
-    * label *label64
-    * label *label65
-    * label *label62
-    * op add :compute:i :compute:i 1
-    * jump *label113 lessThan :compute:i 63
-    * label *label63
+  162 set :compute:i 0
+  163 label *label164
+  164 set :compute:x1 :compute:zx
+  165 op mul *tmp78 :compute:zx :compute:zx
+  166 op mul *tmp79 :compute:zy :compute:zy
+  167 op sub *tmp80 *tmp78 *tmp79
+  168 op add :compute:zx *tmp80 :compute:cx
+  169 op mul *tmp82 2 :compute:x1
+  170 op mul *tmp83 *tmp82 :compute:zy
+  171 op add :compute:zy *tmp83 :compute:cy
+  172 op len :compute:dist :compute:zx :compute:zy
+  173 jump *label165 lessThan :compute:dist 64
+  174 jump *label63 always
+  175 label *label165
+  176 label *label166
+  177 label *label167
+  178 op add :compute:i :compute:i 1
+  179 set :compute:x1 :compute:zx
+  180 op mul *tmp78 :compute:zx :compute:zx
+  181 op mul *tmp79 :compute:zy :compute:zy
+  182 op sub *tmp80 *tmp78 *tmp79
+  183 op add :compute:zx *tmp80 :compute:cx
+  184 op mul *tmp82 2 :compute:x1
+  185 op mul *tmp83 *tmp82 :compute:zy
+  186 op add :compute:zy *tmp83 :compute:cy
+  187 op len :compute:dist :compute:zx :compute:zy
+  188 jump *label168 lessThan :compute:dist 64
+  189 jump *label63 always
+  190 label *label168
+  191 label *label169
+  192 label *label170
+  193 op add :compute:i :compute:i 1
+  194 set :compute:x1 :compute:zx
+  195 op mul *tmp78 :compute:zx :compute:zx
+  196 op mul *tmp79 :compute:zy :compute:zy
+  197 op sub *tmp80 *tmp78 *tmp79
+  198 op add :compute:zx *tmp80 :compute:cx
+  199 op mul *tmp82 2 :compute:x1
+  200 op mul *tmp83 *tmp82 :compute:zy
+  201 op add :compute:zy *tmp83 :compute:cy
+  202 op len :compute:dist :compute:zx :compute:zy
+  203 jump *label171 lessThan :compute:dist 64
+  204 jump *label63 always
+  205 label *label171
+  206 label *label172
+  207 label *label173
+  208 op add :compute:i :compute:i 1
+  209 set :compute:x1 :compute:zx
+  210 op mul *tmp78 :compute:zx :compute:zx
+  211 op mul *tmp79 :compute:zy :compute:zy
+  212 op sub *tmp80 *tmp78 *tmp79
+  213 op add :compute:zx *tmp80 :compute:cx
+  214 op mul *tmp82 2 :compute:x1
+  215 op mul *tmp83 *tmp82 :compute:zy
+  216 op add :compute:zy *tmp83 :compute:cy
+  217 op len :compute:dist :compute:zx :compute:zy
+  218 jump *label174 lessThan :compute:dist 64
+  219 jump *label63 always
+  220 label *label174
+  221 label *label175
+  222 label *label176
+  223 op add :compute:i :compute:i 1
+  224 set :compute:x1 :compute:zx
+  225 op mul *tmp78 :compute:zx :compute:zx
+  226 op mul *tmp79 :compute:zy :compute:zy
+  227 op sub *tmp80 *tmp78 *tmp79
+  228 op add :compute:zx *tmp80 :compute:cx
+  229 op mul *tmp82 2 :compute:x1
+  230 op mul *tmp83 *tmp82 :compute:zy
+  231 op add :compute:zy *tmp83 :compute:cy
+  232 op len :compute:dist :compute:zx :compute:zy
+  233 jump *label177 lessThan :compute:dist 64
+  234 jump *label63 always
+  235 label *label177
+  236 label *label178
+  237 label *label179
+  238 op add :compute:i :compute:i 1
+  239 set :compute:x1 :compute:zx
+  240 op mul *tmp78 :compute:zx :compute:zx
+  241 op mul *tmp79 :compute:zy :compute:zy
+  242 op sub *tmp80 *tmp78 *tmp79
+  243 op add :compute:zx *tmp80 :compute:cx
+  244 op mul *tmp82 2 :compute:x1
+  245 op mul *tmp83 *tmp82 :compute:zy
+  246 op add :compute:zy *tmp83 :compute:cy
+  247 op len :compute:dist :compute:zx :compute:zy
+  248 jump *label180 lessThan :compute:dist 64
+  249 jump *label63 always
+  250 label *label180
+  251 label *label181
+  252 label *label182
+  253 op add :compute:i :compute:i 1
+  254 set :compute:x1 :compute:zx
+  255 op mul *tmp78 :compute:zx :compute:zx
+  256 op mul *tmp79 :compute:zy :compute:zy
+  257 op sub *tmp80 *tmp78 *tmp79
+  258 op add :compute:zx *tmp80 :compute:cx
+  259 op mul *tmp82 2 :compute:x1
+  260 op mul *tmp83 *tmp82 :compute:zy
+  261 op add :compute:zy *tmp83 :compute:cy
+  262 op len :compute:dist :compute:zx :compute:zy
+  263 jump *label183 lessThan :compute:dist 64
+  264 jump *label63 always
+  265 label *label183
+  266 label *label184
+  267 label *label185
+  268 op add :compute:i :compute:i 1
+  269 set :compute:x1 :compute:zx
+  270 op mul *tmp78 :compute:zx :compute:zx
+  271 op mul *tmp79 :compute:zy :compute:zy
+  272 op sub *tmp80 *tmp78 *tmp79
+  273 op add :compute:zx *tmp80 :compute:cx
+  274 op mul *tmp82 2 :compute:x1
+  275 op mul *tmp83 *tmp82 :compute:zy
+  276 op add :compute:zy *tmp83 :compute:cy
+  277 op len :compute:dist :compute:zx :compute:zy
+  278 jump *label186 lessThan :compute:dist 64
+  279 jump *label63 always
+  280 label *label186
+  281 label *label187
+  282 label *label188
+  283 op add :compute:i :compute:i 1
+  284 set :compute:x1 :compute:zx
+  285 op mul *tmp78 :compute:zx :compute:zx
+  286 op mul *tmp79 :compute:zy :compute:zy
+  287 op sub *tmp80 *tmp78 *tmp79
+  288 op add :compute:zx *tmp80 :compute:cx
+  289 op mul *tmp82 2 :compute:x1
+  290 op mul *tmp83 *tmp82 :compute:zy
+  291 op add :compute:zy *tmp83 :compute:cy
+  292 op len :compute:dist :compute:zx :compute:zy
+  293 jump *label189 lessThan :compute:dist 64
+  294 jump *label63 always
+  295 label *label189
+  296 label *label190
+  297 label *label191
+  298 op add :compute:i :compute:i 1
+  299 set :compute:x1 :compute:zx
+  300 op mul *tmp78 :compute:zx :compute:zx
+  301 op mul *tmp79 :compute:zy :compute:zy
+  302 op sub *tmp80 *tmp78 *tmp79
+  303 op add :compute:zx *tmp80 :compute:cx
+  304 op mul *tmp82 2 :compute:x1
+  305 op mul *tmp83 *tmp82 :compute:zy
+  306 op add :compute:zy *tmp83 :compute:cy
+  307 op len :compute:dist :compute:zx :compute:zy
+  308 jump *label192 lessThan :compute:dist 64
+  309 jump *label63 always
+  310 label *label192
+  311 label *label193
+  312 label *label194
+  313 op add :compute:i :compute:i 1
+  314 set :compute:x1 :compute:zx
+  315 op mul *tmp78 :compute:zx :compute:zx
+  316 op mul *tmp79 :compute:zy :compute:zy
+  317 op sub *tmp80 *tmp78 *tmp79
+  318 op add :compute:zx *tmp80 :compute:cx
+  319 op mul *tmp82 2 :compute:x1
+  320 op mul *tmp83 *tmp82 :compute:zy
+  321 op add :compute:zy *tmp83 :compute:cy
+  322 op len :compute:dist :compute:zx :compute:zy
+  323 jump *label195 lessThan :compute:dist 64
+  324 jump *label63 always
+  325 label *label195
+  326 label *label196
+  327 label *label197
+  328 op add :compute:i :compute:i 1
+  329 set :compute:x1 :compute:zx
+  330 op mul *tmp78 :compute:zx :compute:zx
+  331 op mul *tmp79 :compute:zy :compute:zy
+  332 op sub *tmp80 *tmp78 *tmp79
+  333 op add :compute:zx *tmp80 :compute:cx
+  334 op mul *tmp82 2 :compute:x1
+  335 op mul *tmp83 *tmp82 :compute:zy
+  336 op add :compute:zy *tmp83 :compute:cy
+  337 op len :compute:dist :compute:zx :compute:zy
+  338 jump *label198 lessThan :compute:dist 64
+  339 jump *label63 always
+  340 label *label198
+  341 label *label199
+  342 label *label200
+  343 op add :compute:i :compute:i 1
+  344 set :compute:x1 :compute:zx
+  345 op mul *tmp78 :compute:zx :compute:zx
+  346 op mul *tmp79 :compute:zy :compute:zy
+  347 op sub *tmp80 *tmp78 *tmp79
+  348 op add :compute:zx *tmp80 :compute:cx
+  349 op mul *tmp82 2 :compute:x1
+  350 op mul *tmp83 *tmp82 :compute:zy
+  351 op add :compute:zy *tmp83 :compute:cy
+  352 op len :compute:dist :compute:zx :compute:zy
+  353 jump *label201 lessThan :compute:dist 64
+  354 jump *label63 always
+  355 label *label201
+  356 label *label202
+  357 label *label203
+  358 op add :compute:i :compute:i 1
+  359 set :compute:x1 :compute:zx
+  360 op mul *tmp78 :compute:zx :compute:zx
+  361 op mul *tmp79 :compute:zy :compute:zy
+  362 op sub *tmp80 *tmp78 *tmp79
+  363 op add :compute:zx *tmp80 :compute:cx
+  364 op mul *tmp82 2 :compute:x1
+  365 op mul *tmp83 *tmp82 :compute:zy
+  366 op add :compute:zy *tmp83 :compute:cy
+  367 op len :compute:dist :compute:zx :compute:zy
+  368 jump *label204 lessThan :compute:dist 64
+  369 jump *label63 always
+  370 label *label204
+  371 label *label205
+  372 label *label206
+  373 op add :compute:i :compute:i 1
+  374 set :compute:x1 :compute:zx
+  375 op mul *tmp78 :compute:zx :compute:zx
+  376 op mul *tmp79 :compute:zy :compute:zy
+  377 op sub *tmp80 *tmp78 *tmp79
+  378 op add :compute:zx *tmp80 :compute:cx
+  379 op mul *tmp82 2 :compute:x1
+  380 op mul *tmp83 *tmp82 :compute:zy
+  381 op add :compute:zy *tmp83 :compute:cy
+  382 op len :compute:dist :compute:zx :compute:zy
+  383 jump *label207 lessThan :compute:dist 64
+  384 jump *label63 always
+  385 label *label207
+  386 label *label208
+  387 label *label209
+  388 op add :compute:i :compute:i 1
+  389 set :compute:x1 :compute:zx
+  390 op mul *tmp78 :compute:zx :compute:zx
+  391 op mul *tmp79 :compute:zy :compute:zy
+  392 op sub *tmp80 *tmp78 *tmp79
+  393 op add :compute:zx *tmp80 :compute:cx
+  394 op mul *tmp82 2 :compute:x1
+  395 op mul *tmp83 *tmp82 :compute:zy
+  396 op add :compute:zy *tmp83 :compute:cy
+  397 op len :compute:dist :compute:zx :compute:zy
+  398 jump *label210 lessThan :compute:dist 64
+  399 jump *label63 always
+  400 label *label210
+  401 label *label211
+  402 label *label212
+  403 op add :compute:i :compute:i 1
+  404 set :compute:x1 :compute:zx
+  405 op mul *tmp78 :compute:zx :compute:zx
+  406 op mul *tmp79 :compute:zy :compute:zy
+  407 op sub *tmp80 *tmp78 *tmp79
+  408 op add :compute:zx *tmp80 :compute:cx
+  409 op mul *tmp82 2 :compute:x1
+  410 op mul *tmp83 *tmp82 :compute:zy
+  411 op add :compute:zy *tmp83 :compute:cy
+  412 op len :compute:dist :compute:zx :compute:zy
+  413 jump *label213 lessThan :compute:dist 64
+  414 jump *label63 always
+  415 label *label213
+  416 label *label214
+  417 label *label215
+  418 op add :compute:i :compute:i 1
+  419 set :compute:x1 :compute:zx
+  420 op mul *tmp78 :compute:zx :compute:zx
+  421 op mul *tmp79 :compute:zy :compute:zy
+  422 op sub *tmp80 *tmp78 *tmp79
+  423 op add :compute:zx *tmp80 :compute:cx
+  424 op mul *tmp82 2 :compute:x1
+  425 op mul *tmp83 *tmp82 :compute:zy
+  426 op add :compute:zy *tmp83 :compute:cy
+  427 op len :compute:dist :compute:zx :compute:zy
+  428 jump *label216 lessThan :compute:dist 64
+  429 jump *label63 always
+  430 label *label216
+  431 label *label217
+  432 label *label218
+  433 op add :compute:i :compute:i 1
+  434 set :compute:x1 :compute:zx
+  435 op mul *tmp78 :compute:zx :compute:zx
+  436 op mul *tmp79 :compute:zy :compute:zy
+  437 op sub *tmp80 *tmp78 *tmp79
+  438 op add :compute:zx *tmp80 :compute:cx
+  439 op mul *tmp82 2 :compute:x1
+  440 op mul *tmp83 *tmp82 :compute:zy
+  441 op add :compute:zy *tmp83 :compute:cy
+  442 op len :compute:dist :compute:zx :compute:zy
+  443 jump *label219 lessThan :compute:dist 64
+  444 jump *label63 always
+  445 label *label219
+  446 label *label220
+  447 label *label221
+  448 op add :compute:i :compute:i 1
+  449 set :compute:x1 :compute:zx
+  450 op mul *tmp78 :compute:zx :compute:zx
+  451 op mul *tmp79 :compute:zy :compute:zy
+  452 op sub *tmp80 *tmp78 *tmp79
+  453 op add :compute:zx *tmp80 :compute:cx
+  454 op mul *tmp82 2 :compute:x1
+  455 op mul *tmp83 *tmp82 :compute:zy
+  456 op add :compute:zy *tmp83 :compute:cy
+  457 op len :compute:dist :compute:zx :compute:zy
+  458 jump *label222 lessThan :compute:dist 64
+  459 jump *label63 always
+  460 label *label222
+  461 label *label223
+  462 label *label224
+  463 op add :compute:i :compute:i 1
+  464 set :compute:x1 :compute:zx
+  465 op mul *tmp78 :compute:zx :compute:zx
+  466 op mul *tmp79 :compute:zy :compute:zy
+  467 op sub *tmp80 *tmp78 *tmp79
+  468 op add :compute:zx *tmp80 :compute:cx
+  469 op mul *tmp82 2 :compute:x1
+  470 op mul *tmp83 *tmp82 :compute:zy
+  471 op add :compute:zy *tmp83 :compute:cy
+  472 op len :compute:dist :compute:zx :compute:zy
+  473 jump *label225 lessThan :compute:dist 64
+  474 jump *label63 always
+  475 label *label225
+  476 label *label226
+  477 label *label227
+  478 op add :compute:i :compute:i 1
+  479 set :compute:x1 :compute:zx
+  480 op mul *tmp78 :compute:zx :compute:zx
+  481 op mul *tmp79 :compute:zy :compute:zy
+  482 op sub *tmp80 *tmp78 *tmp79
+  483 op add :compute:zx *tmp80 :compute:cx
+  484 op mul *tmp82 2 :compute:x1
+  485 op mul *tmp83 *tmp82 :compute:zy
+  486 op add :compute:zy *tmp83 :compute:cy
+  487 op len :compute:dist :compute:zx :compute:zy
+  488 jump *label228 lessThan :compute:dist 64
+  489 jump *label63 always
+  490 label *label228
+  491 label *label229
+  492 label *label230
+  493 op add :compute:i :compute:i 1
+  494 set :compute:x1 :compute:zx
+  495 op mul *tmp78 :compute:zx :compute:zx
+  496 op mul *tmp79 :compute:zy :compute:zy
+  497 op sub *tmp80 *tmp78 *tmp79
+  498 op add :compute:zx *tmp80 :compute:cx
+  499 op mul *tmp82 2 :compute:x1
+  500 op mul *tmp83 *tmp82 :compute:zy
+  501 op add :compute:zy *tmp83 :compute:cy
+  502 op len :compute:dist :compute:zx :compute:zy
+  503 jump *label231 lessThan :compute:dist 64
+  504 jump *label63 always
+  505 label *label231
+  506 label *label232
+  507 label *label233
+  508 op add :compute:i :compute:i 1
+  509 set :compute:x1 :compute:zx
+  510 op mul *tmp78 :compute:zx :compute:zx
+  511 op mul *tmp79 :compute:zy :compute:zy
+  512 op sub *tmp80 *tmp78 *tmp79
+  513 op add :compute:zx *tmp80 :compute:cx
+  514 op mul *tmp82 2 :compute:x1
+  515 op mul *tmp83 *tmp82 :compute:zy
+  516 op add :compute:zy *tmp83 :compute:cy
+  517 op len :compute:dist :compute:zx :compute:zy
+  518 jump *label234 lessThan :compute:dist 64
+  519 jump *label63 always
+  520 label *label234
+  521 label *label235
+  522 label *label236
+  523 op add :compute:i :compute:i 1
+  524 set :compute:x1 :compute:zx
+  525 op mul *tmp78 :compute:zx :compute:zx
+  526 op mul *tmp79 :compute:zy :compute:zy
+  527 op sub *tmp80 *tmp78 *tmp79
+  528 op add :compute:zx *tmp80 :compute:cx
+  529 op mul *tmp82 2 :compute:x1
+  530 op mul *tmp83 *tmp82 :compute:zy
+  531 op add :compute:zy *tmp83 :compute:cy
+  532 op len :compute:dist :compute:zx :compute:zy
+  533 jump *label237 lessThan :compute:dist 64
+  534 jump *label63 always
+  535 label *label237
+  536 label *label238
+  537 label *label239
+  538 op add :compute:i :compute:i 1
+  539 set :compute:x1 :compute:zx
+  540 op mul *tmp78 :compute:zx :compute:zx
+  541 op mul *tmp79 :compute:zy :compute:zy
+  542 op sub *tmp80 *tmp78 *tmp79
+  543 op add :compute:zx *tmp80 :compute:cx
+  544 op mul *tmp82 2 :compute:x1
+  545 op mul *tmp83 *tmp82 :compute:zy
+  546 op add :compute:zy *tmp83 :compute:cy
+  547 op len :compute:dist :compute:zx :compute:zy
+  548 jump *label240 lessThan :compute:dist 64
+  549 jump *label63 always
+  550 label *label240
+  551 label *label241
+  552 label *label242
+  553 op add :compute:i :compute:i 1
+  554 set :compute:x1 :compute:zx
+  555 op mul *tmp78 :compute:zx :compute:zx
+  556 op mul *tmp79 :compute:zy :compute:zy
+  557 op sub *tmp80 *tmp78 *tmp79
+  558 op add :compute:zx *tmp80 :compute:cx
+  559 op mul *tmp82 2 :compute:x1
+  560 op mul *tmp83 *tmp82 :compute:zy
+  561 op add :compute:zy *tmp83 :compute:cy
+  562 op len :compute:dist :compute:zx :compute:zy
+  563 jump *label243 lessThan :compute:dist 64
+  564 jump *label63 always
+  565 label *label243
+  566 label *label244
+  567 label *label245
+  568 op add :compute:i :compute:i 1
+  569 set :compute:x1 :compute:zx
+  570 op mul *tmp78 :compute:zx :compute:zx
+  571 op mul *tmp79 :compute:zy :compute:zy
+  572 op sub *tmp80 *tmp78 *tmp79
+  573 op add :compute:zx *tmp80 :compute:cx
+  574 op mul *tmp82 2 :compute:x1
+  575 op mul *tmp83 *tmp82 :compute:zy
+  576 op add :compute:zy *tmp83 :compute:cy
+  577 op len :compute:dist :compute:zx :compute:zy
+  578 jump *label246 lessThan :compute:dist 64
+  579 jump *label63 always
+  580 label *label246
+  581 label *label247
+  582 label *label248
+  583 op add :compute:i :compute:i 1
+  584 set :compute:x1 :compute:zx
+  585 op mul *tmp78 :compute:zx :compute:zx
+  586 op mul *tmp79 :compute:zy :compute:zy
+  587 op sub *tmp80 *tmp78 *tmp79
+  588 op add :compute:zx *tmp80 :compute:cx
+  589 op mul *tmp82 2 :compute:x1
+  590 op mul *tmp83 *tmp82 :compute:zy
+  591 op add :compute:zy *tmp83 :compute:cy
+  592 op len :compute:dist :compute:zx :compute:zy
+  593 jump *label249 lessThan :compute:dist 64
+  594 jump *label63 always
+  595 label *label249
+  596 label *label250
+  597 label *label251
+  598 op add :compute:i :compute:i 1
+  599 set :compute:x1 :compute:zx
+  600 op mul *tmp78 :compute:zx :compute:zx
+  601 op mul *tmp79 :compute:zy :compute:zy
+  602 op sub *tmp80 *tmp78 *tmp79
+  603 op add :compute:zx *tmp80 :compute:cx
+  604 op mul *tmp82 2 :compute:x1
+  605 op mul *tmp83 *tmp82 :compute:zy
+  606 op add :compute:zy *tmp83 :compute:cy
+  607 op len :compute:dist :compute:zx :compute:zy
+  608 jump *label252 lessThan :compute:dist 64
+  609 jump *label63 always
+  610 label *label252
+  611 label *label253
+  612 label *label254
+  613 op add :compute:i :compute:i 1
+  614 set :compute:x1 :compute:zx
+  615 op mul *tmp78 :compute:zx :compute:zx
+  616 op mul *tmp79 :compute:zy :compute:zy
+  617 op sub *tmp80 *tmp78 *tmp79
+  618 op add :compute:zx *tmp80 :compute:cx
+  619 op mul *tmp82 2 :compute:x1
+  620 op mul *tmp83 *tmp82 :compute:zy
+  621 op add :compute:zy *tmp83 :compute:cy
+  622 op len :compute:dist :compute:zx :compute:zy
+  623 jump *label255 lessThan :compute:dist 64
+  624 jump *label63 always
+  625 label *label255
+  626 label *label256
+  627 label *label257
+  628 op add :compute:i :compute:i 1
+  629 set :compute:x1 :compute:zx
+  630 op mul *tmp78 :compute:zx :compute:zx
+  631 op mul *tmp79 :compute:zy :compute:zy
+  632 op sub *tmp80 *tmp78 *tmp79
+  633 op add :compute:zx *tmp80 :compute:cx
+  634 op mul *tmp82 2 :compute:x1
+  635 op mul *tmp83 *tmp82 :compute:zy
+  636 op add :compute:zy *tmp83 :compute:cy
+  637 op len :compute:dist :compute:zx :compute:zy
+  638 jump *label258 lessThan :compute:dist 64
+  639 jump *label63 always
+  640 label *label258
+  641 label *label259
+  642 label *label260
+  643 op add :compute:i :compute:i 1
+  644 set :compute:x1 :compute:zx
+  645 op mul *tmp78 :compute:zx :compute:zx
+  646 op mul *tmp79 :compute:zy :compute:zy
+  647 op sub *tmp80 *tmp78 *tmp79
+  648 op add :compute:zx *tmp80 :compute:cx
+  649 op mul *tmp82 2 :compute:x1
+  650 op mul *tmp83 *tmp82 :compute:zy
+  651 op add :compute:zy *tmp83 :compute:cy
+  652 op len :compute:dist :compute:zx :compute:zy
+  653 jump *label261 lessThan :compute:dist 64
+  654 jump *label63 always
+  655 label *label261
+  656 label *label262
+  657 label *label263
+  658 op add :compute:i :compute:i 1
+  659 set :compute:x1 :compute:zx
+  660 op mul *tmp78 :compute:zx :compute:zx
+  661 op mul *tmp79 :compute:zy :compute:zy
+  662 op sub *tmp80 *tmp78 *tmp79
+  663 op add :compute:zx *tmp80 :compute:cx
+  664 op mul *tmp82 2 :compute:x1
+  665 op mul *tmp83 *tmp82 :compute:zy
+  666 op add :compute:zy *tmp83 :compute:cy
+  667 op len :compute:dist :compute:zx :compute:zy
+  668 jump *label264 lessThan :compute:dist 64
+  669 jump *label63 always
+  670 label *label264
+  671 label *label265
+  672 label *label266
+  673 op add :compute:i :compute:i 1
+  674 set :compute:x1 :compute:zx
+  675 op mul *tmp78 :compute:zx :compute:zx
+  676 op mul *tmp79 :compute:zy :compute:zy
+  677 op sub *tmp80 *tmp78 *tmp79
+  678 op add :compute:zx *tmp80 :compute:cx
+  679 op mul *tmp82 2 :compute:x1
+  680 op mul *tmp83 *tmp82 :compute:zy
+  681 op add :compute:zy *tmp83 :compute:cy
+  682 op len :compute:dist :compute:zx :compute:zy
+  683 jump *label267 lessThan :compute:dist 64
+  684 jump *label63 always
+  685 label *label267
+  686 label *label268
+  687 label *label269
+  688 op add :compute:i :compute:i 1
+  689 set :compute:x1 :compute:zx
+  690 op mul *tmp78 :compute:zx :compute:zx
+  691 op mul *tmp79 :compute:zy :compute:zy
+  692 op sub *tmp80 *tmp78 *tmp79
+  693 op add :compute:zx *tmp80 :compute:cx
+  694 op mul *tmp82 2 :compute:x1
+  695 op mul *tmp83 *tmp82 :compute:zy
+  696 op add :compute:zy *tmp83 :compute:cy
+  697 op len :compute:dist :compute:zx :compute:zy
+  698 jump *label270 lessThan :compute:dist 64
+  699 jump *label63 always
+  700 label *label270
+  701 label *label271
+  702 label *label272
+  703 op add :compute:i :compute:i 1
+  704 set :compute:x1 :compute:zx
+  705 op mul *tmp78 :compute:zx :compute:zx
+  706 op mul *tmp79 :compute:zy :compute:zy
+  707 op sub *tmp80 *tmp78 *tmp79
+  708 op add :compute:zx *tmp80 :compute:cx
+  709 op mul *tmp82 2 :compute:x1
+  710 op mul *tmp83 *tmp82 :compute:zy
+  711 op add :compute:zy *tmp83 :compute:cy
+  712 op len :compute:dist :compute:zx :compute:zy
+  713 jump *label273 lessThan :compute:dist 64
+  714 jump *label63 always
+  715 label *label273
+  716 label *label274
+  717 label *label275
+  718 op add :compute:i :compute:i 1
+  719 set :compute:x1 :compute:zx
+  720 op mul *tmp78 :compute:zx :compute:zx
+  721 op mul *tmp79 :compute:zy :compute:zy
+  722 op sub *tmp80 *tmp78 *tmp79
+  723 op add :compute:zx *tmp80 :compute:cx
+  724 op mul *tmp82 2 :compute:x1
+  725 op mul *tmp83 *tmp82 :compute:zy
+  726 op add :compute:zy *tmp83 :compute:cy
+  727 op len :compute:dist :compute:zx :compute:zy
+  728 jump *label276 lessThan :compute:dist 64
+  729 jump *label63 always
+  730 label *label276
+  731 label *label277
+  732 label *label278
+  733 op add :compute:i :compute:i 1
+  734 set :compute:x1 :compute:zx
+  735 op mul *tmp78 :compute:zx :compute:zx
+  736 op mul *tmp79 :compute:zy :compute:zy
+  737 op sub *tmp80 *tmp78 *tmp79
+  738 op add :compute:zx *tmp80 :compute:cx
+  739 op mul *tmp82 2 :compute:x1
+  740 op mul *tmp83 *tmp82 :compute:zy
+  741 op add :compute:zy *tmp83 :compute:cy
+  742 op len :compute:dist :compute:zx :compute:zy
+  743 jump *label279 lessThan :compute:dist 64
+  744 jump *label63 always
+  745 label *label279
+  746 label *label280
+  747 label *label281
+  748 op add :compute:i :compute:i 1
+  749 set :compute:x1 :compute:zx
+  750 op mul *tmp78 :compute:zx :compute:zx
+  751 op mul *tmp79 :compute:zy :compute:zy
+  752 op sub *tmp80 *tmp78 *tmp79
+  753 op add :compute:zx *tmp80 :compute:cx
+  754 op mul *tmp82 2 :compute:x1
+  755 op mul *tmp83 *tmp82 :compute:zy
+  756 op add :compute:zy *tmp83 :compute:cy
+  757 op len :compute:dist :compute:zx :compute:zy
+  758 jump *label282 lessThan :compute:dist 64
+  759 jump *label63 always
+  760 label *label282
+  761 label *label283
+  762 label *label284
+  763 op add :compute:i :compute:i 1
+  764 set :compute:x1 :compute:zx
+  765 op mul *tmp78 :compute:zx :compute:zx
+  766 op mul *tmp79 :compute:zy :compute:zy
+  767 op sub *tmp80 *tmp78 *tmp79
+  768 op add :compute:zx *tmp80 :compute:cx
+  769 op mul *tmp82 2 :compute:x1
+  770 op mul *tmp83 *tmp82 :compute:zy
+  771 op add :compute:zy *tmp83 :compute:cy
+  772 op len :compute:dist :compute:zx :compute:zy
+  773 jump *label285 lessThan :compute:dist 64
+  774 jump *label63 always
+  775 label *label285
+  776 label *label286
+  777 label *label287
+  778 op add :compute:i :compute:i 1
+  779 set :compute:x1 :compute:zx
+  780 op mul *tmp78 :compute:zx :compute:zx
+  781 op mul *tmp79 :compute:zy :compute:zy
+  782 op sub *tmp80 *tmp78 *tmp79
+  783 op add :compute:zx *tmp80 :compute:cx
+  784 op mul *tmp82 2 :compute:x1
+  785 op mul *tmp83 *tmp82 :compute:zy
+  786 op add :compute:zy *tmp83 :compute:cy
+  787 op len :compute:dist :compute:zx :compute:zy
+  788 jump *label288 lessThan :compute:dist 64
+  789 jump *label63 always
+  790 label *label288
+  791 label *label289
+  792 label *label290
+  793 op add :compute:i :compute:i 1
+  794 set :compute:x1 :compute:zx
+  795 op mul *tmp78 :compute:zx :compute:zx
+  796 op mul *tmp79 :compute:zy :compute:zy
+  797 op sub *tmp80 *tmp78 *tmp79
+  798 op add :compute:zx *tmp80 :compute:cx
+  799 op mul *tmp82 2 :compute:x1
+  800 op mul *tmp83 *tmp82 :compute:zy
+  801 op add :compute:zy *tmp83 :compute:cy
+  802 op len :compute:dist :compute:zx :compute:zy
+  803 jump *label291 lessThan :compute:dist 64
+  804 jump *label63 always
+  805 label *label291
+  806 label *label292
+  807 label *label293
+  808 op add :compute:i :compute:i 1
+  809 set :compute:x1 :compute:zx
+  810 op mul *tmp78 :compute:zx :compute:zx
+  811 op mul *tmp79 :compute:zy :compute:zy
+  812 op sub *tmp80 *tmp78 *tmp79
+  813 op add :compute:zx *tmp80 :compute:cx
+  814 op mul *tmp82 2 :compute:x1
+  815 op mul *tmp83 *tmp82 :compute:zy
+  816 op add :compute:zy *tmp83 :compute:cy
+  817 op len :compute:dist :compute:zx :compute:zy
+  818 jump *label294 lessThan :compute:dist 64
+  819 jump *label63 always
+  820 label *label294
+  821 label *label295
+  822 label *label296
+  823 op add :compute:i :compute:i 1
+  824 set :compute:x1 :compute:zx
+  825 op mul *tmp78 :compute:zx :compute:zx
+  826 op mul *tmp79 :compute:zy :compute:zy
+  827 op sub *tmp80 *tmp78 *tmp79
+  828 op add :compute:zx *tmp80 :compute:cx
+  829 op mul *tmp82 2 :compute:x1
+  830 op mul *tmp83 *tmp82 :compute:zy
+  831 op add :compute:zy *tmp83 :compute:cy
+  832 op len :compute:dist :compute:zx :compute:zy
+  833 jump *label297 lessThan :compute:dist 64
+  834 jump *label63 always
+  835 label *label297
+  836 label *label298
+  837 label *label299
+  838 op add :compute:i :compute:i 1
+  839 set :compute:x1 :compute:zx
+  840 op mul *tmp78 :compute:zx :compute:zx
+  841 op mul *tmp79 :compute:zy :compute:zy
+  842 op sub *tmp80 *tmp78 *tmp79
+  843 op add :compute:zx *tmp80 :compute:cx
+  844 op mul *tmp82 2 :compute:x1
+  845 op mul *tmp83 *tmp82 :compute:zy
+  846 op add :compute:zy *tmp83 :compute:cy
+  847 op len :compute:dist :compute:zx :compute:zy
+  848 jump *label300 lessThan :compute:dist 64
+  849 jump *label63 always
+  850 label *label300
+  851 label *label301
+  852 label *label302
+  853 op add :compute:i :compute:i 1
+  854 set :compute:x1 :compute:zx
+  855 op mul *tmp78 :compute:zx :compute:zx
+  856 op mul *tmp79 :compute:zy :compute:zy
+  857 op sub *tmp80 *tmp78 *tmp79
+  858 op add :compute:zx *tmp80 :compute:cx
+  859 op mul *tmp82 2 :compute:x1
+  860 op mul *tmp83 *tmp82 :compute:zy
+  861 op add :compute:zy *tmp83 :compute:cy
+  862 op len :compute:dist :compute:zx :compute:zy
+  863 jump *label303 lessThan :compute:dist 64
+  864 jump *label63 always
+  865 label *label303
+  866 label *label304
+  867 label *label305
+  868 op add :compute:i :compute:i 1
+  869 set :compute:x1 :compute:zx
+  870 op mul *tmp78 :compute:zx :compute:zx
+  871 op mul *tmp79 :compute:zy :compute:zy
+  872 op sub *tmp80 *tmp78 *tmp79
+  873 op add :compute:zx *tmp80 :compute:cx
+  874 op mul *tmp82 2 :compute:x1
+  875 op mul *tmp83 *tmp82 :compute:zy
+  876 op add :compute:zy *tmp83 :compute:cy
+  877 op len :compute:dist :compute:zx :compute:zy
+  878 jump *label306 lessThan :compute:dist 64
+  879 jump *label63 always
+  880 label *label306
+  881 label *label307
+  882 label *label308
+  883 op add :compute:i :compute:i 1
+  884 set :compute:x1 :compute:zx
+  885 op mul *tmp78 :compute:zx :compute:zx
+  886 op mul *tmp79 :compute:zy :compute:zy
+  887 op sub *tmp80 *tmp78 *tmp79
+  888 op add :compute:zx *tmp80 :compute:cx
+  889 op mul *tmp82 2 :compute:x1
+  890 op mul *tmp83 *tmp82 :compute:zy
+  891 op add :compute:zy *tmp83 :compute:cy
+  892 op len :compute:dist :compute:zx :compute:zy
+  893 jump *label309 lessThan :compute:dist 64
+  894 jump *label63 always
+  895 label *label309
+  896 label *label310
+  897 label *label311
+  898 op add :compute:i :compute:i 1
+  899 set :compute:x1 :compute:zx
+  900 op mul *tmp78 :compute:zx :compute:zx
+  901 op mul *tmp79 :compute:zy :compute:zy
+  902 op sub *tmp80 *tmp78 *tmp79
+  903 op add :compute:zx *tmp80 :compute:cx
+  904 op mul *tmp82 2 :compute:x1
+  905 op mul *tmp83 *tmp82 :compute:zy
+  906 op add :compute:zy *tmp83 :compute:cy
+  907 op len :compute:dist :compute:zx :compute:zy
+  908 jump *label312 lessThan :compute:dist 64
+  909 jump *label63 always
+  910 label *label312
+  911 label *label313
+  912 label *label314
+  913 op add :compute:i :compute:i 1
+  914 set :compute:x1 :compute:zx
+  915 op mul *tmp78 :compute:zx :compute:zx
+  916 op mul *tmp79 :compute:zy :compute:zy
+  917 op sub *tmp80 *tmp78 *tmp79
+  918 op add :compute:zx *tmp80 :compute:cx
+  919 op mul *tmp82 2 :compute:x1
+  920 op mul *tmp83 *tmp82 :compute:zy
+  921 op add :compute:zy *tmp83 :compute:cy
+  922 op len :compute:dist :compute:zx :compute:zy
+  923 jump *label315 lessThan :compute:dist 64
+  924 jump *label63 always
+  925 label *label315
+  926 label *label316
+  927 label *label317
+  928 op add :compute:i :compute:i 1
+  929 set :compute:x1 :compute:zx
+  930 op mul *tmp78 :compute:zx :compute:zx
+  931 op mul *tmp79 :compute:zy :compute:zy
+  932 op sub *tmp80 *tmp78 *tmp79
+  933 op add :compute:zx *tmp80 :compute:cx
+  934 op mul *tmp82 2 :compute:x1
+  935 op mul *tmp83 *tmp82 :compute:zy
+  936 op add :compute:zy *tmp83 :compute:cy
+  937 op len :compute:dist :compute:zx :compute:zy
+  938 jump *label318 lessThan :compute:dist 64
+  939 jump *label63 always
+  940 label *label318
+  941 label *label319
+  942 label *label320
+  943 op add :compute:i :compute:i 1
+  944 set :compute:x1 :compute:zx
+  945 op mul *tmp78 :compute:zx :compute:zx
+  946 op mul *tmp79 :compute:zy :compute:zy
+  947 op sub *tmp80 *tmp78 *tmp79
+  948 op add :compute:zx *tmp80 :compute:cx
+  949 op mul *tmp82 2 :compute:x1
+  950 op mul *tmp83 *tmp82 :compute:zy
+  951 op add :compute:zy *tmp83 :compute:cy
+  952 op len :compute:dist :compute:zx :compute:zy
+  953 jump *label321 lessThan :compute:dist 64
+  954 jump *label63 always
+  955 label *label321
+  956 label *label322
+  957 label *label323
+  958 op add :compute:i :compute:i 1
+  959 set :compute:x1 :compute:zx
+  960 op mul *tmp78 :compute:zx :compute:zx
+  961 op mul *tmp79 :compute:zy :compute:zy
+  962 op sub *tmp80 *tmp78 *tmp79
+  963 op add :compute:zx *tmp80 :compute:cx
+  964 op mul *tmp82 2 :compute:x1
+  965 op mul *tmp83 *tmp82 :compute:zy
+  966 op add :compute:zy *tmp83 :compute:cy
+  967 op len :compute:dist :compute:zx :compute:zy
+  968 jump *label324 lessThan :compute:dist 64
+  969 jump *label63 always
+  970 label *label324
+  971 label *label325
+  972 label *label326
+  973 op add :compute:i :compute:i 1
+  974 set :compute:x1 :compute:zx
+  975 op mul *tmp78 :compute:zx :compute:zx
+  976 op mul *tmp79 :compute:zy :compute:zy
+  977 op sub *tmp80 *tmp78 *tmp79
+  978 op add :compute:zx *tmp80 :compute:cx
+  979 op mul *tmp82 2 :compute:x1
+  980 op mul *tmp83 *tmp82 :compute:zy
+  981 op add :compute:zy *tmp83 :compute:cy
+  982 op len :compute:dist :compute:zx :compute:zy
+  983 jump *label327 lessThan :compute:dist 64
+  984 jump *label63 always
+  985 label *label327
+  986 label *label328
+  987 label *label329
+  988 op add :compute:i :compute:i 1
+  989 set :compute:x1 :compute:zx
+  990 op mul *tmp78 :compute:zx :compute:zx
+  991 op mul *tmp79 :compute:zy :compute:zy
+  992 op sub *tmp80 *tmp78 *tmp79
+  993 op add :compute:zx *tmp80 :compute:cx
+  994 op mul *tmp82 2 :compute:x1
+  995 op mul *tmp83 *tmp82 :compute:zy
+  996 op add :compute:zy *tmp83 :compute:cy
+  997 op len :compute:dist :compute:zx :compute:zy
+  998 jump *label330 lessThan :compute:dist 64
+  999 jump *label63 always
+ 1000 label *label330
+ 1001 label *label331
+ 1002 label *label332
+ 1003 op add :compute:i :compute:i 1
+ 1004 set :compute:x1 :compute:zx
+ 1005 op mul *tmp78 :compute:zx :compute:zx
+ 1006 op mul *tmp79 :compute:zy :compute:zy
+ 1007 op sub *tmp80 *tmp78 *tmp79
+ 1008 op add :compute:zx *tmp80 :compute:cx
+ 1009 op mul *tmp82 2 :compute:x1
+ 1010 op mul *tmp83 *tmp82 :compute:zy
+ 1011 op add :compute:zy *tmp83 :compute:cy
+ 1012 op len :compute:dist :compute:zx :compute:zy
+ 1013 jump *label333 lessThan :compute:dist 64
+ 1014 jump *label63 always
+ 1015 label *label333
+ 1016 label *label334
+ 1017 label *label335
+ 1018 op add :compute:i :compute:i 1
+ 1019 set :compute:x1 :compute:zx
+ 1020 op mul *tmp78 :compute:zx :compute:zx
+ 1021 op mul *tmp79 :compute:zy :compute:zy
+ 1022 op sub *tmp80 *tmp78 *tmp79
+ 1023 op add :compute:zx *tmp80 :compute:cx
+ 1024 op mul *tmp82 2 :compute:x1
+ 1025 op mul *tmp83 *tmp82 :compute:zy
+ 1026 op add :compute:zy *tmp83 :compute:cy
+ 1027 op len :compute:dist :compute:zx :compute:zy
+ 1028 jump *label336 lessThan :compute:dist 64
+ 1029 jump *label63 always
+ 1030 label *label336
+ 1031 label *label337
+ 1032 label *label338
+ 1033 op add :compute:i :compute:i 1
+ 1034 set :compute:x1 :compute:zx
+ 1035 op mul *tmp78 :compute:zx :compute:zx
+ 1036 op mul *tmp79 :compute:zy :compute:zy
+ 1037 op sub *tmp80 *tmp78 *tmp79
+ 1038 op add :compute:zx *tmp80 :compute:cx
+ 1039 op mul *tmp82 2 :compute:x1
+ 1040 op mul *tmp83 *tmp82 :compute:zy
+ 1041 op add :compute:zy *tmp83 :compute:cy
+ 1042 op len :compute:dist :compute:zx :compute:zy
+ 1043 jump *label339 lessThan :compute:dist 64
+ 1044 jump *label63 always
+ 1045 label *label339
+ 1046 label *label340
+ 1047 label *label341
+ 1048 op add :compute:i :compute:i 1
+ 1049 set :compute:x1 :compute:zx
+ 1050 op mul *tmp78 :compute:zx :compute:zx
+ 1051 op mul *tmp79 :compute:zy :compute:zy
+ 1052 op sub *tmp80 *tmp78 *tmp79
+ 1053 op add :compute:zx *tmp80 :compute:cx
+ 1054 op mul *tmp82 2 :compute:x1
+ 1055 op mul *tmp83 *tmp82 :compute:zy
+ 1056 op add :compute:zy *tmp83 :compute:cy
+ 1057 op len :compute:dist :compute:zx :compute:zy
+ 1058 jump *label342 lessThan :compute:dist 64
+ 1059 jump *label63 always
+ 1060 label *label342
+ 1061 label *label343
+ 1062 label *label344
+ 1063 op add :compute:i :compute:i 1
+ 1064 set :compute:x1 :compute:zx
+ 1065 op mul *tmp78 :compute:zx :compute:zx
+ 1066 op mul *tmp79 :compute:zy :compute:zy
+ 1067 op sub *tmp80 *tmp78 *tmp79
+ 1068 op add :compute:zx *tmp80 :compute:cx
+ 1069 op mul *tmp82 2 :compute:x1
+ 1070 op mul *tmp83 *tmp82 :compute:zy
+ 1071 op add :compute:zy *tmp83 :compute:cy
+ 1072 op len :compute:dist :compute:zx :compute:zy
+ 1073 jump *label345 lessThan :compute:dist 64
+ 1074 jump *label63 always
+ 1075 label *label345
+ 1076 label *label346
+ 1077 label *label347
+ 1078 op add :compute:i :compute:i 1
+ 1079 set :compute:x1 :compute:zx
+ 1080 op mul *tmp78 :compute:zx :compute:zx
+ 1081 op mul *tmp79 :compute:zy :compute:zy
+ 1082 op sub *tmp80 *tmp78 *tmp79
+ 1083 op add :compute:zx *tmp80 :compute:cx
+ 1084 op mul *tmp82 2 :compute:x1
+ 1085 op mul *tmp83 *tmp82 :compute:zy
+ 1086 op add :compute:zy *tmp83 :compute:cy
+ 1087 op len :compute:dist :compute:zx :compute:zy
+ 1088 jump *label348 lessThan :compute:dist 64
+ 1089 jump *label63 always
+ 1090 label *label348
+ 1091 label *label349
+ 1092 label *label350
+ 1093 op add :compute:i :compute:i 1
+ 1094 set :compute:x1 :compute:zx
+ 1095 op mul *tmp78 :compute:zx :compute:zx
+ 1096 op mul *tmp79 :compute:zy :compute:zy
+ 1097 op sub *tmp80 *tmp78 *tmp79
+ 1098 op add :compute:zx *tmp80 :compute:cx
+ 1099 op mul *tmp82 2 :compute:x1
+ 1100 op mul *tmp83 *tmp82 :compute:zy
+ 1101 op add :compute:zy *tmp83 :compute:cy
+ 1102 op len :compute:dist :compute:zx :compute:zy
+ 1103 jump *label351 lessThan :compute:dist 64
+ 1104 jump *label63 always
+ 1105 label *label351
+ 1106 label *label352
+ 1107 label *label353
+ 1108 op add :compute:i :compute:i 1
+ 1109 label *label63
  1110 op mul *tmp88 .SMOOTH 63
  1111 jump *label66 greaterThanEq :compute:i *tmp88
  1112 op log *tmp91 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   175 label *label165
   176 label *label166
   177 label *label167
-    * op add :compute:i :compute:i 1
+  178 op add :compute:i 0 1
   179 set :compute:x1 :compute:zx
   180 op mul *tmp78 :compute:zx :compute:zx
   181 op mul *tmp79 :compute:zy :compute:zy
 
   190 label *label168
   191 label *label169
   192 label *label170
-    * op add :compute:i :compute:i 1
+  193 op add :compute:i 1 1
   194 set :compute:x1 :compute:zx
   195 op mul *tmp78 :compute:zx :compute:zx
   196 op mul *tmp79 :compute:zy :compute:zy
 
   205 label *label171
   206 label *label172
   207 label *label173
-    * op add :compute:i :compute:i 1
+  208 op add :compute:i 2 1
   209 set :compute:x1 :compute:zx
   210 op mul *tmp78 :compute:zx :compute:zx
   211 op mul *tmp79 :compute:zy :compute:zy
 
   220 label *label174
   221 label *label175
   222 label *label176
-    * op add :compute:i :compute:i 1
+  223 op add :compute:i 3 1
   224 set :compute:x1 :compute:zx
   225 op mul *tmp78 :compute:zx :compute:zx
   226 op mul *tmp79 :compute:zy :compute:zy
 
   235 label *label177
   236 label *label178
   237 label *label179
-    * op add :compute:i :compute:i 1
+  238 op add :compute:i 4 1
   239 set :compute:x1 :compute:zx
   240 op mul *tmp78 :compute:zx :compute:zx
   241 op mul *tmp79 :compute:zy :compute:zy
 
   250 label *label180
   251 label *label181
   252 label *label182
-    * op add :compute:i :compute:i 1
+  253 op add :compute:i 5 1
   254 set :compute:x1 :compute:zx
   255 op mul *tmp78 :compute:zx :compute:zx
   256 op mul *tmp79 :compute:zy :compute:zy
 
   265 label *label183
   266 label *label184
   267 label *label185
-    * op add :compute:i :compute:i 1
+  268 op add :compute:i 6 1
   269 set :compute:x1 :compute:zx
   270 op mul *tmp78 :compute:zx :compute:zx
   271 op mul *tmp79 :compute:zy :compute:zy
 
   280 label *label186
   281 label *label187
   282 label *label188
-    * op add :compute:i :compute:i 1
+  283 op add :compute:i 7 1
   284 set :compute:x1 :compute:zx
   285 op mul *tmp78 :compute:zx :compute:zx
   286 op mul *tmp79 :compute:zy :compute:zy
 
   295 label *label189
   296 label *label190
   297 label *label191
-    * op add :compute:i :compute:i 1
+  298 op add :compute:i 8 1
   299 set :compute:x1 :compute:zx
   300 op mul *tmp78 :compute:zx :compute:zx
   301 op mul *tmp79 :compute:zy :compute:zy
 
   310 label *label192
   311 label *label193
   312 label *label194
-    * op add :compute:i :compute:i 1
+  313 op add :compute:i 9 1
   314 set :compute:x1 :compute:zx
   315 op mul *tmp78 :compute:zx :compute:zx
   316 op mul *tmp79 :compute:zy :compute:zy
 
   325 label *label195
   326 label *label196
   327 label *label197
-    * op add :compute:i :compute:i 1
+  328 op add :compute:i 10 1
   329 set :compute:x1 :compute:zx
   330 op mul *tmp78 :compute:zx :compute:zx
   331 op mul *tmp79 :compute:zy :compute:zy
 
   340 label *label198
   341 label *label199
   342 label *label200
-    * op add :compute:i :compute:i 1
+  343 op add :compute:i 11 1
   344 set :compute:x1 :compute:zx
   345 op mul *tmp78 :compute:zx :compute:zx
   346 op mul *tmp79 :compute:zy :compute:zy
 
   355 label *label201
   356 label *label202
   357 label *label203
-    * op add :compute:i :compute:i 1
+  358 op add :compute:i 12 1
   359 set :compute:x1 :compute:zx
   360 op mul *tmp78 :compute:zx :compute:zx
   361 op mul *tmp79 :compute:zy :compute:zy
 
   370 label *label204
   371 label *label205
   372 label *label206
-    * op add :compute:i :compute:i 1
+  373 op add :compute:i 13 1
   374 set :compute:x1 :compute:zx
   375 op mul *tmp78 :compute:zx :compute:zx
   376 op mul *tmp79 :compute:zy :compute:zy
 
   385 label *label207
   386 label *label208
   387 label *label209
-    * op add :compute:i :compute:i 1
+  388 op add :compute:i 14 1
   389 set :compute:x1 :compute:zx
   390 op mul *tmp78 :compute:zx :compute:zx
   391 op mul *tmp79 :compute:zy :compute:zy
 
   400 label *label210
   401 label *label211
   402 label *label212
-    * op add :compute:i :compute:i 1
+  403 op add :compute:i 15 1
   404 set :compute:x1 :compute:zx
   405 op mul *tmp78 :compute:zx :compute:zx
   406 op mul *tmp79 :compute:zy :compute:zy
 
   415 label *label213
   416 label *label214
   417 label *label215
-    * op add :compute:i :compute:i 1
+  418 op add :compute:i 16 1
   419 set :compute:x1 :compute:zx
   420 op mul *tmp78 :compute:zx :compute:zx
   421 op mul *tmp79 :compute:zy :compute:zy
 
   430 label *label216
   431 label *label217
   432 label *label218
-    * op add :compute:i :compute:i 1
+  433 op add :compute:i 17 1
   434 set :compute:x1 :compute:zx
   435 op mul *tmp78 :compute:zx :compute:zx
   436 op mul *tmp79 :compute:zy :compute:zy
 
   445 label *label219
   446 label *label220
   447 label *label221
-    * op add :compute:i :compute:i 1
+  448 op add :compute:i 18 1
   449 set :compute:x1 :compute:zx
   450 op mul *tmp78 :compute:zx :compute:zx
   451 op mul *tmp79 :compute:zy :compute:zy
 
   460 label *label222
   461 label *label223
   462 label *label224
-    * op add :compute:i :compute:i 1
+  463 op add :compute:i 19 1
   464 set :compute:x1 :compute:zx
   465 op mul *tmp78 :compute:zx :compute:zx
   466 op mul *tmp79 :compute:zy :compute:zy
 
   475 label *label225
   476 label *label226
   477 label *label227
-    * op add :compute:i :compute:i 1
+  478 op add :compute:i 20 1
   479 set :compute:x1 :compute:zx
   480 op mul *tmp78 :compute:zx :compute:zx
   481 op mul *tmp79 :compute:zy :compute:zy
 
   490 label *label228
   491 label *label229
   492 label *label230
-    * op add :compute:i :compute:i 1
+  493 op add :compute:i 21 1
   494 set :compute:x1 :compute:zx
   495 op mul *tmp78 :compute:zx :compute:zx
   496 op mul *tmp79 :compute:zy :compute:zy
 
   505 label *label231
   506 label *label232
   507 label *label233
-    * op add :compute:i :compute:i 1
+  508 op add :compute:i 22 1
   509 set :compute:x1 :compute:zx
   510 op mul *tmp78 :compute:zx :compute:zx
   511 op mul *tmp79 :compute:zy :compute:zy
 
   520 label *label234
   521 label *label235
   522 label *label236
-    * op add :compute:i :compute:i 1
+  523 op add :compute:i 23 1
   524 set :compute:x1 :compute:zx
   525 op mul *tmp78 :compute:zx :compute:zx
   526 op mul *tmp79 :compute:zy :compute:zy
 
   535 label *label237
   536 label *label238
   537 label *label239
-    * op add :compute:i :compute:i 1
+  538 op add :compute:i 24 1
   539 set :compute:x1 :compute:zx
   540 op mul *tmp78 :compute:zx :compute:zx
   541 op mul *tmp79 :compute:zy :compute:zy
 
   550 label *label240
   551 label *label241
   552 label *label242
-    * op add :compute:i :compute:i 1
+  553 op add :compute:i 25 1
   554 set :compute:x1 :compute:zx
   555 op mul *tmp78 :compute:zx :compute:zx
   556 op mul *tmp79 :compute:zy :compute:zy
 
   565 label *label243
   566 label *label244
   567 label *label245
-    * op add :compute:i :compute:i 1
+  568 op add :compute:i 26 1
   569 set :compute:x1 :compute:zx
   570 op mul *tmp78 :compute:zx :compute:zx
   571 op mul *tmp79 :compute:zy :compute:zy
 
   580 label *label246
   581 label *label247
   582 label *label248
-    * op add :compute:i :compute:i 1
+  583 op add :compute:i 27 1
   584 set :compute:x1 :compute:zx
   585 op mul *tmp78 :compute:zx :compute:zx
   586 op mul *tmp79 :compute:zy :compute:zy
 
   595 label *label249
   596 label *label250
   597 label *label251
-    * op add :compute:i :compute:i 1
+  598 op add :compute:i 28 1
   599 set :compute:x1 :compute:zx
   600 op mul *tmp78 :compute:zx :compute:zx
   601 op mul *tmp79 :compute:zy :compute:zy
 
   610 label *label252
   611 label *label253
   612 label *label254
-    * op add :compute:i :compute:i 1
+  613 op add :compute:i 29 1
   614 set :compute:x1 :compute:zx
   615 op mul *tmp78 :compute:zx :compute:zx
   616 op mul *tmp79 :compute:zy :compute:zy
 
   625 label *label255
   626 label *label256
   627 label *label257
-    * op add :compute:i :compute:i 1
+  628 op add :compute:i 30 1
   629 set :compute:x1 :compute:zx
   630 op mul *tmp78 :compute:zx :compute:zx
   631 op mul *tmp79 :compute:zy :compute:zy
 
   640 label *label258
   641 label *label259
   642 label *label260
-    * op add :compute:i :compute:i 1
+  643 op add :compute:i 31 1
   644 set :compute:x1 :compute:zx
   645 op mul *tmp78 :compute:zx :compute:zx
   646 op mul *tmp79 :compute:zy :compute:zy
 
   655 label *label261
   656 label *label262
   657 label *label263
-    * op add :compute:i :compute:i 1
+  658 op add :compute:i 32 1
   659 set :compute:x1 :compute:zx
   660 op mul *tmp78 :compute:zx :compute:zx
   661 op mul *tmp79 :compute:zy :compute:zy
 
   670 label *label264
   671 label *label265
   672 label *label266
-    * op add :compute:i :compute:i 1
+  673 op add :compute:i 33 1
   674 set :compute:x1 :compute:zx
   675 op mul *tmp78 :compute:zx :compute:zx
   676 op mul *tmp79 :compute:zy :compute:zy
 
   685 label *label267
   686 label *label268
   687 label *label269
-    * op add :compute:i :compute:i 1
+  688 op add :compute:i 34 1
   689 set :compute:x1 :compute:zx
   690 op mul *tmp78 :compute:zx :compute:zx
   691 op mul *tmp79 :compute:zy :compute:zy
 
   700 label *label270
   701 label *label271
   702 label *label272
-    * op add :compute:i :compute:i 1
+  703 op add :compute:i 35 1
   704 set :compute:x1 :compute:zx
   705 op mul *tmp78 :compute:zx :compute:zx
   706 op mul *tmp79 :compute:zy :compute:zy
 
   715 label *label273
   716 label *label274
   717 label *label275
-    * op add :compute:i :compute:i 1
+  718 op add :compute:i 36 1
   719 set :compute:x1 :compute:zx
   720 op mul *tmp78 :compute:zx :compute:zx
   721 op mul *tmp79 :compute:zy :compute:zy
 
   730 label *label276
   731 label *label277
   732 label *label278
-    * op add :compute:i :compute:i 1
+  733 op add :compute:i 37 1
   734 set :compute:x1 :compute:zx
   735 op mul *tmp78 :compute:zx :compute:zx
   736 op mul *tmp79 :compute:zy :compute:zy
 
   745 label *label279
   746 label *label280
   747 label *label281
-    * op add :compute:i :compute:i 1
+  748 op add :compute:i 38 1
   749 set :compute:x1 :compute:zx
   750 op mul *tmp78 :compute:zx :compute:zx
   751 op mul *tmp79 :compute:zy :compute:zy
 
   760 label *label282
   761 label *label283
   762 label *label284
-    * op add :compute:i :compute:i 1
+  763 op add :compute:i 39 1
   764 set :compute:x1 :compute:zx
   765 op mul *tmp78 :compute:zx :compute:zx
   766 op mul *tmp79 :compute:zy :compute:zy
 
   775 label *label285
   776 label *label286
   777 label *label287
-    * op add :compute:i :compute:i 1
+  778 op add :compute:i 40 1
   779 set :compute:x1 :compute:zx
   780 op mul *tmp78 :compute:zx :compute:zx
   781 op mul *tmp79 :compute:zy :compute:zy
 
   790 label *label288
   791 label *label289
   792 label *label290
-    * op add :compute:i :compute:i 1
+  793 op add :compute:i 41 1
   794 set :compute:x1 :compute:zx
   795 op mul *tmp78 :compute:zx :compute:zx
   796 op mul *tmp79 :compute:zy :compute:zy
 
   805 label *label291
   806 label *label292
   807 label *label293
-    * op add :compute:i :compute:i 1
+  808 op add :compute:i 42 1
   809 set :compute:x1 :compute:zx
   810 op mul *tmp78 :compute:zx :compute:zx
   811 op mul *tmp79 :compute:zy :compute:zy
 
   820 label *label294
   821 label *label295
   822 label *label296
-    * op add :compute:i :compute:i 1
+  823 op add :compute:i 43 1
   824 set :compute:x1 :compute:zx
   825 op mul *tmp78 :compute:zx :compute:zx
   826 op mul *tmp79 :compute:zy :compute:zy
 
   835 label *label297
   836 label *label298
   837 label *label299
-    * op add :compute:i :compute:i 1
+  838 op add :compute:i 44 1
   839 set :compute:x1 :compute:zx
   840 op mul *tmp78 :compute:zx :compute:zx
   841 op mul *tmp79 :compute:zy :compute:zy
 
   850 label *label300
   851 label *label301
   852 label *label302
-    * op add :compute:i :compute:i 1
+  853 op add :compute:i 45 1
   854 set :compute:x1 :compute:zx
   855 op mul *tmp78 :compute:zx :compute:zx
   856 op mul *tmp79 :compute:zy :compute:zy
 
   865 label *label303
   866 label *label304
   867 label *label305
-    * op add :compute:i :compute:i 1
+  868 op add :compute:i 46 1
   869 set :compute:x1 :compute:zx
   870 op mul *tmp78 :compute:zx :compute:zx
   871 op mul *tmp79 :compute:zy :compute:zy
 
   880 label *label306
   881 label *label307
   882 label *label308
-    * op add :compute:i :compute:i 1
+  883 op add :compute:i 47 1
   884 set :compute:x1 :compute:zx
   885 op mul *tmp78 :compute:zx :compute:zx
   886 op mul *tmp79 :compute:zy :compute:zy
 
   895 label *label309
   896 label *label310
   897 label *label311
-    * op add :compute:i :compute:i 1
+  898 op add :compute:i 48 1
   899 set :compute:x1 :compute:zx
   900 op mul *tmp78 :compute:zx :compute:zx
   901 op mul *tmp79 :compute:zy :compute:zy
 
   910 label *label312
   911 label *label313
   912 label *label314
-    * op add :compute:i :compute:i 1
+  913 op add :compute:i 49 1
   914 set :compute:x1 :compute:zx
   915 op mul *tmp78 :compute:zx :compute:zx
   916 op mul *tmp79 :compute:zy :compute:zy
 
   925 label *label315
   926 label *label316
   927 label *label317
-    * op add :compute:i :compute:i 1
+  928 op add :compute:i 50 1
   929 set :compute:x1 :compute:zx
   930 op mul *tmp78 :compute:zx :compute:zx
   931 op mul *tmp79 :compute:zy :compute:zy
 
   940 label *label318
   941 label *label319
   942 label *label320
-    * op add :compute:i :compute:i 1
+  943 op add :compute:i 51 1
   944 set :compute:x1 :compute:zx
   945 op mul *tmp78 :compute:zx :compute:zx
   946 op mul *tmp79 :compute:zy :compute:zy
 
   955 label *label321
   956 label *label322
   957 label *label323
-    * op add :compute:i :compute:i 1
+  958 op add :compute:i 52 1
   959 set :compute:x1 :compute:zx
   960 op mul *tmp78 :compute:zx :compute:zx
   961 op mul *tmp79 :compute:zy :compute:zy
 
   970 label *label324
   971 label *label325
   972 label *label326
-    * op add :compute:i :compute:i 1
+  973 op add :compute:i 53 1
   974 set :compute:x1 :compute:zx
   975 op mul *tmp78 :compute:zx :compute:zx
   976 op mul *tmp79 :compute:zy :compute:zy
 
   985 label *label327
   986 label *label328
   987 label *label329
-    * op add :compute:i :compute:i 1
+  988 op add :compute:i 54 1
   989 set :compute:x1 :compute:zx
   990 op mul *tmp78 :compute:zx :compute:zx
   991 op mul *tmp79 :compute:zy :compute:zy
 
  1000 label *label330
  1001 label *label331
  1002 label *label332
-    * op add :compute:i :compute:i 1
+ 1003 op add :compute:i 55 1
  1004 set :compute:x1 :compute:zx
  1005 op mul *tmp78 :compute:zx :compute:zx
  1006 op mul *tmp79 :compute:zy :compute:zy
 
  1015 label *label333
  1016 label *label334
  1017 label *label335
-    * op add :compute:i :compute:i 1
+ 1018 op add :compute:i 56 1
  1019 set :compute:x1 :compute:zx
  1020 op mul *tmp78 :compute:zx :compute:zx
  1021 op mul *tmp79 :compute:zy :compute:zy
 
  1030 label *label336
  1031 label *label337
  1032 label *label338
-    * op add :compute:i :compute:i 1
+ 1033 op add :compute:i 57 1
  1034 set :compute:x1 :compute:zx
  1035 op mul *tmp78 :compute:zx :compute:zx
  1036 op mul *tmp79 :compute:zy :compute:zy
 
  1045 label *label339
  1046 label *label340
  1047 label *label341
-    * op add :compute:i :compute:i 1
+ 1048 op add :compute:i 58 1
  1049 set :compute:x1 :compute:zx
  1050 op mul *tmp78 :compute:zx :compute:zx
  1051 op mul *tmp79 :compute:zy :compute:zy
 
  1060 label *label342
  1061 label *label343
  1062 label *label344
-    * op add :compute:i :compute:i 1
+ 1063 op add :compute:i 59 1
  1064 set :compute:x1 :compute:zx
  1065 op mul *tmp78 :compute:zx :compute:zx
  1066 op mul *tmp79 :compute:zy :compute:zy
 
  1075 label *label345
  1076 label *label346
  1077 label *label347
-    * op add :compute:i :compute:i 1
+ 1078 op add :compute:i 60 1
  1079 set :compute:x1 :compute:zx
  1080 op mul *tmp78 :compute:zx :compute:zx
  1081 op mul *tmp79 :compute:zy :compute:zy
 
  1090 label *label348
  1091 label *label349
  1092 label *label350
-    * op add :compute:i :compute:i 1
+ 1093 op add :compute:i 61 1
  1094 set :compute:x1 :compute:zx
  1095 op mul *tmp78 :compute:zx :compute:zx
  1096 op mul *tmp79 :compute:zy :compute:zy
 
  1105 label *label351
  1106 label *label352
  1107 label *label353
-    * op add :compute:i :compute:i 1
+ 1108 op add :compute:i 62 1
  1109 label *label63
  1110 op mul *tmp88 .SMOOTH 63
  1111 jump *label66 greaterThanEq :compute:i *tmp88

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1 (-2 instructions):
 
    21 label *label116
    22 jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    24 label *label117
    25 label *label118
    26 label *label119
 
    29 label *label122
    30 jump *label123 notEqual @memory-bank :findLinkedBlocks:type
    31 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    32 label *label123
    33 label *label124
    34 label *label125
 
   173 label *label165
   174 label *label166
   175 label *label167
-    * op add :compute:i 0 1
+  176 set :compute:i 1
   177 set :compute:x1 :compute:zx
   178 op mul *tmp78 :compute:zx :compute:zx
   179 op mul *tmp79 :compute:zy :compute:zy

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1:
 
    58 label *label146
    59 label *label147
    60 label *label23
-    * printflush :findLinkedBlocks:message
+   61 printflush null
    62 label *label2
    63 jump *label1 equal :findLinkedBlocks:foundAll false
    64 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 2 (-1 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:message null
     1 label *label1
     2 label *label129
     3 label *label130

Modifications by Iterated phase, Boolean Optimization, pass 3, iteration 1 (-2 instructions):
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label116
-    * jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label117
-    * label *label118
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    22 label *label119
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label122
-    * jump *label123 notEqual @memory-bank :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label123
-    * label *label124
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    27 label *label125
    28 set .memory :findLinkedBlocks:variable
    29 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 1:
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label116
-    * select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    22 label *label119
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label122
-    * select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    27 label *label125
    28 set .memory :findLinkedBlocks:variable
    29 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 2 (-2 instructions):
 
    16 print "\nFound: "
    17 print :findLinkedBlocks:block
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:variable .display
    19 label *label116
    20 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    21 label *label119
    22 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:variable .memory
    23 label *label122
    24 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    25 label *label125

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-1 instructions):
     0 set .start 0
     1 label *label1
-    * label *label129
-    * label *label130
     2 set .display null
-    * label *label133
-    * label *label134
     3 set .memory null
-    * label *label6
     4 print "Mandelbrot Generator"
     5 set :findLinkedBlocks:n @links
-    * label *label9
     6 jump *label11 lessThanEq :findLinkedBlocks:n 0
     7 label *label111
     8 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
 
    10 print "\nFound: "
    11 print :findLinkedBlocks:block
    12 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * label *label116
    13 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
-    * label *label119
    14 set .display :findLinkedBlocks:variable
-    * label *label122
    15 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
-    * label *label125
    16 set .memory :findLinkedBlocks:variable
-    * label *label14
-    * label *label10
    17 jump *label111 greaterThan :findLinkedBlocks:n 0
    18 label *label11
-    * label *label138
    19 print "\n"
    20 print "Display"
    21 print ":"
    22 print " "
    23 print .display
    24 op and :findLinkedBlocks:foundAll 1 .display
-    * label *label139
-    * label *label140
-    * label *label141
-    * label *label144
    25 print "\n"
    26 print "Memory"
    27 print ":"
    28 print " "
    29 print .memory
    30 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
-    * label *label145
-    * label *label146
-    * label *label147
-    * label *label23
    31 printflush null
-    * label *label2
    32 jump *label1 equal :findLinkedBlocks:foundAll false
-    * label *label3
-    * label *label0
    33 label *label28
    34 label *label31
    35 wait 0
-    * label *label32
    36 read *tmp24 .memory 66
    37 jump *label31 equal .start *tmp24
-    * label *label33
    38 read .start .memory 66
    39 read .stop .memory 67
    40 set .lastColor -1
 
    57 jump *label37 equal .stop *tmp40
    58 jump *label29 always
    59 label *label37
-    * label *label38
    60 read *tmp42 .memory 64
    61 op add *tmp0 *tmp42 1
    62 write *tmp0 .memory 64
    63 jump *label39 lessThan *tmp42 176
    64 jump *label36 always
    65 label *label39
-    * label *label40
    66 multijump *tmp42 0 0 (m:*label152)
    67 multilabel *label156 (m:*label152)
-    * label *label151
    68 op mul *tmp55 2 *tmp42
    69 op sub *tmp46 *tmp55 175
    70 jump *label41 always
    71 multilabel *label153 (m:*label152)
-    * label *label43
    72 op mul *tmp46 8 *tmp42
    73 jump *label41 always
-    * label *label42
    74 multilabel *label154 (m:*label152)
-    * label *label46
    75 op mul *tmp49 8 *tmp42
    76 op sub *tmp46 *tmp49 172
-    * label *label45
    77 jump *label41 always
    78 multilabel *label155 (m:*label152)
-    * label *label49
    79 op mul *tmp52 4 *tmp42
    80 op sub *tmp46 *tmp52 174
    81 label *label41
    82 op mul *tmp58 17 *tmp46
    83 op mod :x *tmp58 176
    84 set :y 0
-    * label *label51
    85 label *label112
    86 op div *tmp61 :x .ZOOM
    87 op add :compute:zx *tmp61 .OFFSET_X
 
   104 set *tmp60 63
   105 jump *label54 always
   106 label *label57
-    * label *label58
   107 op add *tmp74 :compute:zx 1
   108 op len *tmp75 *tmp74 :compute:zy
   109 jump *label59 greaterThan *tmp75 0.25
   110 set *tmp60 63
   111 jump *label54 always
   112 label *label59
-    * label *label60
   113 label *label56
   114 set :compute:i 0
-    * label *label164
   115 set :compute:x1 :compute:zx
   116 op mul *tmp78 :compute:zx :compute:zx
   117 op mul *tmp79 :compute:zy :compute:zy
 
   124 jump *label165 lessThan :compute:dist 64
   125 jump *label63 always
   126 label *label165
-    * label *label166
-    * label *label167
   127 set :compute:i 1
   128 set :compute:x1 :compute:zx
   129 op mul *tmp78 :compute:zx :compute:zx
 
   137 jump *label168 lessThan :compute:dist 64
   138 jump *label63 always
   139 label *label168
-    * label *label169
-    * label *label170
   140 op add :compute:i 1 1
   141 set :compute:x1 :compute:zx
   142 op mul *tmp78 :compute:zx :compute:zx
 
   150 jump *label171 lessThan :compute:dist 64
   151 jump *label63 always
   152 label *label171
-    * label *label172
-    * label *label173
   153 op add :compute:i 2 1
   154 set :compute:x1 :compute:zx
   155 op mul *tmp78 :compute:zx :compute:zx
 
   163 jump *label174 lessThan :compute:dist 64
   164 jump *label63 always
   165 label *label174
-    * label *label175
-    * label *label176
   166 op add :compute:i 3 1
   167 set :compute:x1 :compute:zx
   168 op mul *tmp78 :compute:zx :compute:zx
 
   176 jump *label177 lessThan :compute:dist 64
   177 jump *label63 always
   178 label *label177
-    * label *label178
-    * label *label179
   179 op add :compute:i 4 1
   180 set :compute:x1 :compute:zx
   181 op mul *tmp78 :compute:zx :compute:zx
 
   189 jump *label180 lessThan :compute:dist 64
   190 jump *label63 always
   191 label *label180
-    * label *label181
-    * label *label182
   192 op add :compute:i 5 1
   193 set :compute:x1 :compute:zx
   194 op mul *tmp78 :compute:zx :compute:zx
 
   202 jump *label183 lessThan :compute:dist 64
   203 jump *label63 always
   204 label *label183
-    * label *label184
-    * label *label185
   205 op add :compute:i 6 1
   206 set :compute:x1 :compute:zx
   207 op mul *tmp78 :compute:zx :compute:zx
 
   215 jump *label186 lessThan :compute:dist 64
   216 jump *label63 always
   217 label *label186
-    * label *label187
-    * label *label188
   218 op add :compute:i 7 1
   219 set :compute:x1 :compute:zx
   220 op mul *tmp78 :compute:zx :compute:zx
 
   228 jump *label189 lessThan :compute:dist 64
   229 jump *label63 always
   230 label *label189
-    * label *label190
-    * label *label191
   231 op add :compute:i 8 1
   232 set :compute:x1 :compute:zx
   233 op mul *tmp78 :compute:zx :compute:zx
 
   241 jump *label192 lessThan :compute:dist 64
   242 jump *label63 always
   243 label *label192
-    * label *label193
-    * label *label194
   244 op add :compute:i 9 1
   245 set :compute:x1 :compute:zx
   246 op mul *tmp78 :compute:zx :compute:zx
 
   254 jump *label195 lessThan :compute:dist 64
   255 jump *label63 always
   256 label *label195
-    * label *label196
-    * label *label197
   257 op add :compute:i 10 1
   258 set :compute:x1 :compute:zx
   259 op mul *tmp78 :compute:zx :compute:zx
 
   267 jump *label198 lessThan :compute:dist 64
   268 jump *label63 always
   269 label *label198
-    * label *label199
-    * label *label200
   270 op add :compute:i 11 1
   271 set :compute:x1 :compute:zx
   272 op mul *tmp78 :compute:zx :compute:zx
 
   280 jump *label201 lessThan :compute:dist 64
   281 jump *label63 always
   282 label *label201
-    * label *label202
-    * label *label203
   283 op add :compute:i 12 1
   284 set :compute:x1 :compute:zx
   285 op mul *tmp78 :compute:zx :compute:zx
 
   293 jump *label204 lessThan :compute:dist 64
   294 jump *label63 always
   295 label *label204
-    * label *label205
-    * label *label206
   296 op add :compute:i 13 1
   297 set :compute:x1 :compute:zx
   298 op mul *tmp78 :compute:zx :compute:zx
 
   306 jump *label207 lessThan :compute:dist 64
   307 jump *label63 always
   308 label *label207
-    * label *label208
-    * label *label209
   309 op add :compute:i 14 1
   310 set :compute:x1 :compute:zx
   311 op mul *tmp78 :compute:zx :compute:zx
 
   319 jump *label210 lessThan :compute:dist 64
   320 jump *label63 always
   321 label *label210
-    * label *label211
-    * label *label212
   322 op add :compute:i 15 1
   323 set :compute:x1 :compute:zx
   324 op mul *tmp78 :compute:zx :compute:zx
 
   332 jump *label213 lessThan :compute:dist 64
   333 jump *label63 always
   334 label *label213
-    * label *label214
-    * label *label215
   335 op add :compute:i 16 1
   336 set :compute:x1 :compute:zx
   337 op mul *tmp78 :compute:zx :compute:zx
 
   345 jump *label216 lessThan :compute:dist 64
   346 jump *label63 always
   347 label *label216
-    * label *label217
-    * label *label218
   348 op add :compute:i 17 1
   349 set :compute:x1 :compute:zx
   350 op mul *tmp78 :compute:zx :compute:zx
 
   358 jump *label219 lessThan :compute:dist 64
   359 jump *label63 always
   360 label *label219
-    * label *label220
-    * label *label221
   361 op add :compute:i 18 1
   362 set :compute:x1 :compute:zx
   363 op mul *tmp78 :compute:zx :compute:zx
 
   371 jump *label222 lessThan :compute:dist 64
   372 jump *label63 always
   373 label *label222
-    * label *label223
-    * label *label224
   374 op add :compute:i 19 1
   375 set :compute:x1 :compute:zx
   376 op mul *tmp78 :compute:zx :compute:zx
 
   384 jump *label225 lessThan :compute:dist 64
   385 jump *label63 always
   386 label *label225
-    * label *label226
-    * label *label227
   387 op add :compute:i 20 1
   388 set :compute:x1 :compute:zx
   389 op mul *tmp78 :compute:zx :compute:zx
 
   397 jump *label228 lessThan :compute:dist 64
   398 jump *label63 always
   399 label *label228
-    * label *label229
-    * label *label230
   400 op add :compute:i 21 1
   401 set :compute:x1 :compute:zx
   402 op mul *tmp78 :compute:zx :compute:zx
 
   410 jump *label231 lessThan :compute:dist 64
   411 jump *label63 always
   412 label *label231
-    * label *label232
-    * label *label233
   413 op add :compute:i 22 1
   414 set :compute:x1 :compute:zx
   415 op mul *tmp78 :compute:zx :compute:zx
 
   423 jump *label234 lessThan :compute:dist 64
   424 jump *label63 always
   425 label *label234
-    * label *label235
-    * label *label236
   426 op add :compute:i 23 1
   427 set :compute:x1 :compute:zx
   428 op mul *tmp78 :compute:zx :compute:zx
 
   436 jump *label237 lessThan :compute:dist 64
   437 jump *label63 always
   438 label *label237
-    * label *label238
-    * label *label239
   439 op add :compute:i 24 1
   440 set :compute:x1 :compute:zx
   441 op mul *tmp78 :compute:zx :compute:zx
 
   449 jump *label240 lessThan :compute:dist 64
   450 jump *label63 always
   451 label *label240
-    * label *label241
-    * label *label242
   452 op add :compute:i 25 1
   453 set :compute:x1 :compute:zx
   454 op mul *tmp78 :compute:zx :compute:zx
 
   462 jump *label243 lessThan :compute:dist 64
   463 jump *label63 always
   464 label *label243
-    * label *label244
-    * label *label245
   465 op add :compute:i 26 1
   466 set :compute:x1 :compute:zx
   467 op mul *tmp78 :compute:zx :compute:zx
 
   475 jump *label246 lessThan :compute:dist 64
   476 jump *label63 always
   477 label *label246
-    * label *label247
-    * label *label248
   478 op add :compute:i 27 1
   479 set :compute:x1 :compute:zx
   480 op mul *tmp78 :compute:zx :compute:zx
 
   488 jump *label249 lessThan :compute:dist 64
   489 jump *label63 always
   490 label *label249
-    * label *label250
-    * label *label251
   491 op add :compute:i 28 1
   492 set :compute:x1 :compute:zx
   493 op mul *tmp78 :compute:zx :compute:zx
 
   501 jump *label252 lessThan :compute:dist 64
   502 jump *label63 always
   503 label *label252
-    * label *label253
-    * label *label254
   504 op add :compute:i 29 1
   505 set :compute:x1 :compute:zx
   506 op mul *tmp78 :compute:zx :compute:zx
 
   514 jump *label255 lessThan :compute:dist 64
   515 jump *label63 always
   516 label *label255
-    * label *label256
-    * label *label257
   517 op add :compute:i 30 1
   518 set :compute:x1 :compute:zx
   519 op mul *tmp78 :compute:zx :compute:zx
 
   527 jump *label258 lessThan :compute:dist 64
   528 jump *label63 always
   529 label *label258
-    * label *label259
-    * label *label260
   530 op add :compute:i 31 1
   531 set :compute:x1 :compute:zx
   532 op mul *tmp78 :compute:zx :compute:zx
 
   540 jump *label261 lessThan :compute:dist 64
   541 jump *label63 always
   542 label *label261
-    * label *label262
-    * label *label263
   543 op add :compute:i 32 1
   544 set :compute:x1 :compute:zx
   545 op mul *tmp78 :compute:zx :compute:zx
 
   553 jump *label264 lessThan :compute:dist 64
   554 jump *label63 always
   555 label *label264
-    * label *label265
-    * label *label266
   556 op add :compute:i 33 1
   557 set :compute:x1 :compute:zx
   558 op mul *tmp78 :compute:zx :compute:zx
 
   566 jump *label267 lessThan :compute:dist 64
   567 jump *label63 always
   568 label *label267
-    * label *label268
-    * label *label269
   569 op add :compute:i 34 1
   570 set :compute:x1 :compute:zx
   571 op mul *tmp78 :compute:zx :compute:zx
 
   579 jump *label270 lessThan :compute:dist 64
   580 jump *label63 always
   581 label *label270
-    * label *label271
-    * label *label272
   582 op add :compute:i 35 1
   583 set :compute:x1 :compute:zx
   584 op mul *tmp78 :compute:zx :compute:zx
 
   592 jump *label273 lessThan :compute:dist 64
   593 jump *label63 always
   594 label *label273
-    * label *label274
-    * label *label275
   595 op add :compute:i 36 1
   596 set :compute:x1 :compute:zx
   597 op mul *tmp78 :compute:zx :compute:zx
 
   605 jump *label276 lessThan :compute:dist 64
   606 jump *label63 always
   607 label *label276
-    * label *label277
-    * label *label278
   608 op add :compute:i 37 1
   609 set :compute:x1 :compute:zx
   610 op mul *tmp78 :compute:zx :compute:zx
 
   618 jump *label279 lessThan :compute:dist 64
   619 jump *label63 always
   620 label *label279
-    * label *label280
-    * label *label281
   621 op add :compute:i 38 1
   622 set :compute:x1 :compute:zx
   623 op mul *tmp78 :compute:zx :compute:zx
 
   631 jump *label282 lessThan :compute:dist 64
   632 jump *label63 always
   633 label *label282
-    * label *label283
-    * label *label284
   634 op add :compute:i 39 1
   635 set :compute:x1 :compute:zx
   636 op mul *tmp78 :compute:zx :compute:zx
 
   644 jump *label285 lessThan :compute:dist 64
   645 jump *label63 always
   646 label *label285
-    * label *label286
-    * label *label287
   647 op add :compute:i 40 1
   648 set :compute:x1 :compute:zx
   649 op mul *tmp78 :compute:zx :compute:zx
 
   657 jump *label288 lessThan :compute:dist 64
   658 jump *label63 always
   659 label *label288
-    * label *label289
-    * label *label290
   660 op add :compute:i 41 1
   661 set :compute:x1 :compute:zx
   662 op mul *tmp78 :compute:zx :compute:zx
 
   670 jump *label291 lessThan :compute:dist 64
   671 jump *label63 always
   672 label *label291
-    * label *label292
-    * label *label293
   673 op add :compute:i 42 1
   674 set :compute:x1 :compute:zx
   675 op mul *tmp78 :compute:zx :compute:zx
 
   683 jump *label294 lessThan :compute:dist 64
   684 jump *label63 always
   685 label *label294
-    * label *label295
-    * label *label296
   686 op add :compute:i 43 1
   687 set :compute:x1 :compute:zx
   688 op mul *tmp78 :compute:zx :compute:zx
 
   696 jump *label297 lessThan :compute:dist 64
   697 jump *label63 always
   698 label *label297
-    * label *label298
-    * label *label299
   699 op add :compute:i 44 1
   700 set :compute:x1 :compute:zx
   701 op mul *tmp78 :compute:zx :compute:zx
 
   709 jump *label300 lessThan :compute:dist 64
   710 jump *label63 always
   711 label *label300
-    * label *label301
-    * label *label302
   712 op add :compute:i 45 1
   713 set :compute:x1 :compute:zx
   714 op mul *tmp78 :compute:zx :compute:zx
 
   722 jump *label303 lessThan :compute:dist 64
   723 jump *label63 always
   724 label *label303
-    * label *label304
-    * label *label305
   725 op add :compute:i 46 1
   726 set :compute:x1 :compute:zx
   727 op mul *tmp78 :compute:zx :compute:zx
 
   735 jump *label306 lessThan :compute:dist 64
   736 jump *label63 always
   737 label *label306
-    * label *label307
-    * label *label308
   738 op add :compute:i 47 1
   739 set :compute:x1 :compute:zx
   740 op mul *tmp78 :compute:zx :compute:zx
 
   748 jump *label309 lessThan :compute:dist 64
   749 jump *label63 always
   750 label *label309
-    * label *label310
-    * label *label311
   751 op add :compute:i 48 1
   752 set :compute:x1 :compute:zx
   753 op mul *tmp78 :compute:zx :compute:zx
 
   761 jump *label312 lessThan :compute:dist 64
   762 jump *label63 always
   763 label *label312
-    * label *label313
-    * label *label314
   764 op add :compute:i 49 1
   765 set :compute:x1 :compute:zx
   766 op mul *tmp78 :compute:zx :compute:zx
 
   774 jump *label315 lessThan :compute:dist 64
   775 jump *label63 always
   776 label *label315
-    * label *label316
-    * label *label317
   777 op add :compute:i 50 1
   778 set :compute:x1 :compute:zx
   779 op mul *tmp78 :compute:zx :compute:zx
 
   787 jump *label318 lessThan :compute:dist 64
   788 jump *label63 always
   789 label *label318
-    * label *label319
-    * label *label320
   790 op add :compute:i 51 1
   791 set :compute:x1 :compute:zx
   792 op mul *tmp78 :compute:zx :compute:zx
 
   800 jump *label321 lessThan :compute:dist 64
   801 jump *label63 always
   802 label *label321
-    * label *label322
-    * label *label323
   803 op add :compute:i 52 1
   804 set :compute:x1 :compute:zx
   805 op mul *tmp78 :compute:zx :compute:zx
 
   813 jump *label324 lessThan :compute:dist 64
   814 jump *label63 always
   815 label *label324
-    * label *label325
-    * label *label326
   816 op add :compute:i 53 1
   817 set :compute:x1 :compute:zx
   818 op mul *tmp78 :compute:zx :compute:zx
 
   826 jump *label327 lessThan :compute:dist 64
   827 jump *label63 always
   828 label *label327
-    * label *label328
-    * label *label329
   829 op add :compute:i 54 1
   830 set :compute:x1 :compute:zx
   831 op mul *tmp78 :compute:zx :compute:zx
 
   839 jump *label330 lessThan :compute:dist 64
   840 jump *label63 always
   841 label *label330
-    * label *label331
-    * label *label332
   842 op add :compute:i 55 1
   843 set :compute:x1 :compute:zx
   844 op mul *tmp78 :compute:zx :compute:zx
 
   852 jump *label333 lessThan :compute:dist 64
   853 jump *label63 always
   854 label *label333
-    * label *label334
-    * label *label335
   855 op add :compute:i 56 1
   856 set :compute:x1 :compute:zx
   857 op mul *tmp78 :compute:zx :compute:zx
 
   865 jump *label336 lessThan :compute:dist 64
   866 jump *label63 always
   867 label *label336
-    * label *label337
-    * label *label338
   868 op add :compute:i 57 1
   869 set :compute:x1 :compute:zx
   870 op mul *tmp78 :compute:zx :compute:zx
 
   878 jump *label339 lessThan :compute:dist 64
   879 jump *label63 always
   880 label *label339
-    * label *label340
-    * label *label341
   881 op add :compute:i 58 1
   882 set :compute:x1 :compute:zx
   883 op mul *tmp78 :compute:zx :compute:zx
 
   891 jump *label342 lessThan :compute:dist 64
   892 jump *label63 always
   893 label *label342
-    * label *label343
-    * label *label344
   894 op add :compute:i 59 1
   895 set :compute:x1 :compute:zx
   896 op mul *tmp78 :compute:zx :compute:zx
 
   904 jump *label345 lessThan :compute:dist 64
   905 jump *label63 always
   906 label *label345
-    * label *label346
-    * label *label347
   907 op add :compute:i 60 1
   908 set :compute:x1 :compute:zx
   909 op mul *tmp78 :compute:zx :compute:zx
 
   917 jump *label348 lessThan :compute:dist 64
   918 jump *label63 always
   919 label *label348
-    * label *label349
-    * label *label350
   920 op add :compute:i 61 1
   921 set :compute:x1 :compute:zx
   922 op mul *tmp78 :compute:zx :compute:zx
 
   930 jump *label351 lessThan :compute:dist 64
   931 jump *label63 always
   932 label *label351
-    * label *label352
-    * label *label353
   933 op add :compute:i 62 1
   934 label *label63
   935 op mul *tmp88 .SMOOTH 63
 
   941 op sub :compute:correction 4 *tmp94
   942 op add :compute:i :compute:i :compute:correction
   943 label *label66
-    * label *label67
   944 set *tmp60 :compute:i
   945 label *label54
   946 jump *label69 lessThanEq .PALETTE 1
   947 set :drawPixel:color %[black]
   948 jump *label72 equal *tmp60 63
-    * label *label71
   949 multijump .PALETTE 0 0 (m:*label158)
   950 multilabel *label163 (m:*label158)
   951 multilabel *label159 (m:*label158)
-    * label *label157
   952 op div *tmp136 *tmp60 63.75
   953 op sub :drawPixel:r 1 *tmp136
   954 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   955 jump *label73 always
   956 multilabel *label160 (m:*label158)
-    * label *label75
   957 op sub *tmp101 32 *tmp60
   958 op abs *tmp102 *tmp101
   959 op div *tmp104 *tmp102 36.42857142857143
 
   966 op add :drawPixel:b 0.47058823529411764 *tmp114
   967 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   968 jump *label73 always
-    * label *label74
   969 multilabel *label161 (m:*label158)
-    * label *label77
   970 op div *tmp118 *tmp60 0.175
   971 op sin :drawPixel:r *tmp118
   972 op cos :drawPixel:g *tmp118
 
   976 op add :drawPixel:b 0.39215686274509803 *tmp126
   977 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   978 jump *label73 always
-    * label *label76
   979 multilabel *label162 (m:*label158)
-    * label *label79
   980 op div :drawPixel:r *tmp60 63.75
   981 op div *tmp132 *tmp60 170
   982 op add :drawPixel:g 96 *tmp132
 
   988 read :drawPixel:color .memory *tmp60
   989 label *label70
   990 jump *label80 lessThan .localBuffer 254
-    * label *label83
   991 jump *label85 lessThanEq .localBuffer 0
   992 label *label114
   993 wait 0
 
   999 drawflush .display
  1000 set .localBuffer 0
  1001 label *label89
-    * label *label90
  1002 label *label87
-    * label *label88
-    * label *label86
-    * label *label84
  1003 jump *label114 greaterThan .localBuffer 0
  1004 label *label85
-    * label *label82
  1005 label *label80
-    * label *label81
  1006 jump *label91 lessThanEq .localBuffer 0
  1007 jump *label91 strictNotEqual :drawPixel:color .lastColor
  1008 draw rect :x :y 1 1
 
  1023 drawflush .display
  1024 set .localBuffer 0
  1025 label *label98
-    * label *label99
  1026 label *label96
-    * label *label97
-    * label *label95
-    * label *label68
  1027 wait 0
  1028 read *tmp161 .memory 65
  1029 op add *tmp1 *tmp161 1
 
  1032 jump *label100 equal .stop *tmp164
  1033 jump *label29 always
  1034 label *label100
-    * label *label101
-    * label *label52
  1035 op add :y :y 1
  1036 jump *label112 lessThan :y 176
-    * label *label53
-    * label *label103
  1037 jump *label105 lessThanEq .localBuffer 0
  1038 label *label115
  1039 wait 0
 
  1045 drawflush .display
  1046 set .localBuffer 0
  1047 label *label109
-    * label *label110
  1048 label *label107
-    * label *label108
-    * label *label106
-    * label *label104
  1049 jump *label115 greaterThan .localBuffer 0
  1050 label *label105
-    * label *label102
-    * label *label35
  1051 jump *label34 always
  1052 label *label36
  1053 label *label29
  1054 jump *label28 always
-    * label *label30
-    * end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-66 instructions):
 
    54 label *label34
    55 wait 0
    56 read *tmp40 .memory 67
-    * jump *label37 equal .stop *tmp40
-    * jump *label29 always
+   57 jump *label29 notEqual .stop *tmp40
    58 label *label37
    59 read *tmp42 .memory 64
    60 op add *tmp0 *tmp42 1
    61 write *tmp0 .memory 64
-    * jump *label39 lessThan *tmp42 176
-    * jump *label36 always
+   62 jump *label36 greaterThanEq *tmp42 176
    63 label *label39
    64 multijump *tmp42 0 0 (m:*label152)
    65 multilabel *label156 (m:*label152)
 
   119 op mul *tmp83 *tmp82 :compute:zy
   120 op add :compute:zy *tmp83 :compute:cy
   121 op len :compute:dist :compute:zx :compute:zy
-    * jump *label165 lessThan :compute:dist 64
-    * jump *label63 always
+  122 jump *label63 greaterThanEq :compute:dist 64
   123 label *label165
   124 set :compute:i 1
   125 set :compute:x1 :compute:zx
 
   131 op mul *tmp83 *tmp82 :compute:zy
   132 op add :compute:zy *tmp83 :compute:cy
   133 op len :compute:dist :compute:zx :compute:zy
-    * jump *label168 lessThan :compute:dist 64
-    * jump *label63 always
+  134 jump *label63 greaterThanEq :compute:dist 64
   135 label *label168
   136 op add :compute:i 1 1
   137 set :compute:x1 :compute:zx
 
   143 op mul *tmp83 *tmp82 :compute:zy
   144 op add :compute:zy *tmp83 :compute:cy
   145 op len :compute:dist :compute:zx :compute:zy
-    * jump *label171 lessThan :compute:dist 64
-    * jump *label63 always
+  146 jump *label63 greaterThanEq :compute:dist 64
   147 label *label171
   148 op add :compute:i 2 1
   149 set :compute:x1 :compute:zx
 
   155 op mul *tmp83 *tmp82 :compute:zy
   156 op add :compute:zy *tmp83 :compute:cy
   157 op len :compute:dist :compute:zx :compute:zy
-    * jump *label174 lessThan :compute:dist 64
-    * jump *label63 always
+  158 jump *label63 greaterThanEq :compute:dist 64
   159 label *label174
   160 op add :compute:i 3 1
   161 set :compute:x1 :compute:zx
 
   167 op mul *tmp83 *tmp82 :compute:zy
   168 op add :compute:zy *tmp83 :compute:cy
   169 op len :compute:dist :compute:zx :compute:zy
-    * jump *label177 lessThan :compute:dist 64
-    * jump *label63 always
+  170 jump *label63 greaterThanEq :compute:dist 64
   171 label *label177
   172 op add :compute:i 4 1
   173 set :compute:x1 :compute:zx
 
   179 op mul *tmp83 *tmp82 :compute:zy
   180 op add :compute:zy *tmp83 :compute:cy
   181 op len :compute:dist :compute:zx :compute:zy
-    * jump *label180 lessThan :compute:dist 64
-    * jump *label63 always
+  182 jump *label63 greaterThanEq :compute:dist 64
   183 label *label180
   184 op add :compute:i 5 1
   185 set :compute:x1 :compute:zx
 
   191 op mul *tmp83 *tmp82 :compute:zy
   192 op add :compute:zy *tmp83 :compute:cy
   193 op len :compute:dist :compute:zx :compute:zy
-    * jump *label183 lessThan :compute:dist 64
-    * jump *label63 always
+  194 jump *label63 greaterThanEq :compute:dist 64
   195 label *label183
   196 op add :compute:i 6 1
   197 set :compute:x1 :compute:zx
 
   203 op mul *tmp83 *tmp82 :compute:zy
   204 op add :compute:zy *tmp83 :compute:cy
   205 op len :compute:dist :compute:zx :compute:zy
-    * jump *label186 lessThan :compute:dist 64
-    * jump *label63 always
+  206 jump *label63 greaterThanEq :compute:dist 64
   207 label *label186
   208 op add :compute:i 7 1
   209 set :compute:x1 :compute:zx
 
   215 op mul *tmp83 *tmp82 :compute:zy
   216 op add :compute:zy *tmp83 :compute:cy
   217 op len :compute:dist :compute:zx :compute:zy
-    * jump *label189 lessThan :compute:dist 64
-    * jump *label63 always
+  218 jump *label63 greaterThanEq :compute:dist 64
   219 label *label189
   220 op add :compute:i 8 1
   221 set :compute:x1 :compute:zx
 
   227 op mul *tmp83 *tmp82 :compute:zy
   228 op add :compute:zy *tmp83 :compute:cy
   229 op len :compute:dist :compute:zx :compute:zy
-    * jump *label192 lessThan :compute:dist 64
-    * jump *label63 always
+  230 jump *label63 greaterThanEq :compute:dist 64
   231 label *label192
   232 op add :compute:i 9 1
   233 set :compute:x1 :compute:zx
 
   239 op mul *tmp83 *tmp82 :compute:zy
   240 op add :compute:zy *tmp83 :compute:cy
   241 op len :compute:dist :compute:zx :compute:zy
-    * jump *label195 lessThan :compute:dist 64
-    * jump *label63 always
+  242 jump *label63 greaterThanEq :compute:dist 64
   243 label *label195
   244 op add :compute:i 10 1
   245 set :compute:x1 :compute:zx
 
   251 op mul *tmp83 *tmp82 :compute:zy
   252 op add :compute:zy *tmp83 :compute:cy
   253 op len :compute:dist :compute:zx :compute:zy
-    * jump *label198 lessThan :compute:dist 64
-    * jump *label63 always
+  254 jump *label63 greaterThanEq :compute:dist 64
   255 label *label198
   256 op add :compute:i 11 1
   257 set :compute:x1 :compute:zx
 
   263 op mul *tmp83 *tmp82 :compute:zy
   264 op add :compute:zy *tmp83 :compute:cy
   265 op len :compute:dist :compute:zx :compute:zy
-    * jump *label201 lessThan :compute:dist 64
-    * jump *label63 always
+  266 jump *label63 greaterThanEq :compute:dist 64
   267 label *label201
   268 op add :compute:i 12 1
   269 set :compute:x1 :compute:zx
 
   275 op mul *tmp83 *tmp82 :compute:zy
   276 op add :compute:zy *tmp83 :compute:cy
   277 op len :compute:dist :compute:zx :compute:zy
-    * jump *label204 lessThan :compute:dist 64
-    * jump *label63 always
+  278 jump *label63 greaterThanEq :compute:dist 64
   279 label *label204
   280 op add :compute:i 13 1
   281 set :compute:x1 :compute:zx
 
   287 op mul *tmp83 *tmp82 :compute:zy
   288 op add :compute:zy *tmp83 :compute:cy
   289 op len :compute:dist :compute:zx :compute:zy
-    * jump *label207 lessThan :compute:dist 64
-    * jump *label63 always
+  290 jump *label63 greaterThanEq :compute:dist 64
   291 label *label207
   292 op add :compute:i 14 1
   293 set :compute:x1 :compute:zx
 
   299 op mul *tmp83 *tmp82 :compute:zy
   300 op add :compute:zy *tmp83 :compute:cy
   301 op len :compute:dist :compute:zx :compute:zy
-    * jump *label210 lessThan :compute:dist 64
-    * jump *label63 always
+  302 jump *label63 greaterThanEq :compute:dist 64
   303 label *label210
   304 op add :compute:i 15 1
   305 set :compute:x1 :compute:zx
 
   311 op mul *tmp83 *tmp82 :compute:zy
   312 op add :compute:zy *tmp83 :compute:cy
   313 op len :compute:dist :compute:zx :compute:zy
-    * jump *label213 lessThan :compute:dist 64
-    * jump *label63 always
+  314 jump *label63 greaterThanEq :compute:dist 64
   315 label *label213
   316 op add :compute:i 16 1
   317 set :compute:x1 :compute:zx
 
   323 op mul *tmp83 *tmp82 :compute:zy
   324 op add :compute:zy *tmp83 :compute:cy
   325 op len :compute:dist :compute:zx :compute:zy
-    * jump *label216 lessThan :compute:dist 64
-    * jump *label63 always
+  326 jump *label63 greaterThanEq :compute:dist 64
   327 label *label216
   328 op add :compute:i 17 1
   329 set :compute:x1 :compute:zx
 
   335 op mul *tmp83 *tmp82 :compute:zy
   336 op add :compute:zy *tmp83 :compute:cy
   337 op len :compute:dist :compute:zx :compute:zy
-    * jump *label219 lessThan :compute:dist 64
-    * jump *label63 always
+  338 jump *label63 greaterThanEq :compute:dist 64
   339 label *label219
   340 op add :compute:i 18 1
   341 set :compute:x1 :compute:zx
 
   347 op mul *tmp83 *tmp82 :compute:zy
   348 op add :compute:zy *tmp83 :compute:cy
   349 op len :compute:dist :compute:zx :compute:zy
-    * jump *label222 lessThan :compute:dist 64
-    * jump *label63 always
+  350 jump *label63 greaterThanEq :compute:dist 64
   351 label *label222
   352 op add :compute:i 19 1
   353 set :compute:x1 :compute:zx
 
   359 op mul *tmp83 *tmp82 :compute:zy
   360 op add :compute:zy *tmp83 :compute:cy
   361 op len :compute:dist :compute:zx :compute:zy
-    * jump *label225 lessThan :compute:dist 64
-    * jump *label63 always
+  362 jump *label63 greaterThanEq :compute:dist 64
   363 label *label225
   364 op add :compute:i 20 1
   365 set :compute:x1 :compute:zx
 
   371 op mul *tmp83 *tmp82 :compute:zy
   372 op add :compute:zy *tmp83 :compute:cy
   373 op len :compute:dist :compute:zx :compute:zy
-    * jump *label228 lessThan :compute:dist 64
-    * jump *label63 always
+  374 jump *label63 greaterThanEq :compute:dist 64
   375 label *label228
   376 op add :compute:i 21 1
   377 set :compute:x1 :compute:zx
 
   383 op mul *tmp83 *tmp82 :compute:zy
   384 op add :compute:zy *tmp83 :compute:cy
   385 op len :compute:dist :compute:zx :compute:zy
-    * jump *label231 lessThan :compute:dist 64
-    * jump *label63 always
+  386 jump *label63 greaterThanEq :compute:dist 64
   387 label *label231
   388 op add :compute:i 22 1
   389 set :compute:x1 :compute:zx
 
   395 op mul *tmp83 *tmp82 :compute:zy
   396 op add :compute:zy *tmp83 :compute:cy
   397 op len :compute:dist :compute:zx :compute:zy
-    * jump *label234 lessThan :compute:dist 64
-    * jump *label63 always
+  398 jump *label63 greaterThanEq :compute:dist 64
   399 label *label234
   400 op add :compute:i 23 1
   401 set :compute:x1 :compute:zx
 
   407 op mul *tmp83 *tmp82 :compute:zy
   408 op add :compute:zy *tmp83 :compute:cy
   409 op len :compute:dist :compute:zx :compute:zy
-    * jump *label237 lessThan :compute:dist 64
-    * jump *label63 always
+  410 jump *label63 greaterThanEq :compute:dist 64
   411 label *label237
   412 op add :compute:i 24 1
   413 set :compute:x1 :compute:zx
 
   419 op mul *tmp83 *tmp82 :compute:zy
   420 op add :compute:zy *tmp83 :compute:cy
   421 op len :compute:dist :compute:zx :compute:zy
-    * jump *label240 lessThan :compute:dist 64
-    * jump *label63 always
+  422 jump *label63 greaterThanEq :compute:dist 64
   423 label *label240
   424 op add :compute:i 25 1
   425 set :compute:x1 :compute:zx
 
   431 op mul *tmp83 *tmp82 :compute:zy
   432 op add :compute:zy *tmp83 :compute:cy
   433 op len :compute:dist :compute:zx :compute:zy
-    * jump *label243 lessThan :compute:dist 64
-    * jump *label63 always
+  434 jump *label63 greaterThanEq :compute:dist 64
   435 label *label243
   436 op add :compute:i 26 1
   437 set :compute:x1 :compute:zx
 
   443 op mul *tmp83 *tmp82 :compute:zy
   444 op add :compute:zy *tmp83 :compute:cy
   445 op len :compute:dist :compute:zx :compute:zy
-    * jump *label246 lessThan :compute:dist 64
-    * jump *label63 always
+  446 jump *label63 greaterThanEq :compute:dist 64
   447 label *label246
   448 op add :compute:i 27 1
   449 set :compute:x1 :compute:zx
 
   455 op mul *tmp83 *tmp82 :compute:zy
   456 op add :compute:zy *tmp83 :compute:cy
   457 op len :compute:dist :compute:zx :compute:zy
-    * jump *label249 lessThan :compute:dist 64
-    * jump *label63 always
+  458 jump *label63 greaterThanEq :compute:dist 64
   459 label *label249
   460 op add :compute:i 28 1
   461 set :compute:x1 :compute:zx
 
   467 op mul *tmp83 *tmp82 :compute:zy
   468 op add :compute:zy *tmp83 :compute:cy
   469 op len :compute:dist :compute:zx :compute:zy
-    * jump *label252 lessThan :compute:dist 64
-    * jump *label63 always
+  470 jump *label63 greaterThanEq :compute:dist 64
   471 label *label252
   472 op add :compute:i 29 1
   473 set :compute:x1 :compute:zx
 
   479 op mul *tmp83 *tmp82 :compute:zy
   480 op add :compute:zy *tmp83 :compute:cy
   481 op len :compute:dist :compute:zx :compute:zy
-    * jump *label255 lessThan :compute:dist 64
-    * jump *label63 always
+  482 jump *label63 greaterThanEq :compute:dist 64
   483 label *label255
   484 op add :compute:i 30 1
   485 set :compute:x1 :compute:zx
 
   491 op mul *tmp83 *tmp82 :compute:zy
   492 op add :compute:zy *tmp83 :compute:cy
   493 op len :compute:dist :compute:zx :compute:zy
-    * jump *label258 lessThan :compute:dist 64
-    * jump *label63 always
+  494 jump *label63 greaterThanEq :compute:dist 64
   495 label *label258
   496 op add :compute:i 31 1
   497 set :compute:x1 :compute:zx
 
   503 op mul *tmp83 *tmp82 :compute:zy
   504 op add :compute:zy *tmp83 :compute:cy
   505 op len :compute:dist :compute:zx :compute:zy
-    * jump *label261 lessThan :compute:dist 64
-    * jump *label63 always
+  506 jump *label63 greaterThanEq :compute:dist 64
   507 label *label261
   508 op add :compute:i 32 1
   509 set :compute:x1 :compute:zx
 
   515 op mul *tmp83 *tmp82 :compute:zy
   516 op add :compute:zy *tmp83 :compute:cy
   517 op len :compute:dist :compute:zx :compute:zy
-    * jump *label264 lessThan :compute:dist 64
-    * jump *label63 always
+  518 jump *label63 greaterThanEq :compute:dist 64
   519 label *label264
   520 op add :compute:i 33 1
   521 set :compute:x1 :compute:zx
 
   527 op mul *tmp83 *tmp82 :compute:zy
   528 op add :compute:zy *tmp83 :compute:cy
   529 op len :compute:dist :compute:zx :compute:zy
-    * jump *label267 lessThan :compute:dist 64
-    * jump *label63 always
+  530 jump *label63 greaterThanEq :compute:dist 64
   531 label *label267
   532 op add :compute:i 34 1
   533 set :compute:x1 :compute:zx
 
   539 op mul *tmp83 *tmp82 :compute:zy
   540 op add :compute:zy *tmp83 :compute:cy
   541 op len :compute:dist :compute:zx :compute:zy
-    * jump *label270 lessThan :compute:dist 64
-    * jump *label63 always
+  542 jump *label63 greaterThanEq :compute:dist 64
   543 label *label270
   544 op add :compute:i 35 1
   545 set :compute:x1 :compute:zx
 
   551 op mul *tmp83 *tmp82 :compute:zy
   552 op add :compute:zy *tmp83 :compute:cy
   553 op len :compute:dist :compute:zx :compute:zy
-    * jump *label273 lessThan :compute:dist 64
-    * jump *label63 always
+  554 jump *label63 greaterThanEq :compute:dist 64
   555 label *label273
   556 op add :compute:i 36 1
   557 set :compute:x1 :compute:zx
 
   563 op mul *tmp83 *tmp82 :compute:zy
   564 op add :compute:zy *tmp83 :compute:cy
   565 op len :compute:dist :compute:zx :compute:zy
-    * jump *label276 lessThan :compute:dist 64
-    * jump *label63 always
+  566 jump *label63 greaterThanEq :compute:dist 64
   567 label *label276
   568 op add :compute:i 37 1
   569 set :compute:x1 :compute:zx
 
   575 op mul *tmp83 *tmp82 :compute:zy
   576 op add :compute:zy *tmp83 :compute:cy
   577 op len :compute:dist :compute:zx :compute:zy
-    * jump *label279 lessThan :compute:dist 64
-    * jump *label63 always
+  578 jump *label63 greaterThanEq :compute:dist 64
   579 label *label279
   580 op add :compute:i 38 1
   581 set :compute:x1 :compute:zx
 
   587 op mul *tmp83 *tmp82 :compute:zy
   588 op add :compute:zy *tmp83 :compute:cy
   589 op len :compute:dist :compute:zx :compute:zy
-    * jump *label282 lessThan :compute:dist 64
-    * jump *label63 always
+  590 jump *label63 greaterThanEq :compute:dist 64
   591 label *label282
   592 op add :compute:i 39 1
   593 set :compute:x1 :compute:zx
 
   599 op mul *tmp83 *tmp82 :compute:zy
   600 op add :compute:zy *tmp83 :compute:cy
   601 op len :compute:dist :compute:zx :compute:zy
-    * jump *label285 lessThan :compute:dist 64
-    * jump *label63 always
+  602 jump *label63 greaterThanEq :compute:dist 64
   603 label *label285
   604 op add :compute:i 40 1
   605 set :compute:x1 :compute:zx
 
   611 op mul *tmp83 *tmp82 :compute:zy
   612 op add :compute:zy *tmp83 :compute:cy
   613 op len :compute:dist :compute:zx :compute:zy
-    * jump *label288 lessThan :compute:dist 64
-    * jump *label63 always
+  614 jump *label63 greaterThanEq :compute:dist 64
   615 label *label288
   616 op add :compute:i 41 1
   617 set :compute:x1 :compute:zx
 
   623 op mul *tmp83 *tmp82 :compute:zy
   624 op add :compute:zy *tmp83 :compute:cy
   625 op len :compute:dist :compute:zx :compute:zy
-    * jump *label291 lessThan :compute:dist 64
-    * jump *label63 always
+  626 jump *label63 greaterThanEq :compute:dist 64
   627 label *label291
   628 op add :compute:i 42 1
   629 set :compute:x1 :compute:zx
 
   635 op mul *tmp83 *tmp82 :compute:zy
   636 op add :compute:zy *tmp83 :compute:cy
   637 op len :compute:dist :compute:zx :compute:zy
-    * jump *label294 lessThan :compute:dist 64
-    * jump *label63 always
+  638 jump *label63 greaterThanEq :compute:dist 64
   639 label *label294
   640 op add :compute:i 43 1
   641 set :compute:x1 :compute:zx
 
   647 op mul *tmp83 *tmp82 :compute:zy
   648 op add :compute:zy *tmp83 :compute:cy
   649 op len :compute:dist :compute:zx :compute:zy
-    * jump *label297 lessThan :compute:dist 64
-    * jump *label63 always
+  650 jump *label63 greaterThanEq :compute:dist 64
   651 label *label297
   652 op add :compute:i 44 1
   653 set :compute:x1 :compute:zx
 
   659 op mul *tmp83 *tmp82 :compute:zy
   660 op add :compute:zy *tmp83 :compute:cy
   661 op len :compute:dist :compute:zx :compute:zy
-    * jump *label300 lessThan :compute:dist 64
-    * jump *label63 always
+  662 jump *label63 greaterThanEq :compute:dist 64
   663 label *label300
   664 op add :compute:i 45 1
   665 set :compute:x1 :compute:zx
 
   671 op mul *tmp83 *tmp82 :compute:zy
   672 op add :compute:zy *tmp83 :compute:cy
   673 op len :compute:dist :compute:zx :compute:zy
-    * jump *label303 lessThan :compute:dist 64
-    * jump *label63 always
+  674 jump *label63 greaterThanEq :compute:dist 64
   675 label *label303
   676 op add :compute:i 46 1
   677 set :compute:x1 :compute:zx
 
   683 op mul *tmp83 *tmp82 :compute:zy
   684 op add :compute:zy *tmp83 :compute:cy
   685 op len :compute:dist :compute:zx :compute:zy
-    * jump *label306 lessThan :compute:dist 64
-    * jump *label63 always
+  686 jump *label63 greaterThanEq :compute:dist 64
   687 label *label306
   688 op add :compute:i 47 1
   689 set :compute:x1 :compute:zx
 
   695 op mul *tmp83 *tmp82 :compute:zy
   696 op add :compute:zy *tmp83 :compute:cy
   697 op len :compute:dist :compute:zx :compute:zy
-    * jump *label309 lessThan :compute:dist 64
-    * jump *label63 always
+  698 jump *label63 greaterThanEq :compute:dist 64
   699 label *label309
   700 op add :compute:i 48 1
   701 set :compute:x1 :compute:zx
 
   707 op mul *tmp83 *tmp82 :compute:zy
   708 op add :compute:zy *tmp83 :compute:cy
   709 op len :compute:dist :compute:zx :compute:zy
-    * jump *label312 lessThan :compute:dist 64
-    * jump *label63 always
+  710 jump *label63 greaterThanEq :compute:dist 64
   711 label *label312
   712 op add :compute:i 49 1
   713 set :compute:x1 :compute:zx
 
   719 op mul *tmp83 *tmp82 :compute:zy
   720 op add :compute:zy *tmp83 :compute:cy
   721 op len :compute:dist :compute:zx :compute:zy
-    * jump *label315 lessThan :compute:dist 64
-    * jump *label63 always
+  722 jump *label63 greaterThanEq :compute:dist 64
   723 label *label315
   724 op add :compute:i 50 1
   725 set :compute:x1 :compute:zx
 
   731 op mul *tmp83 *tmp82 :compute:zy
   732 op add :compute:zy *tmp83 :compute:cy
   733 op len :compute:dist :compute:zx :compute:zy
-    * jump *label318 lessThan :compute:dist 64
-    * jump *label63 always
+  734 jump *label63 greaterThanEq :compute:dist 64
   735 label *label318
   736 op add :compute:i 51 1
   737 set :compute:x1 :compute:zx
 
   743 op mul *tmp83 *tmp82 :compute:zy
   744 op add :compute:zy *tmp83 :compute:cy
   745 op len :compute:dist :compute:zx :compute:zy
-    * jump *label321 lessThan :compute:dist 64
-    * jump *label63 always
+  746 jump *label63 greaterThanEq :compute:dist 64
   747 label *label321
   748 op add :compute:i 52 1
   749 set :compute:x1 :compute:zx
 
   755 op mul *tmp83 *tmp82 :compute:zy
   756 op add :compute:zy *tmp83 :compute:cy
   757 op len :compute:dist :compute:zx :compute:zy
-    * jump *label324 lessThan :compute:dist 64
-    * jump *label63 always
+  758 jump *label63 greaterThanEq :compute:dist 64
   759 label *label324
   760 op add :compute:i 53 1
   761 set :compute:x1 :compute:zx
 
   767 op mul *tmp83 *tmp82 :compute:zy
   768 op add :compute:zy *tmp83 :compute:cy
   769 op len :compute:dist :compute:zx :compute:zy
-    * jump *label327 lessThan :compute:dist 64
-    * jump *label63 always
+  770 jump *label63 greaterThanEq :compute:dist 64
   771 label *label327
   772 op add :compute:i 54 1
   773 set :compute:x1 :compute:zx
 
   779 op mul *tmp83 *tmp82 :compute:zy
   780 op add :compute:zy *tmp83 :compute:cy
   781 op len :compute:dist :compute:zx :compute:zy
-    * jump *label330 lessThan :compute:dist 64
-    * jump *label63 always
+  782 jump *label63 greaterThanEq :compute:dist 64
   783 label *label330
   784 op add :compute:i 55 1
   785 set :compute:x1 :compute:zx
 
   791 op mul *tmp83 *tmp82 :compute:zy
   792 op add :compute:zy *tmp83 :compute:cy
   793 op len :compute:dist :compute:zx :compute:zy
-    * jump *label333 lessThan :compute:dist 64
-    * jump *label63 always
+  794 jump *label63 greaterThanEq :compute:dist 64
   795 label *label333
   796 op add :compute:i 56 1
   797 set :compute:x1 :compute:zx
 
   803 op mul *tmp83 *tmp82 :compute:zy
   804 op add :compute:zy *tmp83 :compute:cy
   805 op len :compute:dist :compute:zx :compute:zy
-    * jump *label336 lessThan :compute:dist 64
-    * jump *label63 always
+  806 jump *label63 greaterThanEq :compute:dist 64
   807 label *label336
   808 op add :compute:i 57 1
   809 set :compute:x1 :compute:zx
 
   815 op mul *tmp83 *tmp82 :compute:zy
   816 op add :compute:zy *tmp83 :compute:cy
   817 op len :compute:dist :compute:zx :compute:zy
-    * jump *label339 lessThan :compute:dist 64
-    * jump *label63 always
+  818 jump *label63 greaterThanEq :compute:dist 64
   819 label *label339
   820 op add :compute:i 58 1
   821 set :compute:x1 :compute:zx
 
   827 op mul *tmp83 *tmp82 :compute:zy
   828 op add :compute:zy *tmp83 :compute:cy
   829 op len :compute:dist :compute:zx :compute:zy
-    * jump *label342 lessThan :compute:dist 64
-    * jump *label63 always
+  830 jump *label63 greaterThanEq :compute:dist 64
   831 label *label342
   832 op add :compute:i 59 1
   833 set :compute:x1 :compute:zx
 
   839 op mul *tmp83 *tmp82 :compute:zy
   840 op add :compute:zy *tmp83 :compute:cy
   841 op len :compute:dist :compute:zx :compute:zy
-    * jump *label345 lessThan :compute:dist 64
-    * jump *label63 always
+  842 jump *label63 greaterThanEq :compute:dist 64
   843 label *label345
   844 op add :compute:i 60 1
   845 set :compute:x1 :compute:zx
 
   851 op mul *tmp83 *tmp82 :compute:zy
   852 op add :compute:zy *tmp83 :compute:cy
   853 op len :compute:dist :compute:zx :compute:zy
-    * jump *label348 lessThan :compute:dist 64
-    * jump *label63 always
+  854 jump *label63 greaterThanEq :compute:dist 64
   855 label *label348
   856 op add :compute:i 61 1
   857 set :compute:x1 :compute:zx
 
   863 op mul *tmp83 *tmp82 :compute:zy
   864 op add :compute:zy *tmp83 :compute:cy
   865 op len :compute:dist :compute:zx :compute:zy
-    * jump *label351 lessThan :compute:dist 64
-    * jump *label63 always
+  866 jump *label63 greaterThanEq :compute:dist 64
   867 label *label351
   868 op add :compute:i 62 1
   869 label *label63
 
   964 op add *tmp1 *tmp161 1
   965 write *tmp1 .memory 65
   966 read *tmp164 .memory 67
-    * jump *label100 equal .stop *tmp164
-    * jump *label29 always
+  967 jump *label29 notEqual .stop *tmp164
   968 label *label100
   969 op add :y :y 1
   970 jump *label112 lessThan :y 176

Modifications by Jumps phase, Jump Threading, pass 6, iteration 1:
 
    54 label *label34
    55 wait 0
    56 read *tmp40 .memory 67
-    * jump *label29 notEqual .stop *tmp40
+   57 jump *label28 notEqual .stop *tmp40
    58 read *tmp42 .memory 64
    59 op add *tmp0 *tmp42 1
    60 write *tmp0 .memory 64
-    * jump *label36 greaterThanEq *tmp42 176
+   61 jump *label28 greaterThanEq *tmp42 176
    62 multijump *tmp42 0 0 (m:*label152)
    63 multilabel *label156 (m:*label152)
    64 op mul *tmp55 2 *tmp42
 
   815 label *label54
   816 jump *label69 lessThanEq .PALETTE 1
   817 set :drawPixel:color %[black]
-    * jump *label72 equal *tmp60 63
+  818 jump *label70 equal *tmp60 63
   819 multijump .PALETTE 0 0 (m:*label158)
   820 multilabel *label163 (m:*label158)
   821 multilabel *label159 (m:*label158)
   822 op div *tmp136 *tmp60 63.75
   823 op sub :drawPixel:r 1 *tmp136
   824 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * jump *label73 always
+  825 jump *label70 always
   826 multilabel *label160 (m:*label158)
   827 op sub *tmp101 32 *tmp60
   828 op abs *tmp102 *tmp101
 
   835 op div *tmp114 *tmp102 63.75
   836 op add :drawPixel:b 0.47058823529411764 *tmp114
   837 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label73 always
+  838 jump *label70 always
   839 multilabel *label161 (m:*label158)
   840 op div *tmp118 *tmp60 0.175
   841 op sin :drawPixel:r *tmp118
 
   845 op div *tmp126 *tmp124 63.75
   846 op add :drawPixel:b 0.39215686274509803 *tmp126
   847 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label73 always
+  848 jump *label70 always
   849 multilabel *label162 (m:*label158)
   850 op div :drawPixel:r *tmp60 63.75
   851 op div *tmp132 *tmp60 170
 
   858 read :drawPixel:color .memory *tmp60
   859 label *label70
   860 jump *label80 lessThan .localBuffer 254
-    * jump *label85 lessThanEq .localBuffer 0
+  861 jump *label91 lessThanEq .localBuffer 0
   862 label *label114
   863 wait 0
   864 sensor *tmp145 .display @enabled
 
   899 op add *tmp1 *tmp161 1
   900 write *tmp1 .memory 65
   901 read *tmp164 .memory 67
-    * jump *label29 notEqual .stop *tmp164
+  902 jump *label28 notEqual .stop *tmp164
   903 op add :y :y 1
   904 jump *label112 lessThan :y 176
-    * jump *label105 lessThanEq .localBuffer 0
+  905 jump *label34 lessThanEq .localBuffer 0
   906 label *label115
   907 wait 0
   908 sensor *tmp167 .display @enabled

Modifications by Jumps phase, Unreachable Code Elimination, pass 7, iteration 1 (-1 instructions):
 
   913 label *label107
   914 jump *label115 greaterThan .localBuffer 0
   915 jump *label34 always
-    * jump *label28 always

Modifications by Final phase, Print Merging, iteration 1 (-7 instructions):
 
    16 set .memory :findLinkedBlocks:variable
    17 jump *label111 greaterThan :findLinkedBlocks:n 0
    18 label *label11
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
-    * print .display
+   19 print "\nDisplay: {0}\nMemory: "
+   20 format .display
    21 op and :findLinkedBlocks:foundAll 1 .display
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
    22 print .memory
    23 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    24 printflush null

Final code before resolving virtual instructions:

    0:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label1                                                *blocks: do
    1:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    2:  set .memory null                                             ...
    3:  print "Mandelbrot Generator"                                 *blocks: print(title);
    4:  set :findLinkedBlocks:n @links                               *blocks: var n = @links;
    5:  jump *label11 lessThanEq :findLinkedBlocks:n 0               *blocks: while n > 0 do
        label *label111                                              ...
    6:  op sub :findLinkedBlocks:n :findLinkedBlocks:n 1             *blocks: var block = getlink(--n);
    7:  getlink :findLinkedBlocks:block :findLinkedBlocks:n          ...
    8:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
    9:  print :findLinkedBlocks:block                                ...
   10:  sensor :findLinkedBlocks:type :findLinkedBlocks:block @type  *blocks: var type = block.@type;
   11:  select :findLinkedBlocks:variable equal @large-logic-display *blocks: if requested == type then
   12:  set .display :findLinkedBlocks:variable                      *blocks: for requested, name, out variable, required in linkMap do
   13:  select :findLinkedBlocks:variable equal @memory-bank :findLi *blocks: if requested == type then
   14:  set .memory :findLinkedBlocks:variable                       *blocks: for requested, name, out variable, required in linkMap do
   15:  jump *label111 greaterThan :findLinkedBlocks:n 0             *blocks: while n > 0 do
        label *label11                                               ...
   16:  print "\nDisplay: {0}\nMemory: "                             *blocks: print($"\n$name: $variable");
   17:  format .display                                              ...
   18:  op and :findLinkedBlocks:foundAll 1 .display                 *blocks: if required then foundAll &= variable; end;
   19:  print .memory                                                *blocks: print($"\n$name: $variable");
   20:  op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll *blocks: if required then foundAll &= variable; end;
   21:  printflush null                                              *blocks: printflush(message);
   22:  jump *label1 equal :findLinkedBlocks:foundAll false          *blocks: do
        label *label28                                               mandelbrot-compute.mnd: MainLoop:
        label *label31                                               mandelbrot-compute.mnd: do wait(0); while start == $START;
   23:  wait 0                                                       ...
   24:  read *tmp24 .memory 66                                       ...
   25:  jump *label31 equal .start *tmp24                            ...
   26:  read .start .memory 66                                       mandelbrot-compute.mnd: start = $START;
   27:  read .stop .memory 67                                        mandelbrot-compute.mnd: stop = $STOP;
   28:  set .lastColor -1                                            mandelbrot-compute.mnd: lastColor = -1;
   29:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   30:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
   31:  read .ZOOM .memory 70                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   32:  op div *tmp28 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   33:  read *tmp30 .memory 68                                       ...
   34:  op add .OFFSET_X *tmp28 *tmp30                               ...
   35:  read *tmp33 .memory 69                                       mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   36:  op add .OFFSET_Y *tmp28 *tmp33                               ...
   37:  read .JULIA .memory 71                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   38:  read .JULIA_X .memory 72                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   39:  read .JULIA_Y .memory 73                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   40:  read .PALETTE .memory 74                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   41:  op greaterThan .SMOOTH .PALETTE 1                            mandelbrot-compute.mnd: SMOOTH   = PALETTE > 1;
        label *label34                                               mandelbrot-compute.mnd: while true do
   42:  wait 0.004                              # 0.240 ticks for at mandelbrot-compute.mnd: atomic
   43:  read *tmp40 .memory 67                                       mandelbrot-compute.mnd: if stop != $STOP then
   44:  jump *label28 notEqual .stop *tmp40                          ...
   45:  read *tmp42 .memory 64                                       mandelbrot-compute.mnd: line = $LINE++;
   46:  op add *tmp0 *tmp42 1                                        ...
   47:  write *tmp0 .memory 64                  # The last atomic bl ...
   48:  jump *label28 greaterThanEq *tmp42 176                       mandelbrot-compute.mnd: if line >= DISPLAY_SIZE_LARGE then
   49:  multijump *tmp42 0 0                                         mandelbrot-compute.mnd: var strip = case line
        multilabel *label156                                         ...
   50:  op mul *tmp55 2 *tmp42                                       mandelbrot-compute.mnd: else 2 * line - 2 * 88 + 1;
   51:  op sub *tmp46 *tmp55 175                                     ...
   52:  jump *label41 always 0 0                                     mandelbrot-compute.mnd: var strip = case line
        multilabel *label153                                         ...
   53:  op mul *tmp46 8 *tmp42                                       mandelbrot-compute.mnd: when 0 ... 22 then 8 * line;
   54:  jump *label41 always 0 0                                     mandelbrot-compute.mnd: var strip = case line
        multilabel *label154                                         ...
   55:  op mul *tmp49 8 *tmp42                                       mandelbrot-compute.mnd: when 22 ... 44 then 8 * line - 8 * 22 + 4;
   56:  op sub *tmp46 *tmp49 172                                     ...
   57:  jump *label41 always 0 0                                     mandelbrot-compute.mnd: var strip = case line
        multilabel *label155                                         ...
   58:  op mul *tmp52 4 *tmp42                                       mandelbrot-compute.mnd: when 44 ... 88 then 4 * line - 4 * 44 + 2;
   59:  op sub *tmp46 *tmp52 174                                     ...
        label *label41                                               mandelbrot-compute.mnd: var strip = case line
   60:  op mul *tmp58 17 *tmp46                                      mandelbrot-compute.mnd: var x = (SKIP * strip) % DISPLAY_SIZE_LARGE;
   61:  op mod :x *tmp58 176                                         ...
   62:  set :y 0                                                     mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
        label *label112                                              ...
   63:  op div *tmp61 :x .ZOOM                                       mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   64:  op add :compute:zx *tmp61 .OFFSET_X                          ...
   65:  op div *tmp63 :y .ZOOM                                       mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   66:  op add :compute:zy *tmp63 .OFFSET_Y                          ...
   67:  jump *label55 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   68:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
   69:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
   70:  jump *label56 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label55                                               ...
   71:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
   72:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
   73:  op sub *tmp66 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   74:  op len :compute:p *tmp66 :compute:zy                         ...
   75:  op mul *tmp68 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
   76:  op mul *tmp69 *tmp68 :compute:p                              ...
   77:  op sub *tmp70 :compute:p *tmp69                              ...
   78:  op add *tmp71 *tmp70 0.25                                    ...
   79:  jump *label57 greaterThan :compute:zx *tmp71                 ...
   80:  set *tmp60 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
   81:  jump *label54 always 0 0                                     ...
        label *label57                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
   82:  op add *tmp74 :compute:zx 1                                  mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
   83:  op len *tmp75 *tmp74 :compute:zy                             ...
   84:  jump *label59 greaterThan *tmp75 0.25                        ...
   85:  set *tmp60 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
   86:  jump *label54 always 0 0                                     ...
        label *label59                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label56                                               mandelbrot-compute.mnd: if JULIA then
   87:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
   88:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
   89:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
   90:  op mul *tmp79 :compute:zy :compute:zy                        ...
   91:  op sub *tmp80 *tmp78 *tmp79                                  ...
   92:  op add :compute:zx *tmp80 :compute:cx                        ...
   93:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
   94:  op mul *tmp83 *tmp82 :compute:zy                             ...
   95:  op add :compute:zy *tmp83 :compute:cy                        ...
   96:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
   97:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
   98:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
   99:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  100:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  101:  op mul *tmp79 :compute:zy :compute:zy                        ...
  102:  op sub *tmp80 *tmp78 *tmp79                                  ...
  103:  op add :compute:zx *tmp80 :compute:cx                        ...
  104:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  105:  op mul *tmp83 *tmp82 :compute:zy                             ...
  106:  op add :compute:zy *tmp83 :compute:cy                        ...
  107:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  108:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  109:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  110:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  111:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  112:  op mul *tmp79 :compute:zy :compute:zy                        ...
  113:  op sub *tmp80 *tmp78 *tmp79                                  ...
  114:  op add :compute:zx *tmp80 :compute:cx                        ...
  115:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  116:  op mul *tmp83 *tmp82 :compute:zy                             ...
  117:  op add :compute:zy *tmp83 :compute:cy                        ...
  118:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  119:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  120:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  121:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  122:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  123:  op mul *tmp79 :compute:zy :compute:zy                        ...
  124:  op sub *tmp80 *tmp78 *tmp79                                  ...
  125:  op add :compute:zx *tmp80 :compute:cx                        ...
  126:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  127:  op mul *tmp83 *tmp82 :compute:zy                             ...
  128:  op add :compute:zy *tmp83 :compute:cy                        ...
  129:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  130:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  131:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  132:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  133:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  134:  op mul *tmp79 :compute:zy :compute:zy                        ...
  135:  op sub *tmp80 *tmp78 *tmp79                                  ...
  136:  op add :compute:zx *tmp80 :compute:cx                        ...
  137:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  138:  op mul *tmp83 *tmp82 :compute:zy                             ...
  139:  op add :compute:zy *tmp83 :compute:cy                        ...
  140:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  141:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  142:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  143:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  144:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  145:  op mul *tmp79 :compute:zy :compute:zy                        ...
  146:  op sub *tmp80 *tmp78 *tmp79                                  ...
  147:  op add :compute:zx *tmp80 :compute:cx                        ...
  148:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  149:  op mul *tmp83 *tmp82 :compute:zy                             ...
  150:  op add :compute:zy *tmp83 :compute:cy                        ...
  151:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  152:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  153:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  154:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  155:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  156:  op mul *tmp79 :compute:zy :compute:zy                        ...
  157:  op sub *tmp80 *tmp78 *tmp79                                  ...
  158:  op add :compute:zx *tmp80 :compute:cx                        ...
  159:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  160:  op mul *tmp83 *tmp82 :compute:zy                             ...
  161:  op add :compute:zy *tmp83 :compute:cy                        ...
  162:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  163:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  164:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  165:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  166:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  167:  op mul *tmp79 :compute:zy :compute:zy                        ...
  168:  op sub *tmp80 *tmp78 *tmp79                                  ...
  169:  op add :compute:zx *tmp80 :compute:cx                        ...
  170:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  171:  op mul *tmp83 *tmp82 :compute:zy                             ...
  172:  op add :compute:zy *tmp83 :compute:cy                        ...
  173:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  174:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  175:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  176:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  177:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  178:  op mul *tmp79 :compute:zy :compute:zy                        ...
  179:  op sub *tmp80 *tmp78 *tmp79                                  ...
  180:  op add :compute:zx *tmp80 :compute:cx                        ...
  181:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  182:  op mul *tmp83 *tmp82 :compute:zy                             ...
  183:  op add :compute:zy *tmp83 :compute:cy                        ...
  184:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  185:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  186:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  187:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  188:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  189:  op mul *tmp79 :compute:zy :compute:zy                        ...
  190:  op sub *tmp80 *tmp78 *tmp79                                  ...
  191:  op add :compute:zx *tmp80 :compute:cx                        ...
  192:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  193:  op mul *tmp83 *tmp82 :compute:zy                             ...
  194:  op add :compute:zy *tmp83 :compute:cy                        ...
  195:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  196:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  197:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  198:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  199:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  200:  op mul *tmp79 :compute:zy :compute:zy                        ...
  201:  op sub *tmp80 *tmp78 *tmp79                                  ...
  202:  op add :compute:zx *tmp80 :compute:cx                        ...
  203:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  204:  op mul *tmp83 *tmp82 :compute:zy                             ...
  205:  op add :compute:zy *tmp83 :compute:cy                        ...
  206:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  207:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  208:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  209:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  210:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  211:  op mul *tmp79 :compute:zy :compute:zy                        ...
  212:  op sub *tmp80 *tmp78 *tmp79                                  ...
  213:  op add :compute:zx *tmp80 :compute:cx                        ...
  214:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  215:  op mul *tmp83 *tmp82 :compute:zy                             ...
  216:  op add :compute:zy *tmp83 :compute:cy                        ...
  217:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  218:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  219:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  220:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  221:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  222:  op mul *tmp79 :compute:zy :compute:zy                        ...
  223:  op sub *tmp80 *tmp78 *tmp79                                  ...
  224:  op add :compute:zx *tmp80 :compute:cx                        ...
  225:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  226:  op mul *tmp83 *tmp82 :compute:zy                             ...
  227:  op add :compute:zy *tmp83 :compute:cy                        ...
  228:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  229:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  230:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  231:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  232:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  233:  op mul *tmp79 :compute:zy :compute:zy                        ...
  234:  op sub *tmp80 *tmp78 *tmp79                                  ...
  235:  op add :compute:zx *tmp80 :compute:cx                        ...
  236:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  237:  op mul *tmp83 *tmp82 :compute:zy                             ...
  238:  op add :compute:zy *tmp83 :compute:cy                        ...
  239:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  240:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  241:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  242:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  243:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  244:  op mul *tmp79 :compute:zy :compute:zy                        ...
  245:  op sub *tmp80 *tmp78 *tmp79                                  ...
  246:  op add :compute:zx *tmp80 :compute:cx                        ...
  247:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  248:  op mul *tmp83 *tmp82 :compute:zy                             ...
  249:  op add :compute:zy *tmp83 :compute:cy                        ...
  250:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  251:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  252:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  253:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  254:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  255:  op mul *tmp79 :compute:zy :compute:zy                        ...
  256:  op sub *tmp80 *tmp78 *tmp79                                  ...
  257:  op add :compute:zx *tmp80 :compute:cx                        ...
  258:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  259:  op mul *tmp83 *tmp82 :compute:zy                             ...
  260:  op add :compute:zy *tmp83 :compute:cy                        ...
  261:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  262:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  263:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  264:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  265:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  266:  op mul *tmp79 :compute:zy :compute:zy                        ...
  267:  op sub *tmp80 *tmp78 *tmp79                                  ...
  268:  op add :compute:zx *tmp80 :compute:cx                        ...
  269:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  270:  op mul *tmp83 *tmp82 :compute:zy                             ...
  271:  op add :compute:zy *tmp83 :compute:cy                        ...
  272:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  273:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  274:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  275:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  276:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  277:  op mul *tmp79 :compute:zy :compute:zy                        ...
  278:  op sub *tmp80 *tmp78 *tmp79                                  ...
  279:  op add :compute:zx *tmp80 :compute:cx                        ...
  280:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  281:  op mul *tmp83 *tmp82 :compute:zy                             ...
  282:  op add :compute:zy *tmp83 :compute:cy                        ...
  283:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  284:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  285:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  286:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  287:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  288:  op mul *tmp79 :compute:zy :compute:zy                        ...
  289:  op sub *tmp80 *tmp78 *tmp79                                  ...
  290:  op add :compute:zx *tmp80 :compute:cx                        ...
  291:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  292:  op mul *tmp83 *tmp82 :compute:zy                             ...
  293:  op add :compute:zy *tmp83 :compute:cy                        ...
  294:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  295:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  296:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  297:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  298:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  299:  op mul *tmp79 :compute:zy :compute:zy                        ...
  300:  op sub *tmp80 *tmp78 *tmp79                                  ...
  301:  op add :compute:zx *tmp80 :compute:cx                        ...
  302:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  303:  op mul *tmp83 *tmp82 :compute:zy                             ...
  304:  op add :compute:zy *tmp83 :compute:cy                        ...
  305:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  306:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  307:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  308:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  309:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  310:  op mul *tmp79 :compute:zy :compute:zy                        ...
  311:  op sub *tmp80 *tmp78 *tmp79                                  ...
  312:  op add :compute:zx *tmp80 :compute:cx                        ...
  313:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  314:  op mul *tmp83 *tmp82 :compute:zy                             ...
  315:  op add :compute:zy *tmp83 :compute:cy                        ...
  316:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  317:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  318:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  319:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  320:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  321:  op mul *tmp79 :compute:zy :compute:zy                        ...
  322:  op sub *tmp80 *tmp78 *tmp79                                  ...
  323:  op add :compute:zx *tmp80 :compute:cx                        ...
  324:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  325:  op mul *tmp83 *tmp82 :compute:zy                             ...
  326:  op add :compute:zy *tmp83 :compute:cy                        ...
  327:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  328:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  329:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  330:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  331:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  332:  op mul *tmp79 :compute:zy :compute:zy                        ...
  333:  op sub *tmp80 *tmp78 *tmp79                                  ...
  334:  op add :compute:zx *tmp80 :compute:cx                        ...
  335:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  336:  op mul *tmp83 *tmp82 :compute:zy                             ...
  337:  op add :compute:zy *tmp83 :compute:cy                        ...
  338:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  339:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  340:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  341:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  342:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  343:  op mul *tmp79 :compute:zy :compute:zy                        ...
  344:  op sub *tmp80 *tmp78 *tmp79                                  ...
  345:  op add :compute:zx *tmp80 :compute:cx                        ...
  346:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  347:  op mul *tmp83 *tmp82 :compute:zy                             ...
  348:  op add :compute:zy *tmp83 :compute:cy                        ...
  349:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  350:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  351:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  352:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  353:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  354:  op mul *tmp79 :compute:zy :compute:zy                        ...
  355:  op sub *tmp80 *tmp78 *tmp79                                  ...
  356:  op add :compute:zx *tmp80 :compute:cx                        ...
  357:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  358:  op mul *tmp83 *tmp82 :compute:zy                             ...
  359:  op add :compute:zy *tmp83 :compute:cy                        ...
  360:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  361:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  362:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  363:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  364:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  365:  op mul *tmp79 :compute:zy :compute:zy                        ...
  366:  op sub *tmp80 *tmp78 *tmp79                                  ...
  367:  op add :compute:zx *tmp80 :compute:cx                        ...
  368:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  369:  op mul *tmp83 *tmp82 :compute:zy                             ...
  370:  op add :compute:zy *tmp83 :compute:cy                        ...
  371:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  372:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  373:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  374:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  375:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  376:  op mul *tmp79 :compute:zy :compute:zy                        ...
  377:  op sub *tmp80 *tmp78 *tmp79                                  ...
  378:  op add :compute:zx *tmp80 :compute:cx                        ...
  379:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  380:  op mul *tmp83 *tmp82 :compute:zy                             ...
  381:  op add :compute:zy *tmp83 :compute:cy                        ...
  382:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  383:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  384:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  385:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  386:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  387:  op mul *tmp79 :compute:zy :compute:zy                        ...
  388:  op sub *tmp80 *tmp78 *tmp79                                  ...
  389:  op add :compute:zx *tmp80 :compute:cx                        ...
  390:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  391:  op mul *tmp83 *tmp82 :compute:zy                             ...
  392:  op add :compute:zy *tmp83 :compute:cy                        ...
  393:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  394:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  395:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  396:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  397:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  398:  op mul *tmp79 :compute:zy :compute:zy                        ...
  399:  op sub *tmp80 *tmp78 *tmp79                                  ...
  400:  op add :compute:zx *tmp80 :compute:cx                        ...
  401:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  402:  op mul *tmp83 *tmp82 :compute:zy                             ...
  403:  op add :compute:zy *tmp83 :compute:cy                        ...
  404:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  405:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  406:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  407:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  408:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  409:  op mul *tmp79 :compute:zy :compute:zy                        ...
  410:  op sub *tmp80 *tmp78 *tmp79                                  ...
  411:  op add :compute:zx *tmp80 :compute:cx                        ...
  412:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  413:  op mul *tmp83 *tmp82 :compute:zy                             ...
  414:  op add :compute:zy *tmp83 :compute:cy                        ...
  415:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  416:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  417:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  418:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  419:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  420:  op mul *tmp79 :compute:zy :compute:zy                        ...
  421:  op sub *tmp80 *tmp78 *tmp79                                  ...
  422:  op add :compute:zx *tmp80 :compute:cx                        ...
  423:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  424:  op mul *tmp83 *tmp82 :compute:zy                             ...
  425:  op add :compute:zy *tmp83 :compute:cy                        ...
  426:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  427:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  428:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  429:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  430:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  431:  op mul *tmp79 :compute:zy :compute:zy                        ...
  432:  op sub *tmp80 *tmp78 *tmp79                                  ...
  433:  op add :compute:zx *tmp80 :compute:cx                        ...
  434:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  435:  op mul *tmp83 *tmp82 :compute:zy                             ...
  436:  op add :compute:zy *tmp83 :compute:cy                        ...
  437:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  438:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  439:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  440:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  441:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  442:  op mul *tmp79 :compute:zy :compute:zy                        ...
  443:  op sub *tmp80 *tmp78 *tmp79                                  ...
  444:  op add :compute:zx *tmp80 :compute:cx                        ...
  445:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  446:  op mul *tmp83 *tmp82 :compute:zy                             ...
  447:  op add :compute:zy *tmp83 :compute:cy                        ...
  448:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  449:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  450:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  451:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  452:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  453:  op mul *tmp79 :compute:zy :compute:zy                        ...
  454:  op sub *tmp80 *tmp78 *tmp79                                  ...
  455:  op add :compute:zx *tmp80 :compute:cx                        ...
  456:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  457:  op mul *tmp83 *tmp82 :compute:zy                             ...
  458:  op add :compute:zy *tmp83 :compute:cy                        ...
  459:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  460:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  461:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  462:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  463:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  464:  op mul *tmp79 :compute:zy :compute:zy                        ...
  465:  op sub *tmp80 *tmp78 *tmp79                                  ...
  466:  op add :compute:zx *tmp80 :compute:cx                        ...
  467:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  468:  op mul *tmp83 *tmp82 :compute:zy                             ...
  469:  op add :compute:zy *tmp83 :compute:cy                        ...
  470:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  471:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  472:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  473:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  474:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  475:  op mul *tmp79 :compute:zy :compute:zy                        ...
  476:  op sub *tmp80 *tmp78 *tmp79                                  ...
  477:  op add :compute:zx *tmp80 :compute:cx                        ...
  478:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  479:  op mul *tmp83 *tmp82 :compute:zy                             ...
  480:  op add :compute:zy *tmp83 :compute:cy                        ...
  481:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  482:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  483:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  484:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  485:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  486:  op mul *tmp79 :compute:zy :compute:zy                        ...
  487:  op sub *tmp80 *tmp78 *tmp79                                  ...
  488:  op add :compute:zx *tmp80 :compute:cx                        ...
  489:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  490:  op mul *tmp83 *tmp82 :compute:zy                             ...
  491:  op add :compute:zy *tmp83 :compute:cy                        ...
  492:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  493:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  494:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  495:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  496:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  497:  op mul *tmp79 :compute:zy :compute:zy                        ...
  498:  op sub *tmp80 *tmp78 *tmp79                                  ...
  499:  op add :compute:zx *tmp80 :compute:cx                        ...
  500:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  501:  op mul *tmp83 *tmp82 :compute:zy                             ...
  502:  op add :compute:zy *tmp83 :compute:cy                        ...
  503:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  504:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  505:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  506:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  507:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  508:  op mul *tmp79 :compute:zy :compute:zy                        ...
  509:  op sub *tmp80 *tmp78 *tmp79                                  ...
  510:  op add :compute:zx *tmp80 :compute:cx                        ...
  511:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  512:  op mul *tmp83 *tmp82 :compute:zy                             ...
  513:  op add :compute:zy *tmp83 :compute:cy                        ...
  514:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  515:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  516:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  517:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  518:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  519:  op mul *tmp79 :compute:zy :compute:zy                        ...
  520:  op sub *tmp80 *tmp78 *tmp79                                  ...
  521:  op add :compute:zx *tmp80 :compute:cx                        ...
  522:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  523:  op mul *tmp83 *tmp82 :compute:zy                             ...
  524:  op add :compute:zy *tmp83 :compute:cy                        ...
  525:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  526:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  527:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  528:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  529:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  530:  op mul *tmp79 :compute:zy :compute:zy                        ...
  531:  op sub *tmp80 *tmp78 *tmp79                                  ...
  532:  op add :compute:zx *tmp80 :compute:cx                        ...
  533:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  534:  op mul *tmp83 *tmp82 :compute:zy                             ...
  535:  op add :compute:zy *tmp83 :compute:cy                        ...
  536:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  537:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  538:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  539:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  540:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  541:  op mul *tmp79 :compute:zy :compute:zy                        ...
  542:  op sub *tmp80 *tmp78 *tmp79                                  ...
  543:  op add :compute:zx *tmp80 :compute:cx                        ...
  544:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  545:  op mul *tmp83 *tmp82 :compute:zy                             ...
  546:  op add :compute:zy *tmp83 :compute:cy                        ...
  547:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  548:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  549:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  550:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  551:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  552:  op mul *tmp79 :compute:zy :compute:zy                        ...
  553:  op sub *tmp80 *tmp78 *tmp79                                  ...
  554:  op add :compute:zx *tmp80 :compute:cx                        ...
  555:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  556:  op mul *tmp83 *tmp82 :compute:zy                             ...
  557:  op add :compute:zy *tmp83 :compute:cy                        ...
  558:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  559:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  560:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  561:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  562:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  563:  op mul *tmp79 :compute:zy :compute:zy                        ...
  564:  op sub *tmp80 *tmp78 *tmp79                                  ...
  565:  op add :compute:zx *tmp80 :compute:cx                        ...
  566:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  567:  op mul *tmp83 *tmp82 :compute:zy                             ...
  568:  op add :compute:zy *tmp83 :compute:cy                        ...
  569:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  570:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  571:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  572:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  573:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  574:  op mul *tmp79 :compute:zy :compute:zy                        ...
  575:  op sub *tmp80 *tmp78 *tmp79                                  ...
  576:  op add :compute:zx *tmp80 :compute:cx                        ...
  577:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  578:  op mul *tmp83 *tmp82 :compute:zy                             ...
  579:  op add :compute:zy *tmp83 :compute:cy                        ...
  580:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  581:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  582:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  583:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  584:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  585:  op mul *tmp79 :compute:zy :compute:zy                        ...
  586:  op sub *tmp80 *tmp78 *tmp79                                  ...
  587:  op add :compute:zx *tmp80 :compute:cx                        ...
  588:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  589:  op mul *tmp83 *tmp82 :compute:zy                             ...
  590:  op add :compute:zy *tmp83 :compute:cy                        ...
  591:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  592:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  593:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  594:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  595:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  596:  op mul *tmp79 :compute:zy :compute:zy                        ...
  597:  op sub *tmp80 *tmp78 *tmp79                                  ...
  598:  op add :compute:zx *tmp80 :compute:cx                        ...
  599:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  600:  op mul *tmp83 *tmp82 :compute:zy                             ...
  601:  op add :compute:zy *tmp83 :compute:cy                        ...
  602:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  603:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  604:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  605:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  606:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  607:  op mul *tmp79 :compute:zy :compute:zy                        ...
  608:  op sub *tmp80 *tmp78 *tmp79                                  ...
  609:  op add :compute:zx *tmp80 :compute:cx                        ...
  610:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  611:  op mul *tmp83 *tmp82 :compute:zy                             ...
  612:  op add :compute:zy *tmp83 :compute:cy                        ...
  613:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  614:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  615:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  616:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  617:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  618:  op mul *tmp79 :compute:zy :compute:zy                        ...
  619:  op sub *tmp80 *tmp78 *tmp79                                  ...
  620:  op add :compute:zx *tmp80 :compute:cx                        ...
  621:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  622:  op mul *tmp83 *tmp82 :compute:zy                             ...
  623:  op add :compute:zy *tmp83 :compute:cy                        ...
  624:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  625:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  626:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  627:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  628:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  629:  op mul *tmp79 :compute:zy :compute:zy                        ...
  630:  op sub *tmp80 *tmp78 *tmp79                                  ...
  631:  op add :compute:zx *tmp80 :compute:cx                        ...
  632:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  633:  op mul *tmp83 *tmp82 :compute:zy                             ...
  634:  op add :compute:zy *tmp83 :compute:cy                        ...
  635:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  636:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  637:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  638:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  639:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  640:  op mul *tmp79 :compute:zy :compute:zy                        ...
  641:  op sub *tmp80 *tmp78 *tmp79                                  ...
  642:  op add :compute:zx *tmp80 :compute:cx                        ...
  643:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  644:  op mul *tmp83 *tmp82 :compute:zy                             ...
  645:  op add :compute:zy *tmp83 :compute:cy                        ...
  646:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  647:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  648:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  649:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  650:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  651:  op mul *tmp79 :compute:zy :compute:zy                        ...
  652:  op sub *tmp80 *tmp78 *tmp79                                  ...
  653:  op add :compute:zx *tmp80 :compute:cx                        ...
  654:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  655:  op mul *tmp83 *tmp82 :compute:zy                             ...
  656:  op add :compute:zy *tmp83 :compute:cy                        ...
  657:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  658:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  659:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  660:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  661:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  662:  op mul *tmp79 :compute:zy :compute:zy                        ...
  663:  op sub *tmp80 *tmp78 *tmp79                                  ...
  664:  op add :compute:zx *tmp80 :compute:cx                        ...
  665:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  666:  op mul *tmp83 *tmp82 :compute:zy                             ...
  667:  op add :compute:zy *tmp83 :compute:cy                        ...
  668:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  669:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  670:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  671:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  672:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  673:  op mul *tmp79 :compute:zy :compute:zy                        ...
  674:  op sub *tmp80 *tmp78 *tmp79                                  ...
  675:  op add :compute:zx *tmp80 :compute:cx                        ...
  676:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  677:  op mul *tmp83 *tmp82 :compute:zy                             ...
  678:  op add :compute:zy *tmp83 :compute:cy                        ...
  679:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  680:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  681:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  682:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  683:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  684:  op mul *tmp79 :compute:zy :compute:zy                        ...
  685:  op sub *tmp80 *tmp78 *tmp79                                  ...
  686:  op add :compute:zx *tmp80 :compute:cx                        ...
  687:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  688:  op mul *tmp83 *tmp82 :compute:zy                             ...
  689:  op add :compute:zy *tmp83 :compute:cy                        ...
  690:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  691:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  692:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  693:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  694:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  695:  op mul *tmp79 :compute:zy :compute:zy                        ...
  696:  op sub *tmp80 *tmp78 *tmp79                                  ...
  697:  op add :compute:zx *tmp80 :compute:cx                        ...
  698:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  699:  op mul *tmp83 *tmp82 :compute:zy                             ...
  700:  op add :compute:zy *tmp83 :compute:cy                        ...
  701:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  702:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  703:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  704:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  705:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  706:  op mul *tmp79 :compute:zy :compute:zy                        ...
  707:  op sub *tmp80 *tmp78 *tmp79                                  ...
  708:  op add :compute:zx *tmp80 :compute:cx                        ...
  709:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  710:  op mul *tmp83 *tmp82 :compute:zy                             ...
  711:  op add :compute:zy *tmp83 :compute:cy                        ...
  712:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  713:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  714:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  715:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  716:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  717:  op mul *tmp79 :compute:zy :compute:zy                        ...
  718:  op sub *tmp80 *tmp78 *tmp79                                  ...
  719:  op add :compute:zx *tmp80 :compute:cx                        ...
  720:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  721:  op mul *tmp83 *tmp82 :compute:zy                             ...
  722:  op add :compute:zy *tmp83 :compute:cy                        ...
  723:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  724:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  725:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  726:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  727:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  728:  op mul *tmp79 :compute:zy :compute:zy                        ...
  729:  op sub *tmp80 *tmp78 *tmp79                                  ...
  730:  op add :compute:zx *tmp80 :compute:cx                        ...
  731:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  732:  op mul *tmp83 *tmp82 :compute:zy                             ...
  733:  op add :compute:zy *tmp83 :compute:cy                        ...
  734:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  735:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  736:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  737:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  738:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  739:  op mul *tmp79 :compute:zy :compute:zy                        ...
  740:  op sub *tmp80 *tmp78 *tmp79                                  ...
  741:  op add :compute:zx *tmp80 :compute:cx                        ...
  742:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  743:  op mul *tmp83 *tmp82 :compute:zy                             ...
  744:  op add :compute:zy *tmp83 :compute:cy                        ...
  745:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  746:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  747:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  748:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  749:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  750:  op mul *tmp79 :compute:zy :compute:zy                        ...
  751:  op sub *tmp80 *tmp78 *tmp79                                  ...
  752:  op add :compute:zx *tmp80 :compute:cx                        ...
  753:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  754:  op mul *tmp83 *tmp82 :compute:zy                             ...
  755:  op add :compute:zy *tmp83 :compute:cy                        ...
  756:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  757:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  758:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  759:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  760:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  761:  op mul *tmp79 :compute:zy :compute:zy                        ...
  762:  op sub *tmp80 *tmp78 *tmp79                                  ...
  763:  op add :compute:zx *tmp80 :compute:cx                        ...
  764:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  765:  op mul *tmp83 *tmp82 :compute:zy                             ...
  766:  op add :compute:zy *tmp83 :compute:cy                        ...
  767:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  768:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  769:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  770:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  771:  op mul *tmp78 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  772:  op mul *tmp79 :compute:zy :compute:zy                        ...
  773:  op sub *tmp80 *tmp78 *tmp79                                  ...
  774:  op add :compute:zx *tmp80 :compute:cx                        ...
  775:  op mul *tmp82 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  776:  op mul *tmp83 *tmp82 :compute:zy                             ...
  777:  op add :compute:zy *tmp83 :compute:cy                        ...
  778:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  779:  jump *label63 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  780:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label63                                               ...
  781:  op mul *tmp88 .SMOOTH 63                                     mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  782:  jump *label66 greaterThanEq :compute:i *tmp88                ...
  783:  op log *tmp91 :compute:dist 0                                mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  784:  op mul *tmp92 *tmp91 0.36067376022224085                     ...
  785:  op log *tmp93 *tmp92 0                                       ...
  786:  op mul *tmp94 *tmp93 1.4426950408889634                      ...
  787:  op sub :compute:correction 4 *tmp94                          ...
  788:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label66                                               mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  789:  set *tmp60 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label54                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  790:  jump *label69 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH then
  791:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  792:  jump *label70 equal *tmp60 63                                mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  793:  multijump .PALETTE 0 0                                       mandelbrot-compute.mnd: case PALETTE
        multilabel *label163                                         ...
        multilabel *label159                                         ...
  794:  op div *tmp136 *tmp60 63.75                                  mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  795:  op sub :drawPixel:r 1 *tmp136                                ...
  796:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  797:  jump *label70 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label160                                         ...
  798:  op sub *tmp101 32 *tmp60                                     mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  799:  op abs *tmp102 *tmp101 0                                     ...
  800:  op div *tmp104 *tmp102 36.42857142857143                     ...
  801:  op sub :drawPixel:r 1 *tmp104                                ...
  802:  op sub *tmp106 *tmp60 32                                     mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  803:  op abs *tmp107 *tmp106 0                                     ...
  804:  op div *tmp109 *tmp107 42.5                                  ...
  805:  op sub :drawPixel:g 0.9411764705882353 *tmp109               ...
  806:  op div *tmp114 *tmp102 63.75                                 mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  807:  op add :drawPixel:b 0.47058823529411764 *tmp114              ...
  808:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  809:  jump *label70 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label161                                         ...
  810:  op div *tmp118 *tmp60 0.175                                  mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  811:  op sin :drawPixel:r *tmp118 0                                ...
  812:  op cos :drawPixel:g *tmp118 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  813:  op sub *tmp123 *tmp60 32                                     mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  814:  op abs *tmp124 *tmp123 0                                     ...
  815:  op div *tmp126 *tmp124 63.75                                 ...
  816:  op add :drawPixel:b 0.39215686274509803 *tmp126              ...
  817:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  818:  jump *label70 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label162                                         ...
  819:  op div :drawPixel:r *tmp60 63.75                             mandelbrot-compute.mnd: r = 4 * iterations / 255;
  820:  op div *tmp132 *tmp60 170                                    mandelbrot-compute.mnd: g = 96 + 1.5 * iterations / 255;
  821:  op add :drawPixel:g 96 *tmp132                               ...
  822:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  823:  jump *label70 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label69                                               ...
  824:  read :drawPixel:color .memory *tmp60                         mandelbrot-compute.mnd: color = memory[iterations];
        label *label70                                               mandelbrot-compute.mnd: if SMOOTH then
  825:  jump *label80 lessThan .localBuffer 254                      mandelbrot-compute.mnd: if localBuffer >= 254 then
  826:  jump *label91 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: while localBuffer > 0 do
        label *label114                                              ...
  827:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  828:  sensor *tmp145 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled then
  829:  jump *label87 equal *tmp145 false                            ...
  830:  sensor *tmp147 .display @bufferSize                          mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  831:  op sub *tmp148 1024 *tmp147                                  ...
  832:  jump *label89 greaterThanEq .localBuffer *tmp148             ...
  833:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  834:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label89                                               mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label87                                               mandelbrot-compute.mnd: if display.@enabled then
  835:  jump *label114 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 do
        label *label80                                               mandelbrot-compute.mnd: if localBuffer >= 254 then
  836:  jump *label91 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  837:  jump *label91 strictNotEqual :drawPixel:color .lastColor     ...
  838:  draw rect :x :y 1 1 0 0                                      mandelbrot-compute.mnd: rect(x, y, 1, 1);
  839:  op add .localBuffer .localBuffer 1                           mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  840:  jump *label92 always 0 0                                     ...
        label *label91                                               ...
  841:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  842:  draw rect :x :y 1 1 0 0                                      mandelbrot-compute.mnd: rect(x, y, 1, 1);
  843:  set .lastColor :drawPixel:color                              mandelbrot-compute.mnd: lastColor = color;
  844:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
        label *label92                                               mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  845:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  846:  sensor *tmp155 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled then
  847:  jump *label96 equal *tmp155 false                            ...
  848:  sensor *tmp157 .display @bufferSize                          mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  849:  op sub *tmp158 1024 *tmp157                                  ...
  850:  jump *label98 greaterThanEq .localBuffer *tmp158             ...
  851:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  852:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label98                                               mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label96                                               mandelbrot-compute.mnd: if display.@enabled then
  853:  wait 0.002667                           # 0.160 ticks for at mandelbrot-compute.mnd: atomic $COMPLETED++; end;
  854:  read *tmp161 .memory 65                                      ...
  855:  op add *tmp1 *tmp161 1                                       ...
  856:  write *tmp1 .memory 65                  # The last atomic bl ...
  857:  read *tmp164 .memory 67                                      mandelbrot-compute.mnd: if stop != $STOP then
  858:  jump *label28 notEqual .stop *tmp164                         ...
  859:  op add :y :y 1                                               mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
  860:  jump *label112 lessThan :y 176                               ...
  861:  jump *label34 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: while localBuffer > 0 do
        label *label115                                              ...
  862:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  863:  sensor *tmp167 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled then
  864:  jump *label107 equal *tmp167 false                           ...
  865:  sensor *tmp169 .display @bufferSize                          mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  866:  op sub *tmp170 1024 *tmp169                                  ...
  867:  jump *label109 greaterThanEq .localBuffer *tmp170            ...
  868:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  869:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label109                                              mandelbrot-compute.mnd: if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label107                                              mandelbrot-compute.mnd: if display.@enabled then
  870:  jump *label115 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 do
  871:  jump *label34 always 0 0                                     mandelbrot-compute.mnd: while true do


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   727     1x    727,0  inline def compute(in x, in y)
    51     1x     51,0  <no function>
    45     1x     45,0  inline void drawPixel(in x, in y, in iterations)
    24     3x      8,0  inline void flushLocalBuffer()
    22     1x     22,0  inline void findLinkedBlocks(in title, in message, in linkMap...)
     4     2x      2,0  inline void emptyLocalBuffer()
Runtime error at instruction #24: 'read *tmp24 .memory 66':
Execution step limit of 100,000 exceeded.

Performance: parsed in 314 ms, compiled in 313 ms, optimized in 1,574 ms, run in 103 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Display: large-logic-display
Memory: memory-bank
