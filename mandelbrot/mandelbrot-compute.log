   362 instructions before optimizations.
    39 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    36 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 4 iterations).
    17 instructions eliminated by Jump Optimization (4 iterations).
    14 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     2 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
    46 instructions eliminated by Data Flow Optimization (5 passes, 20 iterations).
     3 instructions eliminated by Loop Optimization (3 iterations).
     5 loops improved by Loop Optimization.
   742 instructions added by Loop Unrolling (8 iterations).
     4 loops unrolled by Loop Unrolling.
     9 instructions added by Function Inlining (8 iterations).
     2 function calls inlined by Function Inlining.
    68 instructions eliminated by Jump Straightening (2 passes, 4 iterations).
     4 instructions updated by JumpThreading.
     5 instructions eliminated by Unreachable Code Elimination.
     6 instructions eliminated by Print Merging.
   873 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 783):
  * Unroll iteration loop at *blocks:59:9                        cost     0, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:68:13                       cost     0, benefit     9375.0, efficiency   Infinity
    Unroll iteration loop at *blocks:77:9                        cost     0, benefit      375.0, efficiency   Infinity
    Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 787):
  * Unroll iteration loop at *blocks:68:13                       cost     0, benefit     9375.0, efficiency   Infinity (-5 instructions)
    Unroll iteration loop at *blocks:77:9                        cost     0, benefit      375.0, efficiency   Infinity
    Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 792):
  * Unroll iteration loop at *blocks:77:9                        cost     0, benefit      375.0, efficiency   Infinity (-2 instructions)
    Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 794):
  * Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6 (+743 instructions)
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 51):
  * Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0 (+7 instructions)
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   281 set *tmp79 null
   282 jump *label63 always
   283 label *label62
-    * set *tmp81 .PALETTE
-    * jump *label66 equal *tmp81 2
+  284 jump *label66 equal .PALETTE 2
   285 jump *label65 always
   286 label *label66
   287 op sub *tmp82 32 :drawPixel.0:iterations
 
   303 set *tmp80 null
   304 jump *label64 always
   305 label *label65
-    * jump *label68 equal *tmp81 3
+  306 jump *label68 equal .PALETTE 3
   307 jump *label67 always
   308 label *label68
   309 op div *tmp94 :drawPixel.0:iterations 63
 
   325 set *tmp80 null
   326 jump *label64 always
   327 label *label67
-    * jump *label70 equal *tmp81 4
+  328 jump *label70 equal .PALETTE 4
   329 jump *label69 always
   330 label *label70
   331 op mul *tmp106 4 :drawPixel.0:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-24 instructions):
 
    65 label *label20
    66 set *tmp21 null
    67 label *label21
-    * set *tmp19 *tmp21
    68 jump *label19 always
    69 label *label18
-    * set *tmp19 null
    70 label *label19
    71 label *label14
    72 multijump *tmp17 0 0 marker1
 
    98 print :findLinkedBlocks.0:variable
    99 jump *label27 equal :findLinkedBlocks.0:required false
   100 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
-    * set *tmp23 :findLinkedBlocks.0:foundAll
   101 jump *label28 always
   102 label *label27
-    * set *tmp23 null
   103 label *label28
   104 label *label23
   105 multijump *tmp22 0 0 marker2
 
   185 jump *label46 equal .JULIA false
   186 set :compute.0:cx .JULIA_X
   187 set :compute.0:cy .JULIA_Y
-    * set *tmp46 :compute.0:cy
   188 jump *label47 always
   189 label *label46
   190 set :compute.0:cx :compute.0:zx
 
   200 jump *label48 equal *tmp53 false
   201 set *tmp41 63
   202 jump *label45 always
-    * set *tmp54 null
   203 jump *label49 always
   204 label *label48
-    * set *tmp54 null
   205 label *label49
   206 op add *tmp55 :compute.0:cx 1
   207 op len *tmp56 *tmp55 :compute.0:cy
 
   214 label *label50
   215 set *tmp58 null
   216 label *label51
-    * set *tmp46 *tmp58
   217 label *label47
   218 set :compute.0:i 0
   219 label *label52
 
   234 op greaterThanEq *tmp67 :compute.0:dist 64
   235 jump *label55 equal *tmp67 false
   236 jump *label54 always
-    * set *tmp68 null
   237 jump *label56 always
   238 label *label55
-    * set *tmp68 null
   239 label *label56
   240 label *label53
   241 op add :compute.0:i :compute.0:i 1
 
   251 op sub *tmp76 4 *tmp75
   252 set :compute.0:correction *tmp76
   253 op add :compute.0:i :compute.0:i :compute.0:correction
-    * set *tmp71 :compute.0:i
   254 jump *label58 always
   255 label *label57
-    * set *tmp71 null
   256 label *label58
   257 set *tmp41 :compute.0:i
   258 jump *label45 always
 
   333 label *label64
   334 set *tmp79 *tmp80
   335 label *label63
-    * set *tmp77 *tmp79
   336 jump *label61 always
   337 label *label60
   338 set *tmp111 :drawPixel.0:iterations
   339 read *tmp112 .memory *tmp111
   340 draw col *tmp112
-    * set *tmp77 null
   341 label *label61
   342 draw rect :drawPixel.0:x :drawPixel.0:y 1 1
   343 drawflush .display
 
   347 op notEqual *tmp115 *tmp114 .PROCESSOR_ID
   348 jump *label71 equal *tmp115 false
   349 jump *label44 always
-    * set *tmp116 null
   350 jump *label72 always
   351 label *label71
-    * set *tmp116 null
   352 label *label72
   353 read *tmp1 .memory 65
   354 op notEqual *tmp117 .stop *tmp1
   355 jump *label73 equal *tmp117 false
   356 jump *label39 always
-    * set *tmp118 null
   357 jump *label74 always
   358 label *label73
-    * set *tmp118 null
   359 label *label74
   360 label *label43
   361 op add :y :y 1
   362 jump *label42 always
   363 label *label44
-    * set *tmp38 null
   364 jump *label41 always
   365 label *label40
-    * set *tmp38 null
   366 label *label41
   367 op add :line :line :increment
   368 op greaterThan *tmp119 :line 176
 
   371 set :increment :next_increment
   372 op div *tmp121 :increment 2
   373 set :line *tmp121
-    * set *tmp120 :line
   374 jump *label76 always
   375 label *label75
-    * set *tmp120 null
   376 label *label76
   377 label *label38
   378 op add :lines :lines 1
 
   394 set *tmp127 .PROC_STATE_INDEX
   395 write :setState.0:state .memory *tmp127
   396 jump *label80 always
-    * set *tmp126 null
   397 jump *label82 always
   398 label *label81
   399 set *tmp129 .PROC_ID_INDEX
 
   412 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
   413 set *tmp132 .PROC_STATE_INDEX
   414 label *label84
-    * set *tmp126 *tmp132
   415 label *label82
   416 label *label79
   417 jump *label78 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-8 instructions):
 
    60 op equal *tmp20 :findLinkedBlocks.0:requested @message
    61 jump *label20 equal *tmp20 false
    62 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
-    * set *tmp21 :findLinkedBlocks.0:message
    63 jump *label21 always
    64 label *label20
-    * set *tmp21 null
    65 label *label21
    66 jump *label19 always
    67 label *label18
 
   207 jump *label50 equal *tmp57 false
   208 set *tmp41 63
   209 jump *label45 always
-    * set *tmp58 null
   210 jump *label51 always
   211 label *label50
-    * set *tmp58 null
   212 label *label51
   213 label *label47
   214 set :compute.0:i 0
 
   262 op equal *tmp78 :drawPixel.0:iterations 63
   263 jump *label62 equal *tmp78 false
   264 draw color 0 0 0 255
-    * set *tmp79 null
   265 jump *label63 always
   266 label *label62
   267 jump *label66 equal .PALETTE 2
 
   326 draw color :drawPixel.0:r :drawPixel.0:r 0 255
   327 set *tmp80 null
   328 label *label64
-    * set *tmp79 *tmp80
   329 label *label63
   330 jump *label61 always
   331 label *label60
 
   399 set *tmp135 .PROC_STATE_INDEX
   400 write :setState.0:state .memory *tmp135
   401 jump *label80 always
-    * set *tmp132 null
   402 jump *label84 always
   403 label *label83
   404 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   405 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * set *tmp132 .PROC_STATE_INDEX
   406 label *label84
   407 label *label82
   408 label *label79

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   283 op add *tmp93 120 *tmp92
   284 set :drawPixel.0:b *tmp93
   285 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
-    * set *tmp80 null
   286 jump *label64 always
   287 label *label65
   288 jump *label68 equal .PALETTE 3
 
   304 op add *tmp105 100 *tmp104
   305 set :drawPixel.0:b *tmp105
   306 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
-    * set *tmp80 null
   307 jump *label64 always
   308 label *label67
   309 jump *label70 equal .PALETTE 4
 
   315 op add *tmp108 96 *tmp107
   316 set :drawPixel.0:g *tmp108
   317 draw color :drawPixel.0:r :drawPixel.0:g 0 255
-    * set *tmp80 null
   318 jump *label64 always
   319 label *label69
   320 op mul *tmp109 4 :drawPixel.0:iterations
   321 op sub *tmp110 255 *tmp109
   322 set :drawPixel.0:r *tmp110
   323 draw color :drawPixel.0:r :drawPixel.0:r 0 255
-    * set *tmp80 null
   324 label *label64
   325 label *label63
   326 jump *label61 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-39 instructions):
     0 sensor *tmp9 @this @x
     1 sensor *tmp10 @this @y
     2 op mul *tmp11 10000 *tmp10
-    * op add *tmp12 *tmp9 *tmp11
-    * set .PROCESSOR_ID *tmp12
+    3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
 
    33 op greaterThan *tmp14 :findLinkedBlocks.0:n 0
    34 jump *label12 equal *tmp14 false
    35 op sub :findLinkedBlocks.0:n :findLinkedBlocks.0:n 1
-    * getlink *tmp15 :findLinkedBlocks.0:n
-    * set :findLinkedBlocks.0:block *tmp15
+   36 getlink :findLinkedBlocks.0:block :findLinkedBlocks.0:n
    37 print "\nFound: "
    38 print :findLinkedBlocks.0:block
-    * sensor *tmp16 :findLinkedBlocks.0:block @type
-    * set :findLinkedBlocks.0:type *tmp16
+   39 sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @type
    40 setaddr *tmp17 *label16
    41 set :findLinkedBlocks.0:requested @large-logic-display
    42 set :findLinkedBlocks.0:name "Display"
 
   127 setaddr :setState.0*retaddr *label36
   128 call *label0 :setState.0*retval
   129 label *label36
-    * read *tmp4 .memory 68
-    * set .ZOOM *tmp4
+  130 read .ZOOM .memory 68
   131 op div *tmp26 -88 .ZOOM
   132 read *tmp2 .memory 66
-    * op add *tmp27 *tmp26 *tmp2
-    * set .OFFSET_X *tmp27
+  133 op add .OFFSET_X *tmp26 *tmp2
   134 op div *tmp28 -88 .ZOOM
   135 read *tmp3 .memory 67
-    * op add *tmp29 *tmp28 *tmp3
-    * set .OFFSET_Y *tmp29
-    * read *tmp5 .memory 69
-    * set .JULIA *tmp5
-    * read *tmp6 .memory 70
-    * set .JULIA_X *tmp6
-    * read *tmp7 .memory 71
-    * set .JULIA_Y *tmp7
-    * read *tmp8 .memory 72
-    * set .PALETTE *tmp8
-    * op greaterThan *tmp30 .PALETTE 1
-    * set .SMOOTH *tmp30
+  136 op add .OFFSET_Y *tmp28 *tmp3
+  137 read .JULIA .memory 69
+  138 read .JULIA_X .memory 70
+  139 read .JULIA_Y .memory 71
+  140 read .PALETTE .memory 72
+  141 op greaterThan .SMOOTH .PALETTE 1
   142 set :line 8
   143 set :increment 8
   144 set :next_increment 16
 
   148 label *label37
   149 jump *label39 greaterThanEq :lines 176
   150 op mul *tmp32 17 :line
-    * op mod *tmp33 *tmp32 176
-    * set :x *tmp33
-    * op add *tmp34 :x 158
-    * set :position *tmp34
-    * set *tmp35 :position
-    * read *tmp36 .memory *tmp35
+  151 op mod :x *tmp32 176
+  152 op add :position :x 158
+  153 read *tmp36 .memory :position
   154 op equal *tmp37 *tmp36 0
   155 jump *label40 equal *tmp37 false
-    * set *tmp39 :position
-    * write .PROCESSOR_ID .memory *tmp39
+  156 write .PROCESSOR_ID .memory :position
   157 set :y 0
   158 label *label42
   159 jump *label44 greaterThanEq :y 176
   160 set :compute.0:x :x
   161 set :compute.0:y :y
   162 op div *tmp42 :compute.0:x .ZOOM
-    * op add *tmp43 *tmp42 .OFFSET_X
-    * set :compute.0:zx *tmp43
+  163 op add :compute.0:zx *tmp42 .OFFSET_X
   164 op div *tmp44 :compute.0:y .ZOOM
-    * op add *tmp45 *tmp44 .OFFSET_Y
-    * set :compute.0:zy *tmp45
+  165 op add :compute.0:zy *tmp44 .OFFSET_Y
   166 jump *label46 equal .JULIA false
   167 set :compute.0:cx .JULIA_X
   168 set :compute.0:cy .JULIA_Y
 
   171 set :compute.0:cx :compute.0:zx
   172 set :compute.0:cy :compute.0:zy
   173 op sub *tmp47 :compute.0:cx 0.25
-    * op len *tmp48 *tmp47 :compute.0:cy
-    * set :compute.0:p *tmp48
+  174 op len :compute.0:p *tmp47 :compute.0:cy
   175 op mul *tmp49 2 :compute.0:p
   176 op mul *tmp50 *tmp49 :compute.0:p
   177 op sub *tmp51 :compute.0:p *tmp50
 
   201 op mul *tmp59 :compute.0:x1 :compute.0:x1
   202 op mul *tmp60 :compute.0:y1 :compute.0:y1
   203 op sub *tmp61 *tmp59 *tmp60
-    * op add *tmp62 *tmp61 :compute.0:cx
-    * set :compute.0:zx *tmp62
+  204 op add :compute.0:zx *tmp61 :compute.0:cx
   205 op mul *tmp63 2 :compute.0:x1
   206 op mul *tmp64 *tmp63 :compute.0:y1
-    * op add *tmp65 *tmp64 :compute.0:cy
-    * set :compute.0:zy *tmp65
-    * op len *tmp66 :compute.0:zx :compute.0:zy
-    * set :compute.0:dist *tmp66
+  207 op add :compute.0:zy *tmp64 :compute.0:cy
+  208 op len :compute.0:dist :compute.0:zx :compute.0:zy
   209 op greaterThanEq *tmp67 :compute.0:dist 64
   210 jump *label55 equal *tmp67 false
   211 jump *label54 always
 
   223 op mul *tmp73 *tmp72 0.36067376022224085
   224 op log *tmp74 *tmp73
   225 op mul *tmp75 *tmp74 1.4426950408889634
-    * op sub *tmp76 4 *tmp75
-    * set :compute.0:correction *tmp76
+  226 op sub :compute.0:correction 4 *tmp75
   227 op add :compute.0:i :compute.0:i :compute.0:correction
   228 jump *label58 always
   229 label *label57
 
   248 op sub *tmp82 32 :drawPixel.0:iterations
   249 op abs *tmp83 *tmp82
   250 op mul *tmp84 7 *tmp83
-    * op sub *tmp85 255 *tmp84
-    * set :drawPixel.0:r *tmp85
+  251 op sub :drawPixel.0:r 255 *tmp84
   252 op sub *tmp86 :drawPixel.0:iterations 32
   253 op abs *tmp87 *tmp86
   254 op mul *tmp88 6 *tmp87
-    * op sub *tmp89 240 *tmp88
-    * set :drawPixel.0:g *tmp89
+  255 op sub :drawPixel.0:g 240 *tmp88
   256 op sub *tmp90 32 :drawPixel.0:iterations
   257 op abs *tmp91 *tmp90
   258 op mul *tmp92 4 *tmp91
-    * op add *tmp93 120 *tmp92
-    * set :drawPixel.0:b *tmp93
+  259 op add :drawPixel.0:b 120 *tmp92
   260 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   261 jump *label64 always
   262 label *label65
 
   266 op div *tmp94 :drawPixel.0:iterations 63
   267 op mul *tmp95 *tmp94 360
   268 op sin *tmp96 *tmp95
-    * op mul *tmp97 255 *tmp96
-    * set :drawPixel.0:r *tmp97
+  269 op mul :drawPixel.0:r 255 *tmp96
   270 op div *tmp98 :drawPixel.0:iterations 63
   271 op mul *tmp99 *tmp98 360
   272 op cos *tmp100 *tmp99
-    * op mul *tmp101 255 *tmp100
-    * set :drawPixel.0:g *tmp101
+  273 op mul :drawPixel.0:g 255 *tmp100
   274 op sub *tmp102 :drawPixel.0:iterations 32
   275 op abs *tmp103 *tmp102
   276 op mul *tmp104 4 *tmp103
-    * op add *tmp105 100 *tmp104
-    * set :drawPixel.0:b *tmp105
+  277 op add :drawPixel.0:b 100 *tmp104
   278 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   279 jump *label64 always
   280 label *label67
   281 jump *label70 equal .PALETTE 4
   282 jump *label69 always
   283 label *label70
-    * op mul *tmp106 4 :drawPixel.0:iterations
-    * set :drawPixel.0:r *tmp106
+  284 op mul :drawPixel.0:r 4 :drawPixel.0:iterations
   285 op mul *tmp107 1.5 :drawPixel.0:iterations
-    * op add *tmp108 96 *tmp107
-    * set :drawPixel.0:g *tmp108
+  286 op add :drawPixel.0:g 96 *tmp107
   287 draw color :drawPixel.0:r :drawPixel.0:g 0 255
   288 jump *label64 always
   289 label *label69
   290 op mul *tmp109 4 :drawPixel.0:iterations
-    * op sub *tmp110 255 *tmp109
-    * set :drawPixel.0:r *tmp110
+  291 op sub :drawPixel.0:r 255 *tmp109
   292 draw color :drawPixel.0:r :drawPixel.0:r 0 255
   293 label *label64
   294 label *label63
   295 jump *label61 always
   296 label *label60
-    * set *tmp111 :drawPixel.0:iterations
-    * read *tmp112 .memory *tmp111
+  297 read *tmp112 .memory :drawPixel.0:iterations
   298 draw col *tmp112
   299 label *label61
   300 draw rect :drawPixel.0:x :drawPixel.0:y 1 1
   301 drawflush .display
   302 label *label59
-    * set *tmp113 :position
-    * read *tmp114 .memory *tmp113
+  303 read *tmp114 .memory :position
   304 op notEqual *tmp115 *tmp114 .PROCESSOR_ID
   305 jump *label71 equal *tmp115 false
   306 jump *label44 always
 
   326 jump *label75 equal *tmp119 false
   327 op div :next_increment :next_increment 2
   328 set :increment :next_increment
-    * op div *tmp121 :increment 2
-    * set :line *tmp121
+  329 op div :line :increment 2
   330 jump *label76 always
   331 label *label75
   332 label *label76
 
   343 label *label78
   344 op lessThan *tmp122 .PROC_STATE_INDEX 512
   345 jump *label80 equal *tmp122 false
-    * set *tmp123 .PROC_ID_INDEX
-    * read *tmp124 .memory *tmp123
+  346 read *tmp124 .memory .PROC_ID_INDEX
   347 op equal *tmp125 *tmp124 .PROCESSOR_ID
   348 jump *label81 equal *tmp125 false
-    * set *tmp127 .PROC_STATE_INDEX
-    * write :setState.0:state .memory *tmp127
+  349 write :setState.0:state .memory .PROC_STATE_INDEX
   350 jump *label80 always
   351 jump *label82 always
   352 label *label81
-    * set *tmp129 .PROC_ID_INDEX
-    * read *tmp130 .memory *tmp129
+  353 read *tmp130 .memory .PROC_ID_INDEX
   354 op equal *tmp131 *tmp130 0
   355 jump *label83 equal *tmp131 false
-    * set *tmp133 .PROC_ID_INDEX
-    * write .PROCESSOR_ID .memory *tmp133
-    * set *tmp135 .PROC_STATE_INDEX
-    * write :setState.0:state .memory *tmp135
+  356 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  357 write :setState.0:state .memory .PROC_STATE_INDEX
   358 jump *label80 always
   359 jump *label84 always
   360 label *label83

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
   108 label *label4
   109 label *label1
   110 label *label29
-    * jump *label31 equal true false
   111 label *label32
   112 set :setState.0:state 0
   113 setaddr :setState.0*retaddr *label35

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   241 draw color 0 0 0 255
   242 jump *label63 always
   243 label *label62
-    * jump *label66 equal .PALETTE 2
-    * jump *label65 always
+  244 jump *label65 notEqual .PALETTE 2
   245 label *label66
   246 op sub *tmp82 32 :drawPixel.0:iterations
   247 op abs *tmp83 *tmp82
 
   258 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   259 jump *label64 always
   260 label *label65
-    * jump *label68 equal .PALETTE 3
-    * jump *label67 always
+  261 jump *label67 notEqual .PALETTE 3
   262 label *label68
   263 op div *tmp94 :drawPixel.0:iterations 63
   264 op mul *tmp95 *tmp94 360
 
   275 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   276 jump *label64 always
   277 label *label67
-    * jump *label70 equal .PALETTE 4
-    * jump *label69 always
+  278 jump *label69 notEqual .PALETTE 4
   279 label *label70
   280 op mul :drawPixel.0:r 4 :drawPixel.0:iterations
   281 op mul *tmp107 1.5 :drawPixel.0:iterations

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-17 instructions):
 
    30 print :findLinkedBlocks.0:title
    31 set :findLinkedBlocks.0:n @links
    32 label *label10
-    * op greaterThan *tmp14 :findLinkedBlocks.0:n 0
-    * jump *label12 equal *tmp14 false
+   33 jump *label12 lessThanEq :findLinkedBlocks.0:n 0
    34 op sub :findLinkedBlocks.0:n :findLinkedBlocks.0:n 1
    35 getlink :findLinkedBlocks.0:block :findLinkedBlocks.0:n
    36 print "\nFound: "
 
    50 set :findLinkedBlocks.0:variable .memory
    51 set :findLinkedBlocks.0:required true
    52 label *label13
-    * op equal *tmp18 :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
-    * jump *label18 equal *tmp18 false
+   53 jump *label18 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
    54 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * op equal *tmp20 :findLinkedBlocks.0:requested @message
-    * jump *label20 equal *tmp20 false
+   55 jump *label20 notEqual :findLinkedBlocks.0:requested @message
    56 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    57 jump *label21 always
    58 label *label20
 
   100 label *label24
   101 printflush :findLinkedBlocks.0:message
   102 label *label3
-    * op equal *tmp24 :findLinkedBlocks.0:foundAll false
-    * jump *label2 notEqual *tmp24 false
+  103 jump *label2 equal :findLinkedBlocks.0:foundAll false
   104 label *label4
   105 label *label1
   106 label *label29
 
   111 label *label35
   112 label *label33
   113 read *tmp0 .memory 64
-    * op equal *tmp25 .start *tmp0
-    * jump *label32 notEqual *tmp25 false
+  114 jump *label32 equal .start *tmp0
   115 label *label34
   116 read *tmp0 .memory 64
   117 set .start *tmp0
 
   145 op mod :x *tmp32 176
   146 op add :position :x 158
   147 read *tmp36 .memory :position
-    * op equal *tmp37 *tmp36 0
-    * jump *label40 equal *tmp37 false
+  148 jump *label40 notEqual *tmp36 0
   149 write .PROCESSOR_ID .memory :position
   150 set :y 0
   151 label *label42
 
   169 op mul *tmp50 *tmp49 :compute.0:p
   170 op sub *tmp51 :compute.0:p *tmp50
   171 op add *tmp52 *tmp51 0.25
-    * op lessThanEq *tmp53 :compute.0:cx *tmp52
-    * jump *label48 equal *tmp53 false
+  172 jump *label48 greaterThan :compute.0:cx *tmp52
   173 set *tmp41 63
   174 jump *label45 always
   175 jump *label49 always
 
   177 label *label49
   178 op add *tmp55 :compute.0:cx 1
   179 op len *tmp56 *tmp55 :compute.0:cy
-    * op lessThanEq *tmp57 *tmp56 0.25
-    * jump *label50 equal *tmp57 false
+  180 jump *label50 greaterThan *tmp56 0.25
   181 set *tmp41 63
   182 jump *label45 always
   183 jump *label51 always
 
   197 op mul *tmp64 *tmp63 :compute.0:y1
   198 op add :compute.0:zy *tmp64 :compute.0:cy
   199 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * op greaterThanEq *tmp67 :compute.0:dist 64
-    * jump *label55 equal *tmp67 false
+  200 jump *label55 lessThan :compute.0:dist 64
   201 jump *label54 always
   202 jump *label56 always
   203 label *label55
 
   207 jump *label52 always
   208 label *label54
   209 op mul *tmp69 .SMOOTH 63
-    * op lessThan *tmp70 :compute.0:i *tmp69
-    * jump *label57 equal *tmp70 false
+  210 jump *label57 greaterThanEq :compute.0:i *tmp69
   211 op log *tmp72 :compute.0:dist
   212 op mul *tmp73 *tmp72 0.36067376022224085
   213 op log *tmp74 *tmp73
 
   226 set :drawPixel.0:y :y
   227 set :drawPixel.0:iterations :iterations
   228 jump *label60 equal .SMOOTH false
-    * op equal *tmp78 :drawPixel.0:iterations 63
-    * jump *label62 equal *tmp78 false
+  229 jump *label62 notEqual :drawPixel.0:iterations 63
   230 draw color 0 0 0 255
   231 jump *label63 always
   232 label *label62
 
   286 drawflush .display
   287 label *label59
   288 read *tmp114 .memory :position
-    * op notEqual *tmp115 *tmp114 .PROCESSOR_ID
-    * jump *label71 equal *tmp115 false
+  289 jump *label71 equal *tmp114 .PROCESSOR_ID
   290 jump *label44 always
   291 jump *label72 always
   292 label *label71
   293 label *label72
   294 read *tmp1 .memory 65
-    * op notEqual *tmp117 .stop *tmp1
-    * jump *label73 equal *tmp117 false
+  295 jump *label73 equal .stop *tmp1
   296 jump *label39 always
   297 jump *label74 always
   298 label *label73
 
   305 label *label40
   306 label *label41
   307 op add :line :line :increment
-    * op greaterThan *tmp119 :line 176
-    * jump *label75 equal *tmp119 false
+  308 jump *label75 lessThanEq :line 176
   309 op div :next_increment :next_increment 2
   310 set :increment :next_increment
   311 op div :line :increment 2
 
   323 end
   324 label *label0
   325 label *label78
-    * op lessThan *tmp122 .PROC_STATE_INDEX 512
-    * jump *label80 equal *tmp122 false
+  326 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
   327 read *tmp124 .memory .PROC_ID_INDEX
-    * op equal *tmp125 *tmp124 .PROCESSOR_ID
-    * jump *label81 equal *tmp125 false
+  328 jump *label81 notEqual *tmp124 .PROCESSOR_ID
   329 write :setState.0:state .memory .PROC_STATE_INDEX
   330 jump *label80 always
   331 jump *label82 always
   332 label *label81
   333 read *tmp130 .memory .PROC_ID_INDEX
-    * op equal *tmp131 *tmp130 0
-    * jump *label83 equal *tmp131 false
+  334 jump *label83 notEqual *tmp130 0
   335 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   336 write :setState.0:state .memory .PROC_STATE_INDEX
   337 jump *label80 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-11 instructions):
 
    54 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
    55 jump *label20 notEqual :findLinkedBlocks.0:requested @message
    56 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
-    * jump *label21 always
    57 label *label20
    58 label *label21
-    * jump *label19 always
    59 label *label18
    60 label *label19
    61 label *label14
 
    88 print :findLinkedBlocks.0:variable
    89 jump *label27 equal :findLinkedBlocks.0:required false
    90 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
-    * jump *label28 always
    91 label *label27
    92 label *label28
    93 label *label23
 
   169 jump *label48 greaterThan :compute.0:cx *tmp52
   170 set *tmp41 63
   171 jump *label45 always
-    * jump *label49 always
   172 label *label48
   173 label *label49
   174 op add *tmp55 :compute.0:cx 1
 
   176 jump *label50 greaterThan *tmp56 0.25
   177 set *tmp41 63
   178 jump *label45 always
-    * jump *label51 always
   179 label *label50
   180 label *label51
   181 label *label47
 
   194 op len :compute.0:dist :compute.0:zx :compute.0:zy
   195 jump *label55 lessThan :compute.0:dist 64
   196 jump *label54 always
-    * jump *label56 always
   197 label *label55
   198 label *label56
   199 label *label53
 
   208 op mul *tmp75 *tmp74 1.4426950408889634
   209 op sub :compute.0:correction 4 *tmp75
   210 op add :compute.0:i :compute.0:i :compute.0:correction
-    * jump *label58 always
   211 label *label57
   212 label *label58
   213 set *tmp41 :compute.0:i
 
   281 read *tmp114 .memory :position
   282 jump *label71 equal *tmp114 .PROCESSOR_ID
   283 jump *label44 always
-    * jump *label72 always
   284 label *label71
   285 label *label72
   286 read *tmp1 .memory 65
   287 jump *label73 equal .stop *tmp1
   288 jump *label39 always
-    * jump *label74 always
   289 label *label73
   290 label *label74
   291 label *label43
   292 op add :y :y 1
   293 jump *label42 always
   294 label *label44
-    * jump *label41 always
   295 label *label40
   296 label *label41
   297 op add :line :line :increment
 
   299 op div :next_increment :next_increment 2
   300 set :increment :next_increment
   301 op div :line :increment 2
-    * jump *label76 always
   302 label *label75
   303 label *label76
   304 label *label38

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
-    * sensor *tmp9 @this @x
-    * sensor *tmp10 @this @y
+    0 set *tmp9 @thisx
+    1 set *tmp10 @thisy
     2 op mul *tmp11 10000 *tmp10
     3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
     0 set *tmp9 @thisx
     1 set *tmp10 @thisy
-    * op mul *tmp11 10000 *tmp10
-    * op add .PROCESSOR_ID *tmp9 *tmp11
+    2 op mul *tmp11 10000 @thisy
+    3 op add .PROCESSOR_ID @thisx *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
 
     8 set :findLinkedBlocks.0:message null
     9 label *label2
    10 setaddr *tmp13 *label8
-    * set :findLinkedBlocks.0:requested @large-logic-display
-    * set :findLinkedBlocks.0:name "Display"
-    * set :findLinkedBlocks.0:variable .display
-    * set :findLinkedBlocks.0:required true
    11 jump *label5 always
    12 multilabel *label8 marker0
-    * set .display :findLinkedBlocks.0:variable
+   13 set .display null
    14 setaddr *tmp13 *label9
-    * set :findLinkedBlocks.0:requested @memory-bank
-    * set :findLinkedBlocks.0:name "Memory"
-    * set :findLinkedBlocks.0:variable .memory
-    * set :findLinkedBlocks.0:required true
    15 label *label5
    16 set :findLinkedBlocks.0:variable null
    17 label *label6
    18 multijump *tmp13 0 0 marker0
    19 multilabel *label9 marker0
-    * set .memory :findLinkedBlocks.0:variable
+   20 set .memory null
    21 label *label7
-    * print :findLinkedBlocks.0:title
+   22 print "Mandelbrot Generator"
    23 set :findLinkedBlocks.0:n @links
    24 label *label10
    25 jump *label12 lessThanEq :findLinkedBlocks.0:n 0
 
    30 sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @type
    31 setaddr *tmp17 *label16
    32 set :findLinkedBlocks.0:requested @large-logic-display
-    * set :findLinkedBlocks.0:name "Display"
    33 set :findLinkedBlocks.0:variable .display
-    * set :findLinkedBlocks.0:required true
    34 jump *label13 always
    35 multilabel *label16 marker1
    36 set .display :findLinkedBlocks.0:variable
    37 setaddr *tmp17 *label17
    38 set :findLinkedBlocks.0:requested @memory-bank
-    * set :findLinkedBlocks.0:name "Memory"
    39 set :findLinkedBlocks.0:variable .memory
-    * set :findLinkedBlocks.0:required true
    40 label *label13
    41 jump *label18 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
    42 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
 
    56 label *label12
    57 set :findLinkedBlocks.0:foundAll 1
    58 setaddr *tmp22 *label25
-    * set :findLinkedBlocks.0:requested @large-logic-display
    59 set :findLinkedBlocks.0:name "Display"
    60 set :findLinkedBlocks.0:variable .display
    61 set :findLinkedBlocks.0:required true
 
    63 multilabel *label25 marker2
    64 set .display :findLinkedBlocks.0:variable
    65 setaddr *tmp22 *label26
-    * set :findLinkedBlocks.0:requested @memory-bank
    66 set :findLinkedBlocks.0:name "Memory"
    67 set :findLinkedBlocks.0:variable .memory
    68 set :findLinkedBlocks.0:required true
 
    72 print ":"
    73 print " "
    74 print :findLinkedBlocks.0:variable
-    * jump *label27 equal :findLinkedBlocks.0:required false
+   75 jump *label27 equal true false
    76 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
    77 label *label27
    78 label *label28
 
   100 set .start *tmp0
   101 read *tmp1 .memory 65
   102 set .stop *tmp1
-    * set :setState.0:state .start
+  103 set :setState.0:state *tmp0
   104 setaddr :setState.0*retaddr *label36
   105 call *label0 :setState.0*retval
   106 label *label36
 
   110 op add .OFFSET_X *tmp26 *tmp2
   111 op div *tmp28 -88 .ZOOM
   112 read *tmp3 .memory 67
-    * op add .OFFSET_Y *tmp28 *tmp3
+  113 op add .OFFSET_Y *tmp26 *tmp3
   114 read .JULIA .memory 69
   115 read .JULIA_X .memory 70
   116 read .JULIA_Y .memory 71
 
   135 jump *label44 greaterThanEq :y 176
   136 set :compute.0:x :x
   137 set :compute.0:y :y
-    * op div *tmp42 :compute.0:x .ZOOM
+  138 op div *tmp42 :x .ZOOM
   139 op add :compute.0:zx *tmp42 .OFFSET_X
-    * op div *tmp44 :compute.0:y .ZOOM
+  140 op div *tmp44 :y .ZOOM
   141 op add :compute.0:zy *tmp44 .OFFSET_Y
   142 jump *label46 equal .JULIA false
   143 set :compute.0:cx .JULIA_X
 
   146 label *label46
   147 set :compute.0:cx :compute.0:zx
   148 set :compute.0:cy :compute.0:zy
-    * op sub *tmp47 :compute.0:cx 0.25
-    * op len :compute.0:p *tmp47 :compute.0:cy
+  149 op sub *tmp47 :compute.0:zx 0.25
+  150 op len :compute.0:p *tmp47 :compute.0:zy
   151 op mul *tmp49 2 :compute.0:p
   152 op mul *tmp50 *tmp49 :compute.0:p
   153 op sub *tmp51 :compute.0:p *tmp50
   154 op add *tmp52 *tmp51 0.25
-    * jump *label48 greaterThan :compute.0:cx *tmp52
+  155 jump *label48 greaterThan :compute.0:zx *tmp52
   156 set *tmp41 63
   157 jump *label45 always
   158 label *label48
   159 label *label49
-    * op add *tmp55 :compute.0:cx 1
-    * op len *tmp56 *tmp55 :compute.0:cy
+  160 op add *tmp55 :compute.0:zx 1
+  161 op len *tmp56 *tmp55 :compute.0:zy
   162 jump *label50 greaterThan *tmp56 0.25
   163 set *tmp41 63
   164 jump *label45 always
 
   170 jump *label54 greaterThanEq :compute.0:i 63
   171 set :compute.0:x1 :compute.0:zx
   172 set :compute.0:y1 :compute.0:zy
-    * op mul *tmp59 :compute.0:x1 :compute.0:x1
-    * op mul *tmp60 :compute.0:y1 :compute.0:y1
+  173 op mul *tmp59 :compute.0:zx :compute.0:zx
+  174 op mul *tmp60 :compute.0:zy :compute.0:zy
   175 op sub *tmp61 *tmp59 *tmp60
   176 op add :compute.0:zx *tmp61 :compute.0:cx
   177 op mul *tmp63 2 :compute.0:x1
-    * op mul *tmp64 *tmp63 :compute.0:y1
+  178 op mul *tmp64 *tmp63 :compute.0:zy
   179 op add :compute.0:zy *tmp64 :compute.0:cy
   180 op len :compute.0:dist :compute.0:zx :compute.0:zy
   181 jump *label55 lessThan :compute.0:dist 64
 
   198 label *label58
   199 set *tmp41 :compute.0:i
   200 jump *label45 always
-    * set *tmp41 null
   201 label *label45
   202 set :iterations *tmp41
   203 set :drawPixel.0:x :x
   204 set :drawPixel.0:y :y
-    * set :drawPixel.0:iterations :iterations
+  205 set :drawPixel.0:iterations *tmp41
   206 jump *label60 equal .SMOOTH false
-    * jump *label62 notEqual :drawPixel.0:iterations 63
+  207 jump *label62 notEqual :iterations 63
   208 draw color 0 0 0 255
   209 jump *label63 always
   210 label *label62
   211 jump *label65 notEqual .PALETTE 2
   212 label *label66
-    * op sub *tmp82 32 :drawPixel.0:iterations
+  213 op sub *tmp82 32 :iterations
   214 op abs *tmp83 *tmp82
   215 op mul *tmp84 7 *tmp83
   216 op sub :drawPixel.0:r 255 *tmp84
-    * op sub *tmp86 :drawPixel.0:iterations 32
+  217 op sub *tmp86 :iterations 32
   218 op abs *tmp87 *tmp86
   219 op mul *tmp88 6 *tmp87
   220 op sub :drawPixel.0:g 240 *tmp88
-    * op sub *tmp90 32 :drawPixel.0:iterations
-    * op abs *tmp91 *tmp90
-    * op mul *tmp92 4 *tmp91
+  221 op sub *tmp90 32 :iterations
+  222 op abs *tmp91 *tmp82
+  223 op mul *tmp92 4 *tmp83
   224 op add :drawPixel.0:b 120 *tmp92
   225 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
   226 jump *label64 always
   227 label *label65
   228 jump *label67 notEqual .PALETTE 3
   229 label *label68
-    * op div *tmp94 :drawPixel.0:iterations 63
-    * op mul *tmp95 *tmp94 360
+  230 op div *tmp94 :iterations 63
+  231 op div *tmp95 :drawPixel.0:iterations 0.175
   232 op sin *tmp96 *tmp95
   233 op mul :drawPixel.0:r 255 *tmp96
-    * op div *tmp98 :drawPixel.0:iterations 63
-    * op mul *tmp99 *tmp98 360
-    * op cos *tmp100 *tmp99
+  234 op div *tmp98 :iterations 63
+  235 op mul *tmp99 *tmp94 360
+  236 op cos *tmp100 *tmp95
   237 op mul :drawPixel.0:g 255 *tmp100
-    * op sub *tmp102 :drawPixel.0:iterations 32
+  238 op sub *tmp102 :iterations 32
   239 op abs *tmp103 *tmp102
   240 op mul *tmp104 4 *tmp103
   241 op add :drawPixel.0:b 100 *tmp104
 
   244 label *label67
   245 jump *label69 notEqual .PALETTE 4
   246 label *label70
-    * op mul :drawPixel.0:r 4 :drawPixel.0:iterations
-    * op mul *tmp107 1.5 :drawPixel.0:iterations
+  247 op mul :drawPixel.0:r 4 :iterations
+  248 op mul *tmp107 1.5 :iterations
   249 op add :drawPixel.0:g 96 *tmp107
   250 draw color :drawPixel.0:r :drawPixel.0:g 0 255
   251 jump *label64 always
   252 label *label69
-    * op mul *tmp109 4 :drawPixel.0:iterations
+  253 op mul *tmp109 4 :iterations
   254 op sub :drawPixel.0:r 255 *tmp109
   255 draw color :drawPixel.0:r :drawPixel.0:r 0 255
   256 label *label64
   257 label *label63
   258 jump *label61 always
   259 label *label60
-    * read *tmp112 .memory :drawPixel.0:iterations
+  260 read *tmp112 .memory :iterations
   261 draw col *tmp112
   262 label *label61
-    * draw rect :drawPixel.0:x :drawPixel.0:y 1 1
+  263 draw rect :x :y 1 1
   264 drawflush .display
   265 label *label59
   266 read *tmp114 .memory :position
 
   283 jump *label75 lessThanEq :line 176
   284 op div :next_increment :next_increment 2
   285 set :increment :next_increment
-    * op div :line :increment 2
+  286 op div :line :next_increment 2
   287 label *label75
   288 label *label76
   289 label *label38

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-13 instructions):
-    * set *tmp9 @thisx
-    * set *tmp10 @thisy
     0 op mul *tmp11 10000 @thisy
     1 op add .PROCESSOR_ID @thisx *tmp11
     2 set .PROC_ID_INDEX 334
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
-    * set :findLinkedBlocks.0:title "Mandelbrot Generator"
     5 set :findLinkedBlocks.0:message null
     6 label *label2
     7 setaddr *tmp13 *label8
 
    10 set .display null
    11 setaddr *tmp13 *label9
    12 label *label5
-    * set :findLinkedBlocks.0:variable null
    13 label *label6
    14 multijump *tmp13 0 0 marker0
    15 multilabel *label9 marker0
 
    54 setaddr *tmp22 *label25
    55 set :findLinkedBlocks.0:name "Display"
    56 set :findLinkedBlocks.0:variable .display
-    * set :findLinkedBlocks.0:required true
    57 jump *label22 always
    58 multilabel *label25 marker2
    59 set .display :findLinkedBlocks.0:variable
    60 setaddr *tmp22 *label26
    61 set :findLinkedBlocks.0:name "Memory"
    62 set :findLinkedBlocks.0:variable .memory
-    * set :findLinkedBlocks.0:required true
    63 label *label22
    64 print "\n"
    65 print :findLinkedBlocks.0:name
 
   102 op div *tmp26 -88 .ZOOM
   103 read *tmp2 .memory 66
   104 op add .OFFSET_X *tmp26 *tmp2
-    * op div *tmp28 -88 .ZOOM
   105 read *tmp3 .memory 67
   106 op add .OFFSET_Y *tmp26 *tmp3
   107 read .JULIA .memory 69
 
   126 set :y 0
   127 label *label42
   128 jump *label44 greaterThanEq :y 176
-    * set :compute.0:x :x
-    * set :compute.0:y :y
   129 op div *tmp42 :x .ZOOM
   130 op add :compute.0:zx *tmp42 .OFFSET_X
   131 op div *tmp44 :y .ZOOM
 
   160 label *label52
   161 jump *label54 greaterThanEq :compute.0:i 63
   162 set :compute.0:x1 :compute.0:zx
-    * set :compute.0:y1 :compute.0:zy
   163 op mul *tmp59 :compute.0:zx :compute.0:zx
   164 op mul *tmp60 :compute.0:zy :compute.0:zy
   165 op sub *tmp61 *tmp59 *tmp60
 
   190 jump *label45 always
   191 label *label45
   192 set :iterations *tmp41
-    * set :drawPixel.0:x :x
-    * set :drawPixel.0:y :y
   193 set :drawPixel.0:iterations *tmp41
   194 jump *label60 equal .SMOOTH false
-    * jump *label62 notEqual :iterations 63
+  195 jump *label62 notEqual *tmp41 63
   196 draw color 0 0 0 255
   197 jump *label63 always
   198 label *label62
   199 jump *label65 notEqual .PALETTE 2
   200 label *label66
-    * op sub *tmp82 32 :iterations
+  201 op sub *tmp82 32 *tmp41
   202 op abs *tmp83 *tmp82
   203 op mul *tmp84 7 *tmp83
   204 op sub :drawPixel.0:r 255 *tmp84
-    * op sub *tmp86 :iterations 32
+  205 op sub *tmp86 *tmp41 32
   206 op abs *tmp87 *tmp86
   207 op mul *tmp88 6 *tmp87
   208 op sub :drawPixel.0:g 240 *tmp88
-    * op sub *tmp90 32 :iterations
-    * op abs *tmp91 *tmp82
+  209 op sub *tmp90 32 *tmp41
   210 op mul *tmp92 4 *tmp83
   211 op add :drawPixel.0:b 120 *tmp92
   212 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
 
   214 label *label65
   215 jump *label67 notEqual .PALETTE 3
   216 label *label68
-    * op div *tmp94 :iterations 63
-    * op div *tmp95 :drawPixel.0:iterations 0.175
+  217 op div *tmp94 *tmp41 63
+  218 op div *tmp95 *tmp41 0.175
   219 op sin *tmp96 *tmp95
   220 op mul :drawPixel.0:r 255 *tmp96
-    * op div *tmp98 :iterations 63
-    * op mul *tmp99 *tmp94 360
+  221 op div *tmp98 *tmp41 63
+  222 op div *tmp99 :iterations 0.175
   223 op cos *tmp100 *tmp95
   224 op mul :drawPixel.0:g 255 *tmp100
-    * op sub *tmp102 :iterations 32
+  225 op sub *tmp102 *tmp41 32
   226 op abs *tmp103 *tmp102
   227 op mul *tmp104 4 *tmp103
   228 op add :drawPixel.0:b 100 *tmp104
 
   231 label *label67
   232 jump *label69 notEqual .PALETTE 4
   233 label *label70
-    * op mul :drawPixel.0:r 4 :iterations
-    * op mul *tmp107 1.5 :iterations
+  234 op mul :drawPixel.0:r 4 *tmp41
+  235 op mul *tmp107 1.5 *tmp41
   236 op add :drawPixel.0:g 96 *tmp107
   237 draw color :drawPixel.0:r :drawPixel.0:g 0 255
   238 jump *label64 always
   239 label *label69
-    * op mul *tmp109 4 :iterations
+  240 op mul *tmp109 4 *tmp41
   241 op sub :drawPixel.0:r 255 *tmp109
   242 draw color :drawPixel.0:r :drawPixel.0:r 0 255
   243 label *label64
   244 label *label63
   245 jump *label61 always
   246 label *label60
-    * read *tmp112 .memory :iterations
+  247 read *tmp112 .memory *tmp41
   248 draw col *tmp112
   249 label *label61
   250 draw rect :x :y 1 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-4 instructions):
 
   190 jump *label45 always
   191 label *label45
   192 set :iterations *tmp41
-    * set :drawPixel.0:iterations *tmp41
   193 jump *label60 equal .SMOOTH false
   194 jump *label62 notEqual *tmp41 63
   195 draw color 0 0 0 255
 
   205 op abs *tmp87 *tmp86
   206 op mul *tmp88 6 *tmp87
   207 op sub :drawPixel.0:g 240 *tmp88
-    * op sub *tmp90 32 *tmp41
   208 op mul *tmp92 4 *tmp83
   209 op add :drawPixel.0:b 120 *tmp92
   210 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
 
   212 label *label65
   213 jump *label67 notEqual .PALETTE 3
   214 label *label68
-    * op div *tmp94 *tmp41 63
   215 op div *tmp95 *tmp41 0.175
   216 op sin *tmp96 *tmp95
   217 op mul :drawPixel.0:r 255 *tmp96
-    * op div *tmp98 *tmp41 63
-    * op div *tmp99 :iterations 0.175
+  218 op div *tmp99 *tmp41 0.175
   219 op cos *tmp100 *tmp95
   220 op mul :drawPixel.0:g 255 *tmp100
   221 op sub *tmp102 *tmp41 32

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   189 set *tmp41 :compute.0:i
   190 jump *label45 always
   191 label *label45
-    * set :iterations *tmp41
   192 jump *label60 equal .SMOOTH false
   193 jump *label62 notEqual *tmp41 63
   194 draw color 0 0 0 255
 
   214 op div *tmp95 *tmp41 0.175
   215 op sin *tmp96 *tmp95
   216 op mul :drawPixel.0:r 255 *tmp96
-    * op div *tmp99 *tmp41 0.175
   217 op cos *tmp100 *tmp95
   218 op mul :drawPixel.0:g 255 *tmp100
   219 op sub *tmp102 *tmp41 32

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-3 instructions):
 
    19 set :findLinkedBlocks.0:n @links
    20 label *label10
    21 jump *label12 lessThanEq :findLinkedBlocks.0:n 0
+   22 label *label85
    23 op sub :findLinkedBlocks.0:n :findLinkedBlocks.0:n 1
    24 getlink :findLinkedBlocks.0:block :findLinkedBlocks.0:n
    25 print "\nFound: "
 
    49 set .memory :findLinkedBlocks.0:variable
    50 label *label15
    51 label *label11
-    * jump *label10 always
+   52 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    53 label *label12
    54 set :findLinkedBlocks.0:foundAll 1
    55 setaddr *tmp22 *label25
 
   117 wait *tmp31
   118 set :lines 0
   119 label *label37
-    * jump *label39 greaterThanEq :lines 176
+  120 label *label86
   121 op mul *tmp32 17 :line
   122 op mod :x *tmp32 176
   123 op add :position :x 158
 
   126 write .PROCESSOR_ID .memory :position
   127 set :y 0
   128 label *label42
-    * jump *label44 greaterThanEq :y 176
+  129 label *label87
   130 op div *tmp42 :x .ZOOM
   131 op add :compute.0:zx *tmp42 .OFFSET_X
   132 op div *tmp44 :y .ZOOM
 
   159 label *label47
   160 set :compute.0:i 0
   161 label *label52
-    * jump *label54 greaterThanEq :compute.0:i 63
+  162 label *label88
   163 set :compute.0:x1 :compute.0:zx
   164 op mul *tmp59 :compute.0:zx :compute.0:zx
   165 op mul *tmp60 :compute.0:zy :compute.0:zy
 
   175 label *label56
   176 label *label53
   177 op add :compute.0:i :compute.0:i 1
-    * jump *label52 always
+  178 jump *label88 lessThan :compute.0:i 63
   179 label *label54
   180 op mul *tmp69 .SMOOTH 63
   181 jump *label57 greaterThanEq :compute.0:i *tmp69
 
   257 label *label74
   258 label *label43
   259 op add :y :y 1
-    * jump *label42 always
+  260 jump *label87 lessThan :y 176
   261 label *label44
   262 label *label40
   263 label *label41
 
   270 label *label76
   271 label *label38
   272 op add :lines :lines 1
-    * jump *label37 always
+  273 jump *label86 lessThan :lines 176
   274 label *label39
   275 drawflush .display
   276 label *label30
 
   280 label *label0
   281 label *label78
   282 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
+  283 label *label89
   284 read *tmp124 .memory .PROC_ID_INDEX
   285 jump *label81 notEqual *tmp124 .PROCESSOR_ID
   286 write :setState.0:state .memory .PROC_STATE_INDEX
 
   299 label *label84
   300 label *label82
   301 label *label79
-    * jump *label78 always
+  302 jump *label89 lessThan .PROC_STATE_INDEX 512
   303 label *label80
   304 label *label77
   305 return :setState.0*retaddr

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
 
     4 set .start 0
     5 set :findLinkedBlocks.0:message null
     6 label *label2
-    * setaddr *tmp13 *label8
-    * jump *label5 always
-    * multilabel *label8 marker0
-    * set .display null
-    * setaddr *tmp13 *label9
-    * label *label5
-    * label *label6
-    * multijump *tmp13 0 0 marker0
-    * multilabel *label9 marker0
-    * set .memory null
-    * label *label7
+    7 label *label90
+    8 label *label91
+    9 set .display null
+   10 label *label94
+   11 label *label95
+   12 set .memory null
+   13 label *label7
    14 print "Mandelbrot Generator"
    15 set :findLinkedBlocks.0:n @links
    16 label *label10

Modifications by Unroll iteration loop at *blocks:68:13:
 
    21 print "\nFound: "
    22 print :findLinkedBlocks.0:block
    23 sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @type
-    * setaddr *tmp17 *label16
-    * set :findLinkedBlocks.0:requested @large-logic-display
-    * set :findLinkedBlocks.0:variable .display
-    * jump *label13 always
-    * multilabel *label16 marker1
-    * set .display :findLinkedBlocks.0:variable
-    * setaddr *tmp17 *label17
-    * set :findLinkedBlocks.0:requested @memory-bank
-    * set :findLinkedBlocks.0:variable .memory
-    * label *label13
-    * jump *label18 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
-    * set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * jump *label20 notEqual :findLinkedBlocks.0:requested @message
-    * set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
-    * label *label20
-    * label *label21
-    * label *label18
-    * label *label19
-    * label *label14
-    * multijump *tmp17 0 0 marker1
-    * multilabel *label17 marker1
-    * set .memory :findLinkedBlocks.0:variable
-    * label *label15
+   24 set :findLinkedBlocks.0:requested @large-logic-display
+   25 set :findLinkedBlocks.0:variable .display
+   26 label *label99
+   27 jump *label102 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
+   28 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
+   29 jump *label100 notEqual :findLinkedBlocks.0:requested @message
+   30 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
+   31 label *label100
+   32 label *label101
+   33 label *label102
+   34 label *label103
+   35 label *label104
+   36 set .display :findLinkedBlocks.0:variable
+   37 set :findLinkedBlocks.0:requested @memory-bank
+   38 set :findLinkedBlocks.0:variable .memory
+   39 label *label107
+   40 jump *label110 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
+   41 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
+   42 jump *label108 notEqual :findLinkedBlocks.0:requested @message
+   43 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
+   44 label *label108
+   45 label *label109
+   46 label *label110
+   47 label *label111
+   48 label *label112
+   49 set .memory :findLinkedBlocks.0:variable
+   50 label *label15
    51 label *label11
    52 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    53 label *label12

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    24 set :findLinkedBlocks.0:requested @large-logic-display
    25 set :findLinkedBlocks.0:variable .display
    26 label *label99
-    * jump *label102 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
+   27 jump *label102 notEqual @large-logic-display :findLinkedBlocks.0:type
    28 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * jump *label100 notEqual :findLinkedBlocks.0:requested @message
+   29 jump *label100 notEqual @large-logic-display @message
    30 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    31 label *label100
    32 label *label101
 
    37 set :findLinkedBlocks.0:requested @memory-bank
    38 set :findLinkedBlocks.0:variable .memory
    39 label *label107
-    * jump *label110 notEqual :findLinkedBlocks.0:requested :findLinkedBlocks.0:type
+   40 jump *label110 notEqual @memory-bank :findLinkedBlocks.0:type
    41 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * jump *label108 notEqual :findLinkedBlocks.0:requested @message
+   42 jump *label108 notEqual @memory-bank @message
    43 set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    44 label *label108
    45 label *label109

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks.0:block
    23 sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @type
-    * set :findLinkedBlocks.0:requested @large-logic-display
    24 set :findLinkedBlocks.0:variable .display
    25 label *label99
    26 jump *label102 notEqual @large-logic-display :findLinkedBlocks.0:type
    27 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
    28 jump *label100 notEqual @large-logic-display @message
-    * set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    29 label *label100
    30 label *label101
    31 label *label102
    32 label *label103
    33 label *label104
    34 set .display :findLinkedBlocks.0:variable
-    * set :findLinkedBlocks.0:requested @memory-bank
    35 set :findLinkedBlocks.0:variable .memory
    36 label *label107
    37 jump *label110 notEqual @memory-bank :findLinkedBlocks.0:type
    38 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
    39 jump *label108 notEqual @memory-bank @message
-    * set :findLinkedBlocks.0:message :findLinkedBlocks.0:block
    40 label *label108
    41 label *label109
    42 label *label110
 
    72 multilabel *label26 marker2
    73 set .memory :findLinkedBlocks.0:variable
    74 label *label24
-    * printflush :findLinkedBlocks.0:message
+   75 printflush null
    76 label *label3
    77 jump *label2 equal :findLinkedBlocks.0:foundAll false
    78 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
     2 set .PROC_ID_INDEX 334
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
-    * set :findLinkedBlocks.0:message null
     5 label *label2
     6 label *label90
     7 label *label91

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    47 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    48 label *label12
    49 set :findLinkedBlocks.0:foundAll 1
-    * setaddr *tmp22 *label25
-    * set :findLinkedBlocks.0:name "Display"
-    * set :findLinkedBlocks.0:variable .display
-    * jump *label22 always
-    * multilabel *label25 marker2
-    * set .display :findLinkedBlocks.0:variable
-    * setaddr *tmp22 *label26
-    * set :findLinkedBlocks.0:name "Memory"
-    * set :findLinkedBlocks.0:variable .memory
-    * label *label22
-    * print "\n"
-    * print :findLinkedBlocks.0:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks.0:variable
-    * jump *label27 equal true false
-    * op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
-    * label *label27
-    * label *label28
-    * label *label23
-    * multijump *tmp22 0 0 marker2
-    * multilabel *label26 marker2
-    * set .memory :findLinkedBlocks.0:variable
-    * label *label24
+   50 set :findLinkedBlocks.0:name "Display"
+   51 set :findLinkedBlocks.0:variable .display
+   52 label *label116
+   53 print "\n"
+   54 print :findLinkedBlocks.0:name
+   55 print ":"
+   56 print " "
+   57 print :findLinkedBlocks.0:variable
+   58 jump *label117 equal true false
+   59 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
+   60 label *label117
+   61 label *label118
+   62 label *label119
+   63 set .display :findLinkedBlocks.0:variable
+   64 set :findLinkedBlocks.0:name "Memory"
+   65 set :findLinkedBlocks.0:variable .memory
+   66 label *label122
+   67 print "\n"
+   68 print :findLinkedBlocks.0:name
+   69 print ":"
+   70 print " "
+   71 print :findLinkedBlocks.0:variable
+   72 jump *label123 equal true false
+   73 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
+   74 label *label123
+   75 label *label124
+   76 label *label125
+   77 set .memory :findLinkedBlocks.0:variable
+   78 label *label24
    79 printflush null
    80 label *label3
    81 jump *label2 equal :findLinkedBlocks.0:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    51 set :findLinkedBlocks.0:variable .display
    52 label *label116
    53 print "\n"
-    * print :findLinkedBlocks.0:name
+   54 print "Display"
    55 print ":"
    56 print " "
-    * print :findLinkedBlocks.0:variable
+   57 print .display
    58 jump *label117 equal true false
-    * op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
+   59 op and :findLinkedBlocks.0:foundAll 1 .display
    60 label *label117
    61 label *label118
    62 label *label119
-    * set .display :findLinkedBlocks.0:variable
+   63 set .display .display
    64 set :findLinkedBlocks.0:name "Memory"
    65 set :findLinkedBlocks.0:variable .memory
    66 label *label122
    67 print "\n"
-    * print :findLinkedBlocks.0:name
+   68 print "Memory"
    69 print ":"
    70 print " "
-    * print :findLinkedBlocks.0:variable
+   71 print .memory
    72 jump *label123 equal true false
-    * op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:variable
+   73 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll .memory
    74 label *label123
    75 label *label124
    76 label *label125
-    * set .memory :findLinkedBlocks.0:variable
+   77 set .memory .memory
    78 label *label24
    79 printflush null
    80 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    46 label *label11
    47 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    48 label *label12
-    * set :findLinkedBlocks.0:foundAll 1
-    * set :findLinkedBlocks.0:name "Display"
-    * set :findLinkedBlocks.0:variable .display
    49 label *label116
    50 print "\n"
    51 print "Display"
 
    58 label *label118
    59 label *label119
    60 set .display .display
-    * set :findLinkedBlocks.0:name "Memory"
-    * set :findLinkedBlocks.0:variable .memory
    61 label *label122
    62 print "\n"
    63 print "Memory"

Modifications by Unroll loop at mandelbrot-compute.mnd:132:5 (+743 instructions):
 
   152 label *label50
   153 label *label51
   154 label *label47
-    * set :compute.0:i 0
-    * label *label52
-    * label *label88
-    * set :compute.0:x1 :compute.0:zx
-    * op mul *tmp59 :compute.0:zx :compute.0:zx
-    * op mul *tmp60 :compute.0:zy :compute.0:zy
-    * op sub *tmp61 *tmp59 *tmp60
-    * op add :compute.0:zx *tmp61 :compute.0:cx
-    * op mul *tmp63 2 :compute.0:x1
-    * op mul *tmp64 *tmp63 :compute.0:zy
-    * op add :compute.0:zy *tmp64 :compute.0:cy
-    * op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label55 lessThan :compute.0:dist 64
-    * jump *label54 always
-    * label *label55
-    * label *label56
-    * label *label53
-    * op add :compute.0:i :compute.0:i 1
-    * jump *label88 lessThan :compute.0:i 63
-    * label *label54
+  155 set :compute.0:i 0
+  156 label *label129
+  157 label *label130
+  158 set :compute.0:x1 :compute.0:zx
+  159 op mul *tmp59 :compute.0:zx :compute.0:zx
+  160 op mul *tmp60 :compute.0:zy :compute.0:zy
+  161 op sub *tmp61 *tmp59 *tmp60
+  162 op add :compute.0:zx *tmp61 :compute.0:cx
+  163 op mul *tmp63 2 :compute.0:x1
+  164 op mul *tmp64 *tmp63 :compute.0:zy
+  165 op add :compute.0:zy *tmp64 :compute.0:cy
+  166 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  167 jump *label131 lessThan :compute.0:dist 64
+  168 jump *label54 always
+  169 label *label131
+  170 label *label132
+  171 label *label133
+  172 op add :compute.0:i :compute.0:i 1
+  173 label *label134
+  174 set :compute.0:x1 :compute.0:zx
+  175 op mul *tmp59 :compute.0:zx :compute.0:zx
+  176 op mul *tmp60 :compute.0:zy :compute.0:zy
+  177 op sub *tmp61 *tmp59 *tmp60
+  178 op add :compute.0:zx *tmp61 :compute.0:cx
+  179 op mul *tmp63 2 :compute.0:x1
+  180 op mul *tmp64 *tmp63 :compute.0:zy
+  181 op add :compute.0:zy *tmp64 :compute.0:cy
+  182 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  183 jump *label135 lessThan :compute.0:dist 64
+  184 jump *label54 always
+  185 label *label135
+  186 label *label136
+  187 label *label137
+  188 op add :compute.0:i :compute.0:i 1
+  189 label *label138
+  190 set :compute.0:x1 :compute.0:zx
+  191 op mul *tmp59 :compute.0:zx :compute.0:zx
+  192 op mul *tmp60 :compute.0:zy :compute.0:zy
+  193 op sub *tmp61 *tmp59 *tmp60
+  194 op add :compute.0:zx *tmp61 :compute.0:cx
+  195 op mul *tmp63 2 :compute.0:x1
+  196 op mul *tmp64 *tmp63 :compute.0:zy
+  197 op add :compute.0:zy *tmp64 :compute.0:cy
+  198 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  199 jump *label139 lessThan :compute.0:dist 64
+  200 jump *label54 always
+  201 label *label139
+  202 label *label140
+  203 label *label141
+  204 op add :compute.0:i :compute.0:i 1
+  205 label *label142
+  206 set :compute.0:x1 :compute.0:zx
+  207 op mul *tmp59 :compute.0:zx :compute.0:zx
+  208 op mul *tmp60 :compute.0:zy :compute.0:zy
+  209 op sub *tmp61 *tmp59 *tmp60
+  210 op add :compute.0:zx *tmp61 :compute.0:cx
+  211 op mul *tmp63 2 :compute.0:x1
+  212 op mul *tmp64 *tmp63 :compute.0:zy
+  213 op add :compute.0:zy *tmp64 :compute.0:cy
+  214 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  215 jump *label143 lessThan :compute.0:dist 64
+  216 jump *label54 always
+  217 label *label143
+  218 label *label144
+  219 label *label145
+  220 op add :compute.0:i :compute.0:i 1
+  221 label *label146
+  222 set :compute.0:x1 :compute.0:zx
+  223 op mul *tmp59 :compute.0:zx :compute.0:zx
+  224 op mul *tmp60 :compute.0:zy :compute.0:zy
+  225 op sub *tmp61 *tmp59 *tmp60
+  226 op add :compute.0:zx *tmp61 :compute.0:cx
+  227 op mul *tmp63 2 :compute.0:x1
+  228 op mul *tmp64 *tmp63 :compute.0:zy
+  229 op add :compute.0:zy *tmp64 :compute.0:cy
+  230 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  231 jump *label147 lessThan :compute.0:dist 64
+  232 jump *label54 always
+  233 label *label147
+  234 label *label148
+  235 label *label149
+  236 op add :compute.0:i :compute.0:i 1
+  237 label *label150
+  238 set :compute.0:x1 :compute.0:zx
+  239 op mul *tmp59 :compute.0:zx :compute.0:zx
+  240 op mul *tmp60 :compute.0:zy :compute.0:zy
+  241 op sub *tmp61 *tmp59 *tmp60
+  242 op add :compute.0:zx *tmp61 :compute.0:cx
+  243 op mul *tmp63 2 :compute.0:x1
+  244 op mul *tmp64 *tmp63 :compute.0:zy
+  245 op add :compute.0:zy *tmp64 :compute.0:cy
+  246 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  247 jump *label151 lessThan :compute.0:dist 64
+  248 jump *label54 always
+  249 label *label151
+  250 label *label152
+  251 label *label153
+  252 op add :compute.0:i :compute.0:i 1
+  253 label *label154
+  254 set :compute.0:x1 :compute.0:zx
+  255 op mul *tmp59 :compute.0:zx :compute.0:zx
+  256 op mul *tmp60 :compute.0:zy :compute.0:zy
+  257 op sub *tmp61 *tmp59 *tmp60
+  258 op add :compute.0:zx *tmp61 :compute.0:cx
+  259 op mul *tmp63 2 :compute.0:x1
+  260 op mul *tmp64 *tmp63 :compute.0:zy
+  261 op add :compute.0:zy *tmp64 :compute.0:cy
+  262 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  263 jump *label155 lessThan :compute.0:dist 64
+  264 jump *label54 always
+  265 label *label155
+  266 label *label156
+  267 label *label157
+  268 op add :compute.0:i :compute.0:i 1
+  269 label *label158
+  270 set :compute.0:x1 :compute.0:zx
+  271 op mul *tmp59 :compute.0:zx :compute.0:zx
+  272 op mul *tmp60 :compute.0:zy :compute.0:zy
+  273 op sub *tmp61 *tmp59 *tmp60
+  274 op add :compute.0:zx *tmp61 :compute.0:cx
+  275 op mul *tmp63 2 :compute.0:x1
+  276 op mul *tmp64 *tmp63 :compute.0:zy
+  277 op add :compute.0:zy *tmp64 :compute.0:cy
+  278 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  279 jump *label159 lessThan :compute.0:dist 64
+  280 jump *label54 always
+  281 label *label159
+  282 label *label160
+  283 label *label161
+  284 op add :compute.0:i :compute.0:i 1
+  285 label *label162
+  286 set :compute.0:x1 :compute.0:zx
+  287 op mul *tmp59 :compute.0:zx :compute.0:zx
+  288 op mul *tmp60 :compute.0:zy :compute.0:zy
+  289 op sub *tmp61 *tmp59 *tmp60
+  290 op add :compute.0:zx *tmp61 :compute.0:cx
+  291 op mul *tmp63 2 :compute.0:x1
+  292 op mul *tmp64 *tmp63 :compute.0:zy
+  293 op add :compute.0:zy *tmp64 :compute.0:cy
+  294 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  295 jump *label163 lessThan :compute.0:dist 64
+  296 jump *label54 always
+  297 label *label163
+  298 label *label164
+  299 label *label165
+  300 op add :compute.0:i :compute.0:i 1
+  301 label *label166
+  302 set :compute.0:x1 :compute.0:zx
+  303 op mul *tmp59 :compute.0:zx :compute.0:zx
+  304 op mul *tmp60 :compute.0:zy :compute.0:zy
+  305 op sub *tmp61 *tmp59 *tmp60
+  306 op add :compute.0:zx *tmp61 :compute.0:cx
+  307 op mul *tmp63 2 :compute.0:x1
+  308 op mul *tmp64 *tmp63 :compute.0:zy
+  309 op add :compute.0:zy *tmp64 :compute.0:cy
+  310 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  311 jump *label167 lessThan :compute.0:dist 64
+  312 jump *label54 always
+  313 label *label167
+  314 label *label168
+  315 label *label169
+  316 op add :compute.0:i :compute.0:i 1
+  317 label *label170
+  318 set :compute.0:x1 :compute.0:zx
+  319 op mul *tmp59 :compute.0:zx :compute.0:zx
+  320 op mul *tmp60 :compute.0:zy :compute.0:zy
+  321 op sub *tmp61 *tmp59 *tmp60
+  322 op add :compute.0:zx *tmp61 :compute.0:cx
+  323 op mul *tmp63 2 :compute.0:x1
+  324 op mul *tmp64 *tmp63 :compute.0:zy
+  325 op add :compute.0:zy *tmp64 :compute.0:cy
+  326 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  327 jump *label171 lessThan :compute.0:dist 64
+  328 jump *label54 always
+  329 label *label171
+  330 label *label172
+  331 label *label173
+  332 op add :compute.0:i :compute.0:i 1
+  333 label *label174
+  334 set :compute.0:x1 :compute.0:zx
+  335 op mul *tmp59 :compute.0:zx :compute.0:zx
+  336 op mul *tmp60 :compute.0:zy :compute.0:zy
+  337 op sub *tmp61 *tmp59 *tmp60
+  338 op add :compute.0:zx *tmp61 :compute.0:cx
+  339 op mul *tmp63 2 :compute.0:x1
+  340 op mul *tmp64 *tmp63 :compute.0:zy
+  341 op add :compute.0:zy *tmp64 :compute.0:cy
+  342 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  343 jump *label175 lessThan :compute.0:dist 64
+  344 jump *label54 always
+  345 label *label175
+  346 label *label176
+  347 label *label177
+  348 op add :compute.0:i :compute.0:i 1
+  349 label *label178
+  350 set :compute.0:x1 :compute.0:zx
+  351 op mul *tmp59 :compute.0:zx :compute.0:zx
+  352 op mul *tmp60 :compute.0:zy :compute.0:zy
+  353 op sub *tmp61 *tmp59 *tmp60
+  354 op add :compute.0:zx *tmp61 :compute.0:cx
+  355 op mul *tmp63 2 :compute.0:x1
+  356 op mul *tmp64 *tmp63 :compute.0:zy
+  357 op add :compute.0:zy *tmp64 :compute.0:cy
+  358 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  359 jump *label179 lessThan :compute.0:dist 64
+  360 jump *label54 always
+  361 label *label179
+  362 label *label180
+  363 label *label181
+  364 op add :compute.0:i :compute.0:i 1
+  365 label *label182
+  366 set :compute.0:x1 :compute.0:zx
+  367 op mul *tmp59 :compute.0:zx :compute.0:zx
+  368 op mul *tmp60 :compute.0:zy :compute.0:zy
+  369 op sub *tmp61 *tmp59 *tmp60
+  370 op add :compute.0:zx *tmp61 :compute.0:cx
+  371 op mul *tmp63 2 :compute.0:x1
+  372 op mul *tmp64 *tmp63 :compute.0:zy
+  373 op add :compute.0:zy *tmp64 :compute.0:cy
+  374 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  375 jump *label183 lessThan :compute.0:dist 64
+  376 jump *label54 always
+  377 label *label183
+  378 label *label184
+  379 label *label185
+  380 op add :compute.0:i :compute.0:i 1
+  381 label *label186
+  382 set :compute.0:x1 :compute.0:zx
+  383 op mul *tmp59 :compute.0:zx :compute.0:zx
+  384 op mul *tmp60 :compute.0:zy :compute.0:zy
+  385 op sub *tmp61 *tmp59 *tmp60
+  386 op add :compute.0:zx *tmp61 :compute.0:cx
+  387 op mul *tmp63 2 :compute.0:x1
+  388 op mul *tmp64 *tmp63 :compute.0:zy
+  389 op add :compute.0:zy *tmp64 :compute.0:cy
+  390 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  391 jump *label187 lessThan :compute.0:dist 64
+  392 jump *label54 always
+  393 label *label187
+  394 label *label188
+  395 label *label189
+  396 op add :compute.0:i :compute.0:i 1
+  397 label *label190
+  398 set :compute.0:x1 :compute.0:zx
+  399 op mul *tmp59 :compute.0:zx :compute.0:zx
+  400 op mul *tmp60 :compute.0:zy :compute.0:zy
+  401 op sub *tmp61 *tmp59 *tmp60
+  402 op add :compute.0:zx *tmp61 :compute.0:cx
+  403 op mul *tmp63 2 :compute.0:x1
+  404 op mul *tmp64 *tmp63 :compute.0:zy
+  405 op add :compute.0:zy *tmp64 :compute.0:cy
+  406 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  407 jump *label191 lessThan :compute.0:dist 64
+  408 jump *label54 always
+  409 label *label191
+  410 label *label192
+  411 label *label193
+  412 op add :compute.0:i :compute.0:i 1
+  413 label *label194
+  414 set :compute.0:x1 :compute.0:zx
+  415 op mul *tmp59 :compute.0:zx :compute.0:zx
+  416 op mul *tmp60 :compute.0:zy :compute.0:zy
+  417 op sub *tmp61 *tmp59 *tmp60
+  418 op add :compute.0:zx *tmp61 :compute.0:cx
+  419 op mul *tmp63 2 :compute.0:x1
+  420 op mul *tmp64 *tmp63 :compute.0:zy
+  421 op add :compute.0:zy *tmp64 :compute.0:cy
+  422 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  423 jump *label195 lessThan :compute.0:dist 64
+  424 jump *label54 always
+  425 label *label195
+  426 label *label196
+  427 label *label197
+  428 op add :compute.0:i :compute.0:i 1
+  429 label *label198
+  430 set :compute.0:x1 :compute.0:zx
+  431 op mul *tmp59 :compute.0:zx :compute.0:zx
+  432 op mul *tmp60 :compute.0:zy :compute.0:zy
+  433 op sub *tmp61 *tmp59 *tmp60
+  434 op add :compute.0:zx *tmp61 :compute.0:cx
+  435 op mul *tmp63 2 :compute.0:x1
+  436 op mul *tmp64 *tmp63 :compute.0:zy
+  437 op add :compute.0:zy *tmp64 :compute.0:cy
+  438 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  439 jump *label199 lessThan :compute.0:dist 64
+  440 jump *label54 always
+  441 label *label199
+  442 label *label200
+  443 label *label201
+  444 op add :compute.0:i :compute.0:i 1
+  445 label *label202
+  446 set :compute.0:x1 :compute.0:zx
+  447 op mul *tmp59 :compute.0:zx :compute.0:zx
+  448 op mul *tmp60 :compute.0:zy :compute.0:zy
+  449 op sub *tmp61 *tmp59 *tmp60
+  450 op add :compute.0:zx *tmp61 :compute.0:cx
+  451 op mul *tmp63 2 :compute.0:x1
+  452 op mul *tmp64 *tmp63 :compute.0:zy
+  453 op add :compute.0:zy *tmp64 :compute.0:cy
+  454 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  455 jump *label203 lessThan :compute.0:dist 64
+  456 jump *label54 always
+  457 label *label203
+  458 label *label204
+  459 label *label205
+  460 op add :compute.0:i :compute.0:i 1
+  461 label *label206
+  462 set :compute.0:x1 :compute.0:zx
+  463 op mul *tmp59 :compute.0:zx :compute.0:zx
+  464 op mul *tmp60 :compute.0:zy :compute.0:zy
+  465 op sub *tmp61 *tmp59 *tmp60
+  466 op add :compute.0:zx *tmp61 :compute.0:cx
+  467 op mul *tmp63 2 :compute.0:x1
+  468 op mul *tmp64 *tmp63 :compute.0:zy
+  469 op add :compute.0:zy *tmp64 :compute.0:cy
+  470 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  471 jump *label207 lessThan :compute.0:dist 64
+  472 jump *label54 always
+  473 label *label207
+  474 label *label208
+  475 label *label209
+  476 op add :compute.0:i :compute.0:i 1
+  477 label *label210
+  478 set :compute.0:x1 :compute.0:zx
+  479 op mul *tmp59 :compute.0:zx :compute.0:zx
+  480 op mul *tmp60 :compute.0:zy :compute.0:zy
+  481 op sub *tmp61 *tmp59 *tmp60
+  482 op add :compute.0:zx *tmp61 :compute.0:cx
+  483 op mul *tmp63 2 :compute.0:x1
+  484 op mul *tmp64 *tmp63 :compute.0:zy
+  485 op add :compute.0:zy *tmp64 :compute.0:cy
+  486 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  487 jump *label211 lessThan :compute.0:dist 64
+  488 jump *label54 always
+  489 label *label211
+  490 label *label212
+  491 label *label213
+  492 op add :compute.0:i :compute.0:i 1
+  493 label *label214
+  494 set :compute.0:x1 :compute.0:zx
+  495 op mul *tmp59 :compute.0:zx :compute.0:zx
+  496 op mul *tmp60 :compute.0:zy :compute.0:zy
+  497 op sub *tmp61 *tmp59 *tmp60
+  498 op add :compute.0:zx *tmp61 :compute.0:cx
+  499 op mul *tmp63 2 :compute.0:x1
+  500 op mul *tmp64 *tmp63 :compute.0:zy
+  501 op add :compute.0:zy *tmp64 :compute.0:cy
+  502 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  503 jump *label215 lessThan :compute.0:dist 64
+  504 jump *label54 always
+  505 label *label215
+  506 label *label216
+  507 label *label217
+  508 op add :compute.0:i :compute.0:i 1
+  509 label *label218
+  510 set :compute.0:x1 :compute.0:zx
+  511 op mul *tmp59 :compute.0:zx :compute.0:zx
+  512 op mul *tmp60 :compute.0:zy :compute.0:zy
+  513 op sub *tmp61 *tmp59 *tmp60
+  514 op add :compute.0:zx *tmp61 :compute.0:cx
+  515 op mul *tmp63 2 :compute.0:x1
+  516 op mul *tmp64 *tmp63 :compute.0:zy
+  517 op add :compute.0:zy *tmp64 :compute.0:cy
+  518 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  519 jump *label219 lessThan :compute.0:dist 64
+  520 jump *label54 always
+  521 label *label219
+  522 label *label220
+  523 label *label221
+  524 op add :compute.0:i :compute.0:i 1
+  525 label *label222
+  526 set :compute.0:x1 :compute.0:zx
+  527 op mul *tmp59 :compute.0:zx :compute.0:zx
+  528 op mul *tmp60 :compute.0:zy :compute.0:zy
+  529 op sub *tmp61 *tmp59 *tmp60
+  530 op add :compute.0:zx *tmp61 :compute.0:cx
+  531 op mul *tmp63 2 :compute.0:x1
+  532 op mul *tmp64 *tmp63 :compute.0:zy
+  533 op add :compute.0:zy *tmp64 :compute.0:cy
+  534 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  535 jump *label223 lessThan :compute.0:dist 64
+  536 jump *label54 always
+  537 label *label223
+  538 label *label224
+  539 label *label225
+  540 op add :compute.0:i :compute.0:i 1
+  541 label *label226
+  542 set :compute.0:x1 :compute.0:zx
+  543 op mul *tmp59 :compute.0:zx :compute.0:zx
+  544 op mul *tmp60 :compute.0:zy :compute.0:zy
+  545 op sub *tmp61 *tmp59 *tmp60
+  546 op add :compute.0:zx *tmp61 :compute.0:cx
+  547 op mul *tmp63 2 :compute.0:x1
+  548 op mul *tmp64 *tmp63 :compute.0:zy
+  549 op add :compute.0:zy *tmp64 :compute.0:cy
+  550 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  551 jump *label227 lessThan :compute.0:dist 64
+  552 jump *label54 always
+  553 label *label227
+  554 label *label228
+  555 label *label229
+  556 op add :compute.0:i :compute.0:i 1
+  557 label *label230
+  558 set :compute.0:x1 :compute.0:zx
+  559 op mul *tmp59 :compute.0:zx :compute.0:zx
+  560 op mul *tmp60 :compute.0:zy :compute.0:zy
+  561 op sub *tmp61 *tmp59 *tmp60
+  562 op add :compute.0:zx *tmp61 :compute.0:cx
+  563 op mul *tmp63 2 :compute.0:x1
+  564 op mul *tmp64 *tmp63 :compute.0:zy
+  565 op add :compute.0:zy *tmp64 :compute.0:cy
+  566 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  567 jump *label231 lessThan :compute.0:dist 64
+  568 jump *label54 always
+  569 label *label231
+  570 label *label232
+  571 label *label233
+  572 op add :compute.0:i :compute.0:i 1
+  573 label *label234
+  574 set :compute.0:x1 :compute.0:zx
+  575 op mul *tmp59 :compute.0:zx :compute.0:zx
+  576 op mul *tmp60 :compute.0:zy :compute.0:zy
+  577 op sub *tmp61 *tmp59 *tmp60
+  578 op add :compute.0:zx *tmp61 :compute.0:cx
+  579 op mul *tmp63 2 :compute.0:x1
+  580 op mul *tmp64 *tmp63 :compute.0:zy
+  581 op add :compute.0:zy *tmp64 :compute.0:cy
+  582 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  583 jump *label235 lessThan :compute.0:dist 64
+  584 jump *label54 always
+  585 label *label235
+  586 label *label236
+  587 label *label237
+  588 op add :compute.0:i :compute.0:i 1
+  589 label *label238
+  590 set :compute.0:x1 :compute.0:zx
+  591 op mul *tmp59 :compute.0:zx :compute.0:zx
+  592 op mul *tmp60 :compute.0:zy :compute.0:zy
+  593 op sub *tmp61 *tmp59 *tmp60
+  594 op add :compute.0:zx *tmp61 :compute.0:cx
+  595 op mul *tmp63 2 :compute.0:x1
+  596 op mul *tmp64 *tmp63 :compute.0:zy
+  597 op add :compute.0:zy *tmp64 :compute.0:cy
+  598 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  599 jump *label239 lessThan :compute.0:dist 64
+  600 jump *label54 always
+  601 label *label239
+  602 label *label240
+  603 label *label241
+  604 op add :compute.0:i :compute.0:i 1
+  605 label *label242
+  606 set :compute.0:x1 :compute.0:zx
+  607 op mul *tmp59 :compute.0:zx :compute.0:zx
+  608 op mul *tmp60 :compute.0:zy :compute.0:zy
+  609 op sub *tmp61 *tmp59 *tmp60
+  610 op add :compute.0:zx *tmp61 :compute.0:cx
+  611 op mul *tmp63 2 :compute.0:x1
+  612 op mul *tmp64 *tmp63 :compute.0:zy
+  613 op add :compute.0:zy *tmp64 :compute.0:cy
+  614 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  615 jump *label243 lessThan :compute.0:dist 64
+  616 jump *label54 always
+  617 label *label243
+  618 label *label244
+  619 label *label245
+  620 op add :compute.0:i :compute.0:i 1
+  621 label *label246
+  622 set :compute.0:x1 :compute.0:zx
+  623 op mul *tmp59 :compute.0:zx :compute.0:zx
+  624 op mul *tmp60 :compute.0:zy :compute.0:zy
+  625 op sub *tmp61 *tmp59 *tmp60
+  626 op add :compute.0:zx *tmp61 :compute.0:cx
+  627 op mul *tmp63 2 :compute.0:x1
+  628 op mul *tmp64 *tmp63 :compute.0:zy
+  629 op add :compute.0:zy *tmp64 :compute.0:cy
+  630 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  631 jump *label247 lessThan :compute.0:dist 64
+  632 jump *label54 always
+  633 label *label247
+  634 label *label248
+  635 label *label249
+  636 op add :compute.0:i :compute.0:i 1
+  637 label *label250
+  638 set :compute.0:x1 :compute.0:zx
+  639 op mul *tmp59 :compute.0:zx :compute.0:zx
+  640 op mul *tmp60 :compute.0:zy :compute.0:zy
+  641 op sub *tmp61 *tmp59 *tmp60
+  642 op add :compute.0:zx *tmp61 :compute.0:cx
+  643 op mul *tmp63 2 :compute.0:x1
+  644 op mul *tmp64 *tmp63 :compute.0:zy
+  645 op add :compute.0:zy *tmp64 :compute.0:cy
+  646 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  647 jump *label251 lessThan :compute.0:dist 64
+  648 jump *label54 always
+  649 label *label251
+  650 label *label252
+  651 label *label253
+  652 op add :compute.0:i :compute.0:i 1
+  653 label *label254
+  654 set :compute.0:x1 :compute.0:zx
+  655 op mul *tmp59 :compute.0:zx :compute.0:zx
+  656 op mul *tmp60 :compute.0:zy :compute.0:zy
+  657 op sub *tmp61 *tmp59 *tmp60
+  658 op add :compute.0:zx *tmp61 :compute.0:cx
+  659 op mul *tmp63 2 :compute.0:x1
+  660 op mul *tmp64 *tmp63 :compute.0:zy
+  661 op add :compute.0:zy *tmp64 :compute.0:cy
+  662 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  663 jump *label255 lessThan :compute.0:dist 64
+  664 jump *label54 always
+  665 label *label255
+  666 label *label256
+  667 label *label257
+  668 op add :compute.0:i :compute.0:i 1
+  669 label *label258
+  670 set :compute.0:x1 :compute.0:zx
+  671 op mul *tmp59 :compute.0:zx :compute.0:zx
+  672 op mul *tmp60 :compute.0:zy :compute.0:zy
+  673 op sub *tmp61 *tmp59 *tmp60
+  674 op add :compute.0:zx *tmp61 :compute.0:cx
+  675 op mul *tmp63 2 :compute.0:x1
+  676 op mul *tmp64 *tmp63 :compute.0:zy
+  677 op add :compute.0:zy *tmp64 :compute.0:cy
+  678 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  679 jump *label259 lessThan :compute.0:dist 64
+  680 jump *label54 always
+  681 label *label259
+  682 label *label260
+  683 label *label261
+  684 op add :compute.0:i :compute.0:i 1
+  685 label *label262
+  686 set :compute.0:x1 :compute.0:zx
+  687 op mul *tmp59 :compute.0:zx :compute.0:zx
+  688 op mul *tmp60 :compute.0:zy :compute.0:zy
+  689 op sub *tmp61 *tmp59 *tmp60
+  690 op add :compute.0:zx *tmp61 :compute.0:cx
+  691 op mul *tmp63 2 :compute.0:x1
+  692 op mul *tmp64 *tmp63 :compute.0:zy
+  693 op add :compute.0:zy *tmp64 :compute.0:cy
+  694 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  695 jump *label263 lessThan :compute.0:dist 64
+  696 jump *label54 always
+  697 label *label263
+  698 label *label264
+  699 label *label265
+  700 op add :compute.0:i :compute.0:i 1
+  701 label *label266
+  702 set :compute.0:x1 :compute.0:zx
+  703 op mul *tmp59 :compute.0:zx :compute.0:zx
+  704 op mul *tmp60 :compute.0:zy :compute.0:zy
+  705 op sub *tmp61 *tmp59 *tmp60
+  706 op add :compute.0:zx *tmp61 :compute.0:cx
+  707 op mul *tmp63 2 :compute.0:x1
+  708 op mul *tmp64 *tmp63 :compute.0:zy
+  709 op add :compute.0:zy *tmp64 :compute.0:cy
+  710 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  711 jump *label267 lessThan :compute.0:dist 64
+  712 jump *label54 always
+  713 label *label267
+  714 label *label268
+  715 label *label269
+  716 op add :compute.0:i :compute.0:i 1
+  717 label *label270
+  718 set :compute.0:x1 :compute.0:zx
+  719 op mul *tmp59 :compute.0:zx :compute.0:zx
+  720 op mul *tmp60 :compute.0:zy :compute.0:zy
+  721 op sub *tmp61 *tmp59 *tmp60
+  722 op add :compute.0:zx *tmp61 :compute.0:cx
+  723 op mul *tmp63 2 :compute.0:x1
+  724 op mul *tmp64 *tmp63 :compute.0:zy
+  725 op add :compute.0:zy *tmp64 :compute.0:cy
+  726 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  727 jump *label271 lessThan :compute.0:dist 64
+  728 jump *label54 always
+  729 label *label271
+  730 label *label272
+  731 label *label273
+  732 op add :compute.0:i :compute.0:i 1
+  733 label *label274
+  734 set :compute.0:x1 :compute.0:zx
+  735 op mul *tmp59 :compute.0:zx :compute.0:zx
+  736 op mul *tmp60 :compute.0:zy :compute.0:zy
+  737 op sub *tmp61 *tmp59 *tmp60
+  738 op add :compute.0:zx *tmp61 :compute.0:cx
+  739 op mul *tmp63 2 :compute.0:x1
+  740 op mul *tmp64 *tmp63 :compute.0:zy
+  741 op add :compute.0:zy *tmp64 :compute.0:cy
+  742 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  743 jump *label275 lessThan :compute.0:dist 64
+  744 jump *label54 always
+  745 label *label275
+  746 label *label276
+  747 label *label277
+  748 op add :compute.0:i :compute.0:i 1
+  749 label *label278
+  750 set :compute.0:x1 :compute.0:zx
+  751 op mul *tmp59 :compute.0:zx :compute.0:zx
+  752 op mul *tmp60 :compute.0:zy :compute.0:zy
+  753 op sub *tmp61 *tmp59 *tmp60
+  754 op add :compute.0:zx *tmp61 :compute.0:cx
+  755 op mul *tmp63 2 :compute.0:x1
+  756 op mul *tmp64 *tmp63 :compute.0:zy
+  757 op add :compute.0:zy *tmp64 :compute.0:cy
+  758 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  759 jump *label279 lessThan :compute.0:dist 64
+  760 jump *label54 always
+  761 label *label279
+  762 label *label280
+  763 label *label281
+  764 op add :compute.0:i :compute.0:i 1
+  765 label *label282
+  766 set :compute.0:x1 :compute.0:zx
+  767 op mul *tmp59 :compute.0:zx :compute.0:zx
+  768 op mul *tmp60 :compute.0:zy :compute.0:zy
+  769 op sub *tmp61 *tmp59 *tmp60
+  770 op add :compute.0:zx *tmp61 :compute.0:cx
+  771 op mul *tmp63 2 :compute.0:x1
+  772 op mul *tmp64 *tmp63 :compute.0:zy
+  773 op add :compute.0:zy *tmp64 :compute.0:cy
+  774 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  775 jump *label283 lessThan :compute.0:dist 64
+  776 jump *label54 always
+  777 label *label283
+  778 label *label284
+  779 label *label285
+  780 op add :compute.0:i :compute.0:i 1
+  781 label *label286
+  782 set :compute.0:x1 :compute.0:zx
+  783 op mul *tmp59 :compute.0:zx :compute.0:zx
+  784 op mul *tmp60 :compute.0:zy :compute.0:zy
+  785 op sub *tmp61 *tmp59 *tmp60
+  786 op add :compute.0:zx *tmp61 :compute.0:cx
+  787 op mul *tmp63 2 :compute.0:x1
+  788 op mul *tmp64 *tmp63 :compute.0:zy
+  789 op add :compute.0:zy *tmp64 :compute.0:cy
+  790 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  791 jump *label287 lessThan :compute.0:dist 64
+  792 jump *label54 always
+  793 label *label287
+  794 label *label288
+  795 label *label289
+  796 op add :compute.0:i :compute.0:i 1
+  797 label *label290
+  798 set :compute.0:x1 :compute.0:zx
+  799 op mul *tmp59 :compute.0:zx :compute.0:zx
+  800 op mul *tmp60 :compute.0:zy :compute.0:zy
+  801 op sub *tmp61 *tmp59 *tmp60
+  802 op add :compute.0:zx *tmp61 :compute.0:cx
+  803 op mul *tmp63 2 :compute.0:x1
+  804 op mul *tmp64 *tmp63 :compute.0:zy
+  805 op add :compute.0:zy *tmp64 :compute.0:cy
+  806 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  807 jump *label291 lessThan :compute.0:dist 64
+  808 jump *label54 always
+  809 label *label291
+  810 label *label292
+  811 label *label293
+  812 op add :compute.0:i :compute.0:i 1
+  813 label *label294
+  814 set :compute.0:x1 :compute.0:zx
+  815 op mul *tmp59 :compute.0:zx :compute.0:zx
+  816 op mul *tmp60 :compute.0:zy :compute.0:zy
+  817 op sub *tmp61 *tmp59 *tmp60
+  818 op add :compute.0:zx *tmp61 :compute.0:cx
+  819 op mul *tmp63 2 :compute.0:x1
+  820 op mul *tmp64 *tmp63 :compute.0:zy
+  821 op add :compute.0:zy *tmp64 :compute.0:cy
+  822 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  823 jump *label295 lessThan :compute.0:dist 64
+  824 jump *label54 always
+  825 label *label295
+  826 label *label296
+  827 label *label297
+  828 op add :compute.0:i :compute.0:i 1
+  829 label *label298
+  830 set :compute.0:x1 :compute.0:zx
+  831 op mul *tmp59 :compute.0:zx :compute.0:zx
+  832 op mul *tmp60 :compute.0:zy :compute.0:zy
+  833 op sub *tmp61 *tmp59 *tmp60
+  834 op add :compute.0:zx *tmp61 :compute.0:cx
+  835 op mul *tmp63 2 :compute.0:x1
+  836 op mul *tmp64 *tmp63 :compute.0:zy
+  837 op add :compute.0:zy *tmp64 :compute.0:cy
+  838 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  839 jump *label299 lessThan :compute.0:dist 64
+  840 jump *label54 always
+  841 label *label299
+  842 label *label300
+  843 label *label301
+  844 op add :compute.0:i :compute.0:i 1
+  845 label *label302
+  846 set :compute.0:x1 :compute.0:zx
+  847 op mul *tmp59 :compute.0:zx :compute.0:zx
+  848 op mul *tmp60 :compute.0:zy :compute.0:zy
+  849 op sub *tmp61 *tmp59 *tmp60
+  850 op add :compute.0:zx *tmp61 :compute.0:cx
+  851 op mul *tmp63 2 :compute.0:x1
+  852 op mul *tmp64 *tmp63 :compute.0:zy
+  853 op add :compute.0:zy *tmp64 :compute.0:cy
+  854 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  855 jump *label303 lessThan :compute.0:dist 64
+  856 jump *label54 always
+  857 label *label303
+  858 label *label304
+  859 label *label305
+  860 op add :compute.0:i :compute.0:i 1
+  861 label *label306
+  862 set :compute.0:x1 :compute.0:zx
+  863 op mul *tmp59 :compute.0:zx :compute.0:zx
+  864 op mul *tmp60 :compute.0:zy :compute.0:zy
+  865 op sub *tmp61 *tmp59 *tmp60
+  866 op add :compute.0:zx *tmp61 :compute.0:cx
+  867 op mul *tmp63 2 :compute.0:x1
+  868 op mul *tmp64 *tmp63 :compute.0:zy
+  869 op add :compute.0:zy *tmp64 :compute.0:cy
+  870 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  871 jump *label307 lessThan :compute.0:dist 64
+  872 jump *label54 always
+  873 label *label307
+  874 label *label308
+  875 label *label309
+  876 op add :compute.0:i :compute.0:i 1
+  877 label *label310
+  878 set :compute.0:x1 :compute.0:zx
+  879 op mul *tmp59 :compute.0:zx :compute.0:zx
+  880 op mul *tmp60 :compute.0:zy :compute.0:zy
+  881 op sub *tmp61 *tmp59 *tmp60
+  882 op add :compute.0:zx *tmp61 :compute.0:cx
+  883 op mul *tmp63 2 :compute.0:x1
+  884 op mul *tmp64 *tmp63 :compute.0:zy
+  885 op add :compute.0:zy *tmp64 :compute.0:cy
+  886 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  887 jump *label311 lessThan :compute.0:dist 64
+  888 jump *label54 always
+  889 label *label311
+  890 label *label312
+  891 label *label313
+  892 op add :compute.0:i :compute.0:i 1
+  893 label *label314
+  894 set :compute.0:x1 :compute.0:zx
+  895 op mul *tmp59 :compute.0:zx :compute.0:zx
+  896 op mul *tmp60 :compute.0:zy :compute.0:zy
+  897 op sub *tmp61 *tmp59 *tmp60
+  898 op add :compute.0:zx *tmp61 :compute.0:cx
+  899 op mul *tmp63 2 :compute.0:x1
+  900 op mul *tmp64 *tmp63 :compute.0:zy
+  901 op add :compute.0:zy *tmp64 :compute.0:cy
+  902 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  903 jump *label315 lessThan :compute.0:dist 64
+  904 jump *label54 always
+  905 label *label315
+  906 label *label316
+  907 label *label317
+  908 op add :compute.0:i :compute.0:i 1
+  909 label *label318
+  910 set :compute.0:x1 :compute.0:zx
+  911 op mul *tmp59 :compute.0:zx :compute.0:zx
+  912 op mul *tmp60 :compute.0:zy :compute.0:zy
+  913 op sub *tmp61 *tmp59 *tmp60
+  914 op add :compute.0:zx *tmp61 :compute.0:cx
+  915 op mul *tmp63 2 :compute.0:x1
+  916 op mul *tmp64 *tmp63 :compute.0:zy
+  917 op add :compute.0:zy *tmp64 :compute.0:cy
+  918 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  919 jump *label319 lessThan :compute.0:dist 64
+  920 jump *label54 always
+  921 label *label319
+  922 label *label320
+  923 label *label321
+  924 op add :compute.0:i :compute.0:i 1
+  925 label *label322
+  926 set :compute.0:x1 :compute.0:zx
+  927 op mul *tmp59 :compute.0:zx :compute.0:zx
+  928 op mul *tmp60 :compute.0:zy :compute.0:zy
+  929 op sub *tmp61 *tmp59 *tmp60
+  930 op add :compute.0:zx *tmp61 :compute.0:cx
+  931 op mul *tmp63 2 :compute.0:x1
+  932 op mul *tmp64 *tmp63 :compute.0:zy
+  933 op add :compute.0:zy *tmp64 :compute.0:cy
+  934 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  935 jump *label323 lessThan :compute.0:dist 64
+  936 jump *label54 always
+  937 label *label323
+  938 label *label324
+  939 label *label325
+  940 op add :compute.0:i :compute.0:i 1
+  941 label *label326
+  942 set :compute.0:x1 :compute.0:zx
+  943 op mul *tmp59 :compute.0:zx :compute.0:zx
+  944 op mul *tmp60 :compute.0:zy :compute.0:zy
+  945 op sub *tmp61 *tmp59 *tmp60
+  946 op add :compute.0:zx *tmp61 :compute.0:cx
+  947 op mul *tmp63 2 :compute.0:x1
+  948 op mul *tmp64 *tmp63 :compute.0:zy
+  949 op add :compute.0:zy *tmp64 :compute.0:cy
+  950 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  951 jump *label327 lessThan :compute.0:dist 64
+  952 jump *label54 always
+  953 label *label327
+  954 label *label328
+  955 label *label329
+  956 op add :compute.0:i :compute.0:i 1
+  957 label *label330
+  958 set :compute.0:x1 :compute.0:zx
+  959 op mul *tmp59 :compute.0:zx :compute.0:zx
+  960 op mul *tmp60 :compute.0:zy :compute.0:zy
+  961 op sub *tmp61 *tmp59 *tmp60
+  962 op add :compute.0:zx *tmp61 :compute.0:cx
+  963 op mul *tmp63 2 :compute.0:x1
+  964 op mul *tmp64 *tmp63 :compute.0:zy
+  965 op add :compute.0:zy *tmp64 :compute.0:cy
+  966 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  967 jump *label331 lessThan :compute.0:dist 64
+  968 jump *label54 always
+  969 label *label331
+  970 label *label332
+  971 label *label333
+  972 op add :compute.0:i :compute.0:i 1
+  973 label *label334
+  974 set :compute.0:x1 :compute.0:zx
+  975 op mul *tmp59 :compute.0:zx :compute.0:zx
+  976 op mul *tmp60 :compute.0:zy :compute.0:zy
+  977 op sub *tmp61 *tmp59 *tmp60
+  978 op add :compute.0:zx *tmp61 :compute.0:cx
+  979 op mul *tmp63 2 :compute.0:x1
+  980 op mul *tmp64 *tmp63 :compute.0:zy
+  981 op add :compute.0:zy *tmp64 :compute.0:cy
+  982 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  983 jump *label335 lessThan :compute.0:dist 64
+  984 jump *label54 always
+  985 label *label335
+  986 label *label336
+  987 label *label337
+  988 op add :compute.0:i :compute.0:i 1
+  989 label *label338
+  990 set :compute.0:x1 :compute.0:zx
+  991 op mul *tmp59 :compute.0:zx :compute.0:zx
+  992 op mul *tmp60 :compute.0:zy :compute.0:zy
+  993 op sub *tmp61 *tmp59 *tmp60
+  994 op add :compute.0:zx *tmp61 :compute.0:cx
+  995 op mul *tmp63 2 :compute.0:x1
+  996 op mul *tmp64 *tmp63 :compute.0:zy
+  997 op add :compute.0:zy *tmp64 :compute.0:cy
+  998 op len :compute.0:dist :compute.0:zx :compute.0:zy
+  999 jump *label339 lessThan :compute.0:dist 64
+ 1000 jump *label54 always
+ 1001 label *label339
+ 1002 label *label340
+ 1003 label *label341
+ 1004 op add :compute.0:i :compute.0:i 1
+ 1005 label *label342
+ 1006 set :compute.0:x1 :compute.0:zx
+ 1007 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1008 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1009 op sub *tmp61 *tmp59 *tmp60
+ 1010 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1011 op mul *tmp63 2 :compute.0:x1
+ 1012 op mul *tmp64 *tmp63 :compute.0:zy
+ 1013 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1014 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1015 jump *label343 lessThan :compute.0:dist 64
+ 1016 jump *label54 always
+ 1017 label *label343
+ 1018 label *label344
+ 1019 label *label345
+ 1020 op add :compute.0:i :compute.0:i 1
+ 1021 label *label346
+ 1022 set :compute.0:x1 :compute.0:zx
+ 1023 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1024 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1025 op sub *tmp61 *tmp59 *tmp60
+ 1026 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1027 op mul *tmp63 2 :compute.0:x1
+ 1028 op mul *tmp64 *tmp63 :compute.0:zy
+ 1029 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1030 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1031 jump *label347 lessThan :compute.0:dist 64
+ 1032 jump *label54 always
+ 1033 label *label347
+ 1034 label *label348
+ 1035 label *label349
+ 1036 op add :compute.0:i :compute.0:i 1
+ 1037 label *label350
+ 1038 set :compute.0:x1 :compute.0:zx
+ 1039 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1040 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1041 op sub *tmp61 *tmp59 *tmp60
+ 1042 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1043 op mul *tmp63 2 :compute.0:x1
+ 1044 op mul *tmp64 *tmp63 :compute.0:zy
+ 1045 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1046 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1047 jump *label351 lessThan :compute.0:dist 64
+ 1048 jump *label54 always
+ 1049 label *label351
+ 1050 label *label352
+ 1051 label *label353
+ 1052 op add :compute.0:i :compute.0:i 1
+ 1053 label *label354
+ 1054 set :compute.0:x1 :compute.0:zx
+ 1055 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1056 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1057 op sub *tmp61 *tmp59 *tmp60
+ 1058 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1059 op mul *tmp63 2 :compute.0:x1
+ 1060 op mul *tmp64 *tmp63 :compute.0:zy
+ 1061 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1062 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1063 jump *label355 lessThan :compute.0:dist 64
+ 1064 jump *label54 always
+ 1065 label *label355
+ 1066 label *label356
+ 1067 label *label357
+ 1068 op add :compute.0:i :compute.0:i 1
+ 1069 label *label358
+ 1070 set :compute.0:x1 :compute.0:zx
+ 1071 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1072 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1073 op sub *tmp61 *tmp59 *tmp60
+ 1074 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1075 op mul *tmp63 2 :compute.0:x1
+ 1076 op mul *tmp64 *tmp63 :compute.0:zy
+ 1077 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1078 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1079 jump *label359 lessThan :compute.0:dist 64
+ 1080 jump *label54 always
+ 1081 label *label359
+ 1082 label *label360
+ 1083 label *label361
+ 1084 op add :compute.0:i :compute.0:i 1
+ 1085 label *label362
+ 1086 set :compute.0:x1 :compute.0:zx
+ 1087 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1088 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1089 op sub *tmp61 *tmp59 *tmp60
+ 1090 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1091 op mul *tmp63 2 :compute.0:x1
+ 1092 op mul *tmp64 *tmp63 :compute.0:zy
+ 1093 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1094 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1095 jump *label363 lessThan :compute.0:dist 64
+ 1096 jump *label54 always
+ 1097 label *label363
+ 1098 label *label364
+ 1099 label *label365
+ 1100 op add :compute.0:i :compute.0:i 1
+ 1101 label *label366
+ 1102 set :compute.0:x1 :compute.0:zx
+ 1103 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1104 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1105 op sub *tmp61 *tmp59 *tmp60
+ 1106 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1107 op mul *tmp63 2 :compute.0:x1
+ 1108 op mul *tmp64 *tmp63 :compute.0:zy
+ 1109 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1110 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1111 jump *label367 lessThan :compute.0:dist 64
+ 1112 jump *label54 always
+ 1113 label *label367
+ 1114 label *label368
+ 1115 label *label369
+ 1116 op add :compute.0:i :compute.0:i 1
+ 1117 label *label370
+ 1118 set :compute.0:x1 :compute.0:zx
+ 1119 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1120 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1121 op sub *tmp61 *tmp59 *tmp60
+ 1122 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1123 op mul *tmp63 2 :compute.0:x1
+ 1124 op mul *tmp64 *tmp63 :compute.0:zy
+ 1125 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1126 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1127 jump *label371 lessThan :compute.0:dist 64
+ 1128 jump *label54 always
+ 1129 label *label371
+ 1130 label *label372
+ 1131 label *label373
+ 1132 op add :compute.0:i :compute.0:i 1
+ 1133 label *label374
+ 1134 set :compute.0:x1 :compute.0:zx
+ 1135 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1136 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1137 op sub *tmp61 *tmp59 *tmp60
+ 1138 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1139 op mul *tmp63 2 :compute.0:x1
+ 1140 op mul *tmp64 *tmp63 :compute.0:zy
+ 1141 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1142 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1143 jump *label375 lessThan :compute.0:dist 64
+ 1144 jump *label54 always
+ 1145 label *label375
+ 1146 label *label376
+ 1147 label *label377
+ 1148 op add :compute.0:i :compute.0:i 1
+ 1149 label *label378
+ 1150 set :compute.0:x1 :compute.0:zx
+ 1151 op mul *tmp59 :compute.0:zx :compute.0:zx
+ 1152 op mul *tmp60 :compute.0:zy :compute.0:zy
+ 1153 op sub *tmp61 *tmp59 *tmp60
+ 1154 op add :compute.0:zx *tmp61 :compute.0:cx
+ 1155 op mul *tmp63 2 :compute.0:x1
+ 1156 op mul *tmp64 *tmp63 :compute.0:zy
+ 1157 op add :compute.0:zy *tmp64 :compute.0:cy
+ 1158 op len :compute.0:dist :compute.0:zx :compute.0:zy
+ 1159 jump *label379 lessThan :compute.0:dist 64
+ 1160 jump *label54 always
+ 1161 label *label379
+ 1162 label *label380
+ 1163 label *label381
+ 1164 op add :compute.0:i :compute.0:i 1
+ 1165 label *label54
  1166 op mul *tmp69 .SMOOTH 63
  1167 jump *label57 greaterThanEq :compute.0:i *tmp69
  1168 op log *tmp72 :compute.0:dist

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   169 label *label131
   170 label *label132
   171 label *label133
-    * op add :compute.0:i :compute.0:i 1
+  172 op add :compute.0:i 0 1
   173 label *label134
   174 set :compute.0:x1 :compute.0:zx
   175 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   185 label *label135
   186 label *label136
   187 label *label137
-    * op add :compute.0:i :compute.0:i 1
+  188 op add :compute.0:i 1 1
   189 label *label138
   190 set :compute.0:x1 :compute.0:zx
   191 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   201 label *label139
   202 label *label140
   203 label *label141
-    * op add :compute.0:i :compute.0:i 1
+  204 op add :compute.0:i 2 1
   205 label *label142
   206 set :compute.0:x1 :compute.0:zx
   207 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   217 label *label143
   218 label *label144
   219 label *label145
-    * op add :compute.0:i :compute.0:i 1
+  220 op add :compute.0:i 3 1
   221 label *label146
   222 set :compute.0:x1 :compute.0:zx
   223 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   233 label *label147
   234 label *label148
   235 label *label149
-    * op add :compute.0:i :compute.0:i 1
+  236 op add :compute.0:i 4 1
   237 label *label150
   238 set :compute.0:x1 :compute.0:zx
   239 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   249 label *label151
   250 label *label152
   251 label *label153
-    * op add :compute.0:i :compute.0:i 1
+  252 op add :compute.0:i 5 1
   253 label *label154
   254 set :compute.0:x1 :compute.0:zx
   255 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   265 label *label155
   266 label *label156
   267 label *label157
-    * op add :compute.0:i :compute.0:i 1
+  268 op add :compute.0:i 6 1
   269 label *label158
   270 set :compute.0:x1 :compute.0:zx
   271 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   281 label *label159
   282 label *label160
   283 label *label161
-    * op add :compute.0:i :compute.0:i 1
+  284 op add :compute.0:i 7 1
   285 label *label162
   286 set :compute.0:x1 :compute.0:zx
   287 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   297 label *label163
   298 label *label164
   299 label *label165
-    * op add :compute.0:i :compute.0:i 1
+  300 op add :compute.0:i 8 1
   301 label *label166
   302 set :compute.0:x1 :compute.0:zx
   303 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   313 label *label167
   314 label *label168
   315 label *label169
-    * op add :compute.0:i :compute.0:i 1
+  316 op add :compute.0:i 9 1
   317 label *label170
   318 set :compute.0:x1 :compute.0:zx
   319 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   329 label *label171
   330 label *label172
   331 label *label173
-    * op add :compute.0:i :compute.0:i 1
+  332 op add :compute.0:i 10 1
   333 label *label174
   334 set :compute.0:x1 :compute.0:zx
   335 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   345 label *label175
   346 label *label176
   347 label *label177
-    * op add :compute.0:i :compute.0:i 1
+  348 op add :compute.0:i 11 1
   349 label *label178
   350 set :compute.0:x1 :compute.0:zx
   351 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   361 label *label179
   362 label *label180
   363 label *label181
-    * op add :compute.0:i :compute.0:i 1
+  364 op add :compute.0:i 12 1
   365 label *label182
   366 set :compute.0:x1 :compute.0:zx
   367 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   377 label *label183
   378 label *label184
   379 label *label185
-    * op add :compute.0:i :compute.0:i 1
+  380 op add :compute.0:i 13 1
   381 label *label186
   382 set :compute.0:x1 :compute.0:zx
   383 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   393 label *label187
   394 label *label188
   395 label *label189
-    * op add :compute.0:i :compute.0:i 1
+  396 op add :compute.0:i 14 1
   397 label *label190
   398 set :compute.0:x1 :compute.0:zx
   399 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   409 label *label191
   410 label *label192
   411 label *label193
-    * op add :compute.0:i :compute.0:i 1
+  412 op add :compute.0:i 15 1
   413 label *label194
   414 set :compute.0:x1 :compute.0:zx
   415 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   425 label *label195
   426 label *label196
   427 label *label197
-    * op add :compute.0:i :compute.0:i 1
+  428 op add :compute.0:i 16 1
   429 label *label198
   430 set :compute.0:x1 :compute.0:zx
   431 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   441 label *label199
   442 label *label200
   443 label *label201
-    * op add :compute.0:i :compute.0:i 1
+  444 op add :compute.0:i 17 1
   445 label *label202
   446 set :compute.0:x1 :compute.0:zx
   447 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   457 label *label203
   458 label *label204
   459 label *label205
-    * op add :compute.0:i :compute.0:i 1
+  460 op add :compute.0:i 18 1
   461 label *label206
   462 set :compute.0:x1 :compute.0:zx
   463 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   473 label *label207
   474 label *label208
   475 label *label209
-    * op add :compute.0:i :compute.0:i 1
+  476 op add :compute.0:i 19 1
   477 label *label210
   478 set :compute.0:x1 :compute.0:zx
   479 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   489 label *label211
   490 label *label212
   491 label *label213
-    * op add :compute.0:i :compute.0:i 1
+  492 op add :compute.0:i 20 1
   493 label *label214
   494 set :compute.0:x1 :compute.0:zx
   495 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   505 label *label215
   506 label *label216
   507 label *label217
-    * op add :compute.0:i :compute.0:i 1
+  508 op add :compute.0:i 21 1
   509 label *label218
   510 set :compute.0:x1 :compute.0:zx
   511 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   521 label *label219
   522 label *label220
   523 label *label221
-    * op add :compute.0:i :compute.0:i 1
+  524 op add :compute.0:i 22 1
   525 label *label222
   526 set :compute.0:x1 :compute.0:zx
   527 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   537 label *label223
   538 label *label224
   539 label *label225
-    * op add :compute.0:i :compute.0:i 1
+  540 op add :compute.0:i 23 1
   541 label *label226
   542 set :compute.0:x1 :compute.0:zx
   543 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   553 label *label227
   554 label *label228
   555 label *label229
-    * op add :compute.0:i :compute.0:i 1
+  556 op add :compute.0:i 24 1
   557 label *label230
   558 set :compute.0:x1 :compute.0:zx
   559 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   569 label *label231
   570 label *label232
   571 label *label233
-    * op add :compute.0:i :compute.0:i 1
+  572 op add :compute.0:i 25 1
   573 label *label234
   574 set :compute.0:x1 :compute.0:zx
   575 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   585 label *label235
   586 label *label236
   587 label *label237
-    * op add :compute.0:i :compute.0:i 1
+  588 op add :compute.0:i 26 1
   589 label *label238
   590 set :compute.0:x1 :compute.0:zx
   591 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   601 label *label239
   602 label *label240
   603 label *label241
-    * op add :compute.0:i :compute.0:i 1
+  604 op add :compute.0:i 27 1
   605 label *label242
   606 set :compute.0:x1 :compute.0:zx
   607 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   617 label *label243
   618 label *label244
   619 label *label245
-    * op add :compute.0:i :compute.0:i 1
+  620 op add :compute.0:i 28 1
   621 label *label246
   622 set :compute.0:x1 :compute.0:zx
   623 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   633 label *label247
   634 label *label248
   635 label *label249
-    * op add :compute.0:i :compute.0:i 1
+  636 op add :compute.0:i 29 1
   637 label *label250
   638 set :compute.0:x1 :compute.0:zx
   639 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   649 label *label251
   650 label *label252
   651 label *label253
-    * op add :compute.0:i :compute.0:i 1
+  652 op add :compute.0:i 30 1
   653 label *label254
   654 set :compute.0:x1 :compute.0:zx
   655 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   665 label *label255
   666 label *label256
   667 label *label257
-    * op add :compute.0:i :compute.0:i 1
+  668 op add :compute.0:i 31 1
   669 label *label258
   670 set :compute.0:x1 :compute.0:zx
   671 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   681 label *label259
   682 label *label260
   683 label *label261
-    * op add :compute.0:i :compute.0:i 1
+  684 op add :compute.0:i 32 1
   685 label *label262
   686 set :compute.0:x1 :compute.0:zx
   687 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   697 label *label263
   698 label *label264
   699 label *label265
-    * op add :compute.0:i :compute.0:i 1
+  700 op add :compute.0:i 33 1
   701 label *label266
   702 set :compute.0:x1 :compute.0:zx
   703 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   713 label *label267
   714 label *label268
   715 label *label269
-    * op add :compute.0:i :compute.0:i 1
+  716 op add :compute.0:i 34 1
   717 label *label270
   718 set :compute.0:x1 :compute.0:zx
   719 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   729 label *label271
   730 label *label272
   731 label *label273
-    * op add :compute.0:i :compute.0:i 1
+  732 op add :compute.0:i 35 1
   733 label *label274
   734 set :compute.0:x1 :compute.0:zx
   735 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   745 label *label275
   746 label *label276
   747 label *label277
-    * op add :compute.0:i :compute.0:i 1
+  748 op add :compute.0:i 36 1
   749 label *label278
   750 set :compute.0:x1 :compute.0:zx
   751 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   761 label *label279
   762 label *label280
   763 label *label281
-    * op add :compute.0:i :compute.0:i 1
+  764 op add :compute.0:i 37 1
   765 label *label282
   766 set :compute.0:x1 :compute.0:zx
   767 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   777 label *label283
   778 label *label284
   779 label *label285
-    * op add :compute.0:i :compute.0:i 1
+  780 op add :compute.0:i 38 1
   781 label *label286
   782 set :compute.0:x1 :compute.0:zx
   783 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   793 label *label287
   794 label *label288
   795 label *label289
-    * op add :compute.0:i :compute.0:i 1
+  796 op add :compute.0:i 39 1
   797 label *label290
   798 set :compute.0:x1 :compute.0:zx
   799 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   809 label *label291
   810 label *label292
   811 label *label293
-    * op add :compute.0:i :compute.0:i 1
+  812 op add :compute.0:i 40 1
   813 label *label294
   814 set :compute.0:x1 :compute.0:zx
   815 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   825 label *label295
   826 label *label296
   827 label *label297
-    * op add :compute.0:i :compute.0:i 1
+  828 op add :compute.0:i 41 1
   829 label *label298
   830 set :compute.0:x1 :compute.0:zx
   831 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   841 label *label299
   842 label *label300
   843 label *label301
-    * op add :compute.0:i :compute.0:i 1
+  844 op add :compute.0:i 42 1
   845 label *label302
   846 set :compute.0:x1 :compute.0:zx
   847 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   857 label *label303
   858 label *label304
   859 label *label305
-    * op add :compute.0:i :compute.0:i 1
+  860 op add :compute.0:i 43 1
   861 label *label306
   862 set :compute.0:x1 :compute.0:zx
   863 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   873 label *label307
   874 label *label308
   875 label *label309
-    * op add :compute.0:i :compute.0:i 1
+  876 op add :compute.0:i 44 1
   877 label *label310
   878 set :compute.0:x1 :compute.0:zx
   879 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   889 label *label311
   890 label *label312
   891 label *label313
-    * op add :compute.0:i :compute.0:i 1
+  892 op add :compute.0:i 45 1
   893 label *label314
   894 set :compute.0:x1 :compute.0:zx
   895 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   905 label *label315
   906 label *label316
   907 label *label317
-    * op add :compute.0:i :compute.0:i 1
+  908 op add :compute.0:i 46 1
   909 label *label318
   910 set :compute.0:x1 :compute.0:zx
   911 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   921 label *label319
   922 label *label320
   923 label *label321
-    * op add :compute.0:i :compute.0:i 1
+  924 op add :compute.0:i 47 1
   925 label *label322
   926 set :compute.0:x1 :compute.0:zx
   927 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   937 label *label323
   938 label *label324
   939 label *label325
-    * op add :compute.0:i :compute.0:i 1
+  940 op add :compute.0:i 48 1
   941 label *label326
   942 set :compute.0:x1 :compute.0:zx
   943 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   953 label *label327
   954 label *label328
   955 label *label329
-    * op add :compute.0:i :compute.0:i 1
+  956 op add :compute.0:i 49 1
   957 label *label330
   958 set :compute.0:x1 :compute.0:zx
   959 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   969 label *label331
   970 label *label332
   971 label *label333
-    * op add :compute.0:i :compute.0:i 1
+  972 op add :compute.0:i 50 1
   973 label *label334
   974 set :compute.0:x1 :compute.0:zx
   975 op mul *tmp59 :compute.0:zx :compute.0:zx
 
   985 label *label335
   986 label *label336
   987 label *label337
-    * op add :compute.0:i :compute.0:i 1
+  988 op add :compute.0:i 51 1
   989 label *label338
   990 set :compute.0:x1 :compute.0:zx
   991 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1001 label *label339
  1002 label *label340
  1003 label *label341
-    * op add :compute.0:i :compute.0:i 1
+ 1004 op add :compute.0:i 52 1
  1005 label *label342
  1006 set :compute.0:x1 :compute.0:zx
  1007 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1017 label *label343
  1018 label *label344
  1019 label *label345
-    * op add :compute.0:i :compute.0:i 1
+ 1020 op add :compute.0:i 53 1
  1021 label *label346
  1022 set :compute.0:x1 :compute.0:zx
  1023 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1033 label *label347
  1034 label *label348
  1035 label *label349
-    * op add :compute.0:i :compute.0:i 1
+ 1036 op add :compute.0:i 54 1
  1037 label *label350
  1038 set :compute.0:x1 :compute.0:zx
  1039 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1049 label *label351
  1050 label *label352
  1051 label *label353
-    * op add :compute.0:i :compute.0:i 1
+ 1052 op add :compute.0:i 55 1
  1053 label *label354
  1054 set :compute.0:x1 :compute.0:zx
  1055 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1065 label *label355
  1066 label *label356
  1067 label *label357
-    * op add :compute.0:i :compute.0:i 1
+ 1068 op add :compute.0:i 56 1
  1069 label *label358
  1070 set :compute.0:x1 :compute.0:zx
  1071 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1081 label *label359
  1082 label *label360
  1083 label *label361
-    * op add :compute.0:i :compute.0:i 1
+ 1084 op add :compute.0:i 57 1
  1085 label *label362
  1086 set :compute.0:x1 :compute.0:zx
  1087 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1097 label *label363
  1098 label *label364
  1099 label *label365
-    * op add :compute.0:i :compute.0:i 1
+ 1100 op add :compute.0:i 58 1
  1101 label *label366
  1102 set :compute.0:x1 :compute.0:zx
  1103 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1113 label *label367
  1114 label *label368
  1115 label *label369
-    * op add :compute.0:i :compute.0:i 1
+ 1116 op add :compute.0:i 59 1
  1117 label *label370
  1118 set :compute.0:x1 :compute.0:zx
  1119 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1129 label *label371
  1130 label *label372
  1131 label *label373
-    * op add :compute.0:i :compute.0:i 1
+ 1132 op add :compute.0:i 60 1
  1133 label *label374
  1134 set :compute.0:x1 :compute.0:zx
  1135 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1145 label *label375
  1146 label *label376
  1147 label *label377
-    * op add :compute.0:i :compute.0:i 1
+ 1148 op add :compute.0:i 61 1
  1149 label *label378
  1150 set :compute.0:x1 :compute.0:zx
  1151 op mul *tmp59 :compute.0:zx :compute.0:zx
 
  1161 label *label379
  1162 label *label380
  1163 label *label381
-    * op add :compute.0:i :compute.0:i 1
+ 1164 op add :compute.0:i 62 1
  1165 label *label54
  1166 op mul *tmp69 .SMOOTH 63
  1167 jump *label57 greaterThanEq :compute.0:i *tmp69

Modifications by Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 (+9 instructions):
 
    79 label *label29
    80 label *label32
    81 set :setState.0:state 0
-    * setaddr :setState.0*retaddr *label35
-    * call *label0 :setState.0*retval
-    * label *label35
+   82 label *label382
+   83 label *label383
+   84 jump *label390 greaterThanEq .PROC_STATE_INDEX 512
+   85 label *label384
+   86 read *tmp124 .memory .PROC_ID_INDEX
+   87 jump *label385 notEqual *tmp124 .PROCESSOR_ID
+   88 write :setState.0:state .memory .PROC_STATE_INDEX
+   89 jump *label390 always
+   90 jump *label388 always
+   91 label *label385
+   92 read *tmp130 .memory .PROC_ID_INDEX
+   93 jump *label386 notEqual *tmp130 0
+   94 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+   95 write :setState.0:state .memory .PROC_STATE_INDEX
+   96 jump *label390 always
+   97 jump *label387 always
+   98 label *label386
+   99 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  100 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  101 label *label387
+  102 label *label388
+  103 label *label389
+  104 jump *label384 lessThan .PROC_STATE_INDEX 512
+  105 label *label390
+  106 label *label391
   107 label *label33
   108 read *tmp0 .memory 64
   109 jump *label32 equal .start *tmp0
 
   113 read *tmp1 .memory 65
   114 set .stop *tmp1
   115 set :setState.0:state *tmp0
-    * setaddr :setState.0*retaddr *label36
-    * call *label0 :setState.0*retval
-    * label *label36
+  116 label *label392
+  117 label *label393
+  118 jump *label400 greaterThanEq .PROC_STATE_INDEX 512
+  119 label *label394
+  120 read *tmp124 .memory .PROC_ID_INDEX
+  121 jump *label395 notEqual *tmp124 .PROCESSOR_ID
+  122 write :setState.0:state .memory .PROC_STATE_INDEX
+  123 jump *label400 always
+  124 jump *label398 always
+  125 label *label395
+  126 read *tmp130 .memory .PROC_ID_INDEX
+  127 jump *label396 notEqual *tmp130 0
+  128 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  129 write :setState.0:state .memory .PROC_STATE_INDEX
+  130 jump *label400 always
+  131 jump *label397 always
+  132 label *label396
+  133 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  134 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  135 label *label397
+  136 label *label398
+  137 label *label399
+  138 jump *label394 lessThan .PROC_STATE_INDEX 512
+  139 label *label400
+  140 label *label401
   141 read .ZOOM .memory 68
   142 op div *tmp26 -88 .ZOOM
   143 read *tmp2 .memory 66
 
  1307 jump *label29 always
  1308 label *label31
  1309 end
-    * label *label0
-    * label *label78
-    * jump *label80 greaterThanEq .PROC_STATE_INDEX 512
-    * label *label89
-    * read *tmp124 .memory .PROC_ID_INDEX
-    * jump *label81 notEqual *tmp124 .PROCESSOR_ID
-    * write :setState.0:state .memory .PROC_STATE_INDEX
-    * jump *label80 always
-    * jump *label82 always
-    * label *label81
-    * read *tmp130 .memory .PROC_ID_INDEX
-    * jump *label83 notEqual *tmp130 0
-    * write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState.0:state .memory .PROC_STATE_INDEX
-    * jump *label80 always
-    * jump *label84 always
-    * label *label83
-    * op add .PROC_ID_INDEX .PROC_ID_INDEX 2
-    * op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label84
-    * label *label82
-    * label *label79
-    * jump *label89 lessThan .PROC_STATE_INDEX 512
-    * label *label80
-    * label *label77
-    * return :setState.0*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    85 label *label384
    86 read *tmp124 .memory .PROC_ID_INDEX
    87 jump *label385 notEqual *tmp124 .PROCESSOR_ID
-    * write :setState.0:state .memory .PROC_STATE_INDEX
+   88 write 0 .memory .PROC_STATE_INDEX
    89 jump *label390 always
    90 jump *label388 always
    91 label *label385
    92 read *tmp130 .memory .PROC_ID_INDEX
    93 jump *label386 notEqual *tmp130 0
    94 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState.0:state .memory .PROC_STATE_INDEX
+   95 write 0 .memory .PROC_STATE_INDEX
    96 jump *label390 always
    97 jump *label387 always
    98 label *label386
 
   119 label *label394
   120 read *tmp124 .memory .PROC_ID_INDEX
   121 jump *label395 notEqual *tmp124 .PROCESSOR_ID
-    * write :setState.0:state .memory .PROC_STATE_INDEX
+  122 write *tmp0 .memory .PROC_STATE_INDEX
   123 jump *label400 always
   124 jump *label398 always
   125 label *label395
   126 read *tmp130 .memory .PROC_ID_INDEX
   127 jump *label396 notEqual *tmp130 0
   128 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState.0:state .memory .PROC_STATE_INDEX
+  129 write *tmp0 .memory .PROC_STATE_INDEX
   130 jump *label400 always
   131 jump *label397 always
   132 label *label396

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    78 label *label1
    79 label *label29
    80 label *label32
-    * set :setState.0:state 0
    81 label *label382
    82 label *label383
    83 jump *label390 greaterThanEq .PROC_STATE_INDEX 512
 
   111 set .start *tmp0
   112 read *tmp1 .memory 65
   113 set .stop *tmp1
-    * set :setState.0:state *tmp0
   114 label *label392
   115 label *label393
   116 jump *label400 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    24 label *label99
    25 jump *label102 notEqual @large-logic-display :findLinkedBlocks.0:type
    26 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * jump *label100 notEqual @large-logic-display @message
+   27 jump *label100 always
    28 label *label100
    29 label *label101
    30 label *label102
 
    35 label *label107
    36 jump *label110 notEqual @memory-bank :findLinkedBlocks.0:type
    37 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * jump *label108 notEqual @memory-bank @message
+   38 jump *label108 always
    39 label *label108
    40 label *label109
    41 label *label110
 
    52 print ":"
    53 print " "
    54 print .display
-    * jump *label117 equal true false
    55 op and :findLinkedBlocks.0:foundAll 1 .display
    56 label *label117
    57 label *label118
 
    63 print ":"
    64 print " "
    65 print .memory
-    * jump *label123 equal true false
    66 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll .memory
    67 label *label123
    68 label *label124

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
    24 label *label99
    25 jump *label102 notEqual @large-logic-display :findLinkedBlocks.0:type
    26 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * jump *label100 always
    27 label *label100
    28 label *label101
    29 label *label102
 
    34 label *label107
    35 jump *label110 notEqual @memory-bank :findLinkedBlocks.0:type
    36 set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block
-    * jump *label108 always
    37 label *label108
    38 label *label109
    39 label *label110
 
  1212 label *label57
  1213 label *label58
  1214 set *tmp41 :compute.0:i
-    * jump *label45 always
  1215 label *label45
  1216 jump *label60 equal .SMOOTH false
  1217 jump *label62 notEqual *tmp41 63

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-2 instructions):
 
    54 label *label117
    55 label *label118
    56 label *label119
-    * set .display .display
    57 label *label122
    58 print "\n"
    59 print "Memory"
 
    64 label *label123
    65 label *label124
    66 label *label125
-    * set .memory .memory
    67 label *label24
    68 printflush null
    69 label *label3
 
   205 label *label131
   206 label *label132
   207 label *label133
-    * op add :compute.0:i 0 1
+  208 set :compute.0:i 1
   209 label *label134
   210 set :compute.0:x1 :compute.0:zx
   211 op mul *tmp59 :compute.0:zx :compute.0:zx

Modifications by Final phase, Jump Straightening, iteration 1 (-65 instructions):
 
   200 op mul *tmp64 *tmp63 :compute.0:zy
   201 op add :compute.0:zy *tmp64 :compute.0:cy
   202 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label131 lessThan :compute.0:dist 64
-    * jump *label54 always
+  203 jump *label54 greaterThanEq :compute.0:dist 64
   204 label *label131
   205 label *label132
   206 label *label133
 
   215 op mul *tmp64 *tmp63 :compute.0:zy
   216 op add :compute.0:zy *tmp64 :compute.0:cy
   217 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label135 lessThan :compute.0:dist 64
-    * jump *label54 always
+  218 jump *label54 greaterThanEq :compute.0:dist 64
   219 label *label135
   220 label *label136
   221 label *label137
 
   230 op mul *tmp64 *tmp63 :compute.0:zy
   231 op add :compute.0:zy *tmp64 :compute.0:cy
   232 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label139 lessThan :compute.0:dist 64
-    * jump *label54 always
+  233 jump *label54 greaterThanEq :compute.0:dist 64
   234 label *label139
   235 label *label140
   236 label *label141
 
   245 op mul *tmp64 *tmp63 :compute.0:zy
   246 op add :compute.0:zy *tmp64 :compute.0:cy
   247 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label143 lessThan :compute.0:dist 64
-    * jump *label54 always
+  248 jump *label54 greaterThanEq :compute.0:dist 64
   249 label *label143
   250 label *label144
   251 label *label145
 
   260 op mul *tmp64 *tmp63 :compute.0:zy
   261 op add :compute.0:zy *tmp64 :compute.0:cy
   262 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label147 lessThan :compute.0:dist 64
-    * jump *label54 always
+  263 jump *label54 greaterThanEq :compute.0:dist 64
   264 label *label147
   265 label *label148
   266 label *label149
 
   275 op mul *tmp64 *tmp63 :compute.0:zy
   276 op add :compute.0:zy *tmp64 :compute.0:cy
   277 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label151 lessThan :compute.0:dist 64
-    * jump *label54 always
+  278 jump *label54 greaterThanEq :compute.0:dist 64
   279 label *label151
   280 label *label152
   281 label *label153
 
   290 op mul *tmp64 *tmp63 :compute.0:zy
   291 op add :compute.0:zy *tmp64 :compute.0:cy
   292 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label155 lessThan :compute.0:dist 64
-    * jump *label54 always
+  293 jump *label54 greaterThanEq :compute.0:dist 64
   294 label *label155
   295 label *label156
   296 label *label157
 
   305 op mul *tmp64 *tmp63 :compute.0:zy
   306 op add :compute.0:zy *tmp64 :compute.0:cy
   307 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label159 lessThan :compute.0:dist 64
-    * jump *label54 always
+  308 jump *label54 greaterThanEq :compute.0:dist 64
   309 label *label159
   310 label *label160
   311 label *label161
 
   320 op mul *tmp64 *tmp63 :compute.0:zy
   321 op add :compute.0:zy *tmp64 :compute.0:cy
   322 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label163 lessThan :compute.0:dist 64
-    * jump *label54 always
+  323 jump *label54 greaterThanEq :compute.0:dist 64
   324 label *label163
   325 label *label164
   326 label *label165
 
   335 op mul *tmp64 *tmp63 :compute.0:zy
   336 op add :compute.0:zy *tmp64 :compute.0:cy
   337 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label167 lessThan :compute.0:dist 64
-    * jump *label54 always
+  338 jump *label54 greaterThanEq :compute.0:dist 64
   339 label *label167
   340 label *label168
   341 label *label169
 
   350 op mul *tmp64 *tmp63 :compute.0:zy
   351 op add :compute.0:zy *tmp64 :compute.0:cy
   352 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label171 lessThan :compute.0:dist 64
-    * jump *label54 always
+  353 jump *label54 greaterThanEq :compute.0:dist 64
   354 label *label171
   355 label *label172
   356 label *label173
 
   365 op mul *tmp64 *tmp63 :compute.0:zy
   366 op add :compute.0:zy *tmp64 :compute.0:cy
   367 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label175 lessThan :compute.0:dist 64
-    * jump *label54 always
+  368 jump *label54 greaterThanEq :compute.0:dist 64
   369 label *label175
   370 label *label176
   371 label *label177
 
   380 op mul *tmp64 *tmp63 :compute.0:zy
   381 op add :compute.0:zy *tmp64 :compute.0:cy
   382 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label179 lessThan :compute.0:dist 64
-    * jump *label54 always
+  383 jump *label54 greaterThanEq :compute.0:dist 64
   384 label *label179
   385 label *label180
   386 label *label181
 
   395 op mul *tmp64 *tmp63 :compute.0:zy
   396 op add :compute.0:zy *tmp64 :compute.0:cy
   397 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label183 lessThan :compute.0:dist 64
-    * jump *label54 always
+  398 jump *label54 greaterThanEq :compute.0:dist 64
   399 label *label183
   400 label *label184
   401 label *label185
 
   410 op mul *tmp64 *tmp63 :compute.0:zy
   411 op add :compute.0:zy *tmp64 :compute.0:cy
   412 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label187 lessThan :compute.0:dist 64
-    * jump *label54 always
+  413 jump *label54 greaterThanEq :compute.0:dist 64
   414 label *label187
   415 label *label188
   416 label *label189
 
   425 op mul *tmp64 *tmp63 :compute.0:zy
   426 op add :compute.0:zy *tmp64 :compute.0:cy
   427 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label191 lessThan :compute.0:dist 64
-    * jump *label54 always
+  428 jump *label54 greaterThanEq :compute.0:dist 64
   429 label *label191
   430 label *label192
   431 label *label193
 
   440 op mul *tmp64 *tmp63 :compute.0:zy
   441 op add :compute.0:zy *tmp64 :compute.0:cy
   442 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label195 lessThan :compute.0:dist 64
-    * jump *label54 always
+  443 jump *label54 greaterThanEq :compute.0:dist 64
   444 label *label195
   445 label *label196
   446 label *label197
 
   455 op mul *tmp64 *tmp63 :compute.0:zy
   456 op add :compute.0:zy *tmp64 :compute.0:cy
   457 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label199 lessThan :compute.0:dist 64
-    * jump *label54 always
+  458 jump *label54 greaterThanEq :compute.0:dist 64
   459 label *label199
   460 label *label200
   461 label *label201
 
   470 op mul *tmp64 *tmp63 :compute.0:zy
   471 op add :compute.0:zy *tmp64 :compute.0:cy
   472 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label203 lessThan :compute.0:dist 64
-    * jump *label54 always
+  473 jump *label54 greaterThanEq :compute.0:dist 64
   474 label *label203
   475 label *label204
   476 label *label205
 
   485 op mul *tmp64 *tmp63 :compute.0:zy
   486 op add :compute.0:zy *tmp64 :compute.0:cy
   487 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label207 lessThan :compute.0:dist 64
-    * jump *label54 always
+  488 jump *label54 greaterThanEq :compute.0:dist 64
   489 label *label207
   490 label *label208
   491 label *label209
 
   500 op mul *tmp64 *tmp63 :compute.0:zy
   501 op add :compute.0:zy *tmp64 :compute.0:cy
   502 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label211 lessThan :compute.0:dist 64
-    * jump *label54 always
+  503 jump *label54 greaterThanEq :compute.0:dist 64
   504 label *label211
   505 label *label212
   506 label *label213
 
   515 op mul *tmp64 *tmp63 :compute.0:zy
   516 op add :compute.0:zy *tmp64 :compute.0:cy
   517 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label215 lessThan :compute.0:dist 64
-    * jump *label54 always
+  518 jump *label54 greaterThanEq :compute.0:dist 64
   519 label *label215
   520 label *label216
   521 label *label217
 
   530 op mul *tmp64 *tmp63 :compute.0:zy
   531 op add :compute.0:zy *tmp64 :compute.0:cy
   532 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label219 lessThan :compute.0:dist 64
-    * jump *label54 always
+  533 jump *label54 greaterThanEq :compute.0:dist 64
   534 label *label219
   535 label *label220
   536 label *label221
 
   545 op mul *tmp64 *tmp63 :compute.0:zy
   546 op add :compute.0:zy *tmp64 :compute.0:cy
   547 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label223 lessThan :compute.0:dist 64
-    * jump *label54 always
+  548 jump *label54 greaterThanEq :compute.0:dist 64
   549 label *label223
   550 label *label224
   551 label *label225
 
   560 op mul *tmp64 *tmp63 :compute.0:zy
   561 op add :compute.0:zy *tmp64 :compute.0:cy
   562 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label227 lessThan :compute.0:dist 64
-    * jump *label54 always
+  563 jump *label54 greaterThanEq :compute.0:dist 64
   564 label *label227
   565 label *label228
   566 label *label229
 
   575 op mul *tmp64 *tmp63 :compute.0:zy
   576 op add :compute.0:zy *tmp64 :compute.0:cy
   577 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label231 lessThan :compute.0:dist 64
-    * jump *label54 always
+  578 jump *label54 greaterThanEq :compute.0:dist 64
   579 label *label231
   580 label *label232
   581 label *label233
 
   590 op mul *tmp64 *tmp63 :compute.0:zy
   591 op add :compute.0:zy *tmp64 :compute.0:cy
   592 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label235 lessThan :compute.0:dist 64
-    * jump *label54 always
+  593 jump *label54 greaterThanEq :compute.0:dist 64
   594 label *label235
   595 label *label236
   596 label *label237
 
   605 op mul *tmp64 *tmp63 :compute.0:zy
   606 op add :compute.0:zy *tmp64 :compute.0:cy
   607 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label239 lessThan :compute.0:dist 64
-    * jump *label54 always
+  608 jump *label54 greaterThanEq :compute.0:dist 64
   609 label *label239
   610 label *label240
   611 label *label241
 
   620 op mul *tmp64 *tmp63 :compute.0:zy
   621 op add :compute.0:zy *tmp64 :compute.0:cy
   622 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label243 lessThan :compute.0:dist 64
-    * jump *label54 always
+  623 jump *label54 greaterThanEq :compute.0:dist 64
   624 label *label243
   625 label *label244
   626 label *label245
 
   635 op mul *tmp64 *tmp63 :compute.0:zy
   636 op add :compute.0:zy *tmp64 :compute.0:cy
   637 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label247 lessThan :compute.0:dist 64
-    * jump *label54 always
+  638 jump *label54 greaterThanEq :compute.0:dist 64
   639 label *label247
   640 label *label248
   641 label *label249
 
   650 op mul *tmp64 *tmp63 :compute.0:zy
   651 op add :compute.0:zy *tmp64 :compute.0:cy
   652 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label251 lessThan :compute.0:dist 64
-    * jump *label54 always
+  653 jump *label54 greaterThanEq :compute.0:dist 64
   654 label *label251
   655 label *label252
   656 label *label253
 
   665 op mul *tmp64 *tmp63 :compute.0:zy
   666 op add :compute.0:zy *tmp64 :compute.0:cy
   667 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label255 lessThan :compute.0:dist 64
-    * jump *label54 always
+  668 jump *label54 greaterThanEq :compute.0:dist 64
   669 label *label255
   670 label *label256
   671 label *label257
 
   680 op mul *tmp64 *tmp63 :compute.0:zy
   681 op add :compute.0:zy *tmp64 :compute.0:cy
   682 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label259 lessThan :compute.0:dist 64
-    * jump *label54 always
+  683 jump *label54 greaterThanEq :compute.0:dist 64
   684 label *label259
   685 label *label260
   686 label *label261
 
   695 op mul *tmp64 *tmp63 :compute.0:zy
   696 op add :compute.0:zy *tmp64 :compute.0:cy
   697 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label263 lessThan :compute.0:dist 64
-    * jump *label54 always
+  698 jump *label54 greaterThanEq :compute.0:dist 64
   699 label *label263
   700 label *label264
   701 label *label265
 
   710 op mul *tmp64 *tmp63 :compute.0:zy
   711 op add :compute.0:zy *tmp64 :compute.0:cy
   712 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label267 lessThan :compute.0:dist 64
-    * jump *label54 always
+  713 jump *label54 greaterThanEq :compute.0:dist 64
   714 label *label267
   715 label *label268
   716 label *label269
 
   725 op mul *tmp64 *tmp63 :compute.0:zy
   726 op add :compute.0:zy *tmp64 :compute.0:cy
   727 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label271 lessThan :compute.0:dist 64
-    * jump *label54 always
+  728 jump *label54 greaterThanEq :compute.0:dist 64
   729 label *label271
   730 label *label272
   731 label *label273
 
   740 op mul *tmp64 *tmp63 :compute.0:zy
   741 op add :compute.0:zy *tmp64 :compute.0:cy
   742 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label275 lessThan :compute.0:dist 64
-    * jump *label54 always
+  743 jump *label54 greaterThanEq :compute.0:dist 64
   744 label *label275
   745 label *label276
   746 label *label277
 
   755 op mul *tmp64 *tmp63 :compute.0:zy
   756 op add :compute.0:zy *tmp64 :compute.0:cy
   757 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label279 lessThan :compute.0:dist 64
-    * jump *label54 always
+  758 jump *label54 greaterThanEq :compute.0:dist 64
   759 label *label279
   760 label *label280
   761 label *label281
 
   770 op mul *tmp64 *tmp63 :compute.0:zy
   771 op add :compute.0:zy *tmp64 :compute.0:cy
   772 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label283 lessThan :compute.0:dist 64
-    * jump *label54 always
+  773 jump *label54 greaterThanEq :compute.0:dist 64
   774 label *label283
   775 label *label284
   776 label *label285
 
   785 op mul *tmp64 *tmp63 :compute.0:zy
   786 op add :compute.0:zy *tmp64 :compute.0:cy
   787 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label287 lessThan :compute.0:dist 64
-    * jump *label54 always
+  788 jump *label54 greaterThanEq :compute.0:dist 64
   789 label *label287
   790 label *label288
   791 label *label289
 
   800 op mul *tmp64 *tmp63 :compute.0:zy
   801 op add :compute.0:zy *tmp64 :compute.0:cy
   802 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label291 lessThan :compute.0:dist 64
-    * jump *label54 always
+  803 jump *label54 greaterThanEq :compute.0:dist 64
   804 label *label291
   805 label *label292
   806 label *label293
 
   815 op mul *tmp64 *tmp63 :compute.0:zy
   816 op add :compute.0:zy *tmp64 :compute.0:cy
   817 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label295 lessThan :compute.0:dist 64
-    * jump *label54 always
+  818 jump *label54 greaterThanEq :compute.0:dist 64
   819 label *label295
   820 label *label296
   821 label *label297
 
   830 op mul *tmp64 *tmp63 :compute.0:zy
   831 op add :compute.0:zy *tmp64 :compute.0:cy
   832 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label299 lessThan :compute.0:dist 64
-    * jump *label54 always
+  833 jump *label54 greaterThanEq :compute.0:dist 64
   834 label *label299
   835 label *label300
   836 label *label301
 
   845 op mul *tmp64 *tmp63 :compute.0:zy
   846 op add :compute.0:zy *tmp64 :compute.0:cy
   847 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label303 lessThan :compute.0:dist 64
-    * jump *label54 always
+  848 jump *label54 greaterThanEq :compute.0:dist 64
   849 label *label303
   850 label *label304
   851 label *label305
 
   860 op mul *tmp64 *tmp63 :compute.0:zy
   861 op add :compute.0:zy *tmp64 :compute.0:cy
   862 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label307 lessThan :compute.0:dist 64
-    * jump *label54 always
+  863 jump *label54 greaterThanEq :compute.0:dist 64
   864 label *label307
   865 label *label308
   866 label *label309
 
   875 op mul *tmp64 *tmp63 :compute.0:zy
   876 op add :compute.0:zy *tmp64 :compute.0:cy
   877 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label311 lessThan :compute.0:dist 64
-    * jump *label54 always
+  878 jump *label54 greaterThanEq :compute.0:dist 64
   879 label *label311
   880 label *label312
   881 label *label313
 
   890 op mul *tmp64 *tmp63 :compute.0:zy
   891 op add :compute.0:zy *tmp64 :compute.0:cy
   892 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label315 lessThan :compute.0:dist 64
-    * jump *label54 always
+  893 jump *label54 greaterThanEq :compute.0:dist 64
   894 label *label315
   895 label *label316
   896 label *label317
 
   905 op mul *tmp64 *tmp63 :compute.0:zy
   906 op add :compute.0:zy *tmp64 :compute.0:cy
   907 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label319 lessThan :compute.0:dist 64
-    * jump *label54 always
+  908 jump *label54 greaterThanEq :compute.0:dist 64
   909 label *label319
   910 label *label320
   911 label *label321
 
   920 op mul *tmp64 *tmp63 :compute.0:zy
   921 op add :compute.0:zy *tmp64 :compute.0:cy
   922 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label323 lessThan :compute.0:dist 64
-    * jump *label54 always
+  923 jump *label54 greaterThanEq :compute.0:dist 64
   924 label *label323
   925 label *label324
   926 label *label325
 
   935 op mul *tmp64 *tmp63 :compute.0:zy
   936 op add :compute.0:zy *tmp64 :compute.0:cy
   937 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label327 lessThan :compute.0:dist 64
-    * jump *label54 always
+  938 jump *label54 greaterThanEq :compute.0:dist 64
   939 label *label327
   940 label *label328
   941 label *label329
 
   950 op mul *tmp64 *tmp63 :compute.0:zy
   951 op add :compute.0:zy *tmp64 :compute.0:cy
   952 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label331 lessThan :compute.0:dist 64
-    * jump *label54 always
+  953 jump *label54 greaterThanEq :compute.0:dist 64
   954 label *label331
   955 label *label332
   956 label *label333
 
   965 op mul *tmp64 *tmp63 :compute.0:zy
   966 op add :compute.0:zy *tmp64 :compute.0:cy
   967 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label335 lessThan :compute.0:dist 64
-    * jump *label54 always
+  968 jump *label54 greaterThanEq :compute.0:dist 64
   969 label *label335
   970 label *label336
   971 label *label337
 
   980 op mul *tmp64 *tmp63 :compute.0:zy
   981 op add :compute.0:zy *tmp64 :compute.0:cy
   982 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label339 lessThan :compute.0:dist 64
-    * jump *label54 always
+  983 jump *label54 greaterThanEq :compute.0:dist 64
   984 label *label339
   985 label *label340
   986 label *label341
 
   995 op mul *tmp64 *tmp63 :compute.0:zy
   996 op add :compute.0:zy *tmp64 :compute.0:cy
   997 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label343 lessThan :compute.0:dist 64
-    * jump *label54 always
+  998 jump *label54 greaterThanEq :compute.0:dist 64
   999 label *label343
  1000 label *label344
  1001 label *label345
 
  1010 op mul *tmp64 *tmp63 :compute.0:zy
  1011 op add :compute.0:zy *tmp64 :compute.0:cy
  1012 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label347 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1013 jump *label54 greaterThanEq :compute.0:dist 64
  1014 label *label347
  1015 label *label348
  1016 label *label349
 
  1025 op mul *tmp64 *tmp63 :compute.0:zy
  1026 op add :compute.0:zy *tmp64 :compute.0:cy
  1027 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label351 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1028 jump *label54 greaterThanEq :compute.0:dist 64
  1029 label *label351
  1030 label *label352
  1031 label *label353
 
  1040 op mul *tmp64 *tmp63 :compute.0:zy
  1041 op add :compute.0:zy *tmp64 :compute.0:cy
  1042 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label355 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1043 jump *label54 greaterThanEq :compute.0:dist 64
  1044 label *label355
  1045 label *label356
  1046 label *label357
 
  1055 op mul *tmp64 *tmp63 :compute.0:zy
  1056 op add :compute.0:zy *tmp64 :compute.0:cy
  1057 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label359 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1058 jump *label54 greaterThanEq :compute.0:dist 64
  1059 label *label359
  1060 label *label360
  1061 label *label361
 
  1070 op mul *tmp64 *tmp63 :compute.0:zy
  1071 op add :compute.0:zy *tmp64 :compute.0:cy
  1072 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label363 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1073 jump *label54 greaterThanEq :compute.0:dist 64
  1074 label *label363
  1075 label *label364
  1076 label *label365
 
  1085 op mul *tmp64 *tmp63 :compute.0:zy
  1086 op add :compute.0:zy *tmp64 :compute.0:cy
  1087 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label367 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1088 jump *label54 greaterThanEq :compute.0:dist 64
  1089 label *label367
  1090 label *label368
  1091 label *label369
 
  1100 op mul *tmp64 *tmp63 :compute.0:zy
  1101 op add :compute.0:zy *tmp64 :compute.0:cy
  1102 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label371 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1103 jump *label54 greaterThanEq :compute.0:dist 64
  1104 label *label371
  1105 label *label372
  1106 label *label373
 
  1115 op mul *tmp64 *tmp63 :compute.0:zy
  1116 op add :compute.0:zy *tmp64 :compute.0:cy
  1117 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label375 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1118 jump *label54 greaterThanEq :compute.0:dist 64
  1119 label *label375
  1120 label *label376
  1121 label *label377
 
  1130 op mul *tmp64 *tmp63 :compute.0:zy
  1131 op add :compute.0:zy *tmp64 :compute.0:cy
  1132 op len :compute.0:dist :compute.0:zx :compute.0:zy
-    * jump *label379 lessThan :compute.0:dist 64
-    * jump *label54 always
+ 1133 jump *label54 greaterThanEq :compute.0:dist 64
  1134 label *label379
  1135 label *label380
  1136 label *label381
 
  1204 drawflush .display
  1205 label *label59
  1206 read *tmp114 .memory :position
-    * jump *label71 equal *tmp114 .PROCESSOR_ID
-    * jump *label44 always
+ 1207 jump *label44 notEqual *tmp114 .PROCESSOR_ID
  1208 label *label71
  1209 label *label72
  1210 read *tmp1 .memory 65
-    * jump *label73 equal .stop *tmp1
-    * jump *label39 always
+ 1211 jump *label39 notEqual .stop *tmp1
  1212 label *label73
  1213 label *label74
  1214 label *label43

Modifications by Final phase, Jump Threading, iteration 1:
 
  1151 jump *label60 equal .SMOOTH false
  1152 jump *label62 notEqual *tmp41 63
  1153 draw color 0 0 0 255
-    * jump *label63 always
+ 1154 jump *label61 always
  1155 label *label62
  1156 jump *label65 notEqual .PALETTE 2
  1157 label *label66
 
  1166 op mul *tmp92 4 *tmp83
  1167 op add :drawPixel.0:b 120 *tmp92
  1168 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
-    * jump *label64 always
+ 1169 jump *label61 always
  1170 label *label65
  1171 jump *label67 notEqual .PALETTE 3
  1172 label *label68
 
  1180 op mul *tmp104 4 *tmp103
  1181 op add :drawPixel.0:b 100 *tmp104
  1182 draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255
-    * jump *label64 always
+ 1183 jump *label61 always
  1184 label *label67
  1185 jump *label69 notEqual .PALETTE 4
  1186 label *label70
 
  1188 op mul *tmp107 1.5 *tmp41
  1189 op add :drawPixel.0:g 96 *tmp107
  1190 draw color :drawPixel.0:r :drawPixel.0:g 0 255
-    * jump *label64 always
+ 1191 jump *label61 always
  1192 label *label69
  1193 op mul *tmp109 4 *tmp41
  1194 op sub :drawPixel.0:r 255 *tmp109

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-5 instructions):
 
    80 jump *label385 notEqual *tmp124 .PROCESSOR_ID
    81 write 0 .memory .PROC_STATE_INDEX
    82 jump *label390 always
-    * jump *label388 always
    83 label *label385
    84 read *tmp130 .memory .PROC_ID_INDEX
    85 jump *label386 notEqual *tmp130 0
    86 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    87 write 0 .memory .PROC_STATE_INDEX
    88 jump *label390 always
-    * jump *label387 always
    89 label *label386
    90 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    91 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
   111 jump *label395 notEqual *tmp124 .PROCESSOR_ID
   112 write *tmp0 .memory .PROC_STATE_INDEX
   113 jump *label400 always
-    * jump *label398 always
   114 label *label395
   115 read *tmp130 .memory .PROC_ID_INDEX
   116 jump *label396 notEqual *tmp130 0
   117 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   118 write *tmp0 .memory .PROC_STATE_INDEX
   119 jump *label400 always
-    * jump *label397 always
   120 label *label396
   121 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   122 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
  1227 drawflush .display
  1228 label *label30
  1229 jump *label29 always
-    * label *label31
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-6 instructions):
 
    45 jump *label85 greaterThan :findLinkedBlocks.0:n 0
    46 label *label12
    47 label *label116
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
+   48 print "\nDisplay: "
    49 print .display
    50 op and :findLinkedBlocks.0:foundAll 1 .display
    51 label *label117
    52 label *label118
    53 label *label119
    54 label *label122
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
+   55 print "\nMemory: "
    56 print .memory
    57 op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foundAll .memory
    58 label *label123

Final code before resolving virtual instructions:

    0:  op mul *tmp11 10000 @thisy                                   mandelbrot-compute.mnd: var PROCESSOR_ID = @this.@x + 10000 * @this.@y;
    1:  op add .PROCESSOR_ID @thisx *tmp11                           ...
    2:  set .PROC_ID_INDEX 334                                       mandelbrot-compute.mnd: var PROC_ID_INDEX = PROCESSORS;
    3:  set .PROC_STATE_INDEX 335                                    mandelbrot-compute.mnd: var PROC_STATE_INDEX = PROCESSORS + 1;
    4:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label2                                                *blocks: do
    5:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    6:  set .memory null                                             ...
    7:  print "Mandelbrot Generator"                                 *blocks: print(title);
    8:  set :findLinkedBlocks.0:n @links                             *blocks: var n = @links;
    9:  jump *label12 lessThanEq :findLinkedBlocks.0:n 0             *blocks: while n > 0 do
        label *label85                                               ...
   10:  op sub :findLinkedBlocks.0:n :findLinkedBlocks.0:n 1         *blocks: var block = getlink(--n);
   11:  getlink :findLinkedBlocks.0:block :findLinkedBlocks.0:n      ...
   12:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
   13:  print :findLinkedBlocks.0:block                              ...
   14:  sensor :findLinkedBlocks.0:type :findLinkedBlocks.0:block @t *blocks: var type = block.@type;
   15:  set :findLinkedBlocks.0:variable .display                    *blocks: for requested, name, out variable, required in linkMap do
   16:  jump *label102 notEqual @large-logic-display :findLinkedBloc *blocks: if requested == type then
   17:  set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block   *blocks: variable = block;
        label *label102                                              *blocks: if requested == type then
   18:  set .display :findLinkedBlocks.0:variable                    *blocks: for requested, name, out variable, required in linkMap do
   19:  set :findLinkedBlocks.0:variable .memory                     ...
   20:  jump *label110 notEqual @memory-bank :findLinkedBlocks.0:typ *blocks: if requested == type then
   21:  set :findLinkedBlocks.0:variable :findLinkedBlocks.0:block   *blocks: variable = block;
        label *label110                                              *blocks: if requested == type then
   22:  set .memory :findLinkedBlocks.0:variable                     *blocks: for requested, name, out variable, required in linkMap do
   23:  jump *label85 greaterThan :findLinkedBlocks.0:n 0            *blocks: while n > 0 do
        label *label12                                               ...
   24:  print "\nDisplay: "                                          *blocks: print($"\n$name: $variable");
   25:  print .display                                               ...
   26:  op and :findLinkedBlocks.0:foundAll 1 .display               *blocks: if required then foundAll &= variable; end;
   27:  print "\nMemory: "                                           *blocks: print($"\n$name: $variable");
   28:  print .memory                                                ...
   29:  op and :findLinkedBlocks.0:foundAll :findLinkedBlocks.0:foun *blocks: if required then foundAll &= variable; end;
   30:  printflush null                                              *blocks: printflush(message);
   31:  jump *label2 equal :findLinkedBlocks.0:foundAll false        *blocks: do
        label *label29                                               mandelbrot-compute.mnd: while true do
        label *label32                                               mandelbrot-compute.mnd: do
   32:  jump *label390 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label384                                              ...
   33:  read *tmp124 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   34:  jump *label385 notEqual *tmp124 .PROCESSOR_ID                ...
   35:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   36:  jump *label390 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label385                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   37:  read *tmp130 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   38:  jump *label386 notEqual *tmp130 0                            ...
   39:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   40:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   41:  jump *label390 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label386                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   42:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   43:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   44:  jump *label384 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label390                                              ...
   45:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: while start == $START;
   46:  jump *label32 equal .start *tmp0                             mandelbrot-compute.mnd: do
   47:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: start = $START;
   48:  set .start *tmp0                                             ...
   49:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: stop = $STOP;
   50:  set .stop *tmp1                                              ...
   51:  jump *label400 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label394                                              ...
   52:  read *tmp124 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   53:  jump *label395 notEqual *tmp124 .PROCESSOR_ID                ...
   54:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   55:  jump *label400 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label395                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   56:  read *tmp130 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   57:  jump *label396 notEqual *tmp130 0                            ...
   58:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   59:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   60:  jump *label400 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label396                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   61:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   62:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   63:  jump *label394 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label400                                              ...
   64:  read .ZOOM .memory 68                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   65:  op div *tmp26 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   66:  read *tmp2 .memory 66                                        ...
   67:  op add .OFFSET_X *tmp26 *tmp2                                ...
   68:  read *tmp3 .memory 67                                        mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   69:  op add .OFFSET_Y *tmp26 *tmp3                                ...
   70:  read .JULIA .memory 69                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   71:  read .JULIA_X .memory 70                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   72:  read .JULIA_Y .memory 71                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   73:  read .PALETTE .memory 72                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   74:  op greaterThan .SMOOTH .PALETTE 1                            mandelbrot-compute.mnd: SMOOTH   = PALETTE > 1;
   75:  set :line 8                                                  mandelbrot-compute.mnd: var line = 8;
   76:  set :increment 8                                             mandelbrot-compute.mnd: var increment = 8;
   77:  set :next_increment 16                                       mandelbrot-compute.mnd: var next_increment = 16;
   78:  op rand *tmp31 0.1 0                                         mandelbrot-compute.mnd: wait(rand(0.1));
   79:  wait *tmp31                                                  ...
   80:  set :lines 0                                                 mandelbrot-compute.mnd: MasterLoop:
        label *label86                                               ...
   81:  op mul *tmp32 17 :line                                       mandelbrot-compute.mnd: var x = (SKIP * line) % DISPLAY_SIZE_LARGE;
   82:  op mod :x *tmp32 176                                         ...
   83:  op add :position :x 158                                      mandelbrot-compute.mnd: var position = x + SLOTS;
   84:  read *tmp36 .memory :position                                mandelbrot-compute.mnd: if memory[position] == 0 then
   85:  jump *label40 notEqual *tmp36 0                              ...
   86:  write .PROCESSOR_ID .memory :position                        mandelbrot-compute.mnd: memory[position] = PROCESSOR_ID;
   87:  set :y 0                                                     mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
        label *label87                                               ...
   88:  op div *tmp42 :x .ZOOM                                       mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   89:  op add :compute.0:zx *tmp42 .OFFSET_X                        ...
   90:  op div *tmp44 :y .ZOOM                                       mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   91:  op add :compute.0:zy *tmp44 .OFFSET_Y                        ...
   92:  jump *label46 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   93:  set :compute.0:cx .JULIA_X                                   mandelbrot-compute.mnd: cx = JULIA_X;
   94:  set :compute.0:cy .JULIA_Y                                   mandelbrot-compute.mnd: cy = JULIA_Y;
   95:  jump *label47 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label46                                               ...
   96:  set :compute.0:cx :compute.0:zx                              mandelbrot-compute.mnd: cx = zx;
   97:  set :compute.0:cy :compute.0:zy                              mandelbrot-compute.mnd: cy = zy;
   98:  op sub *tmp47 :compute.0:zx 0.25                             mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   99:  op len :compute.0:p *tmp47 :compute.0:zy                     ...
  100:  op mul *tmp49 2 :compute.0:p                                 mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  101:  op mul *tmp50 *tmp49 :compute.0:p                            ...
  102:  op sub *tmp51 :compute.0:p *tmp50                            ...
  103:  op add *tmp52 *tmp51 0.25                                    ...
  104:  jump *label48 greaterThan :compute.0:zx *tmp52               ...
  105:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  106:  jump *label45 always 0 0                                     ...
        label *label48                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  107:  op add *tmp55 :compute.0:zx 1                                mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  108:  op len *tmp56 *tmp55 :compute.0:zy                           ...
  109:  jump *label50 greaterThan *tmp56 0.25                        ...
  110:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  111:  jump *label45 always 0 0                                     ...
        label *label50                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label47                                               mandelbrot-compute.mnd: if JULIA then
  112:  set :compute.0:i 0                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  113:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  114:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  115:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  116:  op sub *tmp61 *tmp59 *tmp60                                  ...
  117:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  118:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  119:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  120:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  121:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  122:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  123:  set :compute.0:i 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  124:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  125:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  126:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  127:  op sub *tmp61 *tmp59 *tmp60                                  ...
  128:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  129:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  130:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  131:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  132:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  133:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  134:  op add :compute.0:i 1 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  135:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  136:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  137:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  138:  op sub *tmp61 *tmp59 *tmp60                                  ...
  139:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  140:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  141:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  142:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  143:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  144:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  145:  op add :compute.0:i 2 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  146:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  147:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  148:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  149:  op sub *tmp61 *tmp59 *tmp60                                  ...
  150:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  151:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  152:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  153:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  154:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  155:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  156:  op add :compute.0:i 3 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  157:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  158:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  159:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  160:  op sub *tmp61 *tmp59 *tmp60                                  ...
  161:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  162:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  163:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  164:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  165:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  166:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  167:  op add :compute.0:i 4 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  168:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  169:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  170:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  171:  op sub *tmp61 *tmp59 *tmp60                                  ...
  172:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  173:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  174:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  175:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  176:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  177:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  178:  op add :compute.0:i 5 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  179:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  180:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  181:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  182:  op sub *tmp61 *tmp59 *tmp60                                  ...
  183:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  184:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  185:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  186:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  187:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  188:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  189:  op add :compute.0:i 6 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  190:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  191:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  192:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  193:  op sub *tmp61 *tmp59 *tmp60                                  ...
  194:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  195:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  196:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  197:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  198:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  199:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  200:  op add :compute.0:i 7 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  201:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  202:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  203:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  204:  op sub *tmp61 *tmp59 *tmp60                                  ...
  205:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  206:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  207:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  208:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  209:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  210:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  211:  op add :compute.0:i 8 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  212:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  213:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  214:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  215:  op sub *tmp61 *tmp59 *tmp60                                  ...
  216:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  217:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  218:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  219:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  220:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  221:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  222:  op add :compute.0:i 9 1                                      mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  223:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  224:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  225:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  226:  op sub *tmp61 *tmp59 *tmp60                                  ...
  227:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  228:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  229:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  230:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  231:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  232:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  233:  op add :compute.0:i 10 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  234:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  235:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  236:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  237:  op sub *tmp61 *tmp59 *tmp60                                  ...
  238:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  239:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  240:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  241:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  242:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  243:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  244:  op add :compute.0:i 11 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  245:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  246:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  247:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  248:  op sub *tmp61 *tmp59 *tmp60                                  ...
  249:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  250:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  251:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  252:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  253:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  254:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  255:  op add :compute.0:i 12 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  256:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  257:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  258:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  259:  op sub *tmp61 *tmp59 *tmp60                                  ...
  260:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  261:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  262:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  263:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  264:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  265:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  266:  op add :compute.0:i 13 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  267:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  268:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  269:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  270:  op sub *tmp61 *tmp59 *tmp60                                  ...
  271:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  272:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  273:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  274:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  275:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  276:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  277:  op add :compute.0:i 14 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  278:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  279:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  280:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  281:  op sub *tmp61 *tmp59 *tmp60                                  ...
  282:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  283:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  284:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  285:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  286:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  287:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  288:  op add :compute.0:i 15 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  289:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  290:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  291:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  292:  op sub *tmp61 *tmp59 *tmp60                                  ...
  293:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  294:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  295:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  296:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  297:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  298:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  299:  op add :compute.0:i 16 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  300:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  301:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  302:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  303:  op sub *tmp61 *tmp59 *tmp60                                  ...
  304:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  305:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  306:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  307:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  308:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  309:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  310:  op add :compute.0:i 17 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  311:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  312:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  313:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  314:  op sub *tmp61 *tmp59 *tmp60                                  ...
  315:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  316:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  317:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  318:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  319:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  320:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  321:  op add :compute.0:i 18 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  322:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  323:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  324:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  325:  op sub *tmp61 *tmp59 *tmp60                                  ...
  326:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  327:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  328:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  329:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  330:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  331:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  332:  op add :compute.0:i 19 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  333:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  334:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  335:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  336:  op sub *tmp61 *tmp59 *tmp60                                  ...
  337:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  338:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  339:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  340:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  341:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  342:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  343:  op add :compute.0:i 20 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  344:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  345:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  346:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  347:  op sub *tmp61 *tmp59 *tmp60                                  ...
  348:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  349:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  350:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  351:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  352:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  353:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  354:  op add :compute.0:i 21 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  355:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  356:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  357:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  358:  op sub *tmp61 *tmp59 *tmp60                                  ...
  359:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  360:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  361:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  362:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  363:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  364:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  365:  op add :compute.0:i 22 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  366:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  367:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  368:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  369:  op sub *tmp61 *tmp59 *tmp60                                  ...
  370:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  371:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  372:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  373:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  374:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  375:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  376:  op add :compute.0:i 23 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  377:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  378:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  379:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  380:  op sub *tmp61 *tmp59 *tmp60                                  ...
  381:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  382:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  383:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  384:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  385:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  386:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  387:  op add :compute.0:i 24 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  388:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  389:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  390:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  391:  op sub *tmp61 *tmp59 *tmp60                                  ...
  392:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  393:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  394:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  395:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  396:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  397:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  398:  op add :compute.0:i 25 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  399:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  400:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  401:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  402:  op sub *tmp61 *tmp59 *tmp60                                  ...
  403:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  404:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  405:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  406:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  407:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  408:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  409:  op add :compute.0:i 26 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  410:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  411:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  412:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  413:  op sub *tmp61 *tmp59 *tmp60                                  ...
  414:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  415:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  416:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  417:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  418:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  419:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  420:  op add :compute.0:i 27 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  421:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  422:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  423:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  424:  op sub *tmp61 *tmp59 *tmp60                                  ...
  425:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  426:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  427:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  428:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  429:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  430:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  431:  op add :compute.0:i 28 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  432:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  433:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  434:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  435:  op sub *tmp61 *tmp59 *tmp60                                  ...
  436:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  437:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  438:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  439:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  440:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  441:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  442:  op add :compute.0:i 29 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  443:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  444:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  445:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  446:  op sub *tmp61 *tmp59 *tmp60                                  ...
  447:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  448:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  449:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  450:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  451:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  452:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  453:  op add :compute.0:i 30 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  454:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  455:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  456:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  457:  op sub *tmp61 *tmp59 *tmp60                                  ...
  458:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  459:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  460:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  461:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  462:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  463:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  464:  op add :compute.0:i 31 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  465:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  466:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  467:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  468:  op sub *tmp61 *tmp59 *tmp60                                  ...
  469:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  470:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  471:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  472:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  473:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  474:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  475:  op add :compute.0:i 32 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  476:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  477:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  478:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  479:  op sub *tmp61 *tmp59 *tmp60                                  ...
  480:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  481:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  482:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  483:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  484:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  485:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  486:  op add :compute.0:i 33 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  487:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  488:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  489:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  490:  op sub *tmp61 *tmp59 *tmp60                                  ...
  491:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  492:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  493:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  494:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  495:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  496:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  497:  op add :compute.0:i 34 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  498:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  499:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  500:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  501:  op sub *tmp61 *tmp59 *tmp60                                  ...
  502:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  503:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  504:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  505:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  506:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  507:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  508:  op add :compute.0:i 35 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  509:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  510:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  511:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  512:  op sub *tmp61 *tmp59 *tmp60                                  ...
  513:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  514:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  515:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  516:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  517:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  518:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  519:  op add :compute.0:i 36 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  520:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  521:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  522:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  523:  op sub *tmp61 *tmp59 *tmp60                                  ...
  524:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  525:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  526:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  527:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  528:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  529:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  530:  op add :compute.0:i 37 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  531:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  532:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  533:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  534:  op sub *tmp61 *tmp59 *tmp60                                  ...
  535:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  536:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  537:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  538:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  539:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  540:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  541:  op add :compute.0:i 38 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  542:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  543:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  544:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  545:  op sub *tmp61 *tmp59 *tmp60                                  ...
  546:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  547:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  548:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  549:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  550:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  551:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  552:  op add :compute.0:i 39 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  553:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  554:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  555:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  556:  op sub *tmp61 *tmp59 *tmp60                                  ...
  557:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  558:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  559:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  560:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  561:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  562:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  563:  op add :compute.0:i 40 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  564:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  565:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  566:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  567:  op sub *tmp61 *tmp59 *tmp60                                  ...
  568:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  569:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  570:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  571:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  572:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  573:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  574:  op add :compute.0:i 41 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  575:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  576:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  577:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  578:  op sub *tmp61 *tmp59 *tmp60                                  ...
  579:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  580:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  581:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  582:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  583:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  584:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  585:  op add :compute.0:i 42 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  586:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  587:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  588:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  589:  op sub *tmp61 *tmp59 *tmp60                                  ...
  590:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  591:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  592:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  593:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  594:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  595:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  596:  op add :compute.0:i 43 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  597:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  598:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  599:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  600:  op sub *tmp61 *tmp59 *tmp60                                  ...
  601:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  602:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  603:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  604:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  605:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  606:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  607:  op add :compute.0:i 44 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  608:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  609:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  610:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  611:  op sub *tmp61 *tmp59 *tmp60                                  ...
  612:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  613:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  614:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  615:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  616:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  617:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  618:  op add :compute.0:i 45 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  619:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  620:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  621:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  622:  op sub *tmp61 *tmp59 *tmp60                                  ...
  623:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  624:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  625:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  626:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  627:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  628:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  629:  op add :compute.0:i 46 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  630:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  631:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  632:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  633:  op sub *tmp61 *tmp59 *tmp60                                  ...
  634:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  635:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  636:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  637:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  638:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  639:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  640:  op add :compute.0:i 47 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  641:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  642:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  643:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  644:  op sub *tmp61 *tmp59 *tmp60                                  ...
  645:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  646:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  647:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  648:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  649:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  650:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  651:  op add :compute.0:i 48 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  652:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  653:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  654:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  655:  op sub *tmp61 *tmp59 *tmp60                                  ...
  656:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  657:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  658:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  659:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  660:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  661:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  662:  op add :compute.0:i 49 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  663:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  664:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  665:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  666:  op sub *tmp61 *tmp59 *tmp60                                  ...
  667:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  668:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  669:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  670:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  671:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  672:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  673:  op add :compute.0:i 50 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  674:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  675:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  676:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  677:  op sub *tmp61 *tmp59 *tmp60                                  ...
  678:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  679:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  680:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  681:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  682:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  683:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  684:  op add :compute.0:i 51 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  685:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  686:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  687:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  688:  op sub *tmp61 *tmp59 *tmp60                                  ...
  689:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  690:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  691:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  692:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  693:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  694:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  695:  op add :compute.0:i 52 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  696:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  697:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  698:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  699:  op sub *tmp61 *tmp59 *tmp60                                  ...
  700:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  701:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  702:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  703:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  704:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  705:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  706:  op add :compute.0:i 53 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  707:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  708:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  709:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  710:  op sub *tmp61 *tmp59 *tmp60                                  ...
  711:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  712:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  713:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  714:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  715:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  716:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  717:  op add :compute.0:i 54 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  718:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  719:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  720:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  721:  op sub *tmp61 *tmp59 *tmp60                                  ...
  722:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  723:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  724:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  725:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  726:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  727:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  728:  op add :compute.0:i 55 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  729:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  730:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  731:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  732:  op sub *tmp61 *tmp59 *tmp60                                  ...
  733:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  734:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  735:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  736:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  737:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  738:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  739:  op add :compute.0:i 56 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  740:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  741:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  742:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  743:  op sub *tmp61 *tmp59 *tmp60                                  ...
  744:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  745:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  746:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  747:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  748:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  749:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  750:  op add :compute.0:i 57 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  751:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  752:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  753:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  754:  op sub *tmp61 *tmp59 *tmp60                                  ...
  755:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  756:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  757:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  758:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  759:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  760:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  761:  op add :compute.0:i 58 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  762:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  763:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  764:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  765:  op sub *tmp61 *tmp59 *tmp60                                  ...
  766:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  767:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  768:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  769:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  770:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  771:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  772:  op add :compute.0:i 59 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  773:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  774:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  775:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  776:  op sub *tmp61 *tmp59 *tmp60                                  ...
  777:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  778:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  779:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  780:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  781:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  782:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  783:  op add :compute.0:i 60 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  784:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  785:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  786:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  787:  op sub *tmp61 *tmp59 *tmp60                                  ...
  788:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  789:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  790:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  791:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  792:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  793:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  794:  op add :compute.0:i 61 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  795:  set :compute.0:x1 :compute.0:zx                              mandelbrot-compute.mnd: var x1 = zx;
  796:  op mul *tmp59 :compute.0:zx :compute.0:zx                    mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  797:  op mul *tmp60 :compute.0:zy :compute.0:zy                    ...
  798:  op sub *tmp61 *tmp59 *tmp60                                  ...
  799:  op add :compute.0:zx *tmp61 :compute.0:cx                    ...
  800:  op mul *tmp63 2 :compute.0:x1                                mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  801:  op mul *tmp64 *tmp63 :compute.0:zy                           ...
  802:  op add :compute.0:zy *tmp64 :compute.0:cy                    ...
  803:  op len :compute.0:dist :compute.0:zx :compute.0:zy           mandelbrot-compute.mnd: dist = len(zx, zy);
  804:  jump *label54 greaterThanEq :compute.0:dist 64               mandelbrot-compute.mnd: if dist >= 64 then
  805:  op add :compute.0:i 62 1                                     mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label54                                               ...
  806:  op mul *tmp69 .SMOOTH 63                                     mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  807:  jump *label57 greaterThanEq :compute.0:i *tmp69              ...
  808:  op log *tmp72 :compute.0:dist 0                              mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  809:  op mul *tmp73 *tmp72 0.36067376022224085                     ...
  810:  op log *tmp74 *tmp73 0                                       ...
  811:  op mul *tmp75 *tmp74 1.4426950408889634                      ...
  812:  op sub :compute.0:correction 4 *tmp75                        ...
  813:  op add :compute.0:i :compute.0:i :compute.0:correction       mandelbrot-compute.mnd: i += correction;
        label *label57                                               mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  814:  set *tmp41 :compute.0:i                                      mandelbrot-compute.mnd: return i;
        label *label45                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  815:  jump *label60 equal .SMOOTH false                            mandelbrot-compute.mnd: if SMOOTH then
  816:  jump *label62 notEqual *tmp41 63                             mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  817:  draw color 0 0 0 255 0 0                                     mandelbrot-compute.mnd: color(0, 0, 0, 255);
  818:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
        label *label62                                               ...
  819:  jump *label65 notEqual .PALETTE 2                            mandelbrot-compute.mnd: case PALETTE
  820:  op sub *tmp82 32 *tmp41                                      mandelbrot-compute.mnd: r = 255 - 7 * abs(32 - iterations);
  821:  op abs *tmp83 *tmp82 0                                       ...
  822:  op mul *tmp84 7 *tmp83                                       ...
  823:  op sub :drawPixel.0:r 255 *tmp84                             ...
  824:  op sub *tmp86 *tmp41 32                                      mandelbrot-compute.mnd: g = 240 - 6 * abs(iterations - 32);
  825:  op abs *tmp87 *tmp86 0                                       ...
  826:  op mul *tmp88 6 *tmp87                                       ...
  827:  op sub :drawPixel.0:g 240 *tmp88                             ...
  828:  op mul *tmp92 4 *tmp83                                       mandelbrot-compute.mnd: b = 120 + 4 * abs(32 - iterations);
  829:  op add :drawPixel.0:b 120 *tmp92                             ...
  830:  draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255  mandelbrot-compute.mnd: color(r, g, b, 255);
  831:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label65                                               ...
  832:  jump *label67 notEqual .PALETTE 3                            ...
  833:  op div *tmp95 *tmp41 0.175                                   mandelbrot-compute.mnd: r = 255 * sin(iterations / MAX_DEPTH * 360);
  834:  op sin *tmp96 *tmp95 0                                       ...
  835:  op mul :drawPixel.0:r 255 *tmp96                             ...
  836:  op cos *tmp100 *tmp95 0                                      mandelbrot-compute.mnd: g = 255 * cos(iterations / MAX_DEPTH * 360);
  837:  op mul :drawPixel.0:g 255 *tmp100                            ...
  838:  op sub *tmp102 *tmp41 32                                     mandelbrot-compute.mnd: b = 100 + 4 * abs(iterations - 32);
  839:  op abs *tmp103 *tmp102 0                                     ...
  840:  op mul *tmp104 4 *tmp103                                     ...
  841:  op add :drawPixel.0:b 100 *tmp104                            ...
  842:  draw color :drawPixel.0:r :drawPixel.0:g :drawPixel.0:b 255  mandelbrot-compute.mnd: color(r, g, b, 255);
  843:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label67                                               ...
  844:  jump *label69 notEqual .PALETTE 4                            ...
  845:  op mul :drawPixel.0:r 4 *tmp41                               mandelbrot-compute.mnd: r = 4 * iterations;
  846:  op mul *tmp107 1.5 *tmp41                                    mandelbrot-compute.mnd: g = 96 + 1.5 * iterations;
  847:  op add :drawPixel.0:g 96 *tmp107                             ...
  848:  draw color :drawPixel.0:r :drawPixel.0:g 0 255 0 0           mandelbrot-compute.mnd: color(r, g, 0, 255);
  849:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label69                                               ...
  850:  op mul *tmp109 4 *tmp41                                      mandelbrot-compute.mnd: r = 255 - 4 * iterations;
  851:  op sub :drawPixel.0:r 255 *tmp109                            ...
  852:  draw color :drawPixel.0:r :drawPixel.0:r 0 255 0 0           mandelbrot-compute.mnd: color(r, r, 0, 255);
  853:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label60                                               ...
  854:  read *tmp112 .memory *tmp41                                  mandelbrot-compute.mnd: col(memory[iterations]);
  855:  draw col *tmp112 0 0 0 0 0                                   ...
        label *label61                                               mandelbrot-compute.mnd: if SMOOTH then
  856:  draw rect :x :y 1 1 0 0                                      mandelbrot-compute.mnd: rect(x, y, 1, 1);
  857:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  858:  read *tmp114 .memory :position                               mandelbrot-compute.mnd: if memory[position] != PROCESSOR_ID then
  859:  jump *label44 notEqual *tmp114 .PROCESSOR_ID                 ...
  860:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: if stop != $STOP then
  861:  jump *label39 notEqual .stop *tmp1                           ...
  862:  op add :y :y 1                                               mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
  863:  jump *label87 lessThan :y 176                                ...
        label *label44                                               ...
        label *label40                                               mandelbrot-compute.mnd: if memory[position] == 0 then
  864:  op add :line :line :increment                                mandelbrot-compute.mnd: line += increment;
  865:  jump *label75 lessThanEq :line 176                           mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  866:  op div :next_increment :next_increment 2                     mandelbrot-compute.mnd: increment = next_increment /= 2;
  867:  set :increment :next_increment                               ...
  868:  op div :line :next_increment 2                               mandelbrot-compute.mnd: line = increment / 2;
        label *label75                                               mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  869:  op add :lines :lines 1                                       mandelbrot-compute.mnd: MasterLoop:
  870:  jump *label86 lessThan :lines 176                            ...
        label *label39                                               ...
  871:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  872:  jump *label29 always 0 0                                     mandelbrot-compute.mnd: while true do


Performance: parsed in 247 ms, compiled in 223 ms, optimized in 2,111 ms, run in 37 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Display: display
Memory: bank
Execution step limit of 100000 exceeded.
