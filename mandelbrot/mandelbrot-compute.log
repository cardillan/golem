   362 instructions before optimizations.
    30 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    36 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 4 iterations).
    17 instructions eliminated by Jump Optimization (4 iterations).
    14 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     8 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
    51 instructions eliminated by Data Flow Optimization (5 passes, 20 iterations).
     3 instructions eliminated by Loop Optimization (3 iterations).
     5 loops improved by Loop Optimization.
   742 instructions added by Loop Unrolling (8 iterations).
     4 loops unrolled by Loop Unrolling.
     9 instructions added by Function Inlining (8 iterations).
     2 function calls inlined by Function Inlining.
    68 instructions eliminated by Jump Straightening (2 passes, 4 iterations).
     4 instructions updated by JumpThreading.
     5 instructions eliminated by Unreachable Code Elimination.
     6 instructions eliminated by Print Merging.
   871 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 781):
  * Unroll iteration loop at *blocks:57:9                        cost     0, benefit      125.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:66:13                       cost     3, benefit     3125.0, efficiency     1041.7
    Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9
    Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 785):
    Unroll iteration loop at *blocks:66:13                       cost     3, benefit     3125.0, efficiency     1041.7
    Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9
  * Unroll loop at mandelbrot-compute.mnd:132:5                  cost   679, benefit 24609375.0, efficiency    36243.6 (+743 instructions)
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 42):
  * Unroll iteration loop at *blocks:66:13                       cost     3, benefit     3125.0, efficiency     1041.7 (-5 instructions)
    Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9
    Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 47):
    Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9
  * Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 cost    13, benefit     2275.0, efficiency      175.0 (+7 instructions)
    Inline function call at mandelbrot-compute.mnd:48:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:56:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 40):
  * Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9 (+0 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   281 set *tmp79 null
   282 jump *label63 always
   283 label *label62
-    * set *tmp81 .PALETTE
-    * jump *label66 equal *tmp81 2
+  284 jump *label66 equal .PALETTE 2
   285 jump *label65 always
   286 label *label66
   287 op sub *tmp82 32 :fn3:iterations
 
   303 set *tmp80 null
   304 jump *label64 always
   305 label *label65
-    * jump *label68 equal *tmp81 3
+  306 jump *label68 equal .PALETTE 3
   307 jump *label67 always
   308 label *label68
   309 op div *tmp94 :fn3:iterations 63
 
   325 set *tmp80 null
   326 jump *label64 always
   327 label *label67
-    * jump *label70 equal *tmp81 4
+  328 jump *label70 equal .PALETTE 4
   329 jump *label69 always
   330 label *label70
   331 op mul *tmp106 4 :fn3:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-24 instructions):
 
    65 label *label20
    66 set *tmp21 null
    67 label *label21
-    * set *tmp19 *tmp21
    68 jump *label19 always
    69 label *label18
-    * set *tmp19 null
    70 label *label19
    71 label *label14
    72 goto *tmp17 marker1
 
    98 print :fn1:variable
    99 jump *label27 equal :fn1:required false
   100 op and :fn1:foundAll :fn1:foundAll :fn1:variable
-    * set *tmp23 :fn1:foundAll
   101 jump *label28 always
   102 label *label27
-    * set *tmp23 null
   103 label *label28
   104 label *label23
   105 goto *tmp22 marker2
 
   185 jump *label46 equal .JULIA false
   186 set :fn2:cx .JULIA_X
   187 set :fn2:cy .JULIA_Y
-    * set *tmp46 :fn2:cy
   188 jump *label47 always
   189 label *label46
   190 set :fn2:cx :fn2:zx
 
   200 jump *label48 equal *tmp53 false
   201 set *tmp41 63
   202 jump *label45 always
-    * set *tmp54 null
   203 jump *label49 always
   204 label *label48
-    * set *tmp54 null
   205 label *label49
   206 op add *tmp55 :fn2:cx 1
   207 op len *tmp56 *tmp55 :fn2:cy
 
   214 label *label50
   215 set *tmp58 null
   216 label *label51
-    * set *tmp46 *tmp58
   217 label *label47
   218 set :fn2:i 0
   219 label *label52
 
   234 op greaterThanEq *tmp67 :fn2:dist 64
   235 jump *label55 equal *tmp67 false
   236 jump *label54 always
-    * set *tmp68 null
   237 jump *label56 always
   238 label *label55
-    * set *tmp68 null
   239 label *label56
   240 label *label53
   241 op add :fn2:i :fn2:i 1
 
   251 op sub *tmp76 4 *tmp75
   252 set :fn2:correction *tmp76
   253 op add :fn2:i :fn2:i :fn2:correction
-    * set *tmp71 :fn2:i
   254 jump *label58 always
   255 label *label57
-    * set *tmp71 null
   256 label *label58
   257 set *tmp41 :fn2:i
   258 jump *label45 always
 
   333 label *label64
   334 set *tmp79 *tmp80
   335 label *label63
-    * set *tmp77 *tmp79
   336 jump *label61 always
   337 label *label60
   338 set *tmp111 :fn3:iterations
   339 read *tmp112 .memory *tmp111
   340 draw col *tmp112
-    * set *tmp77 null
   341 label *label61
   342 draw rect :fn3:x :fn3:y 1 1
   343 drawflush .display
 
   347 op notEqual *tmp115 *tmp114 .PROCESSOR_ID
   348 jump *label71 equal *tmp115 false
   349 jump *label44 always
-    * set *tmp116 null
   350 jump *label72 always
   351 label *label71
-    * set *tmp116 null
   352 label *label72
   353 read *tmp1 .memory 65
   354 op notEqual *tmp117 .stop *tmp1
   355 jump *label73 equal *tmp117 false
   356 jump *label39 always
-    * set *tmp118 null
   357 jump *label74 always
   358 label *label73
-    * set *tmp118 null
   359 label *label74
   360 label *label43
   361 op add :y :y 1
   362 jump *label42 always
   363 label *label44
-    * set *tmp38 null
   364 jump *label41 always
   365 label *label40
-    * set *tmp38 null
   366 label *label41
   367 op add :line :line :increment
   368 op greaterThan *tmp119 :line 176
 
   371 set :increment :next_increment
   372 op div *tmp121 :increment 2
   373 set :line *tmp121
-    * set *tmp120 :line
   374 jump *label76 always
   375 label *label75
-    * set *tmp120 null
   376 label *label76
   377 label *label38
   378 op add :lines :lines 1
 
   394 set *tmp127 .PROC_STATE_INDEX
   395 write :fn0:state .memory *tmp127
   396 jump *label80 always
-    * set *tmp126 null
   397 jump *label82 always
   398 label *label81
   399 set *tmp129 .PROC_ID_INDEX
 
   412 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
   413 set *tmp132 .PROC_STATE_INDEX
   414 label *label84
-    * set *tmp126 *tmp132
   415 label *label82
   416 label *label79
   417 jump *label78 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-8 instructions):
 
    60 op equal *tmp20 :fn1:requested @message
    61 jump *label20 equal *tmp20 false
    62 set :fn1:message :fn1:block
-    * set *tmp21 :fn1:message
    63 jump *label21 always
    64 label *label20
-    * set *tmp21 null
    65 label *label21
    66 jump *label19 always
    67 label *label18
 
   207 jump *label50 equal *tmp57 false
   208 set *tmp41 63
   209 jump *label45 always
-    * set *tmp58 null
   210 jump *label51 always
   211 label *label50
-    * set *tmp58 null
   212 label *label51
   213 label *label47
   214 set :fn2:i 0
 
   262 op equal *tmp78 :fn3:iterations 63
   263 jump *label62 equal *tmp78 false
   264 draw color 0 0 0 255
-    * set *tmp79 null
   265 jump *label63 always
   266 label *label62
   267 jump *label66 equal .PALETTE 2
 
   326 draw color :fn3:r :fn3:r 0 255
   327 set *tmp80 null
   328 label *label64
-    * set *tmp79 *tmp80
   329 label *label63
   330 jump *label61 always
   331 label *label60
 
   399 set *tmp135 .PROC_STATE_INDEX
   400 write :fn0:state .memory *tmp135
   401 jump *label80 always
-    * set *tmp132 null
   402 jump *label84 always
   403 label *label83
   404 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   405 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * set *tmp132 .PROC_STATE_INDEX
   406 label *label84
   407 label *label82
   408 label *label79

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   283 op add *tmp93 120 *tmp92
   284 set :fn3:b *tmp93
   285 draw color :fn3:r :fn3:g :fn3:b 255
-    * set *tmp80 null
   286 jump *label64 always
   287 label *label65
   288 jump *label68 equal .PALETTE 3
 
   304 op add *tmp105 100 *tmp104
   305 set :fn3:b *tmp105
   306 draw color :fn3:r :fn3:g :fn3:b 255
-    * set *tmp80 null
   307 jump *label64 always
   308 label *label67
   309 jump *label70 equal .PALETTE 4
 
   315 op add *tmp108 96 *tmp107
   316 set :fn3:g *tmp108
   317 draw color :fn3:r :fn3:g 0 255
-    * set *tmp80 null
   318 jump *label64 always
   319 label *label69
   320 op mul *tmp109 4 :fn3:iterations
   321 op sub *tmp110 255 *tmp109
   322 set :fn3:r *tmp110
   323 draw color :fn3:r :fn3:r 0 255
-    * set *tmp80 null
   324 label *label64
   325 label *label63
   326 jump *label61 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-30 instructions):
     0 sensor *tmp9 @this @x
     1 sensor *tmp10 @this @y
     2 op mul *tmp11 10000 *tmp10
-    * op add *tmp12 *tmp9 *tmp11
-    * set .PROCESSOR_ID *tmp12
+    3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
 
    33 op greaterThan *tmp14 :fn1:n 0
    34 jump *label12 equal *tmp14 false
    35 op sub :fn1:n :fn1:n 1
-    * getlink *tmp15 :fn1:n
-    * set :fn1:block *tmp15
+   36 getlink :fn1:block :fn1:n
    37 print "\nFound: "
    38 print :fn1:block
-    * sensor *tmp16 :fn1:block @type
-    * set :fn1:type *tmp16
+   39 sensor :fn1:type :fn1:block @type
    40 setaddr *tmp17 *label16
    41 set :fn1:requested @large-logic-display
    42 set :fn1:name "Display"
 
   127 setaddr :fn0*retaddr *label36
   128 call *label0 :fn0*retval
   129 gotolabel *label36 :fn0
-    * read *tmp4 .memory 68
-    * set .ZOOM *tmp4
+  130 read .ZOOM .memory 68
   131 op div *tmp26 -88 .ZOOM
   132 read *tmp2 .memory 66
-    * op add *tmp27 *tmp26 *tmp2
-    * set .OFFSET_X *tmp27
+  133 op add .OFFSET_X *tmp26 *tmp2
   134 op div *tmp28 -88 .ZOOM
   135 read *tmp3 .memory 67
-    * op add *tmp29 *tmp28 *tmp3
-    * set .OFFSET_Y *tmp29
-    * read *tmp5 .memory 69
-    * set .JULIA *tmp5
-    * read *tmp6 .memory 70
-    * set .JULIA_X *tmp6
-    * read *tmp7 .memory 71
-    * set .JULIA_Y *tmp7
-    * read *tmp8 .memory 72
-    * set .PALETTE *tmp8
-    * op greaterThan *tmp30 .PALETTE 1
-    * set .SMOOTH *tmp30
+  136 op add .OFFSET_Y *tmp28 *tmp3
+  137 read .JULIA .memory 69
+  138 read .JULIA_X .memory 70
+  139 read .JULIA_Y .memory 71
+  140 read .PALETTE .memory 72
+  141 op greaterThan .SMOOTH .PALETTE 1
   142 set :line 8
   143 set :increment 8
   144 set :next_increment 16
 
   148 label *label37
   149 jump *label39 greaterThanEq :lines 176
   150 op mul *tmp32 17 :line
-    * op mod *tmp33 *tmp32 176
-    * set :x *tmp33
-    * op add *tmp34 :x 158
-    * set :position *tmp34
+  151 op mod :x *tmp32 176
+  152 op add :position :x 158
   153 set *tmp35 :position
   154 read *tmp36 .memory *tmp35
   155 op equal *tmp37 *tmp36 0
 
   162 set :fn2:x :x
   163 set :fn2:y :y
   164 op div *tmp42 :fn2:x .ZOOM
-    * op add *tmp43 *tmp42 .OFFSET_X
-    * set :fn2:zx *tmp43
+  165 op add :fn2:zx *tmp42 .OFFSET_X
   166 op div *tmp44 :fn2:y .ZOOM
-    * op add *tmp45 *tmp44 .OFFSET_Y
-    * set :fn2:zy *tmp45
+  167 op add :fn2:zy *tmp44 .OFFSET_Y
   168 jump *label46 equal .JULIA false
   169 set :fn2:cx .JULIA_X
   170 set :fn2:cy .JULIA_Y
 
   173 set :fn2:cx :fn2:zx
   174 set :fn2:cy :fn2:zy
   175 op sub *tmp47 :fn2:cx 0.25
-    * op len *tmp48 *tmp47 :fn2:cy
-    * set :fn2:p *tmp48
+  176 op len :fn2:p *tmp47 :fn2:cy
   177 op mul *tmp49 2 :fn2:p
   178 op mul *tmp50 *tmp49 :fn2:p
   179 op sub *tmp51 :fn2:p *tmp50
 
   203 op mul *tmp59 :fn2:x1 :fn2:x1
   204 op mul *tmp60 :fn2:y1 :fn2:y1
   205 op sub *tmp61 *tmp59 *tmp60
-    * op add *tmp62 *tmp61 :fn2:cx
-    * set :fn2:zx *tmp62
+  206 op add :fn2:zx *tmp61 :fn2:cx
   207 op mul *tmp63 2 :fn2:x1
   208 op mul *tmp64 *tmp63 :fn2:y1
-    * op add *tmp65 *tmp64 :fn2:cy
-    * set :fn2:zy *tmp65
-    * op len *tmp66 :fn2:zx :fn2:zy
-    * set :fn2:dist *tmp66
+  209 op add :fn2:zy *tmp64 :fn2:cy
+  210 op len :fn2:dist :fn2:zx :fn2:zy
   211 op greaterThanEq *tmp67 :fn2:dist 64
   212 jump *label55 equal *tmp67 false
   213 jump *label54 always
 
   225 op mul *tmp73 *tmp72 0.36067376022224085
   226 op log *tmp74 *tmp73
   227 op mul *tmp75 *tmp74 1.4426950408889634
-    * op sub *tmp76 4 *tmp75
-    * set :fn2:correction *tmp76
+  228 op sub :fn2:correction 4 *tmp75
   229 op add :fn2:i :fn2:i :fn2:correction
   230 jump *label58 always
   231 label *label57
 
   250 op sub *tmp82 32 :fn3:iterations
   251 op abs *tmp83 *tmp82
   252 op mul *tmp84 7 *tmp83
-    * op sub *tmp85 255 *tmp84
-    * set :fn3:r *tmp85
+  253 op sub :fn3:r 255 *tmp84
   254 op sub *tmp86 :fn3:iterations 32
   255 op abs *tmp87 *tmp86
   256 op mul *tmp88 6 *tmp87
-    * op sub *tmp89 240 *tmp88
-    * set :fn3:g *tmp89
+  257 op sub :fn3:g 240 *tmp88
   258 op sub *tmp90 32 :fn3:iterations
   259 op abs *tmp91 *tmp90
   260 op mul *tmp92 4 *tmp91
-    * op add *tmp93 120 *tmp92
-    * set :fn3:b *tmp93
+  261 op add :fn3:b 120 *tmp92
   262 draw color :fn3:r :fn3:g :fn3:b 255
   263 jump *label64 always
   264 label *label65
 
   268 op div *tmp94 :fn3:iterations 63
   269 op mul *tmp95 *tmp94 360
   270 op sin *tmp96 *tmp95
-    * op mul *tmp97 255 *tmp96
-    * set :fn3:r *tmp97
+  271 op mul :fn3:r 255 *tmp96
   272 op div *tmp98 :fn3:iterations 63
   273 op mul *tmp99 *tmp98 360
   274 op cos *tmp100 *tmp99
-    * op mul *tmp101 255 *tmp100
-    * set :fn3:g *tmp101
+  275 op mul :fn3:g 255 *tmp100
   276 op sub *tmp102 :fn3:iterations 32
   277 op abs *tmp103 *tmp102
   278 op mul *tmp104 4 *tmp103
-    * op add *tmp105 100 *tmp104
-    * set :fn3:b *tmp105
+  279 op add :fn3:b 100 *tmp104
   280 draw color :fn3:r :fn3:g :fn3:b 255
   281 jump *label64 always
   282 label *label67
   283 jump *label70 equal .PALETTE 4
   284 jump *label69 always
   285 label *label70
-    * op mul *tmp106 4 :fn3:iterations
-    * set :fn3:r *tmp106
+  286 op mul :fn3:r 4 :fn3:iterations
   287 op mul *tmp107 1.5 :fn3:iterations
-    * op add *tmp108 96 *tmp107
-    * set :fn3:g *tmp108
+  288 op add :fn3:g 96 *tmp107
   289 draw color :fn3:r :fn3:g 0 255
   290 jump *label64 always
   291 label *label69
   292 op mul *tmp109 4 :fn3:iterations
-    * op sub *tmp110 255 *tmp109
-    * set :fn3:r *tmp110
+  293 op sub :fn3:r 255 *tmp109
   294 draw color :fn3:r :fn3:r 0 255
   295 label *label64
   296 label *label63
 
   330 jump *label75 equal *tmp119 false
   331 op div :next_increment :next_increment 2
   332 set :increment :next_increment
-    * op div *tmp121 :increment 2
-    * set :line *tmp121
+  333 op div :line :increment 2
   334 jump *label76 always
   335 label *label75
   336 label *label76

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
   108 label *label4
   109 label *label1
   110 label *label29
-    * jump *label31 equal true false
   111 label *label32
   112 set :fn0:state 0
   113 setaddr :fn0*retaddr *label35

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   243 draw color 0 0 0 255
   244 jump *label63 always
   245 label *label62
-    * jump *label66 equal .PALETTE 2
-    * jump *label65 always
+  246 jump *label65 notEqual .PALETTE 2
   247 label *label66
   248 op sub *tmp82 32 :fn3:iterations
   249 op abs *tmp83 *tmp82
 
   260 draw color :fn3:r :fn3:g :fn3:b 255
   261 jump *label64 always
   262 label *label65
-    * jump *label68 equal .PALETTE 3
-    * jump *label67 always
+  263 jump *label67 notEqual .PALETTE 3
   264 label *label68
   265 op div *tmp94 :fn3:iterations 63
   266 op mul *tmp95 *tmp94 360
 
   277 draw color :fn3:r :fn3:g :fn3:b 255
   278 jump *label64 always
   279 label *label67
-    * jump *label70 equal .PALETTE 4
-    * jump *label69 always
+  280 jump *label69 notEqual .PALETTE 4
   281 label *label70
   282 op mul :fn3:r 4 :fn3:iterations
   283 op mul *tmp107 1.5 :fn3:iterations

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-17 instructions):
 
    30 print :fn1:title
    31 set :fn1:n @links
    32 label *label10
-    * op greaterThan *tmp14 :fn1:n 0
-    * jump *label12 equal *tmp14 false
+   33 jump *label12 lessThanEq :fn1:n 0
    34 op sub :fn1:n :fn1:n 1
    35 getlink :fn1:block :fn1:n
    36 print "\nFound: "
 
    50 set :fn1:variable .memory
    51 set :fn1:required true
    52 label *label13
-    * op equal *tmp18 :fn1:requested :fn1:type
-    * jump *label18 equal *tmp18 false
+   53 jump *label18 notEqual :fn1:requested :fn1:type
    54 set :fn1:variable :fn1:block
-    * op equal *tmp20 :fn1:requested @message
-    * jump *label20 equal *tmp20 false
+   55 jump *label20 notEqual :fn1:requested @message
    56 set :fn1:message :fn1:block
    57 jump *label21 always
    58 label *label20
 
   100 label *label24
   101 printflush :fn1:message
   102 label *label3
-    * op equal *tmp24 :fn1:foundAll false
-    * jump *label2 notEqual *tmp24 false
+  103 jump *label2 equal :fn1:foundAll false
   104 label *label4
   105 label *label1
   106 label *label29
 
   111 gotolabel *label35 :fn0
   112 label *label33
   113 read *tmp0 .memory 64
-    * op equal *tmp25 .start *tmp0
-    * jump *label32 notEqual *tmp25 false
+  114 jump *label32 equal .start *tmp0
   115 label *label34
   116 read *tmp0 .memory 64
   117 set .start *tmp0
 
   146 op add :position :x 158
   147 set *tmp35 :position
   148 read *tmp36 .memory *tmp35
-    * op equal *tmp37 *tmp36 0
-    * jump *label40 equal *tmp37 false
+  149 jump *label40 notEqual *tmp36 0
   150 set *tmp39 :position
   151 write .PROCESSOR_ID .memory *tmp39
   152 set :y 0
 
   171 op mul *tmp50 *tmp49 :fn2:p
   172 op sub *tmp51 :fn2:p *tmp50
   173 op add *tmp52 *tmp51 0.25
-    * op lessThanEq *tmp53 :fn2:cx *tmp52
-    * jump *label48 equal *tmp53 false
+  174 jump *label48 greaterThan :fn2:cx *tmp52
   175 set *tmp41 63
   176 jump *label45 always
   177 jump *label49 always
 
   179 label *label49
   180 op add *tmp55 :fn2:cx 1
   181 op len *tmp56 *tmp55 :fn2:cy
-    * op lessThanEq *tmp57 *tmp56 0.25
-    * jump *label50 equal *tmp57 false
+  182 jump *label50 greaterThan *tmp56 0.25
   183 set *tmp41 63
   184 jump *label45 always
   185 jump *label51 always
 
   199 op mul *tmp64 *tmp63 :fn2:y1
   200 op add :fn2:zy *tmp64 :fn2:cy
   201 op len :fn2:dist :fn2:zx :fn2:zy
-    * op greaterThanEq *tmp67 :fn2:dist 64
-    * jump *label55 equal *tmp67 false
+  202 jump *label55 lessThan :fn2:dist 64
   203 jump *label54 always
   204 jump *label56 always
   205 label *label55
 
   209 jump *label52 always
   210 label *label54
   211 op mul *tmp69 .SMOOTH 63
-    * op lessThan *tmp70 :fn2:i *tmp69
-    * jump *label57 equal *tmp70 false
+  212 jump *label57 greaterThanEq :fn2:i *tmp69
   213 op log *tmp72 :fn2:dist
   214 op mul *tmp73 *tmp72 0.36067376022224085
   215 op log *tmp74 *tmp73
 
   228 set :fn3:y :y
   229 set :fn3:iterations :iterations
   230 jump *label60 equal .SMOOTH false
-    * op equal *tmp78 :fn3:iterations 63
-    * jump *label62 equal *tmp78 false
+  231 jump *label62 notEqual :fn3:iterations 63
   232 draw color 0 0 0 255
   233 jump *label63 always
   234 label *label62
 
   290 label *label59
   291 set *tmp113 :position
   292 read *tmp114 .memory *tmp113
-    * op notEqual *tmp115 *tmp114 .PROCESSOR_ID
-    * jump *label71 equal *tmp115 false
+  293 jump *label71 equal *tmp114 .PROCESSOR_ID
   294 jump *label44 always
   295 jump *label72 always
   296 label *label71
   297 label *label72
   298 read *tmp1 .memory 65
-    * op notEqual *tmp117 .stop *tmp1
-    * jump *label73 equal *tmp117 false
+  299 jump *label73 equal .stop *tmp1
   300 jump *label39 always
   301 jump *label74 always
   302 label *label73
 
   309 label *label40
   310 label *label41
   311 op add :line :line :increment
-    * op greaterThan *tmp119 :line 176
-    * jump *label75 equal *tmp119 false
+  312 jump *label75 lessThanEq :line 176
   313 op div :next_increment :next_increment 2
   314 set :increment :next_increment
   315 op div :line :increment 2
 
   327 end
   328 label *label0
   329 label *label78
-    * op lessThan *tmp122 .PROC_STATE_INDEX 512
-    * jump *label80 equal *tmp122 false
+  330 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
   331 set *tmp123 .PROC_ID_INDEX
   332 read *tmp124 .memory *tmp123
-    * op equal *tmp125 *tmp124 .PROCESSOR_ID
-    * jump *label81 equal *tmp125 false
+  333 jump *label81 notEqual *tmp124 .PROCESSOR_ID
   334 set *tmp127 .PROC_STATE_INDEX
   335 write :fn0:state .memory *tmp127
   336 jump *label80 always
 
   338 label *label81
   339 set *tmp129 .PROC_ID_INDEX
   340 read *tmp130 .memory *tmp129
-    * op equal *tmp131 *tmp130 0
-    * jump *label83 equal *tmp131 false
+  341 jump *label83 notEqual *tmp130 0
   342 set *tmp133 .PROC_ID_INDEX
   343 write .PROCESSOR_ID .memory *tmp133
   344 set *tmp135 .PROC_STATE_INDEX

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-11 instructions):
 
    54 set :fn1:variable :fn1:block
    55 jump *label20 notEqual :fn1:requested @message
    56 set :fn1:message :fn1:block
-    * jump *label21 always
    57 label *label20
    58 label *label21
-    * jump *label19 always
    59 label *label18
    60 label *label19
    61 label *label14
 
    88 print :fn1:variable
    89 jump *label27 equal :fn1:required false
    90 op and :fn1:foundAll :fn1:foundAll :fn1:variable
-    * jump *label28 always
    91 label *label27
    92 label *label28
    93 label *label23
 
   171 jump *label48 greaterThan :fn2:cx *tmp52
   172 set *tmp41 63
   173 jump *label45 always
-    * jump *label49 always
   174 label *label48
   175 label *label49
   176 op add *tmp55 :fn2:cx 1
 
   178 jump *label50 greaterThan *tmp56 0.25
   179 set *tmp41 63
   180 jump *label45 always
-    * jump *label51 always
   181 label *label50
   182 label *label51
   183 label *label47
 
   196 op len :fn2:dist :fn2:zx :fn2:zy
   197 jump *label55 lessThan :fn2:dist 64
   198 jump *label54 always
-    * jump *label56 always
   199 label *label55
   200 label *label56
   201 label *label53
 
   210 op mul *tmp75 *tmp74 1.4426950408889634
   211 op sub :fn2:correction 4 *tmp75
   212 op add :fn2:i :fn2:i :fn2:correction
-    * jump *label58 always
   213 label *label57
   214 label *label58
   215 set *tmp41 :fn2:i
 
   285 read *tmp114 .memory *tmp113
   286 jump *label71 equal *tmp114 .PROCESSOR_ID
   287 jump *label44 always
-    * jump *label72 always
   288 label *label71
   289 label *label72
   290 read *tmp1 .memory 65
   291 jump *label73 equal .stop *tmp1
   292 jump *label39 always
-    * jump *label74 always
   293 label *label73
   294 label *label74
   295 label *label43
   296 op add :y :y 1
   297 jump *label42 always
   298 label *label44
-    * jump *label41 always
   299 label *label40
   300 label *label41
   301 op add :line :line :increment
 
   303 op div :next_increment :next_increment 2
   304 set :increment :next_increment
   305 op div :line :increment 2
-    * jump *label76 always
   306 label *label75
   307 label *label76
   308 label *label38

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
-    * sensor *tmp9 @this @x
-    * sensor *tmp10 @this @y
+    0 set *tmp9 @thisx
+    1 set *tmp10 @thisy
     2 op mul *tmp11 10000 *tmp10
     3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     8 set :fn1:message null
     9 label *label2
    10 setaddr *tmp13 *label8
-    * set :fn1:requested @large-logic-display
-    * set :fn1:name "Display"
-    * set :fn1:variable .display
-    * set :fn1:required true
    11 jump *label5 always
    12 gotolabel *label8 marker0
-    * set .display :fn1:variable
+   13 set .display null
    14 setaddr *tmp13 *label9
-    * set :fn1:requested @memory-bank
-    * set :fn1:name "Memory"
-    * set :fn1:variable .memory
-    * set :fn1:required true
    15 label *label5
    16 set :fn1:variable null
    17 label *label6
    18 goto *tmp13 marker0
    19 gotolabel *label9 marker0
-    * set .memory :fn1:variable
+   20 set .memory null
    21 label *label7
-    * print :fn1:title
+   22 print "Mandelbrot Generator"
    23 set :fn1:n @links
    24 label *label10
    25 jump *label12 lessThanEq :fn1:n 0
 
    30 sensor :fn1:type :fn1:block @type
    31 setaddr *tmp17 *label16
    32 set :fn1:requested @large-logic-display
-    * set :fn1:name "Display"
    33 set :fn1:variable .display
-    * set :fn1:required true
    34 jump *label13 always
    35 gotolabel *label16 marker1
    36 set .display :fn1:variable
    37 setaddr *tmp17 *label17
    38 set :fn1:requested @memory-bank
-    * set :fn1:name "Memory"
    39 set :fn1:variable .memory
-    * set :fn1:required true
    40 label *label13
    41 jump *label18 notEqual :fn1:requested :fn1:type
    42 set :fn1:variable :fn1:block
 
    56 label *label12
    57 set :fn1:foundAll 1
    58 setaddr *tmp22 *label25
-    * set :fn1:requested @large-logic-display
    59 set :fn1:name "Display"
    60 set :fn1:variable .display
    61 set :fn1:required true
 
    63 gotolabel *label25 marker2
    64 set .display :fn1:variable
    65 setaddr *tmp22 *label26
-    * set :fn1:requested @memory-bank
    66 set :fn1:name "Memory"
    67 set :fn1:variable .memory
    68 set :fn1:required true
 
    72 print ":"
    73 print " "
    74 print :fn1:variable
-    * jump *label27 equal :fn1:required false
+   75 jump *label27 equal true false
    76 op and :fn1:foundAll :fn1:foundAll :fn1:variable
    77 label *label27
    78 label *label28
 
   100 set .start *tmp0
   101 read *tmp1 .memory 65
   102 set .stop *tmp1
-    * set :fn0:state .start
+  103 set :fn0:state *tmp0
   104 setaddr :fn0*retaddr *label36
   105 call *label0 :fn0*retval
   106 gotolabel *label36 :fn0
 
   110 op add .OFFSET_X *tmp26 *tmp2
   111 op div *tmp28 -88 .ZOOM
   112 read *tmp3 .memory 67
-    * op add .OFFSET_Y *tmp28 *tmp3
+  113 op add .OFFSET_Y *tmp26 *tmp3
   114 read .JULIA .memory 69
   115 read .JULIA_X .memory 70
   116 read .JULIA_Y .memory 71
 
   128 op mod :x *tmp32 176
   129 op add :position :x 158
   130 set *tmp35 :position
-    * read *tmp36 .memory *tmp35
+  131 read *tmp36 .memory :position
   132 jump *label40 notEqual *tmp36 0
   133 set *tmp39 :position
-    * write .PROCESSOR_ID .memory *tmp39
+  134 write .PROCESSOR_ID .memory :position
   135 set :y 0
   136 label *label42
   137 jump *label44 greaterThanEq :y 176
   138 set :fn2:x :x
   139 set :fn2:y :y
-    * op div *tmp42 :fn2:x .ZOOM
+  140 op div *tmp42 :x .ZOOM
   141 op add :fn2:zx *tmp42 .OFFSET_X
-    * op div *tmp44 :fn2:y .ZOOM
+  142 op div *tmp44 :y .ZOOM
   143 op add :fn2:zy *tmp44 .OFFSET_Y
   144 jump *label46 equal .JULIA false
   145 set :fn2:cx .JULIA_X
 
   148 label *label46
   149 set :fn2:cx :fn2:zx
   150 set :fn2:cy :fn2:zy
-    * op sub *tmp47 :fn2:cx 0.25
-    * op len :fn2:p *tmp47 :fn2:cy
+  151 op sub *tmp47 :fn2:zx 0.25
+  152 op len :fn2:p *tmp47 :fn2:zy
   153 op mul *tmp49 2 :fn2:p
   154 op mul *tmp50 *tmp49 :fn2:p
   155 op sub *tmp51 :fn2:p *tmp50
   156 op add *tmp52 *tmp51 0.25
-    * jump *label48 greaterThan :fn2:cx *tmp52
+  157 jump *label48 greaterThan :fn2:zx *tmp52
   158 set *tmp41 63
   159 jump *label45 always
   160 label *label48
   161 label *label49
-    * op add *tmp55 :fn2:cx 1
-    * op len *tmp56 *tmp55 :fn2:cy
+  162 op add *tmp55 :fn2:zx 1
+  163 op len *tmp56 *tmp55 :fn2:zy
   164 jump *label50 greaterThan *tmp56 0.25
   165 set *tmp41 63
   166 jump *label45 always
 
   172 jump *label54 greaterThanEq :fn2:i 63
   173 set :fn2:x1 :fn2:zx
   174 set :fn2:y1 :fn2:zy
-    * op mul *tmp59 :fn2:x1 :fn2:x1
-    * op mul *tmp60 :fn2:y1 :fn2:y1
+  175 op mul *tmp59 :fn2:zx :fn2:zx
+  176 op mul *tmp60 :fn2:zy :fn2:zy
   177 op sub *tmp61 *tmp59 *tmp60
   178 op add :fn2:zx *tmp61 :fn2:cx
   179 op mul *tmp63 2 :fn2:x1
-    * op mul *tmp64 *tmp63 :fn2:y1
+  180 op mul *tmp64 *tmp63 :fn2:zy
   181 op add :fn2:zy *tmp64 :fn2:cy
   182 op len :fn2:dist :fn2:zx :fn2:zy
   183 jump *label55 lessThan :fn2:dist 64
 
   200 label *label58
   201 set *tmp41 :fn2:i
   202 jump *label45 always
-    * set *tmp41 null
   203 label *label45
   204 set :iterations *tmp41
   205 set :fn3:x :x
   206 set :fn3:y :y
-    * set :fn3:iterations :iterations
+  207 set :fn3:iterations *tmp41
   208 jump *label60 equal .SMOOTH false
-    * jump *label62 notEqual :fn3:iterations 63
+  209 jump *label62 notEqual :iterations 63
   210 draw color 0 0 0 255
   211 jump *label63 always
   212 label *label62
   213 jump *label65 notEqual .PALETTE 2
   214 label *label66
-    * op sub *tmp82 32 :fn3:iterations
+  215 op sub *tmp82 32 :iterations
   216 op abs *tmp83 *tmp82
   217 op mul *tmp84 7 *tmp83
   218 op sub :fn3:r 255 *tmp84
-    * op sub *tmp86 :fn3:iterations 32
+  219 op sub *tmp86 :iterations 32
   220 op abs *tmp87 *tmp86
   221 op mul *tmp88 6 *tmp87
   222 op sub :fn3:g 240 *tmp88
-    * op sub *tmp90 32 :fn3:iterations
-    * op abs *tmp91 *tmp90
-    * op mul *tmp92 4 *tmp91
+  223 op sub *tmp90 32 :iterations
+  224 op abs *tmp91 *tmp82
+  225 op mul *tmp92 4 *tmp83
   226 op add :fn3:b 120 *tmp92
   227 draw color :fn3:r :fn3:g :fn3:b 255
   228 jump *label64 always
   229 label *label65
   230 jump *label67 notEqual .PALETTE 3
   231 label *label68
-    * op div *tmp94 :fn3:iterations 63
-    * op mul *tmp95 *tmp94 360
+  232 op div *tmp94 :iterations 63
+  233 op div *tmp95 :fn3:iterations 0.175
   234 op sin *tmp96 *tmp95
   235 op mul :fn3:r 255 *tmp96
-    * op div *tmp98 :fn3:iterations 63
-    * op mul *tmp99 *tmp98 360
-    * op cos *tmp100 *tmp99
+  236 op div *tmp98 :iterations 63
+  237 op mul *tmp99 *tmp94 360
+  238 op cos *tmp100 *tmp95
   239 op mul :fn3:g 255 *tmp100
-    * op sub *tmp102 :fn3:iterations 32
+  240 op sub *tmp102 :iterations 32
   241 op abs *tmp103 *tmp102
   242 op mul *tmp104 4 *tmp103
   243 op add :fn3:b 100 *tmp104
 
   246 label *label67
   247 jump *label69 notEqual .PALETTE 4
   248 label *label70
-    * op mul :fn3:r 4 :fn3:iterations
-    * op mul *tmp107 1.5 :fn3:iterations
+  249 op mul :fn3:r 4 :iterations
+  250 op mul *tmp107 1.5 :iterations
   251 op add :fn3:g 96 *tmp107
   252 draw color :fn3:r :fn3:g 0 255
   253 jump *label64 always
   254 label *label69
-    * op mul *tmp109 4 :fn3:iterations
+  255 op mul *tmp109 4 :iterations
   256 op sub :fn3:r 255 *tmp109
   257 draw color :fn3:r :fn3:r 0 255
   258 label *label64
   259 label *label63
   260 jump *label61 always
   261 label *label60
-    * set *tmp111 :fn3:iterations
-    * read *tmp112 .memory *tmp111
+  262 set *tmp111 :iterations
+  263 read *tmp112 .memory :fn3:iterations
   264 draw col *tmp112
   265 label *label61
-    * draw rect :fn3:x :fn3:y 1 1
+  266 draw rect :x :y 1 1
   267 drawflush .display
   268 label *label59
   269 set *tmp113 :position
-    * read *tmp114 .memory *tmp113
+  270 read *tmp114 .memory :position
   271 jump *label71 equal *tmp114 .PROCESSOR_ID
   272 jump *label44 always
   273 label *label71
 
   287 jump *label75 lessThanEq :line 176
   288 op div :next_increment :next_increment 2
   289 set :increment :next_increment
-    * op div :line :increment 2
+  290 op div :line :next_increment 2
   291 label *label75
   292 label *label76
   293 label *label38
 
   303 label *label78
   304 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
   305 set *tmp123 .PROC_ID_INDEX
-    * read *tmp124 .memory *tmp123
+  306 read *tmp124 .memory .PROC_ID_INDEX
   307 jump *label81 notEqual *tmp124 .PROCESSOR_ID
   308 set *tmp127 .PROC_STATE_INDEX
-    * write :fn0:state .memory *tmp127
+  309 write :fn0:state .memory .PROC_STATE_INDEX
   310 jump *label80 always
   311 jump *label82 always
   312 label *label81
   313 set *tmp129 .PROC_ID_INDEX
-    * read *tmp130 .memory *tmp129
+  314 read *tmp130 .memory .PROC_ID_INDEX
   315 jump *label83 notEqual *tmp130 0
   316 set *tmp133 .PROC_ID_INDEX
-    * write .PROCESSOR_ID .memory *tmp133
+  317 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   318 set *tmp135 .PROC_STATE_INDEX
-    * write :fn0:state .memory *tmp135
+  319 write :fn0:state .memory .PROC_STATE_INDEX
   320 jump *label80 always
   321 jump *label84 always
   322 label *label83

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-19 instructions):
 
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
-    * set :fn1:title "Mandelbrot Generator"
     7 set :fn1:message null
     8 label *label2
     9 setaddr *tmp13 *label8
 
    12 set .display null
    13 setaddr *tmp13 *label9
    14 label *label5
-    * set :fn1:variable null
    15 label *label6
    16 goto *tmp13 marker0
    17 gotolabel *label9 marker0
 
    56 setaddr *tmp22 *label25
    57 set :fn1:name "Display"
    58 set :fn1:variable .display
-    * set :fn1:required true
    59 jump *label22 always
    60 gotolabel *label25 marker2
    61 set .display :fn1:variable
    62 setaddr *tmp22 *label26
    63 set :fn1:name "Memory"
    64 set :fn1:variable .memory
-    * set :fn1:required true
    65 label *label22
    66 print "\n"
    67 print :fn1:name
 
   104 op div *tmp26 -88 .ZOOM
   105 read *tmp2 .memory 66
   106 op add .OFFSET_X *tmp26 *tmp2
-    * op div *tmp28 -88 .ZOOM
   107 read *tmp3 .memory 67
   108 op add .OFFSET_Y *tmp26 *tmp3
   109 read .JULIA .memory 69
 
   122 op mul *tmp32 17 :line
   123 op mod :x *tmp32 176
   124 op add :position :x 158
-    * set *tmp35 :position
   125 read *tmp36 .memory :position
   126 jump *label40 notEqual *tmp36 0
-    * set *tmp39 :position
   127 write .PROCESSOR_ID .memory :position
   128 set :y 0
   129 label *label42
   130 jump *label44 greaterThanEq :y 176
-    * set :fn2:x :x
-    * set :fn2:y :y
   131 op div *tmp42 :x .ZOOM
   132 op add :fn2:zx *tmp42 .OFFSET_X
   133 op div *tmp44 :y .ZOOM
 
   162 label *label52
   163 jump *label54 greaterThanEq :fn2:i 63
   164 set :fn2:x1 :fn2:zx
-    * set :fn2:y1 :fn2:zy
   165 op mul *tmp59 :fn2:zx :fn2:zx
   166 op mul *tmp60 :fn2:zy :fn2:zy
   167 op sub *tmp61 *tmp59 *tmp60
 
   192 jump *label45 always
   193 label *label45
   194 set :iterations *tmp41
-    * set :fn3:x :x
-    * set :fn3:y :y
   195 set :fn3:iterations *tmp41
   196 jump *label60 equal .SMOOTH false
-    * jump *label62 notEqual :iterations 63
+  197 jump *label62 notEqual *tmp41 63
   198 draw color 0 0 0 255
   199 jump *label63 always
   200 label *label62
   201 jump *label65 notEqual .PALETTE 2
   202 label *label66
-    * op sub *tmp82 32 :iterations
+  203 op sub *tmp82 32 *tmp41
   204 op abs *tmp83 *tmp82
   205 op mul *tmp84 7 *tmp83
   206 op sub :fn3:r 255 *tmp84
-    * op sub *tmp86 :iterations 32
+  207 op sub *tmp86 *tmp41 32
   208 op abs *tmp87 *tmp86
   209 op mul *tmp88 6 *tmp87
   210 op sub :fn3:g 240 *tmp88
-    * op sub *tmp90 32 :iterations
-    * op abs *tmp91 *tmp82
+  211 op sub *tmp90 32 *tmp41
   212 op mul *tmp92 4 *tmp83
   213 op add :fn3:b 120 *tmp92
   214 draw color :fn3:r :fn3:g :fn3:b 255
 
   216 label *label65
   217 jump *label67 notEqual .PALETTE 3
   218 label *label68
-    * op div *tmp94 :iterations 63
-    * op div *tmp95 :fn3:iterations 0.175
+  219 op div *tmp94 *tmp41 63
+  220 op div *tmp95 *tmp41 0.175
   221 op sin *tmp96 *tmp95
   222 op mul :fn3:r 255 *tmp96
-    * op div *tmp98 :iterations 63
-    * op mul *tmp99 *tmp94 360
+  223 op div *tmp98 *tmp41 63
+  224 op div *tmp99 :iterations 0.175
   225 op cos *tmp100 *tmp95
   226 op mul :fn3:g 255 *tmp100
-    * op sub *tmp102 :iterations 32
+  227 op sub *tmp102 *tmp41 32
   228 op abs *tmp103 *tmp102
   229 op mul *tmp104 4 *tmp103
   230 op add :fn3:b 100 *tmp104
 
   233 label *label67
   234 jump *label69 notEqual .PALETTE 4
   235 label *label70
-    * op mul :fn3:r 4 :iterations
-    * op mul *tmp107 1.5 :iterations
+  236 op mul :fn3:r 4 *tmp41
+  237 op mul *tmp107 1.5 *tmp41
   238 op add :fn3:g 96 *tmp107
   239 draw color :fn3:r :fn3:g 0 255
   240 jump *label64 always
   241 label *label69
-    * op mul *tmp109 4 :iterations
+  242 op mul *tmp109 4 *tmp41
   243 op sub :fn3:r 255 *tmp109
   244 draw color :fn3:r :fn3:r 0 255
   245 label *label64
   246 label *label63
   247 jump *label61 always
   248 label *label60
-    * set *tmp111 :iterations
-    * read *tmp112 .memory :fn3:iterations
+  249 set *tmp111 *tmp41
+  250 read *tmp112 .memory *tmp41
   251 draw col *tmp112
   252 label *label61
   253 draw rect :x :y 1 1
   254 drawflush .display
   255 label *label59
-    * set *tmp113 :position
   256 read *tmp114 .memory :position
   257 jump *label71 equal *tmp114 .PROCESSOR_ID
   258 jump *label44 always
 
   288 label *label0
   289 label *label78
   290 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
-    * set *tmp123 .PROC_ID_INDEX
   291 read *tmp124 .memory .PROC_ID_INDEX
   292 jump *label81 notEqual *tmp124 .PROCESSOR_ID
-    * set *tmp127 .PROC_STATE_INDEX
   293 write :fn0:state .memory .PROC_STATE_INDEX
   294 jump *label80 always
   295 jump *label82 always
   296 label *label81
-    * set *tmp129 .PROC_ID_INDEX
   297 read *tmp130 .memory .PROC_ID_INDEX
   298 jump *label83 notEqual *tmp130 0
-    * set *tmp133 .PROC_ID_INDEX
   299 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * set *tmp135 .PROC_STATE_INDEX
   300 write :fn0:state .memory .PROC_STATE_INDEX
   301 jump *label80 always
   302 jump *label84 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-5 instructions):
 
   192 jump *label45 always
   193 label *label45
   194 set :iterations *tmp41
-    * set :fn3:iterations *tmp41
   195 jump *label60 equal .SMOOTH false
   196 jump *label62 notEqual *tmp41 63
   197 draw color 0 0 0 255
 
   207 op abs *tmp87 *tmp86
   208 op mul *tmp88 6 *tmp87
   209 op sub :fn3:g 240 *tmp88
-    * op sub *tmp90 32 *tmp41
   210 op mul *tmp92 4 *tmp83
   211 op add :fn3:b 120 *tmp92
   212 draw color :fn3:r :fn3:g :fn3:b 255
 
   214 label *label65
   215 jump *label67 notEqual .PALETTE 3
   216 label *label68
-    * op div *tmp94 *tmp41 63
   217 op div *tmp95 *tmp41 0.175
   218 op sin *tmp96 *tmp95
   219 op mul :fn3:r 255 *tmp96
-    * op div *tmp98 *tmp41 63
-    * op div *tmp99 :iterations 0.175
+  220 op div *tmp99 *tmp41 0.175
   221 op cos *tmp100 *tmp95
   222 op mul :fn3:g 255 *tmp100
   223 op sub *tmp102 *tmp41 32
 
   242 label *label63
   243 jump *label61 always
   244 label *label60
-    * set *tmp111 *tmp41
   245 read *tmp112 .memory *tmp41
   246 draw col *tmp112
   247 label *label61

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   191 set *tmp41 :fn2:i
   192 jump *label45 always
   193 label *label45
-    * set :iterations *tmp41
   194 jump *label60 equal .SMOOTH false
   195 jump *label62 notEqual *tmp41 63
   196 draw color 0 0 0 255
 
   216 op div *tmp95 *tmp41 0.175
   217 op sin *tmp96 *tmp95
   218 op mul :fn3:r 255 *tmp96
-    * op div *tmp99 *tmp41 0.175
   219 op cos *tmp100 *tmp95
   220 op mul :fn3:g 255 *tmp100
   221 op sub *tmp102 *tmp41 32

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-3 instructions):
 
    21 set :fn1:n @links
    22 label *label10
    23 jump *label12 lessThanEq :fn1:n 0
+   24 label *label85
    25 op sub :fn1:n :fn1:n 1
    26 getlink :fn1:block :fn1:n
    27 print "\nFound: "
 
    51 set .memory :fn1:variable
    52 label *label15
    53 label *label11
-    * jump *label10 always
+   54 jump *label85 greaterThan :fn1:n 0
    55 label *label12
    56 set :fn1:foundAll 1
    57 setaddr *tmp22 *label25
 
   119 wait *tmp31
   120 set :lines 0
   121 label *label37
-    * jump *label39 greaterThanEq :lines 176
+  122 label *label86
   123 op mul *tmp32 17 :line
   124 op mod :x *tmp32 176
   125 op add :position :x 158
 
   128 write .PROCESSOR_ID .memory :position
   129 set :y 0
   130 label *label42
-    * jump *label44 greaterThanEq :y 176
+  131 label *label87
   132 op div *tmp42 :x .ZOOM
   133 op add :fn2:zx *tmp42 .OFFSET_X
   134 op div *tmp44 :y .ZOOM
 
   161 label *label47
   162 set :fn2:i 0
   163 label *label52
-    * jump *label54 greaterThanEq :fn2:i 63
+  164 label *label88
   165 set :fn2:x1 :fn2:zx
   166 op mul *tmp59 :fn2:zx :fn2:zx
   167 op mul *tmp60 :fn2:zy :fn2:zy
 
   177 label *label56
   178 label *label53
   179 op add :fn2:i :fn2:i 1
-    * jump *label52 always
+  180 jump *label88 lessThan :fn2:i 63
   181 label *label54
   182 op mul *tmp69 .SMOOTH 63
   183 jump *label57 greaterThanEq :fn2:i *tmp69
 
   259 label *label74
   260 label *label43
   261 op add :y :y 1
-    * jump *label42 always
+  262 jump *label87 lessThan :y 176
   263 label *label44
   264 label *label40
   265 label *label41
 
   272 label *label76
   273 label *label38
   274 op add :lines :lines 1
-    * jump *label37 always
+  275 jump *label86 lessThan :lines 176
   276 label *label39
   277 drawflush .display
   278 label *label30
 
   282 label *label0
   283 label *label78
   284 jump *label80 greaterThanEq .PROC_STATE_INDEX 512
+  285 label *label89
   286 read *tmp124 .memory .PROC_ID_INDEX
   287 jump *label81 notEqual *tmp124 .PROCESSOR_ID
   288 write :fn0:state .memory .PROC_STATE_INDEX
 
   301 label *label84
   302 label *label82
   303 label *label79
-    * jump *label78 always
+  304 jump *label89 lessThan .PROC_STATE_INDEX 512
   305 label *label80
   306 label *label77
   307 goto :fn0*retaddr :fn0

Modifications by Unroll iteration loop at *blocks:57:9 (-4 instructions):
 
     6 set .start 0
     7 set :fn1:message null
     8 label *label2
-    * setaddr *tmp13 *label8
-    * jump *label5 always
-    * gotolabel *label8 marker0
-    * set .display null
-    * setaddr *tmp13 *label9
-    * label *label5
-    * label *label6
-    * goto *tmp13 marker0
-    * gotolabel *label9 marker0
-    * set .memory null
-    * label *label7
+    9 label *label90
+   10 label *label91
+   11 set .display null
+   12 label *label94
+   13 label *label95
+   14 set .memory null
+   15 label *label7
    16 print "Mandelbrot Generator"
    17 set :fn1:n @links
    18 label *label10

Modifications by Unroll loop at mandelbrot-compute.mnd:132:5 (+743 instructions):
 
   155 label *label50
   156 label *label51
   157 label *label47
-    * set :fn2:i 0
-    * label *label52
-    * label *label88
-    * set :fn2:x1 :fn2:zx
-    * op mul *tmp59 :fn2:zx :fn2:zx
-    * op mul *tmp60 :fn2:zy :fn2:zy
-    * op sub *tmp61 *tmp59 *tmp60
-    * op add :fn2:zx *tmp61 :fn2:cx
-    * op mul *tmp63 2 :fn2:x1
-    * op mul *tmp64 *tmp63 :fn2:zy
-    * op add :fn2:zy *tmp64 :fn2:cy
-    * op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label55 lessThan :fn2:dist 64
-    * jump *label54 always
-    * label *label55
-    * label *label56
-    * label *label53
-    * op add :fn2:i :fn2:i 1
-    * jump *label88 lessThan :fn2:i 63
-    * label *label54
+  158 set :fn2:i 0
+  159 label *label99
+  160 label *label100
+  161 set :fn2:x1 :fn2:zx
+  162 op mul *tmp59 :fn2:zx :fn2:zx
+  163 op mul *tmp60 :fn2:zy :fn2:zy
+  164 op sub *tmp61 *tmp59 *tmp60
+  165 op add :fn2:zx *tmp61 :fn2:cx
+  166 op mul *tmp63 2 :fn2:x1
+  167 op mul *tmp64 *tmp63 :fn2:zy
+  168 op add :fn2:zy *tmp64 :fn2:cy
+  169 op len :fn2:dist :fn2:zx :fn2:zy
+  170 jump *label101 lessThan :fn2:dist 64
+  171 jump *label54 always
+  172 label *label101
+  173 label *label102
+  174 label *label103
+  175 op add :fn2:i :fn2:i 1
+  176 label *label104
+  177 set :fn2:x1 :fn2:zx
+  178 op mul *tmp59 :fn2:zx :fn2:zx
+  179 op mul *tmp60 :fn2:zy :fn2:zy
+  180 op sub *tmp61 *tmp59 *tmp60
+  181 op add :fn2:zx *tmp61 :fn2:cx
+  182 op mul *tmp63 2 :fn2:x1
+  183 op mul *tmp64 *tmp63 :fn2:zy
+  184 op add :fn2:zy *tmp64 :fn2:cy
+  185 op len :fn2:dist :fn2:zx :fn2:zy
+  186 jump *label105 lessThan :fn2:dist 64
+  187 jump *label54 always
+  188 label *label105
+  189 label *label106
+  190 label *label107
+  191 op add :fn2:i :fn2:i 1
+  192 label *label108
+  193 set :fn2:x1 :fn2:zx
+  194 op mul *tmp59 :fn2:zx :fn2:zx
+  195 op mul *tmp60 :fn2:zy :fn2:zy
+  196 op sub *tmp61 *tmp59 *tmp60
+  197 op add :fn2:zx *tmp61 :fn2:cx
+  198 op mul *tmp63 2 :fn2:x1
+  199 op mul *tmp64 *tmp63 :fn2:zy
+  200 op add :fn2:zy *tmp64 :fn2:cy
+  201 op len :fn2:dist :fn2:zx :fn2:zy
+  202 jump *label109 lessThan :fn2:dist 64
+  203 jump *label54 always
+  204 label *label109
+  205 label *label110
+  206 label *label111
+  207 op add :fn2:i :fn2:i 1
+  208 label *label112
+  209 set :fn2:x1 :fn2:zx
+  210 op mul *tmp59 :fn2:zx :fn2:zx
+  211 op mul *tmp60 :fn2:zy :fn2:zy
+  212 op sub *tmp61 *tmp59 *tmp60
+  213 op add :fn2:zx *tmp61 :fn2:cx
+  214 op mul *tmp63 2 :fn2:x1
+  215 op mul *tmp64 *tmp63 :fn2:zy
+  216 op add :fn2:zy *tmp64 :fn2:cy
+  217 op len :fn2:dist :fn2:zx :fn2:zy
+  218 jump *label113 lessThan :fn2:dist 64
+  219 jump *label54 always
+  220 label *label113
+  221 label *label114
+  222 label *label115
+  223 op add :fn2:i :fn2:i 1
+  224 label *label116
+  225 set :fn2:x1 :fn2:zx
+  226 op mul *tmp59 :fn2:zx :fn2:zx
+  227 op mul *tmp60 :fn2:zy :fn2:zy
+  228 op sub *tmp61 *tmp59 *tmp60
+  229 op add :fn2:zx *tmp61 :fn2:cx
+  230 op mul *tmp63 2 :fn2:x1
+  231 op mul *tmp64 *tmp63 :fn2:zy
+  232 op add :fn2:zy *tmp64 :fn2:cy
+  233 op len :fn2:dist :fn2:zx :fn2:zy
+  234 jump *label117 lessThan :fn2:dist 64
+  235 jump *label54 always
+  236 label *label117
+  237 label *label118
+  238 label *label119
+  239 op add :fn2:i :fn2:i 1
+  240 label *label120
+  241 set :fn2:x1 :fn2:zx
+  242 op mul *tmp59 :fn2:zx :fn2:zx
+  243 op mul *tmp60 :fn2:zy :fn2:zy
+  244 op sub *tmp61 *tmp59 *tmp60
+  245 op add :fn2:zx *tmp61 :fn2:cx
+  246 op mul *tmp63 2 :fn2:x1
+  247 op mul *tmp64 *tmp63 :fn2:zy
+  248 op add :fn2:zy *tmp64 :fn2:cy
+  249 op len :fn2:dist :fn2:zx :fn2:zy
+  250 jump *label121 lessThan :fn2:dist 64
+  251 jump *label54 always
+  252 label *label121
+  253 label *label122
+  254 label *label123
+  255 op add :fn2:i :fn2:i 1
+  256 label *label124
+  257 set :fn2:x1 :fn2:zx
+  258 op mul *tmp59 :fn2:zx :fn2:zx
+  259 op mul *tmp60 :fn2:zy :fn2:zy
+  260 op sub *tmp61 *tmp59 *tmp60
+  261 op add :fn2:zx *tmp61 :fn2:cx
+  262 op mul *tmp63 2 :fn2:x1
+  263 op mul *tmp64 *tmp63 :fn2:zy
+  264 op add :fn2:zy *tmp64 :fn2:cy
+  265 op len :fn2:dist :fn2:zx :fn2:zy
+  266 jump *label125 lessThan :fn2:dist 64
+  267 jump *label54 always
+  268 label *label125
+  269 label *label126
+  270 label *label127
+  271 op add :fn2:i :fn2:i 1
+  272 label *label128
+  273 set :fn2:x1 :fn2:zx
+  274 op mul *tmp59 :fn2:zx :fn2:zx
+  275 op mul *tmp60 :fn2:zy :fn2:zy
+  276 op sub *tmp61 *tmp59 *tmp60
+  277 op add :fn2:zx *tmp61 :fn2:cx
+  278 op mul *tmp63 2 :fn2:x1
+  279 op mul *tmp64 *tmp63 :fn2:zy
+  280 op add :fn2:zy *tmp64 :fn2:cy
+  281 op len :fn2:dist :fn2:zx :fn2:zy
+  282 jump *label129 lessThan :fn2:dist 64
+  283 jump *label54 always
+  284 label *label129
+  285 label *label130
+  286 label *label131
+  287 op add :fn2:i :fn2:i 1
+  288 label *label132
+  289 set :fn2:x1 :fn2:zx
+  290 op mul *tmp59 :fn2:zx :fn2:zx
+  291 op mul *tmp60 :fn2:zy :fn2:zy
+  292 op sub *tmp61 *tmp59 *tmp60
+  293 op add :fn2:zx *tmp61 :fn2:cx
+  294 op mul *tmp63 2 :fn2:x1
+  295 op mul *tmp64 *tmp63 :fn2:zy
+  296 op add :fn2:zy *tmp64 :fn2:cy
+  297 op len :fn2:dist :fn2:zx :fn2:zy
+  298 jump *label133 lessThan :fn2:dist 64
+  299 jump *label54 always
+  300 label *label133
+  301 label *label134
+  302 label *label135
+  303 op add :fn2:i :fn2:i 1
+  304 label *label136
+  305 set :fn2:x1 :fn2:zx
+  306 op mul *tmp59 :fn2:zx :fn2:zx
+  307 op mul *tmp60 :fn2:zy :fn2:zy
+  308 op sub *tmp61 *tmp59 *tmp60
+  309 op add :fn2:zx *tmp61 :fn2:cx
+  310 op mul *tmp63 2 :fn2:x1
+  311 op mul *tmp64 *tmp63 :fn2:zy
+  312 op add :fn2:zy *tmp64 :fn2:cy
+  313 op len :fn2:dist :fn2:zx :fn2:zy
+  314 jump *label137 lessThan :fn2:dist 64
+  315 jump *label54 always
+  316 label *label137
+  317 label *label138
+  318 label *label139
+  319 op add :fn2:i :fn2:i 1
+  320 label *label140
+  321 set :fn2:x1 :fn2:zx
+  322 op mul *tmp59 :fn2:zx :fn2:zx
+  323 op mul *tmp60 :fn2:zy :fn2:zy
+  324 op sub *tmp61 *tmp59 *tmp60
+  325 op add :fn2:zx *tmp61 :fn2:cx
+  326 op mul *tmp63 2 :fn2:x1
+  327 op mul *tmp64 *tmp63 :fn2:zy
+  328 op add :fn2:zy *tmp64 :fn2:cy
+  329 op len :fn2:dist :fn2:zx :fn2:zy
+  330 jump *label141 lessThan :fn2:dist 64
+  331 jump *label54 always
+  332 label *label141
+  333 label *label142
+  334 label *label143
+  335 op add :fn2:i :fn2:i 1
+  336 label *label144
+  337 set :fn2:x1 :fn2:zx
+  338 op mul *tmp59 :fn2:zx :fn2:zx
+  339 op mul *tmp60 :fn2:zy :fn2:zy
+  340 op sub *tmp61 *tmp59 *tmp60
+  341 op add :fn2:zx *tmp61 :fn2:cx
+  342 op mul *tmp63 2 :fn2:x1
+  343 op mul *tmp64 *tmp63 :fn2:zy
+  344 op add :fn2:zy *tmp64 :fn2:cy
+  345 op len :fn2:dist :fn2:zx :fn2:zy
+  346 jump *label145 lessThan :fn2:dist 64
+  347 jump *label54 always
+  348 label *label145
+  349 label *label146
+  350 label *label147
+  351 op add :fn2:i :fn2:i 1
+  352 label *label148
+  353 set :fn2:x1 :fn2:zx
+  354 op mul *tmp59 :fn2:zx :fn2:zx
+  355 op mul *tmp60 :fn2:zy :fn2:zy
+  356 op sub *tmp61 *tmp59 *tmp60
+  357 op add :fn2:zx *tmp61 :fn2:cx
+  358 op mul *tmp63 2 :fn2:x1
+  359 op mul *tmp64 *tmp63 :fn2:zy
+  360 op add :fn2:zy *tmp64 :fn2:cy
+  361 op len :fn2:dist :fn2:zx :fn2:zy
+  362 jump *label149 lessThan :fn2:dist 64
+  363 jump *label54 always
+  364 label *label149
+  365 label *label150
+  366 label *label151
+  367 op add :fn2:i :fn2:i 1
+  368 label *label152
+  369 set :fn2:x1 :fn2:zx
+  370 op mul *tmp59 :fn2:zx :fn2:zx
+  371 op mul *tmp60 :fn2:zy :fn2:zy
+  372 op sub *tmp61 *tmp59 *tmp60
+  373 op add :fn2:zx *tmp61 :fn2:cx
+  374 op mul *tmp63 2 :fn2:x1
+  375 op mul *tmp64 *tmp63 :fn2:zy
+  376 op add :fn2:zy *tmp64 :fn2:cy
+  377 op len :fn2:dist :fn2:zx :fn2:zy
+  378 jump *label153 lessThan :fn2:dist 64
+  379 jump *label54 always
+  380 label *label153
+  381 label *label154
+  382 label *label155
+  383 op add :fn2:i :fn2:i 1
+  384 label *label156
+  385 set :fn2:x1 :fn2:zx
+  386 op mul *tmp59 :fn2:zx :fn2:zx
+  387 op mul *tmp60 :fn2:zy :fn2:zy
+  388 op sub *tmp61 *tmp59 *tmp60
+  389 op add :fn2:zx *tmp61 :fn2:cx
+  390 op mul *tmp63 2 :fn2:x1
+  391 op mul *tmp64 *tmp63 :fn2:zy
+  392 op add :fn2:zy *tmp64 :fn2:cy
+  393 op len :fn2:dist :fn2:zx :fn2:zy
+  394 jump *label157 lessThan :fn2:dist 64
+  395 jump *label54 always
+  396 label *label157
+  397 label *label158
+  398 label *label159
+  399 op add :fn2:i :fn2:i 1
+  400 label *label160
+  401 set :fn2:x1 :fn2:zx
+  402 op mul *tmp59 :fn2:zx :fn2:zx
+  403 op mul *tmp60 :fn2:zy :fn2:zy
+  404 op sub *tmp61 *tmp59 *tmp60
+  405 op add :fn2:zx *tmp61 :fn2:cx
+  406 op mul *tmp63 2 :fn2:x1
+  407 op mul *tmp64 *tmp63 :fn2:zy
+  408 op add :fn2:zy *tmp64 :fn2:cy
+  409 op len :fn2:dist :fn2:zx :fn2:zy
+  410 jump *label161 lessThan :fn2:dist 64
+  411 jump *label54 always
+  412 label *label161
+  413 label *label162
+  414 label *label163
+  415 op add :fn2:i :fn2:i 1
+  416 label *label164
+  417 set :fn2:x1 :fn2:zx
+  418 op mul *tmp59 :fn2:zx :fn2:zx
+  419 op mul *tmp60 :fn2:zy :fn2:zy
+  420 op sub *tmp61 *tmp59 *tmp60
+  421 op add :fn2:zx *tmp61 :fn2:cx
+  422 op mul *tmp63 2 :fn2:x1
+  423 op mul *tmp64 *tmp63 :fn2:zy
+  424 op add :fn2:zy *tmp64 :fn2:cy
+  425 op len :fn2:dist :fn2:zx :fn2:zy
+  426 jump *label165 lessThan :fn2:dist 64
+  427 jump *label54 always
+  428 label *label165
+  429 label *label166
+  430 label *label167
+  431 op add :fn2:i :fn2:i 1
+  432 label *label168
+  433 set :fn2:x1 :fn2:zx
+  434 op mul *tmp59 :fn2:zx :fn2:zx
+  435 op mul *tmp60 :fn2:zy :fn2:zy
+  436 op sub *tmp61 *tmp59 *tmp60
+  437 op add :fn2:zx *tmp61 :fn2:cx
+  438 op mul *tmp63 2 :fn2:x1
+  439 op mul *tmp64 *tmp63 :fn2:zy
+  440 op add :fn2:zy *tmp64 :fn2:cy
+  441 op len :fn2:dist :fn2:zx :fn2:zy
+  442 jump *label169 lessThan :fn2:dist 64
+  443 jump *label54 always
+  444 label *label169
+  445 label *label170
+  446 label *label171
+  447 op add :fn2:i :fn2:i 1
+  448 label *label172
+  449 set :fn2:x1 :fn2:zx
+  450 op mul *tmp59 :fn2:zx :fn2:zx
+  451 op mul *tmp60 :fn2:zy :fn2:zy
+  452 op sub *tmp61 *tmp59 *tmp60
+  453 op add :fn2:zx *tmp61 :fn2:cx
+  454 op mul *tmp63 2 :fn2:x1
+  455 op mul *tmp64 *tmp63 :fn2:zy
+  456 op add :fn2:zy *tmp64 :fn2:cy
+  457 op len :fn2:dist :fn2:zx :fn2:zy
+  458 jump *label173 lessThan :fn2:dist 64
+  459 jump *label54 always
+  460 label *label173
+  461 label *label174
+  462 label *label175
+  463 op add :fn2:i :fn2:i 1
+  464 label *label176
+  465 set :fn2:x1 :fn2:zx
+  466 op mul *tmp59 :fn2:zx :fn2:zx
+  467 op mul *tmp60 :fn2:zy :fn2:zy
+  468 op sub *tmp61 *tmp59 *tmp60
+  469 op add :fn2:zx *tmp61 :fn2:cx
+  470 op mul *tmp63 2 :fn2:x1
+  471 op mul *tmp64 *tmp63 :fn2:zy
+  472 op add :fn2:zy *tmp64 :fn2:cy
+  473 op len :fn2:dist :fn2:zx :fn2:zy
+  474 jump *label177 lessThan :fn2:dist 64
+  475 jump *label54 always
+  476 label *label177
+  477 label *label178
+  478 label *label179
+  479 op add :fn2:i :fn2:i 1
+  480 label *label180
+  481 set :fn2:x1 :fn2:zx
+  482 op mul *tmp59 :fn2:zx :fn2:zx
+  483 op mul *tmp60 :fn2:zy :fn2:zy
+  484 op sub *tmp61 *tmp59 *tmp60
+  485 op add :fn2:zx *tmp61 :fn2:cx
+  486 op mul *tmp63 2 :fn2:x1
+  487 op mul *tmp64 *tmp63 :fn2:zy
+  488 op add :fn2:zy *tmp64 :fn2:cy
+  489 op len :fn2:dist :fn2:zx :fn2:zy
+  490 jump *label181 lessThan :fn2:dist 64
+  491 jump *label54 always
+  492 label *label181
+  493 label *label182
+  494 label *label183
+  495 op add :fn2:i :fn2:i 1
+  496 label *label184
+  497 set :fn2:x1 :fn2:zx
+  498 op mul *tmp59 :fn2:zx :fn2:zx
+  499 op mul *tmp60 :fn2:zy :fn2:zy
+  500 op sub *tmp61 *tmp59 *tmp60
+  501 op add :fn2:zx *tmp61 :fn2:cx
+  502 op mul *tmp63 2 :fn2:x1
+  503 op mul *tmp64 *tmp63 :fn2:zy
+  504 op add :fn2:zy *tmp64 :fn2:cy
+  505 op len :fn2:dist :fn2:zx :fn2:zy
+  506 jump *label185 lessThan :fn2:dist 64
+  507 jump *label54 always
+  508 label *label185
+  509 label *label186
+  510 label *label187
+  511 op add :fn2:i :fn2:i 1
+  512 label *label188
+  513 set :fn2:x1 :fn2:zx
+  514 op mul *tmp59 :fn2:zx :fn2:zx
+  515 op mul *tmp60 :fn2:zy :fn2:zy
+  516 op sub *tmp61 *tmp59 *tmp60
+  517 op add :fn2:zx *tmp61 :fn2:cx
+  518 op mul *tmp63 2 :fn2:x1
+  519 op mul *tmp64 *tmp63 :fn2:zy
+  520 op add :fn2:zy *tmp64 :fn2:cy
+  521 op len :fn2:dist :fn2:zx :fn2:zy
+  522 jump *label189 lessThan :fn2:dist 64
+  523 jump *label54 always
+  524 label *label189
+  525 label *label190
+  526 label *label191
+  527 op add :fn2:i :fn2:i 1
+  528 label *label192
+  529 set :fn2:x1 :fn2:zx
+  530 op mul *tmp59 :fn2:zx :fn2:zx
+  531 op mul *tmp60 :fn2:zy :fn2:zy
+  532 op sub *tmp61 *tmp59 *tmp60
+  533 op add :fn2:zx *tmp61 :fn2:cx
+  534 op mul *tmp63 2 :fn2:x1
+  535 op mul *tmp64 *tmp63 :fn2:zy
+  536 op add :fn2:zy *tmp64 :fn2:cy
+  537 op len :fn2:dist :fn2:zx :fn2:zy
+  538 jump *label193 lessThan :fn2:dist 64
+  539 jump *label54 always
+  540 label *label193
+  541 label *label194
+  542 label *label195
+  543 op add :fn2:i :fn2:i 1
+  544 label *label196
+  545 set :fn2:x1 :fn2:zx
+  546 op mul *tmp59 :fn2:zx :fn2:zx
+  547 op mul *tmp60 :fn2:zy :fn2:zy
+  548 op sub *tmp61 *tmp59 *tmp60
+  549 op add :fn2:zx *tmp61 :fn2:cx
+  550 op mul *tmp63 2 :fn2:x1
+  551 op mul *tmp64 *tmp63 :fn2:zy
+  552 op add :fn2:zy *tmp64 :fn2:cy
+  553 op len :fn2:dist :fn2:zx :fn2:zy
+  554 jump *label197 lessThan :fn2:dist 64
+  555 jump *label54 always
+  556 label *label197
+  557 label *label198
+  558 label *label199
+  559 op add :fn2:i :fn2:i 1
+  560 label *label200
+  561 set :fn2:x1 :fn2:zx
+  562 op mul *tmp59 :fn2:zx :fn2:zx
+  563 op mul *tmp60 :fn2:zy :fn2:zy
+  564 op sub *tmp61 *tmp59 *tmp60
+  565 op add :fn2:zx *tmp61 :fn2:cx
+  566 op mul *tmp63 2 :fn2:x1
+  567 op mul *tmp64 *tmp63 :fn2:zy
+  568 op add :fn2:zy *tmp64 :fn2:cy
+  569 op len :fn2:dist :fn2:zx :fn2:zy
+  570 jump *label201 lessThan :fn2:dist 64
+  571 jump *label54 always
+  572 label *label201
+  573 label *label202
+  574 label *label203
+  575 op add :fn2:i :fn2:i 1
+  576 label *label204
+  577 set :fn2:x1 :fn2:zx
+  578 op mul *tmp59 :fn2:zx :fn2:zx
+  579 op mul *tmp60 :fn2:zy :fn2:zy
+  580 op sub *tmp61 *tmp59 *tmp60
+  581 op add :fn2:zx *tmp61 :fn2:cx
+  582 op mul *tmp63 2 :fn2:x1
+  583 op mul *tmp64 *tmp63 :fn2:zy
+  584 op add :fn2:zy *tmp64 :fn2:cy
+  585 op len :fn2:dist :fn2:zx :fn2:zy
+  586 jump *label205 lessThan :fn2:dist 64
+  587 jump *label54 always
+  588 label *label205
+  589 label *label206
+  590 label *label207
+  591 op add :fn2:i :fn2:i 1
+  592 label *label208
+  593 set :fn2:x1 :fn2:zx
+  594 op mul *tmp59 :fn2:zx :fn2:zx
+  595 op mul *tmp60 :fn2:zy :fn2:zy
+  596 op sub *tmp61 *tmp59 *tmp60
+  597 op add :fn2:zx *tmp61 :fn2:cx
+  598 op mul *tmp63 2 :fn2:x1
+  599 op mul *tmp64 *tmp63 :fn2:zy
+  600 op add :fn2:zy *tmp64 :fn2:cy
+  601 op len :fn2:dist :fn2:zx :fn2:zy
+  602 jump *label209 lessThan :fn2:dist 64
+  603 jump *label54 always
+  604 label *label209
+  605 label *label210
+  606 label *label211
+  607 op add :fn2:i :fn2:i 1
+  608 label *label212
+  609 set :fn2:x1 :fn2:zx
+  610 op mul *tmp59 :fn2:zx :fn2:zx
+  611 op mul *tmp60 :fn2:zy :fn2:zy
+  612 op sub *tmp61 *tmp59 *tmp60
+  613 op add :fn2:zx *tmp61 :fn2:cx
+  614 op mul *tmp63 2 :fn2:x1
+  615 op mul *tmp64 *tmp63 :fn2:zy
+  616 op add :fn2:zy *tmp64 :fn2:cy
+  617 op len :fn2:dist :fn2:zx :fn2:zy
+  618 jump *label213 lessThan :fn2:dist 64
+  619 jump *label54 always
+  620 label *label213
+  621 label *label214
+  622 label *label215
+  623 op add :fn2:i :fn2:i 1
+  624 label *label216
+  625 set :fn2:x1 :fn2:zx
+  626 op mul *tmp59 :fn2:zx :fn2:zx
+  627 op mul *tmp60 :fn2:zy :fn2:zy
+  628 op sub *tmp61 *tmp59 *tmp60
+  629 op add :fn2:zx *tmp61 :fn2:cx
+  630 op mul *tmp63 2 :fn2:x1
+  631 op mul *tmp64 *tmp63 :fn2:zy
+  632 op add :fn2:zy *tmp64 :fn2:cy
+  633 op len :fn2:dist :fn2:zx :fn2:zy
+  634 jump *label217 lessThan :fn2:dist 64
+  635 jump *label54 always
+  636 label *label217
+  637 label *label218
+  638 label *label219
+  639 op add :fn2:i :fn2:i 1
+  640 label *label220
+  641 set :fn2:x1 :fn2:zx
+  642 op mul *tmp59 :fn2:zx :fn2:zx
+  643 op mul *tmp60 :fn2:zy :fn2:zy
+  644 op sub *tmp61 *tmp59 *tmp60
+  645 op add :fn2:zx *tmp61 :fn2:cx
+  646 op mul *tmp63 2 :fn2:x1
+  647 op mul *tmp64 *tmp63 :fn2:zy
+  648 op add :fn2:zy *tmp64 :fn2:cy
+  649 op len :fn2:dist :fn2:zx :fn2:zy
+  650 jump *label221 lessThan :fn2:dist 64
+  651 jump *label54 always
+  652 label *label221
+  653 label *label222
+  654 label *label223
+  655 op add :fn2:i :fn2:i 1
+  656 label *label224
+  657 set :fn2:x1 :fn2:zx
+  658 op mul *tmp59 :fn2:zx :fn2:zx
+  659 op mul *tmp60 :fn2:zy :fn2:zy
+  660 op sub *tmp61 *tmp59 *tmp60
+  661 op add :fn2:zx *tmp61 :fn2:cx
+  662 op mul *tmp63 2 :fn2:x1
+  663 op mul *tmp64 *tmp63 :fn2:zy
+  664 op add :fn2:zy *tmp64 :fn2:cy
+  665 op len :fn2:dist :fn2:zx :fn2:zy
+  666 jump *label225 lessThan :fn2:dist 64
+  667 jump *label54 always
+  668 label *label225
+  669 label *label226
+  670 label *label227
+  671 op add :fn2:i :fn2:i 1
+  672 label *label228
+  673 set :fn2:x1 :fn2:zx
+  674 op mul *tmp59 :fn2:zx :fn2:zx
+  675 op mul *tmp60 :fn2:zy :fn2:zy
+  676 op sub *tmp61 *tmp59 *tmp60
+  677 op add :fn2:zx *tmp61 :fn2:cx
+  678 op mul *tmp63 2 :fn2:x1
+  679 op mul *tmp64 *tmp63 :fn2:zy
+  680 op add :fn2:zy *tmp64 :fn2:cy
+  681 op len :fn2:dist :fn2:zx :fn2:zy
+  682 jump *label229 lessThan :fn2:dist 64
+  683 jump *label54 always
+  684 label *label229
+  685 label *label230
+  686 label *label231
+  687 op add :fn2:i :fn2:i 1
+  688 label *label232
+  689 set :fn2:x1 :fn2:zx
+  690 op mul *tmp59 :fn2:zx :fn2:zx
+  691 op mul *tmp60 :fn2:zy :fn2:zy
+  692 op sub *tmp61 *tmp59 *tmp60
+  693 op add :fn2:zx *tmp61 :fn2:cx
+  694 op mul *tmp63 2 :fn2:x1
+  695 op mul *tmp64 *tmp63 :fn2:zy
+  696 op add :fn2:zy *tmp64 :fn2:cy
+  697 op len :fn2:dist :fn2:zx :fn2:zy
+  698 jump *label233 lessThan :fn2:dist 64
+  699 jump *label54 always
+  700 label *label233
+  701 label *label234
+  702 label *label235
+  703 op add :fn2:i :fn2:i 1
+  704 label *label236
+  705 set :fn2:x1 :fn2:zx
+  706 op mul *tmp59 :fn2:zx :fn2:zx
+  707 op mul *tmp60 :fn2:zy :fn2:zy
+  708 op sub *tmp61 *tmp59 *tmp60
+  709 op add :fn2:zx *tmp61 :fn2:cx
+  710 op mul *tmp63 2 :fn2:x1
+  711 op mul *tmp64 *tmp63 :fn2:zy
+  712 op add :fn2:zy *tmp64 :fn2:cy
+  713 op len :fn2:dist :fn2:zx :fn2:zy
+  714 jump *label237 lessThan :fn2:dist 64
+  715 jump *label54 always
+  716 label *label237
+  717 label *label238
+  718 label *label239
+  719 op add :fn2:i :fn2:i 1
+  720 label *label240
+  721 set :fn2:x1 :fn2:zx
+  722 op mul *tmp59 :fn2:zx :fn2:zx
+  723 op mul *tmp60 :fn2:zy :fn2:zy
+  724 op sub *tmp61 *tmp59 *tmp60
+  725 op add :fn2:zx *tmp61 :fn2:cx
+  726 op mul *tmp63 2 :fn2:x1
+  727 op mul *tmp64 *tmp63 :fn2:zy
+  728 op add :fn2:zy *tmp64 :fn2:cy
+  729 op len :fn2:dist :fn2:zx :fn2:zy
+  730 jump *label241 lessThan :fn2:dist 64
+  731 jump *label54 always
+  732 label *label241
+  733 label *label242
+  734 label *label243
+  735 op add :fn2:i :fn2:i 1
+  736 label *label244
+  737 set :fn2:x1 :fn2:zx
+  738 op mul *tmp59 :fn2:zx :fn2:zx
+  739 op mul *tmp60 :fn2:zy :fn2:zy
+  740 op sub *tmp61 *tmp59 *tmp60
+  741 op add :fn2:zx *tmp61 :fn2:cx
+  742 op mul *tmp63 2 :fn2:x1
+  743 op mul *tmp64 *tmp63 :fn2:zy
+  744 op add :fn2:zy *tmp64 :fn2:cy
+  745 op len :fn2:dist :fn2:zx :fn2:zy
+  746 jump *label245 lessThan :fn2:dist 64
+  747 jump *label54 always
+  748 label *label245
+  749 label *label246
+  750 label *label247
+  751 op add :fn2:i :fn2:i 1
+  752 label *label248
+  753 set :fn2:x1 :fn2:zx
+  754 op mul *tmp59 :fn2:zx :fn2:zx
+  755 op mul *tmp60 :fn2:zy :fn2:zy
+  756 op sub *tmp61 *tmp59 *tmp60
+  757 op add :fn2:zx *tmp61 :fn2:cx
+  758 op mul *tmp63 2 :fn2:x1
+  759 op mul *tmp64 *tmp63 :fn2:zy
+  760 op add :fn2:zy *tmp64 :fn2:cy
+  761 op len :fn2:dist :fn2:zx :fn2:zy
+  762 jump *label249 lessThan :fn2:dist 64
+  763 jump *label54 always
+  764 label *label249
+  765 label *label250
+  766 label *label251
+  767 op add :fn2:i :fn2:i 1
+  768 label *label252
+  769 set :fn2:x1 :fn2:zx
+  770 op mul *tmp59 :fn2:zx :fn2:zx
+  771 op mul *tmp60 :fn2:zy :fn2:zy
+  772 op sub *tmp61 *tmp59 *tmp60
+  773 op add :fn2:zx *tmp61 :fn2:cx
+  774 op mul *tmp63 2 :fn2:x1
+  775 op mul *tmp64 *tmp63 :fn2:zy
+  776 op add :fn2:zy *tmp64 :fn2:cy
+  777 op len :fn2:dist :fn2:zx :fn2:zy
+  778 jump *label253 lessThan :fn2:dist 64
+  779 jump *label54 always
+  780 label *label253
+  781 label *label254
+  782 label *label255
+  783 op add :fn2:i :fn2:i 1
+  784 label *label256
+  785 set :fn2:x1 :fn2:zx
+  786 op mul *tmp59 :fn2:zx :fn2:zx
+  787 op mul *tmp60 :fn2:zy :fn2:zy
+  788 op sub *tmp61 *tmp59 *tmp60
+  789 op add :fn2:zx *tmp61 :fn2:cx
+  790 op mul *tmp63 2 :fn2:x1
+  791 op mul *tmp64 *tmp63 :fn2:zy
+  792 op add :fn2:zy *tmp64 :fn2:cy
+  793 op len :fn2:dist :fn2:zx :fn2:zy
+  794 jump *label257 lessThan :fn2:dist 64
+  795 jump *label54 always
+  796 label *label257
+  797 label *label258
+  798 label *label259
+  799 op add :fn2:i :fn2:i 1
+  800 label *label260
+  801 set :fn2:x1 :fn2:zx
+  802 op mul *tmp59 :fn2:zx :fn2:zx
+  803 op mul *tmp60 :fn2:zy :fn2:zy
+  804 op sub *tmp61 *tmp59 *tmp60
+  805 op add :fn2:zx *tmp61 :fn2:cx
+  806 op mul *tmp63 2 :fn2:x1
+  807 op mul *tmp64 *tmp63 :fn2:zy
+  808 op add :fn2:zy *tmp64 :fn2:cy
+  809 op len :fn2:dist :fn2:zx :fn2:zy
+  810 jump *label261 lessThan :fn2:dist 64
+  811 jump *label54 always
+  812 label *label261
+  813 label *label262
+  814 label *label263
+  815 op add :fn2:i :fn2:i 1
+  816 label *label264
+  817 set :fn2:x1 :fn2:zx
+  818 op mul *tmp59 :fn2:zx :fn2:zx
+  819 op mul *tmp60 :fn2:zy :fn2:zy
+  820 op sub *tmp61 *tmp59 *tmp60
+  821 op add :fn2:zx *tmp61 :fn2:cx
+  822 op mul *tmp63 2 :fn2:x1
+  823 op mul *tmp64 *tmp63 :fn2:zy
+  824 op add :fn2:zy *tmp64 :fn2:cy
+  825 op len :fn2:dist :fn2:zx :fn2:zy
+  826 jump *label265 lessThan :fn2:dist 64
+  827 jump *label54 always
+  828 label *label265
+  829 label *label266
+  830 label *label267
+  831 op add :fn2:i :fn2:i 1
+  832 label *label268
+  833 set :fn2:x1 :fn2:zx
+  834 op mul *tmp59 :fn2:zx :fn2:zx
+  835 op mul *tmp60 :fn2:zy :fn2:zy
+  836 op sub *tmp61 *tmp59 *tmp60
+  837 op add :fn2:zx *tmp61 :fn2:cx
+  838 op mul *tmp63 2 :fn2:x1
+  839 op mul *tmp64 *tmp63 :fn2:zy
+  840 op add :fn2:zy *tmp64 :fn2:cy
+  841 op len :fn2:dist :fn2:zx :fn2:zy
+  842 jump *label269 lessThan :fn2:dist 64
+  843 jump *label54 always
+  844 label *label269
+  845 label *label270
+  846 label *label271
+  847 op add :fn2:i :fn2:i 1
+  848 label *label272
+  849 set :fn2:x1 :fn2:zx
+  850 op mul *tmp59 :fn2:zx :fn2:zx
+  851 op mul *tmp60 :fn2:zy :fn2:zy
+  852 op sub *tmp61 *tmp59 *tmp60
+  853 op add :fn2:zx *tmp61 :fn2:cx
+  854 op mul *tmp63 2 :fn2:x1
+  855 op mul *tmp64 *tmp63 :fn2:zy
+  856 op add :fn2:zy *tmp64 :fn2:cy
+  857 op len :fn2:dist :fn2:zx :fn2:zy
+  858 jump *label273 lessThan :fn2:dist 64
+  859 jump *label54 always
+  860 label *label273
+  861 label *label274
+  862 label *label275
+  863 op add :fn2:i :fn2:i 1
+  864 label *label276
+  865 set :fn2:x1 :fn2:zx
+  866 op mul *tmp59 :fn2:zx :fn2:zx
+  867 op mul *tmp60 :fn2:zy :fn2:zy
+  868 op sub *tmp61 *tmp59 *tmp60
+  869 op add :fn2:zx *tmp61 :fn2:cx
+  870 op mul *tmp63 2 :fn2:x1
+  871 op mul *tmp64 *tmp63 :fn2:zy
+  872 op add :fn2:zy *tmp64 :fn2:cy
+  873 op len :fn2:dist :fn2:zx :fn2:zy
+  874 jump *label277 lessThan :fn2:dist 64
+  875 jump *label54 always
+  876 label *label277
+  877 label *label278
+  878 label *label279
+  879 op add :fn2:i :fn2:i 1
+  880 label *label280
+  881 set :fn2:x1 :fn2:zx
+  882 op mul *tmp59 :fn2:zx :fn2:zx
+  883 op mul *tmp60 :fn2:zy :fn2:zy
+  884 op sub *tmp61 *tmp59 *tmp60
+  885 op add :fn2:zx *tmp61 :fn2:cx
+  886 op mul *tmp63 2 :fn2:x1
+  887 op mul *tmp64 *tmp63 :fn2:zy
+  888 op add :fn2:zy *tmp64 :fn2:cy
+  889 op len :fn2:dist :fn2:zx :fn2:zy
+  890 jump *label281 lessThan :fn2:dist 64
+  891 jump *label54 always
+  892 label *label281
+  893 label *label282
+  894 label *label283
+  895 op add :fn2:i :fn2:i 1
+  896 label *label284
+  897 set :fn2:x1 :fn2:zx
+  898 op mul *tmp59 :fn2:zx :fn2:zx
+  899 op mul *tmp60 :fn2:zy :fn2:zy
+  900 op sub *tmp61 *tmp59 *tmp60
+  901 op add :fn2:zx *tmp61 :fn2:cx
+  902 op mul *tmp63 2 :fn2:x1
+  903 op mul *tmp64 *tmp63 :fn2:zy
+  904 op add :fn2:zy *tmp64 :fn2:cy
+  905 op len :fn2:dist :fn2:zx :fn2:zy
+  906 jump *label285 lessThan :fn2:dist 64
+  907 jump *label54 always
+  908 label *label285
+  909 label *label286
+  910 label *label287
+  911 op add :fn2:i :fn2:i 1
+  912 label *label288
+  913 set :fn2:x1 :fn2:zx
+  914 op mul *tmp59 :fn2:zx :fn2:zx
+  915 op mul *tmp60 :fn2:zy :fn2:zy
+  916 op sub *tmp61 *tmp59 *tmp60
+  917 op add :fn2:zx *tmp61 :fn2:cx
+  918 op mul *tmp63 2 :fn2:x1
+  919 op mul *tmp64 *tmp63 :fn2:zy
+  920 op add :fn2:zy *tmp64 :fn2:cy
+  921 op len :fn2:dist :fn2:zx :fn2:zy
+  922 jump *label289 lessThan :fn2:dist 64
+  923 jump *label54 always
+  924 label *label289
+  925 label *label290
+  926 label *label291
+  927 op add :fn2:i :fn2:i 1
+  928 label *label292
+  929 set :fn2:x1 :fn2:zx
+  930 op mul *tmp59 :fn2:zx :fn2:zx
+  931 op mul *tmp60 :fn2:zy :fn2:zy
+  932 op sub *tmp61 *tmp59 *tmp60
+  933 op add :fn2:zx *tmp61 :fn2:cx
+  934 op mul *tmp63 2 :fn2:x1
+  935 op mul *tmp64 *tmp63 :fn2:zy
+  936 op add :fn2:zy *tmp64 :fn2:cy
+  937 op len :fn2:dist :fn2:zx :fn2:zy
+  938 jump *label293 lessThan :fn2:dist 64
+  939 jump *label54 always
+  940 label *label293
+  941 label *label294
+  942 label *label295
+  943 op add :fn2:i :fn2:i 1
+  944 label *label296
+  945 set :fn2:x1 :fn2:zx
+  946 op mul *tmp59 :fn2:zx :fn2:zx
+  947 op mul *tmp60 :fn2:zy :fn2:zy
+  948 op sub *tmp61 *tmp59 *tmp60
+  949 op add :fn2:zx *tmp61 :fn2:cx
+  950 op mul *tmp63 2 :fn2:x1
+  951 op mul *tmp64 *tmp63 :fn2:zy
+  952 op add :fn2:zy *tmp64 :fn2:cy
+  953 op len :fn2:dist :fn2:zx :fn2:zy
+  954 jump *label297 lessThan :fn2:dist 64
+  955 jump *label54 always
+  956 label *label297
+  957 label *label298
+  958 label *label299
+  959 op add :fn2:i :fn2:i 1
+  960 label *label300
+  961 set :fn2:x1 :fn2:zx
+  962 op mul *tmp59 :fn2:zx :fn2:zx
+  963 op mul *tmp60 :fn2:zy :fn2:zy
+  964 op sub *tmp61 *tmp59 *tmp60
+  965 op add :fn2:zx *tmp61 :fn2:cx
+  966 op mul *tmp63 2 :fn2:x1
+  967 op mul *tmp64 *tmp63 :fn2:zy
+  968 op add :fn2:zy *tmp64 :fn2:cy
+  969 op len :fn2:dist :fn2:zx :fn2:zy
+  970 jump *label301 lessThan :fn2:dist 64
+  971 jump *label54 always
+  972 label *label301
+  973 label *label302
+  974 label *label303
+  975 op add :fn2:i :fn2:i 1
+  976 label *label304
+  977 set :fn2:x1 :fn2:zx
+  978 op mul *tmp59 :fn2:zx :fn2:zx
+  979 op mul *tmp60 :fn2:zy :fn2:zy
+  980 op sub *tmp61 *tmp59 *tmp60
+  981 op add :fn2:zx *tmp61 :fn2:cx
+  982 op mul *tmp63 2 :fn2:x1
+  983 op mul *tmp64 *tmp63 :fn2:zy
+  984 op add :fn2:zy *tmp64 :fn2:cy
+  985 op len :fn2:dist :fn2:zx :fn2:zy
+  986 jump *label305 lessThan :fn2:dist 64
+  987 jump *label54 always
+  988 label *label305
+  989 label *label306
+  990 label *label307
+  991 op add :fn2:i :fn2:i 1
+  992 label *label308
+  993 set :fn2:x1 :fn2:zx
+  994 op mul *tmp59 :fn2:zx :fn2:zx
+  995 op mul *tmp60 :fn2:zy :fn2:zy
+  996 op sub *tmp61 *tmp59 *tmp60
+  997 op add :fn2:zx *tmp61 :fn2:cx
+  998 op mul *tmp63 2 :fn2:x1
+  999 op mul *tmp64 *tmp63 :fn2:zy
+ 1000 op add :fn2:zy *tmp64 :fn2:cy
+ 1001 op len :fn2:dist :fn2:zx :fn2:zy
+ 1002 jump *label309 lessThan :fn2:dist 64
+ 1003 jump *label54 always
+ 1004 label *label309
+ 1005 label *label310
+ 1006 label *label311
+ 1007 op add :fn2:i :fn2:i 1
+ 1008 label *label312
+ 1009 set :fn2:x1 :fn2:zx
+ 1010 op mul *tmp59 :fn2:zx :fn2:zx
+ 1011 op mul *tmp60 :fn2:zy :fn2:zy
+ 1012 op sub *tmp61 *tmp59 *tmp60
+ 1013 op add :fn2:zx *tmp61 :fn2:cx
+ 1014 op mul *tmp63 2 :fn2:x1
+ 1015 op mul *tmp64 *tmp63 :fn2:zy
+ 1016 op add :fn2:zy *tmp64 :fn2:cy
+ 1017 op len :fn2:dist :fn2:zx :fn2:zy
+ 1018 jump *label313 lessThan :fn2:dist 64
+ 1019 jump *label54 always
+ 1020 label *label313
+ 1021 label *label314
+ 1022 label *label315
+ 1023 op add :fn2:i :fn2:i 1
+ 1024 label *label316
+ 1025 set :fn2:x1 :fn2:zx
+ 1026 op mul *tmp59 :fn2:zx :fn2:zx
+ 1027 op mul *tmp60 :fn2:zy :fn2:zy
+ 1028 op sub *tmp61 *tmp59 *tmp60
+ 1029 op add :fn2:zx *tmp61 :fn2:cx
+ 1030 op mul *tmp63 2 :fn2:x1
+ 1031 op mul *tmp64 *tmp63 :fn2:zy
+ 1032 op add :fn2:zy *tmp64 :fn2:cy
+ 1033 op len :fn2:dist :fn2:zx :fn2:zy
+ 1034 jump *label317 lessThan :fn2:dist 64
+ 1035 jump *label54 always
+ 1036 label *label317
+ 1037 label *label318
+ 1038 label *label319
+ 1039 op add :fn2:i :fn2:i 1
+ 1040 label *label320
+ 1041 set :fn2:x1 :fn2:zx
+ 1042 op mul *tmp59 :fn2:zx :fn2:zx
+ 1043 op mul *tmp60 :fn2:zy :fn2:zy
+ 1044 op sub *tmp61 *tmp59 *tmp60
+ 1045 op add :fn2:zx *tmp61 :fn2:cx
+ 1046 op mul *tmp63 2 :fn2:x1
+ 1047 op mul *tmp64 *tmp63 :fn2:zy
+ 1048 op add :fn2:zy *tmp64 :fn2:cy
+ 1049 op len :fn2:dist :fn2:zx :fn2:zy
+ 1050 jump *label321 lessThan :fn2:dist 64
+ 1051 jump *label54 always
+ 1052 label *label321
+ 1053 label *label322
+ 1054 label *label323
+ 1055 op add :fn2:i :fn2:i 1
+ 1056 label *label324
+ 1057 set :fn2:x1 :fn2:zx
+ 1058 op mul *tmp59 :fn2:zx :fn2:zx
+ 1059 op mul *tmp60 :fn2:zy :fn2:zy
+ 1060 op sub *tmp61 *tmp59 *tmp60
+ 1061 op add :fn2:zx *tmp61 :fn2:cx
+ 1062 op mul *tmp63 2 :fn2:x1
+ 1063 op mul *tmp64 *tmp63 :fn2:zy
+ 1064 op add :fn2:zy *tmp64 :fn2:cy
+ 1065 op len :fn2:dist :fn2:zx :fn2:zy
+ 1066 jump *label325 lessThan :fn2:dist 64
+ 1067 jump *label54 always
+ 1068 label *label325
+ 1069 label *label326
+ 1070 label *label327
+ 1071 op add :fn2:i :fn2:i 1
+ 1072 label *label328
+ 1073 set :fn2:x1 :fn2:zx
+ 1074 op mul *tmp59 :fn2:zx :fn2:zx
+ 1075 op mul *tmp60 :fn2:zy :fn2:zy
+ 1076 op sub *tmp61 *tmp59 *tmp60
+ 1077 op add :fn2:zx *tmp61 :fn2:cx
+ 1078 op mul *tmp63 2 :fn2:x1
+ 1079 op mul *tmp64 *tmp63 :fn2:zy
+ 1080 op add :fn2:zy *tmp64 :fn2:cy
+ 1081 op len :fn2:dist :fn2:zx :fn2:zy
+ 1082 jump *label329 lessThan :fn2:dist 64
+ 1083 jump *label54 always
+ 1084 label *label329
+ 1085 label *label330
+ 1086 label *label331
+ 1087 op add :fn2:i :fn2:i 1
+ 1088 label *label332
+ 1089 set :fn2:x1 :fn2:zx
+ 1090 op mul *tmp59 :fn2:zx :fn2:zx
+ 1091 op mul *tmp60 :fn2:zy :fn2:zy
+ 1092 op sub *tmp61 *tmp59 *tmp60
+ 1093 op add :fn2:zx *tmp61 :fn2:cx
+ 1094 op mul *tmp63 2 :fn2:x1
+ 1095 op mul *tmp64 *tmp63 :fn2:zy
+ 1096 op add :fn2:zy *tmp64 :fn2:cy
+ 1097 op len :fn2:dist :fn2:zx :fn2:zy
+ 1098 jump *label333 lessThan :fn2:dist 64
+ 1099 jump *label54 always
+ 1100 label *label333
+ 1101 label *label334
+ 1102 label *label335
+ 1103 op add :fn2:i :fn2:i 1
+ 1104 label *label336
+ 1105 set :fn2:x1 :fn2:zx
+ 1106 op mul *tmp59 :fn2:zx :fn2:zx
+ 1107 op mul *tmp60 :fn2:zy :fn2:zy
+ 1108 op sub *tmp61 *tmp59 *tmp60
+ 1109 op add :fn2:zx *tmp61 :fn2:cx
+ 1110 op mul *tmp63 2 :fn2:x1
+ 1111 op mul *tmp64 *tmp63 :fn2:zy
+ 1112 op add :fn2:zy *tmp64 :fn2:cy
+ 1113 op len :fn2:dist :fn2:zx :fn2:zy
+ 1114 jump *label337 lessThan :fn2:dist 64
+ 1115 jump *label54 always
+ 1116 label *label337
+ 1117 label *label338
+ 1118 label *label339
+ 1119 op add :fn2:i :fn2:i 1
+ 1120 label *label340
+ 1121 set :fn2:x1 :fn2:zx
+ 1122 op mul *tmp59 :fn2:zx :fn2:zx
+ 1123 op mul *tmp60 :fn2:zy :fn2:zy
+ 1124 op sub *tmp61 *tmp59 *tmp60
+ 1125 op add :fn2:zx *tmp61 :fn2:cx
+ 1126 op mul *tmp63 2 :fn2:x1
+ 1127 op mul *tmp64 *tmp63 :fn2:zy
+ 1128 op add :fn2:zy *tmp64 :fn2:cy
+ 1129 op len :fn2:dist :fn2:zx :fn2:zy
+ 1130 jump *label341 lessThan :fn2:dist 64
+ 1131 jump *label54 always
+ 1132 label *label341
+ 1133 label *label342
+ 1134 label *label343
+ 1135 op add :fn2:i :fn2:i 1
+ 1136 label *label344
+ 1137 set :fn2:x1 :fn2:zx
+ 1138 op mul *tmp59 :fn2:zx :fn2:zx
+ 1139 op mul *tmp60 :fn2:zy :fn2:zy
+ 1140 op sub *tmp61 *tmp59 *tmp60
+ 1141 op add :fn2:zx *tmp61 :fn2:cx
+ 1142 op mul *tmp63 2 :fn2:x1
+ 1143 op mul *tmp64 *tmp63 :fn2:zy
+ 1144 op add :fn2:zy *tmp64 :fn2:cy
+ 1145 op len :fn2:dist :fn2:zx :fn2:zy
+ 1146 jump *label345 lessThan :fn2:dist 64
+ 1147 jump *label54 always
+ 1148 label *label345
+ 1149 label *label346
+ 1150 label *label347
+ 1151 op add :fn2:i :fn2:i 1
+ 1152 label *label348
+ 1153 set :fn2:x1 :fn2:zx
+ 1154 op mul *tmp59 :fn2:zx :fn2:zx
+ 1155 op mul *tmp60 :fn2:zy :fn2:zy
+ 1156 op sub *tmp61 *tmp59 *tmp60
+ 1157 op add :fn2:zx *tmp61 :fn2:cx
+ 1158 op mul *tmp63 2 :fn2:x1
+ 1159 op mul *tmp64 *tmp63 :fn2:zy
+ 1160 op add :fn2:zy *tmp64 :fn2:cy
+ 1161 op len :fn2:dist :fn2:zx :fn2:zy
+ 1162 jump *label349 lessThan :fn2:dist 64
+ 1163 jump *label54 always
+ 1164 label *label349
+ 1165 label *label350
+ 1166 label *label351
+ 1167 op add :fn2:i :fn2:i 1
+ 1168 label *label54
  1169 op mul *tmp69 .SMOOTH 63
  1170 jump *label57 greaterThanEq :fn2:i *tmp69
  1171 op log *tmp72 :fn2:dist

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   172 label *label101
   173 label *label102
   174 label *label103
-    * op add :fn2:i :fn2:i 1
+  175 op add :fn2:i 0 1
   176 label *label104
   177 set :fn2:x1 :fn2:zx
   178 op mul *tmp59 :fn2:zx :fn2:zx
 
   188 label *label105
   189 label *label106
   190 label *label107
-    * op add :fn2:i :fn2:i 1
+  191 op add :fn2:i 1 1
   192 label *label108
   193 set :fn2:x1 :fn2:zx
   194 op mul *tmp59 :fn2:zx :fn2:zx
 
   204 label *label109
   205 label *label110
   206 label *label111
-    * op add :fn2:i :fn2:i 1
+  207 op add :fn2:i 2 1
   208 label *label112
   209 set :fn2:x1 :fn2:zx
   210 op mul *tmp59 :fn2:zx :fn2:zx
 
   220 label *label113
   221 label *label114
   222 label *label115
-    * op add :fn2:i :fn2:i 1
+  223 op add :fn2:i 3 1
   224 label *label116
   225 set :fn2:x1 :fn2:zx
   226 op mul *tmp59 :fn2:zx :fn2:zx
 
   236 label *label117
   237 label *label118
   238 label *label119
-    * op add :fn2:i :fn2:i 1
+  239 op add :fn2:i 4 1
   240 label *label120
   241 set :fn2:x1 :fn2:zx
   242 op mul *tmp59 :fn2:zx :fn2:zx
 
   252 label *label121
   253 label *label122
   254 label *label123
-    * op add :fn2:i :fn2:i 1
+  255 op add :fn2:i 5 1
   256 label *label124
   257 set :fn2:x1 :fn2:zx
   258 op mul *tmp59 :fn2:zx :fn2:zx
 
   268 label *label125
   269 label *label126
   270 label *label127
-    * op add :fn2:i :fn2:i 1
+  271 op add :fn2:i 6 1
   272 label *label128
   273 set :fn2:x1 :fn2:zx
   274 op mul *tmp59 :fn2:zx :fn2:zx
 
   284 label *label129
   285 label *label130
   286 label *label131
-    * op add :fn2:i :fn2:i 1
+  287 op add :fn2:i 7 1
   288 label *label132
   289 set :fn2:x1 :fn2:zx
   290 op mul *tmp59 :fn2:zx :fn2:zx
 
   300 label *label133
   301 label *label134
   302 label *label135
-    * op add :fn2:i :fn2:i 1
+  303 op add :fn2:i 8 1
   304 label *label136
   305 set :fn2:x1 :fn2:zx
   306 op mul *tmp59 :fn2:zx :fn2:zx
 
   316 label *label137
   317 label *label138
   318 label *label139
-    * op add :fn2:i :fn2:i 1
+  319 op add :fn2:i 9 1
   320 label *label140
   321 set :fn2:x1 :fn2:zx
   322 op mul *tmp59 :fn2:zx :fn2:zx
 
   332 label *label141
   333 label *label142
   334 label *label143
-    * op add :fn2:i :fn2:i 1
+  335 op add :fn2:i 10 1
   336 label *label144
   337 set :fn2:x1 :fn2:zx
   338 op mul *tmp59 :fn2:zx :fn2:zx
 
   348 label *label145
   349 label *label146
   350 label *label147
-    * op add :fn2:i :fn2:i 1
+  351 op add :fn2:i 11 1
   352 label *label148
   353 set :fn2:x1 :fn2:zx
   354 op mul *tmp59 :fn2:zx :fn2:zx
 
   364 label *label149
   365 label *label150
   366 label *label151
-    * op add :fn2:i :fn2:i 1
+  367 op add :fn2:i 12 1
   368 label *label152
   369 set :fn2:x1 :fn2:zx
   370 op mul *tmp59 :fn2:zx :fn2:zx
 
   380 label *label153
   381 label *label154
   382 label *label155
-    * op add :fn2:i :fn2:i 1
+  383 op add :fn2:i 13 1
   384 label *label156
   385 set :fn2:x1 :fn2:zx
   386 op mul *tmp59 :fn2:zx :fn2:zx
 
   396 label *label157
   397 label *label158
   398 label *label159
-    * op add :fn2:i :fn2:i 1
+  399 op add :fn2:i 14 1
   400 label *label160
   401 set :fn2:x1 :fn2:zx
   402 op mul *tmp59 :fn2:zx :fn2:zx
 
   412 label *label161
   413 label *label162
   414 label *label163
-    * op add :fn2:i :fn2:i 1
+  415 op add :fn2:i 15 1
   416 label *label164
   417 set :fn2:x1 :fn2:zx
   418 op mul *tmp59 :fn2:zx :fn2:zx
 
   428 label *label165
   429 label *label166
   430 label *label167
-    * op add :fn2:i :fn2:i 1
+  431 op add :fn2:i 16 1
   432 label *label168
   433 set :fn2:x1 :fn2:zx
   434 op mul *tmp59 :fn2:zx :fn2:zx
 
   444 label *label169
   445 label *label170
   446 label *label171
-    * op add :fn2:i :fn2:i 1
+  447 op add :fn2:i 17 1
   448 label *label172
   449 set :fn2:x1 :fn2:zx
   450 op mul *tmp59 :fn2:zx :fn2:zx
 
   460 label *label173
   461 label *label174
   462 label *label175
-    * op add :fn2:i :fn2:i 1
+  463 op add :fn2:i 18 1
   464 label *label176
   465 set :fn2:x1 :fn2:zx
   466 op mul *tmp59 :fn2:zx :fn2:zx
 
   476 label *label177
   477 label *label178
   478 label *label179
-    * op add :fn2:i :fn2:i 1
+  479 op add :fn2:i 19 1
   480 label *label180
   481 set :fn2:x1 :fn2:zx
   482 op mul *tmp59 :fn2:zx :fn2:zx
 
   492 label *label181
   493 label *label182
   494 label *label183
-    * op add :fn2:i :fn2:i 1
+  495 op add :fn2:i 20 1
   496 label *label184
   497 set :fn2:x1 :fn2:zx
   498 op mul *tmp59 :fn2:zx :fn2:zx
 
   508 label *label185
   509 label *label186
   510 label *label187
-    * op add :fn2:i :fn2:i 1
+  511 op add :fn2:i 21 1
   512 label *label188
   513 set :fn2:x1 :fn2:zx
   514 op mul *tmp59 :fn2:zx :fn2:zx
 
   524 label *label189
   525 label *label190
   526 label *label191
-    * op add :fn2:i :fn2:i 1
+  527 op add :fn2:i 22 1
   528 label *label192
   529 set :fn2:x1 :fn2:zx
   530 op mul *tmp59 :fn2:zx :fn2:zx
 
   540 label *label193
   541 label *label194
   542 label *label195
-    * op add :fn2:i :fn2:i 1
+  543 op add :fn2:i 23 1
   544 label *label196
   545 set :fn2:x1 :fn2:zx
   546 op mul *tmp59 :fn2:zx :fn2:zx
 
   556 label *label197
   557 label *label198
   558 label *label199
-    * op add :fn2:i :fn2:i 1
+  559 op add :fn2:i 24 1
   560 label *label200
   561 set :fn2:x1 :fn2:zx
   562 op mul *tmp59 :fn2:zx :fn2:zx
 
   572 label *label201
   573 label *label202
   574 label *label203
-    * op add :fn2:i :fn2:i 1
+  575 op add :fn2:i 25 1
   576 label *label204
   577 set :fn2:x1 :fn2:zx
   578 op mul *tmp59 :fn2:zx :fn2:zx
 
   588 label *label205
   589 label *label206
   590 label *label207
-    * op add :fn2:i :fn2:i 1
+  591 op add :fn2:i 26 1
   592 label *label208
   593 set :fn2:x1 :fn2:zx
   594 op mul *tmp59 :fn2:zx :fn2:zx
 
   604 label *label209
   605 label *label210
   606 label *label211
-    * op add :fn2:i :fn2:i 1
+  607 op add :fn2:i 27 1
   608 label *label212
   609 set :fn2:x1 :fn2:zx
   610 op mul *tmp59 :fn2:zx :fn2:zx
 
   620 label *label213
   621 label *label214
   622 label *label215
-    * op add :fn2:i :fn2:i 1
+  623 op add :fn2:i 28 1
   624 label *label216
   625 set :fn2:x1 :fn2:zx
   626 op mul *tmp59 :fn2:zx :fn2:zx
 
   636 label *label217
   637 label *label218
   638 label *label219
-    * op add :fn2:i :fn2:i 1
+  639 op add :fn2:i 29 1
   640 label *label220
   641 set :fn2:x1 :fn2:zx
   642 op mul *tmp59 :fn2:zx :fn2:zx
 
   652 label *label221
   653 label *label222
   654 label *label223
-    * op add :fn2:i :fn2:i 1
+  655 op add :fn2:i 30 1
   656 label *label224
   657 set :fn2:x1 :fn2:zx
   658 op mul *tmp59 :fn2:zx :fn2:zx
 
   668 label *label225
   669 label *label226
   670 label *label227
-    * op add :fn2:i :fn2:i 1
+  671 op add :fn2:i 31 1
   672 label *label228
   673 set :fn2:x1 :fn2:zx
   674 op mul *tmp59 :fn2:zx :fn2:zx
 
   684 label *label229
   685 label *label230
   686 label *label231
-    * op add :fn2:i :fn2:i 1
+  687 op add :fn2:i 32 1
   688 label *label232
   689 set :fn2:x1 :fn2:zx
   690 op mul *tmp59 :fn2:zx :fn2:zx
 
   700 label *label233
   701 label *label234
   702 label *label235
-    * op add :fn2:i :fn2:i 1
+  703 op add :fn2:i 33 1
   704 label *label236
   705 set :fn2:x1 :fn2:zx
   706 op mul *tmp59 :fn2:zx :fn2:zx
 
   716 label *label237
   717 label *label238
   718 label *label239
-    * op add :fn2:i :fn2:i 1
+  719 op add :fn2:i 34 1
   720 label *label240
   721 set :fn2:x1 :fn2:zx
   722 op mul *tmp59 :fn2:zx :fn2:zx
 
   732 label *label241
   733 label *label242
   734 label *label243
-    * op add :fn2:i :fn2:i 1
+  735 op add :fn2:i 35 1
   736 label *label244
   737 set :fn2:x1 :fn2:zx
   738 op mul *tmp59 :fn2:zx :fn2:zx
 
   748 label *label245
   749 label *label246
   750 label *label247
-    * op add :fn2:i :fn2:i 1
+  751 op add :fn2:i 36 1
   752 label *label248
   753 set :fn2:x1 :fn2:zx
   754 op mul *tmp59 :fn2:zx :fn2:zx
 
   764 label *label249
   765 label *label250
   766 label *label251
-    * op add :fn2:i :fn2:i 1
+  767 op add :fn2:i 37 1
   768 label *label252
   769 set :fn2:x1 :fn2:zx
   770 op mul *tmp59 :fn2:zx :fn2:zx
 
   780 label *label253
   781 label *label254
   782 label *label255
-    * op add :fn2:i :fn2:i 1
+  783 op add :fn2:i 38 1
   784 label *label256
   785 set :fn2:x1 :fn2:zx
   786 op mul *tmp59 :fn2:zx :fn2:zx
 
   796 label *label257
   797 label *label258
   798 label *label259
-    * op add :fn2:i :fn2:i 1
+  799 op add :fn2:i 39 1
   800 label *label260
   801 set :fn2:x1 :fn2:zx
   802 op mul *tmp59 :fn2:zx :fn2:zx
 
   812 label *label261
   813 label *label262
   814 label *label263
-    * op add :fn2:i :fn2:i 1
+  815 op add :fn2:i 40 1
   816 label *label264
   817 set :fn2:x1 :fn2:zx
   818 op mul *tmp59 :fn2:zx :fn2:zx
 
   828 label *label265
   829 label *label266
   830 label *label267
-    * op add :fn2:i :fn2:i 1
+  831 op add :fn2:i 41 1
   832 label *label268
   833 set :fn2:x1 :fn2:zx
   834 op mul *tmp59 :fn2:zx :fn2:zx
 
   844 label *label269
   845 label *label270
   846 label *label271
-    * op add :fn2:i :fn2:i 1
+  847 op add :fn2:i 42 1
   848 label *label272
   849 set :fn2:x1 :fn2:zx
   850 op mul *tmp59 :fn2:zx :fn2:zx
 
   860 label *label273
   861 label *label274
   862 label *label275
-    * op add :fn2:i :fn2:i 1
+  863 op add :fn2:i 43 1
   864 label *label276
   865 set :fn2:x1 :fn2:zx
   866 op mul *tmp59 :fn2:zx :fn2:zx
 
   876 label *label277
   877 label *label278
   878 label *label279
-    * op add :fn2:i :fn2:i 1
+  879 op add :fn2:i 44 1
   880 label *label280
   881 set :fn2:x1 :fn2:zx
   882 op mul *tmp59 :fn2:zx :fn2:zx
 
   892 label *label281
   893 label *label282
   894 label *label283
-    * op add :fn2:i :fn2:i 1
+  895 op add :fn2:i 45 1
   896 label *label284
   897 set :fn2:x1 :fn2:zx
   898 op mul *tmp59 :fn2:zx :fn2:zx
 
   908 label *label285
   909 label *label286
   910 label *label287
-    * op add :fn2:i :fn2:i 1
+  911 op add :fn2:i 46 1
   912 label *label288
   913 set :fn2:x1 :fn2:zx
   914 op mul *tmp59 :fn2:zx :fn2:zx
 
   924 label *label289
   925 label *label290
   926 label *label291
-    * op add :fn2:i :fn2:i 1
+  927 op add :fn2:i 47 1
   928 label *label292
   929 set :fn2:x1 :fn2:zx
   930 op mul *tmp59 :fn2:zx :fn2:zx
 
   940 label *label293
   941 label *label294
   942 label *label295
-    * op add :fn2:i :fn2:i 1
+  943 op add :fn2:i 48 1
   944 label *label296
   945 set :fn2:x1 :fn2:zx
   946 op mul *tmp59 :fn2:zx :fn2:zx
 
   956 label *label297
   957 label *label298
   958 label *label299
-    * op add :fn2:i :fn2:i 1
+  959 op add :fn2:i 49 1
   960 label *label300
   961 set :fn2:x1 :fn2:zx
   962 op mul *tmp59 :fn2:zx :fn2:zx
 
   972 label *label301
   973 label *label302
   974 label *label303
-    * op add :fn2:i :fn2:i 1
+  975 op add :fn2:i 50 1
   976 label *label304
   977 set :fn2:x1 :fn2:zx
   978 op mul *tmp59 :fn2:zx :fn2:zx
 
   988 label *label305
   989 label *label306
   990 label *label307
-    * op add :fn2:i :fn2:i 1
+  991 op add :fn2:i 51 1
   992 label *label308
   993 set :fn2:x1 :fn2:zx
   994 op mul *tmp59 :fn2:zx :fn2:zx
 
  1004 label *label309
  1005 label *label310
  1006 label *label311
-    * op add :fn2:i :fn2:i 1
+ 1007 op add :fn2:i 52 1
  1008 label *label312
  1009 set :fn2:x1 :fn2:zx
  1010 op mul *tmp59 :fn2:zx :fn2:zx
 
  1020 label *label313
  1021 label *label314
  1022 label *label315
-    * op add :fn2:i :fn2:i 1
+ 1023 op add :fn2:i 53 1
  1024 label *label316
  1025 set :fn2:x1 :fn2:zx
  1026 op mul *tmp59 :fn2:zx :fn2:zx
 
  1036 label *label317
  1037 label *label318
  1038 label *label319
-    * op add :fn2:i :fn2:i 1
+ 1039 op add :fn2:i 54 1
  1040 label *label320
  1041 set :fn2:x1 :fn2:zx
  1042 op mul *tmp59 :fn2:zx :fn2:zx
 
  1052 label *label321
  1053 label *label322
  1054 label *label323
-    * op add :fn2:i :fn2:i 1
+ 1055 op add :fn2:i 55 1
  1056 label *label324
  1057 set :fn2:x1 :fn2:zx
  1058 op mul *tmp59 :fn2:zx :fn2:zx
 
  1068 label *label325
  1069 label *label326
  1070 label *label327
-    * op add :fn2:i :fn2:i 1
+ 1071 op add :fn2:i 56 1
  1072 label *label328
  1073 set :fn2:x1 :fn2:zx
  1074 op mul *tmp59 :fn2:zx :fn2:zx
 
  1084 label *label329
  1085 label *label330
  1086 label *label331
-    * op add :fn2:i :fn2:i 1
+ 1087 op add :fn2:i 57 1
  1088 label *label332
  1089 set :fn2:x1 :fn2:zx
  1090 op mul *tmp59 :fn2:zx :fn2:zx
 
  1100 label *label333
  1101 label *label334
  1102 label *label335
-    * op add :fn2:i :fn2:i 1
+ 1103 op add :fn2:i 58 1
  1104 label *label336
  1105 set :fn2:x1 :fn2:zx
  1106 op mul *tmp59 :fn2:zx :fn2:zx
 
  1116 label *label337
  1117 label *label338
  1118 label *label339
-    * op add :fn2:i :fn2:i 1
+ 1119 op add :fn2:i 59 1
  1120 label *label340
  1121 set :fn2:x1 :fn2:zx
  1122 op mul *tmp59 :fn2:zx :fn2:zx
 
  1132 label *label341
  1133 label *label342
  1134 label *label343
-    * op add :fn2:i :fn2:i 1
+ 1135 op add :fn2:i 60 1
  1136 label *label344
  1137 set :fn2:x1 :fn2:zx
  1138 op mul *tmp59 :fn2:zx :fn2:zx
 
  1148 label *label345
  1149 label *label346
  1150 label *label347
-    * op add :fn2:i :fn2:i 1
+ 1151 op add :fn2:i 61 1
  1152 label *label348
  1153 set :fn2:x1 :fn2:zx
  1154 op mul *tmp59 :fn2:zx :fn2:zx
 
  1164 label *label349
  1165 label *label350
  1166 label *label351
-    * op add :fn2:i :fn2:i 1
+ 1167 op add :fn2:i 62 1
  1168 label *label54
  1169 op mul *tmp69 .SMOOTH 63
  1170 jump *label57 greaterThanEq :fn2:i *tmp69

Modifications by Unroll iteration loop at *blocks:66:13:
 
    23 print "\nFound: "
    24 print :fn1:block
    25 sensor :fn1:type :fn1:block @type
-    * setaddr *tmp17 *label16
-    * set :fn1:requested @large-logic-display
-    * set :fn1:variable .display
-    * jump *label13 always
-    * gotolabel *label16 marker1
-    * set .display :fn1:variable
-    * setaddr *tmp17 *label17
-    * set :fn1:requested @memory-bank
-    * set :fn1:variable .memory
-    * label *label13
-    * jump *label18 notEqual :fn1:requested :fn1:type
-    * set :fn1:variable :fn1:block
-    * jump *label20 notEqual :fn1:requested @message
-    * set :fn1:message :fn1:block
-    * label *label20
-    * label *label21
-    * label *label18
-    * label *label19
-    * label *label14
-    * goto *tmp17 marker1
-    * gotolabel *label17 marker1
-    * set .memory :fn1:variable
-    * label *label15
+   26 set :fn1:requested @large-logic-display
+   27 set .display .display
+   28 label *label352
+   29 jump *label355 notEqual :fn1:requested :fn1:type
+   30 set .display :fn1:block
+   31 jump *label353 notEqual :fn1:requested @message
+   32 set :fn1:message :fn1:block
+   33 label *label353
+   34 label *label354
+   35 label *label355
+   36 label *label356
+   37 label *label357
+   38 set .display .display
+   39 set :fn1:requested @memory-bank
+   40 set .memory .memory
+   41 label *label360
+   42 jump *label363 notEqual :fn1:requested :fn1:type
+   43 set .memory :fn1:block
+   44 jump *label361 notEqual :fn1:requested @message
+   45 set :fn1:message :fn1:block
+   46 label *label361
+   47 label *label362
+   48 label *label363
+   49 label *label364
+   50 label *label365
+   51 set .memory .memory
+   52 label *label15
    53 label *label11
    54 jump *label85 greaterThan :fn1:n 0
    55 label *label12

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    26 set :fn1:requested @large-logic-display
    27 set .display .display
    28 label *label352
-    * jump *label355 notEqual :fn1:requested :fn1:type
+   29 jump *label355 notEqual @large-logic-display :fn1:type
    30 set .display :fn1:block
-    * jump *label353 notEqual :fn1:requested @message
+   31 jump *label353 notEqual @large-logic-display @message
    32 set :fn1:message :fn1:block
    33 label *label353
    34 label *label354
 
    39 set :fn1:requested @memory-bank
    40 set .memory .memory
    41 label *label360
-    * jump *label363 notEqual :fn1:requested :fn1:type
+   42 jump *label363 notEqual @memory-bank :fn1:type
    43 set .memory :fn1:block
-    * jump *label361 notEqual :fn1:requested @message
+   44 jump *label361 notEqual @memory-bank @message
    45 set :fn1:message :fn1:block
    46 label *label361
    47 label *label362

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    23 print "\nFound: "
    24 print :fn1:block
    25 sensor :fn1:type :fn1:block @type
-    * set :fn1:requested @large-logic-display
    26 set .display .display
    27 label *label352
    28 jump *label355 notEqual @large-logic-display :fn1:type
    29 set .display :fn1:block
    30 jump *label353 notEqual @large-logic-display @message
-    * set :fn1:message :fn1:block
    31 label *label353
    32 label *label354
    33 label *label355
    34 label *label356
    35 label *label357
    36 set .display .display
-    * set :fn1:requested @memory-bank
    37 set .memory .memory
    38 label *label360
    39 jump *label363 notEqual @memory-bank :fn1:type
    40 set .memory :fn1:block
    41 jump *label361 notEqual @memory-bank @message
-    * set :fn1:message :fn1:block
    42 label *label361
    43 label *label362
    44 label *label363
 
    74 gotolabel *label26 marker2
    75 set .memory :fn1:variable
    76 label *label24
-    * printflush :fn1:message
+   77 printflush null
    78 label *label3
    79 jump *label2 equal :fn1:foundAll false
    80 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
-    * set :fn1:message null
     7 label *label2
     8 label *label90
     9 label *label91

Modifications by Inline function 'setState' defined at mandelbrot-compute.mnd:189:1 (+9 instructions):
 
    81 label *label29
    82 label *label32
    83 set :fn0:state 0
-    * setaddr :fn0*retaddr *label35
-    * call *label0 :fn0*retval
-    * gotolabel *label35 :fn0
+   84 label *label369
+   85 label *label370
+   86 jump *label377 greaterThanEq .PROC_STATE_INDEX 512
+   87 label *label371
+   88 read *tmp124 .memory .PROC_ID_INDEX
+   89 jump *label372 notEqual *tmp124 .PROCESSOR_ID
+   90 write :fn0:state .memory .PROC_STATE_INDEX
+   91 jump *label377 always
+   92 jump *label375 always
+   93 label *label372
+   94 read *tmp130 .memory .PROC_ID_INDEX
+   95 jump *label373 notEqual *tmp130 0
+   96 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+   97 write :fn0:state .memory .PROC_STATE_INDEX
+   98 jump *label377 always
+   99 jump *label374 always
+  100 label *label373
+  101 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  102 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  103 label *label374
+  104 label *label375
+  105 label *label376
+  106 jump *label371 lessThan .PROC_STATE_INDEX 512
+  107 label *label377
+  108 label *label378
   109 label *label33
   110 read *tmp0 .memory 64
   111 jump *label32 equal .start *tmp0
 
   115 read *tmp1 .memory 65
   116 set .stop *tmp1
   117 set :fn0:state *tmp0
-    * setaddr :fn0*retaddr *label36
-    * call *label0 :fn0*retval
-    * gotolabel *label36 :fn0
+  118 label *label379
+  119 label *label380
+  120 jump *label387 greaterThanEq .PROC_STATE_INDEX 512
+  121 label *label381
+  122 read *tmp124 .memory .PROC_ID_INDEX
+  123 jump *label382 notEqual *tmp124 .PROCESSOR_ID
+  124 write :fn0:state .memory .PROC_STATE_INDEX
+  125 jump *label387 always
+  126 jump *label385 always
+  127 label *label382
+  128 read *tmp130 .memory .PROC_ID_INDEX
+  129 jump *label383 notEqual *tmp130 0
+  130 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  131 write :fn0:state .memory .PROC_STATE_INDEX
+  132 jump *label387 always
+  133 jump *label384 always
+  134 label *label383
+  135 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  136 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  137 label *label384
+  138 label *label385
+  139 label *label386
+  140 jump *label381 lessThan .PROC_STATE_INDEX 512
+  141 label *label387
+  142 label *label388
   143 read .ZOOM .memory 68
   144 op div *tmp26 -88 .ZOOM
   145 read *tmp2 .memory 66
 
  1309 jump *label29 always
  1310 label *label31
  1311 end
-    * label *label0
-    * label *label78
-    * jump *label80 greaterThanEq .PROC_STATE_INDEX 512
-    * label *label89
-    * read *tmp124 .memory .PROC_ID_INDEX
-    * jump *label81 notEqual *tmp124 .PROCESSOR_ID
-    * write :fn0:state .memory .PROC_STATE_INDEX
-    * jump *label80 always
-    * jump *label82 always
-    * label *label81
-    * read *tmp130 .memory .PROC_ID_INDEX
-    * jump *label83 notEqual *tmp130 0
-    * write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :fn0:state .memory .PROC_STATE_INDEX
-    * jump *label80 always
-    * jump *label84 always
-    * label *label83
-    * op add .PROC_ID_INDEX .PROC_ID_INDEX 2
-    * op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label84
-    * label *label82
-    * label *label79
-    * jump *label89 lessThan .PROC_STATE_INDEX 512
-    * label *label80
-    * label *label77
-    * goto :fn0*retaddr :fn0
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    87 label *label371
    88 read *tmp124 .memory .PROC_ID_INDEX
    89 jump *label372 notEqual *tmp124 .PROCESSOR_ID
-    * write :fn0:state .memory .PROC_STATE_INDEX
+   90 write 0 .memory .PROC_STATE_INDEX
    91 jump *label377 always
    92 jump *label375 always
    93 label *label372
    94 read *tmp130 .memory .PROC_ID_INDEX
    95 jump *label373 notEqual *tmp130 0
    96 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :fn0:state .memory .PROC_STATE_INDEX
+   97 write 0 .memory .PROC_STATE_INDEX
    98 jump *label377 always
    99 jump *label374 always
   100 label *label373
 
   121 label *label381
   122 read *tmp124 .memory .PROC_ID_INDEX
   123 jump *label382 notEqual *tmp124 .PROCESSOR_ID
-    * write :fn0:state .memory .PROC_STATE_INDEX
+  124 write *tmp0 .memory .PROC_STATE_INDEX
   125 jump *label387 always
   126 jump *label385 always
   127 label *label382
   128 read *tmp130 .memory .PROC_ID_INDEX
   129 jump *label383 notEqual *tmp130 0
   130 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :fn0:state .memory .PROC_STATE_INDEX
+  131 write *tmp0 .memory .PROC_STATE_INDEX
   132 jump *label387 always
   133 jump *label384 always
   134 label *label383

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    80 label *label1
    81 label *label29
    82 label *label32
-    * set :fn0:state 0
    83 label *label369
    84 label *label370
    85 jump *label377 greaterThanEq .PROC_STATE_INDEX 512
 
   113 set .start *tmp0
   114 read *tmp1 .memory 65
   115 set .stop *tmp1
-    * set :fn0:state *tmp0
   116 label *label379
   117 label *label380
   118 jump *label387 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Unroll iteration loop at *blocks:75:9 (+3 instructions):
 
    49 jump *label85 greaterThan :fn1:n 0
    50 label *label12
    51 set :fn1:foundAll 1
-    * setaddr *tmp22 *label25
-    * set :fn1:name "Display"
-    * set :fn1:variable .display
-    * jump *label22 always
-    * gotolabel *label25 marker2
-    * set .display :fn1:variable
-    * setaddr *tmp22 *label26
-    * set :fn1:name "Memory"
-    * set :fn1:variable .memory
-    * label *label22
-    * print "\n"
-    * print :fn1:name
-    * print ":"
-    * print " "
-    * print :fn1:variable
-    * jump *label27 equal true false
-    * op and :fn1:foundAll :fn1:foundAll :fn1:variable
-    * label *label27
-    * label *label28
-    * label *label23
-    * goto *tmp22 marker2
-    * gotolabel *label26 marker2
-    * set .memory :fn1:variable
-    * label *label24
+   52 set :fn1:name "Display"
+   53 set .display .display
+   54 label *label389
+   55 print "\n"
+   56 print :fn1:name
+   57 print ":"
+   58 print " "
+   59 print .display
+   60 jump *label390 equal true false
+   61 op and :fn1:foundAll :fn1:foundAll .display
+   62 label *label390
+   63 label *label391
+   64 label *label392
+   65 set .display .display
+   66 set :fn1:name "Memory"
+   67 set .memory .memory
+   68 label *label395
+   69 print "\n"
+   70 print :fn1:name
+   71 print ":"
+   72 print " "
+   73 print .memory
+   74 jump *label396 equal true false
+   75 op and :fn1:foundAll :fn1:foundAll .memory
+   76 label *label396
+   77 label *label397
+   78 label *label398
+   79 set .memory .memory
+   80 label *label24
    81 printflush null
    82 label *label3
    83 jump *label2 equal :fn1:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    53 set .display .display
    54 label *label389
    55 print "\n"
-    * print :fn1:name
+   56 print "Display"
    57 print ":"
    58 print " "
    59 print .display
    60 jump *label390 equal true false
-    * op and :fn1:foundAll :fn1:foundAll .display
+   61 op and :fn1:foundAll 1 .display
    62 label *label390
    63 label *label391
    64 label *label392
 
    67 set .memory .memory
    68 label *label395
    69 print "\n"
-    * print :fn1:name
+   70 print "Memory"
    71 print ":"
    72 print " "
    73 print .memory

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    48 label *label11
    49 jump *label85 greaterThan :fn1:n 0
    50 label *label12
-    * set :fn1:foundAll 1
-    * set :fn1:name "Display"
    51 set .display .display
    52 label *label389
    53 print "\n"
 
    61 label *label391
    62 label *label392
    63 set .display .display
-    * set :fn1:name "Memory"
    64 set .memory .memory
    65 label *label395
    66 print "\n"

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    26 label *label352
    27 jump *label355 notEqual @large-logic-display :fn1:type
    28 set .display :fn1:block
-    * jump *label353 notEqual @large-logic-display @message
+   29 jump *label353 always
    30 label *label353
    31 label *label354
    32 label *label355
 
    37 label *label360
    38 jump *label363 notEqual @memory-bank :fn1:type
    39 set .memory :fn1:block
-    * jump *label361 notEqual @memory-bank @message
+   40 jump *label361 always
    41 label *label361
    42 label *label362
    43 label *label363
 
    55 print ":"
    56 print " "
    57 print .display
-    * jump *label390 equal true false
    58 op and :fn1:foundAll 1 .display
    59 label *label390
    60 label *label391
 
    67 print ":"
    68 print " "
    69 print .memory
-    * jump *label396 equal true false
    70 op and :fn1:foundAll :fn1:foundAll .memory
    71 label *label396
    72 label *label397

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
    26 label *label352
    27 jump *label355 notEqual @large-logic-display :fn1:type
    28 set .display :fn1:block
-    * jump *label353 always
    29 label *label353
    30 label *label354
    31 label *label355
 
    36 label *label360
    37 jump *label363 notEqual @memory-bank :fn1:type
    38 set .memory :fn1:block
-    * jump *label361 always
    39 label *label361
    40 label *label362
    41 label *label363
 
  1216 label *label57
  1217 label *label58
  1218 set *tmp41 :fn2:i
-    * jump *label45 always
  1219 label *label45
  1220 jump *label60 equal .SMOOTH false
  1221 jump *label62 notEqual *tmp41 63

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-8 instructions):
 
    22 print "\nFound: "
    23 print :fn1:block
    24 sensor :fn1:type :fn1:block @type
-    * set .display .display
    25 label *label352
    26 jump *label355 notEqual @large-logic-display :fn1:type
    27 set .display :fn1:block
 
    30 label *label355
    31 label *label356
    32 label *label357
-    * set .display .display
-    * set .memory .memory
    33 label *label360
    34 jump *label363 notEqual @memory-bank :fn1:type
    35 set .memory :fn1:block
 
    38 label *label363
    39 label *label364
    40 label *label365
-    * set .memory .memory
    41 label *label15
    42 label *label11
    43 jump *label85 greaterThan :fn1:n 0
    44 label *label12
-    * set .display .display
    45 label *label389
    46 print "\n"
    47 print "Display"
 
    52 label *label390
    53 label *label391
    54 label *label392
-    * set .display .display
-    * set .memory .memory
    55 label *label395
    56 print "\n"
    57 print "Memory"
 
    62 label *label396
    63 label *label397
    64 label *label398
-    * set .memory .memory
    65 label *label24
    66 printflush null
    67 label *label3
 
   203 label *label101
   204 label *label102
   205 label *label103
-    * op add :fn2:i 0 1
+  206 set :fn2:i 1
   207 label *label104
   208 set :fn2:x1 :fn2:zx
   209 op mul *tmp59 :fn2:zx :fn2:zx

Modifications by Final phase, Jump Straightening, iteration 1 (-65 instructions):
 
   198 op mul *tmp64 *tmp63 :fn2:zy
   199 op add :fn2:zy *tmp64 :fn2:cy
   200 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label101 lessThan :fn2:dist 64
-    * jump *label54 always
+  201 jump *label54 greaterThanEq :fn2:dist 64
   202 label *label101
   203 label *label102
   204 label *label103
 
   213 op mul *tmp64 *tmp63 :fn2:zy
   214 op add :fn2:zy *tmp64 :fn2:cy
   215 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label105 lessThan :fn2:dist 64
-    * jump *label54 always
+  216 jump *label54 greaterThanEq :fn2:dist 64
   217 label *label105
   218 label *label106
   219 label *label107
 
   228 op mul *tmp64 *tmp63 :fn2:zy
   229 op add :fn2:zy *tmp64 :fn2:cy
   230 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label109 lessThan :fn2:dist 64
-    * jump *label54 always
+  231 jump *label54 greaterThanEq :fn2:dist 64
   232 label *label109
   233 label *label110
   234 label *label111
 
   243 op mul *tmp64 *tmp63 :fn2:zy
   244 op add :fn2:zy *tmp64 :fn2:cy
   245 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label113 lessThan :fn2:dist 64
-    * jump *label54 always
+  246 jump *label54 greaterThanEq :fn2:dist 64
   247 label *label113
   248 label *label114
   249 label *label115
 
   258 op mul *tmp64 *tmp63 :fn2:zy
   259 op add :fn2:zy *tmp64 :fn2:cy
   260 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label117 lessThan :fn2:dist 64
-    * jump *label54 always
+  261 jump *label54 greaterThanEq :fn2:dist 64
   262 label *label117
   263 label *label118
   264 label *label119
 
   273 op mul *tmp64 *tmp63 :fn2:zy
   274 op add :fn2:zy *tmp64 :fn2:cy
   275 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label121 lessThan :fn2:dist 64
-    * jump *label54 always
+  276 jump *label54 greaterThanEq :fn2:dist 64
   277 label *label121
   278 label *label122
   279 label *label123
 
   288 op mul *tmp64 *tmp63 :fn2:zy
   289 op add :fn2:zy *tmp64 :fn2:cy
   290 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label125 lessThan :fn2:dist 64
-    * jump *label54 always
+  291 jump *label54 greaterThanEq :fn2:dist 64
   292 label *label125
   293 label *label126
   294 label *label127
 
   303 op mul *tmp64 *tmp63 :fn2:zy
   304 op add :fn2:zy *tmp64 :fn2:cy
   305 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label129 lessThan :fn2:dist 64
-    * jump *label54 always
+  306 jump *label54 greaterThanEq :fn2:dist 64
   307 label *label129
   308 label *label130
   309 label *label131
 
   318 op mul *tmp64 *tmp63 :fn2:zy
   319 op add :fn2:zy *tmp64 :fn2:cy
   320 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label133 lessThan :fn2:dist 64
-    * jump *label54 always
+  321 jump *label54 greaterThanEq :fn2:dist 64
   322 label *label133
   323 label *label134
   324 label *label135
 
   333 op mul *tmp64 *tmp63 :fn2:zy
   334 op add :fn2:zy *tmp64 :fn2:cy
   335 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label137 lessThan :fn2:dist 64
-    * jump *label54 always
+  336 jump *label54 greaterThanEq :fn2:dist 64
   337 label *label137
   338 label *label138
   339 label *label139
 
   348 op mul *tmp64 *tmp63 :fn2:zy
   349 op add :fn2:zy *tmp64 :fn2:cy
   350 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label141 lessThan :fn2:dist 64
-    * jump *label54 always
+  351 jump *label54 greaterThanEq :fn2:dist 64
   352 label *label141
   353 label *label142
   354 label *label143
 
   363 op mul *tmp64 *tmp63 :fn2:zy
   364 op add :fn2:zy *tmp64 :fn2:cy
   365 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label145 lessThan :fn2:dist 64
-    * jump *label54 always
+  366 jump *label54 greaterThanEq :fn2:dist 64
   367 label *label145
   368 label *label146
   369 label *label147
 
   378 op mul *tmp64 *tmp63 :fn2:zy
   379 op add :fn2:zy *tmp64 :fn2:cy
   380 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label149 lessThan :fn2:dist 64
-    * jump *label54 always
+  381 jump *label54 greaterThanEq :fn2:dist 64
   382 label *label149
   383 label *label150
   384 label *label151
 
   393 op mul *tmp64 *tmp63 :fn2:zy
   394 op add :fn2:zy *tmp64 :fn2:cy
   395 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label153 lessThan :fn2:dist 64
-    * jump *label54 always
+  396 jump *label54 greaterThanEq :fn2:dist 64
   397 label *label153
   398 label *label154
   399 label *label155
 
   408 op mul *tmp64 *tmp63 :fn2:zy
   409 op add :fn2:zy *tmp64 :fn2:cy
   410 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label157 lessThan :fn2:dist 64
-    * jump *label54 always
+  411 jump *label54 greaterThanEq :fn2:dist 64
   412 label *label157
   413 label *label158
   414 label *label159
 
   423 op mul *tmp64 *tmp63 :fn2:zy
   424 op add :fn2:zy *tmp64 :fn2:cy
   425 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label161 lessThan :fn2:dist 64
-    * jump *label54 always
+  426 jump *label54 greaterThanEq :fn2:dist 64
   427 label *label161
   428 label *label162
   429 label *label163
 
   438 op mul *tmp64 *tmp63 :fn2:zy
   439 op add :fn2:zy *tmp64 :fn2:cy
   440 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label165 lessThan :fn2:dist 64
-    * jump *label54 always
+  441 jump *label54 greaterThanEq :fn2:dist 64
   442 label *label165
   443 label *label166
   444 label *label167
 
   453 op mul *tmp64 *tmp63 :fn2:zy
   454 op add :fn2:zy *tmp64 :fn2:cy
   455 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label169 lessThan :fn2:dist 64
-    * jump *label54 always
+  456 jump *label54 greaterThanEq :fn2:dist 64
   457 label *label169
   458 label *label170
   459 label *label171
 
   468 op mul *tmp64 *tmp63 :fn2:zy
   469 op add :fn2:zy *tmp64 :fn2:cy
   470 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label173 lessThan :fn2:dist 64
-    * jump *label54 always
+  471 jump *label54 greaterThanEq :fn2:dist 64
   472 label *label173
   473 label *label174
   474 label *label175
 
   483 op mul *tmp64 *tmp63 :fn2:zy
   484 op add :fn2:zy *tmp64 :fn2:cy
   485 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label177 lessThan :fn2:dist 64
-    * jump *label54 always
+  486 jump *label54 greaterThanEq :fn2:dist 64
   487 label *label177
   488 label *label178
   489 label *label179
 
   498 op mul *tmp64 *tmp63 :fn2:zy
   499 op add :fn2:zy *tmp64 :fn2:cy
   500 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label181 lessThan :fn2:dist 64
-    * jump *label54 always
+  501 jump *label54 greaterThanEq :fn2:dist 64
   502 label *label181
   503 label *label182
   504 label *label183
 
   513 op mul *tmp64 *tmp63 :fn2:zy
   514 op add :fn2:zy *tmp64 :fn2:cy
   515 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label185 lessThan :fn2:dist 64
-    * jump *label54 always
+  516 jump *label54 greaterThanEq :fn2:dist 64
   517 label *label185
   518 label *label186
   519 label *label187
 
   528 op mul *tmp64 *tmp63 :fn2:zy
   529 op add :fn2:zy *tmp64 :fn2:cy
   530 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label189 lessThan :fn2:dist 64
-    * jump *label54 always
+  531 jump *label54 greaterThanEq :fn2:dist 64
   532 label *label189
   533 label *label190
   534 label *label191
 
   543 op mul *tmp64 *tmp63 :fn2:zy
   544 op add :fn2:zy *tmp64 :fn2:cy
   545 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label193 lessThan :fn2:dist 64
-    * jump *label54 always
+  546 jump *label54 greaterThanEq :fn2:dist 64
   547 label *label193
   548 label *label194
   549 label *label195
 
   558 op mul *tmp64 *tmp63 :fn2:zy
   559 op add :fn2:zy *tmp64 :fn2:cy
   560 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label197 lessThan :fn2:dist 64
-    * jump *label54 always
+  561 jump *label54 greaterThanEq :fn2:dist 64
   562 label *label197
   563 label *label198
   564 label *label199
 
   573 op mul *tmp64 *tmp63 :fn2:zy
   574 op add :fn2:zy *tmp64 :fn2:cy
   575 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label201 lessThan :fn2:dist 64
-    * jump *label54 always
+  576 jump *label54 greaterThanEq :fn2:dist 64
   577 label *label201
   578 label *label202
   579 label *label203
 
   588 op mul *tmp64 *tmp63 :fn2:zy
   589 op add :fn2:zy *tmp64 :fn2:cy
   590 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label205 lessThan :fn2:dist 64
-    * jump *label54 always
+  591 jump *label54 greaterThanEq :fn2:dist 64
   592 label *label205
   593 label *label206
   594 label *label207
 
   603 op mul *tmp64 *tmp63 :fn2:zy
   604 op add :fn2:zy *tmp64 :fn2:cy
   605 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label209 lessThan :fn2:dist 64
-    * jump *label54 always
+  606 jump *label54 greaterThanEq :fn2:dist 64
   607 label *label209
   608 label *label210
   609 label *label211
 
   618 op mul *tmp64 *tmp63 :fn2:zy
   619 op add :fn2:zy *tmp64 :fn2:cy
   620 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label213 lessThan :fn2:dist 64
-    * jump *label54 always
+  621 jump *label54 greaterThanEq :fn2:dist 64
   622 label *label213
   623 label *label214
   624 label *label215
 
   633 op mul *tmp64 *tmp63 :fn2:zy
   634 op add :fn2:zy *tmp64 :fn2:cy
   635 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label217 lessThan :fn2:dist 64
-    * jump *label54 always
+  636 jump *label54 greaterThanEq :fn2:dist 64
   637 label *label217
   638 label *label218
   639 label *label219
 
   648 op mul *tmp64 *tmp63 :fn2:zy
   649 op add :fn2:zy *tmp64 :fn2:cy
   650 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label221 lessThan :fn2:dist 64
-    * jump *label54 always
+  651 jump *label54 greaterThanEq :fn2:dist 64
   652 label *label221
   653 label *label222
   654 label *label223
 
   663 op mul *tmp64 *tmp63 :fn2:zy
   664 op add :fn2:zy *tmp64 :fn2:cy
   665 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label225 lessThan :fn2:dist 64
-    * jump *label54 always
+  666 jump *label54 greaterThanEq :fn2:dist 64
   667 label *label225
   668 label *label226
   669 label *label227
 
   678 op mul *tmp64 *tmp63 :fn2:zy
   679 op add :fn2:zy *tmp64 :fn2:cy
   680 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label229 lessThan :fn2:dist 64
-    * jump *label54 always
+  681 jump *label54 greaterThanEq :fn2:dist 64
   682 label *label229
   683 label *label230
   684 label *label231
 
   693 op mul *tmp64 *tmp63 :fn2:zy
   694 op add :fn2:zy *tmp64 :fn2:cy
   695 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label233 lessThan :fn2:dist 64
-    * jump *label54 always
+  696 jump *label54 greaterThanEq :fn2:dist 64
   697 label *label233
   698 label *label234
   699 label *label235
 
   708 op mul *tmp64 *tmp63 :fn2:zy
   709 op add :fn2:zy *tmp64 :fn2:cy
   710 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label237 lessThan :fn2:dist 64
-    * jump *label54 always
+  711 jump *label54 greaterThanEq :fn2:dist 64
   712 label *label237
   713 label *label238
   714 label *label239
 
   723 op mul *tmp64 *tmp63 :fn2:zy
   724 op add :fn2:zy *tmp64 :fn2:cy
   725 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label241 lessThan :fn2:dist 64
-    * jump *label54 always
+  726 jump *label54 greaterThanEq :fn2:dist 64
   727 label *label241
   728 label *label242
   729 label *label243
 
   738 op mul *tmp64 *tmp63 :fn2:zy
   739 op add :fn2:zy *tmp64 :fn2:cy
   740 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label245 lessThan :fn2:dist 64
-    * jump *label54 always
+  741 jump *label54 greaterThanEq :fn2:dist 64
   742 label *label245
   743 label *label246
   744 label *label247
 
   753 op mul *tmp64 *tmp63 :fn2:zy
   754 op add :fn2:zy *tmp64 :fn2:cy
   755 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label249 lessThan :fn2:dist 64
-    * jump *label54 always
+  756 jump *label54 greaterThanEq :fn2:dist 64
   757 label *label249
   758 label *label250
   759 label *label251
 
   768 op mul *tmp64 *tmp63 :fn2:zy
   769 op add :fn2:zy *tmp64 :fn2:cy
   770 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label253 lessThan :fn2:dist 64
-    * jump *label54 always
+  771 jump *label54 greaterThanEq :fn2:dist 64
   772 label *label253
   773 label *label254
   774 label *label255
 
   783 op mul *tmp64 *tmp63 :fn2:zy
   784 op add :fn2:zy *tmp64 :fn2:cy
   785 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label257 lessThan :fn2:dist 64
-    * jump *label54 always
+  786 jump *label54 greaterThanEq :fn2:dist 64
   787 label *label257
   788 label *label258
   789 label *label259
 
   798 op mul *tmp64 *tmp63 :fn2:zy
   799 op add :fn2:zy *tmp64 :fn2:cy
   800 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label261 lessThan :fn2:dist 64
-    * jump *label54 always
+  801 jump *label54 greaterThanEq :fn2:dist 64
   802 label *label261
   803 label *label262
   804 label *label263
 
   813 op mul *tmp64 *tmp63 :fn2:zy
   814 op add :fn2:zy *tmp64 :fn2:cy
   815 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label265 lessThan :fn2:dist 64
-    * jump *label54 always
+  816 jump *label54 greaterThanEq :fn2:dist 64
   817 label *label265
   818 label *label266
   819 label *label267
 
   828 op mul *tmp64 *tmp63 :fn2:zy
   829 op add :fn2:zy *tmp64 :fn2:cy
   830 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label269 lessThan :fn2:dist 64
-    * jump *label54 always
+  831 jump *label54 greaterThanEq :fn2:dist 64
   832 label *label269
   833 label *label270
   834 label *label271
 
   843 op mul *tmp64 *tmp63 :fn2:zy
   844 op add :fn2:zy *tmp64 :fn2:cy
   845 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label273 lessThan :fn2:dist 64
-    * jump *label54 always
+  846 jump *label54 greaterThanEq :fn2:dist 64
   847 label *label273
   848 label *label274
   849 label *label275
 
   858 op mul *tmp64 *tmp63 :fn2:zy
   859 op add :fn2:zy *tmp64 :fn2:cy
   860 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label277 lessThan :fn2:dist 64
-    * jump *label54 always
+  861 jump *label54 greaterThanEq :fn2:dist 64
   862 label *label277
   863 label *label278
   864 label *label279
 
   873 op mul *tmp64 *tmp63 :fn2:zy
   874 op add :fn2:zy *tmp64 :fn2:cy
   875 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label281 lessThan :fn2:dist 64
-    * jump *label54 always
+  876 jump *label54 greaterThanEq :fn2:dist 64
   877 label *label281
   878 label *label282
   879 label *label283
 
   888 op mul *tmp64 *tmp63 :fn2:zy
   889 op add :fn2:zy *tmp64 :fn2:cy
   890 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label285 lessThan :fn2:dist 64
-    * jump *label54 always
+  891 jump *label54 greaterThanEq :fn2:dist 64
   892 label *label285
   893 label *label286
   894 label *label287
 
   903 op mul *tmp64 *tmp63 :fn2:zy
   904 op add :fn2:zy *tmp64 :fn2:cy
   905 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label289 lessThan :fn2:dist 64
-    * jump *label54 always
+  906 jump *label54 greaterThanEq :fn2:dist 64
   907 label *label289
   908 label *label290
   909 label *label291
 
   918 op mul *tmp64 *tmp63 :fn2:zy
   919 op add :fn2:zy *tmp64 :fn2:cy
   920 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label293 lessThan :fn2:dist 64
-    * jump *label54 always
+  921 jump *label54 greaterThanEq :fn2:dist 64
   922 label *label293
   923 label *label294
   924 label *label295
 
   933 op mul *tmp64 *tmp63 :fn2:zy
   934 op add :fn2:zy *tmp64 :fn2:cy
   935 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label297 lessThan :fn2:dist 64
-    * jump *label54 always
+  936 jump *label54 greaterThanEq :fn2:dist 64
   937 label *label297
   938 label *label298
   939 label *label299
 
   948 op mul *tmp64 *tmp63 :fn2:zy
   949 op add :fn2:zy *tmp64 :fn2:cy
   950 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label301 lessThan :fn2:dist 64
-    * jump *label54 always
+  951 jump *label54 greaterThanEq :fn2:dist 64
   952 label *label301
   953 label *label302
   954 label *label303
 
   963 op mul *tmp64 *tmp63 :fn2:zy
   964 op add :fn2:zy *tmp64 :fn2:cy
   965 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label305 lessThan :fn2:dist 64
-    * jump *label54 always
+  966 jump *label54 greaterThanEq :fn2:dist 64
   967 label *label305
   968 label *label306
   969 label *label307
 
   978 op mul *tmp64 *tmp63 :fn2:zy
   979 op add :fn2:zy *tmp64 :fn2:cy
   980 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label309 lessThan :fn2:dist 64
-    * jump *label54 always
+  981 jump *label54 greaterThanEq :fn2:dist 64
   982 label *label309
   983 label *label310
   984 label *label311
 
   993 op mul *tmp64 *tmp63 :fn2:zy
   994 op add :fn2:zy *tmp64 :fn2:cy
   995 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label313 lessThan :fn2:dist 64
-    * jump *label54 always
+  996 jump *label54 greaterThanEq :fn2:dist 64
   997 label *label313
   998 label *label314
   999 label *label315
 
  1008 op mul *tmp64 *tmp63 :fn2:zy
  1009 op add :fn2:zy *tmp64 :fn2:cy
  1010 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label317 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1011 jump *label54 greaterThanEq :fn2:dist 64
  1012 label *label317
  1013 label *label318
  1014 label *label319
 
  1023 op mul *tmp64 *tmp63 :fn2:zy
  1024 op add :fn2:zy *tmp64 :fn2:cy
  1025 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label321 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1026 jump *label54 greaterThanEq :fn2:dist 64
  1027 label *label321
  1028 label *label322
  1029 label *label323
 
  1038 op mul *tmp64 *tmp63 :fn2:zy
  1039 op add :fn2:zy *tmp64 :fn2:cy
  1040 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label325 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1041 jump *label54 greaterThanEq :fn2:dist 64
  1042 label *label325
  1043 label *label326
  1044 label *label327
 
  1053 op mul *tmp64 *tmp63 :fn2:zy
  1054 op add :fn2:zy *tmp64 :fn2:cy
  1055 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label329 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1056 jump *label54 greaterThanEq :fn2:dist 64
  1057 label *label329
  1058 label *label330
  1059 label *label331
 
  1068 op mul *tmp64 *tmp63 :fn2:zy
  1069 op add :fn2:zy *tmp64 :fn2:cy
  1070 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label333 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1071 jump *label54 greaterThanEq :fn2:dist 64
  1072 label *label333
  1073 label *label334
  1074 label *label335
 
  1083 op mul *tmp64 *tmp63 :fn2:zy
  1084 op add :fn2:zy *tmp64 :fn2:cy
  1085 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label337 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1086 jump *label54 greaterThanEq :fn2:dist 64
  1087 label *label337
  1088 label *label338
  1089 label *label339
 
  1098 op mul *tmp64 *tmp63 :fn2:zy
  1099 op add :fn2:zy *tmp64 :fn2:cy
  1100 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label341 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1101 jump *label54 greaterThanEq :fn2:dist 64
  1102 label *label341
  1103 label *label342
  1104 label *label343
 
  1113 op mul *tmp64 *tmp63 :fn2:zy
  1114 op add :fn2:zy *tmp64 :fn2:cy
  1115 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label345 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1116 jump *label54 greaterThanEq :fn2:dist 64
  1117 label *label345
  1118 label *label346
  1119 label *label347
 
  1128 op mul *tmp64 *tmp63 :fn2:zy
  1129 op add :fn2:zy *tmp64 :fn2:cy
  1130 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label349 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1131 jump *label54 greaterThanEq :fn2:dist 64
  1132 label *label349
  1133 label *label350
  1134 label *label351
 
  1202 drawflush .display
  1203 label *label59
  1204 read *tmp114 .memory :position
-    * jump *label71 equal *tmp114 .PROCESSOR_ID
-    * jump *label44 always
+ 1205 jump *label44 notEqual *tmp114 .PROCESSOR_ID
  1206 label *label71
  1207 label *label72
  1208 read *tmp1 .memory 65
-    * jump *label73 equal .stop *tmp1
-    * jump *label39 always
+ 1209 jump *label39 notEqual .stop *tmp1
  1210 label *label73
  1211 label *label74
  1212 label *label43

Modifications by Final phase, Jump Threading, iteration 1:
 
  1149 jump *label60 equal .SMOOTH false
  1150 jump *label62 notEqual *tmp41 63
  1151 draw color 0 0 0 255
-    * jump *label63 always
+ 1152 jump *label61 always
  1153 label *label62
  1154 jump *label65 notEqual .PALETTE 2
  1155 label *label66
 
  1164 op mul *tmp92 4 *tmp83
  1165 op add :fn3:b 120 *tmp92
  1166 draw color :fn3:r :fn3:g :fn3:b 255
-    * jump *label64 always
+ 1167 jump *label61 always
  1168 label *label65
  1169 jump *label67 notEqual .PALETTE 3
  1170 label *label68
 
  1178 op mul *tmp104 4 *tmp103
  1179 op add :fn3:b 100 *tmp104
  1180 draw color :fn3:r :fn3:g :fn3:b 255
-    * jump *label64 always
+ 1181 jump *label61 always
  1182 label *label67
  1183 jump *label69 notEqual .PALETTE 4
  1184 label *label70
 
  1186 op mul *tmp107 1.5 *tmp41
  1187 op add :fn3:g 96 *tmp107
  1188 draw color :fn3:r :fn3:g 0 255
-    * jump *label64 always
+ 1189 jump *label61 always
  1190 label *label69
  1191 op mul *tmp109 4 *tmp41
  1192 op sub :fn3:r 255 *tmp109

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-5 instructions):
 
    78 jump *label372 notEqual *tmp124 .PROCESSOR_ID
    79 write 0 .memory .PROC_STATE_INDEX
    80 jump *label377 always
-    * jump *label375 always
    81 label *label372
    82 read *tmp130 .memory .PROC_ID_INDEX
    83 jump *label373 notEqual *tmp130 0
    84 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    85 write 0 .memory .PROC_STATE_INDEX
    86 jump *label377 always
-    * jump *label374 always
    87 label *label373
    88 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    89 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
   109 jump *label382 notEqual *tmp124 .PROCESSOR_ID
   110 write *tmp0 .memory .PROC_STATE_INDEX
   111 jump *label387 always
-    * jump *label385 always
   112 label *label382
   113 read *tmp130 .memory .PROC_ID_INDEX
   114 jump *label383 notEqual *tmp130 0
   115 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   116 write *tmp0 .memory .PROC_STATE_INDEX
   117 jump *label387 always
-    * jump *label384 always
   118 label *label383
   119 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   120 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
  1225 drawflush .display
  1226 label *label30
  1227 jump *label29 always
-    * label *label31
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-6 instructions):
 
    43 jump *label85 greaterThan :fn1:n 0
    44 label *label12
    45 label *label389
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
+   46 print "\nDisplay: "
    47 print .display
    48 op and :fn1:foundAll 1 .display
    49 label *label390
    50 label *label391
    51 label *label392
    52 label *label395
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
+   53 print "\nMemory: "
    54 print .memory
    55 op and :fn1:foundAll :fn1:foundAll .memory
    56 label *label396

Final code before resolving virtual instructions:

    0:  set *tmp9 @thisx                                             mandelbrot-compute.mnd: var PROCESSOR_ID = @this.@x + 10000 * @this.@y;
    1:  set *tmp10 @thisy                                            ...
    2:  op mul *tmp11 10000 *tmp10                                   ...
    3:  op add .PROCESSOR_ID *tmp9 *tmp11                            ...
    4:  set .PROC_ID_INDEX 334                                       mandelbrot-compute.mnd: var PROC_ID_INDEX = PROCESSORS;
    5:  set .PROC_STATE_INDEX 335                                    mandelbrot-compute.mnd: var PROC_STATE_INDEX = PROCESSORS + 1;
    6:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label2                                                *blocks: do
    7:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    8:  set .memory null                                             ...
    9:  print "Mandelbrot Generator"                                 *blocks: print(title);
   10:  set :fn1:n @links                                            *blocks: var n = @links;
   11:  jump *label12 lessThanEq :fn1:n 0                            *blocks: while n > 0 do
        label *label85                                               ...
   12:  op sub :fn1:n :fn1:n 1                                       *blocks: var block = getlink(--n);
   13:  getlink :fn1:block :fn1:n                                    ...
   14:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
   15:  print :fn1:block                                             ...
   16:  sensor :fn1:type :fn1:block @type                            *blocks: var type = block.@type;
   17:  jump *label355 notEqual @large-logic-display :fn1:type       *blocks: if requested == type then
   18:  set .display :fn1:block                                      *blocks: variable = block;
        label *label355                                              *blocks: if requested == type then
   19:  jump *label363 notEqual @memory-bank :fn1:type               ...
   20:  set .memory :fn1:block                                       *blocks: variable = block;
        label *label363                                              *blocks: if requested == type then
   21:  jump *label85 greaterThan :fn1:n 0                           *blocks: while n > 0 do
        label *label12                                               ...
   22:  print "\nDisplay: "                                          *blocks: print($"\n$name: $variable");
   23:  print .display                                               ...
   24:  op and :fn1:foundAll 1 .display                              *blocks: if required then foundAll &= variable; end;
   25:  print "\nMemory: "                                           *blocks: print($"\n$name: $variable");
   26:  print .memory                                                ...
   27:  op and :fn1:foundAll :fn1:foundAll .memory                   *blocks: if required then foundAll &= variable; end;
   28:  printflush null                                              *blocks: printflush(message);
   29:  jump *label2 equal :fn1:foundAll false                       *blocks: do
        label *label29                                               mandelbrot-compute.mnd: while true do
        label *label32                                               mandelbrot-compute.mnd: do
   30:  jump *label377 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label371                                              ...
   31:  read *tmp124 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   32:  jump *label372 notEqual *tmp124 .PROCESSOR_ID                ...
   33:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   34:  jump *label377 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label372                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   35:  read *tmp130 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   36:  jump *label373 notEqual *tmp130 0                            ...
   37:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   38:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   39:  jump *label377 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label373                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   40:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   41:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   42:  jump *label371 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label377                                              ...
   43:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: while start == $START;
   44:  jump *label32 equal .start *tmp0                             mandelbrot-compute.mnd: do
   45:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: start = $START;
   46:  set .start *tmp0                                             ...
   47:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: stop = $STOP;
   48:  set .stop *tmp1                                              ...
   49:  jump *label387 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label381                                              ...
   50:  read *tmp124 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   51:  jump *label382 notEqual *tmp124 .PROCESSOR_ID                ...
   52:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   53:  jump *label387 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label382                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   54:  read *tmp130 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   55:  jump *label383 notEqual *tmp130 0                            ...
   56:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   57:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   58:  jump *label387 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label383                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   59:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   60:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   61:  jump *label381 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label387                                              ...
   62:  read .ZOOM .memory 68                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   63:  op div *tmp26 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   64:  read *tmp2 .memory 66                                        ...
   65:  op add .OFFSET_X *tmp26 *tmp2                                ...
   66:  read *tmp3 .memory 67                                        mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   67:  op add .OFFSET_Y *tmp26 *tmp3                                ...
   68:  read .JULIA .memory 69                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   69:  read .JULIA_X .memory 70                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   70:  read .JULIA_Y .memory 71                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   71:  read .PALETTE .memory 72                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   72:  op greaterThan .SMOOTH .PALETTE 1                            mandelbrot-compute.mnd: SMOOTH   = PALETTE > 1;
   73:  set :line 8                                                  mandelbrot-compute.mnd: var line = 8;
   74:  set :increment 8                                             mandelbrot-compute.mnd: var increment = 8;
   75:  set :next_increment 16                                       mandelbrot-compute.mnd: var next_increment = 16;
   76:  op rand *tmp31 0.1 0                                         mandelbrot-compute.mnd: wait(rand(0.1));
   77:  wait *tmp31                                                  ...
   78:  set :lines 0                                                 mandelbrot-compute.mnd: MasterLoop:
        label *label86                                               ...
   79:  op mul *tmp32 17 :line                                       mandelbrot-compute.mnd: var x = (SKIP * line) % DISPLAY_SIZE_LARGE;
   80:  op mod :x *tmp32 176                                         ...
   81:  op add :position :x 158                                      mandelbrot-compute.mnd: var position = x + SLOTS;
   82:  read *tmp36 .memory :position                                mandelbrot-compute.mnd: if memory[position] == 0 then
   83:  jump *label40 notEqual *tmp36 0                              ...
   84:  write .PROCESSOR_ID .memory :position                        mandelbrot-compute.mnd: memory[position] = PROCESSOR_ID;
   85:  set :y 0                                                     mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
        label *label87                                               ...
   86:  op div *tmp42 :x .ZOOM                                       mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   87:  op add :fn2:zx *tmp42 .OFFSET_X                              ...
   88:  op div *tmp44 :y .ZOOM                                       mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   89:  op add :fn2:zy *tmp44 .OFFSET_Y                              ...
   90:  jump *label46 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   91:  set :fn2:cx .JULIA_X                                         mandelbrot-compute.mnd: cx = JULIA_X;
   92:  set :fn2:cy .JULIA_Y                                         mandelbrot-compute.mnd: cy = JULIA_Y;
   93:  jump *label47 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label46                                               ...
   94:  set :fn2:cx :fn2:zx                                          mandelbrot-compute.mnd: cx = zx;
   95:  set :fn2:cy :fn2:zy                                          mandelbrot-compute.mnd: cy = zy;
   96:  op sub *tmp47 :fn2:zx 0.25                                   mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   97:  op len :fn2:p *tmp47 :fn2:zy                                 ...
   98:  op mul *tmp49 2 :fn2:p                                       mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
   99:  op mul *tmp50 *tmp49 :fn2:p                                  ...
  100:  op sub *tmp51 :fn2:p *tmp50                                  ...
  101:  op add *tmp52 *tmp51 0.25                                    ...
  102:  jump *label48 greaterThan :fn2:zx *tmp52                     ...
  103:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  104:  jump *label45 always 0 0                                     ...
        label *label48                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  105:  op add *tmp55 :fn2:zx 1                                      mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  106:  op len *tmp56 *tmp55 :fn2:zy                                 ...
  107:  jump *label50 greaterThan *tmp56 0.25                        ...
  108:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  109:  jump *label45 always 0 0                                     ...
        label *label50                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label47                                               mandelbrot-compute.mnd: if JULIA then
  110:  set :fn2:i 0                                                 mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  111:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  112:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  113:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  114:  op sub *tmp61 *tmp59 *tmp60                                  ...
  115:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  116:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  117:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  118:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  119:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  120:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  121:  set :fn2:i 1                                                 mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  122:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  123:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  124:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  125:  op sub *tmp61 *tmp59 *tmp60                                  ...
  126:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  127:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  128:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  129:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  130:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  131:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  132:  op add :fn2:i 1 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  133:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  134:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  135:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  136:  op sub *tmp61 *tmp59 *tmp60                                  ...
  137:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  138:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  139:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  140:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  141:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  142:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  143:  op add :fn2:i 2 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  144:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  145:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  146:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  147:  op sub *tmp61 *tmp59 *tmp60                                  ...
  148:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  149:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  150:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  151:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  152:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  153:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  154:  op add :fn2:i 3 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  155:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  156:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  157:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  158:  op sub *tmp61 *tmp59 *tmp60                                  ...
  159:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  160:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  161:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  162:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  163:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  164:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  165:  op add :fn2:i 4 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  166:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  167:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  168:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  169:  op sub *tmp61 *tmp59 *tmp60                                  ...
  170:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  171:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  172:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  173:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  174:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  175:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  176:  op add :fn2:i 5 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  177:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  178:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  179:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  180:  op sub *tmp61 *tmp59 *tmp60                                  ...
  181:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  182:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  183:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  184:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  185:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  186:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  187:  op add :fn2:i 6 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  188:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  189:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  190:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  191:  op sub *tmp61 *tmp59 *tmp60                                  ...
  192:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  193:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  194:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  195:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  196:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  197:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  198:  op add :fn2:i 7 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  199:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  200:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  201:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  202:  op sub *tmp61 *tmp59 *tmp60                                  ...
  203:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  204:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  205:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  206:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  207:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  208:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  209:  op add :fn2:i 8 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  210:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  211:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  212:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  213:  op sub *tmp61 *tmp59 *tmp60                                  ...
  214:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  215:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  216:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  217:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  218:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  219:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  220:  op add :fn2:i 9 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  221:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  222:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  223:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  224:  op sub *tmp61 *tmp59 *tmp60                                  ...
  225:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  226:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  227:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  228:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  229:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  230:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  231:  op add :fn2:i 10 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  232:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  233:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  234:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  235:  op sub *tmp61 *tmp59 *tmp60                                  ...
  236:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  237:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  238:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  239:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  240:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  241:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  242:  op add :fn2:i 11 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  243:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  244:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  245:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  246:  op sub *tmp61 *tmp59 *tmp60                                  ...
  247:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  248:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  249:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  250:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  251:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  252:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  253:  op add :fn2:i 12 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  254:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  255:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  256:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  257:  op sub *tmp61 *tmp59 *tmp60                                  ...
  258:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  259:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  260:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  261:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  262:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  263:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  264:  op add :fn2:i 13 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  265:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  266:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  267:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  268:  op sub *tmp61 *tmp59 *tmp60                                  ...
  269:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  270:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  271:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  272:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  273:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  274:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  275:  op add :fn2:i 14 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  276:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  277:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  278:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  279:  op sub *tmp61 *tmp59 *tmp60                                  ...
  280:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  281:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  282:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  283:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  284:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  285:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  286:  op add :fn2:i 15 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  287:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  288:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  289:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  290:  op sub *tmp61 *tmp59 *tmp60                                  ...
  291:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  292:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  293:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  294:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  295:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  296:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  297:  op add :fn2:i 16 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  298:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  299:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  300:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  301:  op sub *tmp61 *tmp59 *tmp60                                  ...
  302:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  303:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  304:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  305:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  306:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  307:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  308:  op add :fn2:i 17 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  309:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  310:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  311:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  312:  op sub *tmp61 *tmp59 *tmp60                                  ...
  313:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  314:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  315:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  316:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  317:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  318:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  319:  op add :fn2:i 18 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  320:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  321:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  322:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  323:  op sub *tmp61 *tmp59 *tmp60                                  ...
  324:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  325:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  326:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  327:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  328:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  329:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  330:  op add :fn2:i 19 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  331:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  332:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  333:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  334:  op sub *tmp61 *tmp59 *tmp60                                  ...
  335:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  336:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  337:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  338:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  339:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  340:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  341:  op add :fn2:i 20 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  342:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  343:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  344:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  345:  op sub *tmp61 *tmp59 *tmp60                                  ...
  346:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  347:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  348:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  349:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  350:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  351:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  352:  op add :fn2:i 21 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  353:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  354:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  355:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  356:  op sub *tmp61 *tmp59 *tmp60                                  ...
  357:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  358:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  359:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  360:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  361:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  362:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  363:  op add :fn2:i 22 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  364:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  365:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  366:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  367:  op sub *tmp61 *tmp59 *tmp60                                  ...
  368:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  369:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  370:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  371:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  372:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  373:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  374:  op add :fn2:i 23 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  375:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  376:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  377:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  378:  op sub *tmp61 *tmp59 *tmp60                                  ...
  379:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  380:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  381:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  382:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  383:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  384:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  385:  op add :fn2:i 24 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  386:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  387:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  388:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  389:  op sub *tmp61 *tmp59 *tmp60                                  ...
  390:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  391:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  392:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  393:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  394:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  395:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  396:  op add :fn2:i 25 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  397:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  398:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  399:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  400:  op sub *tmp61 *tmp59 *tmp60                                  ...
  401:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  402:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  403:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  404:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  405:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  406:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  407:  op add :fn2:i 26 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  408:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  409:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  410:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  411:  op sub *tmp61 *tmp59 *tmp60                                  ...
  412:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  413:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  414:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  415:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  416:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  417:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  418:  op add :fn2:i 27 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  419:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  420:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  421:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  422:  op sub *tmp61 *tmp59 *tmp60                                  ...
  423:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  424:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  425:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  426:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  427:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  428:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  429:  op add :fn2:i 28 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  430:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  431:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  432:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  433:  op sub *tmp61 *tmp59 *tmp60                                  ...
  434:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  435:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  436:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  437:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  438:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  439:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  440:  op add :fn2:i 29 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  441:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  442:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  443:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  444:  op sub *tmp61 *tmp59 *tmp60                                  ...
  445:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  446:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  447:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  448:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  449:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  450:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  451:  op add :fn2:i 30 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  452:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  453:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  454:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  455:  op sub *tmp61 *tmp59 *tmp60                                  ...
  456:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  457:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  458:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  459:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  460:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  461:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  462:  op add :fn2:i 31 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  463:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  464:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  465:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  466:  op sub *tmp61 *tmp59 *tmp60                                  ...
  467:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  468:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  469:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  470:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  471:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  472:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  473:  op add :fn2:i 32 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  474:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  475:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  476:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  477:  op sub *tmp61 *tmp59 *tmp60                                  ...
  478:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  479:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  480:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  481:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  482:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  483:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  484:  op add :fn2:i 33 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  485:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  486:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  487:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  488:  op sub *tmp61 *tmp59 *tmp60                                  ...
  489:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  490:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  491:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  492:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  493:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  494:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  495:  op add :fn2:i 34 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  496:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  497:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  498:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  499:  op sub *tmp61 *tmp59 *tmp60                                  ...
  500:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  501:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  502:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  503:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  504:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  505:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  506:  op add :fn2:i 35 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  507:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  508:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  509:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  510:  op sub *tmp61 *tmp59 *tmp60                                  ...
  511:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  512:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  513:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  514:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  515:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  516:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  517:  op add :fn2:i 36 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  518:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  519:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  520:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  521:  op sub *tmp61 *tmp59 *tmp60                                  ...
  522:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  523:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  524:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  525:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  526:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  527:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  528:  op add :fn2:i 37 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  529:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  530:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  531:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  532:  op sub *tmp61 *tmp59 *tmp60                                  ...
  533:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  534:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  535:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  536:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  537:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  538:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  539:  op add :fn2:i 38 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  540:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  541:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  542:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  543:  op sub *tmp61 *tmp59 *tmp60                                  ...
  544:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  545:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  546:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  547:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  548:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  549:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  550:  op add :fn2:i 39 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  551:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  552:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  553:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  554:  op sub *tmp61 *tmp59 *tmp60                                  ...
  555:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  556:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  557:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  558:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  559:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  560:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  561:  op add :fn2:i 40 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  562:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  563:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  564:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  565:  op sub *tmp61 *tmp59 *tmp60                                  ...
  566:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  567:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  568:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  569:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  570:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  571:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  572:  op add :fn2:i 41 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  573:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  574:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  575:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  576:  op sub *tmp61 *tmp59 *tmp60                                  ...
  577:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  578:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  579:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  580:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  581:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  582:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  583:  op add :fn2:i 42 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  584:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  585:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  586:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  587:  op sub *tmp61 *tmp59 *tmp60                                  ...
  588:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  589:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  590:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  591:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  592:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  593:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  594:  op add :fn2:i 43 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  595:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  596:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  597:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  598:  op sub *tmp61 *tmp59 *tmp60                                  ...
  599:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  600:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  601:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  602:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  603:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  604:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  605:  op add :fn2:i 44 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  606:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  607:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  608:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  609:  op sub *tmp61 *tmp59 *tmp60                                  ...
  610:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  611:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  612:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  613:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  614:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  615:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  616:  op add :fn2:i 45 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  617:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  618:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  619:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  620:  op sub *tmp61 *tmp59 *tmp60                                  ...
  621:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  622:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  623:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  624:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  625:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  626:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  627:  op add :fn2:i 46 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  628:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  629:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  630:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  631:  op sub *tmp61 *tmp59 *tmp60                                  ...
  632:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  633:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  634:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  635:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  636:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  637:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  638:  op add :fn2:i 47 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  639:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  640:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  641:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  642:  op sub *tmp61 *tmp59 *tmp60                                  ...
  643:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  644:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  645:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  646:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  647:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  648:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  649:  op add :fn2:i 48 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  650:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  651:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  652:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  653:  op sub *tmp61 *tmp59 *tmp60                                  ...
  654:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  655:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  656:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  657:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  658:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  659:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  660:  op add :fn2:i 49 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  661:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  662:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  663:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  664:  op sub *tmp61 *tmp59 *tmp60                                  ...
  665:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  666:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  667:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  668:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  669:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  670:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  671:  op add :fn2:i 50 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  672:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  673:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  674:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  675:  op sub *tmp61 *tmp59 *tmp60                                  ...
  676:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  677:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  678:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  679:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  680:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  681:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  682:  op add :fn2:i 51 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  683:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  684:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  685:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  686:  op sub *tmp61 *tmp59 *tmp60                                  ...
  687:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  688:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  689:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  690:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  691:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  692:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  693:  op add :fn2:i 52 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  694:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  695:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  696:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  697:  op sub *tmp61 *tmp59 *tmp60                                  ...
  698:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  699:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  700:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  701:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  702:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  703:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  704:  op add :fn2:i 53 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  705:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  706:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  707:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  708:  op sub *tmp61 *tmp59 *tmp60                                  ...
  709:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  710:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  711:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  712:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  713:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  714:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  715:  op add :fn2:i 54 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  716:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  717:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  718:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  719:  op sub *tmp61 *tmp59 *tmp60                                  ...
  720:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  721:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  722:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  723:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  724:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  725:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  726:  op add :fn2:i 55 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  727:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  728:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  729:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  730:  op sub *tmp61 *tmp59 *tmp60                                  ...
  731:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  732:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  733:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  734:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  735:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  736:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  737:  op add :fn2:i 56 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  738:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  739:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  740:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  741:  op sub *tmp61 *tmp59 *tmp60                                  ...
  742:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  743:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  744:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  745:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  746:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  747:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  748:  op add :fn2:i 57 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  749:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  750:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  751:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  752:  op sub *tmp61 *tmp59 *tmp60                                  ...
  753:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  754:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  755:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  756:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  757:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  758:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  759:  op add :fn2:i 58 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  760:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  761:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  762:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  763:  op sub *tmp61 *tmp59 *tmp60                                  ...
  764:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  765:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  766:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  767:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  768:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  769:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  770:  op add :fn2:i 59 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  771:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  772:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  773:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  774:  op sub *tmp61 *tmp59 *tmp60                                  ...
  775:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  776:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  777:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  778:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  779:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  780:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  781:  op add :fn2:i 60 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  782:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  783:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  784:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  785:  op sub *tmp61 *tmp59 *tmp60                                  ...
  786:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  787:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  788:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  789:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  790:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  791:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  792:  op add :fn2:i 61 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  793:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  794:  op mul *tmp59 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  795:  op mul *tmp60 :fn2:zy :fn2:zy                                ...
  796:  op sub *tmp61 *tmp59 *tmp60                                  ...
  797:  op add :fn2:zx *tmp61 :fn2:cx                                ...
  798:  op mul *tmp63 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  799:  op mul *tmp64 *tmp63 :fn2:zy                                 ...
  800:  op add :fn2:zy *tmp64 :fn2:cy                                ...
  801:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  802:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  803:  op add :fn2:i 62 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label54                                               ...
  804:  op mul *tmp69 .SMOOTH 63                                     mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  805:  jump *label57 greaterThanEq :fn2:i *tmp69                    ...
  806:  op log *tmp72 :fn2:dist 0                                    mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  807:  op mul *tmp73 *tmp72 0.36067376022224085                     ...
  808:  op log *tmp74 *tmp73 0                                       ...
  809:  op mul *tmp75 *tmp74 1.4426950408889634                      ...
  810:  op sub :fn2:correction 4 *tmp75                              ...
  811:  op add :fn2:i :fn2:i :fn2:correction                         mandelbrot-compute.mnd: i += correction;
        label *label57                                               mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  812:  set *tmp41 :fn2:i                                            mandelbrot-compute.mnd: return i;
        label *label45                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  813:  jump *label60 equal .SMOOTH false                            mandelbrot-compute.mnd: if SMOOTH then
  814:  jump *label62 notEqual *tmp41 63                             mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  815:  draw color 0 0 0 255 0 0                                     mandelbrot-compute.mnd: color(0, 0, 0, 255);
  816:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
        label *label62                                               ...
  817:  jump *label65 notEqual .PALETTE 2                            mandelbrot-compute.mnd: case PALETTE
  818:  op sub *tmp82 32 *tmp41                                      mandelbrot-compute.mnd: r = 255 - 7 * abs(32 - iterations);
  819:  op abs *tmp83 *tmp82 0                                       ...
  820:  op mul *tmp84 7 *tmp83                                       ...
  821:  op sub :fn3:r 255 *tmp84                                     ...
  822:  op sub *tmp86 *tmp41 32                                      mandelbrot-compute.mnd: g = 240 - 6 * abs(iterations - 32);
  823:  op abs *tmp87 *tmp86 0                                       ...
  824:  op mul *tmp88 6 *tmp87                                       ...
  825:  op sub :fn3:g 240 *tmp88                                     ...
  826:  op mul *tmp92 4 *tmp83                                       mandelbrot-compute.mnd: b = 120 + 4 * abs(32 - iterations);
  827:  op add :fn3:b 120 *tmp92                                     ...
  828:  draw color :fn3:r :fn3:g :fn3:b 255 0 0                      mandelbrot-compute.mnd: color(r, g, b, 255);
  829:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label65                                               ...
  830:  jump *label67 notEqual .PALETTE 3                            ...
  831:  op div *tmp95 *tmp41 0.175                                   mandelbrot-compute.mnd: r = 255 * sin(iterations / MAX_DEPTH * 360);
  832:  op sin *tmp96 *tmp95 0                                       ...
  833:  op mul :fn3:r 255 *tmp96                                     ...
  834:  op cos *tmp100 *tmp95 0                                      mandelbrot-compute.mnd: g = 255 * cos(iterations / MAX_DEPTH * 360);
  835:  op mul :fn3:g 255 *tmp100                                    ...
  836:  op sub *tmp102 *tmp41 32                                     mandelbrot-compute.mnd: b = 100 + 4 * abs(iterations - 32);
  837:  op abs *tmp103 *tmp102 0                                     ...
  838:  op mul *tmp104 4 *tmp103                                     ...
  839:  op add :fn3:b 100 *tmp104                                    ...
  840:  draw color :fn3:r :fn3:g :fn3:b 255 0 0                      mandelbrot-compute.mnd: color(r, g, b, 255);
  841:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label67                                               ...
  842:  jump *label69 notEqual .PALETTE 4                            ...
  843:  op mul :fn3:r 4 *tmp41                                       mandelbrot-compute.mnd: r = 4 * iterations;
  844:  op mul *tmp107 1.5 *tmp41                                    mandelbrot-compute.mnd: g = 96 + 1.5 * iterations;
  845:  op add :fn3:g 96 *tmp107                                     ...
  846:  draw color :fn3:r :fn3:g 0 255 0 0                           mandelbrot-compute.mnd: color(r, g, 0, 255);
  847:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label69                                               ...
  848:  op mul *tmp109 4 *tmp41                                      mandelbrot-compute.mnd: r = 255 - 4 * iterations;
  849:  op sub :fn3:r 255 *tmp109                                    ...
  850:  draw color :fn3:r :fn3:r 0 255 0 0                           mandelbrot-compute.mnd: color(r, r, 0, 255);
  851:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label60                                               ...
  852:  read *tmp112 .memory *tmp41                                  mandelbrot-compute.mnd: col(memory[iterations]);
  853:  draw col *tmp112 0 0 0 0 0                                   ...
        label *label61                                               mandelbrot-compute.mnd: if SMOOTH then
  854:  draw rect :x :y 1 1 0 0                                      mandelbrot-compute.mnd: rect(x, y, 1, 1);
  855:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  856:  read *tmp114 .memory :position                               mandelbrot-compute.mnd: if memory[position] != PROCESSOR_ID then
  857:  jump *label44 notEqual *tmp114 .PROCESSOR_ID                 ...
  858:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: if stop != $STOP then
  859:  jump *label39 notEqual .stop *tmp1                           ...
  860:  op add :y :y 1                                               mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
  861:  jump *label87 lessThan :y 176                                ...
        label *label44                                               ...
        label *label40                                               mandelbrot-compute.mnd: if memory[position] == 0 then
  862:  op add :line :line :increment                                mandelbrot-compute.mnd: line += increment;
  863:  jump *label75 lessThanEq :line 176                           mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  864:  op div :next_increment :next_increment 2                     mandelbrot-compute.mnd: increment = next_increment /= 2;
  865:  set :increment :next_increment                               ...
  866:  op div :line :next_increment 2                               mandelbrot-compute.mnd: line = increment / 2;
        label *label75                                               mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  867:  op add :lines :lines 1                                       mandelbrot-compute.mnd: MasterLoop:
  868:  jump *label86 lessThan :lines 176                            ...
        label *label39                                               ...
  869:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  870:  jump *label29 always 0 0                                     mandelbrot-compute.mnd: while true do


Performance: parsed in 248 ms, compiled in 212 ms, optimized in 1,467 ms, run in 38 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Display: display
Memory: bank
Execution step limit of 100 000 exceeded.
