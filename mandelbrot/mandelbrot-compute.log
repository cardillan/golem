   378 instructions before optimizations.
    30 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    38 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 4 iterations).
    20 instructions eliminated by Jump Optimization (4 iterations).
    15 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     8 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
    52 instructions eliminated by Data Flow Optimization (5 passes, 20 iterations).
     3 instructions eliminated by Loop Optimization (3 iterations).
     5 loops improved by Loop Optimization.
   742 instructions added by Loop Unrolling (8 iterations).
     4 loops unrolled by Loop Unrolling.
     9 instructions added by Function Inlining (8 iterations).
     2 function calls inlined by Function Inlining.
    69 instructions eliminated by Jump Straightening (2 passes, 4 iterations).
     4 instructions updated by JumpThreading.
     5 instructions eliminated by Unreachable Code Elimination.
     6 instructions eliminated by Print Merging.
   879 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 772):
  * Unroll iteration loop at *blocks:57:9                        cost     0, benefit      125.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:66:13                       cost     3, benefit     3125.0, efficiency     1041.7
    Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9
    Unroll loop at mandelbrot-compute.mnd:136:5                  cost   679, benefit 24609375.0, efficiency    36243.6
    Inline function 'setState' defined at mandelbrot-compute.mnd:208:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:52:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:60:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 776):
    Unroll iteration loop at *blocks:66:13                       cost     3, benefit     3125.0, efficiency     1041.7
    Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9
  * Unroll loop at mandelbrot-compute.mnd:136:5                  cost   679, benefit 24609375.0, efficiency    36243.6 (+743 instructions)
    Inline function 'setState' defined at mandelbrot-compute.mnd:208:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:52:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:60:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 33):
  * Unroll iteration loop at *blocks:66:13                       cost     3, benefit     3125.0, efficiency     1041.7 (-5 instructions)
    Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9
    Inline function 'setState' defined at mandelbrot-compute.mnd:208:1 cost    13, benefit     2275.0, efficiency      175.0
    Inline function call at mandelbrot-compute.mnd:52:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:60:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 38):
    Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9
  * Inline function 'setState' defined at mandelbrot-compute.mnd:208:1 cost    13, benefit     2275.0, efficiency      175.0 (+7 instructions)
    Inline function call at mandelbrot-compute.mnd:52:13         cost    14, benefit     2187.5, efficiency      156.3
    Inline function call at mandelbrot-compute.mnd:60:9          cost    14, benefit       87.5, efficiency        6.3

Pass 1: speed optimization selection (cost limit 31):
  * Unroll iteration loop at *blocks:75:9                        cost     9, benefit      125.0, efficiency       13.9 (+0 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   283 set *tmp80 null
   284 jump *label63 always
   285 label *label62
-    * set *tmp82 .PALETTE
-    * jump *label66 equal *tmp82 2
+  286 jump *label66 equal .PALETTE 2
   287 jump *label65 always
   288 label *label66
   289 op sub *tmp83 32 :fn3:iterations
 
   305 set *tmp81 null
   306 jump *label64 always
   307 label *label65
-    * jump *label68 equal *tmp82 3
+  308 jump *label68 equal .PALETTE 3
   309 jump *label67 always
   310 label *label68
   311 op div *tmp95 :fn3:iterations 63
 
   327 set *tmp81 null
   328 jump *label64 always
   329 label *label67
-    * jump *label70 equal *tmp82 4
+  330 jump *label70 equal .PALETTE 4
   331 jump *label69 always
   332 label *label70
   333 op mul *tmp107 4 :fn3:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-26 instructions):
 
    66 label *label20
    67 set *tmp22 null
    68 label *label21
-    * set *tmp20 *tmp22
    69 jump *label19 always
    70 label *label18
-    * set *tmp20 null
    71 label *label19
    72 label *label14
    73 goto *tmp18 marker1
 
    99 print :fn1:variable
   100 jump *label27 equal :fn1:required false
   101 op and :fn1:foundAll :fn1:foundAll :fn1:variable
-    * set *tmp24 :fn1:foundAll
   102 jump *label28 always
   103 label *label27
-    * set *tmp24 null
   104 label *label28
   105 label *label23
   106 goto *tmp23 marker2
 
   187 jump *label46 equal .JULIA false
   188 set :fn2:cx .JULIA_X
   189 set :fn2:cy .JULIA_Y
-    * set *tmp47 :fn2:cy
   190 jump *label47 always
   191 label *label46
   192 set :fn2:cx :fn2:zx
 
   202 jump *label48 equal *tmp54 false
   203 set *tmp42 63
   204 jump *label45 always
-    * set *tmp55 null
   205 jump *label49 always
   206 label *label48
-    * set *tmp55 null
   207 label *label49
   208 op add *tmp56 :fn2:cx 1
   209 op len *tmp57 *tmp56 :fn2:cy
 
   216 label *label50
   217 set *tmp59 null
   218 label *label51
-    * set *tmp47 *tmp59
   219 label *label47
   220 set :fn2:i 0
   221 label *label52
 
   236 op greaterThanEq *tmp68 :fn2:dist 64
   237 jump *label55 equal *tmp68 false
   238 jump *label54 always
-    * set *tmp69 null
   239 jump *label56 always
   240 label *label55
-    * set *tmp69 null
   241 label *label56
   242 label *label53
   243 op add :fn2:i :fn2:i 1
 
   253 op sub *tmp77 4 *tmp76
   254 set :fn2:correction *tmp77
   255 op add :fn2:i :fn2:i :fn2:correction
-    * set *tmp72 :fn2:i
   256 jump *label58 always
   257 label *label57
-    * set *tmp72 null
   258 label *label58
   259 set *tmp42 :fn2:i
   260 jump *label45 always
 
   335 label *label64
   336 set *tmp80 *tmp81
   337 label *label63
-    * set *tmp78 *tmp80
   338 jump *label61 always
   339 label *label60
   340 set *tmp112 :fn3:iterations
   341 read *tmp113 .memory *tmp112
   342 draw col *tmp113
-    * set *tmp78 null
   343 label *label61
   344 draw rect :fn3:x :fn3:y 1 1
   345 op add .BATCH .BATCH 1
   346 op lessThan *tmp114 .BATCH 44
   347 jump *label71 equal *tmp114 false
   348 jump *label59 always
-    * set *tmp115 null
   349 jump *label72 always
   350 label *label71
-    * set *tmp115 null
   351 label *label72
   352 label *label73
   353 label *label74
 
   369 op notEqual *tmp120 *tmp119 .PROCESSOR_ID
   370 jump *label79 equal *tmp120 false
   371 jump *label44 always
-    * set *tmp121 null
   372 jump *label80 always
   373 label *label79
-    * set *tmp121 null
   374 label *label80
   375 read *tmp1 .memory 65
   376 op notEqual *tmp122 .stop *tmp1
   377 jump *label81 equal *tmp122 false
   378 jump *label39 always
-    * set *tmp123 null
   379 jump *label82 always
   380 label *label81
-    * set *tmp123 null
   381 label *label82
   382 label *label43
   383 op add :y :y 1
   384 jump *label42 always
   385 label *label44
-    * set *tmp39 null
   386 jump *label41 always
   387 label *label40
-    * set *tmp39 null
   388 label *label41
   389 op add :line :line :increment
   390 op greaterThan *tmp124 :line 176
 
   393 set :increment :next_increment
   394 op div *tmp126 :increment 2
   395 set :line *tmp126
-    * set *tmp125 :line
   396 jump *label84 always
   397 label *label83
-    * set *tmp125 null
   398 label *label84
   399 label *label38
   400 op add :lines :lines 1
 
   416 set *tmp132 .PROC_STATE_INDEX
   417 write :fn0:state .memory *tmp132
   418 jump *label88 always
-    * set *tmp131 null
   419 jump *label90 always
   420 label *label89
   421 set *tmp134 .PROC_ID_INDEX
 
   434 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
   435 set *tmp137 .PROC_STATE_INDEX
   436 label *label92
-    * set *tmp131 *tmp137
   437 label *label90
   438 label *label87
   439 jump *label86 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-8 instructions):
 
    61 op equal *tmp21 :fn1:requested @message
    62 jump *label20 equal *tmp21 false
    63 set :fn1:message :fn1:block
-    * set *tmp22 :fn1:message
    64 jump *label21 always
    65 label *label20
-    * set *tmp22 null
    66 label *label21
    67 jump *label19 always
    68 label *label18
 
   209 jump *label50 equal *tmp58 false
   210 set *tmp42 63
   211 jump *label45 always
-    * set *tmp59 null
   212 jump *label51 always
   213 label *label50
-    * set *tmp59 null
   214 label *label51
   215 label *label47
   216 set :fn2:i 0
 
   264 op equal *tmp79 :fn3:iterations 63
   265 jump *label62 equal *tmp79 false
   266 draw color 0 0 0 255
-    * set *tmp80 null
   267 jump *label63 always
   268 label *label62
   269 jump *label66 equal .PALETTE 2
 
   328 draw color :fn3:r :fn3:r 0 255
   329 set *tmp81 null
   330 label *label64
-    * set *tmp80 *tmp81
   331 label *label63
   332 jump *label61 always
   333 label *label60
 
   421 set *tmp140 .PROC_STATE_INDEX
   422 write :fn0:state .memory *tmp140
   423 jump *label88 always
-    * set *tmp137 null
   424 jump *label92 always
   425 label *label91
   426 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   427 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * set *tmp137 .PROC_STATE_INDEX
   428 label *label92
   429 label *label90
   430 label *label87

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   285 op add *tmp94 120 *tmp93
   286 set :fn3:b *tmp94
   287 draw color :fn3:r :fn3:g :fn3:b 255
-    * set *tmp81 null
   288 jump *label64 always
   289 label *label65
   290 jump *label68 equal .PALETTE 3
 
   306 op add *tmp106 100 *tmp105
   307 set :fn3:b *tmp106
   308 draw color :fn3:r :fn3:g :fn3:b 255
-    * set *tmp81 null
   309 jump *label64 always
   310 label *label67
   311 jump *label70 equal .PALETTE 4
 
   317 op add *tmp109 96 *tmp108
   318 set :fn3:g *tmp109
   319 draw color :fn3:r :fn3:g 0 255
-    * set *tmp81 null
   320 jump *label64 always
   321 label *label69
   322 op mul *tmp110 4 :fn3:iterations
   323 op sub *tmp111 255 *tmp110
   324 set :fn3:r *tmp111
   325 draw color :fn3:r :fn3:r 0 255
-    * set *tmp81 null
   326 label *label64
   327 label *label63
   328 jump *label61 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-30 instructions):
     0 sensor *tmp10 @this @x
     1 sensor *tmp11 @this @y
     2 op mul *tmp12 10000 *tmp11
-    * op add *tmp13 *tmp10 *tmp12
-    * set .PROCESSOR_ID *tmp13
+    3 op add .PROCESSOR_ID *tmp10 *tmp12
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .BATCH 0
 
    34 op greaterThan *tmp15 :fn1:n 0
    35 jump *label12 equal *tmp15 false
    36 op sub :fn1:n :fn1:n 1
-    * getlink *tmp16 :fn1:n
-    * set :fn1:block *tmp16
+   37 getlink :fn1:block :fn1:n
    38 print "\nFound: "
    39 print :fn1:block
-    * sensor *tmp17 :fn1:block @type
-    * set :fn1:type *tmp17
+   40 sensor :fn1:type :fn1:block @type
    41 setaddr *tmp18 *label16
    42 set :fn1:requested @large-logic-display
    43 set :fn1:name "Display"
 
   129 setaddr :fn0*retaddr *label36
   130 call *label0 :fn0*retval
   131 gotolabel *label36 :fn0
-    * read *tmp4 .memory 68
-    * set .ZOOM *tmp4
+  132 read .ZOOM .memory 68
   133 op div *tmp27 -88 .ZOOM
   134 read *tmp2 .memory 66
-    * op add *tmp28 *tmp27 *tmp2
-    * set .OFFSET_X *tmp28
+  135 op add .OFFSET_X *tmp27 *tmp2
   136 op div *tmp29 -88 .ZOOM
   137 read *tmp3 .memory 67
-    * op add *tmp30 *tmp29 *tmp3
-    * set .OFFSET_Y *tmp30
-    * read *tmp5 .memory 69
-    * set .JULIA *tmp5
-    * read *tmp6 .memory 70
-    * set .JULIA_X *tmp6
-    * read *tmp7 .memory 71
-    * set .JULIA_Y *tmp7
-    * read *tmp8 .memory 72
-    * set .PALETTE *tmp8
-    * op greaterThan *tmp31 .PALETTE 1
-    * set .SMOOTH *tmp31
+  138 op add .OFFSET_Y *tmp29 *tmp3
+  139 read .JULIA .memory 69
+  140 read .JULIA_X .memory 70
+  141 read .JULIA_Y .memory 71
+  142 read .PALETTE .memory 72
+  143 op greaterThan .SMOOTH .PALETTE 1
   144 set :line 8
   145 set :increment 8
   146 set :next_increment 16
 
   150 label *label37
   151 jump *label39 greaterThanEq :lines 176
   152 op mul *tmp33 17 :line
-    * op mod *tmp34 *tmp33 176
-    * set :x *tmp34
-    * op add *tmp35 :x 158
-    * set :position *tmp35
+  153 op mod :x *tmp33 176
+  154 op add :position :x 158
   155 set *tmp36 :position
   156 read *tmp37 .memory *tmp36
   157 op equal *tmp38 *tmp37 0
 
   164 set :fn2:x :x
   165 set :fn2:y :y
   166 op div *tmp43 :fn2:x .ZOOM
-    * op add *tmp44 *tmp43 .OFFSET_X
-    * set :fn2:zx *tmp44
+  167 op add :fn2:zx *tmp43 .OFFSET_X
   168 op div *tmp45 :fn2:y .ZOOM
-    * op add *tmp46 *tmp45 .OFFSET_Y
-    * set :fn2:zy *tmp46
+  169 op add :fn2:zy *tmp45 .OFFSET_Y
   170 jump *label46 equal .JULIA false
   171 set :fn2:cx .JULIA_X
   172 set :fn2:cy .JULIA_Y
 
   175 set :fn2:cx :fn2:zx
   176 set :fn2:cy :fn2:zy
   177 op sub *tmp48 :fn2:cx 0.25
-    * op len *tmp49 *tmp48 :fn2:cy
-    * set :fn2:p *tmp49
+  178 op len :fn2:p *tmp48 :fn2:cy
   179 op mul *tmp50 2 :fn2:p
   180 op mul *tmp51 *tmp50 :fn2:p
   181 op sub *tmp52 :fn2:p *tmp51
 
   205 op mul *tmp60 :fn2:x1 :fn2:x1
   206 op mul *tmp61 :fn2:y1 :fn2:y1
   207 op sub *tmp62 *tmp60 *tmp61
-    * op add *tmp63 *tmp62 :fn2:cx
-    * set :fn2:zx *tmp63
+  208 op add :fn2:zx *tmp62 :fn2:cx
   209 op mul *tmp64 2 :fn2:x1
   210 op mul *tmp65 *tmp64 :fn2:y1
-    * op add *tmp66 *tmp65 :fn2:cy
-    * set :fn2:zy *tmp66
-    * op len *tmp67 :fn2:zx :fn2:zy
-    * set :fn2:dist *tmp67
+  211 op add :fn2:zy *tmp65 :fn2:cy
+  212 op len :fn2:dist :fn2:zx :fn2:zy
   213 op greaterThanEq *tmp68 :fn2:dist 64
   214 jump *label55 equal *tmp68 false
   215 jump *label54 always
 
   227 op mul *tmp74 *tmp73 0.36067376022224085
   228 op log *tmp75 *tmp74
   229 op mul *tmp76 *tmp75 1.4426950408889634
-    * op sub *tmp77 4 *tmp76
-    * set :fn2:correction *tmp77
+  230 op sub :fn2:correction 4 *tmp76
   231 op add :fn2:i :fn2:i :fn2:correction
   232 jump *label58 always
   233 label *label57
 
   252 op sub *tmp83 32 :fn3:iterations
   253 op abs *tmp84 *tmp83
   254 op mul *tmp85 7 *tmp84
-    * op sub *tmp86 255 *tmp85
-    * set :fn3:r *tmp86
+  255 op sub :fn3:r 255 *tmp85
   256 op sub *tmp87 :fn3:iterations 32
   257 op abs *tmp88 *tmp87
   258 op mul *tmp89 6 *tmp88
-    * op sub *tmp90 240 *tmp89
-    * set :fn3:g *tmp90
+  259 op sub :fn3:g 240 *tmp89
   260 op sub *tmp91 32 :fn3:iterations
   261 op abs *tmp92 *tmp91
   262 op mul *tmp93 4 *tmp92
-    * op add *tmp94 120 *tmp93
-    * set :fn3:b *tmp94
+  263 op add :fn3:b 120 *tmp93
   264 draw color :fn3:r :fn3:g :fn3:b 255
   265 jump *label64 always
   266 label *label65
 
   270 op div *tmp95 :fn3:iterations 63
   271 op mul *tmp96 *tmp95 360
   272 op sin *tmp97 *tmp96
-    * op mul *tmp98 255 *tmp97
-    * set :fn3:r *tmp98
+  273 op mul :fn3:r 255 *tmp97
   274 op div *tmp99 :fn3:iterations 63
   275 op mul *tmp100 *tmp99 360
   276 op cos *tmp101 *tmp100
-    * op mul *tmp102 255 *tmp101
-    * set :fn3:g *tmp102
+  277 op mul :fn3:g 255 *tmp101
   278 op sub *tmp103 :fn3:iterations 32
   279 op abs *tmp104 *tmp103
   280 op mul *tmp105 4 *tmp104
-    * op add *tmp106 100 *tmp105
-    * set :fn3:b *tmp106
+  281 op add :fn3:b 100 *tmp105
   282 draw color :fn3:r :fn3:g :fn3:b 255
   283 jump *label64 always
   284 label *label67
   285 jump *label70 equal .PALETTE 4
   286 jump *label69 always
   287 label *label70
-    * op mul *tmp107 4 :fn3:iterations
-    * set :fn3:r *tmp107
+  288 op mul :fn3:r 4 :fn3:iterations
   289 op mul *tmp108 1.5 :fn3:iterations
-    * op add *tmp109 96 *tmp108
-    * set :fn3:g *tmp109
+  290 op add :fn3:g 96 *tmp108
   291 draw color :fn3:r :fn3:g 0 255
   292 jump *label64 always
   293 label *label69
   294 op mul *tmp110 4 :fn3:iterations
-    * op sub *tmp111 255 *tmp110
-    * set :fn3:r *tmp111
+  295 op sub :fn3:r 255 *tmp110
   296 draw color :fn3:r :fn3:r 0 255
   297 label *label64
   298 label *label63
 
   352 jump *label83 equal *tmp124 false
   353 op div :next_increment :next_increment 2
   354 set :increment :next_increment
-    * op div *tmp126 :increment 2
-    * set :line *tmp126
+  355 op div :line :increment 2
   356 jump *label84 always
   357 label *label83
   358 label *label84

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
   109 label *label4
   110 label *label1
   111 label *label29
-    * jump *label31 equal true false
   112 set .BATCH 0
   113 label *label32
   114 set :fn0:state 0

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   245 draw color 0 0 0 255
   246 jump *label63 always
   247 label *label62
-    * jump *label66 equal .PALETTE 2
-    * jump *label65 always
+  248 jump *label65 notEqual .PALETTE 2
   249 label *label66
   250 op sub *tmp83 32 :fn3:iterations
   251 op abs *tmp84 *tmp83
 
   262 draw color :fn3:r :fn3:g :fn3:b 255
   263 jump *label64 always
   264 label *label65
-    * jump *label68 equal .PALETTE 3
-    * jump *label67 always
+  265 jump *label67 notEqual .PALETTE 3
   266 label *label68
   267 op div *tmp95 :fn3:iterations 63
   268 op mul *tmp96 *tmp95 360
 
   279 draw color :fn3:r :fn3:g :fn3:b 255
   280 jump *label64 always
   281 label *label67
-    * jump *label70 equal .PALETTE 4
-    * jump *label69 always
+  282 jump *label69 notEqual .PALETTE 4
   283 label *label70
   284 op mul :fn3:r 4 :fn3:iterations
   285 op mul *tmp108 1.5 :fn3:iterations

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-20 instructions):
 
    31 print :fn1:title
    32 set :fn1:n @links
    33 label *label10
-    * op greaterThan *tmp15 :fn1:n 0
-    * jump *label12 equal *tmp15 false
+   34 jump *label12 lessThanEq :fn1:n 0
    35 op sub :fn1:n :fn1:n 1
    36 getlink :fn1:block :fn1:n
    37 print "\nFound: "
 
    51 set :fn1:variable .memory
    52 set :fn1:required true
    53 label *label13
-    * op equal *tmp19 :fn1:requested :fn1:type
-    * jump *label18 equal *tmp19 false
+   54 jump *label18 notEqual :fn1:requested :fn1:type
    55 set :fn1:variable :fn1:block
-    * op equal *tmp21 :fn1:requested @message
-    * jump *label20 equal *tmp21 false
+   56 jump *label20 notEqual :fn1:requested @message
    57 set :fn1:message :fn1:block
    58 jump *label21 always
    59 label *label20
 
   101 label *label24
   102 printflush :fn1:message
   103 label *label3
-    * op equal *tmp25 :fn1:foundAll false
-    * jump *label2 notEqual *tmp25 false
+  104 jump *label2 equal :fn1:foundAll false
   105 label *label4
   106 label *label1
   107 label *label29
 
   113 gotolabel *label35 :fn0
   114 label *label33
   115 read *tmp0 .memory 64
-    * op equal *tmp26 .start *tmp0
-    * jump *label32 notEqual *tmp26 false
+  116 jump *label32 equal .start *tmp0
   117 label *label34
   118 read *tmp0 .memory 64
   119 set .start *tmp0
 
   148 op add :position :x 158
   149 set *tmp36 :position
   150 read *tmp37 .memory *tmp36
-    * op equal *tmp38 *tmp37 0
-    * jump *label40 equal *tmp38 false
+  151 jump *label40 notEqual *tmp37 0
   152 set *tmp40 :position
   153 write .PROCESSOR_ID .memory *tmp40
   154 set :y 0
 
   173 op mul *tmp51 *tmp50 :fn2:p
   174 op sub *tmp52 :fn2:p *tmp51
   175 op add *tmp53 *tmp52 0.25
-    * op lessThanEq *tmp54 :fn2:cx *tmp53
-    * jump *label48 equal *tmp54 false
+  176 jump *label48 greaterThan :fn2:cx *tmp53
   177 set *tmp42 63
   178 jump *label45 always
   179 jump *label49 always
 
   181 label *label49
   182 op add *tmp56 :fn2:cx 1
   183 op len *tmp57 *tmp56 :fn2:cy
-    * op lessThanEq *tmp58 *tmp57 0.25
-    * jump *label50 equal *tmp58 false
+  184 jump *label50 greaterThan *tmp57 0.25
   185 set *tmp42 63
   186 jump *label45 always
   187 jump *label51 always
 
   201 op mul *tmp65 *tmp64 :fn2:y1
   202 op add :fn2:zy *tmp65 :fn2:cy
   203 op len :fn2:dist :fn2:zx :fn2:zy
-    * op greaterThanEq *tmp68 :fn2:dist 64
-    * jump *label55 equal *tmp68 false
+  204 jump *label55 lessThan :fn2:dist 64
   205 jump *label54 always
   206 jump *label56 always
   207 label *label55
 
   211 jump *label52 always
   212 label *label54
   213 op mul *tmp70 .SMOOTH 63
-    * op lessThan *tmp71 :fn2:i *tmp70
-    * jump *label57 equal *tmp71 false
+  214 jump *label57 greaterThanEq :fn2:i *tmp70
   215 op log *tmp73 :fn2:dist
   216 op mul *tmp74 *tmp73 0.36067376022224085
   217 op log *tmp75 *tmp74
 
   230 set :fn3:y :y
   231 set :fn3:iterations :iterations
   232 jump *label60 equal .SMOOTH false
-    * op equal *tmp79 :fn3:iterations 63
-    * jump *label62 equal *tmp79 false
+  233 jump *label62 notEqual :fn3:iterations 63
   234 draw color 0 0 0 255
   235 jump *label63 always
   236 label *label62
 
   289 label *label61
   290 draw rect :fn3:x :fn3:y 1 1
   291 op add .BATCH .BATCH 1
-    * op lessThan *tmp114 .BATCH 44
-    * jump *label71 equal *tmp114 false
+  292 jump *label71 greaterThanEq .BATCH 44
   293 jump *label59 always
   294 jump *label72 always
   295 label *label71
 
   297 label *label73
   298 label *label74
   299 read *tmp9 .memory 73
-    * op equal *tmp116 *tmp9 .PROC_ID_INDEX
-    * jump *label73 notEqual *tmp116 false
+  300 jump *label73 equal *tmp9 .PROC_ID_INDEX
   301 label *label75
   302 label *label76
   303 label *label77
   304 read *tmp9 .memory 73
-    * op notEqual *tmp117 *tmp9 .PROC_ID_INDEX
-    * jump *label76 notEqual *tmp117 false
+  305 jump *label76 notEqual *tmp9 .PROC_ID_INDEX
   306 label *label78
   307 drawflush .display
   308 set .BATCH 0
   309 label *label59
   310 set *tmp118 :position
   311 read *tmp119 .memory *tmp118
-    * op notEqual *tmp120 *tmp119 .PROCESSOR_ID
-    * jump *label79 equal *tmp120 false
+  312 jump *label79 equal *tmp119 .PROCESSOR_ID
   313 jump *label44 always
   314 jump *label80 always
   315 label *label79
   316 label *label80
   317 read *tmp1 .memory 65
-    * op notEqual *tmp122 .stop *tmp1
-    * jump *label81 equal *tmp122 false
+  318 jump *label81 equal .stop *tmp1
   319 jump *label39 always
   320 jump *label82 always
   321 label *label81
 
   328 label *label40
   329 label *label41
   330 op add :line :line :increment
-    * op greaterThan *tmp124 :line 176
-    * jump *label83 equal *tmp124 false
+  331 jump *label83 lessThanEq :line 176
   332 op div :next_increment :next_increment 2
   333 set :increment :next_increment
   334 op div :line :increment 2
 
   346 end
   347 label *label0
   348 label *label86
-    * op lessThan *tmp127 .PROC_STATE_INDEX 512
-    * jump *label88 equal *tmp127 false
+  349 jump *label88 greaterThanEq .PROC_STATE_INDEX 512
   350 set *tmp128 .PROC_ID_INDEX
   351 read *tmp129 .memory *tmp128
-    * op equal *tmp130 *tmp129 .PROCESSOR_ID
-    * jump *label89 equal *tmp130 false
+  352 jump *label89 notEqual *tmp129 .PROCESSOR_ID
   353 set *tmp132 .PROC_STATE_INDEX
   354 write :fn0:state .memory *tmp132
   355 jump *label88 always
 
   357 label *label89
   358 set *tmp134 .PROC_ID_INDEX
   359 read *tmp135 .memory *tmp134
-    * op equal *tmp136 *tmp135 0
-    * jump *label91 equal *tmp136 false
+  360 jump *label91 notEqual *tmp135 0
   361 set *tmp138 .PROC_ID_INDEX
   362 write .PROCESSOR_ID .memory *tmp138
   363 set *tmp140 .PROC_STATE_INDEX

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-12 instructions):
 
    55 set :fn1:variable :fn1:block
    56 jump *label20 notEqual :fn1:requested @message
    57 set :fn1:message :fn1:block
-    * jump *label21 always
    58 label *label20
    59 label *label21
-    * jump *label19 always
    60 label *label18
    61 label *label19
    62 label *label14
 
    89 print :fn1:variable
    90 jump *label27 equal :fn1:required false
    91 op and :fn1:foundAll :fn1:foundAll :fn1:variable
-    * jump *label28 always
    92 label *label27
    93 label *label28
    94 label *label23
 
   173 jump *label48 greaterThan :fn2:cx *tmp53
   174 set *tmp42 63
   175 jump *label45 always
-    * jump *label49 always
   176 label *label48
   177 label *label49
   178 op add *tmp56 :fn2:cx 1
 
   180 jump *label50 greaterThan *tmp57 0.25
   181 set *tmp42 63
   182 jump *label45 always
-    * jump *label51 always
   183 label *label50
   184 label *label51
   185 label *label47
 
   198 op len :fn2:dist :fn2:zx :fn2:zy
   199 jump *label55 lessThan :fn2:dist 64
   200 jump *label54 always
-    * jump *label56 always
   201 label *label55
   202 label *label56
   203 label *label53
 
   212 op mul *tmp76 *tmp75 1.4426950408889634
   213 op sub :fn2:correction 4 *tmp76
   214 op add :fn2:i :fn2:i :fn2:correction
-    * jump *label58 always
   215 label *label57
   216 label *label58
   217 set *tmp42 :fn2:i
 
   284 op add .BATCH .BATCH 1
   285 jump *label71 greaterThanEq .BATCH 44
   286 jump *label59 always
-    * jump *label72 always
   287 label *label71
   288 label *label72
   289 label *label73
 
   303 read *tmp119 .memory *tmp118
   304 jump *label79 equal *tmp119 .PROCESSOR_ID
   305 jump *label44 always
-    * jump *label80 always
   306 label *label79
   307 label *label80
   308 read *tmp1 .memory 65
   309 jump *label81 equal .stop *tmp1
   310 jump *label39 always
-    * jump *label82 always
   311 label *label81
   312 label *label82
   313 label *label43
   314 op add :y :y 1
   315 jump *label42 always
   316 label *label44
-    * jump *label41 always
   317 label *label40
   318 label *label41
   319 op add :line :line :increment
 
   321 op div :next_increment :next_increment 2
   322 set :increment :next_increment
   323 op div :line :increment 2
-    * jump *label84 always
   324 label *label83
   325 label *label84
   326 label *label38

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
-    * sensor *tmp10 @this @x
-    * sensor *tmp11 @this @y
+    0 set *tmp10 @thisx
+    1 set *tmp11 @thisy
     2 op mul *tmp12 10000 *tmp11
     3 op add .PROCESSOR_ID *tmp10 *tmp12
     4 set .PROC_ID_INDEX 334

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-16 instructions):
 
     3 op add .PROCESSOR_ID *tmp10 *tmp12
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
-    * set .BATCH 0
     6 set .start 0
     7 set :fn1:title "Mandelbrot Generator"
     8 set :fn1:message null
     9 label *label2
    10 setaddr *tmp14 *label8
-    * set :fn1:requested @large-logic-display
-    * set :fn1:name "Display"
-    * set :fn1:variable .display
-    * set :fn1:required true
    11 jump *label5 always
    12 gotolabel *label8 marker0
-    * set .display :fn1:variable
+   13 set .display null
    14 setaddr *tmp14 *label9
-    * set :fn1:requested @memory-bank
-    * set :fn1:name "Memory"
-    * set :fn1:variable .memory
-    * set :fn1:required true
    15 label *label5
    16 set :fn1:variable null
    17 label *label6
    18 goto *tmp14 marker0
    19 gotolabel *label9 marker0
-    * set .memory :fn1:variable
+   20 set .memory null
    21 label *label7
-    * print :fn1:title
+   22 print "Mandelbrot Generator"
    23 set :fn1:n @links
    24 label *label10
    25 jump *label12 lessThanEq :fn1:n 0
 
    30 sensor :fn1:type :fn1:block @type
    31 setaddr *tmp18 *label16
    32 set :fn1:requested @large-logic-display
-    * set :fn1:name "Display"
    33 set :fn1:variable .display
-    * set :fn1:required true
    34 jump *label13 always
    35 gotolabel *label16 marker1
    36 set .display :fn1:variable
    37 setaddr *tmp18 *label17
    38 set :fn1:requested @memory-bank
-    * set :fn1:name "Memory"
    39 set :fn1:variable .memory
-    * set :fn1:required true
    40 label *label13
    41 jump *label18 notEqual :fn1:requested :fn1:type
    42 set :fn1:variable :fn1:block
 
    56 label *label12
    57 set :fn1:foundAll 1
    58 setaddr *tmp23 *label25
-    * set :fn1:requested @large-logic-display
    59 set :fn1:name "Display"
    60 set :fn1:variable .display
    61 set :fn1:required true
 
    63 gotolabel *label25 marker2
    64 set .display :fn1:variable
    65 setaddr *tmp23 *label26
-    * set :fn1:requested @memory-bank
    66 set :fn1:name "Memory"
    67 set :fn1:variable .memory
    68 set :fn1:required true
 
    72 print ":"
    73 print " "
    74 print :fn1:variable
-    * jump *label27 equal :fn1:required false
+   75 jump *label27 equal true false
    76 op and :fn1:foundAll :fn1:foundAll :fn1:variable
    77 label *label27
    78 label *label28
 
   101 set .start *tmp0
   102 read *tmp1 .memory 65
   103 set .stop *tmp1
-    * set :fn0:state .start
+  104 set :fn0:state *tmp0
   105 setaddr :fn0*retaddr *label36
   106 call *label0 :fn0*retval
   107 gotolabel *label36 :fn0
 
   111 op add .OFFSET_X *tmp27 *tmp2
   112 op div *tmp29 -88 .ZOOM
   113 read *tmp3 .memory 67
-    * op add .OFFSET_Y *tmp29 *tmp3
+  114 op add .OFFSET_Y *tmp27 *tmp3
   115 read .JULIA .memory 69
   116 read .JULIA_X .memory 70
   117 read .JULIA_Y .memory 71
 
   129 op mod :x *tmp33 176
   130 op add :position :x 158
   131 set *tmp36 :position
-    * read *tmp37 .memory *tmp36
+  132 read *tmp37 .memory :position
   133 jump *label40 notEqual *tmp37 0
   134 set *tmp40 :position
-    * write .PROCESSOR_ID .memory *tmp40
+  135 write .PROCESSOR_ID .memory :position
   136 set :y 0
   137 label *label42
   138 jump *label44 greaterThanEq :y 176
   139 set :fn2:x :x
   140 set :fn2:y :y
-    * op div *tmp43 :fn2:x .ZOOM
+  141 op div *tmp43 :x .ZOOM
   142 op add :fn2:zx *tmp43 .OFFSET_X
-    * op div *tmp45 :fn2:y .ZOOM
+  143 op div *tmp45 :y .ZOOM
   144 op add :fn2:zy *tmp45 .OFFSET_Y
   145 jump *label46 equal .JULIA false
   146 set :fn2:cx .JULIA_X
 
   149 label *label46
   150 set :fn2:cx :fn2:zx
   151 set :fn2:cy :fn2:zy
-    * op sub *tmp48 :fn2:cx 0.25
-    * op len :fn2:p *tmp48 :fn2:cy
+  152 op sub *tmp48 :fn2:zx 0.25
+  153 op len :fn2:p *tmp48 :fn2:zy
   154 op mul *tmp50 2 :fn2:p
   155 op mul *tmp51 *tmp50 :fn2:p
   156 op sub *tmp52 :fn2:p *tmp51
   157 op add *tmp53 *tmp52 0.25
-    * jump *label48 greaterThan :fn2:cx *tmp53
+  158 jump *label48 greaterThan :fn2:zx *tmp53
   159 set *tmp42 63
   160 jump *label45 always
   161 label *label48
   162 label *label49
-    * op add *tmp56 :fn2:cx 1
-    * op len *tmp57 *tmp56 :fn2:cy
+  163 op add *tmp56 :fn2:zx 1
+  164 op len *tmp57 *tmp56 :fn2:zy
   165 jump *label50 greaterThan *tmp57 0.25
   166 set *tmp42 63
   167 jump *label45 always
 
   173 jump *label54 greaterThanEq :fn2:i 63
   174 set :fn2:x1 :fn2:zx
   175 set :fn2:y1 :fn2:zy
-    * op mul *tmp60 :fn2:x1 :fn2:x1
-    * op mul *tmp61 :fn2:y1 :fn2:y1
+  176 op mul *tmp60 :fn2:zx :fn2:zx
+  177 op mul *tmp61 :fn2:zy :fn2:zy
   178 op sub *tmp62 *tmp60 *tmp61
   179 op add :fn2:zx *tmp62 :fn2:cx
   180 op mul *tmp64 2 :fn2:x1
-    * op mul *tmp65 *tmp64 :fn2:y1
+  181 op mul *tmp65 *tmp64 :fn2:zy
   182 op add :fn2:zy *tmp65 :fn2:cy
   183 op len :fn2:dist :fn2:zx :fn2:zy
   184 jump *label55 lessThan :fn2:dist 64
 
   201 label *label58
   202 set *tmp42 :fn2:i
   203 jump *label45 always
-    * set *tmp42 null
   204 label *label45
   205 set :iterations *tmp42
   206 set :fn3:x :x
   207 set :fn3:y :y
-    * set :fn3:iterations :iterations
+  208 set :fn3:iterations *tmp42
   209 jump *label60 equal .SMOOTH false
-    * jump *label62 notEqual :fn3:iterations 63
+  210 jump *label62 notEqual :iterations 63
   211 draw color 0 0 0 255
   212 jump *label63 always
   213 label *label62
   214 jump *label65 notEqual .PALETTE 2
   215 label *label66
-    * op sub *tmp83 32 :fn3:iterations
+  216 op sub *tmp83 32 :iterations
   217 op abs *tmp84 *tmp83
   218 op mul *tmp85 7 *tmp84
   219 op sub :fn3:r 255 *tmp85
-    * op sub *tmp87 :fn3:iterations 32
+  220 op sub *tmp87 :iterations 32
   221 op abs *tmp88 *tmp87
   222 op mul *tmp89 6 *tmp88
   223 op sub :fn3:g 240 *tmp89
-    * op sub *tmp91 32 :fn3:iterations
-    * op abs *tmp92 *tmp91
-    * op mul *tmp93 4 *tmp92
+  224 op sub *tmp91 32 :iterations
+  225 op abs *tmp92 *tmp83
+  226 op mul *tmp93 4 *tmp84
   227 op add :fn3:b 120 *tmp93
   228 draw color :fn3:r :fn3:g :fn3:b 255
   229 jump *label64 always
   230 label *label65
   231 jump *label67 notEqual .PALETTE 3
   232 label *label68
-    * op div *tmp95 :fn3:iterations 63
-    * op mul *tmp96 *tmp95 360
+  233 op div *tmp95 :iterations 63
+  234 op div *tmp96 :fn3:iterations 0.175
   235 op sin *tmp97 *tmp96
   236 op mul :fn3:r 255 *tmp97
-    * op div *tmp99 :fn3:iterations 63
-    * op mul *tmp100 *tmp99 360
-    * op cos *tmp101 *tmp100
+  237 op div *tmp99 :iterations 63
+  238 op mul *tmp100 *tmp95 360
+  239 op cos *tmp101 *tmp96
   240 op mul :fn3:g 255 *tmp101
-    * op sub *tmp103 :fn3:iterations 32
+  241 op sub *tmp103 :iterations 32
   242 op abs *tmp104 *tmp103
   243 op mul *tmp105 4 *tmp104
   244 op add :fn3:b 100 *tmp105
 
   247 label *label67
   248 jump *label69 notEqual .PALETTE 4
   249 label *label70
-    * op mul :fn3:r 4 :fn3:iterations
-    * op mul *tmp108 1.5 :fn3:iterations
+  250 op mul :fn3:r 4 :iterations
+  251 op mul *tmp108 1.5 :iterations
   252 op add :fn3:g 96 *tmp108
   253 draw color :fn3:r :fn3:g 0 255
   254 jump *label64 always
   255 label *label69
-    * op mul *tmp110 4 :fn3:iterations
+  256 op mul *tmp110 4 :iterations
   257 op sub :fn3:r 255 *tmp110
   258 draw color :fn3:r :fn3:r 0 255
   259 label *label64
   260 label *label63
   261 jump *label61 always
   262 label *label60
-    * set *tmp112 :fn3:iterations
-    * read *tmp113 .memory *tmp112
+  263 set *tmp112 :iterations
+  264 read *tmp113 .memory :fn3:iterations
   265 draw col *tmp113
   266 label *label61
-    * draw rect :fn3:x :fn3:y 1 1
+  267 draw rect :x :y 1 1
   268 op add .BATCH .BATCH 1
   269 jump *label71 greaterThanEq .BATCH 44
   270 jump *label59 always
 
   284 set .BATCH 0
   285 label *label59
   286 set *tmp118 :position
-    * read *tmp119 .memory *tmp118
+  287 read *tmp119 .memory :position
   288 jump *label79 equal *tmp119 .PROCESSOR_ID
   289 jump *label44 always
   290 label *label79
 
   304 jump *label83 lessThanEq :line 176
   305 op div :next_increment :next_increment 2
   306 set :increment :next_increment
-    * op div :line :increment 2
+  307 op div :line :next_increment 2
   308 label *label83
   309 label *label84
   310 label *label38
 
   320 label *label86
   321 jump *label88 greaterThanEq .PROC_STATE_INDEX 512
   322 set *tmp128 .PROC_ID_INDEX
-    * read *tmp129 .memory *tmp128
+  323 read *tmp129 .memory .PROC_ID_INDEX
   324 jump *label89 notEqual *tmp129 .PROCESSOR_ID
   325 set *tmp132 .PROC_STATE_INDEX
-    * write :fn0:state .memory *tmp132
+  326 write :fn0:state .memory .PROC_STATE_INDEX
   327 jump *label88 always
   328 jump *label90 always
   329 label *label89
   330 set *tmp134 .PROC_ID_INDEX
-    * read *tmp135 .memory *tmp134
+  331 read *tmp135 .memory .PROC_ID_INDEX
   332 jump *label91 notEqual *tmp135 0
   333 set *tmp138 .PROC_ID_INDEX
-    * write .PROCESSOR_ID .memory *tmp138
+  334 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   335 set *tmp140 .PROC_STATE_INDEX
-    * write :fn0:state .memory *tmp140
+  336 write :fn0:state .memory .PROC_STATE_INDEX
   337 jump *label88 always
   338 jump *label92 always
   339 label *label91

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-19 instructions):
 
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
-    * set :fn1:title "Mandelbrot Generator"
     7 set :fn1:message null
     8 label *label2
     9 setaddr *tmp14 *label8
 
    12 set .display null
    13 setaddr *tmp14 *label9
    14 label *label5
-    * set :fn1:variable null
    15 label *label6
    16 goto *tmp14 marker0
    17 gotolabel *label9 marker0
 
    56 setaddr *tmp23 *label25
    57 set :fn1:name "Display"
    58 set :fn1:variable .display
-    * set :fn1:required true
    59 jump *label22 always
    60 gotolabel *label25 marker2
    61 set .display :fn1:variable
    62 setaddr *tmp23 *label26
    63 set :fn1:name "Memory"
    64 set :fn1:variable .memory
-    * set :fn1:required true
    65 label *label22
    66 print "\n"
    67 print :fn1:name
 
   105 op div *tmp27 -88 .ZOOM
   106 read *tmp2 .memory 66
   107 op add .OFFSET_X *tmp27 *tmp2
-    * op div *tmp29 -88 .ZOOM
   108 read *tmp3 .memory 67
   109 op add .OFFSET_Y *tmp27 *tmp3
   110 read .JULIA .memory 69
 
   123 op mul *tmp33 17 :line
   124 op mod :x *tmp33 176
   125 op add :position :x 158
-    * set *tmp36 :position
   126 read *tmp37 .memory :position
   127 jump *label40 notEqual *tmp37 0
-    * set *tmp40 :position
   128 write .PROCESSOR_ID .memory :position
   129 set :y 0
   130 label *label42
   131 jump *label44 greaterThanEq :y 176
-    * set :fn2:x :x
-    * set :fn2:y :y
   132 op div *tmp43 :x .ZOOM
   133 op add :fn2:zx *tmp43 .OFFSET_X
   134 op div *tmp45 :y .ZOOM
 
   163 label *label52
   164 jump *label54 greaterThanEq :fn2:i 63
   165 set :fn2:x1 :fn2:zx
-    * set :fn2:y1 :fn2:zy
   166 op mul *tmp60 :fn2:zx :fn2:zx
   167 op mul *tmp61 :fn2:zy :fn2:zy
   168 op sub *tmp62 *tmp60 *tmp61
 
   193 jump *label45 always
   194 label *label45
   195 set :iterations *tmp42
-    * set :fn3:x :x
-    * set :fn3:y :y
   196 set :fn3:iterations *tmp42
   197 jump *label60 equal .SMOOTH false
-    * jump *label62 notEqual :iterations 63
+  198 jump *label62 notEqual *tmp42 63
   199 draw color 0 0 0 255
   200 jump *label63 always
   201 label *label62
   202 jump *label65 notEqual .PALETTE 2
   203 label *label66
-    * op sub *tmp83 32 :iterations
+  204 op sub *tmp83 32 *tmp42
   205 op abs *tmp84 *tmp83
   206 op mul *tmp85 7 *tmp84
   207 op sub :fn3:r 255 *tmp85
-    * op sub *tmp87 :iterations 32
+  208 op sub *tmp87 *tmp42 32
   209 op abs *tmp88 *tmp87
   210 op mul *tmp89 6 *tmp88
   211 op sub :fn3:g 240 *tmp89
-    * op sub *tmp91 32 :iterations
-    * op abs *tmp92 *tmp83
+  212 op sub *tmp91 32 *tmp42
   213 op mul *tmp93 4 *tmp84
   214 op add :fn3:b 120 *tmp93
   215 draw color :fn3:r :fn3:g :fn3:b 255
 
   217 label *label65
   218 jump *label67 notEqual .PALETTE 3
   219 label *label68
-    * op div *tmp95 :iterations 63
-    * op div *tmp96 :fn3:iterations 0.175
+  220 op div *tmp95 *tmp42 63
+  221 op div *tmp96 *tmp42 0.175
   222 op sin *tmp97 *tmp96
   223 op mul :fn3:r 255 *tmp97
-    * op div *tmp99 :iterations 63
-    * op mul *tmp100 *tmp95 360
+  224 op div *tmp99 *tmp42 63
+  225 op div *tmp100 :iterations 0.175
   226 op cos *tmp101 *tmp96
   227 op mul :fn3:g 255 *tmp101
-    * op sub *tmp103 :iterations 32
+  228 op sub *tmp103 *tmp42 32
   229 op abs *tmp104 *tmp103
   230 op mul *tmp105 4 *tmp104
   231 op add :fn3:b 100 *tmp105
 
   234 label *label67
   235 jump *label69 notEqual .PALETTE 4
   236 label *label70
-    * op mul :fn3:r 4 :iterations
-    * op mul *tmp108 1.5 :iterations
+  237 op mul :fn3:r 4 *tmp42
+  238 op mul *tmp108 1.5 *tmp42
   239 op add :fn3:g 96 *tmp108
   240 draw color :fn3:r :fn3:g 0 255
   241 jump *label64 always
   242 label *label69
-    * op mul *tmp110 4 :iterations
+  243 op mul *tmp110 4 *tmp42
   244 op sub :fn3:r 255 *tmp110
   245 draw color :fn3:r :fn3:r 0 255
   246 label *label64
   247 label *label63
   248 jump *label61 always
   249 label *label60
-    * set *tmp112 :iterations
-    * read *tmp113 .memory :fn3:iterations
+  250 set *tmp112 *tmp42
+  251 read *tmp113 .memory *tmp42
   252 draw col *tmp113
   253 label *label61
   254 draw rect :x :y 1 1
 
   270 drawflush .display
   271 set .BATCH 0
   272 label *label59
-    * set *tmp118 :position
   273 read *tmp119 .memory :position
   274 jump *label79 equal *tmp119 .PROCESSOR_ID
   275 jump *label44 always
 
   305 label *label0
   306 label *label86
   307 jump *label88 greaterThanEq .PROC_STATE_INDEX 512
-    * set *tmp128 .PROC_ID_INDEX
   308 read *tmp129 .memory .PROC_ID_INDEX
   309 jump *label89 notEqual *tmp129 .PROCESSOR_ID
-    * set *tmp132 .PROC_STATE_INDEX
   310 write :fn0:state .memory .PROC_STATE_INDEX
   311 jump *label88 always
   312 jump *label90 always
   313 label *label89
-    * set *tmp134 .PROC_ID_INDEX
   314 read *tmp135 .memory .PROC_ID_INDEX
   315 jump *label91 notEqual *tmp135 0
-    * set *tmp138 .PROC_ID_INDEX
   316 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * set *tmp140 .PROC_STATE_INDEX
   317 write :fn0:state .memory .PROC_STATE_INDEX
   318 jump *label88 always
   319 jump *label92 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-5 instructions):
 
   193 jump *label45 always
   194 label *label45
   195 set :iterations *tmp42
-    * set :fn3:iterations *tmp42
   196 jump *label60 equal .SMOOTH false
   197 jump *label62 notEqual *tmp42 63
   198 draw color 0 0 0 255
 
   208 op abs *tmp88 *tmp87
   209 op mul *tmp89 6 *tmp88
   210 op sub :fn3:g 240 *tmp89
-    * op sub *tmp91 32 *tmp42
   211 op mul *tmp93 4 *tmp84
   212 op add :fn3:b 120 *tmp93
   213 draw color :fn3:r :fn3:g :fn3:b 255
 
   215 label *label65
   216 jump *label67 notEqual .PALETTE 3
   217 label *label68
-    * op div *tmp95 *tmp42 63
   218 op div *tmp96 *tmp42 0.175
   219 op sin *tmp97 *tmp96
   220 op mul :fn3:r 255 *tmp97
-    * op div *tmp99 *tmp42 63
-    * op div *tmp100 :iterations 0.175
+  221 op div *tmp100 *tmp42 0.175
   222 op cos *tmp101 *tmp96
   223 op mul :fn3:g 255 *tmp101
   224 op sub *tmp103 *tmp42 32
 
   243 label *label63
   244 jump *label61 always
   245 label *label60
-    * set *tmp112 *tmp42
   246 read *tmp113 .memory *tmp42
   247 draw col *tmp113
   248 label *label61

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   192 set *tmp42 :fn2:i
   193 jump *label45 always
   194 label *label45
-    * set :iterations *tmp42
   195 jump *label60 equal .SMOOTH false
   196 jump *label62 notEqual *tmp42 63
   197 draw color 0 0 0 255
 
   217 op div *tmp96 *tmp42 0.175
   218 op sin *tmp97 *tmp96
   219 op mul :fn3:r 255 *tmp97
-    * op div *tmp100 *tmp42 0.175
   220 op cos *tmp101 *tmp96
   221 op mul :fn3:g 255 *tmp101
   222 op sub *tmp103 *tmp42 32

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-3 instructions):
 
    21 set :fn1:n @links
    22 label *label10
    23 jump *label12 lessThanEq :fn1:n 0
+   24 label *label93
    25 op sub :fn1:n :fn1:n 1
    26 getlink :fn1:block :fn1:n
    27 print "\nFound: "
 
    51 set .memory :fn1:variable
    52 label *label15
    53 label *label11
-    * jump *label10 always
+   54 jump *label93 greaterThan :fn1:n 0
    55 label *label12
    56 set :fn1:foundAll 1
    57 setaddr *tmp23 *label25
 
   120 wait *tmp32
   121 set :lines 0
   122 label *label37
-    * jump *label39 greaterThanEq :lines 176
+  123 label *label94
   124 op mul *tmp33 17 :line
   125 op mod :x *tmp33 176
   126 op add :position :x 158
 
   129 write .PROCESSOR_ID .memory :position
   130 set :y 0
   131 label *label42
-    * jump *label44 greaterThanEq :y 176
+  132 label *label95
   133 op div *tmp43 :x .ZOOM
   134 op add :fn2:zx *tmp43 .OFFSET_X
   135 op div *tmp45 :y .ZOOM
 
   162 label *label47
   163 set :fn2:i 0
   164 label *label52
-    * jump *label54 greaterThanEq :fn2:i 63
+  165 label *label96
   166 set :fn2:x1 :fn2:zx
   167 op mul *tmp60 :fn2:zx :fn2:zx
   168 op mul *tmp61 :fn2:zy :fn2:zy
 
   178 label *label56
   179 label *label53
   180 op add :fn2:i :fn2:i 1
-    * jump *label52 always
+  181 jump *label96 lessThan :fn2:i 63
   182 label *label54
   183 op mul *tmp70 .SMOOTH 63
   184 jump *label57 greaterThanEq :fn2:i *tmp70
 
   276 label *label82
   277 label *label43
   278 op add :y :y 1
-    * jump *label42 always
+  279 jump *label95 lessThan :y 176
   280 label *label44
   281 label *label40
   282 label *label41
 
   289 label *label84
   290 label *label38
   291 op add :lines :lines 1
-    * jump *label37 always
+  292 jump *label94 lessThan :lines 176
   293 label *label39
   294 drawflush .display
   295 label *label30
 
   299 label *label0
   300 label *label86
   301 jump *label88 greaterThanEq .PROC_STATE_INDEX 512
+  302 label *label97
   303 read *tmp129 .memory .PROC_ID_INDEX
   304 jump *label89 notEqual *tmp129 .PROCESSOR_ID
   305 write :fn0:state .memory .PROC_STATE_INDEX
 
   318 label *label92
   319 label *label90
   320 label *label87
-    * jump *label86 always
+  321 jump *label97 lessThan .PROC_STATE_INDEX 512
   322 label *label88
   323 label *label85
   324 goto :fn0*retaddr :fn0

Modifications by Unroll iteration loop at *blocks:57:9 (-4 instructions):
 
     6 set .start 0
     7 set :fn1:message null
     8 label *label2
-    * setaddr *tmp14 *label8
-    * jump *label5 always
-    * gotolabel *label8 marker0
-    * set .display null
-    * setaddr *tmp14 *label9
-    * label *label5
-    * label *label6
-    * goto *tmp14 marker0
-    * gotolabel *label9 marker0
-    * set .memory null
-    * label *label7
+    9 label *label98
+   10 label *label99
+   11 set .display null
+   12 label *label102
+   13 label *label103
+   14 set .memory null
+   15 label *label7
    16 print "Mandelbrot Generator"
    17 set :fn1:n @links
    18 label *label10

Modifications by Unroll loop at mandelbrot-compute.mnd:136:5 (+743 instructions):
 
   156 label *label50
   157 label *label51
   158 label *label47
-    * set :fn2:i 0
-    * label *label52
-    * label *label96
-    * set :fn2:x1 :fn2:zx
-    * op mul *tmp60 :fn2:zx :fn2:zx
-    * op mul *tmp61 :fn2:zy :fn2:zy
-    * op sub *tmp62 *tmp60 *tmp61
-    * op add :fn2:zx *tmp62 :fn2:cx
-    * op mul *tmp64 2 :fn2:x1
-    * op mul *tmp65 *tmp64 :fn2:zy
-    * op add :fn2:zy *tmp65 :fn2:cy
-    * op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label55 lessThan :fn2:dist 64
-    * jump *label54 always
-    * label *label55
-    * label *label56
-    * label *label53
-    * op add :fn2:i :fn2:i 1
-    * jump *label96 lessThan :fn2:i 63
-    * label *label54
+  159 set :fn2:i 0
+  160 label *label107
+  161 label *label108
+  162 set :fn2:x1 :fn2:zx
+  163 op mul *tmp60 :fn2:zx :fn2:zx
+  164 op mul *tmp61 :fn2:zy :fn2:zy
+  165 op sub *tmp62 *tmp60 *tmp61
+  166 op add :fn2:zx *tmp62 :fn2:cx
+  167 op mul *tmp64 2 :fn2:x1
+  168 op mul *tmp65 *tmp64 :fn2:zy
+  169 op add :fn2:zy *tmp65 :fn2:cy
+  170 op len :fn2:dist :fn2:zx :fn2:zy
+  171 jump *label109 lessThan :fn2:dist 64
+  172 jump *label54 always
+  173 label *label109
+  174 label *label110
+  175 label *label111
+  176 op add :fn2:i :fn2:i 1
+  177 label *label112
+  178 set :fn2:x1 :fn2:zx
+  179 op mul *tmp60 :fn2:zx :fn2:zx
+  180 op mul *tmp61 :fn2:zy :fn2:zy
+  181 op sub *tmp62 *tmp60 *tmp61
+  182 op add :fn2:zx *tmp62 :fn2:cx
+  183 op mul *tmp64 2 :fn2:x1
+  184 op mul *tmp65 *tmp64 :fn2:zy
+  185 op add :fn2:zy *tmp65 :fn2:cy
+  186 op len :fn2:dist :fn2:zx :fn2:zy
+  187 jump *label113 lessThan :fn2:dist 64
+  188 jump *label54 always
+  189 label *label113
+  190 label *label114
+  191 label *label115
+  192 op add :fn2:i :fn2:i 1
+  193 label *label116
+  194 set :fn2:x1 :fn2:zx
+  195 op mul *tmp60 :fn2:zx :fn2:zx
+  196 op mul *tmp61 :fn2:zy :fn2:zy
+  197 op sub *tmp62 *tmp60 *tmp61
+  198 op add :fn2:zx *tmp62 :fn2:cx
+  199 op mul *tmp64 2 :fn2:x1
+  200 op mul *tmp65 *tmp64 :fn2:zy
+  201 op add :fn2:zy *tmp65 :fn2:cy
+  202 op len :fn2:dist :fn2:zx :fn2:zy
+  203 jump *label117 lessThan :fn2:dist 64
+  204 jump *label54 always
+  205 label *label117
+  206 label *label118
+  207 label *label119
+  208 op add :fn2:i :fn2:i 1
+  209 label *label120
+  210 set :fn2:x1 :fn2:zx
+  211 op mul *tmp60 :fn2:zx :fn2:zx
+  212 op mul *tmp61 :fn2:zy :fn2:zy
+  213 op sub *tmp62 *tmp60 *tmp61
+  214 op add :fn2:zx *tmp62 :fn2:cx
+  215 op mul *tmp64 2 :fn2:x1
+  216 op mul *tmp65 *tmp64 :fn2:zy
+  217 op add :fn2:zy *tmp65 :fn2:cy
+  218 op len :fn2:dist :fn2:zx :fn2:zy
+  219 jump *label121 lessThan :fn2:dist 64
+  220 jump *label54 always
+  221 label *label121
+  222 label *label122
+  223 label *label123
+  224 op add :fn2:i :fn2:i 1
+  225 label *label124
+  226 set :fn2:x1 :fn2:zx
+  227 op mul *tmp60 :fn2:zx :fn2:zx
+  228 op mul *tmp61 :fn2:zy :fn2:zy
+  229 op sub *tmp62 *tmp60 *tmp61
+  230 op add :fn2:zx *tmp62 :fn2:cx
+  231 op mul *tmp64 2 :fn2:x1
+  232 op mul *tmp65 *tmp64 :fn2:zy
+  233 op add :fn2:zy *tmp65 :fn2:cy
+  234 op len :fn2:dist :fn2:zx :fn2:zy
+  235 jump *label125 lessThan :fn2:dist 64
+  236 jump *label54 always
+  237 label *label125
+  238 label *label126
+  239 label *label127
+  240 op add :fn2:i :fn2:i 1
+  241 label *label128
+  242 set :fn2:x1 :fn2:zx
+  243 op mul *tmp60 :fn2:zx :fn2:zx
+  244 op mul *tmp61 :fn2:zy :fn2:zy
+  245 op sub *tmp62 *tmp60 *tmp61
+  246 op add :fn2:zx *tmp62 :fn2:cx
+  247 op mul *tmp64 2 :fn2:x1
+  248 op mul *tmp65 *tmp64 :fn2:zy
+  249 op add :fn2:zy *tmp65 :fn2:cy
+  250 op len :fn2:dist :fn2:zx :fn2:zy
+  251 jump *label129 lessThan :fn2:dist 64
+  252 jump *label54 always
+  253 label *label129
+  254 label *label130
+  255 label *label131
+  256 op add :fn2:i :fn2:i 1
+  257 label *label132
+  258 set :fn2:x1 :fn2:zx
+  259 op mul *tmp60 :fn2:zx :fn2:zx
+  260 op mul *tmp61 :fn2:zy :fn2:zy
+  261 op sub *tmp62 *tmp60 *tmp61
+  262 op add :fn2:zx *tmp62 :fn2:cx
+  263 op mul *tmp64 2 :fn2:x1
+  264 op mul *tmp65 *tmp64 :fn2:zy
+  265 op add :fn2:zy *tmp65 :fn2:cy
+  266 op len :fn2:dist :fn2:zx :fn2:zy
+  267 jump *label133 lessThan :fn2:dist 64
+  268 jump *label54 always
+  269 label *label133
+  270 label *label134
+  271 label *label135
+  272 op add :fn2:i :fn2:i 1
+  273 label *label136
+  274 set :fn2:x1 :fn2:zx
+  275 op mul *tmp60 :fn2:zx :fn2:zx
+  276 op mul *tmp61 :fn2:zy :fn2:zy
+  277 op sub *tmp62 *tmp60 *tmp61
+  278 op add :fn2:zx *tmp62 :fn2:cx
+  279 op mul *tmp64 2 :fn2:x1
+  280 op mul *tmp65 *tmp64 :fn2:zy
+  281 op add :fn2:zy *tmp65 :fn2:cy
+  282 op len :fn2:dist :fn2:zx :fn2:zy
+  283 jump *label137 lessThan :fn2:dist 64
+  284 jump *label54 always
+  285 label *label137
+  286 label *label138
+  287 label *label139
+  288 op add :fn2:i :fn2:i 1
+  289 label *label140
+  290 set :fn2:x1 :fn2:zx
+  291 op mul *tmp60 :fn2:zx :fn2:zx
+  292 op mul *tmp61 :fn2:zy :fn2:zy
+  293 op sub *tmp62 *tmp60 *tmp61
+  294 op add :fn2:zx *tmp62 :fn2:cx
+  295 op mul *tmp64 2 :fn2:x1
+  296 op mul *tmp65 *tmp64 :fn2:zy
+  297 op add :fn2:zy *tmp65 :fn2:cy
+  298 op len :fn2:dist :fn2:zx :fn2:zy
+  299 jump *label141 lessThan :fn2:dist 64
+  300 jump *label54 always
+  301 label *label141
+  302 label *label142
+  303 label *label143
+  304 op add :fn2:i :fn2:i 1
+  305 label *label144
+  306 set :fn2:x1 :fn2:zx
+  307 op mul *tmp60 :fn2:zx :fn2:zx
+  308 op mul *tmp61 :fn2:zy :fn2:zy
+  309 op sub *tmp62 *tmp60 *tmp61
+  310 op add :fn2:zx *tmp62 :fn2:cx
+  311 op mul *tmp64 2 :fn2:x1
+  312 op mul *tmp65 *tmp64 :fn2:zy
+  313 op add :fn2:zy *tmp65 :fn2:cy
+  314 op len :fn2:dist :fn2:zx :fn2:zy
+  315 jump *label145 lessThan :fn2:dist 64
+  316 jump *label54 always
+  317 label *label145
+  318 label *label146
+  319 label *label147
+  320 op add :fn2:i :fn2:i 1
+  321 label *label148
+  322 set :fn2:x1 :fn2:zx
+  323 op mul *tmp60 :fn2:zx :fn2:zx
+  324 op mul *tmp61 :fn2:zy :fn2:zy
+  325 op sub *tmp62 *tmp60 *tmp61
+  326 op add :fn2:zx *tmp62 :fn2:cx
+  327 op mul *tmp64 2 :fn2:x1
+  328 op mul *tmp65 *tmp64 :fn2:zy
+  329 op add :fn2:zy *tmp65 :fn2:cy
+  330 op len :fn2:dist :fn2:zx :fn2:zy
+  331 jump *label149 lessThan :fn2:dist 64
+  332 jump *label54 always
+  333 label *label149
+  334 label *label150
+  335 label *label151
+  336 op add :fn2:i :fn2:i 1
+  337 label *label152
+  338 set :fn2:x1 :fn2:zx
+  339 op mul *tmp60 :fn2:zx :fn2:zx
+  340 op mul *tmp61 :fn2:zy :fn2:zy
+  341 op sub *tmp62 *tmp60 *tmp61
+  342 op add :fn2:zx *tmp62 :fn2:cx
+  343 op mul *tmp64 2 :fn2:x1
+  344 op mul *tmp65 *tmp64 :fn2:zy
+  345 op add :fn2:zy *tmp65 :fn2:cy
+  346 op len :fn2:dist :fn2:zx :fn2:zy
+  347 jump *label153 lessThan :fn2:dist 64
+  348 jump *label54 always
+  349 label *label153
+  350 label *label154
+  351 label *label155
+  352 op add :fn2:i :fn2:i 1
+  353 label *label156
+  354 set :fn2:x1 :fn2:zx
+  355 op mul *tmp60 :fn2:zx :fn2:zx
+  356 op mul *tmp61 :fn2:zy :fn2:zy
+  357 op sub *tmp62 *tmp60 *tmp61
+  358 op add :fn2:zx *tmp62 :fn2:cx
+  359 op mul *tmp64 2 :fn2:x1
+  360 op mul *tmp65 *tmp64 :fn2:zy
+  361 op add :fn2:zy *tmp65 :fn2:cy
+  362 op len :fn2:dist :fn2:zx :fn2:zy
+  363 jump *label157 lessThan :fn2:dist 64
+  364 jump *label54 always
+  365 label *label157
+  366 label *label158
+  367 label *label159
+  368 op add :fn2:i :fn2:i 1
+  369 label *label160
+  370 set :fn2:x1 :fn2:zx
+  371 op mul *tmp60 :fn2:zx :fn2:zx
+  372 op mul *tmp61 :fn2:zy :fn2:zy
+  373 op sub *tmp62 *tmp60 *tmp61
+  374 op add :fn2:zx *tmp62 :fn2:cx
+  375 op mul *tmp64 2 :fn2:x1
+  376 op mul *tmp65 *tmp64 :fn2:zy
+  377 op add :fn2:zy *tmp65 :fn2:cy
+  378 op len :fn2:dist :fn2:zx :fn2:zy
+  379 jump *label161 lessThan :fn2:dist 64
+  380 jump *label54 always
+  381 label *label161
+  382 label *label162
+  383 label *label163
+  384 op add :fn2:i :fn2:i 1
+  385 label *label164
+  386 set :fn2:x1 :fn2:zx
+  387 op mul *tmp60 :fn2:zx :fn2:zx
+  388 op mul *tmp61 :fn2:zy :fn2:zy
+  389 op sub *tmp62 *tmp60 *tmp61
+  390 op add :fn2:zx *tmp62 :fn2:cx
+  391 op mul *tmp64 2 :fn2:x1
+  392 op mul *tmp65 *tmp64 :fn2:zy
+  393 op add :fn2:zy *tmp65 :fn2:cy
+  394 op len :fn2:dist :fn2:zx :fn2:zy
+  395 jump *label165 lessThan :fn2:dist 64
+  396 jump *label54 always
+  397 label *label165
+  398 label *label166
+  399 label *label167
+  400 op add :fn2:i :fn2:i 1
+  401 label *label168
+  402 set :fn2:x1 :fn2:zx
+  403 op mul *tmp60 :fn2:zx :fn2:zx
+  404 op mul *tmp61 :fn2:zy :fn2:zy
+  405 op sub *tmp62 *tmp60 *tmp61
+  406 op add :fn2:zx *tmp62 :fn2:cx
+  407 op mul *tmp64 2 :fn2:x1
+  408 op mul *tmp65 *tmp64 :fn2:zy
+  409 op add :fn2:zy *tmp65 :fn2:cy
+  410 op len :fn2:dist :fn2:zx :fn2:zy
+  411 jump *label169 lessThan :fn2:dist 64
+  412 jump *label54 always
+  413 label *label169
+  414 label *label170
+  415 label *label171
+  416 op add :fn2:i :fn2:i 1
+  417 label *label172
+  418 set :fn2:x1 :fn2:zx
+  419 op mul *tmp60 :fn2:zx :fn2:zx
+  420 op mul *tmp61 :fn2:zy :fn2:zy
+  421 op sub *tmp62 *tmp60 *tmp61
+  422 op add :fn2:zx *tmp62 :fn2:cx
+  423 op mul *tmp64 2 :fn2:x1
+  424 op mul *tmp65 *tmp64 :fn2:zy
+  425 op add :fn2:zy *tmp65 :fn2:cy
+  426 op len :fn2:dist :fn2:zx :fn2:zy
+  427 jump *label173 lessThan :fn2:dist 64
+  428 jump *label54 always
+  429 label *label173
+  430 label *label174
+  431 label *label175
+  432 op add :fn2:i :fn2:i 1
+  433 label *label176
+  434 set :fn2:x1 :fn2:zx
+  435 op mul *tmp60 :fn2:zx :fn2:zx
+  436 op mul *tmp61 :fn2:zy :fn2:zy
+  437 op sub *tmp62 *tmp60 *tmp61
+  438 op add :fn2:zx *tmp62 :fn2:cx
+  439 op mul *tmp64 2 :fn2:x1
+  440 op mul *tmp65 *tmp64 :fn2:zy
+  441 op add :fn2:zy *tmp65 :fn2:cy
+  442 op len :fn2:dist :fn2:zx :fn2:zy
+  443 jump *label177 lessThan :fn2:dist 64
+  444 jump *label54 always
+  445 label *label177
+  446 label *label178
+  447 label *label179
+  448 op add :fn2:i :fn2:i 1
+  449 label *label180
+  450 set :fn2:x1 :fn2:zx
+  451 op mul *tmp60 :fn2:zx :fn2:zx
+  452 op mul *tmp61 :fn2:zy :fn2:zy
+  453 op sub *tmp62 *tmp60 *tmp61
+  454 op add :fn2:zx *tmp62 :fn2:cx
+  455 op mul *tmp64 2 :fn2:x1
+  456 op mul *tmp65 *tmp64 :fn2:zy
+  457 op add :fn2:zy *tmp65 :fn2:cy
+  458 op len :fn2:dist :fn2:zx :fn2:zy
+  459 jump *label181 lessThan :fn2:dist 64
+  460 jump *label54 always
+  461 label *label181
+  462 label *label182
+  463 label *label183
+  464 op add :fn2:i :fn2:i 1
+  465 label *label184
+  466 set :fn2:x1 :fn2:zx
+  467 op mul *tmp60 :fn2:zx :fn2:zx
+  468 op mul *tmp61 :fn2:zy :fn2:zy
+  469 op sub *tmp62 *tmp60 *tmp61
+  470 op add :fn2:zx *tmp62 :fn2:cx
+  471 op mul *tmp64 2 :fn2:x1
+  472 op mul *tmp65 *tmp64 :fn2:zy
+  473 op add :fn2:zy *tmp65 :fn2:cy
+  474 op len :fn2:dist :fn2:zx :fn2:zy
+  475 jump *label185 lessThan :fn2:dist 64
+  476 jump *label54 always
+  477 label *label185
+  478 label *label186
+  479 label *label187
+  480 op add :fn2:i :fn2:i 1
+  481 label *label188
+  482 set :fn2:x1 :fn2:zx
+  483 op mul *tmp60 :fn2:zx :fn2:zx
+  484 op mul *tmp61 :fn2:zy :fn2:zy
+  485 op sub *tmp62 *tmp60 *tmp61
+  486 op add :fn2:zx *tmp62 :fn2:cx
+  487 op mul *tmp64 2 :fn2:x1
+  488 op mul *tmp65 *tmp64 :fn2:zy
+  489 op add :fn2:zy *tmp65 :fn2:cy
+  490 op len :fn2:dist :fn2:zx :fn2:zy
+  491 jump *label189 lessThan :fn2:dist 64
+  492 jump *label54 always
+  493 label *label189
+  494 label *label190
+  495 label *label191
+  496 op add :fn2:i :fn2:i 1
+  497 label *label192
+  498 set :fn2:x1 :fn2:zx
+  499 op mul *tmp60 :fn2:zx :fn2:zx
+  500 op mul *tmp61 :fn2:zy :fn2:zy
+  501 op sub *tmp62 *tmp60 *tmp61
+  502 op add :fn2:zx *tmp62 :fn2:cx
+  503 op mul *tmp64 2 :fn2:x1
+  504 op mul *tmp65 *tmp64 :fn2:zy
+  505 op add :fn2:zy *tmp65 :fn2:cy
+  506 op len :fn2:dist :fn2:zx :fn2:zy
+  507 jump *label193 lessThan :fn2:dist 64
+  508 jump *label54 always
+  509 label *label193
+  510 label *label194
+  511 label *label195
+  512 op add :fn2:i :fn2:i 1
+  513 label *label196
+  514 set :fn2:x1 :fn2:zx
+  515 op mul *tmp60 :fn2:zx :fn2:zx
+  516 op mul *tmp61 :fn2:zy :fn2:zy
+  517 op sub *tmp62 *tmp60 *tmp61
+  518 op add :fn2:zx *tmp62 :fn2:cx
+  519 op mul *tmp64 2 :fn2:x1
+  520 op mul *tmp65 *tmp64 :fn2:zy
+  521 op add :fn2:zy *tmp65 :fn2:cy
+  522 op len :fn2:dist :fn2:zx :fn2:zy
+  523 jump *label197 lessThan :fn2:dist 64
+  524 jump *label54 always
+  525 label *label197
+  526 label *label198
+  527 label *label199
+  528 op add :fn2:i :fn2:i 1
+  529 label *label200
+  530 set :fn2:x1 :fn2:zx
+  531 op mul *tmp60 :fn2:zx :fn2:zx
+  532 op mul *tmp61 :fn2:zy :fn2:zy
+  533 op sub *tmp62 *tmp60 *tmp61
+  534 op add :fn2:zx *tmp62 :fn2:cx
+  535 op mul *tmp64 2 :fn2:x1
+  536 op mul *tmp65 *tmp64 :fn2:zy
+  537 op add :fn2:zy *tmp65 :fn2:cy
+  538 op len :fn2:dist :fn2:zx :fn2:zy
+  539 jump *label201 lessThan :fn2:dist 64
+  540 jump *label54 always
+  541 label *label201
+  542 label *label202
+  543 label *label203
+  544 op add :fn2:i :fn2:i 1
+  545 label *label204
+  546 set :fn2:x1 :fn2:zx
+  547 op mul *tmp60 :fn2:zx :fn2:zx
+  548 op mul *tmp61 :fn2:zy :fn2:zy
+  549 op sub *tmp62 *tmp60 *tmp61
+  550 op add :fn2:zx *tmp62 :fn2:cx
+  551 op mul *tmp64 2 :fn2:x1
+  552 op mul *tmp65 *tmp64 :fn2:zy
+  553 op add :fn2:zy *tmp65 :fn2:cy
+  554 op len :fn2:dist :fn2:zx :fn2:zy
+  555 jump *label205 lessThan :fn2:dist 64
+  556 jump *label54 always
+  557 label *label205
+  558 label *label206
+  559 label *label207
+  560 op add :fn2:i :fn2:i 1
+  561 label *label208
+  562 set :fn2:x1 :fn2:zx
+  563 op mul *tmp60 :fn2:zx :fn2:zx
+  564 op mul *tmp61 :fn2:zy :fn2:zy
+  565 op sub *tmp62 *tmp60 *tmp61
+  566 op add :fn2:zx *tmp62 :fn2:cx
+  567 op mul *tmp64 2 :fn2:x1
+  568 op mul *tmp65 *tmp64 :fn2:zy
+  569 op add :fn2:zy *tmp65 :fn2:cy
+  570 op len :fn2:dist :fn2:zx :fn2:zy
+  571 jump *label209 lessThan :fn2:dist 64
+  572 jump *label54 always
+  573 label *label209
+  574 label *label210
+  575 label *label211
+  576 op add :fn2:i :fn2:i 1
+  577 label *label212
+  578 set :fn2:x1 :fn2:zx
+  579 op mul *tmp60 :fn2:zx :fn2:zx
+  580 op mul *tmp61 :fn2:zy :fn2:zy
+  581 op sub *tmp62 *tmp60 *tmp61
+  582 op add :fn2:zx *tmp62 :fn2:cx
+  583 op mul *tmp64 2 :fn2:x1
+  584 op mul *tmp65 *tmp64 :fn2:zy
+  585 op add :fn2:zy *tmp65 :fn2:cy
+  586 op len :fn2:dist :fn2:zx :fn2:zy
+  587 jump *label213 lessThan :fn2:dist 64
+  588 jump *label54 always
+  589 label *label213
+  590 label *label214
+  591 label *label215
+  592 op add :fn2:i :fn2:i 1
+  593 label *label216
+  594 set :fn2:x1 :fn2:zx
+  595 op mul *tmp60 :fn2:zx :fn2:zx
+  596 op mul *tmp61 :fn2:zy :fn2:zy
+  597 op sub *tmp62 *tmp60 *tmp61
+  598 op add :fn2:zx *tmp62 :fn2:cx
+  599 op mul *tmp64 2 :fn2:x1
+  600 op mul *tmp65 *tmp64 :fn2:zy
+  601 op add :fn2:zy *tmp65 :fn2:cy
+  602 op len :fn2:dist :fn2:zx :fn2:zy
+  603 jump *label217 lessThan :fn2:dist 64
+  604 jump *label54 always
+  605 label *label217
+  606 label *label218
+  607 label *label219
+  608 op add :fn2:i :fn2:i 1
+  609 label *label220
+  610 set :fn2:x1 :fn2:zx
+  611 op mul *tmp60 :fn2:zx :fn2:zx
+  612 op mul *tmp61 :fn2:zy :fn2:zy
+  613 op sub *tmp62 *tmp60 *tmp61
+  614 op add :fn2:zx *tmp62 :fn2:cx
+  615 op mul *tmp64 2 :fn2:x1
+  616 op mul *tmp65 *tmp64 :fn2:zy
+  617 op add :fn2:zy *tmp65 :fn2:cy
+  618 op len :fn2:dist :fn2:zx :fn2:zy
+  619 jump *label221 lessThan :fn2:dist 64
+  620 jump *label54 always
+  621 label *label221
+  622 label *label222
+  623 label *label223
+  624 op add :fn2:i :fn2:i 1
+  625 label *label224
+  626 set :fn2:x1 :fn2:zx
+  627 op mul *tmp60 :fn2:zx :fn2:zx
+  628 op mul *tmp61 :fn2:zy :fn2:zy
+  629 op sub *tmp62 *tmp60 *tmp61
+  630 op add :fn2:zx *tmp62 :fn2:cx
+  631 op mul *tmp64 2 :fn2:x1
+  632 op mul *tmp65 *tmp64 :fn2:zy
+  633 op add :fn2:zy *tmp65 :fn2:cy
+  634 op len :fn2:dist :fn2:zx :fn2:zy
+  635 jump *label225 lessThan :fn2:dist 64
+  636 jump *label54 always
+  637 label *label225
+  638 label *label226
+  639 label *label227
+  640 op add :fn2:i :fn2:i 1
+  641 label *label228
+  642 set :fn2:x1 :fn2:zx
+  643 op mul *tmp60 :fn2:zx :fn2:zx
+  644 op mul *tmp61 :fn2:zy :fn2:zy
+  645 op sub *tmp62 *tmp60 *tmp61
+  646 op add :fn2:zx *tmp62 :fn2:cx
+  647 op mul *tmp64 2 :fn2:x1
+  648 op mul *tmp65 *tmp64 :fn2:zy
+  649 op add :fn2:zy *tmp65 :fn2:cy
+  650 op len :fn2:dist :fn2:zx :fn2:zy
+  651 jump *label229 lessThan :fn2:dist 64
+  652 jump *label54 always
+  653 label *label229
+  654 label *label230
+  655 label *label231
+  656 op add :fn2:i :fn2:i 1
+  657 label *label232
+  658 set :fn2:x1 :fn2:zx
+  659 op mul *tmp60 :fn2:zx :fn2:zx
+  660 op mul *tmp61 :fn2:zy :fn2:zy
+  661 op sub *tmp62 *tmp60 *tmp61
+  662 op add :fn2:zx *tmp62 :fn2:cx
+  663 op mul *tmp64 2 :fn2:x1
+  664 op mul *tmp65 *tmp64 :fn2:zy
+  665 op add :fn2:zy *tmp65 :fn2:cy
+  666 op len :fn2:dist :fn2:zx :fn2:zy
+  667 jump *label233 lessThan :fn2:dist 64
+  668 jump *label54 always
+  669 label *label233
+  670 label *label234
+  671 label *label235
+  672 op add :fn2:i :fn2:i 1
+  673 label *label236
+  674 set :fn2:x1 :fn2:zx
+  675 op mul *tmp60 :fn2:zx :fn2:zx
+  676 op mul *tmp61 :fn2:zy :fn2:zy
+  677 op sub *tmp62 *tmp60 *tmp61
+  678 op add :fn2:zx *tmp62 :fn2:cx
+  679 op mul *tmp64 2 :fn2:x1
+  680 op mul *tmp65 *tmp64 :fn2:zy
+  681 op add :fn2:zy *tmp65 :fn2:cy
+  682 op len :fn2:dist :fn2:zx :fn2:zy
+  683 jump *label237 lessThan :fn2:dist 64
+  684 jump *label54 always
+  685 label *label237
+  686 label *label238
+  687 label *label239
+  688 op add :fn2:i :fn2:i 1
+  689 label *label240
+  690 set :fn2:x1 :fn2:zx
+  691 op mul *tmp60 :fn2:zx :fn2:zx
+  692 op mul *tmp61 :fn2:zy :fn2:zy
+  693 op sub *tmp62 *tmp60 *tmp61
+  694 op add :fn2:zx *tmp62 :fn2:cx
+  695 op mul *tmp64 2 :fn2:x1
+  696 op mul *tmp65 *tmp64 :fn2:zy
+  697 op add :fn2:zy *tmp65 :fn2:cy
+  698 op len :fn2:dist :fn2:zx :fn2:zy
+  699 jump *label241 lessThan :fn2:dist 64
+  700 jump *label54 always
+  701 label *label241
+  702 label *label242
+  703 label *label243
+  704 op add :fn2:i :fn2:i 1
+  705 label *label244
+  706 set :fn2:x1 :fn2:zx
+  707 op mul *tmp60 :fn2:zx :fn2:zx
+  708 op mul *tmp61 :fn2:zy :fn2:zy
+  709 op sub *tmp62 *tmp60 *tmp61
+  710 op add :fn2:zx *tmp62 :fn2:cx
+  711 op mul *tmp64 2 :fn2:x1
+  712 op mul *tmp65 *tmp64 :fn2:zy
+  713 op add :fn2:zy *tmp65 :fn2:cy
+  714 op len :fn2:dist :fn2:zx :fn2:zy
+  715 jump *label245 lessThan :fn2:dist 64
+  716 jump *label54 always
+  717 label *label245
+  718 label *label246
+  719 label *label247
+  720 op add :fn2:i :fn2:i 1
+  721 label *label248
+  722 set :fn2:x1 :fn2:zx
+  723 op mul *tmp60 :fn2:zx :fn2:zx
+  724 op mul *tmp61 :fn2:zy :fn2:zy
+  725 op sub *tmp62 *tmp60 *tmp61
+  726 op add :fn2:zx *tmp62 :fn2:cx
+  727 op mul *tmp64 2 :fn2:x1
+  728 op mul *tmp65 *tmp64 :fn2:zy
+  729 op add :fn2:zy *tmp65 :fn2:cy
+  730 op len :fn2:dist :fn2:zx :fn2:zy
+  731 jump *label249 lessThan :fn2:dist 64
+  732 jump *label54 always
+  733 label *label249
+  734 label *label250
+  735 label *label251
+  736 op add :fn2:i :fn2:i 1
+  737 label *label252
+  738 set :fn2:x1 :fn2:zx
+  739 op mul *tmp60 :fn2:zx :fn2:zx
+  740 op mul *tmp61 :fn2:zy :fn2:zy
+  741 op sub *tmp62 *tmp60 *tmp61
+  742 op add :fn2:zx *tmp62 :fn2:cx
+  743 op mul *tmp64 2 :fn2:x1
+  744 op mul *tmp65 *tmp64 :fn2:zy
+  745 op add :fn2:zy *tmp65 :fn2:cy
+  746 op len :fn2:dist :fn2:zx :fn2:zy
+  747 jump *label253 lessThan :fn2:dist 64
+  748 jump *label54 always
+  749 label *label253
+  750 label *label254
+  751 label *label255
+  752 op add :fn2:i :fn2:i 1
+  753 label *label256
+  754 set :fn2:x1 :fn2:zx
+  755 op mul *tmp60 :fn2:zx :fn2:zx
+  756 op mul *tmp61 :fn2:zy :fn2:zy
+  757 op sub *tmp62 *tmp60 *tmp61
+  758 op add :fn2:zx *tmp62 :fn2:cx
+  759 op mul *tmp64 2 :fn2:x1
+  760 op mul *tmp65 *tmp64 :fn2:zy
+  761 op add :fn2:zy *tmp65 :fn2:cy
+  762 op len :fn2:dist :fn2:zx :fn2:zy
+  763 jump *label257 lessThan :fn2:dist 64
+  764 jump *label54 always
+  765 label *label257
+  766 label *label258
+  767 label *label259
+  768 op add :fn2:i :fn2:i 1
+  769 label *label260
+  770 set :fn2:x1 :fn2:zx
+  771 op mul *tmp60 :fn2:zx :fn2:zx
+  772 op mul *tmp61 :fn2:zy :fn2:zy
+  773 op sub *tmp62 *tmp60 *tmp61
+  774 op add :fn2:zx *tmp62 :fn2:cx
+  775 op mul *tmp64 2 :fn2:x1
+  776 op mul *tmp65 *tmp64 :fn2:zy
+  777 op add :fn2:zy *tmp65 :fn2:cy
+  778 op len :fn2:dist :fn2:zx :fn2:zy
+  779 jump *label261 lessThan :fn2:dist 64
+  780 jump *label54 always
+  781 label *label261
+  782 label *label262
+  783 label *label263
+  784 op add :fn2:i :fn2:i 1
+  785 label *label264
+  786 set :fn2:x1 :fn2:zx
+  787 op mul *tmp60 :fn2:zx :fn2:zx
+  788 op mul *tmp61 :fn2:zy :fn2:zy
+  789 op sub *tmp62 *tmp60 *tmp61
+  790 op add :fn2:zx *tmp62 :fn2:cx
+  791 op mul *tmp64 2 :fn2:x1
+  792 op mul *tmp65 *tmp64 :fn2:zy
+  793 op add :fn2:zy *tmp65 :fn2:cy
+  794 op len :fn2:dist :fn2:zx :fn2:zy
+  795 jump *label265 lessThan :fn2:dist 64
+  796 jump *label54 always
+  797 label *label265
+  798 label *label266
+  799 label *label267
+  800 op add :fn2:i :fn2:i 1
+  801 label *label268
+  802 set :fn2:x1 :fn2:zx
+  803 op mul *tmp60 :fn2:zx :fn2:zx
+  804 op mul *tmp61 :fn2:zy :fn2:zy
+  805 op sub *tmp62 *tmp60 *tmp61
+  806 op add :fn2:zx *tmp62 :fn2:cx
+  807 op mul *tmp64 2 :fn2:x1
+  808 op mul *tmp65 *tmp64 :fn2:zy
+  809 op add :fn2:zy *tmp65 :fn2:cy
+  810 op len :fn2:dist :fn2:zx :fn2:zy
+  811 jump *label269 lessThan :fn2:dist 64
+  812 jump *label54 always
+  813 label *label269
+  814 label *label270
+  815 label *label271
+  816 op add :fn2:i :fn2:i 1
+  817 label *label272
+  818 set :fn2:x1 :fn2:zx
+  819 op mul *tmp60 :fn2:zx :fn2:zx
+  820 op mul *tmp61 :fn2:zy :fn2:zy
+  821 op sub *tmp62 *tmp60 *tmp61
+  822 op add :fn2:zx *tmp62 :fn2:cx
+  823 op mul *tmp64 2 :fn2:x1
+  824 op mul *tmp65 *tmp64 :fn2:zy
+  825 op add :fn2:zy *tmp65 :fn2:cy
+  826 op len :fn2:dist :fn2:zx :fn2:zy
+  827 jump *label273 lessThan :fn2:dist 64
+  828 jump *label54 always
+  829 label *label273
+  830 label *label274
+  831 label *label275
+  832 op add :fn2:i :fn2:i 1
+  833 label *label276
+  834 set :fn2:x1 :fn2:zx
+  835 op mul *tmp60 :fn2:zx :fn2:zx
+  836 op mul *tmp61 :fn2:zy :fn2:zy
+  837 op sub *tmp62 *tmp60 *tmp61
+  838 op add :fn2:zx *tmp62 :fn2:cx
+  839 op mul *tmp64 2 :fn2:x1
+  840 op mul *tmp65 *tmp64 :fn2:zy
+  841 op add :fn2:zy *tmp65 :fn2:cy
+  842 op len :fn2:dist :fn2:zx :fn2:zy
+  843 jump *label277 lessThan :fn2:dist 64
+  844 jump *label54 always
+  845 label *label277
+  846 label *label278
+  847 label *label279
+  848 op add :fn2:i :fn2:i 1
+  849 label *label280
+  850 set :fn2:x1 :fn2:zx
+  851 op mul *tmp60 :fn2:zx :fn2:zx
+  852 op mul *tmp61 :fn2:zy :fn2:zy
+  853 op sub *tmp62 *tmp60 *tmp61
+  854 op add :fn2:zx *tmp62 :fn2:cx
+  855 op mul *tmp64 2 :fn2:x1
+  856 op mul *tmp65 *tmp64 :fn2:zy
+  857 op add :fn2:zy *tmp65 :fn2:cy
+  858 op len :fn2:dist :fn2:zx :fn2:zy
+  859 jump *label281 lessThan :fn2:dist 64
+  860 jump *label54 always
+  861 label *label281
+  862 label *label282
+  863 label *label283
+  864 op add :fn2:i :fn2:i 1
+  865 label *label284
+  866 set :fn2:x1 :fn2:zx
+  867 op mul *tmp60 :fn2:zx :fn2:zx
+  868 op mul *tmp61 :fn2:zy :fn2:zy
+  869 op sub *tmp62 *tmp60 *tmp61
+  870 op add :fn2:zx *tmp62 :fn2:cx
+  871 op mul *tmp64 2 :fn2:x1
+  872 op mul *tmp65 *tmp64 :fn2:zy
+  873 op add :fn2:zy *tmp65 :fn2:cy
+  874 op len :fn2:dist :fn2:zx :fn2:zy
+  875 jump *label285 lessThan :fn2:dist 64
+  876 jump *label54 always
+  877 label *label285
+  878 label *label286
+  879 label *label287
+  880 op add :fn2:i :fn2:i 1
+  881 label *label288
+  882 set :fn2:x1 :fn2:zx
+  883 op mul *tmp60 :fn2:zx :fn2:zx
+  884 op mul *tmp61 :fn2:zy :fn2:zy
+  885 op sub *tmp62 *tmp60 *tmp61
+  886 op add :fn2:zx *tmp62 :fn2:cx
+  887 op mul *tmp64 2 :fn2:x1
+  888 op mul *tmp65 *tmp64 :fn2:zy
+  889 op add :fn2:zy *tmp65 :fn2:cy
+  890 op len :fn2:dist :fn2:zx :fn2:zy
+  891 jump *label289 lessThan :fn2:dist 64
+  892 jump *label54 always
+  893 label *label289
+  894 label *label290
+  895 label *label291
+  896 op add :fn2:i :fn2:i 1
+  897 label *label292
+  898 set :fn2:x1 :fn2:zx
+  899 op mul *tmp60 :fn2:zx :fn2:zx
+  900 op mul *tmp61 :fn2:zy :fn2:zy
+  901 op sub *tmp62 *tmp60 *tmp61
+  902 op add :fn2:zx *tmp62 :fn2:cx
+  903 op mul *tmp64 2 :fn2:x1
+  904 op mul *tmp65 *tmp64 :fn2:zy
+  905 op add :fn2:zy *tmp65 :fn2:cy
+  906 op len :fn2:dist :fn2:zx :fn2:zy
+  907 jump *label293 lessThan :fn2:dist 64
+  908 jump *label54 always
+  909 label *label293
+  910 label *label294
+  911 label *label295
+  912 op add :fn2:i :fn2:i 1
+  913 label *label296
+  914 set :fn2:x1 :fn2:zx
+  915 op mul *tmp60 :fn2:zx :fn2:zx
+  916 op mul *tmp61 :fn2:zy :fn2:zy
+  917 op sub *tmp62 *tmp60 *tmp61
+  918 op add :fn2:zx *tmp62 :fn2:cx
+  919 op mul *tmp64 2 :fn2:x1
+  920 op mul *tmp65 *tmp64 :fn2:zy
+  921 op add :fn2:zy *tmp65 :fn2:cy
+  922 op len :fn2:dist :fn2:zx :fn2:zy
+  923 jump *label297 lessThan :fn2:dist 64
+  924 jump *label54 always
+  925 label *label297
+  926 label *label298
+  927 label *label299
+  928 op add :fn2:i :fn2:i 1
+  929 label *label300
+  930 set :fn2:x1 :fn2:zx
+  931 op mul *tmp60 :fn2:zx :fn2:zx
+  932 op mul *tmp61 :fn2:zy :fn2:zy
+  933 op sub *tmp62 *tmp60 *tmp61
+  934 op add :fn2:zx *tmp62 :fn2:cx
+  935 op mul *tmp64 2 :fn2:x1
+  936 op mul *tmp65 *tmp64 :fn2:zy
+  937 op add :fn2:zy *tmp65 :fn2:cy
+  938 op len :fn2:dist :fn2:zx :fn2:zy
+  939 jump *label301 lessThan :fn2:dist 64
+  940 jump *label54 always
+  941 label *label301
+  942 label *label302
+  943 label *label303
+  944 op add :fn2:i :fn2:i 1
+  945 label *label304
+  946 set :fn2:x1 :fn2:zx
+  947 op mul *tmp60 :fn2:zx :fn2:zx
+  948 op mul *tmp61 :fn2:zy :fn2:zy
+  949 op sub *tmp62 *tmp60 *tmp61
+  950 op add :fn2:zx *tmp62 :fn2:cx
+  951 op mul *tmp64 2 :fn2:x1
+  952 op mul *tmp65 *tmp64 :fn2:zy
+  953 op add :fn2:zy *tmp65 :fn2:cy
+  954 op len :fn2:dist :fn2:zx :fn2:zy
+  955 jump *label305 lessThan :fn2:dist 64
+  956 jump *label54 always
+  957 label *label305
+  958 label *label306
+  959 label *label307
+  960 op add :fn2:i :fn2:i 1
+  961 label *label308
+  962 set :fn2:x1 :fn2:zx
+  963 op mul *tmp60 :fn2:zx :fn2:zx
+  964 op mul *tmp61 :fn2:zy :fn2:zy
+  965 op sub *tmp62 *tmp60 *tmp61
+  966 op add :fn2:zx *tmp62 :fn2:cx
+  967 op mul *tmp64 2 :fn2:x1
+  968 op mul *tmp65 *tmp64 :fn2:zy
+  969 op add :fn2:zy *tmp65 :fn2:cy
+  970 op len :fn2:dist :fn2:zx :fn2:zy
+  971 jump *label309 lessThan :fn2:dist 64
+  972 jump *label54 always
+  973 label *label309
+  974 label *label310
+  975 label *label311
+  976 op add :fn2:i :fn2:i 1
+  977 label *label312
+  978 set :fn2:x1 :fn2:zx
+  979 op mul *tmp60 :fn2:zx :fn2:zx
+  980 op mul *tmp61 :fn2:zy :fn2:zy
+  981 op sub *tmp62 *tmp60 *tmp61
+  982 op add :fn2:zx *tmp62 :fn2:cx
+  983 op mul *tmp64 2 :fn2:x1
+  984 op mul *tmp65 *tmp64 :fn2:zy
+  985 op add :fn2:zy *tmp65 :fn2:cy
+  986 op len :fn2:dist :fn2:zx :fn2:zy
+  987 jump *label313 lessThan :fn2:dist 64
+  988 jump *label54 always
+  989 label *label313
+  990 label *label314
+  991 label *label315
+  992 op add :fn2:i :fn2:i 1
+  993 label *label316
+  994 set :fn2:x1 :fn2:zx
+  995 op mul *tmp60 :fn2:zx :fn2:zx
+  996 op mul *tmp61 :fn2:zy :fn2:zy
+  997 op sub *tmp62 *tmp60 *tmp61
+  998 op add :fn2:zx *tmp62 :fn2:cx
+  999 op mul *tmp64 2 :fn2:x1
+ 1000 op mul *tmp65 *tmp64 :fn2:zy
+ 1001 op add :fn2:zy *tmp65 :fn2:cy
+ 1002 op len :fn2:dist :fn2:zx :fn2:zy
+ 1003 jump *label317 lessThan :fn2:dist 64
+ 1004 jump *label54 always
+ 1005 label *label317
+ 1006 label *label318
+ 1007 label *label319
+ 1008 op add :fn2:i :fn2:i 1
+ 1009 label *label320
+ 1010 set :fn2:x1 :fn2:zx
+ 1011 op mul *tmp60 :fn2:zx :fn2:zx
+ 1012 op mul *tmp61 :fn2:zy :fn2:zy
+ 1013 op sub *tmp62 *tmp60 *tmp61
+ 1014 op add :fn2:zx *tmp62 :fn2:cx
+ 1015 op mul *tmp64 2 :fn2:x1
+ 1016 op mul *tmp65 *tmp64 :fn2:zy
+ 1017 op add :fn2:zy *tmp65 :fn2:cy
+ 1018 op len :fn2:dist :fn2:zx :fn2:zy
+ 1019 jump *label321 lessThan :fn2:dist 64
+ 1020 jump *label54 always
+ 1021 label *label321
+ 1022 label *label322
+ 1023 label *label323
+ 1024 op add :fn2:i :fn2:i 1
+ 1025 label *label324
+ 1026 set :fn2:x1 :fn2:zx
+ 1027 op mul *tmp60 :fn2:zx :fn2:zx
+ 1028 op mul *tmp61 :fn2:zy :fn2:zy
+ 1029 op sub *tmp62 *tmp60 *tmp61
+ 1030 op add :fn2:zx *tmp62 :fn2:cx
+ 1031 op mul *tmp64 2 :fn2:x1
+ 1032 op mul *tmp65 *tmp64 :fn2:zy
+ 1033 op add :fn2:zy *tmp65 :fn2:cy
+ 1034 op len :fn2:dist :fn2:zx :fn2:zy
+ 1035 jump *label325 lessThan :fn2:dist 64
+ 1036 jump *label54 always
+ 1037 label *label325
+ 1038 label *label326
+ 1039 label *label327
+ 1040 op add :fn2:i :fn2:i 1
+ 1041 label *label328
+ 1042 set :fn2:x1 :fn2:zx
+ 1043 op mul *tmp60 :fn2:zx :fn2:zx
+ 1044 op mul *tmp61 :fn2:zy :fn2:zy
+ 1045 op sub *tmp62 *tmp60 *tmp61
+ 1046 op add :fn2:zx *tmp62 :fn2:cx
+ 1047 op mul *tmp64 2 :fn2:x1
+ 1048 op mul *tmp65 *tmp64 :fn2:zy
+ 1049 op add :fn2:zy *tmp65 :fn2:cy
+ 1050 op len :fn2:dist :fn2:zx :fn2:zy
+ 1051 jump *label329 lessThan :fn2:dist 64
+ 1052 jump *label54 always
+ 1053 label *label329
+ 1054 label *label330
+ 1055 label *label331
+ 1056 op add :fn2:i :fn2:i 1
+ 1057 label *label332
+ 1058 set :fn2:x1 :fn2:zx
+ 1059 op mul *tmp60 :fn2:zx :fn2:zx
+ 1060 op mul *tmp61 :fn2:zy :fn2:zy
+ 1061 op sub *tmp62 *tmp60 *tmp61
+ 1062 op add :fn2:zx *tmp62 :fn2:cx
+ 1063 op mul *tmp64 2 :fn2:x1
+ 1064 op mul *tmp65 *tmp64 :fn2:zy
+ 1065 op add :fn2:zy *tmp65 :fn2:cy
+ 1066 op len :fn2:dist :fn2:zx :fn2:zy
+ 1067 jump *label333 lessThan :fn2:dist 64
+ 1068 jump *label54 always
+ 1069 label *label333
+ 1070 label *label334
+ 1071 label *label335
+ 1072 op add :fn2:i :fn2:i 1
+ 1073 label *label336
+ 1074 set :fn2:x1 :fn2:zx
+ 1075 op mul *tmp60 :fn2:zx :fn2:zx
+ 1076 op mul *tmp61 :fn2:zy :fn2:zy
+ 1077 op sub *tmp62 *tmp60 *tmp61
+ 1078 op add :fn2:zx *tmp62 :fn2:cx
+ 1079 op mul *tmp64 2 :fn2:x1
+ 1080 op mul *tmp65 *tmp64 :fn2:zy
+ 1081 op add :fn2:zy *tmp65 :fn2:cy
+ 1082 op len :fn2:dist :fn2:zx :fn2:zy
+ 1083 jump *label337 lessThan :fn2:dist 64
+ 1084 jump *label54 always
+ 1085 label *label337
+ 1086 label *label338
+ 1087 label *label339
+ 1088 op add :fn2:i :fn2:i 1
+ 1089 label *label340
+ 1090 set :fn2:x1 :fn2:zx
+ 1091 op mul *tmp60 :fn2:zx :fn2:zx
+ 1092 op mul *tmp61 :fn2:zy :fn2:zy
+ 1093 op sub *tmp62 *tmp60 *tmp61
+ 1094 op add :fn2:zx *tmp62 :fn2:cx
+ 1095 op mul *tmp64 2 :fn2:x1
+ 1096 op mul *tmp65 *tmp64 :fn2:zy
+ 1097 op add :fn2:zy *tmp65 :fn2:cy
+ 1098 op len :fn2:dist :fn2:zx :fn2:zy
+ 1099 jump *label341 lessThan :fn2:dist 64
+ 1100 jump *label54 always
+ 1101 label *label341
+ 1102 label *label342
+ 1103 label *label343
+ 1104 op add :fn2:i :fn2:i 1
+ 1105 label *label344
+ 1106 set :fn2:x1 :fn2:zx
+ 1107 op mul *tmp60 :fn2:zx :fn2:zx
+ 1108 op mul *tmp61 :fn2:zy :fn2:zy
+ 1109 op sub *tmp62 *tmp60 *tmp61
+ 1110 op add :fn2:zx *tmp62 :fn2:cx
+ 1111 op mul *tmp64 2 :fn2:x1
+ 1112 op mul *tmp65 *tmp64 :fn2:zy
+ 1113 op add :fn2:zy *tmp65 :fn2:cy
+ 1114 op len :fn2:dist :fn2:zx :fn2:zy
+ 1115 jump *label345 lessThan :fn2:dist 64
+ 1116 jump *label54 always
+ 1117 label *label345
+ 1118 label *label346
+ 1119 label *label347
+ 1120 op add :fn2:i :fn2:i 1
+ 1121 label *label348
+ 1122 set :fn2:x1 :fn2:zx
+ 1123 op mul *tmp60 :fn2:zx :fn2:zx
+ 1124 op mul *tmp61 :fn2:zy :fn2:zy
+ 1125 op sub *tmp62 *tmp60 *tmp61
+ 1126 op add :fn2:zx *tmp62 :fn2:cx
+ 1127 op mul *tmp64 2 :fn2:x1
+ 1128 op mul *tmp65 *tmp64 :fn2:zy
+ 1129 op add :fn2:zy *tmp65 :fn2:cy
+ 1130 op len :fn2:dist :fn2:zx :fn2:zy
+ 1131 jump *label349 lessThan :fn2:dist 64
+ 1132 jump *label54 always
+ 1133 label *label349
+ 1134 label *label350
+ 1135 label *label351
+ 1136 op add :fn2:i :fn2:i 1
+ 1137 label *label352
+ 1138 set :fn2:x1 :fn2:zx
+ 1139 op mul *tmp60 :fn2:zx :fn2:zx
+ 1140 op mul *tmp61 :fn2:zy :fn2:zy
+ 1141 op sub *tmp62 *tmp60 *tmp61
+ 1142 op add :fn2:zx *tmp62 :fn2:cx
+ 1143 op mul *tmp64 2 :fn2:x1
+ 1144 op mul *tmp65 *tmp64 :fn2:zy
+ 1145 op add :fn2:zy *tmp65 :fn2:cy
+ 1146 op len :fn2:dist :fn2:zx :fn2:zy
+ 1147 jump *label353 lessThan :fn2:dist 64
+ 1148 jump *label54 always
+ 1149 label *label353
+ 1150 label *label354
+ 1151 label *label355
+ 1152 op add :fn2:i :fn2:i 1
+ 1153 label *label356
+ 1154 set :fn2:x1 :fn2:zx
+ 1155 op mul *tmp60 :fn2:zx :fn2:zx
+ 1156 op mul *tmp61 :fn2:zy :fn2:zy
+ 1157 op sub *tmp62 *tmp60 *tmp61
+ 1158 op add :fn2:zx *tmp62 :fn2:cx
+ 1159 op mul *tmp64 2 :fn2:x1
+ 1160 op mul *tmp65 *tmp64 :fn2:zy
+ 1161 op add :fn2:zy *tmp65 :fn2:cy
+ 1162 op len :fn2:dist :fn2:zx :fn2:zy
+ 1163 jump *label357 lessThan :fn2:dist 64
+ 1164 jump *label54 always
+ 1165 label *label357
+ 1166 label *label358
+ 1167 label *label359
+ 1168 op add :fn2:i :fn2:i 1
+ 1169 label *label54
  1170 op mul *tmp70 .SMOOTH 63
  1171 jump *label57 greaterThanEq :fn2:i *tmp70
  1172 op log *tmp73 :fn2:dist

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   173 label *label109
   174 label *label110
   175 label *label111
-    * op add :fn2:i :fn2:i 1
+  176 op add :fn2:i 0 1
   177 label *label112
   178 set :fn2:x1 :fn2:zx
   179 op mul *tmp60 :fn2:zx :fn2:zx
 
   189 label *label113
   190 label *label114
   191 label *label115
-    * op add :fn2:i :fn2:i 1
+  192 op add :fn2:i 1 1
   193 label *label116
   194 set :fn2:x1 :fn2:zx
   195 op mul *tmp60 :fn2:zx :fn2:zx
 
   205 label *label117
   206 label *label118
   207 label *label119
-    * op add :fn2:i :fn2:i 1
+  208 op add :fn2:i 2 1
   209 label *label120
   210 set :fn2:x1 :fn2:zx
   211 op mul *tmp60 :fn2:zx :fn2:zx
 
   221 label *label121
   222 label *label122
   223 label *label123
-    * op add :fn2:i :fn2:i 1
+  224 op add :fn2:i 3 1
   225 label *label124
   226 set :fn2:x1 :fn2:zx
   227 op mul *tmp60 :fn2:zx :fn2:zx
 
   237 label *label125
   238 label *label126
   239 label *label127
-    * op add :fn2:i :fn2:i 1
+  240 op add :fn2:i 4 1
   241 label *label128
   242 set :fn2:x1 :fn2:zx
   243 op mul *tmp60 :fn2:zx :fn2:zx
 
   253 label *label129
   254 label *label130
   255 label *label131
-    * op add :fn2:i :fn2:i 1
+  256 op add :fn2:i 5 1
   257 label *label132
   258 set :fn2:x1 :fn2:zx
   259 op mul *tmp60 :fn2:zx :fn2:zx
 
   269 label *label133
   270 label *label134
   271 label *label135
-    * op add :fn2:i :fn2:i 1
+  272 op add :fn2:i 6 1
   273 label *label136
   274 set :fn2:x1 :fn2:zx
   275 op mul *tmp60 :fn2:zx :fn2:zx
 
   285 label *label137
   286 label *label138
   287 label *label139
-    * op add :fn2:i :fn2:i 1
+  288 op add :fn2:i 7 1
   289 label *label140
   290 set :fn2:x1 :fn2:zx
   291 op mul *tmp60 :fn2:zx :fn2:zx
 
   301 label *label141
   302 label *label142
   303 label *label143
-    * op add :fn2:i :fn2:i 1
+  304 op add :fn2:i 8 1
   305 label *label144
   306 set :fn2:x1 :fn2:zx
   307 op mul *tmp60 :fn2:zx :fn2:zx
 
   317 label *label145
   318 label *label146
   319 label *label147
-    * op add :fn2:i :fn2:i 1
+  320 op add :fn2:i 9 1
   321 label *label148
   322 set :fn2:x1 :fn2:zx
   323 op mul *tmp60 :fn2:zx :fn2:zx
 
   333 label *label149
   334 label *label150
   335 label *label151
-    * op add :fn2:i :fn2:i 1
+  336 op add :fn2:i 10 1
   337 label *label152
   338 set :fn2:x1 :fn2:zx
   339 op mul *tmp60 :fn2:zx :fn2:zx
 
   349 label *label153
   350 label *label154
   351 label *label155
-    * op add :fn2:i :fn2:i 1
+  352 op add :fn2:i 11 1
   353 label *label156
   354 set :fn2:x1 :fn2:zx
   355 op mul *tmp60 :fn2:zx :fn2:zx
 
   365 label *label157
   366 label *label158
   367 label *label159
-    * op add :fn2:i :fn2:i 1
+  368 op add :fn2:i 12 1
   369 label *label160
   370 set :fn2:x1 :fn2:zx
   371 op mul *tmp60 :fn2:zx :fn2:zx
 
   381 label *label161
   382 label *label162
   383 label *label163
-    * op add :fn2:i :fn2:i 1
+  384 op add :fn2:i 13 1
   385 label *label164
   386 set :fn2:x1 :fn2:zx
   387 op mul *tmp60 :fn2:zx :fn2:zx
 
   397 label *label165
   398 label *label166
   399 label *label167
-    * op add :fn2:i :fn2:i 1
+  400 op add :fn2:i 14 1
   401 label *label168
   402 set :fn2:x1 :fn2:zx
   403 op mul *tmp60 :fn2:zx :fn2:zx
 
   413 label *label169
   414 label *label170
   415 label *label171
-    * op add :fn2:i :fn2:i 1
+  416 op add :fn2:i 15 1
   417 label *label172
   418 set :fn2:x1 :fn2:zx
   419 op mul *tmp60 :fn2:zx :fn2:zx
 
   429 label *label173
   430 label *label174
   431 label *label175
-    * op add :fn2:i :fn2:i 1
+  432 op add :fn2:i 16 1
   433 label *label176
   434 set :fn2:x1 :fn2:zx
   435 op mul *tmp60 :fn2:zx :fn2:zx
 
   445 label *label177
   446 label *label178
   447 label *label179
-    * op add :fn2:i :fn2:i 1
+  448 op add :fn2:i 17 1
   449 label *label180
   450 set :fn2:x1 :fn2:zx
   451 op mul *tmp60 :fn2:zx :fn2:zx
 
   461 label *label181
   462 label *label182
   463 label *label183
-    * op add :fn2:i :fn2:i 1
+  464 op add :fn2:i 18 1
   465 label *label184
   466 set :fn2:x1 :fn2:zx
   467 op mul *tmp60 :fn2:zx :fn2:zx
 
   477 label *label185
   478 label *label186
   479 label *label187
-    * op add :fn2:i :fn2:i 1
+  480 op add :fn2:i 19 1
   481 label *label188
   482 set :fn2:x1 :fn2:zx
   483 op mul *tmp60 :fn2:zx :fn2:zx
 
   493 label *label189
   494 label *label190
   495 label *label191
-    * op add :fn2:i :fn2:i 1
+  496 op add :fn2:i 20 1
   497 label *label192
   498 set :fn2:x1 :fn2:zx
   499 op mul *tmp60 :fn2:zx :fn2:zx
 
   509 label *label193
   510 label *label194
   511 label *label195
-    * op add :fn2:i :fn2:i 1
+  512 op add :fn2:i 21 1
   513 label *label196
   514 set :fn2:x1 :fn2:zx
   515 op mul *tmp60 :fn2:zx :fn2:zx
 
   525 label *label197
   526 label *label198
   527 label *label199
-    * op add :fn2:i :fn2:i 1
+  528 op add :fn2:i 22 1
   529 label *label200
   530 set :fn2:x1 :fn2:zx
   531 op mul *tmp60 :fn2:zx :fn2:zx
 
   541 label *label201
   542 label *label202
   543 label *label203
-    * op add :fn2:i :fn2:i 1
+  544 op add :fn2:i 23 1
   545 label *label204
   546 set :fn2:x1 :fn2:zx
   547 op mul *tmp60 :fn2:zx :fn2:zx
 
   557 label *label205
   558 label *label206
   559 label *label207
-    * op add :fn2:i :fn2:i 1
+  560 op add :fn2:i 24 1
   561 label *label208
   562 set :fn2:x1 :fn2:zx
   563 op mul *tmp60 :fn2:zx :fn2:zx
 
   573 label *label209
   574 label *label210
   575 label *label211
-    * op add :fn2:i :fn2:i 1
+  576 op add :fn2:i 25 1
   577 label *label212
   578 set :fn2:x1 :fn2:zx
   579 op mul *tmp60 :fn2:zx :fn2:zx
 
   589 label *label213
   590 label *label214
   591 label *label215
-    * op add :fn2:i :fn2:i 1
+  592 op add :fn2:i 26 1
   593 label *label216
   594 set :fn2:x1 :fn2:zx
   595 op mul *tmp60 :fn2:zx :fn2:zx
 
   605 label *label217
   606 label *label218
   607 label *label219
-    * op add :fn2:i :fn2:i 1
+  608 op add :fn2:i 27 1
   609 label *label220
   610 set :fn2:x1 :fn2:zx
   611 op mul *tmp60 :fn2:zx :fn2:zx
 
   621 label *label221
   622 label *label222
   623 label *label223
-    * op add :fn2:i :fn2:i 1
+  624 op add :fn2:i 28 1
   625 label *label224
   626 set :fn2:x1 :fn2:zx
   627 op mul *tmp60 :fn2:zx :fn2:zx
 
   637 label *label225
   638 label *label226
   639 label *label227
-    * op add :fn2:i :fn2:i 1
+  640 op add :fn2:i 29 1
   641 label *label228
   642 set :fn2:x1 :fn2:zx
   643 op mul *tmp60 :fn2:zx :fn2:zx
 
   653 label *label229
   654 label *label230
   655 label *label231
-    * op add :fn2:i :fn2:i 1
+  656 op add :fn2:i 30 1
   657 label *label232
   658 set :fn2:x1 :fn2:zx
   659 op mul *tmp60 :fn2:zx :fn2:zx
 
   669 label *label233
   670 label *label234
   671 label *label235
-    * op add :fn2:i :fn2:i 1
+  672 op add :fn2:i 31 1
   673 label *label236
   674 set :fn2:x1 :fn2:zx
   675 op mul *tmp60 :fn2:zx :fn2:zx
 
   685 label *label237
   686 label *label238
   687 label *label239
-    * op add :fn2:i :fn2:i 1
+  688 op add :fn2:i 32 1
   689 label *label240
   690 set :fn2:x1 :fn2:zx
   691 op mul *tmp60 :fn2:zx :fn2:zx
 
   701 label *label241
   702 label *label242
   703 label *label243
-    * op add :fn2:i :fn2:i 1
+  704 op add :fn2:i 33 1
   705 label *label244
   706 set :fn2:x1 :fn2:zx
   707 op mul *tmp60 :fn2:zx :fn2:zx
 
   717 label *label245
   718 label *label246
   719 label *label247
-    * op add :fn2:i :fn2:i 1
+  720 op add :fn2:i 34 1
   721 label *label248
   722 set :fn2:x1 :fn2:zx
   723 op mul *tmp60 :fn2:zx :fn2:zx
 
   733 label *label249
   734 label *label250
   735 label *label251
-    * op add :fn2:i :fn2:i 1
+  736 op add :fn2:i 35 1
   737 label *label252
   738 set :fn2:x1 :fn2:zx
   739 op mul *tmp60 :fn2:zx :fn2:zx
 
   749 label *label253
   750 label *label254
   751 label *label255
-    * op add :fn2:i :fn2:i 1
+  752 op add :fn2:i 36 1
   753 label *label256
   754 set :fn2:x1 :fn2:zx
   755 op mul *tmp60 :fn2:zx :fn2:zx
 
   765 label *label257
   766 label *label258
   767 label *label259
-    * op add :fn2:i :fn2:i 1
+  768 op add :fn2:i 37 1
   769 label *label260
   770 set :fn2:x1 :fn2:zx
   771 op mul *tmp60 :fn2:zx :fn2:zx
 
   781 label *label261
   782 label *label262
   783 label *label263
-    * op add :fn2:i :fn2:i 1
+  784 op add :fn2:i 38 1
   785 label *label264
   786 set :fn2:x1 :fn2:zx
   787 op mul *tmp60 :fn2:zx :fn2:zx
 
   797 label *label265
   798 label *label266
   799 label *label267
-    * op add :fn2:i :fn2:i 1
+  800 op add :fn2:i 39 1
   801 label *label268
   802 set :fn2:x1 :fn2:zx
   803 op mul *tmp60 :fn2:zx :fn2:zx
 
   813 label *label269
   814 label *label270
   815 label *label271
-    * op add :fn2:i :fn2:i 1
+  816 op add :fn2:i 40 1
   817 label *label272
   818 set :fn2:x1 :fn2:zx
   819 op mul *tmp60 :fn2:zx :fn2:zx
 
   829 label *label273
   830 label *label274
   831 label *label275
-    * op add :fn2:i :fn2:i 1
+  832 op add :fn2:i 41 1
   833 label *label276
   834 set :fn2:x1 :fn2:zx
   835 op mul *tmp60 :fn2:zx :fn2:zx
 
   845 label *label277
   846 label *label278
   847 label *label279
-    * op add :fn2:i :fn2:i 1
+  848 op add :fn2:i 42 1
   849 label *label280
   850 set :fn2:x1 :fn2:zx
   851 op mul *tmp60 :fn2:zx :fn2:zx
 
   861 label *label281
   862 label *label282
   863 label *label283
-    * op add :fn2:i :fn2:i 1
+  864 op add :fn2:i 43 1
   865 label *label284
   866 set :fn2:x1 :fn2:zx
   867 op mul *tmp60 :fn2:zx :fn2:zx
 
   877 label *label285
   878 label *label286
   879 label *label287
-    * op add :fn2:i :fn2:i 1
+  880 op add :fn2:i 44 1
   881 label *label288
   882 set :fn2:x1 :fn2:zx
   883 op mul *tmp60 :fn2:zx :fn2:zx
 
   893 label *label289
   894 label *label290
   895 label *label291
-    * op add :fn2:i :fn2:i 1
+  896 op add :fn2:i 45 1
   897 label *label292
   898 set :fn2:x1 :fn2:zx
   899 op mul *tmp60 :fn2:zx :fn2:zx
 
   909 label *label293
   910 label *label294
   911 label *label295
-    * op add :fn2:i :fn2:i 1
+  912 op add :fn2:i 46 1
   913 label *label296
   914 set :fn2:x1 :fn2:zx
   915 op mul *tmp60 :fn2:zx :fn2:zx
 
   925 label *label297
   926 label *label298
   927 label *label299
-    * op add :fn2:i :fn2:i 1
+  928 op add :fn2:i 47 1
   929 label *label300
   930 set :fn2:x1 :fn2:zx
   931 op mul *tmp60 :fn2:zx :fn2:zx
 
   941 label *label301
   942 label *label302
   943 label *label303
-    * op add :fn2:i :fn2:i 1
+  944 op add :fn2:i 48 1
   945 label *label304
   946 set :fn2:x1 :fn2:zx
   947 op mul *tmp60 :fn2:zx :fn2:zx
 
   957 label *label305
   958 label *label306
   959 label *label307
-    * op add :fn2:i :fn2:i 1
+  960 op add :fn2:i 49 1
   961 label *label308
   962 set :fn2:x1 :fn2:zx
   963 op mul *tmp60 :fn2:zx :fn2:zx
 
   973 label *label309
   974 label *label310
   975 label *label311
-    * op add :fn2:i :fn2:i 1
+  976 op add :fn2:i 50 1
   977 label *label312
   978 set :fn2:x1 :fn2:zx
   979 op mul *tmp60 :fn2:zx :fn2:zx
 
   989 label *label313
   990 label *label314
   991 label *label315
-    * op add :fn2:i :fn2:i 1
+  992 op add :fn2:i 51 1
   993 label *label316
   994 set :fn2:x1 :fn2:zx
   995 op mul *tmp60 :fn2:zx :fn2:zx
 
  1005 label *label317
  1006 label *label318
  1007 label *label319
-    * op add :fn2:i :fn2:i 1
+ 1008 op add :fn2:i 52 1
  1009 label *label320
  1010 set :fn2:x1 :fn2:zx
  1011 op mul *tmp60 :fn2:zx :fn2:zx
 
  1021 label *label321
  1022 label *label322
  1023 label *label323
-    * op add :fn2:i :fn2:i 1
+ 1024 op add :fn2:i 53 1
  1025 label *label324
  1026 set :fn2:x1 :fn2:zx
  1027 op mul *tmp60 :fn2:zx :fn2:zx
 
  1037 label *label325
  1038 label *label326
  1039 label *label327
-    * op add :fn2:i :fn2:i 1
+ 1040 op add :fn2:i 54 1
  1041 label *label328
  1042 set :fn2:x1 :fn2:zx
  1043 op mul *tmp60 :fn2:zx :fn2:zx
 
  1053 label *label329
  1054 label *label330
  1055 label *label331
-    * op add :fn2:i :fn2:i 1
+ 1056 op add :fn2:i 55 1
  1057 label *label332
  1058 set :fn2:x1 :fn2:zx
  1059 op mul *tmp60 :fn2:zx :fn2:zx
 
  1069 label *label333
  1070 label *label334
  1071 label *label335
-    * op add :fn2:i :fn2:i 1
+ 1072 op add :fn2:i 56 1
  1073 label *label336
  1074 set :fn2:x1 :fn2:zx
  1075 op mul *tmp60 :fn2:zx :fn2:zx
 
  1085 label *label337
  1086 label *label338
  1087 label *label339
-    * op add :fn2:i :fn2:i 1
+ 1088 op add :fn2:i 57 1
  1089 label *label340
  1090 set :fn2:x1 :fn2:zx
  1091 op mul *tmp60 :fn2:zx :fn2:zx
 
  1101 label *label341
  1102 label *label342
  1103 label *label343
-    * op add :fn2:i :fn2:i 1
+ 1104 op add :fn2:i 58 1
  1105 label *label344
  1106 set :fn2:x1 :fn2:zx
  1107 op mul *tmp60 :fn2:zx :fn2:zx
 
  1117 label *label345
  1118 label *label346
  1119 label *label347
-    * op add :fn2:i :fn2:i 1
+ 1120 op add :fn2:i 59 1
  1121 label *label348
  1122 set :fn2:x1 :fn2:zx
  1123 op mul *tmp60 :fn2:zx :fn2:zx
 
  1133 label *label349
  1134 label *label350
  1135 label *label351
-    * op add :fn2:i :fn2:i 1
+ 1136 op add :fn2:i 60 1
  1137 label *label352
  1138 set :fn2:x1 :fn2:zx
  1139 op mul *tmp60 :fn2:zx :fn2:zx
 
  1149 label *label353
  1150 label *label354
  1151 label *label355
-    * op add :fn2:i :fn2:i 1
+ 1152 op add :fn2:i 61 1
  1153 label *label356
  1154 set :fn2:x1 :fn2:zx
  1155 op mul *tmp60 :fn2:zx :fn2:zx
 
  1165 label *label357
  1166 label *label358
  1167 label *label359
-    * op add :fn2:i :fn2:i 1
+ 1168 op add :fn2:i 62 1
  1169 label *label54
  1170 op mul *tmp70 .SMOOTH 63
  1171 jump *label57 greaterThanEq :fn2:i *tmp70

Modifications by Unroll iteration loop at *blocks:66:13:
 
    23 print "\nFound: "
    24 print :fn1:block
    25 sensor :fn1:type :fn1:block @type
-    * setaddr *tmp18 *label16
-    * set :fn1:requested @large-logic-display
-    * set :fn1:variable .display
-    * jump *label13 always
-    * gotolabel *label16 marker1
-    * set .display :fn1:variable
-    * setaddr *tmp18 *label17
-    * set :fn1:requested @memory-bank
-    * set :fn1:variable .memory
-    * label *label13
-    * jump *label18 notEqual :fn1:requested :fn1:type
-    * set :fn1:variable :fn1:block
-    * jump *label20 notEqual :fn1:requested @message
-    * set :fn1:message :fn1:block
-    * label *label20
-    * label *label21
-    * label *label18
-    * label *label19
-    * label *label14
-    * goto *tmp18 marker1
-    * gotolabel *label17 marker1
-    * set .memory :fn1:variable
-    * label *label15
+   26 set :fn1:requested @large-logic-display
+   27 set .display .display
+   28 label *label360
+   29 jump *label363 notEqual :fn1:requested :fn1:type
+   30 set .display :fn1:block
+   31 jump *label361 notEqual :fn1:requested @message
+   32 set :fn1:message :fn1:block
+   33 label *label361
+   34 label *label362
+   35 label *label363
+   36 label *label364
+   37 label *label365
+   38 set .display .display
+   39 set :fn1:requested @memory-bank
+   40 set .memory .memory
+   41 label *label368
+   42 jump *label371 notEqual :fn1:requested :fn1:type
+   43 set .memory :fn1:block
+   44 jump *label369 notEqual :fn1:requested @message
+   45 set :fn1:message :fn1:block
+   46 label *label369
+   47 label *label370
+   48 label *label371
+   49 label *label372
+   50 label *label373
+   51 set .memory .memory
+   52 label *label15
    53 label *label11
    54 jump *label93 greaterThan :fn1:n 0
    55 label *label12

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    26 set :fn1:requested @large-logic-display
    27 set .display .display
    28 label *label360
-    * jump *label363 notEqual :fn1:requested :fn1:type
+   29 jump *label363 notEqual @large-logic-display :fn1:type
    30 set .display :fn1:block
-    * jump *label361 notEqual :fn1:requested @message
+   31 jump *label361 notEqual @large-logic-display @message
    32 set :fn1:message :fn1:block
    33 label *label361
    34 label *label362
 
    39 set :fn1:requested @memory-bank
    40 set .memory .memory
    41 label *label368
-    * jump *label371 notEqual :fn1:requested :fn1:type
+   42 jump *label371 notEqual @memory-bank :fn1:type
    43 set .memory :fn1:block
-    * jump *label369 notEqual :fn1:requested @message
+   44 jump *label369 notEqual @memory-bank @message
    45 set :fn1:message :fn1:block
    46 label *label369
    47 label *label370

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    23 print "\nFound: "
    24 print :fn1:block
    25 sensor :fn1:type :fn1:block @type
-    * set :fn1:requested @large-logic-display
    26 set .display .display
    27 label *label360
    28 jump *label363 notEqual @large-logic-display :fn1:type
    29 set .display :fn1:block
    30 jump *label361 notEqual @large-logic-display @message
-    * set :fn1:message :fn1:block
    31 label *label361
    32 label *label362
    33 label *label363
    34 label *label364
    35 label *label365
    36 set .display .display
-    * set :fn1:requested @memory-bank
    37 set .memory .memory
    38 label *label368
    39 jump *label371 notEqual @memory-bank :fn1:type
    40 set .memory :fn1:block
    41 jump *label369 notEqual @memory-bank @message
-    * set :fn1:message :fn1:block
    42 label *label369
    43 label *label370
    44 label *label371
 
    74 gotolabel *label26 marker2
    75 set .memory :fn1:variable
    76 label *label24
-    * printflush :fn1:message
+   77 printflush null
    78 label *label3
    79 jump *label2 equal :fn1:foundAll false
    80 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
-    * set :fn1:message null
     7 label *label2
     8 label *label98
     9 label *label99

Modifications by Inline function 'setState' defined at mandelbrot-compute.mnd:208:1 (+9 instructions):
 
    82 set .BATCH 0
    83 label *label32
    84 set :fn0:state 0
-    * setaddr :fn0*retaddr *label35
-    * call *label0 :fn0*retval
-    * gotolabel *label35 :fn0
+   85 label *label377
+   86 label *label378
+   87 jump *label385 greaterThanEq .PROC_STATE_INDEX 512
+   88 label *label379
+   89 read *tmp129 .memory .PROC_ID_INDEX
+   90 jump *label380 notEqual *tmp129 .PROCESSOR_ID
+   91 write :fn0:state .memory .PROC_STATE_INDEX
+   92 jump *label385 always
+   93 jump *label383 always
+   94 label *label380
+   95 read *tmp135 .memory .PROC_ID_INDEX
+   96 jump *label381 notEqual *tmp135 0
+   97 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+   98 write :fn0:state .memory .PROC_STATE_INDEX
+   99 jump *label385 always
+  100 jump *label382 always
+  101 label *label381
+  102 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  103 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  104 label *label382
+  105 label *label383
+  106 label *label384
+  107 jump *label379 lessThan .PROC_STATE_INDEX 512
+  108 label *label385
+  109 label *label386
   110 label *label33
   111 read *tmp0 .memory 64
   112 jump *label32 equal .start *tmp0
 
   116 read *tmp1 .memory 65
   117 set .stop *tmp1
   118 set :fn0:state *tmp0
-    * setaddr :fn0*retaddr *label36
-    * call *label0 :fn0*retval
-    * gotolabel *label36 :fn0
+  119 label *label387
+  120 label *label388
+  121 jump *label395 greaterThanEq .PROC_STATE_INDEX 512
+  122 label *label389
+  123 read *tmp129 .memory .PROC_ID_INDEX
+  124 jump *label390 notEqual *tmp129 .PROCESSOR_ID
+  125 write :fn0:state .memory .PROC_STATE_INDEX
+  126 jump *label395 always
+  127 jump *label393 always
+  128 label *label390
+  129 read *tmp135 .memory .PROC_ID_INDEX
+  130 jump *label391 notEqual *tmp135 0
+  131 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  132 write :fn0:state .memory .PROC_STATE_INDEX
+  133 jump *label395 always
+  134 jump *label392 always
+  135 label *label391
+  136 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  137 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  138 label *label392
+  139 label *label393
+  140 label *label394
+  141 jump *label389 lessThan .PROC_STATE_INDEX 512
+  142 label *label395
+  143 label *label396
   144 read .ZOOM .memory 68
   145 op div *tmp27 -88 .ZOOM
   146 read *tmp2 .memory 66
 
  1326 jump *label29 always
  1327 label *label31
  1328 end
-    * label *label0
-    * label *label86
-    * jump *label88 greaterThanEq .PROC_STATE_INDEX 512
-    * label *label97
-    * read *tmp129 .memory .PROC_ID_INDEX
-    * jump *label89 notEqual *tmp129 .PROCESSOR_ID
-    * write :fn0:state .memory .PROC_STATE_INDEX
-    * jump *label88 always
-    * jump *label90 always
-    * label *label89
-    * read *tmp135 .memory .PROC_ID_INDEX
-    * jump *label91 notEqual *tmp135 0
-    * write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :fn0:state .memory .PROC_STATE_INDEX
-    * jump *label88 always
-    * jump *label92 always
-    * label *label91
-    * op add .PROC_ID_INDEX .PROC_ID_INDEX 2
-    * op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label92
-    * label *label90
-    * label *label87
-    * jump *label97 lessThan .PROC_STATE_INDEX 512
-    * label *label88
-    * label *label85
-    * goto :fn0*retaddr :fn0
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    88 label *label379
    89 read *tmp129 .memory .PROC_ID_INDEX
    90 jump *label380 notEqual *tmp129 .PROCESSOR_ID
-    * write :fn0:state .memory .PROC_STATE_INDEX
+   91 write 0 .memory .PROC_STATE_INDEX
    92 jump *label385 always
    93 jump *label383 always
    94 label *label380
    95 read *tmp135 .memory .PROC_ID_INDEX
    96 jump *label381 notEqual *tmp135 0
    97 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :fn0:state .memory .PROC_STATE_INDEX
+   98 write 0 .memory .PROC_STATE_INDEX
    99 jump *label385 always
   100 jump *label382 always
   101 label *label381
 
   122 label *label389
   123 read *tmp129 .memory .PROC_ID_INDEX
   124 jump *label390 notEqual *tmp129 .PROCESSOR_ID
-    * write :fn0:state .memory .PROC_STATE_INDEX
+  125 write *tmp0 .memory .PROC_STATE_INDEX
   126 jump *label395 always
   127 jump *label393 always
   128 label *label390
   129 read *tmp135 .memory .PROC_ID_INDEX
   130 jump *label391 notEqual *tmp135 0
   131 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :fn0:state .memory .PROC_STATE_INDEX
+  132 write *tmp0 .memory .PROC_STATE_INDEX
   133 jump *label395 always
   134 jump *label392 always
   135 label *label391

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    81 label *label29
    82 set .BATCH 0
    83 label *label32
-    * set :fn0:state 0
    84 label *label377
    85 label *label378
    86 jump *label385 greaterThanEq .PROC_STATE_INDEX 512
 
   114 set .start *tmp0
   115 read *tmp1 .memory 65
   116 set .stop *tmp1
-    * set :fn0:state *tmp0
   117 label *label387
   118 label *label388
   119 jump *label395 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Unroll iteration loop at *blocks:75:9 (+3 instructions):
 
    49 jump *label93 greaterThan :fn1:n 0
    50 label *label12
    51 set :fn1:foundAll 1
-    * setaddr *tmp23 *label25
-    * set :fn1:name "Display"
-    * set :fn1:variable .display
-    * jump *label22 always
-    * gotolabel *label25 marker2
-    * set .display :fn1:variable
-    * setaddr *tmp23 *label26
-    * set :fn1:name "Memory"
-    * set :fn1:variable .memory
-    * label *label22
-    * print "\n"
-    * print :fn1:name
-    * print ":"
-    * print " "
-    * print :fn1:variable
-    * jump *label27 equal true false
-    * op and :fn1:foundAll :fn1:foundAll :fn1:variable
-    * label *label27
-    * label *label28
-    * label *label23
-    * goto *tmp23 marker2
-    * gotolabel *label26 marker2
-    * set .memory :fn1:variable
-    * label *label24
+   52 set :fn1:name "Display"
+   53 set .display .display
+   54 label *label397
+   55 print "\n"
+   56 print :fn1:name
+   57 print ":"
+   58 print " "
+   59 print .display
+   60 jump *label398 equal true false
+   61 op and :fn1:foundAll :fn1:foundAll .display
+   62 label *label398
+   63 label *label399
+   64 label *label400
+   65 set .display .display
+   66 set :fn1:name "Memory"
+   67 set .memory .memory
+   68 label *label403
+   69 print "\n"
+   70 print :fn1:name
+   71 print ":"
+   72 print " "
+   73 print .memory
+   74 jump *label404 equal true false
+   75 op and :fn1:foundAll :fn1:foundAll .memory
+   76 label *label404
+   77 label *label405
+   78 label *label406
+   79 set .memory .memory
+   80 label *label24
    81 printflush null
    82 label *label3
    83 jump *label2 equal :fn1:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    53 set .display .display
    54 label *label397
    55 print "\n"
-    * print :fn1:name
+   56 print "Display"
    57 print ":"
    58 print " "
    59 print .display
    60 jump *label398 equal true false
-    * op and :fn1:foundAll :fn1:foundAll .display
+   61 op and :fn1:foundAll 1 .display
    62 label *label398
    63 label *label399
    64 label *label400
 
    67 set .memory .memory
    68 label *label403
    69 print "\n"
-    * print :fn1:name
+   70 print "Memory"
    71 print ":"
    72 print " "
    73 print .memory

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    48 label *label11
    49 jump *label93 greaterThan :fn1:n 0
    50 label *label12
-    * set :fn1:foundAll 1
-    * set :fn1:name "Display"
    51 set .display .display
    52 label *label397
    53 print "\n"
 
    61 label *label399
    62 label *label400
    63 set .display .display
-    * set :fn1:name "Memory"
    64 set .memory .memory
    65 label *label403
    66 print "\n"

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    26 label *label360
    27 jump *label363 notEqual @large-logic-display :fn1:type
    28 set .display :fn1:block
-    * jump *label361 notEqual @large-logic-display @message
+   29 jump *label361 always
    30 label *label361
    31 label *label362
    32 label *label363
 
    37 label *label368
    38 jump *label371 notEqual @memory-bank :fn1:type
    39 set .memory :fn1:block
-    * jump *label369 notEqual @memory-bank @message
+   40 jump *label369 always
    41 label *label369
    42 label *label370
    43 label *label371
 
    55 print ":"
    56 print " "
    57 print .display
-    * jump *label398 equal true false
    58 op and :fn1:foundAll 1 .display
    59 label *label398
    60 label *label399
 
    67 print ":"
    68 print " "
    69 print .memory
-    * jump *label404 equal true false
    70 op and :fn1:foundAll :fn1:foundAll .memory
    71 label *label404
    72 label *label405

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
    26 label *label360
    27 jump *label363 notEqual @large-logic-display :fn1:type
    28 set .display :fn1:block
-    * jump *label361 always
    29 label *label361
    30 label *label362
    31 label *label363
 
    36 label *label368
    37 jump *label371 notEqual @memory-bank :fn1:type
    38 set .memory :fn1:block
-    * jump *label369 always
    39 label *label369
    40 label *label370
    41 label *label371
 
  1217 label *label57
  1218 label *label58
  1219 set *tmp42 :fn2:i
-    * jump *label45 always
  1220 label *label45
  1221 jump *label60 equal .SMOOTH false
  1222 jump *label62 notEqual *tmp42 63

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-8 instructions):
 
    22 print "\nFound: "
    23 print :fn1:block
    24 sensor :fn1:type :fn1:block @type
-    * set .display .display
    25 label *label360
    26 jump *label363 notEqual @large-logic-display :fn1:type
    27 set .display :fn1:block
 
    30 label *label363
    31 label *label364
    32 label *label365
-    * set .display .display
-    * set .memory .memory
    33 label *label368
    34 jump *label371 notEqual @memory-bank :fn1:type
    35 set .memory :fn1:block
 
    38 label *label371
    39 label *label372
    40 label *label373
-    * set .memory .memory
    41 label *label15
    42 label *label11
    43 jump *label93 greaterThan :fn1:n 0
    44 label *label12
-    * set .display .display
    45 label *label397
    46 print "\n"
    47 print "Display"
 
    52 label *label398
    53 label *label399
    54 label *label400
-    * set .display .display
-    * set .memory .memory
    55 label *label403
    56 print "\n"
    57 print "Memory"
 
    62 label *label404
    63 label *label405
    64 label *label406
-    * set .memory .memory
    65 label *label24
    66 printflush null
    67 label *label3
 
   204 label *label109
   205 label *label110
   206 label *label111
-    * op add :fn2:i 0 1
+  207 set :fn2:i 1
   208 label *label112
   209 set :fn2:x1 :fn2:zx
   210 op mul *tmp60 :fn2:zx :fn2:zx

Modifications by Final phase, Jump Straightening, iteration 1 (-66 instructions):
 
   199 op mul *tmp65 *tmp64 :fn2:zy
   200 op add :fn2:zy *tmp65 :fn2:cy
   201 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label109 lessThan :fn2:dist 64
-    * jump *label54 always
+  202 jump *label54 greaterThanEq :fn2:dist 64
   203 label *label109
   204 label *label110
   205 label *label111
 
   214 op mul *tmp65 *tmp64 :fn2:zy
   215 op add :fn2:zy *tmp65 :fn2:cy
   216 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label113 lessThan :fn2:dist 64
-    * jump *label54 always
+  217 jump *label54 greaterThanEq :fn2:dist 64
   218 label *label113
   219 label *label114
   220 label *label115
 
   229 op mul *tmp65 *tmp64 :fn2:zy
   230 op add :fn2:zy *tmp65 :fn2:cy
   231 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label117 lessThan :fn2:dist 64
-    * jump *label54 always
+  232 jump *label54 greaterThanEq :fn2:dist 64
   233 label *label117
   234 label *label118
   235 label *label119
 
   244 op mul *tmp65 *tmp64 :fn2:zy
   245 op add :fn2:zy *tmp65 :fn2:cy
   246 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label121 lessThan :fn2:dist 64
-    * jump *label54 always
+  247 jump *label54 greaterThanEq :fn2:dist 64
   248 label *label121
   249 label *label122
   250 label *label123
 
   259 op mul *tmp65 *tmp64 :fn2:zy
   260 op add :fn2:zy *tmp65 :fn2:cy
   261 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label125 lessThan :fn2:dist 64
-    * jump *label54 always
+  262 jump *label54 greaterThanEq :fn2:dist 64
   263 label *label125
   264 label *label126
   265 label *label127
 
   274 op mul *tmp65 *tmp64 :fn2:zy
   275 op add :fn2:zy *tmp65 :fn2:cy
   276 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label129 lessThan :fn2:dist 64
-    * jump *label54 always
+  277 jump *label54 greaterThanEq :fn2:dist 64
   278 label *label129
   279 label *label130
   280 label *label131
 
   289 op mul *tmp65 *tmp64 :fn2:zy
   290 op add :fn2:zy *tmp65 :fn2:cy
   291 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label133 lessThan :fn2:dist 64
-    * jump *label54 always
+  292 jump *label54 greaterThanEq :fn2:dist 64
   293 label *label133
   294 label *label134
   295 label *label135
 
   304 op mul *tmp65 *tmp64 :fn2:zy
   305 op add :fn2:zy *tmp65 :fn2:cy
   306 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label137 lessThan :fn2:dist 64
-    * jump *label54 always
+  307 jump *label54 greaterThanEq :fn2:dist 64
   308 label *label137
   309 label *label138
   310 label *label139
 
   319 op mul *tmp65 *tmp64 :fn2:zy
   320 op add :fn2:zy *tmp65 :fn2:cy
   321 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label141 lessThan :fn2:dist 64
-    * jump *label54 always
+  322 jump *label54 greaterThanEq :fn2:dist 64
   323 label *label141
   324 label *label142
   325 label *label143
 
   334 op mul *tmp65 *tmp64 :fn2:zy
   335 op add :fn2:zy *tmp65 :fn2:cy
   336 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label145 lessThan :fn2:dist 64
-    * jump *label54 always
+  337 jump *label54 greaterThanEq :fn2:dist 64
   338 label *label145
   339 label *label146
   340 label *label147
 
   349 op mul *tmp65 *tmp64 :fn2:zy
   350 op add :fn2:zy *tmp65 :fn2:cy
   351 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label149 lessThan :fn2:dist 64
-    * jump *label54 always
+  352 jump *label54 greaterThanEq :fn2:dist 64
   353 label *label149
   354 label *label150
   355 label *label151
 
   364 op mul *tmp65 *tmp64 :fn2:zy
   365 op add :fn2:zy *tmp65 :fn2:cy
   366 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label153 lessThan :fn2:dist 64
-    * jump *label54 always
+  367 jump *label54 greaterThanEq :fn2:dist 64
   368 label *label153
   369 label *label154
   370 label *label155
 
   379 op mul *tmp65 *tmp64 :fn2:zy
   380 op add :fn2:zy *tmp65 :fn2:cy
   381 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label157 lessThan :fn2:dist 64
-    * jump *label54 always
+  382 jump *label54 greaterThanEq :fn2:dist 64
   383 label *label157
   384 label *label158
   385 label *label159
 
   394 op mul *tmp65 *tmp64 :fn2:zy
   395 op add :fn2:zy *tmp65 :fn2:cy
   396 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label161 lessThan :fn2:dist 64
-    * jump *label54 always
+  397 jump *label54 greaterThanEq :fn2:dist 64
   398 label *label161
   399 label *label162
   400 label *label163
 
   409 op mul *tmp65 *tmp64 :fn2:zy
   410 op add :fn2:zy *tmp65 :fn2:cy
   411 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label165 lessThan :fn2:dist 64
-    * jump *label54 always
+  412 jump *label54 greaterThanEq :fn2:dist 64
   413 label *label165
   414 label *label166
   415 label *label167
 
   424 op mul *tmp65 *tmp64 :fn2:zy
   425 op add :fn2:zy *tmp65 :fn2:cy
   426 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label169 lessThan :fn2:dist 64
-    * jump *label54 always
+  427 jump *label54 greaterThanEq :fn2:dist 64
   428 label *label169
   429 label *label170
   430 label *label171
 
   439 op mul *tmp65 *tmp64 :fn2:zy
   440 op add :fn2:zy *tmp65 :fn2:cy
   441 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label173 lessThan :fn2:dist 64
-    * jump *label54 always
+  442 jump *label54 greaterThanEq :fn2:dist 64
   443 label *label173
   444 label *label174
   445 label *label175
 
   454 op mul *tmp65 *tmp64 :fn2:zy
   455 op add :fn2:zy *tmp65 :fn2:cy
   456 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label177 lessThan :fn2:dist 64
-    * jump *label54 always
+  457 jump *label54 greaterThanEq :fn2:dist 64
   458 label *label177
   459 label *label178
   460 label *label179
 
   469 op mul *tmp65 *tmp64 :fn2:zy
   470 op add :fn2:zy *tmp65 :fn2:cy
   471 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label181 lessThan :fn2:dist 64
-    * jump *label54 always
+  472 jump *label54 greaterThanEq :fn2:dist 64
   473 label *label181
   474 label *label182
   475 label *label183
 
   484 op mul *tmp65 *tmp64 :fn2:zy
   485 op add :fn2:zy *tmp65 :fn2:cy
   486 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label185 lessThan :fn2:dist 64
-    * jump *label54 always
+  487 jump *label54 greaterThanEq :fn2:dist 64
   488 label *label185
   489 label *label186
   490 label *label187
 
   499 op mul *tmp65 *tmp64 :fn2:zy
   500 op add :fn2:zy *tmp65 :fn2:cy
   501 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label189 lessThan :fn2:dist 64
-    * jump *label54 always
+  502 jump *label54 greaterThanEq :fn2:dist 64
   503 label *label189
   504 label *label190
   505 label *label191
 
   514 op mul *tmp65 *tmp64 :fn2:zy
   515 op add :fn2:zy *tmp65 :fn2:cy
   516 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label193 lessThan :fn2:dist 64
-    * jump *label54 always
+  517 jump *label54 greaterThanEq :fn2:dist 64
   518 label *label193
   519 label *label194
   520 label *label195
 
   529 op mul *tmp65 *tmp64 :fn2:zy
   530 op add :fn2:zy *tmp65 :fn2:cy
   531 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label197 lessThan :fn2:dist 64
-    * jump *label54 always
+  532 jump *label54 greaterThanEq :fn2:dist 64
   533 label *label197
   534 label *label198
   535 label *label199
 
   544 op mul *tmp65 *tmp64 :fn2:zy
   545 op add :fn2:zy *tmp65 :fn2:cy
   546 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label201 lessThan :fn2:dist 64
-    * jump *label54 always
+  547 jump *label54 greaterThanEq :fn2:dist 64
   548 label *label201
   549 label *label202
   550 label *label203
 
   559 op mul *tmp65 *tmp64 :fn2:zy
   560 op add :fn2:zy *tmp65 :fn2:cy
   561 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label205 lessThan :fn2:dist 64
-    * jump *label54 always
+  562 jump *label54 greaterThanEq :fn2:dist 64
   563 label *label205
   564 label *label206
   565 label *label207
 
   574 op mul *tmp65 *tmp64 :fn2:zy
   575 op add :fn2:zy *tmp65 :fn2:cy
   576 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label209 lessThan :fn2:dist 64
-    * jump *label54 always
+  577 jump *label54 greaterThanEq :fn2:dist 64
   578 label *label209
   579 label *label210
   580 label *label211
 
   589 op mul *tmp65 *tmp64 :fn2:zy
   590 op add :fn2:zy *tmp65 :fn2:cy
   591 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label213 lessThan :fn2:dist 64
-    * jump *label54 always
+  592 jump *label54 greaterThanEq :fn2:dist 64
   593 label *label213
   594 label *label214
   595 label *label215
 
   604 op mul *tmp65 *tmp64 :fn2:zy
   605 op add :fn2:zy *tmp65 :fn2:cy
   606 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label217 lessThan :fn2:dist 64
-    * jump *label54 always
+  607 jump *label54 greaterThanEq :fn2:dist 64
   608 label *label217
   609 label *label218
   610 label *label219
 
   619 op mul *tmp65 *tmp64 :fn2:zy
   620 op add :fn2:zy *tmp65 :fn2:cy
   621 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label221 lessThan :fn2:dist 64
-    * jump *label54 always
+  622 jump *label54 greaterThanEq :fn2:dist 64
   623 label *label221
   624 label *label222
   625 label *label223
 
   634 op mul *tmp65 *tmp64 :fn2:zy
   635 op add :fn2:zy *tmp65 :fn2:cy
   636 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label225 lessThan :fn2:dist 64
-    * jump *label54 always
+  637 jump *label54 greaterThanEq :fn2:dist 64
   638 label *label225
   639 label *label226
   640 label *label227
 
   649 op mul *tmp65 *tmp64 :fn2:zy
   650 op add :fn2:zy *tmp65 :fn2:cy
   651 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label229 lessThan :fn2:dist 64
-    * jump *label54 always
+  652 jump *label54 greaterThanEq :fn2:dist 64
   653 label *label229
   654 label *label230
   655 label *label231
 
   664 op mul *tmp65 *tmp64 :fn2:zy
   665 op add :fn2:zy *tmp65 :fn2:cy
   666 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label233 lessThan :fn2:dist 64
-    * jump *label54 always
+  667 jump *label54 greaterThanEq :fn2:dist 64
   668 label *label233
   669 label *label234
   670 label *label235
 
   679 op mul *tmp65 *tmp64 :fn2:zy
   680 op add :fn2:zy *tmp65 :fn2:cy
   681 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label237 lessThan :fn2:dist 64
-    * jump *label54 always
+  682 jump *label54 greaterThanEq :fn2:dist 64
   683 label *label237
   684 label *label238
   685 label *label239
 
   694 op mul *tmp65 *tmp64 :fn2:zy
   695 op add :fn2:zy *tmp65 :fn2:cy
   696 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label241 lessThan :fn2:dist 64
-    * jump *label54 always
+  697 jump *label54 greaterThanEq :fn2:dist 64
   698 label *label241
   699 label *label242
   700 label *label243
 
   709 op mul *tmp65 *tmp64 :fn2:zy
   710 op add :fn2:zy *tmp65 :fn2:cy
   711 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label245 lessThan :fn2:dist 64
-    * jump *label54 always
+  712 jump *label54 greaterThanEq :fn2:dist 64
   713 label *label245
   714 label *label246
   715 label *label247
 
   724 op mul *tmp65 *tmp64 :fn2:zy
   725 op add :fn2:zy *tmp65 :fn2:cy
   726 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label249 lessThan :fn2:dist 64
-    * jump *label54 always
+  727 jump *label54 greaterThanEq :fn2:dist 64
   728 label *label249
   729 label *label250
   730 label *label251
 
   739 op mul *tmp65 *tmp64 :fn2:zy
   740 op add :fn2:zy *tmp65 :fn2:cy
   741 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label253 lessThan :fn2:dist 64
-    * jump *label54 always
+  742 jump *label54 greaterThanEq :fn2:dist 64
   743 label *label253
   744 label *label254
   745 label *label255
 
   754 op mul *tmp65 *tmp64 :fn2:zy
   755 op add :fn2:zy *tmp65 :fn2:cy
   756 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label257 lessThan :fn2:dist 64
-    * jump *label54 always
+  757 jump *label54 greaterThanEq :fn2:dist 64
   758 label *label257
   759 label *label258
   760 label *label259
 
   769 op mul *tmp65 *tmp64 :fn2:zy
   770 op add :fn2:zy *tmp65 :fn2:cy
   771 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label261 lessThan :fn2:dist 64
-    * jump *label54 always
+  772 jump *label54 greaterThanEq :fn2:dist 64
   773 label *label261
   774 label *label262
   775 label *label263
 
   784 op mul *tmp65 *tmp64 :fn2:zy
   785 op add :fn2:zy *tmp65 :fn2:cy
   786 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label265 lessThan :fn2:dist 64
-    * jump *label54 always
+  787 jump *label54 greaterThanEq :fn2:dist 64
   788 label *label265
   789 label *label266
   790 label *label267
 
   799 op mul *tmp65 *tmp64 :fn2:zy
   800 op add :fn2:zy *tmp65 :fn2:cy
   801 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label269 lessThan :fn2:dist 64
-    * jump *label54 always
+  802 jump *label54 greaterThanEq :fn2:dist 64
   803 label *label269
   804 label *label270
   805 label *label271
 
   814 op mul *tmp65 *tmp64 :fn2:zy
   815 op add :fn2:zy *tmp65 :fn2:cy
   816 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label273 lessThan :fn2:dist 64
-    * jump *label54 always
+  817 jump *label54 greaterThanEq :fn2:dist 64
   818 label *label273
   819 label *label274
   820 label *label275
 
   829 op mul *tmp65 *tmp64 :fn2:zy
   830 op add :fn2:zy *tmp65 :fn2:cy
   831 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label277 lessThan :fn2:dist 64
-    * jump *label54 always
+  832 jump *label54 greaterThanEq :fn2:dist 64
   833 label *label277
   834 label *label278
   835 label *label279
 
   844 op mul *tmp65 *tmp64 :fn2:zy
   845 op add :fn2:zy *tmp65 :fn2:cy
   846 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label281 lessThan :fn2:dist 64
-    * jump *label54 always
+  847 jump *label54 greaterThanEq :fn2:dist 64
   848 label *label281
   849 label *label282
   850 label *label283
 
   859 op mul *tmp65 *tmp64 :fn2:zy
   860 op add :fn2:zy *tmp65 :fn2:cy
   861 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label285 lessThan :fn2:dist 64
-    * jump *label54 always
+  862 jump *label54 greaterThanEq :fn2:dist 64
   863 label *label285
   864 label *label286
   865 label *label287
 
   874 op mul *tmp65 *tmp64 :fn2:zy
   875 op add :fn2:zy *tmp65 :fn2:cy
   876 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label289 lessThan :fn2:dist 64
-    * jump *label54 always
+  877 jump *label54 greaterThanEq :fn2:dist 64
   878 label *label289
   879 label *label290
   880 label *label291
 
   889 op mul *tmp65 *tmp64 :fn2:zy
   890 op add :fn2:zy *tmp65 :fn2:cy
   891 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label293 lessThan :fn2:dist 64
-    * jump *label54 always
+  892 jump *label54 greaterThanEq :fn2:dist 64
   893 label *label293
   894 label *label294
   895 label *label295
 
   904 op mul *tmp65 *tmp64 :fn2:zy
   905 op add :fn2:zy *tmp65 :fn2:cy
   906 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label297 lessThan :fn2:dist 64
-    * jump *label54 always
+  907 jump *label54 greaterThanEq :fn2:dist 64
   908 label *label297
   909 label *label298
   910 label *label299
 
   919 op mul *tmp65 *tmp64 :fn2:zy
   920 op add :fn2:zy *tmp65 :fn2:cy
   921 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label301 lessThan :fn2:dist 64
-    * jump *label54 always
+  922 jump *label54 greaterThanEq :fn2:dist 64
   923 label *label301
   924 label *label302
   925 label *label303
 
   934 op mul *tmp65 *tmp64 :fn2:zy
   935 op add :fn2:zy *tmp65 :fn2:cy
   936 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label305 lessThan :fn2:dist 64
-    * jump *label54 always
+  937 jump *label54 greaterThanEq :fn2:dist 64
   938 label *label305
   939 label *label306
   940 label *label307
 
   949 op mul *tmp65 *tmp64 :fn2:zy
   950 op add :fn2:zy *tmp65 :fn2:cy
   951 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label309 lessThan :fn2:dist 64
-    * jump *label54 always
+  952 jump *label54 greaterThanEq :fn2:dist 64
   953 label *label309
   954 label *label310
   955 label *label311
 
   964 op mul *tmp65 *tmp64 :fn2:zy
   965 op add :fn2:zy *tmp65 :fn2:cy
   966 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label313 lessThan :fn2:dist 64
-    * jump *label54 always
+  967 jump *label54 greaterThanEq :fn2:dist 64
   968 label *label313
   969 label *label314
   970 label *label315
 
   979 op mul *tmp65 *tmp64 :fn2:zy
   980 op add :fn2:zy *tmp65 :fn2:cy
   981 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label317 lessThan :fn2:dist 64
-    * jump *label54 always
+  982 jump *label54 greaterThanEq :fn2:dist 64
   983 label *label317
   984 label *label318
   985 label *label319
 
   994 op mul *tmp65 *tmp64 :fn2:zy
   995 op add :fn2:zy *tmp65 :fn2:cy
   996 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label321 lessThan :fn2:dist 64
-    * jump *label54 always
+  997 jump *label54 greaterThanEq :fn2:dist 64
   998 label *label321
   999 label *label322
  1000 label *label323
 
  1009 op mul *tmp65 *tmp64 :fn2:zy
  1010 op add :fn2:zy *tmp65 :fn2:cy
  1011 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label325 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1012 jump *label54 greaterThanEq :fn2:dist 64
  1013 label *label325
  1014 label *label326
  1015 label *label327
 
  1024 op mul *tmp65 *tmp64 :fn2:zy
  1025 op add :fn2:zy *tmp65 :fn2:cy
  1026 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label329 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1027 jump *label54 greaterThanEq :fn2:dist 64
  1028 label *label329
  1029 label *label330
  1030 label *label331
 
  1039 op mul *tmp65 *tmp64 :fn2:zy
  1040 op add :fn2:zy *tmp65 :fn2:cy
  1041 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label333 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1042 jump *label54 greaterThanEq :fn2:dist 64
  1043 label *label333
  1044 label *label334
  1045 label *label335
 
  1054 op mul *tmp65 *tmp64 :fn2:zy
  1055 op add :fn2:zy *tmp65 :fn2:cy
  1056 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label337 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1057 jump *label54 greaterThanEq :fn2:dist 64
  1058 label *label337
  1059 label *label338
  1060 label *label339
 
  1069 op mul *tmp65 *tmp64 :fn2:zy
  1070 op add :fn2:zy *tmp65 :fn2:cy
  1071 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label341 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1072 jump *label54 greaterThanEq :fn2:dist 64
  1073 label *label341
  1074 label *label342
  1075 label *label343
 
  1084 op mul *tmp65 *tmp64 :fn2:zy
  1085 op add :fn2:zy *tmp65 :fn2:cy
  1086 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label345 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1087 jump *label54 greaterThanEq :fn2:dist 64
  1088 label *label345
  1089 label *label346
  1090 label *label347
 
  1099 op mul *tmp65 *tmp64 :fn2:zy
  1100 op add :fn2:zy *tmp65 :fn2:cy
  1101 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label349 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1102 jump *label54 greaterThanEq :fn2:dist 64
  1103 label *label349
  1104 label *label350
  1105 label *label351
 
  1114 op mul *tmp65 *tmp64 :fn2:zy
  1115 op add :fn2:zy *tmp65 :fn2:cy
  1116 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label353 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1117 jump *label54 greaterThanEq :fn2:dist 64
  1118 label *label353
  1119 label *label354
  1120 label *label355
 
  1129 op mul *tmp65 *tmp64 :fn2:zy
  1130 op add :fn2:zy *tmp65 :fn2:cy
  1131 op len :fn2:dist :fn2:zx :fn2:zy
-    * jump *label357 lessThan :fn2:dist 64
-    * jump *label54 always
+ 1132 jump *label54 greaterThanEq :fn2:dist 64
  1133 label *label357
  1134 label *label358
  1135 label *label359
 
  1201 label *label61
  1202 draw rect :x :y 1 1
  1203 op add .BATCH .BATCH 1
-    * jump *label71 greaterThanEq .BATCH 44
-    * jump *label59 always
+ 1204 jump *label59 lessThan .BATCH 44
  1205 label *label71
  1206 label *label72
  1207 label *label73
 
  1218 set .BATCH 0
  1219 label *label59
  1220 read *tmp119 .memory :position
-    * jump *label79 equal *tmp119 .PROCESSOR_ID
-    * jump *label44 always
+ 1221 jump *label44 notEqual *tmp119 .PROCESSOR_ID
  1222 label *label79
  1223 label *label80
  1224 read *tmp1 .memory 65
-    * jump *label81 equal .stop *tmp1
-    * jump *label39 always
+ 1225 jump *label39 notEqual .stop *tmp1
  1226 label *label81
  1227 label *label82
  1228 label *label43

Modifications by Final phase, Jump Threading, iteration 1:
 
  1150 jump *label60 equal .SMOOTH false
  1151 jump *label62 notEqual *tmp42 63
  1152 draw color 0 0 0 255
-    * jump *label63 always
+ 1153 jump *label61 always
  1154 label *label62
  1155 jump *label65 notEqual .PALETTE 2
  1156 label *label66
 
  1165 op mul *tmp93 4 *tmp84
  1166 op add :fn3:b 120 *tmp93
  1167 draw color :fn3:r :fn3:g :fn3:b 255
-    * jump *label64 always
+ 1168 jump *label61 always
  1169 label *label65
  1170 jump *label67 notEqual .PALETTE 3
  1171 label *label68
 
  1179 op mul *tmp105 4 *tmp104
  1180 op add :fn3:b 100 *tmp105
  1181 draw color :fn3:r :fn3:g :fn3:b 255
-    * jump *label64 always
+ 1182 jump *label61 always
  1183 label *label67
  1184 jump *label69 notEqual .PALETTE 4
  1185 label *label70
 
  1187 op mul *tmp108 1.5 *tmp42
  1188 op add :fn3:g 96 *tmp108
  1189 draw color :fn3:r :fn3:g 0 255
-    * jump *label64 always
+ 1190 jump *label61 always
  1191 label *label69
  1192 op mul *tmp110 4 *tmp42
  1193 op sub :fn3:r 255 *tmp110

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-5 instructions):
 
    79 jump *label380 notEqual *tmp129 .PROCESSOR_ID
    80 write 0 .memory .PROC_STATE_INDEX
    81 jump *label385 always
-    * jump *label383 always
    82 label *label380
    83 read *tmp135 .memory .PROC_ID_INDEX
    84 jump *label381 notEqual *tmp135 0
    85 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    86 write 0 .memory .PROC_STATE_INDEX
    87 jump *label385 always
-    * jump *label382 always
    88 label *label381
    89 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    90 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
   110 jump *label390 notEqual *tmp129 .PROCESSOR_ID
   111 write *tmp0 .memory .PROC_STATE_INDEX
   112 jump *label395 always
-    * jump *label393 always
   113 label *label390
   114 read *tmp135 .memory .PROC_ID_INDEX
   115 jump *label391 notEqual *tmp135 0
   116 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   117 write *tmp0 .memory .PROC_STATE_INDEX
   118 jump *label395 always
-    * jump *label392 always
   119 label *label391
   120 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   121 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
  1241 drawflush .display
  1242 label *label30
  1243 jump *label29 always
-    * label *label31
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-6 instructions):
 
    43 jump *label93 greaterThan :fn1:n 0
    44 label *label12
    45 label *label397
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
+   46 print "\nDisplay: "
    47 print .display
    48 op and :fn1:foundAll 1 .display
    49 label *label398
    50 label *label399
    51 label *label400
    52 label *label403
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
+   53 print "\nMemory: "
    54 print .memory
    55 op and :fn1:foundAll :fn1:foundAll .memory
    56 label *label404

Final code before resolving virtual instructions:

    0:  set *tmp10 @thisx                                            mandelbrot-compute.mnd: var PROCESSOR_ID = @this.@x + 10000 * @this.@y;
    1:  set *tmp11 @thisy                                            ...
    2:  op mul *tmp12 10000 *tmp11                                   ...
    3:  op add .PROCESSOR_ID *tmp10 *tmp12                           ...
    4:  set .PROC_ID_INDEX 334                                       mandelbrot-compute.mnd: var PROC_ID_INDEX = PROCESSORS;
    5:  set .PROC_STATE_INDEX 335                                    mandelbrot-compute.mnd: var PROC_STATE_INDEX = PROCESSORS + 1;
    6:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label2                                                *blocks: do
    7:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    8:  set .memory null                                             ...
    9:  print "Mandelbrot Generator"                                 *blocks: print(title);
   10:  set :fn1:n @links                                            *blocks: var n = @links;
   11:  jump *label12 lessThanEq :fn1:n 0                            *blocks: while n > 0 do
        label *label93                                               ...
   12:  op sub :fn1:n :fn1:n 1                                       *blocks: var block = getlink(--n);
   13:  getlink :fn1:block :fn1:n                                    ...
   14:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
   15:  print :fn1:block                                             ...
   16:  sensor :fn1:type :fn1:block @type                            *blocks: var type = block.@type;
   17:  jump *label363 notEqual @large-logic-display :fn1:type       *blocks: if requested == type then
   18:  set .display :fn1:block                                      *blocks: variable = block;
        label *label363                                              *blocks: if requested == type then
   19:  jump *label371 notEqual @memory-bank :fn1:type               ...
   20:  set .memory :fn1:block                                       *blocks: variable = block;
        label *label371                                              *blocks: if requested == type then
   21:  jump *label93 greaterThan :fn1:n 0                           *blocks: while n > 0 do
        label *label12                                               ...
   22:  print "\nDisplay: "                                          *blocks: print($"\n$name: $variable");
   23:  print .display                                               ...
   24:  op and :fn1:foundAll 1 .display                              *blocks: if required then foundAll &= variable; end;
   25:  print "\nMemory: "                                           *blocks: print($"\n$name: $variable");
   26:  print .memory                                                ...
   27:  op and :fn1:foundAll :fn1:foundAll .memory                   *blocks: if required then foundAll &= variable; end;
   28:  printflush null                                              *blocks: printflush(message);
   29:  jump *label2 equal :fn1:foundAll false                       *blocks: do
        label *label29                                               mandelbrot-compute.mnd: while true do
   30:  set .BATCH 0                                                 mandelbrot-compute.mnd: BATCH = 0;
        label *label32                                               mandelbrot-compute.mnd: do
   31:  jump *label385 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label379                                              ...
   32:  read *tmp129 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   33:  jump *label380 notEqual *tmp129 .PROCESSOR_ID                ...
   34:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   35:  jump *label385 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label380                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   36:  read *tmp135 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   37:  jump *label381 notEqual *tmp135 0                            ...
   38:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   39:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   40:  jump *label385 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label381                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   41:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   42:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   43:  jump *label379 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label385                                              ...
   44:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: while start == $START;
   45:  jump *label32 equal .start *tmp0                             mandelbrot-compute.mnd: do
   46:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: start = $START;
   47:  set .start *tmp0                                             ...
   48:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: stop = $STOP;
   49:  set .stop *tmp1                                              ...
   50:  jump *label395 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label389                                              ...
   51:  read *tmp129 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   52:  jump *label390 notEqual *tmp129 .PROCESSOR_ID                ...
   53:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   54:  jump *label395 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label390                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   55:  read *tmp135 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   56:  jump *label391 notEqual *tmp135 0                            ...
   57:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   58:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   59:  jump *label395 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label391                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   60:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   61:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   62:  jump *label389 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label395                                              ...
   63:  read .ZOOM .memory 68                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   64:  op div *tmp27 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   65:  read *tmp2 .memory 66                                        ...
   66:  op add .OFFSET_X *tmp27 *tmp2                                ...
   67:  read *tmp3 .memory 67                                        mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   68:  op add .OFFSET_Y *tmp27 *tmp3                                ...
   69:  read .JULIA .memory 69                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   70:  read .JULIA_X .memory 70                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   71:  read .JULIA_Y .memory 71                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   72:  read .PALETTE .memory 72                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   73:  op greaterThan .SMOOTH .PALETTE 1                            mandelbrot-compute.mnd: SMOOTH   = PALETTE > 1;
   74:  set :line 8                                                  mandelbrot-compute.mnd: var line = 8;
   75:  set :increment 8                                             mandelbrot-compute.mnd: var increment = 8;
   76:  set :next_increment 16                                       mandelbrot-compute.mnd: var next_increment = 16;
   77:  op rand *tmp32 0.1 0                                         mandelbrot-compute.mnd: wait(rand(0.1));
   78:  wait *tmp32                                                  ...
   79:  set :lines 0                                                 mandelbrot-compute.mnd: MasterLoop:
        label *label94                                               ...
   80:  op mul *tmp33 17 :line                                       mandelbrot-compute.mnd: var x = (SKIP * line) % DISPLAY_SIZE_LARGE;
   81:  op mod :x *tmp33 176                                         ...
   82:  op add :position :x 158                                      mandelbrot-compute.mnd: var position = x + SLOTS;
   83:  read *tmp37 .memory :position                                mandelbrot-compute.mnd: if memory[position] == 0 then
   84:  jump *label40 notEqual *tmp37 0                              ...
   85:  write .PROCESSOR_ID .memory :position                        mandelbrot-compute.mnd: memory[position] = PROCESSOR_ID;
   86:  set :y 0                                                     mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
        label *label95                                               ...
   87:  op div *tmp43 :x .ZOOM                                       mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   88:  op add :fn2:zx *tmp43 .OFFSET_X                              ...
   89:  op div *tmp45 :y .ZOOM                                       mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   90:  op add :fn2:zy *tmp45 .OFFSET_Y                              ...
   91:  jump *label46 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   92:  set :fn2:cx .JULIA_X                                         mandelbrot-compute.mnd: cx = JULIA_X;
   93:  set :fn2:cy .JULIA_Y                                         mandelbrot-compute.mnd: cy = JULIA_Y;
   94:  jump *label47 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label46                                               ...
   95:  set :fn2:cx :fn2:zx                                          mandelbrot-compute.mnd: cx = zx;
   96:  set :fn2:cy :fn2:zy                                          mandelbrot-compute.mnd: cy = zy;
   97:  op sub *tmp48 :fn2:zx 0.25                                   mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   98:  op len :fn2:p *tmp48 :fn2:zy                                 ...
   99:  op mul *tmp50 2 :fn2:p                                       mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  100:  op mul *tmp51 *tmp50 :fn2:p                                  ...
  101:  op sub *tmp52 :fn2:p *tmp51                                  ...
  102:  op add *tmp53 *tmp52 0.25                                    ...
  103:  jump *label48 greaterThan :fn2:zx *tmp53                     ...
  104:  set *tmp42 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  105:  jump *label45 always 0 0                                     ...
        label *label48                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  106:  op add *tmp56 :fn2:zx 1                                      mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  107:  op len *tmp57 *tmp56 :fn2:zy                                 ...
  108:  jump *label50 greaterThan *tmp57 0.25                        ...
  109:  set *tmp42 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  110:  jump *label45 always 0 0                                     ...
        label *label50                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label47                                               mandelbrot-compute.mnd: if JULIA then
  111:  set :fn2:i 0                                                 mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  112:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  113:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  114:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  115:  op sub *tmp62 *tmp60 *tmp61                                  ...
  116:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  117:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  118:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  119:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  120:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  121:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  122:  set :fn2:i 1                                                 mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  123:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  124:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  125:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  126:  op sub *tmp62 *tmp60 *tmp61                                  ...
  127:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  128:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  129:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  130:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  131:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  132:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  133:  op add :fn2:i 1 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  134:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  135:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  136:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  137:  op sub *tmp62 *tmp60 *tmp61                                  ...
  138:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  139:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  140:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  141:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  142:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  143:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  144:  op add :fn2:i 2 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  145:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  146:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  147:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  148:  op sub *tmp62 *tmp60 *tmp61                                  ...
  149:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  150:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  151:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  152:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  153:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  154:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  155:  op add :fn2:i 3 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  156:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  157:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  158:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  159:  op sub *tmp62 *tmp60 *tmp61                                  ...
  160:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  161:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  162:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  163:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  164:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  165:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  166:  op add :fn2:i 4 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  167:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  168:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  169:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  170:  op sub *tmp62 *tmp60 *tmp61                                  ...
  171:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  172:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  173:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  174:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  175:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  176:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  177:  op add :fn2:i 5 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  178:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  179:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  180:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  181:  op sub *tmp62 *tmp60 *tmp61                                  ...
  182:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  183:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  184:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  185:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  186:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  187:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  188:  op add :fn2:i 6 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  189:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  190:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  191:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  192:  op sub *tmp62 *tmp60 *tmp61                                  ...
  193:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  194:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  195:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  196:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  197:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  198:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  199:  op add :fn2:i 7 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  200:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  201:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  202:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  203:  op sub *tmp62 *tmp60 *tmp61                                  ...
  204:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  205:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  206:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  207:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  208:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  209:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  210:  op add :fn2:i 8 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  211:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  212:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  213:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  214:  op sub *tmp62 *tmp60 *tmp61                                  ...
  215:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  216:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  217:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  218:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  219:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  220:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  221:  op add :fn2:i 9 1                                            mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  222:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  223:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  224:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  225:  op sub *tmp62 *tmp60 *tmp61                                  ...
  226:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  227:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  228:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  229:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  230:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  231:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  232:  op add :fn2:i 10 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  233:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  234:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  235:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  236:  op sub *tmp62 *tmp60 *tmp61                                  ...
  237:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  238:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  239:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  240:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  241:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  242:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  243:  op add :fn2:i 11 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  244:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  245:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  246:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  247:  op sub *tmp62 *tmp60 *tmp61                                  ...
  248:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  249:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  250:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  251:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  252:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  253:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  254:  op add :fn2:i 12 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  255:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  256:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  257:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  258:  op sub *tmp62 *tmp60 *tmp61                                  ...
  259:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  260:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  261:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  262:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  263:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  264:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  265:  op add :fn2:i 13 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  266:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  267:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  268:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  269:  op sub *tmp62 *tmp60 *tmp61                                  ...
  270:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  271:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  272:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  273:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  274:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  275:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  276:  op add :fn2:i 14 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  277:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  278:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  279:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  280:  op sub *tmp62 *tmp60 *tmp61                                  ...
  281:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  282:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  283:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  284:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  285:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  286:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  287:  op add :fn2:i 15 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  288:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  289:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  290:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  291:  op sub *tmp62 *tmp60 *tmp61                                  ...
  292:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  293:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  294:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  295:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  296:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  297:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  298:  op add :fn2:i 16 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  299:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  300:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  301:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  302:  op sub *tmp62 *tmp60 *tmp61                                  ...
  303:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  304:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  305:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  306:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  307:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  308:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  309:  op add :fn2:i 17 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  310:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  311:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  312:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  313:  op sub *tmp62 *tmp60 *tmp61                                  ...
  314:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  315:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  316:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  317:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  318:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  319:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  320:  op add :fn2:i 18 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  321:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  322:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  323:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  324:  op sub *tmp62 *tmp60 *tmp61                                  ...
  325:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  326:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  327:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  328:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  329:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  330:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  331:  op add :fn2:i 19 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  332:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  333:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  334:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  335:  op sub *tmp62 *tmp60 *tmp61                                  ...
  336:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  337:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  338:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  339:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  340:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  341:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  342:  op add :fn2:i 20 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  343:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  344:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  345:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  346:  op sub *tmp62 *tmp60 *tmp61                                  ...
  347:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  348:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  349:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  350:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  351:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  352:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  353:  op add :fn2:i 21 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  354:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  355:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  356:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  357:  op sub *tmp62 *tmp60 *tmp61                                  ...
  358:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  359:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  360:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  361:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  362:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  363:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  364:  op add :fn2:i 22 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  365:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  366:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  367:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  368:  op sub *tmp62 *tmp60 *tmp61                                  ...
  369:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  370:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  371:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  372:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  373:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  374:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  375:  op add :fn2:i 23 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  376:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  377:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  378:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  379:  op sub *tmp62 *tmp60 *tmp61                                  ...
  380:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  381:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  382:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  383:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  384:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  385:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  386:  op add :fn2:i 24 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  387:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  388:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  389:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  390:  op sub *tmp62 *tmp60 *tmp61                                  ...
  391:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  392:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  393:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  394:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  395:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  396:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  397:  op add :fn2:i 25 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  398:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  399:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  400:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  401:  op sub *tmp62 *tmp60 *tmp61                                  ...
  402:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  403:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  404:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  405:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  406:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  407:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  408:  op add :fn2:i 26 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  409:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  410:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  411:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  412:  op sub *tmp62 *tmp60 *tmp61                                  ...
  413:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  414:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  415:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  416:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  417:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  418:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  419:  op add :fn2:i 27 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  420:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  421:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  422:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  423:  op sub *tmp62 *tmp60 *tmp61                                  ...
  424:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  425:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  426:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  427:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  428:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  429:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  430:  op add :fn2:i 28 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  431:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  432:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  433:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  434:  op sub *tmp62 *tmp60 *tmp61                                  ...
  435:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  436:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  437:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  438:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  439:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  440:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  441:  op add :fn2:i 29 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  442:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  443:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  444:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  445:  op sub *tmp62 *tmp60 *tmp61                                  ...
  446:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  447:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  448:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  449:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  450:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  451:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  452:  op add :fn2:i 30 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  453:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  454:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  455:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  456:  op sub *tmp62 *tmp60 *tmp61                                  ...
  457:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  458:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  459:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  460:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  461:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  462:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  463:  op add :fn2:i 31 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  464:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  465:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  466:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  467:  op sub *tmp62 *tmp60 *tmp61                                  ...
  468:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  469:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  470:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  471:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  472:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  473:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  474:  op add :fn2:i 32 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  475:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  476:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  477:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  478:  op sub *tmp62 *tmp60 *tmp61                                  ...
  479:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  480:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  481:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  482:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  483:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  484:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  485:  op add :fn2:i 33 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  486:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  487:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  488:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  489:  op sub *tmp62 *tmp60 *tmp61                                  ...
  490:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  491:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  492:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  493:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  494:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  495:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  496:  op add :fn2:i 34 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  497:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  498:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  499:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  500:  op sub *tmp62 *tmp60 *tmp61                                  ...
  501:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  502:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  503:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  504:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  505:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  506:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  507:  op add :fn2:i 35 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  508:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  509:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  510:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  511:  op sub *tmp62 *tmp60 *tmp61                                  ...
  512:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  513:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  514:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  515:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  516:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  517:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  518:  op add :fn2:i 36 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  519:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  520:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  521:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  522:  op sub *tmp62 *tmp60 *tmp61                                  ...
  523:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  524:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  525:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  526:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  527:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  528:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  529:  op add :fn2:i 37 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  530:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  531:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  532:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  533:  op sub *tmp62 *tmp60 *tmp61                                  ...
  534:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  535:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  536:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  537:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  538:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  539:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  540:  op add :fn2:i 38 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  541:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  542:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  543:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  544:  op sub *tmp62 *tmp60 *tmp61                                  ...
  545:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  546:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  547:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  548:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  549:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  550:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  551:  op add :fn2:i 39 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  552:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  553:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  554:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  555:  op sub *tmp62 *tmp60 *tmp61                                  ...
  556:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  557:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  558:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  559:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  560:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  561:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  562:  op add :fn2:i 40 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  563:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  564:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  565:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  566:  op sub *tmp62 *tmp60 *tmp61                                  ...
  567:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  568:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  569:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  570:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  571:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  572:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  573:  op add :fn2:i 41 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  574:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  575:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  576:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  577:  op sub *tmp62 *tmp60 *tmp61                                  ...
  578:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  579:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  580:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  581:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  582:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  583:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  584:  op add :fn2:i 42 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  585:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  586:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  587:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  588:  op sub *tmp62 *tmp60 *tmp61                                  ...
  589:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  590:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  591:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  592:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  593:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  594:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  595:  op add :fn2:i 43 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  596:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  597:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  598:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  599:  op sub *tmp62 *tmp60 *tmp61                                  ...
  600:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  601:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  602:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  603:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  604:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  605:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  606:  op add :fn2:i 44 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  607:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  608:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  609:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  610:  op sub *tmp62 *tmp60 *tmp61                                  ...
  611:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  612:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  613:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  614:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  615:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  616:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  617:  op add :fn2:i 45 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  618:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  619:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  620:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  621:  op sub *tmp62 *tmp60 *tmp61                                  ...
  622:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  623:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  624:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  625:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  626:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  627:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  628:  op add :fn2:i 46 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  629:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  630:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  631:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  632:  op sub *tmp62 *tmp60 *tmp61                                  ...
  633:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  634:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  635:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  636:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  637:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  638:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  639:  op add :fn2:i 47 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  640:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  641:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  642:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  643:  op sub *tmp62 *tmp60 *tmp61                                  ...
  644:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  645:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  646:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  647:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  648:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  649:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  650:  op add :fn2:i 48 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  651:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  652:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  653:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  654:  op sub *tmp62 *tmp60 *tmp61                                  ...
  655:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  656:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  657:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  658:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  659:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  660:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  661:  op add :fn2:i 49 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  662:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  663:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  664:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  665:  op sub *tmp62 *tmp60 *tmp61                                  ...
  666:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  667:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  668:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  669:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  670:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  671:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  672:  op add :fn2:i 50 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  673:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  674:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  675:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  676:  op sub *tmp62 *tmp60 *tmp61                                  ...
  677:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  678:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  679:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  680:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  681:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  682:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  683:  op add :fn2:i 51 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  684:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  685:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  686:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  687:  op sub *tmp62 *tmp60 *tmp61                                  ...
  688:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  689:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  690:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  691:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  692:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  693:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  694:  op add :fn2:i 52 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  695:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  696:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  697:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  698:  op sub *tmp62 *tmp60 *tmp61                                  ...
  699:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  700:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  701:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  702:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  703:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  704:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  705:  op add :fn2:i 53 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  706:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  707:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  708:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  709:  op sub *tmp62 *tmp60 *tmp61                                  ...
  710:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  711:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  712:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  713:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  714:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  715:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  716:  op add :fn2:i 54 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  717:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  718:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  719:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  720:  op sub *tmp62 *tmp60 *tmp61                                  ...
  721:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  722:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  723:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  724:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  725:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  726:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  727:  op add :fn2:i 55 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  728:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  729:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  730:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  731:  op sub *tmp62 *tmp60 *tmp61                                  ...
  732:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  733:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  734:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  735:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  736:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  737:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  738:  op add :fn2:i 56 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  739:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  740:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  741:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  742:  op sub *tmp62 *tmp60 *tmp61                                  ...
  743:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  744:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  745:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  746:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  747:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  748:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  749:  op add :fn2:i 57 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  750:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  751:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  752:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  753:  op sub *tmp62 *tmp60 *tmp61                                  ...
  754:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  755:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  756:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  757:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  758:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  759:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  760:  op add :fn2:i 58 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  761:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  762:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  763:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  764:  op sub *tmp62 *tmp60 *tmp61                                  ...
  765:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  766:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  767:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  768:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  769:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  770:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  771:  op add :fn2:i 59 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  772:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  773:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  774:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  775:  op sub *tmp62 *tmp60 *tmp61                                  ...
  776:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  777:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  778:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  779:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  780:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  781:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  782:  op add :fn2:i 60 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  783:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  784:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  785:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  786:  op sub *tmp62 *tmp60 *tmp61                                  ...
  787:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  788:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  789:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  790:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  791:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  792:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  793:  op add :fn2:i 61 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  794:  set :fn2:x1 :fn2:zx                                          mandelbrot-compute.mnd: var x1 = zx;
  795:  op mul *tmp60 :fn2:zx :fn2:zx                                mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  796:  op mul *tmp61 :fn2:zy :fn2:zy                                ...
  797:  op sub *tmp62 *tmp60 *tmp61                                  ...
  798:  op add :fn2:zx *tmp62 :fn2:cx                                ...
  799:  op mul *tmp64 2 :fn2:x1                                      mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  800:  op mul *tmp65 *tmp64 :fn2:zy                                 ...
  801:  op add :fn2:zy *tmp65 :fn2:cy                                ...
  802:  op len :fn2:dist :fn2:zx :fn2:zy                             mandelbrot-compute.mnd: dist = len(zx, zy);
  803:  jump *label54 greaterThanEq :fn2:dist 64                     mandelbrot-compute.mnd: if dist >= 64 then
  804:  op add :fn2:i 62 1                                           mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label54                                               ...
  805:  op mul *tmp70 .SMOOTH 63                                     mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  806:  jump *label57 greaterThanEq :fn2:i *tmp70                    ...
  807:  op log *tmp73 :fn2:dist 0                                    mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  808:  op mul *tmp74 *tmp73 0.36067376022224085                     ...
  809:  op log *tmp75 *tmp74 0                                       ...
  810:  op mul *tmp76 *tmp75 1.4426950408889634                      ...
  811:  op sub :fn2:correction 4 *tmp76                              ...
  812:  op add :fn2:i :fn2:i :fn2:correction                         mandelbrot-compute.mnd: i += correction;
        label *label57                                               mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  813:  set *tmp42 :fn2:i                                            mandelbrot-compute.mnd: return i;
        label *label45                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  814:  jump *label60 equal .SMOOTH false                            mandelbrot-compute.mnd: if SMOOTH then
  815:  jump *label62 notEqual *tmp42 63                             mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  816:  draw color 0 0 0 255 0 0                                     mandelbrot-compute.mnd: color(0, 0, 0, 255);
  817:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
        label *label62                                               ...
  818:  jump *label65 notEqual .PALETTE 2                            mandelbrot-compute.mnd: case PALETTE
  819:  op sub *tmp83 32 *tmp42                                      mandelbrot-compute.mnd: r = 255 - 7 * abs(32 - iterations);
  820:  op abs *tmp84 *tmp83 0                                       ...
  821:  op mul *tmp85 7 *tmp84                                       ...
  822:  op sub :fn3:r 255 *tmp85                                     ...
  823:  op sub *tmp87 *tmp42 32                                      mandelbrot-compute.mnd: g = 240 - 6 * abs(iterations - 32);
  824:  op abs *tmp88 *tmp87 0                                       ...
  825:  op mul *tmp89 6 *tmp88                                       ...
  826:  op sub :fn3:g 240 *tmp89                                     ...
  827:  op mul *tmp93 4 *tmp84                                       mandelbrot-compute.mnd: b = 120 + 4 * abs(32 - iterations);
  828:  op add :fn3:b 120 *tmp93                                     ...
  829:  draw color :fn3:r :fn3:g :fn3:b 255 0 0                      mandelbrot-compute.mnd: color(r, g, b, 255);
  830:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label65                                               ...
  831:  jump *label67 notEqual .PALETTE 3                            ...
  832:  op div *tmp96 *tmp42 0.175                                   mandelbrot-compute.mnd: r = 255 * sin(iterations / MAX_DEPTH * 360);
  833:  op sin *tmp97 *tmp96 0                                       ...
  834:  op mul :fn3:r 255 *tmp97                                     ...
  835:  op cos *tmp101 *tmp96 0                                      mandelbrot-compute.mnd: g = 255 * cos(iterations / MAX_DEPTH * 360);
  836:  op mul :fn3:g 255 *tmp101                                    ...
  837:  op sub *tmp103 *tmp42 32                                     mandelbrot-compute.mnd: b = 100 + 4 * abs(iterations - 32);
  838:  op abs *tmp104 *tmp103 0                                     ...
  839:  op mul *tmp105 4 *tmp104                                     ...
  840:  op add :fn3:b 100 *tmp105                                    ...
  841:  draw color :fn3:r :fn3:g :fn3:b 255 0 0                      mandelbrot-compute.mnd: color(r, g, b, 255);
  842:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label67                                               ...
  843:  jump *label69 notEqual .PALETTE 4                            ...
  844:  op mul :fn3:r 4 *tmp42                                       mandelbrot-compute.mnd: r = 4 * iterations;
  845:  op mul *tmp108 1.5 *tmp42                                    mandelbrot-compute.mnd: g = 96 + 1.5 * iterations;
  846:  op add :fn3:g 96 *tmp108                                     ...
  847:  draw color :fn3:r :fn3:g 0 255 0 0                           mandelbrot-compute.mnd: color(r, g, 0, 255);
  848:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label69                                               ...
  849:  op mul *tmp110 4 *tmp42                                      mandelbrot-compute.mnd: r = 255 - 4 * iterations;
  850:  op sub :fn3:r 255 *tmp110                                    ...
  851:  draw color :fn3:r :fn3:r 0 255 0 0                           mandelbrot-compute.mnd: color(r, r, 0, 255);
  852:  jump *label61 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label60                                               ...
  853:  read *tmp113 .memory *tmp42                                  mandelbrot-compute.mnd: col(memory[iterations]);
  854:  draw col *tmp113 0 0 0 0 0                                   ...
        label *label61                                               mandelbrot-compute.mnd: if SMOOTH then
  855:  draw rect :x :y 1 1 0 0                                      mandelbrot-compute.mnd: rect(x, y, 1, 1);
  856:  op add .BATCH .BATCH 1                                       mandelbrot-compute.mnd: if ++BATCH < BATCH_SIZE then
  857:  jump *label59 lessThan .BATCH 44                             ...
        label *label73                                               mandelbrot-compute.mnd: do while $SYNC == PROC_ID_INDEX;
  858:  read *tmp9 .memory 73                                        ...
  859:  jump *label73 equal *tmp9 .PROC_ID_INDEX                     ...
        label *label76                                               mandelbrot-compute.mnd: do while $SYNC != PROC_ID_INDEX;
  860:  read *tmp9 .memory 73                                        ...
  861:  jump *label76 notEqual *tmp9 .PROC_ID_INDEX                  ...
  862:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  863:  set .BATCH 0                                                 mandelbrot-compute.mnd: BATCH = 0;
        label *label59                                               mandelbrot-compute.mnd: drawPixel(x, y, iterations);
  864:  read *tmp119 .memory :position                               mandelbrot-compute.mnd: if memory[position] != PROCESSOR_ID then
  865:  jump *label44 notEqual *tmp119 .PROCESSOR_ID                 ...
  866:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: if stop != $STOP then
  867:  jump *label39 notEqual .stop *tmp1                           ...
  868:  op add :y :y 1                                               mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
  869:  jump *label95 lessThan :y 176                                ...
        label *label44                                               ...
        label *label40                                               mandelbrot-compute.mnd: if memory[position] == 0 then
  870:  op add :line :line :increment                                mandelbrot-compute.mnd: line += increment;
  871:  jump *label83 lessThanEq :line 176                           mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  872:  op div :next_increment :next_increment 2                     mandelbrot-compute.mnd: increment = next_increment /= 2;
  873:  set :increment :next_increment                               ...
  874:  op div :line :next_increment 2                               mandelbrot-compute.mnd: line = increment / 2;
        label *label83                                               mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  875:  op add :lines :lines 1                                       mandelbrot-compute.mnd: MasterLoop:
  876:  jump *label94 lessThan :lines 176                            ...
        label *label39                                               ...
  877:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  878:  jump *label29 always 0 0                                     mandelbrot-compute.mnd: while true do


Performance: parsed in 225 ms, compiled in 224 ms, optimized in 2,666 ms, run in 37 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Display: display
Memory: bank
Execution step limit of 100 000 exceeded.
