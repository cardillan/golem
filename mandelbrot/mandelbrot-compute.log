   534 instructions before optimizations.
    52 instructions eliminated by Temp Variables Elimination (2 passes, 9 iterations).
     2 instructions eliminated by Case Expression Optimization.
    53 instructions eliminated by Dead Code Elimination (6 iterations).
     5 instructions eliminated by Jump Normalization (2 passes, 7 iterations).
    29 instructions eliminated by Condition Optimization (2 passes, 9 iterations).
    28 instructions eliminated by Single Step Elimination (2 passes, 9 iterations).
     4 instructions eliminated by Expression Optimization (2 passes, 5 iterations).
    21 instructions eliminated by Boolean Optimization (2 passes, 9 iterations).
       10 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by If Expression Optimization (5 iterations).
    56 instructions eliminated by Data Flow Optimization (6 passes, 24 iterations).
     1 loops improved by Loop Hoisting.
       5 loop conditions were partially rotated.
   741 instructions added by Loop Unrolling (11 iterations).
     4 loops unrolled by Loop Unrolling.
    12 instructions eliminated by Case Switching (11 iterations).
     2 case expressions converted to fast dispatch by Case Switching.
    69 instructions eliminated by Jump Straightening (2 passes, 9 iterations).
     9 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
     7 instructions eliminated by Print Merging.
   935 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 694):
    Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity
  * Unroll iteration loop at *blocks:68:13                       size    -9, benefit     9375.0, efficiency   Infinity (-3 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:136:5           size   -11, benefit   242187.5, efficiency   Infinity
    Fast-dispatch case at mandelbrot-compute.mnd:225:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 697):
  * Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:136:5           size   -11, benefit   242187.5, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:225:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 701):
  * Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity (-2 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:136:5           size   -11, benefit   242187.5, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:225:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 703):
  * Fast-dispatch case at mandelbrot-compute.mnd:136:5           size   -11, benefit   242187.5, efficiency   Infinity (-10 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:225:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 713):
  * Fast-dispatch case at mandelbrot-compute.mnd:225:13          size    -2, benefit     3906.3, efficiency   Infinity (-2 instructions)

Pass 2: speed optimization selection (cost limit 727):
  * Unroll loop at mandelbrot-compute.mnd:197:5                  size  +679, benefit 49218750.0, efficiency  72487.113 (+743 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
   192 op add *tmp57 *tmp56 :i
   193 set :adam5:index *tmp57
   194 op idiv *tmp59 :adam5:index 16
-    * set *tmp60 *tmp59
-    * jump *label50 lessThan *tmp60 0
-    * jump *label49 lessThan *tmp60 121
+  195 jump *label50 lessThan *tmp59 0
+  196 jump *label49 lessThan *tmp59 121
   197 label *label50
   198 jump *label48 always
   199 label *label49
 
   214 set *tmp58 :adam5:dx
   215 jump *label47 always
   216 label *label48
-    * jump *label55 lessThan *tmp60 121
-    * jump *label54 lessThan *tmp60 242
+  217 jump *label55 lessThan *tmp59 121
+  218 jump *label54 lessThan *tmp59 242
   219 label *label55
   220 jump *label53 always
   221 label *label54
 
   244 set *tmp58 :adam5:dy
   245 jump *label47 always
   246 label *label53
-    * jump *label62 lessThan *tmp60 242
-    * jump *label61 lessThan *tmp60 484
+  247 jump *label62 lessThan *tmp59 242
+  248 jump *label61 lessThan *tmp59 484
   249 label *label62
   250 jump *label60 always
   251 label *label61
 
   268 set *tmp58 :adam5:dx
   269 jump *label47 always
   270 label *label60
-    * jump *label67 lessThan *tmp60 484
-    * jump *label66 lessThan *tmp60 968
+  271 jump *label67 lessThan *tmp59 484
+  272 jump *label66 lessThan *tmp59 968
   273 label *label67
   274 jump *label65 always
   275 label *label66
 
   450 set *tmp134 :drawPixel:color
   451 jump *label99 always
   452 label *label98
-    * set *tmp136 .PALETTE
-    * jump *label102 equal *tmp136 2
+  453 jump *label102 equal .PALETTE 2
   454 jump *label101 always
   455 label *label102
   456 op sub *tmp137 32 :drawPixel:iterations
 
   476 set *tmp135 :drawPixel:color
   477 jump *label100 always
   478 label *label101
-    * jump *label104 equal *tmp136 3
+  479 jump *label104 equal .PALETTE 3
   480 jump *label103 always
   481 label *label104
   482 op div *tmp153 :drawPixel:iterations 63
 
   498 set *tmp135 :drawPixel:color
   499 jump *label100 always
   500 label *label103
-    * jump *label106 equal *tmp136 4
+  501 jump *label106 equal .PALETTE 4
   502 jump *label105 always
   503 label *label106
   504 op mul *tmp165 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-42 instructions):
 
    58 label *label19
    59 set *tmp22 null
    60 label *label20
-    * set *tmp20 *tmp22
    61 jump *label18 always
    62 label *label17
-    * set *tmp20 null
    63 label *label18
    64 label *label13
    65 multijump *tmp18 0 0 (m:marker1)
 
    91 print :findLinkedBlocks:variable
    92 jump *label26 equal :findLinkedBlocks:required false
    93 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * set *tmp24 :findLinkedBlocks:foundAll
    94 jump *label27 always
    95 label *label26
-    * set *tmp24 null
    96 label *label27
    97 label *label22
    98 multijump *tmp23 0 0 (m:marker2)
 
   161 op notEqual *tmp46 .stop *tmp47
   162 jump *label39 equal *tmp46 false
   163 jump *label29 always
-    * set *tmp48 null
   164 jump *label40 always
   165 label *label39
-    * set *tmp48 null
   166 label *label40
   167 read *tmp49 .memory 64
   168 set :batch *tmp49
 
   172 op greaterThanEq *tmp52 :batch 2816
   173 jump *label41 equal *tmp52 false
   174 jump *label38 always
-    * set *tmp53 null
   175 jump *label42 always
   176 label *label41
-    * set *tmp53 null
   177 label *label42
   178 op mul *tmp54 11 :multiple
   179 set *tmp55 *tmp54
 
   203 label *label52
   204 set :adam5:dy *tmp65
   205 set :adam5:dx :adam5:dy
-    * set *tmp58 :adam5:dx
   206 jump *label47 always
   207 label *label48
   208 jump *label55 lessThan *tmp59 121
 
   232 set *tmp72 2
   233 label *label59
   234 set :adam5:dy *tmp72
-    * set *tmp58 :adam5:dy
   235 jump *label47 always
   236 label *label53
   237 jump *label62 lessThan *tmp59 242
 
   255 label *label64
   256 set :adam5:dy *tmp78
   257 set :adam5:dx :adam5:dy
-    * set *tmp58 :adam5:dx
   258 jump *label47 always
   259 label *label60
   260 jump *label67 lessThan *tmp59 484
 
   278 set *tmp84 1
   279 label *label69
   280 set :adam5:dy *tmp84
-    * set *tmp58 :adam5:dy
   281 jump *label47 always
   282 label *label65
   283 op sub :adam5:index :adam5:index 15488
 
   289 set :adam5:y *tmp88
   290 set :adam5:dy 1
   291 set :adam5:dx :adam5:dy
-    * set *tmp58 :adam5:dx
   292 label *label47
   293 label *label46
   294 set :x :adam5:x
 
   318 label *label77
   319 drawflush .display
   320 set .localBuffer 0
-    * set *tmp96 .localBuffer
   321 jump *label76 always
   322 label *label75
-    * set *tmp96 null
   323 label *label76
   324 label *label74
-    * set *tmp91 null
   325 jump *label71 always
   326 label *label70
-    * set *tmp91 null
   327 label *label71
   328 set :compute:x :x
   329 set :compute:y :y
 
   336 jump *label80 equal .JULIA false
   337 set :compute:cx .JULIA_X
   338 set :compute:cy .JULIA_Y
-    * set *tmp102 :compute:cy
   339 jump *label81 always
   340 label *label80
   341 set :compute:cx :compute:zx
 
   351 jump *label82 equal *tmp109 false
   352 set *tmp97 63
   353 jump *label79 always
-    * set *tmp110 null
   354 jump *label83 always
   355 label *label82
-    * set *tmp110 null
   356 label *label83
   357 op add *tmp111 :compute:cx 1
   358 op len *tmp112 *tmp111 :compute:cy
 
   365 label *label84
   366 set *tmp114 null
   367 label *label85
-    * set *tmp102 *tmp114
   368 label *label81
   369 set :compute:i 0
   370 label *label86
 
   385 op greaterThanEq *tmp123 :compute:dist 64
   386 jump *label89 equal *tmp123 false
   387 jump *label88 always
-    * set *tmp124 null
   388 jump *label90 always
   389 label *label89
-    * set *tmp124 null
   390 label *label90
   391 label *label87
   392 op add :compute:i :compute:i 1
 
   405 op sub *tmp131 4 *tmp130
   406 set :compute:correction *tmp131
   407 op add :compute:i :compute:i :compute:correction
-    * set *tmp126 :compute:i
   408 jump *label92 always
   409 label *label91
-    * set *tmp126 null
   410 label *label92
   411 set *tmp97 :compute:i
   412 jump *label79 always
 
   497 label *label100
   498 set *tmp134 *tmp135
   499 label *label99
-    * set *tmp132 *tmp134
   500 jump *label97 always
   501 label *label96
   502 set *tmp174 :drawPixel:iterations
   503 read *tmp176 .memory *tmp174
   504 set :drawPixel:color *tmp176
-    * set *tmp132 :drawPixel:color
   505 label *label97
   506 op greaterThanEq *tmp177 .localBuffer 254
   507 jump *label107 equal *tmp177 false
 
   526 label *label118
   527 drawflush .display
   528 set .localBuffer 0
-    * set *tmp186 .localBuffer
   529 jump *label117 always
   530 label *label116
-    * set *tmp186 null
   531 label *label117
   532 label *label115
   533 label *label111
   534 jump *label110 always
   535 label *label112
   536 label *label109
-    * set *tmp178 null
   537 jump *label108 always
   538 label *label107
-    * set *tmp178 null
   539 label *label108
   540 op greaterThan *tmp187 .localBuffer 0
   541 jump *label120 equal *tmp187 false
 
   547 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   548 set *tmp190 .localBuffer
   549 op add .localBuffer .localBuffer 1
-    * set *tmp189 *tmp190
   550 jump *label121 always
   551 label *label120
   552 draw col :drawPixel:color
   553 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   554 set .lastColor :drawPixel:color
   555 op add .localBuffer .localBuffer 2
-    * set *tmp189 .localBuffer
   556 label *label121
   557 wait 0
   558 sensor *tmp191 .display @enabled
 
   566 label *label127
   567 drawflush .display
   568 set .localBuffer 0
-    * set *tmp195 .localBuffer
   569 jump *label126 always
   570 label *label125
-    * set *tmp195 null
   571 label *label126
   572 label *label124
   573 label *label95
 
   576 op notEqual *tmp196 .stop *tmp197
   577 jump *label129 equal *tmp196 false
   578 jump *label29 always
-    * set *tmp198 null
   579 jump *label130 always
   580 label *label129
-    * set *tmp198 null
   581 label *label130
   582 read *tmp199 .memory 66
-    * set *tmp200 *tmp199
   583 op add *tmp2 *tmp199 1
   584 write *tmp2 .memory 66
   585 read *tmp201 .memory 65
 
   592 op greaterThanEq *tmp203 :batch 1337.6
   593 jump *label131 equal *tmp203 false
   594 set :multiple 1
-    * set *tmp204 :multiple
   595 jump *label132 always
   596 label *label131
-    * set *tmp204 null
   597 label *label132
   598 label *label37
   599 jump *label36 always
 
   619 label *label142
   620 drawflush .display
   621 set .localBuffer 0
-    * set *tmp212 .localBuffer
   622 jump *label141 always
   623 label *label140
-    * set *tmp212 null
   624 label *label141
   625 label *label139
   626 label *label135

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-7 instructions):
 
    53 op equal *tmp21 :findLinkedBlocks:requested @message
    54 jump *label19 equal *tmp21 false
    55 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * set *tmp22 :findLinkedBlocks:message
    56 jump *label20 always
    57 label *label19
-    * set *tmp22 null
    58 label *label20
    59 jump *label18 always
    60 label *label17
 
   358 jump *label84 equal *tmp113 false
   359 set *tmp97 63
   360 jump *label79 always
-    * set *tmp114 null
   361 jump *label85 always
   362 label *label84
-    * set *tmp114 null
   363 label *label85
   364 label *label81
   365 set :compute:i 0
 
   418 op equal *tmp133 :drawPixel:iterations 63
   419 jump *label98 equal *tmp133 false
   420 set :drawPixel:color %[black]
-    * set *tmp134 :drawPixel:color
   421 jump *label99 always
   422 label *label98
   423 jump *label102 equal .PALETTE 2
 
   490 set :drawPixel:color *tmp173
   491 set *tmp135 :drawPixel:color
   492 label *label100
-    * set *tmp134 *tmp135
   493 label *label99
   494 jump *label97 always
   495 label *label96
 
   539 jump *label122 always
   540 label *label122
   541 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
-    * set *tmp190 .localBuffer
   542 op add .localBuffer .localBuffer 1
   543 jump *label121 always
   544 label *label120

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   443 set :drawPixel:b *tmp151
   444 packcolor *tmp152 :drawPixel:r :drawPixel:g :drawPixel:b 1
   445 set :drawPixel:color *tmp152
-    * set *tmp135 :drawPixel:color
   446 jump *label100 always
   447 label *label101
   448 jump *label104 equal .PALETTE 3
 
   464 set :drawPixel:b *tmp163
   465 packcolor *tmp164 :drawPixel:r :drawPixel:g :drawPixel:b 1
   466 set :drawPixel:color *tmp164
-    * set *tmp135 :drawPixel:color
   467 jump *label100 always
   468 label *label103
   469 jump *label106 equal .PALETTE 4
 
   477 set :drawPixel:g *tmp168
   478 packcolor *tmp169 :drawPixel:r :drawPixel:g 0 1
   479 set :drawPixel:color *tmp169
-    * set *tmp135 :drawPixel:color
   480 jump *label100 always
   481 label *label105
   482 op mul *tmp170 4 :drawPixel:iterations
 
   485 set :drawPixel:r *tmp172
   486 packcolor *tmp173 :drawPixel:r :drawPixel:r 0 1
   487 set :drawPixel:color *tmp173
-    * set *tmp135 :drawPixel:color
   488 label *label100
   489 label *label99
   490 jump *label97 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-49 instructions):
 
    27 op greaterThan *tmp15 :findLinkedBlocks:n 0
    28 jump *label11 equal *tmp15 false
    29 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
-    * getlink *tmp16 :findLinkedBlocks:n
-    * set :findLinkedBlocks:block *tmp16
+   30 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    31 print "\nFound: "
    32 print :findLinkedBlocks:block
-    * sensor *tmp17 :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:type *tmp17
+   33 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    34 set :findLinkedBlocks:requested @large-logic-display
    35 set :findLinkedBlocks:name "Display"
    36 set :findLinkedBlocks:variable .display
 
   110 op equal *tmp26 .start *tmp27
   111 jump *label31 notEqual *tmp26 false
   112 label *label33
-    * read *tmp28 .memory 67
-    * set .start *tmp28
-    * read *tmp29 .memory 68
-    * set .stop *tmp29
+  113 read .start .memory 67
+  114 read .stop .memory 68
   115 set .lastColor -1
   116 set .localBuffer 0
   117 drawflush null
   118 drawflush .display
-    * read *tmp30 .memory 71
-    * set .ZOOM *tmp30
+  119 read .ZOOM .memory 71
   120 op div *tmp31 -88 .ZOOM
   121 read *tmp33 .memory 69
-    * op add *tmp32 *tmp31 *tmp33
-    * set .OFFSET_X *tmp32
+  122 op add .OFFSET_X *tmp31 *tmp33
   123 op div *tmp34 -88 .ZOOM
   124 read *tmp36 .memory 70
-    * op add *tmp35 *tmp34 *tmp36
-    * set .OFFSET_Y *tmp35
-    * read *tmp37 .memory 72
-    * set .JULIA *tmp37
-    * read *tmp38 .memory 73
-    * set .JULIA_X *tmp38
-    * read *tmp39 .memory 74
-    * set .JULIA_Y *tmp39
-    * read *tmp40 .memory 75
-    * set .PALETTE *tmp40
-    * op greaterThan *tmp41 .PALETTE 1
-    * set .SMOOTH *tmp41
-    * read *tmp42 .memory 76
-    * set .ALL_PASS_COLORING *tmp42
+  125 op add .OFFSET_Y *tmp34 *tmp36
+  126 read .JULIA .memory 72
+  127 read .JULIA_X .memory 73
+  128 read .JULIA_Y .memory 74
+  129 read .PALETTE .memory 75
+  130 op greaterThan .SMOOTH .PALETTE 1
+  131 read .ALL_PASS_COLORING .memory 76
   132 read *tmp43 .memory 77
   133 jump *label34 equal *tmp43 false
-    * op sub *tmp45 1 .ALL_PASS_COLORING
-    * set *tmp44 *tmp45
+  134 op sub *tmp44 1 .ALL_PASS_COLORING
   135 jump *label35 always
   136 label *label34
   137 set *tmp44 99
 
   148 jump *label40 always
   149 label *label39
   150 label *label40
-    * read *tmp49 .memory 64
-    * set :batch *tmp49
+  151 read :batch .memory 64
   152 read *tmp50 .memory 64
   153 op add *tmp51 *tmp50 :multiple
   154 write *tmp51 .memory 64
 
   158 jump *label42 always
   159 label *label41
   160 label *label42
-    * op mul *tmp54 11 :multiple
-    * set *tmp55 *tmp54
+  161 op mul *tmp55 11 :multiple
   162 set :i 0
   163 label *label43
   164 jump *label45 greaterThanEq :i *tmp55
   165 op mul *tmp56 :batch 11
-    * op add *tmp57 *tmp56 :i
-    * set :adam5:index *tmp57
+  166 op add :adam5:index *tmp56 :i
   167 op idiv *tmp59 :adam5:index 16
   168 jump *label50 lessThan *tmp59 0
   169 jump *label49 lessThan *tmp59 121
 
   171 jump *label48 always
   172 label *label49
   173 op mod *tmp61 :adam5:index 44
-    * op mul *tmp62 4 *tmp61
-    * set :adam5:x *tmp62
+  174 op mul :adam5:x 4 *tmp61
   175 op idiv *tmp63 :adam5:index 44
-    * op mul *tmp64 4 *tmp63
-    * set :adam5:y *tmp64
+  176 op mul :adam5:y 4 *tmp63
   177 jump *label51 equal .ALL_PASS_COLORING false
   178 set *tmp65 4
   179 jump *label52 always
 
   192 op sub :adam5:index :adam5:index 1936
   193 op mod *tmp66 :adam5:index 44
   194 op mul *tmp67 4 *tmp66
-    * op add *tmp68 *tmp67 2
-    * set :adam5:x *tmp68
+  195 op add :adam5:x *tmp67 2
   196 op idiv *tmp69 :adam5:index 44
-    * op mul *tmp70 4 *tmp69
-    * set :adam5:y *tmp70
+  197 op mul :adam5:y 4 *tmp69
   198 jump *label56 equal .ALL_PASS_COLORING false
   199 set *tmp71 2
   200 jump *label57 always
 
   218 label *label61
   219 op sub :adam5:index :adam5:index 3872
   220 op mod *tmp73 :adam5:index 88
-    * op mul *tmp74 2 *tmp73
-    * set :adam5:x *tmp74
+  221 op mul :adam5:x 2 *tmp73
   222 op idiv *tmp75 :adam5:index 88
   223 op mul *tmp76 4 *tmp75
-    * op add *tmp77 *tmp76 2
-    * set :adam5:y *tmp77
+  224 op add :adam5:y *tmp76 2
   225 jump *label63 equal .ALL_PASS_COLORING false
   226 set *tmp78 2
   227 jump *label64 always
 
   240 op sub :adam5:index :adam5:index 7744
   241 op mod *tmp79 :adam5:index 88
   242 op mul *tmp80 2 *tmp79
-    * op add *tmp81 *tmp80 1
-    * set :adam5:x *tmp81
+  243 op add :adam5:x *tmp80 1
   244 op idiv *tmp82 :adam5:index 88
-    * op mul *tmp83 2 *tmp82
-    * set :adam5:y *tmp83
+  245 op mul :adam5:y 2 *tmp82
   246 set :adam5:dx 1
   247 jump *label68 equal .ALL_PASS_COLORING false
   248 set *tmp84 2
 
   254 jump *label47 always
   255 label *label65
   256 op sub :adam5:index :adam5:index 15488
-    * op mod *tmp85 :adam5:index 176
-    * set :adam5:x *tmp85
+  257 op mod :adam5:x :adam5:index 176
   258 op idiv *tmp86 :adam5:index 176
   259 op mul *tmp87 2 *tmp86
-    * op add *tmp88 *tmp87 1
-    * set :adam5:y *tmp88
+  260 op add :adam5:y *tmp87 1
   261 set :adam5:dy 1
   262 set :adam5:dx :adam5:dy
   263 label *label47
 
   299 set :compute:x :x
   300 set :compute:y :y
   301 op div *tmp98 :compute:x .ZOOM
-    * op add *tmp99 *tmp98 .OFFSET_X
-    * set :compute:zx *tmp99
+  302 op add :compute:zx *tmp98 .OFFSET_X
   303 op div *tmp100 :compute:y .ZOOM
-    * op add *tmp101 *tmp100 .OFFSET_Y
-    * set :compute:zy *tmp101
+  304 op add :compute:zy *tmp100 .OFFSET_Y
   305 jump *label80 equal .JULIA false
   306 set :compute:cx .JULIA_X
   307 set :compute:cy .JULIA_Y
 
   310 set :compute:cx :compute:zx
   311 set :compute:cy :compute:zy
   312 op sub *tmp103 :compute:cx 0.25
-    * op len *tmp104 *tmp103 :compute:cy
-    * set :compute:p *tmp104
+  313 op len :compute:p *tmp103 :compute:cy
   314 op mul *tmp105 2 :compute:p
   315 op mul *tmp106 *tmp105 :compute:p
   316 op sub *tmp107 :compute:p *tmp106
 
   340 op mul *tmp115 :compute:x1 :compute:x1
   341 op mul *tmp116 :compute:y1 :compute:y1
   342 op sub *tmp117 *tmp115 *tmp116
-    * op add *tmp118 *tmp117 :compute:cx
-    * set :compute:zx *tmp118
+  343 op add :compute:zx *tmp117 :compute:cx
   344 op mul *tmp119 2 :compute:x1
   345 op mul *tmp120 *tmp119 :compute:y1
-    * op add *tmp121 *tmp120 :compute:cy
-    * set :compute:zy *tmp121
-    * op len *tmp122 :compute:zx :compute:zy
-    * set :compute:dist *tmp122
+  346 op add :compute:zy *tmp120 :compute:cy
+  347 op len :compute:dist :compute:zx :compute:zy
   348 op greaterThanEq *tmp123 :compute:dist 64
   349 jump *label89 equal *tmp123 false
   350 jump *label88 always
 
   365 op mul *tmp128 *tmp127 0.36067376022224085
   366 op log *tmp129 *tmp128
   367 op mul *tmp130 *tmp129 1.4426950408889634
-    * op sub *tmp131 4 *tmp130
-    * set :compute:correction *tmp131
+  368 op sub :compute:correction 4 *tmp130
   369 op add :compute:i :compute:i :compute:correction
   370 jump *label92 always
   371 label *label91
 
   393 op abs *tmp138 *tmp137
   394 op mul *tmp139 7 *tmp138
   395 op div *tmp140 *tmp139 255
-    * op sub *tmp141 1 *tmp140
-    * set :drawPixel:r *tmp141
+  396 op sub :drawPixel:r 1 *tmp140
   397 op sub *tmp142 :drawPixel:iterations 32
   398 op abs *tmp143 *tmp142
   399 op mul *tmp144 6 *tmp143
   400 op div *tmp145 *tmp144 255
-    * op sub *tmp146 0.9411764705882353 *tmp145
-    * set :drawPixel:g *tmp146
+  401 op sub :drawPixel:g 0.9411764705882353 *tmp145
   402 op sub *tmp147 32 :drawPixel:iterations
   403 op abs *tmp148 *tmp147
   404 op mul *tmp149 4 *tmp148
   405 op div *tmp150 *tmp149 255
-    * op add *tmp151 0.47058823529411764 *tmp150
-    * set :drawPixel:b *tmp151
-    * packcolor *tmp152 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp152
+  406 op add :drawPixel:b 0.47058823529411764 *tmp150
+  407 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   408 jump *label100 always
   409 label *label101
   410 jump *label104 equal .PALETTE 3
 
   412 label *label104
   413 op div *tmp153 :drawPixel:iterations 63
   414 op mul *tmp154 *tmp153 360
-    * op sin *tmp155 *tmp154
-    * set :drawPixel:r *tmp155
+  415 op sin :drawPixel:r *tmp154
   416 op div *tmp156 :drawPixel:iterations 63
   417 op mul *tmp157 *tmp156 360
-    * op cos *tmp158 *tmp157
-    * set :drawPixel:g *tmp158
+  418 op cos :drawPixel:g *tmp157
   419 op sub *tmp159 :drawPixel:iterations 32
   420 op abs *tmp160 *tmp159
   421 op mul *tmp161 4 *tmp160
   422 op div *tmp162 *tmp161 255
-    * op add *tmp163 0.39215686274509803 *tmp162
-    * set :drawPixel:b *tmp163
-    * packcolor *tmp164 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp164
+  423 op add :drawPixel:b 0.39215686274509803 *tmp162
+  424 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   425 jump *label100 always
   426 label *label103
   427 jump *label106 equal .PALETTE 4
   428 jump *label105 always
   429 label *label106
   430 op mul *tmp165 4 :drawPixel:iterations
-    * op div *tmp166 *tmp165 255
-    * set :drawPixel:r *tmp166
+  431 op div :drawPixel:r *tmp165 255
   432 op mul *tmp167 1.5 :drawPixel:iterations
-    * op div *tmp168 *tmp167 255
-    * set :drawPixel:g *tmp168
-    * packcolor *tmp169 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp169
+  433 op div :drawPixel:g *tmp167 255
+  434 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   435 jump *label100 always
   436 label *label105
   437 op mul *tmp170 4 :drawPixel:iterations
   438 op div *tmp171 *tmp170 255
-    * op sub *tmp172 1 *tmp171
-    * set :drawPixel:r *tmp172
-    * packcolor *tmp173 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp173
+  439 op sub :drawPixel:r 1 *tmp171
+  440 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   441 label *label100
   442 label *label99
   443 jump *label97 always
   444 label *label96
-    * set *tmp174 :drawPixel:iterations
-    * read *tmp176 .memory *tmp174
-    * set :drawPixel:color *tmp176
+  445 read :drawPixel:color .memory :drawPixel:iterations
   446 label *label97
   447 op greaterThanEq *tmp177 .localBuffer 254
   448 jump *label107 equal *tmp177 false

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
   102 label *label3
   103 label *label0
   104 label *label28
-    * jump *label30 equal true false
   105 label *label31
   106 wait 0
   107 label *label32
 
   138 set :leaderLimit *tmp44
   139 set :multiple 4
   140 label *label36
-    * jump *label38 equal true false
   141 wait 0
   142 read *tmp47 .memory 68
   143 op notEqual *tmp46 .stop *tmp47

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   384 set :drawPixel:color %[black]
   385 jump *label99 always
   386 label *label98
-    * jump *label102 equal .PALETTE 2
-    * jump *label101 always
+  387 jump *label101 notEqual .PALETTE 2
   388 label *label102
   389 op sub *tmp137 32 :drawPixel:iterations
   390 op abs *tmp138 *tmp137
 
   404 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   405 jump *label100 always
   406 label *label101
-    * jump *label104 equal .PALETTE 3
-    * jump *label103 always
+  407 jump *label103 notEqual .PALETTE 3
   408 label *label104
   409 op div *tmp153 :drawPixel:iterations 63
   410 op mul *tmp154 *tmp153 360
 
   420 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   421 jump *label100 always
   422 label *label103
-    * jump *label106 equal .PALETTE 4
-    * jump *label105 always
+  423 jump *label105 notEqual .PALETTE 4
   424 label *label106
   425 op mul *tmp165 4 :drawPixel:iterations
   426 op div :drawPixel:r *tmp165 255

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-27 instructions):
 
    24 print :findLinkedBlocks:title
    25 set :findLinkedBlocks:n @links
    26 label *label9
-    * op greaterThan *tmp15 :findLinkedBlocks:n 0
-    * jump *label11 equal *tmp15 false
+   27 jump *label11 lessThanEq :findLinkedBlocks:n 0
    28 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    29 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    30 print "\nFound: "
 
    44 set :findLinkedBlocks:required true
    45 setaddr *tmp18 *label16
    46 label *label12
-    * op equal *tmp19 :findLinkedBlocks:requested :findLinkedBlocks:type
-    * jump *label17 equal *tmp19 false
+   47 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * op equal *tmp21 :findLinkedBlocks:requested @message
-    * jump *label19 equal *tmp21 false
+   49 jump *label19 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
    51 jump *label20 always
    52 label *label19
 
    94 label *label23
    95 printflush :findLinkedBlocks:message
    96 label *label2
-    * op equal *tmp25 :findLinkedBlocks:foundAll false
-    * jump *label1 notEqual *tmp25 false
+   97 jump *label1 equal :findLinkedBlocks:foundAll false
    98 label *label3
    99 label *label0
   100 label *label28
 
   102 wait 0
   103 label *label32
   104 read *tmp27 .memory 67
-    * op equal *tmp26 .start *tmp27
-    * jump *label31 notEqual *tmp26 false
+  105 jump *label31 equal .start *tmp27
   106 label *label33
   107 read .start .memory 67
   108 read .stop .memory 68
 
   135 label *label36
   136 wait 0
   137 read *tmp47 .memory 68
-    * op notEqual *tmp46 .stop *tmp47
-    * jump *label39 equal *tmp46 false
+  138 jump *label39 equal .stop *tmp47
   139 jump *label29 always
   140 jump *label40 always
   141 label *label39
 
   144 read *tmp50 .memory 64
   145 op add *tmp51 *tmp50 :multiple
   146 write *tmp51 .memory 64
-    * op greaterThanEq *tmp52 :batch 2816
-    * jump *label41 equal *tmp52 false
+  147 jump *label41 lessThan :batch 2816
   148 jump *label38 always
   149 jump *label42 always
   150 label *label41
 
   257 set :y :adam5:y
   258 set :dx :adam5:dx
   259 set :dy :adam5:dy
-    * op greaterThan *tmp89 :multiple :leaderLimit
-    * jump *label70 equal *tmp89 false
+  260 jump *label70 lessThanEq :multiple :leaderLimit
   261 label *label73
-    * op equal *tmp90 .localBuffer 0
-    * jump *label70 equal *tmp90 false
+  262 jump *label70 notEqual .localBuffer 0
   263 jump *label72 always
   264 label *label72
   265 draw col %[white]
 
   272 label *label78
   273 sensor *tmp93 .display @bufferSize
   274 op sub *tmp94 1024 *tmp93
-    * op lessThan *tmp95 .localBuffer *tmp94
-    * jump *label75 equal *tmp95 false
+  275 jump *label75 greaterThanEq .localBuffer *tmp94
   276 jump *label77 always
   277 label *label77
   278 drawflush .display
 
   303 op mul *tmp106 *tmp105 :compute:p
   304 op sub *tmp107 :compute:p *tmp106
   305 op add *tmp108 *tmp107 0.25
-    * op lessThanEq *tmp109 :compute:cx *tmp108
-    * jump *label82 equal *tmp109 false
+  306 jump *label82 greaterThan :compute:cx *tmp108
   307 set *tmp97 63
   308 jump *label79 always
   309 jump *label83 always
 
   311 label *label83
   312 op add *tmp111 :compute:cx 1
   313 op len *tmp112 *tmp111 :compute:cy
-    * op lessThanEq *tmp113 *tmp112 0.25
-    * jump *label84 equal *tmp113 false
+  314 jump *label84 greaterThan *tmp112 0.25
   315 set *tmp97 63
   316 jump *label79 always
   317 jump *label85 always
 
   331 op mul *tmp120 *tmp119 :compute:y1
   332 op add :compute:zy *tmp120 :compute:cy
   333 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp123 :compute:dist 64
-    * jump *label89 equal *tmp123 false
+  334 jump *label89 lessThan :compute:dist 64
   335 jump *label88 always
   336 jump *label90 always
   337 label *label89
 
   342 label *label88
   343 jump *label91 equal .SMOOTH false
   344 label *label94
-    * op lessThan *tmp125 :compute:i 63
-    * jump *label91 equal *tmp125 false
+  345 jump *label91 greaterThanEq :compute:i 63
   346 jump *label93 always
   347 label *label93
   348 op log *tmp127 :compute:dist
 
   365 set :drawPixel:dy :dy
   366 set :drawPixel:iterations :iterations
   367 jump *label96 equal .SMOOTH false
-    * op equal *tmp133 :drawPixel:iterations 63
-    * jump *label98 equal *tmp133 false
+  368 jump *label98 notEqual :drawPixel:iterations 63
   369 set :drawPixel:color %[black]
   370 jump *label99 always
   371 label *label98
 
   424 label *label96
   425 read :drawPixel:color .memory :drawPixel:iterations
   426 label *label97
-    * op greaterThanEq *tmp177 .localBuffer 254
-    * jump *label107 equal *tmp177 false
+  427 jump *label107 lessThan .localBuffer 254
   428 label *label110
-    * op greaterThan *tmp179 .localBuffer 0
-    * jump *label112 equal *tmp179 false
+  429 jump *label112 lessThanEq .localBuffer 0
   430 label *label114
   431 read *tmp181 .memory 68
-    * op equal *tmp180 .stop *tmp181
-    * jump *label112 equal *tmp180 false
+  432 jump *label112 notEqual .stop *tmp181
   433 jump *label113 always
   434 label *label113
   435 wait 0
 
   438 label *label119
   439 sensor *tmp183 .display @bufferSize
   440 op sub *tmp184 1024 *tmp183
-    * op lessThan *tmp185 .localBuffer *tmp184
-    * jump *label116 equal *tmp185 false
+  441 jump *label116 greaterThanEq .localBuffer *tmp184
   442 jump *label118 always
   443 label *label118
   444 drawflush .display
 
   454 jump *label108 always
   455 label *label107
   456 label *label108
-    * op greaterThan *tmp187 .localBuffer 0
-    * jump *label120 equal *tmp187 false
+  457 jump *label120 lessThanEq .localBuffer 0
   458 label *label123
-    * op strictEqual *tmp188 :drawPixel:color .lastColor
-    * jump *label120 equal *tmp188 false
+  459 jump *label120 strictNotEqual :drawPixel:color .lastColor
   460 jump *label122 always
   461 label *label122
   462 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
 
   474 label *label128
   475 sensor *tmp192 .display @bufferSize
   476 op sub *tmp193 1024 *tmp192
-    * op lessThan *tmp194 .localBuffer *tmp193
-    * jump *label125 equal *tmp194 false
+  477 jump *label125 greaterThanEq .localBuffer *tmp193
   478 jump *label127 always
   479 label *label127
   480 drawflush .display
 
   486 label *label95
   487 wait 0
   488 read *tmp197 .memory 68
-    * op notEqual *tmp196 .stop *tmp197
-    * jump *label129 equal *tmp196 false
+  489 jump *label129 equal .stop *tmp197
   490 jump *label29 always
   491 jump *label130 always
   492 label *label129
 
   501 op add :i :i 1
   502 jump *label43 always
   503 label *label45
-    * op greaterThanEq *tmp203 :batch 1337.6
-    * jump *label131 equal *tmp203 false
+  504 jump *label131 lessThan :batch 1337.6
   505 set :multiple 1
   506 jump *label132 always
   507 label *label131
 
   510 jump *label36 always
   511 label *label38
   512 label *label134
-    * op greaterThan *tmp205 .localBuffer 0
-    * jump *label136 equal *tmp205 false
+  513 jump *label136 lessThanEq .localBuffer 0
   514 label *label138
   515 read *tmp207 .memory 68
-    * op equal *tmp206 .stop *tmp207
-    * jump *label136 equal *tmp206 false
+  516 jump *label136 notEqual .stop *tmp207
   517 jump *label137 always
   518 label *label137
   519 wait 0
 
   522 label *label143
   523 sensor *tmp209 .display @bufferSize
   524 op sub *tmp210 1024 *tmp209
-    * op lessThan *tmp211 .localBuffer *tmp210
-    * jump *label140 equal *tmp211 false
+  525 jump *label140 greaterThanEq .localBuffer *tmp210
   526 jump *label142 always
   527 label *label142
   528 drawflush .display

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-26 instructions):
 
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
    49 jump *label19 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * jump *label20 always
    51 label *label19
    52 label *label20
-    * jump *label18 always
    53 label *label17
    54 label *label18
    55 label *label13
 
    82 print :findLinkedBlocks:variable
    83 jump *label26 equal :findLinkedBlocks:required false
    84 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * jump *label27 always
    85 label *label26
    86 label *label27
    87 label *label22
 
   134 read *tmp47 .memory 68
   135 jump *label39 equal .stop *tmp47
   136 jump *label29 always
-    * jump *label40 always
   137 label *label39
   138 label *label40
   139 read :batch .memory 64
 
   142 write *tmp51 .memory 64
   143 jump *label41 lessThan :batch 2816
   144 jump *label38 always
-    * jump *label42 always
   145 label *label41
   146 label *label42
   147 op mul *tmp55 11 :multiple
 
   255 jump *label70 lessThanEq :multiple :leaderLimit
   256 label *label73
   257 jump *label70 notEqual .localBuffer 0
-    * jump *label72 always
   258 label *label72
   259 draw col %[white]
   260 draw rect :x :y :dx :dx
 
   267 sensor *tmp93 .display @bufferSize
   268 op sub *tmp94 1024 *tmp93
   269 jump *label75 greaterThanEq .localBuffer *tmp94
-    * jump *label77 always
   270 label *label77
   271 drawflush .display
   272 set .localBuffer 0
-    * jump *label76 always
   273 label *label75
   274 label *label76
   275 label *label74
-    * jump *label71 always
   276 label *label70
   277 label *label71
   278 set :compute:x :x
 
   297 jump *label82 greaterThan :compute:cx *tmp108
   298 set *tmp97 63
   299 jump *label79 always
-    * jump *label83 always
   300 label *label82
   301 label *label83
   302 op add *tmp111 :compute:cx 1
 
   304 jump *label84 greaterThan *tmp112 0.25
   305 set *tmp97 63
   306 jump *label79 always
-    * jump *label85 always
   307 label *label84
   308 label *label85
   309 label *label81
 
   322 op len :compute:dist :compute:zx :compute:zy
   323 jump *label89 lessThan :compute:dist 64
   324 jump *label88 always
-    * jump *label90 always
   325 label *label89
   326 label *label90
   327 label *label87
 
   331 jump *label91 equal .SMOOTH false
   332 label *label94
   333 jump *label91 greaterThanEq :compute:i 63
-    * jump *label93 always
   334 label *label93
   335 op log *tmp127 :compute:dist
   336 op mul *tmp128 *tmp127 0.36067376022224085
 
   338 op mul *tmp130 *tmp129 1.4426950408889634
   339 op sub :compute:correction 4 *tmp130
   340 op add :compute:i :compute:i :compute:correction
-    * jump *label92 always
   341 label *label91
   342 label *label92
   343 set *tmp97 :compute:i
 
   416 label *label114
   417 read *tmp181 .memory 68
   418 jump *label112 notEqual .stop *tmp181
-    * jump *label113 always
   419 label *label113
   420 wait 0
   421 sensor *tmp182 .display @enabled
 
   424 sensor *tmp183 .display @bufferSize
   425 op sub *tmp184 1024 *tmp183
   426 jump *label116 greaterThanEq .localBuffer *tmp184
-    * jump *label118 always
   427 label *label118
   428 drawflush .display
   429 set .localBuffer 0
-    * jump *label117 always
   430 label *label116
   431 label *label117
   432 label *label115
 
   434 jump *label110 always
   435 label *label112
   436 label *label109
-    * jump *label108 always
   437 label *label107
   438 label *label108
   439 jump *label120 lessThanEq .localBuffer 0
   440 label *label123
   441 jump *label120 strictNotEqual :drawPixel:color .lastColor
-    * jump *label122 always
   442 label *label122
   443 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   444 op add .localBuffer .localBuffer 1
 
   456 sensor *tmp192 .display @bufferSize
   457 op sub *tmp193 1024 *tmp192
   458 jump *label125 greaterThanEq .localBuffer *tmp193
-    * jump *label127 always
   459 label *label127
   460 drawflush .display
   461 set .localBuffer 0
-    * jump *label126 always
   462 label *label125
   463 label *label126
   464 label *label124
 
   467 read *tmp197 .memory 68
   468 jump *label129 equal .stop *tmp197
   469 jump *label29 always
-    * jump *label130 always
   470 label *label129
   471 label *label130
   472 read *tmp199 .memory 66
 
   481 label *label45
   482 jump *label131 lessThan :batch 1337.6
   483 set :multiple 1
-    * jump *label132 always
   484 label *label131
   485 label *label132
   486 label *label37
 
   491 label *label138
   492 read *tmp207 .memory 68
   493 jump *label136 notEqual .stop *tmp207
-    * jump *label137 always
   494 label *label137
   495 wait 0
   496 sensor *tmp208 .display @enabled
 
   499 sensor *tmp209 .display @bufferSize
   500 op sub *tmp210 1024 *tmp209
   501 jump *label140 greaterThanEq .localBuffer *tmp210
-    * jump *label142 always
   502 label *label142
   503 drawflush .display
   504 set .localBuffer 0
-    * jump *label141 always
   505 label *label140
   506 label *label141
   507 label *label139

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     1 set :findLinkedBlocks:title "Mandelbrot Generator"
     2 set :findLinkedBlocks:message null
     3 label *label1
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
     4 setaddr *tmp14 *label7
     5 jump *label4 always
     6 multilabel *label7 (m:marker0)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
+    7 set .display null
     8 setaddr *tmp14 *label8
     9 label *label4
    10 set :findLinkedBlocks:variable null
    11 label *label5
    12 multijump *tmp14 0 0 (m:marker0)
    13 multilabel *label8 (m:marker0)
-    * set .memory :findLinkedBlocks:variable
+   14 set .memory null
    15 label *label6
-    * print :findLinkedBlocks:title
+   16 print "Mandelbrot Generator"
    17 set :findLinkedBlocks:n @links
    18 label *label9
    19 jump *label11 lessThanEq :findLinkedBlocks:n 0
 
    23 print :findLinkedBlocks:block
    24 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    25 set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
    26 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    27 setaddr *tmp18 *label15
    28 jump *label12 always
    29 multilabel *label15 (m:marker1)
    30 set .display :findLinkedBlocks:variable
    31 set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
    32 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    33 setaddr *tmp18 *label16
    34 label *label12
    35 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
 
    49 jump *label9 always
    50 label *label11
    51 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:requested @large-logic-display
    52 set :findLinkedBlocks:name "Display"
    53 set :findLinkedBlocks:variable .display
    54 set :findLinkedBlocks:required true
 
    56 jump *label21 always
    57 multilabel *label24 (m:marker2)
    58 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    59 set :findLinkedBlocks:name "Memory"
    60 set :findLinkedBlocks:variable .memory
    61 set :findLinkedBlocks:required true
 
    66 print ":"
    67 print " "
    68 print :findLinkedBlocks:variable
-    * jump *label26 equal :findLinkedBlocks:required false
+   69 jump *label26 equal true false
    70 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
    71 label *label26
    72 label *label27
 
    99 op add .OFFSET_X *tmp31 *tmp33
   100 op div *tmp34 -88 .ZOOM
   101 read *tmp36 .memory 70
-    * op add .OFFSET_Y *tmp34 *tmp36
+  102 op add .OFFSET_Y *tmp31 *tmp36
   103 read .JULIA .memory 72
   104 read .JULIA_X .memory 73
   105 read .JULIA_Y .memory 74
 
   153 set *tmp65 2
   154 label *label52
   155 set :adam5:dy *tmp65
-    * set :adam5:dx :adam5:dy
+  156 set :adam5:dx *tmp65
   157 jump *label47 always
   158 label *label48
   159 jump *label55 lessThan *tmp59 121
 
   201 set *tmp78 1
   202 label *label64
   203 set :adam5:dy *tmp78
-    * set :adam5:dx :adam5:dy
+  204 set :adam5:dx *tmp78
   205 jump *label47 always
   206 label *label60
   207 jump *label67 lessThan *tmp59 484
 
   231 op mul *tmp87 2 *tmp86
   232 op add :adam5:y *tmp87 1
   233 set :adam5:dy 1
-    * set :adam5:dx :adam5:dy
+  234 set :adam5:dx 1
   235 label *label47
   236 label *label46
   237 set :x :adam5:x
   238 set :y :adam5:y
   239 set :dx :adam5:dx
   240 set :dy :adam5:dy
-    * jump *label70 lessThanEq :multiple :leaderLimit
+  241 jump *label70 lessThanEq :multiple *tmp44
   242 label *label73
   243 jump *label70 notEqual .localBuffer 0
   244 label *label72
   245 draw col %[white]
-    * draw rect :x :y :dx :dx
+  246 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx
   247 set .lastColor %[white]
   248 set .localBuffer 2
   249 wait 0
 
   252 label *label78
   253 sensor *tmp93 .display @bufferSize
   254 op sub *tmp94 1024 *tmp93
-    * jump *label75 greaterThanEq .localBuffer *tmp94
+  255 jump *label75 greaterThanEq 2 *tmp94
   256 label *label77
   257 drawflush .display
   258 set .localBuffer 0
 
   261 label *label74
   262 label *label70
   263 label *label71
-    * set :compute:x :x
-    * set :compute:y :y
-    * op div *tmp98 :compute:x .ZOOM
+  264 set :compute:x :adam5:x
+  265 set :compute:y :adam5:y
+  266 op div *tmp98 :x .ZOOM
   267 op add :compute:zx *tmp98 .OFFSET_X
-    * op div *tmp100 :compute:y .ZOOM
+  268 op div *tmp100 :y .ZOOM
   269 op add :compute:zy *tmp100 .OFFSET_Y
   270 jump *label80 equal .JULIA false
   271 set :compute:cx .JULIA_X
 
   274 label *label80
   275 set :compute:cx :compute:zx
   276 set :compute:cy :compute:zy
-    * op sub *tmp103 :compute:cx 0.25
-    * op len :compute:p *tmp103 :compute:cy
+  277 op sub *tmp103 :compute:zx 0.25
+  278 op len :compute:p *tmp103 :compute:zy
   279 op mul *tmp105 2 :compute:p
   280 op mul *tmp106 *tmp105 :compute:p
   281 op sub *tmp107 :compute:p *tmp106
   282 op add *tmp108 *tmp107 0.25
-    * jump *label82 greaterThan :compute:cx *tmp108
+  283 jump *label82 greaterThan :compute:zx *tmp108
   284 set *tmp97 63
   285 jump *label79 always
   286 label *label82
   287 label *label83
-    * op add *tmp111 :compute:cx 1
-    * op len *tmp112 *tmp111 :compute:cy
+  288 op add *tmp111 :compute:zx 1
+  289 op len *tmp112 *tmp111 :compute:zy
   290 jump *label84 greaterThan *tmp112 0.25
   291 set *tmp97 63
   292 jump *label79 always
 
   298 jump *label88 greaterThanEq :compute:i 63
   299 set :compute:x1 :compute:zx
   300 set :compute:y1 :compute:zy
-    * op mul *tmp115 :compute:x1 :compute:x1
-    * op mul *tmp116 :compute:y1 :compute:y1
+  301 op mul *tmp115 :compute:zx :compute:zx
+  302 op mul *tmp116 :compute:zy :compute:zy
   303 op sub *tmp117 *tmp115 *tmp116
   304 op add :compute:zx *tmp117 :compute:cx
   305 op mul *tmp119 2 :compute:x1
-    * op mul *tmp120 *tmp119 :compute:y1
+  306 op mul *tmp120 *tmp119 :compute:zy
   307 op add :compute:zy *tmp120 :compute:cy
   308 op len :compute:dist :compute:zx :compute:zy
   309 jump *label89 lessThan :compute:dist 64
 
   328 label *label92
   329 set *tmp97 :compute:i
   330 jump *label79 always
-    * set *tmp97 null
   331 label *label79
   332 set :iterations *tmp97
-    * set :drawPixel:x :x
-    * set :drawPixel:y :y
-    * set :drawPixel:dx :dx
-    * set :drawPixel:dy :dy
-    * set :drawPixel:iterations :iterations
+  333 set :drawPixel:x :adam5:x
+  334 set :drawPixel:y :adam5:y
+  335 set :drawPixel:dx :adam5:dx
+  336 set :drawPixel:dy :adam5:dy
+  337 set :drawPixel:iterations *tmp97
   338 jump *label96 equal .SMOOTH false
-    * jump *label98 notEqual :drawPixel:iterations 63
+  339 jump *label98 notEqual :iterations 63
   340 set :drawPixel:color %[black]
   341 jump *label99 always
   342 label *label98
   343 jump *label101 notEqual .PALETTE 2
   344 label *label102
-    * op sub *tmp137 32 :drawPixel:iterations
+  345 op sub *tmp137 32 :iterations
   346 op abs *tmp138 *tmp137
   347 op mul *tmp139 7 *tmp138
-    * op div *tmp140 *tmp139 255
+  348 op div *tmp140 *tmp138 36.42857142857143
   349 op sub :drawPixel:r 1 *tmp140
-    * op sub *tmp142 :drawPixel:iterations 32
+  350 op sub *tmp142 :iterations 32
   351 op abs *tmp143 *tmp142
   352 op mul *tmp144 6 *tmp143
-    * op div *tmp145 *tmp144 255
+  353 op div *tmp145 *tmp143 42.5
   354 op sub :drawPixel:g 0.9411764705882353 *tmp145
-    * op sub *tmp147 32 :drawPixel:iterations
-    * op abs *tmp148 *tmp147
-    * op mul *tmp149 4 *tmp148
-    * op div *tmp150 *tmp149 255
+  355 op sub *tmp147 32 :iterations
+  356 op abs *tmp148 *tmp137
+  357 op mul *tmp149 4 *tmp138
+  358 op div *tmp150 *tmp148 63.75
   359 op add :drawPixel:b 0.47058823529411764 *tmp150
   360 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   361 jump *label100 always
   362 label *label101
   363 jump *label103 notEqual .PALETTE 3
   364 label *label104
-    * op div *tmp153 :drawPixel:iterations 63
-    * op mul *tmp154 *tmp153 360
+  365 op div *tmp153 :iterations 63
+  366 op div *tmp154 :drawPixel:iterations 0.175
   367 op sin :drawPixel:r *tmp154
-    * op div *tmp156 :drawPixel:iterations 63
-    * op mul *tmp157 *tmp156 360
-    * op cos :drawPixel:g *tmp157
-    * op sub *tmp159 :drawPixel:iterations 32
+  368 op div *tmp156 :iterations 63
+  369 op mul *tmp157 *tmp153 360
+  370 op cos :drawPixel:g *tmp154
+  371 op sub *tmp159 :iterations 32
   372 op abs *tmp160 *tmp159
   373 op mul *tmp161 4 *tmp160
-    * op div *tmp162 *tmp161 255
+  374 op div *tmp162 *tmp160 63.75
   375 op add :drawPixel:b 0.39215686274509803 *tmp162
   376 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   377 jump *label100 always
   378 label *label103
   379 jump *label105 notEqual .PALETTE 4
   380 label *label106
-    * op mul *tmp165 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp165 255
-    * op mul *tmp167 1.5 :drawPixel:iterations
-    * op div :drawPixel:g *tmp167 255
+  381 op mul *tmp165 4 :iterations
+  382 op div :drawPixel:r :drawPixel:iterations 63.75
+  383 op mul *tmp167 1.5 :iterations
+  384 op div :drawPixel:g :drawPixel:iterations 170
   385 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   386 jump *label100 always
   387 label *label105
-    * op mul *tmp170 4 :drawPixel:iterations
-    * op div *tmp171 *tmp170 255
+  388 op mul *tmp170 4 :iterations
+  389 op div *tmp171 :drawPixel:iterations 63.75
   390 op sub :drawPixel:r 1 *tmp171
   391 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   392 label *label100
   393 label *label99
   394 jump *label97 always
   395 label *label96
-    * read :drawPixel:color .memory :drawPixel:iterations
+  396 read :drawPixel:color .memory :iterations
   397 label *label97
   398 jump *label107 lessThan .localBuffer 254
   399 label *label110
 
   425 label *label123
   426 jump *label120 strictNotEqual :drawPixel:color .lastColor
   427 label *label122
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  428 draw rect :x :y :dx :dy
   429 op add .localBuffer .localBuffer 1
   430 jump *label121 always
   431 label *label120
   432 draw col :drawPixel:color
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  433 draw rect :x :y :dx :dy
   434 set .lastColor :drawPixel:color
   435 op add .localBuffer .localBuffer 2
   436 label *label121
 
   458 op add *tmp2 *tmp199 1
   459 write *tmp2 .memory 66
   460 read *tmp201 .memory 65
-    * op add *tmp202 *tmp201 :iterations
+  461 op add *tmp202 *tmp201 *tmp97
   462 write *tmp202 .memory 65
   463 label *label44
   464 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-17 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:title "Mandelbrot Generator"
     1 set :findLinkedBlocks:message null
     2 label *label1
     3 setaddr *tmp14 *label7
 
     6 set .display null
     7 setaddr *tmp14 *label8
     8 label *label4
-    * set :findLinkedBlocks:variable null
     9 label *label5
    10 multijump *tmp14 0 0 (m:marker0)
    11 multilabel *label8 (m:marker0)
 
    49 set :findLinkedBlocks:foundAll 1
    50 set :findLinkedBlocks:name "Display"
    51 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    52 setaddr *tmp23 *label24
    53 jump *label21 always
    54 multilabel *label24 (m:marker2)
    55 set .display :findLinkedBlocks:variable
    56 set :findLinkedBlocks:name "Memory"
    57 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    58 setaddr *tmp23 *label25
    59 label *label21
    60 print "\n"
 
    93 op div *tmp31 -88 .ZOOM
    94 read *tmp33 .memory 69
    95 op add .OFFSET_X *tmp31 *tmp33
-    * op div *tmp34 -88 .ZOOM
    96 read *tmp36 .memory 70
    97 op add .OFFSET_Y *tmp31 *tmp36
    98 read .JULIA .memory 72
 
   108 label *label34
   109 set *tmp44 99
   110 label *label35
-    * set :leaderLimit *tmp44
   111 set :multiple 4
   112 label *label36
   113 wait 0
 
   255 label *label74
   256 label *label70
   257 label *label71
-    * set :compute:x :adam5:x
-    * set :compute:y :adam5:y
-    * op div *tmp98 :x .ZOOM
+  258 op div *tmp98 :adam5:x .ZOOM
   259 op add :compute:zx *tmp98 .OFFSET_X
-    * op div *tmp100 :y .ZOOM
+  260 op div *tmp100 :adam5:y .ZOOM
   261 op add :compute:zy *tmp100 .OFFSET_Y
   262 jump *label80 equal .JULIA false
   263 set :compute:cx .JULIA_X
 
   289 label *label86
   290 jump *label88 greaterThanEq :compute:i 63
   291 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   292 op mul *tmp115 :compute:zx :compute:zx
   293 op mul *tmp116 :compute:zy :compute:zy
   294 op sub *tmp117 *tmp115 *tmp116
 
   321 jump *label79 always
   322 label *label79
   323 set :iterations *tmp97
-    * set :drawPixel:x :adam5:x
-    * set :drawPixel:y :adam5:y
-    * set :drawPixel:dx :adam5:dx
-    * set :drawPixel:dy :adam5:dy
   324 set :drawPixel:iterations *tmp97
   325 jump *label96 equal .SMOOTH false
-    * jump *label98 notEqual :iterations 63
+  326 jump *label98 notEqual *tmp97 63
   327 set :drawPixel:color %[black]
   328 jump *label99 always
   329 label *label98
   330 jump *label101 notEqual .PALETTE 2
   331 label *label102
-    * op sub *tmp137 32 :iterations
+  332 op sub *tmp137 32 *tmp97
   333 op abs *tmp138 *tmp137
-    * op mul *tmp139 7 *tmp138
   334 op div *tmp140 *tmp138 36.42857142857143
   335 op sub :drawPixel:r 1 *tmp140
-    * op sub *tmp142 :iterations 32
+  336 op sub *tmp142 *tmp97 32
   337 op abs *tmp143 *tmp142
-    * op mul *tmp144 6 *tmp143
   338 op div *tmp145 *tmp143 42.5
   339 op sub :drawPixel:g 0.9411764705882353 *tmp145
-    * op sub *tmp147 32 :iterations
+  340 op sub *tmp147 32 *tmp97
   341 op abs *tmp148 *tmp137
-    * op mul *tmp149 4 *tmp138
-    * op div *tmp150 *tmp148 63.75
+  342 op div *tmp150 *tmp138 63.75
   343 op add :drawPixel:b 0.47058823529411764 *tmp150
   344 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   345 jump *label100 always
   346 label *label101
   347 jump *label103 notEqual .PALETTE 3
   348 label *label104
-    * op div *tmp153 :iterations 63
-    * op div *tmp154 :drawPixel:iterations 0.175
+  349 op div *tmp153 *tmp97 63
+  350 op div *tmp154 *tmp97 0.175
   351 op sin :drawPixel:r *tmp154
-    * op div *tmp156 :iterations 63
-    * op mul *tmp157 *tmp153 360
+  352 op div *tmp156 *tmp97 63
+  353 op div *tmp157 :iterations 0.175
   354 op cos :drawPixel:g *tmp154
-    * op sub *tmp159 :iterations 32
+  355 op sub *tmp159 *tmp97 32
   356 op abs *tmp160 *tmp159
-    * op mul *tmp161 4 *tmp160
   357 op div *tmp162 *tmp160 63.75
   358 op add :drawPixel:b 0.39215686274509803 *tmp162
   359 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   361 label *label103
   362 jump *label105 notEqual .PALETTE 4
   363 label *label106
-    * op mul *tmp165 4 :iterations
-    * op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp167 1.5 :iterations
-    * op div :drawPixel:g :drawPixel:iterations 170
+  364 op mul *tmp165 4 *tmp97
+  365 op div :drawPixel:r *tmp97 63.75
+  366 op mul *tmp167 1.5 *tmp97
+  367 op div :drawPixel:g *tmp97 170
   368 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   369 jump *label100 always
   370 label *label105
-    * op mul *tmp170 4 :iterations
-    * op div *tmp171 :drawPixel:iterations 63.75
+  371 op mul *tmp170 4 *tmp97
+  372 op div *tmp171 *tmp97 63.75
   373 op sub :drawPixel:r 1 *tmp171
   374 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   375 label *label100
   376 label *label99
   377 jump *label97 always
   378 label *label96
-    * read :drawPixel:color .memory :iterations
+  379 read :drawPixel:color .memory *tmp97
   380 label *label97
   381 jump *label107 lessThan .localBuffer 254
   382 label *label110
 
   408 label *label123
   409 jump *label120 strictNotEqual :drawPixel:color .lastColor
   410 label *label122
-    * draw rect :x :y :dx :dy
+  411 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   412 op add .localBuffer .localBuffer 1
   413 jump *label121 always
   414 label *label120
   415 draw col :drawPixel:color
-    * draw rect :x :y :dx :dy
+  416 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   417 set .lastColor :drawPixel:color
   418 op add .localBuffer .localBuffer 2
   419 label *label121

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   228 set :adam5:dx 1
   229 label *label47
   230 label *label46
-    * set :x :adam5:x
-    * set :y :adam5:y
-    * set :dx :adam5:dx
-    * set :dy :adam5:dy
   231 jump *label70 lessThanEq :multiple *tmp44
   232 label *label73
   233 jump *label70 notEqual .localBuffer 0
 
   317 jump *label79 always
   318 label *label79
   319 set :iterations *tmp97
-    * set :drawPixel:iterations *tmp97
   320 jump *label96 equal .SMOOTH false
   321 jump *label98 notEqual *tmp97 63
   322 set :drawPixel:color %[black]
 
   332 op abs *tmp143 *tmp142
   333 op div *tmp145 *tmp143 42.5
   334 op sub :drawPixel:g 0.9411764705882353 *tmp145
-    * op sub *tmp147 32 *tmp97
-    * op abs *tmp148 *tmp137
   335 op div *tmp150 *tmp138 63.75
   336 op add :drawPixel:b 0.47058823529411764 *tmp150
   337 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   339 label *label101
   340 jump *label103 notEqual .PALETTE 3
   341 label *label104
-    * op div *tmp153 *tmp97 63
   342 op div *tmp154 *tmp97 0.175
   343 op sin :drawPixel:r *tmp154
-    * op div *tmp156 *tmp97 63
-    * op div *tmp157 :iterations 0.175
+  344 op div *tmp157 *tmp97 0.175
   345 op cos :drawPixel:g *tmp154
   346 op sub *tmp159 *tmp97 32
   347 op abs *tmp160 *tmp159
 
   352 label *label103
   353 jump *label105 notEqual .PALETTE 4
   354 label *label106
-    * op mul *tmp165 4 *tmp97
   355 op div :drawPixel:r *tmp97 63.75
-    * op mul *tmp167 1.5 *tmp97
   356 op div :drawPixel:g *tmp97 170
   357 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   358 jump *label100 always
   359 label *label105
-    * op mul *tmp170 4 *tmp97
   360 op div *tmp171 *tmp97 63.75
   361 op sub :drawPixel:r 1 *tmp171
   362 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   316 set *tmp97 :compute:i
   317 jump *label79 always
   318 label *label79
-    * set :iterations *tmp97
   319 jump *label96 equal .SMOOTH false
   320 jump *label98 notEqual *tmp97 63
   321 set :drawPixel:color %[black]
 
   340 label *label104
   341 op div *tmp154 *tmp97 0.175
   342 op sin :drawPixel:r *tmp154
-    * op div *tmp157 *tmp97 0.175
   343 op cos :drawPixel:g *tmp154
   344 op sub *tmp159 *tmp97 32
   345 op abs *tmp160 *tmp159

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
   126 label *label42
   127 op mul *tmp55 11 :multiple
   128 set :i 0
+  129 op mul *tmp56 :batch 11
   130 label *label43
   131 jump *label45 greaterThanEq :i *tmp55
-    * op mul *tmp56 :batch 11
   132 op add :adam5:index *tmp56 :i
   133 op idiv *tmp59 :adam5:index 16
   134 jump *label50 lessThan *tmp59 0

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
    15 set :findLinkedBlocks:n @links
    16 label *label9
    17 jump *label11 lessThanEq :findLinkedBlocks:n 0
+   18 label *label144
    19 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    20 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    21 print "\nFound: "
 
    45 set .memory :findLinkedBlocks:variable
    46 label *label14
    47 label *label10
-    * jump *label9 always
+   48 jump *label144 greaterThan :findLinkedBlocks:n 0
    49 label *label11
    50 set :findLinkedBlocks:foundAll 1
    51 set :findLinkedBlocks:name "Display"
 
   130 op mul *tmp56 :batch 11
   131 label *label43
   132 jump *label45 greaterThanEq :i *tmp55
+  133 label *label145
   134 op add :adam5:index *tmp56 :i
   135 op idiv *tmp59 :adam5:index 16
   136 jump *label50 lessThan *tmp59 0
 
   286 set :compute:i 0
   287 label *label86
   288 jump *label88 greaterThanEq :compute:i 63
+  289 label *label146
   290 set :compute:x1 :compute:zx
   291 op mul *tmp115 :compute:zx :compute:zx
   292 op mul *tmp116 :compute:zy :compute:zy
 
   302 label *label90
   303 label *label87
   304 op add :compute:i :compute:i 1
-    * jump *label86 always
+  305 jump *label146 lessThan :compute:i 63
   306 label *label88
   307 jump *label91 equal .SMOOTH false
   308 label *label94
 
   370 jump *label107 lessThan .localBuffer 254
   371 label *label110
   372 jump *label112 lessThanEq .localBuffer 0
-    * label *label114
+  373 label *label147
   374 read *tmp181 .memory 68
   375 jump *label112 notEqual .stop *tmp181
-    * label *label113
   376 wait 0
   377 sensor *tmp182 .display @enabled
   378 jump *label116 equal *tmp182 false
 
   387 label *label117
   388 label *label115
   389 label *label111
-    * jump *label110 always
+  390 jump *label147 greaterThan .localBuffer 0
   391 label *label112
   392 label *label109
   393 label *label107
 
   433 write *tmp202 .memory 65
   434 label *label44
   435 op add :i :i 1
-    * jump *label43 always
+  436 jump *label145 lessThan :i *tmp55
   437 label *label45
   438 jump *label131 lessThan :batch 1337.6
   439 set :multiple 1
 
   444 label *label38
   445 label *label134
   446 jump *label136 lessThanEq .localBuffer 0
-    * label *label138
+  447 label *label148
   448 read *tmp207 .memory 68
   449 jump *label136 notEqual .stop *tmp207
-    * label *label137
   450 wait 0
   451 sensor *tmp208 .display @enabled
   452 jump *label140 equal *tmp208 false
 
   461 label *label141
   462 label *label139
   463 label *label135
-    * jump *label134 always
+  464 jump *label148 greaterThan .localBuffer 0
   465 label *label136
   466 label *label133
   467 label *label29

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-19 instructions):
 
    33 label *label12
    34 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    35 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label19 notEqual :findLinkedBlocks:requested @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
-    * label *label19
-    * label *label20
+   36 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
    37 label *label17
    38 label *label18
    39 label *label13
 
    99 read .PALETTE .memory 75
   100 op greaterThan .SMOOTH .PALETTE 1
   101 read .ALL_PASS_COLORING .memory 76
-    * read *tmp43 .memory 77
-    * jump *label34 equal *tmp43 false
-    * op sub *tmp44 1 .ALL_PASS_COLORING
-    * jump *label35 always
-    * label *label34
-    * set *tmp44 99
-    * label *label35
+  102 read *tmp43 .memory 77
+  103 op sub *tmp213 1 .ALL_PASS_COLORING
+  104 select *tmp44 notEqual *tmp43 false *tmp213 99
   105 set :multiple 4
   106 label *label36
   107 wait 0
 
   135 op mul :adam5:x 4 *tmp61
   136 op idiv *tmp63 :adam5:index 44
   137 op mul :adam5:y 4 *tmp63
-    * jump *label51 equal .ALL_PASS_COLORING false
-    * set *tmp65 4
-    * jump *label52 always
-    * label *label51
-    * set *tmp65 2
-    * label *label52
+  138 select *tmp65 notEqual .ALL_PASS_COLORING false 4 2
   139 set :adam5:dy *tmp65
   140 set :adam5:dx *tmp65
   141 jump *label47 always
 
   151 op add :adam5:x *tmp67 2
   152 op idiv *tmp69 :adam5:index 44
   153 op mul :adam5:y 4 *tmp69
-    * jump *label56 equal .ALL_PASS_COLORING false
-    * set *tmp71 2
-    * jump *label57 always
-    * label *label56
-    * set *tmp71 1
-    * label *label57
+  154 select *tmp71 notEqual .ALL_PASS_COLORING false 2 1
   155 set :adam5:dx *tmp71
-    * jump *label58 equal .ALL_PASS_COLORING false
-    * set *tmp72 4
-    * jump *label59 always
-    * label *label58
-    * set *tmp72 2
-    * label *label59
+  156 select *tmp72 notEqual .ALL_PASS_COLORING false 4 2
   157 set :adam5:dy *tmp72
   158 jump *label47 always
   159 label *label53
 
   168 op idiv *tmp75 :adam5:index 88
   169 op mul *tmp76 4 *tmp75
   170 op add :adam5:y *tmp76 2
-    * jump *label63 equal .ALL_PASS_COLORING false
-    * set *tmp78 2
-    * jump *label64 always
-    * label *label63
-    * set *tmp78 1
-    * label *label64
+  171 select *tmp78 notEqual .ALL_PASS_COLORING false 2 1
   172 set :adam5:dy *tmp78
   173 set :adam5:dx *tmp78
   174 jump *label47 always
 
   185 op idiv *tmp82 :adam5:index 88
   186 op mul :adam5:y 2 *tmp82
   187 set :adam5:dx 1
-    * jump *label68 equal .ALL_PASS_COLORING false
-    * set *tmp84 2
-    * jump *label69 always
-    * label *label68
-    * set *tmp84 1
-    * label *label69
+  188 select *tmp84 notEqual .ALL_PASS_COLORING false 2 1
   189 set :adam5:dy *tmp84
   190 jump *label47 always
   191 label *label65
 
   199 label *label47
   200 label *label46
   201 jump *label70 lessThanEq :multiple *tmp44
-    * label *label73
   202 jump *label70 notEqual .localBuffer 0
-    * label *label72
   203 draw col %[white]
   204 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx
   205 set .lastColor %[white]
 
   207 wait 0
   208 sensor *tmp92 .display @enabled
   209 jump *label75 equal *tmp92 false
-    * label *label78
   210 sensor *tmp93 .display @bufferSize
   211 op sub *tmp94 1024 *tmp93
   212 jump *label75 greaterThanEq 2 *tmp94
-    * label *label77
   213 drawflush .display
   214 set .localBuffer 0
   215 label *label75
 
   269 jump *label146 lessThan :compute:i 63
   270 label *label88
   271 jump *label91 equal .SMOOTH false
-    * label *label94
   272 jump *label91 greaterThanEq :compute:i 63
-    * label *label93
   273 op log *tmp127 :compute:dist
   274 op mul *tmp128 *tmp127 0.36067376022224085
   275 op log *tmp129 *tmp128
 
   338 wait 0
   339 sensor *tmp182 .display @enabled
   340 jump *label116 equal *tmp182 false
-    * label *label119
   341 sensor *tmp183 .display @bufferSize
   342 op sub *tmp184 1024 *tmp183
   343 jump *label116 greaterThanEq .localBuffer *tmp184
-    * label *label118
   344 drawflush .display
   345 set .localBuffer 0
   346 label *label116
 
   353 label *label107
   354 label *label108
   355 jump *label120 lessThanEq .localBuffer 0
-    * label *label123
   356 jump *label120 strictNotEqual :drawPixel:color .lastColor
-    * label *label122
   357 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   358 op add .localBuffer .localBuffer 1
   359 jump *label121 always
 
   366 wait 0
   367 sensor *tmp191 .display @enabled
   368 jump *label125 equal *tmp191 false
-    * label *label128
   369 sensor *tmp192 .display @bufferSize
   370 op sub *tmp193 1024 *tmp192
   371 jump *label125 greaterThanEq .localBuffer *tmp193
-    * label *label127
   372 drawflush .display
   373 set .localBuffer 0
   374 label *label125
 
   391 op add :i :i 1
   392 jump *label145 lessThan :i *tmp55
   393 label *label45
-    * jump *label131 lessThan :batch 1337.6
-    * set :multiple 1
-    * label *label131
-    * label *label132
+  394 select :multiple greaterThanEq :batch 1337.6 1 :multiple
   395 label *label37
   396 jump *label36 always
   397 label *label38
 
   403 wait 0
   404 sensor *tmp208 .display @enabled
   405 jump *label140 equal *tmp208 false
-    * label *label143
   406 sensor *tmp209 .display @bufferSize
   407 op sub *tmp210 1024 *tmp209
   408 jump *label140 greaterThanEq .localBuffer *tmp210
-    * label *label142
   409 drawflush .display
   410 set .localBuffer 0
   411 label *label140

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   282 jump *label79 always
   283 label *label79
   284 jump *label96 equal .SMOOTH false
-    * jump *label98 notEqual *tmp97 63
   285 set :drawPixel:color %[black]
-    * jump *label99 always
+  286 jump *label99 equal *tmp97 63
   287 label *label98
   288 jump *label101 notEqual .PALETTE 2
   289 label *label102

Modifications by Unroll iteration loop at *blocks:68:13 (-1 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp18 *label15
-    * jump *label12 always
-    * multilabel *label15 (m:marker1)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp18 *label16
-    * label *label12
-    * jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
-    * label *label17
-    * label *label18
-    * label *label13
-    * multijump *tmp18 0 0 (m:marker1)
-    * multilabel *label16 (m:marker1)
-    * set .memory :findLinkedBlocks:variable
-    * label *label14
+   24 set :findLinkedBlocks:requested @large-logic-display
+   25 set :findLinkedBlocks:variable .display
+   26 label *label149
+   27 jump *label150 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   28 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   29 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   30 label *label150
+   31 label *label151
+   32 label *label152
+   33 set .display :findLinkedBlocks:variable
+   34 set :findLinkedBlocks:requested @memory-bank
+   35 set :findLinkedBlocks:variable .memory
+   36 label *label155
+   37 jump *label156 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   38 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   39 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   40 label *label156
+   41 label *label157
+   42 label *label158
+   43 set .memory :findLinkedBlocks:variable
+   44 label *label14
    45 label *label10
    46 jump *label144 greaterThan :findLinkedBlocks:n 0
    47 label *label11

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    24 set :findLinkedBlocks:requested @large-logic-display
    25 set :findLinkedBlocks:variable .display
    26 label *label149
-    * jump *label150 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   27 jump *label150 notEqual @large-logic-display :findLinkedBlocks:type
    28 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   29 select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
    30 label *label150
    31 label *label151
    32 label *label152
 
    34 set :findLinkedBlocks:requested @memory-bank
    35 set :findLinkedBlocks:variable .memory
    36 label *label155
-    * jump *label156 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   37 jump *label156 notEqual @memory-bank :findLinkedBlocks:type
    38 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   39 select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
    40 label *label156
    41 label *label157
    42 label *label158
 
   123 set :i 0
   124 op mul *tmp56 :batch 11
   125 label *label43
-    * jump *label45 greaterThanEq :i *tmp55
+  126 jump *label45 greaterThanEq 0 *tmp55
   127 label *label145
   128 op add :adam5:index *tmp56 :i
   129 op idiv *tmp59 :adam5:index 16
 
   250 label *label81
   251 set :compute:i 0
   252 label *label86
-    * jump *label88 greaterThanEq :compute:i 63
+  253 jump *label88 greaterThanEq 0 63
   254 label *label146
   255 set :compute:x1 :compute:zx
   256 op mul *tmp115 :compute:zx :compute:zx

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
    24 set :findLinkedBlocks:variable .display
    25 label *label149
    26 jump *label150 notEqual @large-logic-display :findLinkedBlocks:type
 
    30 label *label151
    31 label *label152
    32 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    33 set :findLinkedBlocks:variable .memory
    34 label *label155
    35 jump *label156 notEqual @memory-bank :findLinkedBlocks:type

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
     0 set .start 0
     1 set :findLinkedBlocks:message null
     2 label *label1
-    * setaddr *tmp14 *label7
-    * jump *label4 always
-    * multilabel *label7 (m:marker0)
-    * set .display null
-    * setaddr *tmp14 *label8
-    * label *label4
-    * label *label5
-    * multijump *tmp14 0 0 (m:marker0)
-    * multilabel *label8 (m:marker0)
-    * set .memory null
-    * label *label6
+    3 label *label162
+    4 label *label163
+    5 set .display null
+    6 label *label166
+    7 label *label167
+    8 set .memory null
+    9 label *label6
    10 print "Mandelbrot Generator"
    11 set :findLinkedBlocks:n @links
    12 label *label9

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    40 jump *label144 greaterThan :findLinkedBlocks:n 0
    41 label *label11
    42 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp23 *label24
-    * jump *label21 always
-    * multilabel *label24 (m:marker2)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp23 *label25
-    * label *label21
-    * print "\n"
-    * print :findLinkedBlocks:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks:variable
-    * jump *label26 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * label *label26
-    * label *label27
-    * label *label22
-    * multijump *tmp23 0 0 (m:marker2)
-    * multilabel *label25 (m:marker2)
-    * set .memory :findLinkedBlocks:variable
-    * label *label23
+   43 set :findLinkedBlocks:name "Display"
+   44 set :findLinkedBlocks:variable .display
+   45 label *label171
+   46 print "\n"
+   47 print :findLinkedBlocks:name
+   48 print ":"
+   49 print " "
+   50 print :findLinkedBlocks:variable
+   51 jump *label172 equal true false
+   52 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   53 label *label172
+   54 label *label173
+   55 label *label174
+   56 set .display :findLinkedBlocks:variable
+   57 set :findLinkedBlocks:name "Memory"
+   58 set :findLinkedBlocks:variable .memory
+   59 label *label177
+   60 print "\n"
+   61 print :findLinkedBlocks:name
+   62 print ":"
+   63 print " "
+   64 print :findLinkedBlocks:variable
+   65 jump *label178 equal true false
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   67 label *label178
+   68 label *label179
+   69 label *label180
+   70 set .memory :findLinkedBlocks:variable
+   71 label *label23
    72 printflush :findLinkedBlocks:message
    73 label *label2
    74 jump *label1 equal :findLinkedBlocks:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    44 set :findLinkedBlocks:variable .display
    45 label *label171
    46 print "\n"
-    * print :findLinkedBlocks:name
+   47 print "Display"
    48 print ":"
    49 print " "
-    * print :findLinkedBlocks:variable
+   50 print .display
    51 jump *label172 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   52 op and :findLinkedBlocks:foundAll 1 .display
    53 label *label172
    54 label *label173
    55 label *label174
-    * set .display :findLinkedBlocks:variable
+   56 set .display .display
    57 set :findLinkedBlocks:name "Memory"
    58 set :findLinkedBlocks:variable .memory
    59 label *label177
    60 print "\n"
-    * print :findLinkedBlocks:name
+   61 print "Memory"
    62 print ":"
    63 print " "
-    * print :findLinkedBlocks:variable
+   64 print .memory
    65 jump *label178 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    67 label *label178
    68 label *label179
    69 label *label180
-    * set .memory :findLinkedBlocks:variable
+   70 set .memory .memory
    71 label *label23
    72 printflush :findLinkedBlocks:message
    73 label *label2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    39 label *label10
    40 jump *label144 greaterThan :findLinkedBlocks:n 0
    41 label *label11
-    * set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
    42 label *label171
    43 print "\n"
    44 print "Display"
 
    51 label *label173
    52 label *label174
    53 set .display .display
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
    54 label *label177
    55 print "\n"
    56 print "Memory"

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:136:5 (-10 instructions):
 
   121 label *label145
   122 op add :adam5:index *tmp56 :i
   123 op idiv *tmp59 :adam5:index 16
-    * jump *label50 lessThan *tmp59 0
-    * jump *label49 lessThan *tmp59 121
-    * label *label50
-    * jump *label48 always
+  124 multijump *tmp59 0 0 (m:*label185)
+  125 multilabel *label190 (m:*label185)
+  126 label *label184
+  127 op sub :adam5:index :adam5:index 15488
+  128 op mod :adam5:x :adam5:index 176
+  129 op idiv *tmp86 :adam5:index 176
+  130 op mul *tmp87 2 *tmp86
+  131 op add :adam5:y *tmp87 1
+  132 set :adam5:dy 1
+  133 set :adam5:dx 1
+  134 jump *label47 always
+  135 multilabel *label186 (m:*label185)
   136 label *label49
   137 op mod *tmp61 :adam5:index 44
   138 op mul :adam5:x 4 *tmp61
 
   143 set :adam5:dx *tmp65
   144 jump *label47 always
   145 label *label48
-    * jump *label55 lessThan *tmp59 121
-    * jump *label54 lessThan *tmp59 242
-    * label *label55
-    * jump *label53 always
+  146 multilabel *label187 (m:*label185)
   147 label *label54
   148 op sub :adam5:index :adam5:index 1936
   149 op mod *tmp66 :adam5:index 44
 
   157 set :adam5:dy *tmp72
   158 jump *label47 always
   159 label *label53
-    * jump *label62 lessThan *tmp59 242
-    * jump *label61 lessThan *tmp59 484
-    * label *label62
-    * jump *label60 always
+  160 multilabel *label188 (m:*label185)
   161 label *label61
   162 op sub :adam5:index :adam5:index 3872
   163 op mod *tmp73 :adam5:index 88
 
   170 set :adam5:dx *tmp78
   171 jump *label47 always
   172 label *label60
-    * jump *label67 lessThan *tmp59 484
-    * jump *label66 lessThan *tmp59 968
-    * label *label67
-    * jump *label65 always
+  173 jump *label47 always
+  174 multilabel *label189 (m:*label185)
   175 label *label66
   176 op sub :adam5:index :adam5:index 7744
   177 op mod *tmp79 :adam5:index 88
 
   182 set :adam5:dx 1
   183 select *tmp84 notEqual .ALL_PASS_COLORING false 2 1
   184 set :adam5:dy *tmp84
-    * jump *label47 always
-    * label *label65
-    * op sub :adam5:index :adam5:index 15488
-    * op mod :adam5:x :adam5:index 176
-    * op idiv *tmp86 :adam5:index 176
-    * op mul *tmp87 2 *tmp86
-    * op add :adam5:y *tmp87 1
-    * set :adam5:dy 1
-    * set :adam5:dx 1
   185 label *label47
   186 label *label46
   187 jump *label70 lessThanEq :multiple *tmp44

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:225:13 (-2 instructions):
 
   271 set :drawPixel:color %[black]
   272 jump *label99 equal *tmp97 63
   273 label *label98
-    * jump *label101 notEqual .PALETTE 2
+  274 multijump .PALETTE 0 0 (m:*label192)
+  275 multilabel *label197 (m:*label192)
+  276 multilabel *label193 (m:*label192)
+  277 label *label191
+  278 op div *tmp171 *tmp97 63.75
+  279 op sub :drawPixel:r 1 *tmp171
+  280 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
+  281 jump *label100 always
+  282 multilabel *label194 (m:*label192)
   283 label *label102
   284 op sub *tmp137 32 *tmp97
   285 op abs *tmp138 *tmp137
 
   294 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   295 jump *label100 always
   296 label *label101
-    * jump *label103 notEqual .PALETTE 3
+  297 multilabel *label195 (m:*label192)
   298 label *label104
   299 op div *tmp154 *tmp97 0.175
   300 op sin :drawPixel:r *tmp154
 
   306 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   307 jump *label100 always
   308 label *label103
-    * jump *label105 notEqual .PALETTE 4
+  309 multilabel *label196 (m:*label192)
   310 label *label106
   311 op div :drawPixel:r *tmp97 63.75
   312 op div :drawPixel:g *tmp97 170
   313 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label100 always
-    * label *label105
-    * op div *tmp171 *tmp97 63.75
-    * op sub :drawPixel:r 1 *tmp171
-    * packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   314 label *label100
   315 label *label99
   316 jump *label97 always

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-3 instructions):
 
    45 print ":"
    46 print " "
    47 print .display
-    * jump *label172 equal true false
    48 op and :findLinkedBlocks:foundAll 1 .display
    49 label *label172
    50 label *label173
 
    56 print ":"
    57 print " "
    58 print .memory
-    * jump *label178 equal true false
    59 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    60 label *label178
    61 label *label179
 
   233 label *label81
   234 set :compute:i 0
   235 label *label86
-    * jump *label88 greaterThanEq 0 63
   236 label *label146
   237 set :compute:x1 :compute:zx
   238 op mul *tmp115 :compute:zx :compute:zx

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-2 instructions):
 
    90 read .JULIA_X .memory 73
    91 read .JULIA_Y .memory 74
    92 read .PALETTE .memory 75
-    * op greaterThan .SMOOTH .PALETTE 1
    93 read .ALL_PASS_COLORING .memory 76
    94 read *tmp43 .memory 77
    95 op sub *tmp213 1 .ALL_PASS_COLORING
 
   114 set :i 0
   115 op mul *tmp56 :batch 11
   116 label *label43
-    * jump *label45 greaterThanEq 0 *tmp55
+  117 jump *label45 lessThanEq :multiple 0
   118 label *label145
   119 op add :adam5:index *tmp56 :i
   120 op idiv *tmp59 :adam5:index 16
 
   191 sensor *tmp92 .display @enabled
   192 jump *label75 equal *tmp92 false
   193 sensor *tmp93 .display @bufferSize
-    * op sub *tmp94 1024 *tmp93
-    * jump *label75 greaterThanEq 2 *tmp94
+  194 jump *label75 greaterThanEq *tmp93 1022
   195 drawflush .display
   196 set .localBuffer 0
   197 label *label75
 
   249 op add :compute:i :compute:i 1
   250 jump *label146 lessThan :compute:i 63
   251 label *label88
-    * jump *label91 equal .SMOOTH false
+  252 jump *label91 lessThanEq .PALETTE 1
   253 jump *label91 greaterThanEq :compute:i 63
   254 op log *tmp127 :compute:dist
   255 op mul *tmp128 *tmp127 0.36067376022224085
 
   262 set *tmp97 :compute:i
   263 jump *label79 always
   264 label *label79
-    * jump *label96 equal .SMOOTH false
+  265 jump *label96 lessThanEq .PALETTE 1
   266 set :drawPixel:color %[black]
   267 jump *label99 equal *tmp97 63
   268 label *label98

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   165 select *tmp78 notEqual .ALL_PASS_COLORING false 2 1
   166 set :adam5:dy *tmp78
   167 set :adam5:dx *tmp78
-    * jump *label47 always
   168 label *label60
   169 jump *label47 always
   170 multilabel *label189 (m:*label185)
 
   259 label *label91
   260 label *label92
   261 set *tmp97 :compute:i
-    * jump *label79 always
   262 label *label79
   263 jump *label96 lessThanEq .PALETTE 1
   264 set :drawPixel:color %[black]

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-2 instructions):
 
    21 label *label149
    22 jump *label150 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
+   24 set :findLinkedBlocks:message :findLinkedBlocks:message
    25 label *label150
    26 label *label151
    27 label *label152
 
    30 label *label155
    31 jump *label156 notEqual @memory-bank :findLinkedBlocks:type
    32 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
+   33 set :findLinkedBlocks:message :findLinkedBlocks:message
    34 label *label156
    35 label *label157
    36 label *label158
 
    49 label *label172
    50 label *label173
    51 label *label174
-    * set .display .display
    52 label *label177
    53 print "\n"
    54 print "Memory"
 
    59 label *label178
    60 label *label179
    61 label *label180
-    * set .memory .memory
    62 label *label23
    63 printflush :findLinkedBlocks:message
    64 label *label2

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-3 instructions):
 
   146 op add :adam5:x *tmp67 2
   147 op idiv *tmp69 :adam5:index 44
   148 op mul :adam5:y 4 *tmp69
-    * select *tmp71 notEqual .ALL_PASS_COLORING false 2 1
-    * set :adam5:dx *tmp71
-    * select *tmp72 notEqual .ALL_PASS_COLORING false 4 2
-    * set :adam5:dy *tmp72
+  149 select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1
+  150 select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2
   151 jump *label47 always
   152 label *label53
   153 multilabel *label188 (m:*label185)
 
   172 op idiv *tmp82 :adam5:index 88
   173 op mul :adam5:y 2 *tmp82
   174 set :adam5:dx 1
-    * select *tmp84 notEqual .ALL_PASS_COLORING false 2 1
-    * set :adam5:dy *tmp84
+  175 select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1
   176 label *label47
   177 label *label46
   178 jump *label70 lessThanEq :multiple *tmp44

Modifications by Unroll loop at mandelbrot-compute.mnd:197:5 (+743 instructions):
 
   223 label *label84
   224 label *label85
   225 label *label81
-    * set :compute:i 0
-    * label *label86
-    * label *label146
-    * set :compute:x1 :compute:zx
-    * op mul *tmp115 :compute:zx :compute:zx
-    * op mul *tmp116 :compute:zy :compute:zy
-    * op sub *tmp117 *tmp115 *tmp116
-    * op add :compute:zx *tmp117 :compute:cx
-    * op mul *tmp119 2 :compute:x1
-    * op mul *tmp120 *tmp119 :compute:zy
-    * op add :compute:zy *tmp120 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label89 lessThan :compute:dist 64
-    * jump *label88 always
-    * label *label89
-    * label *label90
-    * label *label87
-    * op add :compute:i :compute:i 1
-    * jump *label146 lessThan :compute:i 63
-    * label *label88
+  226 set :compute:i 0
+  227 label *label198
+  228 set :compute:x1 :compute:zx
+  229 op mul *tmp115 :compute:zx :compute:zx
+  230 op mul *tmp116 :compute:zy :compute:zy
+  231 op sub *tmp117 *tmp115 *tmp116
+  232 op add :compute:zx *tmp117 :compute:cx
+  233 op mul *tmp119 2 :compute:x1
+  234 op mul *tmp120 *tmp119 :compute:zy
+  235 op add :compute:zy *tmp120 :compute:cy
+  236 op len :compute:dist :compute:zx :compute:zy
+  237 jump *label199 lessThan :compute:dist 64
+  238 jump *label88 always
+  239 label *label199
+  240 label *label200
+  241 label *label201
+  242 op add :compute:i :compute:i 1
+  243 set :compute:x1 :compute:zx
+  244 op mul *tmp115 :compute:zx :compute:zx
+  245 op mul *tmp116 :compute:zy :compute:zy
+  246 op sub *tmp117 *tmp115 *tmp116
+  247 op add :compute:zx *tmp117 :compute:cx
+  248 op mul *tmp119 2 :compute:x1
+  249 op mul *tmp120 *tmp119 :compute:zy
+  250 op add :compute:zy *tmp120 :compute:cy
+  251 op len :compute:dist :compute:zx :compute:zy
+  252 jump *label202 lessThan :compute:dist 64
+  253 jump *label88 always
+  254 label *label202
+  255 label *label203
+  256 label *label204
+  257 op add :compute:i :compute:i 1
+  258 set :compute:x1 :compute:zx
+  259 op mul *tmp115 :compute:zx :compute:zx
+  260 op mul *tmp116 :compute:zy :compute:zy
+  261 op sub *tmp117 *tmp115 *tmp116
+  262 op add :compute:zx *tmp117 :compute:cx
+  263 op mul *tmp119 2 :compute:x1
+  264 op mul *tmp120 *tmp119 :compute:zy
+  265 op add :compute:zy *tmp120 :compute:cy
+  266 op len :compute:dist :compute:zx :compute:zy
+  267 jump *label205 lessThan :compute:dist 64
+  268 jump *label88 always
+  269 label *label205
+  270 label *label206
+  271 label *label207
+  272 op add :compute:i :compute:i 1
+  273 set :compute:x1 :compute:zx
+  274 op mul *tmp115 :compute:zx :compute:zx
+  275 op mul *tmp116 :compute:zy :compute:zy
+  276 op sub *tmp117 *tmp115 *tmp116
+  277 op add :compute:zx *tmp117 :compute:cx
+  278 op mul *tmp119 2 :compute:x1
+  279 op mul *tmp120 *tmp119 :compute:zy
+  280 op add :compute:zy *tmp120 :compute:cy
+  281 op len :compute:dist :compute:zx :compute:zy
+  282 jump *label208 lessThan :compute:dist 64
+  283 jump *label88 always
+  284 label *label208
+  285 label *label209
+  286 label *label210
+  287 op add :compute:i :compute:i 1
+  288 set :compute:x1 :compute:zx
+  289 op mul *tmp115 :compute:zx :compute:zx
+  290 op mul *tmp116 :compute:zy :compute:zy
+  291 op sub *tmp117 *tmp115 *tmp116
+  292 op add :compute:zx *tmp117 :compute:cx
+  293 op mul *tmp119 2 :compute:x1
+  294 op mul *tmp120 *tmp119 :compute:zy
+  295 op add :compute:zy *tmp120 :compute:cy
+  296 op len :compute:dist :compute:zx :compute:zy
+  297 jump *label211 lessThan :compute:dist 64
+  298 jump *label88 always
+  299 label *label211
+  300 label *label212
+  301 label *label213
+  302 op add :compute:i :compute:i 1
+  303 set :compute:x1 :compute:zx
+  304 op mul *tmp115 :compute:zx :compute:zx
+  305 op mul *tmp116 :compute:zy :compute:zy
+  306 op sub *tmp117 *tmp115 *tmp116
+  307 op add :compute:zx *tmp117 :compute:cx
+  308 op mul *tmp119 2 :compute:x1
+  309 op mul *tmp120 *tmp119 :compute:zy
+  310 op add :compute:zy *tmp120 :compute:cy
+  311 op len :compute:dist :compute:zx :compute:zy
+  312 jump *label214 lessThan :compute:dist 64
+  313 jump *label88 always
+  314 label *label214
+  315 label *label215
+  316 label *label216
+  317 op add :compute:i :compute:i 1
+  318 set :compute:x1 :compute:zx
+  319 op mul *tmp115 :compute:zx :compute:zx
+  320 op mul *tmp116 :compute:zy :compute:zy
+  321 op sub *tmp117 *tmp115 *tmp116
+  322 op add :compute:zx *tmp117 :compute:cx
+  323 op mul *tmp119 2 :compute:x1
+  324 op mul *tmp120 *tmp119 :compute:zy
+  325 op add :compute:zy *tmp120 :compute:cy
+  326 op len :compute:dist :compute:zx :compute:zy
+  327 jump *label217 lessThan :compute:dist 64
+  328 jump *label88 always
+  329 label *label217
+  330 label *label218
+  331 label *label219
+  332 op add :compute:i :compute:i 1
+  333 set :compute:x1 :compute:zx
+  334 op mul *tmp115 :compute:zx :compute:zx
+  335 op mul *tmp116 :compute:zy :compute:zy
+  336 op sub *tmp117 *tmp115 *tmp116
+  337 op add :compute:zx *tmp117 :compute:cx
+  338 op mul *tmp119 2 :compute:x1
+  339 op mul *tmp120 *tmp119 :compute:zy
+  340 op add :compute:zy *tmp120 :compute:cy
+  341 op len :compute:dist :compute:zx :compute:zy
+  342 jump *label220 lessThan :compute:dist 64
+  343 jump *label88 always
+  344 label *label220
+  345 label *label221
+  346 label *label222
+  347 op add :compute:i :compute:i 1
+  348 set :compute:x1 :compute:zx
+  349 op mul *tmp115 :compute:zx :compute:zx
+  350 op mul *tmp116 :compute:zy :compute:zy
+  351 op sub *tmp117 *tmp115 *tmp116
+  352 op add :compute:zx *tmp117 :compute:cx
+  353 op mul *tmp119 2 :compute:x1
+  354 op mul *tmp120 *tmp119 :compute:zy
+  355 op add :compute:zy *tmp120 :compute:cy
+  356 op len :compute:dist :compute:zx :compute:zy
+  357 jump *label223 lessThan :compute:dist 64
+  358 jump *label88 always
+  359 label *label223
+  360 label *label224
+  361 label *label225
+  362 op add :compute:i :compute:i 1
+  363 set :compute:x1 :compute:zx
+  364 op mul *tmp115 :compute:zx :compute:zx
+  365 op mul *tmp116 :compute:zy :compute:zy
+  366 op sub *tmp117 *tmp115 *tmp116
+  367 op add :compute:zx *tmp117 :compute:cx
+  368 op mul *tmp119 2 :compute:x1
+  369 op mul *tmp120 *tmp119 :compute:zy
+  370 op add :compute:zy *tmp120 :compute:cy
+  371 op len :compute:dist :compute:zx :compute:zy
+  372 jump *label226 lessThan :compute:dist 64
+  373 jump *label88 always
+  374 label *label226
+  375 label *label227
+  376 label *label228
+  377 op add :compute:i :compute:i 1
+  378 set :compute:x1 :compute:zx
+  379 op mul *tmp115 :compute:zx :compute:zx
+  380 op mul *tmp116 :compute:zy :compute:zy
+  381 op sub *tmp117 *tmp115 *tmp116
+  382 op add :compute:zx *tmp117 :compute:cx
+  383 op mul *tmp119 2 :compute:x1
+  384 op mul *tmp120 *tmp119 :compute:zy
+  385 op add :compute:zy *tmp120 :compute:cy
+  386 op len :compute:dist :compute:zx :compute:zy
+  387 jump *label229 lessThan :compute:dist 64
+  388 jump *label88 always
+  389 label *label229
+  390 label *label230
+  391 label *label231
+  392 op add :compute:i :compute:i 1
+  393 set :compute:x1 :compute:zx
+  394 op mul *tmp115 :compute:zx :compute:zx
+  395 op mul *tmp116 :compute:zy :compute:zy
+  396 op sub *tmp117 *tmp115 *tmp116
+  397 op add :compute:zx *tmp117 :compute:cx
+  398 op mul *tmp119 2 :compute:x1
+  399 op mul *tmp120 *tmp119 :compute:zy
+  400 op add :compute:zy *tmp120 :compute:cy
+  401 op len :compute:dist :compute:zx :compute:zy
+  402 jump *label232 lessThan :compute:dist 64
+  403 jump *label88 always
+  404 label *label232
+  405 label *label233
+  406 label *label234
+  407 op add :compute:i :compute:i 1
+  408 set :compute:x1 :compute:zx
+  409 op mul *tmp115 :compute:zx :compute:zx
+  410 op mul *tmp116 :compute:zy :compute:zy
+  411 op sub *tmp117 *tmp115 *tmp116
+  412 op add :compute:zx *tmp117 :compute:cx
+  413 op mul *tmp119 2 :compute:x1
+  414 op mul *tmp120 *tmp119 :compute:zy
+  415 op add :compute:zy *tmp120 :compute:cy
+  416 op len :compute:dist :compute:zx :compute:zy
+  417 jump *label235 lessThan :compute:dist 64
+  418 jump *label88 always
+  419 label *label235
+  420 label *label236
+  421 label *label237
+  422 op add :compute:i :compute:i 1
+  423 set :compute:x1 :compute:zx
+  424 op mul *tmp115 :compute:zx :compute:zx
+  425 op mul *tmp116 :compute:zy :compute:zy
+  426 op sub *tmp117 *tmp115 *tmp116
+  427 op add :compute:zx *tmp117 :compute:cx
+  428 op mul *tmp119 2 :compute:x1
+  429 op mul *tmp120 *tmp119 :compute:zy
+  430 op add :compute:zy *tmp120 :compute:cy
+  431 op len :compute:dist :compute:zx :compute:zy
+  432 jump *label238 lessThan :compute:dist 64
+  433 jump *label88 always
+  434 label *label238
+  435 label *label239
+  436 label *label240
+  437 op add :compute:i :compute:i 1
+  438 set :compute:x1 :compute:zx
+  439 op mul *tmp115 :compute:zx :compute:zx
+  440 op mul *tmp116 :compute:zy :compute:zy
+  441 op sub *tmp117 *tmp115 *tmp116
+  442 op add :compute:zx *tmp117 :compute:cx
+  443 op mul *tmp119 2 :compute:x1
+  444 op mul *tmp120 *tmp119 :compute:zy
+  445 op add :compute:zy *tmp120 :compute:cy
+  446 op len :compute:dist :compute:zx :compute:zy
+  447 jump *label241 lessThan :compute:dist 64
+  448 jump *label88 always
+  449 label *label241
+  450 label *label242
+  451 label *label243
+  452 op add :compute:i :compute:i 1
+  453 set :compute:x1 :compute:zx
+  454 op mul *tmp115 :compute:zx :compute:zx
+  455 op mul *tmp116 :compute:zy :compute:zy
+  456 op sub *tmp117 *tmp115 *tmp116
+  457 op add :compute:zx *tmp117 :compute:cx
+  458 op mul *tmp119 2 :compute:x1
+  459 op mul *tmp120 *tmp119 :compute:zy
+  460 op add :compute:zy *tmp120 :compute:cy
+  461 op len :compute:dist :compute:zx :compute:zy
+  462 jump *label244 lessThan :compute:dist 64
+  463 jump *label88 always
+  464 label *label244
+  465 label *label245
+  466 label *label246
+  467 op add :compute:i :compute:i 1
+  468 set :compute:x1 :compute:zx
+  469 op mul *tmp115 :compute:zx :compute:zx
+  470 op mul *tmp116 :compute:zy :compute:zy
+  471 op sub *tmp117 *tmp115 *tmp116
+  472 op add :compute:zx *tmp117 :compute:cx
+  473 op mul *tmp119 2 :compute:x1
+  474 op mul *tmp120 *tmp119 :compute:zy
+  475 op add :compute:zy *tmp120 :compute:cy
+  476 op len :compute:dist :compute:zx :compute:zy
+  477 jump *label247 lessThan :compute:dist 64
+  478 jump *label88 always
+  479 label *label247
+  480 label *label248
+  481 label *label249
+  482 op add :compute:i :compute:i 1
+  483 set :compute:x1 :compute:zx
+  484 op mul *tmp115 :compute:zx :compute:zx
+  485 op mul *tmp116 :compute:zy :compute:zy
+  486 op sub *tmp117 *tmp115 *tmp116
+  487 op add :compute:zx *tmp117 :compute:cx
+  488 op mul *tmp119 2 :compute:x1
+  489 op mul *tmp120 *tmp119 :compute:zy
+  490 op add :compute:zy *tmp120 :compute:cy
+  491 op len :compute:dist :compute:zx :compute:zy
+  492 jump *label250 lessThan :compute:dist 64
+  493 jump *label88 always
+  494 label *label250
+  495 label *label251
+  496 label *label252
+  497 op add :compute:i :compute:i 1
+  498 set :compute:x1 :compute:zx
+  499 op mul *tmp115 :compute:zx :compute:zx
+  500 op mul *tmp116 :compute:zy :compute:zy
+  501 op sub *tmp117 *tmp115 *tmp116
+  502 op add :compute:zx *tmp117 :compute:cx
+  503 op mul *tmp119 2 :compute:x1
+  504 op mul *tmp120 *tmp119 :compute:zy
+  505 op add :compute:zy *tmp120 :compute:cy
+  506 op len :compute:dist :compute:zx :compute:zy
+  507 jump *label253 lessThan :compute:dist 64
+  508 jump *label88 always
+  509 label *label253
+  510 label *label254
+  511 label *label255
+  512 op add :compute:i :compute:i 1
+  513 set :compute:x1 :compute:zx
+  514 op mul *tmp115 :compute:zx :compute:zx
+  515 op mul *tmp116 :compute:zy :compute:zy
+  516 op sub *tmp117 *tmp115 *tmp116
+  517 op add :compute:zx *tmp117 :compute:cx
+  518 op mul *tmp119 2 :compute:x1
+  519 op mul *tmp120 *tmp119 :compute:zy
+  520 op add :compute:zy *tmp120 :compute:cy
+  521 op len :compute:dist :compute:zx :compute:zy
+  522 jump *label256 lessThan :compute:dist 64
+  523 jump *label88 always
+  524 label *label256
+  525 label *label257
+  526 label *label258
+  527 op add :compute:i :compute:i 1
+  528 set :compute:x1 :compute:zx
+  529 op mul *tmp115 :compute:zx :compute:zx
+  530 op mul *tmp116 :compute:zy :compute:zy
+  531 op sub *tmp117 *tmp115 *tmp116
+  532 op add :compute:zx *tmp117 :compute:cx
+  533 op mul *tmp119 2 :compute:x1
+  534 op mul *tmp120 *tmp119 :compute:zy
+  535 op add :compute:zy *tmp120 :compute:cy
+  536 op len :compute:dist :compute:zx :compute:zy
+  537 jump *label259 lessThan :compute:dist 64
+  538 jump *label88 always
+  539 label *label259
+  540 label *label260
+  541 label *label261
+  542 op add :compute:i :compute:i 1
+  543 set :compute:x1 :compute:zx
+  544 op mul *tmp115 :compute:zx :compute:zx
+  545 op mul *tmp116 :compute:zy :compute:zy
+  546 op sub *tmp117 *tmp115 *tmp116
+  547 op add :compute:zx *tmp117 :compute:cx
+  548 op mul *tmp119 2 :compute:x1
+  549 op mul *tmp120 *tmp119 :compute:zy
+  550 op add :compute:zy *tmp120 :compute:cy
+  551 op len :compute:dist :compute:zx :compute:zy
+  552 jump *label262 lessThan :compute:dist 64
+  553 jump *label88 always
+  554 label *label262
+  555 label *label263
+  556 label *label264
+  557 op add :compute:i :compute:i 1
+  558 set :compute:x1 :compute:zx
+  559 op mul *tmp115 :compute:zx :compute:zx
+  560 op mul *tmp116 :compute:zy :compute:zy
+  561 op sub *tmp117 *tmp115 *tmp116
+  562 op add :compute:zx *tmp117 :compute:cx
+  563 op mul *tmp119 2 :compute:x1
+  564 op mul *tmp120 *tmp119 :compute:zy
+  565 op add :compute:zy *tmp120 :compute:cy
+  566 op len :compute:dist :compute:zx :compute:zy
+  567 jump *label265 lessThan :compute:dist 64
+  568 jump *label88 always
+  569 label *label265
+  570 label *label266
+  571 label *label267
+  572 op add :compute:i :compute:i 1
+  573 set :compute:x1 :compute:zx
+  574 op mul *tmp115 :compute:zx :compute:zx
+  575 op mul *tmp116 :compute:zy :compute:zy
+  576 op sub *tmp117 *tmp115 *tmp116
+  577 op add :compute:zx *tmp117 :compute:cx
+  578 op mul *tmp119 2 :compute:x1
+  579 op mul *tmp120 *tmp119 :compute:zy
+  580 op add :compute:zy *tmp120 :compute:cy
+  581 op len :compute:dist :compute:zx :compute:zy
+  582 jump *label268 lessThan :compute:dist 64
+  583 jump *label88 always
+  584 label *label268
+  585 label *label269
+  586 label *label270
+  587 op add :compute:i :compute:i 1
+  588 set :compute:x1 :compute:zx
+  589 op mul *tmp115 :compute:zx :compute:zx
+  590 op mul *tmp116 :compute:zy :compute:zy
+  591 op sub *tmp117 *tmp115 *tmp116
+  592 op add :compute:zx *tmp117 :compute:cx
+  593 op mul *tmp119 2 :compute:x1
+  594 op mul *tmp120 *tmp119 :compute:zy
+  595 op add :compute:zy *tmp120 :compute:cy
+  596 op len :compute:dist :compute:zx :compute:zy
+  597 jump *label271 lessThan :compute:dist 64
+  598 jump *label88 always
+  599 label *label271
+  600 label *label272
+  601 label *label273
+  602 op add :compute:i :compute:i 1
+  603 set :compute:x1 :compute:zx
+  604 op mul *tmp115 :compute:zx :compute:zx
+  605 op mul *tmp116 :compute:zy :compute:zy
+  606 op sub *tmp117 *tmp115 *tmp116
+  607 op add :compute:zx *tmp117 :compute:cx
+  608 op mul *tmp119 2 :compute:x1
+  609 op mul *tmp120 *tmp119 :compute:zy
+  610 op add :compute:zy *tmp120 :compute:cy
+  611 op len :compute:dist :compute:zx :compute:zy
+  612 jump *label274 lessThan :compute:dist 64
+  613 jump *label88 always
+  614 label *label274
+  615 label *label275
+  616 label *label276
+  617 op add :compute:i :compute:i 1
+  618 set :compute:x1 :compute:zx
+  619 op mul *tmp115 :compute:zx :compute:zx
+  620 op mul *tmp116 :compute:zy :compute:zy
+  621 op sub *tmp117 *tmp115 *tmp116
+  622 op add :compute:zx *tmp117 :compute:cx
+  623 op mul *tmp119 2 :compute:x1
+  624 op mul *tmp120 *tmp119 :compute:zy
+  625 op add :compute:zy *tmp120 :compute:cy
+  626 op len :compute:dist :compute:zx :compute:zy
+  627 jump *label277 lessThan :compute:dist 64
+  628 jump *label88 always
+  629 label *label277
+  630 label *label278
+  631 label *label279
+  632 op add :compute:i :compute:i 1
+  633 set :compute:x1 :compute:zx
+  634 op mul *tmp115 :compute:zx :compute:zx
+  635 op mul *tmp116 :compute:zy :compute:zy
+  636 op sub *tmp117 *tmp115 *tmp116
+  637 op add :compute:zx *tmp117 :compute:cx
+  638 op mul *tmp119 2 :compute:x1
+  639 op mul *tmp120 *tmp119 :compute:zy
+  640 op add :compute:zy *tmp120 :compute:cy
+  641 op len :compute:dist :compute:zx :compute:zy
+  642 jump *label280 lessThan :compute:dist 64
+  643 jump *label88 always
+  644 label *label280
+  645 label *label281
+  646 label *label282
+  647 op add :compute:i :compute:i 1
+  648 set :compute:x1 :compute:zx
+  649 op mul *tmp115 :compute:zx :compute:zx
+  650 op mul *tmp116 :compute:zy :compute:zy
+  651 op sub *tmp117 *tmp115 *tmp116
+  652 op add :compute:zx *tmp117 :compute:cx
+  653 op mul *tmp119 2 :compute:x1
+  654 op mul *tmp120 *tmp119 :compute:zy
+  655 op add :compute:zy *tmp120 :compute:cy
+  656 op len :compute:dist :compute:zx :compute:zy
+  657 jump *label283 lessThan :compute:dist 64
+  658 jump *label88 always
+  659 label *label283
+  660 label *label284
+  661 label *label285
+  662 op add :compute:i :compute:i 1
+  663 set :compute:x1 :compute:zx
+  664 op mul *tmp115 :compute:zx :compute:zx
+  665 op mul *tmp116 :compute:zy :compute:zy
+  666 op sub *tmp117 *tmp115 *tmp116
+  667 op add :compute:zx *tmp117 :compute:cx
+  668 op mul *tmp119 2 :compute:x1
+  669 op mul *tmp120 *tmp119 :compute:zy
+  670 op add :compute:zy *tmp120 :compute:cy
+  671 op len :compute:dist :compute:zx :compute:zy
+  672 jump *label286 lessThan :compute:dist 64
+  673 jump *label88 always
+  674 label *label286
+  675 label *label287
+  676 label *label288
+  677 op add :compute:i :compute:i 1
+  678 set :compute:x1 :compute:zx
+  679 op mul *tmp115 :compute:zx :compute:zx
+  680 op mul *tmp116 :compute:zy :compute:zy
+  681 op sub *tmp117 *tmp115 *tmp116
+  682 op add :compute:zx *tmp117 :compute:cx
+  683 op mul *tmp119 2 :compute:x1
+  684 op mul *tmp120 *tmp119 :compute:zy
+  685 op add :compute:zy *tmp120 :compute:cy
+  686 op len :compute:dist :compute:zx :compute:zy
+  687 jump *label289 lessThan :compute:dist 64
+  688 jump *label88 always
+  689 label *label289
+  690 label *label290
+  691 label *label291
+  692 op add :compute:i :compute:i 1
+  693 set :compute:x1 :compute:zx
+  694 op mul *tmp115 :compute:zx :compute:zx
+  695 op mul *tmp116 :compute:zy :compute:zy
+  696 op sub *tmp117 *tmp115 *tmp116
+  697 op add :compute:zx *tmp117 :compute:cx
+  698 op mul *tmp119 2 :compute:x1
+  699 op mul *tmp120 *tmp119 :compute:zy
+  700 op add :compute:zy *tmp120 :compute:cy
+  701 op len :compute:dist :compute:zx :compute:zy
+  702 jump *label292 lessThan :compute:dist 64
+  703 jump *label88 always
+  704 label *label292
+  705 label *label293
+  706 label *label294
+  707 op add :compute:i :compute:i 1
+  708 set :compute:x1 :compute:zx
+  709 op mul *tmp115 :compute:zx :compute:zx
+  710 op mul *tmp116 :compute:zy :compute:zy
+  711 op sub *tmp117 *tmp115 *tmp116
+  712 op add :compute:zx *tmp117 :compute:cx
+  713 op mul *tmp119 2 :compute:x1
+  714 op mul *tmp120 *tmp119 :compute:zy
+  715 op add :compute:zy *tmp120 :compute:cy
+  716 op len :compute:dist :compute:zx :compute:zy
+  717 jump *label295 lessThan :compute:dist 64
+  718 jump *label88 always
+  719 label *label295
+  720 label *label296
+  721 label *label297
+  722 op add :compute:i :compute:i 1
+  723 set :compute:x1 :compute:zx
+  724 op mul *tmp115 :compute:zx :compute:zx
+  725 op mul *tmp116 :compute:zy :compute:zy
+  726 op sub *tmp117 *tmp115 *tmp116
+  727 op add :compute:zx *tmp117 :compute:cx
+  728 op mul *tmp119 2 :compute:x1
+  729 op mul *tmp120 *tmp119 :compute:zy
+  730 op add :compute:zy *tmp120 :compute:cy
+  731 op len :compute:dist :compute:zx :compute:zy
+  732 jump *label298 lessThan :compute:dist 64
+  733 jump *label88 always
+  734 label *label298
+  735 label *label299
+  736 label *label300
+  737 op add :compute:i :compute:i 1
+  738 set :compute:x1 :compute:zx
+  739 op mul *tmp115 :compute:zx :compute:zx
+  740 op mul *tmp116 :compute:zy :compute:zy
+  741 op sub *tmp117 *tmp115 *tmp116
+  742 op add :compute:zx *tmp117 :compute:cx
+  743 op mul *tmp119 2 :compute:x1
+  744 op mul *tmp120 *tmp119 :compute:zy
+  745 op add :compute:zy *tmp120 :compute:cy
+  746 op len :compute:dist :compute:zx :compute:zy
+  747 jump *label301 lessThan :compute:dist 64
+  748 jump *label88 always
+  749 label *label301
+  750 label *label302
+  751 label *label303
+  752 op add :compute:i :compute:i 1
+  753 set :compute:x1 :compute:zx
+  754 op mul *tmp115 :compute:zx :compute:zx
+  755 op mul *tmp116 :compute:zy :compute:zy
+  756 op sub *tmp117 *tmp115 *tmp116
+  757 op add :compute:zx *tmp117 :compute:cx
+  758 op mul *tmp119 2 :compute:x1
+  759 op mul *tmp120 *tmp119 :compute:zy
+  760 op add :compute:zy *tmp120 :compute:cy
+  761 op len :compute:dist :compute:zx :compute:zy
+  762 jump *label304 lessThan :compute:dist 64
+  763 jump *label88 always
+  764 label *label304
+  765 label *label305
+  766 label *label306
+  767 op add :compute:i :compute:i 1
+  768 set :compute:x1 :compute:zx
+  769 op mul *tmp115 :compute:zx :compute:zx
+  770 op mul *tmp116 :compute:zy :compute:zy
+  771 op sub *tmp117 *tmp115 *tmp116
+  772 op add :compute:zx *tmp117 :compute:cx
+  773 op mul *tmp119 2 :compute:x1
+  774 op mul *tmp120 *tmp119 :compute:zy
+  775 op add :compute:zy *tmp120 :compute:cy
+  776 op len :compute:dist :compute:zx :compute:zy
+  777 jump *label307 lessThan :compute:dist 64
+  778 jump *label88 always
+  779 label *label307
+  780 label *label308
+  781 label *label309
+  782 op add :compute:i :compute:i 1
+  783 set :compute:x1 :compute:zx
+  784 op mul *tmp115 :compute:zx :compute:zx
+  785 op mul *tmp116 :compute:zy :compute:zy
+  786 op sub *tmp117 *tmp115 *tmp116
+  787 op add :compute:zx *tmp117 :compute:cx
+  788 op mul *tmp119 2 :compute:x1
+  789 op mul *tmp120 *tmp119 :compute:zy
+  790 op add :compute:zy *tmp120 :compute:cy
+  791 op len :compute:dist :compute:zx :compute:zy
+  792 jump *label310 lessThan :compute:dist 64
+  793 jump *label88 always
+  794 label *label310
+  795 label *label311
+  796 label *label312
+  797 op add :compute:i :compute:i 1
+  798 set :compute:x1 :compute:zx
+  799 op mul *tmp115 :compute:zx :compute:zx
+  800 op mul *tmp116 :compute:zy :compute:zy
+  801 op sub *tmp117 *tmp115 *tmp116
+  802 op add :compute:zx *tmp117 :compute:cx
+  803 op mul *tmp119 2 :compute:x1
+  804 op mul *tmp120 *tmp119 :compute:zy
+  805 op add :compute:zy *tmp120 :compute:cy
+  806 op len :compute:dist :compute:zx :compute:zy
+  807 jump *label313 lessThan :compute:dist 64
+  808 jump *label88 always
+  809 label *label313
+  810 label *label314
+  811 label *label315
+  812 op add :compute:i :compute:i 1
+  813 set :compute:x1 :compute:zx
+  814 op mul *tmp115 :compute:zx :compute:zx
+  815 op mul *tmp116 :compute:zy :compute:zy
+  816 op sub *tmp117 *tmp115 *tmp116
+  817 op add :compute:zx *tmp117 :compute:cx
+  818 op mul *tmp119 2 :compute:x1
+  819 op mul *tmp120 *tmp119 :compute:zy
+  820 op add :compute:zy *tmp120 :compute:cy
+  821 op len :compute:dist :compute:zx :compute:zy
+  822 jump *label316 lessThan :compute:dist 64
+  823 jump *label88 always
+  824 label *label316
+  825 label *label317
+  826 label *label318
+  827 op add :compute:i :compute:i 1
+  828 set :compute:x1 :compute:zx
+  829 op mul *tmp115 :compute:zx :compute:zx
+  830 op mul *tmp116 :compute:zy :compute:zy
+  831 op sub *tmp117 *tmp115 *tmp116
+  832 op add :compute:zx *tmp117 :compute:cx
+  833 op mul *tmp119 2 :compute:x1
+  834 op mul *tmp120 *tmp119 :compute:zy
+  835 op add :compute:zy *tmp120 :compute:cy
+  836 op len :compute:dist :compute:zx :compute:zy
+  837 jump *label319 lessThan :compute:dist 64
+  838 jump *label88 always
+  839 label *label319
+  840 label *label320
+  841 label *label321
+  842 op add :compute:i :compute:i 1
+  843 set :compute:x1 :compute:zx
+  844 op mul *tmp115 :compute:zx :compute:zx
+  845 op mul *tmp116 :compute:zy :compute:zy
+  846 op sub *tmp117 *tmp115 *tmp116
+  847 op add :compute:zx *tmp117 :compute:cx
+  848 op mul *tmp119 2 :compute:x1
+  849 op mul *tmp120 *tmp119 :compute:zy
+  850 op add :compute:zy *tmp120 :compute:cy
+  851 op len :compute:dist :compute:zx :compute:zy
+  852 jump *label322 lessThan :compute:dist 64
+  853 jump *label88 always
+  854 label *label322
+  855 label *label323
+  856 label *label324
+  857 op add :compute:i :compute:i 1
+  858 set :compute:x1 :compute:zx
+  859 op mul *tmp115 :compute:zx :compute:zx
+  860 op mul *tmp116 :compute:zy :compute:zy
+  861 op sub *tmp117 *tmp115 *tmp116
+  862 op add :compute:zx *tmp117 :compute:cx
+  863 op mul *tmp119 2 :compute:x1
+  864 op mul *tmp120 *tmp119 :compute:zy
+  865 op add :compute:zy *tmp120 :compute:cy
+  866 op len :compute:dist :compute:zx :compute:zy
+  867 jump *label325 lessThan :compute:dist 64
+  868 jump *label88 always
+  869 label *label325
+  870 label *label326
+  871 label *label327
+  872 op add :compute:i :compute:i 1
+  873 set :compute:x1 :compute:zx
+  874 op mul *tmp115 :compute:zx :compute:zx
+  875 op mul *tmp116 :compute:zy :compute:zy
+  876 op sub *tmp117 *tmp115 *tmp116
+  877 op add :compute:zx *tmp117 :compute:cx
+  878 op mul *tmp119 2 :compute:x1
+  879 op mul *tmp120 *tmp119 :compute:zy
+  880 op add :compute:zy *tmp120 :compute:cy
+  881 op len :compute:dist :compute:zx :compute:zy
+  882 jump *label328 lessThan :compute:dist 64
+  883 jump *label88 always
+  884 label *label328
+  885 label *label329
+  886 label *label330
+  887 op add :compute:i :compute:i 1
+  888 set :compute:x1 :compute:zx
+  889 op mul *tmp115 :compute:zx :compute:zx
+  890 op mul *tmp116 :compute:zy :compute:zy
+  891 op sub *tmp117 *tmp115 *tmp116
+  892 op add :compute:zx *tmp117 :compute:cx
+  893 op mul *tmp119 2 :compute:x1
+  894 op mul *tmp120 *tmp119 :compute:zy
+  895 op add :compute:zy *tmp120 :compute:cy
+  896 op len :compute:dist :compute:zx :compute:zy
+  897 jump *label331 lessThan :compute:dist 64
+  898 jump *label88 always
+  899 label *label331
+  900 label *label332
+  901 label *label333
+  902 op add :compute:i :compute:i 1
+  903 set :compute:x1 :compute:zx
+  904 op mul *tmp115 :compute:zx :compute:zx
+  905 op mul *tmp116 :compute:zy :compute:zy
+  906 op sub *tmp117 *tmp115 *tmp116
+  907 op add :compute:zx *tmp117 :compute:cx
+  908 op mul *tmp119 2 :compute:x1
+  909 op mul *tmp120 *tmp119 :compute:zy
+  910 op add :compute:zy *tmp120 :compute:cy
+  911 op len :compute:dist :compute:zx :compute:zy
+  912 jump *label334 lessThan :compute:dist 64
+  913 jump *label88 always
+  914 label *label334
+  915 label *label335
+  916 label *label336
+  917 op add :compute:i :compute:i 1
+  918 set :compute:x1 :compute:zx
+  919 op mul *tmp115 :compute:zx :compute:zx
+  920 op mul *tmp116 :compute:zy :compute:zy
+  921 op sub *tmp117 *tmp115 *tmp116
+  922 op add :compute:zx *tmp117 :compute:cx
+  923 op mul *tmp119 2 :compute:x1
+  924 op mul *tmp120 *tmp119 :compute:zy
+  925 op add :compute:zy *tmp120 :compute:cy
+  926 op len :compute:dist :compute:zx :compute:zy
+  927 jump *label337 lessThan :compute:dist 64
+  928 jump *label88 always
+  929 label *label337
+  930 label *label338
+  931 label *label339
+  932 op add :compute:i :compute:i 1
+  933 set :compute:x1 :compute:zx
+  934 op mul *tmp115 :compute:zx :compute:zx
+  935 op mul *tmp116 :compute:zy :compute:zy
+  936 op sub *tmp117 *tmp115 *tmp116
+  937 op add :compute:zx *tmp117 :compute:cx
+  938 op mul *tmp119 2 :compute:x1
+  939 op mul *tmp120 *tmp119 :compute:zy
+  940 op add :compute:zy *tmp120 :compute:cy
+  941 op len :compute:dist :compute:zx :compute:zy
+  942 jump *label340 lessThan :compute:dist 64
+  943 jump *label88 always
+  944 label *label340
+  945 label *label341
+  946 label *label342
+  947 op add :compute:i :compute:i 1
+  948 set :compute:x1 :compute:zx
+  949 op mul *tmp115 :compute:zx :compute:zx
+  950 op mul *tmp116 :compute:zy :compute:zy
+  951 op sub *tmp117 *tmp115 *tmp116
+  952 op add :compute:zx *tmp117 :compute:cx
+  953 op mul *tmp119 2 :compute:x1
+  954 op mul *tmp120 *tmp119 :compute:zy
+  955 op add :compute:zy *tmp120 :compute:cy
+  956 op len :compute:dist :compute:zx :compute:zy
+  957 jump *label343 lessThan :compute:dist 64
+  958 jump *label88 always
+  959 label *label343
+  960 label *label344
+  961 label *label345
+  962 op add :compute:i :compute:i 1
+  963 set :compute:x1 :compute:zx
+  964 op mul *tmp115 :compute:zx :compute:zx
+  965 op mul *tmp116 :compute:zy :compute:zy
+  966 op sub *tmp117 *tmp115 *tmp116
+  967 op add :compute:zx *tmp117 :compute:cx
+  968 op mul *tmp119 2 :compute:x1
+  969 op mul *tmp120 *tmp119 :compute:zy
+  970 op add :compute:zy *tmp120 :compute:cy
+  971 op len :compute:dist :compute:zx :compute:zy
+  972 jump *label346 lessThan :compute:dist 64
+  973 jump *label88 always
+  974 label *label346
+  975 label *label347
+  976 label *label348
+  977 op add :compute:i :compute:i 1
+  978 set :compute:x1 :compute:zx
+  979 op mul *tmp115 :compute:zx :compute:zx
+  980 op mul *tmp116 :compute:zy :compute:zy
+  981 op sub *tmp117 *tmp115 *tmp116
+  982 op add :compute:zx *tmp117 :compute:cx
+  983 op mul *tmp119 2 :compute:x1
+  984 op mul *tmp120 *tmp119 :compute:zy
+  985 op add :compute:zy *tmp120 :compute:cy
+  986 op len :compute:dist :compute:zx :compute:zy
+  987 jump *label349 lessThan :compute:dist 64
+  988 jump *label88 always
+  989 label *label349
+  990 label *label350
+  991 label *label351
+  992 op add :compute:i :compute:i 1
+  993 set :compute:x1 :compute:zx
+  994 op mul *tmp115 :compute:zx :compute:zx
+  995 op mul *tmp116 :compute:zy :compute:zy
+  996 op sub *tmp117 *tmp115 *tmp116
+  997 op add :compute:zx *tmp117 :compute:cx
+  998 op mul *tmp119 2 :compute:x1
+  999 op mul *tmp120 *tmp119 :compute:zy
+ 1000 op add :compute:zy *tmp120 :compute:cy
+ 1001 op len :compute:dist :compute:zx :compute:zy
+ 1002 jump *label352 lessThan :compute:dist 64
+ 1003 jump *label88 always
+ 1004 label *label352
+ 1005 label *label353
+ 1006 label *label354
+ 1007 op add :compute:i :compute:i 1
+ 1008 set :compute:x1 :compute:zx
+ 1009 op mul *tmp115 :compute:zx :compute:zx
+ 1010 op mul *tmp116 :compute:zy :compute:zy
+ 1011 op sub *tmp117 *tmp115 *tmp116
+ 1012 op add :compute:zx *tmp117 :compute:cx
+ 1013 op mul *tmp119 2 :compute:x1
+ 1014 op mul *tmp120 *tmp119 :compute:zy
+ 1015 op add :compute:zy *tmp120 :compute:cy
+ 1016 op len :compute:dist :compute:zx :compute:zy
+ 1017 jump *label355 lessThan :compute:dist 64
+ 1018 jump *label88 always
+ 1019 label *label355
+ 1020 label *label356
+ 1021 label *label357
+ 1022 op add :compute:i :compute:i 1
+ 1023 set :compute:x1 :compute:zx
+ 1024 op mul *tmp115 :compute:zx :compute:zx
+ 1025 op mul *tmp116 :compute:zy :compute:zy
+ 1026 op sub *tmp117 *tmp115 *tmp116
+ 1027 op add :compute:zx *tmp117 :compute:cx
+ 1028 op mul *tmp119 2 :compute:x1
+ 1029 op mul *tmp120 *tmp119 :compute:zy
+ 1030 op add :compute:zy *tmp120 :compute:cy
+ 1031 op len :compute:dist :compute:zx :compute:zy
+ 1032 jump *label358 lessThan :compute:dist 64
+ 1033 jump *label88 always
+ 1034 label *label358
+ 1035 label *label359
+ 1036 label *label360
+ 1037 op add :compute:i :compute:i 1
+ 1038 set :compute:x1 :compute:zx
+ 1039 op mul *tmp115 :compute:zx :compute:zx
+ 1040 op mul *tmp116 :compute:zy :compute:zy
+ 1041 op sub *tmp117 *tmp115 *tmp116
+ 1042 op add :compute:zx *tmp117 :compute:cx
+ 1043 op mul *tmp119 2 :compute:x1
+ 1044 op mul *tmp120 *tmp119 :compute:zy
+ 1045 op add :compute:zy *tmp120 :compute:cy
+ 1046 op len :compute:dist :compute:zx :compute:zy
+ 1047 jump *label361 lessThan :compute:dist 64
+ 1048 jump *label88 always
+ 1049 label *label361
+ 1050 label *label362
+ 1051 label *label363
+ 1052 op add :compute:i :compute:i 1
+ 1053 set :compute:x1 :compute:zx
+ 1054 op mul *tmp115 :compute:zx :compute:zx
+ 1055 op mul *tmp116 :compute:zy :compute:zy
+ 1056 op sub *tmp117 *tmp115 *tmp116
+ 1057 op add :compute:zx *tmp117 :compute:cx
+ 1058 op mul *tmp119 2 :compute:x1
+ 1059 op mul *tmp120 *tmp119 :compute:zy
+ 1060 op add :compute:zy *tmp120 :compute:cy
+ 1061 op len :compute:dist :compute:zx :compute:zy
+ 1062 jump *label364 lessThan :compute:dist 64
+ 1063 jump *label88 always
+ 1064 label *label364
+ 1065 label *label365
+ 1066 label *label366
+ 1067 op add :compute:i :compute:i 1
+ 1068 set :compute:x1 :compute:zx
+ 1069 op mul *tmp115 :compute:zx :compute:zx
+ 1070 op mul *tmp116 :compute:zy :compute:zy
+ 1071 op sub *tmp117 *tmp115 *tmp116
+ 1072 op add :compute:zx *tmp117 :compute:cx
+ 1073 op mul *tmp119 2 :compute:x1
+ 1074 op mul *tmp120 *tmp119 :compute:zy
+ 1075 op add :compute:zy *tmp120 :compute:cy
+ 1076 op len :compute:dist :compute:zx :compute:zy
+ 1077 jump *label367 lessThan :compute:dist 64
+ 1078 jump *label88 always
+ 1079 label *label367
+ 1080 label *label368
+ 1081 label *label369
+ 1082 op add :compute:i :compute:i 1
+ 1083 set :compute:x1 :compute:zx
+ 1084 op mul *tmp115 :compute:zx :compute:zx
+ 1085 op mul *tmp116 :compute:zy :compute:zy
+ 1086 op sub *tmp117 *tmp115 *tmp116
+ 1087 op add :compute:zx *tmp117 :compute:cx
+ 1088 op mul *tmp119 2 :compute:x1
+ 1089 op mul *tmp120 *tmp119 :compute:zy
+ 1090 op add :compute:zy *tmp120 :compute:cy
+ 1091 op len :compute:dist :compute:zx :compute:zy
+ 1092 jump *label370 lessThan :compute:dist 64
+ 1093 jump *label88 always
+ 1094 label *label370
+ 1095 label *label371
+ 1096 label *label372
+ 1097 op add :compute:i :compute:i 1
+ 1098 set :compute:x1 :compute:zx
+ 1099 op mul *tmp115 :compute:zx :compute:zx
+ 1100 op mul *tmp116 :compute:zy :compute:zy
+ 1101 op sub *tmp117 *tmp115 *tmp116
+ 1102 op add :compute:zx *tmp117 :compute:cx
+ 1103 op mul *tmp119 2 :compute:x1
+ 1104 op mul *tmp120 *tmp119 :compute:zy
+ 1105 op add :compute:zy *tmp120 :compute:cy
+ 1106 op len :compute:dist :compute:zx :compute:zy
+ 1107 jump *label373 lessThan :compute:dist 64
+ 1108 jump *label88 always
+ 1109 label *label373
+ 1110 label *label374
+ 1111 label *label375
+ 1112 op add :compute:i :compute:i 1
+ 1113 set :compute:x1 :compute:zx
+ 1114 op mul *tmp115 :compute:zx :compute:zx
+ 1115 op mul *tmp116 :compute:zy :compute:zy
+ 1116 op sub *tmp117 *tmp115 *tmp116
+ 1117 op add :compute:zx *tmp117 :compute:cx
+ 1118 op mul *tmp119 2 :compute:x1
+ 1119 op mul *tmp120 *tmp119 :compute:zy
+ 1120 op add :compute:zy *tmp120 :compute:cy
+ 1121 op len :compute:dist :compute:zx :compute:zy
+ 1122 jump *label376 lessThan :compute:dist 64
+ 1123 jump *label88 always
+ 1124 label *label376
+ 1125 label *label377
+ 1126 label *label378
+ 1127 op add :compute:i :compute:i 1
+ 1128 set :compute:x1 :compute:zx
+ 1129 op mul *tmp115 :compute:zx :compute:zx
+ 1130 op mul *tmp116 :compute:zy :compute:zy
+ 1131 op sub *tmp117 *tmp115 *tmp116
+ 1132 op add :compute:zx *tmp117 :compute:cx
+ 1133 op mul *tmp119 2 :compute:x1
+ 1134 op mul *tmp120 *tmp119 :compute:zy
+ 1135 op add :compute:zy *tmp120 :compute:cy
+ 1136 op len :compute:dist :compute:zx :compute:zy
+ 1137 jump *label379 lessThan :compute:dist 64
+ 1138 jump *label88 always
+ 1139 label *label379
+ 1140 label *label380
+ 1141 label *label381
+ 1142 op add :compute:i :compute:i 1
+ 1143 set :compute:x1 :compute:zx
+ 1144 op mul *tmp115 :compute:zx :compute:zx
+ 1145 op mul *tmp116 :compute:zy :compute:zy
+ 1146 op sub *tmp117 *tmp115 *tmp116
+ 1147 op add :compute:zx *tmp117 :compute:cx
+ 1148 op mul *tmp119 2 :compute:x1
+ 1149 op mul *tmp120 *tmp119 :compute:zy
+ 1150 op add :compute:zy *tmp120 :compute:cy
+ 1151 op len :compute:dist :compute:zx :compute:zy
+ 1152 jump *label382 lessThan :compute:dist 64
+ 1153 jump *label88 always
+ 1154 label *label382
+ 1155 label *label383
+ 1156 label *label384
+ 1157 op add :compute:i :compute:i 1
+ 1158 set :compute:x1 :compute:zx
+ 1159 op mul *tmp115 :compute:zx :compute:zx
+ 1160 op mul *tmp116 :compute:zy :compute:zy
+ 1161 op sub *tmp117 *tmp115 *tmp116
+ 1162 op add :compute:zx *tmp117 :compute:cx
+ 1163 op mul *tmp119 2 :compute:x1
+ 1164 op mul *tmp120 *tmp119 :compute:zy
+ 1165 op add :compute:zy *tmp120 :compute:cy
+ 1166 op len :compute:dist :compute:zx :compute:zy
+ 1167 jump *label385 lessThan :compute:dist 64
+ 1168 jump *label88 always
+ 1169 label *label385
+ 1170 label *label386
+ 1171 label *label387
+ 1172 op add :compute:i :compute:i 1
+ 1173 label *label88
  1174 jump *label91 lessThanEq .PALETTE 1
  1175 jump *label91 greaterThanEq :compute:i 63
  1176 op log *tmp127 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   239 label *label199
   240 label *label200
   241 label *label201
-    * op add :compute:i :compute:i 1
+  242 op add :compute:i 0 1
   243 set :compute:x1 :compute:zx
   244 op mul *tmp115 :compute:zx :compute:zx
   245 op mul *tmp116 :compute:zy :compute:zy
 
   254 label *label202
   255 label *label203
   256 label *label204
-    * op add :compute:i :compute:i 1
+  257 op add :compute:i 1 1
   258 set :compute:x1 :compute:zx
   259 op mul *tmp115 :compute:zx :compute:zx
   260 op mul *tmp116 :compute:zy :compute:zy
 
   269 label *label205
   270 label *label206
   271 label *label207
-    * op add :compute:i :compute:i 1
+  272 op add :compute:i 2 1
   273 set :compute:x1 :compute:zx
   274 op mul *tmp115 :compute:zx :compute:zx
   275 op mul *tmp116 :compute:zy :compute:zy
 
   284 label *label208
   285 label *label209
   286 label *label210
-    * op add :compute:i :compute:i 1
+  287 op add :compute:i 3 1
   288 set :compute:x1 :compute:zx
   289 op mul *tmp115 :compute:zx :compute:zx
   290 op mul *tmp116 :compute:zy :compute:zy
 
   299 label *label211
   300 label *label212
   301 label *label213
-    * op add :compute:i :compute:i 1
+  302 op add :compute:i 4 1
   303 set :compute:x1 :compute:zx
   304 op mul *tmp115 :compute:zx :compute:zx
   305 op mul *tmp116 :compute:zy :compute:zy
 
   314 label *label214
   315 label *label215
   316 label *label216
-    * op add :compute:i :compute:i 1
+  317 op add :compute:i 5 1
   318 set :compute:x1 :compute:zx
   319 op mul *tmp115 :compute:zx :compute:zx
   320 op mul *tmp116 :compute:zy :compute:zy
 
   329 label *label217
   330 label *label218
   331 label *label219
-    * op add :compute:i :compute:i 1
+  332 op add :compute:i 6 1
   333 set :compute:x1 :compute:zx
   334 op mul *tmp115 :compute:zx :compute:zx
   335 op mul *tmp116 :compute:zy :compute:zy
 
   344 label *label220
   345 label *label221
   346 label *label222
-    * op add :compute:i :compute:i 1
+  347 op add :compute:i 7 1
   348 set :compute:x1 :compute:zx
   349 op mul *tmp115 :compute:zx :compute:zx
   350 op mul *tmp116 :compute:zy :compute:zy
 
   359 label *label223
   360 label *label224
   361 label *label225
-    * op add :compute:i :compute:i 1
+  362 op add :compute:i 8 1
   363 set :compute:x1 :compute:zx
   364 op mul *tmp115 :compute:zx :compute:zx
   365 op mul *tmp116 :compute:zy :compute:zy
 
   374 label *label226
   375 label *label227
   376 label *label228
-    * op add :compute:i :compute:i 1
+  377 op add :compute:i 9 1
   378 set :compute:x1 :compute:zx
   379 op mul *tmp115 :compute:zx :compute:zx
   380 op mul *tmp116 :compute:zy :compute:zy
 
   389 label *label229
   390 label *label230
   391 label *label231
-    * op add :compute:i :compute:i 1
+  392 op add :compute:i 10 1
   393 set :compute:x1 :compute:zx
   394 op mul *tmp115 :compute:zx :compute:zx
   395 op mul *tmp116 :compute:zy :compute:zy
 
   404 label *label232
   405 label *label233
   406 label *label234
-    * op add :compute:i :compute:i 1
+  407 op add :compute:i 11 1
   408 set :compute:x1 :compute:zx
   409 op mul *tmp115 :compute:zx :compute:zx
   410 op mul *tmp116 :compute:zy :compute:zy
 
   419 label *label235
   420 label *label236
   421 label *label237
-    * op add :compute:i :compute:i 1
+  422 op add :compute:i 12 1
   423 set :compute:x1 :compute:zx
   424 op mul *tmp115 :compute:zx :compute:zx
   425 op mul *tmp116 :compute:zy :compute:zy
 
   434 label *label238
   435 label *label239
   436 label *label240
-    * op add :compute:i :compute:i 1
+  437 op add :compute:i 13 1
   438 set :compute:x1 :compute:zx
   439 op mul *tmp115 :compute:zx :compute:zx
   440 op mul *tmp116 :compute:zy :compute:zy
 
   449 label *label241
   450 label *label242
   451 label *label243
-    * op add :compute:i :compute:i 1
+  452 op add :compute:i 14 1
   453 set :compute:x1 :compute:zx
   454 op mul *tmp115 :compute:zx :compute:zx
   455 op mul *tmp116 :compute:zy :compute:zy
 
   464 label *label244
   465 label *label245
   466 label *label246
-    * op add :compute:i :compute:i 1
+  467 op add :compute:i 15 1
   468 set :compute:x1 :compute:zx
   469 op mul *tmp115 :compute:zx :compute:zx
   470 op mul *tmp116 :compute:zy :compute:zy
 
   479 label *label247
   480 label *label248
   481 label *label249
-    * op add :compute:i :compute:i 1
+  482 op add :compute:i 16 1
   483 set :compute:x1 :compute:zx
   484 op mul *tmp115 :compute:zx :compute:zx
   485 op mul *tmp116 :compute:zy :compute:zy
 
   494 label *label250
   495 label *label251
   496 label *label252
-    * op add :compute:i :compute:i 1
+  497 op add :compute:i 17 1
   498 set :compute:x1 :compute:zx
   499 op mul *tmp115 :compute:zx :compute:zx
   500 op mul *tmp116 :compute:zy :compute:zy
 
   509 label *label253
   510 label *label254
   511 label *label255
-    * op add :compute:i :compute:i 1
+  512 op add :compute:i 18 1
   513 set :compute:x1 :compute:zx
   514 op mul *tmp115 :compute:zx :compute:zx
   515 op mul *tmp116 :compute:zy :compute:zy
 
   524 label *label256
   525 label *label257
   526 label *label258
-    * op add :compute:i :compute:i 1
+  527 op add :compute:i 19 1
   528 set :compute:x1 :compute:zx
   529 op mul *tmp115 :compute:zx :compute:zx
   530 op mul *tmp116 :compute:zy :compute:zy
 
   539 label *label259
   540 label *label260
   541 label *label261
-    * op add :compute:i :compute:i 1
+  542 op add :compute:i 20 1
   543 set :compute:x1 :compute:zx
   544 op mul *tmp115 :compute:zx :compute:zx
   545 op mul *tmp116 :compute:zy :compute:zy
 
   554 label *label262
   555 label *label263
   556 label *label264
-    * op add :compute:i :compute:i 1
+  557 op add :compute:i 21 1
   558 set :compute:x1 :compute:zx
   559 op mul *tmp115 :compute:zx :compute:zx
   560 op mul *tmp116 :compute:zy :compute:zy
 
   569 label *label265
   570 label *label266
   571 label *label267
-    * op add :compute:i :compute:i 1
+  572 op add :compute:i 22 1
   573 set :compute:x1 :compute:zx
   574 op mul *tmp115 :compute:zx :compute:zx
   575 op mul *tmp116 :compute:zy :compute:zy
 
   584 label *label268
   585 label *label269
   586 label *label270
-    * op add :compute:i :compute:i 1
+  587 op add :compute:i 23 1
   588 set :compute:x1 :compute:zx
   589 op mul *tmp115 :compute:zx :compute:zx
   590 op mul *tmp116 :compute:zy :compute:zy
 
   599 label *label271
   600 label *label272
   601 label *label273
-    * op add :compute:i :compute:i 1
+  602 op add :compute:i 24 1
   603 set :compute:x1 :compute:zx
   604 op mul *tmp115 :compute:zx :compute:zx
   605 op mul *tmp116 :compute:zy :compute:zy
 
   614 label *label274
   615 label *label275
   616 label *label276
-    * op add :compute:i :compute:i 1
+  617 op add :compute:i 25 1
   618 set :compute:x1 :compute:zx
   619 op mul *tmp115 :compute:zx :compute:zx
   620 op mul *tmp116 :compute:zy :compute:zy
 
   629 label *label277
   630 label *label278
   631 label *label279
-    * op add :compute:i :compute:i 1
+  632 op add :compute:i 26 1
   633 set :compute:x1 :compute:zx
   634 op mul *tmp115 :compute:zx :compute:zx
   635 op mul *tmp116 :compute:zy :compute:zy
 
   644 label *label280
   645 label *label281
   646 label *label282
-    * op add :compute:i :compute:i 1
+  647 op add :compute:i 27 1
   648 set :compute:x1 :compute:zx
   649 op mul *tmp115 :compute:zx :compute:zx
   650 op mul *tmp116 :compute:zy :compute:zy
 
   659 label *label283
   660 label *label284
   661 label *label285
-    * op add :compute:i :compute:i 1
+  662 op add :compute:i 28 1
   663 set :compute:x1 :compute:zx
   664 op mul *tmp115 :compute:zx :compute:zx
   665 op mul *tmp116 :compute:zy :compute:zy
 
   674 label *label286
   675 label *label287
   676 label *label288
-    * op add :compute:i :compute:i 1
+  677 op add :compute:i 29 1
   678 set :compute:x1 :compute:zx
   679 op mul *tmp115 :compute:zx :compute:zx
   680 op mul *tmp116 :compute:zy :compute:zy
 
   689 label *label289
   690 label *label290
   691 label *label291
-    * op add :compute:i :compute:i 1
+  692 op add :compute:i 30 1
   693 set :compute:x1 :compute:zx
   694 op mul *tmp115 :compute:zx :compute:zx
   695 op mul *tmp116 :compute:zy :compute:zy
 
   704 label *label292
   705 label *label293
   706 label *label294
-    * op add :compute:i :compute:i 1
+  707 op add :compute:i 31 1
   708 set :compute:x1 :compute:zx
   709 op mul *tmp115 :compute:zx :compute:zx
   710 op mul *tmp116 :compute:zy :compute:zy
 
   719 label *label295
   720 label *label296
   721 label *label297
-    * op add :compute:i :compute:i 1
+  722 op add :compute:i 32 1
   723 set :compute:x1 :compute:zx
   724 op mul *tmp115 :compute:zx :compute:zx
   725 op mul *tmp116 :compute:zy :compute:zy
 
   734 label *label298
   735 label *label299
   736 label *label300
-    * op add :compute:i :compute:i 1
+  737 op add :compute:i 33 1
   738 set :compute:x1 :compute:zx
   739 op mul *tmp115 :compute:zx :compute:zx
   740 op mul *tmp116 :compute:zy :compute:zy
 
   749 label *label301
   750 label *label302
   751 label *label303
-    * op add :compute:i :compute:i 1
+  752 op add :compute:i 34 1
   753 set :compute:x1 :compute:zx
   754 op mul *tmp115 :compute:zx :compute:zx
   755 op mul *tmp116 :compute:zy :compute:zy
 
   764 label *label304
   765 label *label305
   766 label *label306
-    * op add :compute:i :compute:i 1
+  767 op add :compute:i 35 1
   768 set :compute:x1 :compute:zx
   769 op mul *tmp115 :compute:zx :compute:zx
   770 op mul *tmp116 :compute:zy :compute:zy
 
   779 label *label307
   780 label *label308
   781 label *label309
-    * op add :compute:i :compute:i 1
+  782 op add :compute:i 36 1
   783 set :compute:x1 :compute:zx
   784 op mul *tmp115 :compute:zx :compute:zx
   785 op mul *tmp116 :compute:zy :compute:zy
 
   794 label *label310
   795 label *label311
   796 label *label312
-    * op add :compute:i :compute:i 1
+  797 op add :compute:i 37 1
   798 set :compute:x1 :compute:zx
   799 op mul *tmp115 :compute:zx :compute:zx
   800 op mul *tmp116 :compute:zy :compute:zy
 
   809 label *label313
   810 label *label314
   811 label *label315
-    * op add :compute:i :compute:i 1
+  812 op add :compute:i 38 1
   813 set :compute:x1 :compute:zx
   814 op mul *tmp115 :compute:zx :compute:zx
   815 op mul *tmp116 :compute:zy :compute:zy
 
   824 label *label316
   825 label *label317
   826 label *label318
-    * op add :compute:i :compute:i 1
+  827 op add :compute:i 39 1
   828 set :compute:x1 :compute:zx
   829 op mul *tmp115 :compute:zx :compute:zx
   830 op mul *tmp116 :compute:zy :compute:zy
 
   839 label *label319
   840 label *label320
   841 label *label321
-    * op add :compute:i :compute:i 1
+  842 op add :compute:i 40 1
   843 set :compute:x1 :compute:zx
   844 op mul *tmp115 :compute:zx :compute:zx
   845 op mul *tmp116 :compute:zy :compute:zy
 
   854 label *label322
   855 label *label323
   856 label *label324
-    * op add :compute:i :compute:i 1
+  857 op add :compute:i 41 1
   858 set :compute:x1 :compute:zx
   859 op mul *tmp115 :compute:zx :compute:zx
   860 op mul *tmp116 :compute:zy :compute:zy
 
   869 label *label325
   870 label *label326
   871 label *label327
-    * op add :compute:i :compute:i 1
+  872 op add :compute:i 42 1
   873 set :compute:x1 :compute:zx
   874 op mul *tmp115 :compute:zx :compute:zx
   875 op mul *tmp116 :compute:zy :compute:zy
 
   884 label *label328
   885 label *label329
   886 label *label330
-    * op add :compute:i :compute:i 1
+  887 op add :compute:i 43 1
   888 set :compute:x1 :compute:zx
   889 op mul *tmp115 :compute:zx :compute:zx
   890 op mul *tmp116 :compute:zy :compute:zy
 
   899 label *label331
   900 label *label332
   901 label *label333
-    * op add :compute:i :compute:i 1
+  902 op add :compute:i 44 1
   903 set :compute:x1 :compute:zx
   904 op mul *tmp115 :compute:zx :compute:zx
   905 op mul *tmp116 :compute:zy :compute:zy
 
   914 label *label334
   915 label *label335
   916 label *label336
-    * op add :compute:i :compute:i 1
+  917 op add :compute:i 45 1
   918 set :compute:x1 :compute:zx
   919 op mul *tmp115 :compute:zx :compute:zx
   920 op mul *tmp116 :compute:zy :compute:zy
 
   929 label *label337
   930 label *label338
   931 label *label339
-    * op add :compute:i :compute:i 1
+  932 op add :compute:i 46 1
   933 set :compute:x1 :compute:zx
   934 op mul *tmp115 :compute:zx :compute:zx
   935 op mul *tmp116 :compute:zy :compute:zy
 
   944 label *label340
   945 label *label341
   946 label *label342
-    * op add :compute:i :compute:i 1
+  947 op add :compute:i 47 1
   948 set :compute:x1 :compute:zx
   949 op mul *tmp115 :compute:zx :compute:zx
   950 op mul *tmp116 :compute:zy :compute:zy
 
   959 label *label343
   960 label *label344
   961 label *label345
-    * op add :compute:i :compute:i 1
+  962 op add :compute:i 48 1
   963 set :compute:x1 :compute:zx
   964 op mul *tmp115 :compute:zx :compute:zx
   965 op mul *tmp116 :compute:zy :compute:zy
 
   974 label *label346
   975 label *label347
   976 label *label348
-    * op add :compute:i :compute:i 1
+  977 op add :compute:i 49 1
   978 set :compute:x1 :compute:zx
   979 op mul *tmp115 :compute:zx :compute:zx
   980 op mul *tmp116 :compute:zy :compute:zy
 
   989 label *label349
   990 label *label350
   991 label *label351
-    * op add :compute:i :compute:i 1
+  992 op add :compute:i 50 1
   993 set :compute:x1 :compute:zx
   994 op mul *tmp115 :compute:zx :compute:zx
   995 op mul *tmp116 :compute:zy :compute:zy
 
  1004 label *label352
  1005 label *label353
  1006 label *label354
-    * op add :compute:i :compute:i 1
+ 1007 op add :compute:i 51 1
  1008 set :compute:x1 :compute:zx
  1009 op mul *tmp115 :compute:zx :compute:zx
  1010 op mul *tmp116 :compute:zy :compute:zy
 
  1019 label *label355
  1020 label *label356
  1021 label *label357
-    * op add :compute:i :compute:i 1
+ 1022 op add :compute:i 52 1
  1023 set :compute:x1 :compute:zx
  1024 op mul *tmp115 :compute:zx :compute:zx
  1025 op mul *tmp116 :compute:zy :compute:zy
 
  1034 label *label358
  1035 label *label359
  1036 label *label360
-    * op add :compute:i :compute:i 1
+ 1037 op add :compute:i 53 1
  1038 set :compute:x1 :compute:zx
  1039 op mul *tmp115 :compute:zx :compute:zx
  1040 op mul *tmp116 :compute:zy :compute:zy
 
  1049 label *label361
  1050 label *label362
  1051 label *label363
-    * op add :compute:i :compute:i 1
+ 1052 op add :compute:i 54 1
  1053 set :compute:x1 :compute:zx
  1054 op mul *tmp115 :compute:zx :compute:zx
  1055 op mul *tmp116 :compute:zy :compute:zy
 
  1064 label *label364
  1065 label *label365
  1066 label *label366
-    * op add :compute:i :compute:i 1
+ 1067 op add :compute:i 55 1
  1068 set :compute:x1 :compute:zx
  1069 op mul *tmp115 :compute:zx :compute:zx
  1070 op mul *tmp116 :compute:zy :compute:zy
 
  1079 label *label367
  1080 label *label368
  1081 label *label369
-    * op add :compute:i :compute:i 1
+ 1082 op add :compute:i 56 1
  1083 set :compute:x1 :compute:zx
  1084 op mul *tmp115 :compute:zx :compute:zx
  1085 op mul *tmp116 :compute:zy :compute:zy
 
  1094 label *label370
  1095 label *label371
  1096 label *label372
-    * op add :compute:i :compute:i 1
+ 1097 op add :compute:i 57 1
  1098 set :compute:x1 :compute:zx
  1099 op mul *tmp115 :compute:zx :compute:zx
  1100 op mul *tmp116 :compute:zy :compute:zy
 
  1109 label *label373
  1110 label *label374
  1111 label *label375
-    * op add :compute:i :compute:i 1
+ 1112 op add :compute:i 58 1
  1113 set :compute:x1 :compute:zx
  1114 op mul *tmp115 :compute:zx :compute:zx
  1115 op mul *tmp116 :compute:zy :compute:zy
 
  1124 label *label376
  1125 label *label377
  1126 label *label378
-    * op add :compute:i :compute:i 1
+ 1127 op add :compute:i 59 1
  1128 set :compute:x1 :compute:zx
  1129 op mul *tmp115 :compute:zx :compute:zx
  1130 op mul *tmp116 :compute:zy :compute:zy
 
  1139 label *label379
  1140 label *label380
  1141 label *label381
-    * op add :compute:i :compute:i 1
+ 1142 op add :compute:i 60 1
  1143 set :compute:x1 :compute:zx
  1144 op mul *tmp115 :compute:zx :compute:zx
  1145 op mul *tmp116 :compute:zy :compute:zy
 
  1154 label *label382
  1155 label *label383
  1156 label *label384
-    * op add :compute:i :compute:i 1
+ 1157 op add :compute:i 61 1
  1158 set :compute:x1 :compute:zx
  1159 op mul *tmp115 :compute:zx :compute:zx
  1160 op mul *tmp116 :compute:zy :compute:zy
 
  1169 label *label385
  1170 label *label386
  1171 label *label387
-    * op add :compute:i :compute:i 1
+ 1172 op add :compute:i 62 1
  1173 label *label88
  1174 jump *label91 lessThanEq .PALETTE 1
  1175 jump *label91 greaterThanEq :compute:i 63

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1 (-2 instructions):
 
    21 label *label149
    22 jump *label150 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    24 label *label150
    25 label *label151
    26 label *label152
 
    29 label *label155
    30 jump *label156 notEqual @memory-bank :findLinkedBlocks:type
    31 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    32 label *label156
    33 label *label157
    34 label *label158
 
   237 label *label199
   238 label *label200
   239 label *label201
-    * op add :compute:i 0 1
+  240 set :compute:i 1
   241 set :compute:x1 :compute:zx
   242 op mul *tmp115 :compute:zx :compute:zx
   243 op mul *tmp116 :compute:zy :compute:zy

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1:
 
    58 label *label179
    59 label *label180
    60 label *label23
-    * printflush :findLinkedBlocks:message
+   61 printflush null
    62 label *label2
    63 jump *label1 equal :findLinkedBlocks:foundAll false
    64 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 2 (-1 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:message null
     1 label *label1
     2 label *label162
     3 label *label163

Modifications by Iterated phase, Boolean Optimization, pass 3, iteration 1 (-2 instructions):
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label149
-    * jump *label150 notEqual @large-logic-display :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label150
-    * label *label151
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    22 label *label152
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label155
-    * jump *label156 notEqual @memory-bank :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label156
-    * label *label157
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    27 label *label158
    28 set .memory :findLinkedBlocks:variable
    29 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 1:
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label149
-    * select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    22 label *label152
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label155
-    * select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    27 label *label158
    28 set .memory :findLinkedBlocks:variable
    29 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 2 (-2 instructions):
 
    16 print "\nFound: "
    17 print :findLinkedBlocks:block
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:variable .display
    19 label *label149
    20 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    21 label *label152
    22 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:variable .memory
    23 label *label155
    24 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    25 label *label158

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-1 instructions):
     0 set .start 0
     1 label *label1
-    * label *label162
-    * label *label163
     2 set .display null
-    * label *label166
-    * label *label167
     3 set .memory null
-    * label *label6
     4 print "Mandelbrot Generator"
     5 set :findLinkedBlocks:n @links
-    * label *label9
     6 jump *label11 lessThanEq :findLinkedBlocks:n 0
     7 label *label144
     8 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
 
    10 print "\nFound: "
    11 print :findLinkedBlocks:block
    12 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * label *label149
    13 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
-    * label *label152
    14 set .display :findLinkedBlocks:variable
-    * label *label155
    15 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
-    * label *label158
    16 set .memory :findLinkedBlocks:variable
-    * label *label14
-    * label *label10
    17 jump *label144 greaterThan :findLinkedBlocks:n 0
    18 label *label11
-    * label *label171
    19 print "\n"
    20 print "Display"
    21 print ":"
    22 print " "
    23 print .display
    24 op and :findLinkedBlocks:foundAll 1 .display
-    * label *label172
-    * label *label173
-    * label *label174
-    * label *label177
    25 print "\n"
    26 print "Memory"
    27 print ":"
    28 print " "
    29 print .memory
    30 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
-    * label *label178
-    * label *label179
-    * label *label180
-    * label *label23
    31 printflush null
-    * label *label2
    32 jump *label1 equal :findLinkedBlocks:foundAll false
-    * label *label3
-    * label *label0
    33 label *label28
    34 label *label31
    35 wait 0
-    * label *label32
    36 read *tmp27 .memory 67
    37 jump *label31 equal .start *tmp27
-    * label *label33
    38 read .start .memory 67
    39 read .stop .memory 68
    40 set .lastColor -1
 
    62 jump *label39 equal .stop *tmp47
    63 jump *label29 always
    64 label *label39
-    * label *label40
    65 read :batch .memory 64
    66 read *tmp50 .memory 64
    67 op add *tmp51 *tmp50 :multiple
 
    69 jump *label41 lessThan :batch 2816
    70 jump *label38 always
    71 label *label41
-    * label *label42
    72 op mul *tmp55 11 :multiple
    73 set :i 0
    74 op mul *tmp56 :batch 11
-    * label *label43
    75 jump *label45 lessThanEq :multiple 0
    76 label *label145
    77 op add :adam5:index *tmp56 :i
    78 op idiv *tmp59 :adam5:index 16
    79 multijump *tmp59 0 0 (m:*label185)
    80 multilabel *label190 (m:*label185)
-    * label *label184
    81 op sub :adam5:index :adam5:index 15488
    82 op mod :adam5:x :adam5:index 176
    83 op idiv *tmp86 :adam5:index 176
 
    87 set :adam5:dx 1
    88 jump *label47 always
    89 multilabel *label186 (m:*label185)
-    * label *label49
    90 op mod *tmp61 :adam5:index 44
    91 op mul :adam5:x 4 *tmp61
    92 op idiv *tmp63 :adam5:index 44
 
    95 set :adam5:dy *tmp65
    96 set :adam5:dx *tmp65
    97 jump *label47 always
-    * label *label48
    98 multilabel *label187 (m:*label185)
-    * label *label54
    99 op sub :adam5:index :adam5:index 1936
   100 op mod *tmp66 :adam5:index 44
   101 op mul *tmp67 4 *tmp66
 
   105 select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1
   106 select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2
   107 jump *label47 always
-    * label *label53
   108 multilabel *label188 (m:*label185)
-    * label *label61
   109 op sub :adam5:index :adam5:index 3872
   110 op mod *tmp73 :adam5:index 88
   111 op mul :adam5:x 2 *tmp73
 
   115 select *tmp78 notEqual .ALL_PASS_COLORING false 2 1
   116 set :adam5:dy *tmp78
   117 set :adam5:dx *tmp78
-    * label *label60
   118 jump *label47 always
   119 multilabel *label189 (m:*label185)
-    * label *label66
   120 op sub :adam5:index :adam5:index 7744
   121 op mod *tmp79 :adam5:index 88
   122 op mul *tmp80 2 *tmp79
 
   126 set :adam5:dx 1
   127 select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1
   128 label *label47
-    * label *label46
   129 jump *label70 lessThanEq :multiple *tmp44
   130 jump *label70 notEqual .localBuffer 0
   131 draw col %[white]
 
   140 drawflush .display
   141 set .localBuffer 0
   142 label *label75
-    * label *label76
-    * label *label74
   143 label *label70
-    * label *label71
   144 op div *tmp98 :adam5:x .ZOOM
   145 op add :compute:zx *tmp98 .OFFSET_X
   146 op div *tmp100 :adam5:y .ZOOM
 
   162 set *tmp97 63
   163 jump *label79 always
   164 label *label82
-    * label *label83
   165 op add *tmp111 :compute:zx 1
   166 op len *tmp112 *tmp111 :compute:zy
   167 jump *label84 greaterThan *tmp112 0.25
   168 set *tmp97 63
   169 jump *label79 always
   170 label *label84
-    * label *label85
   171 label *label81
   172 set :compute:i 0
-    * label *label198
   173 set :compute:x1 :compute:zx
   174 op mul *tmp115 :compute:zx :compute:zx
   175 op mul *tmp116 :compute:zy :compute:zy
 
   182 jump *label199 lessThan :compute:dist 64
   183 jump *label88 always
   184 label *label199
-    * label *label200
-    * label *label201
   185 set :compute:i 1
   186 set :compute:x1 :compute:zx
   187 op mul *tmp115 :compute:zx :compute:zx
 
   195 jump *label202 lessThan :compute:dist 64
   196 jump *label88 always
   197 label *label202
-    * label *label203
-    * label *label204
   198 op add :compute:i 1 1
   199 set :compute:x1 :compute:zx
   200 op mul *tmp115 :compute:zx :compute:zx
 
   208 jump *label205 lessThan :compute:dist 64
   209 jump *label88 always
   210 label *label205
-    * label *label206
-    * label *label207
   211 op add :compute:i 2 1
   212 set :compute:x1 :compute:zx
   213 op mul *tmp115 :compute:zx :compute:zx
 
   221 jump *label208 lessThan :compute:dist 64
   222 jump *label88 always
   223 label *label208
-    * label *label209
-    * label *label210
   224 op add :compute:i 3 1
   225 set :compute:x1 :compute:zx
   226 op mul *tmp115 :compute:zx :compute:zx
 
   234 jump *label211 lessThan :compute:dist 64
   235 jump *label88 always
   236 label *label211
-    * label *label212
-    * label *label213
   237 op add :compute:i 4 1
   238 set :compute:x1 :compute:zx
   239 op mul *tmp115 :compute:zx :compute:zx
 
   247 jump *label214 lessThan :compute:dist 64
   248 jump *label88 always
   249 label *label214
-    * label *label215
-    * label *label216
   250 op add :compute:i 5 1
   251 set :compute:x1 :compute:zx
   252 op mul *tmp115 :compute:zx :compute:zx
 
   260 jump *label217 lessThan :compute:dist 64
   261 jump *label88 always
   262 label *label217
-    * label *label218
-    * label *label219
   263 op add :compute:i 6 1
   264 set :compute:x1 :compute:zx
   265 op mul *tmp115 :compute:zx :compute:zx
 
   273 jump *label220 lessThan :compute:dist 64
   274 jump *label88 always
   275 label *label220
-    * label *label221
-    * label *label222
   276 op add :compute:i 7 1
   277 set :compute:x1 :compute:zx
   278 op mul *tmp115 :compute:zx :compute:zx
 
   286 jump *label223 lessThan :compute:dist 64
   287 jump *label88 always
   288 label *label223
-    * label *label224
-    * label *label225
   289 op add :compute:i 8 1
   290 set :compute:x1 :compute:zx
   291 op mul *tmp115 :compute:zx :compute:zx
 
   299 jump *label226 lessThan :compute:dist 64
   300 jump *label88 always
   301 label *label226
-    * label *label227
-    * label *label228
   302 op add :compute:i 9 1
   303 set :compute:x1 :compute:zx
   304 op mul *tmp115 :compute:zx :compute:zx
 
   312 jump *label229 lessThan :compute:dist 64
   313 jump *label88 always
   314 label *label229
-    * label *label230
-    * label *label231
   315 op add :compute:i 10 1
   316 set :compute:x1 :compute:zx
   317 op mul *tmp115 :compute:zx :compute:zx
 
   325 jump *label232 lessThan :compute:dist 64
   326 jump *label88 always
   327 label *label232
-    * label *label233
-    * label *label234
   328 op add :compute:i 11 1
   329 set :compute:x1 :compute:zx
   330 op mul *tmp115 :compute:zx :compute:zx
 
   338 jump *label235 lessThan :compute:dist 64
   339 jump *label88 always
   340 label *label235
-    * label *label236
-    * label *label237
   341 op add :compute:i 12 1
   342 set :compute:x1 :compute:zx
   343 op mul *tmp115 :compute:zx :compute:zx
 
   351 jump *label238 lessThan :compute:dist 64
   352 jump *label88 always
   353 label *label238
-    * label *label239
-    * label *label240
   354 op add :compute:i 13 1
   355 set :compute:x1 :compute:zx
   356 op mul *tmp115 :compute:zx :compute:zx
 
   364 jump *label241 lessThan :compute:dist 64
   365 jump *label88 always
   366 label *label241
-    * label *label242
-    * label *label243
   367 op add :compute:i 14 1
   368 set :compute:x1 :compute:zx
   369 op mul *tmp115 :compute:zx :compute:zx
 
   377 jump *label244 lessThan :compute:dist 64
   378 jump *label88 always
   379 label *label244
-    * label *label245
-    * label *label246
   380 op add :compute:i 15 1
   381 set :compute:x1 :compute:zx
   382 op mul *tmp115 :compute:zx :compute:zx
 
   390 jump *label247 lessThan :compute:dist 64
   391 jump *label88 always
   392 label *label247
-    * label *label248
-    * label *label249
   393 op add :compute:i 16 1
   394 set :compute:x1 :compute:zx
   395 op mul *tmp115 :compute:zx :compute:zx
 
   403 jump *label250 lessThan :compute:dist 64
   404 jump *label88 always
   405 label *label250
-    * label *label251
-    * label *label252
   406 op add :compute:i 17 1
   407 set :compute:x1 :compute:zx
   408 op mul *tmp115 :compute:zx :compute:zx
 
   416 jump *label253 lessThan :compute:dist 64
   417 jump *label88 always
   418 label *label253
-    * label *label254
-    * label *label255
   419 op add :compute:i 18 1
   420 set :compute:x1 :compute:zx
   421 op mul *tmp115 :compute:zx :compute:zx
 
   429 jump *label256 lessThan :compute:dist 64
   430 jump *label88 always
   431 label *label256
-    * label *label257
-    * label *label258
   432 op add :compute:i 19 1
   433 set :compute:x1 :compute:zx
   434 op mul *tmp115 :compute:zx :compute:zx
 
   442 jump *label259 lessThan :compute:dist 64
   443 jump *label88 always
   444 label *label259
-    * label *label260
-    * label *label261
   445 op add :compute:i 20 1
   446 set :compute:x1 :compute:zx
   447 op mul *tmp115 :compute:zx :compute:zx
 
   455 jump *label262 lessThan :compute:dist 64
   456 jump *label88 always
   457 label *label262
-    * label *label263
-    * label *label264
   458 op add :compute:i 21 1
   459 set :compute:x1 :compute:zx
   460 op mul *tmp115 :compute:zx :compute:zx
 
   468 jump *label265 lessThan :compute:dist 64
   469 jump *label88 always
   470 label *label265
-    * label *label266
-    * label *label267
   471 op add :compute:i 22 1
   472 set :compute:x1 :compute:zx
   473 op mul *tmp115 :compute:zx :compute:zx
 
   481 jump *label268 lessThan :compute:dist 64
   482 jump *label88 always
   483 label *label268
-    * label *label269
-    * label *label270
   484 op add :compute:i 23 1
   485 set :compute:x1 :compute:zx
   486 op mul *tmp115 :compute:zx :compute:zx
 
   494 jump *label271 lessThan :compute:dist 64
   495 jump *label88 always
   496 label *label271
-    * label *label272
-    * label *label273
   497 op add :compute:i 24 1
   498 set :compute:x1 :compute:zx
   499 op mul *tmp115 :compute:zx :compute:zx
 
   507 jump *label274 lessThan :compute:dist 64
   508 jump *label88 always
   509 label *label274
-    * label *label275
-    * label *label276
   510 op add :compute:i 25 1
   511 set :compute:x1 :compute:zx
   512 op mul *tmp115 :compute:zx :compute:zx
 
   520 jump *label277 lessThan :compute:dist 64
   521 jump *label88 always
   522 label *label277
-    * label *label278
-    * label *label279
   523 op add :compute:i 26 1
   524 set :compute:x1 :compute:zx
   525 op mul *tmp115 :compute:zx :compute:zx
 
   533 jump *label280 lessThan :compute:dist 64
   534 jump *label88 always
   535 label *label280
-    * label *label281
-    * label *label282
   536 op add :compute:i 27 1
   537 set :compute:x1 :compute:zx
   538 op mul *tmp115 :compute:zx :compute:zx
 
   546 jump *label283 lessThan :compute:dist 64
   547 jump *label88 always
   548 label *label283
-    * label *label284
-    * label *label285
   549 op add :compute:i 28 1
   550 set :compute:x1 :compute:zx
   551 op mul *tmp115 :compute:zx :compute:zx
 
   559 jump *label286 lessThan :compute:dist 64
   560 jump *label88 always
   561 label *label286
-    * label *label287
-    * label *label288
   562 op add :compute:i 29 1
   563 set :compute:x1 :compute:zx
   564 op mul *tmp115 :compute:zx :compute:zx
 
   572 jump *label289 lessThan :compute:dist 64
   573 jump *label88 always
   574 label *label289
-    * label *label290
-    * label *label291
   575 op add :compute:i 30 1
   576 set :compute:x1 :compute:zx
   577 op mul *tmp115 :compute:zx :compute:zx
 
   585 jump *label292 lessThan :compute:dist 64
   586 jump *label88 always
   587 label *label292
-    * label *label293
-    * label *label294
   588 op add :compute:i 31 1
   589 set :compute:x1 :compute:zx
   590 op mul *tmp115 :compute:zx :compute:zx
 
   598 jump *label295 lessThan :compute:dist 64
   599 jump *label88 always
   600 label *label295
-    * label *label296
-    * label *label297
   601 op add :compute:i 32 1
   602 set :compute:x1 :compute:zx
   603 op mul *tmp115 :compute:zx :compute:zx
 
   611 jump *label298 lessThan :compute:dist 64
   612 jump *label88 always
   613 label *label298
-    * label *label299
-    * label *label300
   614 op add :compute:i 33 1
   615 set :compute:x1 :compute:zx
   616 op mul *tmp115 :compute:zx :compute:zx
 
   624 jump *label301 lessThan :compute:dist 64
   625 jump *label88 always
   626 label *label301
-    * label *label302
-    * label *label303
   627 op add :compute:i 34 1
   628 set :compute:x1 :compute:zx
   629 op mul *tmp115 :compute:zx :compute:zx
 
   637 jump *label304 lessThan :compute:dist 64
   638 jump *label88 always
   639 label *label304
-    * label *label305
-    * label *label306
   640 op add :compute:i 35 1
   641 set :compute:x1 :compute:zx
   642 op mul *tmp115 :compute:zx :compute:zx
 
   650 jump *label307 lessThan :compute:dist 64
   651 jump *label88 always
   652 label *label307
-    * label *label308
-    * label *label309
   653 op add :compute:i 36 1
   654 set :compute:x1 :compute:zx
   655 op mul *tmp115 :compute:zx :compute:zx
 
   663 jump *label310 lessThan :compute:dist 64
   664 jump *label88 always
   665 label *label310
-    * label *label311
-    * label *label312
   666 op add :compute:i 37 1
   667 set :compute:x1 :compute:zx
   668 op mul *tmp115 :compute:zx :compute:zx
 
   676 jump *label313 lessThan :compute:dist 64
   677 jump *label88 always
   678 label *label313
-    * label *label314
-    * label *label315
   679 op add :compute:i 38 1
   680 set :compute:x1 :compute:zx
   681 op mul *tmp115 :compute:zx :compute:zx
 
   689 jump *label316 lessThan :compute:dist 64
   690 jump *label88 always
   691 label *label316
-    * label *label317
-    * label *label318
   692 op add :compute:i 39 1
   693 set :compute:x1 :compute:zx
   694 op mul *tmp115 :compute:zx :compute:zx
 
   702 jump *label319 lessThan :compute:dist 64
   703 jump *label88 always
   704 label *label319
-    * label *label320
-    * label *label321
   705 op add :compute:i 40 1
   706 set :compute:x1 :compute:zx
   707 op mul *tmp115 :compute:zx :compute:zx
 
   715 jump *label322 lessThan :compute:dist 64
   716 jump *label88 always
   717 label *label322
-    * label *label323
-    * label *label324
   718 op add :compute:i 41 1
   719 set :compute:x1 :compute:zx
   720 op mul *tmp115 :compute:zx :compute:zx
 
   728 jump *label325 lessThan :compute:dist 64
   729 jump *label88 always
   730 label *label325
-    * label *label326
-    * label *label327
   731 op add :compute:i 42 1
   732 set :compute:x1 :compute:zx
   733 op mul *tmp115 :compute:zx :compute:zx
 
   741 jump *label328 lessThan :compute:dist 64
   742 jump *label88 always
   743 label *label328
-    * label *label329
-    * label *label330
   744 op add :compute:i 43 1
   745 set :compute:x1 :compute:zx
   746 op mul *tmp115 :compute:zx :compute:zx
 
   754 jump *label331 lessThan :compute:dist 64
   755 jump *label88 always
   756 label *label331
-    * label *label332
-    * label *label333
   757 op add :compute:i 44 1
   758 set :compute:x1 :compute:zx
   759 op mul *tmp115 :compute:zx :compute:zx
 
   767 jump *label334 lessThan :compute:dist 64
   768 jump *label88 always
   769 label *label334
-    * label *label335
-    * label *label336
   770 op add :compute:i 45 1
   771 set :compute:x1 :compute:zx
   772 op mul *tmp115 :compute:zx :compute:zx
 
   780 jump *label337 lessThan :compute:dist 64
   781 jump *label88 always
   782 label *label337
-    * label *label338
-    * label *label339
   783 op add :compute:i 46 1
   784 set :compute:x1 :compute:zx
   785 op mul *tmp115 :compute:zx :compute:zx
 
   793 jump *label340 lessThan :compute:dist 64
   794 jump *label88 always
   795 label *label340
-    * label *label341
-    * label *label342
   796 op add :compute:i 47 1
   797 set :compute:x1 :compute:zx
   798 op mul *tmp115 :compute:zx :compute:zx
 
   806 jump *label343 lessThan :compute:dist 64
   807 jump *label88 always
   808 label *label343
-    * label *label344
-    * label *label345
   809 op add :compute:i 48 1
   810 set :compute:x1 :compute:zx
   811 op mul *tmp115 :compute:zx :compute:zx
 
   819 jump *label346 lessThan :compute:dist 64
   820 jump *label88 always
   821 label *label346
-    * label *label347
-    * label *label348
   822 op add :compute:i 49 1
   823 set :compute:x1 :compute:zx
   824 op mul *tmp115 :compute:zx :compute:zx
 
   832 jump *label349 lessThan :compute:dist 64
   833 jump *label88 always
   834 label *label349
-    * label *label350
-    * label *label351
   835 op add :compute:i 50 1
   836 set :compute:x1 :compute:zx
   837 op mul *tmp115 :compute:zx :compute:zx
 
   845 jump *label352 lessThan :compute:dist 64
   846 jump *label88 always
   847 label *label352
-    * label *label353
-    * label *label354
   848 op add :compute:i 51 1
   849 set :compute:x1 :compute:zx
   850 op mul *tmp115 :compute:zx :compute:zx
 
   858 jump *label355 lessThan :compute:dist 64
   859 jump *label88 always
   860 label *label355
-    * label *label356
-    * label *label357
   861 op add :compute:i 52 1
   862 set :compute:x1 :compute:zx
   863 op mul *tmp115 :compute:zx :compute:zx
 
   871 jump *label358 lessThan :compute:dist 64
   872 jump *label88 always
   873 label *label358
-    * label *label359
-    * label *label360
   874 op add :compute:i 53 1
   875 set :compute:x1 :compute:zx
   876 op mul *tmp115 :compute:zx :compute:zx
 
   884 jump *label361 lessThan :compute:dist 64
   885 jump *label88 always
   886 label *label361
-    * label *label362
-    * label *label363
   887 op add :compute:i 54 1
   888 set :compute:x1 :compute:zx
   889 op mul *tmp115 :compute:zx :compute:zx
 
   897 jump *label364 lessThan :compute:dist 64
   898 jump *label88 always
   899 label *label364
-    * label *label365
-    * label *label366
   900 op add :compute:i 55 1
   901 set :compute:x1 :compute:zx
   902 op mul *tmp115 :compute:zx :compute:zx
 
   910 jump *label367 lessThan :compute:dist 64
   911 jump *label88 always
   912 label *label367
-    * label *label368
-    * label *label369
   913 op add :compute:i 56 1
   914 set :compute:x1 :compute:zx
   915 op mul *tmp115 :compute:zx :compute:zx
 
   923 jump *label370 lessThan :compute:dist 64
   924 jump *label88 always
   925 label *label370
-    * label *label371
-    * label *label372
   926 op add :compute:i 57 1
   927 set :compute:x1 :compute:zx
   928 op mul *tmp115 :compute:zx :compute:zx
 
   936 jump *label373 lessThan :compute:dist 64
   937 jump *label88 always
   938 label *label373
-    * label *label374
-    * label *label375
   939 op add :compute:i 58 1
   940 set :compute:x1 :compute:zx
   941 op mul *tmp115 :compute:zx :compute:zx
 
   949 jump *label376 lessThan :compute:dist 64
   950 jump *label88 always
   951 label *label376
-    * label *label377
-    * label *label378
   952 op add :compute:i 59 1
   953 set :compute:x1 :compute:zx
   954 op mul *tmp115 :compute:zx :compute:zx
 
   962 jump *label379 lessThan :compute:dist 64
   963 jump *label88 always
   964 label *label379
-    * label *label380
-    * label *label381
   965 op add :compute:i 60 1
   966 set :compute:x1 :compute:zx
   967 op mul *tmp115 :compute:zx :compute:zx
 
   975 jump *label382 lessThan :compute:dist 64
   976 jump *label88 always
   977 label *label382
-    * label *label383
-    * label *label384
   978 op add :compute:i 61 1
   979 set :compute:x1 :compute:zx
   980 op mul *tmp115 :compute:zx :compute:zx
 
   988 jump *label385 lessThan :compute:dist 64
   989 jump *label88 always
   990 label *label385
-    * label *label386
-    * label *label387
   991 op add :compute:i 62 1
   992 label *label88
   993 jump *label91 lessThanEq .PALETTE 1
 
   999 op sub :compute:correction 4 *tmp130
  1000 op add :compute:i :compute:i :compute:correction
  1001 label *label91
-    * label *label92
  1002 set *tmp97 :compute:i
  1003 label *label79
  1004 jump *label96 lessThanEq .PALETTE 1
  1005 set :drawPixel:color %[black]
  1006 jump *label99 equal *tmp97 63
-    * label *label98
  1007 multijump .PALETTE 0 0 (m:*label192)
  1008 multilabel *label197 (m:*label192)
  1009 multilabel *label193 (m:*label192)
-    * label *label191
  1010 op div *tmp171 *tmp97 63.75
  1011 op sub :drawPixel:r 1 *tmp171
  1012 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
  1013 jump *label100 always
  1014 multilabel *label194 (m:*label192)
-    * label *label102
  1015 op sub *tmp137 32 *tmp97
  1016 op abs *tmp138 *tmp137
  1017 op div *tmp140 *tmp138 36.42857142857143
 
  1024 op add :drawPixel:b 0.47058823529411764 *tmp150
  1025 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1026 jump *label100 always
-    * label *label101
  1027 multilabel *label195 (m:*label192)
-    * label *label104
  1028 op div *tmp154 *tmp97 0.175
  1029 op sin :drawPixel:r *tmp154
  1030 op cos :drawPixel:g *tmp154
 
  1034 op add :drawPixel:b 0.39215686274509803 *tmp162
  1035 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1036 jump *label100 always
-    * label *label103
  1037 multilabel *label196 (m:*label192)
-    * label *label106
  1038 op div :drawPixel:r *tmp97 63.75
  1039 op div :drawPixel:g *tmp97 170
  1040 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
 
  1045 read :drawPixel:color .memory *tmp97
  1046 label *label97
  1047 jump *label107 lessThan .localBuffer 254
-    * label *label110
  1048 jump *label112 lessThanEq .localBuffer 0
  1049 label *label147
  1050 read *tmp181 .memory 68
 
  1058 drawflush .display
  1059 set .localBuffer 0
  1060 label *label116
-    * label *label117
-    * label *label115
-    * label *label111
  1061 jump *label147 greaterThan .localBuffer 0
  1062 label *label112
-    * label *label109
  1063 label *label107
-    * label *label108
  1064 jump *label120 lessThanEq .localBuffer 0
  1065 jump *label120 strictNotEqual :drawPixel:color .lastColor
  1066 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
 
  1081 drawflush .display
  1082 set .localBuffer 0
  1083 label *label125
-    * label *label126
-    * label *label124
-    * label *label95
  1084 wait 0
  1085 read *tmp197 .memory 68
  1086 jump *label129 equal .stop *tmp197
  1087 jump *label29 always
  1088 label *label129
-    * label *label130
  1089 read *tmp199 .memory 66
  1090 op add *tmp2 *tmp199 1
  1091 write *tmp2 .memory 66
  1092 read *tmp201 .memory 65
  1093 op add *tmp202 *tmp201 *tmp97
  1094 write *tmp202 .memory 65
-    * label *label44
  1095 op add :i :i 1
  1096 jump *label145 lessThan :i *tmp55
  1097 label *label45
  1098 select :multiple greaterThanEq :batch 1337.6 1 :multiple
-    * label *label37
  1099 jump *label36 always
  1100 label *label38
-    * label *label134
  1101 jump *label136 lessThanEq .localBuffer 0
  1102 label *label148
  1103 read *tmp207 .memory 68
 
  1111 drawflush .display
  1112 set .localBuffer 0
  1113 label *label140
-    * label *label141
-    * label *label139
-    * label *label135
  1114 jump *label148 greaterThan .localBuffer 0
  1115 label *label136
-    * label *label133
  1116 label *label29
  1117 jump *label28 always
-    * label *label30
-    * end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-66 instructions):
 
    59 label *label36
    60 wait 0
    61 read *tmp47 .memory 68
-    * jump *label39 equal .stop *tmp47
-    * jump *label29 always
+   62 jump *label29 notEqual .stop *tmp47
    63 label *label39
    64 read :batch .memory 64
    65 read *tmp50 .memory 64
    66 op add *tmp51 *tmp50 :multiple
    67 write *tmp51 .memory 64
-    * jump *label41 lessThan :batch 2816
-    * jump *label38 always
+   68 jump *label38 greaterThanEq :batch 2816
    69 label *label41
    70 op mul *tmp55 11 :multiple
    71 set :i 0
 
   177 op mul *tmp120 *tmp119 :compute:zy
   178 op add :compute:zy *tmp120 :compute:cy
   179 op len :compute:dist :compute:zx :compute:zy
-    * jump *label199 lessThan :compute:dist 64
-    * jump *label88 always
+  180 jump *label88 greaterThanEq :compute:dist 64
   181 label *label199
   182 set :compute:i 1
   183 set :compute:x1 :compute:zx
 
   189 op mul *tmp120 *tmp119 :compute:zy
   190 op add :compute:zy *tmp120 :compute:cy
   191 op len :compute:dist :compute:zx :compute:zy
-    * jump *label202 lessThan :compute:dist 64
-    * jump *label88 always
+  192 jump *label88 greaterThanEq :compute:dist 64
   193 label *label202
   194 op add :compute:i 1 1
   195 set :compute:x1 :compute:zx
 
   201 op mul *tmp120 *tmp119 :compute:zy
   202 op add :compute:zy *tmp120 :compute:cy
   203 op len :compute:dist :compute:zx :compute:zy
-    * jump *label205 lessThan :compute:dist 64
-    * jump *label88 always
+  204 jump *label88 greaterThanEq :compute:dist 64
   205 label *label205
   206 op add :compute:i 2 1
   207 set :compute:x1 :compute:zx
 
   213 op mul *tmp120 *tmp119 :compute:zy
   214 op add :compute:zy *tmp120 :compute:cy
   215 op len :compute:dist :compute:zx :compute:zy
-    * jump *label208 lessThan :compute:dist 64
-    * jump *label88 always
+  216 jump *label88 greaterThanEq :compute:dist 64
   217 label *label208
   218 op add :compute:i 3 1
   219 set :compute:x1 :compute:zx
 
   225 op mul *tmp120 *tmp119 :compute:zy
   226 op add :compute:zy *tmp120 :compute:cy
   227 op len :compute:dist :compute:zx :compute:zy
-    * jump *label211 lessThan :compute:dist 64
-    * jump *label88 always
+  228 jump *label88 greaterThanEq :compute:dist 64
   229 label *label211
   230 op add :compute:i 4 1
   231 set :compute:x1 :compute:zx
 
   237 op mul *tmp120 *tmp119 :compute:zy
   238 op add :compute:zy *tmp120 :compute:cy
   239 op len :compute:dist :compute:zx :compute:zy
-    * jump *label214 lessThan :compute:dist 64
-    * jump *label88 always
+  240 jump *label88 greaterThanEq :compute:dist 64
   241 label *label214
   242 op add :compute:i 5 1
   243 set :compute:x1 :compute:zx
 
   249 op mul *tmp120 *tmp119 :compute:zy
   250 op add :compute:zy *tmp120 :compute:cy
   251 op len :compute:dist :compute:zx :compute:zy
-    * jump *label217 lessThan :compute:dist 64
-    * jump *label88 always
+  252 jump *label88 greaterThanEq :compute:dist 64
   253 label *label217
   254 op add :compute:i 6 1
   255 set :compute:x1 :compute:zx
 
   261 op mul *tmp120 *tmp119 :compute:zy
   262 op add :compute:zy *tmp120 :compute:cy
   263 op len :compute:dist :compute:zx :compute:zy
-    * jump *label220 lessThan :compute:dist 64
-    * jump *label88 always
+  264 jump *label88 greaterThanEq :compute:dist 64
   265 label *label220
   266 op add :compute:i 7 1
   267 set :compute:x1 :compute:zx
 
   273 op mul *tmp120 *tmp119 :compute:zy
   274 op add :compute:zy *tmp120 :compute:cy
   275 op len :compute:dist :compute:zx :compute:zy
-    * jump *label223 lessThan :compute:dist 64
-    * jump *label88 always
+  276 jump *label88 greaterThanEq :compute:dist 64
   277 label *label223
   278 op add :compute:i 8 1
   279 set :compute:x1 :compute:zx
 
   285 op mul *tmp120 *tmp119 :compute:zy
   286 op add :compute:zy *tmp120 :compute:cy
   287 op len :compute:dist :compute:zx :compute:zy
-    * jump *label226 lessThan :compute:dist 64
-    * jump *label88 always
+  288 jump *label88 greaterThanEq :compute:dist 64
   289 label *label226
   290 op add :compute:i 9 1
   291 set :compute:x1 :compute:zx
 
   297 op mul *tmp120 *tmp119 :compute:zy
   298 op add :compute:zy *tmp120 :compute:cy
   299 op len :compute:dist :compute:zx :compute:zy
-    * jump *label229 lessThan :compute:dist 64
-    * jump *label88 always
+  300 jump *label88 greaterThanEq :compute:dist 64
   301 label *label229
   302 op add :compute:i 10 1
   303 set :compute:x1 :compute:zx
 
   309 op mul *tmp120 *tmp119 :compute:zy
   310 op add :compute:zy *tmp120 :compute:cy
   311 op len :compute:dist :compute:zx :compute:zy
-    * jump *label232 lessThan :compute:dist 64
-    * jump *label88 always
+  312 jump *label88 greaterThanEq :compute:dist 64
   313 label *label232
   314 op add :compute:i 11 1
   315 set :compute:x1 :compute:zx
 
   321 op mul *tmp120 *tmp119 :compute:zy
   322 op add :compute:zy *tmp120 :compute:cy
   323 op len :compute:dist :compute:zx :compute:zy
-    * jump *label235 lessThan :compute:dist 64
-    * jump *label88 always
+  324 jump *label88 greaterThanEq :compute:dist 64
   325 label *label235
   326 op add :compute:i 12 1
   327 set :compute:x1 :compute:zx
 
   333 op mul *tmp120 *tmp119 :compute:zy
   334 op add :compute:zy *tmp120 :compute:cy
   335 op len :compute:dist :compute:zx :compute:zy
-    * jump *label238 lessThan :compute:dist 64
-    * jump *label88 always
+  336 jump *label88 greaterThanEq :compute:dist 64
   337 label *label238
   338 op add :compute:i 13 1
   339 set :compute:x1 :compute:zx
 
   345 op mul *tmp120 *tmp119 :compute:zy
   346 op add :compute:zy *tmp120 :compute:cy
   347 op len :compute:dist :compute:zx :compute:zy
-    * jump *label241 lessThan :compute:dist 64
-    * jump *label88 always
+  348 jump *label88 greaterThanEq :compute:dist 64
   349 label *label241
   350 op add :compute:i 14 1
   351 set :compute:x1 :compute:zx
 
   357 op mul *tmp120 *tmp119 :compute:zy
   358 op add :compute:zy *tmp120 :compute:cy
   359 op len :compute:dist :compute:zx :compute:zy
-    * jump *label244 lessThan :compute:dist 64
-    * jump *label88 always
+  360 jump *label88 greaterThanEq :compute:dist 64
   361 label *label244
   362 op add :compute:i 15 1
   363 set :compute:x1 :compute:zx
 
   369 op mul *tmp120 *tmp119 :compute:zy
   370 op add :compute:zy *tmp120 :compute:cy
   371 op len :compute:dist :compute:zx :compute:zy
-    * jump *label247 lessThan :compute:dist 64
-    * jump *label88 always
+  372 jump *label88 greaterThanEq :compute:dist 64
   373 label *label247
   374 op add :compute:i 16 1
   375 set :compute:x1 :compute:zx
 
   381 op mul *tmp120 *tmp119 :compute:zy
   382 op add :compute:zy *tmp120 :compute:cy
   383 op len :compute:dist :compute:zx :compute:zy
-    * jump *label250 lessThan :compute:dist 64
-    * jump *label88 always
+  384 jump *label88 greaterThanEq :compute:dist 64
   385 label *label250
   386 op add :compute:i 17 1
   387 set :compute:x1 :compute:zx
 
   393 op mul *tmp120 *tmp119 :compute:zy
   394 op add :compute:zy *tmp120 :compute:cy
   395 op len :compute:dist :compute:zx :compute:zy
-    * jump *label253 lessThan :compute:dist 64
-    * jump *label88 always
+  396 jump *label88 greaterThanEq :compute:dist 64
   397 label *label253
   398 op add :compute:i 18 1
   399 set :compute:x1 :compute:zx
 
   405 op mul *tmp120 *tmp119 :compute:zy
   406 op add :compute:zy *tmp120 :compute:cy
   407 op len :compute:dist :compute:zx :compute:zy
-    * jump *label256 lessThan :compute:dist 64
-    * jump *label88 always
+  408 jump *label88 greaterThanEq :compute:dist 64
   409 label *label256
   410 op add :compute:i 19 1
   411 set :compute:x1 :compute:zx
 
   417 op mul *tmp120 *tmp119 :compute:zy
   418 op add :compute:zy *tmp120 :compute:cy
   419 op len :compute:dist :compute:zx :compute:zy
-    * jump *label259 lessThan :compute:dist 64
-    * jump *label88 always
+  420 jump *label88 greaterThanEq :compute:dist 64
   421 label *label259
   422 op add :compute:i 20 1
   423 set :compute:x1 :compute:zx
 
   429 op mul *tmp120 *tmp119 :compute:zy
   430 op add :compute:zy *tmp120 :compute:cy
   431 op len :compute:dist :compute:zx :compute:zy
-    * jump *label262 lessThan :compute:dist 64
-    * jump *label88 always
+  432 jump *label88 greaterThanEq :compute:dist 64
   433 label *label262
   434 op add :compute:i 21 1
   435 set :compute:x1 :compute:zx
 
   441 op mul *tmp120 *tmp119 :compute:zy
   442 op add :compute:zy *tmp120 :compute:cy
   443 op len :compute:dist :compute:zx :compute:zy
-    * jump *label265 lessThan :compute:dist 64
-    * jump *label88 always
+  444 jump *label88 greaterThanEq :compute:dist 64
   445 label *label265
   446 op add :compute:i 22 1
   447 set :compute:x1 :compute:zx
 
   453 op mul *tmp120 *tmp119 :compute:zy
   454 op add :compute:zy *tmp120 :compute:cy
   455 op len :compute:dist :compute:zx :compute:zy
-    * jump *label268 lessThan :compute:dist 64
-    * jump *label88 always
+  456 jump *label88 greaterThanEq :compute:dist 64
   457 label *label268
   458 op add :compute:i 23 1
   459 set :compute:x1 :compute:zx
 
   465 op mul *tmp120 *tmp119 :compute:zy
   466 op add :compute:zy *tmp120 :compute:cy
   467 op len :compute:dist :compute:zx :compute:zy
-    * jump *label271 lessThan :compute:dist 64
-    * jump *label88 always
+  468 jump *label88 greaterThanEq :compute:dist 64
   469 label *label271
   470 op add :compute:i 24 1
   471 set :compute:x1 :compute:zx
 
   477 op mul *tmp120 *tmp119 :compute:zy
   478 op add :compute:zy *tmp120 :compute:cy
   479 op len :compute:dist :compute:zx :compute:zy
-    * jump *label274 lessThan :compute:dist 64
-    * jump *label88 always
+  480 jump *label88 greaterThanEq :compute:dist 64
   481 label *label274
   482 op add :compute:i 25 1
   483 set :compute:x1 :compute:zx
 
   489 op mul *tmp120 *tmp119 :compute:zy
   490 op add :compute:zy *tmp120 :compute:cy
   491 op len :compute:dist :compute:zx :compute:zy
-    * jump *label277 lessThan :compute:dist 64
-    * jump *label88 always
+  492 jump *label88 greaterThanEq :compute:dist 64
   493 label *label277
   494 op add :compute:i 26 1
   495 set :compute:x1 :compute:zx
 
   501 op mul *tmp120 *tmp119 :compute:zy
   502 op add :compute:zy *tmp120 :compute:cy
   503 op len :compute:dist :compute:zx :compute:zy
-    * jump *label280 lessThan :compute:dist 64
-    * jump *label88 always
+  504 jump *label88 greaterThanEq :compute:dist 64
   505 label *label280
   506 op add :compute:i 27 1
   507 set :compute:x1 :compute:zx
 
   513 op mul *tmp120 *tmp119 :compute:zy
   514 op add :compute:zy *tmp120 :compute:cy
   515 op len :compute:dist :compute:zx :compute:zy
-    * jump *label283 lessThan :compute:dist 64
-    * jump *label88 always
+  516 jump *label88 greaterThanEq :compute:dist 64
   517 label *label283
   518 op add :compute:i 28 1
   519 set :compute:x1 :compute:zx
 
   525 op mul *tmp120 *tmp119 :compute:zy
   526 op add :compute:zy *tmp120 :compute:cy
   527 op len :compute:dist :compute:zx :compute:zy
-    * jump *label286 lessThan :compute:dist 64
-    * jump *label88 always
+  528 jump *label88 greaterThanEq :compute:dist 64
   529 label *label286
   530 op add :compute:i 29 1
   531 set :compute:x1 :compute:zx
 
   537 op mul *tmp120 *tmp119 :compute:zy
   538 op add :compute:zy *tmp120 :compute:cy
   539 op len :compute:dist :compute:zx :compute:zy
-    * jump *label289 lessThan :compute:dist 64
-    * jump *label88 always
+  540 jump *label88 greaterThanEq :compute:dist 64
   541 label *label289
   542 op add :compute:i 30 1
   543 set :compute:x1 :compute:zx
 
   549 op mul *tmp120 *tmp119 :compute:zy
   550 op add :compute:zy *tmp120 :compute:cy
   551 op len :compute:dist :compute:zx :compute:zy
-    * jump *label292 lessThan :compute:dist 64
-    * jump *label88 always
+  552 jump *label88 greaterThanEq :compute:dist 64
   553 label *label292
   554 op add :compute:i 31 1
   555 set :compute:x1 :compute:zx
 
   561 op mul *tmp120 *tmp119 :compute:zy
   562 op add :compute:zy *tmp120 :compute:cy
   563 op len :compute:dist :compute:zx :compute:zy
-    * jump *label295 lessThan :compute:dist 64
-    * jump *label88 always
+  564 jump *label88 greaterThanEq :compute:dist 64
   565 label *label295
   566 op add :compute:i 32 1
   567 set :compute:x1 :compute:zx
 
   573 op mul *tmp120 *tmp119 :compute:zy
   574 op add :compute:zy *tmp120 :compute:cy
   575 op len :compute:dist :compute:zx :compute:zy
-    * jump *label298 lessThan :compute:dist 64
-    * jump *label88 always
+  576 jump *label88 greaterThanEq :compute:dist 64
   577 label *label298
   578 op add :compute:i 33 1
   579 set :compute:x1 :compute:zx
 
   585 op mul *tmp120 *tmp119 :compute:zy
   586 op add :compute:zy *tmp120 :compute:cy
   587 op len :compute:dist :compute:zx :compute:zy
-    * jump *label301 lessThan :compute:dist 64
-    * jump *label88 always
+  588 jump *label88 greaterThanEq :compute:dist 64
   589 label *label301
   590 op add :compute:i 34 1
   591 set :compute:x1 :compute:zx
 
   597 op mul *tmp120 *tmp119 :compute:zy
   598 op add :compute:zy *tmp120 :compute:cy
   599 op len :compute:dist :compute:zx :compute:zy
-    * jump *label304 lessThan :compute:dist 64
-    * jump *label88 always
+  600 jump *label88 greaterThanEq :compute:dist 64
   601 label *label304
   602 op add :compute:i 35 1
   603 set :compute:x1 :compute:zx
 
   609 op mul *tmp120 *tmp119 :compute:zy
   610 op add :compute:zy *tmp120 :compute:cy
   611 op len :compute:dist :compute:zx :compute:zy
-    * jump *label307 lessThan :compute:dist 64
-    * jump *label88 always
+  612 jump *label88 greaterThanEq :compute:dist 64
   613 label *label307
   614 op add :compute:i 36 1
   615 set :compute:x1 :compute:zx
 
   621 op mul *tmp120 *tmp119 :compute:zy
   622 op add :compute:zy *tmp120 :compute:cy
   623 op len :compute:dist :compute:zx :compute:zy
-    * jump *label310 lessThan :compute:dist 64
-    * jump *label88 always
+  624 jump *label88 greaterThanEq :compute:dist 64
   625 label *label310
   626 op add :compute:i 37 1
   627 set :compute:x1 :compute:zx
 
   633 op mul *tmp120 *tmp119 :compute:zy
   634 op add :compute:zy *tmp120 :compute:cy
   635 op len :compute:dist :compute:zx :compute:zy
-    * jump *label313 lessThan :compute:dist 64
-    * jump *label88 always
+  636 jump *label88 greaterThanEq :compute:dist 64
   637 label *label313
   638 op add :compute:i 38 1
   639 set :compute:x1 :compute:zx
 
   645 op mul *tmp120 *tmp119 :compute:zy
   646 op add :compute:zy *tmp120 :compute:cy
   647 op len :compute:dist :compute:zx :compute:zy
-    * jump *label316 lessThan :compute:dist 64
-    * jump *label88 always
+  648 jump *label88 greaterThanEq :compute:dist 64
   649 label *label316
   650 op add :compute:i 39 1
   651 set :compute:x1 :compute:zx
 
   657 op mul *tmp120 *tmp119 :compute:zy
   658 op add :compute:zy *tmp120 :compute:cy
   659 op len :compute:dist :compute:zx :compute:zy
-    * jump *label319 lessThan :compute:dist 64
-    * jump *label88 always
+  660 jump *label88 greaterThanEq :compute:dist 64
   661 label *label319
   662 op add :compute:i 40 1
   663 set :compute:x1 :compute:zx
 
   669 op mul *tmp120 *tmp119 :compute:zy
   670 op add :compute:zy *tmp120 :compute:cy
   671 op len :compute:dist :compute:zx :compute:zy
-    * jump *label322 lessThan :compute:dist 64
-    * jump *label88 always
+  672 jump *label88 greaterThanEq :compute:dist 64
   673 label *label322
   674 op add :compute:i 41 1
   675 set :compute:x1 :compute:zx
 
   681 op mul *tmp120 *tmp119 :compute:zy
   682 op add :compute:zy *tmp120 :compute:cy
   683 op len :compute:dist :compute:zx :compute:zy
-    * jump *label325 lessThan :compute:dist 64
-    * jump *label88 always
+  684 jump *label88 greaterThanEq :compute:dist 64
   685 label *label325
   686 op add :compute:i 42 1
   687 set :compute:x1 :compute:zx
 
   693 op mul *tmp120 *tmp119 :compute:zy
   694 op add :compute:zy *tmp120 :compute:cy
   695 op len :compute:dist :compute:zx :compute:zy
-    * jump *label328 lessThan :compute:dist 64
-    * jump *label88 always
+  696 jump *label88 greaterThanEq :compute:dist 64
   697 label *label328
   698 op add :compute:i 43 1
   699 set :compute:x1 :compute:zx
 
   705 op mul *tmp120 *tmp119 :compute:zy
   706 op add :compute:zy *tmp120 :compute:cy
   707 op len :compute:dist :compute:zx :compute:zy
-    * jump *label331 lessThan :compute:dist 64
-    * jump *label88 always
+  708 jump *label88 greaterThanEq :compute:dist 64
   709 label *label331
   710 op add :compute:i 44 1
   711 set :compute:x1 :compute:zx
 
   717 op mul *tmp120 *tmp119 :compute:zy
   718 op add :compute:zy *tmp120 :compute:cy
   719 op len :compute:dist :compute:zx :compute:zy
-    * jump *label334 lessThan :compute:dist 64
-    * jump *label88 always
+  720 jump *label88 greaterThanEq :compute:dist 64
   721 label *label334
   722 op add :compute:i 45 1
   723 set :compute:x1 :compute:zx
 
   729 op mul *tmp120 *tmp119 :compute:zy
   730 op add :compute:zy *tmp120 :compute:cy
   731 op len :compute:dist :compute:zx :compute:zy
-    * jump *label337 lessThan :compute:dist 64
-    * jump *label88 always
+  732 jump *label88 greaterThanEq :compute:dist 64
   733 label *label337
   734 op add :compute:i 46 1
   735 set :compute:x1 :compute:zx
 
   741 op mul *tmp120 *tmp119 :compute:zy
   742 op add :compute:zy *tmp120 :compute:cy
   743 op len :compute:dist :compute:zx :compute:zy
-    * jump *label340 lessThan :compute:dist 64
-    * jump *label88 always
+  744 jump *label88 greaterThanEq :compute:dist 64
   745 label *label340
   746 op add :compute:i 47 1
   747 set :compute:x1 :compute:zx
 
   753 op mul *tmp120 *tmp119 :compute:zy
   754 op add :compute:zy *tmp120 :compute:cy
   755 op len :compute:dist :compute:zx :compute:zy
-    * jump *label343 lessThan :compute:dist 64
-    * jump *label88 always
+  756 jump *label88 greaterThanEq :compute:dist 64
   757 label *label343
   758 op add :compute:i 48 1
   759 set :compute:x1 :compute:zx
 
   765 op mul *tmp120 *tmp119 :compute:zy
   766 op add :compute:zy *tmp120 :compute:cy
   767 op len :compute:dist :compute:zx :compute:zy
-    * jump *label346 lessThan :compute:dist 64
-    * jump *label88 always
+  768 jump *label88 greaterThanEq :compute:dist 64
   769 label *label346
   770 op add :compute:i 49 1
   771 set :compute:x1 :compute:zx
 
   777 op mul *tmp120 *tmp119 :compute:zy
   778 op add :compute:zy *tmp120 :compute:cy
   779 op len :compute:dist :compute:zx :compute:zy
-    * jump *label349 lessThan :compute:dist 64
-    * jump *label88 always
+  780 jump *label88 greaterThanEq :compute:dist 64
   781 label *label349
   782 op add :compute:i 50 1
   783 set :compute:x1 :compute:zx
 
   789 op mul *tmp120 *tmp119 :compute:zy
   790 op add :compute:zy *tmp120 :compute:cy
   791 op len :compute:dist :compute:zx :compute:zy
-    * jump *label352 lessThan :compute:dist 64
-    * jump *label88 always
+  792 jump *label88 greaterThanEq :compute:dist 64
   793 label *label352
   794 op add :compute:i 51 1
   795 set :compute:x1 :compute:zx
 
   801 op mul *tmp120 *tmp119 :compute:zy
   802 op add :compute:zy *tmp120 :compute:cy
   803 op len :compute:dist :compute:zx :compute:zy
-    * jump *label355 lessThan :compute:dist 64
-    * jump *label88 always
+  804 jump *label88 greaterThanEq :compute:dist 64
   805 label *label355
   806 op add :compute:i 52 1
   807 set :compute:x1 :compute:zx
 
   813 op mul *tmp120 *tmp119 :compute:zy
   814 op add :compute:zy *tmp120 :compute:cy
   815 op len :compute:dist :compute:zx :compute:zy
-    * jump *label358 lessThan :compute:dist 64
-    * jump *label88 always
+  816 jump *label88 greaterThanEq :compute:dist 64
   817 label *label358
   818 op add :compute:i 53 1
   819 set :compute:x1 :compute:zx
 
   825 op mul *tmp120 *tmp119 :compute:zy
   826 op add :compute:zy *tmp120 :compute:cy
   827 op len :compute:dist :compute:zx :compute:zy
-    * jump *label361 lessThan :compute:dist 64
-    * jump *label88 always
+  828 jump *label88 greaterThanEq :compute:dist 64
   829 label *label361
   830 op add :compute:i 54 1
   831 set :compute:x1 :compute:zx
 
   837 op mul *tmp120 *tmp119 :compute:zy
   838 op add :compute:zy *tmp120 :compute:cy
   839 op len :compute:dist :compute:zx :compute:zy
-    * jump *label364 lessThan :compute:dist 64
-    * jump *label88 always
+  840 jump *label88 greaterThanEq :compute:dist 64
   841 label *label364
   842 op add :compute:i 55 1
   843 set :compute:x1 :compute:zx
 
   849 op mul *tmp120 *tmp119 :compute:zy
   850 op add :compute:zy *tmp120 :compute:cy
   851 op len :compute:dist :compute:zx :compute:zy
-    * jump *label367 lessThan :compute:dist 64
-    * jump *label88 always
+  852 jump *label88 greaterThanEq :compute:dist 64
   853 label *label367
   854 op add :compute:i 56 1
   855 set :compute:x1 :compute:zx
 
   861 op mul *tmp120 *tmp119 :compute:zy
   862 op add :compute:zy *tmp120 :compute:cy
   863 op len :compute:dist :compute:zx :compute:zy
-    * jump *label370 lessThan :compute:dist 64
-    * jump *label88 always
+  864 jump *label88 greaterThanEq :compute:dist 64
   865 label *label370
   866 op add :compute:i 57 1
   867 set :compute:x1 :compute:zx
 
   873 op mul *tmp120 *tmp119 :compute:zy
   874 op add :compute:zy *tmp120 :compute:cy
   875 op len :compute:dist :compute:zx :compute:zy
-    * jump *label373 lessThan :compute:dist 64
-    * jump *label88 always
+  876 jump *label88 greaterThanEq :compute:dist 64
   877 label *label373
   878 op add :compute:i 58 1
   879 set :compute:x1 :compute:zx
 
   885 op mul *tmp120 *tmp119 :compute:zy
   886 op add :compute:zy *tmp120 :compute:cy
   887 op len :compute:dist :compute:zx :compute:zy
-    * jump *label376 lessThan :compute:dist 64
-    * jump *label88 always
+  888 jump *label88 greaterThanEq :compute:dist 64
   889 label *label376
   890 op add :compute:i 59 1
   891 set :compute:x1 :compute:zx
 
   897 op mul *tmp120 *tmp119 :compute:zy
   898 op add :compute:zy *tmp120 :compute:cy
   899 op len :compute:dist :compute:zx :compute:zy
-    * jump *label379 lessThan :compute:dist 64
-    * jump *label88 always
+  900 jump *label88 greaterThanEq :compute:dist 64
   901 label *label379
   902 op add :compute:i 60 1
   903 set :compute:x1 :compute:zx
 
   909 op mul *tmp120 *tmp119 :compute:zy
   910 op add :compute:zy *tmp120 :compute:cy
   911 op len :compute:dist :compute:zx :compute:zy
-    * jump *label382 lessThan :compute:dist 64
-    * jump *label88 always
+  912 jump *label88 greaterThanEq :compute:dist 64
   913 label *label382
   914 op add :compute:i 61 1
   915 set :compute:x1 :compute:zx
 
   921 op mul *tmp120 *tmp119 :compute:zy
   922 op add :compute:zy *tmp120 :compute:cy
   923 op len :compute:dist :compute:zx :compute:zy
-    * jump *label385 lessThan :compute:dist 64
-    * jump *label88 always
+  924 jump *label88 greaterThanEq :compute:dist 64
   925 label *label385
   926 op add :compute:i 62 1
   927 label *label88
 
  1018 label *label125
  1019 wait 0
  1020 read *tmp197 .memory 68
-    * jump *label129 equal .stop *tmp197
-    * jump *label29 always
+ 1021 jump *label29 notEqual .stop *tmp197
  1022 label *label129
  1023 read *tmp199 .memory 66
  1024 op add *tmp2 *tmp199 1

Modifications by Jumps phase, Jump Threading, pass 6, iteration 1:
 
    59 label *label36
    60 wait 0
    61 read *tmp47 .memory 68
-    * jump *label29 notEqual .stop *tmp47
+   62 jump *label28 notEqual .stop *tmp47
    63 read :batch .memory 64
    64 read *tmp50 .memory 64
    65 op add *tmp51 *tmp50 :multiple
 
   873 label *label79
   874 jump *label96 lessThanEq .PALETTE 1
   875 set :drawPixel:color %[black]
-    * jump *label99 equal *tmp97 63
+  876 jump *label97 equal *tmp97 63
   877 multijump .PALETTE 0 0 (m:*label192)
   878 multilabel *label197 (m:*label192)
   879 multilabel *label193 (m:*label192)
   880 op div *tmp171 *tmp97 63.75
   881 op sub :drawPixel:r 1 *tmp171
   882 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * jump *label100 always
+  883 jump *label97 always
   884 multilabel *label194 (m:*label192)
   885 op sub *tmp137 32 *tmp97
   886 op abs *tmp138 *tmp137
 
   893 op div *tmp150 *tmp138 63.75
   894 op add :drawPixel:b 0.47058823529411764 *tmp150
   895 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label100 always
+  896 jump *label97 always
   897 multilabel *label195 (m:*label192)
   898 op div *tmp154 *tmp97 0.175
   899 op sin :drawPixel:r *tmp154
 
   903 op div *tmp162 *tmp160 63.75
   904 op add :drawPixel:b 0.39215686274509803 *tmp162
   905 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label100 always
+  906 jump *label97 always
   907 multilabel *label196 (m:*label192)
   908 op div :drawPixel:r *tmp97 63.75
   909 op div :drawPixel:g *tmp97 170
 
   915 read :drawPixel:color .memory *tmp97
   916 label *label97
   917 jump *label107 lessThan .localBuffer 254
-    * jump *label112 lessThanEq .localBuffer 0
+  918 jump *label120 lessThanEq .localBuffer 0
   919 label *label147
   920 read *tmp181 .memory 68
   921 jump *label112 notEqual .stop *tmp181
 
   953 label *label125
   954 wait 0
   955 read *tmp197 .memory 68
-    * jump *label29 notEqual .stop *tmp197
+  956 jump *label28 notEqual .stop *tmp197
   957 read *tmp199 .memory 66
   958 op add *tmp2 *tmp199 1
   959 write *tmp2 .memory 66
 
   966 select :multiple greaterThanEq :batch 1337.6 1 :multiple
   967 jump *label36 always
   968 label *label38
-    * jump *label136 lessThanEq .localBuffer 0
+  969 jump *label28 lessThanEq .localBuffer 0
   970 label *label148
   971 read *tmp207 .memory 68
-    * jump *label136 notEqual .stop *tmp207
+  972 jump *label28 notEqual .stop *tmp207
   973 wait 0
   974 sensor *tmp208 .display @enabled
   975 jump *label140 equal *tmp208 false

Modifications by Final phase, Print Merging, iteration 1 (-7 instructions):
 
    16 set .memory :findLinkedBlocks:variable
    17 jump *label144 greaterThan :findLinkedBlocks:n 0
    18 label *label11
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
-    * print .display
+   19 print "\nDisplay: {0}\nMemory: "
+   20 format .display
    21 op and :findLinkedBlocks:foundAll 1 .display
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
    22 print .memory
    23 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    24 printflush null

Final code before resolving virtual instructions:

    0:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label1                                                *blocks: do
    1:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    2:  set .memory null                                             ...
    3:  print "Mandelbrot Generator"                                 *blocks: print(title);
    4:  set :findLinkedBlocks:n @links                               *blocks: var n = @links;
    5:  jump *label11 lessThanEq :findLinkedBlocks:n 0               *blocks: while n > 0 do
        label *label144                                              ...
    6:  op sub :findLinkedBlocks:n :findLinkedBlocks:n 1             *blocks: var block = getlink(--n);
    7:  getlink :findLinkedBlocks:block :findLinkedBlocks:n          ...
    8:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
    9:  print :findLinkedBlocks:block                                ...
   10:  sensor :findLinkedBlocks:type :findLinkedBlocks:block @type  *blocks: var type = block.@type;
   11:  select :findLinkedBlocks:variable equal @large-logic-display *blocks: if requested == type then
   12:  set .display :findLinkedBlocks:variable                      *blocks: for requested, name, out variable, required in linkMap do
   13:  select :findLinkedBlocks:variable equal @memory-bank :findLi *blocks: if requested == type then
   14:  set .memory :findLinkedBlocks:variable                       *blocks: for requested, name, out variable, required in linkMap do
   15:  jump *label144 greaterThan :findLinkedBlocks:n 0             *blocks: while n > 0 do
        label *label11                                               ...
   16:  print "\nDisplay: {0}\nMemory: "                             *blocks: print($"\n$name: $variable");
   17:  format .display                                              ...
   18:  op and :findLinkedBlocks:foundAll 1 .display                 *blocks: if required then foundAll &= variable; end;
   19:  print .memory                                                *blocks: print($"\n$name: $variable");
   20:  op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll *blocks: if required then foundAll &= variable; end;
   21:  printflush null                                              *blocks: printflush(message);
   22:  jump *label1 equal :findLinkedBlocks:foundAll false          *blocks: do
        label *label28                                               mandelbrot-compute.mnd: MainLoop:
        label *label31                                               mandelbrot-compute.mnd: do wait(0); while start == $START;
   23:  wait 0                                                       ...
   24:  read *tmp27 .memory 67                                       ...
   25:  jump *label31 equal .start *tmp27                            ...
   26:  read .start .memory 67                                       mandelbrot-compute.mnd: start = $START;
   27:  read .stop .memory 68                                        mandelbrot-compute.mnd: stop = $STOP;
   28:  set .lastColor -1                                            mandelbrot-compute.mnd: lastColor = -1;
   29:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   30:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
   31:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
   32:  read .ZOOM .memory 71                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   33:  op div *tmp31 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   34:  read *tmp33 .memory 69                                       ...
   35:  op add .OFFSET_X *tmp31 *tmp33                               ...
   36:  read *tmp36 .memory 70                                       mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   37:  op add .OFFSET_Y *tmp31 *tmp36                               ...
   38:  read .JULIA .memory 72                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   39:  read .JULIA_X .memory 73                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   40:  read .JULIA_Y .memory 74                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   41:  read .PALETTE .memory 75                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   42:  read .ALL_PASS_COLORING .memory 76                           mandelbrot-compute.mnd: ALL_PASS_COLORING = $ALL_PASS_COLORING;
   43:  read *tmp43 .memory 77                                       mandelbrot-compute.mnd: var leaderLimit = $SHOW_LEADER ? 1 - ALL_PASS_COLORING : 99;
   44:  op sub *tmp213 1 .ALL_PASS_COLORING                          ...
   45:  select *tmp44 notEqual *tmp43 false *tmp213 99               ...
   46:  set :multiple 4                                              mandelbrot-compute.mnd: var multiple = 4;
        label *label36                                               mandelbrot-compute.mnd: while true do
   47:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
   48:  read *tmp47 .memory 68                                       mandelbrot-compute.mnd: if stop != $STOP then
   49:  jump *label28 notEqual .stop *tmp47                          ...
   50:  read :batch .memory 64                                       mandelbrot-compute.mnd: batch = $LINE;
   51:  read *tmp50 .memory 64                                       mandelbrot-compute.mnd: $LINE += multiple;
   52:  op add *tmp51 *tmp50 :multiple                               ...
   53:  write *tmp51 .memory 64                 # The last atomic bl ...
   54:  jump *label38 greaterThanEq :batch 2816                      mandelbrot-compute.mnd: if batch >= TOTAL_BATCHES then
   55:  op mul *tmp55 11 :multiple                                   mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
   56:  set :i 0                                                     ...
   57:  op mul *tmp56 :batch 11                                      ...
   58:  jump *label45 lessThanEq :multiple 0                         ...
        label *label145                                              ...
   59:  op add :adam5:index *tmp56 :i                                mandelbrot-compute.mnd: adam5(batch * BATCH_SIZE + i, out x, out y, out dx, out dy);
   60:  op idiv *tmp59 :adam5:index 16                               mandelbrot-compute.mnd: case index \ 16
   61:  multijump *tmp59 0 0                                         ...
        multilabel *label190                                         ...
   62:  op sub :adam5:index :adam5:index 15488                       mandelbrot-compute.mnd: index -= 8 * PASS_SIZE;
   63:  op mod :adam5:x :adam5:index 176                             mandelbrot-compute.mnd: x = (index % SIZE1);
   64:  op idiv *tmp86 :adam5:index 176                              mandelbrot-compute.mnd: y = 2 * (index \ SIZE1) + 1;
   65:  op mul *tmp87 2 *tmp86                                       ...
   66:  op add :adam5:y *tmp87 1                                     ...
   67:  set :adam5:dy 1                                              mandelbrot-compute.mnd: dx = dy = 1;
   68:  set :adam5:dx 1                                              ...
   69:  jump *label47 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label186                                         ...
   70:  op mod *tmp61 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4);
   71:  op mul :adam5:x 4 *tmp61                                     ...
   72:  op idiv *tmp63 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   73:  op mul :adam5:y 4 *tmp63                                     ...
   74:  select *tmp65 notEqual .ALL_PASS_COLORING false 4 2          mandelbrot-compute.mnd: dx = dy = ALL_PASS_COLORING ? 4 : 2;
   75:  set :adam5:dy *tmp65                                         ...
   76:  set :adam5:dx *tmp65                                         ...
   77:  jump *label47 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label187                                         ...
   78:  op sub :adam5:index :adam5:index 1936                        mandelbrot-compute.mnd: index -= PASS_SIZE;
   79:  op mod *tmp66 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4) + 2;
   80:  op mul *tmp67 4 *tmp66                                       ...
   81:  op add :adam5:x *tmp67 2                                     ...
   82:  op idiv *tmp69 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   83:  op mul :adam5:y 4 *tmp69                                     ...
   84:  select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1       mandelbrot-compute.mnd: dx = ALL_PASS_COLORING ? 2 : 1;
   85:  select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2       mandelbrot-compute.mnd: dy = ALL_PASS_COLORING ? 4 : 2;
   86:  jump *label47 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label188                                         ...
   87:  op sub :adam5:index :adam5:index 3872                        mandelbrot-compute.mnd: index -= 2 * PASS_SIZE;
   88:  op mod *tmp73 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2);
   89:  op mul :adam5:x 2 *tmp73                                     ...
   90:  op idiv *tmp75 :adam5:index 88                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE2) + 2;
   91:  op mul *tmp76 4 *tmp75                                       ...
   92:  op add :adam5:y *tmp76 2                                     ...
   93:  select *tmp78 notEqual .ALL_PASS_COLORING false 2 1          mandelbrot-compute.mnd: dx = dy = ALL_PASS_COLORING ? 2 : 1;
   94:  set :adam5:dy *tmp78                                         ...
   95:  set :adam5:dx *tmp78                                         ...
   96:  jump *label47 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label189                                         ...
   97:  op sub :adam5:index :adam5:index 7744                        mandelbrot-compute.mnd: index -= 4 * PASS_SIZE;
   98:  op mod *tmp79 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2) + 1;
   99:  op mul *tmp80 2 *tmp79                                       ...
  100:  op add :adam5:x *tmp80 1                                     ...
  101:  op idiv *tmp82 :adam5:index 88                               mandelbrot-compute.mnd: y = 2 * (index \ SIZE2);
  102:  op mul :adam5:y 2 *tmp82                                     ...
  103:  set :adam5:dx 1                                              mandelbrot-compute.mnd: dx = 1; dy = ALL_PASS_COLORING ? 2 : 1;
  104:  select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1       ...
        label *label47                                               mandelbrot-compute.mnd: case index \ 16
  105:  jump *label70 lessThanEq :multiple *tmp44                    mandelbrot-compute.mnd: if multiple > leaderLimit and localBuffer == 0 then
  106:  jump *label70 notEqual .localBuffer 0                        ...
  107:  draw col %[white] 0 0 0 0 0                                  mandelbrot-compute.mnd: col(%[white]);
  108:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dx);
  109:  set .lastColor %[white]                                      mandelbrot-compute.mnd: lastColor = %[white];
  110:  set .localBuffer 2                                           mandelbrot-compute.mnd: localBuffer = 2;
  111:  wait 0.004                              # 0.240 ticks for at mandelbrot-compute.mnd: atomic
  112:  sensor *tmp92 .display @enabled                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  113:  jump *label75 equal *tmp92 false                             ...
  114:  sensor *tmp93 .display @bufferSize                           ...
  115:  jump *label75 greaterThanEq *tmp93 1022                      ...
  116:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  117:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label75                                               mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label70                                               mandelbrot-compute.mnd: if multiple > leaderLimit and localBuffer == 0 then
  118:  op div *tmp98 :adam5:x .ZOOM                                 mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
  119:  op add :compute:zx *tmp98 .OFFSET_X                          ...
  120:  op div *tmp100 :adam5:y .ZOOM                                mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
  121:  op add :compute:zy *tmp100 .OFFSET_Y                         ...
  122:  jump *label80 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
  123:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
  124:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
  125:  jump *label81 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label80                                               ...
  126:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
  127:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
  128:  op sub *tmp103 :compute:zx 0.25                              mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
  129:  op len :compute:p *tmp103 :compute:zy                        ...
  130:  op mul *tmp105 2 :compute:p                                  mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  131:  op mul *tmp106 *tmp105 :compute:p                            ...
  132:  op sub *tmp107 :compute:p *tmp106                            ...
  133:  op add *tmp108 *tmp107 0.25                                  ...
  134:  jump *label82 greaterThan :compute:zx *tmp108                ...
  135:  set *tmp97 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  136:  jump *label79 always 0 0                                     ...
        label *label82                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  137:  op add *tmp111 :compute:zx 1                                 mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  138:  op len *tmp112 *tmp111 :compute:zy                           ...
  139:  jump *label84 greaterThan *tmp112 0.25                       ...
  140:  set *tmp97 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  141:  jump *label79 always 0 0                                     ...
        label *label84                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label81                                               mandelbrot-compute.mnd: if JULIA then
  142:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  143:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  144:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  145:  op mul *tmp116 :compute:zy :compute:zy                       ...
  146:  op sub *tmp117 *tmp115 *tmp116                               ...
  147:  op add :compute:zx *tmp117 :compute:cx                       ...
  148:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  149:  op mul *tmp120 *tmp119 :compute:zy                           ...
  150:  op add :compute:zy *tmp120 :compute:cy                       ...
  151:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  152:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  153:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  154:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  155:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  156:  op mul *tmp116 :compute:zy :compute:zy                       ...
  157:  op sub *tmp117 *tmp115 *tmp116                               ...
  158:  op add :compute:zx *tmp117 :compute:cx                       ...
  159:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  160:  op mul *tmp120 *tmp119 :compute:zy                           ...
  161:  op add :compute:zy *tmp120 :compute:cy                       ...
  162:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  163:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  164:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  165:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  166:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  167:  op mul *tmp116 :compute:zy :compute:zy                       ...
  168:  op sub *tmp117 *tmp115 *tmp116                               ...
  169:  op add :compute:zx *tmp117 :compute:cx                       ...
  170:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  171:  op mul *tmp120 *tmp119 :compute:zy                           ...
  172:  op add :compute:zy *tmp120 :compute:cy                       ...
  173:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  174:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  175:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  176:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  177:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  178:  op mul *tmp116 :compute:zy :compute:zy                       ...
  179:  op sub *tmp117 *tmp115 *tmp116                               ...
  180:  op add :compute:zx *tmp117 :compute:cx                       ...
  181:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  182:  op mul *tmp120 *tmp119 :compute:zy                           ...
  183:  op add :compute:zy *tmp120 :compute:cy                       ...
  184:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  185:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  186:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  187:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  188:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  189:  op mul *tmp116 :compute:zy :compute:zy                       ...
  190:  op sub *tmp117 *tmp115 *tmp116                               ...
  191:  op add :compute:zx *tmp117 :compute:cx                       ...
  192:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  193:  op mul *tmp120 *tmp119 :compute:zy                           ...
  194:  op add :compute:zy *tmp120 :compute:cy                       ...
  195:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  196:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  197:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  198:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  199:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  200:  op mul *tmp116 :compute:zy :compute:zy                       ...
  201:  op sub *tmp117 *tmp115 *tmp116                               ...
  202:  op add :compute:zx *tmp117 :compute:cx                       ...
  203:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  204:  op mul *tmp120 *tmp119 :compute:zy                           ...
  205:  op add :compute:zy *tmp120 :compute:cy                       ...
  206:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  207:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  208:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  209:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  210:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  211:  op mul *tmp116 :compute:zy :compute:zy                       ...
  212:  op sub *tmp117 *tmp115 *tmp116                               ...
  213:  op add :compute:zx *tmp117 :compute:cx                       ...
  214:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  215:  op mul *tmp120 *tmp119 :compute:zy                           ...
  216:  op add :compute:zy *tmp120 :compute:cy                       ...
  217:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  218:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  219:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  220:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  221:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  222:  op mul *tmp116 :compute:zy :compute:zy                       ...
  223:  op sub *tmp117 *tmp115 *tmp116                               ...
  224:  op add :compute:zx *tmp117 :compute:cx                       ...
  225:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  226:  op mul *tmp120 *tmp119 :compute:zy                           ...
  227:  op add :compute:zy *tmp120 :compute:cy                       ...
  228:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  229:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  230:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  231:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  232:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  233:  op mul *tmp116 :compute:zy :compute:zy                       ...
  234:  op sub *tmp117 *tmp115 *tmp116                               ...
  235:  op add :compute:zx *tmp117 :compute:cx                       ...
  236:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  237:  op mul *tmp120 *tmp119 :compute:zy                           ...
  238:  op add :compute:zy *tmp120 :compute:cy                       ...
  239:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  240:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  241:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  242:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  243:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  244:  op mul *tmp116 :compute:zy :compute:zy                       ...
  245:  op sub *tmp117 *tmp115 *tmp116                               ...
  246:  op add :compute:zx *tmp117 :compute:cx                       ...
  247:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  248:  op mul *tmp120 *tmp119 :compute:zy                           ...
  249:  op add :compute:zy *tmp120 :compute:cy                       ...
  250:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  251:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  252:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  253:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  254:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  255:  op mul *tmp116 :compute:zy :compute:zy                       ...
  256:  op sub *tmp117 *tmp115 *tmp116                               ...
  257:  op add :compute:zx *tmp117 :compute:cx                       ...
  258:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  259:  op mul *tmp120 *tmp119 :compute:zy                           ...
  260:  op add :compute:zy *tmp120 :compute:cy                       ...
  261:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  262:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  263:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  264:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  265:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  266:  op mul *tmp116 :compute:zy :compute:zy                       ...
  267:  op sub *tmp117 *tmp115 *tmp116                               ...
  268:  op add :compute:zx *tmp117 :compute:cx                       ...
  269:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  270:  op mul *tmp120 *tmp119 :compute:zy                           ...
  271:  op add :compute:zy *tmp120 :compute:cy                       ...
  272:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  273:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  274:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  275:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  276:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  277:  op mul *tmp116 :compute:zy :compute:zy                       ...
  278:  op sub *tmp117 *tmp115 *tmp116                               ...
  279:  op add :compute:zx *tmp117 :compute:cx                       ...
  280:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  281:  op mul *tmp120 *tmp119 :compute:zy                           ...
  282:  op add :compute:zy *tmp120 :compute:cy                       ...
  283:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  284:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  285:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  286:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  287:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  288:  op mul *tmp116 :compute:zy :compute:zy                       ...
  289:  op sub *tmp117 *tmp115 *tmp116                               ...
  290:  op add :compute:zx *tmp117 :compute:cx                       ...
  291:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  292:  op mul *tmp120 *tmp119 :compute:zy                           ...
  293:  op add :compute:zy *tmp120 :compute:cy                       ...
  294:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  295:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  296:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  297:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  298:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  299:  op mul *tmp116 :compute:zy :compute:zy                       ...
  300:  op sub *tmp117 *tmp115 *tmp116                               ...
  301:  op add :compute:zx *tmp117 :compute:cx                       ...
  302:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  303:  op mul *tmp120 *tmp119 :compute:zy                           ...
  304:  op add :compute:zy *tmp120 :compute:cy                       ...
  305:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  306:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  307:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  308:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  309:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  310:  op mul *tmp116 :compute:zy :compute:zy                       ...
  311:  op sub *tmp117 *tmp115 *tmp116                               ...
  312:  op add :compute:zx *tmp117 :compute:cx                       ...
  313:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  314:  op mul *tmp120 *tmp119 :compute:zy                           ...
  315:  op add :compute:zy *tmp120 :compute:cy                       ...
  316:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  317:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  318:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  319:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  320:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  321:  op mul *tmp116 :compute:zy :compute:zy                       ...
  322:  op sub *tmp117 *tmp115 *tmp116                               ...
  323:  op add :compute:zx *tmp117 :compute:cx                       ...
  324:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  325:  op mul *tmp120 *tmp119 :compute:zy                           ...
  326:  op add :compute:zy *tmp120 :compute:cy                       ...
  327:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  328:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  329:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  330:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  331:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  332:  op mul *tmp116 :compute:zy :compute:zy                       ...
  333:  op sub *tmp117 *tmp115 *tmp116                               ...
  334:  op add :compute:zx *tmp117 :compute:cx                       ...
  335:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  336:  op mul *tmp120 *tmp119 :compute:zy                           ...
  337:  op add :compute:zy *tmp120 :compute:cy                       ...
  338:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  339:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  340:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  341:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  342:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  343:  op mul *tmp116 :compute:zy :compute:zy                       ...
  344:  op sub *tmp117 *tmp115 *tmp116                               ...
  345:  op add :compute:zx *tmp117 :compute:cx                       ...
  346:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  347:  op mul *tmp120 *tmp119 :compute:zy                           ...
  348:  op add :compute:zy *tmp120 :compute:cy                       ...
  349:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  350:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  351:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  352:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  353:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  354:  op mul *tmp116 :compute:zy :compute:zy                       ...
  355:  op sub *tmp117 *tmp115 *tmp116                               ...
  356:  op add :compute:zx *tmp117 :compute:cx                       ...
  357:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  358:  op mul *tmp120 *tmp119 :compute:zy                           ...
  359:  op add :compute:zy *tmp120 :compute:cy                       ...
  360:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  361:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  362:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  363:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  364:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  365:  op mul *tmp116 :compute:zy :compute:zy                       ...
  366:  op sub *tmp117 *tmp115 *tmp116                               ...
  367:  op add :compute:zx *tmp117 :compute:cx                       ...
  368:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  369:  op mul *tmp120 *tmp119 :compute:zy                           ...
  370:  op add :compute:zy *tmp120 :compute:cy                       ...
  371:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  372:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  373:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  374:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  375:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  376:  op mul *tmp116 :compute:zy :compute:zy                       ...
  377:  op sub *tmp117 *tmp115 *tmp116                               ...
  378:  op add :compute:zx *tmp117 :compute:cx                       ...
  379:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  380:  op mul *tmp120 *tmp119 :compute:zy                           ...
  381:  op add :compute:zy *tmp120 :compute:cy                       ...
  382:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  383:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  384:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  385:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  386:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  387:  op mul *tmp116 :compute:zy :compute:zy                       ...
  388:  op sub *tmp117 *tmp115 *tmp116                               ...
  389:  op add :compute:zx *tmp117 :compute:cx                       ...
  390:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  391:  op mul *tmp120 *tmp119 :compute:zy                           ...
  392:  op add :compute:zy *tmp120 :compute:cy                       ...
  393:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  394:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  395:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  396:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  397:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  398:  op mul *tmp116 :compute:zy :compute:zy                       ...
  399:  op sub *tmp117 *tmp115 *tmp116                               ...
  400:  op add :compute:zx *tmp117 :compute:cx                       ...
  401:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  402:  op mul *tmp120 *tmp119 :compute:zy                           ...
  403:  op add :compute:zy *tmp120 :compute:cy                       ...
  404:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  405:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  406:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  407:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  408:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  409:  op mul *tmp116 :compute:zy :compute:zy                       ...
  410:  op sub *tmp117 *tmp115 *tmp116                               ...
  411:  op add :compute:zx *tmp117 :compute:cx                       ...
  412:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  413:  op mul *tmp120 *tmp119 :compute:zy                           ...
  414:  op add :compute:zy *tmp120 :compute:cy                       ...
  415:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  416:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  417:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  418:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  419:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  420:  op mul *tmp116 :compute:zy :compute:zy                       ...
  421:  op sub *tmp117 *tmp115 *tmp116                               ...
  422:  op add :compute:zx *tmp117 :compute:cx                       ...
  423:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  424:  op mul *tmp120 *tmp119 :compute:zy                           ...
  425:  op add :compute:zy *tmp120 :compute:cy                       ...
  426:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  427:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  428:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  429:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  430:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  431:  op mul *tmp116 :compute:zy :compute:zy                       ...
  432:  op sub *tmp117 *tmp115 *tmp116                               ...
  433:  op add :compute:zx *tmp117 :compute:cx                       ...
  434:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  435:  op mul *tmp120 *tmp119 :compute:zy                           ...
  436:  op add :compute:zy *tmp120 :compute:cy                       ...
  437:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  438:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  439:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  440:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  441:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  442:  op mul *tmp116 :compute:zy :compute:zy                       ...
  443:  op sub *tmp117 *tmp115 *tmp116                               ...
  444:  op add :compute:zx *tmp117 :compute:cx                       ...
  445:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  446:  op mul *tmp120 *tmp119 :compute:zy                           ...
  447:  op add :compute:zy *tmp120 :compute:cy                       ...
  448:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  449:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  450:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  451:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  452:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  453:  op mul *tmp116 :compute:zy :compute:zy                       ...
  454:  op sub *tmp117 *tmp115 *tmp116                               ...
  455:  op add :compute:zx *tmp117 :compute:cx                       ...
  456:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  457:  op mul *tmp120 *tmp119 :compute:zy                           ...
  458:  op add :compute:zy *tmp120 :compute:cy                       ...
  459:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  460:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  461:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  462:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  463:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  464:  op mul *tmp116 :compute:zy :compute:zy                       ...
  465:  op sub *tmp117 *tmp115 *tmp116                               ...
  466:  op add :compute:zx *tmp117 :compute:cx                       ...
  467:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  468:  op mul *tmp120 *tmp119 :compute:zy                           ...
  469:  op add :compute:zy *tmp120 :compute:cy                       ...
  470:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  471:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  472:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  473:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  474:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  475:  op mul *tmp116 :compute:zy :compute:zy                       ...
  476:  op sub *tmp117 *tmp115 *tmp116                               ...
  477:  op add :compute:zx *tmp117 :compute:cx                       ...
  478:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  479:  op mul *tmp120 *tmp119 :compute:zy                           ...
  480:  op add :compute:zy *tmp120 :compute:cy                       ...
  481:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  482:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  483:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  484:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  485:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  486:  op mul *tmp116 :compute:zy :compute:zy                       ...
  487:  op sub *tmp117 *tmp115 *tmp116                               ...
  488:  op add :compute:zx *tmp117 :compute:cx                       ...
  489:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  490:  op mul *tmp120 *tmp119 :compute:zy                           ...
  491:  op add :compute:zy *tmp120 :compute:cy                       ...
  492:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  493:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  494:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  495:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  496:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  497:  op mul *tmp116 :compute:zy :compute:zy                       ...
  498:  op sub *tmp117 *tmp115 *tmp116                               ...
  499:  op add :compute:zx *tmp117 :compute:cx                       ...
  500:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  501:  op mul *tmp120 *tmp119 :compute:zy                           ...
  502:  op add :compute:zy *tmp120 :compute:cy                       ...
  503:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  504:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  505:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  506:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  507:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  508:  op mul *tmp116 :compute:zy :compute:zy                       ...
  509:  op sub *tmp117 *tmp115 *tmp116                               ...
  510:  op add :compute:zx *tmp117 :compute:cx                       ...
  511:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  512:  op mul *tmp120 *tmp119 :compute:zy                           ...
  513:  op add :compute:zy *tmp120 :compute:cy                       ...
  514:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  515:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  516:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  517:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  518:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  519:  op mul *tmp116 :compute:zy :compute:zy                       ...
  520:  op sub *tmp117 *tmp115 *tmp116                               ...
  521:  op add :compute:zx *tmp117 :compute:cx                       ...
  522:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  523:  op mul *tmp120 *tmp119 :compute:zy                           ...
  524:  op add :compute:zy *tmp120 :compute:cy                       ...
  525:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  526:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  527:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  528:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  529:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  530:  op mul *tmp116 :compute:zy :compute:zy                       ...
  531:  op sub *tmp117 *tmp115 *tmp116                               ...
  532:  op add :compute:zx *tmp117 :compute:cx                       ...
  533:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  534:  op mul *tmp120 *tmp119 :compute:zy                           ...
  535:  op add :compute:zy *tmp120 :compute:cy                       ...
  536:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  537:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  538:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  539:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  540:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  541:  op mul *tmp116 :compute:zy :compute:zy                       ...
  542:  op sub *tmp117 *tmp115 *tmp116                               ...
  543:  op add :compute:zx *tmp117 :compute:cx                       ...
  544:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  545:  op mul *tmp120 *tmp119 :compute:zy                           ...
  546:  op add :compute:zy *tmp120 :compute:cy                       ...
  547:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  548:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  549:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  550:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  551:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  552:  op mul *tmp116 :compute:zy :compute:zy                       ...
  553:  op sub *tmp117 *tmp115 *tmp116                               ...
  554:  op add :compute:zx *tmp117 :compute:cx                       ...
  555:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  556:  op mul *tmp120 *tmp119 :compute:zy                           ...
  557:  op add :compute:zy *tmp120 :compute:cy                       ...
  558:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  559:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  560:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  561:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  562:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  563:  op mul *tmp116 :compute:zy :compute:zy                       ...
  564:  op sub *tmp117 *tmp115 *tmp116                               ...
  565:  op add :compute:zx *tmp117 :compute:cx                       ...
  566:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  567:  op mul *tmp120 *tmp119 :compute:zy                           ...
  568:  op add :compute:zy *tmp120 :compute:cy                       ...
  569:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  570:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  571:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  572:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  573:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  574:  op mul *tmp116 :compute:zy :compute:zy                       ...
  575:  op sub *tmp117 *tmp115 *tmp116                               ...
  576:  op add :compute:zx *tmp117 :compute:cx                       ...
  577:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  578:  op mul *tmp120 *tmp119 :compute:zy                           ...
  579:  op add :compute:zy *tmp120 :compute:cy                       ...
  580:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  581:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  582:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  583:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  584:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  585:  op mul *tmp116 :compute:zy :compute:zy                       ...
  586:  op sub *tmp117 *tmp115 *tmp116                               ...
  587:  op add :compute:zx *tmp117 :compute:cx                       ...
  588:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  589:  op mul *tmp120 *tmp119 :compute:zy                           ...
  590:  op add :compute:zy *tmp120 :compute:cy                       ...
  591:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  592:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  593:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  594:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  595:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  596:  op mul *tmp116 :compute:zy :compute:zy                       ...
  597:  op sub *tmp117 *tmp115 *tmp116                               ...
  598:  op add :compute:zx *tmp117 :compute:cx                       ...
  599:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  600:  op mul *tmp120 *tmp119 :compute:zy                           ...
  601:  op add :compute:zy *tmp120 :compute:cy                       ...
  602:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  603:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  604:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  605:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  606:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  607:  op mul *tmp116 :compute:zy :compute:zy                       ...
  608:  op sub *tmp117 *tmp115 *tmp116                               ...
  609:  op add :compute:zx *tmp117 :compute:cx                       ...
  610:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  611:  op mul *tmp120 *tmp119 :compute:zy                           ...
  612:  op add :compute:zy *tmp120 :compute:cy                       ...
  613:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  614:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  615:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  616:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  617:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  618:  op mul *tmp116 :compute:zy :compute:zy                       ...
  619:  op sub *tmp117 *tmp115 *tmp116                               ...
  620:  op add :compute:zx *tmp117 :compute:cx                       ...
  621:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  622:  op mul *tmp120 *tmp119 :compute:zy                           ...
  623:  op add :compute:zy *tmp120 :compute:cy                       ...
  624:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  625:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  626:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  627:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  628:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  629:  op mul *tmp116 :compute:zy :compute:zy                       ...
  630:  op sub *tmp117 *tmp115 *tmp116                               ...
  631:  op add :compute:zx *tmp117 :compute:cx                       ...
  632:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  633:  op mul *tmp120 *tmp119 :compute:zy                           ...
  634:  op add :compute:zy *tmp120 :compute:cy                       ...
  635:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  636:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  637:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  638:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  639:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  640:  op mul *tmp116 :compute:zy :compute:zy                       ...
  641:  op sub *tmp117 *tmp115 *tmp116                               ...
  642:  op add :compute:zx *tmp117 :compute:cx                       ...
  643:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  644:  op mul *tmp120 *tmp119 :compute:zy                           ...
  645:  op add :compute:zy *tmp120 :compute:cy                       ...
  646:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  647:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  648:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  649:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  650:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  651:  op mul *tmp116 :compute:zy :compute:zy                       ...
  652:  op sub *tmp117 *tmp115 *tmp116                               ...
  653:  op add :compute:zx *tmp117 :compute:cx                       ...
  654:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  655:  op mul *tmp120 *tmp119 :compute:zy                           ...
  656:  op add :compute:zy *tmp120 :compute:cy                       ...
  657:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  658:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  659:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  660:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  661:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  662:  op mul *tmp116 :compute:zy :compute:zy                       ...
  663:  op sub *tmp117 *tmp115 *tmp116                               ...
  664:  op add :compute:zx *tmp117 :compute:cx                       ...
  665:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  666:  op mul *tmp120 *tmp119 :compute:zy                           ...
  667:  op add :compute:zy *tmp120 :compute:cy                       ...
  668:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  669:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  670:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  671:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  672:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  673:  op mul *tmp116 :compute:zy :compute:zy                       ...
  674:  op sub *tmp117 *tmp115 *tmp116                               ...
  675:  op add :compute:zx *tmp117 :compute:cx                       ...
  676:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  677:  op mul *tmp120 *tmp119 :compute:zy                           ...
  678:  op add :compute:zy *tmp120 :compute:cy                       ...
  679:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  680:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  681:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  682:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  683:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  684:  op mul *tmp116 :compute:zy :compute:zy                       ...
  685:  op sub *tmp117 *tmp115 *tmp116                               ...
  686:  op add :compute:zx *tmp117 :compute:cx                       ...
  687:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  688:  op mul *tmp120 *tmp119 :compute:zy                           ...
  689:  op add :compute:zy *tmp120 :compute:cy                       ...
  690:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  691:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  692:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  693:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  694:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  695:  op mul *tmp116 :compute:zy :compute:zy                       ...
  696:  op sub *tmp117 *tmp115 *tmp116                               ...
  697:  op add :compute:zx *tmp117 :compute:cx                       ...
  698:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  699:  op mul *tmp120 *tmp119 :compute:zy                           ...
  700:  op add :compute:zy *tmp120 :compute:cy                       ...
  701:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  702:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  703:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  704:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  705:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  706:  op mul *tmp116 :compute:zy :compute:zy                       ...
  707:  op sub *tmp117 *tmp115 *tmp116                               ...
  708:  op add :compute:zx *tmp117 :compute:cx                       ...
  709:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  710:  op mul *tmp120 *tmp119 :compute:zy                           ...
  711:  op add :compute:zy *tmp120 :compute:cy                       ...
  712:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  713:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  714:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  715:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  716:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  717:  op mul *tmp116 :compute:zy :compute:zy                       ...
  718:  op sub *tmp117 *tmp115 *tmp116                               ...
  719:  op add :compute:zx *tmp117 :compute:cx                       ...
  720:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  721:  op mul *tmp120 *tmp119 :compute:zy                           ...
  722:  op add :compute:zy *tmp120 :compute:cy                       ...
  723:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  724:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  725:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  726:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  727:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  728:  op mul *tmp116 :compute:zy :compute:zy                       ...
  729:  op sub *tmp117 *tmp115 *tmp116                               ...
  730:  op add :compute:zx *tmp117 :compute:cx                       ...
  731:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  732:  op mul *tmp120 *tmp119 :compute:zy                           ...
  733:  op add :compute:zy *tmp120 :compute:cy                       ...
  734:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  735:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  736:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  737:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  738:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  739:  op mul *tmp116 :compute:zy :compute:zy                       ...
  740:  op sub *tmp117 *tmp115 *tmp116                               ...
  741:  op add :compute:zx *tmp117 :compute:cx                       ...
  742:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  743:  op mul *tmp120 *tmp119 :compute:zy                           ...
  744:  op add :compute:zy *tmp120 :compute:cy                       ...
  745:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  746:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  747:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  748:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  749:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  750:  op mul *tmp116 :compute:zy :compute:zy                       ...
  751:  op sub *tmp117 *tmp115 *tmp116                               ...
  752:  op add :compute:zx *tmp117 :compute:cx                       ...
  753:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  754:  op mul *tmp120 *tmp119 :compute:zy                           ...
  755:  op add :compute:zy *tmp120 :compute:cy                       ...
  756:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  757:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  758:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  759:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  760:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  761:  op mul *tmp116 :compute:zy :compute:zy                       ...
  762:  op sub *tmp117 *tmp115 *tmp116                               ...
  763:  op add :compute:zx *tmp117 :compute:cx                       ...
  764:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  765:  op mul *tmp120 *tmp119 :compute:zy                           ...
  766:  op add :compute:zy *tmp120 :compute:cy                       ...
  767:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  768:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  769:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  770:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  771:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  772:  op mul *tmp116 :compute:zy :compute:zy                       ...
  773:  op sub *tmp117 *tmp115 *tmp116                               ...
  774:  op add :compute:zx *tmp117 :compute:cx                       ...
  775:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  776:  op mul *tmp120 *tmp119 :compute:zy                           ...
  777:  op add :compute:zy *tmp120 :compute:cy                       ...
  778:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  779:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  780:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  781:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  782:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  783:  op mul *tmp116 :compute:zy :compute:zy                       ...
  784:  op sub *tmp117 *tmp115 *tmp116                               ...
  785:  op add :compute:zx *tmp117 :compute:cx                       ...
  786:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  787:  op mul *tmp120 *tmp119 :compute:zy                           ...
  788:  op add :compute:zy *tmp120 :compute:cy                       ...
  789:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  790:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  791:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  792:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  793:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  794:  op mul *tmp116 :compute:zy :compute:zy                       ...
  795:  op sub *tmp117 *tmp115 *tmp116                               ...
  796:  op add :compute:zx *tmp117 :compute:cx                       ...
  797:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  798:  op mul *tmp120 *tmp119 :compute:zy                           ...
  799:  op add :compute:zy *tmp120 :compute:cy                       ...
  800:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  801:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  802:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  803:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  804:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  805:  op mul *tmp116 :compute:zy :compute:zy                       ...
  806:  op sub *tmp117 *tmp115 *tmp116                               ...
  807:  op add :compute:zx *tmp117 :compute:cx                       ...
  808:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  809:  op mul *tmp120 *tmp119 :compute:zy                           ...
  810:  op add :compute:zy *tmp120 :compute:cy                       ...
  811:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  812:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  813:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  814:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  815:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  816:  op mul *tmp116 :compute:zy :compute:zy                       ...
  817:  op sub *tmp117 *tmp115 *tmp116                               ...
  818:  op add :compute:zx *tmp117 :compute:cx                       ...
  819:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  820:  op mul *tmp120 *tmp119 :compute:zy                           ...
  821:  op add :compute:zy *tmp120 :compute:cy                       ...
  822:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  823:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  824:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  825:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  826:  op mul *tmp115 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  827:  op mul *tmp116 :compute:zy :compute:zy                       ...
  828:  op sub *tmp117 *tmp115 *tmp116                               ...
  829:  op add :compute:zx *tmp117 :compute:cx                       ...
  830:  op mul *tmp119 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  831:  op mul *tmp120 *tmp119 :compute:zy                           ...
  832:  op add :compute:zy *tmp120 :compute:cy                       ...
  833:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  834:  jump *label88 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  835:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label88                                               ...
  836:  jump *label91 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  837:  jump *label91 greaterThanEq :compute:i 63                    ...
  838:  op log *tmp127 :compute:dist 0                               mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  839:  op mul *tmp128 *tmp127 0.36067376022224085                   ...
  840:  op log *tmp129 *tmp128 0                                     ...
  841:  op mul *tmp130 *tmp129 1.4426950408889634                    ...
  842:  op sub :compute:correction 4 *tmp130                         ...
  843:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label91                                               mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  844:  set *tmp97 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label79                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  845:  jump *label96 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH then
  846:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  847:  jump *label97 equal *tmp97 63                                mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  848:  multijump .PALETTE 0 0                                       mandelbrot-compute.mnd: case PALETTE
        multilabel *label197                                         ...
        multilabel *label193                                         ...
  849:  op div *tmp171 *tmp97 63.75                                  mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  850:  op sub :drawPixel:r 1 *tmp171                                ...
  851:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  852:  jump *label97 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label194                                         ...
  853:  op sub *tmp137 32 *tmp97                                     mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  854:  op abs *tmp138 *tmp137 0                                     ...
  855:  op div *tmp140 *tmp138 36.42857142857143                     ...
  856:  op sub :drawPixel:r 1 *tmp140                                ...
  857:  op sub *tmp142 *tmp97 32                                     mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  858:  op abs *tmp143 *tmp142 0                                     ...
  859:  op div *tmp145 *tmp143 42.5                                  ...
  860:  op sub :drawPixel:g 0.9411764705882353 *tmp145               ...
  861:  op div *tmp150 *tmp138 63.75                                 mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  862:  op add :drawPixel:b 0.47058823529411764 *tmp150              ...
  863:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  864:  jump *label97 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label195                                         ...
  865:  op div *tmp154 *tmp97 0.175                                  mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  866:  op sin :drawPixel:r *tmp154 0                                ...
  867:  op cos :drawPixel:g *tmp154 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  868:  op sub *tmp159 *tmp97 32                                     mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  869:  op abs *tmp160 *tmp159 0                                     ...
  870:  op div *tmp162 *tmp160 63.75                                 ...
  871:  op add :drawPixel:b 0.39215686274509803 *tmp162              ...
  872:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  873:  jump *label97 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label196                                         ...
  874:  op div :drawPixel:r *tmp97 63.75                             mandelbrot-compute.mnd: r = 4 * iterations / 255;
  875:  op div :drawPixel:g *tmp97 170                               mandelbrot-compute.mnd: g = 1.5 * iterations / 255;
  876:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  877:  jump *label97 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label96                                               ...
  878:  read :drawPixel:color .memory *tmp97                         mandelbrot-compute.mnd: color = memory[iterations];
        label *label97                                               mandelbrot-compute.mnd: if SMOOTH then
  879:  jump *label107 lessThan .localBuffer 254                     mandelbrot-compute.mnd: if localBuffer >= 254 then
  880:  jump *label120 lessThanEq .localBuffer 0                     mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label147                                              ...
  881:  read *tmp181 .memory 68                                      ...
  882:  jump *label112 notEqual .stop *tmp181                        ...
  883:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  884:  sensor *tmp182 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  885:  jump *label116 equal *tmp182 false                           ...
  886:  sensor *tmp183 .display @bufferSize                          ...
  887:  op sub *tmp184 1024 *tmp183                                  ...
  888:  jump *label116 greaterThanEq .localBuffer *tmp184            ...
  889:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  890:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label116                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  891:  jump *label147 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label112                                              ...
        label *label107                                              mandelbrot-compute.mnd: if localBuffer >= 254 then
  892:  jump *label120 lessThanEq .localBuffer 0                     mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  893:  jump *label120 strictNotEqual :drawPixel:color .lastColor    ...
  894:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  895:  op add .localBuffer .localBuffer 1                           mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  896:  jump *label121 always 0 0                                    ...
        label *label120                                              ...
  897:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  898:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  899:  set .lastColor :drawPixel:color                              mandelbrot-compute.mnd: lastColor = color;
  900:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
        label *label121                                              mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  901:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  902:  sensor *tmp191 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  903:  jump *label125 equal *tmp191 false                           ...
  904:  sensor *tmp192 .display @bufferSize                          ...
  905:  op sub *tmp193 1024 *tmp192                                  ...
  906:  jump *label125 greaterThanEq .localBuffer *tmp193            ...
  907:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  908:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label125                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  909:  wait 0.006                              # 0.360 ticks for at mandelbrot-compute.mnd: atomic
  910:  read *tmp197 .memory 68                                      mandelbrot-compute.mnd: if stop != $STOP then
  911:  jump *label28 notEqual .stop *tmp197                         ...
  912:  read *tmp199 .memory 66                                      mandelbrot-compute.mnd: atomic
  913:  op add *tmp2 *tmp199 1                                       ...
  914:  write *tmp2 .memory 66                                       ...
  915:  read *tmp201 .memory 65                                      mandelbrot-compute.mnd: $ITERATIONS += iterations;
  916:  op add *tmp202 *tmp201 *tmp97                                ...
  917:  write *tmp202 .memory 65                # The last atomic bl ...
  918:  op add :i :i 1                                               mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
  919:  jump *label145 lessThan :i *tmp55                            ...
        label *label45                                               ...
  920:  select :multiple greaterThanEq :batch 1337.6 1 :multiple     mandelbrot-compute.mnd: if batch >= TOTAL_BATCHES * 0.475 then multiple = 1; end;
  921:  jump *label36 always 0 0                                     mandelbrot-compute.mnd: while true do
        label *label38                                               ...
  922:  jump *label28 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label148                                              ...
  923:  read *tmp207 .memory 68                                      ...
  924:  jump *label28 notEqual .stop *tmp207                         ...
  925:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  926:  sensor *tmp208 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  927:  jump *label140 equal *tmp208 false                           ...
  928:  sensor *tmp209 .display @bufferSize                          ...
  929:  op sub *tmp210 1024 *tmp209                                  ...
  930:  jump *label140 greaterThanEq .localBuffer *tmp210            ...
  931:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  932:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label140                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  933:  jump *label148 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
  934:  jump *label28 always 0 0                                     mandelbrot-compute.mnd: MainLoop:


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   727     1x    727,0  inline def compute(in x, in y)
    59     1x     59,0  <no function>
    45     1x     45,0  void adam5(in index, out x, out y, out dx, out dy)
    44     1x     44,0  inline void drawPixel(in x, in y, in dx, in dy, in iterations)
    31     4x      7,8  inline void tryFlush()
    22     1x     22,0  inline void findLinkedBlocks(in title, in message, in linkMap...)
     8     2x      4,0  inline void flush()
Runtime error at instruction #24: 'read *tmp27 .memory 67':
Execution step limit of 100,000 exceeded.

Performance: parsed in 326 ms, compiled in 277 ms, optimized in 1,930 ms, run in 76 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Display: large-logic-display
Memory: memory-bank
