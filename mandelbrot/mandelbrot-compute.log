   455 instructions before optimizations.
    50 instructions eliminated by Temp Variables Elimination (2 passes, 8 iterations).
     2 instructions eliminated by Case Expression Optimization.
    45 instructions eliminated by Dead Code Elimination (6 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 6 iterations).
    25 instructions eliminated by Condition Optimization (2 passes, 8 iterations).
    24 instructions eliminated by Single Step Elimination (2 passes, 8 iterations).
     1 instructions eliminated by Expression Optimization (2 passes, 4 iterations).
    20 instructions eliminated by Boolean Optimization (7 iterations).
       7 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by If Expression Optimization (4 iterations).
    29 instructions eliminated by Data Flow Optimization (3 passes, 13 iterations).
     1 loops improved by Loop Hoisting.
       4 loop conditions were partially rotated.
   743 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
    12 instructions eliminated by Case Switching (7 iterations).
     2 case expressions converted to fast dispatch by Case Switching.
    69 instructions eliminated by Jump Straightening (2 passes, 8 iterations).
    10 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
   916 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 740):
  * Fast-dispatch case at mandelbrot-compute.mnd:127:5           size   -11, benefit   242187.5, efficiency   Infinity (-10 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:216:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 750):
  * Fast-dispatch case at mandelbrot-compute.mnd:216:13          size    -2, benefit     3906.3, efficiency   Infinity (-2 instructions)

Pass 2: speed optimization selection (cost limit 760):
  * Unroll loop at mandelbrot-compute.mnd:188:5                  size  +679, benefit 49218750.0, efficiency  72487.113 (+743 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
    94 op add *tmp49 *tmp48 :i
    95 set :adam5:index *tmp49
    96 op idiv *tmp51 :adam5:index 16
-    * set *tmp52 *tmp51
-    * jump *label27 lessThan *tmp52 0
-    * jump *label26 lessThan *tmp52 121
+   97 jump *label27 lessThan *tmp51 0
+   98 jump *label26 lessThan *tmp51 121
    99 label *label27
   100 jump *label25 always
   101 label *label26
 
   116 set *tmp50 :adam5:dx
   117 jump *label24 always
   118 label *label25
-    * jump *label32 lessThan *tmp52 121
-    * jump *label31 lessThan *tmp52 242
+  119 jump *label32 lessThan *tmp51 121
+  120 jump *label31 lessThan *tmp51 242
   121 label *label32
   122 jump *label30 always
   123 label *label31
 
   146 set *tmp50 :adam5:dy
   147 jump *label24 always
   148 label *label30
-    * jump *label39 lessThan *tmp52 242
-    * jump *label38 lessThan *tmp52 484
+  149 jump *label39 lessThan *tmp51 242
+  150 jump *label38 lessThan *tmp51 484
   151 label *label39
   152 jump *label37 always
   153 label *label38
 
   170 set *tmp50 :adam5:dx
   171 jump *label24 always
   172 label *label37
-    * jump *label44 lessThan *tmp52 484
-    * jump *label43 lessThan *tmp52 968
+  173 jump *label44 lessThan *tmp51 484
+  174 jump *label43 lessThan *tmp51 968
   175 label *label44
   176 jump *label42 always
   177 label *label43
 
   352 set *tmp126 :drawPixel:color
   353 jump *label76 always
   354 label *label75
-    * set *tmp128 .PALETTE
-    * jump *label79 equal *tmp128 2
+  355 jump *label79 equal .PALETTE 2
   356 jump *label78 always
   357 label *label79
   358 op sub *tmp129 32 :drawPixel:iterations
 
   378 set *tmp127 :drawPixel:color
   379 jump *label77 always
   380 label *label78
-    * jump *label81 equal *tmp128 3
+  381 jump *label81 equal .PALETTE 3
   382 jump *label80 always
   383 label *label81
   384 op div *tmp145 :drawPixel:iterations 63
 
   400 set *tmp127 :drawPixel:color
   401 jump *label77 always
   402 label *label80
-    * jump *label83 equal *tmp128 4
+  403 jump *label83 equal .PALETTE 4
   404 jump *label82 always
   405 label *label83
   406 op mul *tmp157 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-36 instructions):
 
    60 op notEqual *tmp37 .stop *tmp38
    61 jump *label14 equal *tmp37 false
    62 jump *label4 always
-    * set *tmp39 null
    63 jump *label15 always
    64 label *label14
-    * set *tmp39 null
    65 label *label15
    66 read *tmp40 .memory 64
    67 set :batch *tmp40
 
    78 op greaterThanEq *tmp44 :batch 2816
    79 jump *label18 equal *tmp44 false
    80 jump *label13 always
-    * set *tmp45 null
    81 jump *label19 always
    82 label *label18
-    * set *tmp45 null
    83 label *label19
    84 op mul *tmp46 11 :multiple
    85 set *tmp47 *tmp46
 
   109 label *label29
   110 set :adam5:dy *tmp57
   111 set :adam5:dx :adam5:dy
-    * set *tmp50 :adam5:dx
   112 jump *label24 always
   113 label *label25
   114 jump *label32 lessThan *tmp51 121
 
   138 set *tmp64 2
   139 label *label36
   140 set :adam5:dy *tmp64
-    * set *tmp50 :adam5:dy
   141 jump *label24 always
   142 label *label30
   143 jump *label39 lessThan *tmp51 242
 
   161 label *label41
   162 set :adam5:dy *tmp70
   163 set :adam5:dx :adam5:dy
-    * set *tmp50 :adam5:dx
   164 jump *label24 always
   165 label *label37
   166 jump *label44 lessThan *tmp51 484
 
   184 set *tmp76 1
   185 label *label46
   186 set :adam5:dy *tmp76
-    * set *tmp50 :adam5:dy
   187 jump *label24 always
   188 label *label42
   189 op sub :adam5:index :adam5:index 15488
 
   195 set :adam5:y *tmp80
   196 set :adam5:dy 1
   197 set :adam5:dx :adam5:dy
-    * set *tmp50 :adam5:dx
   198 label *label24
   199 label *label23
   200 set :x :adam5:x
 
   224 label *label54
   225 drawflush .display
   226 set .localBuffer 0
-    * set *tmp88 .localBuffer
   227 jump *label53 always
   228 label *label52
-    * set *tmp88 null
   229 label *label53
   230 label *label51
-    * set *tmp83 null
   231 jump *label48 always
   232 label *label47
-    * set *tmp83 null
   233 label *label48
   234 set :compute:x :x
   235 set :compute:y :y
 
   242 jump *label57 equal .JULIA false
   243 set :compute:cx .JULIA_X
   244 set :compute:cy .JULIA_Y
-    * set *tmp94 :compute:cy
   245 jump *label58 always
   246 label *label57
   247 set :compute:cx :compute:zx
 
   257 jump *label59 equal *tmp101 false
   258 set *tmp89 63
   259 jump *label56 always
-    * set *tmp102 null
   260 jump *label60 always
   261 label *label59
-    * set *tmp102 null
   262 label *label60
   263 op add *tmp103 :compute:cx 1
   264 op len *tmp104 *tmp103 :compute:cy
 
   271 label *label61
   272 set *tmp106 null
   273 label *label62
-    * set *tmp94 *tmp106
   274 label *label58
   275 set :compute:i 0
   276 label *label63
 
   291 op greaterThanEq *tmp115 :compute:dist 64
   292 jump *label66 equal *tmp115 false
   293 jump *label65 always
-    * set *tmp116 null
   294 jump *label67 always
   295 label *label66
-    * set *tmp116 null
   296 label *label67
   297 label *label64
   298 op add :compute:i :compute:i 1
 
   311 op sub *tmp123 4 *tmp122
   312 set :compute:correction *tmp123
   313 op add :compute:i :compute:i :compute:correction
-    * set *tmp118 :compute:i
   314 jump *label69 always
   315 label *label68
-    * set *tmp118 null
   316 label *label69
   317 set *tmp89 :compute:i
   318 jump *label56 always
 
   403 label *label77
   404 set *tmp126 *tmp127
   405 label *label76
-    * set *tmp124 *tmp126
   406 jump *label74 always
   407 label *label73
   408 set *tmp166 :drawPixel:iterations
   409 read *tmp168 .memory *tmp166
   410 set :drawPixel:color *tmp168
-    * set *tmp124 :drawPixel:color
   411 label *label74
   412 op greaterThanEq *tmp169 .localBuffer 254
   413 jump *label84 equal *tmp169 false
 
   432 label *label95
   433 drawflush .display
   434 set .localBuffer 0
-    * set *tmp178 .localBuffer
   435 jump *label94 always
   436 label *label93
-    * set *tmp178 null
   437 label *label94
   438 label *label92
   439 label *label88
   440 jump *label87 always
   441 label *label89
   442 label *label86
-    * set *tmp170 null
   443 jump *label85 always
   444 label *label84
-    * set *tmp170 null
   445 label *label85
   446 op greaterThan *tmp179 .localBuffer 0
   447 jump *label97 equal *tmp179 false
 
   453 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   454 set *tmp182 .localBuffer
   455 op add .localBuffer .localBuffer 1
-    * set *tmp181 *tmp182
   456 jump *label98 always
   457 label *label97
   458 draw col :drawPixel:color
   459 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   460 set .lastColor :drawPixel:color
   461 op add .localBuffer .localBuffer 2
-    * set *tmp181 .localBuffer
   462 label *label98
   463 wait 0
   464 sensor *tmp183 .display @enabled
 
   472 label *label104
   473 drawflush .display
   474 set .localBuffer 0
-    * set *tmp187 .localBuffer
   475 jump *label103 always
   476 label *label102
-    * set *tmp187 null
   477 label *label103
   478 label *label101
   479 label *label72
 
   482 op notEqual *tmp188 .stop *tmp189
   483 jump *label106 equal *tmp188 false
   484 jump *label4 always
-    * set *tmp190 null
   485 jump *label107 always
   486 label *label106
-    * set *tmp190 null
   487 label *label107
   488 read *tmp191 .memory 66
-    * set *tmp192 *tmp191
   489 op add *tmp2 *tmp191 1
   490 write *tmp2 .memory 66
   491 read *tmp193 .memory 65
 
   519 label *label117
   520 drawflush .display
   521 set .localBuffer 0
-    * set *tmp202 .localBuffer
   522 jump *label116 always
   523 label *label115
-    * set *tmp202 null
   524 label *label116
   525 label *label114
   526 label *label110

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
   266 jump *label61 equal *tmp105 false
   267 set *tmp89 63
   268 jump *label56 always
-    * set *tmp106 null
   269 jump *label62 always
   270 label *label61
-    * set *tmp106 null
   271 label *label62
   272 label *label58
   273 set :compute:i 0
 
   326 op equal *tmp125 :drawPixel:iterations 63
   327 jump *label75 equal *tmp125 false
   328 set :drawPixel:color %[black]
-    * set *tmp126 :drawPixel:color
   329 jump *label76 always
   330 label *label75
   331 jump *label79 equal .PALETTE 2
 
   398 set :drawPixel:color *tmp165
   399 set *tmp127 :drawPixel:color
   400 label *label77
-    * set *tmp126 *tmp127
   401 label *label76
   402 jump *label74 always
   403 label *label73
 
   447 jump *label99 always
   448 label *label99
   449 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
-    * set *tmp182 .localBuffer
   450 op add .localBuffer .localBuffer 1
   451 jump *label98 always
   452 label *label97

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   351 set :drawPixel:b *tmp143
   352 packcolor *tmp144 :drawPixel:r :drawPixel:g :drawPixel:b 1
   353 set :drawPixel:color *tmp144
-    * set *tmp127 :drawPixel:color
   354 jump *label77 always
   355 label *label78
   356 jump *label81 equal .PALETTE 3
 
   372 set :drawPixel:b *tmp155
   373 packcolor *tmp156 :drawPixel:r :drawPixel:g :drawPixel:b 1
   374 set :drawPixel:color *tmp156
-    * set *tmp127 :drawPixel:color
   375 jump *label77 always
   376 label *label80
   377 jump *label83 equal .PALETTE 4
 
   385 set :drawPixel:g *tmp160
   386 packcolor *tmp161 :drawPixel:r :drawPixel:g 0 1
   387 set :drawPixel:color *tmp161
-    * set *tmp127 :drawPixel:color
   388 jump *label77 always
   389 label *label82
   390 op mul *tmp162 4 :drawPixel:iterations
 
   393 set :drawPixel:r *tmp164
   394 packcolor *tmp165 :drawPixel:r :drawPixel:r 0 1
   395 set :drawPixel:color *tmp165
-    * set *tmp127 :drawPixel:color
   396 label *label77
   397 label *label76
   398 jump *label74 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-47 instructions):
 
    14 op equal *tmp17 .start *tmp18
    15 jump *label6 notEqual *tmp17 false
    16 label *label8
-    * read *tmp19 .memory 67
-    * set .start *tmp19
-    * read *tmp20 .memory 68
-    * set .stop *tmp20
+   17 read .start .memory 67
+   18 read .stop .memory 68
    19 set .lastColor -1
    20 set .localBuffer 0
    21 drawflush null
    22 drawflush .display
-    * read *tmp21 .memory 71
-    * set .ZOOM *tmp21
+   23 read .ZOOM .memory 71
    24 op div *tmp22 -88 .ZOOM
    25 read *tmp24 .memory 69
-    * op add *tmp23 *tmp22 *tmp24
-    * set .OFFSET_X *tmp23
+   26 op add .OFFSET_X *tmp22 *tmp24
    27 op div *tmp25 -88 .ZOOM
    28 read *tmp27 .memory 70
-    * op add *tmp26 *tmp25 *tmp27
-    * set .OFFSET_Y *tmp26
-    * read *tmp28 .memory 72
-    * set .JULIA *tmp28
-    * read *tmp29 .memory 73
-    * set .JULIA_X *tmp29
-    * read *tmp30 .memory 74
-    * set .JULIA_Y *tmp30
-    * read *tmp31 .memory 75
-    * set .PALETTE *tmp31
-    * op greaterThan *tmp32 .PALETTE 1
-    * set .SMOOTH *tmp32
-    * read *tmp33 .memory 76
-    * set .ALL_PASS_COLORING *tmp33
+   29 op add .OFFSET_Y *tmp25 *tmp27
+   30 read .JULIA .memory 72
+   31 read .JULIA_X .memory 73
+   32 read .JULIA_Y .memory 74
+   33 read .PALETTE .memory 75
+   34 op greaterThan .SMOOTH .PALETTE 1
+   35 read .ALL_PASS_COLORING .memory 76
    36 read *tmp34 .memory 77
    37 jump *label9 equal *tmp34 false
-    * op sub *tmp36 1 .ALL_PASS_COLORING
-    * set *tmp35 *tmp36
+   38 op sub *tmp35 1 .ALL_PASS_COLORING
    39 jump *label10 always
    40 label *label9
    41 set *tmp35 99
 
    51 jump *label15 always
    52 label *label14
    53 label *label15
-    * read *tmp40 .memory 64
-    * set :batch *tmp40
+   54 read :batch .memory 64
    55 op greaterThanEq *tmp41 :batch 1408
    56 jump *label16 equal *tmp41 false
    57 set *tmp42 1
 
    68 jump *label19 always
    69 label *label18
    70 label *label19
-    * op mul *tmp46 11 :multiple
-    * set *tmp47 *tmp46
+   71 op mul *tmp47 11 :multiple
    72 set :i 0
    73 label *label20
    74 jump *label22 greaterThanEq :i *tmp47
    75 op mul *tmp48 :batch 11
-    * op add *tmp49 *tmp48 :i
-    * set :adam5:index *tmp49
+   76 op add :adam5:index *tmp48 :i
    77 op idiv *tmp51 :adam5:index 16
    78 jump *label27 lessThan *tmp51 0
    79 jump *label26 lessThan *tmp51 121
 
    81 jump *label25 always
    82 label *label26
    83 op mod *tmp53 :adam5:index 44
-    * op mul *tmp54 4 *tmp53
-    * set :adam5:x *tmp54
+   84 op mul :adam5:x 4 *tmp53
    85 op idiv *tmp55 :adam5:index 44
-    * op mul *tmp56 4 *tmp55
-    * set :adam5:y *tmp56
+   86 op mul :adam5:y 4 *tmp55
    87 jump *label28 equal .ALL_PASS_COLORING false
    88 set *tmp57 4
    89 jump *label29 always
 
   102 op sub :adam5:index :adam5:index 1936
   103 op mod *tmp58 :adam5:index 44
   104 op mul *tmp59 4 *tmp58
-    * op add *tmp60 *tmp59 2
-    * set :adam5:x *tmp60
+  105 op add :adam5:x *tmp59 2
   106 op idiv *tmp61 :adam5:index 44
-    * op mul *tmp62 4 *tmp61
-    * set :adam5:y *tmp62
+  107 op mul :adam5:y 4 *tmp61
   108 jump *label33 equal .ALL_PASS_COLORING false
   109 set *tmp63 2
   110 jump *label34 always
 
   128 label *label38
   129 op sub :adam5:index :adam5:index 3872
   130 op mod *tmp65 :adam5:index 88
-    * op mul *tmp66 2 *tmp65
-    * set :adam5:x *tmp66
+  131 op mul :adam5:x 2 *tmp65
   132 op idiv *tmp67 :adam5:index 88
   133 op mul *tmp68 4 *tmp67
-    * op add *tmp69 *tmp68 2
-    * set :adam5:y *tmp69
+  134 op add :adam5:y *tmp68 2
   135 jump *label40 equal .ALL_PASS_COLORING false
   136 set *tmp70 2
   137 jump *label41 always
 
   150 op sub :adam5:index :adam5:index 7744
   151 op mod *tmp71 :adam5:index 88
   152 op mul *tmp72 2 *tmp71
-    * op add *tmp73 *tmp72 1
-    * set :adam5:x *tmp73
+  153 op add :adam5:x *tmp72 1
   154 op idiv *tmp74 :adam5:index 88
-    * op mul *tmp75 2 *tmp74
-    * set :adam5:y *tmp75
+  155 op mul :adam5:y 2 *tmp74
   156 set :adam5:dx 1
   157 jump *label45 equal .ALL_PASS_COLORING false
   158 set *tmp76 2
 
   164 jump *label24 always
   165 label *label42
   166 op sub :adam5:index :adam5:index 15488
-    * op mod *tmp77 :adam5:index 176
-    * set :adam5:x *tmp77
+  167 op mod :adam5:x :adam5:index 176
   168 op idiv *tmp78 :adam5:index 176
   169 op mul *tmp79 2 *tmp78
-    * op add *tmp80 *tmp79 1
-    * set :adam5:y *tmp80
+  170 op add :adam5:y *tmp79 1
   171 set :adam5:dy 1
   172 set :adam5:dx :adam5:dy
   173 label *label24
 
   209 set :compute:x :x
   210 set :compute:y :y
   211 op div *tmp90 :compute:x .ZOOM
-    * op add *tmp91 *tmp90 .OFFSET_X
-    * set :compute:zx *tmp91
+  212 op add :compute:zx *tmp90 .OFFSET_X
   213 op div *tmp92 :compute:y .ZOOM
-    * op add *tmp93 *tmp92 .OFFSET_Y
-    * set :compute:zy *tmp93
+  214 op add :compute:zy *tmp92 .OFFSET_Y
   215 jump *label57 equal .JULIA false
   216 set :compute:cx .JULIA_X
   217 set :compute:cy .JULIA_Y
 
   220 set :compute:cx :compute:zx
   221 set :compute:cy :compute:zy
   222 op sub *tmp95 :compute:cx 0.25
-    * op len *tmp96 *tmp95 :compute:cy
-    * set :compute:p *tmp96
+  223 op len :compute:p *tmp95 :compute:cy
   224 op mul *tmp97 2 :compute:p
   225 op mul *tmp98 *tmp97 :compute:p
   226 op sub *tmp99 :compute:p *tmp98
 
   250 op mul *tmp107 :compute:x1 :compute:x1
   251 op mul *tmp108 :compute:y1 :compute:y1
   252 op sub *tmp109 *tmp107 *tmp108
-    * op add *tmp110 *tmp109 :compute:cx
-    * set :compute:zx *tmp110
+  253 op add :compute:zx *tmp109 :compute:cx
   254 op mul *tmp111 2 :compute:x1
   255 op mul *tmp112 *tmp111 :compute:y1
-    * op add *tmp113 *tmp112 :compute:cy
-    * set :compute:zy *tmp113
-    * op len *tmp114 :compute:zx :compute:zy
-    * set :compute:dist *tmp114
+  256 op add :compute:zy *tmp112 :compute:cy
+  257 op len :compute:dist :compute:zx :compute:zy
   258 op greaterThanEq *tmp115 :compute:dist 64
   259 jump *label66 equal *tmp115 false
   260 jump *label65 always
 
   275 op mul *tmp120 *tmp119 0.36067376022224085
   276 op log *tmp121 *tmp120
   277 op mul *tmp122 *tmp121 1.4426950408889634
-    * op sub *tmp123 4 *tmp122
-    * set :compute:correction *tmp123
+  278 op sub :compute:correction 4 *tmp122
   279 op add :compute:i :compute:i :compute:correction
   280 jump *label69 always
   281 label *label68
 
   303 op abs *tmp130 *tmp129
   304 op mul *tmp131 7 *tmp130
   305 op div *tmp132 *tmp131 255
-    * op sub *tmp133 1 *tmp132
-    * set :drawPixel:r *tmp133
+  306 op sub :drawPixel:r 1 *tmp132
   307 op sub *tmp134 :drawPixel:iterations 32
   308 op abs *tmp135 *tmp134
   309 op mul *tmp136 6 *tmp135
   310 op div *tmp137 *tmp136 255
-    * op sub *tmp138 0.9411764705882353 *tmp137
-    * set :drawPixel:g *tmp138
+  311 op sub :drawPixel:g 0.9411764705882353 *tmp137
   312 op sub *tmp139 32 :drawPixel:iterations
   313 op abs *tmp140 *tmp139
   314 op mul *tmp141 4 *tmp140
   315 op div *tmp142 *tmp141 255
-    * op add *tmp143 0.47058823529411764 *tmp142
-    * set :drawPixel:b *tmp143
-    * packcolor *tmp144 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp144
+  316 op add :drawPixel:b 0.47058823529411764 *tmp142
+  317 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   318 jump *label77 always
   319 label *label78
   320 jump *label81 equal .PALETTE 3
 
   322 label *label81
   323 op div *tmp145 :drawPixel:iterations 63
   324 op mul *tmp146 *tmp145 360
-    * op sin *tmp147 *tmp146
-    * set :drawPixel:r *tmp147
+  325 op sin :drawPixel:r *tmp146
   326 op div *tmp148 :drawPixel:iterations 63
   327 op mul *tmp149 *tmp148 360
-    * op cos *tmp150 *tmp149
-    * set :drawPixel:g *tmp150
+  328 op cos :drawPixel:g *tmp149
   329 op sub *tmp151 :drawPixel:iterations 32
   330 op abs *tmp152 *tmp151
   331 op mul *tmp153 4 *tmp152
   332 op div *tmp154 *tmp153 255
-    * op add *tmp155 0.39215686274509803 *tmp154
-    * set :drawPixel:b *tmp155
-    * packcolor *tmp156 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp156
+  333 op add :drawPixel:b 0.39215686274509803 *tmp154
+  334 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   335 jump *label77 always
   336 label *label80
   337 jump *label83 equal .PALETTE 4
   338 jump *label82 always
   339 label *label83
   340 op mul *tmp157 4 :drawPixel:iterations
-    * op div *tmp158 *tmp157 255
-    * set :drawPixel:r *tmp158
+  341 op div :drawPixel:r *tmp157 255
   342 op mul *tmp159 1.5 :drawPixel:iterations
-    * op div *tmp160 *tmp159 255
-    * set :drawPixel:g *tmp160
-    * packcolor *tmp161 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp161
+  343 op div :drawPixel:g *tmp159 255
+  344 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   345 jump *label77 always
   346 label *label82
   347 op mul *tmp162 4 :drawPixel:iterations
   348 op div *tmp163 *tmp162 255
-    * op sub *tmp164 1 *tmp163
-    * set :drawPixel:r *tmp164
-    * packcolor *tmp165 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp165
+  349 op sub :drawPixel:r 1 *tmp163
+  350 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   351 label *label77
   352 label *label76
   353 jump *label74 always
   354 label *label73
-    * set *tmp166 :drawPixel:iterations
-    * read *tmp168 .memory *tmp166
-    * set :drawPixel:color *tmp168
+  355 read :drawPixel:color .memory :drawPixel:iterations
   356 label *label74
   357 op greaterThanEq *tmp169 .localBuffer 254
   358 jump *label84 equal *tmp169 false

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
     6 jump *label0 notEqual *tmp16 false
     7 label *label2
     8 label *label3
-    * jump *label5 equal true false
     9 label *label6
    10 wait 0
    11 label *label7
 
    41 label *label10
    42 set :leaderLimit *tmp35
    43 label *label11
-    * jump *label13 equal true false
    44 wait 0
    45 read *tmp38 .memory 68
    46 op notEqual *tmp37 .stop *tmp38

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   294 set :drawPixel:color %[black]
   295 jump *label76 always
   296 label *label75
-    * jump *label79 equal .PALETTE 2
-    * jump *label78 always
+  297 jump *label78 notEqual .PALETTE 2
   298 label *label79
   299 op sub *tmp129 32 :drawPixel:iterations
   300 op abs *tmp130 *tmp129
 
   314 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   315 jump *label77 always
   316 label *label78
-    * jump *label81 equal .PALETTE 3
-    * jump *label80 always
+  317 jump *label80 notEqual .PALETTE 3
   318 label *label81
   319 op div *tmp145 :drawPixel:iterations 63
   320 op mul *tmp146 *tmp145 360
 
   330 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   331 jump *label77 always
   332 label *label80
-    * jump *label83 equal .PALETTE 4
-    * jump *label82 always
+  333 jump *label82 notEqual .PALETTE 4
   334 label *label83
   335 op mul *tmp157 4 :drawPixel:iterations
   336 op div :drawPixel:r *tmp157 255

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-23 instructions):
 
    10 wait 0
    11 label *label7
    12 read *tmp18 .memory 67
-    * op equal *tmp17 .start *tmp18
-    * jump *label6 notEqual *tmp17 false
+   13 jump *label6 equal .start *tmp18
    14 label *label8
    15 read .start .memory 67
    16 read .stop .memory 68
 
    42 label *label11
    43 wait 0
    44 read *tmp38 .memory 68
-    * op notEqual *tmp37 .stop *tmp38
-    * jump *label14 equal *tmp37 false
+   45 jump *label14 equal .stop *tmp38
    46 jump *label4 always
    47 jump *label15 always
    48 label *label14
    49 label *label15
    50 read :batch .memory 64
-    * op greaterThanEq *tmp41 :batch 1408
-    * jump *label16 equal *tmp41 false
+   51 jump *label16 lessThan :batch 1408
    52 set *tmp42 1
    53 jump *label17 always
    54 label *label16
 
    57 set :multiple *tmp42
    58 op add *tmp43 :batch :multiple
    59 write *tmp43 .memory 64
-    * op greaterThanEq *tmp44 :batch 2816
-    * jump *label18 equal *tmp44 false
+   60 jump *label18 lessThan :batch 2816
    61 jump *label13 always
    62 jump *label19 always
    63 label *label18
 
   170 set :y :adam5:y
   171 set :dx :adam5:dx
   172 set :dy :adam5:dy
-    * op greaterThan *tmp81 :multiple :leaderLimit
-    * jump *label47 equal *tmp81 false
+  173 jump *label47 lessThanEq :multiple :leaderLimit
   174 label *label50
-    * op equal *tmp82 .localBuffer 0
-    * jump *label47 equal *tmp82 false
+  175 jump *label47 notEqual .localBuffer 0
   176 jump *label49 always
   177 label *label49
   178 draw col %[white]
 
   185 label *label55
   186 sensor *tmp85 .display @bufferSize
   187 op sub *tmp86 1024 *tmp85
-    * op lessThan *tmp87 .localBuffer *tmp86
-    * jump *label52 equal *tmp87 false
+  188 jump *label52 greaterThanEq .localBuffer *tmp86
   189 jump *label54 always
   190 label *label54
   191 drawflush .display
 
   216 op mul *tmp98 *tmp97 :compute:p
   217 op sub *tmp99 :compute:p *tmp98
   218 op add *tmp100 *tmp99 0.25
-    * op lessThanEq *tmp101 :compute:cx *tmp100
-    * jump *label59 equal *tmp101 false
+  219 jump *label59 greaterThan :compute:cx *tmp100
   220 set *tmp89 63
   221 jump *label56 always
   222 jump *label60 always
 
   224 label *label60
   225 op add *tmp103 :compute:cx 1
   226 op len *tmp104 *tmp103 :compute:cy
-    * op lessThanEq *tmp105 *tmp104 0.25
-    * jump *label61 equal *tmp105 false
+  227 jump *label61 greaterThan *tmp104 0.25
   228 set *tmp89 63
   229 jump *label56 always
   230 jump *label62 always
 
   244 op mul *tmp112 *tmp111 :compute:y1
   245 op add :compute:zy *tmp112 :compute:cy
   246 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp115 :compute:dist 64
-    * jump *label66 equal *tmp115 false
+  247 jump *label66 lessThan :compute:dist 64
   248 jump *label65 always
   249 jump *label67 always
   250 label *label66
 
   255 label *label65
   256 jump *label68 equal .SMOOTH false
   257 label *label71
-    * op lessThan *tmp117 :compute:i 63
-    * jump *label68 equal *tmp117 false
+  258 jump *label68 greaterThanEq :compute:i 63
   259 jump *label70 always
   260 label *label70
   261 op log *tmp119 :compute:dist
 
   278 set :drawPixel:dy :dy
   279 set :drawPixel:iterations :iterations
   280 jump *label73 equal .SMOOTH false
-    * op equal *tmp125 :drawPixel:iterations 63
-    * jump *label75 equal *tmp125 false
+  281 jump *label75 notEqual :drawPixel:iterations 63
   282 set :drawPixel:color %[black]
   283 jump *label76 always
   284 label *label75
 
   337 label *label73
   338 read :drawPixel:color .memory :drawPixel:iterations
   339 label *label74
-    * op greaterThanEq *tmp169 .localBuffer 254
-    * jump *label84 equal *tmp169 false
+  340 jump *label84 lessThan .localBuffer 254
   341 label *label87
-    * op greaterThan *tmp171 .localBuffer 0
-    * jump *label89 equal *tmp171 false
+  342 jump *label89 lessThanEq .localBuffer 0
   343 label *label91
   344 read *tmp173 .memory 68
-    * op equal *tmp172 .stop *tmp173
-    * jump *label89 equal *tmp172 false
+  345 jump *label89 notEqual .stop *tmp173
   346 jump *label90 always
   347 label *label90
   348 wait 0
 
   351 label *label96
   352 sensor *tmp175 .display @bufferSize
   353 op sub *tmp176 1024 *tmp175
-    * op lessThan *tmp177 .localBuffer *tmp176
-    * jump *label93 equal *tmp177 false
+  354 jump *label93 greaterThanEq .localBuffer *tmp176
   355 jump *label95 always
   356 label *label95
   357 drawflush .display
 
   367 jump *label85 always
   368 label *label84
   369 label *label85
-    * op greaterThan *tmp179 .localBuffer 0
-    * jump *label97 equal *tmp179 false
+  370 jump *label97 lessThanEq .localBuffer 0
   371 label *label100
-    * op strictEqual *tmp180 :drawPixel:color .lastColor
-    * jump *label97 equal *tmp180 false
+  372 jump *label97 strictNotEqual :drawPixel:color .lastColor
   373 jump *label99 always
   374 label *label99
   375 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
 
   387 label *label105
   388 sensor *tmp184 .display @bufferSize
   389 op sub *tmp185 1024 *tmp184
-    * op lessThan *tmp186 .localBuffer *tmp185
-    * jump *label102 equal *tmp186 false
+  390 jump *label102 greaterThanEq .localBuffer *tmp185
   391 jump *label104 always
   392 label *label104
   393 drawflush .display
 
   399 label *label72
   400 wait 0
   401 read *tmp189 .memory 68
-    * op notEqual *tmp188 .stop *tmp189
-    * jump *label106 equal *tmp188 false
+  402 jump *label106 equal .stop *tmp189
   403 jump *label4 always
   404 jump *label107 always
   405 label *label106
 
   418 jump *label11 always
   419 label *label13
   420 label *label109
-    * op greaterThan *tmp195 .localBuffer 0
-    * jump *label111 equal *tmp195 false
+  421 jump *label111 lessThanEq .localBuffer 0
   422 label *label113
   423 read *tmp197 .memory 68
-    * op equal *tmp196 .stop *tmp197
-    * jump *label111 equal *tmp196 false
+  424 jump *label111 notEqual .stop *tmp197
   425 jump *label112 always
   426 label *label112
   427 wait 0
 
   430 label *label118
   431 sensor *tmp199 .display @bufferSize
   432 op sub *tmp200 1024 *tmp199
-    * op lessThan *tmp201 .localBuffer *tmp200
-    * jump *label115 equal *tmp201 false
+  433 jump *label115 greaterThanEq .localBuffer *tmp200
   434 jump *label117 always
   435 label *label117
   436 drawflush .display

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-22 instructions):
 
    44 read *tmp38 .memory 68
    45 jump *label14 equal .stop *tmp38
    46 jump *label4 always
-    * jump *label15 always
    47 label *label14
    48 label *label15
    49 read :batch .memory 64
 
    58 write *tmp43 .memory 64
    59 jump *label18 lessThan :batch 2816
    60 jump *label13 always
-    * jump *label19 always
    61 label *label18
    62 label *label19
    63 op mul *tmp47 11 :multiple
 
   171 jump *label47 lessThanEq :multiple :leaderLimit
   172 label *label50
   173 jump *label47 notEqual .localBuffer 0
-    * jump *label49 always
   174 label *label49
   175 draw col %[white]
   176 draw rect :x :y :dx :dx
 
   183 sensor *tmp85 .display @bufferSize
   184 op sub *tmp86 1024 *tmp85
   185 jump *label52 greaterThanEq .localBuffer *tmp86
-    * jump *label54 always
   186 label *label54
   187 drawflush .display
   188 set .localBuffer 0
-    * jump *label53 always
   189 label *label52
   190 label *label53
   191 label *label51
-    * jump *label48 always
   192 label *label47
   193 label *label48
   194 set :compute:x :x
 
   213 jump *label59 greaterThan :compute:cx *tmp100
   214 set *tmp89 63
   215 jump *label56 always
-    * jump *label60 always
   216 label *label59
   217 label *label60
   218 op add *tmp103 :compute:cx 1
 
   220 jump *label61 greaterThan *tmp104 0.25
   221 set *tmp89 63
   222 jump *label56 always
-    * jump *label62 always
   223 label *label61
   224 label *label62
   225 label *label58
 
   238 op len :compute:dist :compute:zx :compute:zy
   239 jump *label66 lessThan :compute:dist 64
   240 jump *label65 always
-    * jump *label67 always
   241 label *label66
   242 label *label67
   243 label *label64
 
   247 jump *label68 equal .SMOOTH false
   248 label *label71
   249 jump *label68 greaterThanEq :compute:i 63
-    * jump *label70 always
   250 label *label70
   251 op log *tmp119 :compute:dist
   252 op mul *tmp120 *tmp119 0.36067376022224085
 
   254 op mul *tmp122 *tmp121 1.4426950408889634
   255 op sub :compute:correction 4 *tmp122
   256 op add :compute:i :compute:i :compute:correction
-    * jump *label69 always
   257 label *label68
   258 label *label69
   259 set *tmp89 :compute:i
 
   332 label *label91
   333 read *tmp173 .memory 68
   334 jump *label89 notEqual .stop *tmp173
-    * jump *label90 always
   335 label *label90
   336 wait 0
   337 sensor *tmp174 .display @enabled
 
   340 sensor *tmp175 .display @bufferSize
   341 op sub *tmp176 1024 *tmp175
   342 jump *label93 greaterThanEq .localBuffer *tmp176
-    * jump *label95 always
   343 label *label95
   344 drawflush .display
   345 set .localBuffer 0
-    * jump *label94 always
   346 label *label93
   347 label *label94
   348 label *label92
 
   350 jump *label87 always
   351 label *label89
   352 label *label86
-    * jump *label85 always
   353 label *label84
   354 label *label85
   355 jump *label97 lessThanEq .localBuffer 0
   356 label *label100
   357 jump *label97 strictNotEqual :drawPixel:color .lastColor
-    * jump *label99 always
   358 label *label99
   359 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   360 op add .localBuffer .localBuffer 1
 
   372 sensor *tmp184 .display @bufferSize
   373 op sub *tmp185 1024 *tmp184
   374 jump *label102 greaterThanEq .localBuffer *tmp185
-    * jump *label104 always
   375 label *label104
   376 drawflush .display
   377 set .localBuffer 0
-    * jump *label103 always
   378 label *label102
   379 label *label103
   380 label *label101
 
   383 read *tmp189 .memory 68
   384 jump *label106 equal .stop *tmp189
   385 jump *label4 always
-    * jump *label107 always
   386 label *label106
   387 label *label107
   388 read *tmp191 .memory 66
 
   403 label *label113
   404 read *tmp197 .memory 68
   405 jump *label111 notEqual .stop *tmp197
-    * jump *label112 always
   406 label *label112
   407 wait 0
   408 sensor *tmp198 .display @enabled
 
   411 sensor *tmp199 .display @bufferSize
   412 op sub *tmp200 1024 *tmp199
   413 jump *label115 greaterThanEq .localBuffer *tmp200
-    * jump *label117 always
   414 label *label117
   415 drawflush .display
   416 set .localBuffer 0
-    * jump *label116 always
   417 label *label115
   418 label *label116
   419 label *label114

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
     2 label *label1
     3 op equal *tmp14 .display null
     4 op equal *tmp15 .memory null
-    * op lor *tmp16 *tmp14 *tmp15
+    5 op or *tmp16 *tmp14 *tmp15
     6 jump *label0 notEqual *tmp16 false
     7 label *label2
     8 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    24 op add .OFFSET_X *tmp22 *tmp24
    25 op div *tmp25 -88 .ZOOM
    26 read *tmp27 .memory 70
-    * op add .OFFSET_Y *tmp25 *tmp27
+   27 op add .OFFSET_Y *tmp22 *tmp27
    28 read .JULIA .memory 72
    29 read .JULIA_X .memory 73
    30 read .JULIA_Y .memory 74
 
    54 set *tmp42 4
    55 label *label17
    56 set :multiple *tmp42
-    * op add *tmp43 :batch :multiple
+   57 op add *tmp43 :batch *tmp42
    58 write *tmp43 .memory 64
    59 jump *label18 lessThan :batch 2816
    60 jump *label13 always
    61 label *label18
    62 label *label19
-    * op mul *tmp47 11 :multiple
+   63 op mul *tmp47 11 *tmp42
    64 set :i 0
    65 label *label20
    66 jump *label22 greaterThanEq :i *tmp47
 
    83 set *tmp57 2
    84 label *label29
    85 set :adam5:dy *tmp57
-    * set :adam5:dx :adam5:dy
+   86 set :adam5:dx *tmp57
    87 jump *label24 always
    88 label *label25
    89 jump *label32 lessThan *tmp51 121
 
   131 set *tmp70 1
   132 label *label41
   133 set :adam5:dy *tmp70
-    * set :adam5:dx :adam5:dy
+  134 set :adam5:dx *tmp70
   135 jump *label24 always
   136 label *label37
   137 jump *label44 lessThan *tmp51 484
 
   161 op mul *tmp79 2 *tmp78
   162 op add :adam5:y *tmp79 1
   163 set :adam5:dy 1
-    * set :adam5:dx :adam5:dy
+  164 set :adam5:dx 1
   165 label *label24
   166 label *label23
   167 set :x :adam5:x
   168 set :y :adam5:y
   169 set :dx :adam5:dx
   170 set :dy :adam5:dy
-    * jump *label47 lessThanEq :multiple :leaderLimit
+  171 jump *label47 lessThanEq *tmp42 *tmp35
   172 label *label50
   173 jump *label47 notEqual .localBuffer 0
   174 label *label49
   175 draw col %[white]
-    * draw rect :x :y :dx :dx
+  176 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx
   177 set .lastColor %[white]
   178 set .localBuffer 2
   179 wait 0
 
   182 label *label55
   183 sensor *tmp85 .display @bufferSize
   184 op sub *tmp86 1024 *tmp85
-    * jump *label52 greaterThanEq .localBuffer *tmp86
+  185 jump *label52 greaterThanEq 2 *tmp86
   186 label *label54
   187 drawflush .display
   188 set .localBuffer 0
 
   191 label *label51
   192 label *label47
   193 label *label48
-    * set :compute:x :x
-    * set :compute:y :y
-    * op div *tmp90 :compute:x .ZOOM
+  194 set :compute:x :adam5:x
+  195 set :compute:y :adam5:y
+  196 op div *tmp90 :x .ZOOM
   197 op add :compute:zx *tmp90 .OFFSET_X
-    * op div *tmp92 :compute:y .ZOOM
+  198 op div *tmp92 :y .ZOOM
   199 op add :compute:zy *tmp92 .OFFSET_Y
   200 jump *label57 equal .JULIA false
   201 set :compute:cx .JULIA_X
 
   204 label *label57
   205 set :compute:cx :compute:zx
   206 set :compute:cy :compute:zy
-    * op sub *tmp95 :compute:cx 0.25
-    * op len :compute:p *tmp95 :compute:cy
+  207 op sub *tmp95 :compute:zx 0.25
+  208 op len :compute:p *tmp95 :compute:zy
   209 op mul *tmp97 2 :compute:p
   210 op mul *tmp98 *tmp97 :compute:p
   211 op sub *tmp99 :compute:p *tmp98
   212 op add *tmp100 *tmp99 0.25
-    * jump *label59 greaterThan :compute:cx *tmp100
+  213 jump *label59 greaterThan :compute:zx *tmp100
   214 set *tmp89 63
   215 jump *label56 always
   216 label *label59
   217 label *label60
-    * op add *tmp103 :compute:cx 1
-    * op len *tmp104 *tmp103 :compute:cy
+  218 op add *tmp103 :compute:zx 1
+  219 op len *tmp104 *tmp103 :compute:zy
   220 jump *label61 greaterThan *tmp104 0.25
   221 set *tmp89 63
   222 jump *label56 always
 
   228 jump *label65 greaterThanEq :compute:i 63
   229 set :compute:x1 :compute:zx
   230 set :compute:y1 :compute:zy
-    * op mul *tmp107 :compute:x1 :compute:x1
-    * op mul *tmp108 :compute:y1 :compute:y1
+  231 op mul *tmp107 :compute:zx :compute:zx
+  232 op mul *tmp108 :compute:zy :compute:zy
   233 op sub *tmp109 *tmp107 *tmp108
   234 op add :compute:zx *tmp109 :compute:cx
   235 op mul *tmp111 2 :compute:x1
-    * op mul *tmp112 *tmp111 :compute:y1
+  236 op mul *tmp112 *tmp111 :compute:zy
   237 op add :compute:zy *tmp112 :compute:cy
   238 op len :compute:dist :compute:zx :compute:zy
   239 jump *label66 lessThan :compute:dist 64
 
   258 label *label69
   259 set *tmp89 :compute:i
   260 jump *label56 always
-    * set *tmp89 null
   261 label *label56
   262 set :iterations *tmp89
-    * set :drawPixel:x :x
-    * set :drawPixel:y :y
-    * set :drawPixel:dx :dx
-    * set :drawPixel:dy :dy
-    * set :drawPixel:iterations :iterations
+  263 set :drawPixel:x :adam5:x
+  264 set :drawPixel:y :adam5:y
+  265 set :drawPixel:dx :adam5:dx
+  266 set :drawPixel:dy :adam5:dy
+  267 set :drawPixel:iterations *tmp89
   268 jump *label73 equal .SMOOTH false
-    * jump *label75 notEqual :drawPixel:iterations 63
+  269 jump *label75 notEqual :iterations 63
   270 set :drawPixel:color %[black]
   271 jump *label76 always
   272 label *label75
   273 jump *label78 notEqual .PALETTE 2
   274 label *label79
-    * op sub *tmp129 32 :drawPixel:iterations
+  275 op sub *tmp129 32 :iterations
   276 op abs *tmp130 *tmp129
   277 op mul *tmp131 7 *tmp130
-    * op div *tmp132 *tmp131 255
+  278 op div *tmp132 *tmp130 36.42857142857143
   279 op sub :drawPixel:r 1 *tmp132
-    * op sub *tmp134 :drawPixel:iterations 32
+  280 op sub *tmp134 :iterations 32
   281 op abs *tmp135 *tmp134
   282 op mul *tmp136 6 *tmp135
-    * op div *tmp137 *tmp136 255
+  283 op div *tmp137 *tmp135 42.5
   284 op sub :drawPixel:g 0.9411764705882353 *tmp137
-    * op sub *tmp139 32 :drawPixel:iterations
-    * op abs *tmp140 *tmp139
-    * op mul *tmp141 4 *tmp140
-    * op div *tmp142 *tmp141 255
+  285 op sub *tmp139 32 :iterations
+  286 op abs *tmp140 *tmp129
+  287 op mul *tmp141 4 *tmp130
+  288 op div *tmp142 *tmp140 63.75
   289 op add :drawPixel:b 0.47058823529411764 *tmp142
   290 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   291 jump *label77 always
   292 label *label78
   293 jump *label80 notEqual .PALETTE 3
   294 label *label81
-    * op div *tmp145 :drawPixel:iterations 63
-    * op mul *tmp146 *tmp145 360
+  295 op div *tmp145 :iterations 63
+  296 op div *tmp146 :drawPixel:iterations 0.175
   297 op sin :drawPixel:r *tmp146
-    * op div *tmp148 :drawPixel:iterations 63
-    * op mul *tmp149 *tmp148 360
-    * op cos :drawPixel:g *tmp149
-    * op sub *tmp151 :drawPixel:iterations 32
+  298 op div *tmp148 :iterations 63
+  299 op mul *tmp149 *tmp145 360
+  300 op cos :drawPixel:g *tmp146
+  301 op sub *tmp151 :iterations 32
   302 op abs *tmp152 *tmp151
   303 op mul *tmp153 4 *tmp152
-    * op div *tmp154 *tmp153 255
+  304 op div *tmp154 *tmp152 63.75
   305 op add :drawPixel:b 0.39215686274509803 *tmp154
   306 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   307 jump *label77 always
   308 label *label80
   309 jump *label82 notEqual .PALETTE 4
   310 label *label83
-    * op mul *tmp157 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp157 255
-    * op mul *tmp159 1.5 :drawPixel:iterations
-    * op div :drawPixel:g *tmp159 255
+  311 op mul *tmp157 4 :iterations
+  312 op div :drawPixel:r :drawPixel:iterations 63.75
+  313 op mul *tmp159 1.5 :iterations
+  314 op div :drawPixel:g :drawPixel:iterations 170
   315 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   316 jump *label77 always
   317 label *label82
-    * op mul *tmp162 4 :drawPixel:iterations
-    * op div *tmp163 *tmp162 255
+  318 op mul *tmp162 4 :iterations
+  319 op div *tmp163 :drawPixel:iterations 63.75
   320 op sub :drawPixel:r 1 *tmp163
   321 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   322 label *label77
   323 label *label76
   324 jump *label74 always
   325 label *label73
-    * read :drawPixel:color .memory :drawPixel:iterations
+  326 read :drawPixel:color .memory :iterations
   327 label *label74
   328 jump *label84 lessThan .localBuffer 254
   329 label *label87
 
   355 label *label100
   356 jump *label97 strictNotEqual :drawPixel:color .lastColor
   357 label *label99
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  358 draw rect :x :y :dx :dy
   359 op add .localBuffer .localBuffer 1
   360 jump *label98 always
   361 label *label97
   362 draw col :drawPixel:color
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  363 draw rect :x :y :dx :dy
   364 set .lastColor :drawPixel:color
   365 op add .localBuffer .localBuffer 2
   366 label *label98
 
   388 op add *tmp2 *tmp191 1
   389 write *tmp2 .memory 66
   390 read *tmp193 .memory 65
-    * op add *tmp194 *tmp193 :iterations
+  391 op add *tmp194 *tmp193 *tmp89
   392 write *tmp194 .memory 65
   393 label *label21
   394 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-14 instructions):
 
    22 op div *tmp22 -88 .ZOOM
    23 read *tmp24 .memory 69
    24 op add .OFFSET_X *tmp22 *tmp24
-    * op div *tmp25 -88 .ZOOM
    25 read *tmp27 .memory 70
    26 op add .OFFSET_Y *tmp22 *tmp27
    27 read .JULIA .memory 72
 
    37 label *label9
    38 set *tmp35 99
    39 label *label10
-    * set :leaderLimit *tmp35
    40 label *label11
    41 wait 0
    42 read *tmp38 .memory 68
 
    51 label *label16
    52 set *tmp42 4
    53 label *label17
-    * set :multiple *tmp42
    54 op add *tmp43 :batch *tmp42
    55 write *tmp43 .memory 64
    56 jump *label18 lessThan :batch 2816
 
   188 label *label51
   189 label *label47
   190 label *label48
-    * set :compute:x :adam5:x
-    * set :compute:y :adam5:y
-    * op div *tmp90 :x .ZOOM
+  191 op div *tmp90 :adam5:x .ZOOM
   192 op add :compute:zx *tmp90 .OFFSET_X
-    * op div *tmp92 :y .ZOOM
+  193 op div *tmp92 :adam5:y .ZOOM
   194 op add :compute:zy *tmp92 .OFFSET_Y
   195 jump *label57 equal .JULIA false
   196 set :compute:cx .JULIA_X
 
   222 label *label63
   223 jump *label65 greaterThanEq :compute:i 63
   224 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   225 op mul *tmp107 :compute:zx :compute:zx
   226 op mul *tmp108 :compute:zy :compute:zy
   227 op sub *tmp109 *tmp107 *tmp108
 
   254 jump *label56 always
   255 label *label56
   256 set :iterations *tmp89
-    * set :drawPixel:x :adam5:x
-    * set :drawPixel:y :adam5:y
-    * set :drawPixel:dx :adam5:dx
-    * set :drawPixel:dy :adam5:dy
   257 set :drawPixel:iterations *tmp89
   258 jump *label73 equal .SMOOTH false
-    * jump *label75 notEqual :iterations 63
+  259 jump *label75 notEqual *tmp89 63
   260 set :drawPixel:color %[black]
   261 jump *label76 always
   262 label *label75
   263 jump *label78 notEqual .PALETTE 2
   264 label *label79
-    * op sub *tmp129 32 :iterations
+  265 op sub *tmp129 32 *tmp89
   266 op abs *tmp130 *tmp129
-    * op mul *tmp131 7 *tmp130
   267 op div *tmp132 *tmp130 36.42857142857143
   268 op sub :drawPixel:r 1 *tmp132
-    * op sub *tmp134 :iterations 32
+  269 op sub *tmp134 *tmp89 32
   270 op abs *tmp135 *tmp134
-    * op mul *tmp136 6 *tmp135
   271 op div *tmp137 *tmp135 42.5
   272 op sub :drawPixel:g 0.9411764705882353 *tmp137
-    * op sub *tmp139 32 :iterations
+  273 op sub *tmp139 32 *tmp89
   274 op abs *tmp140 *tmp129
-    * op mul *tmp141 4 *tmp130
-    * op div *tmp142 *tmp140 63.75
+  275 op div *tmp142 *tmp130 63.75
   276 op add :drawPixel:b 0.47058823529411764 *tmp142
   277 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   278 jump *label77 always
   279 label *label78
   280 jump *label80 notEqual .PALETTE 3
   281 label *label81
-    * op div *tmp145 :iterations 63
-    * op div *tmp146 :drawPixel:iterations 0.175
+  282 op div *tmp145 *tmp89 63
+  283 op div *tmp146 *tmp89 0.175
   284 op sin :drawPixel:r *tmp146
-    * op div *tmp148 :iterations 63
-    * op mul *tmp149 *tmp145 360
+  285 op div *tmp148 *tmp89 63
+  286 op div *tmp149 :iterations 0.175
   287 op cos :drawPixel:g *tmp146
-    * op sub *tmp151 :iterations 32
+  288 op sub *tmp151 *tmp89 32
   289 op abs *tmp152 *tmp151
-    * op mul *tmp153 4 *tmp152
   290 op div *tmp154 *tmp152 63.75
   291 op add :drawPixel:b 0.39215686274509803 *tmp154
   292 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   294 label *label80
   295 jump *label82 notEqual .PALETTE 4
   296 label *label83
-    * op mul *tmp157 4 :iterations
-    * op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp159 1.5 :iterations
-    * op div :drawPixel:g :drawPixel:iterations 170
+  297 op mul *tmp157 4 *tmp89
+  298 op div :drawPixel:r *tmp89 63.75
+  299 op mul *tmp159 1.5 *tmp89
+  300 op div :drawPixel:g *tmp89 170
   301 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   302 jump *label77 always
   303 label *label82
-    * op mul *tmp162 4 :iterations
-    * op div *tmp163 :drawPixel:iterations 63.75
+  304 op mul *tmp162 4 *tmp89
+  305 op div *tmp163 *tmp89 63.75
   306 op sub :drawPixel:r 1 *tmp163
   307 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   308 label *label77
   309 label *label76
   310 jump *label74 always
   311 label *label73
-    * read :drawPixel:color .memory :iterations
+  312 read :drawPixel:color .memory *tmp89
   313 label *label74
   314 jump *label84 lessThan .localBuffer 254
   315 label *label87
 
   341 label *label100
   342 jump *label97 strictNotEqual :drawPixel:color .lastColor
   343 label *label99
-    * draw rect :x :y :dx :dy
+  344 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   345 op add .localBuffer .localBuffer 1
   346 jump *label98 always
   347 label *label97
   348 draw col :drawPixel:color
-    * draw rect :x :y :dx :dy
+  349 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   350 set .lastColor :drawPixel:color
   351 op add .localBuffer .localBuffer 2
   352 label *label98

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   161 set :adam5:dx 1
   162 label *label24
   163 label *label23
-    * set :x :adam5:x
-    * set :y :adam5:y
-    * set :dx :adam5:dx
-    * set :dy :adam5:dy
   164 jump *label47 lessThanEq *tmp42 *tmp35
   165 label *label50
   166 jump *label47 notEqual .localBuffer 0
 
   250 jump *label56 always
   251 label *label56
   252 set :iterations *tmp89
-    * set :drawPixel:iterations *tmp89
   253 jump *label73 equal .SMOOTH false
   254 jump *label75 notEqual *tmp89 63
   255 set :drawPixel:color %[black]
 
   265 op abs *tmp135 *tmp134
   266 op div *tmp137 *tmp135 42.5
   267 op sub :drawPixel:g 0.9411764705882353 *tmp137
-    * op sub *tmp139 32 *tmp89
-    * op abs *tmp140 *tmp129
   268 op div *tmp142 *tmp130 63.75
   269 op add :drawPixel:b 0.47058823529411764 *tmp142
   270 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   272 label *label78
   273 jump *label80 notEqual .PALETTE 3
   274 label *label81
-    * op div *tmp145 *tmp89 63
   275 op div *tmp146 *tmp89 0.175
   276 op sin :drawPixel:r *tmp146
-    * op div *tmp148 *tmp89 63
-    * op div *tmp149 :iterations 0.175
+  277 op div *tmp149 *tmp89 0.175
   278 op cos :drawPixel:g *tmp146
   279 op sub *tmp151 *tmp89 32
   280 op abs *tmp152 *tmp151
 
   285 label *label80
   286 jump *label82 notEqual .PALETTE 4
   287 label *label83
-    * op mul *tmp157 4 *tmp89
   288 op div :drawPixel:r *tmp89 63.75
-    * op mul *tmp159 1.5 *tmp89
   289 op div :drawPixel:g *tmp89 170
   290 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   291 jump *label77 always
   292 label *label82
-    * op mul *tmp162 4 *tmp89
   293 op div *tmp163 *tmp89 63.75
   294 op sub :drawPixel:r 1 *tmp163
   295 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   249 set *tmp89 :compute:i
   250 jump *label56 always
   251 label *label56
-    * set :iterations *tmp89
   252 jump *label73 equal .SMOOTH false
   253 jump *label75 notEqual *tmp89 63
   254 set :drawPixel:color %[black]
 
   273 label *label81
   274 op div *tmp146 *tmp89 0.175
   275 op sin :drawPixel:r *tmp146
-    * op div *tmp149 *tmp89 0.175
   276 op cos :drawPixel:g *tmp146
   277 op sub *tmp151 *tmp89 32
   278 op abs *tmp152 *tmp151

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    59 label *label19
    60 op mul *tmp47 11 *tmp42
    61 set :i 0
+   62 op mul *tmp48 :batch 11
    63 label *label20
    64 jump *label22 greaterThanEq :i *tmp47
-    * op mul *tmp48 :batch 11
    65 op add :adam5:index *tmp48 :i
    66 op idiv *tmp51 :adam5:index 16
    67 jump *label27 lessThan *tmp51 0

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
    62 op mul *tmp48 :batch 11
    63 label *label20
    64 jump *label22 greaterThanEq :i *tmp47
+   65 label *label119
    66 op add :adam5:index *tmp48 :i
    67 op idiv *tmp51 :adam5:index 16
    68 jump *label27 lessThan *tmp51 0
 
   218 set :compute:i 0
   219 label *label63
   220 jump *label65 greaterThanEq :compute:i 63
+  221 label *label120
   222 set :compute:x1 :compute:zx
   223 op mul *tmp107 :compute:zx :compute:zx
   224 op mul *tmp108 :compute:zy :compute:zy
 
   234 label *label67
   235 label *label64
   236 op add :compute:i :compute:i 1
-    * jump *label63 always
+  237 jump *label120 lessThan :compute:i 63
   238 label *label65
   239 jump *label68 equal .SMOOTH false
   240 label *label71
 
   302 jump *label84 lessThan .localBuffer 254
   303 label *label87
   304 jump *label89 lessThanEq .localBuffer 0
-    * label *label91
+  305 label *label121
   306 read *tmp173 .memory 68
   307 jump *label89 notEqual .stop *tmp173
-    * label *label90
   308 wait 0
   309 sensor *tmp174 .display @enabled
   310 jump *label93 equal *tmp174 false
 
   319 label *label94
   320 label *label92
   321 label *label88
-    * jump *label87 always
+  322 jump *label121 greaterThan .localBuffer 0
   323 label *label89
   324 label *label86
   325 label *label84
 
   365 write *tmp194 .memory 65
   366 label *label21
   367 op add :i :i 1
-    * jump *label20 always
+  368 jump *label119 lessThan :i *tmp47
   369 label *label22
   370 label *label12
   371 jump *label11 always
   372 label *label13
   373 label *label109
   374 jump *label111 lessThanEq .localBuffer 0
-    * label *label113
+  375 label *label122
   376 read *tmp197 .memory 68
   377 jump *label111 notEqual .stop *tmp197
-    * label *label112
   378 wait 0
   379 sensor *tmp198 .display @enabled
   380 jump *label115 equal *tmp198 false
 
   389 label *label116
   390 label *label114
   391 label *label110
-    * jump *label109 always
+  392 jump *label122 greaterThan .localBuffer 0
   393 label *label111
   394 label *label108
   395 label *label4

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-20 instructions):
 
    30 read .PALETTE .memory 75
    31 op greaterThan .SMOOTH .PALETTE 1
    32 read .ALL_PASS_COLORING .memory 76
-    * read *tmp34 .memory 77
-    * jump *label9 equal *tmp34 false
-    * op sub *tmp35 1 .ALL_PASS_COLORING
-    * jump *label10 always
-    * label *label9
-    * set *tmp35 99
-    * label *label10
+   33 read *tmp34 .memory 77
+   34 op sub *tmp203 1 .ALL_PASS_COLORING
+   35 select *tmp35 notEqual *tmp34 false *tmp203 99
    36 label *label11
    37 wait 0
    38 read *tmp38 .memory 68
 
    41 label *label14
    42 label *label15
    43 read :batch .memory 64
-    * jump *label16 lessThan :batch 1408
-    * set *tmp42 1
-    * jump *label17 always
-    * label *label16
-    * set *tmp42 4
-    * label *label17
+   44 select *tmp42 greaterThanEq :batch 1408 1 4
    45 op add *tmp43 :batch *tmp42
    46 write *tmp43 .memory 64
    47 jump *label18 lessThan :batch 2816
 
    65 op mul :adam5:x 4 *tmp53
    66 op idiv *tmp55 :adam5:index 44
    67 op mul :adam5:y 4 *tmp55
-    * jump *label28 equal .ALL_PASS_COLORING false
-    * set *tmp57 4
-    * jump *label29 always
-    * label *label28
-    * set *tmp57 2
-    * label *label29
+   68 select *tmp57 notEqual .ALL_PASS_COLORING false 4 2
    69 set :adam5:dy *tmp57
    70 set :adam5:dx *tmp57
    71 jump *label24 always
 
    81 op add :adam5:x *tmp59 2
    82 op idiv *tmp61 :adam5:index 44
    83 op mul :adam5:y 4 *tmp61
-    * jump *label33 equal .ALL_PASS_COLORING false
-    * set *tmp63 2
-    * jump *label34 always
-    * label *label33
-    * set *tmp63 1
-    * label *label34
+   84 select *tmp63 notEqual .ALL_PASS_COLORING false 2 1
    85 set :adam5:dx *tmp63
-    * jump *label35 equal .ALL_PASS_COLORING false
-    * set *tmp64 4
-    * jump *label36 always
-    * label *label35
-    * set *tmp64 2
-    * label *label36
+   86 select *tmp64 notEqual .ALL_PASS_COLORING false 4 2
    87 set :adam5:dy *tmp64
    88 jump *label24 always
    89 label *label30
 
    98 op idiv *tmp67 :adam5:index 88
    99 op mul *tmp68 4 *tmp67
   100 op add :adam5:y *tmp68 2
-    * jump *label40 equal .ALL_PASS_COLORING false
-    * set *tmp70 2
-    * jump *label41 always
-    * label *label40
-    * set *tmp70 1
-    * label *label41
+  101 select *tmp70 notEqual .ALL_PASS_COLORING false 2 1
   102 set :adam5:dy *tmp70
   103 set :adam5:dx *tmp70
   104 jump *label24 always
 
   115 op idiv *tmp74 :adam5:index 88
   116 op mul :adam5:y 2 *tmp74
   117 set :adam5:dx 1
-    * jump *label45 equal .ALL_PASS_COLORING false
-    * set *tmp76 2
-    * jump *label46 always
-    * label *label45
-    * set *tmp76 1
-    * label *label46
+  118 select *tmp76 notEqual .ALL_PASS_COLORING false 2 1
   119 set :adam5:dy *tmp76
   120 jump *label24 always
   121 label *label42
 
   129 label *label24
   130 label *label23
   131 jump *label47 lessThanEq *tmp42 *tmp35
-    * label *label50
   132 jump *label47 notEqual .localBuffer 0
-    * label *label49
   133 draw col %[white]
   134 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx
   135 set .lastColor %[white]
 
   137 wait 0
   138 sensor *tmp84 .display @enabled
   139 jump *label52 equal *tmp84 false
-    * label *label55
   140 sensor *tmp85 .display @bufferSize
   141 op sub *tmp86 1024 *tmp85
   142 jump *label52 greaterThanEq 2 *tmp86
-    * label *label54
   143 drawflush .display
   144 set .localBuffer 0
   145 label *label52
 
   199 jump *label120 lessThan :compute:i 63
   200 label *label65
   201 jump *label68 equal .SMOOTH false
-    * label *label71
   202 jump *label68 greaterThanEq :compute:i 63
-    * label *label70
   203 op log *tmp119 :compute:dist
   204 op mul *tmp120 *tmp119 0.36067376022224085
   205 op log *tmp121 *tmp120
 
   268 wait 0
   269 sensor *tmp174 .display @enabled
   270 jump *label93 equal *tmp174 false
-    * label *label96
   271 sensor *tmp175 .display @bufferSize
   272 op sub *tmp176 1024 *tmp175
   273 jump *label93 greaterThanEq .localBuffer *tmp176
-    * label *label95
   274 drawflush .display
   275 set .localBuffer 0
   276 label *label93
 
   283 label *label84
   284 label *label85
   285 jump *label97 lessThanEq .localBuffer 0
-    * label *label100
   286 jump *label97 strictNotEqual :drawPixel:color .lastColor
-    * label *label99
   287 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   288 op add .localBuffer .localBuffer 1
   289 jump *label98 always
 
   296 wait 0
   297 sensor *tmp183 .display @enabled
   298 jump *label102 equal *tmp183 false
-    * label *label105
   299 sensor *tmp184 .display @bufferSize
   300 op sub *tmp185 1024 *tmp184
   301 jump *label102 greaterThanEq .localBuffer *tmp185
-    * label *label104
   302 drawflush .display
   303 set .localBuffer 0
   304 label *label102
 
   332 wait 0
   333 sensor *tmp198 .display @enabled
   334 jump *label115 equal *tmp198 false
-    * label *label118
   335 sensor *tmp199 .display @bufferSize
   336 op sub *tmp200 1024 *tmp199
   337 jump *label115 greaterThanEq .localBuffer *tmp200
-    * label *label117
   338 drawflush .display
   339 set .localBuffer 0
   340 label *label115

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   212 jump *label56 always
   213 label *label56
   214 jump *label73 equal .SMOOTH false
-    * jump *label75 notEqual *tmp89 63
   215 set :drawPixel:color %[black]
-    * jump *label76 always
+  216 jump *label76 equal *tmp89 63
   217 label *label75
   218 jump *label78 notEqual .PALETTE 2
   219 label *label79

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:127:5 (-10 instructions):
 
    56 label *label119
    57 op add :adam5:index *tmp48 :i
    58 op idiv *tmp51 :adam5:index 16
-    * jump *label27 lessThan *tmp51 0
-    * jump *label26 lessThan *tmp51 121
-    * label *label27
-    * jump *label25 always
+   59 multijump *tmp51 0 0 (m:*label124)
+   60 multilabel *label129 (m:*label124)
+   61 label *label123
+   62 op sub :adam5:index :adam5:index 15488
+   63 op mod :adam5:x :adam5:index 176
+   64 op idiv *tmp78 :adam5:index 176
+   65 op mul *tmp79 2 *tmp78
+   66 op add :adam5:y *tmp79 1
+   67 set :adam5:dy 1
+   68 set :adam5:dx 1
+   69 jump *label24 always
+   70 multilabel *label125 (m:*label124)
    71 label *label26
    72 op mod *tmp53 :adam5:index 44
    73 op mul :adam5:x 4 *tmp53
 
    78 set :adam5:dx *tmp57
    79 jump *label24 always
    80 label *label25
-    * jump *label32 lessThan *tmp51 121
-    * jump *label31 lessThan *tmp51 242
-    * label *label32
-    * jump *label30 always
+   81 multilabel *label126 (m:*label124)
    82 label *label31
    83 op sub :adam5:index :adam5:index 1936
    84 op mod *tmp58 :adam5:index 44
 
    92 set :adam5:dy *tmp64
    93 jump *label24 always
    94 label *label30
-    * jump *label39 lessThan *tmp51 242
-    * jump *label38 lessThan *tmp51 484
-    * label *label39
-    * jump *label37 always
+   95 multilabel *label127 (m:*label124)
    96 label *label38
    97 op sub :adam5:index :adam5:index 3872
    98 op mod *tmp65 :adam5:index 88
 
   105 set :adam5:dx *tmp70
   106 jump *label24 always
   107 label *label37
-    * jump *label44 lessThan *tmp51 484
-    * jump *label43 lessThan *tmp51 968
-    * label *label44
-    * jump *label42 always
+  108 jump *label24 always
+  109 multilabel *label128 (m:*label124)
   110 label *label43
   111 op sub :adam5:index :adam5:index 7744
   112 op mod *tmp71 :adam5:index 88
 
   117 set :adam5:dx 1
   118 select *tmp76 notEqual .ALL_PASS_COLORING false 2 1
   119 set :adam5:dy *tmp76
-    * jump *label24 always
-    * label *label42
-    * op sub :adam5:index :adam5:index 15488
-    * op mod :adam5:x :adam5:index 176
-    * op idiv *tmp78 :adam5:index 176
-    * op mul *tmp79 2 *tmp78
-    * op add :adam5:y *tmp79 1
-    * set :adam5:dy 1
-    * set :adam5:dx 1
   120 label *label24
   121 label *label23
   122 jump *label47 lessThanEq *tmp42 *tmp35

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    52 set :i 0
    53 op mul *tmp48 :batch 11
    54 label *label20
-    * jump *label22 greaterThanEq :i *tmp47
+   55 jump *label22 greaterThanEq 0 *tmp47
    56 label *label119
    57 op add :adam5:index *tmp48 :i
    58 op idiv *tmp51 :adam5:index 16
 
   170 label *label58
   171 set :compute:i 0
   172 label *label63
-    * jump *label65 greaterThanEq :compute:i 63
+  173 jump *label65 greaterThanEq 0 63
   174 label *label120
   175 set :compute:x1 :compute:zx
   176 op mul *tmp107 :compute:zx :compute:zx

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:216:13 (-2 instructions):
 
   206 set :drawPixel:color %[black]
   207 jump *label76 equal *tmp89 63
   208 label *label75
-    * jump *label78 notEqual .PALETTE 2
+  209 multijump .PALETTE 0 0 (m:*label131)
+  210 multilabel *label136 (m:*label131)
+  211 multilabel *label132 (m:*label131)
+  212 label *label130
+  213 op div *tmp163 *tmp89 63.75
+  214 op sub :drawPixel:r 1 *tmp163
+  215 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
+  216 jump *label77 always
+  217 multilabel *label133 (m:*label131)
   218 label *label79
   219 op sub *tmp129 32 *tmp89
   220 op abs *tmp130 *tmp129
 
   229 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   230 jump *label77 always
   231 label *label78
-    * jump *label80 notEqual .PALETTE 3
+  232 multilabel *label134 (m:*label131)
   233 label *label81
   234 op div *tmp146 *tmp89 0.175
   235 op sin :drawPixel:r *tmp146
 
   241 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   242 jump *label77 always
   243 label *label80
-    * jump *label82 notEqual .PALETTE 4
+  244 multilabel *label135 (m:*label131)
   245 label *label83
   246 op div :drawPixel:r *tmp89 63.75
   247 op div :drawPixel:g *tmp89 170
   248 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label77 always
-    * label *label82
-    * op div *tmp163 *tmp89 63.75
-    * op sub :drawPixel:r 1 *tmp163
-    * packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   249 label *label77
   250 label *label76
   251 jump *label74 always

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   170 label *label58
   171 set :compute:i 0
   172 label *label63
-    * jump *label65 greaterThanEq 0 63
   173 label *label120
   174 set :compute:x1 :compute:zx
   175 op mul *tmp107 :compute:zx :compute:zx

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-2 instructions):
 
    28 read .JULIA_X .memory 73
    29 read .JULIA_Y .memory 74
    30 read .PALETTE .memory 75
-    * op greaterThan .SMOOTH .PALETTE 1
    31 read .ALL_PASS_COLORING .memory 76
    32 read *tmp34 .memory 77
    33 op sub *tmp203 1 .ALL_PASS_COLORING
 
    51 set :i 0
    52 op mul *tmp48 :batch 11
    53 label *label20
-    * jump *label22 greaterThanEq 0 *tmp47
+   54 jump *label22 lessThanEq *tmp42 0
    55 label *label119
    56 op add :adam5:index *tmp48 :i
    57 op idiv *tmp51 :adam5:index 16
 
   128 sensor *tmp84 .display @enabled
   129 jump *label52 equal *tmp84 false
   130 sensor *tmp85 .display @bufferSize
-    * op sub *tmp86 1024 *tmp85
-    * jump *label52 greaterThanEq 2 *tmp86
+  131 jump *label52 greaterThanEq *tmp85 1022
   132 drawflush .display
   133 set .localBuffer 0
   134 label *label52
 
   186 op add :compute:i :compute:i 1
   187 jump *label120 lessThan :compute:i 63
   188 label *label65
-    * jump *label68 equal .SMOOTH false
+  189 jump *label68 lessThanEq .PALETTE 1
   190 jump *label68 greaterThanEq :compute:i 63
   191 op log *tmp119 :compute:dist
   192 op mul *tmp120 *tmp119 0.36067376022224085
 
   199 set *tmp89 :compute:i
   200 jump *label56 always
   201 label *label56
-    * jump *label73 equal .SMOOTH false
+  202 jump *label73 lessThanEq .PALETTE 1
   203 set :drawPixel:color %[black]
   204 jump *label76 equal *tmp89 63
   205 label *label75

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   102 select *tmp70 notEqual .ALL_PASS_COLORING false 2 1
   103 set :adam5:dy *tmp70
   104 set :adam5:dx *tmp70
-    * jump *label24 always
   105 label *label37
   106 jump *label24 always
   107 multilabel *label128 (m:*label124)
 
   196 label *label68
   197 label *label69
   198 set *tmp89 :compute:i
-    * jump *label56 always
   199 label *label56
   200 jump *label73 lessThanEq .PALETTE 1
   201 set :drawPixel:color %[black]

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-3 instructions):
 
    85 op add :adam5:x *tmp59 2
    86 op idiv *tmp61 :adam5:index 44
    87 op mul :adam5:y 4 *tmp61
-    * select *tmp63 notEqual .ALL_PASS_COLORING false 2 1
-    * set :adam5:dx *tmp63
-    * select *tmp64 notEqual .ALL_PASS_COLORING false 4 2
-    * set :adam5:dy *tmp64
+   88 select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1
+   89 select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2
    90 jump *label24 always
    91 label *label30
    92 multilabel *label127 (m:*label124)
 
   111 op idiv *tmp74 :adam5:index 88
   112 op mul :adam5:y 2 *tmp74
   113 set :adam5:dx 1
-    * select *tmp76 notEqual .ALL_PASS_COLORING false 2 1
-    * set :adam5:dy *tmp76
+  114 select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1
   115 label *label24
   116 label *label23
   117 jump *label47 lessThanEq *tmp42 *tmp35

Modifications by Unroll loop at mandelbrot-compute.mnd:188:5 (+743 instructions):
 
   162 label *label61
   163 label *label62
   164 label *label58
-    * set :compute:i 0
-    * label *label63
-    * label *label120
-    * set :compute:x1 :compute:zx
-    * op mul *tmp107 :compute:zx :compute:zx
-    * op mul *tmp108 :compute:zy :compute:zy
-    * op sub *tmp109 *tmp107 *tmp108
-    * op add :compute:zx *tmp109 :compute:cx
-    * op mul *tmp111 2 :compute:x1
-    * op mul *tmp112 *tmp111 :compute:zy
-    * op add :compute:zy *tmp112 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label66 lessThan :compute:dist 64
-    * jump *label65 always
-    * label *label66
-    * label *label67
-    * label *label64
-    * op add :compute:i :compute:i 1
-    * jump *label120 lessThan :compute:i 63
-    * label *label65
+  165 set :compute:i 0
+  166 label *label137
+  167 set :compute:x1 :compute:zx
+  168 op mul *tmp107 :compute:zx :compute:zx
+  169 op mul *tmp108 :compute:zy :compute:zy
+  170 op sub *tmp109 *tmp107 *tmp108
+  171 op add :compute:zx *tmp109 :compute:cx
+  172 op mul *tmp111 2 :compute:x1
+  173 op mul *tmp112 *tmp111 :compute:zy
+  174 op add :compute:zy *tmp112 :compute:cy
+  175 op len :compute:dist :compute:zx :compute:zy
+  176 jump *label138 lessThan :compute:dist 64
+  177 jump *label65 always
+  178 label *label138
+  179 label *label139
+  180 label *label140
+  181 op add :compute:i :compute:i 1
+  182 set :compute:x1 :compute:zx
+  183 op mul *tmp107 :compute:zx :compute:zx
+  184 op mul *tmp108 :compute:zy :compute:zy
+  185 op sub *tmp109 *tmp107 *tmp108
+  186 op add :compute:zx *tmp109 :compute:cx
+  187 op mul *tmp111 2 :compute:x1
+  188 op mul *tmp112 *tmp111 :compute:zy
+  189 op add :compute:zy *tmp112 :compute:cy
+  190 op len :compute:dist :compute:zx :compute:zy
+  191 jump *label141 lessThan :compute:dist 64
+  192 jump *label65 always
+  193 label *label141
+  194 label *label142
+  195 label *label143
+  196 op add :compute:i :compute:i 1
+  197 set :compute:x1 :compute:zx
+  198 op mul *tmp107 :compute:zx :compute:zx
+  199 op mul *tmp108 :compute:zy :compute:zy
+  200 op sub *tmp109 *tmp107 *tmp108
+  201 op add :compute:zx *tmp109 :compute:cx
+  202 op mul *tmp111 2 :compute:x1
+  203 op mul *tmp112 *tmp111 :compute:zy
+  204 op add :compute:zy *tmp112 :compute:cy
+  205 op len :compute:dist :compute:zx :compute:zy
+  206 jump *label144 lessThan :compute:dist 64
+  207 jump *label65 always
+  208 label *label144
+  209 label *label145
+  210 label *label146
+  211 op add :compute:i :compute:i 1
+  212 set :compute:x1 :compute:zx
+  213 op mul *tmp107 :compute:zx :compute:zx
+  214 op mul *tmp108 :compute:zy :compute:zy
+  215 op sub *tmp109 *tmp107 *tmp108
+  216 op add :compute:zx *tmp109 :compute:cx
+  217 op mul *tmp111 2 :compute:x1
+  218 op mul *tmp112 *tmp111 :compute:zy
+  219 op add :compute:zy *tmp112 :compute:cy
+  220 op len :compute:dist :compute:zx :compute:zy
+  221 jump *label147 lessThan :compute:dist 64
+  222 jump *label65 always
+  223 label *label147
+  224 label *label148
+  225 label *label149
+  226 op add :compute:i :compute:i 1
+  227 set :compute:x1 :compute:zx
+  228 op mul *tmp107 :compute:zx :compute:zx
+  229 op mul *tmp108 :compute:zy :compute:zy
+  230 op sub *tmp109 *tmp107 *tmp108
+  231 op add :compute:zx *tmp109 :compute:cx
+  232 op mul *tmp111 2 :compute:x1
+  233 op mul *tmp112 *tmp111 :compute:zy
+  234 op add :compute:zy *tmp112 :compute:cy
+  235 op len :compute:dist :compute:zx :compute:zy
+  236 jump *label150 lessThan :compute:dist 64
+  237 jump *label65 always
+  238 label *label150
+  239 label *label151
+  240 label *label152
+  241 op add :compute:i :compute:i 1
+  242 set :compute:x1 :compute:zx
+  243 op mul *tmp107 :compute:zx :compute:zx
+  244 op mul *tmp108 :compute:zy :compute:zy
+  245 op sub *tmp109 *tmp107 *tmp108
+  246 op add :compute:zx *tmp109 :compute:cx
+  247 op mul *tmp111 2 :compute:x1
+  248 op mul *tmp112 *tmp111 :compute:zy
+  249 op add :compute:zy *tmp112 :compute:cy
+  250 op len :compute:dist :compute:zx :compute:zy
+  251 jump *label153 lessThan :compute:dist 64
+  252 jump *label65 always
+  253 label *label153
+  254 label *label154
+  255 label *label155
+  256 op add :compute:i :compute:i 1
+  257 set :compute:x1 :compute:zx
+  258 op mul *tmp107 :compute:zx :compute:zx
+  259 op mul *tmp108 :compute:zy :compute:zy
+  260 op sub *tmp109 *tmp107 *tmp108
+  261 op add :compute:zx *tmp109 :compute:cx
+  262 op mul *tmp111 2 :compute:x1
+  263 op mul *tmp112 *tmp111 :compute:zy
+  264 op add :compute:zy *tmp112 :compute:cy
+  265 op len :compute:dist :compute:zx :compute:zy
+  266 jump *label156 lessThan :compute:dist 64
+  267 jump *label65 always
+  268 label *label156
+  269 label *label157
+  270 label *label158
+  271 op add :compute:i :compute:i 1
+  272 set :compute:x1 :compute:zx
+  273 op mul *tmp107 :compute:zx :compute:zx
+  274 op mul *tmp108 :compute:zy :compute:zy
+  275 op sub *tmp109 *tmp107 *tmp108
+  276 op add :compute:zx *tmp109 :compute:cx
+  277 op mul *tmp111 2 :compute:x1
+  278 op mul *tmp112 *tmp111 :compute:zy
+  279 op add :compute:zy *tmp112 :compute:cy
+  280 op len :compute:dist :compute:zx :compute:zy
+  281 jump *label159 lessThan :compute:dist 64
+  282 jump *label65 always
+  283 label *label159
+  284 label *label160
+  285 label *label161
+  286 op add :compute:i :compute:i 1
+  287 set :compute:x1 :compute:zx
+  288 op mul *tmp107 :compute:zx :compute:zx
+  289 op mul *tmp108 :compute:zy :compute:zy
+  290 op sub *tmp109 *tmp107 *tmp108
+  291 op add :compute:zx *tmp109 :compute:cx
+  292 op mul *tmp111 2 :compute:x1
+  293 op mul *tmp112 *tmp111 :compute:zy
+  294 op add :compute:zy *tmp112 :compute:cy
+  295 op len :compute:dist :compute:zx :compute:zy
+  296 jump *label162 lessThan :compute:dist 64
+  297 jump *label65 always
+  298 label *label162
+  299 label *label163
+  300 label *label164
+  301 op add :compute:i :compute:i 1
+  302 set :compute:x1 :compute:zx
+  303 op mul *tmp107 :compute:zx :compute:zx
+  304 op mul *tmp108 :compute:zy :compute:zy
+  305 op sub *tmp109 *tmp107 *tmp108
+  306 op add :compute:zx *tmp109 :compute:cx
+  307 op mul *tmp111 2 :compute:x1
+  308 op mul *tmp112 *tmp111 :compute:zy
+  309 op add :compute:zy *tmp112 :compute:cy
+  310 op len :compute:dist :compute:zx :compute:zy
+  311 jump *label165 lessThan :compute:dist 64
+  312 jump *label65 always
+  313 label *label165
+  314 label *label166
+  315 label *label167
+  316 op add :compute:i :compute:i 1
+  317 set :compute:x1 :compute:zx
+  318 op mul *tmp107 :compute:zx :compute:zx
+  319 op mul *tmp108 :compute:zy :compute:zy
+  320 op sub *tmp109 *tmp107 *tmp108
+  321 op add :compute:zx *tmp109 :compute:cx
+  322 op mul *tmp111 2 :compute:x1
+  323 op mul *tmp112 *tmp111 :compute:zy
+  324 op add :compute:zy *tmp112 :compute:cy
+  325 op len :compute:dist :compute:zx :compute:zy
+  326 jump *label168 lessThan :compute:dist 64
+  327 jump *label65 always
+  328 label *label168
+  329 label *label169
+  330 label *label170
+  331 op add :compute:i :compute:i 1
+  332 set :compute:x1 :compute:zx
+  333 op mul *tmp107 :compute:zx :compute:zx
+  334 op mul *tmp108 :compute:zy :compute:zy
+  335 op sub *tmp109 *tmp107 *tmp108
+  336 op add :compute:zx *tmp109 :compute:cx
+  337 op mul *tmp111 2 :compute:x1
+  338 op mul *tmp112 *tmp111 :compute:zy
+  339 op add :compute:zy *tmp112 :compute:cy
+  340 op len :compute:dist :compute:zx :compute:zy
+  341 jump *label171 lessThan :compute:dist 64
+  342 jump *label65 always
+  343 label *label171
+  344 label *label172
+  345 label *label173
+  346 op add :compute:i :compute:i 1
+  347 set :compute:x1 :compute:zx
+  348 op mul *tmp107 :compute:zx :compute:zx
+  349 op mul *tmp108 :compute:zy :compute:zy
+  350 op sub *tmp109 *tmp107 *tmp108
+  351 op add :compute:zx *tmp109 :compute:cx
+  352 op mul *tmp111 2 :compute:x1
+  353 op mul *tmp112 *tmp111 :compute:zy
+  354 op add :compute:zy *tmp112 :compute:cy
+  355 op len :compute:dist :compute:zx :compute:zy
+  356 jump *label174 lessThan :compute:dist 64
+  357 jump *label65 always
+  358 label *label174
+  359 label *label175
+  360 label *label176
+  361 op add :compute:i :compute:i 1
+  362 set :compute:x1 :compute:zx
+  363 op mul *tmp107 :compute:zx :compute:zx
+  364 op mul *tmp108 :compute:zy :compute:zy
+  365 op sub *tmp109 *tmp107 *tmp108
+  366 op add :compute:zx *tmp109 :compute:cx
+  367 op mul *tmp111 2 :compute:x1
+  368 op mul *tmp112 *tmp111 :compute:zy
+  369 op add :compute:zy *tmp112 :compute:cy
+  370 op len :compute:dist :compute:zx :compute:zy
+  371 jump *label177 lessThan :compute:dist 64
+  372 jump *label65 always
+  373 label *label177
+  374 label *label178
+  375 label *label179
+  376 op add :compute:i :compute:i 1
+  377 set :compute:x1 :compute:zx
+  378 op mul *tmp107 :compute:zx :compute:zx
+  379 op mul *tmp108 :compute:zy :compute:zy
+  380 op sub *tmp109 *tmp107 *tmp108
+  381 op add :compute:zx *tmp109 :compute:cx
+  382 op mul *tmp111 2 :compute:x1
+  383 op mul *tmp112 *tmp111 :compute:zy
+  384 op add :compute:zy *tmp112 :compute:cy
+  385 op len :compute:dist :compute:zx :compute:zy
+  386 jump *label180 lessThan :compute:dist 64
+  387 jump *label65 always
+  388 label *label180
+  389 label *label181
+  390 label *label182
+  391 op add :compute:i :compute:i 1
+  392 set :compute:x1 :compute:zx
+  393 op mul *tmp107 :compute:zx :compute:zx
+  394 op mul *tmp108 :compute:zy :compute:zy
+  395 op sub *tmp109 *tmp107 *tmp108
+  396 op add :compute:zx *tmp109 :compute:cx
+  397 op mul *tmp111 2 :compute:x1
+  398 op mul *tmp112 *tmp111 :compute:zy
+  399 op add :compute:zy *tmp112 :compute:cy
+  400 op len :compute:dist :compute:zx :compute:zy
+  401 jump *label183 lessThan :compute:dist 64
+  402 jump *label65 always
+  403 label *label183
+  404 label *label184
+  405 label *label185
+  406 op add :compute:i :compute:i 1
+  407 set :compute:x1 :compute:zx
+  408 op mul *tmp107 :compute:zx :compute:zx
+  409 op mul *tmp108 :compute:zy :compute:zy
+  410 op sub *tmp109 *tmp107 *tmp108
+  411 op add :compute:zx *tmp109 :compute:cx
+  412 op mul *tmp111 2 :compute:x1
+  413 op mul *tmp112 *tmp111 :compute:zy
+  414 op add :compute:zy *tmp112 :compute:cy
+  415 op len :compute:dist :compute:zx :compute:zy
+  416 jump *label186 lessThan :compute:dist 64
+  417 jump *label65 always
+  418 label *label186
+  419 label *label187
+  420 label *label188
+  421 op add :compute:i :compute:i 1
+  422 set :compute:x1 :compute:zx
+  423 op mul *tmp107 :compute:zx :compute:zx
+  424 op mul *tmp108 :compute:zy :compute:zy
+  425 op sub *tmp109 *tmp107 *tmp108
+  426 op add :compute:zx *tmp109 :compute:cx
+  427 op mul *tmp111 2 :compute:x1
+  428 op mul *tmp112 *tmp111 :compute:zy
+  429 op add :compute:zy *tmp112 :compute:cy
+  430 op len :compute:dist :compute:zx :compute:zy
+  431 jump *label189 lessThan :compute:dist 64
+  432 jump *label65 always
+  433 label *label189
+  434 label *label190
+  435 label *label191
+  436 op add :compute:i :compute:i 1
+  437 set :compute:x1 :compute:zx
+  438 op mul *tmp107 :compute:zx :compute:zx
+  439 op mul *tmp108 :compute:zy :compute:zy
+  440 op sub *tmp109 *tmp107 *tmp108
+  441 op add :compute:zx *tmp109 :compute:cx
+  442 op mul *tmp111 2 :compute:x1
+  443 op mul *tmp112 *tmp111 :compute:zy
+  444 op add :compute:zy *tmp112 :compute:cy
+  445 op len :compute:dist :compute:zx :compute:zy
+  446 jump *label192 lessThan :compute:dist 64
+  447 jump *label65 always
+  448 label *label192
+  449 label *label193
+  450 label *label194
+  451 op add :compute:i :compute:i 1
+  452 set :compute:x1 :compute:zx
+  453 op mul *tmp107 :compute:zx :compute:zx
+  454 op mul *tmp108 :compute:zy :compute:zy
+  455 op sub *tmp109 *tmp107 *tmp108
+  456 op add :compute:zx *tmp109 :compute:cx
+  457 op mul *tmp111 2 :compute:x1
+  458 op mul *tmp112 *tmp111 :compute:zy
+  459 op add :compute:zy *tmp112 :compute:cy
+  460 op len :compute:dist :compute:zx :compute:zy
+  461 jump *label195 lessThan :compute:dist 64
+  462 jump *label65 always
+  463 label *label195
+  464 label *label196
+  465 label *label197
+  466 op add :compute:i :compute:i 1
+  467 set :compute:x1 :compute:zx
+  468 op mul *tmp107 :compute:zx :compute:zx
+  469 op mul *tmp108 :compute:zy :compute:zy
+  470 op sub *tmp109 *tmp107 *tmp108
+  471 op add :compute:zx *tmp109 :compute:cx
+  472 op mul *tmp111 2 :compute:x1
+  473 op mul *tmp112 *tmp111 :compute:zy
+  474 op add :compute:zy *tmp112 :compute:cy
+  475 op len :compute:dist :compute:zx :compute:zy
+  476 jump *label198 lessThan :compute:dist 64
+  477 jump *label65 always
+  478 label *label198
+  479 label *label199
+  480 label *label200
+  481 op add :compute:i :compute:i 1
+  482 set :compute:x1 :compute:zx
+  483 op mul *tmp107 :compute:zx :compute:zx
+  484 op mul *tmp108 :compute:zy :compute:zy
+  485 op sub *tmp109 *tmp107 *tmp108
+  486 op add :compute:zx *tmp109 :compute:cx
+  487 op mul *tmp111 2 :compute:x1
+  488 op mul *tmp112 *tmp111 :compute:zy
+  489 op add :compute:zy *tmp112 :compute:cy
+  490 op len :compute:dist :compute:zx :compute:zy
+  491 jump *label201 lessThan :compute:dist 64
+  492 jump *label65 always
+  493 label *label201
+  494 label *label202
+  495 label *label203
+  496 op add :compute:i :compute:i 1
+  497 set :compute:x1 :compute:zx
+  498 op mul *tmp107 :compute:zx :compute:zx
+  499 op mul *tmp108 :compute:zy :compute:zy
+  500 op sub *tmp109 *tmp107 *tmp108
+  501 op add :compute:zx *tmp109 :compute:cx
+  502 op mul *tmp111 2 :compute:x1
+  503 op mul *tmp112 *tmp111 :compute:zy
+  504 op add :compute:zy *tmp112 :compute:cy
+  505 op len :compute:dist :compute:zx :compute:zy
+  506 jump *label204 lessThan :compute:dist 64
+  507 jump *label65 always
+  508 label *label204
+  509 label *label205
+  510 label *label206
+  511 op add :compute:i :compute:i 1
+  512 set :compute:x1 :compute:zx
+  513 op mul *tmp107 :compute:zx :compute:zx
+  514 op mul *tmp108 :compute:zy :compute:zy
+  515 op sub *tmp109 *tmp107 *tmp108
+  516 op add :compute:zx *tmp109 :compute:cx
+  517 op mul *tmp111 2 :compute:x1
+  518 op mul *tmp112 *tmp111 :compute:zy
+  519 op add :compute:zy *tmp112 :compute:cy
+  520 op len :compute:dist :compute:zx :compute:zy
+  521 jump *label207 lessThan :compute:dist 64
+  522 jump *label65 always
+  523 label *label207
+  524 label *label208
+  525 label *label209
+  526 op add :compute:i :compute:i 1
+  527 set :compute:x1 :compute:zx
+  528 op mul *tmp107 :compute:zx :compute:zx
+  529 op mul *tmp108 :compute:zy :compute:zy
+  530 op sub *tmp109 *tmp107 *tmp108
+  531 op add :compute:zx *tmp109 :compute:cx
+  532 op mul *tmp111 2 :compute:x1
+  533 op mul *tmp112 *tmp111 :compute:zy
+  534 op add :compute:zy *tmp112 :compute:cy
+  535 op len :compute:dist :compute:zx :compute:zy
+  536 jump *label210 lessThan :compute:dist 64
+  537 jump *label65 always
+  538 label *label210
+  539 label *label211
+  540 label *label212
+  541 op add :compute:i :compute:i 1
+  542 set :compute:x1 :compute:zx
+  543 op mul *tmp107 :compute:zx :compute:zx
+  544 op mul *tmp108 :compute:zy :compute:zy
+  545 op sub *tmp109 *tmp107 *tmp108
+  546 op add :compute:zx *tmp109 :compute:cx
+  547 op mul *tmp111 2 :compute:x1
+  548 op mul *tmp112 *tmp111 :compute:zy
+  549 op add :compute:zy *tmp112 :compute:cy
+  550 op len :compute:dist :compute:zx :compute:zy
+  551 jump *label213 lessThan :compute:dist 64
+  552 jump *label65 always
+  553 label *label213
+  554 label *label214
+  555 label *label215
+  556 op add :compute:i :compute:i 1
+  557 set :compute:x1 :compute:zx
+  558 op mul *tmp107 :compute:zx :compute:zx
+  559 op mul *tmp108 :compute:zy :compute:zy
+  560 op sub *tmp109 *tmp107 *tmp108
+  561 op add :compute:zx *tmp109 :compute:cx
+  562 op mul *tmp111 2 :compute:x1
+  563 op mul *tmp112 *tmp111 :compute:zy
+  564 op add :compute:zy *tmp112 :compute:cy
+  565 op len :compute:dist :compute:zx :compute:zy
+  566 jump *label216 lessThan :compute:dist 64
+  567 jump *label65 always
+  568 label *label216
+  569 label *label217
+  570 label *label218
+  571 op add :compute:i :compute:i 1
+  572 set :compute:x1 :compute:zx
+  573 op mul *tmp107 :compute:zx :compute:zx
+  574 op mul *tmp108 :compute:zy :compute:zy
+  575 op sub *tmp109 *tmp107 *tmp108
+  576 op add :compute:zx *tmp109 :compute:cx
+  577 op mul *tmp111 2 :compute:x1
+  578 op mul *tmp112 *tmp111 :compute:zy
+  579 op add :compute:zy *tmp112 :compute:cy
+  580 op len :compute:dist :compute:zx :compute:zy
+  581 jump *label219 lessThan :compute:dist 64
+  582 jump *label65 always
+  583 label *label219
+  584 label *label220
+  585 label *label221
+  586 op add :compute:i :compute:i 1
+  587 set :compute:x1 :compute:zx
+  588 op mul *tmp107 :compute:zx :compute:zx
+  589 op mul *tmp108 :compute:zy :compute:zy
+  590 op sub *tmp109 *tmp107 *tmp108
+  591 op add :compute:zx *tmp109 :compute:cx
+  592 op mul *tmp111 2 :compute:x1
+  593 op mul *tmp112 *tmp111 :compute:zy
+  594 op add :compute:zy *tmp112 :compute:cy
+  595 op len :compute:dist :compute:zx :compute:zy
+  596 jump *label222 lessThan :compute:dist 64
+  597 jump *label65 always
+  598 label *label222
+  599 label *label223
+  600 label *label224
+  601 op add :compute:i :compute:i 1
+  602 set :compute:x1 :compute:zx
+  603 op mul *tmp107 :compute:zx :compute:zx
+  604 op mul *tmp108 :compute:zy :compute:zy
+  605 op sub *tmp109 *tmp107 *tmp108
+  606 op add :compute:zx *tmp109 :compute:cx
+  607 op mul *tmp111 2 :compute:x1
+  608 op mul *tmp112 *tmp111 :compute:zy
+  609 op add :compute:zy *tmp112 :compute:cy
+  610 op len :compute:dist :compute:zx :compute:zy
+  611 jump *label225 lessThan :compute:dist 64
+  612 jump *label65 always
+  613 label *label225
+  614 label *label226
+  615 label *label227
+  616 op add :compute:i :compute:i 1
+  617 set :compute:x1 :compute:zx
+  618 op mul *tmp107 :compute:zx :compute:zx
+  619 op mul *tmp108 :compute:zy :compute:zy
+  620 op sub *tmp109 *tmp107 *tmp108
+  621 op add :compute:zx *tmp109 :compute:cx
+  622 op mul *tmp111 2 :compute:x1
+  623 op mul *tmp112 *tmp111 :compute:zy
+  624 op add :compute:zy *tmp112 :compute:cy
+  625 op len :compute:dist :compute:zx :compute:zy
+  626 jump *label228 lessThan :compute:dist 64
+  627 jump *label65 always
+  628 label *label228
+  629 label *label229
+  630 label *label230
+  631 op add :compute:i :compute:i 1
+  632 set :compute:x1 :compute:zx
+  633 op mul *tmp107 :compute:zx :compute:zx
+  634 op mul *tmp108 :compute:zy :compute:zy
+  635 op sub *tmp109 *tmp107 *tmp108
+  636 op add :compute:zx *tmp109 :compute:cx
+  637 op mul *tmp111 2 :compute:x1
+  638 op mul *tmp112 *tmp111 :compute:zy
+  639 op add :compute:zy *tmp112 :compute:cy
+  640 op len :compute:dist :compute:zx :compute:zy
+  641 jump *label231 lessThan :compute:dist 64
+  642 jump *label65 always
+  643 label *label231
+  644 label *label232
+  645 label *label233
+  646 op add :compute:i :compute:i 1
+  647 set :compute:x1 :compute:zx
+  648 op mul *tmp107 :compute:zx :compute:zx
+  649 op mul *tmp108 :compute:zy :compute:zy
+  650 op sub *tmp109 *tmp107 *tmp108
+  651 op add :compute:zx *tmp109 :compute:cx
+  652 op mul *tmp111 2 :compute:x1
+  653 op mul *tmp112 *tmp111 :compute:zy
+  654 op add :compute:zy *tmp112 :compute:cy
+  655 op len :compute:dist :compute:zx :compute:zy
+  656 jump *label234 lessThan :compute:dist 64
+  657 jump *label65 always
+  658 label *label234
+  659 label *label235
+  660 label *label236
+  661 op add :compute:i :compute:i 1
+  662 set :compute:x1 :compute:zx
+  663 op mul *tmp107 :compute:zx :compute:zx
+  664 op mul *tmp108 :compute:zy :compute:zy
+  665 op sub *tmp109 *tmp107 *tmp108
+  666 op add :compute:zx *tmp109 :compute:cx
+  667 op mul *tmp111 2 :compute:x1
+  668 op mul *tmp112 *tmp111 :compute:zy
+  669 op add :compute:zy *tmp112 :compute:cy
+  670 op len :compute:dist :compute:zx :compute:zy
+  671 jump *label237 lessThan :compute:dist 64
+  672 jump *label65 always
+  673 label *label237
+  674 label *label238
+  675 label *label239
+  676 op add :compute:i :compute:i 1
+  677 set :compute:x1 :compute:zx
+  678 op mul *tmp107 :compute:zx :compute:zx
+  679 op mul *tmp108 :compute:zy :compute:zy
+  680 op sub *tmp109 *tmp107 *tmp108
+  681 op add :compute:zx *tmp109 :compute:cx
+  682 op mul *tmp111 2 :compute:x1
+  683 op mul *tmp112 *tmp111 :compute:zy
+  684 op add :compute:zy *tmp112 :compute:cy
+  685 op len :compute:dist :compute:zx :compute:zy
+  686 jump *label240 lessThan :compute:dist 64
+  687 jump *label65 always
+  688 label *label240
+  689 label *label241
+  690 label *label242
+  691 op add :compute:i :compute:i 1
+  692 set :compute:x1 :compute:zx
+  693 op mul *tmp107 :compute:zx :compute:zx
+  694 op mul *tmp108 :compute:zy :compute:zy
+  695 op sub *tmp109 *tmp107 *tmp108
+  696 op add :compute:zx *tmp109 :compute:cx
+  697 op mul *tmp111 2 :compute:x1
+  698 op mul *tmp112 *tmp111 :compute:zy
+  699 op add :compute:zy *tmp112 :compute:cy
+  700 op len :compute:dist :compute:zx :compute:zy
+  701 jump *label243 lessThan :compute:dist 64
+  702 jump *label65 always
+  703 label *label243
+  704 label *label244
+  705 label *label245
+  706 op add :compute:i :compute:i 1
+  707 set :compute:x1 :compute:zx
+  708 op mul *tmp107 :compute:zx :compute:zx
+  709 op mul *tmp108 :compute:zy :compute:zy
+  710 op sub *tmp109 *tmp107 *tmp108
+  711 op add :compute:zx *tmp109 :compute:cx
+  712 op mul *tmp111 2 :compute:x1
+  713 op mul *tmp112 *tmp111 :compute:zy
+  714 op add :compute:zy *tmp112 :compute:cy
+  715 op len :compute:dist :compute:zx :compute:zy
+  716 jump *label246 lessThan :compute:dist 64
+  717 jump *label65 always
+  718 label *label246
+  719 label *label247
+  720 label *label248
+  721 op add :compute:i :compute:i 1
+  722 set :compute:x1 :compute:zx
+  723 op mul *tmp107 :compute:zx :compute:zx
+  724 op mul *tmp108 :compute:zy :compute:zy
+  725 op sub *tmp109 *tmp107 *tmp108
+  726 op add :compute:zx *tmp109 :compute:cx
+  727 op mul *tmp111 2 :compute:x1
+  728 op mul *tmp112 *tmp111 :compute:zy
+  729 op add :compute:zy *tmp112 :compute:cy
+  730 op len :compute:dist :compute:zx :compute:zy
+  731 jump *label249 lessThan :compute:dist 64
+  732 jump *label65 always
+  733 label *label249
+  734 label *label250
+  735 label *label251
+  736 op add :compute:i :compute:i 1
+  737 set :compute:x1 :compute:zx
+  738 op mul *tmp107 :compute:zx :compute:zx
+  739 op mul *tmp108 :compute:zy :compute:zy
+  740 op sub *tmp109 *tmp107 *tmp108
+  741 op add :compute:zx *tmp109 :compute:cx
+  742 op mul *tmp111 2 :compute:x1
+  743 op mul *tmp112 *tmp111 :compute:zy
+  744 op add :compute:zy *tmp112 :compute:cy
+  745 op len :compute:dist :compute:zx :compute:zy
+  746 jump *label252 lessThan :compute:dist 64
+  747 jump *label65 always
+  748 label *label252
+  749 label *label253
+  750 label *label254
+  751 op add :compute:i :compute:i 1
+  752 set :compute:x1 :compute:zx
+  753 op mul *tmp107 :compute:zx :compute:zx
+  754 op mul *tmp108 :compute:zy :compute:zy
+  755 op sub *tmp109 *tmp107 *tmp108
+  756 op add :compute:zx *tmp109 :compute:cx
+  757 op mul *tmp111 2 :compute:x1
+  758 op mul *tmp112 *tmp111 :compute:zy
+  759 op add :compute:zy *tmp112 :compute:cy
+  760 op len :compute:dist :compute:zx :compute:zy
+  761 jump *label255 lessThan :compute:dist 64
+  762 jump *label65 always
+  763 label *label255
+  764 label *label256
+  765 label *label257
+  766 op add :compute:i :compute:i 1
+  767 set :compute:x1 :compute:zx
+  768 op mul *tmp107 :compute:zx :compute:zx
+  769 op mul *tmp108 :compute:zy :compute:zy
+  770 op sub *tmp109 *tmp107 *tmp108
+  771 op add :compute:zx *tmp109 :compute:cx
+  772 op mul *tmp111 2 :compute:x1
+  773 op mul *tmp112 *tmp111 :compute:zy
+  774 op add :compute:zy *tmp112 :compute:cy
+  775 op len :compute:dist :compute:zx :compute:zy
+  776 jump *label258 lessThan :compute:dist 64
+  777 jump *label65 always
+  778 label *label258
+  779 label *label259
+  780 label *label260
+  781 op add :compute:i :compute:i 1
+  782 set :compute:x1 :compute:zx
+  783 op mul *tmp107 :compute:zx :compute:zx
+  784 op mul *tmp108 :compute:zy :compute:zy
+  785 op sub *tmp109 *tmp107 *tmp108
+  786 op add :compute:zx *tmp109 :compute:cx
+  787 op mul *tmp111 2 :compute:x1
+  788 op mul *tmp112 *tmp111 :compute:zy
+  789 op add :compute:zy *tmp112 :compute:cy
+  790 op len :compute:dist :compute:zx :compute:zy
+  791 jump *label261 lessThan :compute:dist 64
+  792 jump *label65 always
+  793 label *label261
+  794 label *label262
+  795 label *label263
+  796 op add :compute:i :compute:i 1
+  797 set :compute:x1 :compute:zx
+  798 op mul *tmp107 :compute:zx :compute:zx
+  799 op mul *tmp108 :compute:zy :compute:zy
+  800 op sub *tmp109 *tmp107 *tmp108
+  801 op add :compute:zx *tmp109 :compute:cx
+  802 op mul *tmp111 2 :compute:x1
+  803 op mul *tmp112 *tmp111 :compute:zy
+  804 op add :compute:zy *tmp112 :compute:cy
+  805 op len :compute:dist :compute:zx :compute:zy
+  806 jump *label264 lessThan :compute:dist 64
+  807 jump *label65 always
+  808 label *label264
+  809 label *label265
+  810 label *label266
+  811 op add :compute:i :compute:i 1
+  812 set :compute:x1 :compute:zx
+  813 op mul *tmp107 :compute:zx :compute:zx
+  814 op mul *tmp108 :compute:zy :compute:zy
+  815 op sub *tmp109 *tmp107 *tmp108
+  816 op add :compute:zx *tmp109 :compute:cx
+  817 op mul *tmp111 2 :compute:x1
+  818 op mul *tmp112 *tmp111 :compute:zy
+  819 op add :compute:zy *tmp112 :compute:cy
+  820 op len :compute:dist :compute:zx :compute:zy
+  821 jump *label267 lessThan :compute:dist 64
+  822 jump *label65 always
+  823 label *label267
+  824 label *label268
+  825 label *label269
+  826 op add :compute:i :compute:i 1
+  827 set :compute:x1 :compute:zx
+  828 op mul *tmp107 :compute:zx :compute:zx
+  829 op mul *tmp108 :compute:zy :compute:zy
+  830 op sub *tmp109 *tmp107 *tmp108
+  831 op add :compute:zx *tmp109 :compute:cx
+  832 op mul *tmp111 2 :compute:x1
+  833 op mul *tmp112 *tmp111 :compute:zy
+  834 op add :compute:zy *tmp112 :compute:cy
+  835 op len :compute:dist :compute:zx :compute:zy
+  836 jump *label270 lessThan :compute:dist 64
+  837 jump *label65 always
+  838 label *label270
+  839 label *label271
+  840 label *label272
+  841 op add :compute:i :compute:i 1
+  842 set :compute:x1 :compute:zx
+  843 op mul *tmp107 :compute:zx :compute:zx
+  844 op mul *tmp108 :compute:zy :compute:zy
+  845 op sub *tmp109 *tmp107 *tmp108
+  846 op add :compute:zx *tmp109 :compute:cx
+  847 op mul *tmp111 2 :compute:x1
+  848 op mul *tmp112 *tmp111 :compute:zy
+  849 op add :compute:zy *tmp112 :compute:cy
+  850 op len :compute:dist :compute:zx :compute:zy
+  851 jump *label273 lessThan :compute:dist 64
+  852 jump *label65 always
+  853 label *label273
+  854 label *label274
+  855 label *label275
+  856 op add :compute:i :compute:i 1
+  857 set :compute:x1 :compute:zx
+  858 op mul *tmp107 :compute:zx :compute:zx
+  859 op mul *tmp108 :compute:zy :compute:zy
+  860 op sub *tmp109 *tmp107 *tmp108
+  861 op add :compute:zx *tmp109 :compute:cx
+  862 op mul *tmp111 2 :compute:x1
+  863 op mul *tmp112 *tmp111 :compute:zy
+  864 op add :compute:zy *tmp112 :compute:cy
+  865 op len :compute:dist :compute:zx :compute:zy
+  866 jump *label276 lessThan :compute:dist 64
+  867 jump *label65 always
+  868 label *label276
+  869 label *label277
+  870 label *label278
+  871 op add :compute:i :compute:i 1
+  872 set :compute:x1 :compute:zx
+  873 op mul *tmp107 :compute:zx :compute:zx
+  874 op mul *tmp108 :compute:zy :compute:zy
+  875 op sub *tmp109 *tmp107 *tmp108
+  876 op add :compute:zx *tmp109 :compute:cx
+  877 op mul *tmp111 2 :compute:x1
+  878 op mul *tmp112 *tmp111 :compute:zy
+  879 op add :compute:zy *tmp112 :compute:cy
+  880 op len :compute:dist :compute:zx :compute:zy
+  881 jump *label279 lessThan :compute:dist 64
+  882 jump *label65 always
+  883 label *label279
+  884 label *label280
+  885 label *label281
+  886 op add :compute:i :compute:i 1
+  887 set :compute:x1 :compute:zx
+  888 op mul *tmp107 :compute:zx :compute:zx
+  889 op mul *tmp108 :compute:zy :compute:zy
+  890 op sub *tmp109 *tmp107 *tmp108
+  891 op add :compute:zx *tmp109 :compute:cx
+  892 op mul *tmp111 2 :compute:x1
+  893 op mul *tmp112 *tmp111 :compute:zy
+  894 op add :compute:zy *tmp112 :compute:cy
+  895 op len :compute:dist :compute:zx :compute:zy
+  896 jump *label282 lessThan :compute:dist 64
+  897 jump *label65 always
+  898 label *label282
+  899 label *label283
+  900 label *label284
+  901 op add :compute:i :compute:i 1
+  902 set :compute:x1 :compute:zx
+  903 op mul *tmp107 :compute:zx :compute:zx
+  904 op mul *tmp108 :compute:zy :compute:zy
+  905 op sub *tmp109 *tmp107 *tmp108
+  906 op add :compute:zx *tmp109 :compute:cx
+  907 op mul *tmp111 2 :compute:x1
+  908 op mul *tmp112 *tmp111 :compute:zy
+  909 op add :compute:zy *tmp112 :compute:cy
+  910 op len :compute:dist :compute:zx :compute:zy
+  911 jump *label285 lessThan :compute:dist 64
+  912 jump *label65 always
+  913 label *label285
+  914 label *label286
+  915 label *label287
+  916 op add :compute:i :compute:i 1
+  917 set :compute:x1 :compute:zx
+  918 op mul *tmp107 :compute:zx :compute:zx
+  919 op mul *tmp108 :compute:zy :compute:zy
+  920 op sub *tmp109 *tmp107 *tmp108
+  921 op add :compute:zx *tmp109 :compute:cx
+  922 op mul *tmp111 2 :compute:x1
+  923 op mul *tmp112 *tmp111 :compute:zy
+  924 op add :compute:zy *tmp112 :compute:cy
+  925 op len :compute:dist :compute:zx :compute:zy
+  926 jump *label288 lessThan :compute:dist 64
+  927 jump *label65 always
+  928 label *label288
+  929 label *label289
+  930 label *label290
+  931 op add :compute:i :compute:i 1
+  932 set :compute:x1 :compute:zx
+  933 op mul *tmp107 :compute:zx :compute:zx
+  934 op mul *tmp108 :compute:zy :compute:zy
+  935 op sub *tmp109 *tmp107 *tmp108
+  936 op add :compute:zx *tmp109 :compute:cx
+  937 op mul *tmp111 2 :compute:x1
+  938 op mul *tmp112 *tmp111 :compute:zy
+  939 op add :compute:zy *tmp112 :compute:cy
+  940 op len :compute:dist :compute:zx :compute:zy
+  941 jump *label291 lessThan :compute:dist 64
+  942 jump *label65 always
+  943 label *label291
+  944 label *label292
+  945 label *label293
+  946 op add :compute:i :compute:i 1
+  947 set :compute:x1 :compute:zx
+  948 op mul *tmp107 :compute:zx :compute:zx
+  949 op mul *tmp108 :compute:zy :compute:zy
+  950 op sub *tmp109 *tmp107 *tmp108
+  951 op add :compute:zx *tmp109 :compute:cx
+  952 op mul *tmp111 2 :compute:x1
+  953 op mul *tmp112 *tmp111 :compute:zy
+  954 op add :compute:zy *tmp112 :compute:cy
+  955 op len :compute:dist :compute:zx :compute:zy
+  956 jump *label294 lessThan :compute:dist 64
+  957 jump *label65 always
+  958 label *label294
+  959 label *label295
+  960 label *label296
+  961 op add :compute:i :compute:i 1
+  962 set :compute:x1 :compute:zx
+  963 op mul *tmp107 :compute:zx :compute:zx
+  964 op mul *tmp108 :compute:zy :compute:zy
+  965 op sub *tmp109 *tmp107 *tmp108
+  966 op add :compute:zx *tmp109 :compute:cx
+  967 op mul *tmp111 2 :compute:x1
+  968 op mul *tmp112 *tmp111 :compute:zy
+  969 op add :compute:zy *tmp112 :compute:cy
+  970 op len :compute:dist :compute:zx :compute:zy
+  971 jump *label297 lessThan :compute:dist 64
+  972 jump *label65 always
+  973 label *label297
+  974 label *label298
+  975 label *label299
+  976 op add :compute:i :compute:i 1
+  977 set :compute:x1 :compute:zx
+  978 op mul *tmp107 :compute:zx :compute:zx
+  979 op mul *tmp108 :compute:zy :compute:zy
+  980 op sub *tmp109 *tmp107 *tmp108
+  981 op add :compute:zx *tmp109 :compute:cx
+  982 op mul *tmp111 2 :compute:x1
+  983 op mul *tmp112 *tmp111 :compute:zy
+  984 op add :compute:zy *tmp112 :compute:cy
+  985 op len :compute:dist :compute:zx :compute:zy
+  986 jump *label300 lessThan :compute:dist 64
+  987 jump *label65 always
+  988 label *label300
+  989 label *label301
+  990 label *label302
+  991 op add :compute:i :compute:i 1
+  992 set :compute:x1 :compute:zx
+  993 op mul *tmp107 :compute:zx :compute:zx
+  994 op mul *tmp108 :compute:zy :compute:zy
+  995 op sub *tmp109 *tmp107 *tmp108
+  996 op add :compute:zx *tmp109 :compute:cx
+  997 op mul *tmp111 2 :compute:x1
+  998 op mul *tmp112 *tmp111 :compute:zy
+  999 op add :compute:zy *tmp112 :compute:cy
+ 1000 op len :compute:dist :compute:zx :compute:zy
+ 1001 jump *label303 lessThan :compute:dist 64
+ 1002 jump *label65 always
+ 1003 label *label303
+ 1004 label *label304
+ 1005 label *label305
+ 1006 op add :compute:i :compute:i 1
+ 1007 set :compute:x1 :compute:zx
+ 1008 op mul *tmp107 :compute:zx :compute:zx
+ 1009 op mul *tmp108 :compute:zy :compute:zy
+ 1010 op sub *tmp109 *tmp107 *tmp108
+ 1011 op add :compute:zx *tmp109 :compute:cx
+ 1012 op mul *tmp111 2 :compute:x1
+ 1013 op mul *tmp112 *tmp111 :compute:zy
+ 1014 op add :compute:zy *tmp112 :compute:cy
+ 1015 op len :compute:dist :compute:zx :compute:zy
+ 1016 jump *label306 lessThan :compute:dist 64
+ 1017 jump *label65 always
+ 1018 label *label306
+ 1019 label *label307
+ 1020 label *label308
+ 1021 op add :compute:i :compute:i 1
+ 1022 set :compute:x1 :compute:zx
+ 1023 op mul *tmp107 :compute:zx :compute:zx
+ 1024 op mul *tmp108 :compute:zy :compute:zy
+ 1025 op sub *tmp109 *tmp107 *tmp108
+ 1026 op add :compute:zx *tmp109 :compute:cx
+ 1027 op mul *tmp111 2 :compute:x1
+ 1028 op mul *tmp112 *tmp111 :compute:zy
+ 1029 op add :compute:zy *tmp112 :compute:cy
+ 1030 op len :compute:dist :compute:zx :compute:zy
+ 1031 jump *label309 lessThan :compute:dist 64
+ 1032 jump *label65 always
+ 1033 label *label309
+ 1034 label *label310
+ 1035 label *label311
+ 1036 op add :compute:i :compute:i 1
+ 1037 set :compute:x1 :compute:zx
+ 1038 op mul *tmp107 :compute:zx :compute:zx
+ 1039 op mul *tmp108 :compute:zy :compute:zy
+ 1040 op sub *tmp109 *tmp107 *tmp108
+ 1041 op add :compute:zx *tmp109 :compute:cx
+ 1042 op mul *tmp111 2 :compute:x1
+ 1043 op mul *tmp112 *tmp111 :compute:zy
+ 1044 op add :compute:zy *tmp112 :compute:cy
+ 1045 op len :compute:dist :compute:zx :compute:zy
+ 1046 jump *label312 lessThan :compute:dist 64
+ 1047 jump *label65 always
+ 1048 label *label312
+ 1049 label *label313
+ 1050 label *label314
+ 1051 op add :compute:i :compute:i 1
+ 1052 set :compute:x1 :compute:zx
+ 1053 op mul *tmp107 :compute:zx :compute:zx
+ 1054 op mul *tmp108 :compute:zy :compute:zy
+ 1055 op sub *tmp109 *tmp107 *tmp108
+ 1056 op add :compute:zx *tmp109 :compute:cx
+ 1057 op mul *tmp111 2 :compute:x1
+ 1058 op mul *tmp112 *tmp111 :compute:zy
+ 1059 op add :compute:zy *tmp112 :compute:cy
+ 1060 op len :compute:dist :compute:zx :compute:zy
+ 1061 jump *label315 lessThan :compute:dist 64
+ 1062 jump *label65 always
+ 1063 label *label315
+ 1064 label *label316
+ 1065 label *label317
+ 1066 op add :compute:i :compute:i 1
+ 1067 set :compute:x1 :compute:zx
+ 1068 op mul *tmp107 :compute:zx :compute:zx
+ 1069 op mul *tmp108 :compute:zy :compute:zy
+ 1070 op sub *tmp109 *tmp107 *tmp108
+ 1071 op add :compute:zx *tmp109 :compute:cx
+ 1072 op mul *tmp111 2 :compute:x1
+ 1073 op mul *tmp112 *tmp111 :compute:zy
+ 1074 op add :compute:zy *tmp112 :compute:cy
+ 1075 op len :compute:dist :compute:zx :compute:zy
+ 1076 jump *label318 lessThan :compute:dist 64
+ 1077 jump *label65 always
+ 1078 label *label318
+ 1079 label *label319
+ 1080 label *label320
+ 1081 op add :compute:i :compute:i 1
+ 1082 set :compute:x1 :compute:zx
+ 1083 op mul *tmp107 :compute:zx :compute:zx
+ 1084 op mul *tmp108 :compute:zy :compute:zy
+ 1085 op sub *tmp109 *tmp107 *tmp108
+ 1086 op add :compute:zx *tmp109 :compute:cx
+ 1087 op mul *tmp111 2 :compute:x1
+ 1088 op mul *tmp112 *tmp111 :compute:zy
+ 1089 op add :compute:zy *tmp112 :compute:cy
+ 1090 op len :compute:dist :compute:zx :compute:zy
+ 1091 jump *label321 lessThan :compute:dist 64
+ 1092 jump *label65 always
+ 1093 label *label321
+ 1094 label *label322
+ 1095 label *label323
+ 1096 op add :compute:i :compute:i 1
+ 1097 set :compute:x1 :compute:zx
+ 1098 op mul *tmp107 :compute:zx :compute:zx
+ 1099 op mul *tmp108 :compute:zy :compute:zy
+ 1100 op sub *tmp109 *tmp107 *tmp108
+ 1101 op add :compute:zx *tmp109 :compute:cx
+ 1102 op mul *tmp111 2 :compute:x1
+ 1103 op mul *tmp112 *tmp111 :compute:zy
+ 1104 op add :compute:zy *tmp112 :compute:cy
+ 1105 op len :compute:dist :compute:zx :compute:zy
+ 1106 jump *label324 lessThan :compute:dist 64
+ 1107 jump *label65 always
+ 1108 label *label324
+ 1109 label *label325
+ 1110 label *label326
+ 1111 op add :compute:i :compute:i 1
+ 1112 label *label65
  1113 jump *label68 lessThanEq .PALETTE 1
  1114 jump *label68 greaterThanEq :compute:i 63
  1115 op log *tmp119 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   178 label *label138
   179 label *label139
   180 label *label140
-    * op add :compute:i :compute:i 1
+  181 op add :compute:i 0 1
   182 set :compute:x1 :compute:zx
   183 op mul *tmp107 :compute:zx :compute:zx
   184 op mul *tmp108 :compute:zy :compute:zy
 
   193 label *label141
   194 label *label142
   195 label *label143
-    * op add :compute:i :compute:i 1
+  196 op add :compute:i 1 1
   197 set :compute:x1 :compute:zx
   198 op mul *tmp107 :compute:zx :compute:zx
   199 op mul *tmp108 :compute:zy :compute:zy
 
   208 label *label144
   209 label *label145
   210 label *label146
-    * op add :compute:i :compute:i 1
+  211 op add :compute:i 2 1
   212 set :compute:x1 :compute:zx
   213 op mul *tmp107 :compute:zx :compute:zx
   214 op mul *tmp108 :compute:zy :compute:zy
 
   223 label *label147
   224 label *label148
   225 label *label149
-    * op add :compute:i :compute:i 1
+  226 op add :compute:i 3 1
   227 set :compute:x1 :compute:zx
   228 op mul *tmp107 :compute:zx :compute:zx
   229 op mul *tmp108 :compute:zy :compute:zy
 
   238 label *label150
   239 label *label151
   240 label *label152
-    * op add :compute:i :compute:i 1
+  241 op add :compute:i 4 1
   242 set :compute:x1 :compute:zx
   243 op mul *tmp107 :compute:zx :compute:zx
   244 op mul *tmp108 :compute:zy :compute:zy
 
   253 label *label153
   254 label *label154
   255 label *label155
-    * op add :compute:i :compute:i 1
+  256 op add :compute:i 5 1
   257 set :compute:x1 :compute:zx
   258 op mul *tmp107 :compute:zx :compute:zx
   259 op mul *tmp108 :compute:zy :compute:zy
 
   268 label *label156
   269 label *label157
   270 label *label158
-    * op add :compute:i :compute:i 1
+  271 op add :compute:i 6 1
   272 set :compute:x1 :compute:zx
   273 op mul *tmp107 :compute:zx :compute:zx
   274 op mul *tmp108 :compute:zy :compute:zy
 
   283 label *label159
   284 label *label160
   285 label *label161
-    * op add :compute:i :compute:i 1
+  286 op add :compute:i 7 1
   287 set :compute:x1 :compute:zx
   288 op mul *tmp107 :compute:zx :compute:zx
   289 op mul *tmp108 :compute:zy :compute:zy
 
   298 label *label162
   299 label *label163
   300 label *label164
-    * op add :compute:i :compute:i 1
+  301 op add :compute:i 8 1
   302 set :compute:x1 :compute:zx
   303 op mul *tmp107 :compute:zx :compute:zx
   304 op mul *tmp108 :compute:zy :compute:zy
 
   313 label *label165
   314 label *label166
   315 label *label167
-    * op add :compute:i :compute:i 1
+  316 op add :compute:i 9 1
   317 set :compute:x1 :compute:zx
   318 op mul *tmp107 :compute:zx :compute:zx
   319 op mul *tmp108 :compute:zy :compute:zy
 
   328 label *label168
   329 label *label169
   330 label *label170
-    * op add :compute:i :compute:i 1
+  331 op add :compute:i 10 1
   332 set :compute:x1 :compute:zx
   333 op mul *tmp107 :compute:zx :compute:zx
   334 op mul *tmp108 :compute:zy :compute:zy
 
   343 label *label171
   344 label *label172
   345 label *label173
-    * op add :compute:i :compute:i 1
+  346 op add :compute:i 11 1
   347 set :compute:x1 :compute:zx
   348 op mul *tmp107 :compute:zx :compute:zx
   349 op mul *tmp108 :compute:zy :compute:zy
 
   358 label *label174
   359 label *label175
   360 label *label176
-    * op add :compute:i :compute:i 1
+  361 op add :compute:i 12 1
   362 set :compute:x1 :compute:zx
   363 op mul *tmp107 :compute:zx :compute:zx
   364 op mul *tmp108 :compute:zy :compute:zy
 
   373 label *label177
   374 label *label178
   375 label *label179
-    * op add :compute:i :compute:i 1
+  376 op add :compute:i 13 1
   377 set :compute:x1 :compute:zx
   378 op mul *tmp107 :compute:zx :compute:zx
   379 op mul *tmp108 :compute:zy :compute:zy
 
   388 label *label180
   389 label *label181
   390 label *label182
-    * op add :compute:i :compute:i 1
+  391 op add :compute:i 14 1
   392 set :compute:x1 :compute:zx
   393 op mul *tmp107 :compute:zx :compute:zx
   394 op mul *tmp108 :compute:zy :compute:zy
 
   403 label *label183
   404 label *label184
   405 label *label185
-    * op add :compute:i :compute:i 1
+  406 op add :compute:i 15 1
   407 set :compute:x1 :compute:zx
   408 op mul *tmp107 :compute:zx :compute:zx
   409 op mul *tmp108 :compute:zy :compute:zy
 
   418 label *label186
   419 label *label187
   420 label *label188
-    * op add :compute:i :compute:i 1
+  421 op add :compute:i 16 1
   422 set :compute:x1 :compute:zx
   423 op mul *tmp107 :compute:zx :compute:zx
   424 op mul *tmp108 :compute:zy :compute:zy
 
   433 label *label189
   434 label *label190
   435 label *label191
-    * op add :compute:i :compute:i 1
+  436 op add :compute:i 17 1
   437 set :compute:x1 :compute:zx
   438 op mul *tmp107 :compute:zx :compute:zx
   439 op mul *tmp108 :compute:zy :compute:zy
 
   448 label *label192
   449 label *label193
   450 label *label194
-    * op add :compute:i :compute:i 1
+  451 op add :compute:i 18 1
   452 set :compute:x1 :compute:zx
   453 op mul *tmp107 :compute:zx :compute:zx
   454 op mul *tmp108 :compute:zy :compute:zy
 
   463 label *label195
   464 label *label196
   465 label *label197
-    * op add :compute:i :compute:i 1
+  466 op add :compute:i 19 1
   467 set :compute:x1 :compute:zx
   468 op mul *tmp107 :compute:zx :compute:zx
   469 op mul *tmp108 :compute:zy :compute:zy
 
   478 label *label198
   479 label *label199
   480 label *label200
-    * op add :compute:i :compute:i 1
+  481 op add :compute:i 20 1
   482 set :compute:x1 :compute:zx
   483 op mul *tmp107 :compute:zx :compute:zx
   484 op mul *tmp108 :compute:zy :compute:zy
 
   493 label *label201
   494 label *label202
   495 label *label203
-    * op add :compute:i :compute:i 1
+  496 op add :compute:i 21 1
   497 set :compute:x1 :compute:zx
   498 op mul *tmp107 :compute:zx :compute:zx
   499 op mul *tmp108 :compute:zy :compute:zy
 
   508 label *label204
   509 label *label205
   510 label *label206
-    * op add :compute:i :compute:i 1
+  511 op add :compute:i 22 1
   512 set :compute:x1 :compute:zx
   513 op mul *tmp107 :compute:zx :compute:zx
   514 op mul *tmp108 :compute:zy :compute:zy
 
   523 label *label207
   524 label *label208
   525 label *label209
-    * op add :compute:i :compute:i 1
+  526 op add :compute:i 23 1
   527 set :compute:x1 :compute:zx
   528 op mul *tmp107 :compute:zx :compute:zx
   529 op mul *tmp108 :compute:zy :compute:zy
 
   538 label *label210
   539 label *label211
   540 label *label212
-    * op add :compute:i :compute:i 1
+  541 op add :compute:i 24 1
   542 set :compute:x1 :compute:zx
   543 op mul *tmp107 :compute:zx :compute:zx
   544 op mul *tmp108 :compute:zy :compute:zy
 
   553 label *label213
   554 label *label214
   555 label *label215
-    * op add :compute:i :compute:i 1
+  556 op add :compute:i 25 1
   557 set :compute:x1 :compute:zx
   558 op mul *tmp107 :compute:zx :compute:zx
   559 op mul *tmp108 :compute:zy :compute:zy
 
   568 label *label216
   569 label *label217
   570 label *label218
-    * op add :compute:i :compute:i 1
+  571 op add :compute:i 26 1
   572 set :compute:x1 :compute:zx
   573 op mul *tmp107 :compute:zx :compute:zx
   574 op mul *tmp108 :compute:zy :compute:zy
 
   583 label *label219
   584 label *label220
   585 label *label221
-    * op add :compute:i :compute:i 1
+  586 op add :compute:i 27 1
   587 set :compute:x1 :compute:zx
   588 op mul *tmp107 :compute:zx :compute:zx
   589 op mul *tmp108 :compute:zy :compute:zy
 
   598 label *label222
   599 label *label223
   600 label *label224
-    * op add :compute:i :compute:i 1
+  601 op add :compute:i 28 1
   602 set :compute:x1 :compute:zx
   603 op mul *tmp107 :compute:zx :compute:zx
   604 op mul *tmp108 :compute:zy :compute:zy
 
   613 label *label225
   614 label *label226
   615 label *label227
-    * op add :compute:i :compute:i 1
+  616 op add :compute:i 29 1
   617 set :compute:x1 :compute:zx
   618 op mul *tmp107 :compute:zx :compute:zx
   619 op mul *tmp108 :compute:zy :compute:zy
 
   628 label *label228
   629 label *label229
   630 label *label230
-    * op add :compute:i :compute:i 1
+  631 op add :compute:i 30 1
   632 set :compute:x1 :compute:zx
   633 op mul *tmp107 :compute:zx :compute:zx
   634 op mul *tmp108 :compute:zy :compute:zy
 
   643 label *label231
   644 label *label232
   645 label *label233
-    * op add :compute:i :compute:i 1
+  646 op add :compute:i 31 1
   647 set :compute:x1 :compute:zx
   648 op mul *tmp107 :compute:zx :compute:zx
   649 op mul *tmp108 :compute:zy :compute:zy
 
   658 label *label234
   659 label *label235
   660 label *label236
-    * op add :compute:i :compute:i 1
+  661 op add :compute:i 32 1
   662 set :compute:x1 :compute:zx
   663 op mul *tmp107 :compute:zx :compute:zx
   664 op mul *tmp108 :compute:zy :compute:zy
 
   673 label *label237
   674 label *label238
   675 label *label239
-    * op add :compute:i :compute:i 1
+  676 op add :compute:i 33 1
   677 set :compute:x1 :compute:zx
   678 op mul *tmp107 :compute:zx :compute:zx
   679 op mul *tmp108 :compute:zy :compute:zy
 
   688 label *label240
   689 label *label241
   690 label *label242
-    * op add :compute:i :compute:i 1
+  691 op add :compute:i 34 1
   692 set :compute:x1 :compute:zx
   693 op mul *tmp107 :compute:zx :compute:zx
   694 op mul *tmp108 :compute:zy :compute:zy
 
   703 label *label243
   704 label *label244
   705 label *label245
-    * op add :compute:i :compute:i 1
+  706 op add :compute:i 35 1
   707 set :compute:x1 :compute:zx
   708 op mul *tmp107 :compute:zx :compute:zx
   709 op mul *tmp108 :compute:zy :compute:zy
 
   718 label *label246
   719 label *label247
   720 label *label248
-    * op add :compute:i :compute:i 1
+  721 op add :compute:i 36 1
   722 set :compute:x1 :compute:zx
   723 op mul *tmp107 :compute:zx :compute:zx
   724 op mul *tmp108 :compute:zy :compute:zy
 
   733 label *label249
   734 label *label250
   735 label *label251
-    * op add :compute:i :compute:i 1
+  736 op add :compute:i 37 1
   737 set :compute:x1 :compute:zx
   738 op mul *tmp107 :compute:zx :compute:zx
   739 op mul *tmp108 :compute:zy :compute:zy
 
   748 label *label252
   749 label *label253
   750 label *label254
-    * op add :compute:i :compute:i 1
+  751 op add :compute:i 38 1
   752 set :compute:x1 :compute:zx
   753 op mul *tmp107 :compute:zx :compute:zx
   754 op mul *tmp108 :compute:zy :compute:zy
 
   763 label *label255
   764 label *label256
   765 label *label257
-    * op add :compute:i :compute:i 1
+  766 op add :compute:i 39 1
   767 set :compute:x1 :compute:zx
   768 op mul *tmp107 :compute:zx :compute:zx
   769 op mul *tmp108 :compute:zy :compute:zy
 
   778 label *label258
   779 label *label259
   780 label *label260
-    * op add :compute:i :compute:i 1
+  781 op add :compute:i 40 1
   782 set :compute:x1 :compute:zx
   783 op mul *tmp107 :compute:zx :compute:zx
   784 op mul *tmp108 :compute:zy :compute:zy
 
   793 label *label261
   794 label *label262
   795 label *label263
-    * op add :compute:i :compute:i 1
+  796 op add :compute:i 41 1
   797 set :compute:x1 :compute:zx
   798 op mul *tmp107 :compute:zx :compute:zx
   799 op mul *tmp108 :compute:zy :compute:zy
 
   808 label *label264
   809 label *label265
   810 label *label266
-    * op add :compute:i :compute:i 1
+  811 op add :compute:i 42 1
   812 set :compute:x1 :compute:zx
   813 op mul *tmp107 :compute:zx :compute:zx
   814 op mul *tmp108 :compute:zy :compute:zy
 
   823 label *label267
   824 label *label268
   825 label *label269
-    * op add :compute:i :compute:i 1
+  826 op add :compute:i 43 1
   827 set :compute:x1 :compute:zx
   828 op mul *tmp107 :compute:zx :compute:zx
   829 op mul *tmp108 :compute:zy :compute:zy
 
   838 label *label270
   839 label *label271
   840 label *label272
-    * op add :compute:i :compute:i 1
+  841 op add :compute:i 44 1
   842 set :compute:x1 :compute:zx
   843 op mul *tmp107 :compute:zx :compute:zx
   844 op mul *tmp108 :compute:zy :compute:zy
 
   853 label *label273
   854 label *label274
   855 label *label275
-    * op add :compute:i :compute:i 1
+  856 op add :compute:i 45 1
   857 set :compute:x1 :compute:zx
   858 op mul *tmp107 :compute:zx :compute:zx
   859 op mul *tmp108 :compute:zy :compute:zy
 
   868 label *label276
   869 label *label277
   870 label *label278
-    * op add :compute:i :compute:i 1
+  871 op add :compute:i 46 1
   872 set :compute:x1 :compute:zx
   873 op mul *tmp107 :compute:zx :compute:zx
   874 op mul *tmp108 :compute:zy :compute:zy
 
   883 label *label279
   884 label *label280
   885 label *label281
-    * op add :compute:i :compute:i 1
+  886 op add :compute:i 47 1
   887 set :compute:x1 :compute:zx
   888 op mul *tmp107 :compute:zx :compute:zx
   889 op mul *tmp108 :compute:zy :compute:zy
 
   898 label *label282
   899 label *label283
   900 label *label284
-    * op add :compute:i :compute:i 1
+  901 op add :compute:i 48 1
   902 set :compute:x1 :compute:zx
   903 op mul *tmp107 :compute:zx :compute:zx
   904 op mul *tmp108 :compute:zy :compute:zy
 
   913 label *label285
   914 label *label286
   915 label *label287
-    * op add :compute:i :compute:i 1
+  916 op add :compute:i 49 1
   917 set :compute:x1 :compute:zx
   918 op mul *tmp107 :compute:zx :compute:zx
   919 op mul *tmp108 :compute:zy :compute:zy
 
   928 label *label288
   929 label *label289
   930 label *label290
-    * op add :compute:i :compute:i 1
+  931 op add :compute:i 50 1
   932 set :compute:x1 :compute:zx
   933 op mul *tmp107 :compute:zx :compute:zx
   934 op mul *tmp108 :compute:zy :compute:zy
 
   943 label *label291
   944 label *label292
   945 label *label293
-    * op add :compute:i :compute:i 1
+  946 op add :compute:i 51 1
   947 set :compute:x1 :compute:zx
   948 op mul *tmp107 :compute:zx :compute:zx
   949 op mul *tmp108 :compute:zy :compute:zy
 
   958 label *label294
   959 label *label295
   960 label *label296
-    * op add :compute:i :compute:i 1
+  961 op add :compute:i 52 1
   962 set :compute:x1 :compute:zx
   963 op mul *tmp107 :compute:zx :compute:zx
   964 op mul *tmp108 :compute:zy :compute:zy
 
   973 label *label297
   974 label *label298
   975 label *label299
-    * op add :compute:i :compute:i 1
+  976 op add :compute:i 53 1
   977 set :compute:x1 :compute:zx
   978 op mul *tmp107 :compute:zx :compute:zx
   979 op mul *tmp108 :compute:zy :compute:zy
 
   988 label *label300
   989 label *label301
   990 label *label302
-    * op add :compute:i :compute:i 1
+  991 op add :compute:i 54 1
   992 set :compute:x1 :compute:zx
   993 op mul *tmp107 :compute:zx :compute:zx
   994 op mul *tmp108 :compute:zy :compute:zy
 
  1003 label *label303
  1004 label *label304
  1005 label *label305
-    * op add :compute:i :compute:i 1
+ 1006 op add :compute:i 55 1
  1007 set :compute:x1 :compute:zx
  1008 op mul *tmp107 :compute:zx :compute:zx
  1009 op mul *tmp108 :compute:zy :compute:zy
 
  1018 label *label306
  1019 label *label307
  1020 label *label308
-    * op add :compute:i :compute:i 1
+ 1021 op add :compute:i 56 1
  1022 set :compute:x1 :compute:zx
  1023 op mul *tmp107 :compute:zx :compute:zx
  1024 op mul *tmp108 :compute:zy :compute:zy
 
  1033 label *label309
  1034 label *label310
  1035 label *label311
-    * op add :compute:i :compute:i 1
+ 1036 op add :compute:i 57 1
  1037 set :compute:x1 :compute:zx
  1038 op mul *tmp107 :compute:zx :compute:zx
  1039 op mul *tmp108 :compute:zy :compute:zy
 
  1048 label *label312
  1049 label *label313
  1050 label *label314
-    * op add :compute:i :compute:i 1
+ 1051 op add :compute:i 58 1
  1052 set :compute:x1 :compute:zx
  1053 op mul *tmp107 :compute:zx :compute:zx
  1054 op mul *tmp108 :compute:zy :compute:zy
 
  1063 label *label315
  1064 label *label316
  1065 label *label317
-    * op add :compute:i :compute:i 1
+ 1066 op add :compute:i 59 1
  1067 set :compute:x1 :compute:zx
  1068 op mul *tmp107 :compute:zx :compute:zx
  1069 op mul *tmp108 :compute:zy :compute:zy
 
  1078 label *label318
  1079 label *label319
  1080 label *label320
-    * op add :compute:i :compute:i 1
+ 1081 op add :compute:i 60 1
  1082 set :compute:x1 :compute:zx
  1083 op mul *tmp107 :compute:zx :compute:zx
  1084 op mul *tmp108 :compute:zy :compute:zy
 
  1093 label *label321
  1094 label *label322
  1095 label *label323
-    * op add :compute:i :compute:i 1
+ 1096 op add :compute:i 61 1
  1097 set :compute:x1 :compute:zx
  1098 op mul *tmp107 :compute:zx :compute:zx
  1099 op mul *tmp108 :compute:zy :compute:zy
 
  1108 label *label324
  1109 label *label325
  1110 label *label326
-    * op add :compute:i :compute:i 1
+ 1111 op add :compute:i 62 1
  1112 label *label65
  1113 jump *label68 lessThanEq .PALETTE 1
  1114 jump *label68 greaterThanEq :compute:i 63

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1:
 
   178 label *label138
   179 label *label139
   180 label *label140
-    * op add :compute:i 0 1
+  181 set :compute:i 1
   182 set :compute:x1 :compute:zx
   183 op mul *tmp107 :compute:zx :compute:zx
   184 op mul *tmp108 :compute:zy :compute:zy

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-1 instructions):
     0 set .start 0
     1 label *label0
-    * label *label1
     2 op equal *tmp14 .display null
     3 op equal *tmp15 .memory null
     4 op or *tmp16 *tmp14 *tmp15
     5 jump *label0 notEqual *tmp16 false
-    * label *label2
     6 label *label3
     7 label *label6
     8 wait 0
-    * label *label7
     9 read *tmp18 .memory 67
    10 jump *label6 equal .start *tmp18
-    * label *label8
    11 read .start .memory 67
    12 read .stop .memory 68
    13 set .lastColor -1
 
    34 jump *label14 equal .stop *tmp38
    35 jump *label4 always
    36 label *label14
-    * label *label15
    37 read :batch .memory 64
    38 select *tmp42 greaterThanEq :batch 1408 1 4
    39 op add *tmp43 :batch *tmp42
 
    41 jump *label18 lessThan :batch 2816
    42 jump *label13 always
    43 label *label18
-    * label *label19
    44 op mul *tmp47 11 *tmp42
    45 set :i 0
    46 op mul *tmp48 :batch 11
-    * label *label20
    47 jump *label22 lessThanEq *tmp42 0
    48 label *label119
    49 op add :adam5:index *tmp48 :i
    50 op idiv *tmp51 :adam5:index 16
    51 multijump *tmp51 0 0 (m:*label124)
    52 multilabel *label129 (m:*label124)
-    * label *label123
    53 op sub :adam5:index :adam5:index 15488
    54 op mod :adam5:x :adam5:index 176
    55 op idiv *tmp78 :adam5:index 176
 
    59 set :adam5:dx 1
    60 jump *label24 always
    61 multilabel *label125 (m:*label124)
-    * label *label26
    62 op mod *tmp53 :adam5:index 44
    63 op mul :adam5:x 4 *tmp53
    64 op idiv *tmp55 :adam5:index 44
 
    67 set :adam5:dy *tmp57
    68 set :adam5:dx *tmp57
    69 jump *label24 always
-    * label *label25
    70 multilabel *label126 (m:*label124)
-    * label *label31
    71 op sub :adam5:index :adam5:index 1936
    72 op mod *tmp58 :adam5:index 44
    73 op mul *tmp59 4 *tmp58
 
    77 select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1
    78 select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2
    79 jump *label24 always
-    * label *label30
    80 multilabel *label127 (m:*label124)
-    * label *label38
    81 op sub :adam5:index :adam5:index 3872
    82 op mod *tmp65 :adam5:index 88
    83 op mul :adam5:x 2 *tmp65
 
    87 select *tmp70 notEqual .ALL_PASS_COLORING false 2 1
    88 set :adam5:dy *tmp70
    89 set :adam5:dx *tmp70
-    * label *label37
    90 jump *label24 always
    91 multilabel *label128 (m:*label124)
-    * label *label43
    92 op sub :adam5:index :adam5:index 7744
    93 op mod *tmp71 :adam5:index 88
    94 op mul *tmp72 2 *tmp71
 
    98 set :adam5:dx 1
    99 select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1
   100 label *label24
-    * label *label23
   101 jump *label47 lessThanEq *tmp42 *tmp35
   102 jump *label47 notEqual .localBuffer 0
   103 draw col %[white]
 
   112 drawflush .display
   113 set .localBuffer 0
   114 label *label52
-    * label *label53
-    * label *label51
   115 label *label47
-    * label *label48
   116 op div *tmp90 :adam5:x .ZOOM
   117 op add :compute:zx *tmp90 .OFFSET_X
   118 op div *tmp92 :adam5:y .ZOOM
 
   134 set *tmp89 63
   135 jump *label56 always
   136 label *label59
-    * label *label60
   137 op add *tmp103 :compute:zx 1
   138 op len *tmp104 *tmp103 :compute:zy
   139 jump *label61 greaterThan *tmp104 0.25
   140 set *tmp89 63
   141 jump *label56 always
   142 label *label61
-    * label *label62
   143 label *label58
   144 set :compute:i 0
-    * label *label137
   145 set :compute:x1 :compute:zx
   146 op mul *tmp107 :compute:zx :compute:zx
   147 op mul *tmp108 :compute:zy :compute:zy
 
   154 jump *label138 lessThan :compute:dist 64
   155 jump *label65 always
   156 label *label138
-    * label *label139
-    * label *label140
   157 set :compute:i 1
   158 set :compute:x1 :compute:zx
   159 op mul *tmp107 :compute:zx :compute:zx
 
   167 jump *label141 lessThan :compute:dist 64
   168 jump *label65 always
   169 label *label141
-    * label *label142
-    * label *label143
   170 op add :compute:i 1 1
   171 set :compute:x1 :compute:zx
   172 op mul *tmp107 :compute:zx :compute:zx
 
   180 jump *label144 lessThan :compute:dist 64
   181 jump *label65 always
   182 label *label144
-    * label *label145
-    * label *label146
   183 op add :compute:i 2 1
   184 set :compute:x1 :compute:zx
   185 op mul *tmp107 :compute:zx :compute:zx
 
   193 jump *label147 lessThan :compute:dist 64
   194 jump *label65 always
   195 label *label147
-    * label *label148
-    * label *label149
   196 op add :compute:i 3 1
   197 set :compute:x1 :compute:zx
   198 op mul *tmp107 :compute:zx :compute:zx
 
   206 jump *label150 lessThan :compute:dist 64
   207 jump *label65 always
   208 label *label150
-    * label *label151
-    * label *label152
   209 op add :compute:i 4 1
   210 set :compute:x1 :compute:zx
   211 op mul *tmp107 :compute:zx :compute:zx
 
   219 jump *label153 lessThan :compute:dist 64
   220 jump *label65 always
   221 label *label153
-    * label *label154
-    * label *label155
   222 op add :compute:i 5 1
   223 set :compute:x1 :compute:zx
   224 op mul *tmp107 :compute:zx :compute:zx
 
   232 jump *label156 lessThan :compute:dist 64
   233 jump *label65 always
   234 label *label156
-    * label *label157
-    * label *label158
   235 op add :compute:i 6 1
   236 set :compute:x1 :compute:zx
   237 op mul *tmp107 :compute:zx :compute:zx
 
   245 jump *label159 lessThan :compute:dist 64
   246 jump *label65 always
   247 label *label159
-    * label *label160
-    * label *label161
   248 op add :compute:i 7 1
   249 set :compute:x1 :compute:zx
   250 op mul *tmp107 :compute:zx :compute:zx
 
   258 jump *label162 lessThan :compute:dist 64
   259 jump *label65 always
   260 label *label162
-    * label *label163
-    * label *label164
   261 op add :compute:i 8 1
   262 set :compute:x1 :compute:zx
   263 op mul *tmp107 :compute:zx :compute:zx
 
   271 jump *label165 lessThan :compute:dist 64
   272 jump *label65 always
   273 label *label165
-    * label *label166
-    * label *label167
   274 op add :compute:i 9 1
   275 set :compute:x1 :compute:zx
   276 op mul *tmp107 :compute:zx :compute:zx
 
   284 jump *label168 lessThan :compute:dist 64
   285 jump *label65 always
   286 label *label168
-    * label *label169
-    * label *label170
   287 op add :compute:i 10 1
   288 set :compute:x1 :compute:zx
   289 op mul *tmp107 :compute:zx :compute:zx
 
   297 jump *label171 lessThan :compute:dist 64
   298 jump *label65 always
   299 label *label171
-    * label *label172
-    * label *label173
   300 op add :compute:i 11 1
   301 set :compute:x1 :compute:zx
   302 op mul *tmp107 :compute:zx :compute:zx
 
   310 jump *label174 lessThan :compute:dist 64
   311 jump *label65 always
   312 label *label174
-    * label *label175
-    * label *label176
   313 op add :compute:i 12 1
   314 set :compute:x1 :compute:zx
   315 op mul *tmp107 :compute:zx :compute:zx
 
   323 jump *label177 lessThan :compute:dist 64
   324 jump *label65 always
   325 label *label177
-    * label *label178
-    * label *label179
   326 op add :compute:i 13 1
   327 set :compute:x1 :compute:zx
   328 op mul *tmp107 :compute:zx :compute:zx
 
   336 jump *label180 lessThan :compute:dist 64
   337 jump *label65 always
   338 label *label180
-    * label *label181
-    * label *label182
   339 op add :compute:i 14 1
   340 set :compute:x1 :compute:zx
   341 op mul *tmp107 :compute:zx :compute:zx
 
   349 jump *label183 lessThan :compute:dist 64
   350 jump *label65 always
   351 label *label183
-    * label *label184
-    * label *label185
   352 op add :compute:i 15 1
   353 set :compute:x1 :compute:zx
   354 op mul *tmp107 :compute:zx :compute:zx
 
   362 jump *label186 lessThan :compute:dist 64
   363 jump *label65 always
   364 label *label186
-    * label *label187
-    * label *label188
   365 op add :compute:i 16 1
   366 set :compute:x1 :compute:zx
   367 op mul *tmp107 :compute:zx :compute:zx
 
   375 jump *label189 lessThan :compute:dist 64
   376 jump *label65 always
   377 label *label189
-    * label *label190
-    * label *label191
   378 op add :compute:i 17 1
   379 set :compute:x1 :compute:zx
   380 op mul *tmp107 :compute:zx :compute:zx
 
   388 jump *label192 lessThan :compute:dist 64
   389 jump *label65 always
   390 label *label192
-    * label *label193
-    * label *label194
   391 op add :compute:i 18 1
   392 set :compute:x1 :compute:zx
   393 op mul *tmp107 :compute:zx :compute:zx
 
   401 jump *label195 lessThan :compute:dist 64
   402 jump *label65 always
   403 label *label195
-    * label *label196
-    * label *label197
   404 op add :compute:i 19 1
   405 set :compute:x1 :compute:zx
   406 op mul *tmp107 :compute:zx :compute:zx
 
   414 jump *label198 lessThan :compute:dist 64
   415 jump *label65 always
   416 label *label198
-    * label *label199
-    * label *label200
   417 op add :compute:i 20 1
   418 set :compute:x1 :compute:zx
   419 op mul *tmp107 :compute:zx :compute:zx
 
   427 jump *label201 lessThan :compute:dist 64
   428 jump *label65 always
   429 label *label201
-    * label *label202
-    * label *label203
   430 op add :compute:i 21 1
   431 set :compute:x1 :compute:zx
   432 op mul *tmp107 :compute:zx :compute:zx
 
   440 jump *label204 lessThan :compute:dist 64
   441 jump *label65 always
   442 label *label204
-    * label *label205
-    * label *label206
   443 op add :compute:i 22 1
   444 set :compute:x1 :compute:zx
   445 op mul *tmp107 :compute:zx :compute:zx
 
   453 jump *label207 lessThan :compute:dist 64
   454 jump *label65 always
   455 label *label207
-    * label *label208
-    * label *label209
   456 op add :compute:i 23 1
   457 set :compute:x1 :compute:zx
   458 op mul *tmp107 :compute:zx :compute:zx
 
   466 jump *label210 lessThan :compute:dist 64
   467 jump *label65 always
   468 label *label210
-    * label *label211
-    * label *label212
   469 op add :compute:i 24 1
   470 set :compute:x1 :compute:zx
   471 op mul *tmp107 :compute:zx :compute:zx
 
   479 jump *label213 lessThan :compute:dist 64
   480 jump *label65 always
   481 label *label213
-    * label *label214
-    * label *label215
   482 op add :compute:i 25 1
   483 set :compute:x1 :compute:zx
   484 op mul *tmp107 :compute:zx :compute:zx
 
   492 jump *label216 lessThan :compute:dist 64
   493 jump *label65 always
   494 label *label216
-    * label *label217
-    * label *label218
   495 op add :compute:i 26 1
   496 set :compute:x1 :compute:zx
   497 op mul *tmp107 :compute:zx :compute:zx
 
   505 jump *label219 lessThan :compute:dist 64
   506 jump *label65 always
   507 label *label219
-    * label *label220
-    * label *label221
   508 op add :compute:i 27 1
   509 set :compute:x1 :compute:zx
   510 op mul *tmp107 :compute:zx :compute:zx
 
   518 jump *label222 lessThan :compute:dist 64
   519 jump *label65 always
   520 label *label222
-    * label *label223
-    * label *label224
   521 op add :compute:i 28 1
   522 set :compute:x1 :compute:zx
   523 op mul *tmp107 :compute:zx :compute:zx
 
   531 jump *label225 lessThan :compute:dist 64
   532 jump *label65 always
   533 label *label225
-    * label *label226
-    * label *label227
   534 op add :compute:i 29 1
   535 set :compute:x1 :compute:zx
   536 op mul *tmp107 :compute:zx :compute:zx
 
   544 jump *label228 lessThan :compute:dist 64
   545 jump *label65 always
   546 label *label228
-    * label *label229
-    * label *label230
   547 op add :compute:i 30 1
   548 set :compute:x1 :compute:zx
   549 op mul *tmp107 :compute:zx :compute:zx
 
   557 jump *label231 lessThan :compute:dist 64
   558 jump *label65 always
   559 label *label231
-    * label *label232
-    * label *label233
   560 op add :compute:i 31 1
   561 set :compute:x1 :compute:zx
   562 op mul *tmp107 :compute:zx :compute:zx
 
   570 jump *label234 lessThan :compute:dist 64
   571 jump *label65 always
   572 label *label234
-    * label *label235
-    * label *label236
   573 op add :compute:i 32 1
   574 set :compute:x1 :compute:zx
   575 op mul *tmp107 :compute:zx :compute:zx
 
   583 jump *label237 lessThan :compute:dist 64
   584 jump *label65 always
   585 label *label237
-    * label *label238
-    * label *label239
   586 op add :compute:i 33 1
   587 set :compute:x1 :compute:zx
   588 op mul *tmp107 :compute:zx :compute:zx
 
   596 jump *label240 lessThan :compute:dist 64
   597 jump *label65 always
   598 label *label240
-    * label *label241
-    * label *label242
   599 op add :compute:i 34 1
   600 set :compute:x1 :compute:zx
   601 op mul *tmp107 :compute:zx :compute:zx
 
   609 jump *label243 lessThan :compute:dist 64
   610 jump *label65 always
   611 label *label243
-    * label *label244
-    * label *label245
   612 op add :compute:i 35 1
   613 set :compute:x1 :compute:zx
   614 op mul *tmp107 :compute:zx :compute:zx
 
   622 jump *label246 lessThan :compute:dist 64
   623 jump *label65 always
   624 label *label246
-    * label *label247
-    * label *label248
   625 op add :compute:i 36 1
   626 set :compute:x1 :compute:zx
   627 op mul *tmp107 :compute:zx :compute:zx
 
   635 jump *label249 lessThan :compute:dist 64
   636 jump *label65 always
   637 label *label249
-    * label *label250
-    * label *label251
   638 op add :compute:i 37 1
   639 set :compute:x1 :compute:zx
   640 op mul *tmp107 :compute:zx :compute:zx
 
   648 jump *label252 lessThan :compute:dist 64
   649 jump *label65 always
   650 label *label252
-    * label *label253
-    * label *label254
   651 op add :compute:i 38 1
   652 set :compute:x1 :compute:zx
   653 op mul *tmp107 :compute:zx :compute:zx
 
   661 jump *label255 lessThan :compute:dist 64
   662 jump *label65 always
   663 label *label255
-    * label *label256
-    * label *label257
   664 op add :compute:i 39 1
   665 set :compute:x1 :compute:zx
   666 op mul *tmp107 :compute:zx :compute:zx
 
   674 jump *label258 lessThan :compute:dist 64
   675 jump *label65 always
   676 label *label258
-    * label *label259
-    * label *label260
   677 op add :compute:i 40 1
   678 set :compute:x1 :compute:zx
   679 op mul *tmp107 :compute:zx :compute:zx
 
   687 jump *label261 lessThan :compute:dist 64
   688 jump *label65 always
   689 label *label261
-    * label *label262
-    * label *label263
   690 op add :compute:i 41 1
   691 set :compute:x1 :compute:zx
   692 op mul *tmp107 :compute:zx :compute:zx
 
   700 jump *label264 lessThan :compute:dist 64
   701 jump *label65 always
   702 label *label264
-    * label *label265
-    * label *label266
   703 op add :compute:i 42 1
   704 set :compute:x1 :compute:zx
   705 op mul *tmp107 :compute:zx :compute:zx
 
   713 jump *label267 lessThan :compute:dist 64
   714 jump *label65 always
   715 label *label267
-    * label *label268
-    * label *label269
   716 op add :compute:i 43 1
   717 set :compute:x1 :compute:zx
   718 op mul *tmp107 :compute:zx :compute:zx
 
   726 jump *label270 lessThan :compute:dist 64
   727 jump *label65 always
   728 label *label270
-    * label *label271
-    * label *label272
   729 op add :compute:i 44 1
   730 set :compute:x1 :compute:zx
   731 op mul *tmp107 :compute:zx :compute:zx
 
   739 jump *label273 lessThan :compute:dist 64
   740 jump *label65 always
   741 label *label273
-    * label *label274
-    * label *label275
   742 op add :compute:i 45 1
   743 set :compute:x1 :compute:zx
   744 op mul *tmp107 :compute:zx :compute:zx
 
   752 jump *label276 lessThan :compute:dist 64
   753 jump *label65 always
   754 label *label276
-    * label *label277
-    * label *label278
   755 op add :compute:i 46 1
   756 set :compute:x1 :compute:zx
   757 op mul *tmp107 :compute:zx :compute:zx
 
   765 jump *label279 lessThan :compute:dist 64
   766 jump *label65 always
   767 label *label279
-    * label *label280
-    * label *label281
   768 op add :compute:i 47 1
   769 set :compute:x1 :compute:zx
   770 op mul *tmp107 :compute:zx :compute:zx
 
   778 jump *label282 lessThan :compute:dist 64
   779 jump *label65 always
   780 label *label282
-    * label *label283
-    * label *label284
   781 op add :compute:i 48 1
   782 set :compute:x1 :compute:zx
   783 op mul *tmp107 :compute:zx :compute:zx
 
   791 jump *label285 lessThan :compute:dist 64
   792 jump *label65 always
   793 label *label285
-    * label *label286
-    * label *label287
   794 op add :compute:i 49 1
   795 set :compute:x1 :compute:zx
   796 op mul *tmp107 :compute:zx :compute:zx
 
   804 jump *label288 lessThan :compute:dist 64
   805 jump *label65 always
   806 label *label288
-    * label *label289
-    * label *label290
   807 op add :compute:i 50 1
   808 set :compute:x1 :compute:zx
   809 op mul *tmp107 :compute:zx :compute:zx
 
   817 jump *label291 lessThan :compute:dist 64
   818 jump *label65 always
   819 label *label291
-    * label *label292
-    * label *label293
   820 op add :compute:i 51 1
   821 set :compute:x1 :compute:zx
   822 op mul *tmp107 :compute:zx :compute:zx
 
   830 jump *label294 lessThan :compute:dist 64
   831 jump *label65 always
   832 label *label294
-    * label *label295
-    * label *label296
   833 op add :compute:i 52 1
   834 set :compute:x1 :compute:zx
   835 op mul *tmp107 :compute:zx :compute:zx
 
   843 jump *label297 lessThan :compute:dist 64
   844 jump *label65 always
   845 label *label297
-    * label *label298
-    * label *label299
   846 op add :compute:i 53 1
   847 set :compute:x1 :compute:zx
   848 op mul *tmp107 :compute:zx :compute:zx
 
   856 jump *label300 lessThan :compute:dist 64
   857 jump *label65 always
   858 label *label300
-    * label *label301
-    * label *label302
   859 op add :compute:i 54 1
   860 set :compute:x1 :compute:zx
   861 op mul *tmp107 :compute:zx :compute:zx
 
   869 jump *label303 lessThan :compute:dist 64
   870 jump *label65 always
   871 label *label303
-    * label *label304
-    * label *label305
   872 op add :compute:i 55 1
   873 set :compute:x1 :compute:zx
   874 op mul *tmp107 :compute:zx :compute:zx
 
   882 jump *label306 lessThan :compute:dist 64
   883 jump *label65 always
   884 label *label306
-    * label *label307
-    * label *label308
   885 op add :compute:i 56 1
   886 set :compute:x1 :compute:zx
   887 op mul *tmp107 :compute:zx :compute:zx
 
   895 jump *label309 lessThan :compute:dist 64
   896 jump *label65 always
   897 label *label309
-    * label *label310
-    * label *label311
   898 op add :compute:i 57 1
   899 set :compute:x1 :compute:zx
   900 op mul *tmp107 :compute:zx :compute:zx
 
   908 jump *label312 lessThan :compute:dist 64
   909 jump *label65 always
   910 label *label312
-    * label *label313
-    * label *label314
   911 op add :compute:i 58 1
   912 set :compute:x1 :compute:zx
   913 op mul *tmp107 :compute:zx :compute:zx
 
   921 jump *label315 lessThan :compute:dist 64
   922 jump *label65 always
   923 label *label315
-    * label *label316
-    * label *label317
   924 op add :compute:i 59 1
   925 set :compute:x1 :compute:zx
   926 op mul *tmp107 :compute:zx :compute:zx
 
   934 jump *label318 lessThan :compute:dist 64
   935 jump *label65 always
   936 label *label318
-    * label *label319
-    * label *label320
   937 op add :compute:i 60 1
   938 set :compute:x1 :compute:zx
   939 op mul *tmp107 :compute:zx :compute:zx
 
   947 jump *label321 lessThan :compute:dist 64
   948 jump *label65 always
   949 label *label321
-    * label *label322
-    * label *label323
   950 op add :compute:i 61 1
   951 set :compute:x1 :compute:zx
   952 op mul *tmp107 :compute:zx :compute:zx
 
   960 jump *label324 lessThan :compute:dist 64
   961 jump *label65 always
   962 label *label324
-    * label *label325
-    * label *label326
   963 op add :compute:i 62 1
   964 label *label65
   965 jump *label68 lessThanEq .PALETTE 1
 
   971 op sub :compute:correction 4 *tmp122
   972 op add :compute:i :compute:i :compute:correction
   973 label *label68
-    * label *label69
   974 set *tmp89 :compute:i
   975 label *label56
   976 jump *label73 lessThanEq .PALETTE 1
   977 set :drawPixel:color %[black]
   978 jump *label76 equal *tmp89 63
-    * label *label75
   979 multijump .PALETTE 0 0 (m:*label131)
   980 multilabel *label136 (m:*label131)
   981 multilabel *label132 (m:*label131)
-    * label *label130
   982 op div *tmp163 *tmp89 63.75
   983 op sub :drawPixel:r 1 *tmp163
   984 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   985 jump *label77 always
   986 multilabel *label133 (m:*label131)
-    * label *label79
   987 op sub *tmp129 32 *tmp89
   988 op abs *tmp130 *tmp129
   989 op div *tmp132 *tmp130 36.42857142857143
 
   996 op add :drawPixel:b 0.47058823529411764 *tmp142
   997 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   998 jump *label77 always
-    * label *label78
   999 multilabel *label134 (m:*label131)
-    * label *label81
  1000 op div *tmp146 *tmp89 0.175
  1001 op sin :drawPixel:r *tmp146
  1002 op cos :drawPixel:g *tmp146
 
  1006 op add :drawPixel:b 0.39215686274509803 *tmp154
  1007 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1008 jump *label77 always
-    * label *label80
  1009 multilabel *label135 (m:*label131)
-    * label *label83
  1010 op div :drawPixel:r *tmp89 63.75
  1011 op div :drawPixel:g *tmp89 170
  1012 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
 
  1017 read :drawPixel:color .memory *tmp89
  1018 label *label74
  1019 jump *label84 lessThan .localBuffer 254
-    * label *label87
  1020 jump *label89 lessThanEq .localBuffer 0
  1021 label *label121
  1022 read *tmp173 .memory 68
 
  1030 drawflush .display
  1031 set .localBuffer 0
  1032 label *label93
-    * label *label94
-    * label *label92
-    * label *label88
  1033 jump *label121 greaterThan .localBuffer 0
  1034 label *label89
-    * label *label86
  1035 label *label84
-    * label *label85
  1036 jump *label97 lessThanEq .localBuffer 0
  1037 jump *label97 strictNotEqual :drawPixel:color .lastColor
  1038 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
 
  1053 drawflush .display
  1054 set .localBuffer 0
  1055 label *label102
-    * label *label103
-    * label *label101
-    * label *label72
  1056 wait 0
  1057 read *tmp189 .memory 68
  1058 jump *label106 equal .stop *tmp189
  1059 jump *label4 always
  1060 label *label106
-    * label *label107
  1061 read *tmp191 .memory 66
  1062 op add *tmp2 *tmp191 1
  1063 write *tmp2 .memory 66
  1064 read *tmp193 .memory 65
  1065 op add *tmp194 *tmp193 *tmp89
  1066 write *tmp194 .memory 65
-    * label *label21
  1067 op add :i :i 1
  1068 jump *label119 lessThan :i *tmp47
  1069 label *label22
-    * label *label12
  1070 jump *label11 always
  1071 label *label13
-    * label *label109
  1072 jump *label111 lessThanEq .localBuffer 0
  1073 label *label122
  1074 read *tmp197 .memory 68
 
  1082 drawflush .display
  1083 set .localBuffer 0
  1084 label *label115
-    * label *label116
-    * label *label114
-    * label *label110
  1085 jump *label122 greaterThan .localBuffer 0
  1086 label *label111
-    * label *label108
  1087 label *label4
  1088 jump *label3 always
-    * label *label5
-    * end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-66 instructions):
 
    31 label *label11
    32 wait 0
    33 read *tmp38 .memory 68
-    * jump *label14 equal .stop *tmp38
-    * jump *label4 always
+   34 jump *label4 notEqual .stop *tmp38
    35 label *label14
    36 read :batch .memory 64
    37 select *tmp42 greaterThanEq :batch 1408 1 4
    38 op add *tmp43 :batch *tmp42
    39 write *tmp43 .memory 64
-    * jump *label18 lessThan :batch 2816
-    * jump *label13 always
+   40 jump *label13 greaterThanEq :batch 2816
    41 label *label18
    42 op mul *tmp47 11 *tmp42
    43 set :i 0
 
   149 op mul *tmp112 *tmp111 :compute:zy
   150 op add :compute:zy *tmp112 :compute:cy
   151 op len :compute:dist :compute:zx :compute:zy
-    * jump *label138 lessThan :compute:dist 64
-    * jump *label65 always
+  152 jump *label65 greaterThanEq :compute:dist 64
   153 label *label138
   154 set :compute:i 1
   155 set :compute:x1 :compute:zx
 
   161 op mul *tmp112 *tmp111 :compute:zy
   162 op add :compute:zy *tmp112 :compute:cy
   163 op len :compute:dist :compute:zx :compute:zy
-    * jump *label141 lessThan :compute:dist 64
-    * jump *label65 always
+  164 jump *label65 greaterThanEq :compute:dist 64
   165 label *label141
   166 op add :compute:i 1 1
   167 set :compute:x1 :compute:zx
 
   173 op mul *tmp112 *tmp111 :compute:zy
   174 op add :compute:zy *tmp112 :compute:cy
   175 op len :compute:dist :compute:zx :compute:zy
-    * jump *label144 lessThan :compute:dist 64
-    * jump *label65 always
+  176 jump *label65 greaterThanEq :compute:dist 64
   177 label *label144
   178 op add :compute:i 2 1
   179 set :compute:x1 :compute:zx
 
   185 op mul *tmp112 *tmp111 :compute:zy
   186 op add :compute:zy *tmp112 :compute:cy
   187 op len :compute:dist :compute:zx :compute:zy
-    * jump *label147 lessThan :compute:dist 64
-    * jump *label65 always
+  188 jump *label65 greaterThanEq :compute:dist 64
   189 label *label147
   190 op add :compute:i 3 1
   191 set :compute:x1 :compute:zx
 
   197 op mul *tmp112 *tmp111 :compute:zy
   198 op add :compute:zy *tmp112 :compute:cy
   199 op len :compute:dist :compute:zx :compute:zy
-    * jump *label150 lessThan :compute:dist 64
-    * jump *label65 always
+  200 jump *label65 greaterThanEq :compute:dist 64
   201 label *label150
   202 op add :compute:i 4 1
   203 set :compute:x1 :compute:zx
 
   209 op mul *tmp112 *tmp111 :compute:zy
   210 op add :compute:zy *tmp112 :compute:cy
   211 op len :compute:dist :compute:zx :compute:zy
-    * jump *label153 lessThan :compute:dist 64
-    * jump *label65 always
+  212 jump *label65 greaterThanEq :compute:dist 64
   213 label *label153
   214 op add :compute:i 5 1
   215 set :compute:x1 :compute:zx
 
   221 op mul *tmp112 *tmp111 :compute:zy
   222 op add :compute:zy *tmp112 :compute:cy
   223 op len :compute:dist :compute:zx :compute:zy
-    * jump *label156 lessThan :compute:dist 64
-    * jump *label65 always
+  224 jump *label65 greaterThanEq :compute:dist 64
   225 label *label156
   226 op add :compute:i 6 1
   227 set :compute:x1 :compute:zx
 
   233 op mul *tmp112 *tmp111 :compute:zy
   234 op add :compute:zy *tmp112 :compute:cy
   235 op len :compute:dist :compute:zx :compute:zy
-    * jump *label159 lessThan :compute:dist 64
-    * jump *label65 always
+  236 jump *label65 greaterThanEq :compute:dist 64
   237 label *label159
   238 op add :compute:i 7 1
   239 set :compute:x1 :compute:zx
 
   245 op mul *tmp112 *tmp111 :compute:zy
   246 op add :compute:zy *tmp112 :compute:cy
   247 op len :compute:dist :compute:zx :compute:zy
-    * jump *label162 lessThan :compute:dist 64
-    * jump *label65 always
+  248 jump *label65 greaterThanEq :compute:dist 64
   249 label *label162
   250 op add :compute:i 8 1
   251 set :compute:x1 :compute:zx
 
   257 op mul *tmp112 *tmp111 :compute:zy
   258 op add :compute:zy *tmp112 :compute:cy
   259 op len :compute:dist :compute:zx :compute:zy
-    * jump *label165 lessThan :compute:dist 64
-    * jump *label65 always
+  260 jump *label65 greaterThanEq :compute:dist 64
   261 label *label165
   262 op add :compute:i 9 1
   263 set :compute:x1 :compute:zx
 
   269 op mul *tmp112 *tmp111 :compute:zy
   270 op add :compute:zy *tmp112 :compute:cy
   271 op len :compute:dist :compute:zx :compute:zy
-    * jump *label168 lessThan :compute:dist 64
-    * jump *label65 always
+  272 jump *label65 greaterThanEq :compute:dist 64
   273 label *label168
   274 op add :compute:i 10 1
   275 set :compute:x1 :compute:zx
 
   281 op mul *tmp112 *tmp111 :compute:zy
   282 op add :compute:zy *tmp112 :compute:cy
   283 op len :compute:dist :compute:zx :compute:zy
-    * jump *label171 lessThan :compute:dist 64
-    * jump *label65 always
+  284 jump *label65 greaterThanEq :compute:dist 64
   285 label *label171
   286 op add :compute:i 11 1
   287 set :compute:x1 :compute:zx
 
   293 op mul *tmp112 *tmp111 :compute:zy
   294 op add :compute:zy *tmp112 :compute:cy
   295 op len :compute:dist :compute:zx :compute:zy
-    * jump *label174 lessThan :compute:dist 64
-    * jump *label65 always
+  296 jump *label65 greaterThanEq :compute:dist 64
   297 label *label174
   298 op add :compute:i 12 1
   299 set :compute:x1 :compute:zx
 
   305 op mul *tmp112 *tmp111 :compute:zy
   306 op add :compute:zy *tmp112 :compute:cy
   307 op len :compute:dist :compute:zx :compute:zy
-    * jump *label177 lessThan :compute:dist 64
-    * jump *label65 always
+  308 jump *label65 greaterThanEq :compute:dist 64
   309 label *label177
   310 op add :compute:i 13 1
   311 set :compute:x1 :compute:zx
 
   317 op mul *tmp112 *tmp111 :compute:zy
   318 op add :compute:zy *tmp112 :compute:cy
   319 op len :compute:dist :compute:zx :compute:zy
-    * jump *label180 lessThan :compute:dist 64
-    * jump *label65 always
+  320 jump *label65 greaterThanEq :compute:dist 64
   321 label *label180
   322 op add :compute:i 14 1
   323 set :compute:x1 :compute:zx
 
   329 op mul *tmp112 *tmp111 :compute:zy
   330 op add :compute:zy *tmp112 :compute:cy
   331 op len :compute:dist :compute:zx :compute:zy
-    * jump *label183 lessThan :compute:dist 64
-    * jump *label65 always
+  332 jump *label65 greaterThanEq :compute:dist 64
   333 label *label183
   334 op add :compute:i 15 1
   335 set :compute:x1 :compute:zx
 
   341 op mul *tmp112 *tmp111 :compute:zy
   342 op add :compute:zy *tmp112 :compute:cy
   343 op len :compute:dist :compute:zx :compute:zy
-    * jump *label186 lessThan :compute:dist 64
-    * jump *label65 always
+  344 jump *label65 greaterThanEq :compute:dist 64
   345 label *label186
   346 op add :compute:i 16 1
   347 set :compute:x1 :compute:zx
 
   353 op mul *tmp112 *tmp111 :compute:zy
   354 op add :compute:zy *tmp112 :compute:cy
   355 op len :compute:dist :compute:zx :compute:zy
-    * jump *label189 lessThan :compute:dist 64
-    * jump *label65 always
+  356 jump *label65 greaterThanEq :compute:dist 64
   357 label *label189
   358 op add :compute:i 17 1
   359 set :compute:x1 :compute:zx
 
   365 op mul *tmp112 *tmp111 :compute:zy
   366 op add :compute:zy *tmp112 :compute:cy
   367 op len :compute:dist :compute:zx :compute:zy
-    * jump *label192 lessThan :compute:dist 64
-    * jump *label65 always
+  368 jump *label65 greaterThanEq :compute:dist 64
   369 label *label192
   370 op add :compute:i 18 1
   371 set :compute:x1 :compute:zx
 
   377 op mul *tmp112 *tmp111 :compute:zy
   378 op add :compute:zy *tmp112 :compute:cy
   379 op len :compute:dist :compute:zx :compute:zy
-    * jump *label195 lessThan :compute:dist 64
-    * jump *label65 always
+  380 jump *label65 greaterThanEq :compute:dist 64
   381 label *label195
   382 op add :compute:i 19 1
   383 set :compute:x1 :compute:zx
 
   389 op mul *tmp112 *tmp111 :compute:zy
   390 op add :compute:zy *tmp112 :compute:cy
   391 op len :compute:dist :compute:zx :compute:zy
-    * jump *label198 lessThan :compute:dist 64
-    * jump *label65 always
+  392 jump *label65 greaterThanEq :compute:dist 64
   393 label *label198
   394 op add :compute:i 20 1
   395 set :compute:x1 :compute:zx
 
   401 op mul *tmp112 *tmp111 :compute:zy
   402 op add :compute:zy *tmp112 :compute:cy
   403 op len :compute:dist :compute:zx :compute:zy
-    * jump *label201 lessThan :compute:dist 64
-    * jump *label65 always
+  404 jump *label65 greaterThanEq :compute:dist 64
   405 label *label201
   406 op add :compute:i 21 1
   407 set :compute:x1 :compute:zx
 
   413 op mul *tmp112 *tmp111 :compute:zy
   414 op add :compute:zy *tmp112 :compute:cy
   415 op len :compute:dist :compute:zx :compute:zy
-    * jump *label204 lessThan :compute:dist 64
-    * jump *label65 always
+  416 jump *label65 greaterThanEq :compute:dist 64
   417 label *label204
   418 op add :compute:i 22 1
   419 set :compute:x1 :compute:zx
 
   425 op mul *tmp112 *tmp111 :compute:zy
   426 op add :compute:zy *tmp112 :compute:cy
   427 op len :compute:dist :compute:zx :compute:zy
-    * jump *label207 lessThan :compute:dist 64
-    * jump *label65 always
+  428 jump *label65 greaterThanEq :compute:dist 64
   429 label *label207
   430 op add :compute:i 23 1
   431 set :compute:x1 :compute:zx
 
   437 op mul *tmp112 *tmp111 :compute:zy
   438 op add :compute:zy *tmp112 :compute:cy
   439 op len :compute:dist :compute:zx :compute:zy
-    * jump *label210 lessThan :compute:dist 64
-    * jump *label65 always
+  440 jump *label65 greaterThanEq :compute:dist 64
   441 label *label210
   442 op add :compute:i 24 1
   443 set :compute:x1 :compute:zx
 
   449 op mul *tmp112 *tmp111 :compute:zy
   450 op add :compute:zy *tmp112 :compute:cy
   451 op len :compute:dist :compute:zx :compute:zy
-    * jump *label213 lessThan :compute:dist 64
-    * jump *label65 always
+  452 jump *label65 greaterThanEq :compute:dist 64
   453 label *label213
   454 op add :compute:i 25 1
   455 set :compute:x1 :compute:zx
 
   461 op mul *tmp112 *tmp111 :compute:zy
   462 op add :compute:zy *tmp112 :compute:cy
   463 op len :compute:dist :compute:zx :compute:zy
-    * jump *label216 lessThan :compute:dist 64
-    * jump *label65 always
+  464 jump *label65 greaterThanEq :compute:dist 64
   465 label *label216
   466 op add :compute:i 26 1
   467 set :compute:x1 :compute:zx
 
   473 op mul *tmp112 *tmp111 :compute:zy
   474 op add :compute:zy *tmp112 :compute:cy
   475 op len :compute:dist :compute:zx :compute:zy
-    * jump *label219 lessThan :compute:dist 64
-    * jump *label65 always
+  476 jump *label65 greaterThanEq :compute:dist 64
   477 label *label219
   478 op add :compute:i 27 1
   479 set :compute:x1 :compute:zx
 
   485 op mul *tmp112 *tmp111 :compute:zy
   486 op add :compute:zy *tmp112 :compute:cy
   487 op len :compute:dist :compute:zx :compute:zy
-    * jump *label222 lessThan :compute:dist 64
-    * jump *label65 always
+  488 jump *label65 greaterThanEq :compute:dist 64
   489 label *label222
   490 op add :compute:i 28 1
   491 set :compute:x1 :compute:zx
 
   497 op mul *tmp112 *tmp111 :compute:zy
   498 op add :compute:zy *tmp112 :compute:cy
   499 op len :compute:dist :compute:zx :compute:zy
-    * jump *label225 lessThan :compute:dist 64
-    * jump *label65 always
+  500 jump *label65 greaterThanEq :compute:dist 64
   501 label *label225
   502 op add :compute:i 29 1
   503 set :compute:x1 :compute:zx
 
   509 op mul *tmp112 *tmp111 :compute:zy
   510 op add :compute:zy *tmp112 :compute:cy
   511 op len :compute:dist :compute:zx :compute:zy
-    * jump *label228 lessThan :compute:dist 64
-    * jump *label65 always
+  512 jump *label65 greaterThanEq :compute:dist 64
   513 label *label228
   514 op add :compute:i 30 1
   515 set :compute:x1 :compute:zx
 
   521 op mul *tmp112 *tmp111 :compute:zy
   522 op add :compute:zy *tmp112 :compute:cy
   523 op len :compute:dist :compute:zx :compute:zy
-    * jump *label231 lessThan :compute:dist 64
-    * jump *label65 always
+  524 jump *label65 greaterThanEq :compute:dist 64
   525 label *label231
   526 op add :compute:i 31 1
   527 set :compute:x1 :compute:zx
 
   533 op mul *tmp112 *tmp111 :compute:zy
   534 op add :compute:zy *tmp112 :compute:cy
   535 op len :compute:dist :compute:zx :compute:zy
-    * jump *label234 lessThan :compute:dist 64
-    * jump *label65 always
+  536 jump *label65 greaterThanEq :compute:dist 64
   537 label *label234
   538 op add :compute:i 32 1
   539 set :compute:x1 :compute:zx
 
   545 op mul *tmp112 *tmp111 :compute:zy
   546 op add :compute:zy *tmp112 :compute:cy
   547 op len :compute:dist :compute:zx :compute:zy
-    * jump *label237 lessThan :compute:dist 64
-    * jump *label65 always
+  548 jump *label65 greaterThanEq :compute:dist 64
   549 label *label237
   550 op add :compute:i 33 1
   551 set :compute:x1 :compute:zx
 
   557 op mul *tmp112 *tmp111 :compute:zy
   558 op add :compute:zy *tmp112 :compute:cy
   559 op len :compute:dist :compute:zx :compute:zy
-    * jump *label240 lessThan :compute:dist 64
-    * jump *label65 always
+  560 jump *label65 greaterThanEq :compute:dist 64
   561 label *label240
   562 op add :compute:i 34 1
   563 set :compute:x1 :compute:zx
 
   569 op mul *tmp112 *tmp111 :compute:zy
   570 op add :compute:zy *tmp112 :compute:cy
   571 op len :compute:dist :compute:zx :compute:zy
-    * jump *label243 lessThan :compute:dist 64
-    * jump *label65 always
+  572 jump *label65 greaterThanEq :compute:dist 64
   573 label *label243
   574 op add :compute:i 35 1
   575 set :compute:x1 :compute:zx
 
   581 op mul *tmp112 *tmp111 :compute:zy
   582 op add :compute:zy *tmp112 :compute:cy
   583 op len :compute:dist :compute:zx :compute:zy
-    * jump *label246 lessThan :compute:dist 64
-    * jump *label65 always
+  584 jump *label65 greaterThanEq :compute:dist 64
   585 label *label246
   586 op add :compute:i 36 1
   587 set :compute:x1 :compute:zx
 
   593 op mul *tmp112 *tmp111 :compute:zy
   594 op add :compute:zy *tmp112 :compute:cy
   595 op len :compute:dist :compute:zx :compute:zy
-    * jump *label249 lessThan :compute:dist 64
-    * jump *label65 always
+  596 jump *label65 greaterThanEq :compute:dist 64
   597 label *label249
   598 op add :compute:i 37 1
   599 set :compute:x1 :compute:zx
 
   605 op mul *tmp112 *tmp111 :compute:zy
   606 op add :compute:zy *tmp112 :compute:cy
   607 op len :compute:dist :compute:zx :compute:zy
-    * jump *label252 lessThan :compute:dist 64
-    * jump *label65 always
+  608 jump *label65 greaterThanEq :compute:dist 64
   609 label *label252
   610 op add :compute:i 38 1
   611 set :compute:x1 :compute:zx
 
   617 op mul *tmp112 *tmp111 :compute:zy
   618 op add :compute:zy *tmp112 :compute:cy
   619 op len :compute:dist :compute:zx :compute:zy
-    * jump *label255 lessThan :compute:dist 64
-    * jump *label65 always
+  620 jump *label65 greaterThanEq :compute:dist 64
   621 label *label255
   622 op add :compute:i 39 1
   623 set :compute:x1 :compute:zx
 
   629 op mul *tmp112 *tmp111 :compute:zy
   630 op add :compute:zy *tmp112 :compute:cy
   631 op len :compute:dist :compute:zx :compute:zy
-    * jump *label258 lessThan :compute:dist 64
-    * jump *label65 always
+  632 jump *label65 greaterThanEq :compute:dist 64
   633 label *label258
   634 op add :compute:i 40 1
   635 set :compute:x1 :compute:zx
 
   641 op mul *tmp112 *tmp111 :compute:zy
   642 op add :compute:zy *tmp112 :compute:cy
   643 op len :compute:dist :compute:zx :compute:zy
-    * jump *label261 lessThan :compute:dist 64
-    * jump *label65 always
+  644 jump *label65 greaterThanEq :compute:dist 64
   645 label *label261
   646 op add :compute:i 41 1
   647 set :compute:x1 :compute:zx
 
   653 op mul *tmp112 *tmp111 :compute:zy
   654 op add :compute:zy *tmp112 :compute:cy
   655 op len :compute:dist :compute:zx :compute:zy
-    * jump *label264 lessThan :compute:dist 64
-    * jump *label65 always
+  656 jump *label65 greaterThanEq :compute:dist 64
   657 label *label264
   658 op add :compute:i 42 1
   659 set :compute:x1 :compute:zx
 
   665 op mul *tmp112 *tmp111 :compute:zy
   666 op add :compute:zy *tmp112 :compute:cy
   667 op len :compute:dist :compute:zx :compute:zy
-    * jump *label267 lessThan :compute:dist 64
-    * jump *label65 always
+  668 jump *label65 greaterThanEq :compute:dist 64
   669 label *label267
   670 op add :compute:i 43 1
   671 set :compute:x1 :compute:zx
 
   677 op mul *tmp112 *tmp111 :compute:zy
   678 op add :compute:zy *tmp112 :compute:cy
   679 op len :compute:dist :compute:zx :compute:zy
-    * jump *label270 lessThan :compute:dist 64
-    * jump *label65 always
+  680 jump *label65 greaterThanEq :compute:dist 64
   681 label *label270
   682 op add :compute:i 44 1
   683 set :compute:x1 :compute:zx
 
   689 op mul *tmp112 *tmp111 :compute:zy
   690 op add :compute:zy *tmp112 :compute:cy
   691 op len :compute:dist :compute:zx :compute:zy
-    * jump *label273 lessThan :compute:dist 64
-    * jump *label65 always
+  692 jump *label65 greaterThanEq :compute:dist 64
   693 label *label273
   694 op add :compute:i 45 1
   695 set :compute:x1 :compute:zx
 
   701 op mul *tmp112 *tmp111 :compute:zy
   702 op add :compute:zy *tmp112 :compute:cy
   703 op len :compute:dist :compute:zx :compute:zy
-    * jump *label276 lessThan :compute:dist 64
-    * jump *label65 always
+  704 jump *label65 greaterThanEq :compute:dist 64
   705 label *label276
   706 op add :compute:i 46 1
   707 set :compute:x1 :compute:zx
 
   713 op mul *tmp112 *tmp111 :compute:zy
   714 op add :compute:zy *tmp112 :compute:cy
   715 op len :compute:dist :compute:zx :compute:zy
-    * jump *label279 lessThan :compute:dist 64
-    * jump *label65 always
+  716 jump *label65 greaterThanEq :compute:dist 64
   717 label *label279
   718 op add :compute:i 47 1
   719 set :compute:x1 :compute:zx
 
   725 op mul *tmp112 *tmp111 :compute:zy
   726 op add :compute:zy *tmp112 :compute:cy
   727 op len :compute:dist :compute:zx :compute:zy
-    * jump *label282 lessThan :compute:dist 64
-    * jump *label65 always
+  728 jump *label65 greaterThanEq :compute:dist 64
   729 label *label282
   730 op add :compute:i 48 1
   731 set :compute:x1 :compute:zx
 
   737 op mul *tmp112 *tmp111 :compute:zy
   738 op add :compute:zy *tmp112 :compute:cy
   739 op len :compute:dist :compute:zx :compute:zy
-    * jump *label285 lessThan :compute:dist 64
-    * jump *label65 always
+  740 jump *label65 greaterThanEq :compute:dist 64
   741 label *label285
   742 op add :compute:i 49 1
   743 set :compute:x1 :compute:zx
 
   749 op mul *tmp112 *tmp111 :compute:zy
   750 op add :compute:zy *tmp112 :compute:cy
   751 op len :compute:dist :compute:zx :compute:zy
-    * jump *label288 lessThan :compute:dist 64
-    * jump *label65 always
+  752 jump *label65 greaterThanEq :compute:dist 64
   753 label *label288
   754 op add :compute:i 50 1
   755 set :compute:x1 :compute:zx
 
   761 op mul *tmp112 *tmp111 :compute:zy
   762 op add :compute:zy *tmp112 :compute:cy
   763 op len :compute:dist :compute:zx :compute:zy
-    * jump *label291 lessThan :compute:dist 64
-    * jump *label65 always
+  764 jump *label65 greaterThanEq :compute:dist 64
   765 label *label291
   766 op add :compute:i 51 1
   767 set :compute:x1 :compute:zx
 
   773 op mul *tmp112 *tmp111 :compute:zy
   774 op add :compute:zy *tmp112 :compute:cy
   775 op len :compute:dist :compute:zx :compute:zy
-    * jump *label294 lessThan :compute:dist 64
-    * jump *label65 always
+  776 jump *label65 greaterThanEq :compute:dist 64
   777 label *label294
   778 op add :compute:i 52 1
   779 set :compute:x1 :compute:zx
 
   785 op mul *tmp112 *tmp111 :compute:zy
   786 op add :compute:zy *tmp112 :compute:cy
   787 op len :compute:dist :compute:zx :compute:zy
-    * jump *label297 lessThan :compute:dist 64
-    * jump *label65 always
+  788 jump *label65 greaterThanEq :compute:dist 64
   789 label *label297
   790 op add :compute:i 53 1
   791 set :compute:x1 :compute:zx
 
   797 op mul *tmp112 *tmp111 :compute:zy
   798 op add :compute:zy *tmp112 :compute:cy
   799 op len :compute:dist :compute:zx :compute:zy
-    * jump *label300 lessThan :compute:dist 64
-    * jump *label65 always
+  800 jump *label65 greaterThanEq :compute:dist 64
   801 label *label300
   802 op add :compute:i 54 1
   803 set :compute:x1 :compute:zx
 
   809 op mul *tmp112 *tmp111 :compute:zy
   810 op add :compute:zy *tmp112 :compute:cy
   811 op len :compute:dist :compute:zx :compute:zy
-    * jump *label303 lessThan :compute:dist 64
-    * jump *label65 always
+  812 jump *label65 greaterThanEq :compute:dist 64
   813 label *label303
   814 op add :compute:i 55 1
   815 set :compute:x1 :compute:zx
 
   821 op mul *tmp112 *tmp111 :compute:zy
   822 op add :compute:zy *tmp112 :compute:cy
   823 op len :compute:dist :compute:zx :compute:zy
-    * jump *label306 lessThan :compute:dist 64
-    * jump *label65 always
+  824 jump *label65 greaterThanEq :compute:dist 64
   825 label *label306
   826 op add :compute:i 56 1
   827 set :compute:x1 :compute:zx
 
   833 op mul *tmp112 *tmp111 :compute:zy
   834 op add :compute:zy *tmp112 :compute:cy
   835 op len :compute:dist :compute:zx :compute:zy
-    * jump *label309 lessThan :compute:dist 64
-    * jump *label65 always
+  836 jump *label65 greaterThanEq :compute:dist 64
   837 label *label309
   838 op add :compute:i 57 1
   839 set :compute:x1 :compute:zx
 
   845 op mul *tmp112 *tmp111 :compute:zy
   846 op add :compute:zy *tmp112 :compute:cy
   847 op len :compute:dist :compute:zx :compute:zy
-    * jump *label312 lessThan :compute:dist 64
-    * jump *label65 always
+  848 jump *label65 greaterThanEq :compute:dist 64
   849 label *label312
   850 op add :compute:i 58 1
   851 set :compute:x1 :compute:zx
 
   857 op mul *tmp112 *tmp111 :compute:zy
   858 op add :compute:zy *tmp112 :compute:cy
   859 op len :compute:dist :compute:zx :compute:zy
-    * jump *label315 lessThan :compute:dist 64
-    * jump *label65 always
+  860 jump *label65 greaterThanEq :compute:dist 64
   861 label *label315
   862 op add :compute:i 59 1
   863 set :compute:x1 :compute:zx
 
   869 op mul *tmp112 *tmp111 :compute:zy
   870 op add :compute:zy *tmp112 :compute:cy
   871 op len :compute:dist :compute:zx :compute:zy
-    * jump *label318 lessThan :compute:dist 64
-    * jump *label65 always
+  872 jump *label65 greaterThanEq :compute:dist 64
   873 label *label318
   874 op add :compute:i 60 1
   875 set :compute:x1 :compute:zx
 
   881 op mul *tmp112 *tmp111 :compute:zy
   882 op add :compute:zy *tmp112 :compute:cy
   883 op len :compute:dist :compute:zx :compute:zy
-    * jump *label321 lessThan :compute:dist 64
-    * jump *label65 always
+  884 jump *label65 greaterThanEq :compute:dist 64
   885 label *label321
   886 op add :compute:i 61 1
   887 set :compute:x1 :compute:zx
 
   893 op mul *tmp112 *tmp111 :compute:zy
   894 op add :compute:zy *tmp112 :compute:cy
   895 op len :compute:dist :compute:zx :compute:zy
-    * jump *label324 lessThan :compute:dist 64
-    * jump *label65 always
+  896 jump *label65 greaterThanEq :compute:dist 64
   897 label *label324
   898 op add :compute:i 62 1
   899 label *label65
 
   990 label *label102
   991 wait 0
   992 read *tmp189 .memory 68
-    * jump *label106 equal .stop *tmp189
-    * jump *label4 always
+  993 jump *label4 notEqual .stop *tmp189
   994 label *label106
   995 read *tmp191 .memory 66
   996 op add *tmp2 *tmp191 1

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
 
    31 label *label11
    32 wait 0
    33 read *tmp38 .memory 68
-    * jump *label4 notEqual .stop *tmp38
+   34 jump *label3 notEqual .stop *tmp38
    35 read :batch .memory 64
    36 select *tmp42 greaterThanEq :batch 1408 1 4
    37 op add *tmp43 :batch *tmp42
 
    40 op mul *tmp47 11 *tmp42
    41 set :i 0
    42 op mul *tmp48 :batch 11
-    * jump *label22 lessThanEq *tmp42 0
+   43 jump *label11 lessThanEq *tmp42 0
    44 label *label119
    45 op add :adam5:index *tmp48 :i
    46 op idiv *tmp51 :adam5:index 16
 
   845 label *label56
   846 jump *label73 lessThanEq .PALETTE 1
   847 set :drawPixel:color %[black]
-    * jump *label76 equal *tmp89 63
+  848 jump *label74 equal *tmp89 63
   849 multijump .PALETTE 0 0 (m:*label131)
   850 multilabel *label136 (m:*label131)
   851 multilabel *label132 (m:*label131)
   852 op div *tmp163 *tmp89 63.75
   853 op sub :drawPixel:r 1 *tmp163
   854 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * jump *label77 always
+  855 jump *label74 always
   856 multilabel *label133 (m:*label131)
   857 op sub *tmp129 32 *tmp89
   858 op abs *tmp130 *tmp129
 
   865 op div *tmp142 *tmp130 63.75
   866 op add :drawPixel:b 0.47058823529411764 *tmp142
   867 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label77 always
+  868 jump *label74 always
   869 multilabel *label134 (m:*label131)
   870 op div *tmp146 *tmp89 0.175
   871 op sin :drawPixel:r *tmp146
 
   875 op div *tmp154 *tmp152 63.75
   876 op add :drawPixel:b 0.39215686274509803 *tmp154
   877 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label77 always
+  878 jump *label74 always
   879 multilabel *label135 (m:*label131)
   880 op div :drawPixel:r *tmp89 63.75
   881 op div :drawPixel:g *tmp89 170
 
   887 read :drawPixel:color .memory *tmp89
   888 label *label74
   889 jump *label84 lessThan .localBuffer 254
-    * jump *label89 lessThanEq .localBuffer 0
+  890 jump *label97 lessThanEq .localBuffer 0
   891 label *label121
   892 read *tmp173 .memory 68
   893 jump *label89 notEqual .stop *tmp173
 
   925 label *label102
   926 wait 0
   927 read *tmp189 .memory 68
-    * jump *label4 notEqual .stop *tmp189
+  928 jump *label3 notEqual .stop *tmp189
   929 read *tmp191 .memory 66
   930 op add *tmp2 *tmp191 1
   931 write *tmp2 .memory 66
 
   937 label *label22
   938 jump *label11 always
   939 label *label13
-    * jump *label111 lessThanEq .localBuffer 0
+  940 jump *label3 lessThanEq .localBuffer 0
   941 label *label122
   942 read *tmp197 .memory 68
-    * jump *label111 notEqual .stop *tmp197
+  943 jump *label3 notEqual .stop *tmp197
   944 wait 0
   945 sensor *tmp198 .display @enabled
   946 jump *label115 equal *tmp198 false

Final code before resolving virtual instructions:

    0:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label0                                                mandelbrot-compute.mnd: do while display == null || memory == null;
    1:  op equal *tmp14 .display null                                ...
    2:  op equal *tmp15 .memory null                                 ...
    3:  op or *tmp16 *tmp14 *tmp15                                   ...
    4:  jump *label0 notEqual *tmp16 false                           ...
        label *label3                                                mandelbrot-compute.mnd: MainLoop:
        label *label6                                                mandelbrot-compute.mnd: do wait(0); while start == $START;
    5:  wait 0                                                       ...
    6:  read *tmp18 .memory 67                                       ...
    7:  jump *label6 equal .start *tmp18                             ...
    8:  read .start .memory 67                                       mandelbrot-compute.mnd: start = $START;
    9:  read .stop .memory 68                                        mandelbrot-compute.mnd: stop = $STOP;
   10:  set .lastColor -1                                            mandelbrot-compute.mnd: lastColor = -1;
   11:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   12:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
   13:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
   14:  read .ZOOM .memory 71                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   15:  op div *tmp22 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   16:  read *tmp24 .memory 69                                       ...
   17:  op add .OFFSET_X *tmp22 *tmp24                               ...
   18:  read *tmp27 .memory 70                                       mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   19:  op add .OFFSET_Y *tmp22 *tmp27                               ...
   20:  read .JULIA .memory 72                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   21:  read .JULIA_X .memory 73                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   22:  read .JULIA_Y .memory 74                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   23:  read .PALETTE .memory 75                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   24:  read .ALL_PASS_COLORING .memory 76                           mandelbrot-compute.mnd: ALL_PASS_COLORING = $ALL_PASS_COLORING;
   25:  read *tmp34 .memory 77                                       mandelbrot-compute.mnd: var leaderLimit = $SHOW_LEADER ? 1 - ALL_PASS_COLORING : 99;
   26:  op sub *tmp203 1 .ALL_PASS_COLORING                          ...
   27:  select *tmp35 notEqual *tmp34 false *tmp203 99               ...
        label *label11                                               mandelbrot-compute.mnd: while true do
   28:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
   29:  read *tmp38 .memory 68                                       mandelbrot-compute.mnd: if stop != $STOP then
   30:  jump *label3 notEqual .stop *tmp38                           ...
   31:  read :batch .memory 64                                       mandelbrot-compute.mnd: batch = $LINE;
   32:  select *tmp42 greaterThanEq :batch 1408 1 4                  mandelbrot-compute.mnd: multiple = batch >= TOTAL_BATCHES / 2 ? 1 : 4;
   33:  op add *tmp43 :batch *tmp42                                  mandelbrot-compute.mnd: $LINE = batch + multiple;
   34:  write *tmp43 .memory 64                 # The last atomic bl ...
   35:  jump *label13 greaterThanEq :batch 2816                      mandelbrot-compute.mnd: if batch >= TOTAL_BATCHES then
   36:  op mul *tmp47 11 *tmp42                                      mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
   37:  set :i 0                                                     ...
   38:  op mul *tmp48 :batch 11                                      ...
   39:  jump *label11 lessThanEq *tmp42 0                            ...
        label *label119                                              ...
   40:  op add :adam5:index *tmp48 :i                                mandelbrot-compute.mnd: adam5(batch * BATCH_SIZE + i, out x, out y, out dx, out dy);
   41:  op idiv *tmp51 :adam5:index 16                               mandelbrot-compute.mnd: case index \ 16
   42:  multijump *tmp51 0 0                                         ...
        multilabel *label129                                         ...
   43:  op sub :adam5:index :adam5:index 15488                       mandelbrot-compute.mnd: index -= 8 * PASS_SIZE;
   44:  op mod :adam5:x :adam5:index 176                             mandelbrot-compute.mnd: x = (index % SIZE1);
   45:  op idiv *tmp78 :adam5:index 176                              mandelbrot-compute.mnd: y = 2 * (index \ SIZE1) + 1;
   46:  op mul *tmp79 2 *tmp78                                       ...
   47:  op add :adam5:y *tmp79 1                                     ...
   48:  set :adam5:dy 1                                              mandelbrot-compute.mnd: dx = dy = 1;
   49:  set :adam5:dx 1                                              ...
   50:  jump *label24 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label125                                         ...
   51:  op mod *tmp53 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4);
   52:  op mul :adam5:x 4 *tmp53                                     ...
   53:  op idiv *tmp55 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   54:  op mul :adam5:y 4 *tmp55                                     ...
   55:  select *tmp57 notEqual .ALL_PASS_COLORING false 4 2          mandelbrot-compute.mnd: dx = dy = ALL_PASS_COLORING ? 4 : 2;
   56:  set :adam5:dy *tmp57                                         ...
   57:  set :adam5:dx *tmp57                                         ...
   58:  jump *label24 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label126                                         ...
   59:  op sub :adam5:index :adam5:index 1936                        mandelbrot-compute.mnd: index -= PASS_SIZE;
   60:  op mod *tmp58 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4) + 2;
   61:  op mul *tmp59 4 *tmp58                                       ...
   62:  op add :adam5:x *tmp59 2                                     ...
   63:  op idiv *tmp61 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   64:  op mul :adam5:y 4 *tmp61                                     ...
   65:  select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1       mandelbrot-compute.mnd: dx = ALL_PASS_COLORING ? 2 : 1;
   66:  select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2       mandelbrot-compute.mnd: dy = ALL_PASS_COLORING ? 4 : 2;
   67:  jump *label24 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label127                                         ...
   68:  op sub :adam5:index :adam5:index 3872                        mandelbrot-compute.mnd: index -= 2 * PASS_SIZE;
   69:  op mod *tmp65 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2);
   70:  op mul :adam5:x 2 *tmp65                                     ...
   71:  op idiv *tmp67 :adam5:index 88                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE2) + 2;
   72:  op mul *tmp68 4 *tmp67                                       ...
   73:  op add :adam5:y *tmp68 2                                     ...
   74:  select *tmp70 notEqual .ALL_PASS_COLORING false 2 1          mandelbrot-compute.mnd: dx = dy = ALL_PASS_COLORING ? 2 : 1;
   75:  set :adam5:dy *tmp70                                         ...
   76:  set :adam5:dx *tmp70                                         ...
   77:  jump *label24 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label128                                         ...
   78:  op sub :adam5:index :adam5:index 7744                        mandelbrot-compute.mnd: index -= 4 * PASS_SIZE;
   79:  op mod *tmp71 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2) + 1;
   80:  op mul *tmp72 2 *tmp71                                       ...
   81:  op add :adam5:x *tmp72 1                                     ...
   82:  op idiv *tmp74 :adam5:index 88                               mandelbrot-compute.mnd: y = 2 * (index \ SIZE2);
   83:  op mul :adam5:y 2 *tmp74                                     ...
   84:  set :adam5:dx 1                                              mandelbrot-compute.mnd: dx = 1; dy = ALL_PASS_COLORING ? 2 : 1;
   85:  select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1       ...
        label *label24                                               mandelbrot-compute.mnd: case index \ 16
   86:  jump *label47 lessThanEq *tmp42 *tmp35                       mandelbrot-compute.mnd: if multiple > leaderLimit and localBuffer == 0 then
   87:  jump *label47 notEqual .localBuffer 0                        ...
   88:  draw col %[white] 0 0 0 0 0                                  mandelbrot-compute.mnd: col(%[white]);
   89:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dx);
   90:  set .lastColor %[white]                                      mandelbrot-compute.mnd: lastColor = %[white];
   91:  set .localBuffer 2                                           mandelbrot-compute.mnd: localBuffer = 2;
   92:  wait 0.004                              # 0.240 ticks for at mandelbrot-compute.mnd: atomic
   93:  sensor *tmp84 .display @enabled                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
   94:  jump *label52 equal *tmp84 false                             ...
   95:  sensor *tmp85 .display @bufferSize                           ...
   96:  jump *label52 greaterThanEq *tmp85 1022                      ...
   97:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
   98:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label52                                               mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label47                                               mandelbrot-compute.mnd: if multiple > leaderLimit and localBuffer == 0 then
   99:  op div *tmp90 :adam5:x .ZOOM                                 mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
  100:  op add :compute:zx *tmp90 .OFFSET_X                          ...
  101:  op div *tmp92 :adam5:y .ZOOM                                 mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
  102:  op add :compute:zy *tmp92 .OFFSET_Y                          ...
  103:  jump *label57 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
  104:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
  105:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
  106:  jump *label58 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label57                                               ...
  107:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
  108:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
  109:  op sub *tmp95 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
  110:  op len :compute:p *tmp95 :compute:zy                         ...
  111:  op mul *tmp97 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  112:  op mul *tmp98 *tmp97 :compute:p                              ...
  113:  op sub *tmp99 :compute:p *tmp98                              ...
  114:  op add *tmp100 *tmp99 0.25                                   ...
  115:  jump *label59 greaterThan :compute:zx *tmp100                ...
  116:  set *tmp89 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  117:  jump *label56 always 0 0                                     ...
        label *label59                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  118:  op add *tmp103 :compute:zx 1                                 mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  119:  op len *tmp104 *tmp103 :compute:zy                           ...
  120:  jump *label61 greaterThan *tmp104 0.25                       ...
  121:  set *tmp89 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  122:  jump *label56 always 0 0                                     ...
        label *label61                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label58                                               mandelbrot-compute.mnd: if JULIA then
  123:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  124:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  125:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  126:  op mul *tmp108 :compute:zy :compute:zy                       ...
  127:  op sub *tmp109 *tmp107 *tmp108                               ...
  128:  op add :compute:zx *tmp109 :compute:cx                       ...
  129:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  130:  op mul *tmp112 *tmp111 :compute:zy                           ...
  131:  op add :compute:zy *tmp112 :compute:cy                       ...
  132:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  133:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  134:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  135:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  136:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  137:  op mul *tmp108 :compute:zy :compute:zy                       ...
  138:  op sub *tmp109 *tmp107 *tmp108                               ...
  139:  op add :compute:zx *tmp109 :compute:cx                       ...
  140:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  141:  op mul *tmp112 *tmp111 :compute:zy                           ...
  142:  op add :compute:zy *tmp112 :compute:cy                       ...
  143:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  144:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  145:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  146:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  147:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  148:  op mul *tmp108 :compute:zy :compute:zy                       ...
  149:  op sub *tmp109 *tmp107 *tmp108                               ...
  150:  op add :compute:zx *tmp109 :compute:cx                       ...
  151:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  152:  op mul *tmp112 *tmp111 :compute:zy                           ...
  153:  op add :compute:zy *tmp112 :compute:cy                       ...
  154:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  155:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  156:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  157:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  158:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  159:  op mul *tmp108 :compute:zy :compute:zy                       ...
  160:  op sub *tmp109 *tmp107 *tmp108                               ...
  161:  op add :compute:zx *tmp109 :compute:cx                       ...
  162:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  163:  op mul *tmp112 *tmp111 :compute:zy                           ...
  164:  op add :compute:zy *tmp112 :compute:cy                       ...
  165:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  166:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  167:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  168:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  169:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  170:  op mul *tmp108 :compute:zy :compute:zy                       ...
  171:  op sub *tmp109 *tmp107 *tmp108                               ...
  172:  op add :compute:zx *tmp109 :compute:cx                       ...
  173:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  174:  op mul *tmp112 *tmp111 :compute:zy                           ...
  175:  op add :compute:zy *tmp112 :compute:cy                       ...
  176:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  177:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  178:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  179:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  180:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  181:  op mul *tmp108 :compute:zy :compute:zy                       ...
  182:  op sub *tmp109 *tmp107 *tmp108                               ...
  183:  op add :compute:zx *tmp109 :compute:cx                       ...
  184:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  185:  op mul *tmp112 *tmp111 :compute:zy                           ...
  186:  op add :compute:zy *tmp112 :compute:cy                       ...
  187:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  188:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  189:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  190:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  191:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  192:  op mul *tmp108 :compute:zy :compute:zy                       ...
  193:  op sub *tmp109 *tmp107 *tmp108                               ...
  194:  op add :compute:zx *tmp109 :compute:cx                       ...
  195:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  196:  op mul *tmp112 *tmp111 :compute:zy                           ...
  197:  op add :compute:zy *tmp112 :compute:cy                       ...
  198:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  199:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  200:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  201:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  202:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  203:  op mul *tmp108 :compute:zy :compute:zy                       ...
  204:  op sub *tmp109 *tmp107 *tmp108                               ...
  205:  op add :compute:zx *tmp109 :compute:cx                       ...
  206:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  207:  op mul *tmp112 *tmp111 :compute:zy                           ...
  208:  op add :compute:zy *tmp112 :compute:cy                       ...
  209:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  210:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  211:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  212:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  213:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  214:  op mul *tmp108 :compute:zy :compute:zy                       ...
  215:  op sub *tmp109 *tmp107 *tmp108                               ...
  216:  op add :compute:zx *tmp109 :compute:cx                       ...
  217:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  218:  op mul *tmp112 *tmp111 :compute:zy                           ...
  219:  op add :compute:zy *tmp112 :compute:cy                       ...
  220:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  221:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  222:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  223:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  224:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  225:  op mul *tmp108 :compute:zy :compute:zy                       ...
  226:  op sub *tmp109 *tmp107 *tmp108                               ...
  227:  op add :compute:zx *tmp109 :compute:cx                       ...
  228:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  229:  op mul *tmp112 *tmp111 :compute:zy                           ...
  230:  op add :compute:zy *tmp112 :compute:cy                       ...
  231:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  232:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  233:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  234:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  235:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  236:  op mul *tmp108 :compute:zy :compute:zy                       ...
  237:  op sub *tmp109 *tmp107 *tmp108                               ...
  238:  op add :compute:zx *tmp109 :compute:cx                       ...
  239:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  240:  op mul *tmp112 *tmp111 :compute:zy                           ...
  241:  op add :compute:zy *tmp112 :compute:cy                       ...
  242:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  243:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  244:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  245:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  246:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  247:  op mul *tmp108 :compute:zy :compute:zy                       ...
  248:  op sub *tmp109 *tmp107 *tmp108                               ...
  249:  op add :compute:zx *tmp109 :compute:cx                       ...
  250:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  251:  op mul *tmp112 *tmp111 :compute:zy                           ...
  252:  op add :compute:zy *tmp112 :compute:cy                       ...
  253:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  254:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  255:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  256:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  257:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  258:  op mul *tmp108 :compute:zy :compute:zy                       ...
  259:  op sub *tmp109 *tmp107 *tmp108                               ...
  260:  op add :compute:zx *tmp109 :compute:cx                       ...
  261:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  262:  op mul *tmp112 *tmp111 :compute:zy                           ...
  263:  op add :compute:zy *tmp112 :compute:cy                       ...
  264:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  265:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  266:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  267:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  268:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  269:  op mul *tmp108 :compute:zy :compute:zy                       ...
  270:  op sub *tmp109 *tmp107 *tmp108                               ...
  271:  op add :compute:zx *tmp109 :compute:cx                       ...
  272:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  273:  op mul *tmp112 *tmp111 :compute:zy                           ...
  274:  op add :compute:zy *tmp112 :compute:cy                       ...
  275:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  276:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  277:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  278:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  279:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  280:  op mul *tmp108 :compute:zy :compute:zy                       ...
  281:  op sub *tmp109 *tmp107 *tmp108                               ...
  282:  op add :compute:zx *tmp109 :compute:cx                       ...
  283:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  284:  op mul *tmp112 *tmp111 :compute:zy                           ...
  285:  op add :compute:zy *tmp112 :compute:cy                       ...
  286:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  287:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  288:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  289:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  290:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  291:  op mul *tmp108 :compute:zy :compute:zy                       ...
  292:  op sub *tmp109 *tmp107 *tmp108                               ...
  293:  op add :compute:zx *tmp109 :compute:cx                       ...
  294:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  295:  op mul *tmp112 *tmp111 :compute:zy                           ...
  296:  op add :compute:zy *tmp112 :compute:cy                       ...
  297:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  298:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  299:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  300:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  301:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  302:  op mul *tmp108 :compute:zy :compute:zy                       ...
  303:  op sub *tmp109 *tmp107 *tmp108                               ...
  304:  op add :compute:zx *tmp109 :compute:cx                       ...
  305:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  306:  op mul *tmp112 *tmp111 :compute:zy                           ...
  307:  op add :compute:zy *tmp112 :compute:cy                       ...
  308:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  309:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  310:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  311:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  312:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  313:  op mul *tmp108 :compute:zy :compute:zy                       ...
  314:  op sub *tmp109 *tmp107 *tmp108                               ...
  315:  op add :compute:zx *tmp109 :compute:cx                       ...
  316:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  317:  op mul *tmp112 *tmp111 :compute:zy                           ...
  318:  op add :compute:zy *tmp112 :compute:cy                       ...
  319:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  320:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  321:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  322:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  323:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  324:  op mul *tmp108 :compute:zy :compute:zy                       ...
  325:  op sub *tmp109 *tmp107 *tmp108                               ...
  326:  op add :compute:zx *tmp109 :compute:cx                       ...
  327:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  328:  op mul *tmp112 *tmp111 :compute:zy                           ...
  329:  op add :compute:zy *tmp112 :compute:cy                       ...
  330:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  331:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  332:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  333:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  334:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  335:  op mul *tmp108 :compute:zy :compute:zy                       ...
  336:  op sub *tmp109 *tmp107 *tmp108                               ...
  337:  op add :compute:zx *tmp109 :compute:cx                       ...
  338:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  339:  op mul *tmp112 *tmp111 :compute:zy                           ...
  340:  op add :compute:zy *tmp112 :compute:cy                       ...
  341:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  342:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  343:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  344:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  345:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  346:  op mul *tmp108 :compute:zy :compute:zy                       ...
  347:  op sub *tmp109 *tmp107 *tmp108                               ...
  348:  op add :compute:zx *tmp109 :compute:cx                       ...
  349:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  350:  op mul *tmp112 *tmp111 :compute:zy                           ...
  351:  op add :compute:zy *tmp112 :compute:cy                       ...
  352:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  353:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  354:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  355:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  356:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  357:  op mul *tmp108 :compute:zy :compute:zy                       ...
  358:  op sub *tmp109 *tmp107 *tmp108                               ...
  359:  op add :compute:zx *tmp109 :compute:cx                       ...
  360:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  361:  op mul *tmp112 *tmp111 :compute:zy                           ...
  362:  op add :compute:zy *tmp112 :compute:cy                       ...
  363:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  364:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  365:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  366:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  367:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  368:  op mul *tmp108 :compute:zy :compute:zy                       ...
  369:  op sub *tmp109 *tmp107 *tmp108                               ...
  370:  op add :compute:zx *tmp109 :compute:cx                       ...
  371:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  372:  op mul *tmp112 *tmp111 :compute:zy                           ...
  373:  op add :compute:zy *tmp112 :compute:cy                       ...
  374:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  375:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  376:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  377:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  378:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  379:  op mul *tmp108 :compute:zy :compute:zy                       ...
  380:  op sub *tmp109 *tmp107 *tmp108                               ...
  381:  op add :compute:zx *tmp109 :compute:cx                       ...
  382:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  383:  op mul *tmp112 *tmp111 :compute:zy                           ...
  384:  op add :compute:zy *tmp112 :compute:cy                       ...
  385:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  386:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  387:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  388:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  389:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  390:  op mul *tmp108 :compute:zy :compute:zy                       ...
  391:  op sub *tmp109 *tmp107 *tmp108                               ...
  392:  op add :compute:zx *tmp109 :compute:cx                       ...
  393:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  394:  op mul *tmp112 *tmp111 :compute:zy                           ...
  395:  op add :compute:zy *tmp112 :compute:cy                       ...
  396:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  397:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  398:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  399:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  400:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  401:  op mul *tmp108 :compute:zy :compute:zy                       ...
  402:  op sub *tmp109 *tmp107 *tmp108                               ...
  403:  op add :compute:zx *tmp109 :compute:cx                       ...
  404:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  405:  op mul *tmp112 *tmp111 :compute:zy                           ...
  406:  op add :compute:zy *tmp112 :compute:cy                       ...
  407:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  408:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  409:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  410:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  411:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  412:  op mul *tmp108 :compute:zy :compute:zy                       ...
  413:  op sub *tmp109 *tmp107 *tmp108                               ...
  414:  op add :compute:zx *tmp109 :compute:cx                       ...
  415:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  416:  op mul *tmp112 *tmp111 :compute:zy                           ...
  417:  op add :compute:zy *tmp112 :compute:cy                       ...
  418:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  419:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  420:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  421:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  422:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  423:  op mul *tmp108 :compute:zy :compute:zy                       ...
  424:  op sub *tmp109 *tmp107 *tmp108                               ...
  425:  op add :compute:zx *tmp109 :compute:cx                       ...
  426:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  427:  op mul *tmp112 *tmp111 :compute:zy                           ...
  428:  op add :compute:zy *tmp112 :compute:cy                       ...
  429:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  430:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  431:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  432:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  433:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  434:  op mul *tmp108 :compute:zy :compute:zy                       ...
  435:  op sub *tmp109 *tmp107 *tmp108                               ...
  436:  op add :compute:zx *tmp109 :compute:cx                       ...
  437:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  438:  op mul *tmp112 *tmp111 :compute:zy                           ...
  439:  op add :compute:zy *tmp112 :compute:cy                       ...
  440:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  441:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  442:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  443:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  444:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  445:  op mul *tmp108 :compute:zy :compute:zy                       ...
  446:  op sub *tmp109 *tmp107 *tmp108                               ...
  447:  op add :compute:zx *tmp109 :compute:cx                       ...
  448:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  449:  op mul *tmp112 *tmp111 :compute:zy                           ...
  450:  op add :compute:zy *tmp112 :compute:cy                       ...
  451:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  452:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  453:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  454:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  455:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  456:  op mul *tmp108 :compute:zy :compute:zy                       ...
  457:  op sub *tmp109 *tmp107 *tmp108                               ...
  458:  op add :compute:zx *tmp109 :compute:cx                       ...
  459:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  460:  op mul *tmp112 *tmp111 :compute:zy                           ...
  461:  op add :compute:zy *tmp112 :compute:cy                       ...
  462:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  463:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  464:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  465:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  466:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  467:  op mul *tmp108 :compute:zy :compute:zy                       ...
  468:  op sub *tmp109 *tmp107 *tmp108                               ...
  469:  op add :compute:zx *tmp109 :compute:cx                       ...
  470:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  471:  op mul *tmp112 *tmp111 :compute:zy                           ...
  472:  op add :compute:zy *tmp112 :compute:cy                       ...
  473:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  474:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  475:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  476:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  477:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  478:  op mul *tmp108 :compute:zy :compute:zy                       ...
  479:  op sub *tmp109 *tmp107 *tmp108                               ...
  480:  op add :compute:zx *tmp109 :compute:cx                       ...
  481:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  482:  op mul *tmp112 *tmp111 :compute:zy                           ...
  483:  op add :compute:zy *tmp112 :compute:cy                       ...
  484:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  485:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  486:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  487:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  488:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  489:  op mul *tmp108 :compute:zy :compute:zy                       ...
  490:  op sub *tmp109 *tmp107 *tmp108                               ...
  491:  op add :compute:zx *tmp109 :compute:cx                       ...
  492:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  493:  op mul *tmp112 *tmp111 :compute:zy                           ...
  494:  op add :compute:zy *tmp112 :compute:cy                       ...
  495:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  496:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  497:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  498:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  499:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  500:  op mul *tmp108 :compute:zy :compute:zy                       ...
  501:  op sub *tmp109 *tmp107 *tmp108                               ...
  502:  op add :compute:zx *tmp109 :compute:cx                       ...
  503:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  504:  op mul *tmp112 *tmp111 :compute:zy                           ...
  505:  op add :compute:zy *tmp112 :compute:cy                       ...
  506:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  507:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  508:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  509:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  510:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  511:  op mul *tmp108 :compute:zy :compute:zy                       ...
  512:  op sub *tmp109 *tmp107 *tmp108                               ...
  513:  op add :compute:zx *tmp109 :compute:cx                       ...
  514:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  515:  op mul *tmp112 *tmp111 :compute:zy                           ...
  516:  op add :compute:zy *tmp112 :compute:cy                       ...
  517:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  518:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  519:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  520:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  521:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  522:  op mul *tmp108 :compute:zy :compute:zy                       ...
  523:  op sub *tmp109 *tmp107 *tmp108                               ...
  524:  op add :compute:zx *tmp109 :compute:cx                       ...
  525:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  526:  op mul *tmp112 *tmp111 :compute:zy                           ...
  527:  op add :compute:zy *tmp112 :compute:cy                       ...
  528:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  529:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  530:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  531:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  532:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  533:  op mul *tmp108 :compute:zy :compute:zy                       ...
  534:  op sub *tmp109 *tmp107 *tmp108                               ...
  535:  op add :compute:zx *tmp109 :compute:cx                       ...
  536:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  537:  op mul *tmp112 *tmp111 :compute:zy                           ...
  538:  op add :compute:zy *tmp112 :compute:cy                       ...
  539:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  540:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  541:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  542:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  543:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  544:  op mul *tmp108 :compute:zy :compute:zy                       ...
  545:  op sub *tmp109 *tmp107 *tmp108                               ...
  546:  op add :compute:zx *tmp109 :compute:cx                       ...
  547:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  548:  op mul *tmp112 *tmp111 :compute:zy                           ...
  549:  op add :compute:zy *tmp112 :compute:cy                       ...
  550:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  551:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  552:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  553:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  554:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  555:  op mul *tmp108 :compute:zy :compute:zy                       ...
  556:  op sub *tmp109 *tmp107 *tmp108                               ...
  557:  op add :compute:zx *tmp109 :compute:cx                       ...
  558:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  559:  op mul *tmp112 *tmp111 :compute:zy                           ...
  560:  op add :compute:zy *tmp112 :compute:cy                       ...
  561:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  562:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  563:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  564:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  565:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  566:  op mul *tmp108 :compute:zy :compute:zy                       ...
  567:  op sub *tmp109 *tmp107 *tmp108                               ...
  568:  op add :compute:zx *tmp109 :compute:cx                       ...
  569:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  570:  op mul *tmp112 *tmp111 :compute:zy                           ...
  571:  op add :compute:zy *tmp112 :compute:cy                       ...
  572:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  573:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  574:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  575:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  576:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  577:  op mul *tmp108 :compute:zy :compute:zy                       ...
  578:  op sub *tmp109 *tmp107 *tmp108                               ...
  579:  op add :compute:zx *tmp109 :compute:cx                       ...
  580:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  581:  op mul *tmp112 *tmp111 :compute:zy                           ...
  582:  op add :compute:zy *tmp112 :compute:cy                       ...
  583:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  584:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  585:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  586:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  587:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  588:  op mul *tmp108 :compute:zy :compute:zy                       ...
  589:  op sub *tmp109 *tmp107 *tmp108                               ...
  590:  op add :compute:zx *tmp109 :compute:cx                       ...
  591:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  592:  op mul *tmp112 *tmp111 :compute:zy                           ...
  593:  op add :compute:zy *tmp112 :compute:cy                       ...
  594:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  595:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  596:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  597:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  598:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  599:  op mul *tmp108 :compute:zy :compute:zy                       ...
  600:  op sub *tmp109 *tmp107 *tmp108                               ...
  601:  op add :compute:zx *tmp109 :compute:cx                       ...
  602:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  603:  op mul *tmp112 *tmp111 :compute:zy                           ...
  604:  op add :compute:zy *tmp112 :compute:cy                       ...
  605:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  606:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  607:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  608:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  609:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  610:  op mul *tmp108 :compute:zy :compute:zy                       ...
  611:  op sub *tmp109 *tmp107 *tmp108                               ...
  612:  op add :compute:zx *tmp109 :compute:cx                       ...
  613:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  614:  op mul *tmp112 *tmp111 :compute:zy                           ...
  615:  op add :compute:zy *tmp112 :compute:cy                       ...
  616:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  617:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  618:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  619:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  620:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  621:  op mul *tmp108 :compute:zy :compute:zy                       ...
  622:  op sub *tmp109 *tmp107 *tmp108                               ...
  623:  op add :compute:zx *tmp109 :compute:cx                       ...
  624:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  625:  op mul *tmp112 *tmp111 :compute:zy                           ...
  626:  op add :compute:zy *tmp112 :compute:cy                       ...
  627:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  628:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  629:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  630:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  631:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  632:  op mul *tmp108 :compute:zy :compute:zy                       ...
  633:  op sub *tmp109 *tmp107 *tmp108                               ...
  634:  op add :compute:zx *tmp109 :compute:cx                       ...
  635:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  636:  op mul *tmp112 *tmp111 :compute:zy                           ...
  637:  op add :compute:zy *tmp112 :compute:cy                       ...
  638:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  639:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  640:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  641:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  642:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  643:  op mul *tmp108 :compute:zy :compute:zy                       ...
  644:  op sub *tmp109 *tmp107 *tmp108                               ...
  645:  op add :compute:zx *tmp109 :compute:cx                       ...
  646:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  647:  op mul *tmp112 *tmp111 :compute:zy                           ...
  648:  op add :compute:zy *tmp112 :compute:cy                       ...
  649:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  650:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  651:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  652:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  653:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  654:  op mul *tmp108 :compute:zy :compute:zy                       ...
  655:  op sub *tmp109 *tmp107 *tmp108                               ...
  656:  op add :compute:zx *tmp109 :compute:cx                       ...
  657:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  658:  op mul *tmp112 *tmp111 :compute:zy                           ...
  659:  op add :compute:zy *tmp112 :compute:cy                       ...
  660:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  661:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  662:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  663:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  664:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  665:  op mul *tmp108 :compute:zy :compute:zy                       ...
  666:  op sub *tmp109 *tmp107 *tmp108                               ...
  667:  op add :compute:zx *tmp109 :compute:cx                       ...
  668:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  669:  op mul *tmp112 *tmp111 :compute:zy                           ...
  670:  op add :compute:zy *tmp112 :compute:cy                       ...
  671:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  672:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  673:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  674:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  675:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  676:  op mul *tmp108 :compute:zy :compute:zy                       ...
  677:  op sub *tmp109 *tmp107 *tmp108                               ...
  678:  op add :compute:zx *tmp109 :compute:cx                       ...
  679:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  680:  op mul *tmp112 *tmp111 :compute:zy                           ...
  681:  op add :compute:zy *tmp112 :compute:cy                       ...
  682:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  683:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  684:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  685:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  686:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  687:  op mul *tmp108 :compute:zy :compute:zy                       ...
  688:  op sub *tmp109 *tmp107 *tmp108                               ...
  689:  op add :compute:zx *tmp109 :compute:cx                       ...
  690:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  691:  op mul *tmp112 *tmp111 :compute:zy                           ...
  692:  op add :compute:zy *tmp112 :compute:cy                       ...
  693:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  694:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  695:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  696:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  697:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  698:  op mul *tmp108 :compute:zy :compute:zy                       ...
  699:  op sub *tmp109 *tmp107 *tmp108                               ...
  700:  op add :compute:zx *tmp109 :compute:cx                       ...
  701:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  702:  op mul *tmp112 *tmp111 :compute:zy                           ...
  703:  op add :compute:zy *tmp112 :compute:cy                       ...
  704:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  705:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  706:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  707:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  708:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  709:  op mul *tmp108 :compute:zy :compute:zy                       ...
  710:  op sub *tmp109 *tmp107 *tmp108                               ...
  711:  op add :compute:zx *tmp109 :compute:cx                       ...
  712:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  713:  op mul *tmp112 *tmp111 :compute:zy                           ...
  714:  op add :compute:zy *tmp112 :compute:cy                       ...
  715:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  716:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  717:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  718:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  719:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  720:  op mul *tmp108 :compute:zy :compute:zy                       ...
  721:  op sub *tmp109 *tmp107 *tmp108                               ...
  722:  op add :compute:zx *tmp109 :compute:cx                       ...
  723:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  724:  op mul *tmp112 *tmp111 :compute:zy                           ...
  725:  op add :compute:zy *tmp112 :compute:cy                       ...
  726:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  727:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  728:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  729:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  730:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  731:  op mul *tmp108 :compute:zy :compute:zy                       ...
  732:  op sub *tmp109 *tmp107 *tmp108                               ...
  733:  op add :compute:zx *tmp109 :compute:cx                       ...
  734:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  735:  op mul *tmp112 *tmp111 :compute:zy                           ...
  736:  op add :compute:zy *tmp112 :compute:cy                       ...
  737:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  738:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  739:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  740:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  741:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  742:  op mul *tmp108 :compute:zy :compute:zy                       ...
  743:  op sub *tmp109 *tmp107 *tmp108                               ...
  744:  op add :compute:zx *tmp109 :compute:cx                       ...
  745:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  746:  op mul *tmp112 *tmp111 :compute:zy                           ...
  747:  op add :compute:zy *tmp112 :compute:cy                       ...
  748:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  749:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  750:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  751:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  752:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  753:  op mul *tmp108 :compute:zy :compute:zy                       ...
  754:  op sub *tmp109 *tmp107 *tmp108                               ...
  755:  op add :compute:zx *tmp109 :compute:cx                       ...
  756:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  757:  op mul *tmp112 *tmp111 :compute:zy                           ...
  758:  op add :compute:zy *tmp112 :compute:cy                       ...
  759:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  760:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  761:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  762:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  763:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  764:  op mul *tmp108 :compute:zy :compute:zy                       ...
  765:  op sub *tmp109 *tmp107 *tmp108                               ...
  766:  op add :compute:zx *tmp109 :compute:cx                       ...
  767:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  768:  op mul *tmp112 *tmp111 :compute:zy                           ...
  769:  op add :compute:zy *tmp112 :compute:cy                       ...
  770:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  771:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  772:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  773:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  774:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  775:  op mul *tmp108 :compute:zy :compute:zy                       ...
  776:  op sub *tmp109 *tmp107 *tmp108                               ...
  777:  op add :compute:zx *tmp109 :compute:cx                       ...
  778:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  779:  op mul *tmp112 *tmp111 :compute:zy                           ...
  780:  op add :compute:zy *tmp112 :compute:cy                       ...
  781:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  782:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  783:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  784:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  785:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  786:  op mul *tmp108 :compute:zy :compute:zy                       ...
  787:  op sub *tmp109 *tmp107 *tmp108                               ...
  788:  op add :compute:zx *tmp109 :compute:cx                       ...
  789:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  790:  op mul *tmp112 *tmp111 :compute:zy                           ...
  791:  op add :compute:zy *tmp112 :compute:cy                       ...
  792:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  793:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  794:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  795:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  796:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  797:  op mul *tmp108 :compute:zy :compute:zy                       ...
  798:  op sub *tmp109 *tmp107 *tmp108                               ...
  799:  op add :compute:zx *tmp109 :compute:cx                       ...
  800:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  801:  op mul *tmp112 *tmp111 :compute:zy                           ...
  802:  op add :compute:zy *tmp112 :compute:cy                       ...
  803:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  804:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  805:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  806:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  807:  op mul *tmp107 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  808:  op mul *tmp108 :compute:zy :compute:zy                       ...
  809:  op sub *tmp109 *tmp107 *tmp108                               ...
  810:  op add :compute:zx *tmp109 :compute:cx                       ...
  811:  op mul *tmp111 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  812:  op mul *tmp112 *tmp111 :compute:zy                           ...
  813:  op add :compute:zy *tmp112 :compute:cy                       ...
  814:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  815:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  816:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label65                                               ...
  817:  jump *label68 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  818:  jump *label68 greaterThanEq :compute:i 63                    ...
  819:  op log *tmp119 :compute:dist 0                               mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  820:  op mul *tmp120 *tmp119 0.36067376022224085                   ...
  821:  op log *tmp121 *tmp120 0                                     ...
  822:  op mul *tmp122 *tmp121 1.4426950408889634                    ...
  823:  op sub :compute:correction 4 *tmp122                         ...
  824:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label68                                               mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  825:  set *tmp89 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label56                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  826:  jump *label73 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH then
  827:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  828:  jump *label74 equal *tmp89 63                                mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  829:  multijump .PALETTE 0 0                                       mandelbrot-compute.mnd: case PALETTE
        multilabel *label136                                         ...
        multilabel *label132                                         ...
  830:  op div *tmp163 *tmp89 63.75                                  mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  831:  op sub :drawPixel:r 1 *tmp163                                ...
  832:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  833:  jump *label74 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label133                                         ...
  834:  op sub *tmp129 32 *tmp89                                     mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  835:  op abs *tmp130 *tmp129 0                                     ...
  836:  op div *tmp132 *tmp130 36.42857142857143                     ...
  837:  op sub :drawPixel:r 1 *tmp132                                ...
  838:  op sub *tmp134 *tmp89 32                                     mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  839:  op abs *tmp135 *tmp134 0                                     ...
  840:  op div *tmp137 *tmp135 42.5                                  ...
  841:  op sub :drawPixel:g 0.9411764705882353 *tmp137               ...
  842:  op div *tmp142 *tmp130 63.75                                 mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  843:  op add :drawPixel:b 0.47058823529411764 *tmp142              ...
  844:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  845:  jump *label74 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label134                                         ...
  846:  op div *tmp146 *tmp89 0.175                                  mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  847:  op sin :drawPixel:r *tmp146 0                                ...
  848:  op cos :drawPixel:g *tmp146 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  849:  op sub *tmp151 *tmp89 32                                     mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  850:  op abs *tmp152 *tmp151 0                                     ...
  851:  op div *tmp154 *tmp152 63.75                                 ...
  852:  op add :drawPixel:b 0.39215686274509803 *tmp154              ...
  853:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  854:  jump *label74 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label135                                         ...
  855:  op div :drawPixel:r *tmp89 63.75                             mandelbrot-compute.mnd: r = 4 * iterations / 255;
  856:  op div :drawPixel:g *tmp89 170                               mandelbrot-compute.mnd: g = 1.5 * iterations / 255;
  857:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  858:  jump *label74 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label73                                               ...
  859:  read :drawPixel:color .memory *tmp89                         mandelbrot-compute.mnd: color = memory[iterations];
        label *label74                                               mandelbrot-compute.mnd: if SMOOTH then
  860:  jump *label84 lessThan .localBuffer 254                      mandelbrot-compute.mnd: if localBuffer >= 254 then
  861:  jump *label97 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label121                                              ...
  862:  read *tmp173 .memory 68                                      ...
  863:  jump *label89 notEqual .stop *tmp173                         ...
  864:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  865:  sensor *tmp174 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  866:  jump *label93 equal *tmp174 false                            ...
  867:  sensor *tmp175 .display @bufferSize                          ...
  868:  op sub *tmp176 1024 *tmp175                                  ...
  869:  jump *label93 greaterThanEq .localBuffer *tmp176             ...
  870:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  871:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label93                                               mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  872:  jump *label121 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label89                                               ...
        label *label84                                               mandelbrot-compute.mnd: if localBuffer >= 254 then
  873:  jump *label97 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  874:  jump *label97 strictNotEqual :drawPixel:color .lastColor     ...
  875:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  876:  op add .localBuffer .localBuffer 1                           mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  877:  jump *label98 always 0 0                                     ...
        label *label97                                               ...
  878:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  879:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  880:  set .lastColor :drawPixel:color                              mandelbrot-compute.mnd: lastColor = color;
  881:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
        label *label98                                               mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  882:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  883:  sensor *tmp183 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  884:  jump *label102 equal *tmp183 false                           ...
  885:  sensor *tmp184 .display @bufferSize                          ...
  886:  op sub *tmp185 1024 *tmp184                                  ...
  887:  jump *label102 greaterThanEq .localBuffer *tmp185            ...
  888:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  889:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label102                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  890:  wait 0.006                              # 0.360 ticks for at mandelbrot-compute.mnd: atomic
  891:  read *tmp189 .memory 68                                      mandelbrot-compute.mnd: if stop != $STOP then
  892:  jump *label3 notEqual .stop *tmp189                          ...
  893:  read *tmp191 .memory 66                                      mandelbrot-compute.mnd: atomic
  894:  op add *tmp2 *tmp191 1                                       ...
  895:  write *tmp2 .memory 66                                       ...
  896:  read *tmp193 .memory 65                                      mandelbrot-compute.mnd: $ITERATIONS += iterations;
  897:  op add *tmp194 *tmp193 *tmp89                                ...
  898:  write *tmp194 .memory 65                # The last atomic bl ...
  899:  op add :i :i 1                                               mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
  900:  jump *label119 lessThan :i *tmp47                            ...
  901:  jump *label11 always 0 0                                     mandelbrot-compute.mnd: while true do
        label *label13                                               ...
  902:  jump *label3 lessThanEq .localBuffer 0                       mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label122                                              ...
  903:  read *tmp197 .memory 68                                      ...
  904:  jump *label3 notEqual .stop *tmp197                          ...
  905:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  906:  sensor *tmp198 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  907:  jump *label115 equal *tmp198 false                           ...
  908:  sensor *tmp199 .display @bufferSize                          ...
  909:  op sub *tmp200 1024 *tmp199                                  ...
  910:  jump *label115 greaterThanEq .localBuffer *tmp200            ...
  911:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  912:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label115                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  913:  jump *label122 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
  914:  jump *label3 always 0 0                                      mandelbrot-compute.mnd: MainLoop:


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   727     1x    727,0  inline def compute(in x, in y)
    61     1x     61,0  <no function>
    45     1x     45,0  void adam5(in index, out x, out y, out dx, out dy)
    44     1x     44,0  inline void drawPixel(in x, in y, in dx, in dy, in iterations)
    31     4x      7,8  inline void tryFlush()
     8     2x      4,0  inline void flush()
Runtime error at instruction #2: 'op equal *tmp15 .memory null':
Execution step limit of 100,000 exceeded.

Performance: parsed in 307 ms, compiled in 265 ms, optimized in 1,567 ms, run in 148 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (100,000 steps):
The program didn't generate any output.
