   502 instructions before optimizations.
    51 instructions eliminated by Temp Variables Elimination (2 passes, 9 iterations).
     2 instructions eliminated by Case Expression Optimization.
    49 instructions eliminated by Dead Code Elimination (6 iterations).
     5 instructions eliminated by Jump Normalization (2 passes, 7 iterations).
    25 instructions eliminated by Condition Optimization (2 passes, 9 iterations).
    24 instructions eliminated by Single Step Elimination (2 passes, 9 iterations).
     4 instructions eliminated by Expression Optimization (2 passes, 5 iterations).
    19 instructions eliminated by Boolean Optimization (2 passes, 9 iterations).
       9 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by If Expression Optimization (5 iterations).
    55 instructions eliminated by Data Flow Optimization (6 passes, 24 iterations).
     1 loops improved by Loop Hoisting.
       5 loop conditions were partially rotated.
   741 instructions added by Loop Unrolling (11 iterations).
     4 loops unrolled by Loop Unrolling.
    12 instructions eliminated by Case Switching (11 iterations).
     2 case expressions converted to fast dispatch by Case Switching.
    69 instructions eliminated by Jump Straightening (2 passes, 9 iterations).
     9 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
     7 instructions eliminated by Print Merging.
   919 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 711):
    Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity
  * Unroll iteration loop at *blocks:68:13                       size    -9, benefit     9375.0, efficiency   Infinity (-3 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:125:5           size   -11, benefit   242187.5, efficiency   Infinity
    Fast-dispatch case at mandelbrot-compute.mnd:214:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 714):
  * Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:125:5           size   -11, benefit   242187.5, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:214:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 718):
  * Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity (-2 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:125:5           size   -11, benefit   242187.5, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:214:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 720):
  * Fast-dispatch case at mandelbrot-compute.mnd:125:5           size   -11, benefit   242187.5, efficiency   Infinity (-10 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:214:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 730):
  * Fast-dispatch case at mandelbrot-compute.mnd:214:13          size    -2, benefit     3906.3, efficiency   Infinity (-2 instructions)

Pass 2: speed optimization selection (cost limit 743):
  * Unroll loop at mandelbrot-compute.mnd:186:5                  size  +679, benefit 49218750.0, efficiency  72487.113 (+743 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
   183 op add *tmp53 *tmp52 :i
   184 set :adam5:index *tmp53
   185 op idiv *tmp55 :adam5:index 16
-    * set *tmp56 *tmp55
-    * jump *label48 lessThan *tmp56 0
-    * jump *label47 lessThan *tmp56 121
+  186 jump *label48 lessThan *tmp55 0
+  187 jump *label47 lessThan *tmp55 121
   188 label *label48
   189 jump *label46 always
   190 label *label47
 
   205 set *tmp54 :adam5:dx
   206 jump *label45 always
   207 label *label46
-    * jump *label53 lessThan *tmp56 121
-    * jump *label52 lessThan *tmp56 242
+  208 jump *label53 lessThan *tmp55 121
+  209 jump *label52 lessThan *tmp55 242
   210 label *label53
   211 jump *label51 always
   212 label *label52
 
   235 set *tmp54 :adam5:dy
   236 jump *label45 always
   237 label *label51
-    * jump *label60 lessThan *tmp56 242
-    * jump *label59 lessThan *tmp56 484
+  238 jump *label60 lessThan *tmp55 242
+  239 jump *label59 lessThan *tmp55 484
   240 label *label60
   241 jump *label58 always
   242 label *label59
 
   259 set *tmp54 :adam5:dx
   260 jump *label45 always
   261 label *label58
-    * jump *label65 lessThan *tmp56 484
-    * jump *label64 lessThan *tmp56 968
+  262 jump *label65 lessThan *tmp55 484
+  263 jump *label64 lessThan *tmp55 968
   264 label *label65
   265 jump *label63 always
   266 label *label64
 
   407 set *tmp122 :drawPixel:color
   408 jump *label88 always
   409 label *label87
-    * set *tmp124 .PALETTE
-    * jump *label91 equal *tmp124 2
+  410 jump *label91 equal .PALETTE 2
   411 jump *label90 always
   412 label *label91
   413 op sub *tmp125 32 :drawPixel:iterations
 
   433 set *tmp123 :drawPixel:color
   434 jump *label89 always
   435 label *label90
-    * jump *label93 equal *tmp124 3
+  436 jump *label93 equal .PALETTE 3
   437 jump *label92 always
   438 label *label93
   439 op div *tmp141 :drawPixel:iterations 63
 
   455 set *tmp123 :drawPixel:color
   456 jump *label89 always
   457 label *label92
-    * jump *label95 equal *tmp124 4
+  458 jump *label95 equal .PALETTE 4
   459 jump *label94 always
   460 label *label95
   461 op mul *tmp153 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-38 instructions):
 
    58 label *label19
    59 set *tmp21 null
    60 label *label20
-    * set *tmp19 *tmp21
    61 jump *label18 always
    62 label *label17
-    * set *tmp19 null
    63 label *label18
    64 label *label13
    65 multijump *tmp17 0 0 (m:marker1)
 
    91 print :findLinkedBlocks:variable
    92 jump *label26 equal :findLinkedBlocks:required false
    93 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * set *tmp23 :findLinkedBlocks:foundAll
    94 jump *label27 always
    95 label *label26
-    * set *tmp23 null
    96 label *label27
    97 label *label22
    98 multijump *tmp22 0 0 (m:marker2)
 
   152 op notEqual *tmp42 .stop *tmp43
   153 jump *label37 equal *tmp42 false
   154 jump *label29 always
-    * set *tmp44 null
   155 jump *label38 always
   156 label *label37
-    * set *tmp44 null
   157 label *label38
   158 read *tmp45 .memory 64
   159 set :batch *tmp45
 
   163 op greaterThanEq *tmp48 :batch 2816
   164 jump *label39 equal *tmp48 false
   165 jump *label36 always
-    * set *tmp49 null
   166 jump *label40 always
   167 label *label39
-    * set *tmp49 null
   168 label *label40
   169 op mul *tmp50 11 :multiple
   170 set *tmp51 *tmp50
 
   194 label *label50
   195 set :adam5:dy *tmp61
   196 set :adam5:dx :adam5:dy
-    * set *tmp54 :adam5:dx
   197 jump *label45 always
   198 label *label46
   199 jump *label53 lessThan *tmp55 121
 
   223 set *tmp68 1
   224 label *label57
   225 set :adam5:dy *tmp68
-    * set *tmp54 :adam5:dy
   226 jump *label45 always
   227 label *label51
   228 jump *label60 lessThan *tmp55 242
 
   246 label *label62
   247 set :adam5:dy *tmp74
   248 set :adam5:dx :adam5:dy
-    * set *tmp54 :adam5:dx
   249 jump *label45 always
   250 label *label58
   251 jump *label65 lessThan *tmp55 484
 
   269 set *tmp80 1
   270 label *label67
   271 set :adam5:dy *tmp80
-    * set *tmp54 :adam5:dy
   272 jump *label45 always
   273 label *label63
   274 op sub :adam5:index :adam5:index 15488
 
   280 set :adam5:y *tmp84
   281 set :adam5:dy 1
   282 set :adam5:dx :adam5:dy
-    * set *tmp54 :adam5:dx
   283 label *label45
   284 label *label44
   285 set :x :adam5:x
 
   297 jump *label69 equal .JULIA false
   298 set :compute:cx .JULIA_X
   299 set :compute:cy .JULIA_Y
-    * set *tmp90 :compute:cy
   300 jump *label70 always
   301 label *label69
   302 set :compute:cx :compute:zx
 
   312 jump *label71 equal *tmp97 false
   313 set *tmp85 63
   314 jump *label68 always
-    * set *tmp98 null
   315 jump *label72 always
   316 label *label71
-    * set *tmp98 null
   317 label *label72
   318 op add *tmp99 :compute:cx 1
   319 op len *tmp100 *tmp99 :compute:cy
 
   326 label *label73
   327 set *tmp102 null
   328 label *label74
-    * set *tmp90 *tmp102
   329 label *label70
   330 set :compute:i 0
   331 label *label75
 
   346 op greaterThanEq *tmp111 :compute:dist 64
   347 jump *label78 equal *tmp111 false
   348 jump *label77 always
-    * set *tmp112 null
   349 jump *label79 always
   350 label *label78
-    * set *tmp112 null
   351 label *label79
   352 label *label76
   353 op add :compute:i :compute:i 1
 
   366 op sub *tmp119 4 *tmp118
   367 set :compute:correction *tmp119
   368 op add :compute:i :compute:i :compute:correction
-    * set *tmp114 :compute:i
   369 jump *label81 always
   370 label *label80
-    * set *tmp114 null
   371 label *label81
   372 set *tmp85 :compute:i
   373 jump *label68 always
 
   458 label *label89
   459 set *tmp122 *tmp123
   460 label *label88
-    * set *tmp120 *tmp122
   461 jump *label86 always
   462 label *label85
   463 set *tmp162 :drawPixel:iterations
   464 read *tmp164 .memory *tmp162
   465 set :drawPixel:color *tmp164
-    * set *tmp120 :drawPixel:color
   466 label *label86
   467 op greaterThanEq *tmp165 .localBuffer 254
   468 jump *label96 equal *tmp165 false
 
   487 label *label107
   488 drawflush .display
   489 set .localBuffer 0
-    * set *tmp174 .localBuffer
   490 jump *label106 always
   491 label *label105
-    * set *tmp174 null
   492 label *label106
   493 label *label104
   494 label *label100
   495 jump *label99 always
   496 label *label101
   497 label *label98
-    * set *tmp166 null
   498 jump *label97 always
   499 label *label96
-    * set *tmp166 null
   500 label *label97
   501 op greaterThan *tmp175 .localBuffer 0
   502 jump *label109 equal *tmp175 false
 
   508 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   509 set *tmp178 .localBuffer
   510 op add .localBuffer .localBuffer 1
-    * set *tmp177 *tmp178
   511 jump *label110 always
   512 label *label109
   513 draw col :drawPixel:color
   514 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   515 set .lastColor :drawPixel:color
   516 op add .localBuffer .localBuffer 2
-    * set *tmp177 .localBuffer
   517 label *label110
   518 wait 0
   519 sensor *tmp179 .display @enabled
 
   527 label *label116
   528 drawflush .display
   529 set .localBuffer 0
-    * set *tmp183 .localBuffer
   530 jump *label115 always
   531 label *label114
-    * set *tmp183 null
   532 label *label115
   533 label *label113
   534 label *label84
 
   537 op notEqual *tmp184 .stop *tmp185
   538 jump *label118 equal *tmp184 false
   539 jump *label29 always
-    * set *tmp186 null
   540 jump *label119 always
   541 label *label118
-    * set *tmp186 null
   542 label *label119
   543 read *tmp187 .memory 66
-    * set *tmp188 *tmp187
   544 op add *tmp2 *tmp187 1
   545 write *tmp2 .memory 66
   546 read *tmp189 .memory 65
 
   553 op greaterThanEq *tmp191 :batch 1337.6
   554 jump *label120 equal *tmp191 false
   555 set :multiple 1
-    * set *tmp192 :multiple
   556 jump *label121 always
   557 label *label120
-    * set *tmp192 null
   558 label *label121
   559 label *label35
   560 jump *label34 always
 
   580 label *label131
   581 drawflush .display
   582 set .localBuffer 0
-    * set *tmp200 .localBuffer
   583 jump *label130 always
   584 label *label129
-    * set *tmp200 null
   585 label *label130
   586 label *label128
   587 label *label124

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-7 instructions):
 
    53 op equal *tmp20 :findLinkedBlocks:requested @message
    54 jump *label19 equal *tmp20 false
    55 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * set *tmp21 :findLinkedBlocks:message
    56 jump *label20 always
    57 label *label19
-    * set *tmp21 null
    58 label *label20
    59 jump *label18 always
    60 label *label17
 
   319 jump *label73 equal *tmp101 false
   320 set *tmp85 63
   321 jump *label68 always
-    * set *tmp102 null
   322 jump *label74 always
   323 label *label73
-    * set *tmp102 null
   324 label *label74
   325 label *label70
   326 set :compute:i 0
 
   379 op equal *tmp121 :drawPixel:iterations 63
   380 jump *label87 equal *tmp121 false
   381 set :drawPixel:color %[black]
-    * set *tmp122 :drawPixel:color
   382 jump *label88 always
   383 label *label87
   384 jump *label91 equal .PALETTE 2
 
   451 set :drawPixel:color *tmp161
   452 set *tmp123 :drawPixel:color
   453 label *label89
-    * set *tmp122 *tmp123
   454 label *label88
   455 jump *label86 always
   456 label *label85
 
   500 jump *label111 always
   501 label *label111
   502 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
-    * set *tmp178 .localBuffer
   503 op add .localBuffer .localBuffer 1
   504 jump *label110 always
   505 label *label109

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   404 set :drawPixel:b *tmp139
   405 packcolor *tmp140 :drawPixel:r :drawPixel:g :drawPixel:b 1
   406 set :drawPixel:color *tmp140
-    * set *tmp123 :drawPixel:color
   407 jump *label89 always
   408 label *label90
   409 jump *label93 equal .PALETTE 3
 
   425 set :drawPixel:b *tmp151
   426 packcolor *tmp152 :drawPixel:r :drawPixel:g :drawPixel:b 1
   427 set :drawPixel:color *tmp152
-    * set *tmp123 :drawPixel:color
   428 jump *label89 always
   429 label *label92
   430 jump *label95 equal .PALETTE 4
 
   438 set :drawPixel:g *tmp156
   439 packcolor *tmp157 :drawPixel:r :drawPixel:g 0 1
   440 set :drawPixel:color *tmp157
-    * set *tmp123 :drawPixel:color
   441 jump *label89 always
   442 label *label94
   443 op mul *tmp158 4 :drawPixel:iterations
 
   446 set :drawPixel:r *tmp160
   447 packcolor *tmp161 :drawPixel:r :drawPixel:r 0 1
   448 set :drawPixel:color *tmp161
-    * set *tmp123 :drawPixel:color
   449 label *label89
   450 label *label88
   451 jump *label86 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-48 instructions):
 
    27 op greaterThan *tmp14 :findLinkedBlocks:n 0
    28 jump *label11 equal *tmp14 false
    29 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
-    * getlink *tmp15 :findLinkedBlocks:n
-    * set :findLinkedBlocks:block *tmp15
+   30 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    31 print "\nFound: "
    32 print :findLinkedBlocks:block
-    * sensor *tmp16 :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:type *tmp16
+   33 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    34 set :findLinkedBlocks:requested @large-logic-display
    35 set :findLinkedBlocks:name "Display"
    36 set :findLinkedBlocks:variable .display
 
   110 op equal *tmp25 .start *tmp26
   111 jump *label31 notEqual *tmp25 false
   112 label *label33
-    * read *tmp27 .memory 67
-    * set .start *tmp27
-    * read *tmp28 .memory 68
-    * set .stop *tmp28
+  113 read .start .memory 67
+  114 read .stop .memory 68
   115 set .lastColor -1
   116 set .localBuffer 0
   117 drawflush null
   118 drawflush .display
-    * read *tmp29 .memory 71
-    * set .ZOOM *tmp29
+  119 read .ZOOM .memory 71
   120 op div *tmp30 -88 .ZOOM
   121 read *tmp32 .memory 69
-    * op add *tmp31 *tmp30 *tmp32
-    * set .OFFSET_X *tmp31
+  122 op add .OFFSET_X *tmp30 *tmp32
   123 op div *tmp33 -88 .ZOOM
   124 read *tmp35 .memory 70
-    * op add *tmp34 *tmp33 *tmp35
-    * set .OFFSET_Y *tmp34
-    * read *tmp36 .memory 72
-    * set .JULIA *tmp36
-    * read *tmp37 .memory 73
-    * set .JULIA_X *tmp37
-    * read *tmp38 .memory 74
-    * set .JULIA_Y *tmp38
-    * read *tmp39 .memory 75
-    * set .PALETTE *tmp39
-    * op greaterThan *tmp40 .PALETTE 1
-    * set .SMOOTH *tmp40
-    * read *tmp41 .memory 76
-    * set .FILL_PASS *tmp41
+  125 op add .OFFSET_Y *tmp33 *tmp35
+  126 read .JULIA .memory 72
+  127 read .JULIA_X .memory 73
+  128 read .JULIA_Y .memory 74
+  129 read .PALETTE .memory 75
+  130 op greaterThan .SMOOTH .PALETTE 1
+  131 read .FILL_PASS .memory 76
   132 set :multiple 4
   133 label *label34
   134 jump *label36 equal true false
 
   140 jump *label38 always
   141 label *label37
   142 label *label38
-    * read *tmp45 .memory 64
-    * set :batch *tmp45
+  143 read :batch .memory 64
   144 read *tmp46 .memory 64
   145 op add *tmp47 *tmp46 :multiple
   146 write *tmp47 .memory 64
 
   150 jump *label40 always
   151 label *label39
   152 label *label40
-    * op mul *tmp50 11 :multiple
-    * set *tmp51 *tmp50
+  153 op mul *tmp51 11 :multiple
   154 set :i 0
   155 label *label41
   156 jump *label43 greaterThanEq :i *tmp51
   157 op mul *tmp52 :batch 11
-    * op add *tmp53 *tmp52 :i
-    * set :adam5:index *tmp53
+  158 op add :adam5:index *tmp52 :i
   159 op idiv *tmp55 :adam5:index 16
   160 jump *label48 lessThan *tmp55 0
   161 jump *label47 lessThan *tmp55 121
 
   163 jump *label46 always
   164 label *label47
   165 op mod *tmp57 :adam5:index 44
-    * op mul *tmp58 4 *tmp57
-    * set :adam5:x *tmp58
+  166 op mul :adam5:x 4 *tmp57
   167 op idiv *tmp59 :adam5:index 44
-    * op mul *tmp60 4 *tmp59
-    * set :adam5:y *tmp60
+  168 op mul :adam5:y 4 *tmp59
   169 jump *label49 equal .FILL_PASS false
   170 set *tmp61 4
   171 jump *label50 always
 
   184 op sub :adam5:index :adam5:index 1936
   185 op mod *tmp62 :adam5:index 44
   186 op mul *tmp63 4 *tmp62
-    * op add *tmp64 *tmp63 2
-    * set :adam5:x *tmp64
+  187 op add :adam5:x *tmp63 2
   188 op idiv *tmp65 :adam5:index 44
-    * op mul *tmp66 4 *tmp65
-    * set :adam5:y *tmp66
+  189 op mul :adam5:y 4 *tmp65
   190 jump *label54 equal .FILL_PASS false
   191 set *tmp67 2
   192 jump *label55 always
 
   210 label *label59
   211 op sub :adam5:index :adam5:index 3872
   212 op mod *tmp69 :adam5:index 88
-    * op mul *tmp70 2 *tmp69
-    * set :adam5:x *tmp70
+  213 op mul :adam5:x 2 *tmp69
   214 op idiv *tmp71 :adam5:index 88
   215 op mul *tmp72 4 *tmp71
-    * op add *tmp73 *tmp72 2
-    * set :adam5:y *tmp73
+  216 op add :adam5:y *tmp72 2
   217 jump *label61 equal .FILL_PASS false
   218 set *tmp74 2
   219 jump *label62 always
 
   232 op sub :adam5:index :adam5:index 7744
   233 op mod *tmp75 :adam5:index 88
   234 op mul *tmp76 2 *tmp75
-    * op add *tmp77 *tmp76 1
-    * set :adam5:x *tmp77
+  235 op add :adam5:x *tmp76 1
   236 op idiv *tmp78 :adam5:index 88
-    * op mul *tmp79 2 *tmp78
-    * set :adam5:y *tmp79
+  237 op mul :adam5:y 2 *tmp78
   238 set :adam5:dx 1
   239 jump *label66 equal .FILL_PASS false
   240 set *tmp80 2
 
   246 jump *label45 always
   247 label *label63
   248 op sub :adam5:index :adam5:index 15488
-    * op mod *tmp81 :adam5:index 176
-    * set :adam5:x *tmp81
+  249 op mod :adam5:x :adam5:index 176
   250 op idiv *tmp82 :adam5:index 176
   251 op mul *tmp83 2 *tmp82
-    * op add *tmp84 *tmp83 1
-    * set :adam5:y *tmp84
+  252 op add :adam5:y *tmp83 1
   253 set :adam5:dy 1
   254 set :adam5:dx :adam5:dy
   255 label *label45
 
   261 set :compute:x :x
   262 set :compute:y :y
   263 op div *tmp86 :compute:x .ZOOM
-    * op add *tmp87 *tmp86 .OFFSET_X
-    * set :compute:zx *tmp87
+  264 op add :compute:zx *tmp86 .OFFSET_X
   265 op div *tmp88 :compute:y .ZOOM
-    * op add *tmp89 *tmp88 .OFFSET_Y
-    * set :compute:zy *tmp89
+  266 op add :compute:zy *tmp88 .OFFSET_Y
   267 jump *label69 equal .JULIA false
   268 set :compute:cx .JULIA_X
   269 set :compute:cy .JULIA_Y
 
   272 set :compute:cx :compute:zx
   273 set :compute:cy :compute:zy
   274 op sub *tmp91 :compute:cx 0.25
-    * op len *tmp92 *tmp91 :compute:cy
-    * set :compute:p *tmp92
+  275 op len :compute:p *tmp91 :compute:cy
   276 op mul *tmp93 2 :compute:p
   277 op mul *tmp94 *tmp93 :compute:p
   278 op sub *tmp95 :compute:p *tmp94
 
   302 op mul *tmp103 :compute:x1 :compute:x1
   303 op mul *tmp104 :compute:y1 :compute:y1
   304 op sub *tmp105 *tmp103 *tmp104
-    * op add *tmp106 *tmp105 :compute:cx
-    * set :compute:zx *tmp106
+  305 op add :compute:zx *tmp105 :compute:cx
   306 op mul *tmp107 2 :compute:x1
   307 op mul *tmp108 *tmp107 :compute:y1
-    * op add *tmp109 *tmp108 :compute:cy
-    * set :compute:zy *tmp109
-    * op len *tmp110 :compute:zx :compute:zy
-    * set :compute:dist *tmp110
+  308 op add :compute:zy *tmp108 :compute:cy
+  309 op len :compute:dist :compute:zx :compute:zy
   310 op greaterThanEq *tmp111 :compute:dist 64
   311 jump *label78 equal *tmp111 false
   312 jump *label77 always
 
   327 op mul *tmp116 *tmp115 0.36067376022224085
   328 op log *tmp117 *tmp116
   329 op mul *tmp118 *tmp117 1.4426950408889634
-    * op sub *tmp119 4 *tmp118
-    * set :compute:correction *tmp119
+  330 op sub :compute:correction 4 *tmp118
   331 op add :compute:i :compute:i :compute:correction
   332 jump *label81 always
   333 label *label80
 
   355 op abs *tmp126 *tmp125
   356 op mul *tmp127 7 *tmp126
   357 op div *tmp128 *tmp127 255
-    * op sub *tmp129 1 *tmp128
-    * set :drawPixel:r *tmp129
+  358 op sub :drawPixel:r 1 *tmp128
   359 op sub *tmp130 :drawPixel:iterations 32
   360 op abs *tmp131 *tmp130
   361 op mul *tmp132 6 *tmp131
   362 op div *tmp133 *tmp132 255
-    * op sub *tmp134 0.9411764705882353 *tmp133
-    * set :drawPixel:g *tmp134
+  363 op sub :drawPixel:g 0.9411764705882353 *tmp133
   364 op sub *tmp135 32 :drawPixel:iterations
   365 op abs *tmp136 *tmp135
   366 op mul *tmp137 4 *tmp136
   367 op div *tmp138 *tmp137 255
-    * op add *tmp139 0.47058823529411764 *tmp138
-    * set :drawPixel:b *tmp139
-    * packcolor *tmp140 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp140
+  368 op add :drawPixel:b 0.47058823529411764 *tmp138
+  369 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   370 jump *label89 always
   371 label *label90
   372 jump *label93 equal .PALETTE 3
 
   374 label *label93
   375 op div *tmp141 :drawPixel:iterations 63
   376 op mul *tmp142 *tmp141 360
-    * op sin *tmp143 *tmp142
-    * set :drawPixel:r *tmp143
+  377 op sin :drawPixel:r *tmp142
   378 op div *tmp144 :drawPixel:iterations 63
   379 op mul *tmp145 *tmp144 360
-    * op cos *tmp146 *tmp145
-    * set :drawPixel:g *tmp146
+  380 op cos :drawPixel:g *tmp145
   381 op sub *tmp147 :drawPixel:iterations 32
   382 op abs *tmp148 *tmp147
   383 op mul *tmp149 4 *tmp148
   384 op div *tmp150 *tmp149 255
-    * op add *tmp151 0.39215686274509803 *tmp150
-    * set :drawPixel:b *tmp151
-    * packcolor *tmp152 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp152
+  385 op add :drawPixel:b 0.39215686274509803 *tmp150
+  386 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   387 jump *label89 always
   388 label *label92
   389 jump *label95 equal .PALETTE 4
   390 jump *label94 always
   391 label *label95
   392 op mul *tmp153 4 :drawPixel:iterations
-    * op div *tmp154 *tmp153 255
-    * set :drawPixel:r *tmp154
+  393 op div :drawPixel:r *tmp153 255
   394 op mul *tmp155 1.5 :drawPixel:iterations
-    * op div *tmp156 *tmp155 255
-    * set :drawPixel:g *tmp156
-    * packcolor *tmp157 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp157
+  395 op div :drawPixel:g *tmp155 255
+  396 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   397 jump *label89 always
   398 label *label94
   399 op mul *tmp158 4 :drawPixel:iterations
   400 op div *tmp159 *tmp158 255
-    * op sub *tmp160 1 *tmp159
-    * set :drawPixel:r *tmp160
-    * packcolor *tmp161 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp161
+  401 op sub :drawPixel:r 1 *tmp159
+  402 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   403 label *label89
   404 label *label88
   405 jump *label86 always
   406 label *label85
-    * set *tmp162 :drawPixel:iterations
-    * read *tmp164 .memory *tmp162
-    * set :drawPixel:color *tmp164
+  407 read :drawPixel:color .memory :drawPixel:iterations
   408 label *label86
   409 op greaterThanEq *tmp165 .localBuffer 254
   410 jump *label96 equal *tmp165 false

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
   102 label *label3
   103 label *label0
   104 label *label28
-    * jump *label30 equal true false
   105 label *label31
   106 wait 0
   107 label *label32
 
   130 read .FILL_PASS .memory 76
   131 set :multiple 4
   132 label *label34
-    * jump *label36 equal true false
   133 wait 0
   134 read *tmp43 .memory 68
   135 op notEqual *tmp42 .stop *tmp43

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   346 set :drawPixel:color %[black]
   347 jump *label88 always
   348 label *label87
-    * jump *label91 equal .PALETTE 2
-    * jump *label90 always
+  349 jump *label90 notEqual .PALETTE 2
   350 label *label91
   351 op sub *tmp125 32 :drawPixel:iterations
   352 op abs *tmp126 *tmp125
 
   366 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   367 jump *label89 always
   368 label *label90
-    * jump *label93 equal .PALETTE 3
-    * jump *label92 always
+  369 jump *label92 notEqual .PALETTE 3
   370 label *label93
   371 op div *tmp141 :drawPixel:iterations 63
   372 op mul *tmp142 *tmp141 360
 
   382 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   383 jump *label89 always
   384 label *label92
-    * jump *label95 equal .PALETTE 4
-    * jump *label94 always
+  385 jump *label94 notEqual .PALETTE 4
   386 label *label95
   387 op mul *tmp153 4 :drawPixel:iterations
   388 op div :drawPixel:r *tmp153 255

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-24 instructions):
 
    24 print :findLinkedBlocks:title
    25 set :findLinkedBlocks:n @links
    26 label *label9
-    * op greaterThan *tmp14 :findLinkedBlocks:n 0
-    * jump *label11 equal *tmp14 false
+   27 jump *label11 lessThanEq :findLinkedBlocks:n 0
    28 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    29 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    30 print "\nFound: "
 
    44 set :findLinkedBlocks:required true
    45 setaddr *tmp17 *label16
    46 label *label12
-    * op equal *tmp18 :findLinkedBlocks:requested :findLinkedBlocks:type
-    * jump *label17 equal *tmp18 false
+   47 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * op equal *tmp20 :findLinkedBlocks:requested @message
-    * jump *label19 equal *tmp20 false
+   49 jump *label19 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
    51 jump *label20 always
    52 label *label19
 
    94 label *label23
    95 printflush :findLinkedBlocks:message
    96 label *label2
-    * op equal *tmp24 :findLinkedBlocks:foundAll false
-    * jump *label1 notEqual *tmp24 false
+   97 jump *label1 equal :findLinkedBlocks:foundAll false
    98 label *label3
    99 label *label0
   100 label *label28
 
   102 wait 0
   103 label *label32
   104 read *tmp26 .memory 67
-    * op equal *tmp25 .start *tmp26
-    * jump *label31 notEqual *tmp25 false
+  105 jump *label31 equal .start *tmp26
   106 label *label33
   107 read .start .memory 67
   108 read .stop .memory 68
 
   127 label *label34
   128 wait 0
   129 read *tmp43 .memory 68
-    * op notEqual *tmp42 .stop *tmp43
-    * jump *label37 equal *tmp42 false
+  130 jump *label37 equal .stop *tmp43
   131 jump *label29 always
   132 jump *label38 always
   133 label *label37
 
   136 read *tmp46 .memory 64
   137 op add *tmp47 *tmp46 :multiple
   138 write *tmp47 .memory 64
-    * op greaterThanEq *tmp48 :batch 2816
-    * jump *label39 equal *tmp48 false
+  139 jump *label39 lessThan :batch 2816
   140 jump *label36 always
   141 jump *label40 always
   142 label *label39
 
   268 op mul *tmp94 *tmp93 :compute:p
   269 op sub *tmp95 :compute:p *tmp94
   270 op add *tmp96 *tmp95 0.25
-    * op lessThanEq *tmp97 :compute:cx *tmp96
-    * jump *label71 equal *tmp97 false
+  271 jump *label71 greaterThan :compute:cx *tmp96
   272 set *tmp85 63
   273 jump *label68 always
   274 jump *label72 always
 
   276 label *label72
   277 op add *tmp99 :compute:cx 1
   278 op len *tmp100 *tmp99 :compute:cy
-    * op lessThanEq *tmp101 *tmp100 0.25
-    * jump *label73 equal *tmp101 false
+  279 jump *label73 greaterThan *tmp100 0.25
   280 set *tmp85 63
   281 jump *label68 always
   282 jump *label74 always
 
   296 op mul *tmp108 *tmp107 :compute:y1
   297 op add :compute:zy *tmp108 :compute:cy
   298 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp111 :compute:dist 64
-    * jump *label78 equal *tmp111 false
+  299 jump *label78 lessThan :compute:dist 64
   300 jump *label77 always
   301 jump *label79 always
   302 label *label78
 
   307 label *label77
   308 jump *label80 equal .SMOOTH false
   309 label *label83
-    * op lessThan *tmp113 :compute:i 63
-    * jump *label80 equal *tmp113 false
+  310 jump *label80 greaterThanEq :compute:i 63
   311 jump *label82 always
   312 label *label82
   313 op log *tmp115 :compute:dist
 
   330 set :drawPixel:dy :dy
   331 set :drawPixel:iterations :iterations
   332 jump *label85 equal .SMOOTH false
-    * op equal *tmp121 :drawPixel:iterations 63
-    * jump *label87 equal *tmp121 false
+  333 jump *label87 notEqual :drawPixel:iterations 63
   334 set :drawPixel:color %[black]
   335 jump *label88 always
   336 label *label87
 
   389 label *label85
   390 read :drawPixel:color .memory :drawPixel:iterations
   391 label *label86
-    * op greaterThanEq *tmp165 .localBuffer 254
-    * jump *label96 equal *tmp165 false
+  392 jump *label96 lessThan .localBuffer 254
   393 label *label99
-    * op greaterThan *tmp167 .localBuffer 0
-    * jump *label101 equal *tmp167 false
+  394 jump *label101 lessThanEq .localBuffer 0
   395 label *label103
   396 read *tmp169 .memory 68
-    * op equal *tmp168 .stop *tmp169
-    * jump *label101 equal *tmp168 false
+  397 jump *label101 notEqual .stop *tmp169
   398 jump *label102 always
   399 label *label102
   400 wait 0
 
   403 label *label108
   404 sensor *tmp171 .display @bufferSize
   405 op sub *tmp172 1024 *tmp171
-    * op lessThan *tmp173 .localBuffer *tmp172
-    * jump *label105 equal *tmp173 false
+  406 jump *label105 greaterThanEq .localBuffer *tmp172
   407 jump *label107 always
   408 label *label107
   409 drawflush .display
 
   419 jump *label97 always
   420 label *label96
   421 label *label97
-    * op greaterThan *tmp175 .localBuffer 0
-    * jump *label109 equal *tmp175 false
+  422 jump *label109 lessThanEq .localBuffer 0
   423 label *label112
-    * op strictEqual *tmp176 :drawPixel:color .lastColor
-    * jump *label109 equal *tmp176 false
+  424 jump *label109 strictNotEqual :drawPixel:color .lastColor
   425 jump *label111 always
   426 label *label111
   427 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
 
   439 label *label117
   440 sensor *tmp180 .display @bufferSize
   441 op sub *tmp181 1024 *tmp180
-    * op lessThan *tmp182 .localBuffer *tmp181
-    * jump *label114 equal *tmp182 false
+  442 jump *label114 greaterThanEq .localBuffer *tmp181
   443 jump *label116 always
   444 label *label116
   445 drawflush .display
 
   451 label *label84
   452 wait 0
   453 read *tmp185 .memory 68
-    * op notEqual *tmp184 .stop *tmp185
-    * jump *label118 equal *tmp184 false
+  454 jump *label118 equal .stop *tmp185
   455 jump *label29 always
   456 jump *label119 always
   457 label *label118
 
   466 op add :i :i 1
   467 jump *label41 always
   468 label *label43
-    * op greaterThanEq *tmp191 :batch 1337.6
-    * jump *label120 equal *tmp191 false
+  469 jump *label120 lessThan :batch 1337.6
   470 set :multiple 1
   471 jump *label121 always
   472 label *label120
 
   475 jump *label34 always
   476 label *label36
   477 label *label123
-    * op greaterThan *tmp193 .localBuffer 0
-    * jump *label125 equal *tmp193 false
+  478 jump *label125 lessThanEq .localBuffer 0
   479 label *label127
   480 read *tmp195 .memory 68
-    * op equal *tmp194 .stop *tmp195
-    * jump *label125 equal *tmp194 false
+  481 jump *label125 notEqual .stop *tmp195
   482 jump *label126 always
   483 label *label126
   484 wait 0
 
   487 label *label132
   488 sensor *tmp197 .display @bufferSize
   489 op sub *tmp198 1024 *tmp197
-    * op lessThan *tmp199 .localBuffer *tmp198
-    * jump *label129 equal *tmp199 false
+  490 jump *label129 greaterThanEq .localBuffer *tmp198
   491 jump *label131 always
   492 label *label131
   493 drawflush .display

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-22 instructions):
 
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
    49 jump *label19 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * jump *label20 always
    51 label *label19
    52 label *label20
-    * jump *label18 always
    53 label *label17
    54 label *label18
    55 label *label13
 
    82 print :findLinkedBlocks:variable
    83 jump *label26 equal :findLinkedBlocks:required false
    84 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * jump *label27 always
    85 label *label26
    86 label *label27
    87 label *label22
 
   126 read *tmp43 .memory 68
   127 jump *label37 equal .stop *tmp43
   128 jump *label29 always
-    * jump *label38 always
   129 label *label37
   130 label *label38
   131 read :batch .memory 64
 
   134 write *tmp47 .memory 64
   135 jump *label39 lessThan :batch 2816
   136 jump *label36 always
-    * jump *label40 always
   137 label *label39
   138 label *label40
   139 op mul *tmp51 11 :multiple
 
   266 jump *label71 greaterThan :compute:cx *tmp96
   267 set *tmp85 63
   268 jump *label68 always
-    * jump *label72 always
   269 label *label71
   270 label *label72
   271 op add *tmp99 :compute:cx 1
 
   273 jump *label73 greaterThan *tmp100 0.25
   274 set *tmp85 63
   275 jump *label68 always
-    * jump *label74 always
   276 label *label73
   277 label *label74
   278 label *label70
 
   291 op len :compute:dist :compute:zx :compute:zy
   292 jump *label78 lessThan :compute:dist 64
   293 jump *label77 always
-    * jump *label79 always
   294 label *label78
   295 label *label79
   296 label *label76
 
   300 jump *label80 equal .SMOOTH false
   301 label *label83
   302 jump *label80 greaterThanEq :compute:i 63
-    * jump *label82 always
   303 label *label82
   304 op log *tmp115 :compute:dist
   305 op mul *tmp116 *tmp115 0.36067376022224085
 
   307 op mul *tmp118 *tmp117 1.4426950408889634
   308 op sub :compute:correction 4 *tmp118
   309 op add :compute:i :compute:i :compute:correction
-    * jump *label81 always
   310 label *label80
   311 label *label81
   312 set *tmp85 :compute:i
 
   385 label *label103
   386 read *tmp169 .memory 68
   387 jump *label101 notEqual .stop *tmp169
-    * jump *label102 always
   388 label *label102
   389 wait 0
   390 sensor *tmp170 .display @enabled
 
   393 sensor *tmp171 .display @bufferSize
   394 op sub *tmp172 1024 *tmp171
   395 jump *label105 greaterThanEq .localBuffer *tmp172
-    * jump *label107 always
   396 label *label107
   397 drawflush .display
   398 set .localBuffer 0
-    * jump *label106 always
   399 label *label105
   400 label *label106
   401 label *label104
 
   403 jump *label99 always
   404 label *label101
   405 label *label98
-    * jump *label97 always
   406 label *label96
   407 label *label97
   408 jump *label109 lessThanEq .localBuffer 0
   409 label *label112
   410 jump *label109 strictNotEqual :drawPixel:color .lastColor
-    * jump *label111 always
   411 label *label111
   412 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   413 op add .localBuffer .localBuffer 1
 
   425 sensor *tmp180 .display @bufferSize
   426 op sub *tmp181 1024 *tmp180
   427 jump *label114 greaterThanEq .localBuffer *tmp181
-    * jump *label116 always
   428 label *label116
   429 drawflush .display
   430 set .localBuffer 0
-    * jump *label115 always
   431 label *label114
   432 label *label115
   433 label *label113
 
   436 read *tmp185 .memory 68
   437 jump *label118 equal .stop *tmp185
   438 jump *label29 always
-    * jump *label119 always
   439 label *label118
   440 label *label119
   441 read *tmp187 .memory 66
 
   450 label *label43
   451 jump *label120 lessThan :batch 1337.6
   452 set :multiple 1
-    * jump *label121 always
   453 label *label120
   454 label *label121
   455 label *label35
 
   460 label *label127
   461 read *tmp195 .memory 68
   462 jump *label125 notEqual .stop *tmp195
-    * jump *label126 always
   463 label *label126
   464 wait 0
   465 sensor *tmp196 .display @enabled
 
   468 sensor *tmp197 .display @bufferSize
   469 op sub *tmp198 1024 *tmp197
   470 jump *label129 greaterThanEq .localBuffer *tmp198
-    * jump *label131 always
   471 label *label131
   472 drawflush .display
   473 set .localBuffer 0
-    * jump *label130 always
   474 label *label129
   475 label *label130
   476 label *label128

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     1 set :findLinkedBlocks:title "Mandelbrot Generator"
     2 set :findLinkedBlocks:message null
     3 label *label1
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
     4 setaddr *tmp13 *label7
     5 jump *label4 always
     6 multilabel *label7 (m:marker0)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
+    7 set .display null
     8 setaddr *tmp13 *label8
     9 label *label4
    10 set :findLinkedBlocks:variable null
    11 label *label5
    12 multijump *tmp13 0 0 (m:marker0)
    13 multilabel *label8 (m:marker0)
-    * set .memory :findLinkedBlocks:variable
+   14 set .memory null
    15 label *label6
-    * print :findLinkedBlocks:title
+   16 print "Mandelbrot Generator"
    17 set :findLinkedBlocks:n @links
    18 label *label9
    19 jump *label11 lessThanEq :findLinkedBlocks:n 0
 
    23 print :findLinkedBlocks:block
    24 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    25 set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
    26 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    27 setaddr *tmp17 *label15
    28 jump *label12 always
    29 multilabel *label15 (m:marker1)
    30 set .display :findLinkedBlocks:variable
    31 set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
    32 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    33 setaddr *tmp17 *label16
    34 label *label12
    35 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
 
    49 jump *label9 always
    50 label *label11
    51 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:requested @large-logic-display
    52 set :findLinkedBlocks:name "Display"
    53 set :findLinkedBlocks:variable .display
    54 set :findLinkedBlocks:required true
 
    56 jump *label21 always
    57 multilabel *label24 (m:marker2)
    58 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    59 set :findLinkedBlocks:name "Memory"
    60 set :findLinkedBlocks:variable .memory
    61 set :findLinkedBlocks:required true
 
    66 print ":"
    67 print " "
    68 print :findLinkedBlocks:variable
-    * jump *label26 equal :findLinkedBlocks:required false
+   69 jump *label26 equal true false
    70 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
    71 label *label26
    72 label *label27
 
    99 op add .OFFSET_X *tmp30 *tmp32
   100 op div *tmp33 -88 .ZOOM
   101 read *tmp35 .memory 70
-    * op add .OFFSET_Y *tmp33 *tmp35
+  102 op add .OFFSET_Y *tmp30 *tmp35
   103 read .JULIA .memory 72
   104 read .JULIA_X .memory 73
   105 read .JULIA_Y .memory 74
 
   145 set *tmp61 1
   146 label *label50
   147 set :adam5:dy *tmp61
-    * set :adam5:dx :adam5:dy
+  148 set :adam5:dx *tmp61
   149 jump *label45 always
   150 label *label46
   151 jump *label53 lessThan *tmp55 121
 
   193 set *tmp74 1
   194 label *label62
   195 set :adam5:dy *tmp74
-    * set :adam5:dx :adam5:dy
+  196 set :adam5:dx *tmp74
   197 jump *label45 always
   198 label *label58
   199 jump *label65 lessThan *tmp55 484
 
   223 op mul *tmp83 2 *tmp82
   224 op add :adam5:y *tmp83 1
   225 set :adam5:dy 1
-    * set :adam5:dx :adam5:dy
+  226 set :adam5:dx 1
   227 label *label45
   228 label *label44
   229 set :x :adam5:x
   230 set :y :adam5:y
   231 set :dx :adam5:dx
   232 set :dy :adam5:dy
-    * set :compute:x :x
-    * set :compute:y :y
-    * op div *tmp86 :compute:x .ZOOM
+  233 set :compute:x :adam5:x
+  234 set :compute:y :adam5:y
+  235 op div *tmp86 :x .ZOOM
   236 op add :compute:zx *tmp86 .OFFSET_X
-    * op div *tmp88 :compute:y .ZOOM
+  237 op div *tmp88 :y .ZOOM
   238 op add :compute:zy *tmp88 .OFFSET_Y
   239 jump *label69 equal .JULIA false
   240 set :compute:cx .JULIA_X
 
   243 label *label69
   244 set :compute:cx :compute:zx
   245 set :compute:cy :compute:zy
-    * op sub *tmp91 :compute:cx 0.25
-    * op len :compute:p *tmp91 :compute:cy
+  246 op sub *tmp91 :compute:zx 0.25
+  247 op len :compute:p *tmp91 :compute:zy
   248 op mul *tmp93 2 :compute:p
   249 op mul *tmp94 *tmp93 :compute:p
   250 op sub *tmp95 :compute:p *tmp94
   251 op add *tmp96 *tmp95 0.25
-    * jump *label71 greaterThan :compute:cx *tmp96
+  252 jump *label71 greaterThan :compute:zx *tmp96
   253 set *tmp85 63
   254 jump *label68 always
   255 label *label71
   256 label *label72
-    * op add *tmp99 :compute:cx 1
-    * op len *tmp100 *tmp99 :compute:cy
+  257 op add *tmp99 :compute:zx 1
+  258 op len *tmp100 *tmp99 :compute:zy
   259 jump *label73 greaterThan *tmp100 0.25
   260 set *tmp85 63
   261 jump *label68 always
 
   267 jump *label77 greaterThanEq :compute:i 63
   268 set :compute:x1 :compute:zx
   269 set :compute:y1 :compute:zy
-    * op mul *tmp103 :compute:x1 :compute:x1
-    * op mul *tmp104 :compute:y1 :compute:y1
+  270 op mul *tmp103 :compute:zx :compute:zx
+  271 op mul *tmp104 :compute:zy :compute:zy
   272 op sub *tmp105 *tmp103 *tmp104
   273 op add :compute:zx *tmp105 :compute:cx
   274 op mul *tmp107 2 :compute:x1
-    * op mul *tmp108 *tmp107 :compute:y1
+  275 op mul *tmp108 *tmp107 :compute:zy
   276 op add :compute:zy *tmp108 :compute:cy
   277 op len :compute:dist :compute:zx :compute:zy
   278 jump *label78 lessThan :compute:dist 64
 
   297 label *label81
   298 set *tmp85 :compute:i
   299 jump *label68 always
-    * set *tmp85 null
   300 label *label68
   301 set :iterations *tmp85
-    * set :drawPixel:x :x
-    * set :drawPixel:y :y
-    * set :drawPixel:dx :dx
-    * set :drawPixel:dy :dy
-    * set :drawPixel:iterations :iterations
+  302 set :drawPixel:x :adam5:x
+  303 set :drawPixel:y :adam5:y
+  304 set :drawPixel:dx :adam5:dx
+  305 set :drawPixel:dy :adam5:dy
+  306 set :drawPixel:iterations *tmp85
   307 jump *label85 equal .SMOOTH false
-    * jump *label87 notEqual :drawPixel:iterations 63
+  308 jump *label87 notEqual :iterations 63
   309 set :drawPixel:color %[black]
   310 jump *label88 always
   311 label *label87
   312 jump *label90 notEqual .PALETTE 2
   313 label *label91
-    * op sub *tmp125 32 :drawPixel:iterations
+  314 op sub *tmp125 32 :iterations
   315 op abs *tmp126 *tmp125
   316 op mul *tmp127 7 *tmp126
-    * op div *tmp128 *tmp127 255
+  317 op div *tmp128 *tmp126 36.42857142857143
   318 op sub :drawPixel:r 1 *tmp128
-    * op sub *tmp130 :drawPixel:iterations 32
+  319 op sub *tmp130 :iterations 32
   320 op abs *tmp131 *tmp130
   321 op mul *tmp132 6 *tmp131
-    * op div *tmp133 *tmp132 255
+  322 op div *tmp133 *tmp131 42.5
   323 op sub :drawPixel:g 0.9411764705882353 *tmp133
-    * op sub *tmp135 32 :drawPixel:iterations
-    * op abs *tmp136 *tmp135
-    * op mul *tmp137 4 *tmp136
-    * op div *tmp138 *tmp137 255
+  324 op sub *tmp135 32 :iterations
+  325 op abs *tmp136 *tmp125
+  326 op mul *tmp137 4 *tmp126
+  327 op div *tmp138 *tmp136 63.75
   328 op add :drawPixel:b 0.47058823529411764 *tmp138
   329 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   330 jump *label89 always
   331 label *label90
   332 jump *label92 notEqual .PALETTE 3
   333 label *label93
-    * op div *tmp141 :drawPixel:iterations 63
-    * op mul *tmp142 *tmp141 360
+  334 op div *tmp141 :iterations 63
+  335 op div *tmp142 :drawPixel:iterations 0.175
   336 op sin :drawPixel:r *tmp142
-    * op div *tmp144 :drawPixel:iterations 63
-    * op mul *tmp145 *tmp144 360
-    * op cos :drawPixel:g *tmp145
-    * op sub *tmp147 :drawPixel:iterations 32
+  337 op div *tmp144 :iterations 63
+  338 op mul *tmp145 *tmp141 360
+  339 op cos :drawPixel:g *tmp142
+  340 op sub *tmp147 :iterations 32
   341 op abs *tmp148 *tmp147
   342 op mul *tmp149 4 *tmp148
-    * op div *tmp150 *tmp149 255
+  343 op div *tmp150 *tmp148 63.75
   344 op add :drawPixel:b 0.39215686274509803 *tmp150
   345 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   346 jump *label89 always
   347 label *label92
   348 jump *label94 notEqual .PALETTE 4
   349 label *label95
-    * op mul *tmp153 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp153 255
-    * op mul *tmp155 1.5 :drawPixel:iterations
-    * op div :drawPixel:g *tmp155 255
+  350 op mul *tmp153 4 :iterations
+  351 op div :drawPixel:r :drawPixel:iterations 63.75
+  352 op mul *tmp155 1.5 :iterations
+  353 op div :drawPixel:g :drawPixel:iterations 170
   354 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   355 jump *label89 always
   356 label *label94
-    * op mul *tmp158 4 :drawPixel:iterations
-    * op div *tmp159 *tmp158 255
+  357 op mul *tmp158 4 :iterations
+  358 op div *tmp159 :drawPixel:iterations 63.75
   359 op sub :drawPixel:r 1 *tmp159
   360 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   361 label *label89
   362 label *label88
   363 jump *label86 always
   364 label *label85
-    * read :drawPixel:color .memory :drawPixel:iterations
+  365 read :drawPixel:color .memory :iterations
   366 label *label86
   367 jump *label96 lessThan .localBuffer 254
   368 label *label99
 
   394 label *label112
   395 jump *label109 strictNotEqual :drawPixel:color .lastColor
   396 label *label111
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  397 draw rect :x :y :dx :dy
   398 op add .localBuffer .localBuffer 1
   399 jump *label110 always
   400 label *label109
   401 draw col :drawPixel:color
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  402 draw rect :x :y :dx :dy
   403 set .lastColor :drawPixel:color
   404 op add .localBuffer .localBuffer 2
   405 label *label110
 
   427 op add *tmp2 *tmp187 1
   428 write *tmp2 .memory 66
   429 read *tmp189 .memory 65
-    * op add *tmp190 *tmp189 :iterations
+  430 op add *tmp190 *tmp189 *tmp85
   431 write *tmp190 .memory 65
   432 label *label42
   433 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-16 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:title "Mandelbrot Generator"
     1 set :findLinkedBlocks:message null
     2 label *label1
     3 setaddr *tmp13 *label7
 
     6 set .display null
     7 setaddr *tmp13 *label8
     8 label *label4
-    * set :findLinkedBlocks:variable null
     9 label *label5
    10 multijump *tmp13 0 0 (m:marker0)
    11 multilabel *label8 (m:marker0)
 
    49 set :findLinkedBlocks:foundAll 1
    50 set :findLinkedBlocks:name "Display"
    51 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    52 setaddr *tmp22 *label24
    53 jump *label21 always
    54 multilabel *label24 (m:marker2)
    55 set .display :findLinkedBlocks:variable
    56 set :findLinkedBlocks:name "Memory"
    57 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    58 setaddr *tmp22 *label25
    59 label *label21
    60 print "\n"
 
    93 op div *tmp30 -88 .ZOOM
    94 read *tmp32 .memory 69
    95 op add .OFFSET_X *tmp30 *tmp32
-    * op div *tmp33 -88 .ZOOM
    96 read *tmp35 .memory 70
    97 op add .OFFSET_Y *tmp30 *tmp35
    98 read .JULIA .memory 72
 
   225 set :y :adam5:y
   226 set :dx :adam5:dx
   227 set :dy :adam5:dy
-    * set :compute:x :adam5:x
-    * set :compute:y :adam5:y
-    * op div *tmp86 :x .ZOOM
+  228 op div *tmp86 :adam5:x .ZOOM
   229 op add :compute:zx *tmp86 .OFFSET_X
-    * op div *tmp88 :y .ZOOM
+  230 op div *tmp88 :adam5:y .ZOOM
   231 op add :compute:zy *tmp88 .OFFSET_Y
   232 jump *label69 equal .JULIA false
   233 set :compute:cx .JULIA_X
 
   259 label *label75
   260 jump *label77 greaterThanEq :compute:i 63
   261 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   262 op mul *tmp103 :compute:zx :compute:zx
   263 op mul *tmp104 :compute:zy :compute:zy
   264 op sub *tmp105 *tmp103 *tmp104
 
   291 jump *label68 always
   292 label *label68
   293 set :iterations *tmp85
-    * set :drawPixel:x :adam5:x
-    * set :drawPixel:y :adam5:y
-    * set :drawPixel:dx :adam5:dx
-    * set :drawPixel:dy :adam5:dy
   294 set :drawPixel:iterations *tmp85
   295 jump *label85 equal .SMOOTH false
-    * jump *label87 notEqual :iterations 63
+  296 jump *label87 notEqual *tmp85 63
   297 set :drawPixel:color %[black]
   298 jump *label88 always
   299 label *label87
   300 jump *label90 notEqual .PALETTE 2
   301 label *label91
-    * op sub *tmp125 32 :iterations
+  302 op sub *tmp125 32 *tmp85
   303 op abs *tmp126 *tmp125
-    * op mul *tmp127 7 *tmp126
   304 op div *tmp128 *tmp126 36.42857142857143
   305 op sub :drawPixel:r 1 *tmp128
-    * op sub *tmp130 :iterations 32
+  306 op sub *tmp130 *tmp85 32
   307 op abs *tmp131 *tmp130
-    * op mul *tmp132 6 *tmp131
   308 op div *tmp133 *tmp131 42.5
   309 op sub :drawPixel:g 0.9411764705882353 *tmp133
-    * op sub *tmp135 32 :iterations
+  310 op sub *tmp135 32 *tmp85
   311 op abs *tmp136 *tmp125
-    * op mul *tmp137 4 *tmp126
-    * op div *tmp138 *tmp136 63.75
+  312 op div *tmp138 *tmp126 63.75
   313 op add :drawPixel:b 0.47058823529411764 *tmp138
   314 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   315 jump *label89 always
   316 label *label90
   317 jump *label92 notEqual .PALETTE 3
   318 label *label93
-    * op div *tmp141 :iterations 63
-    * op div *tmp142 :drawPixel:iterations 0.175
+  319 op div *tmp141 *tmp85 63
+  320 op div *tmp142 *tmp85 0.175
   321 op sin :drawPixel:r *tmp142
-    * op div *tmp144 :iterations 63
-    * op mul *tmp145 *tmp141 360
+  322 op div *tmp144 *tmp85 63
+  323 op div *tmp145 :iterations 0.175
   324 op cos :drawPixel:g *tmp142
-    * op sub *tmp147 :iterations 32
+  325 op sub *tmp147 *tmp85 32
   326 op abs *tmp148 *tmp147
-    * op mul *tmp149 4 *tmp148
   327 op div *tmp150 *tmp148 63.75
   328 op add :drawPixel:b 0.39215686274509803 *tmp150
   329 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   331 label *label92
   332 jump *label94 notEqual .PALETTE 4
   333 label *label95
-    * op mul *tmp153 4 :iterations
-    * op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp155 1.5 :iterations
-    * op div :drawPixel:g :drawPixel:iterations 170
+  334 op mul *tmp153 4 *tmp85
+  335 op div :drawPixel:r *tmp85 63.75
+  336 op mul *tmp155 1.5 *tmp85
+  337 op div :drawPixel:g *tmp85 170
   338 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   339 jump *label89 always
   340 label *label94
-    * op mul *tmp158 4 :iterations
-    * op div *tmp159 :drawPixel:iterations 63.75
+  341 op mul *tmp158 4 *tmp85
+  342 op div *tmp159 *tmp85 63.75
   343 op sub :drawPixel:r 1 *tmp159
   344 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   345 label *label89
   346 label *label88
   347 jump *label86 always
   348 label *label85
-    * read :drawPixel:color .memory :iterations
+  349 read :drawPixel:color .memory *tmp85
   350 label *label86
   351 jump *label96 lessThan .localBuffer 254
   352 label *label99
 
   378 label *label112
   379 jump *label109 strictNotEqual :drawPixel:color .lastColor
   380 label *label111
-    * draw rect :x :y :dx :dy
+  381 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   382 op add .localBuffer .localBuffer 1
   383 jump *label110 always
   384 label *label109
   385 draw col :drawPixel:color
-    * draw rect :x :y :dx :dy
+  386 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   387 set .lastColor :drawPixel:color
   388 op add .localBuffer .localBuffer 2
   389 label *label110

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   221 set :adam5:dx 1
   222 label *label45
   223 label *label44
-    * set :x :adam5:x
-    * set :y :adam5:y
-    * set :dx :adam5:dx
-    * set :dy :adam5:dy
   224 op div *tmp86 :adam5:x .ZOOM
   225 op add :compute:zx *tmp86 .OFFSET_X
   226 op div *tmp88 :adam5:y .ZOOM
 
   287 jump *label68 always
   288 label *label68
   289 set :iterations *tmp85
-    * set :drawPixel:iterations *tmp85
   290 jump *label85 equal .SMOOTH false
   291 jump *label87 notEqual *tmp85 63
   292 set :drawPixel:color %[black]
 
   302 op abs *tmp131 *tmp130
   303 op div *tmp133 *tmp131 42.5
   304 op sub :drawPixel:g 0.9411764705882353 *tmp133
-    * op sub *tmp135 32 *tmp85
-    * op abs *tmp136 *tmp125
   305 op div *tmp138 *tmp126 63.75
   306 op add :drawPixel:b 0.47058823529411764 *tmp138
   307 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   309 label *label90
   310 jump *label92 notEqual .PALETTE 3
   311 label *label93
-    * op div *tmp141 *tmp85 63
   312 op div *tmp142 *tmp85 0.175
   313 op sin :drawPixel:r *tmp142
-    * op div *tmp144 *tmp85 63
-    * op div *tmp145 :iterations 0.175
+  314 op div *tmp145 *tmp85 0.175
   315 op cos :drawPixel:g *tmp142
   316 op sub *tmp147 *tmp85 32
   317 op abs *tmp148 *tmp147
 
   322 label *label92
   323 jump *label94 notEqual .PALETTE 4
   324 label *label95
-    * op mul *tmp153 4 *tmp85
   325 op div :drawPixel:r *tmp85 63.75
-    * op mul *tmp155 1.5 *tmp85
   326 op div :drawPixel:g *tmp85 170
   327 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   328 jump *label89 always
   329 label *label94
-    * op mul *tmp158 4 *tmp85
   330 op div *tmp159 *tmp85 63.75
   331 op sub :drawPixel:r 1 *tmp159
   332 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   286 set *tmp85 :compute:i
   287 jump *label68 always
   288 label *label68
-    * set :iterations *tmp85
   289 jump *label85 equal .SMOOTH false
   290 jump *label87 notEqual *tmp85 63
   291 set :drawPixel:color %[black]
 
   310 label *label93
   311 op div *tmp142 *tmp85 0.175
   312 op sin :drawPixel:r *tmp142
-    * op div *tmp145 *tmp85 0.175
   313 op cos :drawPixel:g *tmp142
   314 op sub *tmp147 *tmp85 32
   315 op abs *tmp148 *tmp147

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
   119 label *label40
   120 op mul *tmp51 11 :multiple
   121 set :i 0
+  122 op mul *tmp52 :batch 11
   123 label *label41
   124 jump *label43 greaterThanEq :i *tmp51
-    * op mul *tmp52 :batch 11
   125 op add :adam5:index *tmp52 :i
   126 op idiv *tmp55 :adam5:index 16
   127 jump *label48 lessThan *tmp55 0

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
    15 set :findLinkedBlocks:n @links
    16 label *label9
    17 jump *label11 lessThanEq :findLinkedBlocks:n 0
+   18 label *label133
    19 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    20 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    21 print "\nFound: "
 
    45 set .memory :findLinkedBlocks:variable
    46 label *label14
    47 label *label10
-    * jump *label9 always
+   48 jump *label133 greaterThan :findLinkedBlocks:n 0
    49 label *label11
    50 set :findLinkedBlocks:foundAll 1
    51 set :findLinkedBlocks:name "Display"
 
   123 op mul *tmp52 :batch 11
   124 label *label41
   125 jump *label43 greaterThanEq :i *tmp51
+  126 label *label134
   127 op add :adam5:index *tmp52 :i
   128 op idiv *tmp55 :adam5:index 16
   129 jump *label48 lessThan *tmp55 0
 
   256 set :compute:i 0
   257 label *label75
   258 jump *label77 greaterThanEq :compute:i 63
+  259 label *label135
   260 set :compute:x1 :compute:zx
   261 op mul *tmp103 :compute:zx :compute:zx
   262 op mul *tmp104 :compute:zy :compute:zy
 
   272 label *label79
   273 label *label76
   274 op add :compute:i :compute:i 1
-    * jump *label75 always
+  275 jump *label135 lessThan :compute:i 63
   276 label *label77
   277 jump *label80 equal .SMOOTH false
   278 label *label83
 
   340 jump *label96 lessThan .localBuffer 254
   341 label *label99
   342 jump *label101 lessThanEq .localBuffer 0
-    * label *label103
+  343 label *label136
   344 read *tmp169 .memory 68
   345 jump *label101 notEqual .stop *tmp169
-    * label *label102
   346 wait 0
   347 sensor *tmp170 .display @enabled
   348 jump *label105 equal *tmp170 false
 
   357 label *label106
   358 label *label104
   359 label *label100
-    * jump *label99 always
+  360 jump *label136 greaterThan .localBuffer 0
   361 label *label101
   362 label *label98
   363 label *label96
 
   403 write *tmp190 .memory 65
   404 label *label42
   405 op add :i :i 1
-    * jump *label41 always
+  406 jump *label134 lessThan :i *tmp51
   407 label *label43
   408 jump *label120 lessThan :batch 1337.6
   409 set :multiple 1
 
   414 label *label36
   415 label *label123
   416 jump *label125 lessThanEq .localBuffer 0
-    * label *label127
+  417 label *label137
   418 read *tmp195 .memory 68
   419 jump *label125 notEqual .stop *tmp195
-    * label *label126
   420 wait 0
   421 sensor *tmp196 .display @enabled
   422 jump *label129 equal *tmp196 false
 
   431 label *label130
   432 label *label128
   433 label *label124
-    * jump *label123 always
+  434 jump *label137 greaterThan .localBuffer 0
   435 label *label125
   436 label *label122
   437 label *label29

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-17 instructions):
 
    33 label *label12
    34 jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    35 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label19 notEqual :findLinkedBlocks:requested @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
-    * label *label19
-    * label *label20
+   36 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
    37 label *label17
    38 label *label18
    39 label *label13
 
   132 op mul :adam5:x 4 *tmp57
   133 op idiv *tmp59 :adam5:index 44
   134 op mul :adam5:y 4 *tmp59
-    * jump *label49 equal .FILL_PASS false
-    * set *tmp61 4
-    * jump *label50 always
-    * label *label49
-    * set *tmp61 1
-    * label *label50
+  135 select *tmp61 notEqual .FILL_PASS false 4 1
   136 set :adam5:dy *tmp61
   137 set :adam5:dx *tmp61
   138 jump *label45 always
 
   148 op add :adam5:x *tmp63 2
   149 op idiv *tmp65 :adam5:index 44
   150 op mul :adam5:y 4 *tmp65
-    * jump *label54 equal .FILL_PASS false
-    * set *tmp67 2
-    * jump *label55 always
-    * label *label54
-    * set *tmp67 1
-    * label *label55
+  151 select *tmp67 notEqual .FILL_PASS false 2 1
   152 set :adam5:dx *tmp67
-    * jump *label56 equal .FILL_PASS false
-    * set *tmp68 4
-    * jump *label57 always
-    * label *label56
-    * set *tmp68 1
-    * label *label57
+  153 select *tmp68 notEqual .FILL_PASS false 4 1
   154 set :adam5:dy *tmp68
   155 jump *label45 always
   156 label *label51
 
   165 op idiv *tmp71 :adam5:index 88
   166 op mul *tmp72 4 *tmp71
   167 op add :adam5:y *tmp72 2
-    * jump *label61 equal .FILL_PASS false
-    * set *tmp74 2
-    * jump *label62 always
-    * label *label61
-    * set *tmp74 1
-    * label *label62
+  168 select *tmp74 notEqual .FILL_PASS false 2 1
   169 set :adam5:dy *tmp74
   170 set :adam5:dx *tmp74
   171 jump *label45 always
 
   182 op idiv *tmp78 :adam5:index 88
   183 op mul :adam5:y 2 *tmp78
   184 set :adam5:dx 1
-    * jump *label66 equal .FILL_PASS false
-    * set *tmp80 2
-    * jump *label67 always
-    * label *label66
-    * set *tmp80 1
-    * label *label67
+  185 select *tmp80 notEqual .FILL_PASS false 2 1
   186 set :adam5:dy *tmp80
   187 jump *label45 always
   188 label *label63
 
   247 jump *label135 lessThan :compute:i 63
   248 label *label77
   249 jump *label80 equal .SMOOTH false
-    * label *label83
   250 jump *label80 greaterThanEq :compute:i 63
-    * label *label82
   251 op log *tmp115 :compute:dist
   252 op mul *tmp116 *tmp115 0.36067376022224085
   253 op log *tmp117 *tmp116
 
   316 wait 0
   317 sensor *tmp170 .display @enabled
   318 jump *label105 equal *tmp170 false
-    * label *label108
   319 sensor *tmp171 .display @bufferSize
   320 op sub *tmp172 1024 *tmp171
   321 jump *label105 greaterThanEq .localBuffer *tmp172
-    * label *label107
   322 drawflush .display
   323 set .localBuffer 0
   324 label *label105
 
   331 label *label96
   332 label *label97
   333 jump *label109 lessThanEq .localBuffer 0
-    * label *label112
   334 jump *label109 strictNotEqual :drawPixel:color .lastColor
-    * label *label111
   335 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   336 op add .localBuffer .localBuffer 1
   337 jump *label110 always
 
   344 wait 0
   345 sensor *tmp179 .display @enabled
   346 jump *label114 equal *tmp179 false
-    * label *label117
   347 sensor *tmp180 .display @bufferSize
   348 op sub *tmp181 1024 *tmp180
   349 jump *label114 greaterThanEq .localBuffer *tmp181
-    * label *label116
   350 drawflush .display
   351 set .localBuffer 0
   352 label *label114
 
   369 op add :i :i 1
   370 jump *label134 lessThan :i *tmp51
   371 label *label43
-    * jump *label120 lessThan :batch 1337.6
-    * set :multiple 1
-    * label *label120
-    * label *label121
+  372 select :multiple greaterThanEq :batch 1337.6 1 :multiple
   373 label *label35
   374 jump *label34 always
   375 label *label36
 
   381 wait 0
   382 sensor *tmp196 .display @enabled
   383 jump *label129 equal *tmp196 false
-    * label *label132
   384 sensor *tmp197 .display @bufferSize
   385 op sub *tmp198 1024 *tmp197
   386 jump *label129 greaterThanEq .localBuffer *tmp198
-    * label *label131
   387 drawflush .display
   388 set .localBuffer 0
   389 label *label129

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   260 jump *label68 always
   261 label *label68
   262 jump *label85 equal .SMOOTH false
-    * jump *label87 notEqual *tmp85 63
   263 set :drawPixel:color %[black]
-    * jump *label88 always
+  264 jump *label88 equal *tmp85 63
   265 label *label87
   266 jump *label90 notEqual .PALETTE 2
   267 label *label91

Modifications by Unroll iteration loop at *blocks:68:13 (-1 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp17 *label15
-    * jump *label12 always
-    * multilabel *label15 (m:marker1)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp17 *label16
-    * label *label12
-    * jump *label17 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
-    * label *label17
-    * label *label18
-    * label *label13
-    * multijump *tmp17 0 0 (m:marker1)
-    * multilabel *label16 (m:marker1)
-    * set .memory :findLinkedBlocks:variable
-    * label *label14
+   24 set :findLinkedBlocks:requested @large-logic-display
+   25 set :findLinkedBlocks:variable .display
+   26 label *label138
+   27 jump *label139 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   28 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   29 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   30 label *label139
+   31 label *label140
+   32 label *label141
+   33 set .display :findLinkedBlocks:variable
+   34 set :findLinkedBlocks:requested @memory-bank
+   35 set :findLinkedBlocks:variable .memory
+   36 label *label144
+   37 jump *label145 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   38 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   39 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   40 label *label145
+   41 label *label146
+   42 label *label147
+   43 set .memory :findLinkedBlocks:variable
+   44 label *label14
    45 label *label10
    46 jump *label133 greaterThan :findLinkedBlocks:n 0
    47 label *label11

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    24 set :findLinkedBlocks:requested @large-logic-display
    25 set :findLinkedBlocks:variable .display
    26 label *label138
-    * jump *label139 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   27 jump *label139 notEqual @large-logic-display :findLinkedBlocks:type
    28 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   29 select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
    30 label *label139
    31 label *label140
    32 label *label141
 
    34 set :findLinkedBlocks:requested @memory-bank
    35 set :findLinkedBlocks:variable .memory
    36 label *label144
-    * jump *label145 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   37 jump *label145 notEqual @memory-bank :findLinkedBlocks:type
    38 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   39 select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
    40 label *label145
    41 label *label146
    42 label *label147
 
   120 set :i 0
   121 op mul *tmp52 :batch 11
   122 label *label41
-    * jump *label43 greaterThanEq :i *tmp51
+  123 jump *label43 greaterThanEq 0 *tmp51
   124 label *label134
   125 op add :adam5:index *tmp52 :i
   126 op idiv *tmp55 :adam5:index 16
 
   228 label *label70
   229 set :compute:i 0
   230 label *label75
-    * jump *label77 greaterThanEq :compute:i 63
+  231 jump *label77 greaterThanEq 0 63
   232 label *label135
   233 set :compute:x1 :compute:zx
   234 op mul *tmp103 :compute:zx :compute:zx

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
    24 set :findLinkedBlocks:variable .display
    25 label *label138
    26 jump *label139 notEqual @large-logic-display :findLinkedBlocks:type
 
    30 label *label140
    31 label *label141
    32 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    33 set :findLinkedBlocks:variable .memory
    34 label *label144
    35 jump *label145 notEqual @memory-bank :findLinkedBlocks:type

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
     0 set .start 0
     1 set :findLinkedBlocks:message null
     2 label *label1
-    * setaddr *tmp13 *label7
-    * jump *label4 always
-    * multilabel *label7 (m:marker0)
-    * set .display null
-    * setaddr *tmp13 *label8
-    * label *label4
-    * label *label5
-    * multijump *tmp13 0 0 (m:marker0)
-    * multilabel *label8 (m:marker0)
-    * set .memory null
-    * label *label6
+    3 label *label151
+    4 label *label152
+    5 set .display null
+    6 label *label155
+    7 label *label156
+    8 set .memory null
+    9 label *label6
    10 print "Mandelbrot Generator"
    11 set :findLinkedBlocks:n @links
    12 label *label9

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    40 jump *label133 greaterThan :findLinkedBlocks:n 0
    41 label *label11
    42 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp22 *label24
-    * jump *label21 always
-    * multilabel *label24 (m:marker2)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp22 *label25
-    * label *label21
-    * print "\n"
-    * print :findLinkedBlocks:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks:variable
-    * jump *label26 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * label *label26
-    * label *label27
-    * label *label22
-    * multijump *tmp22 0 0 (m:marker2)
-    * multilabel *label25 (m:marker2)
-    * set .memory :findLinkedBlocks:variable
-    * label *label23
+   43 set :findLinkedBlocks:name "Display"
+   44 set :findLinkedBlocks:variable .display
+   45 label *label160
+   46 print "\n"
+   47 print :findLinkedBlocks:name
+   48 print ":"
+   49 print " "
+   50 print :findLinkedBlocks:variable
+   51 jump *label161 equal true false
+   52 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   53 label *label161
+   54 label *label162
+   55 label *label163
+   56 set .display :findLinkedBlocks:variable
+   57 set :findLinkedBlocks:name "Memory"
+   58 set :findLinkedBlocks:variable .memory
+   59 label *label166
+   60 print "\n"
+   61 print :findLinkedBlocks:name
+   62 print ":"
+   63 print " "
+   64 print :findLinkedBlocks:variable
+   65 jump *label167 equal true false
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   67 label *label167
+   68 label *label168
+   69 label *label169
+   70 set .memory :findLinkedBlocks:variable
+   71 label *label23
    72 printflush :findLinkedBlocks:message
    73 label *label2
    74 jump *label1 equal :findLinkedBlocks:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    44 set :findLinkedBlocks:variable .display
    45 label *label160
    46 print "\n"
-    * print :findLinkedBlocks:name
+   47 print "Display"
    48 print ":"
    49 print " "
-    * print :findLinkedBlocks:variable
+   50 print .display
    51 jump *label161 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   52 op and :findLinkedBlocks:foundAll 1 .display
    53 label *label161
    54 label *label162
    55 label *label163
-    * set .display :findLinkedBlocks:variable
+   56 set .display .display
    57 set :findLinkedBlocks:name "Memory"
    58 set :findLinkedBlocks:variable .memory
    59 label *label166
    60 print "\n"
-    * print :findLinkedBlocks:name
+   61 print "Memory"
    62 print ":"
    63 print " "
-    * print :findLinkedBlocks:variable
+   64 print .memory
    65 jump *label167 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    67 label *label167
    68 label *label168
    69 label *label169
-    * set .memory :findLinkedBlocks:variable
+   70 set .memory .memory
    71 label *label23
    72 printflush :findLinkedBlocks:message
    73 label *label2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    39 label *label10
    40 jump *label133 greaterThan :findLinkedBlocks:n 0
    41 label *label11
-    * set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
    42 label *label160
    43 print "\n"
    44 print "Display"
 
    51 label *label162
    52 label *label163
    53 set .display .display
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
    54 label *label166
    55 print "\n"
    56 print "Memory"

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:125:5 (-10 instructions):
 
   118 label *label134
   119 op add :adam5:index *tmp52 :i
   120 op idiv *tmp55 :adam5:index 16
-    * jump *label48 lessThan *tmp55 0
-    * jump *label47 lessThan *tmp55 121
-    * label *label48
-    * jump *label46 always
+  121 multijump *tmp55 0 0 (m:*label174)
+  122 multilabel *label179 (m:*label174)
+  123 label *label173
+  124 op sub :adam5:index :adam5:index 15488
+  125 op mod :adam5:x :adam5:index 176
+  126 op idiv *tmp82 :adam5:index 176
+  127 op mul *tmp83 2 *tmp82
+  128 op add :adam5:y *tmp83 1
+  129 set :adam5:dy 1
+  130 set :adam5:dx 1
+  131 jump *label45 always
+  132 multilabel *label175 (m:*label174)
   133 label *label47
   134 op mod *tmp57 :adam5:index 44
   135 op mul :adam5:x 4 *tmp57
 
   140 set :adam5:dx *tmp61
   141 jump *label45 always
   142 label *label46
-    * jump *label53 lessThan *tmp55 121
-    * jump *label52 lessThan *tmp55 242
-    * label *label53
-    * jump *label51 always
+  143 multilabel *label176 (m:*label174)
   144 label *label52
   145 op sub :adam5:index :adam5:index 1936
   146 op mod *tmp62 :adam5:index 44
 
   154 set :adam5:dy *tmp68
   155 jump *label45 always
   156 label *label51
-    * jump *label60 lessThan *tmp55 242
-    * jump *label59 lessThan *tmp55 484
-    * label *label60
-    * jump *label58 always
+  157 multilabel *label177 (m:*label174)
   158 label *label59
   159 op sub :adam5:index :adam5:index 3872
   160 op mod *tmp69 :adam5:index 88
 
   167 set :adam5:dx *tmp74
   168 jump *label45 always
   169 label *label58
-    * jump *label65 lessThan *tmp55 484
-    * jump *label64 lessThan *tmp55 968
-    * label *label65
-    * jump *label63 always
+  170 jump *label45 always
+  171 multilabel *label178 (m:*label174)
   172 label *label64
   173 op sub :adam5:index :adam5:index 7744
   174 op mod *tmp75 :adam5:index 88
 
   179 set :adam5:dx 1
   180 select *tmp80 notEqual .FILL_PASS false 2 1
   181 set :adam5:dy *tmp80
-    * jump *label45 always
-    * label *label63
-    * op sub :adam5:index :adam5:index 15488
-    * op mod :adam5:x :adam5:index 176
-    * op idiv *tmp82 :adam5:index 176
-    * op mul *tmp83 2 *tmp82
-    * op add :adam5:y *tmp83 1
-    * set :adam5:dy 1
-    * set :adam5:dx 1
   182 label *label45
   183 label *label44
   184 op div *tmp86 :adam5:x .ZOOM

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:214:13 (-2 instructions):
 
   249 set :drawPixel:color %[black]
   250 jump *label88 equal *tmp85 63
   251 label *label87
-    * jump *label90 notEqual .PALETTE 2
+  252 multijump .PALETTE 0 0 (m:*label181)
+  253 multilabel *label186 (m:*label181)
+  254 multilabel *label182 (m:*label181)
+  255 label *label180
+  256 op div *tmp159 *tmp85 63.75
+  257 op sub :drawPixel:r 1 *tmp159
+  258 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
+  259 jump *label89 always
+  260 multilabel *label183 (m:*label181)
   261 label *label91
   262 op sub *tmp125 32 *tmp85
   263 op abs *tmp126 *tmp125
 
   272 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   273 jump *label89 always
   274 label *label90
-    * jump *label92 notEqual .PALETTE 3
+  275 multilabel *label184 (m:*label181)
   276 label *label93
   277 op div *tmp142 *tmp85 0.175
   278 op sin :drawPixel:r *tmp142
 
   284 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   285 jump *label89 always
   286 label *label92
-    * jump *label94 notEqual .PALETTE 4
+  287 multilabel *label185 (m:*label181)
   288 label *label95
   289 op div :drawPixel:r *tmp85 63.75
   290 op div :drawPixel:g *tmp85 170
   291 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label89 always
-    * label *label94
-    * op div *tmp159 *tmp85 63.75
-    * op sub :drawPixel:r 1 *tmp159
-    * packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   292 label *label89
   293 label *label88
   294 jump *label86 always

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-3 instructions):
 
    45 print ":"
    46 print " "
    47 print .display
-    * jump *label161 equal true false
    48 op and :findLinkedBlocks:foundAll 1 .display
    49 label *label161
    50 label *label162
 
    56 print ":"
    57 print " "
    58 print .memory
-    * jump *label167 equal true false
    59 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    60 label *label167
    61 label *label168
 
   211 label *label70
   212 set :compute:i 0
   213 label *label75
-    * jump *label77 greaterThanEq 0 63
   214 label *label135
   215 set :compute:x1 :compute:zx
   216 op mul *tmp103 :compute:zx :compute:zx

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-1 instructions):
 
    90 read .JULIA_X .memory 73
    91 read .JULIA_Y .memory 74
    92 read .PALETTE .memory 75
-    * op greaterThan .SMOOTH .PALETTE 1
    93 read .FILL_PASS .memory 76
    94 set :multiple 4
    95 label *label34
 
   111 set :i 0
   112 op mul *tmp52 :batch 11
   113 label *label41
-    * jump *label43 greaterThanEq 0 *tmp51
+  114 jump *label43 lessThanEq :multiple 0
   115 label *label134
   116 op add :adam5:index *tmp52 :i
   117 op idiv *tmp55 :adam5:index 16
 
   228 op add :compute:i :compute:i 1
   229 jump *label135 lessThan :compute:i 63
   230 label *label77
-    * jump *label80 equal .SMOOTH false
+  231 jump *label80 lessThanEq .PALETTE 1
   232 jump *label80 greaterThanEq :compute:i 63
   233 op log *tmp115 :compute:dist
   234 op mul *tmp116 *tmp115 0.36067376022224085
 
   241 set *tmp85 :compute:i
   242 jump *label68 always
   243 label *label68
-    * jump *label85 equal .SMOOTH false
+  244 jump *label85 lessThanEq .PALETTE 1
   245 set :drawPixel:color %[black]
   246 jump *label88 equal *tmp85 63
   247 label *label87

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   162 select *tmp74 notEqual .FILL_PASS false 2 1
   163 set :adam5:dy *tmp74
   164 set :adam5:dx *tmp74
-    * jump *label45 always
   165 label *label58
   166 jump *label45 always
   167 multilabel *label178 (m:*label174)
 
   238 label *label80
   239 label *label81
   240 set *tmp85 :compute:i
-    * jump *label68 always
   241 label *label68
   242 jump *label85 lessThanEq .PALETTE 1
   243 set :drawPixel:color %[black]

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-2 instructions):
 
    21 label *label138
    22 jump *label139 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
+   24 set :findLinkedBlocks:message :findLinkedBlocks:message
    25 label *label139
    26 label *label140
    27 label *label141
 
    30 label *label144
    31 jump *label145 notEqual @memory-bank :findLinkedBlocks:type
    32 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
+   33 set :findLinkedBlocks:message :findLinkedBlocks:message
    34 label *label145
    35 label *label146
    36 label *label147
 
    49 label *label161
    50 label *label162
    51 label *label163
-    * set .display .display
    52 label *label166
    53 print "\n"
    54 print "Memory"
 
    59 label *label167
    60 label *label168
    61 label *label169
-    * set .memory .memory
    62 label *label23
    63 printflush :findLinkedBlocks:message
    64 label *label2

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-3 instructions):
 
   143 op add :adam5:x *tmp63 2
   144 op idiv *tmp65 :adam5:index 44
   145 op mul :adam5:y 4 *tmp65
-    * select *tmp67 notEqual .FILL_PASS false 2 1
-    * set :adam5:dx *tmp67
-    * select *tmp68 notEqual .FILL_PASS false 4 1
-    * set :adam5:dy *tmp68
+  146 select :adam5:dx notEqual .FILL_PASS false 2 1
+  147 select :adam5:dy notEqual .FILL_PASS false 4 1
   148 jump *label45 always
   149 label *label51
   150 multilabel *label177 (m:*label174)
 
   169 op idiv *tmp78 :adam5:index 88
   170 op mul :adam5:y 2 *tmp78
   171 set :adam5:dx 1
-    * select *tmp80 notEqual .FILL_PASS false 2 1
-    * set :adam5:dy *tmp80
+  172 select :adam5:dy notEqual .FILL_PASS false 2 1
   173 label *label45
   174 label *label44
   175 op div *tmp86 :adam5:x .ZOOM

Modifications by Unroll loop at mandelbrot-compute.mnd:186:5 (+743 instructions):
 
   202 label *label73
   203 label *label74
   204 label *label70
-    * set :compute:i 0
-    * label *label75
-    * label *label135
-    * set :compute:x1 :compute:zx
-    * op mul *tmp103 :compute:zx :compute:zx
-    * op mul *tmp104 :compute:zy :compute:zy
-    * op sub *tmp105 *tmp103 *tmp104
-    * op add :compute:zx *tmp105 :compute:cx
-    * op mul *tmp107 2 :compute:x1
-    * op mul *tmp108 *tmp107 :compute:zy
-    * op add :compute:zy *tmp108 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label78 lessThan :compute:dist 64
-    * jump *label77 always
-    * label *label78
-    * label *label79
-    * label *label76
-    * op add :compute:i :compute:i 1
-    * jump *label135 lessThan :compute:i 63
-    * label *label77
+  205 set :compute:i 0
+  206 label *label187
+  207 set :compute:x1 :compute:zx
+  208 op mul *tmp103 :compute:zx :compute:zx
+  209 op mul *tmp104 :compute:zy :compute:zy
+  210 op sub *tmp105 *tmp103 *tmp104
+  211 op add :compute:zx *tmp105 :compute:cx
+  212 op mul *tmp107 2 :compute:x1
+  213 op mul *tmp108 *tmp107 :compute:zy
+  214 op add :compute:zy *tmp108 :compute:cy
+  215 op len :compute:dist :compute:zx :compute:zy
+  216 jump *label188 lessThan :compute:dist 64
+  217 jump *label77 always
+  218 label *label188
+  219 label *label189
+  220 label *label190
+  221 op add :compute:i :compute:i 1
+  222 set :compute:x1 :compute:zx
+  223 op mul *tmp103 :compute:zx :compute:zx
+  224 op mul *tmp104 :compute:zy :compute:zy
+  225 op sub *tmp105 *tmp103 *tmp104
+  226 op add :compute:zx *tmp105 :compute:cx
+  227 op mul *tmp107 2 :compute:x1
+  228 op mul *tmp108 *tmp107 :compute:zy
+  229 op add :compute:zy *tmp108 :compute:cy
+  230 op len :compute:dist :compute:zx :compute:zy
+  231 jump *label191 lessThan :compute:dist 64
+  232 jump *label77 always
+  233 label *label191
+  234 label *label192
+  235 label *label193
+  236 op add :compute:i :compute:i 1
+  237 set :compute:x1 :compute:zx
+  238 op mul *tmp103 :compute:zx :compute:zx
+  239 op mul *tmp104 :compute:zy :compute:zy
+  240 op sub *tmp105 *tmp103 *tmp104
+  241 op add :compute:zx *tmp105 :compute:cx
+  242 op mul *tmp107 2 :compute:x1
+  243 op mul *tmp108 *tmp107 :compute:zy
+  244 op add :compute:zy *tmp108 :compute:cy
+  245 op len :compute:dist :compute:zx :compute:zy
+  246 jump *label194 lessThan :compute:dist 64
+  247 jump *label77 always
+  248 label *label194
+  249 label *label195
+  250 label *label196
+  251 op add :compute:i :compute:i 1
+  252 set :compute:x1 :compute:zx
+  253 op mul *tmp103 :compute:zx :compute:zx
+  254 op mul *tmp104 :compute:zy :compute:zy
+  255 op sub *tmp105 *tmp103 *tmp104
+  256 op add :compute:zx *tmp105 :compute:cx
+  257 op mul *tmp107 2 :compute:x1
+  258 op mul *tmp108 *tmp107 :compute:zy
+  259 op add :compute:zy *tmp108 :compute:cy
+  260 op len :compute:dist :compute:zx :compute:zy
+  261 jump *label197 lessThan :compute:dist 64
+  262 jump *label77 always
+  263 label *label197
+  264 label *label198
+  265 label *label199
+  266 op add :compute:i :compute:i 1
+  267 set :compute:x1 :compute:zx
+  268 op mul *tmp103 :compute:zx :compute:zx
+  269 op mul *tmp104 :compute:zy :compute:zy
+  270 op sub *tmp105 *tmp103 *tmp104
+  271 op add :compute:zx *tmp105 :compute:cx
+  272 op mul *tmp107 2 :compute:x1
+  273 op mul *tmp108 *tmp107 :compute:zy
+  274 op add :compute:zy *tmp108 :compute:cy
+  275 op len :compute:dist :compute:zx :compute:zy
+  276 jump *label200 lessThan :compute:dist 64
+  277 jump *label77 always
+  278 label *label200
+  279 label *label201
+  280 label *label202
+  281 op add :compute:i :compute:i 1
+  282 set :compute:x1 :compute:zx
+  283 op mul *tmp103 :compute:zx :compute:zx
+  284 op mul *tmp104 :compute:zy :compute:zy
+  285 op sub *tmp105 *tmp103 *tmp104
+  286 op add :compute:zx *tmp105 :compute:cx
+  287 op mul *tmp107 2 :compute:x1
+  288 op mul *tmp108 *tmp107 :compute:zy
+  289 op add :compute:zy *tmp108 :compute:cy
+  290 op len :compute:dist :compute:zx :compute:zy
+  291 jump *label203 lessThan :compute:dist 64
+  292 jump *label77 always
+  293 label *label203
+  294 label *label204
+  295 label *label205
+  296 op add :compute:i :compute:i 1
+  297 set :compute:x1 :compute:zx
+  298 op mul *tmp103 :compute:zx :compute:zx
+  299 op mul *tmp104 :compute:zy :compute:zy
+  300 op sub *tmp105 *tmp103 *tmp104
+  301 op add :compute:zx *tmp105 :compute:cx
+  302 op mul *tmp107 2 :compute:x1
+  303 op mul *tmp108 *tmp107 :compute:zy
+  304 op add :compute:zy *tmp108 :compute:cy
+  305 op len :compute:dist :compute:zx :compute:zy
+  306 jump *label206 lessThan :compute:dist 64
+  307 jump *label77 always
+  308 label *label206
+  309 label *label207
+  310 label *label208
+  311 op add :compute:i :compute:i 1
+  312 set :compute:x1 :compute:zx
+  313 op mul *tmp103 :compute:zx :compute:zx
+  314 op mul *tmp104 :compute:zy :compute:zy
+  315 op sub *tmp105 *tmp103 *tmp104
+  316 op add :compute:zx *tmp105 :compute:cx
+  317 op mul *tmp107 2 :compute:x1
+  318 op mul *tmp108 *tmp107 :compute:zy
+  319 op add :compute:zy *tmp108 :compute:cy
+  320 op len :compute:dist :compute:zx :compute:zy
+  321 jump *label209 lessThan :compute:dist 64
+  322 jump *label77 always
+  323 label *label209
+  324 label *label210
+  325 label *label211
+  326 op add :compute:i :compute:i 1
+  327 set :compute:x1 :compute:zx
+  328 op mul *tmp103 :compute:zx :compute:zx
+  329 op mul *tmp104 :compute:zy :compute:zy
+  330 op sub *tmp105 *tmp103 *tmp104
+  331 op add :compute:zx *tmp105 :compute:cx
+  332 op mul *tmp107 2 :compute:x1
+  333 op mul *tmp108 *tmp107 :compute:zy
+  334 op add :compute:zy *tmp108 :compute:cy
+  335 op len :compute:dist :compute:zx :compute:zy
+  336 jump *label212 lessThan :compute:dist 64
+  337 jump *label77 always
+  338 label *label212
+  339 label *label213
+  340 label *label214
+  341 op add :compute:i :compute:i 1
+  342 set :compute:x1 :compute:zx
+  343 op mul *tmp103 :compute:zx :compute:zx
+  344 op mul *tmp104 :compute:zy :compute:zy
+  345 op sub *tmp105 *tmp103 *tmp104
+  346 op add :compute:zx *tmp105 :compute:cx
+  347 op mul *tmp107 2 :compute:x1
+  348 op mul *tmp108 *tmp107 :compute:zy
+  349 op add :compute:zy *tmp108 :compute:cy
+  350 op len :compute:dist :compute:zx :compute:zy
+  351 jump *label215 lessThan :compute:dist 64
+  352 jump *label77 always
+  353 label *label215
+  354 label *label216
+  355 label *label217
+  356 op add :compute:i :compute:i 1
+  357 set :compute:x1 :compute:zx
+  358 op mul *tmp103 :compute:zx :compute:zx
+  359 op mul *tmp104 :compute:zy :compute:zy
+  360 op sub *tmp105 *tmp103 *tmp104
+  361 op add :compute:zx *tmp105 :compute:cx
+  362 op mul *tmp107 2 :compute:x1
+  363 op mul *tmp108 *tmp107 :compute:zy
+  364 op add :compute:zy *tmp108 :compute:cy
+  365 op len :compute:dist :compute:zx :compute:zy
+  366 jump *label218 lessThan :compute:dist 64
+  367 jump *label77 always
+  368 label *label218
+  369 label *label219
+  370 label *label220
+  371 op add :compute:i :compute:i 1
+  372 set :compute:x1 :compute:zx
+  373 op mul *tmp103 :compute:zx :compute:zx
+  374 op mul *tmp104 :compute:zy :compute:zy
+  375 op sub *tmp105 *tmp103 *tmp104
+  376 op add :compute:zx *tmp105 :compute:cx
+  377 op mul *tmp107 2 :compute:x1
+  378 op mul *tmp108 *tmp107 :compute:zy
+  379 op add :compute:zy *tmp108 :compute:cy
+  380 op len :compute:dist :compute:zx :compute:zy
+  381 jump *label221 lessThan :compute:dist 64
+  382 jump *label77 always
+  383 label *label221
+  384 label *label222
+  385 label *label223
+  386 op add :compute:i :compute:i 1
+  387 set :compute:x1 :compute:zx
+  388 op mul *tmp103 :compute:zx :compute:zx
+  389 op mul *tmp104 :compute:zy :compute:zy
+  390 op sub *tmp105 *tmp103 *tmp104
+  391 op add :compute:zx *tmp105 :compute:cx
+  392 op mul *tmp107 2 :compute:x1
+  393 op mul *tmp108 *tmp107 :compute:zy
+  394 op add :compute:zy *tmp108 :compute:cy
+  395 op len :compute:dist :compute:zx :compute:zy
+  396 jump *label224 lessThan :compute:dist 64
+  397 jump *label77 always
+  398 label *label224
+  399 label *label225
+  400 label *label226
+  401 op add :compute:i :compute:i 1
+  402 set :compute:x1 :compute:zx
+  403 op mul *tmp103 :compute:zx :compute:zx
+  404 op mul *tmp104 :compute:zy :compute:zy
+  405 op sub *tmp105 *tmp103 *tmp104
+  406 op add :compute:zx *tmp105 :compute:cx
+  407 op mul *tmp107 2 :compute:x1
+  408 op mul *tmp108 *tmp107 :compute:zy
+  409 op add :compute:zy *tmp108 :compute:cy
+  410 op len :compute:dist :compute:zx :compute:zy
+  411 jump *label227 lessThan :compute:dist 64
+  412 jump *label77 always
+  413 label *label227
+  414 label *label228
+  415 label *label229
+  416 op add :compute:i :compute:i 1
+  417 set :compute:x1 :compute:zx
+  418 op mul *tmp103 :compute:zx :compute:zx
+  419 op mul *tmp104 :compute:zy :compute:zy
+  420 op sub *tmp105 *tmp103 *tmp104
+  421 op add :compute:zx *tmp105 :compute:cx
+  422 op mul *tmp107 2 :compute:x1
+  423 op mul *tmp108 *tmp107 :compute:zy
+  424 op add :compute:zy *tmp108 :compute:cy
+  425 op len :compute:dist :compute:zx :compute:zy
+  426 jump *label230 lessThan :compute:dist 64
+  427 jump *label77 always
+  428 label *label230
+  429 label *label231
+  430 label *label232
+  431 op add :compute:i :compute:i 1
+  432 set :compute:x1 :compute:zx
+  433 op mul *tmp103 :compute:zx :compute:zx
+  434 op mul *tmp104 :compute:zy :compute:zy
+  435 op sub *tmp105 *tmp103 *tmp104
+  436 op add :compute:zx *tmp105 :compute:cx
+  437 op mul *tmp107 2 :compute:x1
+  438 op mul *tmp108 *tmp107 :compute:zy
+  439 op add :compute:zy *tmp108 :compute:cy
+  440 op len :compute:dist :compute:zx :compute:zy
+  441 jump *label233 lessThan :compute:dist 64
+  442 jump *label77 always
+  443 label *label233
+  444 label *label234
+  445 label *label235
+  446 op add :compute:i :compute:i 1
+  447 set :compute:x1 :compute:zx
+  448 op mul *tmp103 :compute:zx :compute:zx
+  449 op mul *tmp104 :compute:zy :compute:zy
+  450 op sub *tmp105 *tmp103 *tmp104
+  451 op add :compute:zx *tmp105 :compute:cx
+  452 op mul *tmp107 2 :compute:x1
+  453 op mul *tmp108 *tmp107 :compute:zy
+  454 op add :compute:zy *tmp108 :compute:cy
+  455 op len :compute:dist :compute:zx :compute:zy
+  456 jump *label236 lessThan :compute:dist 64
+  457 jump *label77 always
+  458 label *label236
+  459 label *label237
+  460 label *label238
+  461 op add :compute:i :compute:i 1
+  462 set :compute:x1 :compute:zx
+  463 op mul *tmp103 :compute:zx :compute:zx
+  464 op mul *tmp104 :compute:zy :compute:zy
+  465 op sub *tmp105 *tmp103 *tmp104
+  466 op add :compute:zx *tmp105 :compute:cx
+  467 op mul *tmp107 2 :compute:x1
+  468 op mul *tmp108 *tmp107 :compute:zy
+  469 op add :compute:zy *tmp108 :compute:cy
+  470 op len :compute:dist :compute:zx :compute:zy
+  471 jump *label239 lessThan :compute:dist 64
+  472 jump *label77 always
+  473 label *label239
+  474 label *label240
+  475 label *label241
+  476 op add :compute:i :compute:i 1
+  477 set :compute:x1 :compute:zx
+  478 op mul *tmp103 :compute:zx :compute:zx
+  479 op mul *tmp104 :compute:zy :compute:zy
+  480 op sub *tmp105 *tmp103 *tmp104
+  481 op add :compute:zx *tmp105 :compute:cx
+  482 op mul *tmp107 2 :compute:x1
+  483 op mul *tmp108 *tmp107 :compute:zy
+  484 op add :compute:zy *tmp108 :compute:cy
+  485 op len :compute:dist :compute:zx :compute:zy
+  486 jump *label242 lessThan :compute:dist 64
+  487 jump *label77 always
+  488 label *label242
+  489 label *label243
+  490 label *label244
+  491 op add :compute:i :compute:i 1
+  492 set :compute:x1 :compute:zx
+  493 op mul *tmp103 :compute:zx :compute:zx
+  494 op mul *tmp104 :compute:zy :compute:zy
+  495 op sub *tmp105 *tmp103 *tmp104
+  496 op add :compute:zx *tmp105 :compute:cx
+  497 op mul *tmp107 2 :compute:x1
+  498 op mul *tmp108 *tmp107 :compute:zy
+  499 op add :compute:zy *tmp108 :compute:cy
+  500 op len :compute:dist :compute:zx :compute:zy
+  501 jump *label245 lessThan :compute:dist 64
+  502 jump *label77 always
+  503 label *label245
+  504 label *label246
+  505 label *label247
+  506 op add :compute:i :compute:i 1
+  507 set :compute:x1 :compute:zx
+  508 op mul *tmp103 :compute:zx :compute:zx
+  509 op mul *tmp104 :compute:zy :compute:zy
+  510 op sub *tmp105 *tmp103 *tmp104
+  511 op add :compute:zx *tmp105 :compute:cx
+  512 op mul *tmp107 2 :compute:x1
+  513 op mul *tmp108 *tmp107 :compute:zy
+  514 op add :compute:zy *tmp108 :compute:cy
+  515 op len :compute:dist :compute:zx :compute:zy
+  516 jump *label248 lessThan :compute:dist 64
+  517 jump *label77 always
+  518 label *label248
+  519 label *label249
+  520 label *label250
+  521 op add :compute:i :compute:i 1
+  522 set :compute:x1 :compute:zx
+  523 op mul *tmp103 :compute:zx :compute:zx
+  524 op mul *tmp104 :compute:zy :compute:zy
+  525 op sub *tmp105 *tmp103 *tmp104
+  526 op add :compute:zx *tmp105 :compute:cx
+  527 op mul *tmp107 2 :compute:x1
+  528 op mul *tmp108 *tmp107 :compute:zy
+  529 op add :compute:zy *tmp108 :compute:cy
+  530 op len :compute:dist :compute:zx :compute:zy
+  531 jump *label251 lessThan :compute:dist 64
+  532 jump *label77 always
+  533 label *label251
+  534 label *label252
+  535 label *label253
+  536 op add :compute:i :compute:i 1
+  537 set :compute:x1 :compute:zx
+  538 op mul *tmp103 :compute:zx :compute:zx
+  539 op mul *tmp104 :compute:zy :compute:zy
+  540 op sub *tmp105 *tmp103 *tmp104
+  541 op add :compute:zx *tmp105 :compute:cx
+  542 op mul *tmp107 2 :compute:x1
+  543 op mul *tmp108 *tmp107 :compute:zy
+  544 op add :compute:zy *tmp108 :compute:cy
+  545 op len :compute:dist :compute:zx :compute:zy
+  546 jump *label254 lessThan :compute:dist 64
+  547 jump *label77 always
+  548 label *label254
+  549 label *label255
+  550 label *label256
+  551 op add :compute:i :compute:i 1
+  552 set :compute:x1 :compute:zx
+  553 op mul *tmp103 :compute:zx :compute:zx
+  554 op mul *tmp104 :compute:zy :compute:zy
+  555 op sub *tmp105 *tmp103 *tmp104
+  556 op add :compute:zx *tmp105 :compute:cx
+  557 op mul *tmp107 2 :compute:x1
+  558 op mul *tmp108 *tmp107 :compute:zy
+  559 op add :compute:zy *tmp108 :compute:cy
+  560 op len :compute:dist :compute:zx :compute:zy
+  561 jump *label257 lessThan :compute:dist 64
+  562 jump *label77 always
+  563 label *label257
+  564 label *label258
+  565 label *label259
+  566 op add :compute:i :compute:i 1
+  567 set :compute:x1 :compute:zx
+  568 op mul *tmp103 :compute:zx :compute:zx
+  569 op mul *tmp104 :compute:zy :compute:zy
+  570 op sub *tmp105 *tmp103 *tmp104
+  571 op add :compute:zx *tmp105 :compute:cx
+  572 op mul *tmp107 2 :compute:x1
+  573 op mul *tmp108 *tmp107 :compute:zy
+  574 op add :compute:zy *tmp108 :compute:cy
+  575 op len :compute:dist :compute:zx :compute:zy
+  576 jump *label260 lessThan :compute:dist 64
+  577 jump *label77 always
+  578 label *label260
+  579 label *label261
+  580 label *label262
+  581 op add :compute:i :compute:i 1
+  582 set :compute:x1 :compute:zx
+  583 op mul *tmp103 :compute:zx :compute:zx
+  584 op mul *tmp104 :compute:zy :compute:zy
+  585 op sub *tmp105 *tmp103 *tmp104
+  586 op add :compute:zx *tmp105 :compute:cx
+  587 op mul *tmp107 2 :compute:x1
+  588 op mul *tmp108 *tmp107 :compute:zy
+  589 op add :compute:zy *tmp108 :compute:cy
+  590 op len :compute:dist :compute:zx :compute:zy
+  591 jump *label263 lessThan :compute:dist 64
+  592 jump *label77 always
+  593 label *label263
+  594 label *label264
+  595 label *label265
+  596 op add :compute:i :compute:i 1
+  597 set :compute:x1 :compute:zx
+  598 op mul *tmp103 :compute:zx :compute:zx
+  599 op mul *tmp104 :compute:zy :compute:zy
+  600 op sub *tmp105 *tmp103 *tmp104
+  601 op add :compute:zx *tmp105 :compute:cx
+  602 op mul *tmp107 2 :compute:x1
+  603 op mul *tmp108 *tmp107 :compute:zy
+  604 op add :compute:zy *tmp108 :compute:cy
+  605 op len :compute:dist :compute:zx :compute:zy
+  606 jump *label266 lessThan :compute:dist 64
+  607 jump *label77 always
+  608 label *label266
+  609 label *label267
+  610 label *label268
+  611 op add :compute:i :compute:i 1
+  612 set :compute:x1 :compute:zx
+  613 op mul *tmp103 :compute:zx :compute:zx
+  614 op mul *tmp104 :compute:zy :compute:zy
+  615 op sub *tmp105 *tmp103 *tmp104
+  616 op add :compute:zx *tmp105 :compute:cx
+  617 op mul *tmp107 2 :compute:x1
+  618 op mul *tmp108 *tmp107 :compute:zy
+  619 op add :compute:zy *tmp108 :compute:cy
+  620 op len :compute:dist :compute:zx :compute:zy
+  621 jump *label269 lessThan :compute:dist 64
+  622 jump *label77 always
+  623 label *label269
+  624 label *label270
+  625 label *label271
+  626 op add :compute:i :compute:i 1
+  627 set :compute:x1 :compute:zx
+  628 op mul *tmp103 :compute:zx :compute:zx
+  629 op mul *tmp104 :compute:zy :compute:zy
+  630 op sub *tmp105 *tmp103 *tmp104
+  631 op add :compute:zx *tmp105 :compute:cx
+  632 op mul *tmp107 2 :compute:x1
+  633 op mul *tmp108 *tmp107 :compute:zy
+  634 op add :compute:zy *tmp108 :compute:cy
+  635 op len :compute:dist :compute:zx :compute:zy
+  636 jump *label272 lessThan :compute:dist 64
+  637 jump *label77 always
+  638 label *label272
+  639 label *label273
+  640 label *label274
+  641 op add :compute:i :compute:i 1
+  642 set :compute:x1 :compute:zx
+  643 op mul *tmp103 :compute:zx :compute:zx
+  644 op mul *tmp104 :compute:zy :compute:zy
+  645 op sub *tmp105 *tmp103 *tmp104
+  646 op add :compute:zx *tmp105 :compute:cx
+  647 op mul *tmp107 2 :compute:x1
+  648 op mul *tmp108 *tmp107 :compute:zy
+  649 op add :compute:zy *tmp108 :compute:cy
+  650 op len :compute:dist :compute:zx :compute:zy
+  651 jump *label275 lessThan :compute:dist 64
+  652 jump *label77 always
+  653 label *label275
+  654 label *label276
+  655 label *label277
+  656 op add :compute:i :compute:i 1
+  657 set :compute:x1 :compute:zx
+  658 op mul *tmp103 :compute:zx :compute:zx
+  659 op mul *tmp104 :compute:zy :compute:zy
+  660 op sub *tmp105 *tmp103 *tmp104
+  661 op add :compute:zx *tmp105 :compute:cx
+  662 op mul *tmp107 2 :compute:x1
+  663 op mul *tmp108 *tmp107 :compute:zy
+  664 op add :compute:zy *tmp108 :compute:cy
+  665 op len :compute:dist :compute:zx :compute:zy
+  666 jump *label278 lessThan :compute:dist 64
+  667 jump *label77 always
+  668 label *label278
+  669 label *label279
+  670 label *label280
+  671 op add :compute:i :compute:i 1
+  672 set :compute:x1 :compute:zx
+  673 op mul *tmp103 :compute:zx :compute:zx
+  674 op mul *tmp104 :compute:zy :compute:zy
+  675 op sub *tmp105 *tmp103 *tmp104
+  676 op add :compute:zx *tmp105 :compute:cx
+  677 op mul *tmp107 2 :compute:x1
+  678 op mul *tmp108 *tmp107 :compute:zy
+  679 op add :compute:zy *tmp108 :compute:cy
+  680 op len :compute:dist :compute:zx :compute:zy
+  681 jump *label281 lessThan :compute:dist 64
+  682 jump *label77 always
+  683 label *label281
+  684 label *label282
+  685 label *label283
+  686 op add :compute:i :compute:i 1
+  687 set :compute:x1 :compute:zx
+  688 op mul *tmp103 :compute:zx :compute:zx
+  689 op mul *tmp104 :compute:zy :compute:zy
+  690 op sub *tmp105 *tmp103 *tmp104
+  691 op add :compute:zx *tmp105 :compute:cx
+  692 op mul *tmp107 2 :compute:x1
+  693 op mul *tmp108 *tmp107 :compute:zy
+  694 op add :compute:zy *tmp108 :compute:cy
+  695 op len :compute:dist :compute:zx :compute:zy
+  696 jump *label284 lessThan :compute:dist 64
+  697 jump *label77 always
+  698 label *label284
+  699 label *label285
+  700 label *label286
+  701 op add :compute:i :compute:i 1
+  702 set :compute:x1 :compute:zx
+  703 op mul *tmp103 :compute:zx :compute:zx
+  704 op mul *tmp104 :compute:zy :compute:zy
+  705 op sub *tmp105 *tmp103 *tmp104
+  706 op add :compute:zx *tmp105 :compute:cx
+  707 op mul *tmp107 2 :compute:x1
+  708 op mul *tmp108 *tmp107 :compute:zy
+  709 op add :compute:zy *tmp108 :compute:cy
+  710 op len :compute:dist :compute:zx :compute:zy
+  711 jump *label287 lessThan :compute:dist 64
+  712 jump *label77 always
+  713 label *label287
+  714 label *label288
+  715 label *label289
+  716 op add :compute:i :compute:i 1
+  717 set :compute:x1 :compute:zx
+  718 op mul *tmp103 :compute:zx :compute:zx
+  719 op mul *tmp104 :compute:zy :compute:zy
+  720 op sub *tmp105 *tmp103 *tmp104
+  721 op add :compute:zx *tmp105 :compute:cx
+  722 op mul *tmp107 2 :compute:x1
+  723 op mul *tmp108 *tmp107 :compute:zy
+  724 op add :compute:zy *tmp108 :compute:cy
+  725 op len :compute:dist :compute:zx :compute:zy
+  726 jump *label290 lessThan :compute:dist 64
+  727 jump *label77 always
+  728 label *label290
+  729 label *label291
+  730 label *label292
+  731 op add :compute:i :compute:i 1
+  732 set :compute:x1 :compute:zx
+  733 op mul *tmp103 :compute:zx :compute:zx
+  734 op mul *tmp104 :compute:zy :compute:zy
+  735 op sub *tmp105 *tmp103 *tmp104
+  736 op add :compute:zx *tmp105 :compute:cx
+  737 op mul *tmp107 2 :compute:x1
+  738 op mul *tmp108 *tmp107 :compute:zy
+  739 op add :compute:zy *tmp108 :compute:cy
+  740 op len :compute:dist :compute:zx :compute:zy
+  741 jump *label293 lessThan :compute:dist 64
+  742 jump *label77 always
+  743 label *label293
+  744 label *label294
+  745 label *label295
+  746 op add :compute:i :compute:i 1
+  747 set :compute:x1 :compute:zx
+  748 op mul *tmp103 :compute:zx :compute:zx
+  749 op mul *tmp104 :compute:zy :compute:zy
+  750 op sub *tmp105 *tmp103 *tmp104
+  751 op add :compute:zx *tmp105 :compute:cx
+  752 op mul *tmp107 2 :compute:x1
+  753 op mul *tmp108 *tmp107 :compute:zy
+  754 op add :compute:zy *tmp108 :compute:cy
+  755 op len :compute:dist :compute:zx :compute:zy
+  756 jump *label296 lessThan :compute:dist 64
+  757 jump *label77 always
+  758 label *label296
+  759 label *label297
+  760 label *label298
+  761 op add :compute:i :compute:i 1
+  762 set :compute:x1 :compute:zx
+  763 op mul *tmp103 :compute:zx :compute:zx
+  764 op mul *tmp104 :compute:zy :compute:zy
+  765 op sub *tmp105 *tmp103 *tmp104
+  766 op add :compute:zx *tmp105 :compute:cx
+  767 op mul *tmp107 2 :compute:x1
+  768 op mul *tmp108 *tmp107 :compute:zy
+  769 op add :compute:zy *tmp108 :compute:cy
+  770 op len :compute:dist :compute:zx :compute:zy
+  771 jump *label299 lessThan :compute:dist 64
+  772 jump *label77 always
+  773 label *label299
+  774 label *label300
+  775 label *label301
+  776 op add :compute:i :compute:i 1
+  777 set :compute:x1 :compute:zx
+  778 op mul *tmp103 :compute:zx :compute:zx
+  779 op mul *tmp104 :compute:zy :compute:zy
+  780 op sub *tmp105 *tmp103 *tmp104
+  781 op add :compute:zx *tmp105 :compute:cx
+  782 op mul *tmp107 2 :compute:x1
+  783 op mul *tmp108 *tmp107 :compute:zy
+  784 op add :compute:zy *tmp108 :compute:cy
+  785 op len :compute:dist :compute:zx :compute:zy
+  786 jump *label302 lessThan :compute:dist 64
+  787 jump *label77 always
+  788 label *label302
+  789 label *label303
+  790 label *label304
+  791 op add :compute:i :compute:i 1
+  792 set :compute:x1 :compute:zx
+  793 op mul *tmp103 :compute:zx :compute:zx
+  794 op mul *tmp104 :compute:zy :compute:zy
+  795 op sub *tmp105 *tmp103 *tmp104
+  796 op add :compute:zx *tmp105 :compute:cx
+  797 op mul *tmp107 2 :compute:x1
+  798 op mul *tmp108 *tmp107 :compute:zy
+  799 op add :compute:zy *tmp108 :compute:cy
+  800 op len :compute:dist :compute:zx :compute:zy
+  801 jump *label305 lessThan :compute:dist 64
+  802 jump *label77 always
+  803 label *label305
+  804 label *label306
+  805 label *label307
+  806 op add :compute:i :compute:i 1
+  807 set :compute:x1 :compute:zx
+  808 op mul *tmp103 :compute:zx :compute:zx
+  809 op mul *tmp104 :compute:zy :compute:zy
+  810 op sub *tmp105 *tmp103 *tmp104
+  811 op add :compute:zx *tmp105 :compute:cx
+  812 op mul *tmp107 2 :compute:x1
+  813 op mul *tmp108 *tmp107 :compute:zy
+  814 op add :compute:zy *tmp108 :compute:cy
+  815 op len :compute:dist :compute:zx :compute:zy
+  816 jump *label308 lessThan :compute:dist 64
+  817 jump *label77 always
+  818 label *label308
+  819 label *label309
+  820 label *label310
+  821 op add :compute:i :compute:i 1
+  822 set :compute:x1 :compute:zx
+  823 op mul *tmp103 :compute:zx :compute:zx
+  824 op mul *tmp104 :compute:zy :compute:zy
+  825 op sub *tmp105 *tmp103 *tmp104
+  826 op add :compute:zx *tmp105 :compute:cx
+  827 op mul *tmp107 2 :compute:x1
+  828 op mul *tmp108 *tmp107 :compute:zy
+  829 op add :compute:zy *tmp108 :compute:cy
+  830 op len :compute:dist :compute:zx :compute:zy
+  831 jump *label311 lessThan :compute:dist 64
+  832 jump *label77 always
+  833 label *label311
+  834 label *label312
+  835 label *label313
+  836 op add :compute:i :compute:i 1
+  837 set :compute:x1 :compute:zx
+  838 op mul *tmp103 :compute:zx :compute:zx
+  839 op mul *tmp104 :compute:zy :compute:zy
+  840 op sub *tmp105 *tmp103 *tmp104
+  841 op add :compute:zx *tmp105 :compute:cx
+  842 op mul *tmp107 2 :compute:x1
+  843 op mul *tmp108 *tmp107 :compute:zy
+  844 op add :compute:zy *tmp108 :compute:cy
+  845 op len :compute:dist :compute:zx :compute:zy
+  846 jump *label314 lessThan :compute:dist 64
+  847 jump *label77 always
+  848 label *label314
+  849 label *label315
+  850 label *label316
+  851 op add :compute:i :compute:i 1
+  852 set :compute:x1 :compute:zx
+  853 op mul *tmp103 :compute:zx :compute:zx
+  854 op mul *tmp104 :compute:zy :compute:zy
+  855 op sub *tmp105 *tmp103 *tmp104
+  856 op add :compute:zx *tmp105 :compute:cx
+  857 op mul *tmp107 2 :compute:x1
+  858 op mul *tmp108 *tmp107 :compute:zy
+  859 op add :compute:zy *tmp108 :compute:cy
+  860 op len :compute:dist :compute:zx :compute:zy
+  861 jump *label317 lessThan :compute:dist 64
+  862 jump *label77 always
+  863 label *label317
+  864 label *label318
+  865 label *label319
+  866 op add :compute:i :compute:i 1
+  867 set :compute:x1 :compute:zx
+  868 op mul *tmp103 :compute:zx :compute:zx
+  869 op mul *tmp104 :compute:zy :compute:zy
+  870 op sub *tmp105 *tmp103 *tmp104
+  871 op add :compute:zx *tmp105 :compute:cx
+  872 op mul *tmp107 2 :compute:x1
+  873 op mul *tmp108 *tmp107 :compute:zy
+  874 op add :compute:zy *tmp108 :compute:cy
+  875 op len :compute:dist :compute:zx :compute:zy
+  876 jump *label320 lessThan :compute:dist 64
+  877 jump *label77 always
+  878 label *label320
+  879 label *label321
+  880 label *label322
+  881 op add :compute:i :compute:i 1
+  882 set :compute:x1 :compute:zx
+  883 op mul *tmp103 :compute:zx :compute:zx
+  884 op mul *tmp104 :compute:zy :compute:zy
+  885 op sub *tmp105 *tmp103 *tmp104
+  886 op add :compute:zx *tmp105 :compute:cx
+  887 op mul *tmp107 2 :compute:x1
+  888 op mul *tmp108 *tmp107 :compute:zy
+  889 op add :compute:zy *tmp108 :compute:cy
+  890 op len :compute:dist :compute:zx :compute:zy
+  891 jump *label323 lessThan :compute:dist 64
+  892 jump *label77 always
+  893 label *label323
+  894 label *label324
+  895 label *label325
+  896 op add :compute:i :compute:i 1
+  897 set :compute:x1 :compute:zx
+  898 op mul *tmp103 :compute:zx :compute:zx
+  899 op mul *tmp104 :compute:zy :compute:zy
+  900 op sub *tmp105 *tmp103 *tmp104
+  901 op add :compute:zx *tmp105 :compute:cx
+  902 op mul *tmp107 2 :compute:x1
+  903 op mul *tmp108 *tmp107 :compute:zy
+  904 op add :compute:zy *tmp108 :compute:cy
+  905 op len :compute:dist :compute:zx :compute:zy
+  906 jump *label326 lessThan :compute:dist 64
+  907 jump *label77 always
+  908 label *label326
+  909 label *label327
+  910 label *label328
+  911 op add :compute:i :compute:i 1
+  912 set :compute:x1 :compute:zx
+  913 op mul *tmp103 :compute:zx :compute:zx
+  914 op mul *tmp104 :compute:zy :compute:zy
+  915 op sub *tmp105 *tmp103 *tmp104
+  916 op add :compute:zx *tmp105 :compute:cx
+  917 op mul *tmp107 2 :compute:x1
+  918 op mul *tmp108 *tmp107 :compute:zy
+  919 op add :compute:zy *tmp108 :compute:cy
+  920 op len :compute:dist :compute:zx :compute:zy
+  921 jump *label329 lessThan :compute:dist 64
+  922 jump *label77 always
+  923 label *label329
+  924 label *label330
+  925 label *label331
+  926 op add :compute:i :compute:i 1
+  927 set :compute:x1 :compute:zx
+  928 op mul *tmp103 :compute:zx :compute:zx
+  929 op mul *tmp104 :compute:zy :compute:zy
+  930 op sub *tmp105 *tmp103 *tmp104
+  931 op add :compute:zx *tmp105 :compute:cx
+  932 op mul *tmp107 2 :compute:x1
+  933 op mul *tmp108 *tmp107 :compute:zy
+  934 op add :compute:zy *tmp108 :compute:cy
+  935 op len :compute:dist :compute:zx :compute:zy
+  936 jump *label332 lessThan :compute:dist 64
+  937 jump *label77 always
+  938 label *label332
+  939 label *label333
+  940 label *label334
+  941 op add :compute:i :compute:i 1
+  942 set :compute:x1 :compute:zx
+  943 op mul *tmp103 :compute:zx :compute:zx
+  944 op mul *tmp104 :compute:zy :compute:zy
+  945 op sub *tmp105 *tmp103 *tmp104
+  946 op add :compute:zx *tmp105 :compute:cx
+  947 op mul *tmp107 2 :compute:x1
+  948 op mul *tmp108 *tmp107 :compute:zy
+  949 op add :compute:zy *tmp108 :compute:cy
+  950 op len :compute:dist :compute:zx :compute:zy
+  951 jump *label335 lessThan :compute:dist 64
+  952 jump *label77 always
+  953 label *label335
+  954 label *label336
+  955 label *label337
+  956 op add :compute:i :compute:i 1
+  957 set :compute:x1 :compute:zx
+  958 op mul *tmp103 :compute:zx :compute:zx
+  959 op mul *tmp104 :compute:zy :compute:zy
+  960 op sub *tmp105 *tmp103 *tmp104
+  961 op add :compute:zx *tmp105 :compute:cx
+  962 op mul *tmp107 2 :compute:x1
+  963 op mul *tmp108 *tmp107 :compute:zy
+  964 op add :compute:zy *tmp108 :compute:cy
+  965 op len :compute:dist :compute:zx :compute:zy
+  966 jump *label338 lessThan :compute:dist 64
+  967 jump *label77 always
+  968 label *label338
+  969 label *label339
+  970 label *label340
+  971 op add :compute:i :compute:i 1
+  972 set :compute:x1 :compute:zx
+  973 op mul *tmp103 :compute:zx :compute:zx
+  974 op mul *tmp104 :compute:zy :compute:zy
+  975 op sub *tmp105 *tmp103 *tmp104
+  976 op add :compute:zx *tmp105 :compute:cx
+  977 op mul *tmp107 2 :compute:x1
+  978 op mul *tmp108 *tmp107 :compute:zy
+  979 op add :compute:zy *tmp108 :compute:cy
+  980 op len :compute:dist :compute:zx :compute:zy
+  981 jump *label341 lessThan :compute:dist 64
+  982 jump *label77 always
+  983 label *label341
+  984 label *label342
+  985 label *label343
+  986 op add :compute:i :compute:i 1
+  987 set :compute:x1 :compute:zx
+  988 op mul *tmp103 :compute:zx :compute:zx
+  989 op mul *tmp104 :compute:zy :compute:zy
+  990 op sub *tmp105 *tmp103 *tmp104
+  991 op add :compute:zx *tmp105 :compute:cx
+  992 op mul *tmp107 2 :compute:x1
+  993 op mul *tmp108 *tmp107 :compute:zy
+  994 op add :compute:zy *tmp108 :compute:cy
+  995 op len :compute:dist :compute:zx :compute:zy
+  996 jump *label344 lessThan :compute:dist 64
+  997 jump *label77 always
+  998 label *label344
+  999 label *label345
+ 1000 label *label346
+ 1001 op add :compute:i :compute:i 1
+ 1002 set :compute:x1 :compute:zx
+ 1003 op mul *tmp103 :compute:zx :compute:zx
+ 1004 op mul *tmp104 :compute:zy :compute:zy
+ 1005 op sub *tmp105 *tmp103 *tmp104
+ 1006 op add :compute:zx *tmp105 :compute:cx
+ 1007 op mul *tmp107 2 :compute:x1
+ 1008 op mul *tmp108 *tmp107 :compute:zy
+ 1009 op add :compute:zy *tmp108 :compute:cy
+ 1010 op len :compute:dist :compute:zx :compute:zy
+ 1011 jump *label347 lessThan :compute:dist 64
+ 1012 jump *label77 always
+ 1013 label *label347
+ 1014 label *label348
+ 1015 label *label349
+ 1016 op add :compute:i :compute:i 1
+ 1017 set :compute:x1 :compute:zx
+ 1018 op mul *tmp103 :compute:zx :compute:zx
+ 1019 op mul *tmp104 :compute:zy :compute:zy
+ 1020 op sub *tmp105 *tmp103 *tmp104
+ 1021 op add :compute:zx *tmp105 :compute:cx
+ 1022 op mul *tmp107 2 :compute:x1
+ 1023 op mul *tmp108 *tmp107 :compute:zy
+ 1024 op add :compute:zy *tmp108 :compute:cy
+ 1025 op len :compute:dist :compute:zx :compute:zy
+ 1026 jump *label350 lessThan :compute:dist 64
+ 1027 jump *label77 always
+ 1028 label *label350
+ 1029 label *label351
+ 1030 label *label352
+ 1031 op add :compute:i :compute:i 1
+ 1032 set :compute:x1 :compute:zx
+ 1033 op mul *tmp103 :compute:zx :compute:zx
+ 1034 op mul *tmp104 :compute:zy :compute:zy
+ 1035 op sub *tmp105 *tmp103 *tmp104
+ 1036 op add :compute:zx *tmp105 :compute:cx
+ 1037 op mul *tmp107 2 :compute:x1
+ 1038 op mul *tmp108 *tmp107 :compute:zy
+ 1039 op add :compute:zy *tmp108 :compute:cy
+ 1040 op len :compute:dist :compute:zx :compute:zy
+ 1041 jump *label353 lessThan :compute:dist 64
+ 1042 jump *label77 always
+ 1043 label *label353
+ 1044 label *label354
+ 1045 label *label355
+ 1046 op add :compute:i :compute:i 1
+ 1047 set :compute:x1 :compute:zx
+ 1048 op mul *tmp103 :compute:zx :compute:zx
+ 1049 op mul *tmp104 :compute:zy :compute:zy
+ 1050 op sub *tmp105 *tmp103 *tmp104
+ 1051 op add :compute:zx *tmp105 :compute:cx
+ 1052 op mul *tmp107 2 :compute:x1
+ 1053 op mul *tmp108 *tmp107 :compute:zy
+ 1054 op add :compute:zy *tmp108 :compute:cy
+ 1055 op len :compute:dist :compute:zx :compute:zy
+ 1056 jump *label356 lessThan :compute:dist 64
+ 1057 jump *label77 always
+ 1058 label *label356
+ 1059 label *label357
+ 1060 label *label358
+ 1061 op add :compute:i :compute:i 1
+ 1062 set :compute:x1 :compute:zx
+ 1063 op mul *tmp103 :compute:zx :compute:zx
+ 1064 op mul *tmp104 :compute:zy :compute:zy
+ 1065 op sub *tmp105 *tmp103 *tmp104
+ 1066 op add :compute:zx *tmp105 :compute:cx
+ 1067 op mul *tmp107 2 :compute:x1
+ 1068 op mul *tmp108 *tmp107 :compute:zy
+ 1069 op add :compute:zy *tmp108 :compute:cy
+ 1070 op len :compute:dist :compute:zx :compute:zy
+ 1071 jump *label359 lessThan :compute:dist 64
+ 1072 jump *label77 always
+ 1073 label *label359
+ 1074 label *label360
+ 1075 label *label361
+ 1076 op add :compute:i :compute:i 1
+ 1077 set :compute:x1 :compute:zx
+ 1078 op mul *tmp103 :compute:zx :compute:zx
+ 1079 op mul *tmp104 :compute:zy :compute:zy
+ 1080 op sub *tmp105 *tmp103 *tmp104
+ 1081 op add :compute:zx *tmp105 :compute:cx
+ 1082 op mul *tmp107 2 :compute:x1
+ 1083 op mul *tmp108 *tmp107 :compute:zy
+ 1084 op add :compute:zy *tmp108 :compute:cy
+ 1085 op len :compute:dist :compute:zx :compute:zy
+ 1086 jump *label362 lessThan :compute:dist 64
+ 1087 jump *label77 always
+ 1088 label *label362
+ 1089 label *label363
+ 1090 label *label364
+ 1091 op add :compute:i :compute:i 1
+ 1092 set :compute:x1 :compute:zx
+ 1093 op mul *tmp103 :compute:zx :compute:zx
+ 1094 op mul *tmp104 :compute:zy :compute:zy
+ 1095 op sub *tmp105 *tmp103 *tmp104
+ 1096 op add :compute:zx *tmp105 :compute:cx
+ 1097 op mul *tmp107 2 :compute:x1
+ 1098 op mul *tmp108 *tmp107 :compute:zy
+ 1099 op add :compute:zy *tmp108 :compute:cy
+ 1100 op len :compute:dist :compute:zx :compute:zy
+ 1101 jump *label365 lessThan :compute:dist 64
+ 1102 jump *label77 always
+ 1103 label *label365
+ 1104 label *label366
+ 1105 label *label367
+ 1106 op add :compute:i :compute:i 1
+ 1107 set :compute:x1 :compute:zx
+ 1108 op mul *tmp103 :compute:zx :compute:zx
+ 1109 op mul *tmp104 :compute:zy :compute:zy
+ 1110 op sub *tmp105 *tmp103 *tmp104
+ 1111 op add :compute:zx *tmp105 :compute:cx
+ 1112 op mul *tmp107 2 :compute:x1
+ 1113 op mul *tmp108 *tmp107 :compute:zy
+ 1114 op add :compute:zy *tmp108 :compute:cy
+ 1115 op len :compute:dist :compute:zx :compute:zy
+ 1116 jump *label368 lessThan :compute:dist 64
+ 1117 jump *label77 always
+ 1118 label *label368
+ 1119 label *label369
+ 1120 label *label370
+ 1121 op add :compute:i :compute:i 1
+ 1122 set :compute:x1 :compute:zx
+ 1123 op mul *tmp103 :compute:zx :compute:zx
+ 1124 op mul *tmp104 :compute:zy :compute:zy
+ 1125 op sub *tmp105 *tmp103 *tmp104
+ 1126 op add :compute:zx *tmp105 :compute:cx
+ 1127 op mul *tmp107 2 :compute:x1
+ 1128 op mul *tmp108 *tmp107 :compute:zy
+ 1129 op add :compute:zy *tmp108 :compute:cy
+ 1130 op len :compute:dist :compute:zx :compute:zy
+ 1131 jump *label371 lessThan :compute:dist 64
+ 1132 jump *label77 always
+ 1133 label *label371
+ 1134 label *label372
+ 1135 label *label373
+ 1136 op add :compute:i :compute:i 1
+ 1137 set :compute:x1 :compute:zx
+ 1138 op mul *tmp103 :compute:zx :compute:zx
+ 1139 op mul *tmp104 :compute:zy :compute:zy
+ 1140 op sub *tmp105 *tmp103 *tmp104
+ 1141 op add :compute:zx *tmp105 :compute:cx
+ 1142 op mul *tmp107 2 :compute:x1
+ 1143 op mul *tmp108 *tmp107 :compute:zy
+ 1144 op add :compute:zy *tmp108 :compute:cy
+ 1145 op len :compute:dist :compute:zx :compute:zy
+ 1146 jump *label374 lessThan :compute:dist 64
+ 1147 jump *label77 always
+ 1148 label *label374
+ 1149 label *label375
+ 1150 label *label376
+ 1151 op add :compute:i :compute:i 1
+ 1152 label *label77
  1153 jump *label80 lessThanEq .PALETTE 1
  1154 jump *label80 greaterThanEq :compute:i 63
  1155 op log *tmp115 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   218 label *label188
   219 label *label189
   220 label *label190
-    * op add :compute:i :compute:i 1
+  221 op add :compute:i 0 1
   222 set :compute:x1 :compute:zx
   223 op mul *tmp103 :compute:zx :compute:zx
   224 op mul *tmp104 :compute:zy :compute:zy
 
   233 label *label191
   234 label *label192
   235 label *label193
-    * op add :compute:i :compute:i 1
+  236 op add :compute:i 1 1
   237 set :compute:x1 :compute:zx
   238 op mul *tmp103 :compute:zx :compute:zx
   239 op mul *tmp104 :compute:zy :compute:zy
 
   248 label *label194
   249 label *label195
   250 label *label196
-    * op add :compute:i :compute:i 1
+  251 op add :compute:i 2 1
   252 set :compute:x1 :compute:zx
   253 op mul *tmp103 :compute:zx :compute:zx
   254 op mul *tmp104 :compute:zy :compute:zy
 
   263 label *label197
   264 label *label198
   265 label *label199
-    * op add :compute:i :compute:i 1
+  266 op add :compute:i 3 1
   267 set :compute:x1 :compute:zx
   268 op mul *tmp103 :compute:zx :compute:zx
   269 op mul *tmp104 :compute:zy :compute:zy
 
   278 label *label200
   279 label *label201
   280 label *label202
-    * op add :compute:i :compute:i 1
+  281 op add :compute:i 4 1
   282 set :compute:x1 :compute:zx
   283 op mul *tmp103 :compute:zx :compute:zx
   284 op mul *tmp104 :compute:zy :compute:zy
 
   293 label *label203
   294 label *label204
   295 label *label205
-    * op add :compute:i :compute:i 1
+  296 op add :compute:i 5 1
   297 set :compute:x1 :compute:zx
   298 op mul *tmp103 :compute:zx :compute:zx
   299 op mul *tmp104 :compute:zy :compute:zy
 
   308 label *label206
   309 label *label207
   310 label *label208
-    * op add :compute:i :compute:i 1
+  311 op add :compute:i 6 1
   312 set :compute:x1 :compute:zx
   313 op mul *tmp103 :compute:zx :compute:zx
   314 op mul *tmp104 :compute:zy :compute:zy
 
   323 label *label209
   324 label *label210
   325 label *label211
-    * op add :compute:i :compute:i 1
+  326 op add :compute:i 7 1
   327 set :compute:x1 :compute:zx
   328 op mul *tmp103 :compute:zx :compute:zx
   329 op mul *tmp104 :compute:zy :compute:zy
 
   338 label *label212
   339 label *label213
   340 label *label214
-    * op add :compute:i :compute:i 1
+  341 op add :compute:i 8 1
   342 set :compute:x1 :compute:zx
   343 op mul *tmp103 :compute:zx :compute:zx
   344 op mul *tmp104 :compute:zy :compute:zy
 
   353 label *label215
   354 label *label216
   355 label *label217
-    * op add :compute:i :compute:i 1
+  356 op add :compute:i 9 1
   357 set :compute:x1 :compute:zx
   358 op mul *tmp103 :compute:zx :compute:zx
   359 op mul *tmp104 :compute:zy :compute:zy
 
   368 label *label218
   369 label *label219
   370 label *label220
-    * op add :compute:i :compute:i 1
+  371 op add :compute:i 10 1
   372 set :compute:x1 :compute:zx
   373 op mul *tmp103 :compute:zx :compute:zx
   374 op mul *tmp104 :compute:zy :compute:zy
 
   383 label *label221
   384 label *label222
   385 label *label223
-    * op add :compute:i :compute:i 1
+  386 op add :compute:i 11 1
   387 set :compute:x1 :compute:zx
   388 op mul *tmp103 :compute:zx :compute:zx
   389 op mul *tmp104 :compute:zy :compute:zy
 
   398 label *label224
   399 label *label225
   400 label *label226
-    * op add :compute:i :compute:i 1
+  401 op add :compute:i 12 1
   402 set :compute:x1 :compute:zx
   403 op mul *tmp103 :compute:zx :compute:zx
   404 op mul *tmp104 :compute:zy :compute:zy
 
   413 label *label227
   414 label *label228
   415 label *label229
-    * op add :compute:i :compute:i 1
+  416 op add :compute:i 13 1
   417 set :compute:x1 :compute:zx
   418 op mul *tmp103 :compute:zx :compute:zx
   419 op mul *tmp104 :compute:zy :compute:zy
 
   428 label *label230
   429 label *label231
   430 label *label232
-    * op add :compute:i :compute:i 1
+  431 op add :compute:i 14 1
   432 set :compute:x1 :compute:zx
   433 op mul *tmp103 :compute:zx :compute:zx
   434 op mul *tmp104 :compute:zy :compute:zy
 
   443 label *label233
   444 label *label234
   445 label *label235
-    * op add :compute:i :compute:i 1
+  446 op add :compute:i 15 1
   447 set :compute:x1 :compute:zx
   448 op mul *tmp103 :compute:zx :compute:zx
   449 op mul *tmp104 :compute:zy :compute:zy
 
   458 label *label236
   459 label *label237
   460 label *label238
-    * op add :compute:i :compute:i 1
+  461 op add :compute:i 16 1
   462 set :compute:x1 :compute:zx
   463 op mul *tmp103 :compute:zx :compute:zx
   464 op mul *tmp104 :compute:zy :compute:zy
 
   473 label *label239
   474 label *label240
   475 label *label241
-    * op add :compute:i :compute:i 1
+  476 op add :compute:i 17 1
   477 set :compute:x1 :compute:zx
   478 op mul *tmp103 :compute:zx :compute:zx
   479 op mul *tmp104 :compute:zy :compute:zy
 
   488 label *label242
   489 label *label243
   490 label *label244
-    * op add :compute:i :compute:i 1
+  491 op add :compute:i 18 1
   492 set :compute:x1 :compute:zx
   493 op mul *tmp103 :compute:zx :compute:zx
   494 op mul *tmp104 :compute:zy :compute:zy
 
   503 label *label245
   504 label *label246
   505 label *label247
-    * op add :compute:i :compute:i 1
+  506 op add :compute:i 19 1
   507 set :compute:x1 :compute:zx
   508 op mul *tmp103 :compute:zx :compute:zx
   509 op mul *tmp104 :compute:zy :compute:zy
 
   518 label *label248
   519 label *label249
   520 label *label250
-    * op add :compute:i :compute:i 1
+  521 op add :compute:i 20 1
   522 set :compute:x1 :compute:zx
   523 op mul *tmp103 :compute:zx :compute:zx
   524 op mul *tmp104 :compute:zy :compute:zy
 
   533 label *label251
   534 label *label252
   535 label *label253
-    * op add :compute:i :compute:i 1
+  536 op add :compute:i 21 1
   537 set :compute:x1 :compute:zx
   538 op mul *tmp103 :compute:zx :compute:zx
   539 op mul *tmp104 :compute:zy :compute:zy
 
   548 label *label254
   549 label *label255
   550 label *label256
-    * op add :compute:i :compute:i 1
+  551 op add :compute:i 22 1
   552 set :compute:x1 :compute:zx
   553 op mul *tmp103 :compute:zx :compute:zx
   554 op mul *tmp104 :compute:zy :compute:zy
 
   563 label *label257
   564 label *label258
   565 label *label259
-    * op add :compute:i :compute:i 1
+  566 op add :compute:i 23 1
   567 set :compute:x1 :compute:zx
   568 op mul *tmp103 :compute:zx :compute:zx
   569 op mul *tmp104 :compute:zy :compute:zy
 
   578 label *label260
   579 label *label261
   580 label *label262
-    * op add :compute:i :compute:i 1
+  581 op add :compute:i 24 1
   582 set :compute:x1 :compute:zx
   583 op mul *tmp103 :compute:zx :compute:zx
   584 op mul *tmp104 :compute:zy :compute:zy
 
   593 label *label263
   594 label *label264
   595 label *label265
-    * op add :compute:i :compute:i 1
+  596 op add :compute:i 25 1
   597 set :compute:x1 :compute:zx
   598 op mul *tmp103 :compute:zx :compute:zx
   599 op mul *tmp104 :compute:zy :compute:zy
 
   608 label *label266
   609 label *label267
   610 label *label268
-    * op add :compute:i :compute:i 1
+  611 op add :compute:i 26 1
   612 set :compute:x1 :compute:zx
   613 op mul *tmp103 :compute:zx :compute:zx
   614 op mul *tmp104 :compute:zy :compute:zy
 
   623 label *label269
   624 label *label270
   625 label *label271
-    * op add :compute:i :compute:i 1
+  626 op add :compute:i 27 1
   627 set :compute:x1 :compute:zx
   628 op mul *tmp103 :compute:zx :compute:zx
   629 op mul *tmp104 :compute:zy :compute:zy
 
   638 label *label272
   639 label *label273
   640 label *label274
-    * op add :compute:i :compute:i 1
+  641 op add :compute:i 28 1
   642 set :compute:x1 :compute:zx
   643 op mul *tmp103 :compute:zx :compute:zx
   644 op mul *tmp104 :compute:zy :compute:zy
 
   653 label *label275
   654 label *label276
   655 label *label277
-    * op add :compute:i :compute:i 1
+  656 op add :compute:i 29 1
   657 set :compute:x1 :compute:zx
   658 op mul *tmp103 :compute:zx :compute:zx
   659 op mul *tmp104 :compute:zy :compute:zy
 
   668 label *label278
   669 label *label279
   670 label *label280
-    * op add :compute:i :compute:i 1
+  671 op add :compute:i 30 1
   672 set :compute:x1 :compute:zx
   673 op mul *tmp103 :compute:zx :compute:zx
   674 op mul *tmp104 :compute:zy :compute:zy
 
   683 label *label281
   684 label *label282
   685 label *label283
-    * op add :compute:i :compute:i 1
+  686 op add :compute:i 31 1
   687 set :compute:x1 :compute:zx
   688 op mul *tmp103 :compute:zx :compute:zx
   689 op mul *tmp104 :compute:zy :compute:zy
 
   698 label *label284
   699 label *label285
   700 label *label286
-    * op add :compute:i :compute:i 1
+  701 op add :compute:i 32 1
   702 set :compute:x1 :compute:zx
   703 op mul *tmp103 :compute:zx :compute:zx
   704 op mul *tmp104 :compute:zy :compute:zy
 
   713 label *label287
   714 label *label288
   715 label *label289
-    * op add :compute:i :compute:i 1
+  716 op add :compute:i 33 1
   717 set :compute:x1 :compute:zx
   718 op mul *tmp103 :compute:zx :compute:zx
   719 op mul *tmp104 :compute:zy :compute:zy
 
   728 label *label290
   729 label *label291
   730 label *label292
-    * op add :compute:i :compute:i 1
+  731 op add :compute:i 34 1
   732 set :compute:x1 :compute:zx
   733 op mul *tmp103 :compute:zx :compute:zx
   734 op mul *tmp104 :compute:zy :compute:zy
 
   743 label *label293
   744 label *label294
   745 label *label295
-    * op add :compute:i :compute:i 1
+  746 op add :compute:i 35 1
   747 set :compute:x1 :compute:zx
   748 op mul *tmp103 :compute:zx :compute:zx
   749 op mul *tmp104 :compute:zy :compute:zy
 
   758 label *label296
   759 label *label297
   760 label *label298
-    * op add :compute:i :compute:i 1
+  761 op add :compute:i 36 1
   762 set :compute:x1 :compute:zx
   763 op mul *tmp103 :compute:zx :compute:zx
   764 op mul *tmp104 :compute:zy :compute:zy
 
   773 label *label299
   774 label *label300
   775 label *label301
-    * op add :compute:i :compute:i 1
+  776 op add :compute:i 37 1
   777 set :compute:x1 :compute:zx
   778 op mul *tmp103 :compute:zx :compute:zx
   779 op mul *tmp104 :compute:zy :compute:zy
 
   788 label *label302
   789 label *label303
   790 label *label304
-    * op add :compute:i :compute:i 1
+  791 op add :compute:i 38 1
   792 set :compute:x1 :compute:zx
   793 op mul *tmp103 :compute:zx :compute:zx
   794 op mul *tmp104 :compute:zy :compute:zy
 
   803 label *label305
   804 label *label306
   805 label *label307
-    * op add :compute:i :compute:i 1
+  806 op add :compute:i 39 1
   807 set :compute:x1 :compute:zx
   808 op mul *tmp103 :compute:zx :compute:zx
   809 op mul *tmp104 :compute:zy :compute:zy
 
   818 label *label308
   819 label *label309
   820 label *label310
-    * op add :compute:i :compute:i 1
+  821 op add :compute:i 40 1
   822 set :compute:x1 :compute:zx
   823 op mul *tmp103 :compute:zx :compute:zx
   824 op mul *tmp104 :compute:zy :compute:zy
 
   833 label *label311
   834 label *label312
   835 label *label313
-    * op add :compute:i :compute:i 1
+  836 op add :compute:i 41 1
   837 set :compute:x1 :compute:zx
   838 op mul *tmp103 :compute:zx :compute:zx
   839 op mul *tmp104 :compute:zy :compute:zy
 
   848 label *label314
   849 label *label315
   850 label *label316
-    * op add :compute:i :compute:i 1
+  851 op add :compute:i 42 1
   852 set :compute:x1 :compute:zx
   853 op mul *tmp103 :compute:zx :compute:zx
   854 op mul *tmp104 :compute:zy :compute:zy
 
   863 label *label317
   864 label *label318
   865 label *label319
-    * op add :compute:i :compute:i 1
+  866 op add :compute:i 43 1
   867 set :compute:x1 :compute:zx
   868 op mul *tmp103 :compute:zx :compute:zx
   869 op mul *tmp104 :compute:zy :compute:zy
 
   878 label *label320
   879 label *label321
   880 label *label322
-    * op add :compute:i :compute:i 1
+  881 op add :compute:i 44 1
   882 set :compute:x1 :compute:zx
   883 op mul *tmp103 :compute:zx :compute:zx
   884 op mul *tmp104 :compute:zy :compute:zy
 
   893 label *label323
   894 label *label324
   895 label *label325
-    * op add :compute:i :compute:i 1
+  896 op add :compute:i 45 1
   897 set :compute:x1 :compute:zx
   898 op mul *tmp103 :compute:zx :compute:zx
   899 op mul *tmp104 :compute:zy :compute:zy
 
   908 label *label326
   909 label *label327
   910 label *label328
-    * op add :compute:i :compute:i 1
+  911 op add :compute:i 46 1
   912 set :compute:x1 :compute:zx
   913 op mul *tmp103 :compute:zx :compute:zx
   914 op mul *tmp104 :compute:zy :compute:zy
 
   923 label *label329
   924 label *label330
   925 label *label331
-    * op add :compute:i :compute:i 1
+  926 op add :compute:i 47 1
   927 set :compute:x1 :compute:zx
   928 op mul *tmp103 :compute:zx :compute:zx
   929 op mul *tmp104 :compute:zy :compute:zy
 
   938 label *label332
   939 label *label333
   940 label *label334
-    * op add :compute:i :compute:i 1
+  941 op add :compute:i 48 1
   942 set :compute:x1 :compute:zx
   943 op mul *tmp103 :compute:zx :compute:zx
   944 op mul *tmp104 :compute:zy :compute:zy
 
   953 label *label335
   954 label *label336
   955 label *label337
-    * op add :compute:i :compute:i 1
+  956 op add :compute:i 49 1
   957 set :compute:x1 :compute:zx
   958 op mul *tmp103 :compute:zx :compute:zx
   959 op mul *tmp104 :compute:zy :compute:zy
 
   968 label *label338
   969 label *label339
   970 label *label340
-    * op add :compute:i :compute:i 1
+  971 op add :compute:i 50 1
   972 set :compute:x1 :compute:zx
   973 op mul *tmp103 :compute:zx :compute:zx
   974 op mul *tmp104 :compute:zy :compute:zy
 
   983 label *label341
   984 label *label342
   985 label *label343
-    * op add :compute:i :compute:i 1
+  986 op add :compute:i 51 1
   987 set :compute:x1 :compute:zx
   988 op mul *tmp103 :compute:zx :compute:zx
   989 op mul *tmp104 :compute:zy :compute:zy
 
   998 label *label344
   999 label *label345
  1000 label *label346
-    * op add :compute:i :compute:i 1
+ 1001 op add :compute:i 52 1
  1002 set :compute:x1 :compute:zx
  1003 op mul *tmp103 :compute:zx :compute:zx
  1004 op mul *tmp104 :compute:zy :compute:zy
 
  1013 label *label347
  1014 label *label348
  1015 label *label349
-    * op add :compute:i :compute:i 1
+ 1016 op add :compute:i 53 1
  1017 set :compute:x1 :compute:zx
  1018 op mul *tmp103 :compute:zx :compute:zx
  1019 op mul *tmp104 :compute:zy :compute:zy
 
  1028 label *label350
  1029 label *label351
  1030 label *label352
-    * op add :compute:i :compute:i 1
+ 1031 op add :compute:i 54 1
  1032 set :compute:x1 :compute:zx
  1033 op mul *tmp103 :compute:zx :compute:zx
  1034 op mul *tmp104 :compute:zy :compute:zy
 
  1043 label *label353
  1044 label *label354
  1045 label *label355
-    * op add :compute:i :compute:i 1
+ 1046 op add :compute:i 55 1
  1047 set :compute:x1 :compute:zx
  1048 op mul *tmp103 :compute:zx :compute:zx
  1049 op mul *tmp104 :compute:zy :compute:zy
 
  1058 label *label356
  1059 label *label357
  1060 label *label358
-    * op add :compute:i :compute:i 1
+ 1061 op add :compute:i 56 1
  1062 set :compute:x1 :compute:zx
  1063 op mul *tmp103 :compute:zx :compute:zx
  1064 op mul *tmp104 :compute:zy :compute:zy
 
  1073 label *label359
  1074 label *label360
  1075 label *label361
-    * op add :compute:i :compute:i 1
+ 1076 op add :compute:i 57 1
  1077 set :compute:x1 :compute:zx
  1078 op mul *tmp103 :compute:zx :compute:zx
  1079 op mul *tmp104 :compute:zy :compute:zy
 
  1088 label *label362
  1089 label *label363
  1090 label *label364
-    * op add :compute:i :compute:i 1
+ 1091 op add :compute:i 58 1
  1092 set :compute:x1 :compute:zx
  1093 op mul *tmp103 :compute:zx :compute:zx
  1094 op mul *tmp104 :compute:zy :compute:zy
 
  1103 label *label365
  1104 label *label366
  1105 label *label367
-    * op add :compute:i :compute:i 1
+ 1106 op add :compute:i 59 1
  1107 set :compute:x1 :compute:zx
  1108 op mul *tmp103 :compute:zx :compute:zx
  1109 op mul *tmp104 :compute:zy :compute:zy
 
  1118 label *label368
  1119 label *label369
  1120 label *label370
-    * op add :compute:i :compute:i 1
+ 1121 op add :compute:i 60 1
  1122 set :compute:x1 :compute:zx
  1123 op mul *tmp103 :compute:zx :compute:zx
  1124 op mul *tmp104 :compute:zy :compute:zy
 
  1133 label *label371
  1134 label *label372
  1135 label *label373
-    * op add :compute:i :compute:i 1
+ 1136 op add :compute:i 61 1
  1137 set :compute:x1 :compute:zx
  1138 op mul *tmp103 :compute:zx :compute:zx
  1139 op mul *tmp104 :compute:zy :compute:zy
 
  1148 label *label374
  1149 label *label375
  1150 label *label376
-    * op add :compute:i :compute:i 1
+ 1151 op add :compute:i 62 1
  1152 label *label77
  1153 jump *label80 lessThanEq .PALETTE 1
  1154 jump *label80 greaterThanEq :compute:i 63

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1 (-2 instructions):
 
    21 label *label138
    22 jump *label139 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    24 label *label139
    25 label *label140
    26 label *label141
 
    29 label *label144
    30 jump *label145 notEqual @memory-bank :findLinkedBlocks:type
    31 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    32 label *label145
    33 label *label146
    34 label *label147
 
   216 label *label188
   217 label *label189
   218 label *label190
-    * op add :compute:i 0 1
+  219 set :compute:i 1
   220 set :compute:x1 :compute:zx
   221 op mul *tmp103 :compute:zx :compute:zx
   222 op mul *tmp104 :compute:zy :compute:zy

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1:
 
    58 label *label168
    59 label *label169
    60 label *label23
-    * printflush :findLinkedBlocks:message
+   61 printflush null
    62 label *label2
    63 jump *label1 equal :findLinkedBlocks:foundAll false
    64 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 2 (-1 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:message null
     1 label *label1
     2 label *label151
     3 label *label152

Modifications by Iterated phase, Boolean Optimization, pass 3, iteration 1 (-2 instructions):
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label138
-    * jump *label139 notEqual @large-logic-display :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label139
-    * label *label140
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    22 label *label141
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label144
-    * jump *label145 notEqual @memory-bank :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label145
-    * label *label146
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    27 label *label147
    28 set .memory :findLinkedBlocks:variable
    29 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 1:
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label138
-    * select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    22 label *label141
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label144
-    * select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    27 label *label147
    28 set .memory :findLinkedBlocks:variable
    29 label *label14

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 2 (-2 instructions):
 
    16 print "\nFound: "
    17 print :findLinkedBlocks:block
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:variable .display
    19 label *label138
    20 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    21 label *label141
    22 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:variable .memory
    23 label *label144
    24 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    25 label *label147

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-1 instructions):
     0 set .start 0
     1 label *label1
-    * label *label151
-    * label *label152
     2 set .display null
-    * label *label155
-    * label *label156
     3 set .memory null
-    * label *label6
     4 print "Mandelbrot Generator"
     5 set :findLinkedBlocks:n @links
-    * label *label9
     6 jump *label11 lessThanEq :findLinkedBlocks:n 0
     7 label *label133
     8 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
 
    10 print "\nFound: "
    11 print :findLinkedBlocks:block
    12 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * label *label138
    13 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
-    * label *label141
    14 set .display :findLinkedBlocks:variable
-    * label *label144
    15 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
-    * label *label147
    16 set .memory :findLinkedBlocks:variable
-    * label *label14
-    * label *label10
    17 jump *label133 greaterThan :findLinkedBlocks:n 0
    18 label *label11
-    * label *label160
    19 print "\n"
    20 print "Display"
    21 print ":"
    22 print " "
    23 print .display
    24 op and :findLinkedBlocks:foundAll 1 .display
-    * label *label161
-    * label *label162
-    * label *label163
-    * label *label166
    25 print "\n"
    26 print "Memory"
    27 print ":"
    28 print " "
    29 print .memory
    30 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
-    * label *label167
-    * label *label168
-    * label *label169
-    * label *label23
    31 printflush null
-    * label *label2
    32 jump *label1 equal :findLinkedBlocks:foundAll false
-    * label *label3
-    * label *label0
    33 label *label28
    34 label *label31
    35 wait 0
-    * label *label32
    36 read *tmp26 .memory 67
    37 jump *label31 equal .start *tmp26
-    * label *label33
    38 read .start .memory 67
    39 read .stop .memory 68
    40 set .lastColor -1
 
    59 jump *label37 equal .stop *tmp43
    60 jump *label29 always
    61 label *label37
-    * label *label38
    62 read :batch .memory 64
    63 read *tmp46 .memory 64
    64 op add *tmp47 *tmp46 :multiple
 
    66 jump *label39 lessThan :batch 2816
    67 jump *label36 always
    68 label *label39
-    * label *label40
    69 op mul *tmp51 11 :multiple
    70 set :i 0
    71 op mul *tmp52 :batch 11
-    * label *label41
    72 jump *label43 lessThanEq :multiple 0
    73 label *label134
    74 op add :adam5:index *tmp52 :i
    75 op idiv *tmp55 :adam5:index 16
    76 multijump *tmp55 0 0 (m:*label174)
    77 multilabel *label179 (m:*label174)
-    * label *label173
    78 op sub :adam5:index :adam5:index 15488
    79 op mod :adam5:x :adam5:index 176
    80 op idiv *tmp82 :adam5:index 176
 
    84 set :adam5:dx 1
    85 jump *label45 always
    86 multilabel *label175 (m:*label174)
-    * label *label47
    87 op mod *tmp57 :adam5:index 44
    88 op mul :adam5:x 4 *tmp57
    89 op idiv *tmp59 :adam5:index 44
 
    92 set :adam5:dy *tmp61
    93 set :adam5:dx *tmp61
    94 jump *label45 always
-    * label *label46
    95 multilabel *label176 (m:*label174)
-    * label *label52
    96 op sub :adam5:index :adam5:index 1936
    97 op mod *tmp62 :adam5:index 44
    98 op mul *tmp63 4 *tmp62
 
   102 select :adam5:dx notEqual .FILL_PASS false 2 1
   103 select :adam5:dy notEqual .FILL_PASS false 4 1
   104 jump *label45 always
-    * label *label51
   105 multilabel *label177 (m:*label174)
-    * label *label59
   106 op sub :adam5:index :adam5:index 3872
   107 op mod *tmp69 :adam5:index 88
   108 op mul :adam5:x 2 *tmp69
 
   112 select *tmp74 notEqual .FILL_PASS false 2 1
   113 set :adam5:dy *tmp74
   114 set :adam5:dx *tmp74
-    * label *label58
   115 jump *label45 always
   116 multilabel *label178 (m:*label174)
-    * label *label64
   117 op sub :adam5:index :adam5:index 7744
   118 op mod *tmp75 :adam5:index 88
   119 op mul *tmp76 2 *tmp75
 
   123 set :adam5:dx 1
   124 select :adam5:dy notEqual .FILL_PASS false 2 1
   125 label *label45
-    * label *label44
   126 op div *tmp86 :adam5:x .ZOOM
   127 op add :compute:zx *tmp86 .OFFSET_X
   128 op div *tmp88 :adam5:y .ZOOM
 
   144 set *tmp85 63
   145 jump *label68 always
   146 label *label71
-    * label *label72
   147 op add *tmp99 :compute:zx 1
   148 op len *tmp100 *tmp99 :compute:zy
   149 jump *label73 greaterThan *tmp100 0.25
   150 set *tmp85 63
   151 jump *label68 always
   152 label *label73
-    * label *label74
   153 label *label70
   154 set :compute:i 0
-    * label *label187
   155 set :compute:x1 :compute:zx
   156 op mul *tmp103 :compute:zx :compute:zx
   157 op mul *tmp104 :compute:zy :compute:zy
 
   164 jump *label188 lessThan :compute:dist 64
   165 jump *label77 always
   166 label *label188
-    * label *label189
-    * label *label190
   167 set :compute:i 1
   168 set :compute:x1 :compute:zx
   169 op mul *tmp103 :compute:zx :compute:zx
 
   177 jump *label191 lessThan :compute:dist 64
   178 jump *label77 always
   179 label *label191
-    * label *label192
-    * label *label193
   180 op add :compute:i 1 1
   181 set :compute:x1 :compute:zx
   182 op mul *tmp103 :compute:zx :compute:zx
 
   190 jump *label194 lessThan :compute:dist 64
   191 jump *label77 always
   192 label *label194
-    * label *label195
-    * label *label196
   193 op add :compute:i 2 1
   194 set :compute:x1 :compute:zx
   195 op mul *tmp103 :compute:zx :compute:zx
 
   203 jump *label197 lessThan :compute:dist 64
   204 jump *label77 always
   205 label *label197
-    * label *label198
-    * label *label199
   206 op add :compute:i 3 1
   207 set :compute:x1 :compute:zx
   208 op mul *tmp103 :compute:zx :compute:zx
 
   216 jump *label200 lessThan :compute:dist 64
   217 jump *label77 always
   218 label *label200
-    * label *label201
-    * label *label202
   219 op add :compute:i 4 1
   220 set :compute:x1 :compute:zx
   221 op mul *tmp103 :compute:zx :compute:zx
 
   229 jump *label203 lessThan :compute:dist 64
   230 jump *label77 always
   231 label *label203
-    * label *label204
-    * label *label205
   232 op add :compute:i 5 1
   233 set :compute:x1 :compute:zx
   234 op mul *tmp103 :compute:zx :compute:zx
 
   242 jump *label206 lessThan :compute:dist 64
   243 jump *label77 always
   244 label *label206
-    * label *label207
-    * label *label208
   245 op add :compute:i 6 1
   246 set :compute:x1 :compute:zx
   247 op mul *tmp103 :compute:zx :compute:zx
 
   255 jump *label209 lessThan :compute:dist 64
   256 jump *label77 always
   257 label *label209
-    * label *label210
-    * label *label211
   258 op add :compute:i 7 1
   259 set :compute:x1 :compute:zx
   260 op mul *tmp103 :compute:zx :compute:zx
 
   268 jump *label212 lessThan :compute:dist 64
   269 jump *label77 always
   270 label *label212
-    * label *label213
-    * label *label214
   271 op add :compute:i 8 1
   272 set :compute:x1 :compute:zx
   273 op mul *tmp103 :compute:zx :compute:zx
 
   281 jump *label215 lessThan :compute:dist 64
   282 jump *label77 always
   283 label *label215
-    * label *label216
-    * label *label217
   284 op add :compute:i 9 1
   285 set :compute:x1 :compute:zx
   286 op mul *tmp103 :compute:zx :compute:zx
 
   294 jump *label218 lessThan :compute:dist 64
   295 jump *label77 always
   296 label *label218
-    * label *label219
-    * label *label220
   297 op add :compute:i 10 1
   298 set :compute:x1 :compute:zx
   299 op mul *tmp103 :compute:zx :compute:zx
 
   307 jump *label221 lessThan :compute:dist 64
   308 jump *label77 always
   309 label *label221
-    * label *label222
-    * label *label223
   310 op add :compute:i 11 1
   311 set :compute:x1 :compute:zx
   312 op mul *tmp103 :compute:zx :compute:zx
 
   320 jump *label224 lessThan :compute:dist 64
   321 jump *label77 always
   322 label *label224
-    * label *label225
-    * label *label226
   323 op add :compute:i 12 1
   324 set :compute:x1 :compute:zx
   325 op mul *tmp103 :compute:zx :compute:zx
 
   333 jump *label227 lessThan :compute:dist 64
   334 jump *label77 always
   335 label *label227
-    * label *label228
-    * label *label229
   336 op add :compute:i 13 1
   337 set :compute:x1 :compute:zx
   338 op mul *tmp103 :compute:zx :compute:zx
 
   346 jump *label230 lessThan :compute:dist 64
   347 jump *label77 always
   348 label *label230
-    * label *label231
-    * label *label232
   349 op add :compute:i 14 1
   350 set :compute:x1 :compute:zx
   351 op mul *tmp103 :compute:zx :compute:zx
 
   359 jump *label233 lessThan :compute:dist 64
   360 jump *label77 always
   361 label *label233
-    * label *label234
-    * label *label235
   362 op add :compute:i 15 1
   363 set :compute:x1 :compute:zx
   364 op mul *tmp103 :compute:zx :compute:zx
 
   372 jump *label236 lessThan :compute:dist 64
   373 jump *label77 always
   374 label *label236
-    * label *label237
-    * label *label238
   375 op add :compute:i 16 1
   376 set :compute:x1 :compute:zx
   377 op mul *tmp103 :compute:zx :compute:zx
 
   385 jump *label239 lessThan :compute:dist 64
   386 jump *label77 always
   387 label *label239
-    * label *label240
-    * label *label241
   388 op add :compute:i 17 1
   389 set :compute:x1 :compute:zx
   390 op mul *tmp103 :compute:zx :compute:zx
 
   398 jump *label242 lessThan :compute:dist 64
   399 jump *label77 always
   400 label *label242
-    * label *label243
-    * label *label244
   401 op add :compute:i 18 1
   402 set :compute:x1 :compute:zx
   403 op mul *tmp103 :compute:zx :compute:zx
 
   411 jump *label245 lessThan :compute:dist 64
   412 jump *label77 always
   413 label *label245
-    * label *label246
-    * label *label247
   414 op add :compute:i 19 1
   415 set :compute:x1 :compute:zx
   416 op mul *tmp103 :compute:zx :compute:zx
 
   424 jump *label248 lessThan :compute:dist 64
   425 jump *label77 always
   426 label *label248
-    * label *label249
-    * label *label250
   427 op add :compute:i 20 1
   428 set :compute:x1 :compute:zx
   429 op mul *tmp103 :compute:zx :compute:zx
 
   437 jump *label251 lessThan :compute:dist 64
   438 jump *label77 always
   439 label *label251
-    * label *label252
-    * label *label253
   440 op add :compute:i 21 1
   441 set :compute:x1 :compute:zx
   442 op mul *tmp103 :compute:zx :compute:zx
 
   450 jump *label254 lessThan :compute:dist 64
   451 jump *label77 always
   452 label *label254
-    * label *label255
-    * label *label256
   453 op add :compute:i 22 1
   454 set :compute:x1 :compute:zx
   455 op mul *tmp103 :compute:zx :compute:zx
 
   463 jump *label257 lessThan :compute:dist 64
   464 jump *label77 always
   465 label *label257
-    * label *label258
-    * label *label259
   466 op add :compute:i 23 1
   467 set :compute:x1 :compute:zx
   468 op mul *tmp103 :compute:zx :compute:zx
 
   476 jump *label260 lessThan :compute:dist 64
   477 jump *label77 always
   478 label *label260
-    * label *label261
-    * label *label262
   479 op add :compute:i 24 1
   480 set :compute:x1 :compute:zx
   481 op mul *tmp103 :compute:zx :compute:zx
 
   489 jump *label263 lessThan :compute:dist 64
   490 jump *label77 always
   491 label *label263
-    * label *label264
-    * label *label265
   492 op add :compute:i 25 1
   493 set :compute:x1 :compute:zx
   494 op mul *tmp103 :compute:zx :compute:zx
 
   502 jump *label266 lessThan :compute:dist 64
   503 jump *label77 always
   504 label *label266
-    * label *label267
-    * label *label268
   505 op add :compute:i 26 1
   506 set :compute:x1 :compute:zx
   507 op mul *tmp103 :compute:zx :compute:zx
 
   515 jump *label269 lessThan :compute:dist 64
   516 jump *label77 always
   517 label *label269
-    * label *label270
-    * label *label271
   518 op add :compute:i 27 1
   519 set :compute:x1 :compute:zx
   520 op mul *tmp103 :compute:zx :compute:zx
 
   528 jump *label272 lessThan :compute:dist 64
   529 jump *label77 always
   530 label *label272
-    * label *label273
-    * label *label274
   531 op add :compute:i 28 1
   532 set :compute:x1 :compute:zx
   533 op mul *tmp103 :compute:zx :compute:zx
 
   541 jump *label275 lessThan :compute:dist 64
   542 jump *label77 always
   543 label *label275
-    * label *label276
-    * label *label277
   544 op add :compute:i 29 1
   545 set :compute:x1 :compute:zx
   546 op mul *tmp103 :compute:zx :compute:zx
 
   554 jump *label278 lessThan :compute:dist 64
   555 jump *label77 always
   556 label *label278
-    * label *label279
-    * label *label280
   557 op add :compute:i 30 1
   558 set :compute:x1 :compute:zx
   559 op mul *tmp103 :compute:zx :compute:zx
 
   567 jump *label281 lessThan :compute:dist 64
   568 jump *label77 always
   569 label *label281
-    * label *label282
-    * label *label283
   570 op add :compute:i 31 1
   571 set :compute:x1 :compute:zx
   572 op mul *tmp103 :compute:zx :compute:zx
 
   580 jump *label284 lessThan :compute:dist 64
   581 jump *label77 always
   582 label *label284
-    * label *label285
-    * label *label286
   583 op add :compute:i 32 1
   584 set :compute:x1 :compute:zx
   585 op mul *tmp103 :compute:zx :compute:zx
 
   593 jump *label287 lessThan :compute:dist 64
   594 jump *label77 always
   595 label *label287
-    * label *label288
-    * label *label289
   596 op add :compute:i 33 1
   597 set :compute:x1 :compute:zx
   598 op mul *tmp103 :compute:zx :compute:zx
 
   606 jump *label290 lessThan :compute:dist 64
   607 jump *label77 always
   608 label *label290
-    * label *label291
-    * label *label292
   609 op add :compute:i 34 1
   610 set :compute:x1 :compute:zx
   611 op mul *tmp103 :compute:zx :compute:zx
 
   619 jump *label293 lessThan :compute:dist 64
   620 jump *label77 always
   621 label *label293
-    * label *label294
-    * label *label295
   622 op add :compute:i 35 1
   623 set :compute:x1 :compute:zx
   624 op mul *tmp103 :compute:zx :compute:zx
 
   632 jump *label296 lessThan :compute:dist 64
   633 jump *label77 always
   634 label *label296
-    * label *label297
-    * label *label298
   635 op add :compute:i 36 1
   636 set :compute:x1 :compute:zx
   637 op mul *tmp103 :compute:zx :compute:zx
 
   645 jump *label299 lessThan :compute:dist 64
   646 jump *label77 always
   647 label *label299
-    * label *label300
-    * label *label301
   648 op add :compute:i 37 1
   649 set :compute:x1 :compute:zx
   650 op mul *tmp103 :compute:zx :compute:zx
 
   658 jump *label302 lessThan :compute:dist 64
   659 jump *label77 always
   660 label *label302
-    * label *label303
-    * label *label304
   661 op add :compute:i 38 1
   662 set :compute:x1 :compute:zx
   663 op mul *tmp103 :compute:zx :compute:zx
 
   671 jump *label305 lessThan :compute:dist 64
   672 jump *label77 always
   673 label *label305
-    * label *label306
-    * label *label307
   674 op add :compute:i 39 1
   675 set :compute:x1 :compute:zx
   676 op mul *tmp103 :compute:zx :compute:zx
 
   684 jump *label308 lessThan :compute:dist 64
   685 jump *label77 always
   686 label *label308
-    * label *label309
-    * label *label310
   687 op add :compute:i 40 1
   688 set :compute:x1 :compute:zx
   689 op mul *tmp103 :compute:zx :compute:zx
 
   697 jump *label311 lessThan :compute:dist 64
   698 jump *label77 always
   699 label *label311
-    * label *label312
-    * label *label313
   700 op add :compute:i 41 1
   701 set :compute:x1 :compute:zx
   702 op mul *tmp103 :compute:zx :compute:zx
 
   710 jump *label314 lessThan :compute:dist 64
   711 jump *label77 always
   712 label *label314
-    * label *label315
-    * label *label316
   713 op add :compute:i 42 1
   714 set :compute:x1 :compute:zx
   715 op mul *tmp103 :compute:zx :compute:zx
 
   723 jump *label317 lessThan :compute:dist 64
   724 jump *label77 always
   725 label *label317
-    * label *label318
-    * label *label319
   726 op add :compute:i 43 1
   727 set :compute:x1 :compute:zx
   728 op mul *tmp103 :compute:zx :compute:zx
 
   736 jump *label320 lessThan :compute:dist 64
   737 jump *label77 always
   738 label *label320
-    * label *label321
-    * label *label322
   739 op add :compute:i 44 1
   740 set :compute:x1 :compute:zx
   741 op mul *tmp103 :compute:zx :compute:zx
 
   749 jump *label323 lessThan :compute:dist 64
   750 jump *label77 always
   751 label *label323
-    * label *label324
-    * label *label325
   752 op add :compute:i 45 1
   753 set :compute:x1 :compute:zx
   754 op mul *tmp103 :compute:zx :compute:zx
 
   762 jump *label326 lessThan :compute:dist 64
   763 jump *label77 always
   764 label *label326
-    * label *label327
-    * label *label328
   765 op add :compute:i 46 1
   766 set :compute:x1 :compute:zx
   767 op mul *tmp103 :compute:zx :compute:zx
 
   775 jump *label329 lessThan :compute:dist 64
   776 jump *label77 always
   777 label *label329
-    * label *label330
-    * label *label331
   778 op add :compute:i 47 1
   779 set :compute:x1 :compute:zx
   780 op mul *tmp103 :compute:zx :compute:zx
 
   788 jump *label332 lessThan :compute:dist 64
   789 jump *label77 always
   790 label *label332
-    * label *label333
-    * label *label334
   791 op add :compute:i 48 1
   792 set :compute:x1 :compute:zx
   793 op mul *tmp103 :compute:zx :compute:zx
 
   801 jump *label335 lessThan :compute:dist 64
   802 jump *label77 always
   803 label *label335
-    * label *label336
-    * label *label337
   804 op add :compute:i 49 1
   805 set :compute:x1 :compute:zx
   806 op mul *tmp103 :compute:zx :compute:zx
 
   814 jump *label338 lessThan :compute:dist 64
   815 jump *label77 always
   816 label *label338
-    * label *label339
-    * label *label340
   817 op add :compute:i 50 1
   818 set :compute:x1 :compute:zx
   819 op mul *tmp103 :compute:zx :compute:zx
 
   827 jump *label341 lessThan :compute:dist 64
   828 jump *label77 always
   829 label *label341
-    * label *label342
-    * label *label343
   830 op add :compute:i 51 1
   831 set :compute:x1 :compute:zx
   832 op mul *tmp103 :compute:zx :compute:zx
 
   840 jump *label344 lessThan :compute:dist 64
   841 jump *label77 always
   842 label *label344
-    * label *label345
-    * label *label346
   843 op add :compute:i 52 1
   844 set :compute:x1 :compute:zx
   845 op mul *tmp103 :compute:zx :compute:zx
 
   853 jump *label347 lessThan :compute:dist 64
   854 jump *label77 always
   855 label *label347
-    * label *label348
-    * label *label349
   856 op add :compute:i 53 1
   857 set :compute:x1 :compute:zx
   858 op mul *tmp103 :compute:zx :compute:zx
 
   866 jump *label350 lessThan :compute:dist 64
   867 jump *label77 always
   868 label *label350
-    * label *label351
-    * label *label352
   869 op add :compute:i 54 1
   870 set :compute:x1 :compute:zx
   871 op mul *tmp103 :compute:zx :compute:zx
 
   879 jump *label353 lessThan :compute:dist 64
   880 jump *label77 always
   881 label *label353
-    * label *label354
-    * label *label355
   882 op add :compute:i 55 1
   883 set :compute:x1 :compute:zx
   884 op mul *tmp103 :compute:zx :compute:zx
 
   892 jump *label356 lessThan :compute:dist 64
   893 jump *label77 always
   894 label *label356
-    * label *label357
-    * label *label358
   895 op add :compute:i 56 1
   896 set :compute:x1 :compute:zx
   897 op mul *tmp103 :compute:zx :compute:zx
 
   905 jump *label359 lessThan :compute:dist 64
   906 jump *label77 always
   907 label *label359
-    * label *label360
-    * label *label361
   908 op add :compute:i 57 1
   909 set :compute:x1 :compute:zx
   910 op mul *tmp103 :compute:zx :compute:zx
 
   918 jump *label362 lessThan :compute:dist 64
   919 jump *label77 always
   920 label *label362
-    * label *label363
-    * label *label364
   921 op add :compute:i 58 1
   922 set :compute:x1 :compute:zx
   923 op mul *tmp103 :compute:zx :compute:zx
 
   931 jump *label365 lessThan :compute:dist 64
   932 jump *label77 always
   933 label *label365
-    * label *label366
-    * label *label367
   934 op add :compute:i 59 1
   935 set :compute:x1 :compute:zx
   936 op mul *tmp103 :compute:zx :compute:zx
 
   944 jump *label368 lessThan :compute:dist 64
   945 jump *label77 always
   946 label *label368
-    * label *label369
-    * label *label370
   947 op add :compute:i 60 1
   948 set :compute:x1 :compute:zx
   949 op mul *tmp103 :compute:zx :compute:zx
 
   957 jump *label371 lessThan :compute:dist 64
   958 jump *label77 always
   959 label *label371
-    * label *label372
-    * label *label373
   960 op add :compute:i 61 1
   961 set :compute:x1 :compute:zx
   962 op mul *tmp103 :compute:zx :compute:zx
 
   970 jump *label374 lessThan :compute:dist 64
   971 jump *label77 always
   972 label *label374
-    * label *label375
-    * label *label376
   973 op add :compute:i 62 1
   974 label *label77
   975 jump *label80 lessThanEq .PALETTE 1
 
   981 op sub :compute:correction 4 *tmp118
   982 op add :compute:i :compute:i :compute:correction
   983 label *label80
-    * label *label81
   984 set *tmp85 :compute:i
   985 label *label68
   986 jump *label85 lessThanEq .PALETTE 1
   987 set :drawPixel:color %[black]
   988 jump *label88 equal *tmp85 63
-    * label *label87
   989 multijump .PALETTE 0 0 (m:*label181)
   990 multilabel *label186 (m:*label181)
   991 multilabel *label182 (m:*label181)
-    * label *label180
   992 op div *tmp159 *tmp85 63.75
   993 op sub :drawPixel:r 1 *tmp159
   994 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   995 jump *label89 always
   996 multilabel *label183 (m:*label181)
-    * label *label91
   997 op sub *tmp125 32 *tmp85
   998 op abs *tmp126 *tmp125
   999 op div *tmp128 *tmp126 36.42857142857143
 
  1006 op add :drawPixel:b 0.47058823529411764 *tmp138
  1007 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1008 jump *label89 always
-    * label *label90
  1009 multilabel *label184 (m:*label181)
-    * label *label93
  1010 op div *tmp142 *tmp85 0.175
  1011 op sin :drawPixel:r *tmp142
  1012 op cos :drawPixel:g *tmp142
 
  1016 op add :drawPixel:b 0.39215686274509803 *tmp150
  1017 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1018 jump *label89 always
-    * label *label92
  1019 multilabel *label185 (m:*label181)
-    * label *label95
  1020 op div :drawPixel:r *tmp85 63.75
  1021 op div :drawPixel:g *tmp85 170
  1022 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
 
  1027 read :drawPixel:color .memory *tmp85
  1028 label *label86
  1029 jump *label96 lessThan .localBuffer 254
-    * label *label99
  1030 jump *label101 lessThanEq .localBuffer 0
  1031 label *label136
  1032 read *tmp169 .memory 68
 
  1040 drawflush .display
  1041 set .localBuffer 0
  1042 label *label105
-    * label *label106
-    * label *label104
-    * label *label100
  1043 jump *label136 greaterThan .localBuffer 0
  1044 label *label101
-    * label *label98
  1045 label *label96
-    * label *label97
  1046 jump *label109 lessThanEq .localBuffer 0
  1047 jump *label109 strictNotEqual :drawPixel:color .lastColor
  1048 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
 
  1063 drawflush .display
  1064 set .localBuffer 0
  1065 label *label114
-    * label *label115
-    * label *label113
-    * label *label84
  1066 wait 0
  1067 read *tmp185 .memory 68
  1068 jump *label118 equal .stop *tmp185
  1069 jump *label29 always
  1070 label *label118
-    * label *label119
  1071 read *tmp187 .memory 66
  1072 op add *tmp2 *tmp187 1
  1073 write *tmp2 .memory 66
  1074 read *tmp189 .memory 65
  1075 op add *tmp190 *tmp189 *tmp85
  1076 write *tmp190 .memory 65
-    * label *label42
  1077 op add :i :i 1
  1078 jump *label134 lessThan :i *tmp51
  1079 label *label43
  1080 select :multiple greaterThanEq :batch 1337.6 1 :multiple
-    * label *label35
  1081 jump *label34 always
  1082 label *label36
-    * label *label123
  1083 jump *label125 lessThanEq .localBuffer 0
  1084 label *label137
  1085 read *tmp195 .memory 68
 
  1093 drawflush .display
  1094 set .localBuffer 0
  1095 label *label129
-    * label *label130
-    * label *label128
-    * label *label124
  1096 jump *label137 greaterThan .localBuffer 0
  1097 label *label125
-    * label *label122
  1098 label *label29
  1099 jump *label28 always
-    * label *label30
-    * end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-66 instructions):
 
    56 label *label34
    57 wait 0
    58 read *tmp43 .memory 68
-    * jump *label37 equal .stop *tmp43
-    * jump *label29 always
+   59 jump *label29 notEqual .stop *tmp43
    60 label *label37
    61 read :batch .memory 64
    62 read *tmp46 .memory 64
    63 op add *tmp47 *tmp46 :multiple
    64 write *tmp47 .memory 64
-    * jump *label39 lessThan :batch 2816
-    * jump *label36 always
+   65 jump *label36 greaterThanEq :batch 2816
    66 label *label39
    67 op mul *tmp51 11 :multiple
    68 set :i 0
 
   159 op mul *tmp108 *tmp107 :compute:zy
   160 op add :compute:zy *tmp108 :compute:cy
   161 op len :compute:dist :compute:zx :compute:zy
-    * jump *label188 lessThan :compute:dist 64
-    * jump *label77 always
+  162 jump *label77 greaterThanEq :compute:dist 64
   163 label *label188
   164 set :compute:i 1
   165 set :compute:x1 :compute:zx
 
   171 op mul *tmp108 *tmp107 :compute:zy
   172 op add :compute:zy *tmp108 :compute:cy
   173 op len :compute:dist :compute:zx :compute:zy
-    * jump *label191 lessThan :compute:dist 64
-    * jump *label77 always
+  174 jump *label77 greaterThanEq :compute:dist 64
   175 label *label191
   176 op add :compute:i 1 1
   177 set :compute:x1 :compute:zx
 
   183 op mul *tmp108 *tmp107 :compute:zy
   184 op add :compute:zy *tmp108 :compute:cy
   185 op len :compute:dist :compute:zx :compute:zy
-    * jump *label194 lessThan :compute:dist 64
-    * jump *label77 always
+  186 jump *label77 greaterThanEq :compute:dist 64
   187 label *label194
   188 op add :compute:i 2 1
   189 set :compute:x1 :compute:zx
 
   195 op mul *tmp108 *tmp107 :compute:zy
   196 op add :compute:zy *tmp108 :compute:cy
   197 op len :compute:dist :compute:zx :compute:zy
-    * jump *label197 lessThan :compute:dist 64
-    * jump *label77 always
+  198 jump *label77 greaterThanEq :compute:dist 64
   199 label *label197
   200 op add :compute:i 3 1
   201 set :compute:x1 :compute:zx
 
   207 op mul *tmp108 *tmp107 :compute:zy
   208 op add :compute:zy *tmp108 :compute:cy
   209 op len :compute:dist :compute:zx :compute:zy
-    * jump *label200 lessThan :compute:dist 64
-    * jump *label77 always
+  210 jump *label77 greaterThanEq :compute:dist 64
   211 label *label200
   212 op add :compute:i 4 1
   213 set :compute:x1 :compute:zx
 
   219 op mul *tmp108 *tmp107 :compute:zy
   220 op add :compute:zy *tmp108 :compute:cy
   221 op len :compute:dist :compute:zx :compute:zy
-    * jump *label203 lessThan :compute:dist 64
-    * jump *label77 always
+  222 jump *label77 greaterThanEq :compute:dist 64
   223 label *label203
   224 op add :compute:i 5 1
   225 set :compute:x1 :compute:zx
 
   231 op mul *tmp108 *tmp107 :compute:zy
   232 op add :compute:zy *tmp108 :compute:cy
   233 op len :compute:dist :compute:zx :compute:zy
-    * jump *label206 lessThan :compute:dist 64
-    * jump *label77 always
+  234 jump *label77 greaterThanEq :compute:dist 64
   235 label *label206
   236 op add :compute:i 6 1
   237 set :compute:x1 :compute:zx
 
   243 op mul *tmp108 *tmp107 :compute:zy
   244 op add :compute:zy *tmp108 :compute:cy
   245 op len :compute:dist :compute:zx :compute:zy
-    * jump *label209 lessThan :compute:dist 64
-    * jump *label77 always
+  246 jump *label77 greaterThanEq :compute:dist 64
   247 label *label209
   248 op add :compute:i 7 1
   249 set :compute:x1 :compute:zx
 
   255 op mul *tmp108 *tmp107 :compute:zy
   256 op add :compute:zy *tmp108 :compute:cy
   257 op len :compute:dist :compute:zx :compute:zy
-    * jump *label212 lessThan :compute:dist 64
-    * jump *label77 always
+  258 jump *label77 greaterThanEq :compute:dist 64
   259 label *label212
   260 op add :compute:i 8 1
   261 set :compute:x1 :compute:zx
 
   267 op mul *tmp108 *tmp107 :compute:zy
   268 op add :compute:zy *tmp108 :compute:cy
   269 op len :compute:dist :compute:zx :compute:zy
-    * jump *label215 lessThan :compute:dist 64
-    * jump *label77 always
+  270 jump *label77 greaterThanEq :compute:dist 64
   271 label *label215
   272 op add :compute:i 9 1
   273 set :compute:x1 :compute:zx
 
   279 op mul *tmp108 *tmp107 :compute:zy
   280 op add :compute:zy *tmp108 :compute:cy
   281 op len :compute:dist :compute:zx :compute:zy
-    * jump *label218 lessThan :compute:dist 64
-    * jump *label77 always
+  282 jump *label77 greaterThanEq :compute:dist 64
   283 label *label218
   284 op add :compute:i 10 1
   285 set :compute:x1 :compute:zx
 
   291 op mul *tmp108 *tmp107 :compute:zy
   292 op add :compute:zy *tmp108 :compute:cy
   293 op len :compute:dist :compute:zx :compute:zy
-    * jump *label221 lessThan :compute:dist 64
-    * jump *label77 always
+  294 jump *label77 greaterThanEq :compute:dist 64
   295 label *label221
   296 op add :compute:i 11 1
   297 set :compute:x1 :compute:zx
 
   303 op mul *tmp108 *tmp107 :compute:zy
   304 op add :compute:zy *tmp108 :compute:cy
   305 op len :compute:dist :compute:zx :compute:zy
-    * jump *label224 lessThan :compute:dist 64
-    * jump *label77 always
+  306 jump *label77 greaterThanEq :compute:dist 64
   307 label *label224
   308 op add :compute:i 12 1
   309 set :compute:x1 :compute:zx
 
   315 op mul *tmp108 *tmp107 :compute:zy
   316 op add :compute:zy *tmp108 :compute:cy
   317 op len :compute:dist :compute:zx :compute:zy
-    * jump *label227 lessThan :compute:dist 64
-    * jump *label77 always
+  318 jump *label77 greaterThanEq :compute:dist 64
   319 label *label227
   320 op add :compute:i 13 1
   321 set :compute:x1 :compute:zx
 
   327 op mul *tmp108 *tmp107 :compute:zy
   328 op add :compute:zy *tmp108 :compute:cy
   329 op len :compute:dist :compute:zx :compute:zy
-    * jump *label230 lessThan :compute:dist 64
-    * jump *label77 always
+  330 jump *label77 greaterThanEq :compute:dist 64
   331 label *label230
   332 op add :compute:i 14 1
   333 set :compute:x1 :compute:zx
 
   339 op mul *tmp108 *tmp107 :compute:zy
   340 op add :compute:zy *tmp108 :compute:cy
   341 op len :compute:dist :compute:zx :compute:zy
-    * jump *label233 lessThan :compute:dist 64
-    * jump *label77 always
+  342 jump *label77 greaterThanEq :compute:dist 64
   343 label *label233
   344 op add :compute:i 15 1
   345 set :compute:x1 :compute:zx
 
   351 op mul *tmp108 *tmp107 :compute:zy
   352 op add :compute:zy *tmp108 :compute:cy
   353 op len :compute:dist :compute:zx :compute:zy
-    * jump *label236 lessThan :compute:dist 64
-    * jump *label77 always
+  354 jump *label77 greaterThanEq :compute:dist 64
   355 label *label236
   356 op add :compute:i 16 1
   357 set :compute:x1 :compute:zx
 
   363 op mul *tmp108 *tmp107 :compute:zy
   364 op add :compute:zy *tmp108 :compute:cy
   365 op len :compute:dist :compute:zx :compute:zy
-    * jump *label239 lessThan :compute:dist 64
-    * jump *label77 always
+  366 jump *label77 greaterThanEq :compute:dist 64
   367 label *label239
   368 op add :compute:i 17 1
   369 set :compute:x1 :compute:zx
 
   375 op mul *tmp108 *tmp107 :compute:zy
   376 op add :compute:zy *tmp108 :compute:cy
   377 op len :compute:dist :compute:zx :compute:zy
-    * jump *label242 lessThan :compute:dist 64
-    * jump *label77 always
+  378 jump *label77 greaterThanEq :compute:dist 64
   379 label *label242
   380 op add :compute:i 18 1
   381 set :compute:x1 :compute:zx
 
   387 op mul *tmp108 *tmp107 :compute:zy
   388 op add :compute:zy *tmp108 :compute:cy
   389 op len :compute:dist :compute:zx :compute:zy
-    * jump *label245 lessThan :compute:dist 64
-    * jump *label77 always
+  390 jump *label77 greaterThanEq :compute:dist 64
   391 label *label245
   392 op add :compute:i 19 1
   393 set :compute:x1 :compute:zx
 
   399 op mul *tmp108 *tmp107 :compute:zy
   400 op add :compute:zy *tmp108 :compute:cy
   401 op len :compute:dist :compute:zx :compute:zy
-    * jump *label248 lessThan :compute:dist 64
-    * jump *label77 always
+  402 jump *label77 greaterThanEq :compute:dist 64
   403 label *label248
   404 op add :compute:i 20 1
   405 set :compute:x1 :compute:zx
 
   411 op mul *tmp108 *tmp107 :compute:zy
   412 op add :compute:zy *tmp108 :compute:cy
   413 op len :compute:dist :compute:zx :compute:zy
-    * jump *label251 lessThan :compute:dist 64
-    * jump *label77 always
+  414 jump *label77 greaterThanEq :compute:dist 64
   415 label *label251
   416 op add :compute:i 21 1
   417 set :compute:x1 :compute:zx
 
   423 op mul *tmp108 *tmp107 :compute:zy
   424 op add :compute:zy *tmp108 :compute:cy
   425 op len :compute:dist :compute:zx :compute:zy
-    * jump *label254 lessThan :compute:dist 64
-    * jump *label77 always
+  426 jump *label77 greaterThanEq :compute:dist 64
   427 label *label254
   428 op add :compute:i 22 1
   429 set :compute:x1 :compute:zx
 
   435 op mul *tmp108 *tmp107 :compute:zy
   436 op add :compute:zy *tmp108 :compute:cy
   437 op len :compute:dist :compute:zx :compute:zy
-    * jump *label257 lessThan :compute:dist 64
-    * jump *label77 always
+  438 jump *label77 greaterThanEq :compute:dist 64
   439 label *label257
   440 op add :compute:i 23 1
   441 set :compute:x1 :compute:zx
 
   447 op mul *tmp108 *tmp107 :compute:zy
   448 op add :compute:zy *tmp108 :compute:cy
   449 op len :compute:dist :compute:zx :compute:zy
-    * jump *label260 lessThan :compute:dist 64
-    * jump *label77 always
+  450 jump *label77 greaterThanEq :compute:dist 64
   451 label *label260
   452 op add :compute:i 24 1
   453 set :compute:x1 :compute:zx
 
   459 op mul *tmp108 *tmp107 :compute:zy
   460 op add :compute:zy *tmp108 :compute:cy
   461 op len :compute:dist :compute:zx :compute:zy
-    * jump *label263 lessThan :compute:dist 64
-    * jump *label77 always
+  462 jump *label77 greaterThanEq :compute:dist 64
   463 label *label263
   464 op add :compute:i 25 1
   465 set :compute:x1 :compute:zx
 
   471 op mul *tmp108 *tmp107 :compute:zy
   472 op add :compute:zy *tmp108 :compute:cy
   473 op len :compute:dist :compute:zx :compute:zy
-    * jump *label266 lessThan :compute:dist 64
-    * jump *label77 always
+  474 jump *label77 greaterThanEq :compute:dist 64
   475 label *label266
   476 op add :compute:i 26 1
   477 set :compute:x1 :compute:zx
 
   483 op mul *tmp108 *tmp107 :compute:zy
   484 op add :compute:zy *tmp108 :compute:cy
   485 op len :compute:dist :compute:zx :compute:zy
-    * jump *label269 lessThan :compute:dist 64
-    * jump *label77 always
+  486 jump *label77 greaterThanEq :compute:dist 64
   487 label *label269
   488 op add :compute:i 27 1
   489 set :compute:x1 :compute:zx
 
   495 op mul *tmp108 *tmp107 :compute:zy
   496 op add :compute:zy *tmp108 :compute:cy
   497 op len :compute:dist :compute:zx :compute:zy
-    * jump *label272 lessThan :compute:dist 64
-    * jump *label77 always
+  498 jump *label77 greaterThanEq :compute:dist 64
   499 label *label272
   500 op add :compute:i 28 1
   501 set :compute:x1 :compute:zx
 
   507 op mul *tmp108 *tmp107 :compute:zy
   508 op add :compute:zy *tmp108 :compute:cy
   509 op len :compute:dist :compute:zx :compute:zy
-    * jump *label275 lessThan :compute:dist 64
-    * jump *label77 always
+  510 jump *label77 greaterThanEq :compute:dist 64
   511 label *label275
   512 op add :compute:i 29 1
   513 set :compute:x1 :compute:zx
 
   519 op mul *tmp108 *tmp107 :compute:zy
   520 op add :compute:zy *tmp108 :compute:cy
   521 op len :compute:dist :compute:zx :compute:zy
-    * jump *label278 lessThan :compute:dist 64
-    * jump *label77 always
+  522 jump *label77 greaterThanEq :compute:dist 64
   523 label *label278
   524 op add :compute:i 30 1
   525 set :compute:x1 :compute:zx
 
   531 op mul *tmp108 *tmp107 :compute:zy
   532 op add :compute:zy *tmp108 :compute:cy
   533 op len :compute:dist :compute:zx :compute:zy
-    * jump *label281 lessThan :compute:dist 64
-    * jump *label77 always
+  534 jump *label77 greaterThanEq :compute:dist 64
   535 label *label281
   536 op add :compute:i 31 1
   537 set :compute:x1 :compute:zx
 
   543 op mul *tmp108 *tmp107 :compute:zy
   544 op add :compute:zy *tmp108 :compute:cy
   545 op len :compute:dist :compute:zx :compute:zy
-    * jump *label284 lessThan :compute:dist 64
-    * jump *label77 always
+  546 jump *label77 greaterThanEq :compute:dist 64
   547 label *label284
   548 op add :compute:i 32 1
   549 set :compute:x1 :compute:zx
 
   555 op mul *tmp108 *tmp107 :compute:zy
   556 op add :compute:zy *tmp108 :compute:cy
   557 op len :compute:dist :compute:zx :compute:zy
-    * jump *label287 lessThan :compute:dist 64
-    * jump *label77 always
+  558 jump *label77 greaterThanEq :compute:dist 64
   559 label *label287
   560 op add :compute:i 33 1
   561 set :compute:x1 :compute:zx
 
   567 op mul *tmp108 *tmp107 :compute:zy
   568 op add :compute:zy *tmp108 :compute:cy
   569 op len :compute:dist :compute:zx :compute:zy
-    * jump *label290 lessThan :compute:dist 64
-    * jump *label77 always
+  570 jump *label77 greaterThanEq :compute:dist 64
   571 label *label290
   572 op add :compute:i 34 1
   573 set :compute:x1 :compute:zx
 
   579 op mul *tmp108 *tmp107 :compute:zy
   580 op add :compute:zy *tmp108 :compute:cy
   581 op len :compute:dist :compute:zx :compute:zy
-    * jump *label293 lessThan :compute:dist 64
-    * jump *label77 always
+  582 jump *label77 greaterThanEq :compute:dist 64
   583 label *label293
   584 op add :compute:i 35 1
   585 set :compute:x1 :compute:zx
 
   591 op mul *tmp108 *tmp107 :compute:zy
   592 op add :compute:zy *tmp108 :compute:cy
   593 op len :compute:dist :compute:zx :compute:zy
-    * jump *label296 lessThan :compute:dist 64
-    * jump *label77 always
+  594 jump *label77 greaterThanEq :compute:dist 64
   595 label *label296
   596 op add :compute:i 36 1
   597 set :compute:x1 :compute:zx
 
   603 op mul *tmp108 *tmp107 :compute:zy
   604 op add :compute:zy *tmp108 :compute:cy
   605 op len :compute:dist :compute:zx :compute:zy
-    * jump *label299 lessThan :compute:dist 64
-    * jump *label77 always
+  606 jump *label77 greaterThanEq :compute:dist 64
   607 label *label299
   608 op add :compute:i 37 1
   609 set :compute:x1 :compute:zx
 
   615 op mul *tmp108 *tmp107 :compute:zy
   616 op add :compute:zy *tmp108 :compute:cy
   617 op len :compute:dist :compute:zx :compute:zy
-    * jump *label302 lessThan :compute:dist 64
-    * jump *label77 always
+  618 jump *label77 greaterThanEq :compute:dist 64
   619 label *label302
   620 op add :compute:i 38 1
   621 set :compute:x1 :compute:zx
 
   627 op mul *tmp108 *tmp107 :compute:zy
   628 op add :compute:zy *tmp108 :compute:cy
   629 op len :compute:dist :compute:zx :compute:zy
-    * jump *label305 lessThan :compute:dist 64
-    * jump *label77 always
+  630 jump *label77 greaterThanEq :compute:dist 64
   631 label *label305
   632 op add :compute:i 39 1
   633 set :compute:x1 :compute:zx
 
   639 op mul *tmp108 *tmp107 :compute:zy
   640 op add :compute:zy *tmp108 :compute:cy
   641 op len :compute:dist :compute:zx :compute:zy
-    * jump *label308 lessThan :compute:dist 64
-    * jump *label77 always
+  642 jump *label77 greaterThanEq :compute:dist 64
   643 label *label308
   644 op add :compute:i 40 1
   645 set :compute:x1 :compute:zx
 
   651 op mul *tmp108 *tmp107 :compute:zy
   652 op add :compute:zy *tmp108 :compute:cy
   653 op len :compute:dist :compute:zx :compute:zy
-    * jump *label311 lessThan :compute:dist 64
-    * jump *label77 always
+  654 jump *label77 greaterThanEq :compute:dist 64
   655 label *label311
   656 op add :compute:i 41 1
   657 set :compute:x1 :compute:zx
 
   663 op mul *tmp108 *tmp107 :compute:zy
   664 op add :compute:zy *tmp108 :compute:cy
   665 op len :compute:dist :compute:zx :compute:zy
-    * jump *label314 lessThan :compute:dist 64
-    * jump *label77 always
+  666 jump *label77 greaterThanEq :compute:dist 64
   667 label *label314
   668 op add :compute:i 42 1
   669 set :compute:x1 :compute:zx
 
   675 op mul *tmp108 *tmp107 :compute:zy
   676 op add :compute:zy *tmp108 :compute:cy
   677 op len :compute:dist :compute:zx :compute:zy
-    * jump *label317 lessThan :compute:dist 64
-    * jump *label77 always
+  678 jump *label77 greaterThanEq :compute:dist 64
   679 label *label317
   680 op add :compute:i 43 1
   681 set :compute:x1 :compute:zx
 
   687 op mul *tmp108 *tmp107 :compute:zy
   688 op add :compute:zy *tmp108 :compute:cy
   689 op len :compute:dist :compute:zx :compute:zy
-    * jump *label320 lessThan :compute:dist 64
-    * jump *label77 always
+  690 jump *label77 greaterThanEq :compute:dist 64
   691 label *label320
   692 op add :compute:i 44 1
   693 set :compute:x1 :compute:zx
 
   699 op mul *tmp108 *tmp107 :compute:zy
   700 op add :compute:zy *tmp108 :compute:cy
   701 op len :compute:dist :compute:zx :compute:zy
-    * jump *label323 lessThan :compute:dist 64
-    * jump *label77 always
+  702 jump *label77 greaterThanEq :compute:dist 64
   703 label *label323
   704 op add :compute:i 45 1
   705 set :compute:x1 :compute:zx
 
   711 op mul *tmp108 *tmp107 :compute:zy
   712 op add :compute:zy *tmp108 :compute:cy
   713 op len :compute:dist :compute:zx :compute:zy
-    * jump *label326 lessThan :compute:dist 64
-    * jump *label77 always
+  714 jump *label77 greaterThanEq :compute:dist 64
   715 label *label326
   716 op add :compute:i 46 1
   717 set :compute:x1 :compute:zx
 
   723 op mul *tmp108 *tmp107 :compute:zy
   724 op add :compute:zy *tmp108 :compute:cy
   725 op len :compute:dist :compute:zx :compute:zy
-    * jump *label329 lessThan :compute:dist 64
-    * jump *label77 always
+  726 jump *label77 greaterThanEq :compute:dist 64
   727 label *label329
   728 op add :compute:i 47 1
   729 set :compute:x1 :compute:zx
 
   735 op mul *tmp108 *tmp107 :compute:zy
   736 op add :compute:zy *tmp108 :compute:cy
   737 op len :compute:dist :compute:zx :compute:zy
-    * jump *label332 lessThan :compute:dist 64
-    * jump *label77 always
+  738 jump *label77 greaterThanEq :compute:dist 64
   739 label *label332
   740 op add :compute:i 48 1
   741 set :compute:x1 :compute:zx
 
   747 op mul *tmp108 *tmp107 :compute:zy
   748 op add :compute:zy *tmp108 :compute:cy
   749 op len :compute:dist :compute:zx :compute:zy
-    * jump *label335 lessThan :compute:dist 64
-    * jump *label77 always
+  750 jump *label77 greaterThanEq :compute:dist 64
   751 label *label335
   752 op add :compute:i 49 1
   753 set :compute:x1 :compute:zx
 
   759 op mul *tmp108 *tmp107 :compute:zy
   760 op add :compute:zy *tmp108 :compute:cy
   761 op len :compute:dist :compute:zx :compute:zy
-    * jump *label338 lessThan :compute:dist 64
-    * jump *label77 always
+  762 jump *label77 greaterThanEq :compute:dist 64
   763 label *label338
   764 op add :compute:i 50 1
   765 set :compute:x1 :compute:zx
 
   771 op mul *tmp108 *tmp107 :compute:zy
   772 op add :compute:zy *tmp108 :compute:cy
   773 op len :compute:dist :compute:zx :compute:zy
-    * jump *label341 lessThan :compute:dist 64
-    * jump *label77 always
+  774 jump *label77 greaterThanEq :compute:dist 64
   775 label *label341
   776 op add :compute:i 51 1
   777 set :compute:x1 :compute:zx
 
   783 op mul *tmp108 *tmp107 :compute:zy
   784 op add :compute:zy *tmp108 :compute:cy
   785 op len :compute:dist :compute:zx :compute:zy
-    * jump *label344 lessThan :compute:dist 64
-    * jump *label77 always
+  786 jump *label77 greaterThanEq :compute:dist 64
   787 label *label344
   788 op add :compute:i 52 1
   789 set :compute:x1 :compute:zx
 
   795 op mul *tmp108 *tmp107 :compute:zy
   796 op add :compute:zy *tmp108 :compute:cy
   797 op len :compute:dist :compute:zx :compute:zy
-    * jump *label347 lessThan :compute:dist 64
-    * jump *label77 always
+  798 jump *label77 greaterThanEq :compute:dist 64
   799 label *label347
   800 op add :compute:i 53 1
   801 set :compute:x1 :compute:zx
 
   807 op mul *tmp108 *tmp107 :compute:zy
   808 op add :compute:zy *tmp108 :compute:cy
   809 op len :compute:dist :compute:zx :compute:zy
-    * jump *label350 lessThan :compute:dist 64
-    * jump *label77 always
+  810 jump *label77 greaterThanEq :compute:dist 64
   811 label *label350
   812 op add :compute:i 54 1
   813 set :compute:x1 :compute:zx
 
   819 op mul *tmp108 *tmp107 :compute:zy
   820 op add :compute:zy *tmp108 :compute:cy
   821 op len :compute:dist :compute:zx :compute:zy
-    * jump *label353 lessThan :compute:dist 64
-    * jump *label77 always
+  822 jump *label77 greaterThanEq :compute:dist 64
   823 label *label353
   824 op add :compute:i 55 1
   825 set :compute:x1 :compute:zx
 
   831 op mul *tmp108 *tmp107 :compute:zy
   832 op add :compute:zy *tmp108 :compute:cy
   833 op len :compute:dist :compute:zx :compute:zy
-    * jump *label356 lessThan :compute:dist 64
-    * jump *label77 always
+  834 jump *label77 greaterThanEq :compute:dist 64
   835 label *label356
   836 op add :compute:i 56 1
   837 set :compute:x1 :compute:zx
 
   843 op mul *tmp108 *tmp107 :compute:zy
   844 op add :compute:zy *tmp108 :compute:cy
   845 op len :compute:dist :compute:zx :compute:zy
-    * jump *label359 lessThan :compute:dist 64
-    * jump *label77 always
+  846 jump *label77 greaterThanEq :compute:dist 64
   847 label *label359
   848 op add :compute:i 57 1
   849 set :compute:x1 :compute:zx
 
   855 op mul *tmp108 *tmp107 :compute:zy
   856 op add :compute:zy *tmp108 :compute:cy
   857 op len :compute:dist :compute:zx :compute:zy
-    * jump *label362 lessThan :compute:dist 64
-    * jump *label77 always
+  858 jump *label77 greaterThanEq :compute:dist 64
   859 label *label362
   860 op add :compute:i 58 1
   861 set :compute:x1 :compute:zx
 
   867 op mul *tmp108 *tmp107 :compute:zy
   868 op add :compute:zy *tmp108 :compute:cy
   869 op len :compute:dist :compute:zx :compute:zy
-    * jump *label365 lessThan :compute:dist 64
-    * jump *label77 always
+  870 jump *label77 greaterThanEq :compute:dist 64
   871 label *label365
   872 op add :compute:i 59 1
   873 set :compute:x1 :compute:zx
 
   879 op mul *tmp108 *tmp107 :compute:zy
   880 op add :compute:zy *tmp108 :compute:cy
   881 op len :compute:dist :compute:zx :compute:zy
-    * jump *label368 lessThan :compute:dist 64
-    * jump *label77 always
+  882 jump *label77 greaterThanEq :compute:dist 64
   883 label *label368
   884 op add :compute:i 60 1
   885 set :compute:x1 :compute:zx
 
   891 op mul *tmp108 *tmp107 :compute:zy
   892 op add :compute:zy *tmp108 :compute:cy
   893 op len :compute:dist :compute:zx :compute:zy
-    * jump *label371 lessThan :compute:dist 64
-    * jump *label77 always
+  894 jump *label77 greaterThanEq :compute:dist 64
   895 label *label371
   896 op add :compute:i 61 1
   897 set :compute:x1 :compute:zx
 
   903 op mul *tmp108 *tmp107 :compute:zy
   904 op add :compute:zy *tmp108 :compute:cy
   905 op len :compute:dist :compute:zx :compute:zy
-    * jump *label374 lessThan :compute:dist 64
-    * jump *label77 always
+  906 jump *label77 greaterThanEq :compute:dist 64
   907 label *label374
   908 op add :compute:i 62 1
   909 label *label77
 
  1000 label *label114
  1001 wait 0
  1002 read *tmp185 .memory 68
-    * jump *label118 equal .stop *tmp185
-    * jump *label29 always
+ 1003 jump *label29 notEqual .stop *tmp185
  1004 label *label118
  1005 read *tmp187 .memory 66
  1006 op add *tmp2 *tmp187 1

Modifications by Jumps phase, Jump Threading, pass 6, iteration 1:
 
    56 label *label34
    57 wait 0
    58 read *tmp43 .memory 68
-    * jump *label29 notEqual .stop *tmp43
+   59 jump *label28 notEqual .stop *tmp43
    60 read :batch .memory 64
    61 read *tmp46 .memory 64
    62 op add *tmp47 *tmp46 :multiple
 
   855 label *label68
   856 jump *label85 lessThanEq .PALETTE 1
   857 set :drawPixel:color %[black]
-    * jump *label88 equal *tmp85 63
+  858 jump *label86 equal *tmp85 63
   859 multijump .PALETTE 0 0 (m:*label181)
   860 multilabel *label186 (m:*label181)
   861 multilabel *label182 (m:*label181)
   862 op div *tmp159 *tmp85 63.75
   863 op sub :drawPixel:r 1 *tmp159
   864 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * jump *label89 always
+  865 jump *label86 always
   866 multilabel *label183 (m:*label181)
   867 op sub *tmp125 32 *tmp85
   868 op abs *tmp126 *tmp125
 
   875 op div *tmp138 *tmp126 63.75
   876 op add :drawPixel:b 0.47058823529411764 *tmp138
   877 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label89 always
+  878 jump *label86 always
   879 multilabel *label184 (m:*label181)
   880 op div *tmp142 *tmp85 0.175
   881 op sin :drawPixel:r *tmp142
 
   885 op div *tmp150 *tmp148 63.75
   886 op add :drawPixel:b 0.39215686274509803 *tmp150
   887 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label89 always
+  888 jump *label86 always
   889 multilabel *label185 (m:*label181)
   890 op div :drawPixel:r *tmp85 63.75
   891 op div :drawPixel:g *tmp85 170
 
   897 read :drawPixel:color .memory *tmp85
   898 label *label86
   899 jump *label96 lessThan .localBuffer 254
-    * jump *label101 lessThanEq .localBuffer 0
+  900 jump *label109 lessThanEq .localBuffer 0
   901 label *label136
   902 read *tmp169 .memory 68
   903 jump *label101 notEqual .stop *tmp169
 
   935 label *label114
   936 wait 0
   937 read *tmp185 .memory 68
-    * jump *label29 notEqual .stop *tmp185
+  938 jump *label28 notEqual .stop *tmp185
   939 read *tmp187 .memory 66
   940 op add *tmp2 *tmp187 1
   941 write *tmp2 .memory 66
 
   948 select :multiple greaterThanEq :batch 1337.6 1 :multiple
   949 jump *label34 always
   950 label *label36
-    * jump *label125 lessThanEq .localBuffer 0
+  951 jump *label28 lessThanEq .localBuffer 0
   952 label *label137
   953 read *tmp195 .memory 68
-    * jump *label125 notEqual .stop *tmp195
+  954 jump *label28 notEqual .stop *tmp195
   955 wait 0
   956 sensor *tmp196 .display @enabled
   957 jump *label129 equal *tmp196 false

Modifications by Final phase, Print Merging, iteration 1 (-7 instructions):
 
    16 set .memory :findLinkedBlocks:variable
    17 jump *label133 greaterThan :findLinkedBlocks:n 0
    18 label *label11
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
-    * print .display
+   19 print "\nDisplay: {0}\nMemory: "
+   20 format .display
    21 op and :findLinkedBlocks:foundAll 1 .display
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
    22 print .memory
    23 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    24 printflush null

Final code before resolving virtual instructions:

    0:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label1                                                *blocks: do
    1:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    2:  set .memory null                                             ...
    3:  print "Mandelbrot Generator"                                 *blocks: print(title);
    4:  set :findLinkedBlocks:n @links                               *blocks: var n = @links;
    5:  jump *label11 lessThanEq :findLinkedBlocks:n 0               *blocks: while n > 0 do
        label *label133                                              ...
    6:  op sub :findLinkedBlocks:n :findLinkedBlocks:n 1             *blocks: var block = getlink(--n);
    7:  getlink :findLinkedBlocks:block :findLinkedBlocks:n          ...
    8:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
    9:  print :findLinkedBlocks:block                                ...
   10:  sensor :findLinkedBlocks:type :findLinkedBlocks:block @type  *blocks: var type = block.@type;
   11:  select :findLinkedBlocks:variable equal @large-logic-display *blocks: if requested == type then
   12:  set .display :findLinkedBlocks:variable                      *blocks: for requested, name, out variable, required in linkMap do
   13:  select :findLinkedBlocks:variable equal @memory-bank :findLi *blocks: if requested == type then
   14:  set .memory :findLinkedBlocks:variable                       *blocks: for requested, name, out variable, required in linkMap do
   15:  jump *label133 greaterThan :findLinkedBlocks:n 0             *blocks: while n > 0 do
        label *label11                                               ...
   16:  print "\nDisplay: {0}\nMemory: "                             *blocks: print($"\n$name: $variable");
   17:  format .display                                              ...
   18:  op and :findLinkedBlocks:foundAll 1 .display                 *blocks: if required then foundAll &= variable; end;
   19:  print .memory                                                *blocks: print($"\n$name: $variable");
   20:  op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll *blocks: if required then foundAll &= variable; end;
   21:  printflush null                                              *blocks: printflush(message);
   22:  jump *label1 equal :findLinkedBlocks:foundAll false          *blocks: do
        label *label28                                               mandelbrot-compute.mnd: MainLoop:
        label *label31                                               mandelbrot-compute.mnd: do wait(0); while start == $START;
   23:  wait 0                                                       ...
   24:  read *tmp26 .memory 67                                       ...
   25:  jump *label31 equal .start *tmp26                            ...
   26:  read .start .memory 67                                       mandelbrot-compute.mnd: start = $START;
   27:  read .stop .memory 68                                        mandelbrot-compute.mnd: stop = $STOP;
   28:  set .lastColor -1                                            mandelbrot-compute.mnd: lastColor = -1;
   29:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   30:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
   31:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
   32:  read .ZOOM .memory 71                                        mandelbrot-compute.mnd: ZOOM      = $ZOOM;
   33:  op div *tmp30 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X  = -HALF_SIZE / ZOOM + $X;
   34:  read *tmp32 .memory 69                                       ...
   35:  op add .OFFSET_X *tmp30 *tmp32                               ...
   36:  read *tmp35 .memory 70                                       mandelbrot-compute.mnd: OFFSET_Y  = -HALF_SIZE / ZOOM + $Y;
   37:  op add .OFFSET_Y *tmp30 *tmp35                               ...
   38:  read .JULIA .memory 72                                       mandelbrot-compute.mnd: JULIA     = $JULIA;
   39:  read .JULIA_X .memory 73                                     mandelbrot-compute.mnd: JULIA_X   = $JULIA_X;
   40:  read .JULIA_Y .memory 74                                     mandelbrot-compute.mnd: JULIA_Y   = $JULIA_Y;
   41:  read .PALETTE .memory 75                                     mandelbrot-compute.mnd: PALETTE   = $PALETTE;
   42:  read .FILL_PASS .memory 76                                   mandelbrot-compute.mnd: FILL_PASS = $FILL_PASS;
   43:  set :multiple 4                                              mandelbrot-compute.mnd: var multiple = 4;
        label *label34                                               mandelbrot-compute.mnd: while true do
   44:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
   45:  read *tmp43 .memory 68                                       mandelbrot-compute.mnd: if stop != $STOP then
   46:  jump *label28 notEqual .stop *tmp43                          ...
   47:  read :batch .memory 64                                       mandelbrot-compute.mnd: batch = $LINE;
   48:  read *tmp46 .memory 64                                       mandelbrot-compute.mnd: $LINE += multiple;
   49:  op add *tmp47 *tmp46 :multiple                               ...
   50:  write *tmp47 .memory 64                 # The last atomic bl ...
   51:  jump *label36 greaterThanEq :batch 2816                      mandelbrot-compute.mnd: if batch >= TOTAL_BATCHES then
   52:  op mul *tmp51 11 :multiple                                   mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
   53:  set :i 0                                                     ...
   54:  op mul *tmp52 :batch 11                                      ...
   55:  jump *label43 lessThanEq :multiple 0                         ...
        label *label134                                              ...
   56:  op add :adam5:index *tmp52 :i                                mandelbrot-compute.mnd: adam5(batch * BATCH_SIZE + i, out x, out y, out dx, out dy);
   57:  op idiv *tmp55 :adam5:index 16                               mandelbrot-compute.mnd: case index \ 16
   58:  multijump *tmp55 0 0                                         ...
        multilabel *label179                                         ...
   59:  op sub :adam5:index :adam5:index 15488                       mandelbrot-compute.mnd: index -= 8 * PASS_SIZE;
   60:  op mod :adam5:x :adam5:index 176                             mandelbrot-compute.mnd: x = (index % SIZE1);
   61:  op idiv *tmp82 :adam5:index 176                              mandelbrot-compute.mnd: y = 2 * (index \ SIZE1) + 1;
   62:  op mul *tmp83 2 *tmp82                                       ...
   63:  op add :adam5:y *tmp83 1                                     ...
   64:  set :adam5:dy 1                                              mandelbrot-compute.mnd: dx = dy = 1;
   65:  set :adam5:dx 1                                              ...
   66:  jump *label45 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label175                                         ...
   67:  op mod *tmp57 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4);
   68:  op mul :adam5:x 4 *tmp57                                     ...
   69:  op idiv *tmp59 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   70:  op mul :adam5:y 4 *tmp59                                     ...
   71:  select *tmp61 notEqual .FILL_PASS false 4 1                  mandelbrot-compute.mnd: dx = dy = FILL_PASS ? 4 : 1;
   72:  set :adam5:dy *tmp61                                         ...
   73:  set :adam5:dx *tmp61                                         ...
   74:  jump *label45 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label176                                         ...
   75:  op sub :adam5:index :adam5:index 1936                        mandelbrot-compute.mnd: index -= PASS_SIZE;
   76:  op mod *tmp62 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4) + 2;
   77:  op mul *tmp63 4 *tmp62                                       ...
   78:  op add :adam5:x *tmp63 2                                     ...
   79:  op idiv *tmp65 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   80:  op mul :adam5:y 4 *tmp65                                     ...
   81:  select :adam5:dx notEqual .FILL_PASS false 2 1               mandelbrot-compute.mnd: dx = FILL_PASS ? 2 : 1;
   82:  select :adam5:dy notEqual .FILL_PASS false 4 1               mandelbrot-compute.mnd: dy = FILL_PASS ? 4 : 1;
   83:  jump *label45 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label177                                         ...
   84:  op sub :adam5:index :adam5:index 3872                        mandelbrot-compute.mnd: index -= 2 * PASS_SIZE;
   85:  op mod *tmp69 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2);
   86:  op mul :adam5:x 2 *tmp69                                     ...
   87:  op idiv *tmp71 :adam5:index 88                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE2) + 2;
   88:  op mul *tmp72 4 *tmp71                                       ...
   89:  op add :adam5:y *tmp72 2                                     ...
   90:  select *tmp74 notEqual .FILL_PASS false 2 1                  mandelbrot-compute.mnd: dx = dy = FILL_PASS ? 2 : 1;
   91:  set :adam5:dy *tmp74                                         ...
   92:  set :adam5:dx *tmp74                                         ...
   93:  jump *label45 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label178                                         ...
   94:  op sub :adam5:index :adam5:index 7744                        mandelbrot-compute.mnd: index -= 4 * PASS_SIZE;
   95:  op mod *tmp75 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2) + 1;
   96:  op mul *tmp76 2 *tmp75                                       ...
   97:  op add :adam5:x *tmp76 1                                     ...
   98:  op idiv *tmp78 :adam5:index 88                               mandelbrot-compute.mnd: y = 2 * (index \ SIZE2);
   99:  op mul :adam5:y 2 *tmp78                                     ...
  100:  set :adam5:dx 1                                              mandelbrot-compute.mnd: dx = 1; dy = FILL_PASS ? 2 : 1;
  101:  select :adam5:dy notEqual .FILL_PASS false 2 1               ...
        label *label45                                               mandelbrot-compute.mnd: case index \ 16
  102:  op div *tmp86 :adam5:x .ZOOM                                 mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
  103:  op add :compute:zx *tmp86 .OFFSET_X                          ...
  104:  op div *tmp88 :adam5:y .ZOOM                                 mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
  105:  op add :compute:zy *tmp88 .OFFSET_Y                          ...
  106:  jump *label69 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
  107:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
  108:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
  109:  jump *label70 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label69                                               ...
  110:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
  111:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
  112:  op sub *tmp91 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
  113:  op len :compute:p *tmp91 :compute:zy                         ...
  114:  op mul *tmp93 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  115:  op mul *tmp94 *tmp93 :compute:p                              ...
  116:  op sub *tmp95 :compute:p *tmp94                              ...
  117:  op add *tmp96 *tmp95 0.25                                    ...
  118:  jump *label71 greaterThan :compute:zx *tmp96                 ...
  119:  set *tmp85 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  120:  jump *label68 always 0 0                                     ...
        label *label71                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  121:  op add *tmp99 :compute:zx 1                                  mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  122:  op len *tmp100 *tmp99 :compute:zy                            ...
  123:  jump *label73 greaterThan *tmp100 0.25                       ...
  124:  set *tmp85 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  125:  jump *label68 always 0 0                                     ...
        label *label73                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label70                                               mandelbrot-compute.mnd: if JULIA then
  126:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  127:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  128:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  129:  op mul *tmp104 :compute:zy :compute:zy                       ...
  130:  op sub *tmp105 *tmp103 *tmp104                               ...
  131:  op add :compute:zx *tmp105 :compute:cx                       ...
  132:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  133:  op mul *tmp108 *tmp107 :compute:zy                           ...
  134:  op add :compute:zy *tmp108 :compute:cy                       ...
  135:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  136:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  137:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  138:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  139:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  140:  op mul *tmp104 :compute:zy :compute:zy                       ...
  141:  op sub *tmp105 *tmp103 *tmp104                               ...
  142:  op add :compute:zx *tmp105 :compute:cx                       ...
  143:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  144:  op mul *tmp108 *tmp107 :compute:zy                           ...
  145:  op add :compute:zy *tmp108 :compute:cy                       ...
  146:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  147:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  148:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  149:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  150:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  151:  op mul *tmp104 :compute:zy :compute:zy                       ...
  152:  op sub *tmp105 *tmp103 *tmp104                               ...
  153:  op add :compute:zx *tmp105 :compute:cx                       ...
  154:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  155:  op mul *tmp108 *tmp107 :compute:zy                           ...
  156:  op add :compute:zy *tmp108 :compute:cy                       ...
  157:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  158:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  159:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  160:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  161:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  162:  op mul *tmp104 :compute:zy :compute:zy                       ...
  163:  op sub *tmp105 *tmp103 *tmp104                               ...
  164:  op add :compute:zx *tmp105 :compute:cx                       ...
  165:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  166:  op mul *tmp108 *tmp107 :compute:zy                           ...
  167:  op add :compute:zy *tmp108 :compute:cy                       ...
  168:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  169:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  170:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  171:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  172:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  173:  op mul *tmp104 :compute:zy :compute:zy                       ...
  174:  op sub *tmp105 *tmp103 *tmp104                               ...
  175:  op add :compute:zx *tmp105 :compute:cx                       ...
  176:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  177:  op mul *tmp108 *tmp107 :compute:zy                           ...
  178:  op add :compute:zy *tmp108 :compute:cy                       ...
  179:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  180:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  181:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  182:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  183:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  184:  op mul *tmp104 :compute:zy :compute:zy                       ...
  185:  op sub *tmp105 *tmp103 *tmp104                               ...
  186:  op add :compute:zx *tmp105 :compute:cx                       ...
  187:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  188:  op mul *tmp108 *tmp107 :compute:zy                           ...
  189:  op add :compute:zy *tmp108 :compute:cy                       ...
  190:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  191:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  192:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  193:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  194:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  195:  op mul *tmp104 :compute:zy :compute:zy                       ...
  196:  op sub *tmp105 *tmp103 *tmp104                               ...
  197:  op add :compute:zx *tmp105 :compute:cx                       ...
  198:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  199:  op mul *tmp108 *tmp107 :compute:zy                           ...
  200:  op add :compute:zy *tmp108 :compute:cy                       ...
  201:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  202:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  203:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  204:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  205:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  206:  op mul *tmp104 :compute:zy :compute:zy                       ...
  207:  op sub *tmp105 *tmp103 *tmp104                               ...
  208:  op add :compute:zx *tmp105 :compute:cx                       ...
  209:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  210:  op mul *tmp108 *tmp107 :compute:zy                           ...
  211:  op add :compute:zy *tmp108 :compute:cy                       ...
  212:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  213:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  214:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  215:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  216:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  217:  op mul *tmp104 :compute:zy :compute:zy                       ...
  218:  op sub *tmp105 *tmp103 *tmp104                               ...
  219:  op add :compute:zx *tmp105 :compute:cx                       ...
  220:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  221:  op mul *tmp108 *tmp107 :compute:zy                           ...
  222:  op add :compute:zy *tmp108 :compute:cy                       ...
  223:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  224:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  225:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  226:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  227:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  228:  op mul *tmp104 :compute:zy :compute:zy                       ...
  229:  op sub *tmp105 *tmp103 *tmp104                               ...
  230:  op add :compute:zx *tmp105 :compute:cx                       ...
  231:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  232:  op mul *tmp108 *tmp107 :compute:zy                           ...
  233:  op add :compute:zy *tmp108 :compute:cy                       ...
  234:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  235:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  236:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  237:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  238:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  239:  op mul *tmp104 :compute:zy :compute:zy                       ...
  240:  op sub *tmp105 *tmp103 *tmp104                               ...
  241:  op add :compute:zx *tmp105 :compute:cx                       ...
  242:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  243:  op mul *tmp108 *tmp107 :compute:zy                           ...
  244:  op add :compute:zy *tmp108 :compute:cy                       ...
  245:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  246:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  247:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  248:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  249:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  250:  op mul *tmp104 :compute:zy :compute:zy                       ...
  251:  op sub *tmp105 *tmp103 *tmp104                               ...
  252:  op add :compute:zx *tmp105 :compute:cx                       ...
  253:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  254:  op mul *tmp108 *tmp107 :compute:zy                           ...
  255:  op add :compute:zy *tmp108 :compute:cy                       ...
  256:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  257:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  258:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  259:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  260:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  261:  op mul *tmp104 :compute:zy :compute:zy                       ...
  262:  op sub *tmp105 *tmp103 *tmp104                               ...
  263:  op add :compute:zx *tmp105 :compute:cx                       ...
  264:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  265:  op mul *tmp108 *tmp107 :compute:zy                           ...
  266:  op add :compute:zy *tmp108 :compute:cy                       ...
  267:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  268:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  269:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  270:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  271:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  272:  op mul *tmp104 :compute:zy :compute:zy                       ...
  273:  op sub *tmp105 *tmp103 *tmp104                               ...
  274:  op add :compute:zx *tmp105 :compute:cx                       ...
  275:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  276:  op mul *tmp108 *tmp107 :compute:zy                           ...
  277:  op add :compute:zy *tmp108 :compute:cy                       ...
  278:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  279:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  280:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  281:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  282:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  283:  op mul *tmp104 :compute:zy :compute:zy                       ...
  284:  op sub *tmp105 *tmp103 *tmp104                               ...
  285:  op add :compute:zx *tmp105 :compute:cx                       ...
  286:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  287:  op mul *tmp108 *tmp107 :compute:zy                           ...
  288:  op add :compute:zy *tmp108 :compute:cy                       ...
  289:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  290:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  291:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  292:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  293:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  294:  op mul *tmp104 :compute:zy :compute:zy                       ...
  295:  op sub *tmp105 *tmp103 *tmp104                               ...
  296:  op add :compute:zx *tmp105 :compute:cx                       ...
  297:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  298:  op mul *tmp108 *tmp107 :compute:zy                           ...
  299:  op add :compute:zy *tmp108 :compute:cy                       ...
  300:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  301:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  302:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  303:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  304:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  305:  op mul *tmp104 :compute:zy :compute:zy                       ...
  306:  op sub *tmp105 *tmp103 *tmp104                               ...
  307:  op add :compute:zx *tmp105 :compute:cx                       ...
  308:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  309:  op mul *tmp108 *tmp107 :compute:zy                           ...
  310:  op add :compute:zy *tmp108 :compute:cy                       ...
  311:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  312:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  313:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  314:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  315:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  316:  op mul *tmp104 :compute:zy :compute:zy                       ...
  317:  op sub *tmp105 *tmp103 *tmp104                               ...
  318:  op add :compute:zx *tmp105 :compute:cx                       ...
  319:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  320:  op mul *tmp108 *tmp107 :compute:zy                           ...
  321:  op add :compute:zy *tmp108 :compute:cy                       ...
  322:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  323:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  324:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  325:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  326:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  327:  op mul *tmp104 :compute:zy :compute:zy                       ...
  328:  op sub *tmp105 *tmp103 *tmp104                               ...
  329:  op add :compute:zx *tmp105 :compute:cx                       ...
  330:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  331:  op mul *tmp108 *tmp107 :compute:zy                           ...
  332:  op add :compute:zy *tmp108 :compute:cy                       ...
  333:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  334:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  335:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  336:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  337:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  338:  op mul *tmp104 :compute:zy :compute:zy                       ...
  339:  op sub *tmp105 *tmp103 *tmp104                               ...
  340:  op add :compute:zx *tmp105 :compute:cx                       ...
  341:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  342:  op mul *tmp108 *tmp107 :compute:zy                           ...
  343:  op add :compute:zy *tmp108 :compute:cy                       ...
  344:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  345:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  346:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  347:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  348:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  349:  op mul *tmp104 :compute:zy :compute:zy                       ...
  350:  op sub *tmp105 *tmp103 *tmp104                               ...
  351:  op add :compute:zx *tmp105 :compute:cx                       ...
  352:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  353:  op mul *tmp108 *tmp107 :compute:zy                           ...
  354:  op add :compute:zy *tmp108 :compute:cy                       ...
  355:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  356:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  357:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  358:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  359:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  360:  op mul *tmp104 :compute:zy :compute:zy                       ...
  361:  op sub *tmp105 *tmp103 *tmp104                               ...
  362:  op add :compute:zx *tmp105 :compute:cx                       ...
  363:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  364:  op mul *tmp108 *tmp107 :compute:zy                           ...
  365:  op add :compute:zy *tmp108 :compute:cy                       ...
  366:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  367:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  368:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  369:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  370:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  371:  op mul *tmp104 :compute:zy :compute:zy                       ...
  372:  op sub *tmp105 *tmp103 *tmp104                               ...
  373:  op add :compute:zx *tmp105 :compute:cx                       ...
  374:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  375:  op mul *tmp108 *tmp107 :compute:zy                           ...
  376:  op add :compute:zy *tmp108 :compute:cy                       ...
  377:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  378:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  379:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  380:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  381:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  382:  op mul *tmp104 :compute:zy :compute:zy                       ...
  383:  op sub *tmp105 *tmp103 *tmp104                               ...
  384:  op add :compute:zx *tmp105 :compute:cx                       ...
  385:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  386:  op mul *tmp108 *tmp107 :compute:zy                           ...
  387:  op add :compute:zy *tmp108 :compute:cy                       ...
  388:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  389:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  390:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  391:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  392:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  393:  op mul *tmp104 :compute:zy :compute:zy                       ...
  394:  op sub *tmp105 *tmp103 *tmp104                               ...
  395:  op add :compute:zx *tmp105 :compute:cx                       ...
  396:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  397:  op mul *tmp108 *tmp107 :compute:zy                           ...
  398:  op add :compute:zy *tmp108 :compute:cy                       ...
  399:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  400:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  401:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  402:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  403:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  404:  op mul *tmp104 :compute:zy :compute:zy                       ...
  405:  op sub *tmp105 *tmp103 *tmp104                               ...
  406:  op add :compute:zx *tmp105 :compute:cx                       ...
  407:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  408:  op mul *tmp108 *tmp107 :compute:zy                           ...
  409:  op add :compute:zy *tmp108 :compute:cy                       ...
  410:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  411:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  412:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  413:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  414:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  415:  op mul *tmp104 :compute:zy :compute:zy                       ...
  416:  op sub *tmp105 *tmp103 *tmp104                               ...
  417:  op add :compute:zx *tmp105 :compute:cx                       ...
  418:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  419:  op mul *tmp108 *tmp107 :compute:zy                           ...
  420:  op add :compute:zy *tmp108 :compute:cy                       ...
  421:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  422:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  423:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  424:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  425:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  426:  op mul *tmp104 :compute:zy :compute:zy                       ...
  427:  op sub *tmp105 *tmp103 *tmp104                               ...
  428:  op add :compute:zx *tmp105 :compute:cx                       ...
  429:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  430:  op mul *tmp108 *tmp107 :compute:zy                           ...
  431:  op add :compute:zy *tmp108 :compute:cy                       ...
  432:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  433:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  434:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  435:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  436:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  437:  op mul *tmp104 :compute:zy :compute:zy                       ...
  438:  op sub *tmp105 *tmp103 *tmp104                               ...
  439:  op add :compute:zx *tmp105 :compute:cx                       ...
  440:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  441:  op mul *tmp108 *tmp107 :compute:zy                           ...
  442:  op add :compute:zy *tmp108 :compute:cy                       ...
  443:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  444:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  445:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  446:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  447:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  448:  op mul *tmp104 :compute:zy :compute:zy                       ...
  449:  op sub *tmp105 *tmp103 *tmp104                               ...
  450:  op add :compute:zx *tmp105 :compute:cx                       ...
  451:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  452:  op mul *tmp108 *tmp107 :compute:zy                           ...
  453:  op add :compute:zy *tmp108 :compute:cy                       ...
  454:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  455:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  456:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  457:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  458:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  459:  op mul *tmp104 :compute:zy :compute:zy                       ...
  460:  op sub *tmp105 *tmp103 *tmp104                               ...
  461:  op add :compute:zx *tmp105 :compute:cx                       ...
  462:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  463:  op mul *tmp108 *tmp107 :compute:zy                           ...
  464:  op add :compute:zy *tmp108 :compute:cy                       ...
  465:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  466:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  467:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  468:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  469:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  470:  op mul *tmp104 :compute:zy :compute:zy                       ...
  471:  op sub *tmp105 *tmp103 *tmp104                               ...
  472:  op add :compute:zx *tmp105 :compute:cx                       ...
  473:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  474:  op mul *tmp108 *tmp107 :compute:zy                           ...
  475:  op add :compute:zy *tmp108 :compute:cy                       ...
  476:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  477:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  478:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  479:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  480:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  481:  op mul *tmp104 :compute:zy :compute:zy                       ...
  482:  op sub *tmp105 *tmp103 *tmp104                               ...
  483:  op add :compute:zx *tmp105 :compute:cx                       ...
  484:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  485:  op mul *tmp108 *tmp107 :compute:zy                           ...
  486:  op add :compute:zy *tmp108 :compute:cy                       ...
  487:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  488:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  489:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  490:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  491:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  492:  op mul *tmp104 :compute:zy :compute:zy                       ...
  493:  op sub *tmp105 *tmp103 *tmp104                               ...
  494:  op add :compute:zx *tmp105 :compute:cx                       ...
  495:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  496:  op mul *tmp108 *tmp107 :compute:zy                           ...
  497:  op add :compute:zy *tmp108 :compute:cy                       ...
  498:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  499:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  500:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  501:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  502:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  503:  op mul *tmp104 :compute:zy :compute:zy                       ...
  504:  op sub *tmp105 *tmp103 *tmp104                               ...
  505:  op add :compute:zx *tmp105 :compute:cx                       ...
  506:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  507:  op mul *tmp108 *tmp107 :compute:zy                           ...
  508:  op add :compute:zy *tmp108 :compute:cy                       ...
  509:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  510:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  511:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  512:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  513:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  514:  op mul *tmp104 :compute:zy :compute:zy                       ...
  515:  op sub *tmp105 *tmp103 *tmp104                               ...
  516:  op add :compute:zx *tmp105 :compute:cx                       ...
  517:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  518:  op mul *tmp108 *tmp107 :compute:zy                           ...
  519:  op add :compute:zy *tmp108 :compute:cy                       ...
  520:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  521:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  522:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  523:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  524:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  525:  op mul *tmp104 :compute:zy :compute:zy                       ...
  526:  op sub *tmp105 *tmp103 *tmp104                               ...
  527:  op add :compute:zx *tmp105 :compute:cx                       ...
  528:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  529:  op mul *tmp108 *tmp107 :compute:zy                           ...
  530:  op add :compute:zy *tmp108 :compute:cy                       ...
  531:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  532:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  533:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  534:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  535:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  536:  op mul *tmp104 :compute:zy :compute:zy                       ...
  537:  op sub *tmp105 *tmp103 *tmp104                               ...
  538:  op add :compute:zx *tmp105 :compute:cx                       ...
  539:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  540:  op mul *tmp108 *tmp107 :compute:zy                           ...
  541:  op add :compute:zy *tmp108 :compute:cy                       ...
  542:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  543:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  544:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  545:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  546:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  547:  op mul *tmp104 :compute:zy :compute:zy                       ...
  548:  op sub *tmp105 *tmp103 *tmp104                               ...
  549:  op add :compute:zx *tmp105 :compute:cx                       ...
  550:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  551:  op mul *tmp108 *tmp107 :compute:zy                           ...
  552:  op add :compute:zy *tmp108 :compute:cy                       ...
  553:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  554:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  555:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  556:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  557:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  558:  op mul *tmp104 :compute:zy :compute:zy                       ...
  559:  op sub *tmp105 *tmp103 *tmp104                               ...
  560:  op add :compute:zx *tmp105 :compute:cx                       ...
  561:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  562:  op mul *tmp108 *tmp107 :compute:zy                           ...
  563:  op add :compute:zy *tmp108 :compute:cy                       ...
  564:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  565:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  566:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  567:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  568:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  569:  op mul *tmp104 :compute:zy :compute:zy                       ...
  570:  op sub *tmp105 *tmp103 *tmp104                               ...
  571:  op add :compute:zx *tmp105 :compute:cx                       ...
  572:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  573:  op mul *tmp108 *tmp107 :compute:zy                           ...
  574:  op add :compute:zy *tmp108 :compute:cy                       ...
  575:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  576:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  577:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  578:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  579:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  580:  op mul *tmp104 :compute:zy :compute:zy                       ...
  581:  op sub *tmp105 *tmp103 *tmp104                               ...
  582:  op add :compute:zx *tmp105 :compute:cx                       ...
  583:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  584:  op mul *tmp108 *tmp107 :compute:zy                           ...
  585:  op add :compute:zy *tmp108 :compute:cy                       ...
  586:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  587:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  588:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  589:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  590:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  591:  op mul *tmp104 :compute:zy :compute:zy                       ...
  592:  op sub *tmp105 *tmp103 *tmp104                               ...
  593:  op add :compute:zx *tmp105 :compute:cx                       ...
  594:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  595:  op mul *tmp108 *tmp107 :compute:zy                           ...
  596:  op add :compute:zy *tmp108 :compute:cy                       ...
  597:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  598:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  599:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  600:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  601:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  602:  op mul *tmp104 :compute:zy :compute:zy                       ...
  603:  op sub *tmp105 *tmp103 *tmp104                               ...
  604:  op add :compute:zx *tmp105 :compute:cx                       ...
  605:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  606:  op mul *tmp108 *tmp107 :compute:zy                           ...
  607:  op add :compute:zy *tmp108 :compute:cy                       ...
  608:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  609:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  610:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  611:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  612:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  613:  op mul *tmp104 :compute:zy :compute:zy                       ...
  614:  op sub *tmp105 *tmp103 *tmp104                               ...
  615:  op add :compute:zx *tmp105 :compute:cx                       ...
  616:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  617:  op mul *tmp108 *tmp107 :compute:zy                           ...
  618:  op add :compute:zy *tmp108 :compute:cy                       ...
  619:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  620:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  621:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  622:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  623:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  624:  op mul *tmp104 :compute:zy :compute:zy                       ...
  625:  op sub *tmp105 *tmp103 *tmp104                               ...
  626:  op add :compute:zx *tmp105 :compute:cx                       ...
  627:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  628:  op mul *tmp108 *tmp107 :compute:zy                           ...
  629:  op add :compute:zy *tmp108 :compute:cy                       ...
  630:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  631:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  632:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  633:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  634:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  635:  op mul *tmp104 :compute:zy :compute:zy                       ...
  636:  op sub *tmp105 *tmp103 *tmp104                               ...
  637:  op add :compute:zx *tmp105 :compute:cx                       ...
  638:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  639:  op mul *tmp108 *tmp107 :compute:zy                           ...
  640:  op add :compute:zy *tmp108 :compute:cy                       ...
  641:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  642:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  643:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  644:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  645:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  646:  op mul *tmp104 :compute:zy :compute:zy                       ...
  647:  op sub *tmp105 *tmp103 *tmp104                               ...
  648:  op add :compute:zx *tmp105 :compute:cx                       ...
  649:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  650:  op mul *tmp108 *tmp107 :compute:zy                           ...
  651:  op add :compute:zy *tmp108 :compute:cy                       ...
  652:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  653:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  654:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  655:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  656:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  657:  op mul *tmp104 :compute:zy :compute:zy                       ...
  658:  op sub *tmp105 *tmp103 *tmp104                               ...
  659:  op add :compute:zx *tmp105 :compute:cx                       ...
  660:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  661:  op mul *tmp108 *tmp107 :compute:zy                           ...
  662:  op add :compute:zy *tmp108 :compute:cy                       ...
  663:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  664:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  665:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  666:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  667:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  668:  op mul *tmp104 :compute:zy :compute:zy                       ...
  669:  op sub *tmp105 *tmp103 *tmp104                               ...
  670:  op add :compute:zx *tmp105 :compute:cx                       ...
  671:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  672:  op mul *tmp108 *tmp107 :compute:zy                           ...
  673:  op add :compute:zy *tmp108 :compute:cy                       ...
  674:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  675:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  676:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  677:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  678:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  679:  op mul *tmp104 :compute:zy :compute:zy                       ...
  680:  op sub *tmp105 *tmp103 *tmp104                               ...
  681:  op add :compute:zx *tmp105 :compute:cx                       ...
  682:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  683:  op mul *tmp108 *tmp107 :compute:zy                           ...
  684:  op add :compute:zy *tmp108 :compute:cy                       ...
  685:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  686:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  687:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  688:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  689:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  690:  op mul *tmp104 :compute:zy :compute:zy                       ...
  691:  op sub *tmp105 *tmp103 *tmp104                               ...
  692:  op add :compute:zx *tmp105 :compute:cx                       ...
  693:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  694:  op mul *tmp108 *tmp107 :compute:zy                           ...
  695:  op add :compute:zy *tmp108 :compute:cy                       ...
  696:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  697:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  698:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  699:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  700:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  701:  op mul *tmp104 :compute:zy :compute:zy                       ...
  702:  op sub *tmp105 *tmp103 *tmp104                               ...
  703:  op add :compute:zx *tmp105 :compute:cx                       ...
  704:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  705:  op mul *tmp108 *tmp107 :compute:zy                           ...
  706:  op add :compute:zy *tmp108 :compute:cy                       ...
  707:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  708:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  709:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  710:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  711:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  712:  op mul *tmp104 :compute:zy :compute:zy                       ...
  713:  op sub *tmp105 *tmp103 *tmp104                               ...
  714:  op add :compute:zx *tmp105 :compute:cx                       ...
  715:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  716:  op mul *tmp108 *tmp107 :compute:zy                           ...
  717:  op add :compute:zy *tmp108 :compute:cy                       ...
  718:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  719:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  720:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  721:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  722:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  723:  op mul *tmp104 :compute:zy :compute:zy                       ...
  724:  op sub *tmp105 *tmp103 *tmp104                               ...
  725:  op add :compute:zx *tmp105 :compute:cx                       ...
  726:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  727:  op mul *tmp108 *tmp107 :compute:zy                           ...
  728:  op add :compute:zy *tmp108 :compute:cy                       ...
  729:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  730:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  731:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  732:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  733:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  734:  op mul *tmp104 :compute:zy :compute:zy                       ...
  735:  op sub *tmp105 *tmp103 *tmp104                               ...
  736:  op add :compute:zx *tmp105 :compute:cx                       ...
  737:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  738:  op mul *tmp108 *tmp107 :compute:zy                           ...
  739:  op add :compute:zy *tmp108 :compute:cy                       ...
  740:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  741:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  742:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  743:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  744:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  745:  op mul *tmp104 :compute:zy :compute:zy                       ...
  746:  op sub *tmp105 *tmp103 *tmp104                               ...
  747:  op add :compute:zx *tmp105 :compute:cx                       ...
  748:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  749:  op mul *tmp108 *tmp107 :compute:zy                           ...
  750:  op add :compute:zy *tmp108 :compute:cy                       ...
  751:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  752:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  753:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  754:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  755:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  756:  op mul *tmp104 :compute:zy :compute:zy                       ...
  757:  op sub *tmp105 *tmp103 *tmp104                               ...
  758:  op add :compute:zx *tmp105 :compute:cx                       ...
  759:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  760:  op mul *tmp108 *tmp107 :compute:zy                           ...
  761:  op add :compute:zy *tmp108 :compute:cy                       ...
  762:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  763:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  764:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  765:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  766:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  767:  op mul *tmp104 :compute:zy :compute:zy                       ...
  768:  op sub *tmp105 *tmp103 *tmp104                               ...
  769:  op add :compute:zx *tmp105 :compute:cx                       ...
  770:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  771:  op mul *tmp108 *tmp107 :compute:zy                           ...
  772:  op add :compute:zy *tmp108 :compute:cy                       ...
  773:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  774:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  775:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  776:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  777:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  778:  op mul *tmp104 :compute:zy :compute:zy                       ...
  779:  op sub *tmp105 *tmp103 *tmp104                               ...
  780:  op add :compute:zx *tmp105 :compute:cx                       ...
  781:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  782:  op mul *tmp108 *tmp107 :compute:zy                           ...
  783:  op add :compute:zy *tmp108 :compute:cy                       ...
  784:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  785:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  786:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  787:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  788:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  789:  op mul *tmp104 :compute:zy :compute:zy                       ...
  790:  op sub *tmp105 *tmp103 *tmp104                               ...
  791:  op add :compute:zx *tmp105 :compute:cx                       ...
  792:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  793:  op mul *tmp108 *tmp107 :compute:zy                           ...
  794:  op add :compute:zy *tmp108 :compute:cy                       ...
  795:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  796:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  797:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  798:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  799:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  800:  op mul *tmp104 :compute:zy :compute:zy                       ...
  801:  op sub *tmp105 *tmp103 *tmp104                               ...
  802:  op add :compute:zx *tmp105 :compute:cx                       ...
  803:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  804:  op mul *tmp108 *tmp107 :compute:zy                           ...
  805:  op add :compute:zy *tmp108 :compute:cy                       ...
  806:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  807:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  808:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  809:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  810:  op mul *tmp103 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  811:  op mul *tmp104 :compute:zy :compute:zy                       ...
  812:  op sub *tmp105 *tmp103 *tmp104                               ...
  813:  op add :compute:zx *tmp105 :compute:cx                       ...
  814:  op mul *tmp107 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  815:  op mul *tmp108 *tmp107 :compute:zy                           ...
  816:  op add :compute:zy *tmp108 :compute:cy                       ...
  817:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  818:  jump *label77 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  819:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label77                                               ...
  820:  jump *label80 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  821:  jump *label80 greaterThanEq :compute:i 63                    ...
  822:  op log *tmp115 :compute:dist 0                               mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  823:  op mul *tmp116 *tmp115 0.36067376022224085                   ...
  824:  op log *tmp117 *tmp116 0                                     ...
  825:  op mul *tmp118 *tmp117 1.4426950408889634                    ...
  826:  op sub :compute:correction 4 *tmp118                         ...
  827:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label80                                               mandelbrot-compute.mnd: if SMOOTH and i < MAX_DEPTH then
  828:  set *tmp85 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label68                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  829:  jump *label85 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH then
  830:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  831:  jump *label86 equal *tmp85 63                                mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  832:  multijump .PALETTE 0 0                                       mandelbrot-compute.mnd: case PALETTE
        multilabel *label186                                         ...
        multilabel *label182                                         ...
  833:  op div *tmp159 *tmp85 63.75                                  mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  834:  op sub :drawPixel:r 1 *tmp159                                ...
  835:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  836:  jump *label86 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label183                                         ...
  837:  op sub *tmp125 32 *tmp85                                     mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  838:  op abs *tmp126 *tmp125 0                                     ...
  839:  op div *tmp128 *tmp126 36.42857142857143                     ...
  840:  op sub :drawPixel:r 1 *tmp128                                ...
  841:  op sub *tmp130 *tmp85 32                                     mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  842:  op abs *tmp131 *tmp130 0                                     ...
  843:  op div *tmp133 *tmp131 42.5                                  ...
  844:  op sub :drawPixel:g 0.9411764705882353 *tmp133               ...
  845:  op div *tmp138 *tmp126 63.75                                 mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  846:  op add :drawPixel:b 0.47058823529411764 *tmp138              ...
  847:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  848:  jump *label86 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label184                                         ...
  849:  op div *tmp142 *tmp85 0.175                                  mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  850:  op sin :drawPixel:r *tmp142 0                                ...
  851:  op cos :drawPixel:g *tmp142 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  852:  op sub *tmp147 *tmp85 32                                     mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  853:  op abs *tmp148 *tmp147 0                                     ...
  854:  op div *tmp150 *tmp148 63.75                                 ...
  855:  op add :drawPixel:b 0.39215686274509803 *tmp150              ...
  856:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  857:  jump *label86 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label185                                         ...
  858:  op div :drawPixel:r *tmp85 63.75                             mandelbrot-compute.mnd: r = 4 * iterations / 255;
  859:  op div :drawPixel:g *tmp85 170                               mandelbrot-compute.mnd: g = 1.5 * iterations / 255;
  860:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  861:  jump *label86 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label85                                               ...
  862:  read :drawPixel:color .memory *tmp85                         mandelbrot-compute.mnd: color = memory[iterations];
        label *label86                                               mandelbrot-compute.mnd: if SMOOTH then
  863:  jump *label96 lessThan .localBuffer 254                      mandelbrot-compute.mnd: if localBuffer >= 254 then
  864:  jump *label109 lessThanEq .localBuffer 0                     mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label136                                              ...
  865:  read *tmp169 .memory 68                                      ...
  866:  jump *label101 notEqual .stop *tmp169                        ...
  867:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  868:  sensor *tmp170 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  869:  jump *label105 equal *tmp170 false                           ...
  870:  sensor *tmp171 .display @bufferSize                          ...
  871:  op sub *tmp172 1024 *tmp171                                  ...
  872:  jump *label105 greaterThanEq .localBuffer *tmp172            ...
  873:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  874:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label105                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  875:  jump *label136 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label101                                              ...
        label *label96                                               mandelbrot-compute.mnd: if localBuffer >= 254 then
  876:  jump *label109 lessThanEq .localBuffer 0                     mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  877:  jump *label109 strictNotEqual :drawPixel:color .lastColor    ...
  878:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  879:  op add .localBuffer .localBuffer 1                           mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  880:  jump *label110 always 0 0                                    ...
        label *label109                                              ...
  881:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  882:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  883:  set .lastColor :drawPixel:color                              mandelbrot-compute.mnd: lastColor = color;
  884:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
        label *label110                                              mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  885:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  886:  sensor *tmp179 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  887:  jump *label114 equal *tmp179 false                           ...
  888:  sensor *tmp180 .display @bufferSize                          ...
  889:  op sub *tmp181 1024 *tmp180                                  ...
  890:  jump *label114 greaterThanEq .localBuffer *tmp181            ...
  891:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  892:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label114                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  893:  wait 0.006                              # 0.360 ticks for at mandelbrot-compute.mnd: atomic
  894:  read *tmp185 .memory 68                                      mandelbrot-compute.mnd: if stop != $STOP then
  895:  jump *label28 notEqual .stop *tmp185                         ...
  896:  read *tmp187 .memory 66                                      mandelbrot-compute.mnd: atomic
  897:  op add *tmp2 *tmp187 1                                       ...
  898:  write *tmp2 .memory 66                                       ...
  899:  read *tmp189 .memory 65                                      mandelbrot-compute.mnd: $ITERATIONS += iterations;
  900:  op add *tmp190 *tmp189 *tmp85                                ...
  901:  write *tmp190 .memory 65                # The last atomic bl ...
  902:  op add :i :i 1                                               mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
  903:  jump *label134 lessThan :i *tmp51                            ...
        label *label43                                               ...
  904:  select :multiple greaterThanEq :batch 1337.6 1 :multiple     mandelbrot-compute.mnd: if batch >= TOTAL_BATCHES * 0.475 then multiple = 1; end;
  905:  jump *label34 always 0 0                                     mandelbrot-compute.mnd: while true do
        label *label36                                               ...
  906:  jump *label28 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label137                                              ...
  907:  read *tmp195 .memory 68                                      ...
  908:  jump *label28 notEqual .stop *tmp195                         ...
  909:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  910:  sensor *tmp196 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  911:  jump *label129 equal *tmp196 false                           ...
  912:  sensor *tmp197 .display @bufferSize                          ...
  913:  op sub *tmp198 1024 *tmp197                                  ...
  914:  jump *label129 greaterThanEq .localBuffer *tmp198            ...
  915:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  916:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label129                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  917:  jump *label137 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
  918:  jump *label28 always 0 0                                     mandelbrot-compute.mnd: MainLoop:


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   727     1x    727,0  inline def compute(in x, in y)
    50     1x     50,0  <no function>
    45     1x     45,0  void adam5(in index, out x, out y, out dx, out dy)
    44     1x     44,0  inline void drawPixel(in x, in y, in dx, in dy, in iterations)
    24     3x      8,0  inline void tryFlush()
    22     1x     22,0  inline void findLinkedBlocks(in title, in message, in linkMap...)
     8     2x      4,0  inline void flush()
Runtime error at instruction #24: 'read *tmp26 .memory 67':
Execution step limit of 100,000 exceeded.

Performance: parsed in 317 ms, compiled in 277 ms, optimized in 1,863 ms, run in 91 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Display: large-logic-display
Memory: memory-bank
