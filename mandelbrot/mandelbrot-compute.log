   397 instructions before optimizations.
    41 instructions eliminated by Temp Variables Elimination (8 iterations).
     2 instructions eliminated by Case Expression Optimization.
    39 instructions eliminated by Dead Code Elimination (7 iterations).
     6 instructions eliminated by Jump Normalization (2 passes, 8 iterations).
    19 instructions eliminated by Condition Optimization (9 iterations).
    15 instructions eliminated by Single Step Elimination (2 passes, 10 iterations).
     4 instructions eliminated by Expression Optimization (2 passes, 5 iterations).
     3 instructions eliminated by Boolean Optimization (2 passes, 10 iterations).
       3 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by If Expression Optimization (5 iterations).
    52 instructions eliminated by Data Flow Optimization (6 passes, 24 iterations).
     3 loops improved by Loop Hoisting.
       3 loop conditions were partially rotated.
   741 instructions added by Loop Unrolling (12 iterations).
     4 loops unrolled by Loop Unrolling.
     2 instructions added by Function Inlining (12 iterations).
     2 function calls inlined by Function Inlining.
     9 instructions eliminated by Case Switching (12 iterations).
     2 case expressions converted to fast dispatch by Case Switching.
    69 instructions eliminated by Jump Straightening (2 passes, 10 iterations).
     8 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 passes, 3 iterations).
     7 instructions eliminated by Print Merging.
   870 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 766):
    Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity
  * Unroll iteration loop at *blocks:68:13                       size    -9, benefit     9375.0, efficiency   Infinity (-3 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:200:1 size    +6, benefit    25312.5, efficiency   4218.750
    Inline function call at mandelbrot-compute.mnd:95:13         size    +7, benefit     1875.0, efficiency    267.857
    Inline function call at mandelbrot-compute.mnd:182:9         size    +7, benefit    23437.5, efficiency   3348.214
    Fast-dispatch case at mandelbrot-compute.mnd:79:21           size    -8, benefit     6250.0, efficiency   Infinity
    Fast-dispatch case at mandelbrot-compute.mnd:152:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 769):
  * Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:200:1 size    +6, benefit    25312.5, efficiency   4218.750
    Inline function call at mandelbrot-compute.mnd:95:13         size    +7, benefit     1875.0, efficiency    267.857
    Inline function call at mandelbrot-compute.mnd:182:9         size    +7, benefit    23437.5, efficiency   3348.214
  o Fast-dispatch case at mandelbrot-compute.mnd:79:21           size    -8, benefit     6250.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:152:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 773):
  * Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity (-2 instructions)
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:200:1 size    +6, benefit    25312.5, efficiency   4218.750
    Inline function call at mandelbrot-compute.mnd:95:13         size    +7, benefit     1875.0, efficiency    267.857
    Inline function call at mandelbrot-compute.mnd:182:9         size    +7, benefit    23437.5, efficiency   3348.214
  o Fast-dispatch case at mandelbrot-compute.mnd:79:21           size    -8, benefit     6250.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:152:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 775):
  * Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:200:1 size    +6, benefit    25312.5, efficiency   4218.750 (+2 instructions)
    Inline function call at mandelbrot-compute.mnd:95:13         size    +7, benefit     1875.0, efficiency    267.857
    Inline function call at mandelbrot-compute.mnd:182:9         size    +7, benefit    23437.5, efficiency   3348.214
  o Fast-dispatch case at mandelbrot-compute.mnd:79:21           size    -8, benefit     6250.0, efficiency   Infinity
  o Fast-dispatch case at mandelbrot-compute.mnd:152:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 773):
  * Fast-dispatch case at mandelbrot-compute.mnd:79:21           size    -8, benefit     6250.0, efficiency   Infinity (-7 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:152:13          size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 780):
  * Fast-dispatch case at mandelbrot-compute.mnd:152:13          size    -2, benefit     3906.3, efficiency   Infinity (-2 instructions)

Pass 2: speed optimization selection (cost limit 790):
  * Unroll loop at mandelbrot-compute.mnd:125:5                  size  +679, benefit 49218750.0, efficiency  72487.113 (+743 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
   169 label *label41
   170 set *tmp45 null
   171 label *label42
-    * set *tmp47 :line
-    * jump *label46 lessThan *tmp47 0
-    * jump *label45 lessThan *tmp47 22
+  172 jump *label46 lessThan :line 0
+  173 jump *label45 lessThan :line 22
   174 label *label46
   175 jump *label44 always
   176 label *label45
 
   178 set *tmp46 *tmp48
   179 jump *label43 always
   180 label *label44
-    * jump *label49 lessThan *tmp47 22
-    * jump *label48 lessThan *tmp47 44
+  181 jump *label49 lessThan :line 22
+  182 jump *label48 lessThan :line 44
   183 label *label49
   184 jump *label47 always
   185 label *label48
 
   189 set *tmp46 *tmp51
   190 jump *label43 always
   191 label *label47
-    * jump *label52 lessThan *tmp47 44
-    * jump *label51 lessThan *tmp47 88
+  192 jump *label52 lessThan :line 44
+  193 jump *label51 lessThan :line 88
   194 label *label52
   195 jump *label50 always
   196 label *label51
 
   344 set *tmp101 :drawPixel:color
   345 jump *label78 always
   346 label *label77
-    * set *tmp103 .PALETTE
-    * jump *label81 equal *tmp103 2
+  347 jump *label81 equal .PALETTE 2
   348 jump *label80 always
   349 label *label81
   350 op sub *tmp104 32 :drawPixel:iterations
 
   370 set *tmp102 :drawPixel:color
   371 jump *label79 always
   372 label *label80
-    * jump *label83 equal *tmp103 3
+  373 jump *label83 equal .PALETTE 3
   374 jump *label82 always
   375 label *label83
   376 op div *tmp120 :drawPixel:iterations 63
 
   392 set *tmp102 :drawPixel:color
   393 jump *label79 always
   394 label *label82
-    * jump *label85 equal *tmp103 4
+  395 jump *label85 equal .PALETTE 4
   396 jump *label84 always
   397 label *label85
   398 op mul *tmp132 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-27 instructions):
 
    58 label *label21
    59 set *tmp19 null
    60 label *label22
-    * set *tmp17 *tmp19
    61 jump *label20 always
    62 label *label19
-    * set *tmp17 null
    63 label *label20
    64 label *label15
    65 multijump *tmp15 0 0 (m:marker1)
 
    91 print :findLinkedBlocks:variable
    92 jump *label28 equal :findLinkedBlocks:required false
    93 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * set *tmp21 :findLinkedBlocks:foundAll
    94 jump *label29 always
    95 label *label28
-    * set *tmp21 null
    96 label *label29
    97 label *label24
    98 multijump *tmp20 0 0 (m:marker2)
 
   147 op notEqual *tmp39 .stop *tmp40
   148 jump *label39 equal *tmp39 false
   149 jump *label38 always
-    * set *tmp41 null
   150 jump *label40 always
   151 label *label39
-    * set *tmp41 null
   152 label *label40
   153 read *tmp42 .memory 64
   154 set *tmp43 *tmp42
 
   158 op greaterThanEq *tmp44 :line 176
   159 jump *label41 equal *tmp44 false
   160 jump *label38 always
-    * set *tmp45 null
   161 jump *label42 always
   162 label *label41
-    * set *tmp45 null
   163 label *label42
   164 jump *label46 lessThan :line 0
   165 jump *label45 lessThan :line 22
 
   212 jump *label57 equal .JULIA false
   213 set :compute:cx .JULIA_X
   214 set :compute:cy .JULIA_Y
-    * set *tmp63 :compute:cy
   215 jump *label58 always
   216 label *label57
   217 set :compute:cx :compute:zx
 
   227 jump *label59 equal *tmp70 false
   228 set *tmp58 63
   229 jump *label56 always
-    * set *tmp71 null
   230 jump *label60 always
   231 label *label59
-    * set *tmp71 null
   232 label *label60
   233 op add *tmp72 :compute:cx 1
   234 op len *tmp73 *tmp72 :compute:cy
 
   241 label *label61
   242 set *tmp75 null
   243 label *label62
-    * set *tmp63 *tmp75
   244 label *label58
   245 set :compute:i 0
   246 label *label63
 
   261 op greaterThanEq *tmp84 :compute:dist 64
   262 jump *label66 equal *tmp84 false
   263 jump *label65 always
-    * set *tmp85 null
   264 jump *label67 always
   265 label *label66
-    * set *tmp85 null
   266 label *label67
   267 label *label64
   268 op add :compute:i :compute:i 1
 
   278 op sub *tmp93 4 *tmp92
   279 set :compute:correction *tmp93
   280 op add :compute:i :compute:i :compute:correction
-    * set *tmp88 :compute:i
   281 jump *label69 always
   282 label *label68
-    * set *tmp88 null
   283 label *label69
   284 set *tmp58 :compute:i
   285 jump *label56 always
 
   294 label *label70
   295 wait 0
   296 read *tmp94 .memory 65
-    * set *tmp95 *tmp94
   297 op add *tmp1 *tmp94 1
   298 write *tmp1 .memory 65
   299 read *tmp97 .memory 67
   300 op notEqual *tmp96 .stop *tmp97
   301 jump *label71 equal *tmp96 false
   302 jump *label31 always
-    * set *tmp98 null
   303 jump *label72 always
   304 label *label71
-    * set *tmp98 null
   305 label *label72
   306 label *label54
   307 op add :y :y 1
 
   398 label *label79
   399 set *tmp101 *tmp102
   400 label *label78
-    * set *tmp99 *tmp101
   401 jump *label76 always
   402 label *label75
   403 set *tmp142 :drawPixel:iterations
   404 read *tmp144 .memory *tmp142
   405 set :drawPixel:color *tmp144
-    * set *tmp99 :drawPixel:color
   406 label *label76
   407 op greaterThanEq *tmp145 .localBuffer 254
   408 jump *label86 equal *tmp145 false
   409 setaddr :flushLocalBuffer*retaddr *label88 (h:*label88)
   410 call *label1 *invalid :flushLocalBuffer*retval (m:*label88) (h:*label88)
   411 label *label88
-    * set *tmp146 null
   412 jump *label87 always
   413 label *label86
-    * set *tmp146 null
   414 label *label87
   415 draw col :drawPixel:color
   416 draw rect :drawPixel:x :drawPixel:y 1 1
 
   427 jump *label89 equal *tmp153 false
   428 drawflush .display
   429 set .localBuffer 0
-    * set *tmp154 .localBuffer
   430 jump *label90 always
   431 label *label89
   432 op div *tmp155 1800 .localBuffer
 
   439 label *label91
   440 set *tmp157 null
   441 label *label92
-    * set *tmp154 *tmp157
   442 label *label90
   443 label *label74
   444 return :drawPixel*retaddr
 
   459 op greaterThan *tmp163 *tmp162 250
   460 jump *label99 notEqual *tmp163 false
   461 label *label101
-    * set *tmp161 null
   462 jump *label98 always
   463 label *label97
-    * set *tmp161 null
   464 label *label98
   465 drawflush .display
   466 set .localBuffer 0

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-8 instructions):
 
    53 op equal *tmp18 :findLinkedBlocks:requested @message
    54 jump *label21 equal *tmp18 false
    55 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * set *tmp19 :findLinkedBlocks:message
    56 jump *label22 always
    57 label *label21
-    * set *tmp19 null
    58 label *label22
    59 jump *label20 always
    60 label *label19
 
   234 jump *label61 equal *tmp74 false
   235 set *tmp58 63
   236 jump *label56 always
-    * set *tmp75 null
   237 jump *label62 always
   238 label *label61
-    * set *tmp75 null
   239 label *label62
   240 label *label58
   241 set :compute:i 0
 
   318 op equal *tmp100 :drawPixel:iterations 63
   319 jump *label77 equal *tmp100 false
   320 set :drawPixel:color %[black]
-    * set *tmp101 :drawPixel:color
   321 jump *label78 always
   322 label *label77
   323 jump *label81 equal .PALETTE 2
 
   391 set :drawPixel:color *tmp141
   392 set *tmp102 :drawPixel:color
   393 label *label79
-    * set *tmp101 *tmp102
   394 label *label78
   395 jump *label76 always
   396 label *label75
 
   428 jump *label91 equal *tmp156 false
   429 drawflush .display
   430 set .localBuffer 0
-    * set *tmp157 .localBuffer
   431 jump *label92 always
   432 label *label91
-    * set *tmp157 null
   433 label *label92
   434 label *label90
   435 label *label74

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   343 set :drawPixel:b *tmp118
   344 packcolor *tmp119 :drawPixel:r :drawPixel:g :drawPixel:b 1
   345 set :drawPixel:color *tmp119
-    * set *tmp102 :drawPixel:color
   346 jump *label79 always
   347 label *label80
   348 jump *label83 equal .PALETTE 3
 
   364 set :drawPixel:b *tmp130
   365 packcolor *tmp131 :drawPixel:r :drawPixel:g :drawPixel:b 1
   366 set :drawPixel:color *tmp131
-    * set *tmp102 :drawPixel:color
   367 jump *label79 always
   368 label *label82
   369 jump *label85 equal .PALETTE 4
 
   378 set :drawPixel:g *tmp136
   379 packcolor *tmp137 :drawPixel:r :drawPixel:g 0 1
   380 set :drawPixel:color *tmp137
-    * set *tmp102 :drawPixel:color
   381 jump *label79 always
   382 label *label84
   383 op mul *tmp138 4 :drawPixel:iterations
 
   386 set :drawPixel:r *tmp140
   387 packcolor *tmp141 :drawPixel:r :drawPixel:r 0 1
   388 set :drawPixel:color *tmp141
-    * set *tmp102 :drawPixel:color
   389 label *label79
   390 label *label78
   391 jump *label76 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-41 instructions):
 
    27 op greaterThan *tmp12 :findLinkedBlocks:n 0
    28 jump *label13 equal *tmp12 false
    29 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
-    * getlink *tmp13 :findLinkedBlocks:n
-    * set :findLinkedBlocks:block *tmp13
+   30 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    31 print "\nFound: "
    32 print :findLinkedBlocks:block
-    * sensor *tmp14 :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:type *tmp14
+   33 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    34 set :findLinkedBlocks:requested @large-logic-display
    35 set :findLinkedBlocks:name "Display"
    36 set :findLinkedBlocks:variable .display
 
   112 op equal *tmp23 .start *tmp24
   113 jump *label33 notEqual *tmp23 false
   114 label *label35
-    * read *tmp25 .memory 66
-    * set .start *tmp25
-    * read *tmp26 .memory 67
-    * set .stop *tmp26
-    * read *tmp27 .memory 70
-    * set .ZOOM *tmp27
+  115 read .start .memory 66
+  116 read .stop .memory 67
+  117 read .ZOOM .memory 70
   118 op div *tmp28 -88 .ZOOM
   119 read *tmp30 .memory 68
-    * op add *tmp29 *tmp28 *tmp30
-    * set .OFFSET_X *tmp29
+  120 op add .OFFSET_X *tmp28 *tmp30
   121 op div *tmp31 -88 .ZOOM
   122 read *tmp33 .memory 69
-    * op add *tmp32 *tmp31 *tmp33
-    * set .OFFSET_Y *tmp32
-    * read *tmp34 .memory 71
-    * set .JULIA *tmp34
-    * read *tmp35 .memory 72
-    * set .JULIA_X *tmp35
-    * read *tmp36 .memory 73
-    * set .JULIA_Y *tmp36
-    * read *tmp37 .memory 74
-    * set .PALETTE *tmp37
-    * op greaterThan *tmp38 .PALETTE 1
-    * set .SMOOTH *tmp38
+  123 op add .OFFSET_Y *tmp31 *tmp33
+  124 read .JULIA .memory 71
+  125 read .JULIA_X .memory 72
+  126 read .JULIA_Y .memory 73
+  127 read .PALETTE .memory 74
+  128 op greaterThan .SMOOTH .PALETTE 1
   129 label *label36
   130 jump *label38 equal true false
   131 wait 0
 
   152 label *label46
   153 jump *label44 always
   154 label *label45
-    * op mul *tmp48 8 :line
-    * set *tmp46 *tmp48
+  155 op mul *tmp46 8 :line
   156 jump *label43 always
   157 label *label44
   158 jump *label49 lessThan :line 22
 
   162 label *label48
   163 op mul *tmp49 8 :line
   164 op sub *tmp50 *tmp49 176
-    * op add *tmp51 *tmp50 4
-    * set *tmp46 *tmp51
+  165 op add *tmp46 *tmp50 4
   166 jump *label43 always
   167 label *label47
   168 jump *label52 lessThan :line 44
 
   172 label *label51
   173 op mul *tmp52 4 :line
   174 op sub *tmp53 *tmp52 176
-    * op add *tmp54 *tmp53 2
-    * set *tmp46 *tmp54
+  175 op add *tmp46 *tmp53 2
   176 jump *label43 always
   177 label *label50
   178 op mul *tmp55 2 :line
   179 op sub *tmp56 *tmp55 176
-    * op add *tmp57 *tmp56 1
-    * set *tmp46 *tmp57
+  180 op add *tmp46 *tmp56 1
   181 label *label43
   182 set :x *tmp46
   183 set :y 0
 
   186 set :compute:x :x
   187 set :compute:y :y
   188 op div *tmp59 :compute:x .ZOOM
-    * op add *tmp60 *tmp59 .OFFSET_X
-    * set :compute:zx *tmp60
+  189 op add :compute:zx *tmp59 .OFFSET_X
   190 op div *tmp61 :compute:y .ZOOM
-    * op add *tmp62 *tmp61 .OFFSET_Y
-    * set :compute:zy *tmp62
+  191 op add :compute:zy *tmp61 .OFFSET_Y
   192 jump *label57 equal .JULIA false
   193 set :compute:cx .JULIA_X
   194 set :compute:cy .JULIA_Y
 
   197 set :compute:cx :compute:zx
   198 set :compute:cy :compute:zy
   199 op sub *tmp64 :compute:cx 0.25
-    * op len *tmp65 *tmp64 :compute:cy
-    * set :compute:p *tmp65
+  200 op len :compute:p *tmp64 :compute:cy
   201 op mul *tmp66 2 :compute:p
   202 op mul *tmp67 *tmp66 :compute:p
   203 op sub *tmp68 :compute:p *tmp67
 
   227 op mul *tmp76 :compute:x1 :compute:x1
   228 op mul *tmp77 :compute:y1 :compute:y1
   229 op sub *tmp78 *tmp76 *tmp77
-    * op add *tmp79 *tmp78 :compute:cx
-    * set :compute:zx *tmp79
+  230 op add :compute:zx *tmp78 :compute:cx
   231 op mul *tmp80 2 :compute:x1
   232 op mul *tmp81 *tmp80 :compute:y1
-    * op add *tmp82 *tmp81 :compute:cy
-    * set :compute:zy *tmp82
-    * op len *tmp83 :compute:zx :compute:zy
-    * set :compute:dist *tmp83
+  233 op add :compute:zy *tmp81 :compute:cy
+  234 op len :compute:dist :compute:zx :compute:zy
   235 op greaterThanEq *tmp84 :compute:dist 64
   236 jump *label66 equal *tmp84 false
   237 jump *label65 always
 
   249 op mul *tmp90 *tmp89 0.36067376022224085
   250 op log *tmp91 *tmp90
   251 op mul *tmp92 *tmp91 1.4426950408889634
-    * op sub *tmp93 4 *tmp92
-    * set :compute:correction *tmp93
+  252 op sub :compute:correction 4 *tmp92
   253 op add :compute:i :compute:i :compute:correction
   254 jump *label69 always
   255 label *label68
 
   304 op abs *tmp105 *tmp104
   305 op mul *tmp106 7 *tmp105
   306 op div *tmp107 *tmp106 255
-    * op sub *tmp108 1 *tmp107
-    * set :drawPixel:r *tmp108
+  307 op sub :drawPixel:r 1 *tmp107
   308 op sub *tmp109 :drawPixel:iterations 32
   309 op abs *tmp110 *tmp109
   310 op mul *tmp111 6 *tmp110
   311 op div *tmp112 *tmp111 255
-    * op sub *tmp113 0.9411764705882353 *tmp112
-    * set :drawPixel:g *tmp113
+  312 op sub :drawPixel:g 0.9411764705882353 *tmp112
   313 op sub *tmp114 32 :drawPixel:iterations
   314 op abs *tmp115 *tmp114
   315 op mul *tmp116 4 *tmp115
   316 op div *tmp117 *tmp116 255
-    * op add *tmp118 0.47058823529411764 *tmp117
-    * set :drawPixel:b *tmp118
-    * packcolor *tmp119 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp119
+  317 op add :drawPixel:b 0.47058823529411764 *tmp117
+  318 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   319 jump *label79 always
   320 label *label80
   321 jump *label83 equal .PALETTE 3
 
   323 label *label83
   324 op div *tmp120 :drawPixel:iterations 63
   325 op mul *tmp121 *tmp120 360
-    * op sin *tmp122 *tmp121
-    * set :drawPixel:r *tmp122
+  326 op sin :drawPixel:r *tmp121
   327 op div *tmp123 :drawPixel:iterations 63
   328 op mul *tmp124 *tmp123 360
-    * op cos *tmp125 *tmp124
-    * set :drawPixel:g *tmp125
+  329 op cos :drawPixel:g *tmp124
   330 op sub *tmp126 :drawPixel:iterations 32
   331 op abs *tmp127 *tmp126
   332 op mul *tmp128 4 *tmp127
   333 op div *tmp129 *tmp128 255
-    * op add *tmp130 0.39215686274509803 *tmp129
-    * set :drawPixel:b *tmp130
-    * packcolor *tmp131 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp131
+  334 op add :drawPixel:b 0.39215686274509803 *tmp129
+  335 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   336 jump *label79 always
   337 label *label82
   338 jump *label85 equal .PALETTE 4
   339 jump *label84 always
   340 label *label85
   341 op mul *tmp132 4 :drawPixel:iterations
-    * op div *tmp133 *tmp132 255
-    * set :drawPixel:r *tmp133
+  342 op div :drawPixel:r *tmp132 255
   343 op mul *tmp134 1.5 :drawPixel:iterations
   344 op div *tmp135 *tmp134 255
-    * op add *tmp136 96 *tmp135
-    * set :drawPixel:g *tmp136
-    * packcolor *tmp137 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp137
+  345 op add :drawPixel:g 96 *tmp135
+  346 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   347 jump *label79 always
   348 label *label84
   349 op mul *tmp138 4 :drawPixel:iterations
   350 op div *tmp139 *tmp138 255
-    * op sub *tmp140 1 *tmp139
-    * set :drawPixel:r *tmp140
-    * packcolor *tmp141 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp141
+  351 op sub :drawPixel:r 1 *tmp139
+  352 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   353 label *label79
   354 label *label78
   355 jump *label76 always
   356 label *label75
-    * set *tmp142 :drawPixel:iterations
-    * read *tmp144 .memory *tmp142
-    * set :drawPixel:color *tmp144
+  357 read :drawPixel:color .memory :drawPixel:iterations
   358 label *label76
   359 op greaterThanEq *tmp145 .localBuffer 254
   360 jump *label86 equal *tmp145 false
 
   367 draw col :drawPixel:color
   368 draw rect :drawPixel:x :drawPixel:y 1 1
   369 op add .localBuffer .localBuffer 2
-    * set *tmp147 .display
-    * sensor *tmp148 *tmp147 @enabled
-    * op sub *tmp149 1 *tmp148
-    * set :drawPixel:disabled *tmp149
+  370 sensor *tmp148 .display @enabled
+  371 op sub :drawPixel:disabled 1 *tmp148
   372 sensor *tmp150 .display @bufferSize
   373 op mul *tmp151 :drawPixel:disabled 900
-    * op add *tmp152 *tmp150 *tmp151
-    * set :drawPixel:usage *tmp152
+  374 op add :drawPixel:usage *tmp150 *tmp151
   375 op lessThan *tmp153 :drawPixel:usage 100
   376 jump *label89 equal *tmp153 false
   377 drawflush .display

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
   102 label *label5
   103 label *label2
   104 label *label30
-    * jump *label32 equal true false
   105 set .localBuffer 0
   106 drawflush null
   107 label *label33
 
   126 read .PALETTE .memory 74
   127 op greaterThan .SMOOTH .PALETTE 1
   128 label *label36
-    * jump *label38 equal true false
   129 wait 0
   130 read *tmp40 .memory 67
   131 op notEqual *tmp39 .stop *tmp40

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   295 set :drawPixel:color %[black]
   296 jump *label78 always
   297 label *label77
-    * jump *label81 equal .PALETTE 2
-    * jump *label80 always
+  298 jump *label80 notEqual .PALETTE 2
   299 label *label81
   300 op sub *tmp104 32 :drawPixel:iterations
   301 op abs *tmp105 *tmp104
 
   315 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   316 jump *label79 always
   317 label *label80
-    * jump *label83 equal .PALETTE 3
-    * jump *label82 always
+  318 jump *label82 notEqual .PALETTE 3
   319 label *label83
   320 op div *tmp120 :drawPixel:iterations 63
   321 op mul *tmp121 *tmp120 360
 
   331 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   332 jump *label79 always
   333 label *label82
-    * jump *label85 equal .PALETTE 4
-    * jump *label84 always
+  334 jump *label84 notEqual .PALETTE 4
   335 label *label85
   336 op mul *tmp132 4 :drawPixel:iterations
   337 op div :drawPixel:r *tmp132 255

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-19 instructions):
 
    24 print :findLinkedBlocks:title
    25 set :findLinkedBlocks:n @links
    26 label *label11
-    * op greaterThan *tmp12 :findLinkedBlocks:n 0
-    * jump *label13 equal *tmp12 false
+   27 jump *label13 lessThanEq :findLinkedBlocks:n 0
    28 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    29 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    30 print "\nFound: "
 
    44 set :findLinkedBlocks:required true
    45 setaddr *tmp15 *label18
    46 label *label14
-    * op equal *tmp16 :findLinkedBlocks:requested :findLinkedBlocks:type
-    * jump *label19 equal *tmp16 false
+   47 jump *label19 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * op equal *tmp18 :findLinkedBlocks:requested @message
-    * jump *label21 equal *tmp18 false
+   49 jump *label21 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
    51 jump *label22 always
    52 label *label21
 
    94 label *label25
    95 printflush :findLinkedBlocks:message
    96 label *label4
-    * op equal *tmp22 :findLinkedBlocks:foundAll false
-    * jump *label3 notEqual *tmp22 false
+   97 jump *label3 equal :findLinkedBlocks:foundAll false
    98 label *label5
    99 label *label2
   100 label *label30
 
   104 wait 0
   105 label *label34
   106 read *tmp24 .memory 66
-    * op equal *tmp23 .start *tmp24
-    * jump *label33 notEqual *tmp23 false
+  107 jump *label33 equal .start *tmp24
   108 label *label35
   109 read .start .memory 66
   110 read .stop .memory 67
 
   123 label *label36
   124 wait 0
   125 read *tmp40 .memory 67
-    * op notEqual *tmp39 .stop *tmp40
-    * jump *label39 equal *tmp39 false
+  126 jump *label39 equal .stop *tmp40
   127 jump *label38 always
   128 jump *label40 always
   129 label *label39
 
   133 op add *tmp0 *tmp42 1
   134 write *tmp0 .memory 64
   135 set :line *tmp43
-    * op greaterThanEq *tmp44 :line 176
-    * jump *label41 equal *tmp44 false
+  136 jump *label41 lessThan :line 176
   137 jump *label38 always
   138 jump *label42 always
   139 label *label41
 
   193 op mul *tmp67 *tmp66 :compute:p
   194 op sub *tmp68 :compute:p *tmp67
   195 op add *tmp69 *tmp68 0.25
-    * op lessThanEq *tmp70 :compute:cx *tmp69
-    * jump *label59 equal *tmp70 false
+  196 jump *label59 greaterThan :compute:cx *tmp69
   197 set *tmp58 63
   198 jump *label56 always
   199 jump *label60 always
 
   201 label *label60
   202 op add *tmp72 :compute:cx 1
   203 op len *tmp73 *tmp72 :compute:cy
-    * op lessThanEq *tmp74 *tmp73 0.25
-    * jump *label61 equal *tmp74 false
+  204 jump *label61 greaterThan *tmp73 0.25
   205 set *tmp58 63
   206 jump *label56 always
   207 jump *label62 always
 
   221 op mul *tmp81 *tmp80 :compute:y1
   222 op add :compute:zy *tmp81 :compute:cy
   223 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp84 :compute:dist 64
-    * jump *label66 equal *tmp84 false
+  224 jump *label66 lessThan :compute:dist 64
   225 jump *label65 always
   226 jump *label67 always
   227 label *label66
 
   231 jump *label63 always
   232 label *label65
   233 op mul *tmp86 .SMOOTH 63
-    * op lessThan *tmp87 :compute:i *tmp86
-    * jump *label68 equal *tmp87 false
+  234 jump *label68 greaterThanEq :compute:i *tmp86
   235 op log *tmp89 :compute:dist
   236 op mul *tmp90 *tmp89 0.36067376022224085
   237 op log *tmp91 *tmp90
 
   257 op add *tmp1 *tmp94 1
   258 write *tmp1 .memory 65
   259 read *tmp97 .memory 67
-    * op notEqual *tmp96 .stop *tmp97
-    * jump *label71 equal *tmp96 false
+  260 jump *label71 equal .stop *tmp97
   261 jump *label31 always
   262 jump *label72 always
   263 label *label71
 
   278 end
   279 label *label0
   280 jump *label75 equal .SMOOTH false
-    * op equal *tmp100 :drawPixel:iterations 63
-    * jump *label77 equal *tmp100 false
+  281 jump *label77 notEqual :drawPixel:iterations 63
   282 set :drawPixel:color %[black]
   283 jump *label78 always
   284 label *label77
 
   338 label *label75
   339 read :drawPixel:color .memory :drawPixel:iterations
   340 label *label76
-    * op greaterThanEq *tmp145 .localBuffer 254
-    * jump *label86 equal *tmp145 false
+  341 jump *label86 lessThan .localBuffer 254
   342 setaddr :flushLocalBuffer*retaddr *label88 (h:*label88)
   343 call *label1 *invalid :flushLocalBuffer*retval (m:*label88) (h:*label88)
   344 label *label88
 
   353 sensor *tmp150 .display @bufferSize
   354 op mul *tmp151 :drawPixel:disabled 900
   355 op add :drawPixel:usage *tmp150 *tmp151
-    * op lessThan *tmp153 :drawPixel:usage 100
-    * jump *label89 equal *tmp153 false
+  356 jump *label89 greaterThanEq :drawPixel:usage 100
   357 drawflush .display
   358 set .localBuffer 0
   359 jump *label90 always
   360 label *label89
   361 op div *tmp155 1800 .localBuffer
-    * op lessThan *tmp156 :drawPixel:usage *tmp155
-    * jump *label91 equal *tmp156 false
+  362 jump *label91 greaterThanEq :drawPixel:usage *tmp155
   363 drawflush .display
   364 set .localBuffer 0
   365 jump *label92 always
 
   373 label *label94
   374 label *label95
   375 sensor *tmp158 .display @enabled
-    * op equal *tmp159 *tmp158 false
-    * jump *label94 notEqual *tmp159 false
+  376 jump *label94 equal *tmp158 false
   377 label *label96
-    * op greaterThan *tmp160 .localBuffer 4
-    * jump *label97 equal *tmp160 false
+  378 jump *label97 lessThanEq .localBuffer 4
   379 label *label99
   380 wait 0.0001
   381 label *label100
   382 sensor *tmp162 .display @bufferSize
-    * op greaterThan *tmp163 *tmp162 250
-    * jump *label99 notEqual *tmp163 false
+  383 jump *label99 greaterThan *tmp162 250
   384 label *label101
   385 jump *label98 always
   386 label *label97

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-13 instructions):
 
    48 set :findLinkedBlocks:variable :findLinkedBlocks:block
    49 jump *label21 notEqual :findLinkedBlocks:requested @message
    50 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * jump *label22 always
    51 label *label21
    52 label *label22
-    * jump *label20 always
    53 label *label19
    54 label *label20
    55 label *label15
 
    82 print :findLinkedBlocks:variable
    83 jump *label28 equal :findLinkedBlocks:required false
    84 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * jump *label29 always
    85 label *label28
    86 label *label29
    87 label *label24
 
   122 read *tmp40 .memory 67
   123 jump *label39 equal .stop *tmp40
   124 jump *label38 always
-    * jump *label40 always
   125 label *label39
   126 label *label40
   127 read *tmp42 .memory 64
 
   131 set :line *tmp43
   132 jump *label41 lessThan :line 176
   133 jump *label38 always
-    * jump *label42 always
   134 label *label41
   135 label *label42
   136 jump *label46 lessThan :line 0
 
   191 jump *label59 greaterThan :compute:cx *tmp69
   192 set *tmp58 63
   193 jump *label56 always
-    * jump *label60 always
   194 label *label59
   195 label *label60
   196 op add *tmp72 :compute:cx 1
 
   198 jump *label61 greaterThan *tmp73 0.25
   199 set *tmp58 63
   200 jump *label56 always
-    * jump *label62 always
   201 label *label61
   202 label *label62
   203 label *label58
 
   216 op len :compute:dist :compute:zx :compute:zy
   217 jump *label66 lessThan :compute:dist 64
   218 jump *label65 always
-    * jump *label67 always
   219 label *label66
   220 label *label67
   221 label *label64
 
   230 op mul *tmp92 *tmp91 1.4426950408889634
   231 op sub :compute:correction 4 *tmp92
   232 op add :compute:i :compute:i :compute:correction
-    * jump *label69 always
   233 label *label68
   234 label *label69
   235 set *tmp58 :compute:i
 
   250 read *tmp97 .memory 67
   251 jump *label71 equal .stop *tmp97
   252 jump *label31 always
-    * jump *label72 always
   253 label *label71
   254 label *label72
   255 label *label54
 
   332 setaddr :flushLocalBuffer*retaddr *label88 (h:*label88)
   333 call *label1 *invalid :flushLocalBuffer*retval (m:*label88) (h:*label88)
   334 label *label88
-    * jump *label87 always
   335 label *label86
   336 label *label87
   337 draw col :drawPixel:color
 
   351 jump *label91 greaterThanEq :drawPixel:usage *tmp155
   352 drawflush .display
   353 set .localBuffer 0
-    * jump *label92 always
   354 label *label91
   355 label *label92
   356 label *label90
 
   370 sensor *tmp162 .display @bufferSize
   371 jump *label99 greaterThan *tmp162 250
   372 label *label101
-    * jump *label98 always
   373 label *label97
   374 label *label98
   375 drawflush .display

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     1 set :findLinkedBlocks:title "Mandelbrot Generator"
     2 set :findLinkedBlocks:message null
     3 label *label3
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
     4 setaddr *tmp11 *label9
     5 jump *label6 always
     6 multilabel *label9 (m:marker0)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
+    7 set .display null
     8 setaddr *tmp11 *label10
     9 label *label6
    10 set :findLinkedBlocks:variable null
    11 label *label7
    12 multijump *tmp11 0 0 (m:marker0)
    13 multilabel *label10 (m:marker0)
-    * set .memory :findLinkedBlocks:variable
+   14 set .memory null
    15 label *label8
-    * print :findLinkedBlocks:title
+   16 print "Mandelbrot Generator"
    17 set :findLinkedBlocks:n @links
    18 label *label11
    19 jump *label13 lessThanEq :findLinkedBlocks:n 0
 
    23 print :findLinkedBlocks:block
    24 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    25 set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
    26 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    27 setaddr *tmp15 *label17
    28 jump *label14 always
    29 multilabel *label17 (m:marker1)
    30 set .display :findLinkedBlocks:variable
    31 set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
    32 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    33 setaddr *tmp15 *label18
    34 label *label14
    35 jump *label19 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
 
    49 jump *label11 always
    50 label *label13
    51 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:requested @large-logic-display
    52 set :findLinkedBlocks:name "Display"
    53 set :findLinkedBlocks:variable .display
    54 set :findLinkedBlocks:required true
 
    56 jump *label23 always
    57 multilabel *label26 (m:marker2)
    58 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    59 set :findLinkedBlocks:name "Memory"
    60 set :findLinkedBlocks:variable .memory
    61 set :findLinkedBlocks:required true
 
    66 print ":"
    67 print " "
    68 print :findLinkedBlocks:variable
-    * jump *label28 equal :findLinkedBlocks:required false
+   69 jump *label28 equal true false
    70 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
    71 label *label28
    72 label *label29
 
    97 op add .OFFSET_X *tmp28 *tmp30
    98 op div *tmp31 -88 .ZOOM
    99 read *tmp33 .memory 69
-    * op add .OFFSET_Y *tmp31 *tmp33
+  100 op add .OFFSET_Y *tmp28 *tmp33
   101 read .JULIA .memory 71
   102 read .JULIA_X .memory 72
   103 read .JULIA_Y .memory 73
 
   114 set *tmp43 *tmp42
   115 op add *tmp0 *tmp42 1
   116 write *tmp0 .memory 64
-    * set :line *tmp43
-    * jump *label41 lessThan :line 176
+  117 set :line *tmp42
+  118 jump *label41 lessThan *tmp43 176
   119 jump *label38 always
   120 label *label41
   121 label *label42
-    * jump *label46 lessThan :line 0
-    * jump *label45 lessThan :line 22
+  122 jump *label46 lessThan *tmp43 0
+  123 jump *label45 lessThan *tmp43 22
   124 label *label46
   125 jump *label44 always
   126 label *label45
-    * op mul *tmp46 8 :line
+  127 op mul *tmp46 8 *tmp43
   128 jump *label43 always
   129 label *label44
-    * jump *label49 lessThan :line 22
-    * jump *label48 lessThan :line 44
+  130 jump *label49 lessThan *tmp43 22
+  131 jump *label48 lessThan *tmp43 44
   132 label *label49
   133 jump *label47 always
   134 label *label48
-    * op mul *tmp49 8 :line
+  135 op mul *tmp49 8 *tmp43
   136 op sub *tmp50 *tmp49 176
-    * op add *tmp46 *tmp50 4
+  137 op sub *tmp46 *tmp49 172
   138 jump *label43 always
   139 label *label47
-    * jump *label52 lessThan :line 44
-    * jump *label51 lessThan :line 88
+  140 jump *label52 lessThan *tmp43 44
+  141 jump *label51 lessThan *tmp43 88
   142 label *label52
   143 jump *label50 always
   144 label *label51
-    * op mul *tmp52 4 :line
+  145 op mul *tmp52 4 *tmp43
   146 op sub *tmp53 *tmp52 176
-    * op add *tmp46 *tmp53 2
+  147 op sub *tmp46 *tmp52 174
   148 jump *label43 always
   149 label *label50
-    * op mul *tmp55 2 :line
+  150 op mul *tmp55 2 *tmp43
   151 op sub *tmp56 *tmp55 176
-    * op add *tmp46 *tmp56 1
+  152 op sub *tmp46 *tmp55 175
   153 label *label43
   154 set :x *tmp46
   155 set :y 0
   156 label *label53
   157 jump *label55 greaterThanEq :y 176
-    * set :compute:x :x
+  158 set :compute:x *tmp46
   159 set :compute:y :y
-    * op div *tmp59 :compute:x .ZOOM
+  160 op div *tmp59 :x .ZOOM
   161 op add :compute:zx *tmp59 .OFFSET_X
-    * op div *tmp61 :compute:y .ZOOM
+  162 op div *tmp61 :y .ZOOM
   163 op add :compute:zy *tmp61 .OFFSET_Y
   164 jump *label57 equal .JULIA false
   165 set :compute:cx .JULIA_X
 
   168 label *label57
   169 set :compute:cx :compute:zx
   170 set :compute:cy :compute:zy
-    * op sub *tmp64 :compute:cx 0.25
-    * op len :compute:p *tmp64 :compute:cy
+  171 op sub *tmp64 :compute:zx 0.25
+  172 op len :compute:p *tmp64 :compute:zy
   173 op mul *tmp66 2 :compute:p
   174 op mul *tmp67 *tmp66 :compute:p
   175 op sub *tmp68 :compute:p *tmp67
   176 op add *tmp69 *tmp68 0.25
-    * jump *label59 greaterThan :compute:cx *tmp69
+  177 jump *label59 greaterThan :compute:zx *tmp69
   178 set *tmp58 63
   179 jump *label56 always
   180 label *label59
   181 label *label60
-    * op add *tmp72 :compute:cx 1
-    * op len *tmp73 *tmp72 :compute:cy
+  182 op add *tmp72 :compute:zx 1
+  183 op len *tmp73 *tmp72 :compute:zy
   184 jump *label61 greaterThan *tmp73 0.25
   185 set *tmp58 63
   186 jump *label56 always
 
   192 jump *label65 greaterThanEq :compute:i 63
   193 set :compute:x1 :compute:zx
   194 set :compute:y1 :compute:zy
-    * op mul *tmp76 :compute:x1 :compute:x1
-    * op mul *tmp77 :compute:y1 :compute:y1
+  195 op mul *tmp76 :compute:zx :compute:zx
+  196 op mul *tmp77 :compute:zy :compute:zy
   197 op sub *tmp78 *tmp76 *tmp77
   198 op add :compute:zx *tmp78 :compute:cx
   199 op mul *tmp80 2 :compute:x1
-    * op mul *tmp81 *tmp80 :compute:y1
+  200 op mul *tmp81 *tmp80 :compute:zy
   201 op add :compute:zy *tmp81 :compute:cy
   202 op len :compute:dist :compute:zx :compute:zy
   203 jump *label66 lessThan :compute:dist 64
 
   220 label *label69
   221 set *tmp58 :compute:i
   222 jump *label56 always
-    * set *tmp58 null
   223 label *label56
   224 set :iterations *tmp58
-    * set :drawPixel:x :x
+  225 set :drawPixel:x *tmp46
   226 set :drawPixel:y :y
-    * set :drawPixel:iterations :iterations
+  227 set :drawPixel:iterations *tmp58
   228 setaddr :drawPixel*retaddr *label70 (h:*label70)
   229 call *label0 *invalid :drawPixel*retval (m:*label70) (h:*label70)
   230 label *label70
 
   262 op sub *tmp104 32 :drawPixel:iterations
   263 op abs *tmp105 *tmp104
   264 op mul *tmp106 7 *tmp105
-    * op div *tmp107 *tmp106 255
+  265 op div *tmp107 *tmp105 36.42857142857143
   266 op sub :drawPixel:r 1 *tmp107
   267 op sub *tmp109 :drawPixel:iterations 32
   268 op abs *tmp110 *tmp109
   269 op mul *tmp111 6 *tmp110
-    * op div *tmp112 *tmp111 255
+  270 op div *tmp112 *tmp110 42.5
   271 op sub :drawPixel:g 0.9411764705882353 *tmp112
   272 op sub *tmp114 32 :drawPixel:iterations
-    * op abs *tmp115 *tmp114
-    * op mul *tmp116 4 *tmp115
-    * op div *tmp117 *tmp116 255
+  273 op abs *tmp115 *tmp104
+  274 op mul *tmp116 4 *tmp105
+  275 op div *tmp117 *tmp115 63.75
   276 op add :drawPixel:b 0.47058823529411764 *tmp117
   277 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   278 jump *label79 always
 
   280 jump *label82 notEqual .PALETTE 3
   281 label *label83
   282 op div *tmp120 :drawPixel:iterations 63
-    * op mul *tmp121 *tmp120 360
+  283 op div *tmp121 :drawPixel:iterations 0.175
   284 op sin :drawPixel:r *tmp121
   285 op div *tmp123 :drawPixel:iterations 63
-    * op mul *tmp124 *tmp123 360
-    * op cos :drawPixel:g *tmp124
+  286 op mul *tmp124 *tmp120 360
+  287 op cos :drawPixel:g *tmp121
   288 op sub *tmp126 :drawPixel:iterations 32
   289 op abs *tmp127 *tmp126
   290 op mul *tmp128 4 *tmp127
-    * op div *tmp129 *tmp128 255
+  291 op div *tmp129 *tmp127 63.75
   292 op add :drawPixel:b 0.39215686274509803 *tmp129
   293 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   294 jump *label79 always
 
   296 jump *label84 notEqual .PALETTE 4
   297 label *label85
   298 op mul *tmp132 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp132 255
+  299 op div :drawPixel:r :drawPixel:iterations 63.75
   300 op mul *tmp134 1.5 :drawPixel:iterations
-    * op div *tmp135 *tmp134 255
+  301 op div *tmp135 :drawPixel:iterations 170
   302 op add :drawPixel:g 96 *tmp135
   303 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   304 jump *label79 always
   305 label *label84
   306 op mul *tmp138 4 :drawPixel:iterations
-    * op div *tmp139 *tmp138 255
+  307 op div *tmp139 :drawPixel:iterations 63.75
   308 op sub :drawPixel:r 1 *tmp139
   309 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   310 label *label79

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-22 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:title "Mandelbrot Generator"
     1 set :findLinkedBlocks:message null
     2 label *label3
     3 setaddr *tmp11 *label9
 
     6 set .display null
     7 setaddr *tmp11 *label10
     8 label *label6
-    * set :findLinkedBlocks:variable null
     9 label *label7
    10 multijump *tmp11 0 0 (m:marker0)
    11 multilabel *label10 (m:marker0)
 
    49 set :findLinkedBlocks:foundAll 1
    50 set :findLinkedBlocks:name "Display"
    51 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    52 setaddr *tmp20 *label26
    53 jump *label23 always
    54 multilabel *label26 (m:marker2)
    55 set .display :findLinkedBlocks:variable
    56 set :findLinkedBlocks:name "Memory"
    57 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    58 setaddr *tmp20 *label27
    59 label *label23
    60 print "\n"
 
    91 op div *tmp28 -88 .ZOOM
    92 read *tmp30 .memory 68
    93 op add .OFFSET_X *tmp28 *tmp30
-    * op div *tmp31 -88 .ZOOM
    94 read *tmp33 .memory 69
    95 op add .OFFSET_Y *tmp28 *tmp33
    96 read .JULIA .memory 71
 
   109 set *tmp43 *tmp42
   110 op add *tmp0 *tmp42 1
   111 write *tmp0 .memory 64
-    * set :line *tmp42
-    * jump *label41 lessThan *tmp43 176
+  112 jump *label41 lessThan *tmp42 176
   113 jump *label38 always
   114 label *label41
   115 label *label42
-    * jump *label46 lessThan *tmp43 0
-    * jump *label45 lessThan *tmp43 22
+  116 jump *label46 lessThan *tmp42 0
+  117 jump *label45 lessThan *tmp42 22
   118 label *label46
   119 jump *label44 always
   120 label *label45
-    * op mul *tmp46 8 *tmp43
+  121 op mul *tmp46 8 *tmp42
   122 jump *label43 always
   123 label *label44
-    * jump *label49 lessThan *tmp43 22
-    * jump *label48 lessThan *tmp43 44
+  124 jump *label49 lessThan *tmp42 22
+  125 jump *label48 lessThan *tmp42 44
   126 label *label49
   127 jump *label47 always
   128 label *label48
-    * op mul *tmp49 8 *tmp43
-    * op sub *tmp50 *tmp49 176
+  129 op mul *tmp49 8 *tmp42
   130 op sub *tmp46 *tmp49 172
   131 jump *label43 always
   132 label *label47
-    * jump *label52 lessThan *tmp43 44
-    * jump *label51 lessThan *tmp43 88
+  133 jump *label52 lessThan *tmp42 44
+  134 jump *label51 lessThan *tmp42 88
   135 label *label52
   136 jump *label50 always
   137 label *label51
-    * op mul *tmp52 4 *tmp43
-    * op sub *tmp53 *tmp52 176
+  138 op mul *tmp52 4 *tmp42
   139 op sub *tmp46 *tmp52 174
   140 jump *label43 always
   141 label *label50
-    * op mul *tmp55 2 *tmp43
-    * op sub *tmp56 *tmp55 176
+  142 op mul *tmp55 2 *tmp42
   143 op sub *tmp46 *tmp55 175
   144 label *label43
   145 set :x *tmp46
   146 set :y 0
   147 label *label53
   148 jump *label55 greaterThanEq :y 176
-    * set :compute:x *tmp46
-    * set :compute:y :y
-    * op div *tmp59 :x .ZOOM
+  149 op div *tmp59 *tmp46 .ZOOM
   150 op add :compute:zx *tmp59 .OFFSET_X
   151 op div *tmp61 :y .ZOOM
   152 op add :compute:zy *tmp61 .OFFSET_Y
 
   180 label *label63
   181 jump *label65 greaterThanEq :compute:i 63
   182 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   183 op mul *tmp76 :compute:zx :compute:zx
   184 op mul *tmp77 :compute:zy :compute:zy
   185 op sub *tmp78 *tmp76 *tmp77
 
   209 set *tmp58 :compute:i
   210 jump *label56 always
   211 label *label56
-    * set :iterations *tmp58
   212 set :drawPixel:x *tmp46
   213 set :drawPixel:y :y
   214 set :drawPixel:iterations *tmp58
 
   248 label *label81
   249 op sub *tmp104 32 :drawPixel:iterations
   250 op abs *tmp105 *tmp104
-    * op mul *tmp106 7 *tmp105
   251 op div *tmp107 *tmp105 36.42857142857143
   252 op sub :drawPixel:r 1 *tmp107
   253 op sub *tmp109 :drawPixel:iterations 32
   254 op abs *tmp110 *tmp109
-    * op mul *tmp111 6 *tmp110
   255 op div *tmp112 *tmp110 42.5
   256 op sub :drawPixel:g 0.9411764705882353 *tmp112
-    * op sub *tmp114 32 :drawPixel:iterations
   257 op abs *tmp115 *tmp104
-    * op mul *tmp116 4 *tmp105
-    * op div *tmp117 *tmp115 63.75
+  258 op div *tmp117 *tmp105 63.75
   259 op add :drawPixel:b 0.47058823529411764 *tmp117
   260 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   261 jump *label79 always
 
   265 op div *tmp120 :drawPixel:iterations 63
   266 op div *tmp121 :drawPixel:iterations 0.175
   267 op sin :drawPixel:r *tmp121
-    * op div *tmp123 :drawPixel:iterations 63
-    * op mul *tmp124 *tmp120 360
+  268 op div *tmp124 :drawPixel:iterations 0.175
   269 op cos :drawPixel:g *tmp121
   270 op sub *tmp126 :drawPixel:iterations 32
   271 op abs *tmp127 *tmp126
-    * op mul *tmp128 4 *tmp127
   272 op div *tmp129 *tmp127 63.75
   273 op add :drawPixel:b 0.39215686274509803 *tmp129
   274 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   276 label *label82
   277 jump *label84 notEqual .PALETTE 4
   278 label *label85
-    * op mul *tmp132 4 :drawPixel:iterations
   279 op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp134 1.5 :drawPixel:iterations
   280 op div *tmp135 :drawPixel:iterations 170
   281 op add :drawPixel:g 96 *tmp135
   282 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   283 jump *label79 always
   284 label *label84
-    * op mul *tmp138 4 :drawPixel:iterations
   285 op div *tmp139 :drawPixel:iterations 63.75
   286 op sub :drawPixel:r 1 *tmp139
   287 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-5 instructions):
 
   106 label *label39
   107 label *label40
   108 read *tmp42 .memory 64
-    * set *tmp43 *tmp42
   109 op add *tmp0 *tmp42 1
   110 write *tmp0 .memory 64
   111 jump *label41 lessThan *tmp42 176
 
   141 op mul *tmp55 2 *tmp42
   142 op sub *tmp46 *tmp55 175
   143 label *label43
-    * set :x *tmp46
   144 set :y 0
   145 label *label53
   146 jump *label55 greaterThanEq :y 176
 
   252 op abs *tmp110 *tmp109
   253 op div *tmp112 *tmp110 42.5
   254 op sub :drawPixel:g 0.9411764705882353 *tmp112
-    * op abs *tmp115 *tmp104
   255 op div *tmp117 *tmp105 63.75
   256 op add :drawPixel:b 0.47058823529411764 *tmp117
   257 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   259 label *label80
   260 jump *label82 notEqual .PALETTE 3
   261 label *label83
-    * op div *tmp120 :drawPixel:iterations 63
   262 op div *tmp121 :drawPixel:iterations 0.175
   263 op sin :drawPixel:r *tmp121
-    * op div *tmp124 :drawPixel:iterations 0.175
   264 op cos :drawPixel:g *tmp121
   265 op sub *tmp126 :drawPixel:iterations 32
   266 op abs *tmp127 *tmp126

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
   142 op sub *tmp46 *tmp55 175
   143 label *label43
   144 set :y 0
+  145 set :drawPixel:x *tmp46
+  146 setaddr :drawPixel*retaddr *label70 (h:*label70)
   147 label *label53
   148 jump *label55 greaterThanEq :y 176
   149 op div *tmp59 *tmp46 .ZOOM
 
   209 set *tmp58 :compute:i
   210 jump *label56 always
   211 label *label56
-    * set :drawPixel:x *tmp46
   212 set :drawPixel:y :y
   213 set :drawPixel:iterations *tmp58
-    * setaddr :drawPixel*retaddr *label70 (h:*label70)
   214 call *label0 *invalid :drawPixel*retval (m:*label70) (h:*label70)
   215 label *label70
   216 wait 0

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 2:
 
    98 read .JULIA_Y .memory 73
    99 read .PALETTE .memory 74
   100 op greaterThan .SMOOTH .PALETTE 1
+  101 setaddr :drawPixel*retaddr *label70 (h:*label70)
   102 label *label36
   103 wait 0
   104 read *tmp40 .memory 67
 
   144 label *label43
   145 set :y 0
   146 set :drawPixel:x *tmp46
-    * setaddr :drawPixel*retaddr *label70 (h:*label70)
   147 label *label53
   148 jump *label55 greaterThanEq :y 176
   149 op div *tmp59 *tmp46 .ZOOM

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 3:
 
    76 jump *label3 equal :findLinkedBlocks:foundAll false
    77 label *label5
    78 label *label2
+   79 setaddr :drawPixel*retaddr *label70 (h:*label70)
    80 label *label30
    81 set .localBuffer 0
    82 drawflush null
 
    99 read .JULIA_Y .memory 73
   100 read .PALETTE .memory 74
   101 op greaterThan .SMOOTH .PALETTE 1
-    * setaddr :drawPixel*retaddr *label70 (h:*label70)
   102 label *label36
   103 wait 0
   104 read *tmp40 .memory 67

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
    15 set :findLinkedBlocks:n @links
    16 label *label11
    17 jump *label13 lessThanEq :findLinkedBlocks:n 0
+   18 label *label102
    19 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    20 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    21 print "\nFound: "
 
    45 set .memory :findLinkedBlocks:variable
    46 label *label16
    47 label *label12
-    * jump *label11 always
+   48 jump *label102 greaterThan :findLinkedBlocks:n 0
    49 label *label13
    50 set :findLinkedBlocks:foundAll 1
    51 set :findLinkedBlocks:name "Display"
 
   147 set :drawPixel:x *tmp46
   148 label *label53
   149 jump *label55 greaterThanEq :y 176
+  150 label *label103
   151 op div *tmp59 *tmp46 .ZOOM
   152 op add :compute:zx *tmp59 .OFFSET_X
   153 op div *tmp61 :y .ZOOM
 
   181 set :compute:i 0
   182 label *label63
   183 jump *label65 greaterThanEq :compute:i 63
+  184 label *label104
   185 set :compute:x1 :compute:zx
   186 op mul *tmp76 :compute:zx :compute:zx
   187 op mul *tmp77 :compute:zy :compute:zy
 
   197 label *label67
   198 label *label64
   199 op add :compute:i :compute:i 1
-    * jump *label63 always
+  200 jump *label104 lessThan :compute:i 63
   201 label *label65
   202 op mul *tmp86 .SMOOTH 63
   203 jump *label68 greaterThanEq :compute:i *tmp86
 
   227 label *label72
   228 label *label54
   229 op add :y :y 1
-    * jump *label53 always
+  230 jump *label103 lessThan :y 176
   231 label *label55
   232 setaddr :flushLocalBuffer*retaddr *label73 (h:*label73)
   233 call *label1 *invalid :flushLocalBuffer*retval (m:*label73) (h:*label73)

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
    33 label *label14
    34 jump *label19 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    35 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label21 notEqual :findLinkedBlocks:requested @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
-    * label *label21
-    * label *label22
+   36 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
    37 label *label19
    38 label *label20
    39 label *label15

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   238 end
   239 label *label0
   240 jump *label75 equal .SMOOTH false
-    * jump *label77 notEqual :drawPixel:iterations 63
   241 set :drawPixel:color %[black]
-    * jump *label78 always
+  242 jump *label78 equal :drawPixel:iterations 63
   243 label *label77
   244 jump *label80 notEqual .PALETTE 2
   245 label *label81

Modifications by Unroll iteration loop at *blocks:68:13 (-1 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp15 *label17
-    * jump *label14 always
-    * multilabel *label17 (m:marker1)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp15 *label18
-    * label *label14
-    * jump *label19 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
-    * label *label19
-    * label *label20
-    * label *label15
-    * multijump *tmp15 0 0 (m:marker1)
-    * multilabel *label18 (m:marker1)
-    * set .memory :findLinkedBlocks:variable
-    * label *label16
+   24 set :findLinkedBlocks:requested @large-logic-display
+   25 set :findLinkedBlocks:variable .display
+   26 label *label105
+   27 jump *label106 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   28 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   29 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   30 label *label106
+   31 label *label107
+   32 label *label108
+   33 set .display :findLinkedBlocks:variable
+   34 set :findLinkedBlocks:requested @memory-bank
+   35 set :findLinkedBlocks:variable .memory
+   36 label *label111
+   37 jump *label112 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   38 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   39 select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   40 label *label112
+   41 label *label113
+   42 label *label114
+   43 set .memory :findLinkedBlocks:variable
+   44 label *label16
    45 label *label12
    46 jump *label102 greaterThan :findLinkedBlocks:n 0
    47 label *label13

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    24 set :findLinkedBlocks:requested @large-logic-display
    25 set :findLinkedBlocks:variable .display
    26 label *label105
-    * jump *label106 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   27 jump *label106 notEqual @large-logic-display :findLinkedBlocks:type
    28 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   29 select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
    30 label *label106
    31 label *label107
    32 label *label108
 
    34 set :findLinkedBlocks:requested @memory-bank
    35 set :findLinkedBlocks:variable .memory
    36 label *label111
-    * jump *label112 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   37 jump *label112 notEqual @memory-bank :findLinkedBlocks:type
    38 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal :findLinkedBlocks:requested @message :findLinkedBlocks:block :findLinkedBlocks:message
+   39 select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
    40 label *label112
    41 label *label113
    42 label *label114
 
   144 set :y 0
   145 set :drawPixel:x *tmp46
   146 label *label53
-    * jump *label55 greaterThanEq :y 176
+  147 jump *label55 greaterThanEq 0 176
   148 label *label103
   149 op div *tmp59 *tmp46 .ZOOM
   150 op add :compute:zx *tmp59 .OFFSET_X
 
   178 label *label58
   179 set :compute:i 0
   180 label *label63
-    * jump *label65 greaterThanEq :compute:i 63
+  181 jump *label65 greaterThanEq 0 63
   182 label *label104
   183 set :compute:x1 :compute:zx
   184 op mul *tmp76 :compute:zx :compute:zx

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    21 print "\nFound: "
    22 print :findLinkedBlocks:block
    23 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
    24 set :findLinkedBlocks:variable .display
    25 label *label105
    26 jump *label106 notEqual @large-logic-display :findLinkedBlocks:type
 
    30 label *label107
    31 label *label108
    32 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    33 set :findLinkedBlocks:variable .memory
    34 label *label111
    35 jump *label112 notEqual @memory-bank :findLinkedBlocks:type

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
     0 set .start 0
     1 set :findLinkedBlocks:message null
     2 label *label3
-    * setaddr *tmp11 *label9
-    * jump *label6 always
-    * multilabel *label9 (m:marker0)
-    * set .display null
-    * setaddr *tmp11 *label10
-    * label *label6
-    * label *label7
-    * multijump *tmp11 0 0 (m:marker0)
-    * multilabel *label10 (m:marker0)
-    * set .memory null
-    * label *label8
+    3 label *label118
+    4 label *label119
+    5 set .display null
+    6 label *label122
+    7 label *label123
+    8 set .memory null
+    9 label *label8
    10 print "Mandelbrot Generator"
    11 set :findLinkedBlocks:n @links
    12 label *label11

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    40 jump *label102 greaterThan :findLinkedBlocks:n 0
    41 label *label13
    42 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp20 *label26
-    * jump *label23 always
-    * multilabel *label26 (m:marker2)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp20 *label27
-    * label *label23
-    * print "\n"
-    * print :findLinkedBlocks:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks:variable
-    * jump *label28 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * label *label28
-    * label *label29
-    * label *label24
-    * multijump *tmp20 0 0 (m:marker2)
-    * multilabel *label27 (m:marker2)
-    * set .memory :findLinkedBlocks:variable
-    * label *label25
+   43 set :findLinkedBlocks:name "Display"
+   44 set :findLinkedBlocks:variable .display
+   45 label *label127
+   46 print "\n"
+   47 print :findLinkedBlocks:name
+   48 print ":"
+   49 print " "
+   50 print :findLinkedBlocks:variable
+   51 jump *label128 equal true false
+   52 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   53 label *label128
+   54 label *label129
+   55 label *label130
+   56 set .display :findLinkedBlocks:variable
+   57 set :findLinkedBlocks:name "Memory"
+   58 set :findLinkedBlocks:variable .memory
+   59 label *label133
+   60 print "\n"
+   61 print :findLinkedBlocks:name
+   62 print ":"
+   63 print " "
+   64 print :findLinkedBlocks:variable
+   65 jump *label134 equal true false
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   67 label *label134
+   68 label *label135
+   69 label *label136
+   70 set .memory :findLinkedBlocks:variable
+   71 label *label25
    72 printflush :findLinkedBlocks:message
    73 label *label4
    74 jump *label3 equal :findLinkedBlocks:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    44 set :findLinkedBlocks:variable .display
    45 label *label127
    46 print "\n"
-    * print :findLinkedBlocks:name
+   47 print "Display"
    48 print ":"
    49 print " "
-    * print :findLinkedBlocks:variable
+   50 print .display
    51 jump *label128 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   52 op and :findLinkedBlocks:foundAll 1 .display
    53 label *label128
    54 label *label129
    55 label *label130
-    * set .display :findLinkedBlocks:variable
+   56 set .display .display
    57 set :findLinkedBlocks:name "Memory"
    58 set :findLinkedBlocks:variable .memory
    59 label *label133
    60 print "\n"
-    * print :findLinkedBlocks:name
+   61 print "Memory"
    62 print ":"
    63 print " "
-    * print :findLinkedBlocks:variable
+   64 print .memory
    65 jump *label134 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   66 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    67 label *label134
    68 label *label135
    69 label *label136
-    * set .memory :findLinkedBlocks:variable
+   70 set .memory .memory
    71 label *label25
    72 printflush :findLinkedBlocks:message
    73 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    39 label *label12
    40 jump *label102 greaterThan :findLinkedBlocks:n 0
    41 label *label13
-    * set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
    42 label *label127
    43 print "\n"
    44 print "Display"
 
    51 label *label129
    52 label *label130
    53 set .display .display
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
    54 label *label133
    55 print "\n"
    56 print "Memory"

Modifications by Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:200:1 (+2 instructions):
 
   221 op add :y :y 1
   222 jump *label103 lessThan :y 176
   223 label *label55
-    * setaddr :flushLocalBuffer*retaddr *label73 (h:*label73)
-    * call *label1 *invalid :flushLocalBuffer*retval (m:*label73) (h:*label73)
-    * label *label73
+  224 label *label140
+  225 label *label141
+  226 label *label142
+  227 sensor *tmp158 .display @enabled
+  228 jump *label141 equal *tmp158 false
+  229 label *label143
+  230 jump *label147 lessThanEq .localBuffer 4
+  231 label *label144
+  232 wait 0.0001
+  233 label *label145
+  234 sensor *tmp162 .display @bufferSize
+  235 jump *label144 greaterThan *tmp162 250
+  236 label *label146
+  237 label *label147
+  238 label *label148
+  239 drawflush .display
+  240 set .localBuffer 0
+  241 label *label149
   242 label *label37
   243 jump *label36 always
   244 label *label38
 
   296 read :drawPixel:color .memory :drawPixel:iterations
   297 label *label76
   298 jump *label86 lessThan .localBuffer 254
-    * setaddr :flushLocalBuffer*retaddr *label88 (h:*label88)
-    * call *label1 *invalid :flushLocalBuffer*retval (m:*label88) (h:*label88)
-    * label *label88
+  299 label *label150
+  300 label *label151
+  301 label *label152
+  302 sensor *tmp158 .display @enabled
+  303 jump *label151 equal *tmp158 false
+  304 label *label153
+  305 jump *label157 lessThanEq .localBuffer 4
+  306 label *label154
+  307 wait 0.0001
+  308 label *label155
+  309 sensor *tmp162 .display @bufferSize
+  310 jump *label154 greaterThan *tmp162 250
+  311 label *label156
+  312 label *label157
+  313 label *label158
+  314 drawflush .display
+  315 set .localBuffer 0
+  316 label *label159
   317 label *label86
   318 label *label87
   319 draw col :drawPixel:color
 
   339 label *label74
   340 return :drawPixel*retaddr
   341 end
-    * label *label1
-    * label *label94
-    * label *label95
-    * sensor *tmp158 .display @enabled
-    * jump *label94 equal *tmp158 false
-    * label *label96
-    * jump *label97 lessThanEq .localBuffer 4
-    * label *label99
-    * wait 0.0001
-    * label *label100
-    * sensor *tmp162 .display @bufferSize
-    * jump *label99 greaterThan *tmp162 250
-    * label *label101
-    * label *label97
-    * label *label98
-    * drawflush .display
-    * set .localBuffer 0
-    * label *label93
-    * return :flushLocalBuffer*retaddr
-    * end

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:79:21 (-7 instructions):
 
   106 jump *label38 always
   107 label *label41
   108 label *label42
-    * jump *label46 lessThan *tmp42 0
-    * jump *label45 lessThan *tmp42 22
-    * label *label46
-    * jump *label44 always
+  109 multijump *tmp42 0 0 (m:*label161)
+  110 multilabel *label165 (m:*label161)
+  111 label *label160
+  112 op mul *tmp55 2 *tmp42
+  113 op sub *tmp46 *tmp55 175
+  114 jump *label43 always
+  115 multilabel *label162 (m:*label161)
   116 label *label45
   117 op mul *tmp46 8 *tmp42
   118 jump *label43 always
   119 label *label44
-    * jump *label49 lessThan *tmp42 22
-    * jump *label48 lessThan *tmp42 44
-    * label *label49
-    * jump *label47 always
+  120 multilabel *label163 (m:*label161)
   121 label *label48
   122 op mul *tmp49 8 *tmp42
   123 op sub *tmp46 *tmp49 172
   124 jump *label43 always
   125 label *label47
-    * jump *label52 lessThan *tmp42 44
-    * jump *label51 lessThan *tmp42 88
-    * label *label52
-    * jump *label50 always
+  126 jump *label43 always
+  127 multilabel *label164 (m:*label161)
   128 label *label51
   129 op mul *tmp52 4 *tmp42
   130 op sub *tmp46 *tmp52 174
-    * jump *label43 always
-    * label *label50
-    * op mul *tmp55 2 *tmp42
-    * op sub *tmp46 *tmp55 175
   131 label *label43
   132 set :y 0
   133 set :drawPixel:x *tmp46

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:152:13 (-2 instructions):
 
   245 set :drawPixel:color %[black]
   246 jump *label78 equal :drawPixel:iterations 63
   247 label *label77
-    * jump *label80 notEqual .PALETTE 2
+  248 multijump .PALETTE 0 0 (m:*label167)
+  249 multilabel *label172 (m:*label167)
+  250 multilabel *label168 (m:*label167)
+  251 label *label166
+  252 op div *tmp139 :drawPixel:iterations 63.75
+  253 op sub :drawPixel:r 1 *tmp139
+  254 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
+  255 jump *label79 always
+  256 multilabel *label169 (m:*label167)
   257 label *label81
   258 op sub *tmp104 32 :drawPixel:iterations
   259 op abs *tmp105 *tmp104
 
   268 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   269 jump *label79 always
   270 label *label80
-    * jump *label82 notEqual .PALETTE 3
+  271 multilabel *label170 (m:*label167)
   272 label *label83
   273 op div *tmp121 :drawPixel:iterations 0.175
   274 op sin :drawPixel:r *tmp121
 
   280 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   281 jump *label79 always
   282 label *label82
-    * jump *label84 notEqual .PALETTE 4
+  283 multilabel *label171 (m:*label167)
   284 label *label85
   285 op div :drawPixel:r :drawPixel:iterations 63.75
   286 op div *tmp135 :drawPixel:iterations 170
   287 op add :drawPixel:g 96 *tmp135
   288 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label79 always
-    * label *label84
-    * op div *tmp139 :drawPixel:iterations 63.75
-    * op sub :drawPixel:r 1 *tmp139
-    * packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   289 label *label79
   290 label *label78
   291 jump *label76 always

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-4 instructions):
 
    45 print ":"
    46 print " "
    47 print .display
-    * jump *label128 equal true false
    48 op and :findLinkedBlocks:foundAll 1 .display
    49 label *label128
    50 label *label129
 
    56 print ":"
    57 print " "
    58 print .memory
-    * jump *label134 equal true false
    59 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    60 label *label134
    61 label *label135
 
   130 set :y 0
   131 set :drawPixel:x *tmp46
   132 label *label53
-    * jump *label55 greaterThanEq 0 176
   133 label *label103
   134 op div *tmp59 *tmp46 .ZOOM
   135 op add :compute:zx *tmp59 .OFFSET_X
 
   163 label *label58
   164 set :compute:i 0
   165 label *label63
-    * jump *label65 greaterThanEq 0 63
   166 label *label104
   167 set :compute:x1 :compute:zx
   168 op mul *tmp76 :compute:zx :compute:zx

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   119 label *label48
   120 op mul *tmp49 8 *tmp42
   121 op sub *tmp46 *tmp49 172
-    * jump *label43 always
   122 label *label47
   123 jump *label43 always
   124 multilabel *label164 (m:*label161)
 
   191 label *label68
   192 label *label69
   193 set *tmp58 :compute:i
-    * jump *label56 always
   194 label *label56
   195 set :drawPixel:y :y
   196 set :drawPixel:iterations *tmp58

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-2 instructions):
 
    21 label *label105
    22 jump *label106 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @large-logic-display @message :findLinkedBlocks:block :findLinkedBlocks:message
+   24 set :findLinkedBlocks:message :findLinkedBlocks:message
    25 label *label106
    26 label *label107
    27 label *label108
 
    30 label *label111
    31 jump *label112 notEqual @memory-bank :findLinkedBlocks:type
    32 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * select :findLinkedBlocks:message equal @memory-bank @message :findLinkedBlocks:block :findLinkedBlocks:message
+   33 set :findLinkedBlocks:message :findLinkedBlocks:message
    34 label *label112
    35 label *label113
    36 label *label114
 
    49 label *label128
    50 label *label129
    51 label *label130
-    * set .display .display
    52 label *label133
    53 print "\n"
    54 print "Memory"
 
    59 label *label134
    60 label *label135
    61 label *label136
-    * set .memory .memory
    62 label *label25
    63 printflush :findLinkedBlocks:message
    64 label *label4

Modifications by Unroll loop at mandelbrot-compute.mnd:125:5 (+743 instructions):
 
   158 label *label61
   159 label *label62
   160 label *label58
-    * set :compute:i 0
-    * label *label63
-    * label *label104
-    * set :compute:x1 :compute:zx
-    * op mul *tmp76 :compute:zx :compute:zx
-    * op mul *tmp77 :compute:zy :compute:zy
-    * op sub *tmp78 *tmp76 *tmp77
-    * op add :compute:zx *tmp78 :compute:cx
-    * op mul *tmp80 2 :compute:x1
-    * op mul *tmp81 *tmp80 :compute:zy
-    * op add :compute:zy *tmp81 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label66 lessThan :compute:dist 64
-    * jump *label65 always
-    * label *label66
-    * label *label67
-    * label *label64
-    * op add :compute:i :compute:i 1
-    * jump *label104 lessThan :compute:i 63
-    * label *label65
+  161 set :compute:i 0
+  162 label *label173
+  163 set :compute:x1 :compute:zx
+  164 op mul *tmp76 :compute:zx :compute:zx
+  165 op mul *tmp77 :compute:zy :compute:zy
+  166 op sub *tmp78 *tmp76 *tmp77
+  167 op add :compute:zx *tmp78 :compute:cx
+  168 op mul *tmp80 2 :compute:x1
+  169 op mul *tmp81 *tmp80 :compute:zy
+  170 op add :compute:zy *tmp81 :compute:cy
+  171 op len :compute:dist :compute:zx :compute:zy
+  172 jump *label174 lessThan :compute:dist 64
+  173 jump *label65 always
+  174 label *label174
+  175 label *label175
+  176 label *label176
+  177 op add :compute:i :compute:i 1
+  178 set :compute:x1 :compute:zx
+  179 op mul *tmp76 :compute:zx :compute:zx
+  180 op mul *tmp77 :compute:zy :compute:zy
+  181 op sub *tmp78 *tmp76 *tmp77
+  182 op add :compute:zx *tmp78 :compute:cx
+  183 op mul *tmp80 2 :compute:x1
+  184 op mul *tmp81 *tmp80 :compute:zy
+  185 op add :compute:zy *tmp81 :compute:cy
+  186 op len :compute:dist :compute:zx :compute:zy
+  187 jump *label177 lessThan :compute:dist 64
+  188 jump *label65 always
+  189 label *label177
+  190 label *label178
+  191 label *label179
+  192 op add :compute:i :compute:i 1
+  193 set :compute:x1 :compute:zx
+  194 op mul *tmp76 :compute:zx :compute:zx
+  195 op mul *tmp77 :compute:zy :compute:zy
+  196 op sub *tmp78 *tmp76 *tmp77
+  197 op add :compute:zx *tmp78 :compute:cx
+  198 op mul *tmp80 2 :compute:x1
+  199 op mul *tmp81 *tmp80 :compute:zy
+  200 op add :compute:zy *tmp81 :compute:cy
+  201 op len :compute:dist :compute:zx :compute:zy
+  202 jump *label180 lessThan :compute:dist 64
+  203 jump *label65 always
+  204 label *label180
+  205 label *label181
+  206 label *label182
+  207 op add :compute:i :compute:i 1
+  208 set :compute:x1 :compute:zx
+  209 op mul *tmp76 :compute:zx :compute:zx
+  210 op mul *tmp77 :compute:zy :compute:zy
+  211 op sub *tmp78 *tmp76 *tmp77
+  212 op add :compute:zx *tmp78 :compute:cx
+  213 op mul *tmp80 2 :compute:x1
+  214 op mul *tmp81 *tmp80 :compute:zy
+  215 op add :compute:zy *tmp81 :compute:cy
+  216 op len :compute:dist :compute:zx :compute:zy
+  217 jump *label183 lessThan :compute:dist 64
+  218 jump *label65 always
+  219 label *label183
+  220 label *label184
+  221 label *label185
+  222 op add :compute:i :compute:i 1
+  223 set :compute:x1 :compute:zx
+  224 op mul *tmp76 :compute:zx :compute:zx
+  225 op mul *tmp77 :compute:zy :compute:zy
+  226 op sub *tmp78 *tmp76 *tmp77
+  227 op add :compute:zx *tmp78 :compute:cx
+  228 op mul *tmp80 2 :compute:x1
+  229 op mul *tmp81 *tmp80 :compute:zy
+  230 op add :compute:zy *tmp81 :compute:cy
+  231 op len :compute:dist :compute:zx :compute:zy
+  232 jump *label186 lessThan :compute:dist 64
+  233 jump *label65 always
+  234 label *label186
+  235 label *label187
+  236 label *label188
+  237 op add :compute:i :compute:i 1
+  238 set :compute:x1 :compute:zx
+  239 op mul *tmp76 :compute:zx :compute:zx
+  240 op mul *tmp77 :compute:zy :compute:zy
+  241 op sub *tmp78 *tmp76 *tmp77
+  242 op add :compute:zx *tmp78 :compute:cx
+  243 op mul *tmp80 2 :compute:x1
+  244 op mul *tmp81 *tmp80 :compute:zy
+  245 op add :compute:zy *tmp81 :compute:cy
+  246 op len :compute:dist :compute:zx :compute:zy
+  247 jump *label189 lessThan :compute:dist 64
+  248 jump *label65 always
+  249 label *label189
+  250 label *label190
+  251 label *label191
+  252 op add :compute:i :compute:i 1
+  253 set :compute:x1 :compute:zx
+  254 op mul *tmp76 :compute:zx :compute:zx
+  255 op mul *tmp77 :compute:zy :compute:zy
+  256 op sub *tmp78 *tmp76 *tmp77
+  257 op add :compute:zx *tmp78 :compute:cx
+  258 op mul *tmp80 2 :compute:x1
+  259 op mul *tmp81 *tmp80 :compute:zy
+  260 op add :compute:zy *tmp81 :compute:cy
+  261 op len :compute:dist :compute:zx :compute:zy
+  262 jump *label192 lessThan :compute:dist 64
+  263 jump *label65 always
+  264 label *label192
+  265 label *label193
+  266 label *label194
+  267 op add :compute:i :compute:i 1
+  268 set :compute:x1 :compute:zx
+  269 op mul *tmp76 :compute:zx :compute:zx
+  270 op mul *tmp77 :compute:zy :compute:zy
+  271 op sub *tmp78 *tmp76 *tmp77
+  272 op add :compute:zx *tmp78 :compute:cx
+  273 op mul *tmp80 2 :compute:x1
+  274 op mul *tmp81 *tmp80 :compute:zy
+  275 op add :compute:zy *tmp81 :compute:cy
+  276 op len :compute:dist :compute:zx :compute:zy
+  277 jump *label195 lessThan :compute:dist 64
+  278 jump *label65 always
+  279 label *label195
+  280 label *label196
+  281 label *label197
+  282 op add :compute:i :compute:i 1
+  283 set :compute:x1 :compute:zx
+  284 op mul *tmp76 :compute:zx :compute:zx
+  285 op mul *tmp77 :compute:zy :compute:zy
+  286 op sub *tmp78 *tmp76 *tmp77
+  287 op add :compute:zx *tmp78 :compute:cx
+  288 op mul *tmp80 2 :compute:x1
+  289 op mul *tmp81 *tmp80 :compute:zy
+  290 op add :compute:zy *tmp81 :compute:cy
+  291 op len :compute:dist :compute:zx :compute:zy
+  292 jump *label198 lessThan :compute:dist 64
+  293 jump *label65 always
+  294 label *label198
+  295 label *label199
+  296 label *label200
+  297 op add :compute:i :compute:i 1
+  298 set :compute:x1 :compute:zx
+  299 op mul *tmp76 :compute:zx :compute:zx
+  300 op mul *tmp77 :compute:zy :compute:zy
+  301 op sub *tmp78 *tmp76 *tmp77
+  302 op add :compute:zx *tmp78 :compute:cx
+  303 op mul *tmp80 2 :compute:x1
+  304 op mul *tmp81 *tmp80 :compute:zy
+  305 op add :compute:zy *tmp81 :compute:cy
+  306 op len :compute:dist :compute:zx :compute:zy
+  307 jump *label201 lessThan :compute:dist 64
+  308 jump *label65 always
+  309 label *label201
+  310 label *label202
+  311 label *label203
+  312 op add :compute:i :compute:i 1
+  313 set :compute:x1 :compute:zx
+  314 op mul *tmp76 :compute:zx :compute:zx
+  315 op mul *tmp77 :compute:zy :compute:zy
+  316 op sub *tmp78 *tmp76 *tmp77
+  317 op add :compute:zx *tmp78 :compute:cx
+  318 op mul *tmp80 2 :compute:x1
+  319 op mul *tmp81 *tmp80 :compute:zy
+  320 op add :compute:zy *tmp81 :compute:cy
+  321 op len :compute:dist :compute:zx :compute:zy
+  322 jump *label204 lessThan :compute:dist 64
+  323 jump *label65 always
+  324 label *label204
+  325 label *label205
+  326 label *label206
+  327 op add :compute:i :compute:i 1
+  328 set :compute:x1 :compute:zx
+  329 op mul *tmp76 :compute:zx :compute:zx
+  330 op mul *tmp77 :compute:zy :compute:zy
+  331 op sub *tmp78 *tmp76 *tmp77
+  332 op add :compute:zx *tmp78 :compute:cx
+  333 op mul *tmp80 2 :compute:x1
+  334 op mul *tmp81 *tmp80 :compute:zy
+  335 op add :compute:zy *tmp81 :compute:cy
+  336 op len :compute:dist :compute:zx :compute:zy
+  337 jump *label207 lessThan :compute:dist 64
+  338 jump *label65 always
+  339 label *label207
+  340 label *label208
+  341 label *label209
+  342 op add :compute:i :compute:i 1
+  343 set :compute:x1 :compute:zx
+  344 op mul *tmp76 :compute:zx :compute:zx
+  345 op mul *tmp77 :compute:zy :compute:zy
+  346 op sub *tmp78 *tmp76 *tmp77
+  347 op add :compute:zx *tmp78 :compute:cx
+  348 op mul *tmp80 2 :compute:x1
+  349 op mul *tmp81 *tmp80 :compute:zy
+  350 op add :compute:zy *tmp81 :compute:cy
+  351 op len :compute:dist :compute:zx :compute:zy
+  352 jump *label210 lessThan :compute:dist 64
+  353 jump *label65 always
+  354 label *label210
+  355 label *label211
+  356 label *label212
+  357 op add :compute:i :compute:i 1
+  358 set :compute:x1 :compute:zx
+  359 op mul *tmp76 :compute:zx :compute:zx
+  360 op mul *tmp77 :compute:zy :compute:zy
+  361 op sub *tmp78 *tmp76 *tmp77
+  362 op add :compute:zx *tmp78 :compute:cx
+  363 op mul *tmp80 2 :compute:x1
+  364 op mul *tmp81 *tmp80 :compute:zy
+  365 op add :compute:zy *tmp81 :compute:cy
+  366 op len :compute:dist :compute:zx :compute:zy
+  367 jump *label213 lessThan :compute:dist 64
+  368 jump *label65 always
+  369 label *label213
+  370 label *label214
+  371 label *label215
+  372 op add :compute:i :compute:i 1
+  373 set :compute:x1 :compute:zx
+  374 op mul *tmp76 :compute:zx :compute:zx
+  375 op mul *tmp77 :compute:zy :compute:zy
+  376 op sub *tmp78 *tmp76 *tmp77
+  377 op add :compute:zx *tmp78 :compute:cx
+  378 op mul *tmp80 2 :compute:x1
+  379 op mul *tmp81 *tmp80 :compute:zy
+  380 op add :compute:zy *tmp81 :compute:cy
+  381 op len :compute:dist :compute:zx :compute:zy
+  382 jump *label216 lessThan :compute:dist 64
+  383 jump *label65 always
+  384 label *label216
+  385 label *label217
+  386 label *label218
+  387 op add :compute:i :compute:i 1
+  388 set :compute:x1 :compute:zx
+  389 op mul *tmp76 :compute:zx :compute:zx
+  390 op mul *tmp77 :compute:zy :compute:zy
+  391 op sub *tmp78 *tmp76 *tmp77
+  392 op add :compute:zx *tmp78 :compute:cx
+  393 op mul *tmp80 2 :compute:x1
+  394 op mul *tmp81 *tmp80 :compute:zy
+  395 op add :compute:zy *tmp81 :compute:cy
+  396 op len :compute:dist :compute:zx :compute:zy
+  397 jump *label219 lessThan :compute:dist 64
+  398 jump *label65 always
+  399 label *label219
+  400 label *label220
+  401 label *label221
+  402 op add :compute:i :compute:i 1
+  403 set :compute:x1 :compute:zx
+  404 op mul *tmp76 :compute:zx :compute:zx
+  405 op mul *tmp77 :compute:zy :compute:zy
+  406 op sub *tmp78 *tmp76 *tmp77
+  407 op add :compute:zx *tmp78 :compute:cx
+  408 op mul *tmp80 2 :compute:x1
+  409 op mul *tmp81 *tmp80 :compute:zy
+  410 op add :compute:zy *tmp81 :compute:cy
+  411 op len :compute:dist :compute:zx :compute:zy
+  412 jump *label222 lessThan :compute:dist 64
+  413 jump *label65 always
+  414 label *label222
+  415 label *label223
+  416 label *label224
+  417 op add :compute:i :compute:i 1
+  418 set :compute:x1 :compute:zx
+  419 op mul *tmp76 :compute:zx :compute:zx
+  420 op mul *tmp77 :compute:zy :compute:zy
+  421 op sub *tmp78 *tmp76 *tmp77
+  422 op add :compute:zx *tmp78 :compute:cx
+  423 op mul *tmp80 2 :compute:x1
+  424 op mul *tmp81 *tmp80 :compute:zy
+  425 op add :compute:zy *tmp81 :compute:cy
+  426 op len :compute:dist :compute:zx :compute:zy
+  427 jump *label225 lessThan :compute:dist 64
+  428 jump *label65 always
+  429 label *label225
+  430 label *label226
+  431 label *label227
+  432 op add :compute:i :compute:i 1
+  433 set :compute:x1 :compute:zx
+  434 op mul *tmp76 :compute:zx :compute:zx
+  435 op mul *tmp77 :compute:zy :compute:zy
+  436 op sub *tmp78 *tmp76 *tmp77
+  437 op add :compute:zx *tmp78 :compute:cx
+  438 op mul *tmp80 2 :compute:x1
+  439 op mul *tmp81 *tmp80 :compute:zy
+  440 op add :compute:zy *tmp81 :compute:cy
+  441 op len :compute:dist :compute:zx :compute:zy
+  442 jump *label228 lessThan :compute:dist 64
+  443 jump *label65 always
+  444 label *label228
+  445 label *label229
+  446 label *label230
+  447 op add :compute:i :compute:i 1
+  448 set :compute:x1 :compute:zx
+  449 op mul *tmp76 :compute:zx :compute:zx
+  450 op mul *tmp77 :compute:zy :compute:zy
+  451 op sub *tmp78 *tmp76 *tmp77
+  452 op add :compute:zx *tmp78 :compute:cx
+  453 op mul *tmp80 2 :compute:x1
+  454 op mul *tmp81 *tmp80 :compute:zy
+  455 op add :compute:zy *tmp81 :compute:cy
+  456 op len :compute:dist :compute:zx :compute:zy
+  457 jump *label231 lessThan :compute:dist 64
+  458 jump *label65 always
+  459 label *label231
+  460 label *label232
+  461 label *label233
+  462 op add :compute:i :compute:i 1
+  463 set :compute:x1 :compute:zx
+  464 op mul *tmp76 :compute:zx :compute:zx
+  465 op mul *tmp77 :compute:zy :compute:zy
+  466 op sub *tmp78 *tmp76 *tmp77
+  467 op add :compute:zx *tmp78 :compute:cx
+  468 op mul *tmp80 2 :compute:x1
+  469 op mul *tmp81 *tmp80 :compute:zy
+  470 op add :compute:zy *tmp81 :compute:cy
+  471 op len :compute:dist :compute:zx :compute:zy
+  472 jump *label234 lessThan :compute:dist 64
+  473 jump *label65 always
+  474 label *label234
+  475 label *label235
+  476 label *label236
+  477 op add :compute:i :compute:i 1
+  478 set :compute:x1 :compute:zx
+  479 op mul *tmp76 :compute:zx :compute:zx
+  480 op mul *tmp77 :compute:zy :compute:zy
+  481 op sub *tmp78 *tmp76 *tmp77
+  482 op add :compute:zx *tmp78 :compute:cx
+  483 op mul *tmp80 2 :compute:x1
+  484 op mul *tmp81 *tmp80 :compute:zy
+  485 op add :compute:zy *tmp81 :compute:cy
+  486 op len :compute:dist :compute:zx :compute:zy
+  487 jump *label237 lessThan :compute:dist 64
+  488 jump *label65 always
+  489 label *label237
+  490 label *label238
+  491 label *label239
+  492 op add :compute:i :compute:i 1
+  493 set :compute:x1 :compute:zx
+  494 op mul *tmp76 :compute:zx :compute:zx
+  495 op mul *tmp77 :compute:zy :compute:zy
+  496 op sub *tmp78 *tmp76 *tmp77
+  497 op add :compute:zx *tmp78 :compute:cx
+  498 op mul *tmp80 2 :compute:x1
+  499 op mul *tmp81 *tmp80 :compute:zy
+  500 op add :compute:zy *tmp81 :compute:cy
+  501 op len :compute:dist :compute:zx :compute:zy
+  502 jump *label240 lessThan :compute:dist 64
+  503 jump *label65 always
+  504 label *label240
+  505 label *label241
+  506 label *label242
+  507 op add :compute:i :compute:i 1
+  508 set :compute:x1 :compute:zx
+  509 op mul *tmp76 :compute:zx :compute:zx
+  510 op mul *tmp77 :compute:zy :compute:zy
+  511 op sub *tmp78 *tmp76 *tmp77
+  512 op add :compute:zx *tmp78 :compute:cx
+  513 op mul *tmp80 2 :compute:x1
+  514 op mul *tmp81 *tmp80 :compute:zy
+  515 op add :compute:zy *tmp81 :compute:cy
+  516 op len :compute:dist :compute:zx :compute:zy
+  517 jump *label243 lessThan :compute:dist 64
+  518 jump *label65 always
+  519 label *label243
+  520 label *label244
+  521 label *label245
+  522 op add :compute:i :compute:i 1
+  523 set :compute:x1 :compute:zx
+  524 op mul *tmp76 :compute:zx :compute:zx
+  525 op mul *tmp77 :compute:zy :compute:zy
+  526 op sub *tmp78 *tmp76 *tmp77
+  527 op add :compute:zx *tmp78 :compute:cx
+  528 op mul *tmp80 2 :compute:x1
+  529 op mul *tmp81 *tmp80 :compute:zy
+  530 op add :compute:zy *tmp81 :compute:cy
+  531 op len :compute:dist :compute:zx :compute:zy
+  532 jump *label246 lessThan :compute:dist 64
+  533 jump *label65 always
+  534 label *label246
+  535 label *label247
+  536 label *label248
+  537 op add :compute:i :compute:i 1
+  538 set :compute:x1 :compute:zx
+  539 op mul *tmp76 :compute:zx :compute:zx
+  540 op mul *tmp77 :compute:zy :compute:zy
+  541 op sub *tmp78 *tmp76 *tmp77
+  542 op add :compute:zx *tmp78 :compute:cx
+  543 op mul *tmp80 2 :compute:x1
+  544 op mul *tmp81 *tmp80 :compute:zy
+  545 op add :compute:zy *tmp81 :compute:cy
+  546 op len :compute:dist :compute:zx :compute:zy
+  547 jump *label249 lessThan :compute:dist 64
+  548 jump *label65 always
+  549 label *label249
+  550 label *label250
+  551 label *label251
+  552 op add :compute:i :compute:i 1
+  553 set :compute:x1 :compute:zx
+  554 op mul *tmp76 :compute:zx :compute:zx
+  555 op mul *tmp77 :compute:zy :compute:zy
+  556 op sub *tmp78 *tmp76 *tmp77
+  557 op add :compute:zx *tmp78 :compute:cx
+  558 op mul *tmp80 2 :compute:x1
+  559 op mul *tmp81 *tmp80 :compute:zy
+  560 op add :compute:zy *tmp81 :compute:cy
+  561 op len :compute:dist :compute:zx :compute:zy
+  562 jump *label252 lessThan :compute:dist 64
+  563 jump *label65 always
+  564 label *label252
+  565 label *label253
+  566 label *label254
+  567 op add :compute:i :compute:i 1
+  568 set :compute:x1 :compute:zx
+  569 op mul *tmp76 :compute:zx :compute:zx
+  570 op mul *tmp77 :compute:zy :compute:zy
+  571 op sub *tmp78 *tmp76 *tmp77
+  572 op add :compute:zx *tmp78 :compute:cx
+  573 op mul *tmp80 2 :compute:x1
+  574 op mul *tmp81 *tmp80 :compute:zy
+  575 op add :compute:zy *tmp81 :compute:cy
+  576 op len :compute:dist :compute:zx :compute:zy
+  577 jump *label255 lessThan :compute:dist 64
+  578 jump *label65 always
+  579 label *label255
+  580 label *label256
+  581 label *label257
+  582 op add :compute:i :compute:i 1
+  583 set :compute:x1 :compute:zx
+  584 op mul *tmp76 :compute:zx :compute:zx
+  585 op mul *tmp77 :compute:zy :compute:zy
+  586 op sub *tmp78 *tmp76 *tmp77
+  587 op add :compute:zx *tmp78 :compute:cx
+  588 op mul *tmp80 2 :compute:x1
+  589 op mul *tmp81 *tmp80 :compute:zy
+  590 op add :compute:zy *tmp81 :compute:cy
+  591 op len :compute:dist :compute:zx :compute:zy
+  592 jump *label258 lessThan :compute:dist 64
+  593 jump *label65 always
+  594 label *label258
+  595 label *label259
+  596 label *label260
+  597 op add :compute:i :compute:i 1
+  598 set :compute:x1 :compute:zx
+  599 op mul *tmp76 :compute:zx :compute:zx
+  600 op mul *tmp77 :compute:zy :compute:zy
+  601 op sub *tmp78 *tmp76 *tmp77
+  602 op add :compute:zx *tmp78 :compute:cx
+  603 op mul *tmp80 2 :compute:x1
+  604 op mul *tmp81 *tmp80 :compute:zy
+  605 op add :compute:zy *tmp81 :compute:cy
+  606 op len :compute:dist :compute:zx :compute:zy
+  607 jump *label261 lessThan :compute:dist 64
+  608 jump *label65 always
+  609 label *label261
+  610 label *label262
+  611 label *label263
+  612 op add :compute:i :compute:i 1
+  613 set :compute:x1 :compute:zx
+  614 op mul *tmp76 :compute:zx :compute:zx
+  615 op mul *tmp77 :compute:zy :compute:zy
+  616 op sub *tmp78 *tmp76 *tmp77
+  617 op add :compute:zx *tmp78 :compute:cx
+  618 op mul *tmp80 2 :compute:x1
+  619 op mul *tmp81 *tmp80 :compute:zy
+  620 op add :compute:zy *tmp81 :compute:cy
+  621 op len :compute:dist :compute:zx :compute:zy
+  622 jump *label264 lessThan :compute:dist 64
+  623 jump *label65 always
+  624 label *label264
+  625 label *label265
+  626 label *label266
+  627 op add :compute:i :compute:i 1
+  628 set :compute:x1 :compute:zx
+  629 op mul *tmp76 :compute:zx :compute:zx
+  630 op mul *tmp77 :compute:zy :compute:zy
+  631 op sub *tmp78 *tmp76 *tmp77
+  632 op add :compute:zx *tmp78 :compute:cx
+  633 op mul *tmp80 2 :compute:x1
+  634 op mul *tmp81 *tmp80 :compute:zy
+  635 op add :compute:zy *tmp81 :compute:cy
+  636 op len :compute:dist :compute:zx :compute:zy
+  637 jump *label267 lessThan :compute:dist 64
+  638 jump *label65 always
+  639 label *label267
+  640 label *label268
+  641 label *label269
+  642 op add :compute:i :compute:i 1
+  643 set :compute:x1 :compute:zx
+  644 op mul *tmp76 :compute:zx :compute:zx
+  645 op mul *tmp77 :compute:zy :compute:zy
+  646 op sub *tmp78 *tmp76 *tmp77
+  647 op add :compute:zx *tmp78 :compute:cx
+  648 op mul *tmp80 2 :compute:x1
+  649 op mul *tmp81 *tmp80 :compute:zy
+  650 op add :compute:zy *tmp81 :compute:cy
+  651 op len :compute:dist :compute:zx :compute:zy
+  652 jump *label270 lessThan :compute:dist 64
+  653 jump *label65 always
+  654 label *label270
+  655 label *label271
+  656 label *label272
+  657 op add :compute:i :compute:i 1
+  658 set :compute:x1 :compute:zx
+  659 op mul *tmp76 :compute:zx :compute:zx
+  660 op mul *tmp77 :compute:zy :compute:zy
+  661 op sub *tmp78 *tmp76 *tmp77
+  662 op add :compute:zx *tmp78 :compute:cx
+  663 op mul *tmp80 2 :compute:x1
+  664 op mul *tmp81 *tmp80 :compute:zy
+  665 op add :compute:zy *tmp81 :compute:cy
+  666 op len :compute:dist :compute:zx :compute:zy
+  667 jump *label273 lessThan :compute:dist 64
+  668 jump *label65 always
+  669 label *label273
+  670 label *label274
+  671 label *label275
+  672 op add :compute:i :compute:i 1
+  673 set :compute:x1 :compute:zx
+  674 op mul *tmp76 :compute:zx :compute:zx
+  675 op mul *tmp77 :compute:zy :compute:zy
+  676 op sub *tmp78 *tmp76 *tmp77
+  677 op add :compute:zx *tmp78 :compute:cx
+  678 op mul *tmp80 2 :compute:x1
+  679 op mul *tmp81 *tmp80 :compute:zy
+  680 op add :compute:zy *tmp81 :compute:cy
+  681 op len :compute:dist :compute:zx :compute:zy
+  682 jump *label276 lessThan :compute:dist 64
+  683 jump *label65 always
+  684 label *label276
+  685 label *label277
+  686 label *label278
+  687 op add :compute:i :compute:i 1
+  688 set :compute:x1 :compute:zx
+  689 op mul *tmp76 :compute:zx :compute:zx
+  690 op mul *tmp77 :compute:zy :compute:zy
+  691 op sub *tmp78 *tmp76 *tmp77
+  692 op add :compute:zx *tmp78 :compute:cx
+  693 op mul *tmp80 2 :compute:x1
+  694 op mul *tmp81 *tmp80 :compute:zy
+  695 op add :compute:zy *tmp81 :compute:cy
+  696 op len :compute:dist :compute:zx :compute:zy
+  697 jump *label279 lessThan :compute:dist 64
+  698 jump *label65 always
+  699 label *label279
+  700 label *label280
+  701 label *label281
+  702 op add :compute:i :compute:i 1
+  703 set :compute:x1 :compute:zx
+  704 op mul *tmp76 :compute:zx :compute:zx
+  705 op mul *tmp77 :compute:zy :compute:zy
+  706 op sub *tmp78 *tmp76 *tmp77
+  707 op add :compute:zx *tmp78 :compute:cx
+  708 op mul *tmp80 2 :compute:x1
+  709 op mul *tmp81 *tmp80 :compute:zy
+  710 op add :compute:zy *tmp81 :compute:cy
+  711 op len :compute:dist :compute:zx :compute:zy
+  712 jump *label282 lessThan :compute:dist 64
+  713 jump *label65 always
+  714 label *label282
+  715 label *label283
+  716 label *label284
+  717 op add :compute:i :compute:i 1
+  718 set :compute:x1 :compute:zx
+  719 op mul *tmp76 :compute:zx :compute:zx
+  720 op mul *tmp77 :compute:zy :compute:zy
+  721 op sub *tmp78 *tmp76 *tmp77
+  722 op add :compute:zx *tmp78 :compute:cx
+  723 op mul *tmp80 2 :compute:x1
+  724 op mul *tmp81 *tmp80 :compute:zy
+  725 op add :compute:zy *tmp81 :compute:cy
+  726 op len :compute:dist :compute:zx :compute:zy
+  727 jump *label285 lessThan :compute:dist 64
+  728 jump *label65 always
+  729 label *label285
+  730 label *label286
+  731 label *label287
+  732 op add :compute:i :compute:i 1
+  733 set :compute:x1 :compute:zx
+  734 op mul *tmp76 :compute:zx :compute:zx
+  735 op mul *tmp77 :compute:zy :compute:zy
+  736 op sub *tmp78 *tmp76 *tmp77
+  737 op add :compute:zx *tmp78 :compute:cx
+  738 op mul *tmp80 2 :compute:x1
+  739 op mul *tmp81 *tmp80 :compute:zy
+  740 op add :compute:zy *tmp81 :compute:cy
+  741 op len :compute:dist :compute:zx :compute:zy
+  742 jump *label288 lessThan :compute:dist 64
+  743 jump *label65 always
+  744 label *label288
+  745 label *label289
+  746 label *label290
+  747 op add :compute:i :compute:i 1
+  748 set :compute:x1 :compute:zx
+  749 op mul *tmp76 :compute:zx :compute:zx
+  750 op mul *tmp77 :compute:zy :compute:zy
+  751 op sub *tmp78 *tmp76 *tmp77
+  752 op add :compute:zx *tmp78 :compute:cx
+  753 op mul *tmp80 2 :compute:x1
+  754 op mul *tmp81 *tmp80 :compute:zy
+  755 op add :compute:zy *tmp81 :compute:cy
+  756 op len :compute:dist :compute:zx :compute:zy
+  757 jump *label291 lessThan :compute:dist 64
+  758 jump *label65 always
+  759 label *label291
+  760 label *label292
+  761 label *label293
+  762 op add :compute:i :compute:i 1
+  763 set :compute:x1 :compute:zx
+  764 op mul *tmp76 :compute:zx :compute:zx
+  765 op mul *tmp77 :compute:zy :compute:zy
+  766 op sub *tmp78 *tmp76 *tmp77
+  767 op add :compute:zx *tmp78 :compute:cx
+  768 op mul *tmp80 2 :compute:x1
+  769 op mul *tmp81 *tmp80 :compute:zy
+  770 op add :compute:zy *tmp81 :compute:cy
+  771 op len :compute:dist :compute:zx :compute:zy
+  772 jump *label294 lessThan :compute:dist 64
+  773 jump *label65 always
+  774 label *label294
+  775 label *label295
+  776 label *label296
+  777 op add :compute:i :compute:i 1
+  778 set :compute:x1 :compute:zx
+  779 op mul *tmp76 :compute:zx :compute:zx
+  780 op mul *tmp77 :compute:zy :compute:zy
+  781 op sub *tmp78 *tmp76 *tmp77
+  782 op add :compute:zx *tmp78 :compute:cx
+  783 op mul *tmp80 2 :compute:x1
+  784 op mul *tmp81 *tmp80 :compute:zy
+  785 op add :compute:zy *tmp81 :compute:cy
+  786 op len :compute:dist :compute:zx :compute:zy
+  787 jump *label297 lessThan :compute:dist 64
+  788 jump *label65 always
+  789 label *label297
+  790 label *label298
+  791 label *label299
+  792 op add :compute:i :compute:i 1
+  793 set :compute:x1 :compute:zx
+  794 op mul *tmp76 :compute:zx :compute:zx
+  795 op mul *tmp77 :compute:zy :compute:zy
+  796 op sub *tmp78 *tmp76 *tmp77
+  797 op add :compute:zx *tmp78 :compute:cx
+  798 op mul *tmp80 2 :compute:x1
+  799 op mul *tmp81 *tmp80 :compute:zy
+  800 op add :compute:zy *tmp81 :compute:cy
+  801 op len :compute:dist :compute:zx :compute:zy
+  802 jump *label300 lessThan :compute:dist 64
+  803 jump *label65 always
+  804 label *label300
+  805 label *label301
+  806 label *label302
+  807 op add :compute:i :compute:i 1
+  808 set :compute:x1 :compute:zx
+  809 op mul *tmp76 :compute:zx :compute:zx
+  810 op mul *tmp77 :compute:zy :compute:zy
+  811 op sub *tmp78 *tmp76 *tmp77
+  812 op add :compute:zx *tmp78 :compute:cx
+  813 op mul *tmp80 2 :compute:x1
+  814 op mul *tmp81 *tmp80 :compute:zy
+  815 op add :compute:zy *tmp81 :compute:cy
+  816 op len :compute:dist :compute:zx :compute:zy
+  817 jump *label303 lessThan :compute:dist 64
+  818 jump *label65 always
+  819 label *label303
+  820 label *label304
+  821 label *label305
+  822 op add :compute:i :compute:i 1
+  823 set :compute:x1 :compute:zx
+  824 op mul *tmp76 :compute:zx :compute:zx
+  825 op mul *tmp77 :compute:zy :compute:zy
+  826 op sub *tmp78 *tmp76 *tmp77
+  827 op add :compute:zx *tmp78 :compute:cx
+  828 op mul *tmp80 2 :compute:x1
+  829 op mul *tmp81 *tmp80 :compute:zy
+  830 op add :compute:zy *tmp81 :compute:cy
+  831 op len :compute:dist :compute:zx :compute:zy
+  832 jump *label306 lessThan :compute:dist 64
+  833 jump *label65 always
+  834 label *label306
+  835 label *label307
+  836 label *label308
+  837 op add :compute:i :compute:i 1
+  838 set :compute:x1 :compute:zx
+  839 op mul *tmp76 :compute:zx :compute:zx
+  840 op mul *tmp77 :compute:zy :compute:zy
+  841 op sub *tmp78 *tmp76 *tmp77
+  842 op add :compute:zx *tmp78 :compute:cx
+  843 op mul *tmp80 2 :compute:x1
+  844 op mul *tmp81 *tmp80 :compute:zy
+  845 op add :compute:zy *tmp81 :compute:cy
+  846 op len :compute:dist :compute:zx :compute:zy
+  847 jump *label309 lessThan :compute:dist 64
+  848 jump *label65 always
+  849 label *label309
+  850 label *label310
+  851 label *label311
+  852 op add :compute:i :compute:i 1
+  853 set :compute:x1 :compute:zx
+  854 op mul *tmp76 :compute:zx :compute:zx
+  855 op mul *tmp77 :compute:zy :compute:zy
+  856 op sub *tmp78 *tmp76 *tmp77
+  857 op add :compute:zx *tmp78 :compute:cx
+  858 op mul *tmp80 2 :compute:x1
+  859 op mul *tmp81 *tmp80 :compute:zy
+  860 op add :compute:zy *tmp81 :compute:cy
+  861 op len :compute:dist :compute:zx :compute:zy
+  862 jump *label312 lessThan :compute:dist 64
+  863 jump *label65 always
+  864 label *label312
+  865 label *label313
+  866 label *label314
+  867 op add :compute:i :compute:i 1
+  868 set :compute:x1 :compute:zx
+  869 op mul *tmp76 :compute:zx :compute:zx
+  870 op mul *tmp77 :compute:zy :compute:zy
+  871 op sub *tmp78 *tmp76 *tmp77
+  872 op add :compute:zx *tmp78 :compute:cx
+  873 op mul *tmp80 2 :compute:x1
+  874 op mul *tmp81 *tmp80 :compute:zy
+  875 op add :compute:zy *tmp81 :compute:cy
+  876 op len :compute:dist :compute:zx :compute:zy
+  877 jump *label315 lessThan :compute:dist 64
+  878 jump *label65 always
+  879 label *label315
+  880 label *label316
+  881 label *label317
+  882 op add :compute:i :compute:i 1
+  883 set :compute:x1 :compute:zx
+  884 op mul *tmp76 :compute:zx :compute:zx
+  885 op mul *tmp77 :compute:zy :compute:zy
+  886 op sub *tmp78 *tmp76 *tmp77
+  887 op add :compute:zx *tmp78 :compute:cx
+  888 op mul *tmp80 2 :compute:x1
+  889 op mul *tmp81 *tmp80 :compute:zy
+  890 op add :compute:zy *tmp81 :compute:cy
+  891 op len :compute:dist :compute:zx :compute:zy
+  892 jump *label318 lessThan :compute:dist 64
+  893 jump *label65 always
+  894 label *label318
+  895 label *label319
+  896 label *label320
+  897 op add :compute:i :compute:i 1
+  898 set :compute:x1 :compute:zx
+  899 op mul *tmp76 :compute:zx :compute:zx
+  900 op mul *tmp77 :compute:zy :compute:zy
+  901 op sub *tmp78 *tmp76 *tmp77
+  902 op add :compute:zx *tmp78 :compute:cx
+  903 op mul *tmp80 2 :compute:x1
+  904 op mul *tmp81 *tmp80 :compute:zy
+  905 op add :compute:zy *tmp81 :compute:cy
+  906 op len :compute:dist :compute:zx :compute:zy
+  907 jump *label321 lessThan :compute:dist 64
+  908 jump *label65 always
+  909 label *label321
+  910 label *label322
+  911 label *label323
+  912 op add :compute:i :compute:i 1
+  913 set :compute:x1 :compute:zx
+  914 op mul *tmp76 :compute:zx :compute:zx
+  915 op mul *tmp77 :compute:zy :compute:zy
+  916 op sub *tmp78 *tmp76 *tmp77
+  917 op add :compute:zx *tmp78 :compute:cx
+  918 op mul *tmp80 2 :compute:x1
+  919 op mul *tmp81 *tmp80 :compute:zy
+  920 op add :compute:zy *tmp81 :compute:cy
+  921 op len :compute:dist :compute:zx :compute:zy
+  922 jump *label324 lessThan :compute:dist 64
+  923 jump *label65 always
+  924 label *label324
+  925 label *label325
+  926 label *label326
+  927 op add :compute:i :compute:i 1
+  928 set :compute:x1 :compute:zx
+  929 op mul *tmp76 :compute:zx :compute:zx
+  930 op mul *tmp77 :compute:zy :compute:zy
+  931 op sub *tmp78 *tmp76 *tmp77
+  932 op add :compute:zx *tmp78 :compute:cx
+  933 op mul *tmp80 2 :compute:x1
+  934 op mul *tmp81 *tmp80 :compute:zy
+  935 op add :compute:zy *tmp81 :compute:cy
+  936 op len :compute:dist :compute:zx :compute:zy
+  937 jump *label327 lessThan :compute:dist 64
+  938 jump *label65 always
+  939 label *label327
+  940 label *label328
+  941 label *label329
+  942 op add :compute:i :compute:i 1
+  943 set :compute:x1 :compute:zx
+  944 op mul *tmp76 :compute:zx :compute:zx
+  945 op mul *tmp77 :compute:zy :compute:zy
+  946 op sub *tmp78 *tmp76 *tmp77
+  947 op add :compute:zx *tmp78 :compute:cx
+  948 op mul *tmp80 2 :compute:x1
+  949 op mul *tmp81 *tmp80 :compute:zy
+  950 op add :compute:zy *tmp81 :compute:cy
+  951 op len :compute:dist :compute:zx :compute:zy
+  952 jump *label330 lessThan :compute:dist 64
+  953 jump *label65 always
+  954 label *label330
+  955 label *label331
+  956 label *label332
+  957 op add :compute:i :compute:i 1
+  958 set :compute:x1 :compute:zx
+  959 op mul *tmp76 :compute:zx :compute:zx
+  960 op mul *tmp77 :compute:zy :compute:zy
+  961 op sub *tmp78 *tmp76 *tmp77
+  962 op add :compute:zx *tmp78 :compute:cx
+  963 op mul *tmp80 2 :compute:x1
+  964 op mul *tmp81 *tmp80 :compute:zy
+  965 op add :compute:zy *tmp81 :compute:cy
+  966 op len :compute:dist :compute:zx :compute:zy
+  967 jump *label333 lessThan :compute:dist 64
+  968 jump *label65 always
+  969 label *label333
+  970 label *label334
+  971 label *label335
+  972 op add :compute:i :compute:i 1
+  973 set :compute:x1 :compute:zx
+  974 op mul *tmp76 :compute:zx :compute:zx
+  975 op mul *tmp77 :compute:zy :compute:zy
+  976 op sub *tmp78 *tmp76 *tmp77
+  977 op add :compute:zx *tmp78 :compute:cx
+  978 op mul *tmp80 2 :compute:x1
+  979 op mul *tmp81 *tmp80 :compute:zy
+  980 op add :compute:zy *tmp81 :compute:cy
+  981 op len :compute:dist :compute:zx :compute:zy
+  982 jump *label336 lessThan :compute:dist 64
+  983 jump *label65 always
+  984 label *label336
+  985 label *label337
+  986 label *label338
+  987 op add :compute:i :compute:i 1
+  988 set :compute:x1 :compute:zx
+  989 op mul *tmp76 :compute:zx :compute:zx
+  990 op mul *tmp77 :compute:zy :compute:zy
+  991 op sub *tmp78 *tmp76 *tmp77
+  992 op add :compute:zx *tmp78 :compute:cx
+  993 op mul *tmp80 2 :compute:x1
+  994 op mul *tmp81 *tmp80 :compute:zy
+  995 op add :compute:zy *tmp81 :compute:cy
+  996 op len :compute:dist :compute:zx :compute:zy
+  997 jump *label339 lessThan :compute:dist 64
+  998 jump *label65 always
+  999 label *label339
+ 1000 label *label340
+ 1001 label *label341
+ 1002 op add :compute:i :compute:i 1
+ 1003 set :compute:x1 :compute:zx
+ 1004 op mul *tmp76 :compute:zx :compute:zx
+ 1005 op mul *tmp77 :compute:zy :compute:zy
+ 1006 op sub *tmp78 *tmp76 *tmp77
+ 1007 op add :compute:zx *tmp78 :compute:cx
+ 1008 op mul *tmp80 2 :compute:x1
+ 1009 op mul *tmp81 *tmp80 :compute:zy
+ 1010 op add :compute:zy *tmp81 :compute:cy
+ 1011 op len :compute:dist :compute:zx :compute:zy
+ 1012 jump *label342 lessThan :compute:dist 64
+ 1013 jump *label65 always
+ 1014 label *label342
+ 1015 label *label343
+ 1016 label *label344
+ 1017 op add :compute:i :compute:i 1
+ 1018 set :compute:x1 :compute:zx
+ 1019 op mul *tmp76 :compute:zx :compute:zx
+ 1020 op mul *tmp77 :compute:zy :compute:zy
+ 1021 op sub *tmp78 *tmp76 *tmp77
+ 1022 op add :compute:zx *tmp78 :compute:cx
+ 1023 op mul *tmp80 2 :compute:x1
+ 1024 op mul *tmp81 *tmp80 :compute:zy
+ 1025 op add :compute:zy *tmp81 :compute:cy
+ 1026 op len :compute:dist :compute:zx :compute:zy
+ 1027 jump *label345 lessThan :compute:dist 64
+ 1028 jump *label65 always
+ 1029 label *label345
+ 1030 label *label346
+ 1031 label *label347
+ 1032 op add :compute:i :compute:i 1
+ 1033 set :compute:x1 :compute:zx
+ 1034 op mul *tmp76 :compute:zx :compute:zx
+ 1035 op mul *tmp77 :compute:zy :compute:zy
+ 1036 op sub *tmp78 *tmp76 *tmp77
+ 1037 op add :compute:zx *tmp78 :compute:cx
+ 1038 op mul *tmp80 2 :compute:x1
+ 1039 op mul *tmp81 *tmp80 :compute:zy
+ 1040 op add :compute:zy *tmp81 :compute:cy
+ 1041 op len :compute:dist :compute:zx :compute:zy
+ 1042 jump *label348 lessThan :compute:dist 64
+ 1043 jump *label65 always
+ 1044 label *label348
+ 1045 label *label349
+ 1046 label *label350
+ 1047 op add :compute:i :compute:i 1
+ 1048 set :compute:x1 :compute:zx
+ 1049 op mul *tmp76 :compute:zx :compute:zx
+ 1050 op mul *tmp77 :compute:zy :compute:zy
+ 1051 op sub *tmp78 *tmp76 *tmp77
+ 1052 op add :compute:zx *tmp78 :compute:cx
+ 1053 op mul *tmp80 2 :compute:x1
+ 1054 op mul *tmp81 *tmp80 :compute:zy
+ 1055 op add :compute:zy *tmp81 :compute:cy
+ 1056 op len :compute:dist :compute:zx :compute:zy
+ 1057 jump *label351 lessThan :compute:dist 64
+ 1058 jump *label65 always
+ 1059 label *label351
+ 1060 label *label352
+ 1061 label *label353
+ 1062 op add :compute:i :compute:i 1
+ 1063 set :compute:x1 :compute:zx
+ 1064 op mul *tmp76 :compute:zx :compute:zx
+ 1065 op mul *tmp77 :compute:zy :compute:zy
+ 1066 op sub *tmp78 *tmp76 *tmp77
+ 1067 op add :compute:zx *tmp78 :compute:cx
+ 1068 op mul *tmp80 2 :compute:x1
+ 1069 op mul *tmp81 *tmp80 :compute:zy
+ 1070 op add :compute:zy *tmp81 :compute:cy
+ 1071 op len :compute:dist :compute:zx :compute:zy
+ 1072 jump *label354 lessThan :compute:dist 64
+ 1073 jump *label65 always
+ 1074 label *label354
+ 1075 label *label355
+ 1076 label *label356
+ 1077 op add :compute:i :compute:i 1
+ 1078 set :compute:x1 :compute:zx
+ 1079 op mul *tmp76 :compute:zx :compute:zx
+ 1080 op mul *tmp77 :compute:zy :compute:zy
+ 1081 op sub *tmp78 *tmp76 *tmp77
+ 1082 op add :compute:zx *tmp78 :compute:cx
+ 1083 op mul *tmp80 2 :compute:x1
+ 1084 op mul *tmp81 *tmp80 :compute:zy
+ 1085 op add :compute:zy *tmp81 :compute:cy
+ 1086 op len :compute:dist :compute:zx :compute:zy
+ 1087 jump *label357 lessThan :compute:dist 64
+ 1088 jump *label65 always
+ 1089 label *label357
+ 1090 label *label358
+ 1091 label *label359
+ 1092 op add :compute:i :compute:i 1
+ 1093 set :compute:x1 :compute:zx
+ 1094 op mul *tmp76 :compute:zx :compute:zx
+ 1095 op mul *tmp77 :compute:zy :compute:zy
+ 1096 op sub *tmp78 *tmp76 *tmp77
+ 1097 op add :compute:zx *tmp78 :compute:cx
+ 1098 op mul *tmp80 2 :compute:x1
+ 1099 op mul *tmp81 *tmp80 :compute:zy
+ 1100 op add :compute:zy *tmp81 :compute:cy
+ 1101 op len :compute:dist :compute:zx :compute:zy
+ 1102 jump *label360 lessThan :compute:dist 64
+ 1103 jump *label65 always
+ 1104 label *label360
+ 1105 label *label361
+ 1106 label *label362
+ 1107 op add :compute:i :compute:i 1
+ 1108 label *label65
  1109 op mul *tmp86 .SMOOTH 63
  1110 jump *label68 greaterThanEq :compute:i *tmp86
  1111 op log *tmp89 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   174 label *label174
   175 label *label175
   176 label *label176
-    * op add :compute:i :compute:i 1
+  177 op add :compute:i 0 1
   178 set :compute:x1 :compute:zx
   179 op mul *tmp76 :compute:zx :compute:zx
   180 op mul *tmp77 :compute:zy :compute:zy
 
   189 label *label177
   190 label *label178
   191 label *label179
-    * op add :compute:i :compute:i 1
+  192 op add :compute:i 1 1
   193 set :compute:x1 :compute:zx
   194 op mul *tmp76 :compute:zx :compute:zx
   195 op mul *tmp77 :compute:zy :compute:zy
 
   204 label *label180
   205 label *label181
   206 label *label182
-    * op add :compute:i :compute:i 1
+  207 op add :compute:i 2 1
   208 set :compute:x1 :compute:zx
   209 op mul *tmp76 :compute:zx :compute:zx
   210 op mul *tmp77 :compute:zy :compute:zy
 
   219 label *label183
   220 label *label184
   221 label *label185
-    * op add :compute:i :compute:i 1
+  222 op add :compute:i 3 1
   223 set :compute:x1 :compute:zx
   224 op mul *tmp76 :compute:zx :compute:zx
   225 op mul *tmp77 :compute:zy :compute:zy
 
   234 label *label186
   235 label *label187
   236 label *label188
-    * op add :compute:i :compute:i 1
+  237 op add :compute:i 4 1
   238 set :compute:x1 :compute:zx
   239 op mul *tmp76 :compute:zx :compute:zx
   240 op mul *tmp77 :compute:zy :compute:zy
 
   249 label *label189
   250 label *label190
   251 label *label191
-    * op add :compute:i :compute:i 1
+  252 op add :compute:i 5 1
   253 set :compute:x1 :compute:zx
   254 op mul *tmp76 :compute:zx :compute:zx
   255 op mul *tmp77 :compute:zy :compute:zy
 
   264 label *label192
   265 label *label193
   266 label *label194
-    * op add :compute:i :compute:i 1
+  267 op add :compute:i 6 1
   268 set :compute:x1 :compute:zx
   269 op mul *tmp76 :compute:zx :compute:zx
   270 op mul *tmp77 :compute:zy :compute:zy
 
   279 label *label195
   280 label *label196
   281 label *label197
-    * op add :compute:i :compute:i 1
+  282 op add :compute:i 7 1
   283 set :compute:x1 :compute:zx
   284 op mul *tmp76 :compute:zx :compute:zx
   285 op mul *tmp77 :compute:zy :compute:zy
 
   294 label *label198
   295 label *label199
   296 label *label200
-    * op add :compute:i :compute:i 1
+  297 op add :compute:i 8 1
   298 set :compute:x1 :compute:zx
   299 op mul *tmp76 :compute:zx :compute:zx
   300 op mul *tmp77 :compute:zy :compute:zy
 
   309 label *label201
   310 label *label202
   311 label *label203
-    * op add :compute:i :compute:i 1
+  312 op add :compute:i 9 1
   313 set :compute:x1 :compute:zx
   314 op mul *tmp76 :compute:zx :compute:zx
   315 op mul *tmp77 :compute:zy :compute:zy
 
   324 label *label204
   325 label *label205
   326 label *label206
-    * op add :compute:i :compute:i 1
+  327 op add :compute:i 10 1
   328 set :compute:x1 :compute:zx
   329 op mul *tmp76 :compute:zx :compute:zx
   330 op mul *tmp77 :compute:zy :compute:zy
 
   339 label *label207
   340 label *label208
   341 label *label209
-    * op add :compute:i :compute:i 1
+  342 op add :compute:i 11 1
   343 set :compute:x1 :compute:zx
   344 op mul *tmp76 :compute:zx :compute:zx
   345 op mul *tmp77 :compute:zy :compute:zy
 
   354 label *label210
   355 label *label211
   356 label *label212
-    * op add :compute:i :compute:i 1
+  357 op add :compute:i 12 1
   358 set :compute:x1 :compute:zx
   359 op mul *tmp76 :compute:zx :compute:zx
   360 op mul *tmp77 :compute:zy :compute:zy
 
   369 label *label213
   370 label *label214
   371 label *label215
-    * op add :compute:i :compute:i 1
+  372 op add :compute:i 13 1
   373 set :compute:x1 :compute:zx
   374 op mul *tmp76 :compute:zx :compute:zx
   375 op mul *tmp77 :compute:zy :compute:zy
 
   384 label *label216
   385 label *label217
   386 label *label218
-    * op add :compute:i :compute:i 1
+  387 op add :compute:i 14 1
   388 set :compute:x1 :compute:zx
   389 op mul *tmp76 :compute:zx :compute:zx
   390 op mul *tmp77 :compute:zy :compute:zy
 
   399 label *label219
   400 label *label220
   401 label *label221
-    * op add :compute:i :compute:i 1
+  402 op add :compute:i 15 1
   403 set :compute:x1 :compute:zx
   404 op mul *tmp76 :compute:zx :compute:zx
   405 op mul *tmp77 :compute:zy :compute:zy
 
   414 label *label222
   415 label *label223
   416 label *label224
-    * op add :compute:i :compute:i 1
+  417 op add :compute:i 16 1
   418 set :compute:x1 :compute:zx
   419 op mul *tmp76 :compute:zx :compute:zx
   420 op mul *tmp77 :compute:zy :compute:zy
 
   429 label *label225
   430 label *label226
   431 label *label227
-    * op add :compute:i :compute:i 1
+  432 op add :compute:i 17 1
   433 set :compute:x1 :compute:zx
   434 op mul *tmp76 :compute:zx :compute:zx
   435 op mul *tmp77 :compute:zy :compute:zy
 
   444 label *label228
   445 label *label229
   446 label *label230
-    * op add :compute:i :compute:i 1
+  447 op add :compute:i 18 1
   448 set :compute:x1 :compute:zx
   449 op mul *tmp76 :compute:zx :compute:zx
   450 op mul *tmp77 :compute:zy :compute:zy
 
   459 label *label231
   460 label *label232
   461 label *label233
-    * op add :compute:i :compute:i 1
+  462 op add :compute:i 19 1
   463 set :compute:x1 :compute:zx
   464 op mul *tmp76 :compute:zx :compute:zx
   465 op mul *tmp77 :compute:zy :compute:zy
 
   474 label *label234
   475 label *label235
   476 label *label236
-    * op add :compute:i :compute:i 1
+  477 op add :compute:i 20 1
   478 set :compute:x1 :compute:zx
   479 op mul *tmp76 :compute:zx :compute:zx
   480 op mul *tmp77 :compute:zy :compute:zy
 
   489 label *label237
   490 label *label238
   491 label *label239
-    * op add :compute:i :compute:i 1
+  492 op add :compute:i 21 1
   493 set :compute:x1 :compute:zx
   494 op mul *tmp76 :compute:zx :compute:zx
   495 op mul *tmp77 :compute:zy :compute:zy
 
   504 label *label240
   505 label *label241
   506 label *label242
-    * op add :compute:i :compute:i 1
+  507 op add :compute:i 22 1
   508 set :compute:x1 :compute:zx
   509 op mul *tmp76 :compute:zx :compute:zx
   510 op mul *tmp77 :compute:zy :compute:zy
 
   519 label *label243
   520 label *label244
   521 label *label245
-    * op add :compute:i :compute:i 1
+  522 op add :compute:i 23 1
   523 set :compute:x1 :compute:zx
   524 op mul *tmp76 :compute:zx :compute:zx
   525 op mul *tmp77 :compute:zy :compute:zy
 
   534 label *label246
   535 label *label247
   536 label *label248
-    * op add :compute:i :compute:i 1
+  537 op add :compute:i 24 1
   538 set :compute:x1 :compute:zx
   539 op mul *tmp76 :compute:zx :compute:zx
   540 op mul *tmp77 :compute:zy :compute:zy
 
   549 label *label249
   550 label *label250
   551 label *label251
-    * op add :compute:i :compute:i 1
+  552 op add :compute:i 25 1
   553 set :compute:x1 :compute:zx
   554 op mul *tmp76 :compute:zx :compute:zx
   555 op mul *tmp77 :compute:zy :compute:zy
 
   564 label *label252
   565 label *label253
   566 label *label254
-    * op add :compute:i :compute:i 1
+  567 op add :compute:i 26 1
   568 set :compute:x1 :compute:zx
   569 op mul *tmp76 :compute:zx :compute:zx
   570 op mul *tmp77 :compute:zy :compute:zy
 
   579 label *label255
   580 label *label256
   581 label *label257
-    * op add :compute:i :compute:i 1
+  582 op add :compute:i 27 1
   583 set :compute:x1 :compute:zx
   584 op mul *tmp76 :compute:zx :compute:zx
   585 op mul *tmp77 :compute:zy :compute:zy
 
   594 label *label258
   595 label *label259
   596 label *label260
-    * op add :compute:i :compute:i 1
+  597 op add :compute:i 28 1
   598 set :compute:x1 :compute:zx
   599 op mul *tmp76 :compute:zx :compute:zx
   600 op mul *tmp77 :compute:zy :compute:zy
 
   609 label *label261
   610 label *label262
   611 label *label263
-    * op add :compute:i :compute:i 1
+  612 op add :compute:i 29 1
   613 set :compute:x1 :compute:zx
   614 op mul *tmp76 :compute:zx :compute:zx
   615 op mul *tmp77 :compute:zy :compute:zy
 
   624 label *label264
   625 label *label265
   626 label *label266
-    * op add :compute:i :compute:i 1
+  627 op add :compute:i 30 1
   628 set :compute:x1 :compute:zx
   629 op mul *tmp76 :compute:zx :compute:zx
   630 op mul *tmp77 :compute:zy :compute:zy
 
   639 label *label267
   640 label *label268
   641 label *label269
-    * op add :compute:i :compute:i 1
+  642 op add :compute:i 31 1
   643 set :compute:x1 :compute:zx
   644 op mul *tmp76 :compute:zx :compute:zx
   645 op mul *tmp77 :compute:zy :compute:zy
 
   654 label *label270
   655 label *label271
   656 label *label272
-    * op add :compute:i :compute:i 1
+  657 op add :compute:i 32 1
   658 set :compute:x1 :compute:zx
   659 op mul *tmp76 :compute:zx :compute:zx
   660 op mul *tmp77 :compute:zy :compute:zy
 
   669 label *label273
   670 label *label274
   671 label *label275
-    * op add :compute:i :compute:i 1
+  672 op add :compute:i 33 1
   673 set :compute:x1 :compute:zx
   674 op mul *tmp76 :compute:zx :compute:zx
   675 op mul *tmp77 :compute:zy :compute:zy
 
   684 label *label276
   685 label *label277
   686 label *label278
-    * op add :compute:i :compute:i 1
+  687 op add :compute:i 34 1
   688 set :compute:x1 :compute:zx
   689 op mul *tmp76 :compute:zx :compute:zx
   690 op mul *tmp77 :compute:zy :compute:zy
 
   699 label *label279
   700 label *label280
   701 label *label281
-    * op add :compute:i :compute:i 1
+  702 op add :compute:i 35 1
   703 set :compute:x1 :compute:zx
   704 op mul *tmp76 :compute:zx :compute:zx
   705 op mul *tmp77 :compute:zy :compute:zy
 
   714 label *label282
   715 label *label283
   716 label *label284
-    * op add :compute:i :compute:i 1
+  717 op add :compute:i 36 1
   718 set :compute:x1 :compute:zx
   719 op mul *tmp76 :compute:zx :compute:zx
   720 op mul *tmp77 :compute:zy :compute:zy
 
   729 label *label285
   730 label *label286
   731 label *label287
-    * op add :compute:i :compute:i 1
+  732 op add :compute:i 37 1
   733 set :compute:x1 :compute:zx
   734 op mul *tmp76 :compute:zx :compute:zx
   735 op mul *tmp77 :compute:zy :compute:zy
 
   744 label *label288
   745 label *label289
   746 label *label290
-    * op add :compute:i :compute:i 1
+  747 op add :compute:i 38 1
   748 set :compute:x1 :compute:zx
   749 op mul *tmp76 :compute:zx :compute:zx
   750 op mul *tmp77 :compute:zy :compute:zy
 
   759 label *label291
   760 label *label292
   761 label *label293
-    * op add :compute:i :compute:i 1
+  762 op add :compute:i 39 1
   763 set :compute:x1 :compute:zx
   764 op mul *tmp76 :compute:zx :compute:zx
   765 op mul *tmp77 :compute:zy :compute:zy
 
   774 label *label294
   775 label *label295
   776 label *label296
-    * op add :compute:i :compute:i 1
+  777 op add :compute:i 40 1
   778 set :compute:x1 :compute:zx
   779 op mul *tmp76 :compute:zx :compute:zx
   780 op mul *tmp77 :compute:zy :compute:zy
 
   789 label *label297
   790 label *label298
   791 label *label299
-    * op add :compute:i :compute:i 1
+  792 op add :compute:i 41 1
   793 set :compute:x1 :compute:zx
   794 op mul *tmp76 :compute:zx :compute:zx
   795 op mul *tmp77 :compute:zy :compute:zy
 
   804 label *label300
   805 label *label301
   806 label *label302
-    * op add :compute:i :compute:i 1
+  807 op add :compute:i 42 1
   808 set :compute:x1 :compute:zx
   809 op mul *tmp76 :compute:zx :compute:zx
   810 op mul *tmp77 :compute:zy :compute:zy
 
   819 label *label303
   820 label *label304
   821 label *label305
-    * op add :compute:i :compute:i 1
+  822 op add :compute:i 43 1
   823 set :compute:x1 :compute:zx
   824 op mul *tmp76 :compute:zx :compute:zx
   825 op mul *tmp77 :compute:zy :compute:zy
 
   834 label *label306
   835 label *label307
   836 label *label308
-    * op add :compute:i :compute:i 1
+  837 op add :compute:i 44 1
   838 set :compute:x1 :compute:zx
   839 op mul *tmp76 :compute:zx :compute:zx
   840 op mul *tmp77 :compute:zy :compute:zy
 
   849 label *label309
   850 label *label310
   851 label *label311
-    * op add :compute:i :compute:i 1
+  852 op add :compute:i 45 1
   853 set :compute:x1 :compute:zx
   854 op mul *tmp76 :compute:zx :compute:zx
   855 op mul *tmp77 :compute:zy :compute:zy
 
   864 label *label312
   865 label *label313
   866 label *label314
-    * op add :compute:i :compute:i 1
+  867 op add :compute:i 46 1
   868 set :compute:x1 :compute:zx
   869 op mul *tmp76 :compute:zx :compute:zx
   870 op mul *tmp77 :compute:zy :compute:zy
 
   879 label *label315
   880 label *label316
   881 label *label317
-    * op add :compute:i :compute:i 1
+  882 op add :compute:i 47 1
   883 set :compute:x1 :compute:zx
   884 op mul *tmp76 :compute:zx :compute:zx
   885 op mul *tmp77 :compute:zy :compute:zy
 
   894 label *label318
   895 label *label319
   896 label *label320
-    * op add :compute:i :compute:i 1
+  897 op add :compute:i 48 1
   898 set :compute:x1 :compute:zx
   899 op mul *tmp76 :compute:zx :compute:zx
   900 op mul *tmp77 :compute:zy :compute:zy
 
   909 label *label321
   910 label *label322
   911 label *label323
-    * op add :compute:i :compute:i 1
+  912 op add :compute:i 49 1
   913 set :compute:x1 :compute:zx
   914 op mul *tmp76 :compute:zx :compute:zx
   915 op mul *tmp77 :compute:zy :compute:zy
 
   924 label *label324
   925 label *label325
   926 label *label326
-    * op add :compute:i :compute:i 1
+  927 op add :compute:i 50 1
   928 set :compute:x1 :compute:zx
   929 op mul *tmp76 :compute:zx :compute:zx
   930 op mul *tmp77 :compute:zy :compute:zy
 
   939 label *label327
   940 label *label328
   941 label *label329
-    * op add :compute:i :compute:i 1
+  942 op add :compute:i 51 1
   943 set :compute:x1 :compute:zx
   944 op mul *tmp76 :compute:zx :compute:zx
   945 op mul *tmp77 :compute:zy :compute:zy
 
   954 label *label330
   955 label *label331
   956 label *label332
-    * op add :compute:i :compute:i 1
+  957 op add :compute:i 52 1
   958 set :compute:x1 :compute:zx
   959 op mul *tmp76 :compute:zx :compute:zx
   960 op mul *tmp77 :compute:zy :compute:zy
 
   969 label *label333
   970 label *label334
   971 label *label335
-    * op add :compute:i :compute:i 1
+  972 op add :compute:i 53 1
   973 set :compute:x1 :compute:zx
   974 op mul *tmp76 :compute:zx :compute:zx
   975 op mul *tmp77 :compute:zy :compute:zy
 
   984 label *label336
   985 label *label337
   986 label *label338
-    * op add :compute:i :compute:i 1
+  987 op add :compute:i 54 1
   988 set :compute:x1 :compute:zx
   989 op mul *tmp76 :compute:zx :compute:zx
   990 op mul *tmp77 :compute:zy :compute:zy
 
   999 label *label339
  1000 label *label340
  1001 label *label341
-    * op add :compute:i :compute:i 1
+ 1002 op add :compute:i 55 1
  1003 set :compute:x1 :compute:zx
  1004 op mul *tmp76 :compute:zx :compute:zx
  1005 op mul *tmp77 :compute:zy :compute:zy
 
  1014 label *label342
  1015 label *label343
  1016 label *label344
-    * op add :compute:i :compute:i 1
+ 1017 op add :compute:i 56 1
  1018 set :compute:x1 :compute:zx
  1019 op mul *tmp76 :compute:zx :compute:zx
  1020 op mul *tmp77 :compute:zy :compute:zy
 
  1029 label *label345
  1030 label *label346
  1031 label *label347
-    * op add :compute:i :compute:i 1
+ 1032 op add :compute:i 57 1
  1033 set :compute:x1 :compute:zx
  1034 op mul *tmp76 :compute:zx :compute:zx
  1035 op mul *tmp77 :compute:zy :compute:zy
 
  1044 label *label348
  1045 label *label349
  1046 label *label350
-    * op add :compute:i :compute:i 1
+ 1047 op add :compute:i 58 1
  1048 set :compute:x1 :compute:zx
  1049 op mul *tmp76 :compute:zx :compute:zx
  1050 op mul *tmp77 :compute:zy :compute:zy
 
  1059 label *label351
  1060 label *label352
  1061 label *label353
-    * op add :compute:i :compute:i 1
+ 1062 op add :compute:i 59 1
  1063 set :compute:x1 :compute:zx
  1064 op mul *tmp76 :compute:zx :compute:zx
  1065 op mul *tmp77 :compute:zy :compute:zy
 
  1074 label *label354
  1075 label *label355
  1076 label *label356
-    * op add :compute:i :compute:i 1
+ 1077 op add :compute:i 60 1
  1078 set :compute:x1 :compute:zx
  1079 op mul *tmp76 :compute:zx :compute:zx
  1080 op mul *tmp77 :compute:zy :compute:zy
 
  1089 label *label357
  1090 label *label358
  1091 label *label359
-    * op add :compute:i :compute:i 1
+ 1092 op add :compute:i 61 1
  1093 set :compute:x1 :compute:zx
  1094 op mul *tmp76 :compute:zx :compute:zx
  1095 op mul *tmp77 :compute:zy :compute:zy
 
  1104 label *label360
  1105 label *label361
  1106 label *label362
-    * op add :compute:i :compute:i 1
+ 1107 op add :compute:i 62 1
  1108 label *label65
  1109 op mul *tmp86 .SMOOTH 63
  1110 jump *label68 greaterThanEq :compute:i *tmp86

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1 (-2 instructions):
 
    21 label *label105
    22 jump *label106 notEqual @large-logic-display :findLinkedBlocks:type
    23 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    24 label *label106
    25 label *label107
    26 label *label108
 
    29 label *label111
    30 jump *label112 notEqual @memory-bank :findLinkedBlocks:type
    31 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * set :findLinkedBlocks:message :findLinkedBlocks:message
    32 label *label112
    33 label *label113
    34 label *label114
 
   172 label *label174
   173 label *label175
   174 label *label176
-    * op add :compute:i 0 1
+  175 set :compute:i 1
   176 set :compute:x1 :compute:zx
   177 op mul *tmp76 :compute:zx :compute:zx
   178 op mul *tmp77 :compute:zy :compute:zy

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1:
 
    58 label *label135
    59 label *label136
    60 label *label25
-    * printflush :findLinkedBlocks:message
+   61 printflush null
    62 label *label4
    63 jump *label3 equal :findLinkedBlocks:foundAll false
    64 label *label5

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 2 (-1 instructions):
     0 set .start 0
-    * set :findLinkedBlocks:message null
     1 label *label3
     2 label *label118
     3 label *label119

Modifications by Iterated phase, Boolean Optimization, pass 3, iteration 1 (-2 instructions):
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label105
-    * jump *label106 notEqual @large-logic-display :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label106
-    * label *label107
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    22 label *label108
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label111
-    * jump *label112 notEqual @memory-bank :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label112
-    * label *label113
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
    27 label *label114
    28 set .memory :findLinkedBlocks:variable
    29 label *label16

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 1:
 
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    19 set :findLinkedBlocks:variable .display
    20 label *label105
-    * select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   21 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    22 label *label108
    23 set .display :findLinkedBlocks:variable
    24 set :findLinkedBlocks:variable .memory
    25 label *label111
-    * select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block :findLinkedBlocks:variable
+   26 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    27 label *label114
    28 set .memory :findLinkedBlocks:variable
    29 label *label16

Modifications by Iterated phase, Data Flow Optimization, pass 4, iteration 2 (-2 instructions):
 
    16 print "\nFound: "
    17 print :findLinkedBlocks:block
    18 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:variable .display
    19 label *label105
    20 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
    21 label *label108
    22 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:variable .memory
    23 label *label111
    24 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
    25 label *label114

Modifications by Jumps phase, Unreachable Code Elimination, pass 6, iteration 1 (-2 instructions):
     0 set .start 0
     1 label *label3
-    * label *label118
-    * label *label119
     2 set .display null
-    * label *label122
-    * label *label123
     3 set .memory null
-    * label *label8
     4 print "Mandelbrot Generator"
     5 set :findLinkedBlocks:n @links
-    * label *label11
     6 jump *label13 lessThanEq :findLinkedBlocks:n 0
     7 label *label102
     8 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
 
    10 print "\nFound: "
    11 print :findLinkedBlocks:block
    12 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * label *label105
    13 select :findLinkedBlocks:variable equal @large-logic-display :findLinkedBlocks:type :findLinkedBlocks:block .display
-    * label *label108
    14 set .display :findLinkedBlocks:variable
-    * label *label111
    15 select :findLinkedBlocks:variable equal @memory-bank :findLinkedBlocks:type :findLinkedBlocks:block .memory
-    * label *label114
    16 set .memory :findLinkedBlocks:variable
-    * label *label16
-    * label *label12
    17 jump *label102 greaterThan :findLinkedBlocks:n 0
    18 label *label13
-    * label *label127
    19 print "\n"
    20 print "Display"
    21 print ":"
    22 print " "
    23 print .display
    24 op and :findLinkedBlocks:foundAll 1 .display
-    * label *label128
-    * label *label129
-    * label *label130
-    * label *label133
    25 print "\n"
    26 print "Memory"
    27 print ":"
    28 print " "
    29 print .memory
    30 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
-    * label *label134
-    * label *label135
-    * label *label136
-    * label *label25
    31 printflush null
-    * label *label4
    32 jump *label3 equal :findLinkedBlocks:foundAll false
-    * label *label5
-    * label *label2
    33 setaddr :drawPixel*retaddr *label70 (h:*label70)
    34 label *label30
    35 set .localBuffer 0
    36 drawflush null
    37 label *label33
    38 wait 0
-    * label *label34
    39 read *tmp24 .memory 66
    40 jump *label33 equal .start *tmp24
-    * label *label35
    41 read .start .memory 66
    42 read .stop .memory 67
    43 read .ZOOM .memory 70
 
    57 jump *label39 equal .stop *tmp40
    58 jump *label38 always
    59 label *label39
-    * label *label40
    60 read *tmp42 .memory 64
    61 op add *tmp0 *tmp42 1
    62 write *tmp0 .memory 64
    63 jump *label41 lessThan *tmp42 176
    64 jump *label38 always
    65 label *label41
-    * label *label42
    66 multijump *tmp42 0 0 (m:*label161)
    67 multilabel *label165 (m:*label161)
-    * label *label160
    68 op mul *tmp55 2 *tmp42
    69 op sub *tmp46 *tmp55 175
    70 jump *label43 always
    71 multilabel *label162 (m:*label161)
-    * label *label45
    72 op mul *tmp46 8 *tmp42
    73 jump *label43 always
-    * label *label44
    74 multilabel *label163 (m:*label161)
-    * label *label48
    75 op mul *tmp49 8 *tmp42
    76 op sub *tmp46 *tmp49 172
-    * label *label47
    77 jump *label43 always
    78 multilabel *label164 (m:*label161)
-    * label *label51
    79 op mul *tmp52 4 *tmp42
    80 op sub *tmp46 *tmp52 174
    81 label *label43
    82 set :y 0
    83 set :drawPixel:x *tmp46
-    * label *label53
    84 label *label103
    85 op div *tmp59 *tmp46 .ZOOM
    86 op add :compute:zx *tmp59 .OFFSET_X
 
   103 set *tmp58 63
   104 jump *label56 always
   105 label *label59
-    * label *label60
   106 op add *tmp72 :compute:zx 1
   107 op len *tmp73 *tmp72 :compute:zy
   108 jump *label61 greaterThan *tmp73 0.25
   109 set *tmp58 63
   110 jump *label56 always
   111 label *label61
-    * label *label62
   112 label *label58
   113 set :compute:i 0
-    * label *label173
   114 set :compute:x1 :compute:zx
   115 op mul *tmp76 :compute:zx :compute:zx
   116 op mul *tmp77 :compute:zy :compute:zy
 
   123 jump *label174 lessThan :compute:dist 64
   124 jump *label65 always
   125 label *label174
-    * label *label175
-    * label *label176
   126 set :compute:i 1
   127 set :compute:x1 :compute:zx
   128 op mul *tmp76 :compute:zx :compute:zx
 
   136 jump *label177 lessThan :compute:dist 64
   137 jump *label65 always
   138 label *label177
-    * label *label178
-    * label *label179
   139 op add :compute:i 1 1
   140 set :compute:x1 :compute:zx
   141 op mul *tmp76 :compute:zx :compute:zx
 
   149 jump *label180 lessThan :compute:dist 64
   150 jump *label65 always
   151 label *label180
-    * label *label181
-    * label *label182
   152 op add :compute:i 2 1
   153 set :compute:x1 :compute:zx
   154 op mul *tmp76 :compute:zx :compute:zx
 
   162 jump *label183 lessThan :compute:dist 64
   163 jump *label65 always
   164 label *label183
-    * label *label184
-    * label *label185
   165 op add :compute:i 3 1
   166 set :compute:x1 :compute:zx
   167 op mul *tmp76 :compute:zx :compute:zx
 
   175 jump *label186 lessThan :compute:dist 64
   176 jump *label65 always
   177 label *label186
-    * label *label187
-    * label *label188
   178 op add :compute:i 4 1
   179 set :compute:x1 :compute:zx
   180 op mul *tmp76 :compute:zx :compute:zx
 
   188 jump *label189 lessThan :compute:dist 64
   189 jump *label65 always
   190 label *label189
-    * label *label190
-    * label *label191
   191 op add :compute:i 5 1
   192 set :compute:x1 :compute:zx
   193 op mul *tmp76 :compute:zx :compute:zx
 
   201 jump *label192 lessThan :compute:dist 64
   202 jump *label65 always
   203 label *label192
-    * label *label193
-    * label *label194
   204 op add :compute:i 6 1
   205 set :compute:x1 :compute:zx
   206 op mul *tmp76 :compute:zx :compute:zx
 
   214 jump *label195 lessThan :compute:dist 64
   215 jump *label65 always
   216 label *label195
-    * label *label196
-    * label *label197
   217 op add :compute:i 7 1
   218 set :compute:x1 :compute:zx
   219 op mul *tmp76 :compute:zx :compute:zx
 
   227 jump *label198 lessThan :compute:dist 64
   228 jump *label65 always
   229 label *label198
-    * label *label199
-    * label *label200
   230 op add :compute:i 8 1
   231 set :compute:x1 :compute:zx
   232 op mul *tmp76 :compute:zx :compute:zx
 
   240 jump *label201 lessThan :compute:dist 64
   241 jump *label65 always
   242 label *label201
-    * label *label202
-    * label *label203
   243 op add :compute:i 9 1
   244 set :compute:x1 :compute:zx
   245 op mul *tmp76 :compute:zx :compute:zx
 
   253 jump *label204 lessThan :compute:dist 64
   254 jump *label65 always
   255 label *label204
-    * label *label205
-    * label *label206
   256 op add :compute:i 10 1
   257 set :compute:x1 :compute:zx
   258 op mul *tmp76 :compute:zx :compute:zx
 
   266 jump *label207 lessThan :compute:dist 64
   267 jump *label65 always
   268 label *label207
-    * label *label208
-    * label *label209
   269 op add :compute:i 11 1
   270 set :compute:x1 :compute:zx
   271 op mul *tmp76 :compute:zx :compute:zx
 
   279 jump *label210 lessThan :compute:dist 64
   280 jump *label65 always
   281 label *label210
-    * label *label211
-    * label *label212
   282 op add :compute:i 12 1
   283 set :compute:x1 :compute:zx
   284 op mul *tmp76 :compute:zx :compute:zx
 
   292 jump *label213 lessThan :compute:dist 64
   293 jump *label65 always
   294 label *label213
-    * label *label214
-    * label *label215
   295 op add :compute:i 13 1
   296 set :compute:x1 :compute:zx
   297 op mul *tmp76 :compute:zx :compute:zx
 
   305 jump *label216 lessThan :compute:dist 64
   306 jump *label65 always
   307 label *label216
-    * label *label217
-    * label *label218
   308 op add :compute:i 14 1
   309 set :compute:x1 :compute:zx
   310 op mul *tmp76 :compute:zx :compute:zx
 
   318 jump *label219 lessThan :compute:dist 64
   319 jump *label65 always
   320 label *label219
-    * label *label220
-    * label *label221
   321 op add :compute:i 15 1
   322 set :compute:x1 :compute:zx
   323 op mul *tmp76 :compute:zx :compute:zx
 
   331 jump *label222 lessThan :compute:dist 64
   332 jump *label65 always
   333 label *label222
-    * label *label223
-    * label *label224
   334 op add :compute:i 16 1
   335 set :compute:x1 :compute:zx
   336 op mul *tmp76 :compute:zx :compute:zx
 
   344 jump *label225 lessThan :compute:dist 64
   345 jump *label65 always
   346 label *label225
-    * label *label226
-    * label *label227
   347 op add :compute:i 17 1
   348 set :compute:x1 :compute:zx
   349 op mul *tmp76 :compute:zx :compute:zx
 
   357 jump *label228 lessThan :compute:dist 64
   358 jump *label65 always
   359 label *label228
-    * label *label229
-    * label *label230
   360 op add :compute:i 18 1
   361 set :compute:x1 :compute:zx
   362 op mul *tmp76 :compute:zx :compute:zx
 
   370 jump *label231 lessThan :compute:dist 64
   371 jump *label65 always
   372 label *label231
-    * label *label232
-    * label *label233
   373 op add :compute:i 19 1
   374 set :compute:x1 :compute:zx
   375 op mul *tmp76 :compute:zx :compute:zx
 
   383 jump *label234 lessThan :compute:dist 64
   384 jump *label65 always
   385 label *label234
-    * label *label235
-    * label *label236
   386 op add :compute:i 20 1
   387 set :compute:x1 :compute:zx
   388 op mul *tmp76 :compute:zx :compute:zx
 
   396 jump *label237 lessThan :compute:dist 64
   397 jump *label65 always
   398 label *label237
-    * label *label238
-    * label *label239
   399 op add :compute:i 21 1
   400 set :compute:x1 :compute:zx
   401 op mul *tmp76 :compute:zx :compute:zx
 
   409 jump *label240 lessThan :compute:dist 64
   410 jump *label65 always
   411 label *label240
-    * label *label241
-    * label *label242
   412 op add :compute:i 22 1
   413 set :compute:x1 :compute:zx
   414 op mul *tmp76 :compute:zx :compute:zx
 
   422 jump *label243 lessThan :compute:dist 64
   423 jump *label65 always
   424 label *label243
-    * label *label244
-    * label *label245
   425 op add :compute:i 23 1
   426 set :compute:x1 :compute:zx
   427 op mul *tmp76 :compute:zx :compute:zx
 
   435 jump *label246 lessThan :compute:dist 64
   436 jump *label65 always
   437 label *label246
-    * label *label247
-    * label *label248
   438 op add :compute:i 24 1
   439 set :compute:x1 :compute:zx
   440 op mul *tmp76 :compute:zx :compute:zx
 
   448 jump *label249 lessThan :compute:dist 64
   449 jump *label65 always
   450 label *label249
-    * label *label250
-    * label *label251
   451 op add :compute:i 25 1
   452 set :compute:x1 :compute:zx
   453 op mul *tmp76 :compute:zx :compute:zx
 
   461 jump *label252 lessThan :compute:dist 64
   462 jump *label65 always
   463 label *label252
-    * label *label253
-    * label *label254
   464 op add :compute:i 26 1
   465 set :compute:x1 :compute:zx
   466 op mul *tmp76 :compute:zx :compute:zx
 
   474 jump *label255 lessThan :compute:dist 64
   475 jump *label65 always
   476 label *label255
-    * label *label256
-    * label *label257
   477 op add :compute:i 27 1
   478 set :compute:x1 :compute:zx
   479 op mul *tmp76 :compute:zx :compute:zx
 
   487 jump *label258 lessThan :compute:dist 64
   488 jump *label65 always
   489 label *label258
-    * label *label259
-    * label *label260
   490 op add :compute:i 28 1
   491 set :compute:x1 :compute:zx
   492 op mul *tmp76 :compute:zx :compute:zx
 
   500 jump *label261 lessThan :compute:dist 64
   501 jump *label65 always
   502 label *label261
-    * label *label262
-    * label *label263
   503 op add :compute:i 29 1
   504 set :compute:x1 :compute:zx
   505 op mul *tmp76 :compute:zx :compute:zx
 
   513 jump *label264 lessThan :compute:dist 64
   514 jump *label65 always
   515 label *label264
-    * label *label265
-    * label *label266
   516 op add :compute:i 30 1
   517 set :compute:x1 :compute:zx
   518 op mul *tmp76 :compute:zx :compute:zx
 
   526 jump *label267 lessThan :compute:dist 64
   527 jump *label65 always
   528 label *label267
-    * label *label268
-    * label *label269
   529 op add :compute:i 31 1
   530 set :compute:x1 :compute:zx
   531 op mul *tmp76 :compute:zx :compute:zx
 
   539 jump *label270 lessThan :compute:dist 64
   540 jump *label65 always
   541 label *label270
-    * label *label271
-    * label *label272
   542 op add :compute:i 32 1
   543 set :compute:x1 :compute:zx
   544 op mul *tmp76 :compute:zx :compute:zx
 
   552 jump *label273 lessThan :compute:dist 64
   553 jump *label65 always
   554 label *label273
-    * label *label274
-    * label *label275
   555 op add :compute:i 33 1
   556 set :compute:x1 :compute:zx
   557 op mul *tmp76 :compute:zx :compute:zx
 
   565 jump *label276 lessThan :compute:dist 64
   566 jump *label65 always
   567 label *label276
-    * label *label277
-    * label *label278
   568 op add :compute:i 34 1
   569 set :compute:x1 :compute:zx
   570 op mul *tmp76 :compute:zx :compute:zx
 
   578 jump *label279 lessThan :compute:dist 64
   579 jump *label65 always
   580 label *label279
-    * label *label280
-    * label *label281
   581 op add :compute:i 35 1
   582 set :compute:x1 :compute:zx
   583 op mul *tmp76 :compute:zx :compute:zx
 
   591 jump *label282 lessThan :compute:dist 64
   592 jump *label65 always
   593 label *label282
-    * label *label283
-    * label *label284
   594 op add :compute:i 36 1
   595 set :compute:x1 :compute:zx
   596 op mul *tmp76 :compute:zx :compute:zx
 
   604 jump *label285 lessThan :compute:dist 64
   605 jump *label65 always
   606 label *label285
-    * label *label286
-    * label *label287
   607 op add :compute:i 37 1
   608 set :compute:x1 :compute:zx
   609 op mul *tmp76 :compute:zx :compute:zx
 
   617 jump *label288 lessThan :compute:dist 64
   618 jump *label65 always
   619 label *label288
-    * label *label289
-    * label *label290
   620 op add :compute:i 38 1
   621 set :compute:x1 :compute:zx
   622 op mul *tmp76 :compute:zx :compute:zx
 
   630 jump *label291 lessThan :compute:dist 64
   631 jump *label65 always
   632 label *label291
-    * label *label292
-    * label *label293
   633 op add :compute:i 39 1
   634 set :compute:x1 :compute:zx
   635 op mul *tmp76 :compute:zx :compute:zx
 
   643 jump *label294 lessThan :compute:dist 64
   644 jump *label65 always
   645 label *label294
-    * label *label295
-    * label *label296
   646 op add :compute:i 40 1
   647 set :compute:x1 :compute:zx
   648 op mul *tmp76 :compute:zx :compute:zx
 
   656 jump *label297 lessThan :compute:dist 64
   657 jump *label65 always
   658 label *label297
-    * label *label298
-    * label *label299
   659 op add :compute:i 41 1
   660 set :compute:x1 :compute:zx
   661 op mul *tmp76 :compute:zx :compute:zx
 
   669 jump *label300 lessThan :compute:dist 64
   670 jump *label65 always
   671 label *label300
-    * label *label301
-    * label *label302
   672 op add :compute:i 42 1
   673 set :compute:x1 :compute:zx
   674 op mul *tmp76 :compute:zx :compute:zx
 
   682 jump *label303 lessThan :compute:dist 64
   683 jump *label65 always
   684 label *label303
-    * label *label304
-    * label *label305
   685 op add :compute:i 43 1
   686 set :compute:x1 :compute:zx
   687 op mul *tmp76 :compute:zx :compute:zx
 
   695 jump *label306 lessThan :compute:dist 64
   696 jump *label65 always
   697 label *label306
-    * label *label307
-    * label *label308
   698 op add :compute:i 44 1
   699 set :compute:x1 :compute:zx
   700 op mul *tmp76 :compute:zx :compute:zx
 
   708 jump *label309 lessThan :compute:dist 64
   709 jump *label65 always
   710 label *label309
-    * label *label310
-    * label *label311
   711 op add :compute:i 45 1
   712 set :compute:x1 :compute:zx
   713 op mul *tmp76 :compute:zx :compute:zx
 
   721 jump *label312 lessThan :compute:dist 64
   722 jump *label65 always
   723 label *label312
-    * label *label313
-    * label *label314
   724 op add :compute:i 46 1
   725 set :compute:x1 :compute:zx
   726 op mul *tmp76 :compute:zx :compute:zx
 
   734 jump *label315 lessThan :compute:dist 64
   735 jump *label65 always
   736 label *label315
-    * label *label316
-    * label *label317
   737 op add :compute:i 47 1
   738 set :compute:x1 :compute:zx
   739 op mul *tmp76 :compute:zx :compute:zx
 
   747 jump *label318 lessThan :compute:dist 64
   748 jump *label65 always
   749 label *label318
-    * label *label319
-    * label *label320
   750 op add :compute:i 48 1
   751 set :compute:x1 :compute:zx
   752 op mul *tmp76 :compute:zx :compute:zx
 
   760 jump *label321 lessThan :compute:dist 64
   761 jump *label65 always
   762 label *label321
-    * label *label322
-    * label *label323
   763 op add :compute:i 49 1
   764 set :compute:x1 :compute:zx
   765 op mul *tmp76 :compute:zx :compute:zx
 
   773 jump *label324 lessThan :compute:dist 64
   774 jump *label65 always
   775 label *label324
-    * label *label325
-    * label *label326
   776 op add :compute:i 50 1
   777 set :compute:x1 :compute:zx
   778 op mul *tmp76 :compute:zx :compute:zx
 
   786 jump *label327 lessThan :compute:dist 64
   787 jump *label65 always
   788 label *label327
-    * label *label328
-    * label *label329
   789 op add :compute:i 51 1
   790 set :compute:x1 :compute:zx
   791 op mul *tmp76 :compute:zx :compute:zx
 
   799 jump *label330 lessThan :compute:dist 64
   800 jump *label65 always
   801 label *label330
-    * label *label331
-    * label *label332
   802 op add :compute:i 52 1
   803 set :compute:x1 :compute:zx
   804 op mul *tmp76 :compute:zx :compute:zx
 
   812 jump *label333 lessThan :compute:dist 64
   813 jump *label65 always
   814 label *label333
-    * label *label334
-    * label *label335
   815 op add :compute:i 53 1
   816 set :compute:x1 :compute:zx
   817 op mul *tmp76 :compute:zx :compute:zx
 
   825 jump *label336 lessThan :compute:dist 64
   826 jump *label65 always
   827 label *label336
-    * label *label337
-    * label *label338
   828 op add :compute:i 54 1
   829 set :compute:x1 :compute:zx
   830 op mul *tmp76 :compute:zx :compute:zx
 
   838 jump *label339 lessThan :compute:dist 64
   839 jump *label65 always
   840 label *label339
-    * label *label340
-    * label *label341
   841 op add :compute:i 55 1
   842 set :compute:x1 :compute:zx
   843 op mul *tmp76 :compute:zx :compute:zx
 
   851 jump *label342 lessThan :compute:dist 64
   852 jump *label65 always
   853 label *label342
-    * label *label343
-    * label *label344
   854 op add :compute:i 56 1
   855 set :compute:x1 :compute:zx
   856 op mul *tmp76 :compute:zx :compute:zx
 
   864 jump *label345 lessThan :compute:dist 64
   865 jump *label65 always
   866 label *label345
-    * label *label346
-    * label *label347
   867 op add :compute:i 57 1
   868 set :compute:x1 :compute:zx
   869 op mul *tmp76 :compute:zx :compute:zx
 
   877 jump *label348 lessThan :compute:dist 64
   878 jump *label65 always
   879 label *label348
-    * label *label349
-    * label *label350
   880 op add :compute:i 58 1
   881 set :compute:x1 :compute:zx
   882 op mul *tmp76 :compute:zx :compute:zx
 
   890 jump *label351 lessThan :compute:dist 64
   891 jump *label65 always
   892 label *label351
-    * label *label352
-    * label *label353
   893 op add :compute:i 59 1
   894 set :compute:x1 :compute:zx
   895 op mul *tmp76 :compute:zx :compute:zx
 
   903 jump *label354 lessThan :compute:dist 64
   904 jump *label65 always
   905 label *label354
-    * label *label355
-    * label *label356
   906 op add :compute:i 60 1
   907 set :compute:x1 :compute:zx
   908 op mul *tmp76 :compute:zx :compute:zx
 
   916 jump *label357 lessThan :compute:dist 64
   917 jump *label65 always
   918 label *label357
-    * label *label358
-    * label *label359
   919 op add :compute:i 61 1
   920 set :compute:x1 :compute:zx
   921 op mul *tmp76 :compute:zx :compute:zx
 
   929 jump *label360 lessThan :compute:dist 64
   930 jump *label65 always
   931 label *label360
-    * label *label361
-    * label *label362
   932 op add :compute:i 62 1
   933 label *label65
   934 op mul *tmp86 .SMOOTH 63
 
   940 op sub :compute:correction 4 *tmp92
   941 op add :compute:i :compute:i :compute:correction
   942 label *label68
-    * label *label69
   943 set *tmp58 :compute:i
   944 label *label56
   945 set :drawPixel:y :y
 
   954 jump *label71 equal .stop *tmp97
   955 jump *label31 always
   956 label *label71
-    * label *label72
-    * label *label54
   957 op add :y :y 1
   958 jump *label103 lessThan :y 176
-    * label *label55
-    * label *label140
   959 label *label141
-    * label *label142
   960 sensor *tmp158 .display @enabled
   961 jump *label141 equal *tmp158 false
-    * label *label143
   962 jump *label147 lessThanEq .localBuffer 4
   963 label *label144
   964 wait 0.0001
-    * label *label145
   965 sensor *tmp162 .display @bufferSize
   966 jump *label144 greaterThan *tmp162 250
-    * label *label146
   967 label *label147
-    * label *label148
   968 drawflush .display
   969 set .localBuffer 0
-    * label *label149
-    * label *label37
   970 jump *label36 always
   971 label *label38
   972 label *label31
   973 jump *label30 always
-    * label *label32
-    * end
   974 label *label0
   975 jump *label75 equal .SMOOTH false
   976 set :drawPixel:color %[black]
   977 jump *label78 equal :drawPixel:iterations 63
-    * label *label77
   978 multijump .PALETTE 0 0 (m:*label167)
   979 multilabel *label172 (m:*label167)
   980 multilabel *label168 (m:*label167)
-    * label *label166
   981 op div *tmp139 :drawPixel:iterations 63.75
   982 op sub :drawPixel:r 1 *tmp139
   983 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   984 jump *label79 always
   985 multilabel *label169 (m:*label167)
-    * label *label81
   986 op sub *tmp104 32 :drawPixel:iterations
   987 op abs *tmp105 *tmp104
   988 op div *tmp107 *tmp105 36.42857142857143
 
   995 op add :drawPixel:b 0.47058823529411764 *tmp117
   996 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   997 jump *label79 always
-    * label *label80
   998 multilabel *label170 (m:*label167)
-    * label *label83
   999 op div *tmp121 :drawPixel:iterations 0.175
  1000 op sin :drawPixel:r *tmp121
  1001 op cos :drawPixel:g *tmp121
 
  1005 op add :drawPixel:b 0.39215686274509803 *tmp129
  1006 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1007 jump *label79 always
-    * label *label82
  1008 multilabel *label171 (m:*label167)
-    * label *label85
  1009 op div :drawPixel:r :drawPixel:iterations 63.75
  1010 op div *tmp135 :drawPixel:iterations 170
  1011 op add :drawPixel:g 96 *tmp135
 
  1017 read :drawPixel:color .memory :drawPixel:iterations
  1018 label *label76
  1019 jump *label86 lessThan .localBuffer 254
-    * label *label150
  1020 label *label151
-    * label *label152
  1021 sensor *tmp158 .display @enabled
  1022 jump *label151 equal *tmp158 false
-    * label *label153
  1023 jump *label157 lessThanEq .localBuffer 4
  1024 label *label154
  1025 wait 0.0001
-    * label *label155
  1026 sensor *tmp162 .display @bufferSize
  1027 jump *label154 greaterThan *tmp162 250
-    * label *label156
  1028 label *label157
-    * label *label158
  1029 drawflush .display
  1030 set .localBuffer 0
-    * label *label159
  1031 label *label86
-    * label *label87
  1032 draw col :drawPixel:color
  1033 draw rect :drawPixel:x :drawPixel:y 1 1
  1034 op add .localBuffer .localBuffer 2
 
  1047 drawflush .display
  1048 set .localBuffer 0
  1049 label *label91
-    * label *label92
  1050 label *label90
-    * label *label74
  1051 return :drawPixel*retaddr
-    * end

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-66 instructions):
 
    54 label *label36
    55 wait 0
    56 read *tmp40 .memory 67
-    * jump *label39 equal .stop *tmp40
-    * jump *label38 always
+   57 jump *label38 notEqual .stop *tmp40
    58 label *label39
    59 read *tmp42 .memory 64
    60 op add *tmp0 *tmp42 1
    61 write *tmp0 .memory 64
-    * jump *label41 lessThan *tmp42 176
-    * jump *label38 always
+   62 jump *label38 greaterThanEq *tmp42 176
    63 label *label41
    64 multijump *tmp42 0 0 (m:*label161)
    65 multilabel *label165 (m:*label161)
 
   118 op mul *tmp81 *tmp80 :compute:zy
   119 op add :compute:zy *tmp81 :compute:cy
   120 op len :compute:dist :compute:zx :compute:zy
-    * jump *label174 lessThan :compute:dist 64
-    * jump *label65 always
+  121 jump *label65 greaterThanEq :compute:dist 64
   122 label *label174
   123 set :compute:i 1
   124 set :compute:x1 :compute:zx
 
   130 op mul *tmp81 *tmp80 :compute:zy
   131 op add :compute:zy *tmp81 :compute:cy
   132 op len :compute:dist :compute:zx :compute:zy
-    * jump *label177 lessThan :compute:dist 64
-    * jump *label65 always
+  133 jump *label65 greaterThanEq :compute:dist 64
   134 label *label177
   135 op add :compute:i 1 1
   136 set :compute:x1 :compute:zx
 
   142 op mul *tmp81 *tmp80 :compute:zy
   143 op add :compute:zy *tmp81 :compute:cy
   144 op len :compute:dist :compute:zx :compute:zy
-    * jump *label180 lessThan :compute:dist 64
-    * jump *label65 always
+  145 jump *label65 greaterThanEq :compute:dist 64
   146 label *label180
   147 op add :compute:i 2 1
   148 set :compute:x1 :compute:zx
 
   154 op mul *tmp81 *tmp80 :compute:zy
   155 op add :compute:zy *tmp81 :compute:cy
   156 op len :compute:dist :compute:zx :compute:zy
-    * jump *label183 lessThan :compute:dist 64
-    * jump *label65 always
+  157 jump *label65 greaterThanEq :compute:dist 64
   158 label *label183
   159 op add :compute:i 3 1
   160 set :compute:x1 :compute:zx
 
   166 op mul *tmp81 *tmp80 :compute:zy
   167 op add :compute:zy *tmp81 :compute:cy
   168 op len :compute:dist :compute:zx :compute:zy
-    * jump *label186 lessThan :compute:dist 64
-    * jump *label65 always
+  169 jump *label65 greaterThanEq :compute:dist 64
   170 label *label186
   171 op add :compute:i 4 1
   172 set :compute:x1 :compute:zx
 
   178 op mul *tmp81 *tmp80 :compute:zy
   179 op add :compute:zy *tmp81 :compute:cy
   180 op len :compute:dist :compute:zx :compute:zy
-    * jump *label189 lessThan :compute:dist 64
-    * jump *label65 always
+  181 jump *label65 greaterThanEq :compute:dist 64
   182 label *label189
   183 op add :compute:i 5 1
   184 set :compute:x1 :compute:zx
 
   190 op mul *tmp81 *tmp80 :compute:zy
   191 op add :compute:zy *tmp81 :compute:cy
   192 op len :compute:dist :compute:zx :compute:zy
-    * jump *label192 lessThan :compute:dist 64
-    * jump *label65 always
+  193 jump *label65 greaterThanEq :compute:dist 64
   194 label *label192
   195 op add :compute:i 6 1
   196 set :compute:x1 :compute:zx
 
   202 op mul *tmp81 *tmp80 :compute:zy
   203 op add :compute:zy *tmp81 :compute:cy
   204 op len :compute:dist :compute:zx :compute:zy
-    * jump *label195 lessThan :compute:dist 64
-    * jump *label65 always
+  205 jump *label65 greaterThanEq :compute:dist 64
   206 label *label195
   207 op add :compute:i 7 1
   208 set :compute:x1 :compute:zx
 
   214 op mul *tmp81 *tmp80 :compute:zy
   215 op add :compute:zy *tmp81 :compute:cy
   216 op len :compute:dist :compute:zx :compute:zy
-    * jump *label198 lessThan :compute:dist 64
-    * jump *label65 always
+  217 jump *label65 greaterThanEq :compute:dist 64
   218 label *label198
   219 op add :compute:i 8 1
   220 set :compute:x1 :compute:zx
 
   226 op mul *tmp81 *tmp80 :compute:zy
   227 op add :compute:zy *tmp81 :compute:cy
   228 op len :compute:dist :compute:zx :compute:zy
-    * jump *label201 lessThan :compute:dist 64
-    * jump *label65 always
+  229 jump *label65 greaterThanEq :compute:dist 64
   230 label *label201
   231 op add :compute:i 9 1
   232 set :compute:x1 :compute:zx
 
   238 op mul *tmp81 *tmp80 :compute:zy
   239 op add :compute:zy *tmp81 :compute:cy
   240 op len :compute:dist :compute:zx :compute:zy
-    * jump *label204 lessThan :compute:dist 64
-    * jump *label65 always
+  241 jump *label65 greaterThanEq :compute:dist 64
   242 label *label204
   243 op add :compute:i 10 1
   244 set :compute:x1 :compute:zx
 
   250 op mul *tmp81 *tmp80 :compute:zy
   251 op add :compute:zy *tmp81 :compute:cy
   252 op len :compute:dist :compute:zx :compute:zy
-    * jump *label207 lessThan :compute:dist 64
-    * jump *label65 always
+  253 jump *label65 greaterThanEq :compute:dist 64
   254 label *label207
   255 op add :compute:i 11 1
   256 set :compute:x1 :compute:zx
 
   262 op mul *tmp81 *tmp80 :compute:zy
   263 op add :compute:zy *tmp81 :compute:cy
   264 op len :compute:dist :compute:zx :compute:zy
-    * jump *label210 lessThan :compute:dist 64
-    * jump *label65 always
+  265 jump *label65 greaterThanEq :compute:dist 64
   266 label *label210
   267 op add :compute:i 12 1
   268 set :compute:x1 :compute:zx
 
   274 op mul *tmp81 *tmp80 :compute:zy
   275 op add :compute:zy *tmp81 :compute:cy
   276 op len :compute:dist :compute:zx :compute:zy
-    * jump *label213 lessThan :compute:dist 64
-    * jump *label65 always
+  277 jump *label65 greaterThanEq :compute:dist 64
   278 label *label213
   279 op add :compute:i 13 1
   280 set :compute:x1 :compute:zx
 
   286 op mul *tmp81 *tmp80 :compute:zy
   287 op add :compute:zy *tmp81 :compute:cy
   288 op len :compute:dist :compute:zx :compute:zy
-    * jump *label216 lessThan :compute:dist 64
-    * jump *label65 always
+  289 jump *label65 greaterThanEq :compute:dist 64
   290 label *label216
   291 op add :compute:i 14 1
   292 set :compute:x1 :compute:zx
 
   298 op mul *tmp81 *tmp80 :compute:zy
   299 op add :compute:zy *tmp81 :compute:cy
   300 op len :compute:dist :compute:zx :compute:zy
-    * jump *label219 lessThan :compute:dist 64
-    * jump *label65 always
+  301 jump *label65 greaterThanEq :compute:dist 64
   302 label *label219
   303 op add :compute:i 15 1
   304 set :compute:x1 :compute:zx
 
   310 op mul *tmp81 *tmp80 :compute:zy
   311 op add :compute:zy *tmp81 :compute:cy
   312 op len :compute:dist :compute:zx :compute:zy
-    * jump *label222 lessThan :compute:dist 64
-    * jump *label65 always
+  313 jump *label65 greaterThanEq :compute:dist 64
   314 label *label222
   315 op add :compute:i 16 1
   316 set :compute:x1 :compute:zx
 
   322 op mul *tmp81 *tmp80 :compute:zy
   323 op add :compute:zy *tmp81 :compute:cy
   324 op len :compute:dist :compute:zx :compute:zy
-    * jump *label225 lessThan :compute:dist 64
-    * jump *label65 always
+  325 jump *label65 greaterThanEq :compute:dist 64
   326 label *label225
   327 op add :compute:i 17 1
   328 set :compute:x1 :compute:zx
 
   334 op mul *tmp81 *tmp80 :compute:zy
   335 op add :compute:zy *tmp81 :compute:cy
   336 op len :compute:dist :compute:zx :compute:zy
-    * jump *label228 lessThan :compute:dist 64
-    * jump *label65 always
+  337 jump *label65 greaterThanEq :compute:dist 64
   338 label *label228
   339 op add :compute:i 18 1
   340 set :compute:x1 :compute:zx
 
   346 op mul *tmp81 *tmp80 :compute:zy
   347 op add :compute:zy *tmp81 :compute:cy
   348 op len :compute:dist :compute:zx :compute:zy
-    * jump *label231 lessThan :compute:dist 64
-    * jump *label65 always
+  349 jump *label65 greaterThanEq :compute:dist 64
   350 label *label231
   351 op add :compute:i 19 1
   352 set :compute:x1 :compute:zx
 
   358 op mul *tmp81 *tmp80 :compute:zy
   359 op add :compute:zy *tmp81 :compute:cy
   360 op len :compute:dist :compute:zx :compute:zy
-    * jump *label234 lessThan :compute:dist 64
-    * jump *label65 always
+  361 jump *label65 greaterThanEq :compute:dist 64
   362 label *label234
   363 op add :compute:i 20 1
   364 set :compute:x1 :compute:zx
 
   370 op mul *tmp81 *tmp80 :compute:zy
   371 op add :compute:zy *tmp81 :compute:cy
   372 op len :compute:dist :compute:zx :compute:zy
-    * jump *label237 lessThan :compute:dist 64
-    * jump *label65 always
+  373 jump *label65 greaterThanEq :compute:dist 64
   374 label *label237
   375 op add :compute:i 21 1
   376 set :compute:x1 :compute:zx
 
   382 op mul *tmp81 *tmp80 :compute:zy
   383 op add :compute:zy *tmp81 :compute:cy
   384 op len :compute:dist :compute:zx :compute:zy
-    * jump *label240 lessThan :compute:dist 64
-    * jump *label65 always
+  385 jump *label65 greaterThanEq :compute:dist 64
   386 label *label240
   387 op add :compute:i 22 1
   388 set :compute:x1 :compute:zx
 
   394 op mul *tmp81 *tmp80 :compute:zy
   395 op add :compute:zy *tmp81 :compute:cy
   396 op len :compute:dist :compute:zx :compute:zy
-    * jump *label243 lessThan :compute:dist 64
-    * jump *label65 always
+  397 jump *label65 greaterThanEq :compute:dist 64
   398 label *label243
   399 op add :compute:i 23 1
   400 set :compute:x1 :compute:zx
 
   406 op mul *tmp81 *tmp80 :compute:zy
   407 op add :compute:zy *tmp81 :compute:cy
   408 op len :compute:dist :compute:zx :compute:zy
-    * jump *label246 lessThan :compute:dist 64
-    * jump *label65 always
+  409 jump *label65 greaterThanEq :compute:dist 64
   410 label *label246
   411 op add :compute:i 24 1
   412 set :compute:x1 :compute:zx
 
   418 op mul *tmp81 *tmp80 :compute:zy
   419 op add :compute:zy *tmp81 :compute:cy
   420 op len :compute:dist :compute:zx :compute:zy
-    * jump *label249 lessThan :compute:dist 64
-    * jump *label65 always
+  421 jump *label65 greaterThanEq :compute:dist 64
   422 label *label249
   423 op add :compute:i 25 1
   424 set :compute:x1 :compute:zx
 
   430 op mul *tmp81 *tmp80 :compute:zy
   431 op add :compute:zy *tmp81 :compute:cy
   432 op len :compute:dist :compute:zx :compute:zy
-    * jump *label252 lessThan :compute:dist 64
-    * jump *label65 always
+  433 jump *label65 greaterThanEq :compute:dist 64
   434 label *label252
   435 op add :compute:i 26 1
   436 set :compute:x1 :compute:zx
 
   442 op mul *tmp81 *tmp80 :compute:zy
   443 op add :compute:zy *tmp81 :compute:cy
   444 op len :compute:dist :compute:zx :compute:zy
-    * jump *label255 lessThan :compute:dist 64
-    * jump *label65 always
+  445 jump *label65 greaterThanEq :compute:dist 64
   446 label *label255
   447 op add :compute:i 27 1
   448 set :compute:x1 :compute:zx
 
   454 op mul *tmp81 *tmp80 :compute:zy
   455 op add :compute:zy *tmp81 :compute:cy
   456 op len :compute:dist :compute:zx :compute:zy
-    * jump *label258 lessThan :compute:dist 64
-    * jump *label65 always
+  457 jump *label65 greaterThanEq :compute:dist 64
   458 label *label258
   459 op add :compute:i 28 1
   460 set :compute:x1 :compute:zx
 
   466 op mul *tmp81 *tmp80 :compute:zy
   467 op add :compute:zy *tmp81 :compute:cy
   468 op len :compute:dist :compute:zx :compute:zy
-    * jump *label261 lessThan :compute:dist 64
-    * jump *label65 always
+  469 jump *label65 greaterThanEq :compute:dist 64
   470 label *label261
   471 op add :compute:i 29 1
   472 set :compute:x1 :compute:zx
 
   478 op mul *tmp81 *tmp80 :compute:zy
   479 op add :compute:zy *tmp81 :compute:cy
   480 op len :compute:dist :compute:zx :compute:zy
-    * jump *label264 lessThan :compute:dist 64
-    * jump *label65 always
+  481 jump *label65 greaterThanEq :compute:dist 64
   482 label *label264
   483 op add :compute:i 30 1
   484 set :compute:x1 :compute:zx
 
   490 op mul *tmp81 *tmp80 :compute:zy
   491 op add :compute:zy *tmp81 :compute:cy
   492 op len :compute:dist :compute:zx :compute:zy
-    * jump *label267 lessThan :compute:dist 64
-    * jump *label65 always
+  493 jump *label65 greaterThanEq :compute:dist 64
   494 label *label267
   495 op add :compute:i 31 1
   496 set :compute:x1 :compute:zx
 
   502 op mul *tmp81 *tmp80 :compute:zy
   503 op add :compute:zy *tmp81 :compute:cy
   504 op len :compute:dist :compute:zx :compute:zy
-    * jump *label270 lessThan :compute:dist 64
-    * jump *label65 always
+  505 jump *label65 greaterThanEq :compute:dist 64
   506 label *label270
   507 op add :compute:i 32 1
   508 set :compute:x1 :compute:zx
 
   514 op mul *tmp81 *tmp80 :compute:zy
   515 op add :compute:zy *tmp81 :compute:cy
   516 op len :compute:dist :compute:zx :compute:zy
-    * jump *label273 lessThan :compute:dist 64
-    * jump *label65 always
+  517 jump *label65 greaterThanEq :compute:dist 64
   518 label *label273
   519 op add :compute:i 33 1
   520 set :compute:x1 :compute:zx
 
   526 op mul *tmp81 *tmp80 :compute:zy
   527 op add :compute:zy *tmp81 :compute:cy
   528 op len :compute:dist :compute:zx :compute:zy
-    * jump *label276 lessThan :compute:dist 64
-    * jump *label65 always
+  529 jump *label65 greaterThanEq :compute:dist 64
   530 label *label276
   531 op add :compute:i 34 1
   532 set :compute:x1 :compute:zx
 
   538 op mul *tmp81 *tmp80 :compute:zy
   539 op add :compute:zy *tmp81 :compute:cy
   540 op len :compute:dist :compute:zx :compute:zy
-    * jump *label279 lessThan :compute:dist 64
-    * jump *label65 always
+  541 jump *label65 greaterThanEq :compute:dist 64
   542 label *label279
   543 op add :compute:i 35 1
   544 set :compute:x1 :compute:zx
 
   550 op mul *tmp81 *tmp80 :compute:zy
   551 op add :compute:zy *tmp81 :compute:cy
   552 op len :compute:dist :compute:zx :compute:zy
-    * jump *label282 lessThan :compute:dist 64
-    * jump *label65 always
+  553 jump *label65 greaterThanEq :compute:dist 64
   554 label *label282
   555 op add :compute:i 36 1
   556 set :compute:x1 :compute:zx
 
   562 op mul *tmp81 *tmp80 :compute:zy
   563 op add :compute:zy *tmp81 :compute:cy
   564 op len :compute:dist :compute:zx :compute:zy
-    * jump *label285 lessThan :compute:dist 64
-    * jump *label65 always
+  565 jump *label65 greaterThanEq :compute:dist 64
   566 label *label285
   567 op add :compute:i 37 1
   568 set :compute:x1 :compute:zx
 
   574 op mul *tmp81 *tmp80 :compute:zy
   575 op add :compute:zy *tmp81 :compute:cy
   576 op len :compute:dist :compute:zx :compute:zy
-    * jump *label288 lessThan :compute:dist 64
-    * jump *label65 always
+  577 jump *label65 greaterThanEq :compute:dist 64
   578 label *label288
   579 op add :compute:i 38 1
   580 set :compute:x1 :compute:zx
 
   586 op mul *tmp81 *tmp80 :compute:zy
   587 op add :compute:zy *tmp81 :compute:cy
   588 op len :compute:dist :compute:zx :compute:zy
-    * jump *label291 lessThan :compute:dist 64
-    * jump *label65 always
+  589 jump *label65 greaterThanEq :compute:dist 64
   590 label *label291
   591 op add :compute:i 39 1
   592 set :compute:x1 :compute:zx
 
   598 op mul *tmp81 *tmp80 :compute:zy
   599 op add :compute:zy *tmp81 :compute:cy
   600 op len :compute:dist :compute:zx :compute:zy
-    * jump *label294 lessThan :compute:dist 64
-    * jump *label65 always
+  601 jump *label65 greaterThanEq :compute:dist 64
   602 label *label294
   603 op add :compute:i 40 1
   604 set :compute:x1 :compute:zx
 
   610 op mul *tmp81 *tmp80 :compute:zy
   611 op add :compute:zy *tmp81 :compute:cy
   612 op len :compute:dist :compute:zx :compute:zy
-    * jump *label297 lessThan :compute:dist 64
-    * jump *label65 always
+  613 jump *label65 greaterThanEq :compute:dist 64
   614 label *label297
   615 op add :compute:i 41 1
   616 set :compute:x1 :compute:zx
 
   622 op mul *tmp81 *tmp80 :compute:zy
   623 op add :compute:zy *tmp81 :compute:cy
   624 op len :compute:dist :compute:zx :compute:zy
-    * jump *label300 lessThan :compute:dist 64
-    * jump *label65 always
+  625 jump *label65 greaterThanEq :compute:dist 64
   626 label *label300
   627 op add :compute:i 42 1
   628 set :compute:x1 :compute:zx
 
   634 op mul *tmp81 *tmp80 :compute:zy
   635 op add :compute:zy *tmp81 :compute:cy
   636 op len :compute:dist :compute:zx :compute:zy
-    * jump *label303 lessThan :compute:dist 64
-    * jump *label65 always
+  637 jump *label65 greaterThanEq :compute:dist 64
   638 label *label303
   639 op add :compute:i 43 1
   640 set :compute:x1 :compute:zx
 
   646 op mul *tmp81 *tmp80 :compute:zy
   647 op add :compute:zy *tmp81 :compute:cy
   648 op len :compute:dist :compute:zx :compute:zy
-    * jump *label306 lessThan :compute:dist 64
-    * jump *label65 always
+  649 jump *label65 greaterThanEq :compute:dist 64
   650 label *label306
   651 op add :compute:i 44 1
   652 set :compute:x1 :compute:zx
 
   658 op mul *tmp81 *tmp80 :compute:zy
   659 op add :compute:zy *tmp81 :compute:cy
   660 op len :compute:dist :compute:zx :compute:zy
-    * jump *label309 lessThan :compute:dist 64
-    * jump *label65 always
+  661 jump *label65 greaterThanEq :compute:dist 64
   662 label *label309
   663 op add :compute:i 45 1
   664 set :compute:x1 :compute:zx
 
   670 op mul *tmp81 *tmp80 :compute:zy
   671 op add :compute:zy *tmp81 :compute:cy
   672 op len :compute:dist :compute:zx :compute:zy
-    * jump *label312 lessThan :compute:dist 64
-    * jump *label65 always
+  673 jump *label65 greaterThanEq :compute:dist 64
   674 label *label312
   675 op add :compute:i 46 1
   676 set :compute:x1 :compute:zx
 
   682 op mul *tmp81 *tmp80 :compute:zy
   683 op add :compute:zy *tmp81 :compute:cy
   684 op len :compute:dist :compute:zx :compute:zy
-    * jump *label315 lessThan :compute:dist 64
-    * jump *label65 always
+  685 jump *label65 greaterThanEq :compute:dist 64
   686 label *label315
   687 op add :compute:i 47 1
   688 set :compute:x1 :compute:zx
 
   694 op mul *tmp81 *tmp80 :compute:zy
   695 op add :compute:zy *tmp81 :compute:cy
   696 op len :compute:dist :compute:zx :compute:zy
-    * jump *label318 lessThan :compute:dist 64
-    * jump *label65 always
+  697 jump *label65 greaterThanEq :compute:dist 64
   698 label *label318
   699 op add :compute:i 48 1
   700 set :compute:x1 :compute:zx
 
   706 op mul *tmp81 *tmp80 :compute:zy
   707 op add :compute:zy *tmp81 :compute:cy
   708 op len :compute:dist :compute:zx :compute:zy
-    * jump *label321 lessThan :compute:dist 64
-    * jump *label65 always
+  709 jump *label65 greaterThanEq :compute:dist 64
   710 label *label321
   711 op add :compute:i 49 1
   712 set :compute:x1 :compute:zx
 
   718 op mul *tmp81 *tmp80 :compute:zy
   719 op add :compute:zy *tmp81 :compute:cy
   720 op len :compute:dist :compute:zx :compute:zy
-    * jump *label324 lessThan :compute:dist 64
-    * jump *label65 always
+  721 jump *label65 greaterThanEq :compute:dist 64
   722 label *label324
   723 op add :compute:i 50 1
   724 set :compute:x1 :compute:zx
 
   730 op mul *tmp81 *tmp80 :compute:zy
   731 op add :compute:zy *tmp81 :compute:cy
   732 op len :compute:dist :compute:zx :compute:zy
-    * jump *label327 lessThan :compute:dist 64
-    * jump *label65 always
+  733 jump *label65 greaterThanEq :compute:dist 64
   734 label *label327
   735 op add :compute:i 51 1
   736 set :compute:x1 :compute:zx
 
   742 op mul *tmp81 *tmp80 :compute:zy
   743 op add :compute:zy *tmp81 :compute:cy
   744 op len :compute:dist :compute:zx :compute:zy
-    * jump *label330 lessThan :compute:dist 64
-    * jump *label65 always
+  745 jump *label65 greaterThanEq :compute:dist 64
   746 label *label330
   747 op add :compute:i 52 1
   748 set :compute:x1 :compute:zx
 
   754 op mul *tmp81 *tmp80 :compute:zy
   755 op add :compute:zy *tmp81 :compute:cy
   756 op len :compute:dist :compute:zx :compute:zy
-    * jump *label333 lessThan :compute:dist 64
-    * jump *label65 always
+  757 jump *label65 greaterThanEq :compute:dist 64
   758 label *label333
   759 op add :compute:i 53 1
   760 set :compute:x1 :compute:zx
 
   766 op mul *tmp81 *tmp80 :compute:zy
   767 op add :compute:zy *tmp81 :compute:cy
   768 op len :compute:dist :compute:zx :compute:zy
-    * jump *label336 lessThan :compute:dist 64
-    * jump *label65 always
+  769 jump *label65 greaterThanEq :compute:dist 64
   770 label *label336
   771 op add :compute:i 54 1
   772 set :compute:x1 :compute:zx
 
   778 op mul *tmp81 *tmp80 :compute:zy
   779 op add :compute:zy *tmp81 :compute:cy
   780 op len :compute:dist :compute:zx :compute:zy
-    * jump *label339 lessThan :compute:dist 64
-    * jump *label65 always
+  781 jump *label65 greaterThanEq :compute:dist 64
   782 label *label339
   783 op add :compute:i 55 1
   784 set :compute:x1 :compute:zx
 
   790 op mul *tmp81 *tmp80 :compute:zy
   791 op add :compute:zy *tmp81 :compute:cy
   792 op len :compute:dist :compute:zx :compute:zy
-    * jump *label342 lessThan :compute:dist 64
-    * jump *label65 always
+  793 jump *label65 greaterThanEq :compute:dist 64
   794 label *label342
   795 op add :compute:i 56 1
   796 set :compute:x1 :compute:zx
 
   802 op mul *tmp81 *tmp80 :compute:zy
   803 op add :compute:zy *tmp81 :compute:cy
   804 op len :compute:dist :compute:zx :compute:zy
-    * jump *label345 lessThan :compute:dist 64
-    * jump *label65 always
+  805 jump *label65 greaterThanEq :compute:dist 64
   806 label *label345
   807 op add :compute:i 57 1
   808 set :compute:x1 :compute:zx
 
   814 op mul *tmp81 *tmp80 :compute:zy
   815 op add :compute:zy *tmp81 :compute:cy
   816 op len :compute:dist :compute:zx :compute:zy
-    * jump *label348 lessThan :compute:dist 64
-    * jump *label65 always
+  817 jump *label65 greaterThanEq :compute:dist 64
   818 label *label348
   819 op add :compute:i 58 1
   820 set :compute:x1 :compute:zx
 
   826 op mul *tmp81 *tmp80 :compute:zy
   827 op add :compute:zy *tmp81 :compute:cy
   828 op len :compute:dist :compute:zx :compute:zy
-    * jump *label351 lessThan :compute:dist 64
-    * jump *label65 always
+  829 jump *label65 greaterThanEq :compute:dist 64
   830 label *label351
   831 op add :compute:i 59 1
   832 set :compute:x1 :compute:zx
 
   838 op mul *tmp81 *tmp80 :compute:zy
   839 op add :compute:zy *tmp81 :compute:cy
   840 op len :compute:dist :compute:zx :compute:zy
-    * jump *label354 lessThan :compute:dist 64
-    * jump *label65 always
+  841 jump *label65 greaterThanEq :compute:dist 64
   842 label *label354
   843 op add :compute:i 60 1
   844 set :compute:x1 :compute:zx
 
   850 op mul *tmp81 *tmp80 :compute:zy
   851 op add :compute:zy *tmp81 :compute:cy
   852 op len :compute:dist :compute:zx :compute:zy
-    * jump *label357 lessThan :compute:dist 64
-    * jump *label65 always
+  853 jump *label65 greaterThanEq :compute:dist 64
   854 label *label357
   855 op add :compute:i 61 1
   856 set :compute:x1 :compute:zx
 
   862 op mul *tmp81 *tmp80 :compute:zy
   863 op add :compute:zy *tmp81 :compute:cy
   864 op len :compute:dist :compute:zx :compute:zy
-    * jump *label360 lessThan :compute:dist 64
-    * jump *label65 always
+  865 jump *label65 greaterThanEq :compute:dist 64
   866 label *label360
   867 op add :compute:i 62 1
   868 label *label65
 
   886 op add *tmp1 *tmp94 1
   887 write *tmp1 .memory 65
   888 read *tmp97 .memory 67
-    * jump *label71 equal .stop *tmp97
-    * jump *label31 always
+  889 jump *label31 notEqual .stop *tmp97
   890 label *label71
   891 op add :y :y 1
   892 jump *label103 lessThan :y 176

Modifications by Jumps phase, Jump Threading, pass 6, iteration 1:
 
    54 label *label36
    55 wait 0
    56 read *tmp40 .memory 67
-    * jump *label38 notEqual .stop *tmp40
+   57 jump *label30 notEqual .stop *tmp40
    58 read *tmp42 .memory 64
    59 op add *tmp0 *tmp42 1
    60 write *tmp0 .memory 64
-    * jump *label38 greaterThanEq *tmp42 176
+   61 jump *label30 greaterThanEq *tmp42 176
    62 multijump *tmp42 0 0 (m:*label161)
    63 multilabel *label165 (m:*label161)
    64 op mul *tmp55 2 *tmp42
 
   821 op add *tmp1 *tmp94 1
   822 write *tmp1 .memory 65
   823 read *tmp97 .memory 67
-    * jump *label31 notEqual .stop *tmp97
+  824 jump *label30 notEqual .stop *tmp97
   825 op add :y :y 1
   826 jump *label103 lessThan :y 176
   827 label *label141
 
   842 label *label0
   843 jump *label75 equal .SMOOTH false
   844 set :drawPixel:color %[black]
-    * jump *label78 equal :drawPixel:iterations 63
+  845 jump *label76 equal :drawPixel:iterations 63
   846 multijump .PALETTE 0 0 (m:*label167)
   847 multilabel *label172 (m:*label167)
   848 multilabel *label168 (m:*label167)
   849 op div *tmp139 :drawPixel:iterations 63.75
   850 op sub :drawPixel:r 1 *tmp139
   851 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * jump *label79 always
+  852 jump *label76 always
   853 multilabel *label169 (m:*label167)
   854 op sub *tmp104 32 :drawPixel:iterations
   855 op abs *tmp105 *tmp104
 
   862 op div *tmp117 *tmp105 63.75
   863 op add :drawPixel:b 0.47058823529411764 *tmp117
   864 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label79 always
+  865 jump *label76 always
   866 multilabel *label170 (m:*label167)
   867 op div *tmp121 :drawPixel:iterations 0.175
   868 op sin :drawPixel:r *tmp121
 
   872 op div *tmp129 *tmp127 63.75
   873 op add :drawPixel:b 0.39215686274509803 *tmp129
   874 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label79 always
+  875 jump *label76 always
   876 multilabel *label171 (m:*label167)
   877 op div :drawPixel:r :drawPixel:iterations 63.75
   878 op div *tmp135 :drawPixel:iterations 170
 
   908 jump *label89 greaterThanEq :drawPixel:usage 100
   909 drawflush .display
   910 set .localBuffer 0
-    * jump *label90 always
+  911 return :drawPixel*retaddr
   912 label *label89
   913 op div *tmp155 1800 .localBuffer
   914 jump *label91 greaterThanEq :drawPixel:usage *tmp155

Modifications by Jumps phase, Unreachable Code Elimination, pass 7, iteration 1 (-1 instructions):
 
   836 drawflush .display
   837 set .localBuffer 0
   838 jump *label36 always
-    * jump *label30 always
   839 label *label0
   840 jump *label75 equal .SMOOTH false
   841 set :drawPixel:color %[black]

Modifications by Final phase, Print Merging, iteration 1 (-7 instructions):
 
    16 set .memory :findLinkedBlocks:variable
    17 jump *label102 greaterThan :findLinkedBlocks:n 0
    18 label *label13
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
-    * print .display
+   19 print "\nDisplay: {0}\nMemory: "
+   20 format .display
    21 op and :findLinkedBlocks:foundAll 1 .display
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
    22 print .memory
    23 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    24 printflush null

Final code before resolving virtual instructions:

    0:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label3                                                *blocks: do
    1:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    2:  set .memory null                                             ...
    3:  print "Mandelbrot Generator"                                 *blocks: print(title);
    4:  set :findLinkedBlocks:n @links                               *blocks: var n = @links;
    5:  jump *label13 lessThanEq :findLinkedBlocks:n 0               *blocks: while n > 0 do
        label *label102                                              ...
    6:  op sub :findLinkedBlocks:n :findLinkedBlocks:n 1             *blocks: var block = getlink(--n);
    7:  getlink :findLinkedBlocks:block :findLinkedBlocks:n          ...
    8:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
    9:  print :findLinkedBlocks:block                                ...
   10:  sensor :findLinkedBlocks:type :findLinkedBlocks:block @type  *blocks: var type = block.@type;
   11:  select :findLinkedBlocks:variable equal @large-logic-display *blocks: if requested == type then
   12:  set .display :findLinkedBlocks:variable                      *blocks: for requested, name, out variable, required in linkMap do
   13:  select :findLinkedBlocks:variable equal @memory-bank :findLi *blocks: if requested == type then
   14:  set .memory :findLinkedBlocks:variable                       *blocks: for requested, name, out variable, required in linkMap do
   15:  jump *label102 greaterThan :findLinkedBlocks:n 0             *blocks: while n > 0 do
        label *label13                                               ...
   16:  print "\nDisplay: {0}\nMemory: "                             *blocks: print($"\n$name: $variable");
   17:  format .display                                              ...
   18:  op and :findLinkedBlocks:foundAll 1 .display                 *blocks: if required then foundAll &= variable; end;
   19:  print .memory                                                *blocks: print($"\n$name: $variable");
   20:  op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll *blocks: if required then foundAll &= variable; end;
   21:  printflush null                                              *blocks: printflush(message);
   22:  jump *label3 equal :findLinkedBlocks:foundAll false          *blocks: do
   23:  setaddr :drawPixel*retaddr *label70                          mandelbrot-compute.mnd: MainLoop:
        label *label30                                               ...
   24:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   25:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
        label *label33                                               mandelbrot-compute.mnd: do wait(0); while start == $START;
   26:  wait 0                                                       ...
   27:  read *tmp24 .memory 66                                       ...
   28:  jump *label33 equal .start *tmp24                            ...
   29:  read .start .memory 66                                       mandelbrot-compute.mnd: start = $START;
   30:  read .stop .memory 67                                        mandelbrot-compute.mnd: stop = $STOP;
   31:  read .ZOOM .memory 70                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   32:  op div *tmp28 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   33:  read *tmp30 .memory 68                                       ...
   34:  op add .OFFSET_X *tmp28 *tmp30                               ...
   35:  read *tmp33 .memory 69                                       mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   36:  op add .OFFSET_Y *tmp28 *tmp33                               ...
   37:  read .JULIA .memory 71                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   38:  read .JULIA_X .memory 72                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   39:  read .JULIA_Y .memory 73                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   40:  read .PALETTE .memory 74                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   41:  op greaterThan .SMOOTH .PALETTE 1                            mandelbrot-compute.mnd: SMOOTH   = PALETTE > 1;
        label *label36                                               mandelbrot-compute.mnd: while true do
   42:  wait 0.004                              # 0.240 ticks for at mandelbrot-compute.mnd: atomic
   43:  read *tmp40 .memory 67                                       mandelbrot-compute.mnd: if stop != $STOP then
   44:  jump *label30 notEqual .stop *tmp40                          ...
   45:  read *tmp42 .memory 64                                       mandelbrot-compute.mnd: line = $LINE++;
   46:  op add *tmp0 *tmp42 1                                        ...
   47:  write *tmp0 .memory 64                  # The last atomic bl ...
   48:  jump *label30 greaterThanEq *tmp42 176                       mandelbrot-compute.mnd: if line >= DISPLAY_SIZE_LARGE then
   49:  multijump *tmp42 0 0                                         mandelbrot-compute.mnd: var x = case line
        multilabel *label165                                         ...
   50:  op mul *tmp55 2 *tmp42                                       mandelbrot-compute.mnd: else 2 * line - 2 * 88 + 1;
   51:  op sub *tmp46 *tmp55 175                                     ...
   52:  jump *label43 always 0 0                                     mandelbrot-compute.mnd: var x = case line
        multilabel *label162                                         ...
   53:  op mul *tmp46 8 *tmp42                                       mandelbrot-compute.mnd: when 0 ... 22 then 8 * line;
   54:  jump *label43 always 0 0                                     mandelbrot-compute.mnd: var x = case line
        multilabel *label163                                         ...
   55:  op mul *tmp49 8 *tmp42                                       mandelbrot-compute.mnd: when 22 ... 44 then 8 * line - 8 * 22 + 4;
   56:  op sub *tmp46 *tmp49 172                                     ...
   57:  jump *label43 always 0 0                                     mandelbrot-compute.mnd: var x = case line
        multilabel *label164                                         ...
   58:  op mul *tmp52 4 *tmp42                                       mandelbrot-compute.mnd: when 44 ... 88 then 4 * line - 4 * 44 + 2;
   59:  op sub *tmp46 *tmp52 174                                     ...
        label *label43                                               mandelbrot-compute.mnd: var x = case line
   60:  set :y 0                                                     mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
   61:  set :drawPixel:x *tmp46                                      ...
        label *label103                                              ...
   62:  op div *tmp59 *tmp46 .ZOOM                                   mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   63:  op add :compute:zx *tmp59 .OFFSET_X                          ...
   64:  op div *tmp61 :y .ZOOM                                       mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   65:  op add :compute:zy *tmp61 .OFFSET_Y                          ...
   66:  jump *label57 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   67:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
   68:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
   69:  jump *label58 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label57                                               ...
   70:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
   71:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
   72:  op sub *tmp64 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   73:  op len :compute:p *tmp64 :compute:zy                         ...
   74:  op mul *tmp66 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
   75:  op mul *tmp67 *tmp66 :compute:p                              ...
   76:  op sub *tmp68 :compute:p *tmp67                              ...
   77:  op add *tmp69 *tmp68 0.25                                    ...
   78:  jump *label59 greaterThan :compute:zx *tmp69                 ...
   79:  set *tmp58 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
   80:  jump *label56 always 0 0                                     ...
        label *label59                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
   81:  op add *tmp72 :compute:zx 1                                  mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
   82:  op len *tmp73 *tmp72 :compute:zy                             ...
   83:  jump *label61 greaterThan *tmp73 0.25                        ...
   84:  set *tmp58 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
   85:  jump *label56 always 0 0                                     ...
        label *label61                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label58                                               mandelbrot-compute.mnd: if JULIA then
   86:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
   87:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
   88:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
   89:  op mul *tmp77 :compute:zy :compute:zy                        ...
   90:  op sub *tmp78 *tmp76 *tmp77                                  ...
   91:  op add :compute:zx *tmp78 :compute:cx                        ...
   92:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
   93:  op mul *tmp81 *tmp80 :compute:zy                             ...
   94:  op add :compute:zy *tmp81 :compute:cy                        ...
   95:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
   96:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
   97:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
   98:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
   99:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  100:  op mul *tmp77 :compute:zy :compute:zy                        ...
  101:  op sub *tmp78 *tmp76 *tmp77                                  ...
  102:  op add :compute:zx *tmp78 :compute:cx                        ...
  103:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  104:  op mul *tmp81 *tmp80 :compute:zy                             ...
  105:  op add :compute:zy *tmp81 :compute:cy                        ...
  106:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  107:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  108:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  109:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  110:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  111:  op mul *tmp77 :compute:zy :compute:zy                        ...
  112:  op sub *tmp78 *tmp76 *tmp77                                  ...
  113:  op add :compute:zx *tmp78 :compute:cx                        ...
  114:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  115:  op mul *tmp81 *tmp80 :compute:zy                             ...
  116:  op add :compute:zy *tmp81 :compute:cy                        ...
  117:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  118:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  119:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  120:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  121:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  122:  op mul *tmp77 :compute:zy :compute:zy                        ...
  123:  op sub *tmp78 *tmp76 *tmp77                                  ...
  124:  op add :compute:zx *tmp78 :compute:cx                        ...
  125:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  126:  op mul *tmp81 *tmp80 :compute:zy                             ...
  127:  op add :compute:zy *tmp81 :compute:cy                        ...
  128:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  129:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  130:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  131:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  132:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  133:  op mul *tmp77 :compute:zy :compute:zy                        ...
  134:  op sub *tmp78 *tmp76 *tmp77                                  ...
  135:  op add :compute:zx *tmp78 :compute:cx                        ...
  136:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  137:  op mul *tmp81 *tmp80 :compute:zy                             ...
  138:  op add :compute:zy *tmp81 :compute:cy                        ...
  139:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  140:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  141:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  142:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  143:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  144:  op mul *tmp77 :compute:zy :compute:zy                        ...
  145:  op sub *tmp78 *tmp76 *tmp77                                  ...
  146:  op add :compute:zx *tmp78 :compute:cx                        ...
  147:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  148:  op mul *tmp81 *tmp80 :compute:zy                             ...
  149:  op add :compute:zy *tmp81 :compute:cy                        ...
  150:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  151:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  152:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  153:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  154:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  155:  op mul *tmp77 :compute:zy :compute:zy                        ...
  156:  op sub *tmp78 *tmp76 *tmp77                                  ...
  157:  op add :compute:zx *tmp78 :compute:cx                        ...
  158:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  159:  op mul *tmp81 *tmp80 :compute:zy                             ...
  160:  op add :compute:zy *tmp81 :compute:cy                        ...
  161:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  162:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  163:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  164:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  165:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  166:  op mul *tmp77 :compute:zy :compute:zy                        ...
  167:  op sub *tmp78 *tmp76 *tmp77                                  ...
  168:  op add :compute:zx *tmp78 :compute:cx                        ...
  169:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  170:  op mul *tmp81 *tmp80 :compute:zy                             ...
  171:  op add :compute:zy *tmp81 :compute:cy                        ...
  172:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  173:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  174:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  175:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  176:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  177:  op mul *tmp77 :compute:zy :compute:zy                        ...
  178:  op sub *tmp78 *tmp76 *tmp77                                  ...
  179:  op add :compute:zx *tmp78 :compute:cx                        ...
  180:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  181:  op mul *tmp81 *tmp80 :compute:zy                             ...
  182:  op add :compute:zy *tmp81 :compute:cy                        ...
  183:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  184:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  185:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  186:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  187:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  188:  op mul *tmp77 :compute:zy :compute:zy                        ...
  189:  op sub *tmp78 *tmp76 *tmp77                                  ...
  190:  op add :compute:zx *tmp78 :compute:cx                        ...
  191:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  192:  op mul *tmp81 *tmp80 :compute:zy                             ...
  193:  op add :compute:zy *tmp81 :compute:cy                        ...
  194:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  195:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  196:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  197:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  198:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  199:  op mul *tmp77 :compute:zy :compute:zy                        ...
  200:  op sub *tmp78 *tmp76 *tmp77                                  ...
  201:  op add :compute:zx *tmp78 :compute:cx                        ...
  202:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  203:  op mul *tmp81 *tmp80 :compute:zy                             ...
  204:  op add :compute:zy *tmp81 :compute:cy                        ...
  205:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  206:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  207:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  208:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  209:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  210:  op mul *tmp77 :compute:zy :compute:zy                        ...
  211:  op sub *tmp78 *tmp76 *tmp77                                  ...
  212:  op add :compute:zx *tmp78 :compute:cx                        ...
  213:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  214:  op mul *tmp81 *tmp80 :compute:zy                             ...
  215:  op add :compute:zy *tmp81 :compute:cy                        ...
  216:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  217:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  218:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  219:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  220:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  221:  op mul *tmp77 :compute:zy :compute:zy                        ...
  222:  op sub *tmp78 *tmp76 *tmp77                                  ...
  223:  op add :compute:zx *tmp78 :compute:cx                        ...
  224:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  225:  op mul *tmp81 *tmp80 :compute:zy                             ...
  226:  op add :compute:zy *tmp81 :compute:cy                        ...
  227:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  228:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  229:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  230:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  231:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  232:  op mul *tmp77 :compute:zy :compute:zy                        ...
  233:  op sub *tmp78 *tmp76 *tmp77                                  ...
  234:  op add :compute:zx *tmp78 :compute:cx                        ...
  235:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  236:  op mul *tmp81 *tmp80 :compute:zy                             ...
  237:  op add :compute:zy *tmp81 :compute:cy                        ...
  238:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  239:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  240:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  241:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  242:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  243:  op mul *tmp77 :compute:zy :compute:zy                        ...
  244:  op sub *tmp78 *tmp76 *tmp77                                  ...
  245:  op add :compute:zx *tmp78 :compute:cx                        ...
  246:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  247:  op mul *tmp81 *tmp80 :compute:zy                             ...
  248:  op add :compute:zy *tmp81 :compute:cy                        ...
  249:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  250:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  251:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  252:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  253:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  254:  op mul *tmp77 :compute:zy :compute:zy                        ...
  255:  op sub *tmp78 *tmp76 *tmp77                                  ...
  256:  op add :compute:zx *tmp78 :compute:cx                        ...
  257:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  258:  op mul *tmp81 *tmp80 :compute:zy                             ...
  259:  op add :compute:zy *tmp81 :compute:cy                        ...
  260:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  261:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  262:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  263:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  264:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  265:  op mul *tmp77 :compute:zy :compute:zy                        ...
  266:  op sub *tmp78 *tmp76 *tmp77                                  ...
  267:  op add :compute:zx *tmp78 :compute:cx                        ...
  268:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  269:  op mul *tmp81 *tmp80 :compute:zy                             ...
  270:  op add :compute:zy *tmp81 :compute:cy                        ...
  271:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  272:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  273:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  274:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  275:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  276:  op mul *tmp77 :compute:zy :compute:zy                        ...
  277:  op sub *tmp78 *tmp76 *tmp77                                  ...
  278:  op add :compute:zx *tmp78 :compute:cx                        ...
  279:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  280:  op mul *tmp81 *tmp80 :compute:zy                             ...
  281:  op add :compute:zy *tmp81 :compute:cy                        ...
  282:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  283:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  284:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  285:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  286:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  287:  op mul *tmp77 :compute:zy :compute:zy                        ...
  288:  op sub *tmp78 *tmp76 *tmp77                                  ...
  289:  op add :compute:zx *tmp78 :compute:cx                        ...
  290:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  291:  op mul *tmp81 *tmp80 :compute:zy                             ...
  292:  op add :compute:zy *tmp81 :compute:cy                        ...
  293:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  294:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  295:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  296:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  297:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  298:  op mul *tmp77 :compute:zy :compute:zy                        ...
  299:  op sub *tmp78 *tmp76 *tmp77                                  ...
  300:  op add :compute:zx *tmp78 :compute:cx                        ...
  301:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  302:  op mul *tmp81 *tmp80 :compute:zy                             ...
  303:  op add :compute:zy *tmp81 :compute:cy                        ...
  304:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  305:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  306:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  307:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  308:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  309:  op mul *tmp77 :compute:zy :compute:zy                        ...
  310:  op sub *tmp78 *tmp76 *tmp77                                  ...
  311:  op add :compute:zx *tmp78 :compute:cx                        ...
  312:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  313:  op mul *tmp81 *tmp80 :compute:zy                             ...
  314:  op add :compute:zy *tmp81 :compute:cy                        ...
  315:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  316:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  317:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  318:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  319:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  320:  op mul *tmp77 :compute:zy :compute:zy                        ...
  321:  op sub *tmp78 *tmp76 *tmp77                                  ...
  322:  op add :compute:zx *tmp78 :compute:cx                        ...
  323:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  324:  op mul *tmp81 *tmp80 :compute:zy                             ...
  325:  op add :compute:zy *tmp81 :compute:cy                        ...
  326:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  327:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  328:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  329:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  330:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  331:  op mul *tmp77 :compute:zy :compute:zy                        ...
  332:  op sub *tmp78 *tmp76 *tmp77                                  ...
  333:  op add :compute:zx *tmp78 :compute:cx                        ...
  334:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  335:  op mul *tmp81 *tmp80 :compute:zy                             ...
  336:  op add :compute:zy *tmp81 :compute:cy                        ...
  337:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  338:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  339:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  340:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  341:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  342:  op mul *tmp77 :compute:zy :compute:zy                        ...
  343:  op sub *tmp78 *tmp76 *tmp77                                  ...
  344:  op add :compute:zx *tmp78 :compute:cx                        ...
  345:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  346:  op mul *tmp81 *tmp80 :compute:zy                             ...
  347:  op add :compute:zy *tmp81 :compute:cy                        ...
  348:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  349:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  350:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  351:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  352:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  353:  op mul *tmp77 :compute:zy :compute:zy                        ...
  354:  op sub *tmp78 *tmp76 *tmp77                                  ...
  355:  op add :compute:zx *tmp78 :compute:cx                        ...
  356:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  357:  op mul *tmp81 *tmp80 :compute:zy                             ...
  358:  op add :compute:zy *tmp81 :compute:cy                        ...
  359:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  360:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  361:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  362:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  363:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  364:  op mul *tmp77 :compute:zy :compute:zy                        ...
  365:  op sub *tmp78 *tmp76 *tmp77                                  ...
  366:  op add :compute:zx *tmp78 :compute:cx                        ...
  367:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  368:  op mul *tmp81 *tmp80 :compute:zy                             ...
  369:  op add :compute:zy *tmp81 :compute:cy                        ...
  370:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  371:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  372:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  373:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  374:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  375:  op mul *tmp77 :compute:zy :compute:zy                        ...
  376:  op sub *tmp78 *tmp76 *tmp77                                  ...
  377:  op add :compute:zx *tmp78 :compute:cx                        ...
  378:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  379:  op mul *tmp81 *tmp80 :compute:zy                             ...
  380:  op add :compute:zy *tmp81 :compute:cy                        ...
  381:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  382:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  383:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  384:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  385:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  386:  op mul *tmp77 :compute:zy :compute:zy                        ...
  387:  op sub *tmp78 *tmp76 *tmp77                                  ...
  388:  op add :compute:zx *tmp78 :compute:cx                        ...
  389:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  390:  op mul *tmp81 *tmp80 :compute:zy                             ...
  391:  op add :compute:zy *tmp81 :compute:cy                        ...
  392:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  393:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  394:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  395:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  396:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  397:  op mul *tmp77 :compute:zy :compute:zy                        ...
  398:  op sub *tmp78 *tmp76 *tmp77                                  ...
  399:  op add :compute:zx *tmp78 :compute:cx                        ...
  400:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  401:  op mul *tmp81 *tmp80 :compute:zy                             ...
  402:  op add :compute:zy *tmp81 :compute:cy                        ...
  403:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  404:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  405:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  406:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  407:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  408:  op mul *tmp77 :compute:zy :compute:zy                        ...
  409:  op sub *tmp78 *tmp76 *tmp77                                  ...
  410:  op add :compute:zx *tmp78 :compute:cx                        ...
  411:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  412:  op mul *tmp81 *tmp80 :compute:zy                             ...
  413:  op add :compute:zy *tmp81 :compute:cy                        ...
  414:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  415:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  416:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  417:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  418:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  419:  op mul *tmp77 :compute:zy :compute:zy                        ...
  420:  op sub *tmp78 *tmp76 *tmp77                                  ...
  421:  op add :compute:zx *tmp78 :compute:cx                        ...
  422:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  423:  op mul *tmp81 *tmp80 :compute:zy                             ...
  424:  op add :compute:zy *tmp81 :compute:cy                        ...
  425:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  426:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  427:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  428:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  429:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  430:  op mul *tmp77 :compute:zy :compute:zy                        ...
  431:  op sub *tmp78 *tmp76 *tmp77                                  ...
  432:  op add :compute:zx *tmp78 :compute:cx                        ...
  433:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  434:  op mul *tmp81 *tmp80 :compute:zy                             ...
  435:  op add :compute:zy *tmp81 :compute:cy                        ...
  436:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  437:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  438:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  439:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  440:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  441:  op mul *tmp77 :compute:zy :compute:zy                        ...
  442:  op sub *tmp78 *tmp76 *tmp77                                  ...
  443:  op add :compute:zx *tmp78 :compute:cx                        ...
  444:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  445:  op mul *tmp81 *tmp80 :compute:zy                             ...
  446:  op add :compute:zy *tmp81 :compute:cy                        ...
  447:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  448:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  449:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  450:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  451:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  452:  op mul *tmp77 :compute:zy :compute:zy                        ...
  453:  op sub *tmp78 *tmp76 *tmp77                                  ...
  454:  op add :compute:zx *tmp78 :compute:cx                        ...
  455:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  456:  op mul *tmp81 *tmp80 :compute:zy                             ...
  457:  op add :compute:zy *tmp81 :compute:cy                        ...
  458:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  459:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  460:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  461:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  462:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  463:  op mul *tmp77 :compute:zy :compute:zy                        ...
  464:  op sub *tmp78 *tmp76 *tmp77                                  ...
  465:  op add :compute:zx *tmp78 :compute:cx                        ...
  466:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  467:  op mul *tmp81 *tmp80 :compute:zy                             ...
  468:  op add :compute:zy *tmp81 :compute:cy                        ...
  469:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  470:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  471:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  472:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  473:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  474:  op mul *tmp77 :compute:zy :compute:zy                        ...
  475:  op sub *tmp78 *tmp76 *tmp77                                  ...
  476:  op add :compute:zx *tmp78 :compute:cx                        ...
  477:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  478:  op mul *tmp81 *tmp80 :compute:zy                             ...
  479:  op add :compute:zy *tmp81 :compute:cy                        ...
  480:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  481:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  482:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  483:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  484:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  485:  op mul *tmp77 :compute:zy :compute:zy                        ...
  486:  op sub *tmp78 *tmp76 *tmp77                                  ...
  487:  op add :compute:zx *tmp78 :compute:cx                        ...
  488:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  489:  op mul *tmp81 *tmp80 :compute:zy                             ...
  490:  op add :compute:zy *tmp81 :compute:cy                        ...
  491:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  492:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  493:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  494:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  495:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  496:  op mul *tmp77 :compute:zy :compute:zy                        ...
  497:  op sub *tmp78 *tmp76 *tmp77                                  ...
  498:  op add :compute:zx *tmp78 :compute:cx                        ...
  499:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  500:  op mul *tmp81 *tmp80 :compute:zy                             ...
  501:  op add :compute:zy *tmp81 :compute:cy                        ...
  502:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  503:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  504:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  505:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  506:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  507:  op mul *tmp77 :compute:zy :compute:zy                        ...
  508:  op sub *tmp78 *tmp76 *tmp77                                  ...
  509:  op add :compute:zx *tmp78 :compute:cx                        ...
  510:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  511:  op mul *tmp81 *tmp80 :compute:zy                             ...
  512:  op add :compute:zy *tmp81 :compute:cy                        ...
  513:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  514:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  515:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  516:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  517:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  518:  op mul *tmp77 :compute:zy :compute:zy                        ...
  519:  op sub *tmp78 *tmp76 *tmp77                                  ...
  520:  op add :compute:zx *tmp78 :compute:cx                        ...
  521:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  522:  op mul *tmp81 *tmp80 :compute:zy                             ...
  523:  op add :compute:zy *tmp81 :compute:cy                        ...
  524:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  525:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  526:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  527:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  528:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  529:  op mul *tmp77 :compute:zy :compute:zy                        ...
  530:  op sub *tmp78 *tmp76 *tmp77                                  ...
  531:  op add :compute:zx *tmp78 :compute:cx                        ...
  532:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  533:  op mul *tmp81 *tmp80 :compute:zy                             ...
  534:  op add :compute:zy *tmp81 :compute:cy                        ...
  535:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  536:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  537:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  538:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  539:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  540:  op mul *tmp77 :compute:zy :compute:zy                        ...
  541:  op sub *tmp78 *tmp76 *tmp77                                  ...
  542:  op add :compute:zx *tmp78 :compute:cx                        ...
  543:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  544:  op mul *tmp81 *tmp80 :compute:zy                             ...
  545:  op add :compute:zy *tmp81 :compute:cy                        ...
  546:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  547:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  548:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  549:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  550:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  551:  op mul *tmp77 :compute:zy :compute:zy                        ...
  552:  op sub *tmp78 *tmp76 *tmp77                                  ...
  553:  op add :compute:zx *tmp78 :compute:cx                        ...
  554:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  555:  op mul *tmp81 *tmp80 :compute:zy                             ...
  556:  op add :compute:zy *tmp81 :compute:cy                        ...
  557:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  558:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  559:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  560:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  561:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  562:  op mul *tmp77 :compute:zy :compute:zy                        ...
  563:  op sub *tmp78 *tmp76 *tmp77                                  ...
  564:  op add :compute:zx *tmp78 :compute:cx                        ...
  565:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  566:  op mul *tmp81 *tmp80 :compute:zy                             ...
  567:  op add :compute:zy *tmp81 :compute:cy                        ...
  568:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  569:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  570:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  571:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  572:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  573:  op mul *tmp77 :compute:zy :compute:zy                        ...
  574:  op sub *tmp78 *tmp76 *tmp77                                  ...
  575:  op add :compute:zx *tmp78 :compute:cx                        ...
  576:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  577:  op mul *tmp81 *tmp80 :compute:zy                             ...
  578:  op add :compute:zy *tmp81 :compute:cy                        ...
  579:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  580:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  581:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  582:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  583:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  584:  op mul *tmp77 :compute:zy :compute:zy                        ...
  585:  op sub *tmp78 *tmp76 *tmp77                                  ...
  586:  op add :compute:zx *tmp78 :compute:cx                        ...
  587:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  588:  op mul *tmp81 *tmp80 :compute:zy                             ...
  589:  op add :compute:zy *tmp81 :compute:cy                        ...
  590:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  591:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  592:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  593:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  594:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  595:  op mul *tmp77 :compute:zy :compute:zy                        ...
  596:  op sub *tmp78 *tmp76 *tmp77                                  ...
  597:  op add :compute:zx *tmp78 :compute:cx                        ...
  598:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  599:  op mul *tmp81 *tmp80 :compute:zy                             ...
  600:  op add :compute:zy *tmp81 :compute:cy                        ...
  601:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  602:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  603:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  604:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  605:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  606:  op mul *tmp77 :compute:zy :compute:zy                        ...
  607:  op sub *tmp78 *tmp76 *tmp77                                  ...
  608:  op add :compute:zx *tmp78 :compute:cx                        ...
  609:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  610:  op mul *tmp81 *tmp80 :compute:zy                             ...
  611:  op add :compute:zy *tmp81 :compute:cy                        ...
  612:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  613:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  614:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  615:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  616:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  617:  op mul *tmp77 :compute:zy :compute:zy                        ...
  618:  op sub *tmp78 *tmp76 *tmp77                                  ...
  619:  op add :compute:zx *tmp78 :compute:cx                        ...
  620:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  621:  op mul *tmp81 *tmp80 :compute:zy                             ...
  622:  op add :compute:zy *tmp81 :compute:cy                        ...
  623:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  624:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  625:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  626:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  627:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  628:  op mul *tmp77 :compute:zy :compute:zy                        ...
  629:  op sub *tmp78 *tmp76 *tmp77                                  ...
  630:  op add :compute:zx *tmp78 :compute:cx                        ...
  631:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  632:  op mul *tmp81 *tmp80 :compute:zy                             ...
  633:  op add :compute:zy *tmp81 :compute:cy                        ...
  634:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  635:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  636:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  637:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  638:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  639:  op mul *tmp77 :compute:zy :compute:zy                        ...
  640:  op sub *tmp78 *tmp76 *tmp77                                  ...
  641:  op add :compute:zx *tmp78 :compute:cx                        ...
  642:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  643:  op mul *tmp81 *tmp80 :compute:zy                             ...
  644:  op add :compute:zy *tmp81 :compute:cy                        ...
  645:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  646:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  647:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  648:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  649:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  650:  op mul *tmp77 :compute:zy :compute:zy                        ...
  651:  op sub *tmp78 *tmp76 *tmp77                                  ...
  652:  op add :compute:zx *tmp78 :compute:cx                        ...
  653:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  654:  op mul *tmp81 *tmp80 :compute:zy                             ...
  655:  op add :compute:zy *tmp81 :compute:cy                        ...
  656:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  657:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  658:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  659:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  660:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  661:  op mul *tmp77 :compute:zy :compute:zy                        ...
  662:  op sub *tmp78 *tmp76 *tmp77                                  ...
  663:  op add :compute:zx *tmp78 :compute:cx                        ...
  664:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  665:  op mul *tmp81 *tmp80 :compute:zy                             ...
  666:  op add :compute:zy *tmp81 :compute:cy                        ...
  667:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  668:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  669:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  670:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  671:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  672:  op mul *tmp77 :compute:zy :compute:zy                        ...
  673:  op sub *tmp78 *tmp76 *tmp77                                  ...
  674:  op add :compute:zx *tmp78 :compute:cx                        ...
  675:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  676:  op mul *tmp81 *tmp80 :compute:zy                             ...
  677:  op add :compute:zy *tmp81 :compute:cy                        ...
  678:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  679:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  680:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  681:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  682:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  683:  op mul *tmp77 :compute:zy :compute:zy                        ...
  684:  op sub *tmp78 *tmp76 *tmp77                                  ...
  685:  op add :compute:zx *tmp78 :compute:cx                        ...
  686:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  687:  op mul *tmp81 *tmp80 :compute:zy                             ...
  688:  op add :compute:zy *tmp81 :compute:cy                        ...
  689:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  690:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  691:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  692:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  693:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  694:  op mul *tmp77 :compute:zy :compute:zy                        ...
  695:  op sub *tmp78 *tmp76 *tmp77                                  ...
  696:  op add :compute:zx *tmp78 :compute:cx                        ...
  697:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  698:  op mul *tmp81 *tmp80 :compute:zy                             ...
  699:  op add :compute:zy *tmp81 :compute:cy                        ...
  700:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  701:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  702:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  703:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  704:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  705:  op mul *tmp77 :compute:zy :compute:zy                        ...
  706:  op sub *tmp78 *tmp76 *tmp77                                  ...
  707:  op add :compute:zx *tmp78 :compute:cx                        ...
  708:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  709:  op mul *tmp81 *tmp80 :compute:zy                             ...
  710:  op add :compute:zy *tmp81 :compute:cy                        ...
  711:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  712:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  713:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  714:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  715:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  716:  op mul *tmp77 :compute:zy :compute:zy                        ...
  717:  op sub *tmp78 *tmp76 *tmp77                                  ...
  718:  op add :compute:zx *tmp78 :compute:cx                        ...
  719:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  720:  op mul *tmp81 *tmp80 :compute:zy                             ...
  721:  op add :compute:zy *tmp81 :compute:cy                        ...
  722:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  723:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  724:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  725:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  726:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  727:  op mul *tmp77 :compute:zy :compute:zy                        ...
  728:  op sub *tmp78 *tmp76 *tmp77                                  ...
  729:  op add :compute:zx *tmp78 :compute:cx                        ...
  730:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  731:  op mul *tmp81 *tmp80 :compute:zy                             ...
  732:  op add :compute:zy *tmp81 :compute:cy                        ...
  733:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  734:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  735:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  736:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  737:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  738:  op mul *tmp77 :compute:zy :compute:zy                        ...
  739:  op sub *tmp78 *tmp76 *tmp77                                  ...
  740:  op add :compute:zx *tmp78 :compute:cx                        ...
  741:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  742:  op mul *tmp81 *tmp80 :compute:zy                             ...
  743:  op add :compute:zy *tmp81 :compute:cy                        ...
  744:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  745:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  746:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  747:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  748:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  749:  op mul *tmp77 :compute:zy :compute:zy                        ...
  750:  op sub *tmp78 *tmp76 *tmp77                                  ...
  751:  op add :compute:zx *tmp78 :compute:cx                        ...
  752:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  753:  op mul *tmp81 *tmp80 :compute:zy                             ...
  754:  op add :compute:zy *tmp81 :compute:cy                        ...
  755:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  756:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  757:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  758:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  759:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  760:  op mul *tmp77 :compute:zy :compute:zy                        ...
  761:  op sub *tmp78 *tmp76 *tmp77                                  ...
  762:  op add :compute:zx *tmp78 :compute:cx                        ...
  763:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  764:  op mul *tmp81 *tmp80 :compute:zy                             ...
  765:  op add :compute:zy *tmp81 :compute:cy                        ...
  766:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  767:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  768:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  769:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  770:  op mul *tmp76 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  771:  op mul *tmp77 :compute:zy :compute:zy                        ...
  772:  op sub *tmp78 *tmp76 *tmp77                                  ...
  773:  op add :compute:zx *tmp78 :compute:cx                        ...
  774:  op mul *tmp80 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  775:  op mul *tmp81 *tmp80 :compute:zy                             ...
  776:  op add :compute:zy *tmp81 :compute:cy                        ...
  777:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  778:  jump *label65 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  779:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label65                                               ...
  780:  op mul *tmp86 .SMOOTH 63                                     mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  781:  jump *label68 greaterThanEq :compute:i *tmp86                ...
  782:  op log *tmp89 :compute:dist 0                                mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  783:  op mul *tmp90 *tmp89 0.36067376022224085                     ...
  784:  op log *tmp91 *tmp90 0                                       ...
  785:  op mul *tmp92 *tmp91 1.4426950408889634                      ...
  786:  op sub :compute:correction 4 *tmp92                          ...
  787:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label68                                               mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  788:  set *tmp58 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label56                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  789:  set :drawPixel:y :y                                          mandelbrot-compute.mnd: drawPixel(x, y, iterations);
  790:  set :drawPixel:iterations *tmp58                             ...
  791:  call *label0 *invalid :drawPixel*retval                      ...
        label *label70                                               ...
  792:  wait 0.002667                           # 0.160 ticks for at mandelbrot-compute.mnd: atomic $COMPLETED++; end;
  793:  read *tmp94 .memory 65                                       ...
  794:  op add *tmp1 *tmp94 1                                        ...
  795:  write *tmp1 .memory 65                  # The last atomic bl ...
  796:  read *tmp97 .memory 67                                       mandelbrot-compute.mnd: if stop != $STOP then
  797:  jump *label30 notEqual .stop *tmp97                          ...
  798:  op add :y :y 1                                               mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
  799:  jump *label103 lessThan :y 176                               ...
        label *label141                                              mandelbrot-compute.mnd: do while !display.@enabled;
  800:  sensor *tmp158 .display @enabled                             ...
  801:  jump *label141 equal *tmp158 false                           ...
  802:  jump *label147 lessThanEq .localBuffer 4                     mandelbrot-compute.mnd: if localBuffer > 4 then
        label *label144                                              mandelbrot-compute.mnd: do
  803:  wait 0.0001                                                  mandelbrot-compute.mnd: wait(1e-4);
  804:  sensor *tmp162 .display @bufferSize                          mandelbrot-compute.mnd: while display.@bufferSize > 250;
  805:  jump *label144 greaterThan *tmp162 250                       mandelbrot-compute.mnd: do
        label *label147                                              mandelbrot-compute.mnd: if localBuffer > 4 then
  806:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  807:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
  808:  jump *label36 always 0 0                                     mandelbrot-compute.mnd: while true do
        label *label0                                                mandelbrot-compute.mnd: noinline void drawPixel(x, y, iterations)
  809:  jump *label75 equal .SMOOTH false                            mandelbrot-compute.mnd: if SMOOTH then
  810:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  811:  jump *label76 equal :drawPixel:iterations 63                 mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  812:  multijump .PALETTE 0 0                                       mandelbrot-compute.mnd: case PALETTE
        multilabel *label172                                         ...
        multilabel *label168                                         ...
  813:  op div *tmp139 :drawPixel:iterations 63.75                   mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  814:  op sub :drawPixel:r 1 *tmp139                                ...
  815:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  816:  jump *label76 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label169                                         ...
  817:  op sub *tmp104 32 :drawPixel:iterations                      mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  818:  op abs *tmp105 *tmp104 0                                     ...
  819:  op div *tmp107 *tmp105 36.42857142857143                     ...
  820:  op sub :drawPixel:r 1 *tmp107                                ...
  821:  op sub *tmp109 :drawPixel:iterations 32                      mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  822:  op abs *tmp110 *tmp109 0                                     ...
  823:  op div *tmp112 *tmp110 42.5                                  ...
  824:  op sub :drawPixel:g 0.9411764705882353 *tmp112               ...
  825:  op div *tmp117 *tmp105 63.75                                 mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  826:  op add :drawPixel:b 0.47058823529411764 *tmp117              ...
  827:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  828:  jump *label76 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label170                                         ...
  829:  op div *tmp121 :drawPixel:iterations 0.175                   mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  830:  op sin :drawPixel:r *tmp121 0                                ...
  831:  op cos :drawPixel:g *tmp121 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  832:  op sub *tmp126 :drawPixel:iterations 32                      mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  833:  op abs *tmp127 *tmp126 0                                     ...
  834:  op div *tmp129 *tmp127 63.75                                 ...
  835:  op add :drawPixel:b 0.39215686274509803 *tmp129              ...
  836:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  837:  jump *label76 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label171                                         ...
  838:  op div :drawPixel:r :drawPixel:iterations 63.75              mandelbrot-compute.mnd: r = 4 * iterations / 255;
  839:  op div *tmp135 :drawPixel:iterations 170                     mandelbrot-compute.mnd: g = 96 + 1.5 * iterations / 255;
  840:  op add :drawPixel:g 96 *tmp135                               ...
  841:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  842:  jump *label76 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label75                                               ...
  843:  read :drawPixel:color .memory :drawPixel:iterations          mandelbrot-compute.mnd: color = memory[iterations];
        label *label76                                               mandelbrot-compute.mnd: if SMOOTH then
  844:  jump *label86 lessThan .localBuffer 254                      mandelbrot-compute.mnd: if localBuffer >= 254 then
        label *label151                                              mandelbrot-compute.mnd: do while !display.@enabled;
  845:  sensor *tmp158 .display @enabled                             ...
  846:  jump *label151 equal *tmp158 false                           ...
  847:  jump *label157 lessThanEq .localBuffer 4                     mandelbrot-compute.mnd: if localBuffer > 4 then
        label *label154                                              mandelbrot-compute.mnd: do
  848:  wait 0.0001                                                  mandelbrot-compute.mnd: wait(1e-4);
  849:  sensor *tmp162 .display @bufferSize                          mandelbrot-compute.mnd: while display.@bufferSize > 250;
  850:  jump *label154 greaterThan *tmp162 250                       mandelbrot-compute.mnd: do
        label *label157                                              mandelbrot-compute.mnd: if localBuffer > 4 then
  851:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  852:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
        label *label86                                               mandelbrot-compute.mnd: if localBuffer >= 254 then
  853:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  854:  draw rect :drawPixel:x :drawPixel:y 1 1 0 0                  mandelbrot-compute.mnd: rect(x, y, 1, 1);
  855:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
  856:  sensor *tmp148 .display @enabled                             mandelbrot-compute.mnd: var disabled = 1 - display.enabled;
  857:  op sub :drawPixel:disabled 1 *tmp148                         ...
  858:  sensor *tmp150 .display @bufferSize                          mandelbrot-compute.mnd: var usage = display.@bufferSize + disabled * 900;
  859:  op mul *tmp151 :drawPixel:disabled 900                       ...
  860:  op add :drawPixel:usage *tmp150 *tmp151                      ...
  861:  jump *label89 greaterThanEq :drawPixel:usage 100             mandelbrot-compute.mnd: if usage < 100 then
  862:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  863:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
  864:  return :drawPixel*retaddr                                    mandelbrot-compute.mnd: if usage < 100 then
        label *label89                                               ...
  865:  op div *tmp155 1800 .localBuffer                             mandelbrot-compute.mnd: elsif usage < 1800 / localBuffer then
  866:  jump *label91 greaterThanEq :drawPixel:usage *tmp155         ...
  867:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  868:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
        label *label91                                               mandelbrot-compute.mnd: elsif usage < 1800 / localBuffer then
  869:  return :drawPixel*retaddr                                    mandelbrot-compute.mnd: noinline void drawPixel(x, y, iterations)


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   727     1x    727,0  def compute(in x, in y)
    54     1x     54,0  noinline void drawPixel(in x, in y, in iterations)
    52     1x     52,0  <no function>
    22     1x     22,0  inline void findLinkedBlocks(in title, in message, in linkMap...)
    16     2x      8,0  void flushLocalBuffer()
Runtime error at instruction #27: 'read *tmp24 .memory 66':
Execution step limit of 100,000 exceeded.

Performance: parsed in 295 ms, compiled in 315 ms, optimized in 1,400 ms, run in 88 ms.

Compiled mlog code was sent to Mlog Watcher.
  Mlog Watcher: no processor selected.
  (The target processor must be selected in Mindustry to receive the code.)

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: large-logic-display
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-bank
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Found: memory-cell
Display: large-logic-display
Memory: memory-bank
