   407 instructions before optimizations.
    44 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    44 instructions eliminated by Dead Code Elimination (6 iterations).
     3 instructions eliminated by Jump Normalization (2 passes, 5 iterations).
    22 instructions eliminated by Jump Optimization (5 iterations).
    18 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     2 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
     1 instructions eliminated by If Expression Optimization (3 iterations).
    53 instructions eliminated by Data Flow Optimization (5 passes, 21 iterations).
     1 loops improved by Loop Hoisting.
     3 instructions eliminated by Loop Optimization (3 iterations).
     5 loops improved by Loop Optimization.
   742 instructions added by Loop Unrolling (9 iterations).
     4 loops unrolled by Loop Unrolling.
     9 instructions added by Function Inlining (9 iterations).
     4 function calls inlined by Function Inlining.
    68 instructions eliminated by Jump Straightening (2 passes, 5 iterations).
     4 instructions updated by JumpThreading.
     5 instructions eliminated by Unreachable Code Elimination (2 iterations).
     7 instructions eliminated by Print Merging.
   887 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 768):
  * Unroll iteration loop at *blocks:59:9                        size   -15, benefit      375.0, efficiency   Infinity (-4 instructions)
    Unroll iteration loop at *blocks:68:13                       size    -7, benefit     9375.0, efficiency   Infinity
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
    Unroll loop at mandelbrot-compute.mnd:136:5                  size  +679, benefit 24609375.0, efficiency  36243.557
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:207:1 size    +4, benefit    11793.8, efficiency   2948.438
    Inline function 'setState' defined at mandelbrot-compute.mnd:217:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:52:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:60:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:192:9         size    +5, benefit    11718.8, efficiency   2343.750
    Inline function call at mandelbrot-compute.mnd:107:9         size    +5, benefit       75.0, efficiency     15.000

Pass 1: speed optimization selection (cost limit 772):
  * Unroll iteration loop at *blocks:68:13                       size    -7, benefit     9375.0, efficiency   Infinity (-5 instructions)
    Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity
    Unroll loop at mandelbrot-compute.mnd:136:5                  size  +679, benefit 24609375.0, efficiency  36243.557
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:207:1 size    +4, benefit    11793.8, efficiency   2948.438
    Inline function 'setState' defined at mandelbrot-compute.mnd:217:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:52:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:60:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:192:9         size    +5, benefit    11718.8, efficiency   2343.750
    Inline function call at mandelbrot-compute.mnd:107:9         size    +5, benefit       75.0, efficiency     15.000

Pass 1: speed optimization selection (cost limit 777):
  * Unroll iteration loop at *blocks:77:9                        size    -1, benefit      375.0, efficiency   Infinity (-2 instructions)
    Unroll loop at mandelbrot-compute.mnd:136:5                  size  +679, benefit 24609375.0, efficiency  36243.557
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:207:1 size    +4, benefit    11793.8, efficiency   2948.438
    Inline function 'setState' defined at mandelbrot-compute.mnd:217:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:52:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:60:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:192:9         size    +5, benefit    11718.8, efficiency   2343.750
    Inline function call at mandelbrot-compute.mnd:107:9         size    +5, benefit       75.0, efficiency     15.000

Pass 1: speed optimization selection (cost limit 779):
  * Unroll loop at mandelbrot-compute.mnd:136:5                  size  +679, benefit 24609375.0, efficiency  36243.557 (+743 instructions)
    Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:207:1 size    +4, benefit    11793.8, efficiency   2948.438
    Inline function 'setState' defined at mandelbrot-compute.mnd:217:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:52:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:60:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:192:9         size    +5, benefit    11718.8, efficiency   2343.750
    Inline function call at mandelbrot-compute.mnd:107:9         size    +5, benefit       75.0, efficiency     15.000

Pass 1: speed optimization selection (cost limit 36):
  * Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:207:1 size    +4, benefit    11793.8, efficiency   2948.438 (+0 instructions)
    Inline function 'setState' defined at mandelbrot-compute.mnd:217:1 size   +13, benefit     2275.0, efficiency    175.000
    Inline function call at mandelbrot-compute.mnd:52:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:60:9          size   +14, benefit       87.5, efficiency      6.250
    Inline function call at mandelbrot-compute.mnd:192:9         size    +5, benefit    11718.8, efficiency   2343.750
    Inline function call at mandelbrot-compute.mnd:107:9         size    +5, benefit       75.0, efficiency     15.000

Pass 1: speed optimization selection (cost limit 36):
  * Inline function 'setState' defined at mandelbrot-compute.mnd:217:1 size   +13, benefit     2275.0, efficiency    175.000 (+7 instructions)
    Inline function call at mandelbrot-compute.mnd:52:13         size   +14, benefit     2187.5, efficiency    156.250
    Inline function call at mandelbrot-compute.mnd:60:9          size   +14, benefit       87.5, efficiency      6.250

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
   282 set *tmp79 :drawPixel:color
   283 jump *label64 always
   284 label *label63
-    * set *tmp81 .PALETTE
-    * jump *label67 equal *tmp81 2
+  285 jump *label67 equal .PALETTE 2
   286 jump *label66 always
   287 label *label67
   288 op sub *tmp82 32 :drawPixel:iterations
 
   308 set *tmp80 :drawPixel:color
   309 jump *label65 always
   310 label *label66
-    * jump *label69 equal *tmp81 3
+  311 jump *label69 equal .PALETTE 3
   312 jump *label68 always
   313 label *label69
   314 op div *tmp98 :drawPixel:iterations 63
 
   330 set *tmp80 :drawPixel:color
   331 jump *label65 always
   332 label *label68
-    * jump *label71 equal *tmp81 4
+  333 jump *label71 equal .PALETTE 4
   334 jump *label70 always
   335 label *label71
   336 op mul *tmp110 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-30 instructions):
 
    66 label *label21
    67 set *tmp21 null
    68 label *label22
-    * set *tmp19 *tmp21
    69 jump *label20 always
    70 label *label19
-    * set *tmp19 null
    71 label *label20
    72 label *label15
    73 multijump *tmp17 0 0 (m:marker1)
 
    99 print :findLinkedBlocks:variable
   100 jump *label28 equal :findLinkedBlocks:required false
   101 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * set *tmp23 :findLinkedBlocks:foundAll
   102 jump *label29 always
   103 label *label28
-    * set *tmp23 null
   104 label *label29
   105 label *label24
   106 multijump *tmp22 0 0 (m:marker2)
 
   186 jump *label47 equal .JULIA false
   187 set :compute:cx .JULIA_X
   188 set :compute:cy .JULIA_Y
-    * set *tmp46 :compute:cy
   189 jump *label48 always
   190 label *label47
   191 set :compute:cx :compute:zx
 
   201 jump *label49 equal *tmp53 false
   202 set *tmp41 63
   203 jump *label46 always
-    * set *tmp54 null
   204 jump *label50 always
   205 label *label49
-    * set *tmp54 null
   206 label *label50
   207 op add *tmp55 :compute:cx 1
   208 op len *tmp56 *tmp55 :compute:cy
 
   215 label *label51
   216 set *tmp58 null
   217 label *label52
-    * set *tmp46 *tmp58
   218 label *label48
   219 set :compute:i 0
   220 label *label53
 
   235 op greaterThanEq *tmp67 :compute:dist 64
   236 jump *label56 equal *tmp67 false
   237 jump *label55 always
-    * set *tmp68 null
   238 jump *label57 always
   239 label *label56
-    * set *tmp68 null
   240 label *label57
   241 label *label54
   242 op add :compute:i :compute:i 1
 
   252 op sub *tmp76 4 *tmp75
   253 set :compute:correction *tmp76
   254 op add :compute:i :compute:i :compute:correction
-    * set *tmp71 :compute:i
   255 jump *label59 always
   256 label *label58
-    * set *tmp71 null
   257 label *label59
   258 set *tmp41 :compute:i
   259 jump *label46 always
 
   343 label *label65
   344 set *tmp79 *tmp80
   345 label *label64
-    * set *tmp77 *tmp79
   346 jump *label62 always
   347 label *label61
   348 set *tmp120 :drawPixel:iterations
   349 read *tmp121 .memory *tmp120
   350 set :drawPixel:color *tmp121
-    * set *tmp77 :drawPixel:color
   351 label *label62
   352 op greaterThanEq *tmp122 .localBuffer 250
   353 jump *label72 equal *tmp122 false
   354 setaddr :flushLocalBuffer*retaddr *label74 (h:*label74)
   355 call *label0 *invalid :flushLocalBuffer*retval (m:*label74) (h:*label74)
   356 label *label74
-    * set *tmp123 null
   357 jump *label73 always
   358 label *label72
-    * set *tmp123 null
   359 label *label73
   360 draw col :drawPixel:color
   361 draw rect :drawPixel:x :drawPixel:y 1 1
 
   372 label *label77
   373 set *tmp128 null
   374 label *label78
-    * set *tmp125 *tmp128
   375 jump *label76 always
   376 label *label75
-    * set *tmp125 null
   377 label *label76
   378 label *label60
   379 set *tmp129 :position
 
   381 op notEqual *tmp131 *tmp130 .PROCESSOR_ID
   382 jump *label79 equal *tmp131 false
   383 jump *label45 always
-    * set *tmp132 null
   384 jump *label80 always
   385 label *label79
-    * set *tmp132 null
   386 label *label80
   387 read *tmp1 .memory 65
   388 op notEqual *tmp133 .stop *tmp1
   389 jump *label81 equal *tmp133 false
   390 jump *label40 always
-    * set *tmp134 null
   391 jump *label82 always
   392 label *label81
-    * set *tmp134 null
   393 label *label82
   394 label *label44
   395 op add :y :y 1
   396 jump *label43 always
   397 label *label45
-    * set *tmp38 null
   398 jump *label42 always
   399 label *label41
-    * set *tmp38 null
   400 label *label42
   401 op add :line :line :increment
   402 op greaterThan *tmp135 :line 176
 
   405 set :increment :next_increment
   406 op div *tmp137 :increment 2
   407 set :line *tmp137
-    * set *tmp136 :line
   408 jump *label84 always
   409 label *label83
-    * set *tmp136 null
   410 label *label84
   411 label *label39
   412 op add :lines :lines 1
 
   429 op greaterThan *tmp141 *tmp140 250
   430 jump *label89 notEqual *tmp141 false
   431 label *label91
-    * set *tmp139 null
   432 jump *label88 always
   433 label *label87
-    * set *tmp139 null
   434 label *label88
   435 drawflush .display
   436 set .localBuffer 0
 
   448 set *tmp147 .PROC_STATE_INDEX
   449 write :setState:state .memory *tmp147
   450 jump *label95 always
-    * set *tmp146 null
   451 jump *label97 always
   452 label *label96
   453 set *tmp149 .PROC_ID_INDEX
 
   466 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
   467 set *tmp152 .PROC_STATE_INDEX
   468 label *label99
-    * set *tmp146 *tmp152
   469 label *label97
   470 label *label94
   471 jump *label93 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-10 instructions):
 
    61 op equal *tmp20 :findLinkedBlocks:requested @message
    62 jump *label21 equal *tmp20 false
    63 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * set *tmp21 :findLinkedBlocks:message
    64 jump *label22 always
    65 label *label21
-    * set *tmp21 null
    66 label *label22
    67 jump *label20 always
    68 label *label19
 
   208 jump *label51 equal *tmp57 false
   209 set *tmp41 63
   210 jump *label46 always
-    * set *tmp58 null
   211 jump *label52 always
   212 label *label51
-    * set *tmp58 null
   213 label *label52
   214 label *label48
   215 set :compute:i 0
 
   263 op equal *tmp78 :drawPixel:iterations 63
   264 jump *label63 equal *tmp78 false
   265 set :drawPixel:color %[black]
-    * set *tmp79 :drawPixel:color
   266 jump *label64 always
   267 label *label63
   268 jump *label67 equal .PALETTE 2
 
   336 set :drawPixel:color *tmp119
   337 set *tmp80 :drawPixel:color
   338 label *label65
-    * set *tmp79 *tmp80
   339 label *label64
   340 jump *label62 always
   341 label *label61
 
   361 jump *label77 equal *tmp127 false
   362 drawflush .display
   363 set .localBuffer 0
-    * set *tmp128 .localBuffer
   364 jump *label78 always
   365 label *label77
-    * set *tmp128 null
   366 label *label78
   367 jump *label76 always
   368 label *label75
 
   451 set *tmp155 .PROC_STATE_INDEX
   452 write :setState:state .memory *tmp155
   453 jump *label95 always
-    * set *tmp152 null
   454 jump *label99 always
   455 label *label98
   456 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
   457 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * set *tmp152 .PROC_STATE_INDEX
   458 label *label99
   459 label *label97
   460 label *label94

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   288 set :drawPixel:b *tmp96
   289 packcolor *tmp97 :drawPixel:r :drawPixel:g :drawPixel:b 1
   290 set :drawPixel:color *tmp97
-    * set *tmp80 :drawPixel:color
   291 jump *label65 always
   292 label *label66
   293 jump *label69 equal .PALETTE 3
 
   309 set :drawPixel:b *tmp108
   310 packcolor *tmp109 :drawPixel:r :drawPixel:g :drawPixel:b 1
   311 set :drawPixel:color *tmp109
-    * set *tmp80 :drawPixel:color
   312 jump *label65 always
   313 label *label68
   314 jump *label71 equal .PALETTE 4
 
   323 set :drawPixel:g *tmp114
   324 packcolor *tmp115 :drawPixel:r :drawPixel:g 0 1
   325 set :drawPixel:color *tmp115
-    * set *tmp80 :drawPixel:color
   326 jump *label65 always
   327 label *label70
   328 op mul *tmp116 4 :drawPixel:iterations
 
   331 set :drawPixel:r *tmp118
   332 packcolor *tmp119 :drawPixel:r :drawPixel:r 0 1
   333 set :drawPixel:color *tmp119
-    * set *tmp80 :drawPixel:color
   334 label *label65
   335 label *label64
   336 jump *label62 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-44 instructions):
     0 sensor *tmp9 @this @x
     1 sensor *tmp10 @this @y
     2 op mul *tmp11 10000 *tmp10
-    * op add *tmp12 *tmp9 *tmp11
-    * set .PROCESSOR_ID *tmp12
+    3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
 
    34 op greaterThan *tmp14 :findLinkedBlocks:n 0
    35 jump *label13 equal *tmp14 false
    36 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
-    * getlink *tmp15 :findLinkedBlocks:n
-    * set :findLinkedBlocks:block *tmp15
+   37 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    38 print "\nFound: "
    39 print :findLinkedBlocks:block
-    * sensor *tmp16 :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:type *tmp16
+   40 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    41 set :findLinkedBlocks:requested @large-logic-display
    42 set :findLinkedBlocks:name "Display"
    43 set :findLinkedBlocks:variable .display
 
   128 setaddr :setState*retaddr *label37 (h:*label37)
   129 call *label1 *invalid :setState*retval (m:*label37) (h:*label37)
   130 label *label37
-    * read *tmp4 .memory 68
-    * set .ZOOM *tmp4
+  131 read .ZOOM .memory 68
   132 op div *tmp26 -88 .ZOOM
   133 read *tmp2 .memory 66
-    * op add *tmp27 *tmp26 *tmp2
-    * set .OFFSET_X *tmp27
+  134 op add .OFFSET_X *tmp26 *tmp2
   135 op div *tmp28 -88 .ZOOM
   136 read *tmp3 .memory 67
-    * op add *tmp29 *tmp28 *tmp3
-    * set .OFFSET_Y *tmp29
-    * read *tmp5 .memory 69
-    * set .JULIA *tmp5
-    * read *tmp6 .memory 70
-    * set .JULIA_X *tmp6
-    * read *tmp7 .memory 71
-    * set .JULIA_Y *tmp7
-    * read *tmp8 .memory 72
-    * set .PALETTE *tmp8
-    * op greaterThan *tmp30 .PALETTE 1
-    * set .SMOOTH *tmp30
+  137 op add .OFFSET_Y *tmp28 *tmp3
+  138 read .JULIA .memory 69
+  139 read .JULIA_X .memory 70
+  140 read .JULIA_Y .memory 71
+  141 read .PALETTE .memory 72
+  142 op greaterThan .SMOOTH .PALETTE 1
   143 set :line 8
   144 set :increment 8
   145 set :next_increment 16
 
   149 label *label38
   150 jump *label40 greaterThanEq :lines 176
   151 op mul *tmp32 17 :line
-    * op mod *tmp33 *tmp32 176
-    * set :x *tmp33
-    * op add *tmp34 :x 158
-    * set :position *tmp34
-    * set *tmp35 :position
-    * read *tmp36 .memory *tmp35
+  152 op mod :x *tmp32 176
+  153 op add :position :x 158
+  154 read *tmp36 .memory :position
   155 op equal *tmp37 *tmp36 0
   156 jump *label41 equal *tmp37 false
-    * set *tmp39 :position
-    * write .PROCESSOR_ID .memory *tmp39
+  157 write .PROCESSOR_ID .memory :position
   158 set :y 0
   159 label *label43
   160 jump *label45 greaterThanEq :y 176
   161 set :compute:x :x
   162 set :compute:y :y
   163 op div *tmp42 :compute:x .ZOOM
-    * op add *tmp43 *tmp42 .OFFSET_X
-    * set :compute:zx *tmp43
+  164 op add :compute:zx *tmp42 .OFFSET_X
   165 op div *tmp44 :compute:y .ZOOM
-    * op add *tmp45 *tmp44 .OFFSET_Y
-    * set :compute:zy *tmp45
+  166 op add :compute:zy *tmp44 .OFFSET_Y
   167 jump *label47 equal .JULIA false
   168 set :compute:cx .JULIA_X
   169 set :compute:cy .JULIA_Y
 
   172 set :compute:cx :compute:zx
   173 set :compute:cy :compute:zy
   174 op sub *tmp47 :compute:cx 0.25
-    * op len *tmp48 *tmp47 :compute:cy
-    * set :compute:p *tmp48
+  175 op len :compute:p *tmp47 :compute:cy
   176 op mul *tmp49 2 :compute:p
   177 op mul *tmp50 *tmp49 :compute:p
   178 op sub *tmp51 :compute:p *tmp50
 
   202 op mul *tmp59 :compute:x1 :compute:x1
   203 op mul *tmp60 :compute:y1 :compute:y1
   204 op sub *tmp61 *tmp59 *tmp60
-    * op add *tmp62 *tmp61 :compute:cx
-    * set :compute:zx *tmp62
+  205 op add :compute:zx *tmp61 :compute:cx
   206 op mul *tmp63 2 :compute:x1
   207 op mul *tmp64 *tmp63 :compute:y1
-    * op add *tmp65 *tmp64 :compute:cy
-    * set :compute:zy *tmp65
-    * op len *tmp66 :compute:zx :compute:zy
-    * set :compute:dist *tmp66
+  208 op add :compute:zy *tmp64 :compute:cy
+  209 op len :compute:dist :compute:zx :compute:zy
   210 op greaterThanEq *tmp67 :compute:dist 64
   211 jump *label56 equal *tmp67 false
   212 jump *label55 always
 
   224 op mul *tmp73 *tmp72 0.36067376022224085
   225 op log *tmp74 *tmp73
   226 op mul *tmp75 *tmp74 1.4426950408889634
-    * op sub *tmp76 4 *tmp75
-    * set :compute:correction *tmp76
+  227 op sub :compute:correction 4 *tmp75
   228 op add :compute:i :compute:i :compute:correction
   229 jump *label59 always
   230 label *label58
 
   250 op abs *tmp83 *tmp82
   251 op mul *tmp84 7 *tmp83
   252 op div *tmp85 *tmp84 255
-    * op sub *tmp86 1 *tmp85
-    * set :drawPixel:r *tmp86
+  253 op sub :drawPixel:r 1 *tmp85
   254 op sub *tmp87 :drawPixel:iterations 32
   255 op abs *tmp88 *tmp87
   256 op mul *tmp89 6 *tmp88
   257 op div *tmp90 *tmp89 255
-    * op sub *tmp91 0.9411764705882353 *tmp90
-    * set :drawPixel:g *tmp91
+  258 op sub :drawPixel:g 0.9411764705882353 *tmp90
   259 op sub *tmp92 32 :drawPixel:iterations
   260 op abs *tmp93 *tmp92
   261 op mul *tmp94 4 *tmp93
   262 op div *tmp95 *tmp94 255
-    * op add *tmp96 0.47058823529411764 *tmp95
-    * set :drawPixel:b *tmp96
-    * packcolor *tmp97 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp97
+  263 op add :drawPixel:b 0.47058823529411764 *tmp95
+  264 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   265 jump *label65 always
   266 label *label66
   267 jump *label69 equal .PALETTE 3
 
   269 label *label69
   270 op div *tmp98 :drawPixel:iterations 63
   271 op mul *tmp99 *tmp98 360
-    * op sin *tmp100 *tmp99
-    * set :drawPixel:r *tmp100
+  272 op sin :drawPixel:r *tmp99
   273 op div *tmp101 :drawPixel:iterations 63
   274 op mul *tmp102 *tmp101 360
-    * op cos *tmp103 *tmp102
-    * set :drawPixel:g *tmp103
+  275 op cos :drawPixel:g *tmp102
   276 op sub *tmp104 :drawPixel:iterations 32
   277 op abs *tmp105 *tmp104
   278 op mul *tmp106 4 *tmp105
   279 op div *tmp107 *tmp106 255
-    * op add *tmp108 0.39215686274509803 *tmp107
-    * set :drawPixel:b *tmp108
-    * packcolor *tmp109 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp109
+  280 op add :drawPixel:b 0.39215686274509803 *tmp107
+  281 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   282 jump *label65 always
   283 label *label68
   284 jump *label71 equal .PALETTE 4
   285 jump *label70 always
   286 label *label71
   287 op mul *tmp110 4 :drawPixel:iterations
-    * op div *tmp111 *tmp110 255
-    * set :drawPixel:r *tmp111
+  288 op div :drawPixel:r *tmp110 255
   289 op mul *tmp112 1.5 :drawPixel:iterations
   290 op div *tmp113 *tmp112 255
-    * op add *tmp114 96 *tmp113
-    * set :drawPixel:g *tmp114
-    * packcolor *tmp115 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp115
+  291 op add :drawPixel:g 96 *tmp113
+  292 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   293 jump *label65 always
   294 label *label70
   295 op mul *tmp116 4 :drawPixel:iterations
   296 op div *tmp117 *tmp116 255
-    * op sub *tmp118 1 *tmp117
-    * set :drawPixel:r *tmp118
-    * packcolor *tmp119 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp119
+  297 op sub :drawPixel:r 1 *tmp117
+  298 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   299 label *label65
   300 label *label64
   301 jump *label62 always
   302 label *label61
-    * set *tmp120 :drawPixel:iterations
-    * read *tmp121 .memory *tmp120
-    * set :drawPixel:color *tmp121
+  303 read :drawPixel:color .memory :drawPixel:iterations
   304 label *label62
   305 op greaterThanEq *tmp122 .localBuffer 250
   306 jump *label72 equal *tmp122 false
 
   327 label *label75
   328 label *label76
   329 label *label60
-    * set *tmp129 :position
-    * read *tmp130 .memory *tmp129
+  330 read *tmp130 .memory :position
   331 op notEqual *tmp131 *tmp130 .PROCESSOR_ID
   332 jump *label79 equal *tmp131 false
   333 jump *label45 always
 
   353 jump *label83 equal *tmp135 false
   354 op div :next_increment :next_increment 2
   355 set :increment :next_increment
-    * op div *tmp137 :increment 2
-    * set :line *tmp137
+  356 op div :line :increment 2
   357 jump *label84 always
   358 label *label83
   359 label *label84
 
   390 label *label93
   391 op lessThan *tmp142 .PROC_STATE_INDEX 512
   392 jump *label95 equal *tmp142 false
-    * set *tmp143 .PROC_ID_INDEX
-    * read *tmp144 .memory *tmp143
+  393 read *tmp144 .memory .PROC_ID_INDEX
   394 op equal *tmp145 *tmp144 .PROCESSOR_ID
   395 jump *label96 equal *tmp145 false
-    * set *tmp147 .PROC_STATE_INDEX
-    * write :setState:state .memory *tmp147
+  396 write :setState:state .memory .PROC_STATE_INDEX
   397 jump *label95 always
   398 jump *label97 always
   399 label *label96
-    * set *tmp149 .PROC_ID_INDEX
-    * read *tmp150 .memory *tmp149
+  400 read *tmp150 .memory .PROC_ID_INDEX
   401 op equal *tmp151 *tmp150 0
   402 jump *label98 equal *tmp151 false
-    * set *tmp153 .PROC_ID_INDEX
-    * write .PROCESSOR_ID .memory *tmp153
-    * set *tmp155 .PROC_STATE_INDEX
-    * write :setState:state .memory *tmp155
+  403 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  404 write :setState:state .memory .PROC_STATE_INDEX
   405 jump *label95 always
   406 jump *label99 always
   407 label *label98

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
   109 label *label5
   110 label *label2
   111 label *label30
-    * jump *label32 equal true false
   112 label *label33
   113 set :setState:state 0
   114 setaddr :setState*retaddr *label36 (h:*label36)

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   242 set :drawPixel:color %[black]
   243 jump *label64 always
   244 label *label63
-    * jump *label67 equal .PALETTE 2
-    * jump *label66 always
+  245 jump *label66 notEqual .PALETTE 2
   246 label *label67
   247 op sub *tmp82 32 :drawPixel:iterations
   248 op abs *tmp83 *tmp82
 
   262 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   263 jump *label65 always
   264 label *label66
-    * jump *label69 equal .PALETTE 3
-    * jump *label68 always
+  265 jump *label68 notEqual .PALETTE 3
   266 label *label69
   267 op div *tmp98 :drawPixel:iterations 63
   268 op mul *tmp99 *tmp98 360
 
   278 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   279 jump *label65 always
   280 label *label68
-    * jump *label71 equal .PALETTE 4
-    * jump *label70 always
+  281 jump *label70 notEqual .PALETTE 4
   282 label *label71
   283 op mul *tmp110 4 :drawPixel:iterations
   284 op div :drawPixel:r *tmp110 255

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-22 instructions):
 
    31 print :findLinkedBlocks:title
    32 set :findLinkedBlocks:n @links
    33 label *label11
-    * op greaterThan *tmp14 :findLinkedBlocks:n 0
-    * jump *label13 equal *tmp14 false
+   34 jump *label13 lessThanEq :findLinkedBlocks:n 0
    35 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    36 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    37 print "\nFound: "
 
    51 set :findLinkedBlocks:required true
    52 setaddr *tmp17 *label18
    53 label *label14
-    * op equal *tmp18 :findLinkedBlocks:requested :findLinkedBlocks:type
-    * jump *label19 equal *tmp18 false
+   54 jump *label19 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
    55 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * op equal *tmp20 :findLinkedBlocks:requested @message
-    * jump *label21 equal *tmp20 false
+   56 jump *label21 notEqual :findLinkedBlocks:requested @message
    57 set :findLinkedBlocks:message :findLinkedBlocks:block
    58 jump *label22 always
    59 label *label21
 
   101 label *label25
   102 printflush :findLinkedBlocks:message
   103 label *label4
-    * op equal *tmp24 :findLinkedBlocks:foundAll false
-    * jump *label3 notEqual *tmp24 false
+  104 jump *label3 equal :findLinkedBlocks:foundAll false
   105 label *label5
   106 label *label2
   107 label *label30
 
   112 label *label36
   113 label *label34
   114 read *tmp0 .memory 64
-    * op equal *tmp25 .start *tmp0
-    * jump *label33 notEqual *tmp25 false
+  115 jump *label33 equal .start *tmp0
   116 label *label35
   117 read *tmp0 .memory 64
   118 set .start *tmp0
 
   146 op mod :x *tmp32 176
   147 op add :position :x 158
   148 read *tmp36 .memory :position
-    * op equal *tmp37 *tmp36 0
-    * jump *label41 equal *tmp37 false
+  149 jump *label41 notEqual *tmp36 0
   150 write .PROCESSOR_ID .memory :position
   151 set :y 0
   152 label *label43
 
   170 op mul *tmp50 *tmp49 :compute:p
   171 op sub *tmp51 :compute:p *tmp50
   172 op add *tmp52 *tmp51 0.25
-    * op lessThanEq *tmp53 :compute:cx *tmp52
-    * jump *label49 equal *tmp53 false
+  173 jump *label49 greaterThan :compute:cx *tmp52
   174 set *tmp41 63
   175 jump *label46 always
   176 jump *label50 always
 
   178 label *label50
   179 op add *tmp55 :compute:cx 1
   180 op len *tmp56 *tmp55 :compute:cy
-    * op lessThanEq *tmp57 *tmp56 0.25
-    * jump *label51 equal *tmp57 false
+  181 jump *label51 greaterThan *tmp56 0.25
   182 set *tmp41 63
   183 jump *label46 always
   184 jump *label52 always
 
   198 op mul *tmp64 *tmp63 :compute:y1
   199 op add :compute:zy *tmp64 :compute:cy
   200 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp67 :compute:dist 64
-    * jump *label56 equal *tmp67 false
+  201 jump *label56 lessThan :compute:dist 64
   202 jump *label55 always
   203 jump *label57 always
   204 label *label56
 
   208 jump *label53 always
   209 label *label55
   210 op mul *tmp69 .SMOOTH 63
-    * op lessThan *tmp70 :compute:i *tmp69
-    * jump *label58 equal *tmp70 false
+  211 jump *label58 greaterThanEq :compute:i *tmp69
   212 op log *tmp72 :compute:dist
   213 op mul *tmp73 *tmp72 0.36067376022224085
   214 op log *tmp74 *tmp73
 
   227 set :drawPixel:y :y
   228 set :drawPixel:iterations :iterations
   229 jump *label61 equal .SMOOTH false
-    * op equal *tmp78 :drawPixel:iterations 63
-    * jump *label63 equal *tmp78 false
+  230 jump *label63 notEqual :drawPixel:iterations 63
   231 set :drawPixel:color %[black]
   232 jump *label64 always
   233 label *label63
 
   287 label *label61
   288 read :drawPixel:color .memory :drawPixel:iterations
   289 label *label62
-    * op greaterThanEq *tmp122 .localBuffer 250
-    * jump *label72 equal *tmp122 false
+  290 jump *label72 lessThan .localBuffer 250
   291 setaddr :flushLocalBuffer*retaddr *label74 (h:*label74)
   292 call *label0 *invalid :flushLocalBuffer*retval (m:*label74) (h:*label74)
   293 label *label74
 
   297 draw col :drawPixel:color
   298 draw rect :drawPixel:x :drawPixel:y 1 1
   299 op add .localBuffer .localBuffer 2
-    * op lessThanEq *tmp124 .localBuffer 4
-    * jump *label75 equal *tmp124 false
+  300 jump *label75 greaterThan .localBuffer 4
   301 sensor *tmp126 .display @bufferUsage
-    * op lessThan *tmp127 *tmp126 900
-    * jump *label77 equal *tmp127 false
+  302 jump *label77 greaterThanEq *tmp126 900
   303 drawflush .display
   304 set .localBuffer 0
   305 jump *label78 always
 
   310 label *label76
   311 label *label60
   312 read *tmp130 .memory :position
-    * op notEqual *tmp131 *tmp130 .PROCESSOR_ID
-    * jump *label79 equal *tmp131 false
+  313 jump *label79 equal *tmp130 .PROCESSOR_ID
   314 jump *label45 always
   315 jump *label80 always
   316 label *label79
   317 label *label80
   318 read *tmp1 .memory 65
-    * op notEqual *tmp133 .stop *tmp1
-    * jump *label81 equal *tmp133 false
+  319 jump *label81 equal .stop *tmp1
   320 jump *label40 always
   321 jump *label82 always
   322 label *label81
 
   329 label *label41
   330 label *label42
   331 op add :line :line :increment
-    * op greaterThan *tmp135 :line 176
-    * jump *label83 equal *tmp135 false
+  332 jump *label83 lessThanEq :line 176
   333 op div :next_increment :next_increment 2
   334 set :increment :next_increment
   335 op div :line :increment 2
 
   348 label *label32
   349 end
   350 label *label0
-    * op greaterThan *tmp138 .localBuffer 4
-    * jump *label87 equal *tmp138 false
+  351 jump *label87 lessThanEq .localBuffer 4
   352 label *label89
   353 wait 0.0001
   354 label *label90
   355 sensor *tmp140 .display @bufferUsage
-    * op greaterThan *tmp141 *tmp140 250
-    * jump *label89 notEqual *tmp141 false
+  356 jump *label89 greaterThan *tmp140 250
   357 label *label91
   358 jump *label88 always
   359 label *label87
 
   365 end
   366 label *label1
   367 label *label93
-    * op lessThan *tmp142 .PROC_STATE_INDEX 512
-    * jump *label95 equal *tmp142 false
+  368 jump *label95 greaterThanEq .PROC_STATE_INDEX 512
   369 read *tmp144 .memory .PROC_ID_INDEX
-    * op equal *tmp145 *tmp144 .PROCESSOR_ID
-    * jump *label96 equal *tmp145 false
+  370 jump *label96 notEqual *tmp144 .PROCESSOR_ID
   371 write :setState:state .memory .PROC_STATE_INDEX
   372 jump *label95 always
   373 jump *label97 always
   374 label *label96
   375 read *tmp150 .memory .PROC_ID_INDEX
-    * op equal *tmp151 *tmp150 0
-    * jump *label98 equal *tmp151 false
+  376 jump *label98 notEqual *tmp150 0
   377 write .PROCESSOR_ID .memory .PROC_ID_INDEX
   378 write :setState:state .memory .PROC_STATE_INDEX
   379 jump *label95 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-15 instructions):
 
    55 set :findLinkedBlocks:variable :findLinkedBlocks:block
    56 jump *label21 notEqual :findLinkedBlocks:requested @message
    57 set :findLinkedBlocks:message :findLinkedBlocks:block
-    * jump *label22 always
    58 label *label21
    59 label *label22
-    * jump *label20 always
    60 label *label19
    61 label *label20
    62 label *label15
 
    89 print :findLinkedBlocks:variable
    90 jump *label28 equal :findLinkedBlocks:required false
    91 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * jump *label29 always
    92 label *label28
    93 label *label29
    94 label *label24
 
   170 jump *label49 greaterThan :compute:cx *tmp52
   171 set *tmp41 63
   172 jump *label46 always
-    * jump *label50 always
   173 label *label49
   174 label *label50
   175 op add *tmp55 :compute:cx 1
 
   177 jump *label51 greaterThan *tmp56 0.25
   178 set *tmp41 63
   179 jump *label46 always
-    * jump *label52 always
   180 label *label51
   181 label *label52
   182 label *label48
 
   195 op len :compute:dist :compute:zx :compute:zy
   196 jump *label56 lessThan :compute:dist 64
   197 jump *label55 always
-    * jump *label57 always
   198 label *label56
   199 label *label57
   200 label *label54
 
   209 op mul *tmp75 *tmp74 1.4426950408889634
   210 op sub :compute:correction 4 *tmp75
   211 op add :compute:i :compute:i :compute:correction
-    * jump *label59 always
   212 label *label58
   213 label *label59
   214 set *tmp41 :compute:i
 
   284 setaddr :flushLocalBuffer*retaddr *label74 (h:*label74)
   285 call *label0 *invalid :flushLocalBuffer*retval (m:*label74) (h:*label74)
   286 label *label74
-    * jump *label73 always
   287 label *label72
   288 label *label73
   289 draw col :drawPixel:color
 
   294 jump *label77 greaterThanEq *tmp126 900
   295 drawflush .display
   296 set .localBuffer 0
-    * jump *label78 always
   297 label *label77
   298 label *label78
-    * jump *label76 always
   299 label *label75
   300 label *label76
   301 label *label60
   302 read *tmp130 .memory :position
   303 jump *label79 equal *tmp130 .PROCESSOR_ID
   304 jump *label45 always
-    * jump *label80 always
   305 label *label79
   306 label *label80
   307 read *tmp1 .memory 65
   308 jump *label81 equal .stop *tmp1
   309 jump *label40 always
-    * jump *label82 always
   310 label *label81
   311 label *label82
   312 label *label44
   313 op add :y :y 1
   314 jump *label43 always
   315 label *label45
-    * jump *label42 always
   316 label *label41
   317 label *label42
   318 op add :line :line :increment
 
   320 op div :next_increment :next_increment 2
   321 set :increment :next_increment
   322 op div :line :increment 2
-    * jump *label84 always
   323 label *label83
   324 label *label84
   325 label *label39
 
   341 sensor *tmp140 .display @bufferUsage
   342 jump *label89 greaterThan *tmp140 250
   343 label *label91
-    * jump *label88 always
   344 label *label87
   345 label *label88
   346 drawflush .display

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
-    * sensor *tmp9 @this @x
-    * sensor *tmp10 @this @y
+    0 set *tmp9 @thisx
+    1 set *tmp10 @thisy
     2 op mul *tmp11 10000 *tmp10
     3 op add .PROCESSOR_ID *tmp9 *tmp11
     4 set .PROC_ID_INDEX 334

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
     0 set *tmp9 @thisx
     1 set *tmp10 @thisy
-    * op mul *tmp11 10000 *tmp10
-    * op add .PROCESSOR_ID *tmp9 *tmp11
+    2 op mul *tmp11 10000 @thisy
+    3 op add .PROCESSOR_ID @thisx *tmp11
     4 set .PROC_ID_INDEX 334
     5 set .PROC_STATE_INDEX 335
     6 set .start 0
 
     8 set :findLinkedBlocks:title "Mandelbrot Generator"
     9 set :findLinkedBlocks:message null
    10 label *label3
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    11 setaddr *tmp13 *label9
    12 jump *label6 always
    13 multilabel *label9 (m:marker0)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
+   14 set .display null
    15 setaddr *tmp13 *label10
    16 label *label6
    17 set :findLinkedBlocks:variable null
    18 label *label7
    19 multijump *tmp13 0 0 (m:marker0)
    20 multilabel *label10 (m:marker0)
-    * set .memory :findLinkedBlocks:variable
+   21 set .memory null
    22 label *label8
-    * print :findLinkedBlocks:title
+   23 print "Mandelbrot Generator"
    24 set :findLinkedBlocks:n @links
    25 label *label11
    26 jump *label13 lessThanEq :findLinkedBlocks:n 0
 
    30 print :findLinkedBlocks:block
    31 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    32 set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:name "Display"
    33 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    34 setaddr *tmp17 *label17
    35 jump *label14 always
    36 multilabel *label17 (m:marker1)
    37 set .display :findLinkedBlocks:variable
    38 set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:name "Memory"
    39 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    40 setaddr *tmp17 *label18
    41 label *label14
    42 jump *label19 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
 
    56 jump *label11 always
    57 label *label13
    58 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:requested @large-logic-display
    59 set :findLinkedBlocks:name "Display"
    60 set :findLinkedBlocks:variable .display
    61 set :findLinkedBlocks:required true
 
    63 jump *label23 always
    64 multilabel *label26 (m:marker2)
    65 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    66 set :findLinkedBlocks:name "Memory"
    67 set :findLinkedBlocks:variable .memory
    68 set :findLinkedBlocks:required true
 
    73 print ":"
    74 print " "
    75 print :findLinkedBlocks:variable
-    * jump *label28 equal :findLinkedBlocks:required false
+   76 jump *label28 equal true false
    77 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
    78 label *label28
    79 label *label29
 
   101 set .start *tmp0
   102 read *tmp1 .memory 65
   103 set .stop *tmp1
-    * set :setState:state .start
+  104 set :setState:state *tmp0
   105 setaddr :setState*retaddr *label37 (h:*label37)
   106 call *label1 *invalid :setState*retval (m:*label37) (h:*label37)
   107 label *label37
 
   111 op add .OFFSET_X *tmp26 *tmp2
   112 op div *tmp28 -88 .ZOOM
   113 read *tmp3 .memory 67
-    * op add .OFFSET_Y *tmp28 *tmp3
+  114 op add .OFFSET_Y *tmp26 *tmp3
   115 read .JULIA .memory 69
   116 read .JULIA_X .memory 70
   117 read .JULIA_Y .memory 71
 
   136 jump *label45 greaterThanEq :y 176
   137 set :compute:x :x
   138 set :compute:y :y
-    * op div *tmp42 :compute:x .ZOOM
+  139 op div *tmp42 :x .ZOOM
   140 op add :compute:zx *tmp42 .OFFSET_X
-    * op div *tmp44 :compute:y .ZOOM
+  141 op div *tmp44 :y .ZOOM
   142 op add :compute:zy *tmp44 .OFFSET_Y
   143 jump *label47 equal .JULIA false
   144 set :compute:cx .JULIA_X
 
   147 label *label47
   148 set :compute:cx :compute:zx
   149 set :compute:cy :compute:zy
-    * op sub *tmp47 :compute:cx 0.25
-    * op len :compute:p *tmp47 :compute:cy
+  150 op sub *tmp47 :compute:zx 0.25
+  151 op len :compute:p *tmp47 :compute:zy
   152 op mul *tmp49 2 :compute:p
   153 op mul *tmp50 *tmp49 :compute:p
   154 op sub *tmp51 :compute:p *tmp50
   155 op add *tmp52 *tmp51 0.25
-    * jump *label49 greaterThan :compute:cx *tmp52
+  156 jump *label49 greaterThan :compute:zx *tmp52
   157 set *tmp41 63
   158 jump *label46 always
   159 label *label49
   160 label *label50
-    * op add *tmp55 :compute:cx 1
-    * op len *tmp56 *tmp55 :compute:cy
+  161 op add *tmp55 :compute:zx 1
+  162 op len *tmp56 *tmp55 :compute:zy
   163 jump *label51 greaterThan *tmp56 0.25
   164 set *tmp41 63
   165 jump *label46 always
 
   171 jump *label55 greaterThanEq :compute:i 63
   172 set :compute:x1 :compute:zx
   173 set :compute:y1 :compute:zy
-    * op mul *tmp59 :compute:x1 :compute:x1
-    * op mul *tmp60 :compute:y1 :compute:y1
+  174 op mul *tmp59 :compute:zx :compute:zx
+  175 op mul *tmp60 :compute:zy :compute:zy
   176 op sub *tmp61 *tmp59 *tmp60
   177 op add :compute:zx *tmp61 :compute:cx
   178 op mul *tmp63 2 :compute:x1
-    * op mul *tmp64 *tmp63 :compute:y1
+  179 op mul *tmp64 *tmp63 :compute:zy
   180 op add :compute:zy *tmp64 :compute:cy
   181 op len :compute:dist :compute:zx :compute:zy
   182 jump *label56 lessThan :compute:dist 64
 
   199 label *label59
   200 set *tmp41 :compute:i
   201 jump *label46 always
-    * set *tmp41 null
   202 label *label46
   203 set :iterations *tmp41
   204 set :drawPixel:x :x
   205 set :drawPixel:y :y
-    * set :drawPixel:iterations :iterations
+  206 set :drawPixel:iterations *tmp41
   207 jump *label61 equal .SMOOTH false
-    * jump *label63 notEqual :drawPixel:iterations 63
+  208 jump *label63 notEqual :iterations 63
   209 set :drawPixel:color %[black]
   210 jump *label64 always
   211 label *label63
   212 jump *label66 notEqual .PALETTE 2
   213 label *label67
-    * op sub *tmp82 32 :drawPixel:iterations
+  214 op sub *tmp82 32 :iterations
   215 op abs *tmp83 *tmp82
   216 op mul *tmp84 7 *tmp83
-    * op div *tmp85 *tmp84 255
+  217 op div *tmp85 *tmp83 36.42857142857143
   218 op sub :drawPixel:r 1 *tmp85
-    * op sub *tmp87 :drawPixel:iterations 32
+  219 op sub *tmp87 :iterations 32
   220 op abs *tmp88 *tmp87
   221 op mul *tmp89 6 *tmp88
-    * op div *tmp90 *tmp89 255
+  222 op div *tmp90 *tmp88 42.5
   223 op sub :drawPixel:g 0.9411764705882353 *tmp90
-    * op sub *tmp92 32 :drawPixel:iterations
-    * op abs *tmp93 *tmp92
-    * op mul *tmp94 4 *tmp93
-    * op div *tmp95 *tmp94 255
+  224 op sub *tmp92 32 :iterations
+  225 op abs *tmp93 *tmp82
+  226 op mul *tmp94 4 *tmp83
+  227 op div *tmp95 *tmp93 63.75
   228 op add :drawPixel:b 0.47058823529411764 *tmp95
   229 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   230 jump *label65 always
   231 label *label66
   232 jump *label68 notEqual .PALETTE 3
   233 label *label69
-    * op div *tmp98 :drawPixel:iterations 63
-    * op mul *tmp99 *tmp98 360
+  234 op div *tmp98 :iterations 63
+  235 op div *tmp99 :drawPixel:iterations 0.175
   236 op sin :drawPixel:r *tmp99
-    * op div *tmp101 :drawPixel:iterations 63
-    * op mul *tmp102 *tmp101 360
-    * op cos :drawPixel:g *tmp102
-    * op sub *tmp104 :drawPixel:iterations 32
+  237 op div *tmp101 :iterations 63
+  238 op mul *tmp102 *tmp98 360
+  239 op cos :drawPixel:g *tmp99
+  240 op sub *tmp104 :iterations 32
   241 op abs *tmp105 *tmp104
   242 op mul *tmp106 4 *tmp105
-    * op div *tmp107 *tmp106 255
+  243 op div *tmp107 *tmp105 63.75
   244 op add :drawPixel:b 0.39215686274509803 *tmp107
   245 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   246 jump *label65 always
   247 label *label68
   248 jump *label70 notEqual .PALETTE 4
   249 label *label71
-    * op mul *tmp110 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp110 255
-    * op mul *tmp112 1.5 :drawPixel:iterations
-    * op div *tmp113 *tmp112 255
+  250 op mul *tmp110 4 :iterations
+  251 op div :drawPixel:r :drawPixel:iterations 63.75
+  252 op mul *tmp112 1.5 :iterations
+  253 op div *tmp113 :drawPixel:iterations 170
   254 op add :drawPixel:g 96 *tmp113
   255 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   256 jump *label65 always
   257 label *label70
-    * op mul *tmp116 4 :drawPixel:iterations
-    * op div *tmp117 *tmp116 255
+  258 op mul *tmp116 4 :iterations
+  259 op div *tmp117 :drawPixel:iterations 63.75
   260 op sub :drawPixel:r 1 *tmp117
   261 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   262 label *label65
   263 label *label64
   264 jump *label62 always
   265 label *label61
-    * read :drawPixel:color .memory :drawPixel:iterations
+  266 read :drawPixel:color .memory :iterations
   267 label *label62
   268 jump *label72 lessThan .localBuffer 250
   269 setaddr :flushLocalBuffer*retaddr *label74 (h:*label74)
 
   272 label *label72
   273 label *label73
   274 draw col :drawPixel:color
-    * draw rect :drawPixel:x :drawPixel:y 1 1
+  275 draw rect :x :y 1 1
   276 op add .localBuffer .localBuffer 2
   277 jump *label75 greaterThan .localBuffer 4
   278 sensor *tmp126 .display @bufferUsage
 
   304 jump *label83 lessThanEq :line 176
   305 op div :next_increment :next_increment 2
   306 set :increment :next_increment
-    * op div :line :increment 2
+  307 op div :line :next_increment 2
   308 label *label83
   309 label *label84
   310 label *label39

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-16 instructions):
-    * set *tmp9 @thisx
-    * set *tmp10 @thisy
     0 op mul *tmp11 10000 @thisy
     1 op add .PROCESSOR_ID @thisx *tmp11
     2 set .PROC_ID_INDEX 334
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
     5 set .localBuffer 0
-    * set :findLinkedBlocks:title "Mandelbrot Generator"
     6 set :findLinkedBlocks:message null
     7 label *label3
     8 setaddr *tmp13 *label9
 
    11 set .display null
    12 setaddr *tmp13 *label10
    13 label *label6
-    * set :findLinkedBlocks:variable null
    14 label *label7
    15 multijump *tmp13 0 0 (m:marker0)
    16 multilabel *label10 (m:marker0)
 
    54 set :findLinkedBlocks:foundAll 1
    55 set :findLinkedBlocks:name "Display"
    56 set :findLinkedBlocks:variable .display
-    * set :findLinkedBlocks:required true
    57 setaddr *tmp22 *label26
    58 jump *label23 always
    59 multilabel *label26 (m:marker2)
    60 set .display :findLinkedBlocks:variable
    61 set :findLinkedBlocks:name "Memory"
    62 set :findLinkedBlocks:variable .memory
-    * set :findLinkedBlocks:required true
    63 setaddr *tmp22 *label27
    64 label *label23
    65 print "\n"
 
   103 op div *tmp26 -88 .ZOOM
   104 read *tmp2 .memory 66
   105 op add .OFFSET_X *tmp26 *tmp2
-    * op div *tmp28 -88 .ZOOM
   106 read *tmp3 .memory 67
   107 op add .OFFSET_Y *tmp26 *tmp3
   108 read .JULIA .memory 69
 
   127 set :y 0
   128 label *label43
   129 jump *label45 greaterThanEq :y 176
-    * set :compute:x :x
-    * set :compute:y :y
   130 op div *tmp42 :x .ZOOM
   131 op add :compute:zx *tmp42 .OFFSET_X
   132 op div *tmp44 :y .ZOOM
 
   161 label *label53
   162 jump *label55 greaterThanEq :compute:i 63
   163 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   164 op mul *tmp59 :compute:zx :compute:zx
   165 op mul *tmp60 :compute:zy :compute:zy
   166 op sub *tmp61 *tmp59 *tmp60
 
   191 jump *label46 always
   192 label *label46
   193 set :iterations *tmp41
-    * set :drawPixel:x :x
-    * set :drawPixel:y :y
   194 set :drawPixel:iterations *tmp41
   195 jump *label61 equal .SMOOTH false
-    * jump *label63 notEqual :iterations 63
+  196 jump *label63 notEqual *tmp41 63
   197 set :drawPixel:color %[black]
   198 jump *label64 always
   199 label *label63
   200 jump *label66 notEqual .PALETTE 2
   201 label *label67
-    * op sub *tmp82 32 :iterations
+  202 op sub *tmp82 32 *tmp41
   203 op abs *tmp83 *tmp82
-    * op mul *tmp84 7 *tmp83
   204 op div *tmp85 *tmp83 36.42857142857143
   205 op sub :drawPixel:r 1 *tmp85
-    * op sub *tmp87 :iterations 32
+  206 op sub *tmp87 *tmp41 32
   207 op abs *tmp88 *tmp87
-    * op mul *tmp89 6 *tmp88
   208 op div *tmp90 *tmp88 42.5
   209 op sub :drawPixel:g 0.9411764705882353 *tmp90
-    * op sub *tmp92 32 :iterations
+  210 op sub *tmp92 32 *tmp41
   211 op abs *tmp93 *tmp82
-    * op mul *tmp94 4 *tmp83
-    * op div *tmp95 *tmp93 63.75
+  212 op div *tmp95 *tmp83 63.75
   213 op add :drawPixel:b 0.47058823529411764 *tmp95
   214 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   215 jump *label65 always
   216 label *label66
   217 jump *label68 notEqual .PALETTE 3
   218 label *label69
-    * op div *tmp98 :iterations 63
-    * op div *tmp99 :drawPixel:iterations 0.175
+  219 op div *tmp98 *tmp41 63
+  220 op div *tmp99 *tmp41 0.175
   221 op sin :drawPixel:r *tmp99
-    * op div *tmp101 :iterations 63
-    * op mul *tmp102 *tmp98 360
+  222 op div *tmp101 *tmp41 63
+  223 op div *tmp102 :iterations 0.175
   224 op cos :drawPixel:g *tmp99
-    * op sub *tmp104 :iterations 32
+  225 op sub *tmp104 *tmp41 32
   226 op abs *tmp105 *tmp104
-    * op mul *tmp106 4 *tmp105
   227 op div *tmp107 *tmp105 63.75
   228 op add :drawPixel:b 0.39215686274509803 *tmp107
   229 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   231 label *label68
   232 jump *label70 notEqual .PALETTE 4
   233 label *label71
-    * op mul *tmp110 4 :iterations
-    * op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp112 1.5 :iterations
-    * op div *tmp113 :drawPixel:iterations 170
+  234 op mul *tmp110 4 *tmp41
+  235 op div :drawPixel:r *tmp41 63.75
+  236 op mul *tmp112 1.5 *tmp41
+  237 op div *tmp113 *tmp41 170
   238 op add :drawPixel:g 96 *tmp113
   239 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   240 jump *label65 always
   241 label *label70
-    * op mul *tmp116 4 :iterations
-    * op div *tmp117 :drawPixel:iterations 63.75
+  242 op mul *tmp116 4 *tmp41
+  243 op div *tmp117 *tmp41 63.75
   244 op sub :drawPixel:r 1 *tmp117
   245 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   246 label *label65
   247 label *label64
   248 jump *label62 always
   249 label *label61
-    * read :drawPixel:color .memory :iterations
+  250 read :drawPixel:color .memory *tmp41
   251 label *label62
   252 jump *label72 lessThan .localBuffer 250
   253 setaddr :flushLocalBuffer*retaddr *label74 (h:*label74)

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-8 instructions):
 
   191 jump *label46 always
   192 label *label46
   193 set :iterations *tmp41
-    * set :drawPixel:iterations *tmp41
   194 jump *label61 equal .SMOOTH false
   195 jump *label63 notEqual *tmp41 63
   196 set :drawPixel:color %[black]
 
   206 op abs *tmp88 *tmp87
   207 op div *tmp90 *tmp88 42.5
   208 op sub :drawPixel:g 0.9411764705882353 *tmp90
-    * op sub *tmp92 32 *tmp41
-    * op abs *tmp93 *tmp82
   209 op div *tmp95 *tmp83 63.75
   210 op add :drawPixel:b 0.47058823529411764 *tmp95
   211 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   213 label *label66
   214 jump *label68 notEqual .PALETTE 3
   215 label *label69
-    * op div *tmp98 *tmp41 63
   216 op div *tmp99 *tmp41 0.175
   217 op sin :drawPixel:r *tmp99
-    * op div *tmp101 *tmp41 63
-    * op div *tmp102 :iterations 0.175
+  218 op div *tmp102 *tmp41 0.175
   219 op cos :drawPixel:g *tmp99
   220 op sub *tmp104 *tmp41 32
   221 op abs *tmp105 *tmp104
 
   226 label *label68
   227 jump *label70 notEqual .PALETTE 4
   228 label *label71
-    * op mul *tmp110 4 *tmp41
   229 op div :drawPixel:r *tmp41 63.75
-    * op mul *tmp112 1.5 *tmp41
   230 op div *tmp113 *tmp41 170
   231 op add :drawPixel:g 96 *tmp113
   232 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   233 jump *label65 always
   234 label *label70
-    * op mul *tmp116 4 *tmp41
   235 op div *tmp117 *tmp41 63.75
   236 op sub :drawPixel:r 1 *tmp117
   237 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   190 set *tmp41 :compute:i
   191 jump *label46 always
   192 label *label46
-    * set :iterations *tmp41
   193 jump *label61 equal .SMOOTH false
   194 jump *label63 notEqual *tmp41 63
   195 set :drawPixel:color %[black]
 
   214 label *label69
   215 op div *tmp99 *tmp41 0.175
   216 op sin :drawPixel:r *tmp99
-    * op div *tmp102 *tmp41 0.175
   217 op cos :drawPixel:g *tmp99
   218 op sub *tmp104 *tmp41 32
   219 op abs *tmp105 *tmp104

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    82 label *label5
    83 label *label2
    84 label *label30
+   85 set :setState:state 0
+   86 setaddr :setState*retaddr *label36 (h:*label36)
    87 label *label33
-    * set :setState:state 0
-    * setaddr :setState*retaddr *label36 (h:*label36)
    88 call *label1 *invalid :setState*retval (m:*label36) (h:*label36)
    89 label *label36
    90 label *label34

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-3 instructions):
 
    20 set :findLinkedBlocks:n @links
    21 label *label11
    22 jump *label13 lessThanEq :findLinkedBlocks:n 0
+   23 label *label100
    24 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
    25 getlink :findLinkedBlocks:block :findLinkedBlocks:n
    26 print "\nFound: "
 
    50 set .memory :findLinkedBlocks:variable
    51 label *label16
    52 label *label12
-    * jump *label11 always
+   53 jump *label100 greaterThan :findLinkedBlocks:n 0
    54 label *label13
    55 set :findLinkedBlocks:foundAll 1
    56 set :findLinkedBlocks:name "Display"
 
   118 wait *tmp31
   119 set :lines 0
   120 label *label38
-    * jump *label40 greaterThanEq :lines 176
+  121 label *label101
   122 op mul *tmp32 17 :line
   123 op mod :x *tmp32 176
   124 op add :position :x 158
 
   127 write .PROCESSOR_ID .memory :position
   128 set :y 0
   129 label *label43
-    * jump *label45 greaterThanEq :y 176
+  130 label *label102
   131 op div *tmp42 :x .ZOOM
   132 op add :compute:zx *tmp42 .OFFSET_X
   133 op div *tmp44 :y .ZOOM
 
   160 label *label48
   161 set :compute:i 0
   162 label *label53
-    * jump *label55 greaterThanEq :compute:i 63
+  163 label *label103
   164 set :compute:x1 :compute:zx
   165 op mul *tmp59 :compute:zx :compute:zx
   166 op mul *tmp60 :compute:zy :compute:zy
 
   176 label *label57
   177 label *label54
   178 op add :compute:i :compute:i 1
-    * jump *label53 always
+  179 jump *label103 lessThan :compute:i 63
   180 label *label55
   181 op mul *tmp69 .SMOOTH 63
   182 jump *label58 greaterThanEq :compute:i *tmp69
 
   271 label *label82
   272 label *label44
   273 op add :y :y 1
-    * jump *label43 always
+  274 jump *label102 lessThan :y 176
   275 label *label45
   276 label *label41
   277 label *label42
 
   284 label *label84
   285 label *label39
   286 op add :lines :lines 1
-    * jump *label38 always
+  287 jump *label101 lessThan :lines 176
   288 label *label40
   289 setaddr :flushLocalBuffer*retaddr *label85 (h:*label85)
   290 call *label0 *invalid :flushLocalBuffer*retval (m:*label85) (h:*label85)
 
   311 label *label1
   312 label *label93
   313 jump *label95 greaterThanEq .PROC_STATE_INDEX 512
+  314 label *label104
   315 read *tmp144 .memory .PROC_ID_INDEX
   316 jump *label96 notEqual *tmp144 .PROCESSOR_ID
   317 write :setState:state .memory .PROC_STATE_INDEX
 
   330 label *label99
   331 label *label97
   332 label *label94
-    * jump *label93 always
+  333 jump *label104 lessThan .PROC_STATE_INDEX 512
   334 label *label95
   335 label *label92
   336 return :setState*retaddr

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   192 jump *label46 always
   193 label *label46
   194 jump *label61 equal .SMOOTH false
-    * jump *label63 notEqual *tmp41 63
   195 set :drawPixel:color %[black]
-    * jump *label64 always
+  196 jump *label64 equal *tmp41 63
   197 label *label63
   198 jump *label66 notEqual .PALETTE 2
   199 label *label67

Modifications by Unroll iteration loop at *blocks:59:9 (-4 instructions):
 
     5 set .localBuffer 0
     6 set :findLinkedBlocks:message null
     7 label *label3
-    * setaddr *tmp13 *label9
-    * jump *label6 always
-    * multilabel *label9 (m:marker0)
-    * set .display null
-    * setaddr *tmp13 *label10
-    * label *label6
-    * label *label7
-    * multijump *tmp13 0 0 (m:marker0)
-    * multilabel *label10 (m:marker0)
-    * set .memory null
-    * label *label8
+    8 label *label105
+    9 label *label106
+   10 set .display null
+   11 label *label109
+   12 label *label110
+   13 set .memory null
+   14 label *label8
    15 print "Mandelbrot Generator"
    16 set :findLinkedBlocks:n @links
    17 label *label11

Modifications by Unroll iteration loop at *blocks:68:13:
 
    22 print "\nFound: "
    23 print :findLinkedBlocks:block
    24 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp17 *label17
-    * jump *label14 always
-    * multilabel *label17 (m:marker1)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp17 *label18
-    * label *label14
-    * jump *label19 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
-    * set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label21 notEqual :findLinkedBlocks:requested @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
-    * label *label21
-    * label *label22
-    * label *label19
-    * label *label20
-    * label *label15
-    * multijump *tmp17 0 0 (m:marker1)
-    * multilabel *label18 (m:marker1)
-    * set .memory :findLinkedBlocks:variable
-    * label *label16
+   25 set :findLinkedBlocks:requested @large-logic-display
+   26 set :findLinkedBlocks:variable .display
+   27 label *label114
+   28 jump *label117 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   29 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   30 jump *label115 notEqual :findLinkedBlocks:requested @message
+   31 set :findLinkedBlocks:message :findLinkedBlocks:block
+   32 label *label115
+   33 label *label116
+   34 label *label117
+   35 label *label118
+   36 label *label119
+   37 set .display :findLinkedBlocks:variable
+   38 set :findLinkedBlocks:requested @memory-bank
+   39 set :findLinkedBlocks:variable .memory
+   40 label *label122
+   41 jump *label125 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   42 set :findLinkedBlocks:variable :findLinkedBlocks:block
+   43 jump *label123 notEqual :findLinkedBlocks:requested @message
+   44 set :findLinkedBlocks:message :findLinkedBlocks:block
+   45 label *label123
+   46 label *label124
+   47 label *label125
+   48 label *label126
+   49 label *label127
+   50 set .memory :findLinkedBlocks:variable
+   51 label *label16
    52 label *label12
    53 jump *label100 greaterThan :findLinkedBlocks:n 0
    54 label *label13

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    25 set :findLinkedBlocks:requested @large-logic-display
    26 set :findLinkedBlocks:variable .display
    27 label *label114
-    * jump *label117 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   28 jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
    29 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label115 notEqual :findLinkedBlocks:requested @message
+   30 jump *label115 notEqual @large-logic-display @message
    31 set :findLinkedBlocks:message :findLinkedBlocks:block
    32 label *label115
    33 label *label116
 
    38 set :findLinkedBlocks:requested @memory-bank
    39 set :findLinkedBlocks:variable .memory
    40 label *label122
-    * jump *label125 notEqual :findLinkedBlocks:requested :findLinkedBlocks:type
+   41 jump *label125 notEqual @memory-bank :findLinkedBlocks:type
    42 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label123 notEqual :findLinkedBlocks:requested @message
+   43 jump *label123 notEqual @memory-bank @message
    44 set :findLinkedBlocks:message :findLinkedBlocks:block
    45 label *label123
    46 label *label124

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    22 print "\nFound: "
    23 print :findLinkedBlocks:block
    24 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
-    * set :findLinkedBlocks:requested @large-logic-display
    25 set :findLinkedBlocks:variable .display
    26 label *label114
    27 jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
    28 set :findLinkedBlocks:variable :findLinkedBlocks:block
    29 jump *label115 notEqual @large-logic-display @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
    30 label *label115
    31 label *label116
    32 label *label117
    33 label *label118
    34 label *label119
    35 set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:requested @memory-bank
    36 set :findLinkedBlocks:variable .memory
    37 label *label122
    38 jump *label125 notEqual @memory-bank :findLinkedBlocks:type
    39 set :findLinkedBlocks:variable :findLinkedBlocks:block
    40 jump *label123 notEqual @memory-bank @message
-    * set :findLinkedBlocks:message :findLinkedBlocks:block
    41 label *label123
    42 label *label124
    43 label *label125
 
    73 multilabel *label27 (m:marker2)
    74 set .memory :findLinkedBlocks:variable
    75 label *label25
-    * printflush :findLinkedBlocks:message
+   76 printflush null
    77 label *label4
    78 jump *label3 equal :findLinkedBlocks:foundAll false
    79 label *label5

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
     3 set .PROC_STATE_INDEX 335
     4 set .start 0
     5 set .localBuffer 0
-    * set :findLinkedBlocks:message null
     6 label *label3
     7 label *label105
     8 label *label106

Modifications by Unroll iteration loop at *blocks:77:9 (+3 instructions):
 
    48 jump *label100 greaterThan :findLinkedBlocks:n 0
    49 label *label13
    50 set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
-    * setaddr *tmp22 *label26
-    * jump *label23 always
-    * multilabel *label26 (m:marker2)
-    * set .display :findLinkedBlocks:variable
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
-    * setaddr *tmp22 *label27
-    * label *label23
-    * print "\n"
-    * print :findLinkedBlocks:name
-    * print ":"
-    * print " "
-    * print :findLinkedBlocks:variable
-    * jump *label28 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
-    * label *label28
-    * label *label29
-    * label *label24
-    * multijump *tmp22 0 0 (m:marker2)
-    * multilabel *label27 (m:marker2)
-    * set .memory :findLinkedBlocks:variable
-    * label *label25
+   51 set :findLinkedBlocks:name "Display"
+   52 set :findLinkedBlocks:variable .display
+   53 label *label131
+   54 print "\n"
+   55 print :findLinkedBlocks:name
+   56 print ":"
+   57 print " "
+   58 print :findLinkedBlocks:variable
+   59 jump *label132 equal true false
+   60 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   61 label *label132
+   62 label *label133
+   63 label *label134
+   64 set .display :findLinkedBlocks:variable
+   65 set :findLinkedBlocks:name "Memory"
+   66 set :findLinkedBlocks:variable .memory
+   67 label *label137
+   68 print "\n"
+   69 print :findLinkedBlocks:name
+   70 print ":"
+   71 print " "
+   72 print :findLinkedBlocks:variable
+   73 jump *label138 equal true false
+   74 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   75 label *label138
+   76 label *label139
+   77 label *label140
+   78 set .memory :findLinkedBlocks:variable
+   79 label *label25
    80 printflush null
    81 label *label4
    82 jump *label3 equal :findLinkedBlocks:foundAll false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    52 set :findLinkedBlocks:variable .display
    53 label *label131
    54 print "\n"
-    * print :findLinkedBlocks:name
+   55 print "Display"
    56 print ":"
    57 print " "
-    * print :findLinkedBlocks:variable
+   58 print .display
    59 jump *label132 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   60 op and :findLinkedBlocks:foundAll 1 .display
    61 label *label132
    62 label *label133
    63 label *label134
-    * set .display :findLinkedBlocks:variable
+   64 set .display .display
    65 set :findLinkedBlocks:name "Memory"
    66 set :findLinkedBlocks:variable .memory
    67 label *label137
    68 print "\n"
-    * print :findLinkedBlocks:name
+   69 print "Memory"
    70 print ":"
    71 print " "
-    * print :findLinkedBlocks:variable
+   72 print .memory
    73 jump *label138 equal true false
-    * op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll :findLinkedBlocks:variable
+   74 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    75 label *label138
    76 label *label139
    77 label *label140
-    * set .memory :findLinkedBlocks:variable
+   78 set .memory .memory
    79 label *label25
    80 printflush null
    81 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    47 label *label12
    48 jump *label100 greaterThan :findLinkedBlocks:n 0
    49 label *label13
-    * set :findLinkedBlocks:foundAll 1
-    * set :findLinkedBlocks:name "Display"
-    * set :findLinkedBlocks:variable .display
    50 label *label131
    51 print "\n"
    52 print "Display"
 
    59 label *label133
    60 label *label134
    61 set .display .display
-    * set :findLinkedBlocks:name "Memory"
-    * set :findLinkedBlocks:variable .memory
    62 label *label137
    63 print "\n"
    64 print "Memory"

Modifications by Unroll loop at mandelbrot-compute.mnd:136:5 (+743 instructions):
 
   153 label *label51
   154 label *label52
   155 label *label48
-    * set :compute:i 0
-    * label *label53
-    * label *label103
-    * set :compute:x1 :compute:zx
-    * op mul *tmp59 :compute:zx :compute:zx
-    * op mul *tmp60 :compute:zy :compute:zy
-    * op sub *tmp61 *tmp59 *tmp60
-    * op add :compute:zx *tmp61 :compute:cx
-    * op mul *tmp63 2 :compute:x1
-    * op mul *tmp64 *tmp63 :compute:zy
-    * op add :compute:zy *tmp64 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label56 lessThan :compute:dist 64
-    * jump *label55 always
-    * label *label56
-    * label *label57
-    * label *label54
-    * op add :compute:i :compute:i 1
-    * jump *label103 lessThan :compute:i 63
-    * label *label55
+  156 set :compute:i 0
+  157 label *label144
+  158 label *label145
+  159 set :compute:x1 :compute:zx
+  160 op mul *tmp59 :compute:zx :compute:zx
+  161 op mul *tmp60 :compute:zy :compute:zy
+  162 op sub *tmp61 *tmp59 *tmp60
+  163 op add :compute:zx *tmp61 :compute:cx
+  164 op mul *tmp63 2 :compute:x1
+  165 op mul *tmp64 *tmp63 :compute:zy
+  166 op add :compute:zy *tmp64 :compute:cy
+  167 op len :compute:dist :compute:zx :compute:zy
+  168 jump *label146 lessThan :compute:dist 64
+  169 jump *label55 always
+  170 label *label146
+  171 label *label147
+  172 label *label148
+  173 op add :compute:i :compute:i 1
+  174 label *label149
+  175 set :compute:x1 :compute:zx
+  176 op mul *tmp59 :compute:zx :compute:zx
+  177 op mul *tmp60 :compute:zy :compute:zy
+  178 op sub *tmp61 *tmp59 *tmp60
+  179 op add :compute:zx *tmp61 :compute:cx
+  180 op mul *tmp63 2 :compute:x1
+  181 op mul *tmp64 *tmp63 :compute:zy
+  182 op add :compute:zy *tmp64 :compute:cy
+  183 op len :compute:dist :compute:zx :compute:zy
+  184 jump *label150 lessThan :compute:dist 64
+  185 jump *label55 always
+  186 label *label150
+  187 label *label151
+  188 label *label152
+  189 op add :compute:i :compute:i 1
+  190 label *label153
+  191 set :compute:x1 :compute:zx
+  192 op mul *tmp59 :compute:zx :compute:zx
+  193 op mul *tmp60 :compute:zy :compute:zy
+  194 op sub *tmp61 *tmp59 *tmp60
+  195 op add :compute:zx *tmp61 :compute:cx
+  196 op mul *tmp63 2 :compute:x1
+  197 op mul *tmp64 *tmp63 :compute:zy
+  198 op add :compute:zy *tmp64 :compute:cy
+  199 op len :compute:dist :compute:zx :compute:zy
+  200 jump *label154 lessThan :compute:dist 64
+  201 jump *label55 always
+  202 label *label154
+  203 label *label155
+  204 label *label156
+  205 op add :compute:i :compute:i 1
+  206 label *label157
+  207 set :compute:x1 :compute:zx
+  208 op mul *tmp59 :compute:zx :compute:zx
+  209 op mul *tmp60 :compute:zy :compute:zy
+  210 op sub *tmp61 *tmp59 *tmp60
+  211 op add :compute:zx *tmp61 :compute:cx
+  212 op mul *tmp63 2 :compute:x1
+  213 op mul *tmp64 *tmp63 :compute:zy
+  214 op add :compute:zy *tmp64 :compute:cy
+  215 op len :compute:dist :compute:zx :compute:zy
+  216 jump *label158 lessThan :compute:dist 64
+  217 jump *label55 always
+  218 label *label158
+  219 label *label159
+  220 label *label160
+  221 op add :compute:i :compute:i 1
+  222 label *label161
+  223 set :compute:x1 :compute:zx
+  224 op mul *tmp59 :compute:zx :compute:zx
+  225 op mul *tmp60 :compute:zy :compute:zy
+  226 op sub *tmp61 *tmp59 *tmp60
+  227 op add :compute:zx *tmp61 :compute:cx
+  228 op mul *tmp63 2 :compute:x1
+  229 op mul *tmp64 *tmp63 :compute:zy
+  230 op add :compute:zy *tmp64 :compute:cy
+  231 op len :compute:dist :compute:zx :compute:zy
+  232 jump *label162 lessThan :compute:dist 64
+  233 jump *label55 always
+  234 label *label162
+  235 label *label163
+  236 label *label164
+  237 op add :compute:i :compute:i 1
+  238 label *label165
+  239 set :compute:x1 :compute:zx
+  240 op mul *tmp59 :compute:zx :compute:zx
+  241 op mul *tmp60 :compute:zy :compute:zy
+  242 op sub *tmp61 *tmp59 *tmp60
+  243 op add :compute:zx *tmp61 :compute:cx
+  244 op mul *tmp63 2 :compute:x1
+  245 op mul *tmp64 *tmp63 :compute:zy
+  246 op add :compute:zy *tmp64 :compute:cy
+  247 op len :compute:dist :compute:zx :compute:zy
+  248 jump *label166 lessThan :compute:dist 64
+  249 jump *label55 always
+  250 label *label166
+  251 label *label167
+  252 label *label168
+  253 op add :compute:i :compute:i 1
+  254 label *label169
+  255 set :compute:x1 :compute:zx
+  256 op mul *tmp59 :compute:zx :compute:zx
+  257 op mul *tmp60 :compute:zy :compute:zy
+  258 op sub *tmp61 *tmp59 *tmp60
+  259 op add :compute:zx *tmp61 :compute:cx
+  260 op mul *tmp63 2 :compute:x1
+  261 op mul *tmp64 *tmp63 :compute:zy
+  262 op add :compute:zy *tmp64 :compute:cy
+  263 op len :compute:dist :compute:zx :compute:zy
+  264 jump *label170 lessThan :compute:dist 64
+  265 jump *label55 always
+  266 label *label170
+  267 label *label171
+  268 label *label172
+  269 op add :compute:i :compute:i 1
+  270 label *label173
+  271 set :compute:x1 :compute:zx
+  272 op mul *tmp59 :compute:zx :compute:zx
+  273 op mul *tmp60 :compute:zy :compute:zy
+  274 op sub *tmp61 *tmp59 *tmp60
+  275 op add :compute:zx *tmp61 :compute:cx
+  276 op mul *tmp63 2 :compute:x1
+  277 op mul *tmp64 *tmp63 :compute:zy
+  278 op add :compute:zy *tmp64 :compute:cy
+  279 op len :compute:dist :compute:zx :compute:zy
+  280 jump *label174 lessThan :compute:dist 64
+  281 jump *label55 always
+  282 label *label174
+  283 label *label175
+  284 label *label176
+  285 op add :compute:i :compute:i 1
+  286 label *label177
+  287 set :compute:x1 :compute:zx
+  288 op mul *tmp59 :compute:zx :compute:zx
+  289 op mul *tmp60 :compute:zy :compute:zy
+  290 op sub *tmp61 *tmp59 *tmp60
+  291 op add :compute:zx *tmp61 :compute:cx
+  292 op mul *tmp63 2 :compute:x1
+  293 op mul *tmp64 *tmp63 :compute:zy
+  294 op add :compute:zy *tmp64 :compute:cy
+  295 op len :compute:dist :compute:zx :compute:zy
+  296 jump *label178 lessThan :compute:dist 64
+  297 jump *label55 always
+  298 label *label178
+  299 label *label179
+  300 label *label180
+  301 op add :compute:i :compute:i 1
+  302 label *label181
+  303 set :compute:x1 :compute:zx
+  304 op mul *tmp59 :compute:zx :compute:zx
+  305 op mul *tmp60 :compute:zy :compute:zy
+  306 op sub *tmp61 *tmp59 *tmp60
+  307 op add :compute:zx *tmp61 :compute:cx
+  308 op mul *tmp63 2 :compute:x1
+  309 op mul *tmp64 *tmp63 :compute:zy
+  310 op add :compute:zy *tmp64 :compute:cy
+  311 op len :compute:dist :compute:zx :compute:zy
+  312 jump *label182 lessThan :compute:dist 64
+  313 jump *label55 always
+  314 label *label182
+  315 label *label183
+  316 label *label184
+  317 op add :compute:i :compute:i 1
+  318 label *label185
+  319 set :compute:x1 :compute:zx
+  320 op mul *tmp59 :compute:zx :compute:zx
+  321 op mul *tmp60 :compute:zy :compute:zy
+  322 op sub *tmp61 *tmp59 *tmp60
+  323 op add :compute:zx *tmp61 :compute:cx
+  324 op mul *tmp63 2 :compute:x1
+  325 op mul *tmp64 *tmp63 :compute:zy
+  326 op add :compute:zy *tmp64 :compute:cy
+  327 op len :compute:dist :compute:zx :compute:zy
+  328 jump *label186 lessThan :compute:dist 64
+  329 jump *label55 always
+  330 label *label186
+  331 label *label187
+  332 label *label188
+  333 op add :compute:i :compute:i 1
+  334 label *label189
+  335 set :compute:x1 :compute:zx
+  336 op mul *tmp59 :compute:zx :compute:zx
+  337 op mul *tmp60 :compute:zy :compute:zy
+  338 op sub *tmp61 *tmp59 *tmp60
+  339 op add :compute:zx *tmp61 :compute:cx
+  340 op mul *tmp63 2 :compute:x1
+  341 op mul *tmp64 *tmp63 :compute:zy
+  342 op add :compute:zy *tmp64 :compute:cy
+  343 op len :compute:dist :compute:zx :compute:zy
+  344 jump *label190 lessThan :compute:dist 64
+  345 jump *label55 always
+  346 label *label190
+  347 label *label191
+  348 label *label192
+  349 op add :compute:i :compute:i 1
+  350 label *label193
+  351 set :compute:x1 :compute:zx
+  352 op mul *tmp59 :compute:zx :compute:zx
+  353 op mul *tmp60 :compute:zy :compute:zy
+  354 op sub *tmp61 *tmp59 *tmp60
+  355 op add :compute:zx *tmp61 :compute:cx
+  356 op mul *tmp63 2 :compute:x1
+  357 op mul *tmp64 *tmp63 :compute:zy
+  358 op add :compute:zy *tmp64 :compute:cy
+  359 op len :compute:dist :compute:zx :compute:zy
+  360 jump *label194 lessThan :compute:dist 64
+  361 jump *label55 always
+  362 label *label194
+  363 label *label195
+  364 label *label196
+  365 op add :compute:i :compute:i 1
+  366 label *label197
+  367 set :compute:x1 :compute:zx
+  368 op mul *tmp59 :compute:zx :compute:zx
+  369 op mul *tmp60 :compute:zy :compute:zy
+  370 op sub *tmp61 *tmp59 *tmp60
+  371 op add :compute:zx *tmp61 :compute:cx
+  372 op mul *tmp63 2 :compute:x1
+  373 op mul *tmp64 *tmp63 :compute:zy
+  374 op add :compute:zy *tmp64 :compute:cy
+  375 op len :compute:dist :compute:zx :compute:zy
+  376 jump *label198 lessThan :compute:dist 64
+  377 jump *label55 always
+  378 label *label198
+  379 label *label199
+  380 label *label200
+  381 op add :compute:i :compute:i 1
+  382 label *label201
+  383 set :compute:x1 :compute:zx
+  384 op mul *tmp59 :compute:zx :compute:zx
+  385 op mul *tmp60 :compute:zy :compute:zy
+  386 op sub *tmp61 *tmp59 *tmp60
+  387 op add :compute:zx *tmp61 :compute:cx
+  388 op mul *tmp63 2 :compute:x1
+  389 op mul *tmp64 *tmp63 :compute:zy
+  390 op add :compute:zy *tmp64 :compute:cy
+  391 op len :compute:dist :compute:zx :compute:zy
+  392 jump *label202 lessThan :compute:dist 64
+  393 jump *label55 always
+  394 label *label202
+  395 label *label203
+  396 label *label204
+  397 op add :compute:i :compute:i 1
+  398 label *label205
+  399 set :compute:x1 :compute:zx
+  400 op mul *tmp59 :compute:zx :compute:zx
+  401 op mul *tmp60 :compute:zy :compute:zy
+  402 op sub *tmp61 *tmp59 *tmp60
+  403 op add :compute:zx *tmp61 :compute:cx
+  404 op mul *tmp63 2 :compute:x1
+  405 op mul *tmp64 *tmp63 :compute:zy
+  406 op add :compute:zy *tmp64 :compute:cy
+  407 op len :compute:dist :compute:zx :compute:zy
+  408 jump *label206 lessThan :compute:dist 64
+  409 jump *label55 always
+  410 label *label206
+  411 label *label207
+  412 label *label208
+  413 op add :compute:i :compute:i 1
+  414 label *label209
+  415 set :compute:x1 :compute:zx
+  416 op mul *tmp59 :compute:zx :compute:zx
+  417 op mul *tmp60 :compute:zy :compute:zy
+  418 op sub *tmp61 *tmp59 *tmp60
+  419 op add :compute:zx *tmp61 :compute:cx
+  420 op mul *tmp63 2 :compute:x1
+  421 op mul *tmp64 *tmp63 :compute:zy
+  422 op add :compute:zy *tmp64 :compute:cy
+  423 op len :compute:dist :compute:zx :compute:zy
+  424 jump *label210 lessThan :compute:dist 64
+  425 jump *label55 always
+  426 label *label210
+  427 label *label211
+  428 label *label212
+  429 op add :compute:i :compute:i 1
+  430 label *label213
+  431 set :compute:x1 :compute:zx
+  432 op mul *tmp59 :compute:zx :compute:zx
+  433 op mul *tmp60 :compute:zy :compute:zy
+  434 op sub *tmp61 *tmp59 *tmp60
+  435 op add :compute:zx *tmp61 :compute:cx
+  436 op mul *tmp63 2 :compute:x1
+  437 op mul *tmp64 *tmp63 :compute:zy
+  438 op add :compute:zy *tmp64 :compute:cy
+  439 op len :compute:dist :compute:zx :compute:zy
+  440 jump *label214 lessThan :compute:dist 64
+  441 jump *label55 always
+  442 label *label214
+  443 label *label215
+  444 label *label216
+  445 op add :compute:i :compute:i 1
+  446 label *label217
+  447 set :compute:x1 :compute:zx
+  448 op mul *tmp59 :compute:zx :compute:zx
+  449 op mul *tmp60 :compute:zy :compute:zy
+  450 op sub *tmp61 *tmp59 *tmp60
+  451 op add :compute:zx *tmp61 :compute:cx
+  452 op mul *tmp63 2 :compute:x1
+  453 op mul *tmp64 *tmp63 :compute:zy
+  454 op add :compute:zy *tmp64 :compute:cy
+  455 op len :compute:dist :compute:zx :compute:zy
+  456 jump *label218 lessThan :compute:dist 64
+  457 jump *label55 always
+  458 label *label218
+  459 label *label219
+  460 label *label220
+  461 op add :compute:i :compute:i 1
+  462 label *label221
+  463 set :compute:x1 :compute:zx
+  464 op mul *tmp59 :compute:zx :compute:zx
+  465 op mul *tmp60 :compute:zy :compute:zy
+  466 op sub *tmp61 *tmp59 *tmp60
+  467 op add :compute:zx *tmp61 :compute:cx
+  468 op mul *tmp63 2 :compute:x1
+  469 op mul *tmp64 *tmp63 :compute:zy
+  470 op add :compute:zy *tmp64 :compute:cy
+  471 op len :compute:dist :compute:zx :compute:zy
+  472 jump *label222 lessThan :compute:dist 64
+  473 jump *label55 always
+  474 label *label222
+  475 label *label223
+  476 label *label224
+  477 op add :compute:i :compute:i 1
+  478 label *label225
+  479 set :compute:x1 :compute:zx
+  480 op mul *tmp59 :compute:zx :compute:zx
+  481 op mul *tmp60 :compute:zy :compute:zy
+  482 op sub *tmp61 *tmp59 *tmp60
+  483 op add :compute:zx *tmp61 :compute:cx
+  484 op mul *tmp63 2 :compute:x1
+  485 op mul *tmp64 *tmp63 :compute:zy
+  486 op add :compute:zy *tmp64 :compute:cy
+  487 op len :compute:dist :compute:zx :compute:zy
+  488 jump *label226 lessThan :compute:dist 64
+  489 jump *label55 always
+  490 label *label226
+  491 label *label227
+  492 label *label228
+  493 op add :compute:i :compute:i 1
+  494 label *label229
+  495 set :compute:x1 :compute:zx
+  496 op mul *tmp59 :compute:zx :compute:zx
+  497 op mul *tmp60 :compute:zy :compute:zy
+  498 op sub *tmp61 *tmp59 *tmp60
+  499 op add :compute:zx *tmp61 :compute:cx
+  500 op mul *tmp63 2 :compute:x1
+  501 op mul *tmp64 *tmp63 :compute:zy
+  502 op add :compute:zy *tmp64 :compute:cy
+  503 op len :compute:dist :compute:zx :compute:zy
+  504 jump *label230 lessThan :compute:dist 64
+  505 jump *label55 always
+  506 label *label230
+  507 label *label231
+  508 label *label232
+  509 op add :compute:i :compute:i 1
+  510 label *label233
+  511 set :compute:x1 :compute:zx
+  512 op mul *tmp59 :compute:zx :compute:zx
+  513 op mul *tmp60 :compute:zy :compute:zy
+  514 op sub *tmp61 *tmp59 *tmp60
+  515 op add :compute:zx *tmp61 :compute:cx
+  516 op mul *tmp63 2 :compute:x1
+  517 op mul *tmp64 *tmp63 :compute:zy
+  518 op add :compute:zy *tmp64 :compute:cy
+  519 op len :compute:dist :compute:zx :compute:zy
+  520 jump *label234 lessThan :compute:dist 64
+  521 jump *label55 always
+  522 label *label234
+  523 label *label235
+  524 label *label236
+  525 op add :compute:i :compute:i 1
+  526 label *label237
+  527 set :compute:x1 :compute:zx
+  528 op mul *tmp59 :compute:zx :compute:zx
+  529 op mul *tmp60 :compute:zy :compute:zy
+  530 op sub *tmp61 *tmp59 *tmp60
+  531 op add :compute:zx *tmp61 :compute:cx
+  532 op mul *tmp63 2 :compute:x1
+  533 op mul *tmp64 *tmp63 :compute:zy
+  534 op add :compute:zy *tmp64 :compute:cy
+  535 op len :compute:dist :compute:zx :compute:zy
+  536 jump *label238 lessThan :compute:dist 64
+  537 jump *label55 always
+  538 label *label238
+  539 label *label239
+  540 label *label240
+  541 op add :compute:i :compute:i 1
+  542 label *label241
+  543 set :compute:x1 :compute:zx
+  544 op mul *tmp59 :compute:zx :compute:zx
+  545 op mul *tmp60 :compute:zy :compute:zy
+  546 op sub *tmp61 *tmp59 *tmp60
+  547 op add :compute:zx *tmp61 :compute:cx
+  548 op mul *tmp63 2 :compute:x1
+  549 op mul *tmp64 *tmp63 :compute:zy
+  550 op add :compute:zy *tmp64 :compute:cy
+  551 op len :compute:dist :compute:zx :compute:zy
+  552 jump *label242 lessThan :compute:dist 64
+  553 jump *label55 always
+  554 label *label242
+  555 label *label243
+  556 label *label244
+  557 op add :compute:i :compute:i 1
+  558 label *label245
+  559 set :compute:x1 :compute:zx
+  560 op mul *tmp59 :compute:zx :compute:zx
+  561 op mul *tmp60 :compute:zy :compute:zy
+  562 op sub *tmp61 *tmp59 *tmp60
+  563 op add :compute:zx *tmp61 :compute:cx
+  564 op mul *tmp63 2 :compute:x1
+  565 op mul *tmp64 *tmp63 :compute:zy
+  566 op add :compute:zy *tmp64 :compute:cy
+  567 op len :compute:dist :compute:zx :compute:zy
+  568 jump *label246 lessThan :compute:dist 64
+  569 jump *label55 always
+  570 label *label246
+  571 label *label247
+  572 label *label248
+  573 op add :compute:i :compute:i 1
+  574 label *label249
+  575 set :compute:x1 :compute:zx
+  576 op mul *tmp59 :compute:zx :compute:zx
+  577 op mul *tmp60 :compute:zy :compute:zy
+  578 op sub *tmp61 *tmp59 *tmp60
+  579 op add :compute:zx *tmp61 :compute:cx
+  580 op mul *tmp63 2 :compute:x1
+  581 op mul *tmp64 *tmp63 :compute:zy
+  582 op add :compute:zy *tmp64 :compute:cy
+  583 op len :compute:dist :compute:zx :compute:zy
+  584 jump *label250 lessThan :compute:dist 64
+  585 jump *label55 always
+  586 label *label250
+  587 label *label251
+  588 label *label252
+  589 op add :compute:i :compute:i 1
+  590 label *label253
+  591 set :compute:x1 :compute:zx
+  592 op mul *tmp59 :compute:zx :compute:zx
+  593 op mul *tmp60 :compute:zy :compute:zy
+  594 op sub *tmp61 *tmp59 *tmp60
+  595 op add :compute:zx *tmp61 :compute:cx
+  596 op mul *tmp63 2 :compute:x1
+  597 op mul *tmp64 *tmp63 :compute:zy
+  598 op add :compute:zy *tmp64 :compute:cy
+  599 op len :compute:dist :compute:zx :compute:zy
+  600 jump *label254 lessThan :compute:dist 64
+  601 jump *label55 always
+  602 label *label254
+  603 label *label255
+  604 label *label256
+  605 op add :compute:i :compute:i 1
+  606 label *label257
+  607 set :compute:x1 :compute:zx
+  608 op mul *tmp59 :compute:zx :compute:zx
+  609 op mul *tmp60 :compute:zy :compute:zy
+  610 op sub *tmp61 *tmp59 *tmp60
+  611 op add :compute:zx *tmp61 :compute:cx
+  612 op mul *tmp63 2 :compute:x1
+  613 op mul *tmp64 *tmp63 :compute:zy
+  614 op add :compute:zy *tmp64 :compute:cy
+  615 op len :compute:dist :compute:zx :compute:zy
+  616 jump *label258 lessThan :compute:dist 64
+  617 jump *label55 always
+  618 label *label258
+  619 label *label259
+  620 label *label260
+  621 op add :compute:i :compute:i 1
+  622 label *label261
+  623 set :compute:x1 :compute:zx
+  624 op mul *tmp59 :compute:zx :compute:zx
+  625 op mul *tmp60 :compute:zy :compute:zy
+  626 op sub *tmp61 *tmp59 *tmp60
+  627 op add :compute:zx *tmp61 :compute:cx
+  628 op mul *tmp63 2 :compute:x1
+  629 op mul *tmp64 *tmp63 :compute:zy
+  630 op add :compute:zy *tmp64 :compute:cy
+  631 op len :compute:dist :compute:zx :compute:zy
+  632 jump *label262 lessThan :compute:dist 64
+  633 jump *label55 always
+  634 label *label262
+  635 label *label263
+  636 label *label264
+  637 op add :compute:i :compute:i 1
+  638 label *label265
+  639 set :compute:x1 :compute:zx
+  640 op mul *tmp59 :compute:zx :compute:zx
+  641 op mul *tmp60 :compute:zy :compute:zy
+  642 op sub *tmp61 *tmp59 *tmp60
+  643 op add :compute:zx *tmp61 :compute:cx
+  644 op mul *tmp63 2 :compute:x1
+  645 op mul *tmp64 *tmp63 :compute:zy
+  646 op add :compute:zy *tmp64 :compute:cy
+  647 op len :compute:dist :compute:zx :compute:zy
+  648 jump *label266 lessThan :compute:dist 64
+  649 jump *label55 always
+  650 label *label266
+  651 label *label267
+  652 label *label268
+  653 op add :compute:i :compute:i 1
+  654 label *label269
+  655 set :compute:x1 :compute:zx
+  656 op mul *tmp59 :compute:zx :compute:zx
+  657 op mul *tmp60 :compute:zy :compute:zy
+  658 op sub *tmp61 *tmp59 *tmp60
+  659 op add :compute:zx *tmp61 :compute:cx
+  660 op mul *tmp63 2 :compute:x1
+  661 op mul *tmp64 *tmp63 :compute:zy
+  662 op add :compute:zy *tmp64 :compute:cy
+  663 op len :compute:dist :compute:zx :compute:zy
+  664 jump *label270 lessThan :compute:dist 64
+  665 jump *label55 always
+  666 label *label270
+  667 label *label271
+  668 label *label272
+  669 op add :compute:i :compute:i 1
+  670 label *label273
+  671 set :compute:x1 :compute:zx
+  672 op mul *tmp59 :compute:zx :compute:zx
+  673 op mul *tmp60 :compute:zy :compute:zy
+  674 op sub *tmp61 *tmp59 *tmp60
+  675 op add :compute:zx *tmp61 :compute:cx
+  676 op mul *tmp63 2 :compute:x1
+  677 op mul *tmp64 *tmp63 :compute:zy
+  678 op add :compute:zy *tmp64 :compute:cy
+  679 op len :compute:dist :compute:zx :compute:zy
+  680 jump *label274 lessThan :compute:dist 64
+  681 jump *label55 always
+  682 label *label274
+  683 label *label275
+  684 label *label276
+  685 op add :compute:i :compute:i 1
+  686 label *label277
+  687 set :compute:x1 :compute:zx
+  688 op mul *tmp59 :compute:zx :compute:zx
+  689 op mul *tmp60 :compute:zy :compute:zy
+  690 op sub *tmp61 *tmp59 *tmp60
+  691 op add :compute:zx *tmp61 :compute:cx
+  692 op mul *tmp63 2 :compute:x1
+  693 op mul *tmp64 *tmp63 :compute:zy
+  694 op add :compute:zy *tmp64 :compute:cy
+  695 op len :compute:dist :compute:zx :compute:zy
+  696 jump *label278 lessThan :compute:dist 64
+  697 jump *label55 always
+  698 label *label278
+  699 label *label279
+  700 label *label280
+  701 op add :compute:i :compute:i 1
+  702 label *label281
+  703 set :compute:x1 :compute:zx
+  704 op mul *tmp59 :compute:zx :compute:zx
+  705 op mul *tmp60 :compute:zy :compute:zy
+  706 op sub *tmp61 *tmp59 *tmp60
+  707 op add :compute:zx *tmp61 :compute:cx
+  708 op mul *tmp63 2 :compute:x1
+  709 op mul *tmp64 *tmp63 :compute:zy
+  710 op add :compute:zy *tmp64 :compute:cy
+  711 op len :compute:dist :compute:zx :compute:zy
+  712 jump *label282 lessThan :compute:dist 64
+  713 jump *label55 always
+  714 label *label282
+  715 label *label283
+  716 label *label284
+  717 op add :compute:i :compute:i 1
+  718 label *label285
+  719 set :compute:x1 :compute:zx
+  720 op mul *tmp59 :compute:zx :compute:zx
+  721 op mul *tmp60 :compute:zy :compute:zy
+  722 op sub *tmp61 *tmp59 *tmp60
+  723 op add :compute:zx *tmp61 :compute:cx
+  724 op mul *tmp63 2 :compute:x1
+  725 op mul *tmp64 *tmp63 :compute:zy
+  726 op add :compute:zy *tmp64 :compute:cy
+  727 op len :compute:dist :compute:zx :compute:zy
+  728 jump *label286 lessThan :compute:dist 64
+  729 jump *label55 always
+  730 label *label286
+  731 label *label287
+  732 label *label288
+  733 op add :compute:i :compute:i 1
+  734 label *label289
+  735 set :compute:x1 :compute:zx
+  736 op mul *tmp59 :compute:zx :compute:zx
+  737 op mul *tmp60 :compute:zy :compute:zy
+  738 op sub *tmp61 *tmp59 *tmp60
+  739 op add :compute:zx *tmp61 :compute:cx
+  740 op mul *tmp63 2 :compute:x1
+  741 op mul *tmp64 *tmp63 :compute:zy
+  742 op add :compute:zy *tmp64 :compute:cy
+  743 op len :compute:dist :compute:zx :compute:zy
+  744 jump *label290 lessThan :compute:dist 64
+  745 jump *label55 always
+  746 label *label290
+  747 label *label291
+  748 label *label292
+  749 op add :compute:i :compute:i 1
+  750 label *label293
+  751 set :compute:x1 :compute:zx
+  752 op mul *tmp59 :compute:zx :compute:zx
+  753 op mul *tmp60 :compute:zy :compute:zy
+  754 op sub *tmp61 *tmp59 *tmp60
+  755 op add :compute:zx *tmp61 :compute:cx
+  756 op mul *tmp63 2 :compute:x1
+  757 op mul *tmp64 *tmp63 :compute:zy
+  758 op add :compute:zy *tmp64 :compute:cy
+  759 op len :compute:dist :compute:zx :compute:zy
+  760 jump *label294 lessThan :compute:dist 64
+  761 jump *label55 always
+  762 label *label294
+  763 label *label295
+  764 label *label296
+  765 op add :compute:i :compute:i 1
+  766 label *label297
+  767 set :compute:x1 :compute:zx
+  768 op mul *tmp59 :compute:zx :compute:zx
+  769 op mul *tmp60 :compute:zy :compute:zy
+  770 op sub *tmp61 *tmp59 *tmp60
+  771 op add :compute:zx *tmp61 :compute:cx
+  772 op mul *tmp63 2 :compute:x1
+  773 op mul *tmp64 *tmp63 :compute:zy
+  774 op add :compute:zy *tmp64 :compute:cy
+  775 op len :compute:dist :compute:zx :compute:zy
+  776 jump *label298 lessThan :compute:dist 64
+  777 jump *label55 always
+  778 label *label298
+  779 label *label299
+  780 label *label300
+  781 op add :compute:i :compute:i 1
+  782 label *label301
+  783 set :compute:x1 :compute:zx
+  784 op mul *tmp59 :compute:zx :compute:zx
+  785 op mul *tmp60 :compute:zy :compute:zy
+  786 op sub *tmp61 *tmp59 *tmp60
+  787 op add :compute:zx *tmp61 :compute:cx
+  788 op mul *tmp63 2 :compute:x1
+  789 op mul *tmp64 *tmp63 :compute:zy
+  790 op add :compute:zy *tmp64 :compute:cy
+  791 op len :compute:dist :compute:zx :compute:zy
+  792 jump *label302 lessThan :compute:dist 64
+  793 jump *label55 always
+  794 label *label302
+  795 label *label303
+  796 label *label304
+  797 op add :compute:i :compute:i 1
+  798 label *label305
+  799 set :compute:x1 :compute:zx
+  800 op mul *tmp59 :compute:zx :compute:zx
+  801 op mul *tmp60 :compute:zy :compute:zy
+  802 op sub *tmp61 *tmp59 *tmp60
+  803 op add :compute:zx *tmp61 :compute:cx
+  804 op mul *tmp63 2 :compute:x1
+  805 op mul *tmp64 *tmp63 :compute:zy
+  806 op add :compute:zy *tmp64 :compute:cy
+  807 op len :compute:dist :compute:zx :compute:zy
+  808 jump *label306 lessThan :compute:dist 64
+  809 jump *label55 always
+  810 label *label306
+  811 label *label307
+  812 label *label308
+  813 op add :compute:i :compute:i 1
+  814 label *label309
+  815 set :compute:x1 :compute:zx
+  816 op mul *tmp59 :compute:zx :compute:zx
+  817 op mul *tmp60 :compute:zy :compute:zy
+  818 op sub *tmp61 *tmp59 *tmp60
+  819 op add :compute:zx *tmp61 :compute:cx
+  820 op mul *tmp63 2 :compute:x1
+  821 op mul *tmp64 *tmp63 :compute:zy
+  822 op add :compute:zy *tmp64 :compute:cy
+  823 op len :compute:dist :compute:zx :compute:zy
+  824 jump *label310 lessThan :compute:dist 64
+  825 jump *label55 always
+  826 label *label310
+  827 label *label311
+  828 label *label312
+  829 op add :compute:i :compute:i 1
+  830 label *label313
+  831 set :compute:x1 :compute:zx
+  832 op mul *tmp59 :compute:zx :compute:zx
+  833 op mul *tmp60 :compute:zy :compute:zy
+  834 op sub *tmp61 *tmp59 *tmp60
+  835 op add :compute:zx *tmp61 :compute:cx
+  836 op mul *tmp63 2 :compute:x1
+  837 op mul *tmp64 *tmp63 :compute:zy
+  838 op add :compute:zy *tmp64 :compute:cy
+  839 op len :compute:dist :compute:zx :compute:zy
+  840 jump *label314 lessThan :compute:dist 64
+  841 jump *label55 always
+  842 label *label314
+  843 label *label315
+  844 label *label316
+  845 op add :compute:i :compute:i 1
+  846 label *label317
+  847 set :compute:x1 :compute:zx
+  848 op mul *tmp59 :compute:zx :compute:zx
+  849 op mul *tmp60 :compute:zy :compute:zy
+  850 op sub *tmp61 *tmp59 *tmp60
+  851 op add :compute:zx *tmp61 :compute:cx
+  852 op mul *tmp63 2 :compute:x1
+  853 op mul *tmp64 *tmp63 :compute:zy
+  854 op add :compute:zy *tmp64 :compute:cy
+  855 op len :compute:dist :compute:zx :compute:zy
+  856 jump *label318 lessThan :compute:dist 64
+  857 jump *label55 always
+  858 label *label318
+  859 label *label319
+  860 label *label320
+  861 op add :compute:i :compute:i 1
+  862 label *label321
+  863 set :compute:x1 :compute:zx
+  864 op mul *tmp59 :compute:zx :compute:zx
+  865 op mul *tmp60 :compute:zy :compute:zy
+  866 op sub *tmp61 *tmp59 *tmp60
+  867 op add :compute:zx *tmp61 :compute:cx
+  868 op mul *tmp63 2 :compute:x1
+  869 op mul *tmp64 *tmp63 :compute:zy
+  870 op add :compute:zy *tmp64 :compute:cy
+  871 op len :compute:dist :compute:zx :compute:zy
+  872 jump *label322 lessThan :compute:dist 64
+  873 jump *label55 always
+  874 label *label322
+  875 label *label323
+  876 label *label324
+  877 op add :compute:i :compute:i 1
+  878 label *label325
+  879 set :compute:x1 :compute:zx
+  880 op mul *tmp59 :compute:zx :compute:zx
+  881 op mul *tmp60 :compute:zy :compute:zy
+  882 op sub *tmp61 *tmp59 *tmp60
+  883 op add :compute:zx *tmp61 :compute:cx
+  884 op mul *tmp63 2 :compute:x1
+  885 op mul *tmp64 *tmp63 :compute:zy
+  886 op add :compute:zy *tmp64 :compute:cy
+  887 op len :compute:dist :compute:zx :compute:zy
+  888 jump *label326 lessThan :compute:dist 64
+  889 jump *label55 always
+  890 label *label326
+  891 label *label327
+  892 label *label328
+  893 op add :compute:i :compute:i 1
+  894 label *label329
+  895 set :compute:x1 :compute:zx
+  896 op mul *tmp59 :compute:zx :compute:zx
+  897 op mul *tmp60 :compute:zy :compute:zy
+  898 op sub *tmp61 *tmp59 *tmp60
+  899 op add :compute:zx *tmp61 :compute:cx
+  900 op mul *tmp63 2 :compute:x1
+  901 op mul *tmp64 *tmp63 :compute:zy
+  902 op add :compute:zy *tmp64 :compute:cy
+  903 op len :compute:dist :compute:zx :compute:zy
+  904 jump *label330 lessThan :compute:dist 64
+  905 jump *label55 always
+  906 label *label330
+  907 label *label331
+  908 label *label332
+  909 op add :compute:i :compute:i 1
+  910 label *label333
+  911 set :compute:x1 :compute:zx
+  912 op mul *tmp59 :compute:zx :compute:zx
+  913 op mul *tmp60 :compute:zy :compute:zy
+  914 op sub *tmp61 *tmp59 *tmp60
+  915 op add :compute:zx *tmp61 :compute:cx
+  916 op mul *tmp63 2 :compute:x1
+  917 op mul *tmp64 *tmp63 :compute:zy
+  918 op add :compute:zy *tmp64 :compute:cy
+  919 op len :compute:dist :compute:zx :compute:zy
+  920 jump *label334 lessThan :compute:dist 64
+  921 jump *label55 always
+  922 label *label334
+  923 label *label335
+  924 label *label336
+  925 op add :compute:i :compute:i 1
+  926 label *label337
+  927 set :compute:x1 :compute:zx
+  928 op mul *tmp59 :compute:zx :compute:zx
+  929 op mul *tmp60 :compute:zy :compute:zy
+  930 op sub *tmp61 *tmp59 *tmp60
+  931 op add :compute:zx *tmp61 :compute:cx
+  932 op mul *tmp63 2 :compute:x1
+  933 op mul *tmp64 *tmp63 :compute:zy
+  934 op add :compute:zy *tmp64 :compute:cy
+  935 op len :compute:dist :compute:zx :compute:zy
+  936 jump *label338 lessThan :compute:dist 64
+  937 jump *label55 always
+  938 label *label338
+  939 label *label339
+  940 label *label340
+  941 op add :compute:i :compute:i 1
+  942 label *label341
+  943 set :compute:x1 :compute:zx
+  944 op mul *tmp59 :compute:zx :compute:zx
+  945 op mul *tmp60 :compute:zy :compute:zy
+  946 op sub *tmp61 *tmp59 *tmp60
+  947 op add :compute:zx *tmp61 :compute:cx
+  948 op mul *tmp63 2 :compute:x1
+  949 op mul *tmp64 *tmp63 :compute:zy
+  950 op add :compute:zy *tmp64 :compute:cy
+  951 op len :compute:dist :compute:zx :compute:zy
+  952 jump *label342 lessThan :compute:dist 64
+  953 jump *label55 always
+  954 label *label342
+  955 label *label343
+  956 label *label344
+  957 op add :compute:i :compute:i 1
+  958 label *label345
+  959 set :compute:x1 :compute:zx
+  960 op mul *tmp59 :compute:zx :compute:zx
+  961 op mul *tmp60 :compute:zy :compute:zy
+  962 op sub *tmp61 *tmp59 *tmp60
+  963 op add :compute:zx *tmp61 :compute:cx
+  964 op mul *tmp63 2 :compute:x1
+  965 op mul *tmp64 *tmp63 :compute:zy
+  966 op add :compute:zy *tmp64 :compute:cy
+  967 op len :compute:dist :compute:zx :compute:zy
+  968 jump *label346 lessThan :compute:dist 64
+  969 jump *label55 always
+  970 label *label346
+  971 label *label347
+  972 label *label348
+  973 op add :compute:i :compute:i 1
+  974 label *label349
+  975 set :compute:x1 :compute:zx
+  976 op mul *tmp59 :compute:zx :compute:zx
+  977 op mul *tmp60 :compute:zy :compute:zy
+  978 op sub *tmp61 *tmp59 *tmp60
+  979 op add :compute:zx *tmp61 :compute:cx
+  980 op mul *tmp63 2 :compute:x1
+  981 op mul *tmp64 *tmp63 :compute:zy
+  982 op add :compute:zy *tmp64 :compute:cy
+  983 op len :compute:dist :compute:zx :compute:zy
+  984 jump *label350 lessThan :compute:dist 64
+  985 jump *label55 always
+  986 label *label350
+  987 label *label351
+  988 label *label352
+  989 op add :compute:i :compute:i 1
+  990 label *label353
+  991 set :compute:x1 :compute:zx
+  992 op mul *tmp59 :compute:zx :compute:zx
+  993 op mul *tmp60 :compute:zy :compute:zy
+  994 op sub *tmp61 *tmp59 *tmp60
+  995 op add :compute:zx *tmp61 :compute:cx
+  996 op mul *tmp63 2 :compute:x1
+  997 op mul *tmp64 *tmp63 :compute:zy
+  998 op add :compute:zy *tmp64 :compute:cy
+  999 op len :compute:dist :compute:zx :compute:zy
+ 1000 jump *label354 lessThan :compute:dist 64
+ 1001 jump *label55 always
+ 1002 label *label354
+ 1003 label *label355
+ 1004 label *label356
+ 1005 op add :compute:i :compute:i 1
+ 1006 label *label357
+ 1007 set :compute:x1 :compute:zx
+ 1008 op mul *tmp59 :compute:zx :compute:zx
+ 1009 op mul *tmp60 :compute:zy :compute:zy
+ 1010 op sub *tmp61 *tmp59 *tmp60
+ 1011 op add :compute:zx *tmp61 :compute:cx
+ 1012 op mul *tmp63 2 :compute:x1
+ 1013 op mul *tmp64 *tmp63 :compute:zy
+ 1014 op add :compute:zy *tmp64 :compute:cy
+ 1015 op len :compute:dist :compute:zx :compute:zy
+ 1016 jump *label358 lessThan :compute:dist 64
+ 1017 jump *label55 always
+ 1018 label *label358
+ 1019 label *label359
+ 1020 label *label360
+ 1021 op add :compute:i :compute:i 1
+ 1022 label *label361
+ 1023 set :compute:x1 :compute:zx
+ 1024 op mul *tmp59 :compute:zx :compute:zx
+ 1025 op mul *tmp60 :compute:zy :compute:zy
+ 1026 op sub *tmp61 *tmp59 *tmp60
+ 1027 op add :compute:zx *tmp61 :compute:cx
+ 1028 op mul *tmp63 2 :compute:x1
+ 1029 op mul *tmp64 *tmp63 :compute:zy
+ 1030 op add :compute:zy *tmp64 :compute:cy
+ 1031 op len :compute:dist :compute:zx :compute:zy
+ 1032 jump *label362 lessThan :compute:dist 64
+ 1033 jump *label55 always
+ 1034 label *label362
+ 1035 label *label363
+ 1036 label *label364
+ 1037 op add :compute:i :compute:i 1
+ 1038 label *label365
+ 1039 set :compute:x1 :compute:zx
+ 1040 op mul *tmp59 :compute:zx :compute:zx
+ 1041 op mul *tmp60 :compute:zy :compute:zy
+ 1042 op sub *tmp61 *tmp59 *tmp60
+ 1043 op add :compute:zx *tmp61 :compute:cx
+ 1044 op mul *tmp63 2 :compute:x1
+ 1045 op mul *tmp64 *tmp63 :compute:zy
+ 1046 op add :compute:zy *tmp64 :compute:cy
+ 1047 op len :compute:dist :compute:zx :compute:zy
+ 1048 jump *label366 lessThan :compute:dist 64
+ 1049 jump *label55 always
+ 1050 label *label366
+ 1051 label *label367
+ 1052 label *label368
+ 1053 op add :compute:i :compute:i 1
+ 1054 label *label369
+ 1055 set :compute:x1 :compute:zx
+ 1056 op mul *tmp59 :compute:zx :compute:zx
+ 1057 op mul *tmp60 :compute:zy :compute:zy
+ 1058 op sub *tmp61 *tmp59 *tmp60
+ 1059 op add :compute:zx *tmp61 :compute:cx
+ 1060 op mul *tmp63 2 :compute:x1
+ 1061 op mul *tmp64 *tmp63 :compute:zy
+ 1062 op add :compute:zy *tmp64 :compute:cy
+ 1063 op len :compute:dist :compute:zx :compute:zy
+ 1064 jump *label370 lessThan :compute:dist 64
+ 1065 jump *label55 always
+ 1066 label *label370
+ 1067 label *label371
+ 1068 label *label372
+ 1069 op add :compute:i :compute:i 1
+ 1070 label *label373
+ 1071 set :compute:x1 :compute:zx
+ 1072 op mul *tmp59 :compute:zx :compute:zx
+ 1073 op mul *tmp60 :compute:zy :compute:zy
+ 1074 op sub *tmp61 *tmp59 *tmp60
+ 1075 op add :compute:zx *tmp61 :compute:cx
+ 1076 op mul *tmp63 2 :compute:x1
+ 1077 op mul *tmp64 *tmp63 :compute:zy
+ 1078 op add :compute:zy *tmp64 :compute:cy
+ 1079 op len :compute:dist :compute:zx :compute:zy
+ 1080 jump *label374 lessThan :compute:dist 64
+ 1081 jump *label55 always
+ 1082 label *label374
+ 1083 label *label375
+ 1084 label *label376
+ 1085 op add :compute:i :compute:i 1
+ 1086 label *label377
+ 1087 set :compute:x1 :compute:zx
+ 1088 op mul *tmp59 :compute:zx :compute:zx
+ 1089 op mul *tmp60 :compute:zy :compute:zy
+ 1090 op sub *tmp61 *tmp59 *tmp60
+ 1091 op add :compute:zx *tmp61 :compute:cx
+ 1092 op mul *tmp63 2 :compute:x1
+ 1093 op mul *tmp64 *tmp63 :compute:zy
+ 1094 op add :compute:zy *tmp64 :compute:cy
+ 1095 op len :compute:dist :compute:zx :compute:zy
+ 1096 jump *label378 lessThan :compute:dist 64
+ 1097 jump *label55 always
+ 1098 label *label378
+ 1099 label *label379
+ 1100 label *label380
+ 1101 op add :compute:i :compute:i 1
+ 1102 label *label381
+ 1103 set :compute:x1 :compute:zx
+ 1104 op mul *tmp59 :compute:zx :compute:zx
+ 1105 op mul *tmp60 :compute:zy :compute:zy
+ 1106 op sub *tmp61 *tmp59 *tmp60
+ 1107 op add :compute:zx *tmp61 :compute:cx
+ 1108 op mul *tmp63 2 :compute:x1
+ 1109 op mul *tmp64 *tmp63 :compute:zy
+ 1110 op add :compute:zy *tmp64 :compute:cy
+ 1111 op len :compute:dist :compute:zx :compute:zy
+ 1112 jump *label382 lessThan :compute:dist 64
+ 1113 jump *label55 always
+ 1114 label *label382
+ 1115 label *label383
+ 1116 label *label384
+ 1117 op add :compute:i :compute:i 1
+ 1118 label *label385
+ 1119 set :compute:x1 :compute:zx
+ 1120 op mul *tmp59 :compute:zx :compute:zx
+ 1121 op mul *tmp60 :compute:zy :compute:zy
+ 1122 op sub *tmp61 *tmp59 *tmp60
+ 1123 op add :compute:zx *tmp61 :compute:cx
+ 1124 op mul *tmp63 2 :compute:x1
+ 1125 op mul *tmp64 *tmp63 :compute:zy
+ 1126 op add :compute:zy *tmp64 :compute:cy
+ 1127 op len :compute:dist :compute:zx :compute:zy
+ 1128 jump *label386 lessThan :compute:dist 64
+ 1129 jump *label55 always
+ 1130 label *label386
+ 1131 label *label387
+ 1132 label *label388
+ 1133 op add :compute:i :compute:i 1
+ 1134 label *label389
+ 1135 set :compute:x1 :compute:zx
+ 1136 op mul *tmp59 :compute:zx :compute:zx
+ 1137 op mul *tmp60 :compute:zy :compute:zy
+ 1138 op sub *tmp61 *tmp59 *tmp60
+ 1139 op add :compute:zx *tmp61 :compute:cx
+ 1140 op mul *tmp63 2 :compute:x1
+ 1141 op mul *tmp64 *tmp63 :compute:zy
+ 1142 op add :compute:zy *tmp64 :compute:cy
+ 1143 op len :compute:dist :compute:zx :compute:zy
+ 1144 jump *label390 lessThan :compute:dist 64
+ 1145 jump *label55 always
+ 1146 label *label390
+ 1147 label *label391
+ 1148 label *label392
+ 1149 op add :compute:i :compute:i 1
+ 1150 label *label393
+ 1151 set :compute:x1 :compute:zx
+ 1152 op mul *tmp59 :compute:zx :compute:zx
+ 1153 op mul *tmp60 :compute:zy :compute:zy
+ 1154 op sub *tmp61 *tmp59 *tmp60
+ 1155 op add :compute:zx *tmp61 :compute:cx
+ 1156 op mul *tmp63 2 :compute:x1
+ 1157 op mul *tmp64 *tmp63 :compute:zy
+ 1158 op add :compute:zy *tmp64 :compute:cy
+ 1159 op len :compute:dist :compute:zx :compute:zy
+ 1160 jump *label394 lessThan :compute:dist 64
+ 1161 jump *label55 always
+ 1162 label *label394
+ 1163 label *label395
+ 1164 label *label396
+ 1165 op add :compute:i :compute:i 1
+ 1166 label *label55
  1167 op mul *tmp69 .SMOOTH 63
  1168 jump *label58 greaterThanEq :compute:i *tmp69
  1169 op log *tmp72 :compute:dist

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   170 label *label146
   171 label *label147
   172 label *label148
-    * op add :compute:i :compute:i 1
+  173 op add :compute:i 0 1
   174 label *label149
   175 set :compute:x1 :compute:zx
   176 op mul *tmp59 :compute:zx :compute:zx
 
   186 label *label150
   187 label *label151
   188 label *label152
-    * op add :compute:i :compute:i 1
+  189 op add :compute:i 1 1
   190 label *label153
   191 set :compute:x1 :compute:zx
   192 op mul *tmp59 :compute:zx :compute:zx
 
   202 label *label154
   203 label *label155
   204 label *label156
-    * op add :compute:i :compute:i 1
+  205 op add :compute:i 2 1
   206 label *label157
   207 set :compute:x1 :compute:zx
   208 op mul *tmp59 :compute:zx :compute:zx
 
   218 label *label158
   219 label *label159
   220 label *label160
-    * op add :compute:i :compute:i 1
+  221 op add :compute:i 3 1
   222 label *label161
   223 set :compute:x1 :compute:zx
   224 op mul *tmp59 :compute:zx :compute:zx
 
   234 label *label162
   235 label *label163
   236 label *label164
-    * op add :compute:i :compute:i 1
+  237 op add :compute:i 4 1
   238 label *label165
   239 set :compute:x1 :compute:zx
   240 op mul *tmp59 :compute:zx :compute:zx
 
   250 label *label166
   251 label *label167
   252 label *label168
-    * op add :compute:i :compute:i 1
+  253 op add :compute:i 5 1
   254 label *label169
   255 set :compute:x1 :compute:zx
   256 op mul *tmp59 :compute:zx :compute:zx
 
   266 label *label170
   267 label *label171
   268 label *label172
-    * op add :compute:i :compute:i 1
+  269 op add :compute:i 6 1
   270 label *label173
   271 set :compute:x1 :compute:zx
   272 op mul *tmp59 :compute:zx :compute:zx
 
   282 label *label174
   283 label *label175
   284 label *label176
-    * op add :compute:i :compute:i 1
+  285 op add :compute:i 7 1
   286 label *label177
   287 set :compute:x1 :compute:zx
   288 op mul *tmp59 :compute:zx :compute:zx
 
   298 label *label178
   299 label *label179
   300 label *label180
-    * op add :compute:i :compute:i 1
+  301 op add :compute:i 8 1
   302 label *label181
   303 set :compute:x1 :compute:zx
   304 op mul *tmp59 :compute:zx :compute:zx
 
   314 label *label182
   315 label *label183
   316 label *label184
-    * op add :compute:i :compute:i 1
+  317 op add :compute:i 9 1
   318 label *label185
   319 set :compute:x1 :compute:zx
   320 op mul *tmp59 :compute:zx :compute:zx
 
   330 label *label186
   331 label *label187
   332 label *label188
-    * op add :compute:i :compute:i 1
+  333 op add :compute:i 10 1
   334 label *label189
   335 set :compute:x1 :compute:zx
   336 op mul *tmp59 :compute:zx :compute:zx
 
   346 label *label190
   347 label *label191
   348 label *label192
-    * op add :compute:i :compute:i 1
+  349 op add :compute:i 11 1
   350 label *label193
   351 set :compute:x1 :compute:zx
   352 op mul *tmp59 :compute:zx :compute:zx
 
   362 label *label194
   363 label *label195
   364 label *label196
-    * op add :compute:i :compute:i 1
+  365 op add :compute:i 12 1
   366 label *label197
   367 set :compute:x1 :compute:zx
   368 op mul *tmp59 :compute:zx :compute:zx
 
   378 label *label198
   379 label *label199
   380 label *label200
-    * op add :compute:i :compute:i 1
+  381 op add :compute:i 13 1
   382 label *label201
   383 set :compute:x1 :compute:zx
   384 op mul *tmp59 :compute:zx :compute:zx
 
   394 label *label202
   395 label *label203
   396 label *label204
-    * op add :compute:i :compute:i 1
+  397 op add :compute:i 14 1
   398 label *label205
   399 set :compute:x1 :compute:zx
   400 op mul *tmp59 :compute:zx :compute:zx
 
   410 label *label206
   411 label *label207
   412 label *label208
-    * op add :compute:i :compute:i 1
+  413 op add :compute:i 15 1
   414 label *label209
   415 set :compute:x1 :compute:zx
   416 op mul *tmp59 :compute:zx :compute:zx
 
   426 label *label210
   427 label *label211
   428 label *label212
-    * op add :compute:i :compute:i 1
+  429 op add :compute:i 16 1
   430 label *label213
   431 set :compute:x1 :compute:zx
   432 op mul *tmp59 :compute:zx :compute:zx
 
   442 label *label214
   443 label *label215
   444 label *label216
-    * op add :compute:i :compute:i 1
+  445 op add :compute:i 17 1
   446 label *label217
   447 set :compute:x1 :compute:zx
   448 op mul *tmp59 :compute:zx :compute:zx
 
   458 label *label218
   459 label *label219
   460 label *label220
-    * op add :compute:i :compute:i 1
+  461 op add :compute:i 18 1
   462 label *label221
   463 set :compute:x1 :compute:zx
   464 op mul *tmp59 :compute:zx :compute:zx
 
   474 label *label222
   475 label *label223
   476 label *label224
-    * op add :compute:i :compute:i 1
+  477 op add :compute:i 19 1
   478 label *label225
   479 set :compute:x1 :compute:zx
   480 op mul *tmp59 :compute:zx :compute:zx
 
   490 label *label226
   491 label *label227
   492 label *label228
-    * op add :compute:i :compute:i 1
+  493 op add :compute:i 20 1
   494 label *label229
   495 set :compute:x1 :compute:zx
   496 op mul *tmp59 :compute:zx :compute:zx
 
   506 label *label230
   507 label *label231
   508 label *label232
-    * op add :compute:i :compute:i 1
+  509 op add :compute:i 21 1
   510 label *label233
   511 set :compute:x1 :compute:zx
   512 op mul *tmp59 :compute:zx :compute:zx
 
   522 label *label234
   523 label *label235
   524 label *label236
-    * op add :compute:i :compute:i 1
+  525 op add :compute:i 22 1
   526 label *label237
   527 set :compute:x1 :compute:zx
   528 op mul *tmp59 :compute:zx :compute:zx
 
   538 label *label238
   539 label *label239
   540 label *label240
-    * op add :compute:i :compute:i 1
+  541 op add :compute:i 23 1
   542 label *label241
   543 set :compute:x1 :compute:zx
   544 op mul *tmp59 :compute:zx :compute:zx
 
   554 label *label242
   555 label *label243
   556 label *label244
-    * op add :compute:i :compute:i 1
+  557 op add :compute:i 24 1
   558 label *label245
   559 set :compute:x1 :compute:zx
   560 op mul *tmp59 :compute:zx :compute:zx
 
   570 label *label246
   571 label *label247
   572 label *label248
-    * op add :compute:i :compute:i 1
+  573 op add :compute:i 25 1
   574 label *label249
   575 set :compute:x1 :compute:zx
   576 op mul *tmp59 :compute:zx :compute:zx
 
   586 label *label250
   587 label *label251
   588 label *label252
-    * op add :compute:i :compute:i 1
+  589 op add :compute:i 26 1
   590 label *label253
   591 set :compute:x1 :compute:zx
   592 op mul *tmp59 :compute:zx :compute:zx
 
   602 label *label254
   603 label *label255
   604 label *label256
-    * op add :compute:i :compute:i 1
+  605 op add :compute:i 27 1
   606 label *label257
   607 set :compute:x1 :compute:zx
   608 op mul *tmp59 :compute:zx :compute:zx
 
   618 label *label258
   619 label *label259
   620 label *label260
-    * op add :compute:i :compute:i 1
+  621 op add :compute:i 28 1
   622 label *label261
   623 set :compute:x1 :compute:zx
   624 op mul *tmp59 :compute:zx :compute:zx
 
   634 label *label262
   635 label *label263
   636 label *label264
-    * op add :compute:i :compute:i 1
+  637 op add :compute:i 29 1
   638 label *label265
   639 set :compute:x1 :compute:zx
   640 op mul *tmp59 :compute:zx :compute:zx
 
   650 label *label266
   651 label *label267
   652 label *label268
-    * op add :compute:i :compute:i 1
+  653 op add :compute:i 30 1
   654 label *label269
   655 set :compute:x1 :compute:zx
   656 op mul *tmp59 :compute:zx :compute:zx
 
   666 label *label270
   667 label *label271
   668 label *label272
-    * op add :compute:i :compute:i 1
+  669 op add :compute:i 31 1
   670 label *label273
   671 set :compute:x1 :compute:zx
   672 op mul *tmp59 :compute:zx :compute:zx
 
   682 label *label274
   683 label *label275
   684 label *label276
-    * op add :compute:i :compute:i 1
+  685 op add :compute:i 32 1
   686 label *label277
   687 set :compute:x1 :compute:zx
   688 op mul *tmp59 :compute:zx :compute:zx
 
   698 label *label278
   699 label *label279
   700 label *label280
-    * op add :compute:i :compute:i 1
+  701 op add :compute:i 33 1
   702 label *label281
   703 set :compute:x1 :compute:zx
   704 op mul *tmp59 :compute:zx :compute:zx
 
   714 label *label282
   715 label *label283
   716 label *label284
-    * op add :compute:i :compute:i 1
+  717 op add :compute:i 34 1
   718 label *label285
   719 set :compute:x1 :compute:zx
   720 op mul *tmp59 :compute:zx :compute:zx
 
   730 label *label286
   731 label *label287
   732 label *label288
-    * op add :compute:i :compute:i 1
+  733 op add :compute:i 35 1
   734 label *label289
   735 set :compute:x1 :compute:zx
   736 op mul *tmp59 :compute:zx :compute:zx
 
   746 label *label290
   747 label *label291
   748 label *label292
-    * op add :compute:i :compute:i 1
+  749 op add :compute:i 36 1
   750 label *label293
   751 set :compute:x1 :compute:zx
   752 op mul *tmp59 :compute:zx :compute:zx
 
   762 label *label294
   763 label *label295
   764 label *label296
-    * op add :compute:i :compute:i 1
+  765 op add :compute:i 37 1
   766 label *label297
   767 set :compute:x1 :compute:zx
   768 op mul *tmp59 :compute:zx :compute:zx
 
   778 label *label298
   779 label *label299
   780 label *label300
-    * op add :compute:i :compute:i 1
+  781 op add :compute:i 38 1
   782 label *label301
   783 set :compute:x1 :compute:zx
   784 op mul *tmp59 :compute:zx :compute:zx
 
   794 label *label302
   795 label *label303
   796 label *label304
-    * op add :compute:i :compute:i 1
+  797 op add :compute:i 39 1
   798 label *label305
   799 set :compute:x1 :compute:zx
   800 op mul *tmp59 :compute:zx :compute:zx
 
   810 label *label306
   811 label *label307
   812 label *label308
-    * op add :compute:i :compute:i 1
+  813 op add :compute:i 40 1
   814 label *label309
   815 set :compute:x1 :compute:zx
   816 op mul *tmp59 :compute:zx :compute:zx
 
   826 label *label310
   827 label *label311
   828 label *label312
-    * op add :compute:i :compute:i 1
+  829 op add :compute:i 41 1
   830 label *label313
   831 set :compute:x1 :compute:zx
   832 op mul *tmp59 :compute:zx :compute:zx
 
   842 label *label314
   843 label *label315
   844 label *label316
-    * op add :compute:i :compute:i 1
+  845 op add :compute:i 42 1
   846 label *label317
   847 set :compute:x1 :compute:zx
   848 op mul *tmp59 :compute:zx :compute:zx
 
   858 label *label318
   859 label *label319
   860 label *label320
-    * op add :compute:i :compute:i 1
+  861 op add :compute:i 43 1
   862 label *label321
   863 set :compute:x1 :compute:zx
   864 op mul *tmp59 :compute:zx :compute:zx
 
   874 label *label322
   875 label *label323
   876 label *label324
-    * op add :compute:i :compute:i 1
+  877 op add :compute:i 44 1
   878 label *label325
   879 set :compute:x1 :compute:zx
   880 op mul *tmp59 :compute:zx :compute:zx
 
   890 label *label326
   891 label *label327
   892 label *label328
-    * op add :compute:i :compute:i 1
+  893 op add :compute:i 45 1
   894 label *label329
   895 set :compute:x1 :compute:zx
   896 op mul *tmp59 :compute:zx :compute:zx
 
   906 label *label330
   907 label *label331
   908 label *label332
-    * op add :compute:i :compute:i 1
+  909 op add :compute:i 46 1
   910 label *label333
   911 set :compute:x1 :compute:zx
   912 op mul *tmp59 :compute:zx :compute:zx
 
   922 label *label334
   923 label *label335
   924 label *label336
-    * op add :compute:i :compute:i 1
+  925 op add :compute:i 47 1
   926 label *label337
   927 set :compute:x1 :compute:zx
   928 op mul *tmp59 :compute:zx :compute:zx
 
   938 label *label338
   939 label *label339
   940 label *label340
-    * op add :compute:i :compute:i 1
+  941 op add :compute:i 48 1
   942 label *label341
   943 set :compute:x1 :compute:zx
   944 op mul *tmp59 :compute:zx :compute:zx
 
   954 label *label342
   955 label *label343
   956 label *label344
-    * op add :compute:i :compute:i 1
+  957 op add :compute:i 49 1
   958 label *label345
   959 set :compute:x1 :compute:zx
   960 op mul *tmp59 :compute:zx :compute:zx
 
   970 label *label346
   971 label *label347
   972 label *label348
-    * op add :compute:i :compute:i 1
+  973 op add :compute:i 50 1
   974 label *label349
   975 set :compute:x1 :compute:zx
   976 op mul *tmp59 :compute:zx :compute:zx
 
   986 label *label350
   987 label *label351
   988 label *label352
-    * op add :compute:i :compute:i 1
+  989 op add :compute:i 51 1
   990 label *label353
   991 set :compute:x1 :compute:zx
   992 op mul *tmp59 :compute:zx :compute:zx
 
  1002 label *label354
  1003 label *label355
  1004 label *label356
-    * op add :compute:i :compute:i 1
+ 1005 op add :compute:i 52 1
  1006 label *label357
  1007 set :compute:x1 :compute:zx
  1008 op mul *tmp59 :compute:zx :compute:zx
 
  1018 label *label358
  1019 label *label359
  1020 label *label360
-    * op add :compute:i :compute:i 1
+ 1021 op add :compute:i 53 1
  1022 label *label361
  1023 set :compute:x1 :compute:zx
  1024 op mul *tmp59 :compute:zx :compute:zx
 
  1034 label *label362
  1035 label *label363
  1036 label *label364
-    * op add :compute:i :compute:i 1
+ 1037 op add :compute:i 54 1
  1038 label *label365
  1039 set :compute:x1 :compute:zx
  1040 op mul *tmp59 :compute:zx :compute:zx
 
  1050 label *label366
  1051 label *label367
  1052 label *label368
-    * op add :compute:i :compute:i 1
+ 1053 op add :compute:i 55 1
  1054 label *label369
  1055 set :compute:x1 :compute:zx
  1056 op mul *tmp59 :compute:zx :compute:zx
 
  1066 label *label370
  1067 label *label371
  1068 label *label372
-    * op add :compute:i :compute:i 1
+ 1069 op add :compute:i 56 1
  1070 label *label373
  1071 set :compute:x1 :compute:zx
  1072 op mul *tmp59 :compute:zx :compute:zx
 
  1082 label *label374
  1083 label *label375
  1084 label *label376
-    * op add :compute:i :compute:i 1
+ 1085 op add :compute:i 57 1
  1086 label *label377
  1087 set :compute:x1 :compute:zx
  1088 op mul *tmp59 :compute:zx :compute:zx
 
  1098 label *label378
  1099 label *label379
  1100 label *label380
-    * op add :compute:i :compute:i 1
+ 1101 op add :compute:i 58 1
  1102 label *label381
  1103 set :compute:x1 :compute:zx
  1104 op mul *tmp59 :compute:zx :compute:zx
 
  1114 label *label382
  1115 label *label383
  1116 label *label384
-    * op add :compute:i :compute:i 1
+ 1117 op add :compute:i 59 1
  1118 label *label385
  1119 set :compute:x1 :compute:zx
  1120 op mul *tmp59 :compute:zx :compute:zx
 
  1130 label *label386
  1131 label *label387
  1132 label *label388
-    * op add :compute:i :compute:i 1
+ 1133 op add :compute:i 60 1
  1134 label *label389
  1135 set :compute:x1 :compute:zx
  1136 op mul *tmp59 :compute:zx :compute:zx
 
  1146 label *label390
  1147 label *label391
  1148 label *label392
-    * op add :compute:i :compute:i 1
+ 1149 op add :compute:i 61 1
  1150 label *label393
  1151 set :compute:x1 :compute:zx
  1152 op mul *tmp59 :compute:zx :compute:zx
 
  1162 label *label394
  1163 label *label395
  1164 label *label396
-    * op add :compute:i :compute:i 1
+ 1165 op add :compute:i 62 1
  1166 label *label55
  1167 op mul *tmp69 .SMOOTH 63
  1168 jump *label58 greaterThanEq :compute:i *tmp69

Modifications by Inline function 'flushLocalBuffer' defined at mandelbrot-compute.mnd:207:1:
 
  1226 read :drawPixel:color .memory *tmp41
  1227 label *label62
  1228 jump *label72 lessThan .localBuffer 250
-    * setaddr :flushLocalBuffer*retaddr *label74 (h:*label74)
-    * call *label0 *invalid :flushLocalBuffer*retval (m:*label74) (h:*label74)
-    * label *label74
+ 1229 label *label397
+ 1230 jump *label401 lessThanEq .localBuffer 4
+ 1231 label *label398
+ 1232 wait 0.0001
+ 1233 label *label399
+ 1234 sensor *tmp140 .display @bufferUsage
+ 1235 jump *label398 greaterThan *tmp140 250
+ 1236 label *label400
+ 1237 label *label401
+ 1238 label *label402
+ 1239 drawflush .display
+ 1240 set .localBuffer 0
+ 1241 label *label403
  1242 label *label72
  1243 label *label73
  1244 draw col :drawPixel:color
 
  1281 op add :lines :lines 1
  1282 jump *label101 lessThan :lines 176
  1283 label *label40
-    * setaddr :flushLocalBuffer*retaddr *label85 (h:*label85)
-    * call *label0 *invalid :flushLocalBuffer*retval (m:*label85) (h:*label85)
-    * label *label85
+ 1284 label *label404
+ 1285 jump *label408 lessThanEq .localBuffer 4
+ 1286 label *label405
+ 1287 wait 0.0001
+ 1288 label *label406
+ 1289 sensor *tmp140 .display @bufferUsage
+ 1290 jump *label405 greaterThan *tmp140 250
+ 1291 label *label407
+ 1292 label *label408
+ 1293 label *label409
+ 1294 drawflush .display
+ 1295 set .localBuffer 0
+ 1296 label *label410
  1297 label *label31
  1298 jump *label30 always
  1299 label *label32
  1300 end
-    * label *label0
-    * jump *label87 lessThanEq .localBuffer 4
-    * label *label89
-    * wait 0.0001
-    * label *label90
-    * sensor *tmp140 .display @bufferUsage
-    * jump *label89 greaterThan *tmp140 250
-    * label *label91
-    * label *label87
-    * label *label88
-    * drawflush .display
-    * set .localBuffer 0
-    * label *label86
-    * return :flushLocalBuffer*retaddr
-    * end
  1301 label *label1
  1302 label *label93
  1303 jump *label95 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Inline function 'setState' defined at mandelbrot-compute.mnd:217:1 (+9 instructions):
 
    79 label *label2
    80 label *label30
    81 set :setState:state 0
-    * setaddr :setState*retaddr *label36 (h:*label36)
    82 label *label33
-    * call *label1 *invalid :setState*retval (m:*label36) (h:*label36)
-    * label *label36
+   83 label *label411
+   84 label *label412
+   85 jump *label419 greaterThanEq .PROC_STATE_INDEX 512
+   86 label *label413
+   87 read *tmp144 .memory .PROC_ID_INDEX
+   88 jump *label414 notEqual *tmp144 .PROCESSOR_ID
+   89 write :setState:state .memory .PROC_STATE_INDEX
+   90 jump *label419 always
+   91 jump *label417 always
+   92 label *label414
+   93 read *tmp150 .memory .PROC_ID_INDEX
+   94 jump *label415 notEqual *tmp150 0
+   95 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+   96 write :setState:state .memory .PROC_STATE_INDEX
+   97 jump *label419 always
+   98 jump *label416 always
+   99 label *label415
+  100 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  101 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  102 label *label416
+  103 label *label417
+  104 label *label418
+  105 jump *label413 lessThan .PROC_STATE_INDEX 512
+  106 label *label419
+  107 label *label420
   108 label *label34
   109 read *tmp0 .memory 64
   110 jump *label33 equal .start *tmp0
 
   114 read *tmp1 .memory 65
   115 set .stop *tmp1
   116 set :setState:state *tmp0
-    * setaddr :setState*retaddr *label37 (h:*label37)
-    * call *label1 *invalid :setState*retval (m:*label37) (h:*label37)
-    * label *label37
+  117 label *label421
+  118 label *label422
+  119 jump *label429 greaterThanEq .PROC_STATE_INDEX 512
+  120 label *label423
+  121 read *tmp144 .memory .PROC_ID_INDEX
+  122 jump *label424 notEqual *tmp144 .PROCESSOR_ID
+  123 write :setState:state .memory .PROC_STATE_INDEX
+  124 jump *label429 always
+  125 jump *label427 always
+  126 label *label424
+  127 read *tmp150 .memory .PROC_ID_INDEX
+  128 jump *label425 notEqual *tmp150 0
+  129 write .PROCESSOR_ID .memory .PROC_ID_INDEX
+  130 write :setState:state .memory .PROC_STATE_INDEX
+  131 jump *label429 always
+  132 jump *label426 always
+  133 label *label425
+  134 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
+  135 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
+  136 label *label426
+  137 label *label427
+  138 label *label428
+  139 jump *label423 lessThan .PROC_STATE_INDEX 512
+  140 label *label429
+  141 label *label430
   142 read .ZOOM .memory 68
   143 op div *tmp26 -88 .ZOOM
   144 read *tmp2 .memory 66
 
  1342 jump *label30 always
  1343 label *label32
  1344 end
-    * label *label1
-    * label *label93
-    * jump *label95 greaterThanEq .PROC_STATE_INDEX 512
-    * label *label104
-    * read *tmp144 .memory .PROC_ID_INDEX
-    * jump *label96 notEqual *tmp144 .PROCESSOR_ID
-    * write :setState:state .memory .PROC_STATE_INDEX
-    * jump *label95 always
-    * jump *label97 always
-    * label *label96
-    * read *tmp150 .memory .PROC_ID_INDEX
-    * jump *label98 notEqual *tmp150 0
-    * write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState:state .memory .PROC_STATE_INDEX
-    * jump *label95 always
-    * jump *label99 always
-    * label *label98
-    * op add .PROC_ID_INDEX .PROC_ID_INDEX 2
-    * op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label99
-    * label *label97
-    * label *label94
-    * jump *label104 lessThan .PROC_STATE_INDEX 512
-    * label *label95
-    * label *label92
-    * return :setState*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    86 label *label413
    87 read *tmp144 .memory .PROC_ID_INDEX
    88 jump *label414 notEqual *tmp144 .PROCESSOR_ID
-    * write :setState:state .memory .PROC_STATE_INDEX
+   89 write 0 .memory .PROC_STATE_INDEX
    90 jump *label419 always
    91 jump *label417 always
    92 label *label414
    93 read *tmp150 .memory .PROC_ID_INDEX
    94 jump *label415 notEqual *tmp150 0
    95 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState:state .memory .PROC_STATE_INDEX
+   96 write 0 .memory .PROC_STATE_INDEX
    97 jump *label419 always
    98 jump *label416 always
    99 label *label415
 
   120 label *label423
   121 read *tmp144 .memory .PROC_ID_INDEX
   122 jump *label424 notEqual *tmp144 .PROCESSOR_ID
-    * write :setState:state .memory .PROC_STATE_INDEX
+  123 write *tmp0 .memory .PROC_STATE_INDEX
   124 jump *label429 always
   125 jump *label427 always
   126 label *label424
   127 read *tmp150 .memory .PROC_ID_INDEX
   128 jump *label425 notEqual *tmp150 0
   129 write .PROCESSOR_ID .memory .PROC_ID_INDEX
-    * write :setState:state .memory .PROC_STATE_INDEX
+  130 write *tmp0 .memory .PROC_STATE_INDEX
   131 jump *label429 always
   132 jump *label426 always
   133 label *label425

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    78 label *label5
    79 label *label2
    80 label *label30
-    * set :setState:state 0
    81 label *label33
    82 label *label411
    83 label *label412
 
   112 set .start *tmp0
   113 read *tmp1 .memory 65
   114 set .stop *tmp1
-    * set :setState:state *tmp0
   115 label *label421
   116 label *label422
   117 jump *label429 greaterThanEq .PROC_STATE_INDEX 512

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    25 label *label114
    26 jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
    27 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label115 notEqual @large-logic-display @message
+   28 jump *label115 always
    29 label *label115
    30 label *label116
    31 label *label117
 
    36 label *label122
    37 jump *label125 notEqual @memory-bank :findLinkedBlocks:type
    38 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label123 notEqual @memory-bank @message
+   39 jump *label123 always
    40 label *label123
    41 label *label124
    42 label *label125
 
    53 print ":"
    54 print " "
    55 print .display
-    * jump *label132 equal true false
    56 op and :findLinkedBlocks:foundAll 1 .display
    57 label *label132
    58 label *label133
 
    64 print ":"
    65 print " "
    66 print .memory
-    * jump *label138 equal true false
    67 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    68 label *label138
    69 label *label139

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
    25 label *label114
    26 jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
    27 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label115 always
    28 label *label115
    29 label *label116
    30 label *label117
 
    35 label *label122
    36 jump *label125 notEqual @memory-bank :findLinkedBlocks:type
    37 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * jump *label123 always
    38 label *label123
    39 label *label124
    40 label *label125
 
  1213 label *label58
  1214 label *label59
  1215 set *tmp41 :compute:i
-    * jump *label46 always
  1216 label *label46
  1217 jump *label61 equal .SMOOTH false
  1218 set :drawPixel:color %[black]

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-2 instructions):
 
    55 label *label132
    56 label *label133
    57 label *label134
-    * set .display .display
    58 label *label137
    59 print "\n"
    60 print "Memory"
 
    65 label *label138
    66 label *label139
    67 label *label140
-    * set .memory .memory
    68 label *label25
    69 printflush null
    70 label *label4
 
   206 label *label146
   207 label *label147
   208 label *label148
-    * op add :compute:i 0 1
+  209 set :compute:i 1
   210 label *label149
   211 set :compute:x1 :compute:zx
   212 op mul *tmp59 :compute:zx :compute:zx

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     4 set .start 0
     5 set .localBuffer 0
     6 label *label3
-    * label *label105
-    * label *label106
     7 set .display null
-    * label *label109
-    * label *label110
     8 set .memory null
-    * label *label8
     9 print "Mandelbrot Generator"
    10 set :findLinkedBlocks:n @links
-    * label *label11
    11 jump *label13 lessThanEq :findLinkedBlocks:n 0
    12 label *label100
    13 op sub :findLinkedBlocks:n :findLinkedBlocks:n 1
 
    16 print :findLinkedBlocks:block
    17 sensor :findLinkedBlocks:type :findLinkedBlocks:block @type
    18 set :findLinkedBlocks:variable .display
-    * label *label114
    19 jump *label117 notEqual @large-logic-display :findLinkedBlocks:type
    20 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label115
-    * label *label116
    21 label *label117
-    * label *label118
-    * label *label119
    22 set .display :findLinkedBlocks:variable
    23 set :findLinkedBlocks:variable .memory
-    * label *label122
    24 jump *label125 notEqual @memory-bank :findLinkedBlocks:type
    25 set :findLinkedBlocks:variable :findLinkedBlocks:block
-    * label *label123
-    * label *label124
    26 label *label125
-    * label *label126
-    * label *label127
    27 set .memory :findLinkedBlocks:variable
-    * label *label16
-    * label *label12
    28 jump *label100 greaterThan :findLinkedBlocks:n 0
    29 label *label13
-    * label *label131
    30 print "\n"
    31 print "Display"
    32 print ":"
    33 print " "
    34 print .display
    35 op and :findLinkedBlocks:foundAll 1 .display
-    * label *label132
-    * label *label133
-    * label *label134
-    * label *label137
    36 print "\n"
    37 print "Memory"
    38 print ":"
    39 print " "
    40 print .memory
    41 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
-    * label *label138
-    * label *label139
-    * label *label140
-    * label *label25
    42 printflush null
-    * label *label4
    43 jump *label3 equal :findLinkedBlocks:foundAll false
-    * label *label5
-    * label *label2
    44 label *label30
    45 label *label33
-    * label *label411
-    * label *label412
    46 jump *label419 greaterThanEq .PROC_STATE_INDEX 512
    47 label *label413
    48 read *tmp144 .memory .PROC_ID_INDEX
 
    62 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
    63 label *label416
    64 label *label417
-    * label *label418
    65 jump *label413 lessThan .PROC_STATE_INDEX 512
    66 label *label419
-    * label *label420
-    * label *label34
    67 read *tmp0 .memory 64
    68 jump *label33 equal .start *tmp0
-    * label *label35
    69 read *tmp0 .memory 64
    70 set .start *tmp0
    71 read *tmp1 .memory 65
    72 set .stop *tmp1
-    * label *label421
-    * label *label422
    73 jump *label429 greaterThanEq .PROC_STATE_INDEX 512
    74 label *label423
    75 read *tmp144 .memory .PROC_ID_INDEX
 
    89 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
    90 label *label426
    91 label *label427
-    * label *label428
    92 jump *label423 lessThan .PROC_STATE_INDEX 512
    93 label *label429
-    * label *label430
    94 read .ZOOM .memory 68
    95 op div *tmp26 -88 .ZOOM
    96 read *tmp2 .memory 66
 
   108 op rand *tmp31 0.1
   109 wait *tmp31
   110 set :lines 0
-    * label *label38
   111 label *label101
   112 op mul *tmp32 17 :line
   113 op mod :x *tmp32 176
 
   116 jump *label41 notEqual *tmp36 0
   117 write .PROCESSOR_ID .memory :position
   118 set :y 0
-    * label *label43
   119 label *label102
   120 op div *tmp42 :x .ZOOM
   121 op add :compute:zx *tmp42 .OFFSET_X
 
   138 set *tmp41 63
   139 jump *label46 always
   140 label *label49
-    * label *label50
   141 op add *tmp55 :compute:zx 1
   142 op len *tmp56 *tmp55 :compute:zy
   143 jump *label51 greaterThan *tmp56 0.25
   144 set *tmp41 63
   145 jump *label46 always
   146 label *label51
-    * label *label52
   147 label *label48
   148 set :compute:i 0
-    * label *label144
-    * label *label145
   149 set :compute:x1 :compute:zx
   150 op mul *tmp59 :compute:zx :compute:zx
   151 op mul *tmp60 :compute:zy :compute:zy
 
   158 jump *label146 lessThan :compute:dist 64
   159 jump *label55 always
   160 label *label146
-    * label *label147
-    * label *label148
   161 set :compute:i 1
-    * label *label149
   162 set :compute:x1 :compute:zx
   163 op mul *tmp59 :compute:zx :compute:zx
   164 op mul *tmp60 :compute:zy :compute:zy
 
   171 jump *label150 lessThan :compute:dist 64
   172 jump *label55 always
   173 label *label150
-    * label *label151
-    * label *label152
   174 op add :compute:i 1 1
-    * label *label153
   175 set :compute:x1 :compute:zx
   176 op mul *tmp59 :compute:zx :compute:zx
   177 op mul *tmp60 :compute:zy :compute:zy
 
   184 jump *label154 lessThan :compute:dist 64
   185 jump *label55 always
   186 label *label154
-    * label *label155
-    * label *label156
   187 op add :compute:i 2 1
-    * label *label157
   188 set :compute:x1 :compute:zx
   189 op mul *tmp59 :compute:zx :compute:zx
   190 op mul *tmp60 :compute:zy :compute:zy
 
   197 jump *label158 lessThan :compute:dist 64
   198 jump *label55 always
   199 label *label158
-    * label *label159
-    * label *label160
   200 op add :compute:i 3 1
-    * label *label161
   201 set :compute:x1 :compute:zx
   202 op mul *tmp59 :compute:zx :compute:zx
   203 op mul *tmp60 :compute:zy :compute:zy
 
   210 jump *label162 lessThan :compute:dist 64
   211 jump *label55 always
   212 label *label162
-    * label *label163
-    * label *label164
   213 op add :compute:i 4 1
-    * label *label165
   214 set :compute:x1 :compute:zx
   215 op mul *tmp59 :compute:zx :compute:zx
   216 op mul *tmp60 :compute:zy :compute:zy
 
   223 jump *label166 lessThan :compute:dist 64
   224 jump *label55 always
   225 label *label166
-    * label *label167
-    * label *label168
   226 op add :compute:i 5 1
-    * label *label169
   227 set :compute:x1 :compute:zx
   228 op mul *tmp59 :compute:zx :compute:zx
   229 op mul *tmp60 :compute:zy :compute:zy
 
   236 jump *label170 lessThan :compute:dist 64
   237 jump *label55 always
   238 label *label170
-    * label *label171
-    * label *label172
   239 op add :compute:i 6 1
-    * label *label173
   240 set :compute:x1 :compute:zx
   241 op mul *tmp59 :compute:zx :compute:zx
   242 op mul *tmp60 :compute:zy :compute:zy
 
   249 jump *label174 lessThan :compute:dist 64
   250 jump *label55 always
   251 label *label174
-    * label *label175
-    * label *label176
   252 op add :compute:i 7 1
-    * label *label177
   253 set :compute:x1 :compute:zx
   254 op mul *tmp59 :compute:zx :compute:zx
   255 op mul *tmp60 :compute:zy :compute:zy
 
   262 jump *label178 lessThan :compute:dist 64
   263 jump *label55 always
   264 label *label178
-    * label *label179
-    * label *label180
   265 op add :compute:i 8 1
-    * label *label181
   266 set :compute:x1 :compute:zx
   267 op mul *tmp59 :compute:zx :compute:zx
   268 op mul *tmp60 :compute:zy :compute:zy
 
   275 jump *label182 lessThan :compute:dist 64
   276 jump *label55 always
   277 label *label182
-    * label *label183
-    * label *label184
   278 op add :compute:i 9 1
-    * label *label185
   279 set :compute:x1 :compute:zx
   280 op mul *tmp59 :compute:zx :compute:zx
   281 op mul *tmp60 :compute:zy :compute:zy
 
   288 jump *label186 lessThan :compute:dist 64
   289 jump *label55 always
   290 label *label186
-    * label *label187
-    * label *label188
   291 op add :compute:i 10 1
-    * label *label189
   292 set :compute:x1 :compute:zx
   293 op mul *tmp59 :compute:zx :compute:zx
   294 op mul *tmp60 :compute:zy :compute:zy
 
   301 jump *label190 lessThan :compute:dist 64
   302 jump *label55 always
   303 label *label190
-    * label *label191
-    * label *label192
   304 op add :compute:i 11 1
-    * label *label193
   305 set :compute:x1 :compute:zx
   306 op mul *tmp59 :compute:zx :compute:zx
   307 op mul *tmp60 :compute:zy :compute:zy
 
   314 jump *label194 lessThan :compute:dist 64
   315 jump *label55 always
   316 label *label194
-    * label *label195
-    * label *label196
   317 op add :compute:i 12 1
-    * label *label197
   318 set :compute:x1 :compute:zx
   319 op mul *tmp59 :compute:zx :compute:zx
   320 op mul *tmp60 :compute:zy :compute:zy
 
   327 jump *label198 lessThan :compute:dist 64
   328 jump *label55 always
   329 label *label198
-    * label *label199
-    * label *label200
   330 op add :compute:i 13 1
-    * label *label201
   331 set :compute:x1 :compute:zx
   332 op mul *tmp59 :compute:zx :compute:zx
   333 op mul *tmp60 :compute:zy :compute:zy
 
   340 jump *label202 lessThan :compute:dist 64
   341 jump *label55 always
   342 label *label202
-    * label *label203
-    * label *label204
   343 op add :compute:i 14 1
-    * label *label205
   344 set :compute:x1 :compute:zx
   345 op mul *tmp59 :compute:zx :compute:zx
   346 op mul *tmp60 :compute:zy :compute:zy
 
   353 jump *label206 lessThan :compute:dist 64
   354 jump *label55 always
   355 label *label206
-    * label *label207
-    * label *label208
   356 op add :compute:i 15 1
-    * label *label209
   357 set :compute:x1 :compute:zx
   358 op mul *tmp59 :compute:zx :compute:zx
   359 op mul *tmp60 :compute:zy :compute:zy
 
   366 jump *label210 lessThan :compute:dist 64
   367 jump *label55 always
   368 label *label210
-    * label *label211
-    * label *label212
   369 op add :compute:i 16 1
-    * label *label213
   370 set :compute:x1 :compute:zx
   371 op mul *tmp59 :compute:zx :compute:zx
   372 op mul *tmp60 :compute:zy :compute:zy
 
   379 jump *label214 lessThan :compute:dist 64
   380 jump *label55 always
   381 label *label214
-    * label *label215
-    * label *label216
   382 op add :compute:i 17 1
-    * label *label217
   383 set :compute:x1 :compute:zx
   384 op mul *tmp59 :compute:zx :compute:zx
   385 op mul *tmp60 :compute:zy :compute:zy
 
   392 jump *label218 lessThan :compute:dist 64
   393 jump *label55 always
   394 label *label218
-    * label *label219
-    * label *label220
   395 op add :compute:i 18 1
-    * label *label221
   396 set :compute:x1 :compute:zx
   397 op mul *tmp59 :compute:zx :compute:zx
   398 op mul *tmp60 :compute:zy :compute:zy
 
   405 jump *label222 lessThan :compute:dist 64
   406 jump *label55 always
   407 label *label222
-    * label *label223
-    * label *label224
   408 op add :compute:i 19 1
-    * label *label225
   409 set :compute:x1 :compute:zx
   410 op mul *tmp59 :compute:zx :compute:zx
   411 op mul *tmp60 :compute:zy :compute:zy
 
   418 jump *label226 lessThan :compute:dist 64
   419 jump *label55 always
   420 label *label226
-    * label *label227
-    * label *label228
   421 op add :compute:i 20 1
-    * label *label229
   422 set :compute:x1 :compute:zx
   423 op mul *tmp59 :compute:zx :compute:zx
   424 op mul *tmp60 :compute:zy :compute:zy
 
   431 jump *label230 lessThan :compute:dist 64
   432 jump *label55 always
   433 label *label230
-    * label *label231
-    * label *label232
   434 op add :compute:i 21 1
-    * label *label233
   435 set :compute:x1 :compute:zx
   436 op mul *tmp59 :compute:zx :compute:zx
   437 op mul *tmp60 :compute:zy :compute:zy
 
   444 jump *label234 lessThan :compute:dist 64
   445 jump *label55 always
   446 label *label234
-    * label *label235
-    * label *label236
   447 op add :compute:i 22 1
-    * label *label237
   448 set :compute:x1 :compute:zx
   449 op mul *tmp59 :compute:zx :compute:zx
   450 op mul *tmp60 :compute:zy :compute:zy
 
   457 jump *label238 lessThan :compute:dist 64
   458 jump *label55 always
   459 label *label238
-    * label *label239
-    * label *label240
   460 op add :compute:i 23 1
-    * label *label241
   461 set :compute:x1 :compute:zx
   462 op mul *tmp59 :compute:zx :compute:zx
   463 op mul *tmp60 :compute:zy :compute:zy
 
   470 jump *label242 lessThan :compute:dist 64
   471 jump *label55 always
   472 label *label242
-    * label *label243
-    * label *label244
   473 op add :compute:i 24 1
-    * label *label245
   474 set :compute:x1 :compute:zx
   475 op mul *tmp59 :compute:zx :compute:zx
   476 op mul *tmp60 :compute:zy :compute:zy
 
   483 jump *label246 lessThan :compute:dist 64
   484 jump *label55 always
   485 label *label246
-    * label *label247
-    * label *label248
   486 op add :compute:i 25 1
-    * label *label249
   487 set :compute:x1 :compute:zx
   488 op mul *tmp59 :compute:zx :compute:zx
   489 op mul *tmp60 :compute:zy :compute:zy
 
   496 jump *label250 lessThan :compute:dist 64
   497 jump *label55 always
   498 label *label250
-    * label *label251
-    * label *label252
   499 op add :compute:i 26 1
-    * label *label253
   500 set :compute:x1 :compute:zx
   501 op mul *tmp59 :compute:zx :compute:zx
   502 op mul *tmp60 :compute:zy :compute:zy
 
   509 jump *label254 lessThan :compute:dist 64
   510 jump *label55 always
   511 label *label254
-    * label *label255
-    * label *label256
   512 op add :compute:i 27 1
-    * label *label257
   513 set :compute:x1 :compute:zx
   514 op mul *tmp59 :compute:zx :compute:zx
   515 op mul *tmp60 :compute:zy :compute:zy
 
   522 jump *label258 lessThan :compute:dist 64
   523 jump *label55 always
   524 label *label258
-    * label *label259
-    * label *label260
   525 op add :compute:i 28 1
-    * label *label261
   526 set :compute:x1 :compute:zx
   527 op mul *tmp59 :compute:zx :compute:zx
   528 op mul *tmp60 :compute:zy :compute:zy
 
   535 jump *label262 lessThan :compute:dist 64
   536 jump *label55 always
   537 label *label262
-    * label *label263
-    * label *label264
   538 op add :compute:i 29 1
-    * label *label265
   539 set :compute:x1 :compute:zx
   540 op mul *tmp59 :compute:zx :compute:zx
   541 op mul *tmp60 :compute:zy :compute:zy
 
   548 jump *label266 lessThan :compute:dist 64
   549 jump *label55 always
   550 label *label266
-    * label *label267
-    * label *label268
   551 op add :compute:i 30 1
-    * label *label269
   552 set :compute:x1 :compute:zx
   553 op mul *tmp59 :compute:zx :compute:zx
   554 op mul *tmp60 :compute:zy :compute:zy
 
   561 jump *label270 lessThan :compute:dist 64
   562 jump *label55 always
   563 label *label270
-    * label *label271
-    * label *label272
   564 op add :compute:i 31 1
-    * label *label273
   565 set :compute:x1 :compute:zx
   566 op mul *tmp59 :compute:zx :compute:zx
   567 op mul *tmp60 :compute:zy :compute:zy
 
   574 jump *label274 lessThan :compute:dist 64
   575 jump *label55 always
   576 label *label274
-    * label *label275
-    * label *label276
   577 op add :compute:i 32 1
-    * label *label277
   578 set :compute:x1 :compute:zx
   579 op mul *tmp59 :compute:zx :compute:zx
   580 op mul *tmp60 :compute:zy :compute:zy
 
   587 jump *label278 lessThan :compute:dist 64
   588 jump *label55 always
   589 label *label278
-    * label *label279
-    * label *label280
   590 op add :compute:i 33 1
-    * label *label281
   591 set :compute:x1 :compute:zx
   592 op mul *tmp59 :compute:zx :compute:zx
   593 op mul *tmp60 :compute:zy :compute:zy
 
   600 jump *label282 lessThan :compute:dist 64
   601 jump *label55 always
   602 label *label282
-    * label *label283
-    * label *label284
   603 op add :compute:i 34 1
-    * label *label285
   604 set :compute:x1 :compute:zx
   605 op mul *tmp59 :compute:zx :compute:zx
   606 op mul *tmp60 :compute:zy :compute:zy
 
   613 jump *label286 lessThan :compute:dist 64
   614 jump *label55 always
   615 label *label286
-    * label *label287
-    * label *label288
   616 op add :compute:i 35 1
-    * label *label289
   617 set :compute:x1 :compute:zx
   618 op mul *tmp59 :compute:zx :compute:zx
   619 op mul *tmp60 :compute:zy :compute:zy
 
   626 jump *label290 lessThan :compute:dist 64
   627 jump *label55 always
   628 label *label290
-    * label *label291
-    * label *label292
   629 op add :compute:i 36 1
-    * label *label293
   630 set :compute:x1 :compute:zx
   631 op mul *tmp59 :compute:zx :compute:zx
   632 op mul *tmp60 :compute:zy :compute:zy
 
   639 jump *label294 lessThan :compute:dist 64
   640 jump *label55 always
   641 label *label294
-    * label *label295
-    * label *label296
   642 op add :compute:i 37 1
-    * label *label297
   643 set :compute:x1 :compute:zx
   644 op mul *tmp59 :compute:zx :compute:zx
   645 op mul *tmp60 :compute:zy :compute:zy
 
   652 jump *label298 lessThan :compute:dist 64
   653 jump *label55 always
   654 label *label298
-    * label *label299
-    * label *label300
   655 op add :compute:i 38 1
-    * label *label301
   656 set :compute:x1 :compute:zx
   657 op mul *tmp59 :compute:zx :compute:zx
   658 op mul *tmp60 :compute:zy :compute:zy
 
   665 jump *label302 lessThan :compute:dist 64
   666 jump *label55 always
   667 label *label302
-    * label *label303
-    * label *label304
   668 op add :compute:i 39 1
-    * label *label305
   669 set :compute:x1 :compute:zx
   670 op mul *tmp59 :compute:zx :compute:zx
   671 op mul *tmp60 :compute:zy :compute:zy
 
   678 jump *label306 lessThan :compute:dist 64
   679 jump *label55 always
   680 label *label306
-    * label *label307
-    * label *label308
   681 op add :compute:i 40 1
-    * label *label309
   682 set :compute:x1 :compute:zx
   683 op mul *tmp59 :compute:zx :compute:zx
   684 op mul *tmp60 :compute:zy :compute:zy
 
   691 jump *label310 lessThan :compute:dist 64
   692 jump *label55 always
   693 label *label310
-    * label *label311
-    * label *label312
   694 op add :compute:i 41 1
-    * label *label313
   695 set :compute:x1 :compute:zx
   696 op mul *tmp59 :compute:zx :compute:zx
   697 op mul *tmp60 :compute:zy :compute:zy
 
   704 jump *label314 lessThan :compute:dist 64
   705 jump *label55 always
   706 label *label314
-    * label *label315
-    * label *label316
   707 op add :compute:i 42 1
-    * label *label317
   708 set :compute:x1 :compute:zx
   709 op mul *tmp59 :compute:zx :compute:zx
   710 op mul *tmp60 :compute:zy :compute:zy
 
   717 jump *label318 lessThan :compute:dist 64
   718 jump *label55 always
   719 label *label318
-    * label *label319
-    * label *label320
   720 op add :compute:i 43 1
-    * label *label321
   721 set :compute:x1 :compute:zx
   722 op mul *tmp59 :compute:zx :compute:zx
   723 op mul *tmp60 :compute:zy :compute:zy
 
   730 jump *label322 lessThan :compute:dist 64
   731 jump *label55 always
   732 label *label322
-    * label *label323
-    * label *label324
   733 op add :compute:i 44 1
-    * label *label325
   734 set :compute:x1 :compute:zx
   735 op mul *tmp59 :compute:zx :compute:zx
   736 op mul *tmp60 :compute:zy :compute:zy
 
   743 jump *label326 lessThan :compute:dist 64
   744 jump *label55 always
   745 label *label326
-    * label *label327
-    * label *label328
   746 op add :compute:i 45 1
-    * label *label329
   747 set :compute:x1 :compute:zx
   748 op mul *tmp59 :compute:zx :compute:zx
   749 op mul *tmp60 :compute:zy :compute:zy
 
   756 jump *label330 lessThan :compute:dist 64
   757 jump *label55 always
   758 label *label330
-    * label *label331
-    * label *label332
   759 op add :compute:i 46 1
-    * label *label333
   760 set :compute:x1 :compute:zx
   761 op mul *tmp59 :compute:zx :compute:zx
   762 op mul *tmp60 :compute:zy :compute:zy
 
   769 jump *label334 lessThan :compute:dist 64
   770 jump *label55 always
   771 label *label334
-    * label *label335
-    * label *label336
   772 op add :compute:i 47 1
-    * label *label337
   773 set :compute:x1 :compute:zx
   774 op mul *tmp59 :compute:zx :compute:zx
   775 op mul *tmp60 :compute:zy :compute:zy
 
   782 jump *label338 lessThan :compute:dist 64
   783 jump *label55 always
   784 label *label338
-    * label *label339
-    * label *label340
   785 op add :compute:i 48 1
-    * label *label341
   786 set :compute:x1 :compute:zx
   787 op mul *tmp59 :compute:zx :compute:zx
   788 op mul *tmp60 :compute:zy :compute:zy
 
   795 jump *label342 lessThan :compute:dist 64
   796 jump *label55 always
   797 label *label342
-    * label *label343
-    * label *label344
   798 op add :compute:i 49 1
-    * label *label345
   799 set :compute:x1 :compute:zx
   800 op mul *tmp59 :compute:zx :compute:zx
   801 op mul *tmp60 :compute:zy :compute:zy
 
   808 jump *label346 lessThan :compute:dist 64
   809 jump *label55 always
   810 label *label346
-    * label *label347
-    * label *label348
   811 op add :compute:i 50 1
-    * label *label349
   812 set :compute:x1 :compute:zx
   813 op mul *tmp59 :compute:zx :compute:zx
   814 op mul *tmp60 :compute:zy :compute:zy
 
   821 jump *label350 lessThan :compute:dist 64
   822 jump *label55 always
   823 label *label350
-    * label *label351
-    * label *label352
   824 op add :compute:i 51 1
-    * label *label353
   825 set :compute:x1 :compute:zx
   826 op mul *tmp59 :compute:zx :compute:zx
   827 op mul *tmp60 :compute:zy :compute:zy
 
   834 jump *label354 lessThan :compute:dist 64
   835 jump *label55 always
   836 label *label354
-    * label *label355
-    * label *label356
   837 op add :compute:i 52 1
-    * label *label357
   838 set :compute:x1 :compute:zx
   839 op mul *tmp59 :compute:zx :compute:zx
   840 op mul *tmp60 :compute:zy :compute:zy
 
   847 jump *label358 lessThan :compute:dist 64
   848 jump *label55 always
   849 label *label358
-    * label *label359
-    * label *label360
   850 op add :compute:i 53 1
-    * label *label361
   851 set :compute:x1 :compute:zx
   852 op mul *tmp59 :compute:zx :compute:zx
   853 op mul *tmp60 :compute:zy :compute:zy
 
   860 jump *label362 lessThan :compute:dist 64
   861 jump *label55 always
   862 label *label362
-    * label *label363
-    * label *label364
   863 op add :compute:i 54 1
-    * label *label365
   864 set :compute:x1 :compute:zx
   865 op mul *tmp59 :compute:zx :compute:zx
   866 op mul *tmp60 :compute:zy :compute:zy
 
   873 jump *label366 lessThan :compute:dist 64
   874 jump *label55 always
   875 label *label366
-    * label *label367
-    * label *label368
   876 op add :compute:i 55 1
-    * label *label369
   877 set :compute:x1 :compute:zx
   878 op mul *tmp59 :compute:zx :compute:zx
   879 op mul *tmp60 :compute:zy :compute:zy
 
   886 jump *label370 lessThan :compute:dist 64
   887 jump *label55 always
   888 label *label370
-    * label *label371
-    * label *label372
   889 op add :compute:i 56 1
-    * label *label373
   890 set :compute:x1 :compute:zx
   891 op mul *tmp59 :compute:zx :compute:zx
   892 op mul *tmp60 :compute:zy :compute:zy
 
   899 jump *label374 lessThan :compute:dist 64
   900 jump *label55 always
   901 label *label374
-    * label *label375
-    * label *label376
   902 op add :compute:i 57 1
-    * label *label377
   903 set :compute:x1 :compute:zx
   904 op mul *tmp59 :compute:zx :compute:zx
   905 op mul *tmp60 :compute:zy :compute:zy
 
   912 jump *label378 lessThan :compute:dist 64
   913 jump *label55 always
   914 label *label378
-    * label *label379
-    * label *label380
   915 op add :compute:i 58 1
-    * label *label381
   916 set :compute:x1 :compute:zx
   917 op mul *tmp59 :compute:zx :compute:zx
   918 op mul *tmp60 :compute:zy :compute:zy
 
   925 jump *label382 lessThan :compute:dist 64
   926 jump *label55 always
   927 label *label382
-    * label *label383
-    * label *label384
   928 op add :compute:i 59 1
-    * label *label385
   929 set :compute:x1 :compute:zx
   930 op mul *tmp59 :compute:zx :compute:zx
   931 op mul *tmp60 :compute:zy :compute:zy
 
   938 jump *label386 lessThan :compute:dist 64
   939 jump *label55 always
   940 label *label386
-    * label *label387
-    * label *label388
   941 op add :compute:i 60 1
-    * label *label389
   942 set :compute:x1 :compute:zx
   943 op mul *tmp59 :compute:zx :compute:zx
   944 op mul *tmp60 :compute:zy :compute:zy
 
   951 jump *label390 lessThan :compute:dist 64
   952 jump *label55 always
   953 label *label390
-    * label *label391
-    * label *label392
   954 op add :compute:i 61 1
-    * label *label393
   955 set :compute:x1 :compute:zx
   956 op mul *tmp59 :compute:zx :compute:zx
   957 op mul *tmp60 :compute:zy :compute:zy
 
   964 jump *label394 lessThan :compute:dist 64
   965 jump *label55 always
   966 label *label394
-    * label *label395
-    * label *label396
   967 op add :compute:i 62 1
   968 label *label55
   969 op mul *tmp69 .SMOOTH 63
 
   975 op sub :compute:correction 4 *tmp75
   976 op add :compute:i :compute:i :compute:correction
   977 label *label58
-    * label *label59
   978 set *tmp41 :compute:i
   979 label *label46
   980 jump *label61 equal .SMOOTH false
   981 set :drawPixel:color %[black]
   982 jump *label64 equal *tmp41 63
-    * label *label63
   983 jump *label66 notEqual .PALETTE 2
-    * label *label67
   984 op sub *tmp82 32 *tmp41
   985 op abs *tmp83 *tmp82
   986 op div *tmp85 *tmp83 36.42857142857143
 
   995 jump *label65 always
   996 label *label66
   997 jump *label68 notEqual .PALETTE 3
-    * label *label69
   998 op div *tmp99 *tmp41 0.175
   999 op sin :drawPixel:r *tmp99
  1000 op cos :drawPixel:g *tmp99
 
  1006 jump *label65 always
  1007 label *label68
  1008 jump *label70 notEqual .PALETTE 4
-    * label *label71
  1009 op div :drawPixel:r *tmp41 63.75
  1010 op div *tmp113 *tmp41 170
  1011 op add :drawPixel:g 96 *tmp113
 
  1022 read :drawPixel:color .memory *tmp41
  1023 label *label62
  1024 jump *label72 lessThan .localBuffer 250
-    * label *label397
  1025 jump *label401 lessThanEq .localBuffer 4
  1026 label *label398
  1027 wait 0.0001
-    * label *label399
  1028 sensor *tmp140 .display @bufferUsage
  1029 jump *label398 greaterThan *tmp140 250
-    * label *label400
  1030 label *label401
-    * label *label402
  1031 drawflush .display
  1032 set .localBuffer 0
-    * label *label403
  1033 label *label72
-    * label *label73
  1034 draw col :drawPixel:color
  1035 draw rect :x :y 1 1
  1036 op add .localBuffer .localBuffer 2
 
  1040 drawflush .display
  1041 set .localBuffer 0
  1042 label *label77
-    * label *label78
  1043 label *label75
-    * label *label76
-    * label *label60
  1044 read *tmp130 .memory :position
  1045 jump *label79 equal *tmp130 .PROCESSOR_ID
  1046 jump *label45 always
  1047 label *label79
-    * label *label80
  1048 read *tmp1 .memory 65
  1049 jump *label81 equal .stop *tmp1
  1050 jump *label40 always
  1051 label *label81
-    * label *label82
-    * label *label44
  1052 op add :y :y 1
  1053 jump *label102 lessThan :y 176
  1054 label *label45
  1055 label *label41
-    * label *label42
  1056 op add :line :line :increment
  1057 jump *label83 lessThanEq :line 176
  1058 op div :next_increment :next_increment 2
  1059 set :increment :next_increment
  1060 op div :line :next_increment 2
  1061 label *label83
-    * label *label84
-    * label *label39
  1062 op add :lines :lines 1
  1063 jump *label101 lessThan :lines 176
  1064 label *label40
-    * label *label404
  1065 jump *label408 lessThanEq .localBuffer 4
  1066 label *label405
  1067 wait 0.0001
-    * label *label406
  1068 sensor *tmp140 .display @bufferUsage
  1069 jump *label405 greaterThan *tmp140 250
-    * label *label407
  1070 label *label408
-    * label *label409
  1071 drawflush .display
  1072 set .localBuffer 0
-    * label *label410
-    * label *label31
  1073 jump *label30 always
-    * label *label32
  1074 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-65 instructions):
 
   155 op mul *tmp64 *tmp63 :compute:zy
   156 op add :compute:zy *tmp64 :compute:cy
   157 op len :compute:dist :compute:zx :compute:zy
-    * jump *label146 lessThan :compute:dist 64
-    * jump *label55 always
+  158 jump *label55 greaterThanEq :compute:dist 64
   159 label *label146
   160 set :compute:i 1
   161 set :compute:x1 :compute:zx
 
   167 op mul *tmp64 *tmp63 :compute:zy
   168 op add :compute:zy *tmp64 :compute:cy
   169 op len :compute:dist :compute:zx :compute:zy
-    * jump *label150 lessThan :compute:dist 64
-    * jump *label55 always
+  170 jump *label55 greaterThanEq :compute:dist 64
   171 label *label150
   172 op add :compute:i 1 1
   173 set :compute:x1 :compute:zx
 
   179 op mul *tmp64 *tmp63 :compute:zy
   180 op add :compute:zy *tmp64 :compute:cy
   181 op len :compute:dist :compute:zx :compute:zy
-    * jump *label154 lessThan :compute:dist 64
-    * jump *label55 always
+  182 jump *label55 greaterThanEq :compute:dist 64
   183 label *label154
   184 op add :compute:i 2 1
   185 set :compute:x1 :compute:zx
 
   191 op mul *tmp64 *tmp63 :compute:zy
   192 op add :compute:zy *tmp64 :compute:cy
   193 op len :compute:dist :compute:zx :compute:zy
-    * jump *label158 lessThan :compute:dist 64
-    * jump *label55 always
+  194 jump *label55 greaterThanEq :compute:dist 64
   195 label *label158
   196 op add :compute:i 3 1
   197 set :compute:x1 :compute:zx
 
   203 op mul *tmp64 *tmp63 :compute:zy
   204 op add :compute:zy *tmp64 :compute:cy
   205 op len :compute:dist :compute:zx :compute:zy
-    * jump *label162 lessThan :compute:dist 64
-    * jump *label55 always
+  206 jump *label55 greaterThanEq :compute:dist 64
   207 label *label162
   208 op add :compute:i 4 1
   209 set :compute:x1 :compute:zx
 
   215 op mul *tmp64 *tmp63 :compute:zy
   216 op add :compute:zy *tmp64 :compute:cy
   217 op len :compute:dist :compute:zx :compute:zy
-    * jump *label166 lessThan :compute:dist 64
-    * jump *label55 always
+  218 jump *label55 greaterThanEq :compute:dist 64
   219 label *label166
   220 op add :compute:i 5 1
   221 set :compute:x1 :compute:zx
 
   227 op mul *tmp64 *tmp63 :compute:zy
   228 op add :compute:zy *tmp64 :compute:cy
   229 op len :compute:dist :compute:zx :compute:zy
-    * jump *label170 lessThan :compute:dist 64
-    * jump *label55 always
+  230 jump *label55 greaterThanEq :compute:dist 64
   231 label *label170
   232 op add :compute:i 6 1
   233 set :compute:x1 :compute:zx
 
   239 op mul *tmp64 *tmp63 :compute:zy
   240 op add :compute:zy *tmp64 :compute:cy
   241 op len :compute:dist :compute:zx :compute:zy
-    * jump *label174 lessThan :compute:dist 64
-    * jump *label55 always
+  242 jump *label55 greaterThanEq :compute:dist 64
   243 label *label174
   244 op add :compute:i 7 1
   245 set :compute:x1 :compute:zx
 
   251 op mul *tmp64 *tmp63 :compute:zy
   252 op add :compute:zy *tmp64 :compute:cy
   253 op len :compute:dist :compute:zx :compute:zy
-    * jump *label178 lessThan :compute:dist 64
-    * jump *label55 always
+  254 jump *label55 greaterThanEq :compute:dist 64
   255 label *label178
   256 op add :compute:i 8 1
   257 set :compute:x1 :compute:zx
 
   263 op mul *tmp64 *tmp63 :compute:zy
   264 op add :compute:zy *tmp64 :compute:cy
   265 op len :compute:dist :compute:zx :compute:zy
-    * jump *label182 lessThan :compute:dist 64
-    * jump *label55 always
+  266 jump *label55 greaterThanEq :compute:dist 64
   267 label *label182
   268 op add :compute:i 9 1
   269 set :compute:x1 :compute:zx
 
   275 op mul *tmp64 *tmp63 :compute:zy
   276 op add :compute:zy *tmp64 :compute:cy
   277 op len :compute:dist :compute:zx :compute:zy
-    * jump *label186 lessThan :compute:dist 64
-    * jump *label55 always
+  278 jump *label55 greaterThanEq :compute:dist 64
   279 label *label186
   280 op add :compute:i 10 1
   281 set :compute:x1 :compute:zx
 
   287 op mul *tmp64 *tmp63 :compute:zy
   288 op add :compute:zy *tmp64 :compute:cy
   289 op len :compute:dist :compute:zx :compute:zy
-    * jump *label190 lessThan :compute:dist 64
-    * jump *label55 always
+  290 jump *label55 greaterThanEq :compute:dist 64
   291 label *label190
   292 op add :compute:i 11 1
   293 set :compute:x1 :compute:zx
 
   299 op mul *tmp64 *tmp63 :compute:zy
   300 op add :compute:zy *tmp64 :compute:cy
   301 op len :compute:dist :compute:zx :compute:zy
-    * jump *label194 lessThan :compute:dist 64
-    * jump *label55 always
+  302 jump *label55 greaterThanEq :compute:dist 64
   303 label *label194
   304 op add :compute:i 12 1
   305 set :compute:x1 :compute:zx
 
   311 op mul *tmp64 *tmp63 :compute:zy
   312 op add :compute:zy *tmp64 :compute:cy
   313 op len :compute:dist :compute:zx :compute:zy
-    * jump *label198 lessThan :compute:dist 64
-    * jump *label55 always
+  314 jump *label55 greaterThanEq :compute:dist 64
   315 label *label198
   316 op add :compute:i 13 1
   317 set :compute:x1 :compute:zx
 
   323 op mul *tmp64 *tmp63 :compute:zy
   324 op add :compute:zy *tmp64 :compute:cy
   325 op len :compute:dist :compute:zx :compute:zy
-    * jump *label202 lessThan :compute:dist 64
-    * jump *label55 always
+  326 jump *label55 greaterThanEq :compute:dist 64
   327 label *label202
   328 op add :compute:i 14 1
   329 set :compute:x1 :compute:zx
 
   335 op mul *tmp64 *tmp63 :compute:zy
   336 op add :compute:zy *tmp64 :compute:cy
   337 op len :compute:dist :compute:zx :compute:zy
-    * jump *label206 lessThan :compute:dist 64
-    * jump *label55 always
+  338 jump *label55 greaterThanEq :compute:dist 64
   339 label *label206
   340 op add :compute:i 15 1
   341 set :compute:x1 :compute:zx
 
   347 op mul *tmp64 *tmp63 :compute:zy
   348 op add :compute:zy *tmp64 :compute:cy
   349 op len :compute:dist :compute:zx :compute:zy
-    * jump *label210 lessThan :compute:dist 64
-    * jump *label55 always
+  350 jump *label55 greaterThanEq :compute:dist 64
   351 label *label210
   352 op add :compute:i 16 1
   353 set :compute:x1 :compute:zx
 
   359 op mul *tmp64 *tmp63 :compute:zy
   360 op add :compute:zy *tmp64 :compute:cy
   361 op len :compute:dist :compute:zx :compute:zy
-    * jump *label214 lessThan :compute:dist 64
-    * jump *label55 always
+  362 jump *label55 greaterThanEq :compute:dist 64
   363 label *label214
   364 op add :compute:i 17 1
   365 set :compute:x1 :compute:zx
 
   371 op mul *tmp64 *tmp63 :compute:zy
   372 op add :compute:zy *tmp64 :compute:cy
   373 op len :compute:dist :compute:zx :compute:zy
-    * jump *label218 lessThan :compute:dist 64
-    * jump *label55 always
+  374 jump *label55 greaterThanEq :compute:dist 64
   375 label *label218
   376 op add :compute:i 18 1
   377 set :compute:x1 :compute:zx
 
   383 op mul *tmp64 *tmp63 :compute:zy
   384 op add :compute:zy *tmp64 :compute:cy
   385 op len :compute:dist :compute:zx :compute:zy
-    * jump *label222 lessThan :compute:dist 64
-    * jump *label55 always
+  386 jump *label55 greaterThanEq :compute:dist 64
   387 label *label222
   388 op add :compute:i 19 1
   389 set :compute:x1 :compute:zx
 
   395 op mul *tmp64 *tmp63 :compute:zy
   396 op add :compute:zy *tmp64 :compute:cy
   397 op len :compute:dist :compute:zx :compute:zy
-    * jump *label226 lessThan :compute:dist 64
-    * jump *label55 always
+  398 jump *label55 greaterThanEq :compute:dist 64
   399 label *label226
   400 op add :compute:i 20 1
   401 set :compute:x1 :compute:zx
 
   407 op mul *tmp64 *tmp63 :compute:zy
   408 op add :compute:zy *tmp64 :compute:cy
   409 op len :compute:dist :compute:zx :compute:zy
-    * jump *label230 lessThan :compute:dist 64
-    * jump *label55 always
+  410 jump *label55 greaterThanEq :compute:dist 64
   411 label *label230
   412 op add :compute:i 21 1
   413 set :compute:x1 :compute:zx
 
   419 op mul *tmp64 *tmp63 :compute:zy
   420 op add :compute:zy *tmp64 :compute:cy
   421 op len :compute:dist :compute:zx :compute:zy
-    * jump *label234 lessThan :compute:dist 64
-    * jump *label55 always
+  422 jump *label55 greaterThanEq :compute:dist 64
   423 label *label234
   424 op add :compute:i 22 1
   425 set :compute:x1 :compute:zx
 
   431 op mul *tmp64 *tmp63 :compute:zy
   432 op add :compute:zy *tmp64 :compute:cy
   433 op len :compute:dist :compute:zx :compute:zy
-    * jump *label238 lessThan :compute:dist 64
-    * jump *label55 always
+  434 jump *label55 greaterThanEq :compute:dist 64
   435 label *label238
   436 op add :compute:i 23 1
   437 set :compute:x1 :compute:zx
 
   443 op mul *tmp64 *tmp63 :compute:zy
   444 op add :compute:zy *tmp64 :compute:cy
   445 op len :compute:dist :compute:zx :compute:zy
-    * jump *label242 lessThan :compute:dist 64
-    * jump *label55 always
+  446 jump *label55 greaterThanEq :compute:dist 64
   447 label *label242
   448 op add :compute:i 24 1
   449 set :compute:x1 :compute:zx
 
   455 op mul *tmp64 *tmp63 :compute:zy
   456 op add :compute:zy *tmp64 :compute:cy
   457 op len :compute:dist :compute:zx :compute:zy
-    * jump *label246 lessThan :compute:dist 64
-    * jump *label55 always
+  458 jump *label55 greaterThanEq :compute:dist 64
   459 label *label246
   460 op add :compute:i 25 1
   461 set :compute:x1 :compute:zx
 
   467 op mul *tmp64 *tmp63 :compute:zy
   468 op add :compute:zy *tmp64 :compute:cy
   469 op len :compute:dist :compute:zx :compute:zy
-    * jump *label250 lessThan :compute:dist 64
-    * jump *label55 always
+  470 jump *label55 greaterThanEq :compute:dist 64
   471 label *label250
   472 op add :compute:i 26 1
   473 set :compute:x1 :compute:zx
 
   479 op mul *tmp64 *tmp63 :compute:zy
   480 op add :compute:zy *tmp64 :compute:cy
   481 op len :compute:dist :compute:zx :compute:zy
-    * jump *label254 lessThan :compute:dist 64
-    * jump *label55 always
+  482 jump *label55 greaterThanEq :compute:dist 64
   483 label *label254
   484 op add :compute:i 27 1
   485 set :compute:x1 :compute:zx
 
   491 op mul *tmp64 *tmp63 :compute:zy
   492 op add :compute:zy *tmp64 :compute:cy
   493 op len :compute:dist :compute:zx :compute:zy
-    * jump *label258 lessThan :compute:dist 64
-    * jump *label55 always
+  494 jump *label55 greaterThanEq :compute:dist 64
   495 label *label258
   496 op add :compute:i 28 1
   497 set :compute:x1 :compute:zx
 
   503 op mul *tmp64 *tmp63 :compute:zy
   504 op add :compute:zy *tmp64 :compute:cy
   505 op len :compute:dist :compute:zx :compute:zy
-    * jump *label262 lessThan :compute:dist 64
-    * jump *label55 always
+  506 jump *label55 greaterThanEq :compute:dist 64
   507 label *label262
   508 op add :compute:i 29 1
   509 set :compute:x1 :compute:zx
 
   515 op mul *tmp64 *tmp63 :compute:zy
   516 op add :compute:zy *tmp64 :compute:cy
   517 op len :compute:dist :compute:zx :compute:zy
-    * jump *label266 lessThan :compute:dist 64
-    * jump *label55 always
+  518 jump *label55 greaterThanEq :compute:dist 64
   519 label *label266
   520 op add :compute:i 30 1
   521 set :compute:x1 :compute:zx
 
   527 op mul *tmp64 *tmp63 :compute:zy
   528 op add :compute:zy *tmp64 :compute:cy
   529 op len :compute:dist :compute:zx :compute:zy
-    * jump *label270 lessThan :compute:dist 64
-    * jump *label55 always
+  530 jump *label55 greaterThanEq :compute:dist 64
   531 label *label270
   532 op add :compute:i 31 1
   533 set :compute:x1 :compute:zx
 
   539 op mul *tmp64 *tmp63 :compute:zy
   540 op add :compute:zy *tmp64 :compute:cy
   541 op len :compute:dist :compute:zx :compute:zy
-    * jump *label274 lessThan :compute:dist 64
-    * jump *label55 always
+  542 jump *label55 greaterThanEq :compute:dist 64
   543 label *label274
   544 op add :compute:i 32 1
   545 set :compute:x1 :compute:zx
 
   551 op mul *tmp64 *tmp63 :compute:zy
   552 op add :compute:zy *tmp64 :compute:cy
   553 op len :compute:dist :compute:zx :compute:zy
-    * jump *label278 lessThan :compute:dist 64
-    * jump *label55 always
+  554 jump *label55 greaterThanEq :compute:dist 64
   555 label *label278
   556 op add :compute:i 33 1
   557 set :compute:x1 :compute:zx
 
   563 op mul *tmp64 *tmp63 :compute:zy
   564 op add :compute:zy *tmp64 :compute:cy
   565 op len :compute:dist :compute:zx :compute:zy
-    * jump *label282 lessThan :compute:dist 64
-    * jump *label55 always
+  566 jump *label55 greaterThanEq :compute:dist 64
   567 label *label282
   568 op add :compute:i 34 1
   569 set :compute:x1 :compute:zx
 
   575 op mul *tmp64 *tmp63 :compute:zy
   576 op add :compute:zy *tmp64 :compute:cy
   577 op len :compute:dist :compute:zx :compute:zy
-    * jump *label286 lessThan :compute:dist 64
-    * jump *label55 always
+  578 jump *label55 greaterThanEq :compute:dist 64
   579 label *label286
   580 op add :compute:i 35 1
   581 set :compute:x1 :compute:zx
 
   587 op mul *tmp64 *tmp63 :compute:zy
   588 op add :compute:zy *tmp64 :compute:cy
   589 op len :compute:dist :compute:zx :compute:zy
-    * jump *label290 lessThan :compute:dist 64
-    * jump *label55 always
+  590 jump *label55 greaterThanEq :compute:dist 64
   591 label *label290
   592 op add :compute:i 36 1
   593 set :compute:x1 :compute:zx
 
   599 op mul *tmp64 *tmp63 :compute:zy
   600 op add :compute:zy *tmp64 :compute:cy
   601 op len :compute:dist :compute:zx :compute:zy
-    * jump *label294 lessThan :compute:dist 64
-    * jump *label55 always
+  602 jump *label55 greaterThanEq :compute:dist 64
   603 label *label294
   604 op add :compute:i 37 1
   605 set :compute:x1 :compute:zx
 
   611 op mul *tmp64 *tmp63 :compute:zy
   612 op add :compute:zy *tmp64 :compute:cy
   613 op len :compute:dist :compute:zx :compute:zy
-    * jump *label298 lessThan :compute:dist 64
-    * jump *label55 always
+  614 jump *label55 greaterThanEq :compute:dist 64
   615 label *label298
   616 op add :compute:i 38 1
   617 set :compute:x1 :compute:zx
 
   623 op mul *tmp64 *tmp63 :compute:zy
   624 op add :compute:zy *tmp64 :compute:cy
   625 op len :compute:dist :compute:zx :compute:zy
-    * jump *label302 lessThan :compute:dist 64
-    * jump *label55 always
+  626 jump *label55 greaterThanEq :compute:dist 64
   627 label *label302
   628 op add :compute:i 39 1
   629 set :compute:x1 :compute:zx
 
   635 op mul *tmp64 *tmp63 :compute:zy
   636 op add :compute:zy *tmp64 :compute:cy
   637 op len :compute:dist :compute:zx :compute:zy
-    * jump *label306 lessThan :compute:dist 64
-    * jump *label55 always
+  638 jump *label55 greaterThanEq :compute:dist 64
   639 label *label306
   640 op add :compute:i 40 1
   641 set :compute:x1 :compute:zx
 
   647 op mul *tmp64 *tmp63 :compute:zy
   648 op add :compute:zy *tmp64 :compute:cy
   649 op len :compute:dist :compute:zx :compute:zy
-    * jump *label310 lessThan :compute:dist 64
-    * jump *label55 always
+  650 jump *label55 greaterThanEq :compute:dist 64
   651 label *label310
   652 op add :compute:i 41 1
   653 set :compute:x1 :compute:zx
 
   659 op mul *tmp64 *tmp63 :compute:zy
   660 op add :compute:zy *tmp64 :compute:cy
   661 op len :compute:dist :compute:zx :compute:zy
-    * jump *label314 lessThan :compute:dist 64
-    * jump *label55 always
+  662 jump *label55 greaterThanEq :compute:dist 64
   663 label *label314
   664 op add :compute:i 42 1
   665 set :compute:x1 :compute:zx
 
   671 op mul *tmp64 *tmp63 :compute:zy
   672 op add :compute:zy *tmp64 :compute:cy
   673 op len :compute:dist :compute:zx :compute:zy
-    * jump *label318 lessThan :compute:dist 64
-    * jump *label55 always
+  674 jump *label55 greaterThanEq :compute:dist 64
   675 label *label318
   676 op add :compute:i 43 1
   677 set :compute:x1 :compute:zx
 
   683 op mul *tmp64 *tmp63 :compute:zy
   684 op add :compute:zy *tmp64 :compute:cy
   685 op len :compute:dist :compute:zx :compute:zy
-    * jump *label322 lessThan :compute:dist 64
-    * jump *label55 always
+  686 jump *label55 greaterThanEq :compute:dist 64
   687 label *label322
   688 op add :compute:i 44 1
   689 set :compute:x1 :compute:zx
 
   695 op mul *tmp64 *tmp63 :compute:zy
   696 op add :compute:zy *tmp64 :compute:cy
   697 op len :compute:dist :compute:zx :compute:zy
-    * jump *label326 lessThan :compute:dist 64
-    * jump *label55 always
+  698 jump *label55 greaterThanEq :compute:dist 64
   699 label *label326
   700 op add :compute:i 45 1
   701 set :compute:x1 :compute:zx
 
   707 op mul *tmp64 *tmp63 :compute:zy
   708 op add :compute:zy *tmp64 :compute:cy
   709 op len :compute:dist :compute:zx :compute:zy
-    * jump *label330 lessThan :compute:dist 64
-    * jump *label55 always
+  710 jump *label55 greaterThanEq :compute:dist 64
   711 label *label330
   712 op add :compute:i 46 1
   713 set :compute:x1 :compute:zx
 
   719 op mul *tmp64 *tmp63 :compute:zy
   720 op add :compute:zy *tmp64 :compute:cy
   721 op len :compute:dist :compute:zx :compute:zy
-    * jump *label334 lessThan :compute:dist 64
-    * jump *label55 always
+  722 jump *label55 greaterThanEq :compute:dist 64
   723 label *label334
   724 op add :compute:i 47 1
   725 set :compute:x1 :compute:zx
 
   731 op mul *tmp64 *tmp63 :compute:zy
   732 op add :compute:zy *tmp64 :compute:cy
   733 op len :compute:dist :compute:zx :compute:zy
-    * jump *label338 lessThan :compute:dist 64
-    * jump *label55 always
+  734 jump *label55 greaterThanEq :compute:dist 64
   735 label *label338
   736 op add :compute:i 48 1
   737 set :compute:x1 :compute:zx
 
   743 op mul *tmp64 *tmp63 :compute:zy
   744 op add :compute:zy *tmp64 :compute:cy
   745 op len :compute:dist :compute:zx :compute:zy
-    * jump *label342 lessThan :compute:dist 64
-    * jump *label55 always
+  746 jump *label55 greaterThanEq :compute:dist 64
   747 label *label342
   748 op add :compute:i 49 1
   749 set :compute:x1 :compute:zx
 
   755 op mul *tmp64 *tmp63 :compute:zy
   756 op add :compute:zy *tmp64 :compute:cy
   757 op len :compute:dist :compute:zx :compute:zy
-    * jump *label346 lessThan :compute:dist 64
-    * jump *label55 always
+  758 jump *label55 greaterThanEq :compute:dist 64
   759 label *label346
   760 op add :compute:i 50 1
   761 set :compute:x1 :compute:zx
 
   767 op mul *tmp64 *tmp63 :compute:zy
   768 op add :compute:zy *tmp64 :compute:cy
   769 op len :compute:dist :compute:zx :compute:zy
-    * jump *label350 lessThan :compute:dist 64
-    * jump *label55 always
+  770 jump *label55 greaterThanEq :compute:dist 64
   771 label *label350
   772 op add :compute:i 51 1
   773 set :compute:x1 :compute:zx
 
   779 op mul *tmp64 *tmp63 :compute:zy
   780 op add :compute:zy *tmp64 :compute:cy
   781 op len :compute:dist :compute:zx :compute:zy
-    * jump *label354 lessThan :compute:dist 64
-    * jump *label55 always
+  782 jump *label55 greaterThanEq :compute:dist 64
   783 label *label354
   784 op add :compute:i 52 1
   785 set :compute:x1 :compute:zx
 
   791 op mul *tmp64 *tmp63 :compute:zy
   792 op add :compute:zy *tmp64 :compute:cy
   793 op len :compute:dist :compute:zx :compute:zy
-    * jump *label358 lessThan :compute:dist 64
-    * jump *label55 always
+  794 jump *label55 greaterThanEq :compute:dist 64
   795 label *label358
   796 op add :compute:i 53 1
   797 set :compute:x1 :compute:zx
 
   803 op mul *tmp64 *tmp63 :compute:zy
   804 op add :compute:zy *tmp64 :compute:cy
   805 op len :compute:dist :compute:zx :compute:zy
-    * jump *label362 lessThan :compute:dist 64
-    * jump *label55 always
+  806 jump *label55 greaterThanEq :compute:dist 64
   807 label *label362
   808 op add :compute:i 54 1
   809 set :compute:x1 :compute:zx
 
   815 op mul *tmp64 *tmp63 :compute:zy
   816 op add :compute:zy *tmp64 :compute:cy
   817 op len :compute:dist :compute:zx :compute:zy
-    * jump *label366 lessThan :compute:dist 64
-    * jump *label55 always
+  818 jump *label55 greaterThanEq :compute:dist 64
   819 label *label366
   820 op add :compute:i 55 1
   821 set :compute:x1 :compute:zx
 
   827 op mul *tmp64 *tmp63 :compute:zy
   828 op add :compute:zy *tmp64 :compute:cy
   829 op len :compute:dist :compute:zx :compute:zy
-    * jump *label370 lessThan :compute:dist 64
-    * jump *label55 always
+  830 jump *label55 greaterThanEq :compute:dist 64
   831 label *label370
   832 op add :compute:i 56 1
   833 set :compute:x1 :compute:zx
 
   839 op mul *tmp64 *tmp63 :compute:zy
   840 op add :compute:zy *tmp64 :compute:cy
   841 op len :compute:dist :compute:zx :compute:zy
-    * jump *label374 lessThan :compute:dist 64
-    * jump *label55 always
+  842 jump *label55 greaterThanEq :compute:dist 64
   843 label *label374
   844 op add :compute:i 57 1
   845 set :compute:x1 :compute:zx
 
   851 op mul *tmp64 *tmp63 :compute:zy
   852 op add :compute:zy *tmp64 :compute:cy
   853 op len :compute:dist :compute:zx :compute:zy
-    * jump *label378 lessThan :compute:dist 64
-    * jump *label55 always
+  854 jump *label55 greaterThanEq :compute:dist 64
   855 label *label378
   856 op add :compute:i 58 1
   857 set :compute:x1 :compute:zx
 
   863 op mul *tmp64 *tmp63 :compute:zy
   864 op add :compute:zy *tmp64 :compute:cy
   865 op len :compute:dist :compute:zx :compute:zy
-    * jump *label382 lessThan :compute:dist 64
-    * jump *label55 always
+  866 jump *label55 greaterThanEq :compute:dist 64
   867 label *label382
   868 op add :compute:i 59 1
   869 set :compute:x1 :compute:zx
 
   875 op mul *tmp64 *tmp63 :compute:zy
   876 op add :compute:zy *tmp64 :compute:cy
   877 op len :compute:dist :compute:zx :compute:zy
-    * jump *label386 lessThan :compute:dist 64
-    * jump *label55 always
+  878 jump *label55 greaterThanEq :compute:dist 64
   879 label *label386
   880 op add :compute:i 60 1
   881 set :compute:x1 :compute:zx
 
   887 op mul *tmp64 *tmp63 :compute:zy
   888 op add :compute:zy *tmp64 :compute:cy
   889 op len :compute:dist :compute:zx :compute:zy
-    * jump *label390 lessThan :compute:dist 64
-    * jump *label55 always
+  890 jump *label55 greaterThanEq :compute:dist 64
   891 label *label390
   892 op add :compute:i 61 1
   893 set :compute:x1 :compute:zx
 
   899 op mul *tmp64 *tmp63 :compute:zy
   900 op add :compute:zy *tmp64 :compute:cy
   901 op len :compute:dist :compute:zx :compute:zy
-    * jump *label394 lessThan :compute:dist 64
-    * jump *label55 always
+  902 jump *label55 greaterThanEq :compute:dist 64
   903 label *label394
   904 op add :compute:i 62 1
   905 label *label55
 
   979 label *label77
   980 label *label75
   981 read *tmp130 .memory :position
-    * jump *label79 equal *tmp130 .PROCESSOR_ID
-    * jump *label45 always
+  982 jump *label45 notEqual *tmp130 .PROCESSOR_ID
   983 label *label79
   984 read *tmp1 .memory 65
-    * jump *label81 equal .stop *tmp1
-    * jump *label40 always
+  985 jump *label40 notEqual .stop *tmp1
   986 label *label81
   987 op add :y :y 1
   988 jump *label102 lessThan :y 176

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
   156 op add :compute:zy *tmp64 :compute:cy
   157 op len :compute:dist :compute:zx :compute:zy
   158 jump *label55 greaterThanEq :compute:dist 64
-    * label *label146
   159 set :compute:i 1
   160 set :compute:x1 :compute:zx
   161 op mul *tmp59 :compute:zx :compute:zx
 
   167 op add :compute:zy *tmp64 :compute:cy
   168 op len :compute:dist :compute:zx :compute:zy
   169 jump *label55 greaterThanEq :compute:dist 64
-    * label *label150
   170 op add :compute:i 1 1
   171 set :compute:x1 :compute:zx
   172 op mul *tmp59 :compute:zx :compute:zx
 
   178 op add :compute:zy *tmp64 :compute:cy
   179 op len :compute:dist :compute:zx :compute:zy
   180 jump *label55 greaterThanEq :compute:dist 64
-    * label *label154
   181 op add :compute:i 2 1
   182 set :compute:x1 :compute:zx
   183 op mul *tmp59 :compute:zx :compute:zx
 
   189 op add :compute:zy *tmp64 :compute:cy
   190 op len :compute:dist :compute:zx :compute:zy
   191 jump *label55 greaterThanEq :compute:dist 64
-    * label *label158
   192 op add :compute:i 3 1
   193 set :compute:x1 :compute:zx
   194 op mul *tmp59 :compute:zx :compute:zx
 
   200 op add :compute:zy *tmp64 :compute:cy
   201 op len :compute:dist :compute:zx :compute:zy
   202 jump *label55 greaterThanEq :compute:dist 64
-    * label *label162
   203 op add :compute:i 4 1
   204 set :compute:x1 :compute:zx
   205 op mul *tmp59 :compute:zx :compute:zx
 
   211 op add :compute:zy *tmp64 :compute:cy
   212 op len :compute:dist :compute:zx :compute:zy
   213 jump *label55 greaterThanEq :compute:dist 64
-    * label *label166
   214 op add :compute:i 5 1
   215 set :compute:x1 :compute:zx
   216 op mul *tmp59 :compute:zx :compute:zx
 
   222 op add :compute:zy *tmp64 :compute:cy
   223 op len :compute:dist :compute:zx :compute:zy
   224 jump *label55 greaterThanEq :compute:dist 64
-    * label *label170
   225 op add :compute:i 6 1
   226 set :compute:x1 :compute:zx
   227 op mul *tmp59 :compute:zx :compute:zx
 
   233 op add :compute:zy *tmp64 :compute:cy
   234 op len :compute:dist :compute:zx :compute:zy
   235 jump *label55 greaterThanEq :compute:dist 64
-    * label *label174
   236 op add :compute:i 7 1
   237 set :compute:x1 :compute:zx
   238 op mul *tmp59 :compute:zx :compute:zx
 
   244 op add :compute:zy *tmp64 :compute:cy
   245 op len :compute:dist :compute:zx :compute:zy
   246 jump *label55 greaterThanEq :compute:dist 64
-    * label *label178
   247 op add :compute:i 8 1
   248 set :compute:x1 :compute:zx
   249 op mul *tmp59 :compute:zx :compute:zx
 
   255 op add :compute:zy *tmp64 :compute:cy
   256 op len :compute:dist :compute:zx :compute:zy
   257 jump *label55 greaterThanEq :compute:dist 64
-    * label *label182
   258 op add :compute:i 9 1
   259 set :compute:x1 :compute:zx
   260 op mul *tmp59 :compute:zx :compute:zx
 
   266 op add :compute:zy *tmp64 :compute:cy
   267 op len :compute:dist :compute:zx :compute:zy
   268 jump *label55 greaterThanEq :compute:dist 64
-    * label *label186
   269 op add :compute:i 10 1
   270 set :compute:x1 :compute:zx
   271 op mul *tmp59 :compute:zx :compute:zx
 
   277 op add :compute:zy *tmp64 :compute:cy
   278 op len :compute:dist :compute:zx :compute:zy
   279 jump *label55 greaterThanEq :compute:dist 64
-    * label *label190
   280 op add :compute:i 11 1
   281 set :compute:x1 :compute:zx
   282 op mul *tmp59 :compute:zx :compute:zx
 
   288 op add :compute:zy *tmp64 :compute:cy
   289 op len :compute:dist :compute:zx :compute:zy
   290 jump *label55 greaterThanEq :compute:dist 64
-    * label *label194
   291 op add :compute:i 12 1
   292 set :compute:x1 :compute:zx
   293 op mul *tmp59 :compute:zx :compute:zx
 
   299 op add :compute:zy *tmp64 :compute:cy
   300 op len :compute:dist :compute:zx :compute:zy
   301 jump *label55 greaterThanEq :compute:dist 64
-    * label *label198
   302 op add :compute:i 13 1
   303 set :compute:x1 :compute:zx
   304 op mul *tmp59 :compute:zx :compute:zx
 
   310 op add :compute:zy *tmp64 :compute:cy
   311 op len :compute:dist :compute:zx :compute:zy
   312 jump *label55 greaterThanEq :compute:dist 64
-    * label *label202
   313 op add :compute:i 14 1
   314 set :compute:x1 :compute:zx
   315 op mul *tmp59 :compute:zx :compute:zx
 
   321 op add :compute:zy *tmp64 :compute:cy
   322 op len :compute:dist :compute:zx :compute:zy
   323 jump *label55 greaterThanEq :compute:dist 64
-    * label *label206
   324 op add :compute:i 15 1
   325 set :compute:x1 :compute:zx
   326 op mul *tmp59 :compute:zx :compute:zx
 
   332 op add :compute:zy *tmp64 :compute:cy
   333 op len :compute:dist :compute:zx :compute:zy
   334 jump *label55 greaterThanEq :compute:dist 64
-    * label *label210
   335 op add :compute:i 16 1
   336 set :compute:x1 :compute:zx
   337 op mul *tmp59 :compute:zx :compute:zx
 
   343 op add :compute:zy *tmp64 :compute:cy
   344 op len :compute:dist :compute:zx :compute:zy
   345 jump *label55 greaterThanEq :compute:dist 64
-    * label *label214
   346 op add :compute:i 17 1
   347 set :compute:x1 :compute:zx
   348 op mul *tmp59 :compute:zx :compute:zx
 
   354 op add :compute:zy *tmp64 :compute:cy
   355 op len :compute:dist :compute:zx :compute:zy
   356 jump *label55 greaterThanEq :compute:dist 64
-    * label *label218
   357 op add :compute:i 18 1
   358 set :compute:x1 :compute:zx
   359 op mul *tmp59 :compute:zx :compute:zx
 
   365 op add :compute:zy *tmp64 :compute:cy
   366 op len :compute:dist :compute:zx :compute:zy
   367 jump *label55 greaterThanEq :compute:dist 64
-    * label *label222
   368 op add :compute:i 19 1
   369 set :compute:x1 :compute:zx
   370 op mul *tmp59 :compute:zx :compute:zx
 
   376 op add :compute:zy *tmp64 :compute:cy
   377 op len :compute:dist :compute:zx :compute:zy
   378 jump *label55 greaterThanEq :compute:dist 64
-    * label *label226
   379 op add :compute:i 20 1
   380 set :compute:x1 :compute:zx
   381 op mul *tmp59 :compute:zx :compute:zx
 
   387 op add :compute:zy *tmp64 :compute:cy
   388 op len :compute:dist :compute:zx :compute:zy
   389 jump *label55 greaterThanEq :compute:dist 64
-    * label *label230
   390 op add :compute:i 21 1
   391 set :compute:x1 :compute:zx
   392 op mul *tmp59 :compute:zx :compute:zx
 
   398 op add :compute:zy *tmp64 :compute:cy
   399 op len :compute:dist :compute:zx :compute:zy
   400 jump *label55 greaterThanEq :compute:dist 64
-    * label *label234
   401 op add :compute:i 22 1
   402 set :compute:x1 :compute:zx
   403 op mul *tmp59 :compute:zx :compute:zx
 
   409 op add :compute:zy *tmp64 :compute:cy
   410 op len :compute:dist :compute:zx :compute:zy
   411 jump *label55 greaterThanEq :compute:dist 64
-    * label *label238
   412 op add :compute:i 23 1
   413 set :compute:x1 :compute:zx
   414 op mul *tmp59 :compute:zx :compute:zx
 
   420 op add :compute:zy *tmp64 :compute:cy
   421 op len :compute:dist :compute:zx :compute:zy
   422 jump *label55 greaterThanEq :compute:dist 64
-    * label *label242
   423 op add :compute:i 24 1
   424 set :compute:x1 :compute:zx
   425 op mul *tmp59 :compute:zx :compute:zx
 
   431 op add :compute:zy *tmp64 :compute:cy
   432 op len :compute:dist :compute:zx :compute:zy
   433 jump *label55 greaterThanEq :compute:dist 64
-    * label *label246
   434 op add :compute:i 25 1
   435 set :compute:x1 :compute:zx
   436 op mul *tmp59 :compute:zx :compute:zx
 
   442 op add :compute:zy *tmp64 :compute:cy
   443 op len :compute:dist :compute:zx :compute:zy
   444 jump *label55 greaterThanEq :compute:dist 64
-    * label *label250
   445 op add :compute:i 26 1
   446 set :compute:x1 :compute:zx
   447 op mul *tmp59 :compute:zx :compute:zx
 
   453 op add :compute:zy *tmp64 :compute:cy
   454 op len :compute:dist :compute:zx :compute:zy
   455 jump *label55 greaterThanEq :compute:dist 64
-    * label *label254
   456 op add :compute:i 27 1
   457 set :compute:x1 :compute:zx
   458 op mul *tmp59 :compute:zx :compute:zx
 
   464 op add :compute:zy *tmp64 :compute:cy
   465 op len :compute:dist :compute:zx :compute:zy
   466 jump *label55 greaterThanEq :compute:dist 64
-    * label *label258
   467 op add :compute:i 28 1
   468 set :compute:x1 :compute:zx
   469 op mul *tmp59 :compute:zx :compute:zx
 
   475 op add :compute:zy *tmp64 :compute:cy
   476 op len :compute:dist :compute:zx :compute:zy
   477 jump *label55 greaterThanEq :compute:dist 64
-    * label *label262
   478 op add :compute:i 29 1
   479 set :compute:x1 :compute:zx
   480 op mul *tmp59 :compute:zx :compute:zx
 
   486 op add :compute:zy *tmp64 :compute:cy
   487 op len :compute:dist :compute:zx :compute:zy
   488 jump *label55 greaterThanEq :compute:dist 64
-    * label *label266
   489 op add :compute:i 30 1
   490 set :compute:x1 :compute:zx
   491 op mul *tmp59 :compute:zx :compute:zx
 
   497 op add :compute:zy *tmp64 :compute:cy
   498 op len :compute:dist :compute:zx :compute:zy
   499 jump *label55 greaterThanEq :compute:dist 64
-    * label *label270
   500 op add :compute:i 31 1
   501 set :compute:x1 :compute:zx
   502 op mul *tmp59 :compute:zx :compute:zx
 
   508 op add :compute:zy *tmp64 :compute:cy
   509 op len :compute:dist :compute:zx :compute:zy
   510 jump *label55 greaterThanEq :compute:dist 64
-    * label *label274
   511 op add :compute:i 32 1
   512 set :compute:x1 :compute:zx
   513 op mul *tmp59 :compute:zx :compute:zx
 
   519 op add :compute:zy *tmp64 :compute:cy
   520 op len :compute:dist :compute:zx :compute:zy
   521 jump *label55 greaterThanEq :compute:dist 64
-    * label *label278
   522 op add :compute:i 33 1
   523 set :compute:x1 :compute:zx
   524 op mul *tmp59 :compute:zx :compute:zx
 
   530 op add :compute:zy *tmp64 :compute:cy
   531 op len :compute:dist :compute:zx :compute:zy
   532 jump *label55 greaterThanEq :compute:dist 64
-    * label *label282
   533 op add :compute:i 34 1
   534 set :compute:x1 :compute:zx
   535 op mul *tmp59 :compute:zx :compute:zx
 
   541 op add :compute:zy *tmp64 :compute:cy
   542 op len :compute:dist :compute:zx :compute:zy
   543 jump *label55 greaterThanEq :compute:dist 64
-    * label *label286
   544 op add :compute:i 35 1
   545 set :compute:x1 :compute:zx
   546 op mul *tmp59 :compute:zx :compute:zx
 
   552 op add :compute:zy *tmp64 :compute:cy
   553 op len :compute:dist :compute:zx :compute:zy
   554 jump *label55 greaterThanEq :compute:dist 64
-    * label *label290
   555 op add :compute:i 36 1
   556 set :compute:x1 :compute:zx
   557 op mul *tmp59 :compute:zx :compute:zx
 
   563 op add :compute:zy *tmp64 :compute:cy
   564 op len :compute:dist :compute:zx :compute:zy
   565 jump *label55 greaterThanEq :compute:dist 64
-    * label *label294
   566 op add :compute:i 37 1
   567 set :compute:x1 :compute:zx
   568 op mul *tmp59 :compute:zx :compute:zx
 
   574 op add :compute:zy *tmp64 :compute:cy
   575 op len :compute:dist :compute:zx :compute:zy
   576 jump *label55 greaterThanEq :compute:dist 64
-    * label *label298
   577 op add :compute:i 38 1
   578 set :compute:x1 :compute:zx
   579 op mul *tmp59 :compute:zx :compute:zx
 
   585 op add :compute:zy *tmp64 :compute:cy
   586 op len :compute:dist :compute:zx :compute:zy
   587 jump *label55 greaterThanEq :compute:dist 64
-    * label *label302
   588 op add :compute:i 39 1
   589 set :compute:x1 :compute:zx
   590 op mul *tmp59 :compute:zx :compute:zx
 
   596 op add :compute:zy *tmp64 :compute:cy
   597 op len :compute:dist :compute:zx :compute:zy
   598 jump *label55 greaterThanEq :compute:dist 64
-    * label *label306
   599 op add :compute:i 40 1
   600 set :compute:x1 :compute:zx
   601 op mul *tmp59 :compute:zx :compute:zx
 
   607 op add :compute:zy *tmp64 :compute:cy
   608 op len :compute:dist :compute:zx :compute:zy
   609 jump *label55 greaterThanEq :compute:dist 64
-    * label *label310
   610 op add :compute:i 41 1
   611 set :compute:x1 :compute:zx
   612 op mul *tmp59 :compute:zx :compute:zx
 
   618 op add :compute:zy *tmp64 :compute:cy
   619 op len :compute:dist :compute:zx :compute:zy
   620 jump *label55 greaterThanEq :compute:dist 64
-    * label *label314
   621 op add :compute:i 42 1
   622 set :compute:x1 :compute:zx
   623 op mul *tmp59 :compute:zx :compute:zx
 
   629 op add :compute:zy *tmp64 :compute:cy
   630 op len :compute:dist :compute:zx :compute:zy
   631 jump *label55 greaterThanEq :compute:dist 64
-    * label *label318
   632 op add :compute:i 43 1
   633 set :compute:x1 :compute:zx
   634 op mul *tmp59 :compute:zx :compute:zx
 
   640 op add :compute:zy *tmp64 :compute:cy
   641 op len :compute:dist :compute:zx :compute:zy
   642 jump *label55 greaterThanEq :compute:dist 64
-    * label *label322
   643 op add :compute:i 44 1
   644 set :compute:x1 :compute:zx
   645 op mul *tmp59 :compute:zx :compute:zx
 
   651 op add :compute:zy *tmp64 :compute:cy
   652 op len :compute:dist :compute:zx :compute:zy
   653 jump *label55 greaterThanEq :compute:dist 64
-    * label *label326
   654 op add :compute:i 45 1
   655 set :compute:x1 :compute:zx
   656 op mul *tmp59 :compute:zx :compute:zx
 
   662 op add :compute:zy *tmp64 :compute:cy
   663 op len :compute:dist :compute:zx :compute:zy
   664 jump *label55 greaterThanEq :compute:dist 64
-    * label *label330
   665 op add :compute:i 46 1
   666 set :compute:x1 :compute:zx
   667 op mul *tmp59 :compute:zx :compute:zx
 
   673 op add :compute:zy *tmp64 :compute:cy
   674 op len :compute:dist :compute:zx :compute:zy
   675 jump *label55 greaterThanEq :compute:dist 64
-    * label *label334
   676 op add :compute:i 47 1
   677 set :compute:x1 :compute:zx
   678 op mul *tmp59 :compute:zx :compute:zx
 
   684 op add :compute:zy *tmp64 :compute:cy
   685 op len :compute:dist :compute:zx :compute:zy
   686 jump *label55 greaterThanEq :compute:dist 64
-    * label *label338
   687 op add :compute:i 48 1
   688 set :compute:x1 :compute:zx
   689 op mul *tmp59 :compute:zx :compute:zx
 
   695 op add :compute:zy *tmp64 :compute:cy
   696 op len :compute:dist :compute:zx :compute:zy
   697 jump *label55 greaterThanEq :compute:dist 64
-    * label *label342
   698 op add :compute:i 49 1
   699 set :compute:x1 :compute:zx
   700 op mul *tmp59 :compute:zx :compute:zx
 
   706 op add :compute:zy *tmp64 :compute:cy
   707 op len :compute:dist :compute:zx :compute:zy
   708 jump *label55 greaterThanEq :compute:dist 64
-    * label *label346
   709 op add :compute:i 50 1
   710 set :compute:x1 :compute:zx
   711 op mul *tmp59 :compute:zx :compute:zx
 
   717 op add :compute:zy *tmp64 :compute:cy
   718 op len :compute:dist :compute:zx :compute:zy
   719 jump *label55 greaterThanEq :compute:dist 64
-    * label *label350
   720 op add :compute:i 51 1
   721 set :compute:x1 :compute:zx
   722 op mul *tmp59 :compute:zx :compute:zx
 
   728 op add :compute:zy *tmp64 :compute:cy
   729 op len :compute:dist :compute:zx :compute:zy
   730 jump *label55 greaterThanEq :compute:dist 64
-    * label *label354
   731 op add :compute:i 52 1
   732 set :compute:x1 :compute:zx
   733 op mul *tmp59 :compute:zx :compute:zx
 
   739 op add :compute:zy *tmp64 :compute:cy
   740 op len :compute:dist :compute:zx :compute:zy
   741 jump *label55 greaterThanEq :compute:dist 64
-    * label *label358
   742 op add :compute:i 53 1
   743 set :compute:x1 :compute:zx
   744 op mul *tmp59 :compute:zx :compute:zx
 
   750 op add :compute:zy *tmp64 :compute:cy
   751 op len :compute:dist :compute:zx :compute:zy
   752 jump *label55 greaterThanEq :compute:dist 64
-    * label *label362
   753 op add :compute:i 54 1
   754 set :compute:x1 :compute:zx
   755 op mul *tmp59 :compute:zx :compute:zx
 
   761 op add :compute:zy *tmp64 :compute:cy
   762 op len :compute:dist :compute:zx :compute:zy
   763 jump *label55 greaterThanEq :compute:dist 64
-    * label *label366
   764 op add :compute:i 55 1
   765 set :compute:x1 :compute:zx
   766 op mul *tmp59 :compute:zx :compute:zx
 
   772 op add :compute:zy *tmp64 :compute:cy
   773 op len :compute:dist :compute:zx :compute:zy
   774 jump *label55 greaterThanEq :compute:dist 64
-    * label *label370
   775 op add :compute:i 56 1
   776 set :compute:x1 :compute:zx
   777 op mul *tmp59 :compute:zx :compute:zx
 
   783 op add :compute:zy *tmp64 :compute:cy
   784 op len :compute:dist :compute:zx :compute:zy
   785 jump *label55 greaterThanEq :compute:dist 64
-    * label *label374
   786 op add :compute:i 57 1
   787 set :compute:x1 :compute:zx
   788 op mul *tmp59 :compute:zx :compute:zx
 
   794 op add :compute:zy *tmp64 :compute:cy
   795 op len :compute:dist :compute:zx :compute:zy
   796 jump *label55 greaterThanEq :compute:dist 64
-    * label *label378
   797 op add :compute:i 58 1
   798 set :compute:x1 :compute:zx
   799 op mul *tmp59 :compute:zx :compute:zx
 
   805 op add :compute:zy *tmp64 :compute:cy
   806 op len :compute:dist :compute:zx :compute:zy
   807 jump *label55 greaterThanEq :compute:dist 64
-    * label *label382
   808 op add :compute:i 59 1
   809 set :compute:x1 :compute:zx
   810 op mul *tmp59 :compute:zx :compute:zx
 
   816 op add :compute:zy *tmp64 :compute:cy
   817 op len :compute:dist :compute:zx :compute:zy
   818 jump *label55 greaterThanEq :compute:dist 64
-    * label *label386
   819 op add :compute:i 60 1
   820 set :compute:x1 :compute:zx
   821 op mul *tmp59 :compute:zx :compute:zx
 
   827 op add :compute:zy *tmp64 :compute:cy
   828 op len :compute:dist :compute:zx :compute:zy
   829 jump *label55 greaterThanEq :compute:dist 64
-    * label *label390
   830 op add :compute:i 61 1
   831 set :compute:x1 :compute:zx
   832 op mul *tmp59 :compute:zx :compute:zx
 
   838 op add :compute:zy *tmp64 :compute:cy
   839 op len :compute:dist :compute:zx :compute:zy
   840 jump *label55 greaterThanEq :compute:dist 64
-    * label *label394
   841 op add :compute:i 62 1
   842 label *label55
   843 op mul *tmp69 .SMOOTH 63
 
   917 label *label75
   918 read *tmp130 .memory :position
   919 jump *label45 notEqual *tmp130 .PROCESSOR_ID
-    * label *label79
   920 read *tmp1 .memory 65
   921 jump *label40 notEqual .stop *tmp1
-    * label *label81
   922 op add :y :y 1
   923 jump *label102 lessThan :y 176
   924 label *label45

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
   853 label *label46
   854 jump *label61 equal .SMOOTH false
   855 set :drawPixel:color %[black]
-    * jump *label64 equal *tmp41 63
+  856 jump *label62 equal *tmp41 63
   857 jump *label66 notEqual .PALETTE 2
   858 op sub *tmp82 32 *tmp41
   859 op abs *tmp83 *tmp82
 
   866 op div *tmp95 *tmp83 63.75
   867 op add :drawPixel:b 0.47058823529411764 *tmp95
   868 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label65 always
+  869 jump *label62 always
   870 label *label66
   871 jump *label68 notEqual .PALETTE 3
   872 op div *tmp99 *tmp41 0.175
 
   877 op div *tmp107 *tmp105 63.75
   878 op add :drawPixel:b 0.39215686274509803 *tmp107
   879 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label65 always
+  880 jump *label62 always
   881 label *label68
   882 jump *label70 notEqual .PALETTE 4
   883 op div :drawPixel:r *tmp41 63.75
   884 op div *tmp113 *tmp41 170
   885 op add :drawPixel:g 96 *tmp113
   886 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label65 always
+  887 jump *label62 always
   888 label *label70
   889 op div *tmp117 *tmp41 63.75
   890 op sub :drawPixel:r 1 *tmp117

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-5 instructions):
 
    49 jump *label414 notEqual *tmp144 .PROCESSOR_ID
    50 write 0 .memory .PROC_STATE_INDEX
    51 jump *label419 always
-    * jump *label417 always
    52 label *label414
    53 read *tmp150 .memory .PROC_ID_INDEX
    54 jump *label415 notEqual *tmp150 0
    55 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    56 write 0 .memory .PROC_STATE_INDEX
    57 jump *label419 always
-    * jump *label416 always
    58 label *label415
    59 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    60 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
    74 jump *label424 notEqual *tmp144 .PROCESSOR_ID
    75 write *tmp0 .memory .PROC_STATE_INDEX
    76 jump *label429 always
-    * jump *label427 always
    77 label *label424
    78 read *tmp150 .memory .PROC_ID_INDEX
    79 jump *label425 notEqual *tmp150 0
    80 write .PROCESSOR_ID .memory .PROC_ID_INDEX
    81 write *tmp0 .memory .PROC_STATE_INDEX
    82 jump *label429 always
-    * jump *label426 always
    83 label *label425
    84 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    85 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
 
   885 op div *tmp117 *tmp41 63.75
   886 op sub :drawPixel:r 1 *tmp117
   887 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * label *label65
-    * label *label64
   888 jump *label62 always
   889 label *label61
   890 read :drawPixel:color .memory *tmp41
 
   935 drawflush .display
   936 set .localBuffer 0
   937 jump *label30 always
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1:
 
    58 label *label415
    59 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    60 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label416
-    * label *label417
    61 jump *label413 lessThan .PROC_STATE_INDEX 512
    62 label *label419
    63 read *tmp0 .memory 64
 
    81 label *label425
    82 op add .PROC_ID_INDEX .PROC_ID_INDEX 2
    83 op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2
-    * label *label426
-    * label *label427
    84 jump *label423 lessThan .PROC_STATE_INDEX 512
    85 label *label429
    86 read .ZOOM .memory 68

Modifications by Final phase, Print Merging, iteration 1 (-7 instructions):
 
    27 set .memory :findLinkedBlocks:variable
    28 jump *label100 greaterThan :findLinkedBlocks:n 0
    29 label *label13
-    * print "\n"
-    * print "Display"
-    * print ":"
-    * print " "
-    * print .display
+   30 print "\nDisplay: {0}\nMemory: "
+   31 format .display
    32 op and :findLinkedBlocks:foundAll 1 .display
-    * print "\n"
-    * print "Memory"
-    * print ":"
-    * print " "
    33 print .memory
    34 op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll .memory
    35 printflush null

Final code before resolving virtual instructions:

    0:  op mul *tmp11 10000 @thisy                                   mandelbrot-compute.mnd: var PROCESSOR_ID = @this.@x + 10000 * @this.@y;
    1:  op add .PROCESSOR_ID @thisx *tmp11                           ...
    2:  set .PROC_ID_INDEX 334                                       mandelbrot-compute.mnd: var PROC_ID_INDEX = PROCESSORS;
    3:  set .PROC_STATE_INDEX 335                                    mandelbrot-compute.mnd: var PROC_STATE_INDEX = PROCESSORS + 1;
    4:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
    5:  set .localBuffer 0                                           mandelbrot-compute.mnd: var localBuffer = 0;
        label *label3                                                *blocks: do
    6:  set .display null                                            *blocks: for requested, name, out variable, required in linkMap do
    7:  set .memory null                                             ...
    8:  print "Mandelbrot Generator"                                 *blocks: print(title);
    9:  set :findLinkedBlocks:n @links                               *blocks: var n = @links;
   10:  jump *label13 lessThanEq :findLinkedBlocks:n 0               *blocks: while n > 0 do
        label *label100                                              ...
   11:  op sub :findLinkedBlocks:n :findLinkedBlocks:n 1             *blocks: var block = getlink(--n);
   12:  getlink :findLinkedBlocks:block :findLinkedBlocks:n          ...
   13:  print "\nFound: "                                            *blocks: print("\nFound: ", block);
   14:  print :findLinkedBlocks:block                                ...
   15:  sensor :findLinkedBlocks:type :findLinkedBlocks:block @type  *blocks: var type = block.@type;
   16:  set :findLinkedBlocks:variable .display                      *blocks: for requested, name, out variable, required in linkMap do
   17:  jump *label117 notEqual @large-logic-display :findLinkedBloc *blocks: if requested == type then
   18:  set :findLinkedBlocks:variable :findLinkedBlocks:block       *blocks: variable = block;
        label *label117                                              *blocks: if requested == type then
   19:  set .display :findLinkedBlocks:variable                      *blocks: for requested, name, out variable, required in linkMap do
   20:  set :findLinkedBlocks:variable .memory                       ...
   21:  jump *label125 notEqual @memory-bank :findLinkedBlocks:type  *blocks: if requested == type then
   22:  set :findLinkedBlocks:variable :findLinkedBlocks:block       *blocks: variable = block;
        label *label125                                              *blocks: if requested == type then
   23:  set .memory :findLinkedBlocks:variable                       *blocks: for requested, name, out variable, required in linkMap do
   24:  jump *label100 greaterThan :findLinkedBlocks:n 0             *blocks: while n > 0 do
        label *label13                                               ...
   25:  print "\nDisplay: {0}\nMemory: "                             *blocks: print($"\n$name: $variable");
   26:  format .display                                              ...
   27:  op and :findLinkedBlocks:foundAll 1 .display                 *blocks: if required then foundAll &= variable; end;
   28:  print .memory                                                *blocks: print($"\n$name: $variable");
   29:  op and :findLinkedBlocks:foundAll :findLinkedBlocks:foundAll *blocks: if required then foundAll &= variable; end;
   30:  printflush null                                              *blocks: printflush(message);
   31:  jump *label3 equal :findLinkedBlocks:foundAll false          *blocks: do
        label *label30                                               mandelbrot-compute.mnd: while true do
        label *label33                                               mandelbrot-compute.mnd: do
   32:  jump *label419 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label413                                              ...
   33:  read *tmp144 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   34:  jump *label414 notEqual *tmp144 .PROCESSOR_ID                ...
   35:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   36:  jump *label419 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label414                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   37:  read *tmp150 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   38:  jump *label415 notEqual *tmp150 0                            ...
   39:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   40:  write 0 .memory .PROC_STATE_INDEX                            mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   41:  jump *label419 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label415                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   42:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   43:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   44:  jump *label413 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label419                                              ...
   45:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: while start == $START;
   46:  jump *label33 equal .start *tmp0                             mandelbrot-compute.mnd: do
   47:  read *tmp0 .memory 64                                        mandelbrot-compute.mnd: start = $START;
   48:  set .start *tmp0                                             ...
   49:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: stop = $STOP;
   50:  set .stop *tmp1                                              ...
   51:  jump *label429 greaterThanEq .PROC_STATE_INDEX 512           mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label423                                              ...
   52:  read *tmp144 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   53:  jump *label424 notEqual *tmp144 .PROCESSOR_ID                ...
   54:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   55:  jump *label429 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label424                                              mandelbrot-compute.mnd: if memory[PROC_ID_INDEX] == PROCESSOR_ID then
   56:  read *tmp150 .memory .PROC_ID_INDEX                          mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   57:  jump *label425 notEqual *tmp150 0                            ...
   58:  write .PROCESSOR_ID .memory .PROC_ID_INDEX                   mandelbrot-compute.mnd: memory[PROC_ID_INDEX] = PROCESSOR_ID;
   59:  write *tmp0 .memory .PROC_STATE_INDEX                        mandelbrot-compute.mnd: memory[PROC_STATE_INDEX] = state;
   60:  jump *label429 always 0 0                                    mandelbrot-compute.mnd: break;
        label *label425                                              mandelbrot-compute.mnd: elsif memory[PROC_ID_INDEX] == 0 then
   61:  op add .PROC_ID_INDEX .PROC_ID_INDEX 2                       mandelbrot-compute.mnd: PROC_ID_INDEX += 2;
   62:  op add .PROC_STATE_INDEX .PROC_STATE_INDEX 2                 mandelbrot-compute.mnd: PROC_STATE_INDEX += 2;
   63:  jump *label423 lessThan .PROC_STATE_INDEX 512                mandelbrot-compute.mnd: while PROC_STATE_INDEX < 512 do
        label *label429                                              ...
   64:  read .ZOOM .memory 68                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   65:  op div *tmp26 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   66:  read *tmp2 .memory 66                                        ...
   67:  op add .OFFSET_X *tmp26 *tmp2                                ...
   68:  read *tmp3 .memory 67                                        mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   69:  op add .OFFSET_Y *tmp26 *tmp3                                ...
   70:  read .JULIA .memory 69                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   71:  read .JULIA_X .memory 70                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   72:  read .JULIA_Y .memory 71                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   73:  read .PALETTE .memory 72                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   74:  op greaterThan .SMOOTH .PALETTE 1                            mandelbrot-compute.mnd: SMOOTH   = PALETTE > 1;
   75:  set :line 8                                                  mandelbrot-compute.mnd: var line = 8;
   76:  set :increment 8                                             mandelbrot-compute.mnd: var increment = 8;
   77:  set :next_increment 16                                       mandelbrot-compute.mnd: var next_increment = 16;
   78:  op rand *tmp31 0.1 0                                         mandelbrot-compute.mnd: wait(rand(0.1));
   79:  wait *tmp31                                                  ...
   80:  set :lines 0                                                 mandelbrot-compute.mnd: MasterLoop:
        label *label101                                              ...
   81:  op mul *tmp32 17 :line                                       mandelbrot-compute.mnd: var x = (SKIP * line) % DISPLAY_SIZE_LARGE;
   82:  op mod :x *tmp32 176                                         ...
   83:  op add :position :x 158                                      mandelbrot-compute.mnd: var position = x + SLOTS;
   84:  read *tmp36 .memory :position                                mandelbrot-compute.mnd: if memory[position] == 0 then
   85:  jump *label41 notEqual *tmp36 0                              ...
   86:  write .PROCESSOR_ID .memory :position                        mandelbrot-compute.mnd: memory[position] = PROCESSOR_ID;
   87:  set :y 0                                                     mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
        label *label102                                              ...
   88:  op div *tmp42 :x .ZOOM                                       mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   89:  op add :compute:zx *tmp42 .OFFSET_X                          ...
   90:  op div *tmp44 :y .ZOOM                                       mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
   91:  op add :compute:zy *tmp44 .OFFSET_Y                          ...
   92:  jump *label47 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
   93:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
   94:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
   95:  jump *label48 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label47                                               ...
   96:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
   97:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
   98:  op sub *tmp47 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
   99:  op len :compute:p *tmp47 :compute:zy                         ...
  100:  op mul *tmp49 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  101:  op mul *tmp50 *tmp49 :compute:p                              ...
  102:  op sub *tmp51 :compute:p *tmp50                              ...
  103:  op add *tmp52 *tmp51 0.25                                    ...
  104:  jump *label49 greaterThan :compute:zx *tmp52                 ...
  105:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  106:  jump *label46 always 0 0                                     ...
        label *label49                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  107:  op add *tmp55 :compute:zx 1                                  mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  108:  op len *tmp56 *tmp55 :compute:zy                             ...
  109:  jump *label51 greaterThan *tmp56 0.25                        ...
  110:  set *tmp41 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  111:  jump *label46 always 0 0                                     ...
        label *label51                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label48                                               mandelbrot-compute.mnd: if JULIA then
  112:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  113:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  114:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  115:  op mul *tmp60 :compute:zy :compute:zy                        ...
  116:  op sub *tmp61 *tmp59 *tmp60                                  ...
  117:  op add :compute:zx *tmp61 :compute:cx                        ...
  118:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  119:  op mul *tmp64 *tmp63 :compute:zy                             ...
  120:  op add :compute:zy *tmp64 :compute:cy                        ...
  121:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  122:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  123:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  124:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  125:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  126:  op mul *tmp60 :compute:zy :compute:zy                        ...
  127:  op sub *tmp61 *tmp59 *tmp60                                  ...
  128:  op add :compute:zx *tmp61 :compute:cx                        ...
  129:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  130:  op mul *tmp64 *tmp63 :compute:zy                             ...
  131:  op add :compute:zy *tmp64 :compute:cy                        ...
  132:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  133:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  134:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  135:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  136:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  137:  op mul *tmp60 :compute:zy :compute:zy                        ...
  138:  op sub *tmp61 *tmp59 *tmp60                                  ...
  139:  op add :compute:zx *tmp61 :compute:cx                        ...
  140:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  141:  op mul *tmp64 *tmp63 :compute:zy                             ...
  142:  op add :compute:zy *tmp64 :compute:cy                        ...
  143:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  144:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  145:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  146:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  147:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  148:  op mul *tmp60 :compute:zy :compute:zy                        ...
  149:  op sub *tmp61 *tmp59 *tmp60                                  ...
  150:  op add :compute:zx *tmp61 :compute:cx                        ...
  151:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  152:  op mul *tmp64 *tmp63 :compute:zy                             ...
  153:  op add :compute:zy *tmp64 :compute:cy                        ...
  154:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  155:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  156:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  157:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  158:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  159:  op mul *tmp60 :compute:zy :compute:zy                        ...
  160:  op sub *tmp61 *tmp59 *tmp60                                  ...
  161:  op add :compute:zx *tmp61 :compute:cx                        ...
  162:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  163:  op mul *tmp64 *tmp63 :compute:zy                             ...
  164:  op add :compute:zy *tmp64 :compute:cy                        ...
  165:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  166:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  167:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  168:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  169:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  170:  op mul *tmp60 :compute:zy :compute:zy                        ...
  171:  op sub *tmp61 *tmp59 *tmp60                                  ...
  172:  op add :compute:zx *tmp61 :compute:cx                        ...
  173:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  174:  op mul *tmp64 *tmp63 :compute:zy                             ...
  175:  op add :compute:zy *tmp64 :compute:cy                        ...
  176:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  177:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  178:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  179:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  180:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  181:  op mul *tmp60 :compute:zy :compute:zy                        ...
  182:  op sub *tmp61 *tmp59 *tmp60                                  ...
  183:  op add :compute:zx *tmp61 :compute:cx                        ...
  184:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  185:  op mul *tmp64 *tmp63 :compute:zy                             ...
  186:  op add :compute:zy *tmp64 :compute:cy                        ...
  187:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  188:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  189:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  190:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  191:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  192:  op mul *tmp60 :compute:zy :compute:zy                        ...
  193:  op sub *tmp61 *tmp59 *tmp60                                  ...
  194:  op add :compute:zx *tmp61 :compute:cx                        ...
  195:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  196:  op mul *tmp64 *tmp63 :compute:zy                             ...
  197:  op add :compute:zy *tmp64 :compute:cy                        ...
  198:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  199:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  200:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  201:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  202:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  203:  op mul *tmp60 :compute:zy :compute:zy                        ...
  204:  op sub *tmp61 *tmp59 *tmp60                                  ...
  205:  op add :compute:zx *tmp61 :compute:cx                        ...
  206:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  207:  op mul *tmp64 *tmp63 :compute:zy                             ...
  208:  op add :compute:zy *tmp64 :compute:cy                        ...
  209:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  210:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  211:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  212:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  213:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  214:  op mul *tmp60 :compute:zy :compute:zy                        ...
  215:  op sub *tmp61 *tmp59 *tmp60                                  ...
  216:  op add :compute:zx *tmp61 :compute:cx                        ...
  217:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  218:  op mul *tmp64 *tmp63 :compute:zy                             ...
  219:  op add :compute:zy *tmp64 :compute:cy                        ...
  220:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  221:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  222:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  223:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  224:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  225:  op mul *tmp60 :compute:zy :compute:zy                        ...
  226:  op sub *tmp61 *tmp59 *tmp60                                  ...
  227:  op add :compute:zx *tmp61 :compute:cx                        ...
  228:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  229:  op mul *tmp64 *tmp63 :compute:zy                             ...
  230:  op add :compute:zy *tmp64 :compute:cy                        ...
  231:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  232:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  233:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  234:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  235:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  236:  op mul *tmp60 :compute:zy :compute:zy                        ...
  237:  op sub *tmp61 *tmp59 *tmp60                                  ...
  238:  op add :compute:zx *tmp61 :compute:cx                        ...
  239:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  240:  op mul *tmp64 *tmp63 :compute:zy                             ...
  241:  op add :compute:zy *tmp64 :compute:cy                        ...
  242:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  243:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  244:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  245:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  246:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  247:  op mul *tmp60 :compute:zy :compute:zy                        ...
  248:  op sub *tmp61 *tmp59 *tmp60                                  ...
  249:  op add :compute:zx *tmp61 :compute:cx                        ...
  250:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  251:  op mul *tmp64 *tmp63 :compute:zy                             ...
  252:  op add :compute:zy *tmp64 :compute:cy                        ...
  253:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  254:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  255:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  256:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  257:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  258:  op mul *tmp60 :compute:zy :compute:zy                        ...
  259:  op sub *tmp61 *tmp59 *tmp60                                  ...
  260:  op add :compute:zx *tmp61 :compute:cx                        ...
  261:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  262:  op mul *tmp64 *tmp63 :compute:zy                             ...
  263:  op add :compute:zy *tmp64 :compute:cy                        ...
  264:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  265:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  266:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  267:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  268:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  269:  op mul *tmp60 :compute:zy :compute:zy                        ...
  270:  op sub *tmp61 *tmp59 *tmp60                                  ...
  271:  op add :compute:zx *tmp61 :compute:cx                        ...
  272:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  273:  op mul *tmp64 *tmp63 :compute:zy                             ...
  274:  op add :compute:zy *tmp64 :compute:cy                        ...
  275:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  276:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  277:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  278:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  279:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  280:  op mul *tmp60 :compute:zy :compute:zy                        ...
  281:  op sub *tmp61 *tmp59 *tmp60                                  ...
  282:  op add :compute:zx *tmp61 :compute:cx                        ...
  283:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  284:  op mul *tmp64 *tmp63 :compute:zy                             ...
  285:  op add :compute:zy *tmp64 :compute:cy                        ...
  286:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  287:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  288:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  289:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  290:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  291:  op mul *tmp60 :compute:zy :compute:zy                        ...
  292:  op sub *tmp61 *tmp59 *tmp60                                  ...
  293:  op add :compute:zx *tmp61 :compute:cx                        ...
  294:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  295:  op mul *tmp64 *tmp63 :compute:zy                             ...
  296:  op add :compute:zy *tmp64 :compute:cy                        ...
  297:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  298:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  299:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  300:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  301:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  302:  op mul *tmp60 :compute:zy :compute:zy                        ...
  303:  op sub *tmp61 *tmp59 *tmp60                                  ...
  304:  op add :compute:zx *tmp61 :compute:cx                        ...
  305:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  306:  op mul *tmp64 *tmp63 :compute:zy                             ...
  307:  op add :compute:zy *tmp64 :compute:cy                        ...
  308:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  309:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  310:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  311:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  312:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  313:  op mul *tmp60 :compute:zy :compute:zy                        ...
  314:  op sub *tmp61 *tmp59 *tmp60                                  ...
  315:  op add :compute:zx *tmp61 :compute:cx                        ...
  316:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  317:  op mul *tmp64 *tmp63 :compute:zy                             ...
  318:  op add :compute:zy *tmp64 :compute:cy                        ...
  319:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  320:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  321:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  322:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  323:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  324:  op mul *tmp60 :compute:zy :compute:zy                        ...
  325:  op sub *tmp61 *tmp59 *tmp60                                  ...
  326:  op add :compute:zx *tmp61 :compute:cx                        ...
  327:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  328:  op mul *tmp64 *tmp63 :compute:zy                             ...
  329:  op add :compute:zy *tmp64 :compute:cy                        ...
  330:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  331:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  332:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  333:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  334:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  335:  op mul *tmp60 :compute:zy :compute:zy                        ...
  336:  op sub *tmp61 *tmp59 *tmp60                                  ...
  337:  op add :compute:zx *tmp61 :compute:cx                        ...
  338:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  339:  op mul *tmp64 *tmp63 :compute:zy                             ...
  340:  op add :compute:zy *tmp64 :compute:cy                        ...
  341:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  342:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  343:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  344:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  345:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  346:  op mul *tmp60 :compute:zy :compute:zy                        ...
  347:  op sub *tmp61 *tmp59 *tmp60                                  ...
  348:  op add :compute:zx *tmp61 :compute:cx                        ...
  349:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  350:  op mul *tmp64 *tmp63 :compute:zy                             ...
  351:  op add :compute:zy *tmp64 :compute:cy                        ...
  352:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  353:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  354:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  355:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  356:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  357:  op mul *tmp60 :compute:zy :compute:zy                        ...
  358:  op sub *tmp61 *tmp59 *tmp60                                  ...
  359:  op add :compute:zx *tmp61 :compute:cx                        ...
  360:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  361:  op mul *tmp64 *tmp63 :compute:zy                             ...
  362:  op add :compute:zy *tmp64 :compute:cy                        ...
  363:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  364:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  365:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  366:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  367:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  368:  op mul *tmp60 :compute:zy :compute:zy                        ...
  369:  op sub *tmp61 *tmp59 *tmp60                                  ...
  370:  op add :compute:zx *tmp61 :compute:cx                        ...
  371:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  372:  op mul *tmp64 *tmp63 :compute:zy                             ...
  373:  op add :compute:zy *tmp64 :compute:cy                        ...
  374:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  375:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  376:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  377:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  378:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  379:  op mul *tmp60 :compute:zy :compute:zy                        ...
  380:  op sub *tmp61 *tmp59 *tmp60                                  ...
  381:  op add :compute:zx *tmp61 :compute:cx                        ...
  382:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  383:  op mul *tmp64 *tmp63 :compute:zy                             ...
  384:  op add :compute:zy *tmp64 :compute:cy                        ...
  385:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  386:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  387:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  388:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  389:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  390:  op mul *tmp60 :compute:zy :compute:zy                        ...
  391:  op sub *tmp61 *tmp59 *tmp60                                  ...
  392:  op add :compute:zx *tmp61 :compute:cx                        ...
  393:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  394:  op mul *tmp64 *tmp63 :compute:zy                             ...
  395:  op add :compute:zy *tmp64 :compute:cy                        ...
  396:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  397:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  398:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  399:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  400:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  401:  op mul *tmp60 :compute:zy :compute:zy                        ...
  402:  op sub *tmp61 *tmp59 *tmp60                                  ...
  403:  op add :compute:zx *tmp61 :compute:cx                        ...
  404:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  405:  op mul *tmp64 *tmp63 :compute:zy                             ...
  406:  op add :compute:zy *tmp64 :compute:cy                        ...
  407:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  408:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  409:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  410:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  411:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  412:  op mul *tmp60 :compute:zy :compute:zy                        ...
  413:  op sub *tmp61 *tmp59 *tmp60                                  ...
  414:  op add :compute:zx *tmp61 :compute:cx                        ...
  415:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  416:  op mul *tmp64 *tmp63 :compute:zy                             ...
  417:  op add :compute:zy *tmp64 :compute:cy                        ...
  418:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  419:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  420:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  421:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  422:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  423:  op mul *tmp60 :compute:zy :compute:zy                        ...
  424:  op sub *tmp61 *tmp59 *tmp60                                  ...
  425:  op add :compute:zx *tmp61 :compute:cx                        ...
  426:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  427:  op mul *tmp64 *tmp63 :compute:zy                             ...
  428:  op add :compute:zy *tmp64 :compute:cy                        ...
  429:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  430:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  431:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  432:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  433:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  434:  op mul *tmp60 :compute:zy :compute:zy                        ...
  435:  op sub *tmp61 *tmp59 *tmp60                                  ...
  436:  op add :compute:zx *tmp61 :compute:cx                        ...
  437:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  438:  op mul *tmp64 *tmp63 :compute:zy                             ...
  439:  op add :compute:zy *tmp64 :compute:cy                        ...
  440:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  441:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  442:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  443:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  444:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  445:  op mul *tmp60 :compute:zy :compute:zy                        ...
  446:  op sub *tmp61 *tmp59 *tmp60                                  ...
  447:  op add :compute:zx *tmp61 :compute:cx                        ...
  448:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  449:  op mul *tmp64 *tmp63 :compute:zy                             ...
  450:  op add :compute:zy *tmp64 :compute:cy                        ...
  451:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  452:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  453:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  454:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  455:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  456:  op mul *tmp60 :compute:zy :compute:zy                        ...
  457:  op sub *tmp61 *tmp59 *tmp60                                  ...
  458:  op add :compute:zx *tmp61 :compute:cx                        ...
  459:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  460:  op mul *tmp64 *tmp63 :compute:zy                             ...
  461:  op add :compute:zy *tmp64 :compute:cy                        ...
  462:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  463:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  464:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  465:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  466:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  467:  op mul *tmp60 :compute:zy :compute:zy                        ...
  468:  op sub *tmp61 *tmp59 *tmp60                                  ...
  469:  op add :compute:zx *tmp61 :compute:cx                        ...
  470:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  471:  op mul *tmp64 *tmp63 :compute:zy                             ...
  472:  op add :compute:zy *tmp64 :compute:cy                        ...
  473:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  474:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  475:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  476:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  477:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  478:  op mul *tmp60 :compute:zy :compute:zy                        ...
  479:  op sub *tmp61 *tmp59 *tmp60                                  ...
  480:  op add :compute:zx *tmp61 :compute:cx                        ...
  481:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  482:  op mul *tmp64 *tmp63 :compute:zy                             ...
  483:  op add :compute:zy *tmp64 :compute:cy                        ...
  484:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  485:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  486:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  487:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  488:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  489:  op mul *tmp60 :compute:zy :compute:zy                        ...
  490:  op sub *tmp61 *tmp59 *tmp60                                  ...
  491:  op add :compute:zx *tmp61 :compute:cx                        ...
  492:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  493:  op mul *tmp64 *tmp63 :compute:zy                             ...
  494:  op add :compute:zy *tmp64 :compute:cy                        ...
  495:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  496:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  497:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  498:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  499:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  500:  op mul *tmp60 :compute:zy :compute:zy                        ...
  501:  op sub *tmp61 *tmp59 *tmp60                                  ...
  502:  op add :compute:zx *tmp61 :compute:cx                        ...
  503:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  504:  op mul *tmp64 *tmp63 :compute:zy                             ...
  505:  op add :compute:zy *tmp64 :compute:cy                        ...
  506:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  507:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  508:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  509:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  510:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  511:  op mul *tmp60 :compute:zy :compute:zy                        ...
  512:  op sub *tmp61 *tmp59 *tmp60                                  ...
  513:  op add :compute:zx *tmp61 :compute:cx                        ...
  514:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  515:  op mul *tmp64 *tmp63 :compute:zy                             ...
  516:  op add :compute:zy *tmp64 :compute:cy                        ...
  517:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  518:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  519:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  520:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  521:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  522:  op mul *tmp60 :compute:zy :compute:zy                        ...
  523:  op sub *tmp61 *tmp59 *tmp60                                  ...
  524:  op add :compute:zx *tmp61 :compute:cx                        ...
  525:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  526:  op mul *tmp64 *tmp63 :compute:zy                             ...
  527:  op add :compute:zy *tmp64 :compute:cy                        ...
  528:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  529:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  530:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  531:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  532:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  533:  op mul *tmp60 :compute:zy :compute:zy                        ...
  534:  op sub *tmp61 *tmp59 *tmp60                                  ...
  535:  op add :compute:zx *tmp61 :compute:cx                        ...
  536:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  537:  op mul *tmp64 *tmp63 :compute:zy                             ...
  538:  op add :compute:zy *tmp64 :compute:cy                        ...
  539:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  540:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  541:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  542:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  543:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  544:  op mul *tmp60 :compute:zy :compute:zy                        ...
  545:  op sub *tmp61 *tmp59 *tmp60                                  ...
  546:  op add :compute:zx *tmp61 :compute:cx                        ...
  547:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  548:  op mul *tmp64 *tmp63 :compute:zy                             ...
  549:  op add :compute:zy *tmp64 :compute:cy                        ...
  550:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  551:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  552:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  553:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  554:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  555:  op mul *tmp60 :compute:zy :compute:zy                        ...
  556:  op sub *tmp61 *tmp59 *tmp60                                  ...
  557:  op add :compute:zx *tmp61 :compute:cx                        ...
  558:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  559:  op mul *tmp64 *tmp63 :compute:zy                             ...
  560:  op add :compute:zy *tmp64 :compute:cy                        ...
  561:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  562:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  563:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  564:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  565:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  566:  op mul *tmp60 :compute:zy :compute:zy                        ...
  567:  op sub *tmp61 *tmp59 *tmp60                                  ...
  568:  op add :compute:zx *tmp61 :compute:cx                        ...
  569:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  570:  op mul *tmp64 *tmp63 :compute:zy                             ...
  571:  op add :compute:zy *tmp64 :compute:cy                        ...
  572:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  573:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  574:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  575:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  576:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  577:  op mul *tmp60 :compute:zy :compute:zy                        ...
  578:  op sub *tmp61 *tmp59 *tmp60                                  ...
  579:  op add :compute:zx *tmp61 :compute:cx                        ...
  580:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  581:  op mul *tmp64 *tmp63 :compute:zy                             ...
  582:  op add :compute:zy *tmp64 :compute:cy                        ...
  583:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  584:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  585:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  586:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  587:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  588:  op mul *tmp60 :compute:zy :compute:zy                        ...
  589:  op sub *tmp61 *tmp59 *tmp60                                  ...
  590:  op add :compute:zx *tmp61 :compute:cx                        ...
  591:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  592:  op mul *tmp64 *tmp63 :compute:zy                             ...
  593:  op add :compute:zy *tmp64 :compute:cy                        ...
  594:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  595:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  596:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  597:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  598:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  599:  op mul *tmp60 :compute:zy :compute:zy                        ...
  600:  op sub *tmp61 *tmp59 *tmp60                                  ...
  601:  op add :compute:zx *tmp61 :compute:cx                        ...
  602:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  603:  op mul *tmp64 *tmp63 :compute:zy                             ...
  604:  op add :compute:zy *tmp64 :compute:cy                        ...
  605:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  606:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  607:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  608:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  609:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  610:  op mul *tmp60 :compute:zy :compute:zy                        ...
  611:  op sub *tmp61 *tmp59 *tmp60                                  ...
  612:  op add :compute:zx *tmp61 :compute:cx                        ...
  613:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  614:  op mul *tmp64 *tmp63 :compute:zy                             ...
  615:  op add :compute:zy *tmp64 :compute:cy                        ...
  616:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  617:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  618:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  619:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  620:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  621:  op mul *tmp60 :compute:zy :compute:zy                        ...
  622:  op sub *tmp61 *tmp59 *tmp60                                  ...
  623:  op add :compute:zx *tmp61 :compute:cx                        ...
  624:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  625:  op mul *tmp64 *tmp63 :compute:zy                             ...
  626:  op add :compute:zy *tmp64 :compute:cy                        ...
  627:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  628:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  629:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  630:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  631:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  632:  op mul *tmp60 :compute:zy :compute:zy                        ...
  633:  op sub *tmp61 *tmp59 *tmp60                                  ...
  634:  op add :compute:zx *tmp61 :compute:cx                        ...
  635:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  636:  op mul *tmp64 *tmp63 :compute:zy                             ...
  637:  op add :compute:zy *tmp64 :compute:cy                        ...
  638:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  639:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  640:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  641:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  642:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  643:  op mul *tmp60 :compute:zy :compute:zy                        ...
  644:  op sub *tmp61 *tmp59 *tmp60                                  ...
  645:  op add :compute:zx *tmp61 :compute:cx                        ...
  646:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  647:  op mul *tmp64 *tmp63 :compute:zy                             ...
  648:  op add :compute:zy *tmp64 :compute:cy                        ...
  649:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  650:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  651:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  652:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  653:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  654:  op mul *tmp60 :compute:zy :compute:zy                        ...
  655:  op sub *tmp61 *tmp59 *tmp60                                  ...
  656:  op add :compute:zx *tmp61 :compute:cx                        ...
  657:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  658:  op mul *tmp64 *tmp63 :compute:zy                             ...
  659:  op add :compute:zy *tmp64 :compute:cy                        ...
  660:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  661:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  662:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  663:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  664:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  665:  op mul *tmp60 :compute:zy :compute:zy                        ...
  666:  op sub *tmp61 *tmp59 *tmp60                                  ...
  667:  op add :compute:zx *tmp61 :compute:cx                        ...
  668:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  669:  op mul *tmp64 *tmp63 :compute:zy                             ...
  670:  op add :compute:zy *tmp64 :compute:cy                        ...
  671:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  672:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  673:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  674:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  675:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  676:  op mul *tmp60 :compute:zy :compute:zy                        ...
  677:  op sub *tmp61 *tmp59 *tmp60                                  ...
  678:  op add :compute:zx *tmp61 :compute:cx                        ...
  679:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  680:  op mul *tmp64 *tmp63 :compute:zy                             ...
  681:  op add :compute:zy *tmp64 :compute:cy                        ...
  682:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  683:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  684:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  685:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  686:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  687:  op mul *tmp60 :compute:zy :compute:zy                        ...
  688:  op sub *tmp61 *tmp59 *tmp60                                  ...
  689:  op add :compute:zx *tmp61 :compute:cx                        ...
  690:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  691:  op mul *tmp64 *tmp63 :compute:zy                             ...
  692:  op add :compute:zy *tmp64 :compute:cy                        ...
  693:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  694:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  695:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  696:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  697:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  698:  op mul *tmp60 :compute:zy :compute:zy                        ...
  699:  op sub *tmp61 *tmp59 *tmp60                                  ...
  700:  op add :compute:zx *tmp61 :compute:cx                        ...
  701:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  702:  op mul *tmp64 *tmp63 :compute:zy                             ...
  703:  op add :compute:zy *tmp64 :compute:cy                        ...
  704:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  705:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  706:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  707:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  708:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  709:  op mul *tmp60 :compute:zy :compute:zy                        ...
  710:  op sub *tmp61 *tmp59 *tmp60                                  ...
  711:  op add :compute:zx *tmp61 :compute:cx                        ...
  712:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  713:  op mul *tmp64 *tmp63 :compute:zy                             ...
  714:  op add :compute:zy *tmp64 :compute:cy                        ...
  715:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  716:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  717:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  718:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  719:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  720:  op mul *tmp60 :compute:zy :compute:zy                        ...
  721:  op sub *tmp61 *tmp59 *tmp60                                  ...
  722:  op add :compute:zx *tmp61 :compute:cx                        ...
  723:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  724:  op mul *tmp64 *tmp63 :compute:zy                             ...
  725:  op add :compute:zy *tmp64 :compute:cy                        ...
  726:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  727:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  728:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  729:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  730:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  731:  op mul *tmp60 :compute:zy :compute:zy                        ...
  732:  op sub *tmp61 *tmp59 *tmp60                                  ...
  733:  op add :compute:zx *tmp61 :compute:cx                        ...
  734:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  735:  op mul *tmp64 *tmp63 :compute:zy                             ...
  736:  op add :compute:zy *tmp64 :compute:cy                        ...
  737:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  738:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  739:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  740:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  741:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  742:  op mul *tmp60 :compute:zy :compute:zy                        ...
  743:  op sub *tmp61 *tmp59 *tmp60                                  ...
  744:  op add :compute:zx *tmp61 :compute:cx                        ...
  745:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  746:  op mul *tmp64 *tmp63 :compute:zy                             ...
  747:  op add :compute:zy *tmp64 :compute:cy                        ...
  748:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  749:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  750:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  751:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  752:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  753:  op mul *tmp60 :compute:zy :compute:zy                        ...
  754:  op sub *tmp61 *tmp59 *tmp60                                  ...
  755:  op add :compute:zx *tmp61 :compute:cx                        ...
  756:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  757:  op mul *tmp64 *tmp63 :compute:zy                             ...
  758:  op add :compute:zy *tmp64 :compute:cy                        ...
  759:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  760:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  761:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  762:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  763:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  764:  op mul *tmp60 :compute:zy :compute:zy                        ...
  765:  op sub *tmp61 *tmp59 *tmp60                                  ...
  766:  op add :compute:zx *tmp61 :compute:cx                        ...
  767:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  768:  op mul *tmp64 *tmp63 :compute:zy                             ...
  769:  op add :compute:zy *tmp64 :compute:cy                        ...
  770:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  771:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  772:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  773:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  774:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  775:  op mul *tmp60 :compute:zy :compute:zy                        ...
  776:  op sub *tmp61 *tmp59 *tmp60                                  ...
  777:  op add :compute:zx *tmp61 :compute:cx                        ...
  778:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  779:  op mul *tmp64 *tmp63 :compute:zy                             ...
  780:  op add :compute:zy *tmp64 :compute:cy                        ...
  781:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  782:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  783:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  784:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  785:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  786:  op mul *tmp60 :compute:zy :compute:zy                        ...
  787:  op sub *tmp61 *tmp59 *tmp60                                  ...
  788:  op add :compute:zx *tmp61 :compute:cx                        ...
  789:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  790:  op mul *tmp64 *tmp63 :compute:zy                             ...
  791:  op add :compute:zy *tmp64 :compute:cy                        ...
  792:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  793:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  794:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  795:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  796:  op mul *tmp59 :compute:zx :compute:zx                        mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  797:  op mul *tmp60 :compute:zy :compute:zy                        ...
  798:  op sub *tmp61 *tmp59 *tmp60                                  ...
  799:  op add :compute:zx *tmp61 :compute:cx                        ...
  800:  op mul *tmp63 2 :compute:x1                                  mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  801:  op mul *tmp64 *tmp63 :compute:zy                             ...
  802:  op add :compute:zy *tmp64 :compute:cy                        ...
  803:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  804:  jump *label55 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  805:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
        label *label55                                               ...
  806:  op mul *tmp69 .SMOOTH 63                                     mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  807:  jump *label58 greaterThanEq :compute:i *tmp69                ...
  808:  op log *tmp72 :compute:dist 0                                mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  809:  op mul *tmp73 *tmp72 0.36067376022224085                     ...
  810:  op log *tmp74 *tmp73 0                                       ...
  811:  op mul *tmp75 *tmp74 1.4426950408889634                      ...
  812:  op sub :compute:correction 4 *tmp75                          ...
  813:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label58                                               mandelbrot-compute.mnd: if i < SMOOTH * MAX_DEPTH then
  814:  set *tmp41 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label46                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  815:  jump *label61 equal .SMOOTH false                            mandelbrot-compute.mnd: if SMOOTH then
  816:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  817:  jump *label62 equal *tmp41 63                                mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  818:  jump *label66 notEqual .PALETTE 2                            mandelbrot-compute.mnd: case PALETTE
  819:  op sub *tmp82 32 *tmp41                                      mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  820:  op abs *tmp83 *tmp82 0                                       ...
  821:  op div *tmp85 *tmp83 36.42857142857143                       ...
  822:  op sub :drawPixel:r 1 *tmp85                                 ...
  823:  op sub *tmp87 *tmp41 32                                      mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  824:  op abs *tmp88 *tmp87 0                                       ...
  825:  op div *tmp90 *tmp88 42.5                                    ...
  826:  op sub :drawPixel:g 0.9411764705882353 *tmp90                ...
  827:  op div *tmp95 *tmp83 63.75                                   mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  828:  op add :drawPixel:b 0.47058823529411764 *tmp95               ...
  829:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  830:  jump *label62 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label66                                               ...
  831:  jump *label68 notEqual .PALETTE 3                            ...
  832:  op div *tmp99 *tmp41 0.175                                   mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  833:  op sin :drawPixel:r *tmp99 0                                 ...
  834:  op cos :drawPixel:g *tmp99 0                                 mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  835:  op sub *tmp104 *tmp41 32                                     mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  836:  op abs *tmp105 *tmp104 0                                     ...
  837:  op div *tmp107 *tmp105 63.75                                 ...
  838:  op add :drawPixel:b 0.39215686274509803 *tmp107              ...
  839:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  840:  jump *label62 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label68                                               ...
  841:  jump *label70 notEqual .PALETTE 4                            ...
  842:  op div :drawPixel:r *tmp41 63.75                             mandelbrot-compute.mnd: r = 4 * iterations / 255;
  843:  op div *tmp113 *tmp41 170                                    mandelbrot-compute.mnd: g = 96 + 1.5 * iterations / 255;
  844:  op add :drawPixel:g 96 *tmp113                               ...
  845:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  846:  jump *label62 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        label *label70                                               ...
  847:  op div *tmp117 *tmp41 63.75                                  mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  848:  op sub :drawPixel:r 1 *tmp117                                ...
  849:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  850:  jump *label62 always 0 0                                     mandelbrot-compute.mnd: if SMOOTH then
        label *label61                                               ...
  851:  read :drawPixel:color .memory *tmp41                         mandelbrot-compute.mnd: color = memory[iterations];
        label *label62                                               mandelbrot-compute.mnd: if SMOOTH then
  852:  jump *label72 lessThan .localBuffer 250                      mandelbrot-compute.mnd: if localBuffer >= 250 then
  853:  jump *label401 lessThanEq .localBuffer 4                     mandelbrot-compute.mnd: if localBuffer > 4 then
        label *label398                                              mandelbrot-compute.mnd: do
  854:  wait 0.0001                                                  mandelbrot-compute.mnd: wait(1e-4);
  855:  sensor *tmp140 .display @bufferUsage                         mandelbrot-compute.mnd: while display.@bufferUsage > 250;
  856:  jump *label398 greaterThan *tmp140 250                       mandelbrot-compute.mnd: do
        label *label401                                              mandelbrot-compute.mnd: if localBuffer > 4 then
  857:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  858:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
        label *label72                                               mandelbrot-compute.mnd: if localBuffer >= 250 then
  859:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  860:  draw rect :x :y 1 1 0 0                                      mandelbrot-compute.mnd: rect(x, y, 1, 1);
  861:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
  862:  jump *label75 greaterThan .localBuffer 4                     mandelbrot-compute.mnd: if localBuffer <= 4 then
  863:  sensor *tmp126 .display @bufferUsage                         mandelbrot-compute.mnd: if display.@bufferUsage < 900 then
  864:  jump *label77 greaterThanEq *tmp126 900                      ...
  865:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  866:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
        label *label77                                               mandelbrot-compute.mnd: if display.@bufferUsage < 900 then
        label *label75                                               mandelbrot-compute.mnd: if localBuffer <= 4 then
  867:  read *tmp130 .memory :position                               mandelbrot-compute.mnd: if memory[position] != PROCESSOR_ID then
  868:  jump *label45 notEqual *tmp130 .PROCESSOR_ID                 ...
  869:  read *tmp1 .memory 65                                        mandelbrot-compute.mnd: if stop != $STOP then
  870:  jump *label40 notEqual .stop *tmp1                           ...
  871:  op add :y :y 1                                               mandelbrot-compute.mnd: for var y in 0 ... DISPLAY_SIZE_LARGE do
  872:  jump *label102 lessThan :y 176                               ...
        label *label45                                               ...
        label *label41                                               mandelbrot-compute.mnd: if memory[position] == 0 then
  873:  op add :line :line :increment                                mandelbrot-compute.mnd: line += increment;
  874:  jump *label83 lessThanEq :line 176                           mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  875:  op div :next_increment :next_increment 2                     mandelbrot-compute.mnd: increment = next_increment /= 2;
  876:  set :increment :next_increment                               ...
  877:  op div :line :next_increment 2                               mandelbrot-compute.mnd: line = increment / 2;
        label *label83                                               mandelbrot-compute.mnd: if line > DISPLAY_SIZE_LARGE then
  878:  op add :lines :lines 1                                       mandelbrot-compute.mnd: MasterLoop:
  879:  jump *label101 lessThan :lines 176                           ...
        label *label40                                               ...
  880:  jump *label408 lessThanEq .localBuffer 4                     mandelbrot-compute.mnd: if localBuffer > 4 then
        label *label405                                              mandelbrot-compute.mnd: do
  881:  wait 0.0001                                                  mandelbrot-compute.mnd: wait(1e-4);
  882:  sensor *tmp140 .display @bufferUsage                         mandelbrot-compute.mnd: while display.@bufferUsage > 250;
  883:  jump *label405 greaterThan *tmp140 250                       mandelbrot-compute.mnd: do
        label *label408                                              mandelbrot-compute.mnd: if localBuffer > 4 then
  884:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  885:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
  886:  jump *label30 always 0 0                                     mandelbrot-compute.mnd: while true do


Performance: parsed in 287 ms, compiled in 281 ms, optimized in 1,451 ms, run in 47 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Mandelbrot Generator
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Display: display
Memory: bank
Execution step limit of 100000 exceeded.
