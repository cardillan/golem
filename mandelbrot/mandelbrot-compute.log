   456 instructions before optimizations.
    50 instructions eliminated by Temp Variables Elimination (2 passes, 8 iterations).
     2 instructions eliminated by Case Expression Optimization.
    45 instructions eliminated by Dead Code Elimination (6 iterations).
     4 instructions eliminated by Jump Normalization (2 passes, 6 iterations).
    26 instructions eliminated by Condition Optimization (2 passes, 8 iterations).
    24 instructions eliminated by Single Step Elimination (2 passes, 8 iterations).
     1 instructions modified by Expression Optimization (4 iterations).
    20 instructions eliminated by Boolean Optimization (7 iterations).
       7 fully-evaluated expressions optimized using selects.
    29 instructions eliminated by Data Flow Optimization (3 passes, 13 iterations).
     2 loops improved by Loop Hoisting.
       4 loop conditions were partially rotated.
   743 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
    12 instructions eliminated by Case Switching (7 iterations).
     2 case expressions converted to fast dispatch by Case Switching.
    69 instructions eliminated by Jump Straightening (2 passes, 8 iterations).
     9 instructions updated by Jump Threading.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
   917 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 739):
  * Fast-dispatch case at mandelbrot-compute.mnd:131:5           size   -11, benefit   242187.5, efficiency   Infinity (-10 instructions)
  o Fast-dispatch case at mandelbrot-compute.mnd:223:9           size    -2, benefit     3906.3, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 749):
  * Fast-dispatch case at mandelbrot-compute.mnd:223:9           size    -2, benefit     3906.3, efficiency   Infinity (-2 instructions)

Pass 2: speed optimization selection (cost limit 759):
  * Unroll loop at mandelbrot-compute.mnd:193:9                  size  +679, benefit 1230468750.0, efficiency 1812177.835 (+743 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
    97 op add *tmp48 *tmp47 :i
    98 set :adam5:index *tmp48
    99 op idiv *tmp50 :adam5:index 16
-    * set *tmp51 *tmp50
-    * jump *label28 lessThan *tmp51 0
-    * jump *label27 lessThan *tmp51 121
+  100 jump *label28 lessThan *tmp50 0
+  101 jump *label27 lessThan *tmp50 121
   102 label *label28
   103 jump *label26 always
   104 label *label27
 
   119 set *tmp49 :adam5:dx
   120 jump *label25 always
   121 label *label26
-    * jump *label33 lessThan *tmp51 121
-    * jump *label32 lessThan *tmp51 242
+  122 jump *label33 lessThan *tmp50 121
+  123 jump *label32 lessThan *tmp50 242
   124 label *label33
   125 jump *label31 always
   126 label *label32
 
   149 set *tmp49 :adam5:dy
   150 jump *label25 always
   151 label *label31
-    * jump *label40 lessThan *tmp51 242
-    * jump *label39 lessThan *tmp51 484
+  152 jump *label40 lessThan *tmp50 242
+  153 jump *label39 lessThan *tmp50 484
   154 label *label40
   155 jump *label38 always
   156 label *label39
 
   173 set *tmp49 :adam5:dx
   174 jump *label25 always
   175 label *label38
-    * jump *label45 lessThan *tmp51 484
-    * jump *label44 lessThan *tmp51 968
+  176 jump *label45 lessThan *tmp50 484
+  177 jump *label44 lessThan *tmp50 968
   178 label *label45
   179 jump *label43 always
   180 label *label44
 
   356 jump *label76 always
   357 label *label75
   358 jump *label77 equal .SMOOTH false
-    * set *tmp126 .PALETTE
-    * jump *label81 equal *tmp126 2
+  359 jump *label81 equal .PALETTE 2
   360 jump *label80 always
   361 label *label81
   362 op sub *tmp127 32 :drawPixel:iterations
 
   382 set *tmp125 :drawPixel:color
   383 jump *label79 always
   384 label *label80
-    * jump *label83 equal *tmp126 3
+  385 jump *label83 equal .PALETTE 3
   386 jump *label82 always
   387 label *label83
   388 op div *tmp143 :drawPixel:iterations 63
 
   404 set *tmp125 :drawPixel:color
   405 jump *label79 always
   406 label *label82
-    * jump *label85 equal *tmp126 4
+  407 jump *label85 equal .PALETTE 4
   408 jump *label84 always
   409 label *label85
   410 op mul *tmp155 4 :drawPixel:iterations

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-36 instructions):
 
    63 op notEqual *tmp36 .stop *tmp37
    64 jump *label15 equal *tmp36 false
    65 jump *label5 always
-    * set *tmp38 null
    66 jump *label16 always
    67 label *label15
-    * set *tmp38 null
    68 label *label16
    69 read *tmp39 .memory 64
    70 set :batch *tmp39
 
    81 op greaterThanEq *tmp43 :batch 2816
    82 jump *label19 equal *tmp43 false
    83 jump *label14 always
-    * set *tmp44 null
    84 jump *label20 always
    85 label *label19
-    * set *tmp44 null
    86 label *label20
    87 op mul *tmp45 11 :multiple
    88 set *tmp46 *tmp45
 
   112 label *label30
   113 set :adam5:dy *tmp56
   114 set :adam5:dx :adam5:dy
-    * set *tmp49 :adam5:dx
   115 jump *label25 always
   116 label *label26
   117 jump *label33 lessThan *tmp50 121
 
   141 set *tmp63 2
   142 label *label37
   143 set :adam5:dy *tmp63
-    * set *tmp49 :adam5:dy
   144 jump *label25 always
   145 label *label31
   146 jump *label40 lessThan *tmp50 242
 
   164 label *label42
   165 set :adam5:dy *tmp69
   166 set :adam5:dx :adam5:dy
-    * set *tmp49 :adam5:dx
   167 jump *label25 always
   168 label *label38
   169 jump *label45 lessThan *tmp50 484
 
   187 set *tmp75 1
   188 label *label47
   189 set :adam5:dy *tmp75
-    * set *tmp49 :adam5:dy
   190 jump *label25 always
   191 label *label43
   192 op sub :adam5:index :adam5:index 15488
 
   198 set :adam5:y *tmp79
   199 set :adam5:dy 1
   200 set :adam5:dx :adam5:dy
-    * set *tmp49 :adam5:dx
   201 label *label25
   202 label *label24
   203 set :x :adam5:x
 
   227 label *label55
   228 drawflush .display
   229 set .localBuffer 0
-    * set *tmp87 .localBuffer
   230 jump *label54 always
   231 label *label53
-    * set *tmp87 null
   232 label *label54
   233 label *label52
-    * set *tmp82 null
   234 jump *label49 always
   235 label *label48
-    * set *tmp82 null
   236 label *label49
   237 set :compute:x :x
   238 set :compute:y :y
 
   245 jump *label58 equal .JULIA false
   246 set :compute:cx .JULIA_X
   247 set :compute:cy .JULIA_Y
-    * set *tmp93 :compute:cy
   248 jump *label59 always
   249 label *label58
   250 set :compute:cx :compute:zx
 
   260 jump *label60 equal *tmp100 false
   261 set *tmp88 63
   262 jump *label57 always
-    * set *tmp101 null
   263 jump *label61 always
   264 label *label60
-    * set *tmp101 null
   265 label *label61
   266 op add *tmp102 :compute:cx 1
   267 op len *tmp103 *tmp102 :compute:cy
 
   274 label *label62
   275 set *tmp105 null
   276 label *label63
-    * set *tmp93 *tmp105
   277 label *label59
   278 label *label64
   279 set :compute:i 0
 
   295 op greaterThanEq *tmp114 :compute:dist 64
   296 jump *label70 equal *tmp114 false
   297 jump *label66 always
-    * set *tmp115 null
   298 jump *label71 always
   299 label *label70
-    * set *tmp115 null
   300 label *label71
   301 label *label68
   302 op add :compute:i :compute:i 1
 
   315 op sub *tmp121 4 *tmp120
   316 set :compute:correction *tmp121
   317 op add :compute:i :compute:i :compute:correction
-    * set *tmp116 :compute:i
   318 jump *label73 always
   319 label *label72
-    * set *tmp116 null
   320 label *label73
   321 set *tmp88 :compute:i
   322 jump *label57 always
 
   331 op equal *tmp122 :drawPixel:iterations 63
   332 jump *label75 equal *tmp122 false
   333 set :drawPixel:color %[black]
-    * set *tmp123 :drawPixel:color
   334 jump *label76 always
   335 label *label75
   336 jump *label77 equal .SMOOTH false
 
   412 set :drawPixel:color *tmp166
   413 set *tmp124 :drawPixel:color
   414 label *label78
-    * set *tmp123 *tmp124
   415 label *label76
   416 op greaterThanEq *tmp167 .localBuffer 254
   417 jump *label86 equal *tmp167 false
 
   436 label *label97
   437 drawflush .display
   438 set .localBuffer 0
-    * set *tmp176 .localBuffer
   439 jump *label96 always
   440 label *label95
-    * set *tmp176 null
   441 label *label96
   442 label *label94
   443 label *label90
   444 jump *label89 always
   445 label *label91
   446 label *label88
-    * set *tmp168 null
   447 jump *label87 always
   448 label *label86
-    * set *tmp168 null
   449 label *label87
   450 op greaterThan *tmp177 .localBuffer 0
   451 jump *label99 equal *tmp177 false
 
   457 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   458 set *tmp180 .localBuffer
   459 op add .localBuffer .localBuffer 1
-    * set *tmp179 *tmp180
   460 jump *label100 always
   461 label *label99
   462 draw col :drawPixel:color
   463 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   464 set .lastColor :drawPixel:color
   465 op add .localBuffer .localBuffer 2
-    * set *tmp179 .localBuffer
   466 label *label100
   467 wait 0
   468 sensor *tmp181 .display @enabled
 
   476 label *label106
   477 drawflush .display
   478 set .localBuffer 0
-    * set *tmp185 .localBuffer
   479 jump *label105 always
   480 label *label104
-    * set *tmp185 null
   481 label *label105
   482 label *label103
   483 label *label74
 
   486 op notEqual *tmp186 .stop *tmp187
   487 jump *label108 equal *tmp186 false
   488 jump *label5 always
-    * set *tmp188 null
   489 jump *label109 always
   490 label *label108
-    * set *tmp188 null
   491 label *label109
   492 read *tmp189 .memory 66
-    * set *tmp190 *tmp189
   493 op add *tmp2 *tmp189 1
   494 write *tmp2 .memory 66
   495 read *tmp191 .memory 65
 
   523 label *label119
   524 drawflush .display
   525 set .localBuffer 0
-    * set *tmp200 .localBuffer
   526 jump *label118 always
   527 label *label117
-    * set *tmp200 null
   528 label *label118
   529 label *label116
   530 label *label112

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
   269 jump *label62 equal *tmp104 false
   270 set *tmp88 63
   271 jump *label57 always
-    * set *tmp105 null
   272 jump *label63 always
   273 label *label62
-    * set *tmp105 null
   274 label *label63
   275 label *label59
   276 label *label64
 
   402 set :drawPixel:color *tmp163
   403 set *tmp125 :drawPixel:color
   404 label *label79
-    * set *tmp124 *tmp125
   405 jump *label78 always
   406 label *label77
   407 set *tmp164 :drawPixel:iterations
   408 read *tmp166 .memory *tmp164
   409 set :drawPixel:color *tmp166
-    * set *tmp124 :drawPixel:color
   410 label *label78
   411 label *label76
   412 op greaterThanEq *tmp167 .localBuffer 254
 
   451 jump *label101 always
   452 label *label101
   453 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
-    * set *tmp180 .localBuffer
   454 op add .localBuffer .localBuffer 1
   455 jump *label100 always
   456 label *label99

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-4 instructions):
 
   355 set :drawPixel:b *tmp141
   356 packcolor *tmp142 :drawPixel:r :drawPixel:g :drawPixel:b 1
   357 set :drawPixel:color *tmp142
-    * set *tmp125 :drawPixel:color
   358 jump *label79 always
   359 label *label80
   360 jump *label83 equal .PALETTE 3
 
   376 set :drawPixel:b *tmp153
   377 packcolor *tmp154 :drawPixel:r :drawPixel:g :drawPixel:b 1
   378 set :drawPixel:color *tmp154
-    * set *tmp125 :drawPixel:color
   379 jump *label79 always
   380 label *label82
   381 jump *label85 equal .PALETTE 4
 
   389 set :drawPixel:g *tmp158
   390 packcolor *tmp159 :drawPixel:r :drawPixel:g 0 1
   391 set :drawPixel:color *tmp159
-    * set *tmp125 :drawPixel:color
   392 jump *label79 always
   393 label *label84
   394 op mul *tmp160 4 :drawPixel:iterations
 
   397 set :drawPixel:r *tmp162
   398 packcolor *tmp163 :drawPixel:r :drawPixel:r 0 1
   399 set :drawPixel:color *tmp163
-    * set *tmp125 :drawPixel:color
   400 label *label79
   401 jump *label78 always
   402 label *label77

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-47 instructions):
 
    17 op equal *tmp16 .start *tmp17
    18 jump *label7 notEqual *tmp16 false
    19 label *label9
-    * read *tmp18 .memory 67
-    * set .start *tmp18
-    * read *tmp19 .memory 68
-    * set .stop *tmp19
+   20 read .start .memory 67
+   21 read .stop .memory 68
    22 set .lastColor -1
    23 set .localBuffer 0
    24 drawflush null
    25 drawflush .display
-    * read *tmp20 .memory 71
-    * set .ZOOM *tmp20
+   26 read .ZOOM .memory 71
    27 op div *tmp21 -88 .ZOOM
    28 read *tmp23 .memory 69
-    * op add *tmp22 *tmp21 *tmp23
-    * set .OFFSET_X *tmp22
+   29 op add .OFFSET_X *tmp21 *tmp23
    30 op div *tmp24 -88 .ZOOM
    31 read *tmp26 .memory 70
-    * op add *tmp25 *tmp24 *tmp26
-    * set .OFFSET_Y *tmp25
-    * read *tmp27 .memory 72
-    * set .JULIA *tmp27
-    * read *tmp28 .memory 73
-    * set .JULIA_X *tmp28
-    * read *tmp29 .memory 74
-    * set .JULIA_Y *tmp29
-    * read *tmp30 .memory 75
-    * set .PALETTE *tmp30
-    * op greaterThan *tmp31 .PALETTE 1
-    * set .SMOOTH *tmp31
-    * read *tmp32 .memory 76
-    * set .ALL_PASS_COLORING *tmp32
+   32 op add .OFFSET_Y *tmp24 *tmp26
+   33 read .JULIA .memory 72
+   34 read .JULIA_X .memory 73
+   35 read .JULIA_Y .memory 74
+   36 read .PALETTE .memory 75
+   37 op greaterThan .SMOOTH .PALETTE 1
+   38 read .ALL_PASS_COLORING .memory 76
    39 read *tmp33 .memory 77
    40 jump *label10 equal *tmp33 false
-    * op sub *tmp35 1 .ALL_PASS_COLORING
-    * set *tmp34 *tmp35
+   41 op sub *tmp34 1 .ALL_PASS_COLORING
    42 jump *label11 always
    43 label *label10
    44 set *tmp34 99
 
    54 jump *label16 always
    55 label *label15
    56 label *label16
-    * read *tmp39 .memory 64
-    * set :batch *tmp39
+   57 read :batch .memory 64
    58 op greaterThanEq *tmp40 :batch 1408
    59 jump *label17 equal *tmp40 false
    60 set *tmp41 1
 
    71 jump *label20 always
    72 label *label19
    73 label *label20
-    * op mul *tmp45 11 :multiple
-    * set *tmp46 *tmp45
+   74 op mul *tmp46 11 :multiple
    75 set :i 0
    76 label *label21
    77 jump *label23 greaterThanEq :i *tmp46
    78 op mul *tmp47 :batch 11
-    * op add *tmp48 *tmp47 :i
-    * set :adam5:index *tmp48
+   79 op add :adam5:index *tmp47 :i
    80 op idiv *tmp50 :adam5:index 16
    81 jump *label28 lessThan *tmp50 0
    82 jump *label27 lessThan *tmp50 121
 
    84 jump *label26 always
    85 label *label27
    86 op mod *tmp52 :adam5:index 44
-    * op mul *tmp53 4 *tmp52
-    * set :adam5:x *tmp53
+   87 op mul :adam5:x 4 *tmp52
    88 op idiv *tmp54 :adam5:index 44
-    * op mul *tmp55 4 *tmp54
-    * set :adam5:y *tmp55
+   89 op mul :adam5:y 4 *tmp54
    90 jump *label29 equal .ALL_PASS_COLORING false
    91 set *tmp56 4
    92 jump *label30 always
 
   105 op sub :adam5:index :adam5:index 1936
   106 op mod *tmp57 :adam5:index 44
   107 op mul *tmp58 4 *tmp57
-    * op add *tmp59 *tmp58 2
-    * set :adam5:x *tmp59
+  108 op add :adam5:x *tmp58 2
   109 op idiv *tmp60 :adam5:index 44
-    * op mul *tmp61 4 *tmp60
-    * set :adam5:y *tmp61
+  110 op mul :adam5:y 4 *tmp60
   111 jump *label34 equal .ALL_PASS_COLORING false
   112 set *tmp62 2
   113 jump *label35 always
 
   131 label *label39
   132 op sub :adam5:index :adam5:index 3872
   133 op mod *tmp64 :adam5:index 88
-    * op mul *tmp65 2 *tmp64
-    * set :adam5:x *tmp65
+  134 op mul :adam5:x 2 *tmp64
   135 op idiv *tmp66 :adam5:index 88
   136 op mul *tmp67 4 *tmp66
-    * op add *tmp68 *tmp67 2
-    * set :adam5:y *tmp68
+  137 op add :adam5:y *tmp67 2
   138 jump *label41 equal .ALL_PASS_COLORING false
   139 set *tmp69 2
   140 jump *label42 always
 
   153 op sub :adam5:index :adam5:index 7744
   154 op mod *tmp70 :adam5:index 88
   155 op mul *tmp71 2 *tmp70
-    * op add *tmp72 *tmp71 1
-    * set :adam5:x *tmp72
+  156 op add :adam5:x *tmp71 1
   157 op idiv *tmp73 :adam5:index 88
-    * op mul *tmp74 2 *tmp73
-    * set :adam5:y *tmp74
+  158 op mul :adam5:y 2 *tmp73
   159 set :adam5:dx 1
   160 jump *label46 equal .ALL_PASS_COLORING false
   161 set *tmp75 2
 
   167 jump *label25 always
   168 label *label43
   169 op sub :adam5:index :adam5:index 15488
-    * op mod *tmp76 :adam5:index 176
-    * set :adam5:x *tmp76
+  170 op mod :adam5:x :adam5:index 176
   171 op idiv *tmp77 :adam5:index 176
   172 op mul *tmp78 2 *tmp77
-    * op add *tmp79 *tmp78 1
-    * set :adam5:y *tmp79
+  173 op add :adam5:y *tmp78 1
   174 set :adam5:dy 1
   175 set :adam5:dx :adam5:dy
   176 label *label25
 
   212 set :compute:x :x
   213 set :compute:y :y
   214 op div *tmp89 :compute:x .ZOOM
-    * op add *tmp90 *tmp89 .OFFSET_X
-    * set :compute:zx *tmp90
+  215 op add :compute:zx *tmp89 .OFFSET_X
   216 op div *tmp91 :compute:y .ZOOM
-    * op add *tmp92 *tmp91 .OFFSET_Y
-    * set :compute:zy *tmp92
+  217 op add :compute:zy *tmp91 .OFFSET_Y
   218 jump *label58 equal .JULIA false
   219 set :compute:cx .JULIA_X
   220 set :compute:cy .JULIA_Y
 
   223 set :compute:cx :compute:zx
   224 set :compute:cy :compute:zy
   225 op sub *tmp94 :compute:cx 0.25
-    * op len *tmp95 *tmp94 :compute:cy
-    * set :compute:p *tmp95
+  226 op len :compute:p *tmp94 :compute:cy
   227 op mul *tmp96 2 :compute:p
   228 op mul *tmp97 *tmp96 :compute:p
   229 op sub *tmp98 :compute:p *tmp97
 
   254 op mul *tmp106 :compute:x1 :compute:x1
   255 op mul *tmp107 :compute:y1 :compute:y1
   256 op sub *tmp108 *tmp106 *tmp107
-    * op add *tmp109 *tmp108 :compute:cx
-    * set :compute:zx *tmp109
+  257 op add :compute:zx *tmp108 :compute:cx
   258 op mul *tmp110 2 :compute:x1
   259 op mul *tmp111 *tmp110 :compute:y1
-    * op add *tmp112 *tmp111 :compute:cy
-    * set :compute:zy *tmp112
-    * op len *tmp113 :compute:zx :compute:zy
-    * set :compute:dist *tmp113
+  260 op add :compute:zy *tmp111 :compute:cy
+  261 op len :compute:dist :compute:zx :compute:zy
   262 op greaterThanEq *tmp114 :compute:dist 64
   263 jump *label70 equal *tmp114 false
   264 jump *label66 always
 
   279 op mul *tmp118 *tmp117 0.36067376022224085
   280 op log *tmp119 *tmp118
   281 op mul *tmp120 *tmp119 1.4426950408889634
-    * op sub *tmp121 4 *tmp120
-    * set :compute:correction *tmp121
+  282 op sub :compute:correction 4 *tmp120
   283 op add :compute:i :compute:i :compute:correction
   284 jump *label73 always
   285 label *label72
 
   307 op abs *tmp128 *tmp127
   308 op mul *tmp129 7 *tmp128
   309 op div *tmp130 *tmp129 255
-    * op sub *tmp131 1 *tmp130
-    * set :drawPixel:r *tmp131
+  310 op sub :drawPixel:r 1 *tmp130
   311 op sub *tmp132 :drawPixel:iterations 32
   312 op abs *tmp133 *tmp132
   313 op mul *tmp134 6 *tmp133
   314 op div *tmp135 *tmp134 255
-    * op sub *tmp136 0.9411764705882353 *tmp135
-    * set :drawPixel:g *tmp136
+  315 op sub :drawPixel:g 0.9411764705882353 *tmp135
   316 op sub *tmp137 32 :drawPixel:iterations
   317 op abs *tmp138 *tmp137
   318 op mul *tmp139 4 *tmp138
   319 op div *tmp140 *tmp139 255
-    * op add *tmp141 0.47058823529411764 *tmp140
-    * set :drawPixel:b *tmp141
-    * packcolor *tmp142 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp142
+  320 op add :drawPixel:b 0.47058823529411764 *tmp140
+  321 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   322 jump *label79 always
   323 label *label80
   324 jump *label83 equal .PALETTE 3
 
   326 label *label83
   327 op div *tmp143 :drawPixel:iterations 63
   328 op mul *tmp144 *tmp143 360
-    * op sin *tmp145 *tmp144
-    * set :drawPixel:r *tmp145
+  329 op sin :drawPixel:r *tmp144
   330 op div *tmp146 :drawPixel:iterations 63
   331 op mul *tmp147 *tmp146 360
-    * op cos *tmp148 *tmp147
-    * set :drawPixel:g *tmp148
+  332 op cos :drawPixel:g *tmp147
   333 op sub *tmp149 :drawPixel:iterations 32
   334 op abs *tmp150 *tmp149
   335 op mul *tmp151 4 *tmp150
   336 op div *tmp152 *tmp151 255
-    * op add *tmp153 0.39215686274509803 *tmp152
-    * set :drawPixel:b *tmp153
-    * packcolor *tmp154 :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * set :drawPixel:color *tmp154
+  337 op add :drawPixel:b 0.39215686274509803 *tmp152
+  338 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   339 jump *label79 always
   340 label *label82
   341 jump *label85 equal .PALETTE 4
   342 jump *label84 always
   343 label *label85
   344 op mul *tmp155 4 :drawPixel:iterations
-    * op div *tmp156 *tmp155 255
-    * set :drawPixel:r *tmp156
+  345 op div :drawPixel:r *tmp155 255
   346 op mul *tmp157 1.5 :drawPixel:iterations
-    * op div *tmp158 *tmp157 255
-    * set :drawPixel:g *tmp158
-    * packcolor *tmp159 :drawPixel:r :drawPixel:g 0 1
-    * set :drawPixel:color *tmp159
+  347 op div :drawPixel:g *tmp157 255
+  348 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   349 jump *label79 always
   350 label *label84
   351 op mul *tmp160 4 :drawPixel:iterations
   352 op div *tmp161 *tmp160 255
-    * op sub *tmp162 1 *tmp161
-    * set :drawPixel:r *tmp162
-    * packcolor *tmp163 :drawPixel:r :drawPixel:r 0 1
-    * set :drawPixel:color *tmp163
+  353 op sub :drawPixel:r 1 *tmp161
+  354 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   355 label *label79
   356 jump *label78 always
   357 label *label77
-    * set *tmp164 :drawPixel:iterations
-    * read *tmp166 .memory *tmp164
-    * set :drawPixel:color *tmp166
+  358 read :drawPixel:color .memory :drawPixel:iterations
   359 label *label78
   360 label *label76
   361 op greaterThanEq *tmp167 .localBuffer 254

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-3 instructions):
 
     9 jump *label2 always
    10 label *label2
    11 label *label4
-    * jump *label6 equal true false
    12 label *label7
    13 wait 0
    14 label *label8
 
    44 label *label11
    45 set :leaderLimit *tmp34
    46 label *label12
-    * jump *label14 equal true false
    47 wait 0
    48 read *tmp37 .memory 68
    49 op notEqual *tmp36 .stop *tmp37
 
   270 set *tmp88 :compute:i
   271 jump *label57 always
   272 label *label65
-    * jump *label64 notEqual false false
   273 label *label66
   274 jump *label72 equal .SMOOTH false
   275 op log *tmp117 :compute:dist

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
   297 jump *label76 always
   298 label *label75
   299 jump *label77 equal .SMOOTH false
-    * jump *label81 equal .PALETTE 2
-    * jump *label80 always
+  300 jump *label80 notEqual .PALETTE 2
   301 label *label81
   302 op sub *tmp127 32 :drawPixel:iterations
   303 op abs *tmp128 *tmp127
 
   317 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   318 jump *label79 always
   319 label *label80
-    * jump *label83 equal .PALETTE 3
-    * jump *label82 always
+  320 jump *label82 notEqual .PALETTE 3
   321 label *label83
   322 op div *tmp143 :drawPixel:iterations 63
   323 op mul *tmp144 *tmp143 360
 
   333 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   334 jump *label79 always
   335 label *label82
-    * jump *label85 equal .PALETTE 4
-    * jump *label84 always
+  336 jump *label84 notEqual .PALETTE 4
   337 label *label85
   338 op mul *tmp155 4 :drawPixel:iterations
   339 op div :drawPixel:r *tmp155 255

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-24 instructions):
 
     1 set .start 0
     2 label *label0
     3 label *label1
-    * op equal *tmp14 .display null
-    * jump *label0 notEqual *tmp14 false
+    4 jump *label0 equal .display null
     5 label *label3
-    * op equal *tmp15 .memory null
-    * jump *label0 notEqual *tmp15 false
+    6 jump *label0 equal .memory null
     7 jump *label2 always
     8 label *label2
     9 label *label4
 
    11 wait 0
    12 label *label8
    13 read *tmp17 .memory 67
-    * op equal *tmp16 .start *tmp17
-    * jump *label7 notEqual *tmp16 false
+   14 jump *label7 equal .start *tmp17
    15 label *label9
    16 read .start .memory 67
    17 read .stop .memory 68
 
    43 label *label12
    44 wait 0
    45 read *tmp37 .memory 68
-    * op notEqual *tmp36 .stop *tmp37
-    * jump *label15 equal *tmp36 false
+   46 jump *label15 equal .stop *tmp37
    47 jump *label5 always
    48 jump *label16 always
    49 label *label15
    50 label *label16
    51 read :batch .memory 64
-    * op greaterThanEq *tmp40 :batch 1408
-    * jump *label17 equal *tmp40 false
+   52 jump *label17 lessThan :batch 1408
    53 set *tmp41 1
    54 jump *label18 always
    55 label *label17
 
    58 set :multiple *tmp41
    59 op add *tmp42 :batch :multiple
    60 write *tmp42 .memory 64
-    * op greaterThanEq *tmp43 :batch 2816
-    * jump *label19 equal *tmp43 false
+   61 jump *label19 lessThan :batch 2816
    62 jump *label14 always
    63 jump *label20 always
    64 label *label19
 
   171 set :y :adam5:y
   172 set :dx :adam5:dx
   173 set :dy :adam5:dy
-    * op greaterThan *tmp80 :multiple :leaderLimit
-    * jump *label48 equal *tmp80 false
+  174 jump *label48 lessThanEq :multiple :leaderLimit
   175 label *label51
-    * op equal *tmp81 .localBuffer 0
-    * jump *label48 equal *tmp81 false
+  176 jump *label48 notEqual .localBuffer 0
   177 jump *label50 always
   178 label *label50
   179 draw col %[white]
 
   186 label *label56
   187 sensor *tmp84 .display @bufferSize
   188 op sub *tmp85 1024 *tmp84
-    * op lessThan *tmp86 .localBuffer *tmp85
-    * jump *label53 equal *tmp86 false
+  189 jump *label53 greaterThanEq .localBuffer *tmp85
   190 jump *label55 always
   191 label *label55
   192 drawflush .display
 
   217 op mul *tmp97 *tmp96 :compute:p
   218 op sub *tmp98 :compute:p *tmp97
   219 op add *tmp99 *tmp98 0.25
-    * op lessThanEq *tmp100 :compute:cx *tmp99
-    * jump *label60 equal *tmp100 false
+  220 jump *label60 greaterThan :compute:cx *tmp99
   221 set *tmp88 63
   222 jump *label57 always
   223 jump *label61 always
 
   225 label *label61
   226 op add *tmp102 :compute:cx 1
   227 op len *tmp103 *tmp102 :compute:cy
-    * op lessThanEq *tmp104 *tmp103 0.25
-    * jump *label62 equal *tmp104 false
+  228 jump *label62 greaterThan *tmp103 0.25
   229 set *tmp88 63
   230 jump *label57 always
   231 jump *label63 always
 
   246 op mul *tmp111 *tmp110 :compute:y1
   247 op add :compute:zy *tmp111 :compute:cy
   248 op len :compute:dist :compute:zx :compute:zy
-    * op greaterThanEq *tmp114 :compute:dist 64
-    * jump *label70 equal *tmp114 false
+  249 jump *label70 lessThan :compute:dist 64
   250 jump *label66 always
   251 jump *label71 always
   252 label *label70
 
   279 set :drawPixel:dx :dx
   280 set :drawPixel:dy :dy
   281 set :drawPixel:iterations :iterations
-    * op equal *tmp122 :drawPixel:iterations 63
-    * jump *label75 equal *tmp122 false
+  282 jump *label75 notEqual :drawPixel:iterations 63
   283 set :drawPixel:color %[black]
   284 jump *label76 always
   285 label *label75
 
   339 read :drawPixel:color .memory :drawPixel:iterations
   340 label *label78
   341 label *label76
-    * op greaterThanEq *tmp167 .localBuffer 254
-    * jump *label86 equal *tmp167 false
+  342 jump *label86 lessThan .localBuffer 254
   343 label *label89
-    * op greaterThan *tmp169 .localBuffer 0
-    * jump *label91 equal *tmp169 false
+  344 jump *label91 lessThanEq .localBuffer 0
   345 label *label93
   346 read *tmp171 .memory 68
-    * op equal *tmp170 .stop *tmp171
-    * jump *label91 equal *tmp170 false
+  347 jump *label91 notEqual .stop *tmp171
   348 jump *label92 always
   349 label *label92
   350 wait 0
 
   353 label *label98
   354 sensor *tmp173 .display @bufferSize
   355 op sub *tmp174 1024 *tmp173
-    * op lessThan *tmp175 .localBuffer *tmp174
-    * jump *label95 equal *tmp175 false
+  356 jump *label95 greaterThanEq .localBuffer *tmp174
   357 jump *label97 always
   358 label *label97
   359 drawflush .display
 
   369 jump *label87 always
   370 label *label86
   371 label *label87
-    * op greaterThan *tmp177 .localBuffer 0
-    * jump *label99 equal *tmp177 false
+  372 jump *label99 lessThanEq .localBuffer 0
   373 label *label102
-    * op strictEqual *tmp178 :drawPixel:color .lastColor
-    * jump *label99 equal *tmp178 false
+  374 jump *label99 strictNotEqual :drawPixel:color .lastColor
   375 jump *label101 always
   376 label *label101
   377 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
 
   389 label *label107
   390 sensor *tmp182 .display @bufferSize
   391 op sub *tmp183 1024 *tmp182
-    * op lessThan *tmp184 .localBuffer *tmp183
-    * jump *label104 equal *tmp184 false
+  392 jump *label104 greaterThanEq .localBuffer *tmp183
   393 jump *label106 always
   394 label *label106
   395 drawflush .display
 
   401 label *label74
   402 wait 0
   403 read *tmp187 .memory 68
-    * op notEqual *tmp186 .stop *tmp187
-    * jump *label108 equal *tmp186 false
+  404 jump *label108 equal .stop *tmp187
   405 jump *label5 always
   406 jump *label109 always
   407 label *label108
 
   420 jump *label12 always
   421 label *label14
   422 label *label111
-    * op greaterThan *tmp193 .localBuffer 0
-    * jump *label113 equal *tmp193 false
+  423 jump *label113 lessThanEq .localBuffer 0
   424 label *label115
   425 read *tmp195 .memory 68
-    * op equal *tmp194 .stop *tmp195
-    * jump *label113 equal *tmp194 false
+  426 jump *label113 notEqual .stop *tmp195
   427 jump *label114 always
   428 label *label114
   429 wait 0
 
   432 label *label120
   433 sensor *tmp197 .display @bufferSize
   434 op sub *tmp198 1024 *tmp197
-    * op lessThan *tmp199 .localBuffer *tmp198
-    * jump *label117 equal *tmp199 false
+  435 jump *label117 greaterThanEq .localBuffer *tmp198
   436 jump *label119 always
   437 label *label119
   438 drawflush .display

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-22 instructions):
 
     4 jump *label0 equal .display null
     5 label *label3
     6 jump *label0 equal .memory null
-    * jump *label2 always
     7 label *label2
     8 label *label4
     9 label *label7
 
    44 read *tmp37 .memory 68
    45 jump *label15 equal .stop *tmp37
    46 jump *label5 always
-    * jump *label16 always
    47 label *label15
    48 label *label16
    49 read :batch .memory 64
 
    58 write *tmp42 .memory 64
    59 jump *label19 lessThan :batch 2816
    60 jump *label14 always
-    * jump *label20 always
    61 label *label19
    62 label *label20
    63 op mul *tmp46 11 :multiple
 
   171 jump *label48 lessThanEq :multiple :leaderLimit
   172 label *label51
   173 jump *label48 notEqual .localBuffer 0
-    * jump *label50 always
   174 label *label50
   175 draw col %[white]
   176 draw rect :x :y :dx :dx
 
   183 sensor *tmp84 .display @bufferSize
   184 op sub *tmp85 1024 *tmp84
   185 jump *label53 greaterThanEq .localBuffer *tmp85
-    * jump *label55 always
   186 label *label55
   187 drawflush .display
   188 set .localBuffer 0
-    * jump *label54 always
   189 label *label53
   190 label *label54
   191 label *label52
-    * jump *label49 always
   192 label *label48
   193 label *label49
   194 set :compute:x :x
 
   213 jump *label60 greaterThan :compute:cx *tmp99
   214 set *tmp88 63
   215 jump *label57 always
-    * jump *label61 always
   216 label *label60
   217 label *label61
   218 op add *tmp102 :compute:cx 1
 
   220 jump *label62 greaterThan *tmp103 0.25
   221 set *tmp88 63
   222 jump *label57 always
-    * jump *label63 always
   223 label *label62
   224 label *label63
   225 label *label59
 
   239 op len :compute:dist :compute:zx :compute:zy
   240 jump *label70 lessThan :compute:dist 64
   241 jump *label66 always
-    * jump *label71 always
   242 label *label70
   243 label *label71
   244 label *label68
 
   256 op mul *tmp120 *tmp119 1.4426950408889634
   257 op sub :compute:correction 4 *tmp120
   258 op add :compute:i :compute:i :compute:correction
-    * jump *label73 always
   259 label *label72
   260 label *label73
   261 set *tmp88 :compute:i
 
   334 label *label93
   335 read *tmp171 .memory 68
   336 jump *label91 notEqual .stop *tmp171
-    * jump *label92 always
   337 label *label92
   338 wait 0
   339 sensor *tmp172 .display @enabled
 
   342 sensor *tmp173 .display @bufferSize
   343 op sub *tmp174 1024 *tmp173
   344 jump *label95 greaterThanEq .localBuffer *tmp174
-    * jump *label97 always
   345 label *label97
   346 drawflush .display
   347 set .localBuffer 0
-    * jump *label96 always
   348 label *label95
   349 label *label96
   350 label *label94
 
   352 jump *label89 always
   353 label *label91
   354 label *label88
-    * jump *label87 always
   355 label *label86
   356 label *label87
   357 jump *label99 lessThanEq .localBuffer 0
   358 label *label102
   359 jump *label99 strictNotEqual :drawPixel:color .lastColor
-    * jump *label101 always
   360 label *label101
   361 draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
   362 op add .localBuffer .localBuffer 1
 
   374 sensor *tmp182 .display @bufferSize
   375 op sub *tmp183 1024 *tmp182
   376 jump *label104 greaterThanEq .localBuffer *tmp183
-    * jump *label106 always
   377 label *label106
   378 drawflush .display
   379 set .localBuffer 0
-    * jump *label105 always
   380 label *label104
   381 label *label105
   382 label *label103
 
   385 read *tmp187 .memory 68
   386 jump *label108 equal .stop *tmp187
   387 jump *label5 always
-    * jump *label109 always
   388 label *label108
   389 label *label109
   390 read *tmp189 .memory 66
 
   405 label *label115
   406 read *tmp195 .memory 68
   407 jump *label113 notEqual .stop *tmp195
-    * jump *label114 always
   408 label *label114
   409 wait 0
   410 sensor *tmp196 .display @enabled
 
   413 sensor *tmp197 .display @bufferSize
   414 op sub *tmp198 1024 *tmp197
   415 jump *label117 greaterThanEq .localBuffer *tmp198
-    * jump *label119 always
   416 label *label119
   417 drawflush .display
   418 set .localBuffer 0
-    * jump *label118 always
   419 label *label117
   420 label *label118
   421 label *label116

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
    24 op add .OFFSET_X *tmp21 *tmp23
    25 op div *tmp24 -88 .ZOOM
    26 read *tmp26 .memory 70
-    * op add .OFFSET_Y *tmp24 *tmp26
+   27 op add .OFFSET_Y *tmp21 *tmp26
    28 read .JULIA .memory 72
    29 read .JULIA_X .memory 73
    30 read .JULIA_Y .memory 74
 
    54 set *tmp41 4
    55 label *label18
    56 set :multiple *tmp41
-    * op add *tmp42 :batch :multiple
+   57 op add *tmp42 :batch *tmp41
    58 write *tmp42 .memory 64
    59 jump *label19 lessThan :batch 2816
    60 jump *label14 always
    61 label *label19
    62 label *label20
-    * op mul *tmp46 11 :multiple
+   63 op mul *tmp46 11 *tmp41
    64 set :i 0
    65 label *label21
    66 jump *label23 greaterThanEq :i *tmp46
 
    83 set *tmp56 2
    84 label *label30
    85 set :adam5:dy *tmp56
-    * set :adam5:dx :adam5:dy
+   86 set :adam5:dx *tmp56
    87 jump *label25 always
    88 label *label26
    89 jump *label33 lessThan *tmp50 121
 
   131 set *tmp69 1
   132 label *label42
   133 set :adam5:dy *tmp69
-    * set :adam5:dx :adam5:dy
+  134 set :adam5:dx *tmp69
   135 jump *label25 always
   136 label *label38
   137 jump *label45 lessThan *tmp50 484
 
   161 op mul *tmp78 2 *tmp77
   162 op add :adam5:y *tmp78 1
   163 set :adam5:dy 1
-    * set :adam5:dx :adam5:dy
+  164 set :adam5:dx 1
   165 label *label25
   166 label *label24
   167 set :x :adam5:x
   168 set :y :adam5:y
   169 set :dx :adam5:dx
   170 set :dy :adam5:dy
-    * jump *label48 lessThanEq :multiple :leaderLimit
+  171 jump *label48 lessThanEq *tmp41 *tmp34
   172 label *label51
   173 jump *label48 notEqual .localBuffer 0
   174 label *label50
   175 draw col %[white]
-    * draw rect :x :y :dx :dx
+  176 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx
   177 set .lastColor %[white]
   178 set .localBuffer 2
   179 wait 0
 
   182 label *label56
   183 sensor *tmp84 .display @bufferSize
   184 op sub *tmp85 1024 *tmp84
-    * jump *label53 greaterThanEq .localBuffer *tmp85
+  185 jump *label53 greaterThanEq 2 *tmp85
   186 label *label55
   187 drawflush .display
   188 set .localBuffer 0
 
   191 label *label52
   192 label *label48
   193 label *label49
-    * set :compute:x :x
-    * set :compute:y :y
-    * op div *tmp89 :compute:x .ZOOM
+  194 set :compute:x :adam5:x
+  195 set :compute:y :adam5:y
+  196 op div *tmp89 :x .ZOOM
   197 op add :compute:zx *tmp89 .OFFSET_X
-    * op div *tmp91 :compute:y .ZOOM
+  198 op div *tmp91 :y .ZOOM
   199 op add :compute:zy *tmp91 .OFFSET_Y
   200 jump *label58 equal .JULIA false
   201 set :compute:cx .JULIA_X
 
   204 label *label58
   205 set :compute:cx :compute:zx
   206 set :compute:cy :compute:zy
-    * op sub *tmp94 :compute:cx 0.25
-    * op len :compute:p *tmp94 :compute:cy
+  207 op sub *tmp94 :compute:zx 0.25
+  208 op len :compute:p *tmp94 :compute:zy
   209 op mul *tmp96 2 :compute:p
   210 op mul *tmp97 *tmp96 :compute:p
   211 op sub *tmp98 :compute:p *tmp97
   212 op add *tmp99 *tmp98 0.25
-    * jump *label60 greaterThan :compute:cx *tmp99
+  213 jump *label60 greaterThan :compute:zx *tmp99
   214 set *tmp88 63
   215 jump *label57 always
   216 label *label60
   217 label *label61
-    * op add *tmp102 :compute:cx 1
-    * op len *tmp103 *tmp102 :compute:cy
+  218 op add *tmp102 :compute:zx 1
+  219 op len *tmp103 *tmp102 :compute:zy
   220 jump *label62 greaterThan *tmp103 0.25
   221 set *tmp88 63
   222 jump *label57 always
 
   229 jump *label69 greaterThanEq :compute:i 63
   230 set :compute:x1 :compute:zx
   231 set :compute:y1 :compute:zy
-    * op mul *tmp106 :compute:x1 :compute:x1
-    * op mul *tmp107 :compute:y1 :compute:y1
+  232 op mul *tmp106 :compute:zx :compute:zx
+  233 op mul *tmp107 :compute:zy :compute:zy
   234 op sub *tmp108 *tmp106 *tmp107
   235 op add :compute:zx *tmp108 :compute:cx
   236 op mul *tmp110 2 :compute:x1
-    * op mul *tmp111 *tmp110 :compute:y1
+  237 op mul *tmp111 *tmp110 :compute:zy
   238 op add :compute:zy *tmp111 :compute:cy
   239 op len :compute:dist :compute:zx :compute:zy
   240 jump *label70 lessThan :compute:dist 64
 
   260 label *label73
   261 set *tmp88 :compute:i
   262 jump *label57 always
-    * set *tmp88 null
   263 label *label57
   264 set :iterations *tmp88
-    * set :drawPixel:x :x
-    * set :drawPixel:y :y
-    * set :drawPixel:dx :dx
-    * set :drawPixel:dy :dy
-    * set :drawPixel:iterations :iterations
-    * jump *label75 notEqual :drawPixel:iterations 63
+  265 set :drawPixel:x :adam5:x
+  266 set :drawPixel:y :adam5:y
+  267 set :drawPixel:dx :adam5:dx
+  268 set :drawPixel:dy :adam5:dy
+  269 set :drawPixel:iterations *tmp88
+  270 jump *label75 notEqual :iterations 63
   271 set :drawPixel:color %[black]
   272 jump *label76 always
   273 label *label75
   274 jump *label77 equal .SMOOTH false
   275 jump *label80 notEqual .PALETTE 2
   276 label *label81
-    * op sub *tmp127 32 :drawPixel:iterations
+  277 op sub *tmp127 32 :iterations
   278 op abs *tmp128 *tmp127
   279 op mul *tmp129 7 *tmp128
-    * op div *tmp130 *tmp129 255
+  280 op div *tmp130 *tmp128 36.42857142857143
   281 op sub :drawPixel:r 1 *tmp130
-    * op sub *tmp132 :drawPixel:iterations 32
+  282 op sub *tmp132 :iterations 32
   283 op abs *tmp133 *tmp132
   284 op mul *tmp134 6 *tmp133
-    * op div *tmp135 *tmp134 255
+  285 op div *tmp135 *tmp133 42.5
   286 op sub :drawPixel:g 0.9411764705882353 *tmp135
-    * op sub *tmp137 32 :drawPixel:iterations
-    * op abs *tmp138 *tmp137
-    * op mul *tmp139 4 *tmp138
-    * op div *tmp140 *tmp139 255
+  287 op sub *tmp137 32 :iterations
+  288 op abs *tmp138 *tmp127
+  289 op mul *tmp139 4 *tmp128
+  290 op div *tmp140 *tmp138 63.75
   291 op add :drawPixel:b 0.47058823529411764 *tmp140
   292 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   293 jump *label79 always
   294 label *label80
   295 jump *label82 notEqual .PALETTE 3
   296 label *label83
-    * op div *tmp143 :drawPixel:iterations 63
-    * op mul *tmp144 *tmp143 360
+  297 op div *tmp143 :iterations 63
+  298 op div *tmp144 :drawPixel:iterations 0.175
   299 op sin :drawPixel:r *tmp144
-    * op div *tmp146 :drawPixel:iterations 63
-    * op mul *tmp147 *tmp146 360
-    * op cos :drawPixel:g *tmp147
-    * op sub *tmp149 :drawPixel:iterations 32
+  300 op div *tmp146 :iterations 63
+  301 op mul *tmp147 *tmp143 360
+  302 op cos :drawPixel:g *tmp144
+  303 op sub *tmp149 :iterations 32
   304 op abs *tmp150 *tmp149
   305 op mul *tmp151 4 *tmp150
-    * op div *tmp152 *tmp151 255
+  306 op div *tmp152 *tmp150 63.75
   307 op add :drawPixel:b 0.39215686274509803 *tmp152
   308 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   309 jump *label79 always
   310 label *label82
   311 jump *label84 notEqual .PALETTE 4
   312 label *label85
-    * op mul *tmp155 4 :drawPixel:iterations
-    * op div :drawPixel:r *tmp155 255
-    * op mul *tmp157 1.5 :drawPixel:iterations
-    * op div :drawPixel:g *tmp157 255
+  313 op mul *tmp155 4 :iterations
+  314 op div :drawPixel:r :drawPixel:iterations 63.75
+  315 op mul *tmp157 1.5 :iterations
+  316 op div :drawPixel:g :drawPixel:iterations 170
   317 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   318 jump *label79 always
   319 label *label84
-    * op mul *tmp160 4 :drawPixel:iterations
-    * op div *tmp161 *tmp160 255
+  320 op mul *tmp160 4 :iterations
+  321 op div *tmp161 :drawPixel:iterations 63.75
   322 op sub :drawPixel:r 1 *tmp161
   323 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   324 label *label79
   325 jump *label78 always
   326 label *label77
-    * read :drawPixel:color .memory :drawPixel:iterations
+  327 read :drawPixel:color .memory :iterations
   328 label *label78
   329 label *label76
   330 jump *label86 lessThan .localBuffer 254
 
   357 label *label102
   358 jump *label99 strictNotEqual :drawPixel:color .lastColor
   359 label *label101
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  360 draw rect :x :y :dx :dy
   361 op add .localBuffer .localBuffer 1
   362 jump *label100 always
   363 label *label99
   364 draw col :drawPixel:color
-    * draw rect :drawPixel:x :drawPixel:y :drawPixel:dx :drawPixel:dy
+  365 draw rect :x :y :dx :dy
   366 set .lastColor :drawPixel:color
   367 op add .localBuffer .localBuffer 2
   368 label *label100
 
   390 op add *tmp2 *tmp189 1
   391 write *tmp2 .memory 66
   392 read *tmp191 .memory 65
-    * op add *tmp192 *tmp191 :iterations
+  393 op add *tmp192 *tmp191 *tmp88
   394 write *tmp192 .memory 65
   395 label *label22
   396 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-14 instructions):
 
    22 op div *tmp21 -88 .ZOOM
    23 read *tmp23 .memory 69
    24 op add .OFFSET_X *tmp21 *tmp23
-    * op div *tmp24 -88 .ZOOM
    25 read *tmp26 .memory 70
    26 op add .OFFSET_Y *tmp21 *tmp26
    27 read .JULIA .memory 72
 
    37 label *label10
    38 set *tmp34 99
    39 label *label11
-    * set :leaderLimit *tmp34
    40 label *label12
    41 wait 0
    42 read *tmp37 .memory 68
 
    51 label *label17
    52 set *tmp41 4
    53 label *label18
-    * set :multiple *tmp41
    54 op add *tmp42 :batch *tmp41
    55 write *tmp42 .memory 64
    56 jump *label19 lessThan :batch 2816
 
   188 label *label52
   189 label *label48
   190 label *label49
-    * set :compute:x :adam5:x
-    * set :compute:y :adam5:y
-    * op div *tmp89 :x .ZOOM
+  191 op div *tmp89 :adam5:x .ZOOM
   192 op add :compute:zx *tmp89 .OFFSET_X
-    * op div *tmp91 :y .ZOOM
+  193 op div *tmp91 :adam5:y .ZOOM
   194 op add :compute:zy *tmp91 .OFFSET_Y
   195 jump *label58 equal .JULIA false
   196 set :compute:cx .JULIA_X
 
   223 label *label67
   224 jump *label69 greaterThanEq :compute:i 63
   225 set :compute:x1 :compute:zx
-    * set :compute:y1 :compute:zy
   226 op mul *tmp106 :compute:zx :compute:zx
   227 op mul *tmp107 :compute:zy :compute:zy
   228 op sub *tmp108 *tmp106 *tmp107
 
   256 jump *label57 always
   257 label *label57
   258 set :iterations *tmp88
-    * set :drawPixel:x :adam5:x
-    * set :drawPixel:y :adam5:y
-    * set :drawPixel:dx :adam5:dx
-    * set :drawPixel:dy :adam5:dy
   259 set :drawPixel:iterations *tmp88
-    * jump *label75 notEqual :iterations 63
+  260 jump *label75 notEqual *tmp88 63
   261 set :drawPixel:color %[black]
   262 jump *label76 always
   263 label *label75
   264 jump *label77 equal .SMOOTH false
   265 jump *label80 notEqual .PALETTE 2
   266 label *label81
-    * op sub *tmp127 32 :iterations
+  267 op sub *tmp127 32 *tmp88
   268 op abs *tmp128 *tmp127
-    * op mul *tmp129 7 *tmp128
   269 op div *tmp130 *tmp128 36.42857142857143
   270 op sub :drawPixel:r 1 *tmp130
-    * op sub *tmp132 :iterations 32
+  271 op sub *tmp132 *tmp88 32
   272 op abs *tmp133 *tmp132
-    * op mul *tmp134 6 *tmp133
   273 op div *tmp135 *tmp133 42.5
   274 op sub :drawPixel:g 0.9411764705882353 *tmp135
-    * op sub *tmp137 32 :iterations
+  275 op sub *tmp137 32 *tmp88
   276 op abs *tmp138 *tmp127
-    * op mul *tmp139 4 *tmp128
-    * op div *tmp140 *tmp138 63.75
+  277 op div *tmp140 *tmp128 63.75
   278 op add :drawPixel:b 0.47058823529411764 *tmp140
   279 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   280 jump *label79 always
   281 label *label80
   282 jump *label82 notEqual .PALETTE 3
   283 label *label83
-    * op div *tmp143 :iterations 63
-    * op div *tmp144 :drawPixel:iterations 0.175
+  284 op div *tmp143 *tmp88 63
+  285 op div *tmp144 *tmp88 0.175
   286 op sin :drawPixel:r *tmp144
-    * op div *tmp146 :iterations 63
-    * op mul *tmp147 *tmp143 360
+  287 op div *tmp146 *tmp88 63
+  288 op div *tmp147 :iterations 0.175
   289 op cos :drawPixel:g *tmp144
-    * op sub *tmp149 :iterations 32
+  290 op sub *tmp149 *tmp88 32
   291 op abs *tmp150 *tmp149
-    * op mul *tmp151 4 *tmp150
   292 op div *tmp152 *tmp150 63.75
   293 op add :drawPixel:b 0.39215686274509803 *tmp152
   294 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   296 label *label82
   297 jump *label84 notEqual .PALETTE 4
   298 label *label85
-    * op mul *tmp155 4 :iterations
-    * op div :drawPixel:r :drawPixel:iterations 63.75
-    * op mul *tmp157 1.5 :iterations
-    * op div :drawPixel:g :drawPixel:iterations 170
+  299 op mul *tmp155 4 *tmp88
+  300 op div :drawPixel:r *tmp88 63.75
+  301 op mul *tmp157 1.5 *tmp88
+  302 op div :drawPixel:g *tmp88 170
   303 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   304 jump *label79 always
   305 label *label84
-    * op mul *tmp160 4 :iterations
-    * op div *tmp161 :drawPixel:iterations 63.75
+  306 op mul *tmp160 4 *tmp88
+  307 op div *tmp161 *tmp88 63.75
   308 op sub :drawPixel:r 1 *tmp161
   309 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   310 label *label79
   311 jump *label78 always
   312 label *label77
-    * read :drawPixel:color .memory :iterations
+  313 read :drawPixel:color .memory *tmp88
   314 label *label78
   315 label *label76
   316 jump *label86 lessThan .localBuffer 254
 
   343 label *label102
   344 jump *label99 strictNotEqual :drawPixel:color .lastColor
   345 label *label101
-    * draw rect :x :y :dx :dy
+  346 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   347 op add .localBuffer .localBuffer 1
   348 jump *label100 always
   349 label *label99
   350 draw col :drawPixel:color
-    * draw rect :x :y :dx :dy
+  351 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   352 set .lastColor :drawPixel:color
   353 op add .localBuffer .localBuffer 2
   354 label *label100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   161 set :adam5:dx 1
   162 label *label25
   163 label *label24
-    * set :x :adam5:x
-    * set :y :adam5:y
-    * set :dx :adam5:dx
-    * set :dy :adam5:dy
   164 jump *label48 lessThanEq *tmp41 *tmp34
   165 label *label51
   166 jump *label48 notEqual .localBuffer 0
 
   252 jump *label57 always
   253 label *label57
   254 set :iterations *tmp88
-    * set :drawPixel:iterations *tmp88
   255 jump *label75 notEqual *tmp88 63
   256 set :drawPixel:color %[black]
   257 jump *label76 always
 
   267 op abs *tmp133 *tmp132
   268 op div *tmp135 *tmp133 42.5
   269 op sub :drawPixel:g 0.9411764705882353 *tmp135
-    * op sub *tmp137 32 *tmp88
-    * op abs *tmp138 *tmp127
   270 op div *tmp140 *tmp128 63.75
   271 op add :drawPixel:b 0.47058823529411764 *tmp140
   272 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
 
   274 label *label80
   275 jump *label82 notEqual .PALETTE 3
   276 label *label83
-    * op div *tmp143 *tmp88 63
   277 op div *tmp144 *tmp88 0.175
   278 op sin :drawPixel:r *tmp144
-    * op div *tmp146 *tmp88 63
-    * op div *tmp147 :iterations 0.175
+  279 op div *tmp147 *tmp88 0.175
   280 op cos :drawPixel:g *tmp144
   281 op sub *tmp149 *tmp88 32
   282 op abs *tmp150 *tmp149
 
   287 label *label82
   288 jump *label84 notEqual .PALETTE 4
   289 label *label85
-    * op mul *tmp155 4 *tmp88
   290 op div :drawPixel:r *tmp88 63.75
-    * op mul *tmp157 1.5 *tmp88
   291 op div :drawPixel:g *tmp88 170
   292 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
   293 jump *label79 always
   294 label *label84
-    * op mul *tmp160 4 *tmp88
   295 op div *tmp161 *tmp88 63.75
   296 op sub :drawPixel:r 1 *tmp161
   297 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-2 instructions):
 
   251 set *tmp88 :compute:i
   252 jump *label57 always
   253 label *label57
-    * set :iterations *tmp88
   254 jump *label75 notEqual *tmp88 63
   255 set :drawPixel:color %[black]
   256 jump *label76 always
 
   275 label *label83
   276 op div *tmp144 *tmp88 0.175
   277 op sin :drawPixel:r *tmp144
-    * op div *tmp147 *tmp88 0.175
   278 op cos :drawPixel:g *tmp144
   279 op sub *tmp149 *tmp88 32
   280 op abs *tmp150 *tmp149

Modifications by Iterated phase, Loop Hoisting, pass 1, iteration 1:
 
    59 label *label20
    60 op mul *tmp46 11 *tmp41
    61 set :i 0
+   62 op mul *tmp47 :batch 11
    63 label *label21
    64 jump *label23 greaterThanEq :i *tmp46
-    * op mul *tmp47 :batch 11
    65 op add :adam5:index *tmp47 :i
    66 op idiv *tmp50 :adam5:index 16
    67 jump *label28 lessThan *tmp50 0

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     2 label *label0
     3 label *label1
     4 jump *label0 equal .display null
-    * label *label3
     5 jump *label0 equal .memory null
     6 label *label2
     7 label *label4
 
    61 op mul *tmp47 :batch 11
    62 label *label21
    63 jump *label23 greaterThanEq :i *tmp46
+   64 label *label121
    65 op add :adam5:index *tmp47 :i
    66 op idiv *tmp50 :adam5:index 16
    67 jump *label28 lessThan *tmp50 0
 
   218 set :compute:i 0
   219 label *label67
   220 jump *label69 greaterThanEq :compute:i 63
+  221 label *label122
   222 set :compute:x1 :compute:zx
   223 op mul *tmp106 :compute:zx :compute:zx
   224 op mul *tmp107 :compute:zy :compute:zy
 
   234 label *label71
   235 label *label68
   236 op add :compute:i :compute:i 1
-    * jump *label67 always
+  237 jump *label122 lessThan :compute:i 63
   238 label *label69
   239 set *tmp88 :compute:i
   240 jump *label57 always
 
   303 jump *label86 lessThan .localBuffer 254
   304 label *label89
   305 jump *label91 lessThanEq .localBuffer 0
-    * label *label93
+  306 label *label123
   307 read *tmp171 .memory 68
   308 jump *label91 notEqual .stop *tmp171
-    * label *label92
   309 wait 0
   310 sensor *tmp172 .display @enabled
   311 jump *label95 equal *tmp172 false
 
   320 label *label96
   321 label *label94
   322 label *label90
-    * jump *label89 always
+  323 jump *label123 greaterThan .localBuffer 0
   324 label *label91
   325 label *label88
   326 label *label86
 
   366 write *tmp192 .memory 65
   367 label *label22
   368 op add :i :i 1
-    * jump *label21 always
+  369 jump *label121 lessThan :i *tmp46
   370 label *label23
   371 label *label13
   372 jump *label12 always
   373 label *label14
   374 label *label111
   375 jump *label113 lessThanEq .localBuffer 0
-    * label *label115
+  376 label *label124
   377 read *tmp195 .memory 68
   378 jump *label113 notEqual .stop *tmp195
-    * label *label114
   379 wait 0
   380 sensor *tmp196 .display @enabled
   381 jump *label117 equal *tmp196 false
 
   390 label *label118
   391 label *label116
   392 label *label112
-    * jump *label111 always
+  393 jump *label124 greaterThan .localBuffer 0
   394 label *label113
   395 label *label110
   396 label *label5

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-20 instructions):
 
    29 read .PALETTE .memory 75
    30 op greaterThan .SMOOTH .PALETTE 1
    31 read .ALL_PASS_COLORING .memory 76
-    * read *tmp33 .memory 77
-    * jump *label10 equal *tmp33 false
-    * op sub *tmp34 1 .ALL_PASS_COLORING
-    * jump *label11 always
-    * label *label10
-    * set *tmp34 99
-    * label *label11
+   32 read *tmp33 .memory 77
+   33 op sub *tmp201 1 .ALL_PASS_COLORING
+   34 select *tmp34 notEqual *tmp33 false *tmp201 99
    35 label *label12
    36 wait 0
    37 read *tmp37 .memory 68
 
    40 label *label15
    41 label *label16
    42 read :batch .memory 64
-    * jump *label17 lessThan :batch 1408
-    * set *tmp41 1
-    * jump *label18 always
-    * label *label17
-    * set *tmp41 4
-    * label *label18
+   43 select *tmp41 greaterThanEq :batch 1408 1 4
    44 op add *tmp42 :batch *tmp41
    45 write *tmp42 .memory 64
    46 jump *label19 lessThan :batch 2816
 
    64 op mul :adam5:x 4 *tmp52
    65 op idiv *tmp54 :adam5:index 44
    66 op mul :adam5:y 4 *tmp54
-    * jump *label29 equal .ALL_PASS_COLORING false
-    * set *tmp56 4
-    * jump *label30 always
-    * label *label29
-    * set *tmp56 2
-    * label *label30
+   67 select *tmp56 notEqual .ALL_PASS_COLORING false 4 2
    68 set :adam5:dy *tmp56
    69 set :adam5:dx *tmp56
    70 jump *label25 always
 
    80 op add :adam5:x *tmp58 2
    81 op idiv *tmp60 :adam5:index 44
    82 op mul :adam5:y 4 *tmp60
-    * jump *label34 equal .ALL_PASS_COLORING false
-    * set *tmp62 2
-    * jump *label35 always
-    * label *label34
-    * set *tmp62 1
-    * label *label35
+   83 select *tmp62 notEqual .ALL_PASS_COLORING false 2 1
    84 set :adam5:dx *tmp62
-    * jump *label36 equal .ALL_PASS_COLORING false
-    * set *tmp63 4
-    * jump *label37 always
-    * label *label36
-    * set *tmp63 2
-    * label *label37
+   85 select *tmp63 notEqual .ALL_PASS_COLORING false 4 2
    86 set :adam5:dy *tmp63
    87 jump *label25 always
    88 label *label31
 
    97 op idiv *tmp66 :adam5:index 88
    98 op mul *tmp67 4 *tmp66
    99 op add :adam5:y *tmp67 2
-    * jump *label41 equal .ALL_PASS_COLORING false
-    * set *tmp69 2
-    * jump *label42 always
-    * label *label41
-    * set *tmp69 1
-    * label *label42
+  100 select *tmp69 notEqual .ALL_PASS_COLORING false 2 1
   101 set :adam5:dy *tmp69
   102 set :adam5:dx *tmp69
   103 jump *label25 always
 
   114 op idiv *tmp73 :adam5:index 88
   115 op mul :adam5:y 2 *tmp73
   116 set :adam5:dx 1
-    * jump *label46 equal .ALL_PASS_COLORING false
-    * set *tmp75 2
-    * jump *label47 always
-    * label *label46
-    * set *tmp75 1
-    * label *label47
+  117 select *tmp75 notEqual .ALL_PASS_COLORING false 2 1
   118 set :adam5:dy *tmp75
   119 jump *label25 always
   120 label *label43
 
   128 label *label25
   129 label *label24
   130 jump *label48 lessThanEq *tmp41 *tmp34
-    * label *label51
   131 jump *label48 notEqual .localBuffer 0
-    * label *label50
   132 draw col %[white]
   133 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx
   134 set .lastColor %[white]
 
   136 wait 0
   137 sensor *tmp83 .display @enabled
   138 jump *label53 equal *tmp83 false
-    * label *label56
   139 sensor *tmp84 .display @bufferSize
   140 op sub *tmp85 1024 *tmp84
   141 jump *label53 greaterThanEq 2 *tmp85
-    * label *label55
   142 drawflush .display
   143 set .localBuffer 0
   144 label *label53
 
   271 wait 0
   272 sensor *tmp172 .display @enabled
   273 jump *label95 equal *tmp172 false
-    * label *label98
   274 sensor *tmp173 .display @bufferSize
   275 op sub *tmp174 1024 *tmp173
   276 jump *label95 greaterThanEq .localBuffer *tmp174
-    * label *label97
   277 drawflush .display
   278 set .localBuffer 0
   279 label *label95
 
   286 label *label86
   287 label *label87
   288 jump *label99 lessThanEq .localBuffer 0
-    * label *label102
   289 jump *label99 strictNotEqual :drawPixel:color .lastColor
-    * label *label101
   290 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
   291 op add .localBuffer .localBuffer 1
   292 jump *label100 always
 
   299 wait 0
   300 sensor *tmp181 .display @enabled
   301 jump *label104 equal *tmp181 false
-    * label *label107
   302 sensor *tmp182 .display @bufferSize
   303 op sub *tmp183 1024 *tmp182
   304 jump *label104 greaterThanEq .localBuffer *tmp183
-    * label *label106
   305 drawflush .display
   306 set .localBuffer 0
   307 label *label104
 
   335 wait 0
   336 sensor *tmp196 .display @enabled
   337 jump *label117 equal *tmp196 false
-    * label *label120
   338 sensor *tmp197 .display @bufferSize
   339 op sub *tmp198 1024 *tmp197
   340 jump *label117 greaterThanEq .localBuffer *tmp198
-    * label *label119
   341 drawflush .display
   342 set .localBuffer 0
   343 label *label117

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:131:5 (-10 instructions):
 
    55 label *label121
    56 op add :adam5:index *tmp47 :i
    57 op idiv *tmp50 :adam5:index 16
-    * jump *label28 lessThan *tmp50 0
-    * jump *label27 lessThan *tmp50 121
-    * label *label28
-    * jump *label26 always
+   58 multijump *tmp50 0 0 (m:*label126)
+   59 multilabel *label131 (m:*label126)
+   60 label *label125
+   61 op sub :adam5:index :adam5:index 15488
+   62 op mod :adam5:x :adam5:index 176
+   63 op idiv *tmp77 :adam5:index 176
+   64 op mul *tmp78 2 *tmp77
+   65 op add :adam5:y *tmp78 1
+   66 set :adam5:dy 1
+   67 set :adam5:dx 1
+   68 jump *label25 always
+   69 multilabel *label127 (m:*label126)
    70 label *label27
    71 op mod *tmp52 :adam5:index 44
    72 op mul :adam5:x 4 *tmp52
 
    77 set :adam5:dx *tmp56
    78 jump *label25 always
    79 label *label26
-    * jump *label33 lessThan *tmp50 121
-    * jump *label32 lessThan *tmp50 242
-    * label *label33
-    * jump *label31 always
+   80 multilabel *label128 (m:*label126)
    81 label *label32
    82 op sub :adam5:index :adam5:index 1936
    83 op mod *tmp57 :adam5:index 44
 
    91 set :adam5:dy *tmp63
    92 jump *label25 always
    93 label *label31
-    * jump *label40 lessThan *tmp50 242
-    * jump *label39 lessThan *tmp50 484
-    * label *label40
-    * jump *label38 always
+   94 multilabel *label129 (m:*label126)
    95 label *label39
    96 op sub :adam5:index :adam5:index 3872
    97 op mod *tmp64 :adam5:index 88
 
   104 set :adam5:dx *tmp69
   105 jump *label25 always
   106 label *label38
-    * jump *label45 lessThan *tmp50 484
-    * jump *label44 lessThan *tmp50 968
-    * label *label45
-    * jump *label43 always
+  107 jump *label25 always
+  108 multilabel *label130 (m:*label126)
   109 label *label44
   110 op sub :adam5:index :adam5:index 7744
   111 op mod *tmp70 :adam5:index 88
 
   116 set :adam5:dx 1
   117 select *tmp75 notEqual .ALL_PASS_COLORING false 2 1
   118 set :adam5:dy *tmp75
-    * jump *label25 always
-    * label *label43
-    * op sub :adam5:index :adam5:index 15488
-    * op mod :adam5:x :adam5:index 176
-    * op idiv *tmp77 :adam5:index 176
-    * op mul *tmp78 2 *tmp77
-    * op add :adam5:y *tmp78 1
-    * set :adam5:dy 1
-    * set :adam5:dx 1
   119 label *label25
   120 label *label24
   121 jump *label48 lessThanEq *tmp41 *tmp34

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    51 set :i 0
    52 op mul *tmp47 :batch 11
    53 label *label21
-    * jump *label23 greaterThanEq :i *tmp46
+   54 jump *label23 greaterThanEq 0 *tmp46
    55 label *label121
    56 op add :adam5:index *tmp47 :i
    57 op idiv *tmp50 :adam5:index 16
 
   170 label *label64
   171 set :compute:i 0
   172 label *label67
-    * jump *label69 greaterThanEq :compute:i 63
+  173 jump *label69 greaterThanEq 0 63
   174 label *label122
   175 set :compute:x1 :compute:zx
   176 op mul *tmp106 :compute:zx :compute:zx

Modifications by Fast-dispatch case at mandelbrot-compute.mnd:223:9 (-2 instructions):
 
   210 jump *label76 always
   211 label *label75
   212 jump *label77 equal .SMOOTH false
-    * jump *label80 notEqual .PALETTE 2
+  213 multijump .PALETTE 0 0 (m:*label133)
+  214 multilabel *label138 (m:*label133)
+  215 multilabel *label134 (m:*label133)
+  216 label *label132
+  217 op div *tmp161 *tmp88 63.75
+  218 op sub :drawPixel:r 1 *tmp161
+  219 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
+  220 jump *label79 always
+  221 multilabel *label135 (m:*label133)
   222 label *label81
   223 op sub *tmp127 32 *tmp88
   224 op abs *tmp128 *tmp127
 
   233 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   234 jump *label79 always
   235 label *label80
-    * jump *label82 notEqual .PALETTE 3
+  236 multilabel *label136 (m:*label133)
   237 label *label83
   238 op div *tmp144 *tmp88 0.175
   239 op sin :drawPixel:r *tmp144
 
   245 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
   246 jump *label79 always
   247 label *label82
-    * jump *label84 notEqual .PALETTE 4
+  248 multilabel *label137 (m:*label133)
   249 label *label85
   250 op div :drawPixel:r *tmp88 63.75
   251 op div :drawPixel:g *tmp88 170
   252 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
-    * jump *label79 always
-    * label *label84
-    * op div *tmp161 *tmp88 63.75
-    * op sub :drawPixel:r 1 *tmp161
-    * packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   253 label *label79
   254 jump *label78 always
   255 label *label77

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   170 label *label64
   171 set :compute:i 0
   172 label *label67
-    * jump *label69 greaterThanEq 0 63
   173 label *label122
   174 set :compute:x1 :compute:zx
   175 op mul *tmp106 :compute:zx :compute:zx

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-2 instructions):
 
    27 read .JULIA_X .memory 73
    28 read .JULIA_Y .memory 74
    29 read .PALETTE .memory 75
-    * op greaterThan .SMOOTH .PALETTE 1
    30 read .ALL_PASS_COLORING .memory 76
    31 read *tmp33 .memory 77
    32 op sub *tmp201 1 .ALL_PASS_COLORING
 
    50 set :i 0
    51 op mul *tmp47 :batch 11
    52 label *label21
-    * jump *label23 greaterThanEq 0 *tmp46
+   53 jump *label23 lessThanEq *tmp41 0
    54 label *label121
    55 op add :adam5:index *tmp47 :i
    56 op idiv *tmp50 :adam5:index 16
 
   127 sensor *tmp83 .display @enabled
   128 jump *label53 equal *tmp83 false
   129 sensor *tmp84 .display @bufferSize
-    * op sub *tmp85 1024 *tmp84
-    * jump *label53 greaterThanEq 2 *tmp85
+  130 jump *label53 greaterThanEq *tmp84 1022
   131 drawflush .display
   132 set .localBuffer 0
   133 label *label53
 
   190 jump *label57 always
   191 label *label65
   192 label *label66
-    * jump *label72 equal .SMOOTH false
+  193 jump *label72 lessThanEq .PALETTE 1
   194 op log *tmp117 :compute:dist
   195 op mul *tmp118 *tmp117 0.36067376022224085
   196 op log *tmp119 *tmp118
 
   206 set :drawPixel:color %[black]
   207 jump *label76 always
   208 label *label75
-    * jump *label77 equal .SMOOTH false
+  209 jump *label77 lessThanEq .PALETTE 1
   210 multijump .PALETTE 0 0 (m:*label133)
   211 multilabel *label138 (m:*label133)
   212 multilabel *label134 (m:*label133)

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-2 instructions):
 
   101 select *tmp69 notEqual .ALL_PASS_COLORING false 2 1
   102 set :adam5:dy *tmp69
   103 set :adam5:dx *tmp69
-    * jump *label25 always
   104 label *label38
   105 jump *label25 always
   106 multilabel *label130 (m:*label126)
 
   199 label *label72
   200 label *label73
   201 set *tmp88 :compute:i
-    * jump *label57 always
   202 label *label57
   203 jump *label75 notEqual *tmp88 63
   204 set :drawPixel:color %[black]

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-3 instructions):
 
    84 op add :adam5:x *tmp58 2
    85 op idiv *tmp60 :adam5:index 44
    86 op mul :adam5:y 4 *tmp60
-    * select *tmp62 notEqual .ALL_PASS_COLORING false 2 1
-    * set :adam5:dx *tmp62
-    * select *tmp63 notEqual .ALL_PASS_COLORING false 4 2
-    * set :adam5:dy *tmp63
+   87 select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1
+   88 select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2
    89 jump *label25 always
    90 label *label31
    91 multilabel *label129 (m:*label126)
 
   110 op idiv *tmp73 :adam5:index 88
   111 op mul :adam5:y 2 *tmp73
   112 set :adam5:dx 1
-    * select *tmp75 notEqual .ALL_PASS_COLORING false 2 1
-    * set :adam5:dy *tmp75
+  113 select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1
   114 label *label25
   115 label *label24
   116 jump *label48 lessThanEq *tmp41 *tmp34

Modifications by Unroll loop at mandelbrot-compute.mnd:193:9 (+743 instructions):
 
   162 label *label63
   163 label *label59
   164 label *label64
-    * set :compute:i 0
-    * label *label67
-    * label *label122
-    * set :compute:x1 :compute:zx
-    * op mul *tmp106 :compute:zx :compute:zx
-    * op mul *tmp107 :compute:zy :compute:zy
-    * op sub *tmp108 *tmp106 *tmp107
-    * op add :compute:zx *tmp108 :compute:cx
-    * op mul *tmp110 2 :compute:x1
-    * op mul *tmp111 *tmp110 :compute:zy
-    * op add :compute:zy *tmp111 :compute:cy
-    * op len :compute:dist :compute:zx :compute:zy
-    * jump *label70 lessThan :compute:dist 64
-    * jump *label66 always
-    * label *label70
-    * label *label71
-    * label *label68
-    * op add :compute:i :compute:i 1
-    * jump *label122 lessThan :compute:i 63
-    * label *label69
+  165 set :compute:i 0
+  166 label *label139
+  167 set :compute:x1 :compute:zx
+  168 op mul *tmp106 :compute:zx :compute:zx
+  169 op mul *tmp107 :compute:zy :compute:zy
+  170 op sub *tmp108 *tmp106 *tmp107
+  171 op add :compute:zx *tmp108 :compute:cx
+  172 op mul *tmp110 2 :compute:x1
+  173 op mul *tmp111 *tmp110 :compute:zy
+  174 op add :compute:zy *tmp111 :compute:cy
+  175 op len :compute:dist :compute:zx :compute:zy
+  176 jump *label140 lessThan :compute:dist 64
+  177 jump *label66 always
+  178 label *label140
+  179 label *label141
+  180 label *label142
+  181 op add :compute:i :compute:i 1
+  182 set :compute:x1 :compute:zx
+  183 op mul *tmp106 :compute:zx :compute:zx
+  184 op mul *tmp107 :compute:zy :compute:zy
+  185 op sub *tmp108 *tmp106 *tmp107
+  186 op add :compute:zx *tmp108 :compute:cx
+  187 op mul *tmp110 2 :compute:x1
+  188 op mul *tmp111 *tmp110 :compute:zy
+  189 op add :compute:zy *tmp111 :compute:cy
+  190 op len :compute:dist :compute:zx :compute:zy
+  191 jump *label143 lessThan :compute:dist 64
+  192 jump *label66 always
+  193 label *label143
+  194 label *label144
+  195 label *label145
+  196 op add :compute:i :compute:i 1
+  197 set :compute:x1 :compute:zx
+  198 op mul *tmp106 :compute:zx :compute:zx
+  199 op mul *tmp107 :compute:zy :compute:zy
+  200 op sub *tmp108 *tmp106 *tmp107
+  201 op add :compute:zx *tmp108 :compute:cx
+  202 op mul *tmp110 2 :compute:x1
+  203 op mul *tmp111 *tmp110 :compute:zy
+  204 op add :compute:zy *tmp111 :compute:cy
+  205 op len :compute:dist :compute:zx :compute:zy
+  206 jump *label146 lessThan :compute:dist 64
+  207 jump *label66 always
+  208 label *label146
+  209 label *label147
+  210 label *label148
+  211 op add :compute:i :compute:i 1
+  212 set :compute:x1 :compute:zx
+  213 op mul *tmp106 :compute:zx :compute:zx
+  214 op mul *tmp107 :compute:zy :compute:zy
+  215 op sub *tmp108 *tmp106 *tmp107
+  216 op add :compute:zx *tmp108 :compute:cx
+  217 op mul *tmp110 2 :compute:x1
+  218 op mul *tmp111 *tmp110 :compute:zy
+  219 op add :compute:zy *tmp111 :compute:cy
+  220 op len :compute:dist :compute:zx :compute:zy
+  221 jump *label149 lessThan :compute:dist 64
+  222 jump *label66 always
+  223 label *label149
+  224 label *label150
+  225 label *label151
+  226 op add :compute:i :compute:i 1
+  227 set :compute:x1 :compute:zx
+  228 op mul *tmp106 :compute:zx :compute:zx
+  229 op mul *tmp107 :compute:zy :compute:zy
+  230 op sub *tmp108 *tmp106 *tmp107
+  231 op add :compute:zx *tmp108 :compute:cx
+  232 op mul *tmp110 2 :compute:x1
+  233 op mul *tmp111 *tmp110 :compute:zy
+  234 op add :compute:zy *tmp111 :compute:cy
+  235 op len :compute:dist :compute:zx :compute:zy
+  236 jump *label152 lessThan :compute:dist 64
+  237 jump *label66 always
+  238 label *label152
+  239 label *label153
+  240 label *label154
+  241 op add :compute:i :compute:i 1
+  242 set :compute:x1 :compute:zx
+  243 op mul *tmp106 :compute:zx :compute:zx
+  244 op mul *tmp107 :compute:zy :compute:zy
+  245 op sub *tmp108 *tmp106 *tmp107
+  246 op add :compute:zx *tmp108 :compute:cx
+  247 op mul *tmp110 2 :compute:x1
+  248 op mul *tmp111 *tmp110 :compute:zy
+  249 op add :compute:zy *tmp111 :compute:cy
+  250 op len :compute:dist :compute:zx :compute:zy
+  251 jump *label155 lessThan :compute:dist 64
+  252 jump *label66 always
+  253 label *label155
+  254 label *label156
+  255 label *label157
+  256 op add :compute:i :compute:i 1
+  257 set :compute:x1 :compute:zx
+  258 op mul *tmp106 :compute:zx :compute:zx
+  259 op mul *tmp107 :compute:zy :compute:zy
+  260 op sub *tmp108 *tmp106 *tmp107
+  261 op add :compute:zx *tmp108 :compute:cx
+  262 op mul *tmp110 2 :compute:x1
+  263 op mul *tmp111 *tmp110 :compute:zy
+  264 op add :compute:zy *tmp111 :compute:cy
+  265 op len :compute:dist :compute:zx :compute:zy
+  266 jump *label158 lessThan :compute:dist 64
+  267 jump *label66 always
+  268 label *label158
+  269 label *label159
+  270 label *label160
+  271 op add :compute:i :compute:i 1
+  272 set :compute:x1 :compute:zx
+  273 op mul *tmp106 :compute:zx :compute:zx
+  274 op mul *tmp107 :compute:zy :compute:zy
+  275 op sub *tmp108 *tmp106 *tmp107
+  276 op add :compute:zx *tmp108 :compute:cx
+  277 op mul *tmp110 2 :compute:x1
+  278 op mul *tmp111 *tmp110 :compute:zy
+  279 op add :compute:zy *tmp111 :compute:cy
+  280 op len :compute:dist :compute:zx :compute:zy
+  281 jump *label161 lessThan :compute:dist 64
+  282 jump *label66 always
+  283 label *label161
+  284 label *label162
+  285 label *label163
+  286 op add :compute:i :compute:i 1
+  287 set :compute:x1 :compute:zx
+  288 op mul *tmp106 :compute:zx :compute:zx
+  289 op mul *tmp107 :compute:zy :compute:zy
+  290 op sub *tmp108 *tmp106 *tmp107
+  291 op add :compute:zx *tmp108 :compute:cx
+  292 op mul *tmp110 2 :compute:x1
+  293 op mul *tmp111 *tmp110 :compute:zy
+  294 op add :compute:zy *tmp111 :compute:cy
+  295 op len :compute:dist :compute:zx :compute:zy
+  296 jump *label164 lessThan :compute:dist 64
+  297 jump *label66 always
+  298 label *label164
+  299 label *label165
+  300 label *label166
+  301 op add :compute:i :compute:i 1
+  302 set :compute:x1 :compute:zx
+  303 op mul *tmp106 :compute:zx :compute:zx
+  304 op mul *tmp107 :compute:zy :compute:zy
+  305 op sub *tmp108 *tmp106 *tmp107
+  306 op add :compute:zx *tmp108 :compute:cx
+  307 op mul *tmp110 2 :compute:x1
+  308 op mul *tmp111 *tmp110 :compute:zy
+  309 op add :compute:zy *tmp111 :compute:cy
+  310 op len :compute:dist :compute:zx :compute:zy
+  311 jump *label167 lessThan :compute:dist 64
+  312 jump *label66 always
+  313 label *label167
+  314 label *label168
+  315 label *label169
+  316 op add :compute:i :compute:i 1
+  317 set :compute:x1 :compute:zx
+  318 op mul *tmp106 :compute:zx :compute:zx
+  319 op mul *tmp107 :compute:zy :compute:zy
+  320 op sub *tmp108 *tmp106 *tmp107
+  321 op add :compute:zx *tmp108 :compute:cx
+  322 op mul *tmp110 2 :compute:x1
+  323 op mul *tmp111 *tmp110 :compute:zy
+  324 op add :compute:zy *tmp111 :compute:cy
+  325 op len :compute:dist :compute:zx :compute:zy
+  326 jump *label170 lessThan :compute:dist 64
+  327 jump *label66 always
+  328 label *label170
+  329 label *label171
+  330 label *label172
+  331 op add :compute:i :compute:i 1
+  332 set :compute:x1 :compute:zx
+  333 op mul *tmp106 :compute:zx :compute:zx
+  334 op mul *tmp107 :compute:zy :compute:zy
+  335 op sub *tmp108 *tmp106 *tmp107
+  336 op add :compute:zx *tmp108 :compute:cx
+  337 op mul *tmp110 2 :compute:x1
+  338 op mul *tmp111 *tmp110 :compute:zy
+  339 op add :compute:zy *tmp111 :compute:cy
+  340 op len :compute:dist :compute:zx :compute:zy
+  341 jump *label173 lessThan :compute:dist 64
+  342 jump *label66 always
+  343 label *label173
+  344 label *label174
+  345 label *label175
+  346 op add :compute:i :compute:i 1
+  347 set :compute:x1 :compute:zx
+  348 op mul *tmp106 :compute:zx :compute:zx
+  349 op mul *tmp107 :compute:zy :compute:zy
+  350 op sub *tmp108 *tmp106 *tmp107
+  351 op add :compute:zx *tmp108 :compute:cx
+  352 op mul *tmp110 2 :compute:x1
+  353 op mul *tmp111 *tmp110 :compute:zy
+  354 op add :compute:zy *tmp111 :compute:cy
+  355 op len :compute:dist :compute:zx :compute:zy
+  356 jump *label176 lessThan :compute:dist 64
+  357 jump *label66 always
+  358 label *label176
+  359 label *label177
+  360 label *label178
+  361 op add :compute:i :compute:i 1
+  362 set :compute:x1 :compute:zx
+  363 op mul *tmp106 :compute:zx :compute:zx
+  364 op mul *tmp107 :compute:zy :compute:zy
+  365 op sub *tmp108 *tmp106 *tmp107
+  366 op add :compute:zx *tmp108 :compute:cx
+  367 op mul *tmp110 2 :compute:x1
+  368 op mul *tmp111 *tmp110 :compute:zy
+  369 op add :compute:zy *tmp111 :compute:cy
+  370 op len :compute:dist :compute:zx :compute:zy
+  371 jump *label179 lessThan :compute:dist 64
+  372 jump *label66 always
+  373 label *label179
+  374 label *label180
+  375 label *label181
+  376 op add :compute:i :compute:i 1
+  377 set :compute:x1 :compute:zx
+  378 op mul *tmp106 :compute:zx :compute:zx
+  379 op mul *tmp107 :compute:zy :compute:zy
+  380 op sub *tmp108 *tmp106 *tmp107
+  381 op add :compute:zx *tmp108 :compute:cx
+  382 op mul *tmp110 2 :compute:x1
+  383 op mul *tmp111 *tmp110 :compute:zy
+  384 op add :compute:zy *tmp111 :compute:cy
+  385 op len :compute:dist :compute:zx :compute:zy
+  386 jump *label182 lessThan :compute:dist 64
+  387 jump *label66 always
+  388 label *label182
+  389 label *label183
+  390 label *label184
+  391 op add :compute:i :compute:i 1
+  392 set :compute:x1 :compute:zx
+  393 op mul *tmp106 :compute:zx :compute:zx
+  394 op mul *tmp107 :compute:zy :compute:zy
+  395 op sub *tmp108 *tmp106 *tmp107
+  396 op add :compute:zx *tmp108 :compute:cx
+  397 op mul *tmp110 2 :compute:x1
+  398 op mul *tmp111 *tmp110 :compute:zy
+  399 op add :compute:zy *tmp111 :compute:cy
+  400 op len :compute:dist :compute:zx :compute:zy
+  401 jump *label185 lessThan :compute:dist 64
+  402 jump *label66 always
+  403 label *label185
+  404 label *label186
+  405 label *label187
+  406 op add :compute:i :compute:i 1
+  407 set :compute:x1 :compute:zx
+  408 op mul *tmp106 :compute:zx :compute:zx
+  409 op mul *tmp107 :compute:zy :compute:zy
+  410 op sub *tmp108 *tmp106 *tmp107
+  411 op add :compute:zx *tmp108 :compute:cx
+  412 op mul *tmp110 2 :compute:x1
+  413 op mul *tmp111 *tmp110 :compute:zy
+  414 op add :compute:zy *tmp111 :compute:cy
+  415 op len :compute:dist :compute:zx :compute:zy
+  416 jump *label188 lessThan :compute:dist 64
+  417 jump *label66 always
+  418 label *label188
+  419 label *label189
+  420 label *label190
+  421 op add :compute:i :compute:i 1
+  422 set :compute:x1 :compute:zx
+  423 op mul *tmp106 :compute:zx :compute:zx
+  424 op mul *tmp107 :compute:zy :compute:zy
+  425 op sub *tmp108 *tmp106 *tmp107
+  426 op add :compute:zx *tmp108 :compute:cx
+  427 op mul *tmp110 2 :compute:x1
+  428 op mul *tmp111 *tmp110 :compute:zy
+  429 op add :compute:zy *tmp111 :compute:cy
+  430 op len :compute:dist :compute:zx :compute:zy
+  431 jump *label191 lessThan :compute:dist 64
+  432 jump *label66 always
+  433 label *label191
+  434 label *label192
+  435 label *label193
+  436 op add :compute:i :compute:i 1
+  437 set :compute:x1 :compute:zx
+  438 op mul *tmp106 :compute:zx :compute:zx
+  439 op mul *tmp107 :compute:zy :compute:zy
+  440 op sub *tmp108 *tmp106 *tmp107
+  441 op add :compute:zx *tmp108 :compute:cx
+  442 op mul *tmp110 2 :compute:x1
+  443 op mul *tmp111 *tmp110 :compute:zy
+  444 op add :compute:zy *tmp111 :compute:cy
+  445 op len :compute:dist :compute:zx :compute:zy
+  446 jump *label194 lessThan :compute:dist 64
+  447 jump *label66 always
+  448 label *label194
+  449 label *label195
+  450 label *label196
+  451 op add :compute:i :compute:i 1
+  452 set :compute:x1 :compute:zx
+  453 op mul *tmp106 :compute:zx :compute:zx
+  454 op mul *tmp107 :compute:zy :compute:zy
+  455 op sub *tmp108 *tmp106 *tmp107
+  456 op add :compute:zx *tmp108 :compute:cx
+  457 op mul *tmp110 2 :compute:x1
+  458 op mul *tmp111 *tmp110 :compute:zy
+  459 op add :compute:zy *tmp111 :compute:cy
+  460 op len :compute:dist :compute:zx :compute:zy
+  461 jump *label197 lessThan :compute:dist 64
+  462 jump *label66 always
+  463 label *label197
+  464 label *label198
+  465 label *label199
+  466 op add :compute:i :compute:i 1
+  467 set :compute:x1 :compute:zx
+  468 op mul *tmp106 :compute:zx :compute:zx
+  469 op mul *tmp107 :compute:zy :compute:zy
+  470 op sub *tmp108 *tmp106 *tmp107
+  471 op add :compute:zx *tmp108 :compute:cx
+  472 op mul *tmp110 2 :compute:x1
+  473 op mul *tmp111 *tmp110 :compute:zy
+  474 op add :compute:zy *tmp111 :compute:cy
+  475 op len :compute:dist :compute:zx :compute:zy
+  476 jump *label200 lessThan :compute:dist 64
+  477 jump *label66 always
+  478 label *label200
+  479 label *label201
+  480 label *label202
+  481 op add :compute:i :compute:i 1
+  482 set :compute:x1 :compute:zx
+  483 op mul *tmp106 :compute:zx :compute:zx
+  484 op mul *tmp107 :compute:zy :compute:zy
+  485 op sub *tmp108 *tmp106 *tmp107
+  486 op add :compute:zx *tmp108 :compute:cx
+  487 op mul *tmp110 2 :compute:x1
+  488 op mul *tmp111 *tmp110 :compute:zy
+  489 op add :compute:zy *tmp111 :compute:cy
+  490 op len :compute:dist :compute:zx :compute:zy
+  491 jump *label203 lessThan :compute:dist 64
+  492 jump *label66 always
+  493 label *label203
+  494 label *label204
+  495 label *label205
+  496 op add :compute:i :compute:i 1
+  497 set :compute:x1 :compute:zx
+  498 op mul *tmp106 :compute:zx :compute:zx
+  499 op mul *tmp107 :compute:zy :compute:zy
+  500 op sub *tmp108 *tmp106 *tmp107
+  501 op add :compute:zx *tmp108 :compute:cx
+  502 op mul *tmp110 2 :compute:x1
+  503 op mul *tmp111 *tmp110 :compute:zy
+  504 op add :compute:zy *tmp111 :compute:cy
+  505 op len :compute:dist :compute:zx :compute:zy
+  506 jump *label206 lessThan :compute:dist 64
+  507 jump *label66 always
+  508 label *label206
+  509 label *label207
+  510 label *label208
+  511 op add :compute:i :compute:i 1
+  512 set :compute:x1 :compute:zx
+  513 op mul *tmp106 :compute:zx :compute:zx
+  514 op mul *tmp107 :compute:zy :compute:zy
+  515 op sub *tmp108 *tmp106 *tmp107
+  516 op add :compute:zx *tmp108 :compute:cx
+  517 op mul *tmp110 2 :compute:x1
+  518 op mul *tmp111 *tmp110 :compute:zy
+  519 op add :compute:zy *tmp111 :compute:cy
+  520 op len :compute:dist :compute:zx :compute:zy
+  521 jump *label209 lessThan :compute:dist 64
+  522 jump *label66 always
+  523 label *label209
+  524 label *label210
+  525 label *label211
+  526 op add :compute:i :compute:i 1
+  527 set :compute:x1 :compute:zx
+  528 op mul *tmp106 :compute:zx :compute:zx
+  529 op mul *tmp107 :compute:zy :compute:zy
+  530 op sub *tmp108 *tmp106 *tmp107
+  531 op add :compute:zx *tmp108 :compute:cx
+  532 op mul *tmp110 2 :compute:x1
+  533 op mul *tmp111 *tmp110 :compute:zy
+  534 op add :compute:zy *tmp111 :compute:cy
+  535 op len :compute:dist :compute:zx :compute:zy
+  536 jump *label212 lessThan :compute:dist 64
+  537 jump *label66 always
+  538 label *label212
+  539 label *label213
+  540 label *label214
+  541 op add :compute:i :compute:i 1
+  542 set :compute:x1 :compute:zx
+  543 op mul *tmp106 :compute:zx :compute:zx
+  544 op mul *tmp107 :compute:zy :compute:zy
+  545 op sub *tmp108 *tmp106 *tmp107
+  546 op add :compute:zx *tmp108 :compute:cx
+  547 op mul *tmp110 2 :compute:x1
+  548 op mul *tmp111 *tmp110 :compute:zy
+  549 op add :compute:zy *tmp111 :compute:cy
+  550 op len :compute:dist :compute:zx :compute:zy
+  551 jump *label215 lessThan :compute:dist 64
+  552 jump *label66 always
+  553 label *label215
+  554 label *label216
+  555 label *label217
+  556 op add :compute:i :compute:i 1
+  557 set :compute:x1 :compute:zx
+  558 op mul *tmp106 :compute:zx :compute:zx
+  559 op mul *tmp107 :compute:zy :compute:zy
+  560 op sub *tmp108 *tmp106 *tmp107
+  561 op add :compute:zx *tmp108 :compute:cx
+  562 op mul *tmp110 2 :compute:x1
+  563 op mul *tmp111 *tmp110 :compute:zy
+  564 op add :compute:zy *tmp111 :compute:cy
+  565 op len :compute:dist :compute:zx :compute:zy
+  566 jump *label218 lessThan :compute:dist 64
+  567 jump *label66 always
+  568 label *label218
+  569 label *label219
+  570 label *label220
+  571 op add :compute:i :compute:i 1
+  572 set :compute:x1 :compute:zx
+  573 op mul *tmp106 :compute:zx :compute:zx
+  574 op mul *tmp107 :compute:zy :compute:zy
+  575 op sub *tmp108 *tmp106 *tmp107
+  576 op add :compute:zx *tmp108 :compute:cx
+  577 op mul *tmp110 2 :compute:x1
+  578 op mul *tmp111 *tmp110 :compute:zy
+  579 op add :compute:zy *tmp111 :compute:cy
+  580 op len :compute:dist :compute:zx :compute:zy
+  581 jump *label221 lessThan :compute:dist 64
+  582 jump *label66 always
+  583 label *label221
+  584 label *label222
+  585 label *label223
+  586 op add :compute:i :compute:i 1
+  587 set :compute:x1 :compute:zx
+  588 op mul *tmp106 :compute:zx :compute:zx
+  589 op mul *tmp107 :compute:zy :compute:zy
+  590 op sub *tmp108 *tmp106 *tmp107
+  591 op add :compute:zx *tmp108 :compute:cx
+  592 op mul *tmp110 2 :compute:x1
+  593 op mul *tmp111 *tmp110 :compute:zy
+  594 op add :compute:zy *tmp111 :compute:cy
+  595 op len :compute:dist :compute:zx :compute:zy
+  596 jump *label224 lessThan :compute:dist 64
+  597 jump *label66 always
+  598 label *label224
+  599 label *label225
+  600 label *label226
+  601 op add :compute:i :compute:i 1
+  602 set :compute:x1 :compute:zx
+  603 op mul *tmp106 :compute:zx :compute:zx
+  604 op mul *tmp107 :compute:zy :compute:zy
+  605 op sub *tmp108 *tmp106 *tmp107
+  606 op add :compute:zx *tmp108 :compute:cx
+  607 op mul *tmp110 2 :compute:x1
+  608 op mul *tmp111 *tmp110 :compute:zy
+  609 op add :compute:zy *tmp111 :compute:cy
+  610 op len :compute:dist :compute:zx :compute:zy
+  611 jump *label227 lessThan :compute:dist 64
+  612 jump *label66 always
+  613 label *label227
+  614 label *label228
+  615 label *label229
+  616 op add :compute:i :compute:i 1
+  617 set :compute:x1 :compute:zx
+  618 op mul *tmp106 :compute:zx :compute:zx
+  619 op mul *tmp107 :compute:zy :compute:zy
+  620 op sub *tmp108 *tmp106 *tmp107
+  621 op add :compute:zx *tmp108 :compute:cx
+  622 op mul *tmp110 2 :compute:x1
+  623 op mul *tmp111 *tmp110 :compute:zy
+  624 op add :compute:zy *tmp111 :compute:cy
+  625 op len :compute:dist :compute:zx :compute:zy
+  626 jump *label230 lessThan :compute:dist 64
+  627 jump *label66 always
+  628 label *label230
+  629 label *label231
+  630 label *label232
+  631 op add :compute:i :compute:i 1
+  632 set :compute:x1 :compute:zx
+  633 op mul *tmp106 :compute:zx :compute:zx
+  634 op mul *tmp107 :compute:zy :compute:zy
+  635 op sub *tmp108 *tmp106 *tmp107
+  636 op add :compute:zx *tmp108 :compute:cx
+  637 op mul *tmp110 2 :compute:x1
+  638 op mul *tmp111 *tmp110 :compute:zy
+  639 op add :compute:zy *tmp111 :compute:cy
+  640 op len :compute:dist :compute:zx :compute:zy
+  641 jump *label233 lessThan :compute:dist 64
+  642 jump *label66 always
+  643 label *label233
+  644 label *label234
+  645 label *label235
+  646 op add :compute:i :compute:i 1
+  647 set :compute:x1 :compute:zx
+  648 op mul *tmp106 :compute:zx :compute:zx
+  649 op mul *tmp107 :compute:zy :compute:zy
+  650 op sub *tmp108 *tmp106 *tmp107
+  651 op add :compute:zx *tmp108 :compute:cx
+  652 op mul *tmp110 2 :compute:x1
+  653 op mul *tmp111 *tmp110 :compute:zy
+  654 op add :compute:zy *tmp111 :compute:cy
+  655 op len :compute:dist :compute:zx :compute:zy
+  656 jump *label236 lessThan :compute:dist 64
+  657 jump *label66 always
+  658 label *label236
+  659 label *label237
+  660 label *label238
+  661 op add :compute:i :compute:i 1
+  662 set :compute:x1 :compute:zx
+  663 op mul *tmp106 :compute:zx :compute:zx
+  664 op mul *tmp107 :compute:zy :compute:zy
+  665 op sub *tmp108 *tmp106 *tmp107
+  666 op add :compute:zx *tmp108 :compute:cx
+  667 op mul *tmp110 2 :compute:x1
+  668 op mul *tmp111 *tmp110 :compute:zy
+  669 op add :compute:zy *tmp111 :compute:cy
+  670 op len :compute:dist :compute:zx :compute:zy
+  671 jump *label239 lessThan :compute:dist 64
+  672 jump *label66 always
+  673 label *label239
+  674 label *label240
+  675 label *label241
+  676 op add :compute:i :compute:i 1
+  677 set :compute:x1 :compute:zx
+  678 op mul *tmp106 :compute:zx :compute:zx
+  679 op mul *tmp107 :compute:zy :compute:zy
+  680 op sub *tmp108 *tmp106 *tmp107
+  681 op add :compute:zx *tmp108 :compute:cx
+  682 op mul *tmp110 2 :compute:x1
+  683 op mul *tmp111 *tmp110 :compute:zy
+  684 op add :compute:zy *tmp111 :compute:cy
+  685 op len :compute:dist :compute:zx :compute:zy
+  686 jump *label242 lessThan :compute:dist 64
+  687 jump *label66 always
+  688 label *label242
+  689 label *label243
+  690 label *label244
+  691 op add :compute:i :compute:i 1
+  692 set :compute:x1 :compute:zx
+  693 op mul *tmp106 :compute:zx :compute:zx
+  694 op mul *tmp107 :compute:zy :compute:zy
+  695 op sub *tmp108 *tmp106 *tmp107
+  696 op add :compute:zx *tmp108 :compute:cx
+  697 op mul *tmp110 2 :compute:x1
+  698 op mul *tmp111 *tmp110 :compute:zy
+  699 op add :compute:zy *tmp111 :compute:cy
+  700 op len :compute:dist :compute:zx :compute:zy
+  701 jump *label245 lessThan :compute:dist 64
+  702 jump *label66 always
+  703 label *label245
+  704 label *label246
+  705 label *label247
+  706 op add :compute:i :compute:i 1
+  707 set :compute:x1 :compute:zx
+  708 op mul *tmp106 :compute:zx :compute:zx
+  709 op mul *tmp107 :compute:zy :compute:zy
+  710 op sub *tmp108 *tmp106 *tmp107
+  711 op add :compute:zx *tmp108 :compute:cx
+  712 op mul *tmp110 2 :compute:x1
+  713 op mul *tmp111 *tmp110 :compute:zy
+  714 op add :compute:zy *tmp111 :compute:cy
+  715 op len :compute:dist :compute:zx :compute:zy
+  716 jump *label248 lessThan :compute:dist 64
+  717 jump *label66 always
+  718 label *label248
+  719 label *label249
+  720 label *label250
+  721 op add :compute:i :compute:i 1
+  722 set :compute:x1 :compute:zx
+  723 op mul *tmp106 :compute:zx :compute:zx
+  724 op mul *tmp107 :compute:zy :compute:zy
+  725 op sub *tmp108 *tmp106 *tmp107
+  726 op add :compute:zx *tmp108 :compute:cx
+  727 op mul *tmp110 2 :compute:x1
+  728 op mul *tmp111 *tmp110 :compute:zy
+  729 op add :compute:zy *tmp111 :compute:cy
+  730 op len :compute:dist :compute:zx :compute:zy
+  731 jump *label251 lessThan :compute:dist 64
+  732 jump *label66 always
+  733 label *label251
+  734 label *label252
+  735 label *label253
+  736 op add :compute:i :compute:i 1
+  737 set :compute:x1 :compute:zx
+  738 op mul *tmp106 :compute:zx :compute:zx
+  739 op mul *tmp107 :compute:zy :compute:zy
+  740 op sub *tmp108 *tmp106 *tmp107
+  741 op add :compute:zx *tmp108 :compute:cx
+  742 op mul *tmp110 2 :compute:x1
+  743 op mul *tmp111 *tmp110 :compute:zy
+  744 op add :compute:zy *tmp111 :compute:cy
+  745 op len :compute:dist :compute:zx :compute:zy
+  746 jump *label254 lessThan :compute:dist 64
+  747 jump *label66 always
+  748 label *label254
+  749 label *label255
+  750 label *label256
+  751 op add :compute:i :compute:i 1
+  752 set :compute:x1 :compute:zx
+  753 op mul *tmp106 :compute:zx :compute:zx
+  754 op mul *tmp107 :compute:zy :compute:zy
+  755 op sub *tmp108 *tmp106 *tmp107
+  756 op add :compute:zx *tmp108 :compute:cx
+  757 op mul *tmp110 2 :compute:x1
+  758 op mul *tmp111 *tmp110 :compute:zy
+  759 op add :compute:zy *tmp111 :compute:cy
+  760 op len :compute:dist :compute:zx :compute:zy
+  761 jump *label257 lessThan :compute:dist 64
+  762 jump *label66 always
+  763 label *label257
+  764 label *label258
+  765 label *label259
+  766 op add :compute:i :compute:i 1
+  767 set :compute:x1 :compute:zx
+  768 op mul *tmp106 :compute:zx :compute:zx
+  769 op mul *tmp107 :compute:zy :compute:zy
+  770 op sub *tmp108 *tmp106 *tmp107
+  771 op add :compute:zx *tmp108 :compute:cx
+  772 op mul *tmp110 2 :compute:x1
+  773 op mul *tmp111 *tmp110 :compute:zy
+  774 op add :compute:zy *tmp111 :compute:cy
+  775 op len :compute:dist :compute:zx :compute:zy
+  776 jump *label260 lessThan :compute:dist 64
+  777 jump *label66 always
+  778 label *label260
+  779 label *label261
+  780 label *label262
+  781 op add :compute:i :compute:i 1
+  782 set :compute:x1 :compute:zx
+  783 op mul *tmp106 :compute:zx :compute:zx
+  784 op mul *tmp107 :compute:zy :compute:zy
+  785 op sub *tmp108 *tmp106 *tmp107
+  786 op add :compute:zx *tmp108 :compute:cx
+  787 op mul *tmp110 2 :compute:x1
+  788 op mul *tmp111 *tmp110 :compute:zy
+  789 op add :compute:zy *tmp111 :compute:cy
+  790 op len :compute:dist :compute:zx :compute:zy
+  791 jump *label263 lessThan :compute:dist 64
+  792 jump *label66 always
+  793 label *label263
+  794 label *label264
+  795 label *label265
+  796 op add :compute:i :compute:i 1
+  797 set :compute:x1 :compute:zx
+  798 op mul *tmp106 :compute:zx :compute:zx
+  799 op mul *tmp107 :compute:zy :compute:zy
+  800 op sub *tmp108 *tmp106 *tmp107
+  801 op add :compute:zx *tmp108 :compute:cx
+  802 op mul *tmp110 2 :compute:x1
+  803 op mul *tmp111 *tmp110 :compute:zy
+  804 op add :compute:zy *tmp111 :compute:cy
+  805 op len :compute:dist :compute:zx :compute:zy
+  806 jump *label266 lessThan :compute:dist 64
+  807 jump *label66 always
+  808 label *label266
+  809 label *label267
+  810 label *label268
+  811 op add :compute:i :compute:i 1
+  812 set :compute:x1 :compute:zx
+  813 op mul *tmp106 :compute:zx :compute:zx
+  814 op mul *tmp107 :compute:zy :compute:zy
+  815 op sub *tmp108 *tmp106 *tmp107
+  816 op add :compute:zx *tmp108 :compute:cx
+  817 op mul *tmp110 2 :compute:x1
+  818 op mul *tmp111 *tmp110 :compute:zy
+  819 op add :compute:zy *tmp111 :compute:cy
+  820 op len :compute:dist :compute:zx :compute:zy
+  821 jump *label269 lessThan :compute:dist 64
+  822 jump *label66 always
+  823 label *label269
+  824 label *label270
+  825 label *label271
+  826 op add :compute:i :compute:i 1
+  827 set :compute:x1 :compute:zx
+  828 op mul *tmp106 :compute:zx :compute:zx
+  829 op mul *tmp107 :compute:zy :compute:zy
+  830 op sub *tmp108 *tmp106 *tmp107
+  831 op add :compute:zx *tmp108 :compute:cx
+  832 op mul *tmp110 2 :compute:x1
+  833 op mul *tmp111 *tmp110 :compute:zy
+  834 op add :compute:zy *tmp111 :compute:cy
+  835 op len :compute:dist :compute:zx :compute:zy
+  836 jump *label272 lessThan :compute:dist 64
+  837 jump *label66 always
+  838 label *label272
+  839 label *label273
+  840 label *label274
+  841 op add :compute:i :compute:i 1
+  842 set :compute:x1 :compute:zx
+  843 op mul *tmp106 :compute:zx :compute:zx
+  844 op mul *tmp107 :compute:zy :compute:zy
+  845 op sub *tmp108 *tmp106 *tmp107
+  846 op add :compute:zx *tmp108 :compute:cx
+  847 op mul *tmp110 2 :compute:x1
+  848 op mul *tmp111 *tmp110 :compute:zy
+  849 op add :compute:zy *tmp111 :compute:cy
+  850 op len :compute:dist :compute:zx :compute:zy
+  851 jump *label275 lessThan :compute:dist 64
+  852 jump *label66 always
+  853 label *label275
+  854 label *label276
+  855 label *label277
+  856 op add :compute:i :compute:i 1
+  857 set :compute:x1 :compute:zx
+  858 op mul *tmp106 :compute:zx :compute:zx
+  859 op mul *tmp107 :compute:zy :compute:zy
+  860 op sub *tmp108 *tmp106 *tmp107
+  861 op add :compute:zx *tmp108 :compute:cx
+  862 op mul *tmp110 2 :compute:x1
+  863 op mul *tmp111 *tmp110 :compute:zy
+  864 op add :compute:zy *tmp111 :compute:cy
+  865 op len :compute:dist :compute:zx :compute:zy
+  866 jump *label278 lessThan :compute:dist 64
+  867 jump *label66 always
+  868 label *label278
+  869 label *label279
+  870 label *label280
+  871 op add :compute:i :compute:i 1
+  872 set :compute:x1 :compute:zx
+  873 op mul *tmp106 :compute:zx :compute:zx
+  874 op mul *tmp107 :compute:zy :compute:zy
+  875 op sub *tmp108 *tmp106 *tmp107
+  876 op add :compute:zx *tmp108 :compute:cx
+  877 op mul *tmp110 2 :compute:x1
+  878 op mul *tmp111 *tmp110 :compute:zy
+  879 op add :compute:zy *tmp111 :compute:cy
+  880 op len :compute:dist :compute:zx :compute:zy
+  881 jump *label281 lessThan :compute:dist 64
+  882 jump *label66 always
+  883 label *label281
+  884 label *label282
+  885 label *label283
+  886 op add :compute:i :compute:i 1
+  887 set :compute:x1 :compute:zx
+  888 op mul *tmp106 :compute:zx :compute:zx
+  889 op mul *tmp107 :compute:zy :compute:zy
+  890 op sub *tmp108 *tmp106 *tmp107
+  891 op add :compute:zx *tmp108 :compute:cx
+  892 op mul *tmp110 2 :compute:x1
+  893 op mul *tmp111 *tmp110 :compute:zy
+  894 op add :compute:zy *tmp111 :compute:cy
+  895 op len :compute:dist :compute:zx :compute:zy
+  896 jump *label284 lessThan :compute:dist 64
+  897 jump *label66 always
+  898 label *label284
+  899 label *label285
+  900 label *label286
+  901 op add :compute:i :compute:i 1
+  902 set :compute:x1 :compute:zx
+  903 op mul *tmp106 :compute:zx :compute:zx
+  904 op mul *tmp107 :compute:zy :compute:zy
+  905 op sub *tmp108 *tmp106 *tmp107
+  906 op add :compute:zx *tmp108 :compute:cx
+  907 op mul *tmp110 2 :compute:x1
+  908 op mul *tmp111 *tmp110 :compute:zy
+  909 op add :compute:zy *tmp111 :compute:cy
+  910 op len :compute:dist :compute:zx :compute:zy
+  911 jump *label287 lessThan :compute:dist 64
+  912 jump *label66 always
+  913 label *label287
+  914 label *label288
+  915 label *label289
+  916 op add :compute:i :compute:i 1
+  917 set :compute:x1 :compute:zx
+  918 op mul *tmp106 :compute:zx :compute:zx
+  919 op mul *tmp107 :compute:zy :compute:zy
+  920 op sub *tmp108 *tmp106 *tmp107
+  921 op add :compute:zx *tmp108 :compute:cx
+  922 op mul *tmp110 2 :compute:x1
+  923 op mul *tmp111 *tmp110 :compute:zy
+  924 op add :compute:zy *tmp111 :compute:cy
+  925 op len :compute:dist :compute:zx :compute:zy
+  926 jump *label290 lessThan :compute:dist 64
+  927 jump *label66 always
+  928 label *label290
+  929 label *label291
+  930 label *label292
+  931 op add :compute:i :compute:i 1
+  932 set :compute:x1 :compute:zx
+  933 op mul *tmp106 :compute:zx :compute:zx
+  934 op mul *tmp107 :compute:zy :compute:zy
+  935 op sub *tmp108 *tmp106 *tmp107
+  936 op add :compute:zx *tmp108 :compute:cx
+  937 op mul *tmp110 2 :compute:x1
+  938 op mul *tmp111 *tmp110 :compute:zy
+  939 op add :compute:zy *tmp111 :compute:cy
+  940 op len :compute:dist :compute:zx :compute:zy
+  941 jump *label293 lessThan :compute:dist 64
+  942 jump *label66 always
+  943 label *label293
+  944 label *label294
+  945 label *label295
+  946 op add :compute:i :compute:i 1
+  947 set :compute:x1 :compute:zx
+  948 op mul *tmp106 :compute:zx :compute:zx
+  949 op mul *tmp107 :compute:zy :compute:zy
+  950 op sub *tmp108 *tmp106 *tmp107
+  951 op add :compute:zx *tmp108 :compute:cx
+  952 op mul *tmp110 2 :compute:x1
+  953 op mul *tmp111 *tmp110 :compute:zy
+  954 op add :compute:zy *tmp111 :compute:cy
+  955 op len :compute:dist :compute:zx :compute:zy
+  956 jump *label296 lessThan :compute:dist 64
+  957 jump *label66 always
+  958 label *label296
+  959 label *label297
+  960 label *label298
+  961 op add :compute:i :compute:i 1
+  962 set :compute:x1 :compute:zx
+  963 op mul *tmp106 :compute:zx :compute:zx
+  964 op mul *tmp107 :compute:zy :compute:zy
+  965 op sub *tmp108 *tmp106 *tmp107
+  966 op add :compute:zx *tmp108 :compute:cx
+  967 op mul *tmp110 2 :compute:x1
+  968 op mul *tmp111 *tmp110 :compute:zy
+  969 op add :compute:zy *tmp111 :compute:cy
+  970 op len :compute:dist :compute:zx :compute:zy
+  971 jump *label299 lessThan :compute:dist 64
+  972 jump *label66 always
+  973 label *label299
+  974 label *label300
+  975 label *label301
+  976 op add :compute:i :compute:i 1
+  977 set :compute:x1 :compute:zx
+  978 op mul *tmp106 :compute:zx :compute:zx
+  979 op mul *tmp107 :compute:zy :compute:zy
+  980 op sub *tmp108 *tmp106 *tmp107
+  981 op add :compute:zx *tmp108 :compute:cx
+  982 op mul *tmp110 2 :compute:x1
+  983 op mul *tmp111 *tmp110 :compute:zy
+  984 op add :compute:zy *tmp111 :compute:cy
+  985 op len :compute:dist :compute:zx :compute:zy
+  986 jump *label302 lessThan :compute:dist 64
+  987 jump *label66 always
+  988 label *label302
+  989 label *label303
+  990 label *label304
+  991 op add :compute:i :compute:i 1
+  992 set :compute:x1 :compute:zx
+  993 op mul *tmp106 :compute:zx :compute:zx
+  994 op mul *tmp107 :compute:zy :compute:zy
+  995 op sub *tmp108 *tmp106 *tmp107
+  996 op add :compute:zx *tmp108 :compute:cx
+  997 op mul *tmp110 2 :compute:x1
+  998 op mul *tmp111 *tmp110 :compute:zy
+  999 op add :compute:zy *tmp111 :compute:cy
+ 1000 op len :compute:dist :compute:zx :compute:zy
+ 1001 jump *label305 lessThan :compute:dist 64
+ 1002 jump *label66 always
+ 1003 label *label305
+ 1004 label *label306
+ 1005 label *label307
+ 1006 op add :compute:i :compute:i 1
+ 1007 set :compute:x1 :compute:zx
+ 1008 op mul *tmp106 :compute:zx :compute:zx
+ 1009 op mul *tmp107 :compute:zy :compute:zy
+ 1010 op sub *tmp108 *tmp106 *tmp107
+ 1011 op add :compute:zx *tmp108 :compute:cx
+ 1012 op mul *tmp110 2 :compute:x1
+ 1013 op mul *tmp111 *tmp110 :compute:zy
+ 1014 op add :compute:zy *tmp111 :compute:cy
+ 1015 op len :compute:dist :compute:zx :compute:zy
+ 1016 jump *label308 lessThan :compute:dist 64
+ 1017 jump *label66 always
+ 1018 label *label308
+ 1019 label *label309
+ 1020 label *label310
+ 1021 op add :compute:i :compute:i 1
+ 1022 set :compute:x1 :compute:zx
+ 1023 op mul *tmp106 :compute:zx :compute:zx
+ 1024 op mul *tmp107 :compute:zy :compute:zy
+ 1025 op sub *tmp108 *tmp106 *tmp107
+ 1026 op add :compute:zx *tmp108 :compute:cx
+ 1027 op mul *tmp110 2 :compute:x1
+ 1028 op mul *tmp111 *tmp110 :compute:zy
+ 1029 op add :compute:zy *tmp111 :compute:cy
+ 1030 op len :compute:dist :compute:zx :compute:zy
+ 1031 jump *label311 lessThan :compute:dist 64
+ 1032 jump *label66 always
+ 1033 label *label311
+ 1034 label *label312
+ 1035 label *label313
+ 1036 op add :compute:i :compute:i 1
+ 1037 set :compute:x1 :compute:zx
+ 1038 op mul *tmp106 :compute:zx :compute:zx
+ 1039 op mul *tmp107 :compute:zy :compute:zy
+ 1040 op sub *tmp108 *tmp106 *tmp107
+ 1041 op add :compute:zx *tmp108 :compute:cx
+ 1042 op mul *tmp110 2 :compute:x1
+ 1043 op mul *tmp111 *tmp110 :compute:zy
+ 1044 op add :compute:zy *tmp111 :compute:cy
+ 1045 op len :compute:dist :compute:zx :compute:zy
+ 1046 jump *label314 lessThan :compute:dist 64
+ 1047 jump *label66 always
+ 1048 label *label314
+ 1049 label *label315
+ 1050 label *label316
+ 1051 op add :compute:i :compute:i 1
+ 1052 set :compute:x1 :compute:zx
+ 1053 op mul *tmp106 :compute:zx :compute:zx
+ 1054 op mul *tmp107 :compute:zy :compute:zy
+ 1055 op sub *tmp108 *tmp106 *tmp107
+ 1056 op add :compute:zx *tmp108 :compute:cx
+ 1057 op mul *tmp110 2 :compute:x1
+ 1058 op mul *tmp111 *tmp110 :compute:zy
+ 1059 op add :compute:zy *tmp111 :compute:cy
+ 1060 op len :compute:dist :compute:zx :compute:zy
+ 1061 jump *label317 lessThan :compute:dist 64
+ 1062 jump *label66 always
+ 1063 label *label317
+ 1064 label *label318
+ 1065 label *label319
+ 1066 op add :compute:i :compute:i 1
+ 1067 set :compute:x1 :compute:zx
+ 1068 op mul *tmp106 :compute:zx :compute:zx
+ 1069 op mul *tmp107 :compute:zy :compute:zy
+ 1070 op sub *tmp108 *tmp106 *tmp107
+ 1071 op add :compute:zx *tmp108 :compute:cx
+ 1072 op mul *tmp110 2 :compute:x1
+ 1073 op mul *tmp111 *tmp110 :compute:zy
+ 1074 op add :compute:zy *tmp111 :compute:cy
+ 1075 op len :compute:dist :compute:zx :compute:zy
+ 1076 jump *label320 lessThan :compute:dist 64
+ 1077 jump *label66 always
+ 1078 label *label320
+ 1079 label *label321
+ 1080 label *label322
+ 1081 op add :compute:i :compute:i 1
+ 1082 set :compute:x1 :compute:zx
+ 1083 op mul *tmp106 :compute:zx :compute:zx
+ 1084 op mul *tmp107 :compute:zy :compute:zy
+ 1085 op sub *tmp108 *tmp106 *tmp107
+ 1086 op add :compute:zx *tmp108 :compute:cx
+ 1087 op mul *tmp110 2 :compute:x1
+ 1088 op mul *tmp111 *tmp110 :compute:zy
+ 1089 op add :compute:zy *tmp111 :compute:cy
+ 1090 op len :compute:dist :compute:zx :compute:zy
+ 1091 jump *label323 lessThan :compute:dist 64
+ 1092 jump *label66 always
+ 1093 label *label323
+ 1094 label *label324
+ 1095 label *label325
+ 1096 op add :compute:i :compute:i 1
+ 1097 set :compute:x1 :compute:zx
+ 1098 op mul *tmp106 :compute:zx :compute:zx
+ 1099 op mul *tmp107 :compute:zy :compute:zy
+ 1100 op sub *tmp108 *tmp106 *tmp107
+ 1101 op add :compute:zx *tmp108 :compute:cx
+ 1102 op mul *tmp110 2 :compute:x1
+ 1103 op mul *tmp111 *tmp110 :compute:zy
+ 1104 op add :compute:zy *tmp111 :compute:cy
+ 1105 op len :compute:dist :compute:zx :compute:zy
+ 1106 jump *label326 lessThan :compute:dist 64
+ 1107 jump *label66 always
+ 1108 label *label326
+ 1109 label *label327
+ 1110 label *label328
+ 1111 op add :compute:i :compute:i 1
+ 1112 label *label69
  1113 set *tmp88 :compute:i
  1114 jump *label57 always
  1115 label *label65

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   178 label *label140
   179 label *label141
   180 label *label142
-    * op add :compute:i :compute:i 1
+  181 op add :compute:i 0 1
   182 set :compute:x1 :compute:zx
   183 op mul *tmp106 :compute:zx :compute:zx
   184 op mul *tmp107 :compute:zy :compute:zy
 
   193 label *label143
   194 label *label144
   195 label *label145
-    * op add :compute:i :compute:i 1
+  196 op add :compute:i 1 1
   197 set :compute:x1 :compute:zx
   198 op mul *tmp106 :compute:zx :compute:zx
   199 op mul *tmp107 :compute:zy :compute:zy
 
   208 label *label146
   209 label *label147
   210 label *label148
-    * op add :compute:i :compute:i 1
+  211 op add :compute:i 2 1
   212 set :compute:x1 :compute:zx
   213 op mul *tmp106 :compute:zx :compute:zx
   214 op mul *tmp107 :compute:zy :compute:zy
 
   223 label *label149
   224 label *label150
   225 label *label151
-    * op add :compute:i :compute:i 1
+  226 op add :compute:i 3 1
   227 set :compute:x1 :compute:zx
   228 op mul *tmp106 :compute:zx :compute:zx
   229 op mul *tmp107 :compute:zy :compute:zy
 
   238 label *label152
   239 label *label153
   240 label *label154
-    * op add :compute:i :compute:i 1
+  241 op add :compute:i 4 1
   242 set :compute:x1 :compute:zx
   243 op mul *tmp106 :compute:zx :compute:zx
   244 op mul *tmp107 :compute:zy :compute:zy
 
   253 label *label155
   254 label *label156
   255 label *label157
-    * op add :compute:i :compute:i 1
+  256 op add :compute:i 5 1
   257 set :compute:x1 :compute:zx
   258 op mul *tmp106 :compute:zx :compute:zx
   259 op mul *tmp107 :compute:zy :compute:zy
 
   268 label *label158
   269 label *label159
   270 label *label160
-    * op add :compute:i :compute:i 1
+  271 op add :compute:i 6 1
   272 set :compute:x1 :compute:zx
   273 op mul *tmp106 :compute:zx :compute:zx
   274 op mul *tmp107 :compute:zy :compute:zy
 
   283 label *label161
   284 label *label162
   285 label *label163
-    * op add :compute:i :compute:i 1
+  286 op add :compute:i 7 1
   287 set :compute:x1 :compute:zx
   288 op mul *tmp106 :compute:zx :compute:zx
   289 op mul *tmp107 :compute:zy :compute:zy
 
   298 label *label164
   299 label *label165
   300 label *label166
-    * op add :compute:i :compute:i 1
+  301 op add :compute:i 8 1
   302 set :compute:x1 :compute:zx
   303 op mul *tmp106 :compute:zx :compute:zx
   304 op mul *tmp107 :compute:zy :compute:zy
 
   313 label *label167
   314 label *label168
   315 label *label169
-    * op add :compute:i :compute:i 1
+  316 op add :compute:i 9 1
   317 set :compute:x1 :compute:zx
   318 op mul *tmp106 :compute:zx :compute:zx
   319 op mul *tmp107 :compute:zy :compute:zy
 
   328 label *label170
   329 label *label171
   330 label *label172
-    * op add :compute:i :compute:i 1
+  331 op add :compute:i 10 1
   332 set :compute:x1 :compute:zx
   333 op mul *tmp106 :compute:zx :compute:zx
   334 op mul *tmp107 :compute:zy :compute:zy
 
   343 label *label173
   344 label *label174
   345 label *label175
-    * op add :compute:i :compute:i 1
+  346 op add :compute:i 11 1
   347 set :compute:x1 :compute:zx
   348 op mul *tmp106 :compute:zx :compute:zx
   349 op mul *tmp107 :compute:zy :compute:zy
 
   358 label *label176
   359 label *label177
   360 label *label178
-    * op add :compute:i :compute:i 1
+  361 op add :compute:i 12 1
   362 set :compute:x1 :compute:zx
   363 op mul *tmp106 :compute:zx :compute:zx
   364 op mul *tmp107 :compute:zy :compute:zy
 
   373 label *label179
   374 label *label180
   375 label *label181
-    * op add :compute:i :compute:i 1
+  376 op add :compute:i 13 1
   377 set :compute:x1 :compute:zx
   378 op mul *tmp106 :compute:zx :compute:zx
   379 op mul *tmp107 :compute:zy :compute:zy
 
   388 label *label182
   389 label *label183
   390 label *label184
-    * op add :compute:i :compute:i 1
+  391 op add :compute:i 14 1
   392 set :compute:x1 :compute:zx
   393 op mul *tmp106 :compute:zx :compute:zx
   394 op mul *tmp107 :compute:zy :compute:zy
 
   403 label *label185
   404 label *label186
   405 label *label187
-    * op add :compute:i :compute:i 1
+  406 op add :compute:i 15 1
   407 set :compute:x1 :compute:zx
   408 op mul *tmp106 :compute:zx :compute:zx
   409 op mul *tmp107 :compute:zy :compute:zy
 
   418 label *label188
   419 label *label189
   420 label *label190
-    * op add :compute:i :compute:i 1
+  421 op add :compute:i 16 1
   422 set :compute:x1 :compute:zx
   423 op mul *tmp106 :compute:zx :compute:zx
   424 op mul *tmp107 :compute:zy :compute:zy
 
   433 label *label191
   434 label *label192
   435 label *label193
-    * op add :compute:i :compute:i 1
+  436 op add :compute:i 17 1
   437 set :compute:x1 :compute:zx
   438 op mul *tmp106 :compute:zx :compute:zx
   439 op mul *tmp107 :compute:zy :compute:zy
 
   448 label *label194
   449 label *label195
   450 label *label196
-    * op add :compute:i :compute:i 1
+  451 op add :compute:i 18 1
   452 set :compute:x1 :compute:zx
   453 op mul *tmp106 :compute:zx :compute:zx
   454 op mul *tmp107 :compute:zy :compute:zy
 
   463 label *label197
   464 label *label198
   465 label *label199
-    * op add :compute:i :compute:i 1
+  466 op add :compute:i 19 1
   467 set :compute:x1 :compute:zx
   468 op mul *tmp106 :compute:zx :compute:zx
   469 op mul *tmp107 :compute:zy :compute:zy
 
   478 label *label200
   479 label *label201
   480 label *label202
-    * op add :compute:i :compute:i 1
+  481 op add :compute:i 20 1
   482 set :compute:x1 :compute:zx
   483 op mul *tmp106 :compute:zx :compute:zx
   484 op mul *tmp107 :compute:zy :compute:zy
 
   493 label *label203
   494 label *label204
   495 label *label205
-    * op add :compute:i :compute:i 1
+  496 op add :compute:i 21 1
   497 set :compute:x1 :compute:zx
   498 op mul *tmp106 :compute:zx :compute:zx
   499 op mul *tmp107 :compute:zy :compute:zy
 
   508 label *label206
   509 label *label207
   510 label *label208
-    * op add :compute:i :compute:i 1
+  511 op add :compute:i 22 1
   512 set :compute:x1 :compute:zx
   513 op mul *tmp106 :compute:zx :compute:zx
   514 op mul *tmp107 :compute:zy :compute:zy
 
   523 label *label209
   524 label *label210
   525 label *label211
-    * op add :compute:i :compute:i 1
+  526 op add :compute:i 23 1
   527 set :compute:x1 :compute:zx
   528 op mul *tmp106 :compute:zx :compute:zx
   529 op mul *tmp107 :compute:zy :compute:zy
 
   538 label *label212
   539 label *label213
   540 label *label214
-    * op add :compute:i :compute:i 1
+  541 op add :compute:i 24 1
   542 set :compute:x1 :compute:zx
   543 op mul *tmp106 :compute:zx :compute:zx
   544 op mul *tmp107 :compute:zy :compute:zy
 
   553 label *label215
   554 label *label216
   555 label *label217
-    * op add :compute:i :compute:i 1
+  556 op add :compute:i 25 1
   557 set :compute:x1 :compute:zx
   558 op mul *tmp106 :compute:zx :compute:zx
   559 op mul *tmp107 :compute:zy :compute:zy
 
   568 label *label218
   569 label *label219
   570 label *label220
-    * op add :compute:i :compute:i 1
+  571 op add :compute:i 26 1
   572 set :compute:x1 :compute:zx
   573 op mul *tmp106 :compute:zx :compute:zx
   574 op mul *tmp107 :compute:zy :compute:zy
 
   583 label *label221
   584 label *label222
   585 label *label223
-    * op add :compute:i :compute:i 1
+  586 op add :compute:i 27 1
   587 set :compute:x1 :compute:zx
   588 op mul *tmp106 :compute:zx :compute:zx
   589 op mul *tmp107 :compute:zy :compute:zy
 
   598 label *label224
   599 label *label225
   600 label *label226
-    * op add :compute:i :compute:i 1
+  601 op add :compute:i 28 1
   602 set :compute:x1 :compute:zx
   603 op mul *tmp106 :compute:zx :compute:zx
   604 op mul *tmp107 :compute:zy :compute:zy
 
   613 label *label227
   614 label *label228
   615 label *label229
-    * op add :compute:i :compute:i 1
+  616 op add :compute:i 29 1
   617 set :compute:x1 :compute:zx
   618 op mul *tmp106 :compute:zx :compute:zx
   619 op mul *tmp107 :compute:zy :compute:zy
 
   628 label *label230
   629 label *label231
   630 label *label232
-    * op add :compute:i :compute:i 1
+  631 op add :compute:i 30 1
   632 set :compute:x1 :compute:zx
   633 op mul *tmp106 :compute:zx :compute:zx
   634 op mul *tmp107 :compute:zy :compute:zy
 
   643 label *label233
   644 label *label234
   645 label *label235
-    * op add :compute:i :compute:i 1
+  646 op add :compute:i 31 1
   647 set :compute:x1 :compute:zx
   648 op mul *tmp106 :compute:zx :compute:zx
   649 op mul *tmp107 :compute:zy :compute:zy
 
   658 label *label236
   659 label *label237
   660 label *label238
-    * op add :compute:i :compute:i 1
+  661 op add :compute:i 32 1
   662 set :compute:x1 :compute:zx
   663 op mul *tmp106 :compute:zx :compute:zx
   664 op mul *tmp107 :compute:zy :compute:zy
 
   673 label *label239
   674 label *label240
   675 label *label241
-    * op add :compute:i :compute:i 1
+  676 op add :compute:i 33 1
   677 set :compute:x1 :compute:zx
   678 op mul *tmp106 :compute:zx :compute:zx
   679 op mul *tmp107 :compute:zy :compute:zy
 
   688 label *label242
   689 label *label243
   690 label *label244
-    * op add :compute:i :compute:i 1
+  691 op add :compute:i 34 1
   692 set :compute:x1 :compute:zx
   693 op mul *tmp106 :compute:zx :compute:zx
   694 op mul *tmp107 :compute:zy :compute:zy
 
   703 label *label245
   704 label *label246
   705 label *label247
-    * op add :compute:i :compute:i 1
+  706 op add :compute:i 35 1
   707 set :compute:x1 :compute:zx
   708 op mul *tmp106 :compute:zx :compute:zx
   709 op mul *tmp107 :compute:zy :compute:zy
 
   718 label *label248
   719 label *label249
   720 label *label250
-    * op add :compute:i :compute:i 1
+  721 op add :compute:i 36 1
   722 set :compute:x1 :compute:zx
   723 op mul *tmp106 :compute:zx :compute:zx
   724 op mul *tmp107 :compute:zy :compute:zy
 
   733 label *label251
   734 label *label252
   735 label *label253
-    * op add :compute:i :compute:i 1
+  736 op add :compute:i 37 1
   737 set :compute:x1 :compute:zx
   738 op mul *tmp106 :compute:zx :compute:zx
   739 op mul *tmp107 :compute:zy :compute:zy
 
   748 label *label254
   749 label *label255
   750 label *label256
-    * op add :compute:i :compute:i 1
+  751 op add :compute:i 38 1
   752 set :compute:x1 :compute:zx
   753 op mul *tmp106 :compute:zx :compute:zx
   754 op mul *tmp107 :compute:zy :compute:zy
 
   763 label *label257
   764 label *label258
   765 label *label259
-    * op add :compute:i :compute:i 1
+  766 op add :compute:i 39 1
   767 set :compute:x1 :compute:zx
   768 op mul *tmp106 :compute:zx :compute:zx
   769 op mul *tmp107 :compute:zy :compute:zy
 
   778 label *label260
   779 label *label261
   780 label *label262
-    * op add :compute:i :compute:i 1
+  781 op add :compute:i 40 1
   782 set :compute:x1 :compute:zx
   783 op mul *tmp106 :compute:zx :compute:zx
   784 op mul *tmp107 :compute:zy :compute:zy
 
   793 label *label263
   794 label *label264
   795 label *label265
-    * op add :compute:i :compute:i 1
+  796 op add :compute:i 41 1
   797 set :compute:x1 :compute:zx
   798 op mul *tmp106 :compute:zx :compute:zx
   799 op mul *tmp107 :compute:zy :compute:zy
 
   808 label *label266
   809 label *label267
   810 label *label268
-    * op add :compute:i :compute:i 1
+  811 op add :compute:i 42 1
   812 set :compute:x1 :compute:zx
   813 op mul *tmp106 :compute:zx :compute:zx
   814 op mul *tmp107 :compute:zy :compute:zy
 
   823 label *label269
   824 label *label270
   825 label *label271
-    * op add :compute:i :compute:i 1
+  826 op add :compute:i 43 1
   827 set :compute:x1 :compute:zx
   828 op mul *tmp106 :compute:zx :compute:zx
   829 op mul *tmp107 :compute:zy :compute:zy
 
   838 label *label272
   839 label *label273
   840 label *label274
-    * op add :compute:i :compute:i 1
+  841 op add :compute:i 44 1
   842 set :compute:x1 :compute:zx
   843 op mul *tmp106 :compute:zx :compute:zx
   844 op mul *tmp107 :compute:zy :compute:zy
 
   853 label *label275
   854 label *label276
   855 label *label277
-    * op add :compute:i :compute:i 1
+  856 op add :compute:i 45 1
   857 set :compute:x1 :compute:zx
   858 op mul *tmp106 :compute:zx :compute:zx
   859 op mul *tmp107 :compute:zy :compute:zy
 
   868 label *label278
   869 label *label279
   870 label *label280
-    * op add :compute:i :compute:i 1
+  871 op add :compute:i 46 1
   872 set :compute:x1 :compute:zx
   873 op mul *tmp106 :compute:zx :compute:zx
   874 op mul *tmp107 :compute:zy :compute:zy
 
   883 label *label281
   884 label *label282
   885 label *label283
-    * op add :compute:i :compute:i 1
+  886 op add :compute:i 47 1
   887 set :compute:x1 :compute:zx
   888 op mul *tmp106 :compute:zx :compute:zx
   889 op mul *tmp107 :compute:zy :compute:zy
 
   898 label *label284
   899 label *label285
   900 label *label286
-    * op add :compute:i :compute:i 1
+  901 op add :compute:i 48 1
   902 set :compute:x1 :compute:zx
   903 op mul *tmp106 :compute:zx :compute:zx
   904 op mul *tmp107 :compute:zy :compute:zy
 
   913 label *label287
   914 label *label288
   915 label *label289
-    * op add :compute:i :compute:i 1
+  916 op add :compute:i 49 1
   917 set :compute:x1 :compute:zx
   918 op mul *tmp106 :compute:zx :compute:zx
   919 op mul *tmp107 :compute:zy :compute:zy
 
   928 label *label290
   929 label *label291
   930 label *label292
-    * op add :compute:i :compute:i 1
+  931 op add :compute:i 50 1
   932 set :compute:x1 :compute:zx
   933 op mul *tmp106 :compute:zx :compute:zx
   934 op mul *tmp107 :compute:zy :compute:zy
 
   943 label *label293
   944 label *label294
   945 label *label295
-    * op add :compute:i :compute:i 1
+  946 op add :compute:i 51 1
   947 set :compute:x1 :compute:zx
   948 op mul *tmp106 :compute:zx :compute:zx
   949 op mul *tmp107 :compute:zy :compute:zy
 
   958 label *label296
   959 label *label297
   960 label *label298
-    * op add :compute:i :compute:i 1
+  961 op add :compute:i 52 1
   962 set :compute:x1 :compute:zx
   963 op mul *tmp106 :compute:zx :compute:zx
   964 op mul *tmp107 :compute:zy :compute:zy
 
   973 label *label299
   974 label *label300
   975 label *label301
-    * op add :compute:i :compute:i 1
+  976 op add :compute:i 53 1
   977 set :compute:x1 :compute:zx
   978 op mul *tmp106 :compute:zx :compute:zx
   979 op mul *tmp107 :compute:zy :compute:zy
 
   988 label *label302
   989 label *label303
   990 label *label304
-    * op add :compute:i :compute:i 1
+  991 op add :compute:i 54 1
   992 set :compute:x1 :compute:zx
   993 op mul *tmp106 :compute:zx :compute:zx
   994 op mul *tmp107 :compute:zy :compute:zy
 
  1003 label *label305
  1004 label *label306
  1005 label *label307
-    * op add :compute:i :compute:i 1
+ 1006 op add :compute:i 55 1
  1007 set :compute:x1 :compute:zx
  1008 op mul *tmp106 :compute:zx :compute:zx
  1009 op mul *tmp107 :compute:zy :compute:zy
 
  1018 label *label308
  1019 label *label309
  1020 label *label310
-    * op add :compute:i :compute:i 1
+ 1021 op add :compute:i 56 1
  1022 set :compute:x1 :compute:zx
  1023 op mul *tmp106 :compute:zx :compute:zx
  1024 op mul *tmp107 :compute:zy :compute:zy
 
  1033 label *label311
  1034 label *label312
  1035 label *label313
-    * op add :compute:i :compute:i 1
+ 1036 op add :compute:i 57 1
  1037 set :compute:x1 :compute:zx
  1038 op mul *tmp106 :compute:zx :compute:zx
  1039 op mul *tmp107 :compute:zy :compute:zy
 
  1048 label *label314
  1049 label *label315
  1050 label *label316
-    * op add :compute:i :compute:i 1
+ 1051 op add :compute:i 58 1
  1052 set :compute:x1 :compute:zx
  1053 op mul *tmp106 :compute:zx :compute:zx
  1054 op mul *tmp107 :compute:zy :compute:zy
 
  1063 label *label317
  1064 label *label318
  1065 label *label319
-    * op add :compute:i :compute:i 1
+ 1066 op add :compute:i 59 1
  1067 set :compute:x1 :compute:zx
  1068 op mul *tmp106 :compute:zx :compute:zx
  1069 op mul *tmp107 :compute:zy :compute:zy
 
  1078 label *label320
  1079 label *label321
  1080 label *label322
-    * op add :compute:i :compute:i 1
+ 1081 op add :compute:i 60 1
  1082 set :compute:x1 :compute:zx
  1083 op mul *tmp106 :compute:zx :compute:zx
  1084 op mul *tmp107 :compute:zy :compute:zy
 
  1093 label *label323
  1094 label *label324
  1095 label *label325
-    * op add :compute:i :compute:i 1
+ 1096 op add :compute:i 61 1
  1097 set :compute:x1 :compute:zx
  1098 op mul *tmp106 :compute:zx :compute:zx
  1099 op mul *tmp107 :compute:zy :compute:zy
 
  1108 label *label326
  1109 label *label327
  1110 label *label328
-    * op add :compute:i :compute:i 1
+ 1111 op add :compute:i 62 1
  1112 label *label69
-    * set *tmp88 :compute:i
+ 1113 set *tmp88 63
  1114 jump *label57 always
  1115 label *label65
  1116 label *label66

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1:
 
   178 label *label140
   179 label *label141
   180 label *label142
-    * op add :compute:i 0 1
+  181 set :compute:i 1
   182 set :compute:x1 :compute:zx
   183 op mul *tmp106 :compute:zx :compute:zx
   184 op mul *tmp107 :compute:zy :compute:zy

Modifications by Iterated phase, Loop Hoisting, pass 3, iteration 1:
 
   161 label *label62
   162 label *label63
   163 label *label59
+  164 set *tmp88 63
   165 label *label64
   166 set :compute:i 0
   167 label *label139
 
  1111 label *label328
  1112 op add :compute:i 62 1
  1113 label *label69
-    * set *tmp88 63
  1114 jump *label57 always
  1115 label *label65
  1116 label *label66

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-1 instructions):
     0 set *id "id: Computing\nname: Mandelbrot Mania!\nversion: v3.0"
     1 set .start 0
     2 label *label0
-    * label *label1
     3 jump *label0 equal .display null
     4 jump *label0 equal .memory null
-    * label *label2
     5 label *label4
     6 label *label7
     7 wait 0
-    * label *label8
     8 read *tmp17 .memory 67
     9 jump *label7 equal .start *tmp17
-    * label *label9
    10 read .start .memory 67
    11 read .stop .memory 68
    12 set .lastColor -1
 
    33 jump *label15 equal .stop *tmp37
    34 jump *label5 always
    35 label *label15
-    * label *label16
    36 read :batch .memory 64
    37 select *tmp41 greaterThanEq :batch 1408 1 4
    38 op add *tmp42 :batch *tmp41
 
    40 jump *label19 lessThan :batch 2816
    41 jump *label14 always
    42 label *label19
-    * label *label20
    43 op mul *tmp46 11 *tmp41
    44 set :i 0
    45 op mul *tmp47 :batch 11
-    * label *label21
    46 jump *label23 lessThanEq *tmp41 0
    47 label *label121
    48 op add :adam5:index *tmp47 :i
    49 op idiv *tmp50 :adam5:index 16
    50 multijump *tmp50 0 0 (m:*label126)
    51 multilabel *label131 (m:*label126)
-    * label *label125
    52 op sub :adam5:index :adam5:index 15488
    53 op mod :adam5:x :adam5:index 176
    54 op idiv *tmp77 :adam5:index 176
 
    58 set :adam5:dx 1
    59 jump *label25 always
    60 multilabel *label127 (m:*label126)
-    * label *label27
    61 op mod *tmp52 :adam5:index 44
    62 op mul :adam5:x 4 *tmp52
    63 op idiv *tmp54 :adam5:index 44
 
    66 set :adam5:dy *tmp56
    67 set :adam5:dx *tmp56
    68 jump *label25 always
-    * label *label26
    69 multilabel *label128 (m:*label126)
-    * label *label32
    70 op sub :adam5:index :adam5:index 1936
    71 op mod *tmp57 :adam5:index 44
    72 op mul *tmp58 4 *tmp57
 
    76 select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1
    77 select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2
    78 jump *label25 always
-    * label *label31
    79 multilabel *label129 (m:*label126)
-    * label *label39
    80 op sub :adam5:index :adam5:index 3872
    81 op mod *tmp64 :adam5:index 88
    82 op mul :adam5:x 2 *tmp64
 
    86 select *tmp69 notEqual .ALL_PASS_COLORING false 2 1
    87 set :adam5:dy *tmp69
    88 set :adam5:dx *tmp69
-    * label *label38
    89 jump *label25 always
    90 multilabel *label130 (m:*label126)
-    * label *label44
    91 op sub :adam5:index :adam5:index 7744
    92 op mod *tmp70 :adam5:index 88
    93 op mul *tmp71 2 *tmp70
 
    97 set :adam5:dx 1
    98 select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1
    99 label *label25
-    * label *label24
   100 jump *label48 lessThanEq *tmp41 *tmp34
   101 jump *label48 notEqual .localBuffer 0
   102 draw col %[white]
 
   111 drawflush .display
   112 set .localBuffer 0
   113 label *label53
-    * label *label54
-    * label *label52
   114 label *label48
-    * label *label49
   115 op div *tmp89 :adam5:x .ZOOM
   116 op add :compute:zx *tmp89 .OFFSET_X
   117 op div *tmp91 :adam5:y .ZOOM
 
   133 set *tmp88 63
   134 jump *label57 always
   135 label *label60
-    * label *label61
   136 op add *tmp102 :compute:zx 1
   137 op len *tmp103 *tmp102 :compute:zy
   138 jump *label62 greaterThan *tmp103 0.25
   139 set *tmp88 63
   140 jump *label57 always
   141 label *label62
-    * label *label63
   142 label *label59
   143 set *tmp88 63
-    * label *label64
   144 set :compute:i 0
-    * label *label139
   145 set :compute:x1 :compute:zx
   146 op mul *tmp106 :compute:zx :compute:zx
   147 op mul *tmp107 :compute:zy :compute:zy
 
   154 jump *label140 lessThan :compute:dist 64
   155 jump *label66 always
   156 label *label140
-    * label *label141
-    * label *label142
   157 set :compute:i 1
   158 set :compute:x1 :compute:zx
   159 op mul *tmp106 :compute:zx :compute:zx
 
   167 jump *label143 lessThan :compute:dist 64
   168 jump *label66 always
   169 label *label143
-    * label *label144
-    * label *label145
   170 op add :compute:i 1 1
   171 set :compute:x1 :compute:zx
   172 op mul *tmp106 :compute:zx :compute:zx
 
   180 jump *label146 lessThan :compute:dist 64
   181 jump *label66 always
   182 label *label146
-    * label *label147
-    * label *label148
   183 op add :compute:i 2 1
   184 set :compute:x1 :compute:zx
   185 op mul *tmp106 :compute:zx :compute:zx
 
   193 jump *label149 lessThan :compute:dist 64
   194 jump *label66 always
   195 label *label149
-    * label *label150
-    * label *label151
   196 op add :compute:i 3 1
   197 set :compute:x1 :compute:zx
   198 op mul *tmp106 :compute:zx :compute:zx
 
   206 jump *label152 lessThan :compute:dist 64
   207 jump *label66 always
   208 label *label152
-    * label *label153
-    * label *label154
   209 op add :compute:i 4 1
   210 set :compute:x1 :compute:zx
   211 op mul *tmp106 :compute:zx :compute:zx
 
   219 jump *label155 lessThan :compute:dist 64
   220 jump *label66 always
   221 label *label155
-    * label *label156
-    * label *label157
   222 op add :compute:i 5 1
   223 set :compute:x1 :compute:zx
   224 op mul *tmp106 :compute:zx :compute:zx
 
   232 jump *label158 lessThan :compute:dist 64
   233 jump *label66 always
   234 label *label158
-    * label *label159
-    * label *label160
   235 op add :compute:i 6 1
   236 set :compute:x1 :compute:zx
   237 op mul *tmp106 :compute:zx :compute:zx
 
   245 jump *label161 lessThan :compute:dist 64
   246 jump *label66 always
   247 label *label161
-    * label *label162
-    * label *label163
   248 op add :compute:i 7 1
   249 set :compute:x1 :compute:zx
   250 op mul *tmp106 :compute:zx :compute:zx
 
   258 jump *label164 lessThan :compute:dist 64
   259 jump *label66 always
   260 label *label164
-    * label *label165
-    * label *label166
   261 op add :compute:i 8 1
   262 set :compute:x1 :compute:zx
   263 op mul *tmp106 :compute:zx :compute:zx
 
   271 jump *label167 lessThan :compute:dist 64
   272 jump *label66 always
   273 label *label167
-    * label *label168
-    * label *label169
   274 op add :compute:i 9 1
   275 set :compute:x1 :compute:zx
   276 op mul *tmp106 :compute:zx :compute:zx
 
   284 jump *label170 lessThan :compute:dist 64
   285 jump *label66 always
   286 label *label170
-    * label *label171
-    * label *label172
   287 op add :compute:i 10 1
   288 set :compute:x1 :compute:zx
   289 op mul *tmp106 :compute:zx :compute:zx
 
   297 jump *label173 lessThan :compute:dist 64
   298 jump *label66 always
   299 label *label173
-    * label *label174
-    * label *label175
   300 op add :compute:i 11 1
   301 set :compute:x1 :compute:zx
   302 op mul *tmp106 :compute:zx :compute:zx
 
   310 jump *label176 lessThan :compute:dist 64
   311 jump *label66 always
   312 label *label176
-    * label *label177
-    * label *label178
   313 op add :compute:i 12 1
   314 set :compute:x1 :compute:zx
   315 op mul *tmp106 :compute:zx :compute:zx
 
   323 jump *label179 lessThan :compute:dist 64
   324 jump *label66 always
   325 label *label179
-    * label *label180
-    * label *label181
   326 op add :compute:i 13 1
   327 set :compute:x1 :compute:zx
   328 op mul *tmp106 :compute:zx :compute:zx
 
   336 jump *label182 lessThan :compute:dist 64
   337 jump *label66 always
   338 label *label182
-    * label *label183
-    * label *label184
   339 op add :compute:i 14 1
   340 set :compute:x1 :compute:zx
   341 op mul *tmp106 :compute:zx :compute:zx
 
   349 jump *label185 lessThan :compute:dist 64
   350 jump *label66 always
   351 label *label185
-    * label *label186
-    * label *label187
   352 op add :compute:i 15 1
   353 set :compute:x1 :compute:zx
   354 op mul *tmp106 :compute:zx :compute:zx
 
   362 jump *label188 lessThan :compute:dist 64
   363 jump *label66 always
   364 label *label188
-    * label *label189
-    * label *label190
   365 op add :compute:i 16 1
   366 set :compute:x1 :compute:zx
   367 op mul *tmp106 :compute:zx :compute:zx
 
   375 jump *label191 lessThan :compute:dist 64
   376 jump *label66 always
   377 label *label191
-    * label *label192
-    * label *label193
   378 op add :compute:i 17 1
   379 set :compute:x1 :compute:zx
   380 op mul *tmp106 :compute:zx :compute:zx
 
   388 jump *label194 lessThan :compute:dist 64
   389 jump *label66 always
   390 label *label194
-    * label *label195
-    * label *label196
   391 op add :compute:i 18 1
   392 set :compute:x1 :compute:zx
   393 op mul *tmp106 :compute:zx :compute:zx
 
   401 jump *label197 lessThan :compute:dist 64
   402 jump *label66 always
   403 label *label197
-    * label *label198
-    * label *label199
   404 op add :compute:i 19 1
   405 set :compute:x1 :compute:zx
   406 op mul *tmp106 :compute:zx :compute:zx
 
   414 jump *label200 lessThan :compute:dist 64
   415 jump *label66 always
   416 label *label200
-    * label *label201
-    * label *label202
   417 op add :compute:i 20 1
   418 set :compute:x1 :compute:zx
   419 op mul *tmp106 :compute:zx :compute:zx
 
   427 jump *label203 lessThan :compute:dist 64
   428 jump *label66 always
   429 label *label203
-    * label *label204
-    * label *label205
   430 op add :compute:i 21 1
   431 set :compute:x1 :compute:zx
   432 op mul *tmp106 :compute:zx :compute:zx
 
   440 jump *label206 lessThan :compute:dist 64
   441 jump *label66 always
   442 label *label206
-    * label *label207
-    * label *label208
   443 op add :compute:i 22 1
   444 set :compute:x1 :compute:zx
   445 op mul *tmp106 :compute:zx :compute:zx
 
   453 jump *label209 lessThan :compute:dist 64
   454 jump *label66 always
   455 label *label209
-    * label *label210
-    * label *label211
   456 op add :compute:i 23 1
   457 set :compute:x1 :compute:zx
   458 op mul *tmp106 :compute:zx :compute:zx
 
   466 jump *label212 lessThan :compute:dist 64
   467 jump *label66 always
   468 label *label212
-    * label *label213
-    * label *label214
   469 op add :compute:i 24 1
   470 set :compute:x1 :compute:zx
   471 op mul *tmp106 :compute:zx :compute:zx
 
   479 jump *label215 lessThan :compute:dist 64
   480 jump *label66 always
   481 label *label215
-    * label *label216
-    * label *label217
   482 op add :compute:i 25 1
   483 set :compute:x1 :compute:zx
   484 op mul *tmp106 :compute:zx :compute:zx
 
   492 jump *label218 lessThan :compute:dist 64
   493 jump *label66 always
   494 label *label218
-    * label *label219
-    * label *label220
   495 op add :compute:i 26 1
   496 set :compute:x1 :compute:zx
   497 op mul *tmp106 :compute:zx :compute:zx
 
   505 jump *label221 lessThan :compute:dist 64
   506 jump *label66 always
   507 label *label221
-    * label *label222
-    * label *label223
   508 op add :compute:i 27 1
   509 set :compute:x1 :compute:zx
   510 op mul *tmp106 :compute:zx :compute:zx
 
   518 jump *label224 lessThan :compute:dist 64
   519 jump *label66 always
   520 label *label224
-    * label *label225
-    * label *label226
   521 op add :compute:i 28 1
   522 set :compute:x1 :compute:zx
   523 op mul *tmp106 :compute:zx :compute:zx
 
   531 jump *label227 lessThan :compute:dist 64
   532 jump *label66 always
   533 label *label227
-    * label *label228
-    * label *label229
   534 op add :compute:i 29 1
   535 set :compute:x1 :compute:zx
   536 op mul *tmp106 :compute:zx :compute:zx
 
   544 jump *label230 lessThan :compute:dist 64
   545 jump *label66 always
   546 label *label230
-    * label *label231
-    * label *label232
   547 op add :compute:i 30 1
   548 set :compute:x1 :compute:zx
   549 op mul *tmp106 :compute:zx :compute:zx
 
   557 jump *label233 lessThan :compute:dist 64
   558 jump *label66 always
   559 label *label233
-    * label *label234
-    * label *label235
   560 op add :compute:i 31 1
   561 set :compute:x1 :compute:zx
   562 op mul *tmp106 :compute:zx :compute:zx
 
   570 jump *label236 lessThan :compute:dist 64
   571 jump *label66 always
   572 label *label236
-    * label *label237
-    * label *label238
   573 op add :compute:i 32 1
   574 set :compute:x1 :compute:zx
   575 op mul *tmp106 :compute:zx :compute:zx
 
   583 jump *label239 lessThan :compute:dist 64
   584 jump *label66 always
   585 label *label239
-    * label *label240
-    * label *label241
   586 op add :compute:i 33 1
   587 set :compute:x1 :compute:zx
   588 op mul *tmp106 :compute:zx :compute:zx
 
   596 jump *label242 lessThan :compute:dist 64
   597 jump *label66 always
   598 label *label242
-    * label *label243
-    * label *label244
   599 op add :compute:i 34 1
   600 set :compute:x1 :compute:zx
   601 op mul *tmp106 :compute:zx :compute:zx
 
   609 jump *label245 lessThan :compute:dist 64
   610 jump *label66 always
   611 label *label245
-    * label *label246
-    * label *label247
   612 op add :compute:i 35 1
   613 set :compute:x1 :compute:zx
   614 op mul *tmp106 :compute:zx :compute:zx
 
   622 jump *label248 lessThan :compute:dist 64
   623 jump *label66 always
   624 label *label248
-    * label *label249
-    * label *label250
   625 op add :compute:i 36 1
   626 set :compute:x1 :compute:zx
   627 op mul *tmp106 :compute:zx :compute:zx
 
   635 jump *label251 lessThan :compute:dist 64
   636 jump *label66 always
   637 label *label251
-    * label *label252
-    * label *label253
   638 op add :compute:i 37 1
   639 set :compute:x1 :compute:zx
   640 op mul *tmp106 :compute:zx :compute:zx
 
   648 jump *label254 lessThan :compute:dist 64
   649 jump *label66 always
   650 label *label254
-    * label *label255
-    * label *label256
   651 op add :compute:i 38 1
   652 set :compute:x1 :compute:zx
   653 op mul *tmp106 :compute:zx :compute:zx
 
   661 jump *label257 lessThan :compute:dist 64
   662 jump *label66 always
   663 label *label257
-    * label *label258
-    * label *label259
   664 op add :compute:i 39 1
   665 set :compute:x1 :compute:zx
   666 op mul *tmp106 :compute:zx :compute:zx
 
   674 jump *label260 lessThan :compute:dist 64
   675 jump *label66 always
   676 label *label260
-    * label *label261
-    * label *label262
   677 op add :compute:i 40 1
   678 set :compute:x1 :compute:zx
   679 op mul *tmp106 :compute:zx :compute:zx
 
   687 jump *label263 lessThan :compute:dist 64
   688 jump *label66 always
   689 label *label263
-    * label *label264
-    * label *label265
   690 op add :compute:i 41 1
   691 set :compute:x1 :compute:zx
   692 op mul *tmp106 :compute:zx :compute:zx
 
   700 jump *label266 lessThan :compute:dist 64
   701 jump *label66 always
   702 label *label266
-    * label *label267
-    * label *label268
   703 op add :compute:i 42 1
   704 set :compute:x1 :compute:zx
   705 op mul *tmp106 :compute:zx :compute:zx
 
   713 jump *label269 lessThan :compute:dist 64
   714 jump *label66 always
   715 label *label269
-    * label *label270
-    * label *label271
   716 op add :compute:i 43 1
   717 set :compute:x1 :compute:zx
   718 op mul *tmp106 :compute:zx :compute:zx
 
   726 jump *label272 lessThan :compute:dist 64
   727 jump *label66 always
   728 label *label272
-    * label *label273
-    * label *label274
   729 op add :compute:i 44 1
   730 set :compute:x1 :compute:zx
   731 op mul *tmp106 :compute:zx :compute:zx
 
   739 jump *label275 lessThan :compute:dist 64
   740 jump *label66 always
   741 label *label275
-    * label *label276
-    * label *label277
   742 op add :compute:i 45 1
   743 set :compute:x1 :compute:zx
   744 op mul *tmp106 :compute:zx :compute:zx
 
   752 jump *label278 lessThan :compute:dist 64
   753 jump *label66 always
   754 label *label278
-    * label *label279
-    * label *label280
   755 op add :compute:i 46 1
   756 set :compute:x1 :compute:zx
   757 op mul *tmp106 :compute:zx :compute:zx
 
   765 jump *label281 lessThan :compute:dist 64
   766 jump *label66 always
   767 label *label281
-    * label *label282
-    * label *label283
   768 op add :compute:i 47 1
   769 set :compute:x1 :compute:zx
   770 op mul *tmp106 :compute:zx :compute:zx
 
   778 jump *label284 lessThan :compute:dist 64
   779 jump *label66 always
   780 label *label284
-    * label *label285
-    * label *label286
   781 op add :compute:i 48 1
   782 set :compute:x1 :compute:zx
   783 op mul *tmp106 :compute:zx :compute:zx
 
   791 jump *label287 lessThan :compute:dist 64
   792 jump *label66 always
   793 label *label287
-    * label *label288
-    * label *label289
   794 op add :compute:i 49 1
   795 set :compute:x1 :compute:zx
   796 op mul *tmp106 :compute:zx :compute:zx
 
   804 jump *label290 lessThan :compute:dist 64
   805 jump *label66 always
   806 label *label290
-    * label *label291
-    * label *label292
   807 op add :compute:i 50 1
   808 set :compute:x1 :compute:zx
   809 op mul *tmp106 :compute:zx :compute:zx
 
   817 jump *label293 lessThan :compute:dist 64
   818 jump *label66 always
   819 label *label293
-    * label *label294
-    * label *label295
   820 op add :compute:i 51 1
   821 set :compute:x1 :compute:zx
   822 op mul *tmp106 :compute:zx :compute:zx
 
   830 jump *label296 lessThan :compute:dist 64
   831 jump *label66 always
   832 label *label296
-    * label *label297
-    * label *label298
   833 op add :compute:i 52 1
   834 set :compute:x1 :compute:zx
   835 op mul *tmp106 :compute:zx :compute:zx
 
   843 jump *label299 lessThan :compute:dist 64
   844 jump *label66 always
   845 label *label299
-    * label *label300
-    * label *label301
   846 op add :compute:i 53 1
   847 set :compute:x1 :compute:zx
   848 op mul *tmp106 :compute:zx :compute:zx
 
   856 jump *label302 lessThan :compute:dist 64
   857 jump *label66 always
   858 label *label302
-    * label *label303
-    * label *label304
   859 op add :compute:i 54 1
   860 set :compute:x1 :compute:zx
   861 op mul *tmp106 :compute:zx :compute:zx
 
   869 jump *label305 lessThan :compute:dist 64
   870 jump *label66 always
   871 label *label305
-    * label *label306
-    * label *label307
   872 op add :compute:i 55 1
   873 set :compute:x1 :compute:zx
   874 op mul *tmp106 :compute:zx :compute:zx
 
   882 jump *label308 lessThan :compute:dist 64
   883 jump *label66 always
   884 label *label308
-    * label *label309
-    * label *label310
   885 op add :compute:i 56 1
   886 set :compute:x1 :compute:zx
   887 op mul *tmp106 :compute:zx :compute:zx
 
   895 jump *label311 lessThan :compute:dist 64
   896 jump *label66 always
   897 label *label311
-    * label *label312
-    * label *label313
   898 op add :compute:i 57 1
   899 set :compute:x1 :compute:zx
   900 op mul *tmp106 :compute:zx :compute:zx
 
   908 jump *label314 lessThan :compute:dist 64
   909 jump *label66 always
   910 label *label314
-    * label *label315
-    * label *label316
   911 op add :compute:i 58 1
   912 set :compute:x1 :compute:zx
   913 op mul *tmp106 :compute:zx :compute:zx
 
   921 jump *label317 lessThan :compute:dist 64
   922 jump *label66 always
   923 label *label317
-    * label *label318
-    * label *label319
   924 op add :compute:i 59 1
   925 set :compute:x1 :compute:zx
   926 op mul *tmp106 :compute:zx :compute:zx
 
   934 jump *label320 lessThan :compute:dist 64
   935 jump *label66 always
   936 label *label320
-    * label *label321
-    * label *label322
   937 op add :compute:i 60 1
   938 set :compute:x1 :compute:zx
   939 op mul *tmp106 :compute:zx :compute:zx
 
   947 jump *label323 lessThan :compute:dist 64
   948 jump *label66 always
   949 label *label323
-    * label *label324
-    * label *label325
   950 op add :compute:i 61 1
   951 set :compute:x1 :compute:zx
   952 op mul *tmp106 :compute:zx :compute:zx
 
   960 jump *label326 lessThan :compute:dist 64
   961 jump *label66 always
   962 label *label326
-    * label *label327
-    * label *label328
   963 op add :compute:i 62 1
-    * label *label69
   964 jump *label57 always
-    * label *label65
   965 label *label66
   966 jump *label72 lessThanEq .PALETTE 1
   967 op log *tmp117 :compute:dist
 
   971 op sub :compute:correction 4 *tmp120
   972 op add :compute:i :compute:i :compute:correction
   973 label *label72
-    * label *label73
   974 set *tmp88 :compute:i
   975 label *label57
   976 jump *label75 notEqual *tmp88 63
 
   981 multijump .PALETTE 0 0 (m:*label133)
   982 multilabel *label138 (m:*label133)
   983 multilabel *label134 (m:*label133)
-    * label *label132
   984 op div *tmp161 *tmp88 63.75
   985 op sub :drawPixel:r 1 *tmp161
   986 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
   987 jump *label79 always
   988 multilabel *label135 (m:*label133)
-    * label *label81
   989 op sub *tmp127 32 *tmp88
   990 op abs *tmp128 *tmp127
   991 op div *tmp130 *tmp128 36.42857142857143
 
   998 op add :drawPixel:b 0.47058823529411764 *tmp140
   999 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1000 jump *label79 always
-    * label *label80
  1001 multilabel *label136 (m:*label133)
-    * label *label83
  1002 op div *tmp144 *tmp88 0.175
  1003 op sin :drawPixel:r *tmp144
  1004 op cos :drawPixel:g *tmp144
 
  1008 op add :drawPixel:b 0.39215686274509803 *tmp152
  1009 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
  1010 jump *label79 always
-    * label *label82
  1011 multilabel *label137 (m:*label133)
-    * label *label85
  1012 op div :drawPixel:r *tmp88 63.75
  1013 op div :drawPixel:g *tmp88 170
  1014 packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1
 
  1019 label *label78
  1020 label *label76
  1021 jump *label86 lessThan .localBuffer 254
-    * label *label89
  1022 jump *label91 lessThanEq .localBuffer 0
  1023 label *label123
  1024 read *tmp171 .memory 68
 
  1032 drawflush .display
  1033 set .localBuffer 0
  1034 label *label95
-    * label *label96
-    * label *label94
-    * label *label90
  1035 jump *label123 greaterThan .localBuffer 0
  1036 label *label91
-    * label *label88
  1037 label *label86
-    * label *label87
  1038 jump *label99 lessThanEq .localBuffer 0
  1039 jump *label99 strictNotEqual :drawPixel:color .lastColor
  1040 draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy
 
  1055 drawflush .display
  1056 set .localBuffer 0
  1057 label *label104
-    * label *label105
-    * label *label103
-    * label *label74
  1058 wait 0
  1059 read *tmp187 .memory 68
  1060 jump *label108 equal .stop *tmp187
  1061 jump *label5 always
  1062 label *label108
-    * label *label109
  1063 read *tmp189 .memory 66
  1064 op add *tmp2 *tmp189 1
  1065 write *tmp2 .memory 66
  1066 read *tmp191 .memory 65
  1067 op add *tmp192 *tmp191 *tmp88
  1068 write *tmp192 .memory 65
-    * label *label22
  1069 op add :i :i 1
  1070 jump *label121 lessThan :i *tmp46
  1071 label *label23
-    * label *label13
  1072 jump *label12 always
  1073 label *label14
-    * label *label111
  1074 jump *label113 lessThanEq .localBuffer 0
  1075 label *label124
  1076 read *tmp195 .memory 68
 
  1084 drawflush .display
  1085 set .localBuffer 0
  1086 label *label117
-    * label *label118
-    * label *label116
-    * label *label112
  1087 jump *label124 greaterThan .localBuffer 0
  1088 label *label113
-    * label *label110
  1089 label *label5
  1090 jump *label4 always
-    * label *label6
-    * end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-66 instructions):
 
    30 label *label12
    31 wait 0
    32 read *tmp37 .memory 68
-    * jump *label15 equal .stop *tmp37
-    * jump *label5 always
+   33 jump *label5 notEqual .stop *tmp37
    34 label *label15
    35 read :batch .memory 64
    36 select *tmp41 greaterThanEq :batch 1408 1 4
    37 op add *tmp42 :batch *tmp41
    38 write *tmp42 .memory 64
-    * jump *label19 lessThan :batch 2816
-    * jump *label14 always
+   39 jump *label14 greaterThanEq :batch 2816
    40 label *label19
    41 op mul *tmp46 11 *tmp41
    42 set :i 0
 
   149 op mul *tmp111 *tmp110 :compute:zy
   150 op add :compute:zy *tmp111 :compute:cy
   151 op len :compute:dist :compute:zx :compute:zy
-    * jump *label140 lessThan :compute:dist 64
-    * jump *label66 always
+  152 jump *label66 greaterThanEq :compute:dist 64
   153 label *label140
   154 set :compute:i 1
   155 set :compute:x1 :compute:zx
 
   161 op mul *tmp111 *tmp110 :compute:zy
   162 op add :compute:zy *tmp111 :compute:cy
   163 op len :compute:dist :compute:zx :compute:zy
-    * jump *label143 lessThan :compute:dist 64
-    * jump *label66 always
+  164 jump *label66 greaterThanEq :compute:dist 64
   165 label *label143
   166 op add :compute:i 1 1
   167 set :compute:x1 :compute:zx
 
   173 op mul *tmp111 *tmp110 :compute:zy
   174 op add :compute:zy *tmp111 :compute:cy
   175 op len :compute:dist :compute:zx :compute:zy
-    * jump *label146 lessThan :compute:dist 64
-    * jump *label66 always
+  176 jump *label66 greaterThanEq :compute:dist 64
   177 label *label146
   178 op add :compute:i 2 1
   179 set :compute:x1 :compute:zx
 
   185 op mul *tmp111 *tmp110 :compute:zy
   186 op add :compute:zy *tmp111 :compute:cy
   187 op len :compute:dist :compute:zx :compute:zy
-    * jump *label149 lessThan :compute:dist 64
-    * jump *label66 always
+  188 jump *label66 greaterThanEq :compute:dist 64
   189 label *label149
   190 op add :compute:i 3 1
   191 set :compute:x1 :compute:zx
 
   197 op mul *tmp111 *tmp110 :compute:zy
   198 op add :compute:zy *tmp111 :compute:cy
   199 op len :compute:dist :compute:zx :compute:zy
-    * jump *label152 lessThan :compute:dist 64
-    * jump *label66 always
+  200 jump *label66 greaterThanEq :compute:dist 64
   201 label *label152
   202 op add :compute:i 4 1
   203 set :compute:x1 :compute:zx
 
   209 op mul *tmp111 *tmp110 :compute:zy
   210 op add :compute:zy *tmp111 :compute:cy
   211 op len :compute:dist :compute:zx :compute:zy
-    * jump *label155 lessThan :compute:dist 64
-    * jump *label66 always
+  212 jump *label66 greaterThanEq :compute:dist 64
   213 label *label155
   214 op add :compute:i 5 1
   215 set :compute:x1 :compute:zx
 
   221 op mul *tmp111 *tmp110 :compute:zy
   222 op add :compute:zy *tmp111 :compute:cy
   223 op len :compute:dist :compute:zx :compute:zy
-    * jump *label158 lessThan :compute:dist 64
-    * jump *label66 always
+  224 jump *label66 greaterThanEq :compute:dist 64
   225 label *label158
   226 op add :compute:i 6 1
   227 set :compute:x1 :compute:zx
 
   233 op mul *tmp111 *tmp110 :compute:zy
   234 op add :compute:zy *tmp111 :compute:cy
   235 op len :compute:dist :compute:zx :compute:zy
-    * jump *label161 lessThan :compute:dist 64
-    * jump *label66 always
+  236 jump *label66 greaterThanEq :compute:dist 64
   237 label *label161
   238 op add :compute:i 7 1
   239 set :compute:x1 :compute:zx
 
   245 op mul *tmp111 *tmp110 :compute:zy
   246 op add :compute:zy *tmp111 :compute:cy
   247 op len :compute:dist :compute:zx :compute:zy
-    * jump *label164 lessThan :compute:dist 64
-    * jump *label66 always
+  248 jump *label66 greaterThanEq :compute:dist 64
   249 label *label164
   250 op add :compute:i 8 1
   251 set :compute:x1 :compute:zx
 
   257 op mul *tmp111 *tmp110 :compute:zy
   258 op add :compute:zy *tmp111 :compute:cy
   259 op len :compute:dist :compute:zx :compute:zy
-    * jump *label167 lessThan :compute:dist 64
-    * jump *label66 always
+  260 jump *label66 greaterThanEq :compute:dist 64
   261 label *label167
   262 op add :compute:i 9 1
   263 set :compute:x1 :compute:zx
 
   269 op mul *tmp111 *tmp110 :compute:zy
   270 op add :compute:zy *tmp111 :compute:cy
   271 op len :compute:dist :compute:zx :compute:zy
-    * jump *label170 lessThan :compute:dist 64
-    * jump *label66 always
+  272 jump *label66 greaterThanEq :compute:dist 64
   273 label *label170
   274 op add :compute:i 10 1
   275 set :compute:x1 :compute:zx
 
   281 op mul *tmp111 *tmp110 :compute:zy
   282 op add :compute:zy *tmp111 :compute:cy
   283 op len :compute:dist :compute:zx :compute:zy
-    * jump *label173 lessThan :compute:dist 64
-    * jump *label66 always
+  284 jump *label66 greaterThanEq :compute:dist 64
   285 label *label173
   286 op add :compute:i 11 1
   287 set :compute:x1 :compute:zx
 
   293 op mul *tmp111 *tmp110 :compute:zy
   294 op add :compute:zy *tmp111 :compute:cy
   295 op len :compute:dist :compute:zx :compute:zy
-    * jump *label176 lessThan :compute:dist 64
-    * jump *label66 always
+  296 jump *label66 greaterThanEq :compute:dist 64
   297 label *label176
   298 op add :compute:i 12 1
   299 set :compute:x1 :compute:zx
 
   305 op mul *tmp111 *tmp110 :compute:zy
   306 op add :compute:zy *tmp111 :compute:cy
   307 op len :compute:dist :compute:zx :compute:zy
-    * jump *label179 lessThan :compute:dist 64
-    * jump *label66 always
+  308 jump *label66 greaterThanEq :compute:dist 64
   309 label *label179
   310 op add :compute:i 13 1
   311 set :compute:x1 :compute:zx
 
   317 op mul *tmp111 *tmp110 :compute:zy
   318 op add :compute:zy *tmp111 :compute:cy
   319 op len :compute:dist :compute:zx :compute:zy
-    * jump *label182 lessThan :compute:dist 64
-    * jump *label66 always
+  320 jump *label66 greaterThanEq :compute:dist 64
   321 label *label182
   322 op add :compute:i 14 1
   323 set :compute:x1 :compute:zx
 
   329 op mul *tmp111 *tmp110 :compute:zy
   330 op add :compute:zy *tmp111 :compute:cy
   331 op len :compute:dist :compute:zx :compute:zy
-    * jump *label185 lessThan :compute:dist 64
-    * jump *label66 always
+  332 jump *label66 greaterThanEq :compute:dist 64
   333 label *label185
   334 op add :compute:i 15 1
   335 set :compute:x1 :compute:zx
 
   341 op mul *tmp111 *tmp110 :compute:zy
   342 op add :compute:zy *tmp111 :compute:cy
   343 op len :compute:dist :compute:zx :compute:zy
-    * jump *label188 lessThan :compute:dist 64
-    * jump *label66 always
+  344 jump *label66 greaterThanEq :compute:dist 64
   345 label *label188
   346 op add :compute:i 16 1
   347 set :compute:x1 :compute:zx
 
   353 op mul *tmp111 *tmp110 :compute:zy
   354 op add :compute:zy *tmp111 :compute:cy
   355 op len :compute:dist :compute:zx :compute:zy
-    * jump *label191 lessThan :compute:dist 64
-    * jump *label66 always
+  356 jump *label66 greaterThanEq :compute:dist 64
   357 label *label191
   358 op add :compute:i 17 1
   359 set :compute:x1 :compute:zx
 
   365 op mul *tmp111 *tmp110 :compute:zy
   366 op add :compute:zy *tmp111 :compute:cy
   367 op len :compute:dist :compute:zx :compute:zy
-    * jump *label194 lessThan :compute:dist 64
-    * jump *label66 always
+  368 jump *label66 greaterThanEq :compute:dist 64
   369 label *label194
   370 op add :compute:i 18 1
   371 set :compute:x1 :compute:zx
 
   377 op mul *tmp111 *tmp110 :compute:zy
   378 op add :compute:zy *tmp111 :compute:cy
   379 op len :compute:dist :compute:zx :compute:zy
-    * jump *label197 lessThan :compute:dist 64
-    * jump *label66 always
+  380 jump *label66 greaterThanEq :compute:dist 64
   381 label *label197
   382 op add :compute:i 19 1
   383 set :compute:x1 :compute:zx
 
   389 op mul *tmp111 *tmp110 :compute:zy
   390 op add :compute:zy *tmp111 :compute:cy
   391 op len :compute:dist :compute:zx :compute:zy
-    * jump *label200 lessThan :compute:dist 64
-    * jump *label66 always
+  392 jump *label66 greaterThanEq :compute:dist 64
   393 label *label200
   394 op add :compute:i 20 1
   395 set :compute:x1 :compute:zx
 
   401 op mul *tmp111 *tmp110 :compute:zy
   402 op add :compute:zy *tmp111 :compute:cy
   403 op len :compute:dist :compute:zx :compute:zy
-    * jump *label203 lessThan :compute:dist 64
-    * jump *label66 always
+  404 jump *label66 greaterThanEq :compute:dist 64
   405 label *label203
   406 op add :compute:i 21 1
   407 set :compute:x1 :compute:zx
 
   413 op mul *tmp111 *tmp110 :compute:zy
   414 op add :compute:zy *tmp111 :compute:cy
   415 op len :compute:dist :compute:zx :compute:zy
-    * jump *label206 lessThan :compute:dist 64
-    * jump *label66 always
+  416 jump *label66 greaterThanEq :compute:dist 64
   417 label *label206
   418 op add :compute:i 22 1
   419 set :compute:x1 :compute:zx
 
   425 op mul *tmp111 *tmp110 :compute:zy
   426 op add :compute:zy *tmp111 :compute:cy
   427 op len :compute:dist :compute:zx :compute:zy
-    * jump *label209 lessThan :compute:dist 64
-    * jump *label66 always
+  428 jump *label66 greaterThanEq :compute:dist 64
   429 label *label209
   430 op add :compute:i 23 1
   431 set :compute:x1 :compute:zx
 
   437 op mul *tmp111 *tmp110 :compute:zy
   438 op add :compute:zy *tmp111 :compute:cy
   439 op len :compute:dist :compute:zx :compute:zy
-    * jump *label212 lessThan :compute:dist 64
-    * jump *label66 always
+  440 jump *label66 greaterThanEq :compute:dist 64
   441 label *label212
   442 op add :compute:i 24 1
   443 set :compute:x1 :compute:zx
 
   449 op mul *tmp111 *tmp110 :compute:zy
   450 op add :compute:zy *tmp111 :compute:cy
   451 op len :compute:dist :compute:zx :compute:zy
-    * jump *label215 lessThan :compute:dist 64
-    * jump *label66 always
+  452 jump *label66 greaterThanEq :compute:dist 64
   453 label *label215
   454 op add :compute:i 25 1
   455 set :compute:x1 :compute:zx
 
   461 op mul *tmp111 *tmp110 :compute:zy
   462 op add :compute:zy *tmp111 :compute:cy
   463 op len :compute:dist :compute:zx :compute:zy
-    * jump *label218 lessThan :compute:dist 64
-    * jump *label66 always
+  464 jump *label66 greaterThanEq :compute:dist 64
   465 label *label218
   466 op add :compute:i 26 1
   467 set :compute:x1 :compute:zx
 
   473 op mul *tmp111 *tmp110 :compute:zy
   474 op add :compute:zy *tmp111 :compute:cy
   475 op len :compute:dist :compute:zx :compute:zy
-    * jump *label221 lessThan :compute:dist 64
-    * jump *label66 always
+  476 jump *label66 greaterThanEq :compute:dist 64
   477 label *label221
   478 op add :compute:i 27 1
   479 set :compute:x1 :compute:zx
 
   485 op mul *tmp111 *tmp110 :compute:zy
   486 op add :compute:zy *tmp111 :compute:cy
   487 op len :compute:dist :compute:zx :compute:zy
-    * jump *label224 lessThan :compute:dist 64
-    * jump *label66 always
+  488 jump *label66 greaterThanEq :compute:dist 64
   489 label *label224
   490 op add :compute:i 28 1
   491 set :compute:x1 :compute:zx
 
   497 op mul *tmp111 *tmp110 :compute:zy
   498 op add :compute:zy *tmp111 :compute:cy
   499 op len :compute:dist :compute:zx :compute:zy
-    * jump *label227 lessThan :compute:dist 64
-    * jump *label66 always
+  500 jump *label66 greaterThanEq :compute:dist 64
   501 label *label227
   502 op add :compute:i 29 1
   503 set :compute:x1 :compute:zx
 
   509 op mul *tmp111 *tmp110 :compute:zy
   510 op add :compute:zy *tmp111 :compute:cy
   511 op len :compute:dist :compute:zx :compute:zy
-    * jump *label230 lessThan :compute:dist 64
-    * jump *label66 always
+  512 jump *label66 greaterThanEq :compute:dist 64
   513 label *label230
   514 op add :compute:i 30 1
   515 set :compute:x1 :compute:zx
 
   521 op mul *tmp111 *tmp110 :compute:zy
   522 op add :compute:zy *tmp111 :compute:cy
   523 op len :compute:dist :compute:zx :compute:zy
-    * jump *label233 lessThan :compute:dist 64
-    * jump *label66 always
+  524 jump *label66 greaterThanEq :compute:dist 64
   525 label *label233
   526 op add :compute:i 31 1
   527 set :compute:x1 :compute:zx
 
   533 op mul *tmp111 *tmp110 :compute:zy
   534 op add :compute:zy *tmp111 :compute:cy
   535 op len :compute:dist :compute:zx :compute:zy
-    * jump *label236 lessThan :compute:dist 64
-    * jump *label66 always
+  536 jump *label66 greaterThanEq :compute:dist 64
   537 label *label236
   538 op add :compute:i 32 1
   539 set :compute:x1 :compute:zx
 
   545 op mul *tmp111 *tmp110 :compute:zy
   546 op add :compute:zy *tmp111 :compute:cy
   547 op len :compute:dist :compute:zx :compute:zy
-    * jump *label239 lessThan :compute:dist 64
-    * jump *label66 always
+  548 jump *label66 greaterThanEq :compute:dist 64
   549 label *label239
   550 op add :compute:i 33 1
   551 set :compute:x1 :compute:zx
 
   557 op mul *tmp111 *tmp110 :compute:zy
   558 op add :compute:zy *tmp111 :compute:cy
   559 op len :compute:dist :compute:zx :compute:zy
-    * jump *label242 lessThan :compute:dist 64
-    * jump *label66 always
+  560 jump *label66 greaterThanEq :compute:dist 64
   561 label *label242
   562 op add :compute:i 34 1
   563 set :compute:x1 :compute:zx
 
   569 op mul *tmp111 *tmp110 :compute:zy
   570 op add :compute:zy *tmp111 :compute:cy
   571 op len :compute:dist :compute:zx :compute:zy
-    * jump *label245 lessThan :compute:dist 64
-    * jump *label66 always
+  572 jump *label66 greaterThanEq :compute:dist 64
   573 label *label245
   574 op add :compute:i 35 1
   575 set :compute:x1 :compute:zx
 
   581 op mul *tmp111 *tmp110 :compute:zy
   582 op add :compute:zy *tmp111 :compute:cy
   583 op len :compute:dist :compute:zx :compute:zy
-    * jump *label248 lessThan :compute:dist 64
-    * jump *label66 always
+  584 jump *label66 greaterThanEq :compute:dist 64
   585 label *label248
   586 op add :compute:i 36 1
   587 set :compute:x1 :compute:zx
 
   593 op mul *tmp111 *tmp110 :compute:zy
   594 op add :compute:zy *tmp111 :compute:cy
   595 op len :compute:dist :compute:zx :compute:zy
-    * jump *label251 lessThan :compute:dist 64
-    * jump *label66 always
+  596 jump *label66 greaterThanEq :compute:dist 64
   597 label *label251
   598 op add :compute:i 37 1
   599 set :compute:x1 :compute:zx
 
   605 op mul *tmp111 *tmp110 :compute:zy
   606 op add :compute:zy *tmp111 :compute:cy
   607 op len :compute:dist :compute:zx :compute:zy
-    * jump *label254 lessThan :compute:dist 64
-    * jump *label66 always
+  608 jump *label66 greaterThanEq :compute:dist 64
   609 label *label254
   610 op add :compute:i 38 1
   611 set :compute:x1 :compute:zx
 
   617 op mul *tmp111 *tmp110 :compute:zy
   618 op add :compute:zy *tmp111 :compute:cy
   619 op len :compute:dist :compute:zx :compute:zy
-    * jump *label257 lessThan :compute:dist 64
-    * jump *label66 always
+  620 jump *label66 greaterThanEq :compute:dist 64
   621 label *label257
   622 op add :compute:i 39 1
   623 set :compute:x1 :compute:zx
 
   629 op mul *tmp111 *tmp110 :compute:zy
   630 op add :compute:zy *tmp111 :compute:cy
   631 op len :compute:dist :compute:zx :compute:zy
-    * jump *label260 lessThan :compute:dist 64
-    * jump *label66 always
+  632 jump *label66 greaterThanEq :compute:dist 64
   633 label *label260
   634 op add :compute:i 40 1
   635 set :compute:x1 :compute:zx
 
   641 op mul *tmp111 *tmp110 :compute:zy
   642 op add :compute:zy *tmp111 :compute:cy
   643 op len :compute:dist :compute:zx :compute:zy
-    * jump *label263 lessThan :compute:dist 64
-    * jump *label66 always
+  644 jump *label66 greaterThanEq :compute:dist 64
   645 label *label263
   646 op add :compute:i 41 1
   647 set :compute:x1 :compute:zx
 
   653 op mul *tmp111 *tmp110 :compute:zy
   654 op add :compute:zy *tmp111 :compute:cy
   655 op len :compute:dist :compute:zx :compute:zy
-    * jump *label266 lessThan :compute:dist 64
-    * jump *label66 always
+  656 jump *label66 greaterThanEq :compute:dist 64
   657 label *label266
   658 op add :compute:i 42 1
   659 set :compute:x1 :compute:zx
 
   665 op mul *tmp111 *tmp110 :compute:zy
   666 op add :compute:zy *tmp111 :compute:cy
   667 op len :compute:dist :compute:zx :compute:zy
-    * jump *label269 lessThan :compute:dist 64
-    * jump *label66 always
+  668 jump *label66 greaterThanEq :compute:dist 64
   669 label *label269
   670 op add :compute:i 43 1
   671 set :compute:x1 :compute:zx
 
   677 op mul *tmp111 *tmp110 :compute:zy
   678 op add :compute:zy *tmp111 :compute:cy
   679 op len :compute:dist :compute:zx :compute:zy
-    * jump *label272 lessThan :compute:dist 64
-    * jump *label66 always
+  680 jump *label66 greaterThanEq :compute:dist 64
   681 label *label272
   682 op add :compute:i 44 1
   683 set :compute:x1 :compute:zx
 
   689 op mul *tmp111 *tmp110 :compute:zy
   690 op add :compute:zy *tmp111 :compute:cy
   691 op len :compute:dist :compute:zx :compute:zy
-    * jump *label275 lessThan :compute:dist 64
-    * jump *label66 always
+  692 jump *label66 greaterThanEq :compute:dist 64
   693 label *label275
   694 op add :compute:i 45 1
   695 set :compute:x1 :compute:zx
 
   701 op mul *tmp111 *tmp110 :compute:zy
   702 op add :compute:zy *tmp111 :compute:cy
   703 op len :compute:dist :compute:zx :compute:zy
-    * jump *label278 lessThan :compute:dist 64
-    * jump *label66 always
+  704 jump *label66 greaterThanEq :compute:dist 64
   705 label *label278
   706 op add :compute:i 46 1
   707 set :compute:x1 :compute:zx
 
   713 op mul *tmp111 *tmp110 :compute:zy
   714 op add :compute:zy *tmp111 :compute:cy
   715 op len :compute:dist :compute:zx :compute:zy
-    * jump *label281 lessThan :compute:dist 64
-    * jump *label66 always
+  716 jump *label66 greaterThanEq :compute:dist 64
   717 label *label281
   718 op add :compute:i 47 1
   719 set :compute:x1 :compute:zx
 
   725 op mul *tmp111 *tmp110 :compute:zy
   726 op add :compute:zy *tmp111 :compute:cy
   727 op len :compute:dist :compute:zx :compute:zy
-    * jump *label284 lessThan :compute:dist 64
-    * jump *label66 always
+  728 jump *label66 greaterThanEq :compute:dist 64
   729 label *label284
   730 op add :compute:i 48 1
   731 set :compute:x1 :compute:zx
 
   737 op mul *tmp111 *tmp110 :compute:zy
   738 op add :compute:zy *tmp111 :compute:cy
   739 op len :compute:dist :compute:zx :compute:zy
-    * jump *label287 lessThan :compute:dist 64
-    * jump *label66 always
+  740 jump *label66 greaterThanEq :compute:dist 64
   741 label *label287
   742 op add :compute:i 49 1
   743 set :compute:x1 :compute:zx
 
   749 op mul *tmp111 *tmp110 :compute:zy
   750 op add :compute:zy *tmp111 :compute:cy
   751 op len :compute:dist :compute:zx :compute:zy
-    * jump *label290 lessThan :compute:dist 64
-    * jump *label66 always
+  752 jump *label66 greaterThanEq :compute:dist 64
   753 label *label290
   754 op add :compute:i 50 1
   755 set :compute:x1 :compute:zx
 
   761 op mul *tmp111 *tmp110 :compute:zy
   762 op add :compute:zy *tmp111 :compute:cy
   763 op len :compute:dist :compute:zx :compute:zy
-    * jump *label293 lessThan :compute:dist 64
-    * jump *label66 always
+  764 jump *label66 greaterThanEq :compute:dist 64
   765 label *label293
   766 op add :compute:i 51 1
   767 set :compute:x1 :compute:zx
 
   773 op mul *tmp111 *tmp110 :compute:zy
   774 op add :compute:zy *tmp111 :compute:cy
   775 op len :compute:dist :compute:zx :compute:zy
-    * jump *label296 lessThan :compute:dist 64
-    * jump *label66 always
+  776 jump *label66 greaterThanEq :compute:dist 64
   777 label *label296
   778 op add :compute:i 52 1
   779 set :compute:x1 :compute:zx
 
   785 op mul *tmp111 *tmp110 :compute:zy
   786 op add :compute:zy *tmp111 :compute:cy
   787 op len :compute:dist :compute:zx :compute:zy
-    * jump *label299 lessThan :compute:dist 64
-    * jump *label66 always
+  788 jump *label66 greaterThanEq :compute:dist 64
   789 label *label299
   790 op add :compute:i 53 1
   791 set :compute:x1 :compute:zx
 
   797 op mul *tmp111 *tmp110 :compute:zy
   798 op add :compute:zy *tmp111 :compute:cy
   799 op len :compute:dist :compute:zx :compute:zy
-    * jump *label302 lessThan :compute:dist 64
-    * jump *label66 always
+  800 jump *label66 greaterThanEq :compute:dist 64
   801 label *label302
   802 op add :compute:i 54 1
   803 set :compute:x1 :compute:zx
 
   809 op mul *tmp111 *tmp110 :compute:zy
   810 op add :compute:zy *tmp111 :compute:cy
   811 op len :compute:dist :compute:zx :compute:zy
-    * jump *label305 lessThan :compute:dist 64
-    * jump *label66 always
+  812 jump *label66 greaterThanEq :compute:dist 64
   813 label *label305
   814 op add :compute:i 55 1
   815 set :compute:x1 :compute:zx
 
   821 op mul *tmp111 *tmp110 :compute:zy
   822 op add :compute:zy *tmp111 :compute:cy
   823 op len :compute:dist :compute:zx :compute:zy
-    * jump *label308 lessThan :compute:dist 64
-    * jump *label66 always
+  824 jump *label66 greaterThanEq :compute:dist 64
   825 label *label308
   826 op add :compute:i 56 1
   827 set :compute:x1 :compute:zx
 
   833 op mul *tmp111 *tmp110 :compute:zy
   834 op add :compute:zy *tmp111 :compute:cy
   835 op len :compute:dist :compute:zx :compute:zy
-    * jump *label311 lessThan :compute:dist 64
-    * jump *label66 always
+  836 jump *label66 greaterThanEq :compute:dist 64
   837 label *label311
   838 op add :compute:i 57 1
   839 set :compute:x1 :compute:zx
 
   845 op mul *tmp111 *tmp110 :compute:zy
   846 op add :compute:zy *tmp111 :compute:cy
   847 op len :compute:dist :compute:zx :compute:zy
-    * jump *label314 lessThan :compute:dist 64
-    * jump *label66 always
+  848 jump *label66 greaterThanEq :compute:dist 64
   849 label *label314
   850 op add :compute:i 58 1
   851 set :compute:x1 :compute:zx
 
   857 op mul *tmp111 *tmp110 :compute:zy
   858 op add :compute:zy *tmp111 :compute:cy
   859 op len :compute:dist :compute:zx :compute:zy
-    * jump *label317 lessThan :compute:dist 64
-    * jump *label66 always
+  860 jump *label66 greaterThanEq :compute:dist 64
   861 label *label317
   862 op add :compute:i 59 1
   863 set :compute:x1 :compute:zx
 
   869 op mul *tmp111 *tmp110 :compute:zy
   870 op add :compute:zy *tmp111 :compute:cy
   871 op len :compute:dist :compute:zx :compute:zy
-    * jump *label320 lessThan :compute:dist 64
-    * jump *label66 always
+  872 jump *label66 greaterThanEq :compute:dist 64
   873 label *label320
   874 op add :compute:i 60 1
   875 set :compute:x1 :compute:zx
 
   881 op mul *tmp111 *tmp110 :compute:zy
   882 op add :compute:zy *tmp111 :compute:cy
   883 op len :compute:dist :compute:zx :compute:zy
-    * jump *label323 lessThan :compute:dist 64
-    * jump *label66 always
+  884 jump *label66 greaterThanEq :compute:dist 64
   885 label *label323
   886 op add :compute:i 61 1
   887 set :compute:x1 :compute:zx
 
   893 op mul *tmp111 *tmp110 :compute:zy
   894 op add :compute:zy *tmp111 :compute:cy
   895 op len :compute:dist :compute:zx :compute:zy
-    * jump *label326 lessThan :compute:dist 64
-    * jump *label66 always
+  896 jump *label66 greaterThanEq :compute:dist 64
   897 label *label326
   898 op add :compute:i 62 1
   899 jump *label57 always
 
   992 label *label104
   993 wait 0
   994 read *tmp187 .memory 68
-    * jump *label108 equal .stop *tmp187
-    * jump *label5 always
+  995 jump *label5 notEqual .stop *tmp187
   996 label *label108
   997 read *tmp189 .memory 66
   998 op add *tmp2 *tmp189 1

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
 
    30 label *label12
    31 wait 0
    32 read *tmp37 .memory 68
-    * jump *label5 notEqual .stop *tmp37
+   33 jump *label4 notEqual .stop *tmp37
    34 read :batch .memory 64
    35 select *tmp41 greaterThanEq :batch 1408 1 4
    36 op add *tmp42 :batch *tmp41
 
    39 op mul *tmp46 11 *tmp41
    40 set :i 0
    41 op mul *tmp47 :batch 11
-    * jump *label23 lessThanEq *tmp41 0
+   42 jump *label12 lessThanEq *tmp41 0
    43 label *label121
    44 op add :adam5:index *tmp47 :i
    45 op idiv *tmp50 :adam5:index 16
 
   854 op div *tmp161 *tmp88 63.75
   855 op sub :drawPixel:r 1 *tmp161
   856 packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1
-    * jump *label79 always
+  857 jump *label78 always
   858 multilabel *label135 (m:*label133)
   859 op sub *tmp127 32 *tmp88
   860 op abs *tmp128 *tmp127
 
   867 op div *tmp140 *tmp128 63.75
   868 op add :drawPixel:b 0.47058823529411764 *tmp140
   869 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label79 always
+  870 jump *label78 always
   871 multilabel *label136 (m:*label133)
   872 op div *tmp144 *tmp88 0.175
   873 op sin :drawPixel:r *tmp144
 
   877 op div *tmp152 *tmp150 63.75
   878 op add :drawPixel:b 0.39215686274509803 *tmp152
   879 packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPixel:b 1
-    * jump *label79 always
+  880 jump *label78 always
   881 multilabel *label137 (m:*label133)
   882 op div :drawPixel:r *tmp88 63.75
   883 op div :drawPixel:g *tmp88 170
 
   889 label *label78
   890 label *label76
   891 jump *label86 lessThan .localBuffer 254
-    * jump *label91 lessThanEq .localBuffer 0
+  892 jump *label99 lessThanEq .localBuffer 0
   893 label *label123
   894 read *tmp171 .memory 68
   895 jump *label91 notEqual .stop *tmp171
 
   927 label *label104
   928 wait 0
   929 read *tmp187 .memory 68
-    * jump *label5 notEqual .stop *tmp187
+  930 jump *label4 notEqual .stop *tmp187
   931 read *tmp189 .memory 66
   932 op add *tmp2 *tmp189 1
   933 write *tmp2 .memory 66
 
   939 label *label23
   940 jump *label12 always
   941 label *label14
-    * jump *label113 lessThanEq .localBuffer 0
+  942 jump *label4 lessThanEq .localBuffer 0
   943 label *label124
   944 read *tmp195 .memory 68
-    * jump *label113 notEqual .stop *tmp195
+  945 jump *label4 notEqual .stop *tmp195
   946 wait 0
   947 sensor *tmp196 .display @enabled
   948 jump *label117 equal *tmp196 false

Final code before resolving virtual instructions:

    0:  set *id "id: Computing\nname: Mandelbrot Mania!\nversion: v3 mandelbrot-compute.mnd: #set syntax = strict;
    1:  set .start 0                                                 mandelbrot-compute.mnd: var start = 0, stop;
        label *label0                                                mandelbrot-compute.mnd: do while display == null or memory == null;
    2:  jump *label0 equal .display null                             ...
    3:  jump *label0 equal .memory null                              ...
        label *label4                                                mandelbrot-compute.mnd: MainLoop:
        label *label7                                                mandelbrot-compute.mnd: do wait(0); while start == $START;
    4:  wait 0                                                       ...
    5:  read *tmp17 .memory 67                                       ...
    6:  jump *label7 equal .start *tmp17                             ...
    7:  read .start .memory 67                                       mandelbrot-compute.mnd: start = $START;
    8:  read .stop .memory 68                                        mandelbrot-compute.mnd: stop = $STOP;
    9:  set .lastColor -1                                            mandelbrot-compute.mnd: lastColor = -1;
   10:  set .localBuffer 0                                           mandelbrot-compute.mnd: localBuffer = 0;
   11:  drawflush null                                               mandelbrot-compute.mnd: drawflush(null);
   12:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
   13:  read .ZOOM .memory 71                                        mandelbrot-compute.mnd: ZOOM     = $ZOOM;
   14:  op div *tmp21 -88 .ZOOM                                      mandelbrot-compute.mnd: OFFSET_X = -HALF_SIZE / ZOOM + $X;
   15:  read *tmp23 .memory 69                                       ...
   16:  op add .OFFSET_X *tmp21 *tmp23                               ...
   17:  read *tmp26 .memory 70                                       mandelbrot-compute.mnd: OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
   18:  op add .OFFSET_Y *tmp21 *tmp26                               ...
   19:  read .JULIA .memory 72                                       mandelbrot-compute.mnd: JULIA    = $JULIA;
   20:  read .JULIA_X .memory 73                                     mandelbrot-compute.mnd: JULIA_X  = $JULIA_X;
   21:  read .JULIA_Y .memory 74                                     mandelbrot-compute.mnd: JULIA_Y  = $JULIA_Y;
   22:  read .PALETTE .memory 75                                     mandelbrot-compute.mnd: PALETTE  = $PALETTE;
   23:  read .ALL_PASS_COLORING .memory 76                           mandelbrot-compute.mnd: ALL_PASS_COLORING = $ALL_PASS_COLORING;
   24:  read *tmp33 .memory 77                                       mandelbrot-compute.mnd: var leaderLimit = $SHOW_LEADER ? 1 - ALL_PASS_COLORING : 99;
   25:  op sub *tmp201 1 .ALL_PASS_COLORING                          ...
   26:  select *tmp34 notEqual *tmp33 false *tmp201 99               ...
        label *label12                                               mandelbrot-compute.mnd: while true do
   27:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
   28:  read *tmp37 .memory 68                                       mandelbrot-compute.mnd: if stop != $STOP then
   29:  jump *label4 notEqual .stop *tmp37                           ...
   30:  read :batch .memory 64                                       mandelbrot-compute.mnd: batch = $LINE;
   31:  select *tmp41 greaterThanEq :batch 1408 1 4                  mandelbrot-compute.mnd: multiple = batch >= TOTAL_BATCHES / 2 ? 1 : 4;
   32:  op add *tmp42 :batch *tmp41                                  mandelbrot-compute.mnd: $LINE = batch + multiple;
   33:  write *tmp42 .memory 64                 # The last atomic bl ...
   34:  jump *label14 greaterThanEq :batch 2816                      mandelbrot-compute.mnd: if batch >= TOTAL_BATCHES then
   35:  op mul *tmp46 11 *tmp41                                      mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
   36:  set :i 0                                                     ...
   37:  op mul *tmp47 :batch 11                                      ...
   38:  jump *label12 lessThanEq *tmp41 0                            ...
        label *label121                                              ...
   39:  op add :adam5:index *tmp47 :i                                mandelbrot-compute.mnd: adam5(batch * BATCH_SIZE + i, out x, out y, out dx, out dy);
   40:  op idiv *tmp50 :adam5:index 16                               mandelbrot-compute.mnd: case index \ 16
   41:  multijump *tmp50 0 0                                         ...
        multilabel *label131                                         ...
   42:  op sub :adam5:index :adam5:index 15488                       mandelbrot-compute.mnd: index -= 8 * PASS_SIZE;
   43:  op mod :adam5:x :adam5:index 176                             mandelbrot-compute.mnd: x = (index % SIZE1);
   44:  op idiv *tmp77 :adam5:index 176                              mandelbrot-compute.mnd: y = 2 * (index \ SIZE1) + 1;
   45:  op mul *tmp78 2 *tmp77                                       ...
   46:  op add :adam5:y *tmp78 1                                     ...
   47:  set :adam5:dy 1                                              mandelbrot-compute.mnd: dx = dy = 1;
   48:  set :adam5:dx 1                                              ...
   49:  jump *label25 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label127                                         ...
   50:  op mod *tmp52 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4);
   51:  op mul :adam5:x 4 *tmp52                                     ...
   52:  op idiv *tmp54 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   53:  op mul :adam5:y 4 *tmp54                                     ...
   54:  select *tmp56 notEqual .ALL_PASS_COLORING false 4 2          mandelbrot-compute.mnd: dx = dy = ALL_PASS_COLORING ? 4 : 2;
   55:  set :adam5:dy *tmp56                                         ...
   56:  set :adam5:dx *tmp56                                         ...
   57:  jump *label25 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label128                                         ...
   58:  op sub :adam5:index :adam5:index 1936                        mandelbrot-compute.mnd: index -= PASS_SIZE;
   59:  op mod *tmp57 :adam5:index 44                                mandelbrot-compute.mnd: x = 4 * (index % SIZE4) + 2;
   60:  op mul *tmp58 4 *tmp57                                       ...
   61:  op add :adam5:x *tmp58 2                                     ...
   62:  op idiv *tmp60 :adam5:index 44                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE4);
   63:  op mul :adam5:y 4 *tmp60                                     ...
   64:  select :adam5:dx notEqual .ALL_PASS_COLORING false 2 1       mandelbrot-compute.mnd: dx = ALL_PASS_COLORING ? 2 : 1;
   65:  select :adam5:dy notEqual .ALL_PASS_COLORING false 4 2       mandelbrot-compute.mnd: dy = ALL_PASS_COLORING ? 4 : 2;
   66:  jump *label25 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label129                                         ...
   67:  op sub :adam5:index :adam5:index 3872                        mandelbrot-compute.mnd: index -= 2 * PASS_SIZE;
   68:  op mod *tmp64 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2);
   69:  op mul :adam5:x 2 *tmp64                                     ...
   70:  op idiv *tmp66 :adam5:index 88                               mandelbrot-compute.mnd: y = 4 * (index \ SIZE2) + 2;
   71:  op mul *tmp67 4 *tmp66                                       ...
   72:  op add :adam5:y *tmp67 2                                     ...
   73:  select *tmp69 notEqual .ALL_PASS_COLORING false 2 1          mandelbrot-compute.mnd: dx = dy = ALL_PASS_COLORING ? 2 : 1;
   74:  set :adam5:dy *tmp69                                         ...
   75:  set :adam5:dx *tmp69                                         ...
   76:  jump *label25 always 0 0                                     mandelbrot-compute.mnd: case index \ 16
        multilabel *label130                                         ...
   77:  op sub :adam5:index :adam5:index 7744                        mandelbrot-compute.mnd: index -= 4 * PASS_SIZE;
   78:  op mod *tmp70 :adam5:index 88                                mandelbrot-compute.mnd: x = 2 * (index % SIZE2) + 1;
   79:  op mul *tmp71 2 *tmp70                                       ...
   80:  op add :adam5:x *tmp71 1                                     ...
   81:  op idiv *tmp73 :adam5:index 88                               mandelbrot-compute.mnd: y = 2 * (index \ SIZE2);
   82:  op mul :adam5:y 2 *tmp73                                     ...
   83:  set :adam5:dx 1                                              mandelbrot-compute.mnd: dx = 1; dy = ALL_PASS_COLORING ? 2 : 1;
   84:  select :adam5:dy notEqual .ALL_PASS_COLORING false 2 1       ...
        label *label25                                               mandelbrot-compute.mnd: case index \ 16
   85:  jump *label48 lessThanEq *tmp41 *tmp34                       mandelbrot-compute.mnd: if multiple > leaderLimit and localBuffer == 0 then
   86:  jump *label48 notEqual .localBuffer 0                        ...
   87:  draw col %[white] 0 0 0 0 0                                  mandelbrot-compute.mnd: col(%[white]);
   88:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dx 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dx);
   89:  set .lastColor %[white]                                      mandelbrot-compute.mnd: lastColor = %[white];
   90:  set .localBuffer 2                                           mandelbrot-compute.mnd: localBuffer = 2;
   91:  wait 0.004                              # 0.240 ticks for at mandelbrot-compute.mnd: atomic
   92:  sensor *tmp83 .display @enabled                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
   93:  jump *label53 equal *tmp83 false                             ...
   94:  sensor *tmp84 .display @bufferSize                           ...
   95:  jump *label53 greaterThanEq *tmp84 1022                      ...
   96:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
   97:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label53                                               mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
        label *label48                                               mandelbrot-compute.mnd: if multiple > leaderLimit and localBuffer == 0 then
   98:  op div *tmp89 :adam5:x .ZOOM                                 mandelbrot-compute.mnd: var zx = x / ZOOM + OFFSET_X;
   99:  op add :compute:zx *tmp89 .OFFSET_X                          ...
  100:  op div *tmp91 :adam5:y .ZOOM                                 mandelbrot-compute.mnd: var zy = y / ZOOM + OFFSET_Y;
  101:  op add :compute:zy *tmp91 .OFFSET_Y                          ...
  102:  jump *label58 equal .JULIA false                             mandelbrot-compute.mnd: if JULIA then
  103:  set :compute:cx .JULIA_X                                     mandelbrot-compute.mnd: cx = JULIA_X;
  104:  set :compute:cy .JULIA_Y                                     mandelbrot-compute.mnd: cy = JULIA_Y;
  105:  jump *label59 always 0 0                                     mandelbrot-compute.mnd: if JULIA then
        label *label58                                               ...
  106:  set :compute:cx :compute:zx                                  mandelbrot-compute.mnd: cx = zx;
  107:  set :compute:cy :compute:zy                                  mandelbrot-compute.mnd: cy = zy;
  108:  op sub *tmp94 :compute:zx 0.25                               mandelbrot-compute.mnd: var p = len(cx - 0.25, cy);
  109:  op len :compute:p *tmp94 :compute:zy                         ...
  110:  op mul *tmp96 2 :compute:p                                   mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  111:  op mul *tmp97 *tmp96 :compute:p                              ...
  112:  op sub *tmp98 :compute:p *tmp97                              ...
  113:  op add *tmp99 *tmp98 0.25                                    ...
  114:  jump *label60 greaterThan :compute:zx *tmp99                 ...
  115:  set *tmp88 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  116:  jump *label57 always 0 0                                     ...
        label *label60                                               mandelbrot-compute.mnd: if cx <= p - 2 * p * p + 0.25 then
  117:  op add *tmp102 :compute:zx 1                                 mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
  118:  op len *tmp103 *tmp102 :compute:zy                           ...
  119:  jump *label62 greaterThan *tmp103 0.25                       ...
  120:  set *tmp88 63                                                mandelbrot-compute.mnd: return MAX_DEPTH;
  121:  jump *label57 always 0 0                                     ...
        label *label62                                               mandelbrot-compute.mnd: if len(cx + 1, cy) <= 0.25 then
        label *label59                                               mandelbrot-compute.mnd: if JULIA then
  122:  set *tmp88 63                                                mandelbrot-compute.mnd: Compute: do
  123:  set :compute:i 0                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  124:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  125:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  126:  op mul *tmp107 :compute:zy :compute:zy                       ...
  127:  op sub *tmp108 *tmp106 *tmp107                               ...
  128:  op add :compute:zx *tmp108 :compute:cx                       ...
  129:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  130:  op mul *tmp111 *tmp110 :compute:zy                           ...
  131:  op add :compute:zy *tmp111 :compute:cy                       ...
  132:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  133:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  134:  set :compute:i 1                                             mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  135:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  136:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  137:  op mul *tmp107 :compute:zy :compute:zy                       ...
  138:  op sub *tmp108 *tmp106 *tmp107                               ...
  139:  op add :compute:zx *tmp108 :compute:cx                       ...
  140:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  141:  op mul *tmp111 *tmp110 :compute:zy                           ...
  142:  op add :compute:zy *tmp111 :compute:cy                       ...
  143:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  144:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  145:  op add :compute:i 1 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  146:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  147:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  148:  op mul *tmp107 :compute:zy :compute:zy                       ...
  149:  op sub *tmp108 *tmp106 *tmp107                               ...
  150:  op add :compute:zx *tmp108 :compute:cx                       ...
  151:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  152:  op mul *tmp111 *tmp110 :compute:zy                           ...
  153:  op add :compute:zy *tmp111 :compute:cy                       ...
  154:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  155:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  156:  op add :compute:i 2 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  157:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  158:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  159:  op mul *tmp107 :compute:zy :compute:zy                       ...
  160:  op sub *tmp108 *tmp106 *tmp107                               ...
  161:  op add :compute:zx *tmp108 :compute:cx                       ...
  162:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  163:  op mul *tmp111 *tmp110 :compute:zy                           ...
  164:  op add :compute:zy *tmp111 :compute:cy                       ...
  165:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  166:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  167:  op add :compute:i 3 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  168:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  169:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  170:  op mul *tmp107 :compute:zy :compute:zy                       ...
  171:  op sub *tmp108 *tmp106 *tmp107                               ...
  172:  op add :compute:zx *tmp108 :compute:cx                       ...
  173:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  174:  op mul *tmp111 *tmp110 :compute:zy                           ...
  175:  op add :compute:zy *tmp111 :compute:cy                       ...
  176:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  177:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  178:  op add :compute:i 4 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  179:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  180:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  181:  op mul *tmp107 :compute:zy :compute:zy                       ...
  182:  op sub *tmp108 *tmp106 *tmp107                               ...
  183:  op add :compute:zx *tmp108 :compute:cx                       ...
  184:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  185:  op mul *tmp111 *tmp110 :compute:zy                           ...
  186:  op add :compute:zy *tmp111 :compute:cy                       ...
  187:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  188:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  189:  op add :compute:i 5 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  190:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  191:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  192:  op mul *tmp107 :compute:zy :compute:zy                       ...
  193:  op sub *tmp108 *tmp106 *tmp107                               ...
  194:  op add :compute:zx *tmp108 :compute:cx                       ...
  195:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  196:  op mul *tmp111 *tmp110 :compute:zy                           ...
  197:  op add :compute:zy *tmp111 :compute:cy                       ...
  198:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  199:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  200:  op add :compute:i 6 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  201:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  202:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  203:  op mul *tmp107 :compute:zy :compute:zy                       ...
  204:  op sub *tmp108 *tmp106 *tmp107                               ...
  205:  op add :compute:zx *tmp108 :compute:cx                       ...
  206:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  207:  op mul *tmp111 *tmp110 :compute:zy                           ...
  208:  op add :compute:zy *tmp111 :compute:cy                       ...
  209:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  210:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  211:  op add :compute:i 7 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  212:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  213:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  214:  op mul *tmp107 :compute:zy :compute:zy                       ...
  215:  op sub *tmp108 *tmp106 *tmp107                               ...
  216:  op add :compute:zx *tmp108 :compute:cx                       ...
  217:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  218:  op mul *tmp111 *tmp110 :compute:zy                           ...
  219:  op add :compute:zy *tmp111 :compute:cy                       ...
  220:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  221:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  222:  op add :compute:i 8 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  223:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  224:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  225:  op mul *tmp107 :compute:zy :compute:zy                       ...
  226:  op sub *tmp108 *tmp106 *tmp107                               ...
  227:  op add :compute:zx *tmp108 :compute:cx                       ...
  228:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  229:  op mul *tmp111 *tmp110 :compute:zy                           ...
  230:  op add :compute:zy *tmp111 :compute:cy                       ...
  231:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  232:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  233:  op add :compute:i 9 1                                        mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  234:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  235:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  236:  op mul *tmp107 :compute:zy :compute:zy                       ...
  237:  op sub *tmp108 *tmp106 *tmp107                               ...
  238:  op add :compute:zx *tmp108 :compute:cx                       ...
  239:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  240:  op mul *tmp111 *tmp110 :compute:zy                           ...
  241:  op add :compute:zy *tmp111 :compute:cy                       ...
  242:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  243:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  244:  op add :compute:i 10 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  245:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  246:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  247:  op mul *tmp107 :compute:zy :compute:zy                       ...
  248:  op sub *tmp108 *tmp106 *tmp107                               ...
  249:  op add :compute:zx *tmp108 :compute:cx                       ...
  250:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  251:  op mul *tmp111 *tmp110 :compute:zy                           ...
  252:  op add :compute:zy *tmp111 :compute:cy                       ...
  253:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  254:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  255:  op add :compute:i 11 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  256:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  257:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  258:  op mul *tmp107 :compute:zy :compute:zy                       ...
  259:  op sub *tmp108 *tmp106 *tmp107                               ...
  260:  op add :compute:zx *tmp108 :compute:cx                       ...
  261:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  262:  op mul *tmp111 *tmp110 :compute:zy                           ...
  263:  op add :compute:zy *tmp111 :compute:cy                       ...
  264:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  265:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  266:  op add :compute:i 12 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  267:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  268:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  269:  op mul *tmp107 :compute:zy :compute:zy                       ...
  270:  op sub *tmp108 *tmp106 *tmp107                               ...
  271:  op add :compute:zx *tmp108 :compute:cx                       ...
  272:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  273:  op mul *tmp111 *tmp110 :compute:zy                           ...
  274:  op add :compute:zy *tmp111 :compute:cy                       ...
  275:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  276:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  277:  op add :compute:i 13 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  278:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  279:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  280:  op mul *tmp107 :compute:zy :compute:zy                       ...
  281:  op sub *tmp108 *tmp106 *tmp107                               ...
  282:  op add :compute:zx *tmp108 :compute:cx                       ...
  283:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  284:  op mul *tmp111 *tmp110 :compute:zy                           ...
  285:  op add :compute:zy *tmp111 :compute:cy                       ...
  286:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  287:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  288:  op add :compute:i 14 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  289:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  290:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  291:  op mul *tmp107 :compute:zy :compute:zy                       ...
  292:  op sub *tmp108 *tmp106 *tmp107                               ...
  293:  op add :compute:zx *tmp108 :compute:cx                       ...
  294:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  295:  op mul *tmp111 *tmp110 :compute:zy                           ...
  296:  op add :compute:zy *tmp111 :compute:cy                       ...
  297:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  298:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  299:  op add :compute:i 15 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  300:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  301:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  302:  op mul *tmp107 :compute:zy :compute:zy                       ...
  303:  op sub *tmp108 *tmp106 *tmp107                               ...
  304:  op add :compute:zx *tmp108 :compute:cx                       ...
  305:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  306:  op mul *tmp111 *tmp110 :compute:zy                           ...
  307:  op add :compute:zy *tmp111 :compute:cy                       ...
  308:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  309:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  310:  op add :compute:i 16 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  311:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  312:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  313:  op mul *tmp107 :compute:zy :compute:zy                       ...
  314:  op sub *tmp108 *tmp106 *tmp107                               ...
  315:  op add :compute:zx *tmp108 :compute:cx                       ...
  316:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  317:  op mul *tmp111 *tmp110 :compute:zy                           ...
  318:  op add :compute:zy *tmp111 :compute:cy                       ...
  319:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  320:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  321:  op add :compute:i 17 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  322:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  323:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  324:  op mul *tmp107 :compute:zy :compute:zy                       ...
  325:  op sub *tmp108 *tmp106 *tmp107                               ...
  326:  op add :compute:zx *tmp108 :compute:cx                       ...
  327:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  328:  op mul *tmp111 *tmp110 :compute:zy                           ...
  329:  op add :compute:zy *tmp111 :compute:cy                       ...
  330:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  331:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  332:  op add :compute:i 18 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  333:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  334:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  335:  op mul *tmp107 :compute:zy :compute:zy                       ...
  336:  op sub *tmp108 *tmp106 *tmp107                               ...
  337:  op add :compute:zx *tmp108 :compute:cx                       ...
  338:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  339:  op mul *tmp111 *tmp110 :compute:zy                           ...
  340:  op add :compute:zy *tmp111 :compute:cy                       ...
  341:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  342:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  343:  op add :compute:i 19 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  344:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  345:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  346:  op mul *tmp107 :compute:zy :compute:zy                       ...
  347:  op sub *tmp108 *tmp106 *tmp107                               ...
  348:  op add :compute:zx *tmp108 :compute:cx                       ...
  349:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  350:  op mul *tmp111 *tmp110 :compute:zy                           ...
  351:  op add :compute:zy *tmp111 :compute:cy                       ...
  352:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  353:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  354:  op add :compute:i 20 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  355:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  356:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  357:  op mul *tmp107 :compute:zy :compute:zy                       ...
  358:  op sub *tmp108 *tmp106 *tmp107                               ...
  359:  op add :compute:zx *tmp108 :compute:cx                       ...
  360:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  361:  op mul *tmp111 *tmp110 :compute:zy                           ...
  362:  op add :compute:zy *tmp111 :compute:cy                       ...
  363:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  364:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  365:  op add :compute:i 21 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  366:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  367:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  368:  op mul *tmp107 :compute:zy :compute:zy                       ...
  369:  op sub *tmp108 *tmp106 *tmp107                               ...
  370:  op add :compute:zx *tmp108 :compute:cx                       ...
  371:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  372:  op mul *tmp111 *tmp110 :compute:zy                           ...
  373:  op add :compute:zy *tmp111 :compute:cy                       ...
  374:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  375:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  376:  op add :compute:i 22 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  377:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  378:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  379:  op mul *tmp107 :compute:zy :compute:zy                       ...
  380:  op sub *tmp108 *tmp106 *tmp107                               ...
  381:  op add :compute:zx *tmp108 :compute:cx                       ...
  382:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  383:  op mul *tmp111 *tmp110 :compute:zy                           ...
  384:  op add :compute:zy *tmp111 :compute:cy                       ...
  385:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  386:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  387:  op add :compute:i 23 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  388:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  389:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  390:  op mul *tmp107 :compute:zy :compute:zy                       ...
  391:  op sub *tmp108 *tmp106 *tmp107                               ...
  392:  op add :compute:zx *tmp108 :compute:cx                       ...
  393:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  394:  op mul *tmp111 *tmp110 :compute:zy                           ...
  395:  op add :compute:zy *tmp111 :compute:cy                       ...
  396:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  397:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  398:  op add :compute:i 24 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  399:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  400:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  401:  op mul *tmp107 :compute:zy :compute:zy                       ...
  402:  op sub *tmp108 *tmp106 *tmp107                               ...
  403:  op add :compute:zx *tmp108 :compute:cx                       ...
  404:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  405:  op mul *tmp111 *tmp110 :compute:zy                           ...
  406:  op add :compute:zy *tmp111 :compute:cy                       ...
  407:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  408:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  409:  op add :compute:i 25 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  410:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  411:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  412:  op mul *tmp107 :compute:zy :compute:zy                       ...
  413:  op sub *tmp108 *tmp106 *tmp107                               ...
  414:  op add :compute:zx *tmp108 :compute:cx                       ...
  415:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  416:  op mul *tmp111 *tmp110 :compute:zy                           ...
  417:  op add :compute:zy *tmp111 :compute:cy                       ...
  418:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  419:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  420:  op add :compute:i 26 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  421:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  422:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  423:  op mul *tmp107 :compute:zy :compute:zy                       ...
  424:  op sub *tmp108 *tmp106 *tmp107                               ...
  425:  op add :compute:zx *tmp108 :compute:cx                       ...
  426:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  427:  op mul *tmp111 *tmp110 :compute:zy                           ...
  428:  op add :compute:zy *tmp111 :compute:cy                       ...
  429:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  430:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  431:  op add :compute:i 27 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  432:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  433:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  434:  op mul *tmp107 :compute:zy :compute:zy                       ...
  435:  op sub *tmp108 *tmp106 *tmp107                               ...
  436:  op add :compute:zx *tmp108 :compute:cx                       ...
  437:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  438:  op mul *tmp111 *tmp110 :compute:zy                           ...
  439:  op add :compute:zy *tmp111 :compute:cy                       ...
  440:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  441:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  442:  op add :compute:i 28 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  443:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  444:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  445:  op mul *tmp107 :compute:zy :compute:zy                       ...
  446:  op sub *tmp108 *tmp106 *tmp107                               ...
  447:  op add :compute:zx *tmp108 :compute:cx                       ...
  448:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  449:  op mul *tmp111 *tmp110 :compute:zy                           ...
  450:  op add :compute:zy *tmp111 :compute:cy                       ...
  451:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  452:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  453:  op add :compute:i 29 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  454:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  455:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  456:  op mul *tmp107 :compute:zy :compute:zy                       ...
  457:  op sub *tmp108 *tmp106 *tmp107                               ...
  458:  op add :compute:zx *tmp108 :compute:cx                       ...
  459:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  460:  op mul *tmp111 *tmp110 :compute:zy                           ...
  461:  op add :compute:zy *tmp111 :compute:cy                       ...
  462:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  463:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  464:  op add :compute:i 30 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  465:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  466:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  467:  op mul *tmp107 :compute:zy :compute:zy                       ...
  468:  op sub *tmp108 *tmp106 *tmp107                               ...
  469:  op add :compute:zx *tmp108 :compute:cx                       ...
  470:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  471:  op mul *tmp111 *tmp110 :compute:zy                           ...
  472:  op add :compute:zy *tmp111 :compute:cy                       ...
  473:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  474:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  475:  op add :compute:i 31 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  476:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  477:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  478:  op mul *tmp107 :compute:zy :compute:zy                       ...
  479:  op sub *tmp108 *tmp106 *tmp107                               ...
  480:  op add :compute:zx *tmp108 :compute:cx                       ...
  481:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  482:  op mul *tmp111 *tmp110 :compute:zy                           ...
  483:  op add :compute:zy *tmp111 :compute:cy                       ...
  484:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  485:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  486:  op add :compute:i 32 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  487:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  488:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  489:  op mul *tmp107 :compute:zy :compute:zy                       ...
  490:  op sub *tmp108 *tmp106 *tmp107                               ...
  491:  op add :compute:zx *tmp108 :compute:cx                       ...
  492:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  493:  op mul *tmp111 *tmp110 :compute:zy                           ...
  494:  op add :compute:zy *tmp111 :compute:cy                       ...
  495:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  496:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  497:  op add :compute:i 33 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  498:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  499:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  500:  op mul *tmp107 :compute:zy :compute:zy                       ...
  501:  op sub *tmp108 *tmp106 *tmp107                               ...
  502:  op add :compute:zx *tmp108 :compute:cx                       ...
  503:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  504:  op mul *tmp111 *tmp110 :compute:zy                           ...
  505:  op add :compute:zy *tmp111 :compute:cy                       ...
  506:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  507:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  508:  op add :compute:i 34 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  509:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  510:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  511:  op mul *tmp107 :compute:zy :compute:zy                       ...
  512:  op sub *tmp108 *tmp106 *tmp107                               ...
  513:  op add :compute:zx *tmp108 :compute:cx                       ...
  514:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  515:  op mul *tmp111 *tmp110 :compute:zy                           ...
  516:  op add :compute:zy *tmp111 :compute:cy                       ...
  517:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  518:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  519:  op add :compute:i 35 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  520:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  521:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  522:  op mul *tmp107 :compute:zy :compute:zy                       ...
  523:  op sub *tmp108 *tmp106 *tmp107                               ...
  524:  op add :compute:zx *tmp108 :compute:cx                       ...
  525:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  526:  op mul *tmp111 *tmp110 :compute:zy                           ...
  527:  op add :compute:zy *tmp111 :compute:cy                       ...
  528:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  529:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  530:  op add :compute:i 36 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  531:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  532:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  533:  op mul *tmp107 :compute:zy :compute:zy                       ...
  534:  op sub *tmp108 *tmp106 *tmp107                               ...
  535:  op add :compute:zx *tmp108 :compute:cx                       ...
  536:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  537:  op mul *tmp111 *tmp110 :compute:zy                           ...
  538:  op add :compute:zy *tmp111 :compute:cy                       ...
  539:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  540:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  541:  op add :compute:i 37 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  542:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  543:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  544:  op mul *tmp107 :compute:zy :compute:zy                       ...
  545:  op sub *tmp108 *tmp106 *tmp107                               ...
  546:  op add :compute:zx *tmp108 :compute:cx                       ...
  547:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  548:  op mul *tmp111 *tmp110 :compute:zy                           ...
  549:  op add :compute:zy *tmp111 :compute:cy                       ...
  550:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  551:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  552:  op add :compute:i 38 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  553:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  554:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  555:  op mul *tmp107 :compute:zy :compute:zy                       ...
  556:  op sub *tmp108 *tmp106 *tmp107                               ...
  557:  op add :compute:zx *tmp108 :compute:cx                       ...
  558:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  559:  op mul *tmp111 *tmp110 :compute:zy                           ...
  560:  op add :compute:zy *tmp111 :compute:cy                       ...
  561:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  562:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  563:  op add :compute:i 39 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  564:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  565:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  566:  op mul *tmp107 :compute:zy :compute:zy                       ...
  567:  op sub *tmp108 *tmp106 *tmp107                               ...
  568:  op add :compute:zx *tmp108 :compute:cx                       ...
  569:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  570:  op mul *tmp111 *tmp110 :compute:zy                           ...
  571:  op add :compute:zy *tmp111 :compute:cy                       ...
  572:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  573:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  574:  op add :compute:i 40 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  575:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  576:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  577:  op mul *tmp107 :compute:zy :compute:zy                       ...
  578:  op sub *tmp108 *tmp106 *tmp107                               ...
  579:  op add :compute:zx *tmp108 :compute:cx                       ...
  580:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  581:  op mul *tmp111 *tmp110 :compute:zy                           ...
  582:  op add :compute:zy *tmp111 :compute:cy                       ...
  583:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  584:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  585:  op add :compute:i 41 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  586:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  587:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  588:  op mul *tmp107 :compute:zy :compute:zy                       ...
  589:  op sub *tmp108 *tmp106 *tmp107                               ...
  590:  op add :compute:zx *tmp108 :compute:cx                       ...
  591:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  592:  op mul *tmp111 *tmp110 :compute:zy                           ...
  593:  op add :compute:zy *tmp111 :compute:cy                       ...
  594:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  595:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  596:  op add :compute:i 42 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  597:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  598:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  599:  op mul *tmp107 :compute:zy :compute:zy                       ...
  600:  op sub *tmp108 *tmp106 *tmp107                               ...
  601:  op add :compute:zx *tmp108 :compute:cx                       ...
  602:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  603:  op mul *tmp111 *tmp110 :compute:zy                           ...
  604:  op add :compute:zy *tmp111 :compute:cy                       ...
  605:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  606:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  607:  op add :compute:i 43 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  608:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  609:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  610:  op mul *tmp107 :compute:zy :compute:zy                       ...
  611:  op sub *tmp108 *tmp106 *tmp107                               ...
  612:  op add :compute:zx *tmp108 :compute:cx                       ...
  613:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  614:  op mul *tmp111 *tmp110 :compute:zy                           ...
  615:  op add :compute:zy *tmp111 :compute:cy                       ...
  616:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  617:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  618:  op add :compute:i 44 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  619:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  620:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  621:  op mul *tmp107 :compute:zy :compute:zy                       ...
  622:  op sub *tmp108 *tmp106 *tmp107                               ...
  623:  op add :compute:zx *tmp108 :compute:cx                       ...
  624:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  625:  op mul *tmp111 *tmp110 :compute:zy                           ...
  626:  op add :compute:zy *tmp111 :compute:cy                       ...
  627:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  628:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  629:  op add :compute:i 45 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  630:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  631:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  632:  op mul *tmp107 :compute:zy :compute:zy                       ...
  633:  op sub *tmp108 *tmp106 *tmp107                               ...
  634:  op add :compute:zx *tmp108 :compute:cx                       ...
  635:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  636:  op mul *tmp111 *tmp110 :compute:zy                           ...
  637:  op add :compute:zy *tmp111 :compute:cy                       ...
  638:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  639:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  640:  op add :compute:i 46 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  641:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  642:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  643:  op mul *tmp107 :compute:zy :compute:zy                       ...
  644:  op sub *tmp108 *tmp106 *tmp107                               ...
  645:  op add :compute:zx *tmp108 :compute:cx                       ...
  646:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  647:  op mul *tmp111 *tmp110 :compute:zy                           ...
  648:  op add :compute:zy *tmp111 :compute:cy                       ...
  649:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  650:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  651:  op add :compute:i 47 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  652:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  653:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  654:  op mul *tmp107 :compute:zy :compute:zy                       ...
  655:  op sub *tmp108 *tmp106 *tmp107                               ...
  656:  op add :compute:zx *tmp108 :compute:cx                       ...
  657:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  658:  op mul *tmp111 *tmp110 :compute:zy                           ...
  659:  op add :compute:zy *tmp111 :compute:cy                       ...
  660:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  661:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  662:  op add :compute:i 48 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  663:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  664:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  665:  op mul *tmp107 :compute:zy :compute:zy                       ...
  666:  op sub *tmp108 *tmp106 *tmp107                               ...
  667:  op add :compute:zx *tmp108 :compute:cx                       ...
  668:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  669:  op mul *tmp111 *tmp110 :compute:zy                           ...
  670:  op add :compute:zy *tmp111 :compute:cy                       ...
  671:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  672:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  673:  op add :compute:i 49 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  674:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  675:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  676:  op mul *tmp107 :compute:zy :compute:zy                       ...
  677:  op sub *tmp108 *tmp106 *tmp107                               ...
  678:  op add :compute:zx *tmp108 :compute:cx                       ...
  679:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  680:  op mul *tmp111 *tmp110 :compute:zy                           ...
  681:  op add :compute:zy *tmp111 :compute:cy                       ...
  682:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  683:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  684:  op add :compute:i 50 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  685:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  686:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  687:  op mul *tmp107 :compute:zy :compute:zy                       ...
  688:  op sub *tmp108 *tmp106 *tmp107                               ...
  689:  op add :compute:zx *tmp108 :compute:cx                       ...
  690:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  691:  op mul *tmp111 *tmp110 :compute:zy                           ...
  692:  op add :compute:zy *tmp111 :compute:cy                       ...
  693:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  694:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  695:  op add :compute:i 51 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  696:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  697:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  698:  op mul *tmp107 :compute:zy :compute:zy                       ...
  699:  op sub *tmp108 *tmp106 *tmp107                               ...
  700:  op add :compute:zx *tmp108 :compute:cx                       ...
  701:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  702:  op mul *tmp111 *tmp110 :compute:zy                           ...
  703:  op add :compute:zy *tmp111 :compute:cy                       ...
  704:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  705:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  706:  op add :compute:i 52 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  707:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  708:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  709:  op mul *tmp107 :compute:zy :compute:zy                       ...
  710:  op sub *tmp108 *tmp106 *tmp107                               ...
  711:  op add :compute:zx *tmp108 :compute:cx                       ...
  712:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  713:  op mul *tmp111 *tmp110 :compute:zy                           ...
  714:  op add :compute:zy *tmp111 :compute:cy                       ...
  715:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  716:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  717:  op add :compute:i 53 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  718:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  719:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  720:  op mul *tmp107 :compute:zy :compute:zy                       ...
  721:  op sub *tmp108 *tmp106 *tmp107                               ...
  722:  op add :compute:zx *tmp108 :compute:cx                       ...
  723:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  724:  op mul *tmp111 *tmp110 :compute:zy                           ...
  725:  op add :compute:zy *tmp111 :compute:cy                       ...
  726:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  727:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  728:  op add :compute:i 54 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  729:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  730:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  731:  op mul *tmp107 :compute:zy :compute:zy                       ...
  732:  op sub *tmp108 *tmp106 *tmp107                               ...
  733:  op add :compute:zx *tmp108 :compute:cx                       ...
  734:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  735:  op mul *tmp111 *tmp110 :compute:zy                           ...
  736:  op add :compute:zy *tmp111 :compute:cy                       ...
  737:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  738:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  739:  op add :compute:i 55 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  740:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  741:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  742:  op mul *tmp107 :compute:zy :compute:zy                       ...
  743:  op sub *tmp108 *tmp106 *tmp107                               ...
  744:  op add :compute:zx *tmp108 :compute:cx                       ...
  745:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  746:  op mul *tmp111 *tmp110 :compute:zy                           ...
  747:  op add :compute:zy *tmp111 :compute:cy                       ...
  748:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  749:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  750:  op add :compute:i 56 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  751:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  752:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  753:  op mul *tmp107 :compute:zy :compute:zy                       ...
  754:  op sub *tmp108 *tmp106 *tmp107                               ...
  755:  op add :compute:zx *tmp108 :compute:cx                       ...
  756:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  757:  op mul *tmp111 *tmp110 :compute:zy                           ...
  758:  op add :compute:zy *tmp111 :compute:cy                       ...
  759:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  760:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  761:  op add :compute:i 57 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  762:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  763:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  764:  op mul *tmp107 :compute:zy :compute:zy                       ...
  765:  op sub *tmp108 *tmp106 *tmp107                               ...
  766:  op add :compute:zx *tmp108 :compute:cx                       ...
  767:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  768:  op mul *tmp111 *tmp110 :compute:zy                           ...
  769:  op add :compute:zy *tmp111 :compute:cy                       ...
  770:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  771:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  772:  op add :compute:i 58 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  773:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  774:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  775:  op mul *tmp107 :compute:zy :compute:zy                       ...
  776:  op sub *tmp108 *tmp106 *tmp107                               ...
  777:  op add :compute:zx *tmp108 :compute:cx                       ...
  778:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  779:  op mul *tmp111 *tmp110 :compute:zy                           ...
  780:  op add :compute:zy *tmp111 :compute:cy                       ...
  781:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  782:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  783:  op add :compute:i 59 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  784:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  785:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  786:  op mul *tmp107 :compute:zy :compute:zy                       ...
  787:  op sub *tmp108 *tmp106 *tmp107                               ...
  788:  op add :compute:zx *tmp108 :compute:cx                       ...
  789:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  790:  op mul *tmp111 *tmp110 :compute:zy                           ...
  791:  op add :compute:zy *tmp111 :compute:cy                       ...
  792:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  793:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  794:  op add :compute:i 60 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  795:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  796:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  797:  op mul *tmp107 :compute:zy :compute:zy                       ...
  798:  op sub *tmp108 *tmp106 *tmp107                               ...
  799:  op add :compute:zx *tmp108 :compute:cx                       ...
  800:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  801:  op mul *tmp111 *tmp110 :compute:zy                           ...
  802:  op add :compute:zy *tmp111 :compute:cy                       ...
  803:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  804:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  805:  op add :compute:i 61 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  806:  set :compute:x1 :compute:zx                                  mandelbrot-compute.mnd: var x1 = zx;
  807:  op mul *tmp106 :compute:zx :compute:zx                       mandelbrot-compute.mnd: zx = x1 * x1 - y1 * y1 + cx;
  808:  op mul *tmp107 :compute:zy :compute:zy                       ...
  809:  op sub *tmp108 *tmp106 *tmp107                               ...
  810:  op add :compute:zx *tmp108 :compute:cx                       ...
  811:  op mul *tmp110 2 :compute:x1                                 mandelbrot-compute.mnd: zy = 2 * x1 * y1 + cy;
  812:  op mul *tmp111 *tmp110 :compute:zy                           ...
  813:  op add :compute:zy *tmp111 :compute:cy                       ...
  814:  op len :compute:dist :compute:zx :compute:zy                 mandelbrot-compute.mnd: dist = len(zx, zy);
  815:  jump *label66 greaterThanEq :compute:dist 64                 mandelbrot-compute.mnd: if dist >= 64 then
  816:  op add :compute:i 62 1                                       mandelbrot-compute.mnd: for i in 0 ... MAX_DEPTH do
  817:  jump *label57 always 0 0                                     mandelbrot-compute.mnd: return i;
        label *label66                                               mandelbrot-compute.mnd: Compute: do
  818:  jump *label72 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: if SMOOTH then
  819:  op log *tmp117 :compute:dist 0                               mandelbrot-compute.mnd: var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
  820:  op mul *tmp118 *tmp117 0.36067376022224085                   ...
  821:  op log *tmp119 *tmp118 0                                     ...
  822:  op mul *tmp120 *tmp119 1.4426950408889634                    ...
  823:  op sub :compute:correction 4 *tmp120                         ...
  824:  op add :compute:i :compute:i :compute:correction             mandelbrot-compute.mnd: i += correction;
        label *label72                                               mandelbrot-compute.mnd: if SMOOTH then
  825:  set *tmp88 :compute:i                                        mandelbrot-compute.mnd: return i;
        label *label57                                               mandelbrot-compute.mnd: var iterations = compute(x, y);
  826:  jump *label75 notEqual *tmp88 63                             mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  827:  set :drawPixel:color %[black]                                mandelbrot-compute.mnd: color = %[black];
  828:  jump *label76 always 0 0                                     mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
        label *label75                                               ...
  829:  jump *label77 lessThanEq .PALETTE 1                          mandelbrot-compute.mnd: elsif SMOOTH then
  830:  multijump .PALETTE 0 0                                       mandelbrot-compute.mnd: case PALETTE
        multilabel *label138                                         ...
        multilabel *label134                                         ...
  831:  op div *tmp161 *tmp88 63.75                                  mandelbrot-compute.mnd: r = 1 - 4 * iterations / 255;
  832:  op sub :drawPixel:r 1 *tmp161                                ...
  833:  packcolor :drawPixel:color :drawPixel:r :drawPixel:r 0 1     mandelbrot-compute.mnd: color = packcolor(r, r, 0, 1);
  834:  jump *label78 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label135                                         ...
  835:  op sub *tmp127 32 *tmp88                                     mandelbrot-compute.mnd: r = 255/255 - 7 * abs(32 - iterations) / 255;
  836:  op abs *tmp128 *tmp127 0                                     ...
  837:  op div *tmp130 *tmp128 36.42857142857143                     ...
  838:  op sub :drawPixel:r 1 *tmp130                                ...
  839:  op sub *tmp132 *tmp88 32                                     mandelbrot-compute.mnd: g = 240/255 - 6 * abs(iterations - 32) / 255;
  840:  op abs *tmp133 *tmp132 0                                     ...
  841:  op div *tmp135 *tmp133 42.5                                  ...
  842:  op sub :drawPixel:g 0.9411764705882353 *tmp135               ...
  843:  op div *tmp140 *tmp128 63.75                                 mandelbrot-compute.mnd: b = 120/255 + 4 * abs(32 - iterations) / 255;
  844:  op add :drawPixel:b 0.47058823529411764 *tmp140              ...
  845:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  846:  jump *label78 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label136                                         ...
  847:  op div *tmp144 *tmp88 0.175                                  mandelbrot-compute.mnd: r = sin(iterations / MAX_DEPTH * 360);
  848:  op sin :drawPixel:r *tmp144 0                                ...
  849:  op cos :drawPixel:g *tmp144 0                                mandelbrot-compute.mnd: g = cos(iterations / MAX_DEPTH * 360);
  850:  op sub *tmp149 *tmp88 32                                     mandelbrot-compute.mnd: b = 100/255 + 4 * abs(iterations - 32) / 255;
  851:  op abs *tmp150 *tmp149 0                                     ...
  852:  op div *tmp152 *tmp150 63.75                                 ...
  853:  op add :drawPixel:b 0.39215686274509803 *tmp152              ...
  854:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g :drawPi mandelbrot-compute.mnd: color = packcolor(r, g, b, 1);
  855:  jump *label78 always 0 0                                     mandelbrot-compute.mnd: case PALETTE
        multilabel *label137                                         ...
  856:  op div :drawPixel:r *tmp88 63.75                             mandelbrot-compute.mnd: r = 4 * iterations / 255;
  857:  op div :drawPixel:g *tmp88 170                               mandelbrot-compute.mnd: g = 1.5 * iterations / 255;
  858:  packcolor :drawPixel:color :drawPixel:r :drawPixel:g 0 1     mandelbrot-compute.mnd: color = packcolor(r, g, 0, 1);
  859:  jump *label78 always 0 0                                     mandelbrot-compute.mnd: elsif SMOOTH then
        label *label77                                               ...
  860:  read :drawPixel:color .memory *tmp88                         mandelbrot-compute.mnd: color = memory[iterations];
        label *label78                                               mandelbrot-compute.mnd: elsif SMOOTH then
        label *label76                                               mandelbrot-compute.mnd: if iterations == MAX_DEPTH then
  861:  jump *label86 lessThan .localBuffer 254                      mandelbrot-compute.mnd: if localBuffer >= 254 then
  862:  jump *label99 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label123                                              ...
  863:  read *tmp171 .memory 68                                      ...
  864:  jump *label91 notEqual .stop *tmp171                         ...
  865:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  866:  sensor *tmp172 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  867:  jump *label95 equal *tmp172 false                            ...
  868:  sensor *tmp173 .display @bufferSize                          ...
  869:  op sub *tmp174 1024 *tmp173                                  ...
  870:  jump *label95 greaterThanEq .localBuffer *tmp174             ...
  871:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  872:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label95                                               mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  873:  jump *label123 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label91                                               ...
        label *label86                                               mandelbrot-compute.mnd: if localBuffer >= 254 then
  874:  jump *label99 lessThanEq .localBuffer 0                      mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  875:  jump *label99 strictNotEqual :drawPixel:color .lastColor     ...
  876:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  877:  op add .localBuffer .localBuffer 1                           mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  878:  jump *label100 always 0 0                                    ...
        label *label99                                               ...
  879:  draw col :drawPixel:color 0 0 0 0 0                          mandelbrot-compute.mnd: col(color);
  880:  draw rect :adam5:x :adam5:y :adam5:dx :adam5:dy 0 0          mandelbrot-compute.mnd: rect(x, y, dx, dy);
  881:  set .lastColor :drawPixel:color                              mandelbrot-compute.mnd: lastColor = color;
  882:  op add .localBuffer .localBuffer 2                           mandelbrot-compute.mnd: localBuffer += 2;
        label *label100                                              mandelbrot-compute.mnd: if localBuffer > 0 and color === lastColor then
  883:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  884:  sensor *tmp181 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  885:  jump *label104 equal *tmp181 false                           ...
  886:  sensor *tmp182 .display @bufferSize                          ...
  887:  op sub *tmp183 1024 *tmp182                                  ...
  888:  jump *label104 greaterThanEq .localBuffer *tmp183            ...
  889:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  890:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label104                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  891:  wait 0.006                              # 0.360 ticks for at mandelbrot-compute.mnd: atomic
  892:  read *tmp187 .memory 68                                      mandelbrot-compute.mnd: if stop != $STOP then
  893:  jump *label4 notEqual .stop *tmp187                          ...
  894:  read *tmp189 .memory 66                                      mandelbrot-compute.mnd: atomic
  895:  op add *tmp2 *tmp189 1                                       ...
  896:  write *tmp2 .memory 66                                       ...
  897:  read *tmp191 .memory 65                                      mandelbrot-compute.mnd: $ITERATIONS += iterations;
  898:  op add *tmp192 *tmp191 *tmp88                                ...
  899:  write *tmp192 .memory 65                # The last atomic bl ...
  900:  op add :i :i 1                                               mandelbrot-compute.mnd: for var i in 0 ... BATCH_SIZE * multiple do
  901:  jump *label121 lessThan :i *tmp46                            ...
  902:  jump *label12 always 0 0                                     mandelbrot-compute.mnd: while true do
        label *label14                                               ...
  903:  jump *label4 lessThanEq .localBuffer 0                       mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
        label *label124                                              ...
  904:  read *tmp195 .memory 68                                      ...
  905:  jump *label4 notEqual .stop *tmp195                          ...
  906:  wait 0.004667                           # 0.280 ticks for at mandelbrot-compute.mnd: atomic
  907:  sensor *tmp196 .display @enabled                             mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  908:  jump *label117 equal *tmp196 false                           ...
  909:  sensor *tmp197 .display @bufferSize                          ...
  910:  op sub *tmp198 1024 *tmp197                                  ...
  911:  jump *label117 greaterThanEq .localBuffer *tmp198            ...
  912:  drawflush .display                                           mandelbrot-compute.mnd: drawflush(display);
  913:  set .localBuffer 0                      # The last atomic bl mandelbrot-compute.mnd: localBuffer = 0;
        label *label117                                              mandelbrot-compute.mnd: if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
  914:  jump *label124 greaterThan .localBuffer 0                    mandelbrot-compute.mnd: while localBuffer > 0 and stop == $STOP do
  915:  jump *label4 always 0 0                                      mandelbrot-compute.mnd: MainLoop:


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   728     1x    728,0  inline def compute(in x, in y)
    60     1x     60,0  <no function>
    45     1x     45,0  inline void drawPixel(in x, in y, in dx, in dy, in iterations)
    45     1x     45,0  void adam5(in index, out x, out y, out dx, out dy)
    31     4x      7,8  inline void tryFlush()
     8     2x      4,0  inline void flush()
