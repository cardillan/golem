#set target = 8L;
#set syntax = strict;
#set instruction-limit = 1500;

#set processor-id = "Controlling";
#set program-name = "Mandelbrot Mania!";
#set program-version = "v3.0";

require "mandelbrot-common.mnd";

// When set to true, all passes will color all pixels.
// Gives a full image after the first pass, but spotting changes mabe by subsequent passes (especially by the last one)
// are difficult to notice.
param ALL_PASS_COLORING = false;

// When set to true, the pixel(s) being computed are painted white. Makes it easier to see how the computation
// progresses, especially with ALL_PASS_COLORING = true.
param SHOW_LEADER = true;

// When false, the display won't be fully cleared before the next computation, just dimmed.
param CLEAR_DISPLAY = true;

// As the schematic takes a long time to build, this processor may be built and running before all these blocks
// are created. 'guarded' here ensures the program will wait for all the blocks to be built.
guarded linked message1, message2, message3,
    display     = display1,
    memory      = bank1,
    buttonUp    = switch1,
    buttonLeft  = switch2,
    buttonRight = switch3,
    buttonDown  = switch4,
    buttonPlus  = switch5,
    buttonMinus = switch6,
    buttonJulia = switch7,
    buttonLoad  = switch8,
    buttonSave  = switch9;

const bookmarkButtons = 13;
const paletteButtons = 5;

// The length must be one longer then the number of buttons, as index 0 is unused
var buttonBookmark[bookmarkButtons + 1];
var buttonPalette[paletteButtons + 1];
var links = 0;

allocate heap in memory[VARIABLES ... BOOKMARKS];

// Amount of pixels to move the center when direction button is clicked
const SHIFT = 44;

external LINE;                     // Current line
external ITERATIONS;               // Number of completed lines
external COMPLETED;                // Number of completed lines
external cached START = 0;
noinit external cached STOP;
noinit external cached X;
noinit external cached Y;
noinit external cached ZOOM;
noinit external cached JULIA;
noinit external cached JULIA_X;
noinit external cached JULIA_Y;
noinit external cached PALETTE;

external ALL_PASS_COLORING_CFG = ALL_PASS_COLORING;
external SHOW_LEADER_CFG = SHOW_LEADER;

var CHANGE = true;
var PERCENT = 0;
var TIME = 0;
var text1 = "";
var text2 = "";
var second = @second;

// Bookmark buttons state
var bookmark_x = message2.@x;
var bookmark_y = message2.@y;
var bookmark = 1;
var bookmark_clr = -1;
var position = BOOKMARKS + BOOKMARK_SIZE * (bookmark - 1);

// Palette buttons state
var palette_x = message3.@x;
var palette_clr = -1;

begin
    initialize();

    var updateBookmarks = true;
    var print = true;
    var operations = 0;
    var lastTime = 0;
    var lastPercent = 0;

    while true do
        var start = @time;

        if links != @links then
            initializeProcessors();
        end;

        if operations > display.@operations then
            // The display has been reset (map reload?), force recomputing
            CHANGE = true;
        end;
        operations = display.@operations;

        if print then printInfo(); print = false; end;

        handleMove(buttonUp,    0,  1, 1);
        handleMove(buttonLeft, -1,  0, 1);
        handleMove(buttonRight, 1,  0, 1);
        handleMove(buttonDown,  0, -1, 1);
        handleMove(buttonPlus,  0,  0, 2);      // zoom  in
        handleMove(buttonMinus, 0,  0, 0.5);    // zoom  out

        if buttonJulia.@enabled != JULIA then
            CHANGE = true;
            JULIA = buttonJulia.@enabled;
            if JULIA then JULIA_X = X; JULIA_Y = Y; end;
        end;

        if buttonLoad.@enabled then
            loadBookmark(position, bookmark);
            CHANGE = true;
        end;

        if buttonSave.@enabled then
            saveBookmark(position, bookmark);
            updateBookmarks = true;
        end;

        handleTopRowButtons(out updateBookmarks);

        if updateBookmarks then
            printBookmarks(position, bookmark);
            updateBookmarks = false;
        end;

        // Computation progress
        PERCENT = (100 * COMPLETED) \ TOTAL;
        if PERCENT < 100 then TIME = round(@second - second); end;
        if lastTime != TIME or lastPercent != PERCENT then
            lastTime = TIME;
            lastPercent = PERCENT;
            print = true;
        end;

        // Parameters changed, recompute
        if CHANGE then
            print("Initializing...");
            printflush(message1);

            // Sent signal to stop all processors
            STOP++;
            CHANGE = false;

            // Dim the current display
            if CLEAR_DISPLAY then
                clear(86, 86, 102);
            else
                color(86, 86, 102, 204);
                rect(0, 0, 176, 176);
            end;
            drawflush(display);

            // Signal next round of computing to processors
            atomic
                LINE = ITERATIONS = COMPLETED = 0;
                START++;
            end;

            second = @second;
            text1 = text2 = "";
            print = true;
        end;

        println("Links: ", links);
        print("Loop time: ", round(@time - start));
        printflush(message4);
    end;
end;

//   STATUS OUTPUT
///////////////////////////////////////////////////////////////////////

inline void printInfo()
    println("Mandelbrot Mania! v3.0");
    println($"Completed $PERCENT% in ${TIME}s");
    if JULIA then
        println("Julia set of Mandelbrot");
        println("fractal at coordinates");
        println($"   X: $JULIA_X");
        println($"   Y: $JULIA_Y");
    else
        println("Mandelbrot set");
    end;
    println("-------------------------");
    println($"X: $X");
    println($"Y: $Y");
    println($"Zoom: $ZOOM");
    println("Avg. iters: ", round(ITERATIONS / COMPLETED));
    print(text1, text2);
    printflush(message1);
end;

inline void printBookmarks(position, bookmark)
    println("BOOKMARKS");
    println("[o] [o] [o] [o] ...");
    println("      [o] Load");
    println("      [o] Save");
    println("-------------------------");
    print($"Selected bookmark #$bookmark:\n");
    if memory[position + 3] then
        println("Julia set of Mandelbrot");
        println("fractal at coordinates");
        print($"   X: $\n", memory[position + 4]);
        print($"   Y: $\n", memory[position + 5]);
    else
        println("Mandelbrot set");
    end;
    println("-------------------------");
    print($"X: $\n", memory[position]);
    print($"Y: $\n", memory[position + 1]);
    print($"Zoom: $\n", memory[position + 2]);
    printflush(message2);
end;

//   BUTTON HANDLING
///////////////////////////////////////////////////////////////////////

inline void handleMove(switch, x, y, z)
    if switch.enabled then
        CHANGE = true;
        if x != 0 then
            X = X + x * SHIFT / ZOOM;
        end;
        if y != 0 then
            Y = Y + y * SHIFT / ZOOM;
        end;
        if z != 1 then
            ZOOM = ZOOM * z;
        end;
        switch.enabled = false;
    end;
end;

inline void loadBookmark(position, bookmark)
    X = memory[position];
    Y = memory[position + 1];
    ZOOM = memory[position + 2];
    JULIA = memory[position + 3];
    JULIA_X = memory[position + 4];
    JULIA_Y = memory[position + 5];
    buttonJulia.enabled = JULIA;
    buttonLoad.enabled = false;
    text1 = "\nLoaded from #";
    text2 = bookmark;
end;

inline void saveBookmark(position, bookmark)
    memory[position] = X;
    memory[position + 1] = Y;
    memory[position + 2] = ZOOM;
    memory[position + 3] = JULIA;
    memory[position + 4] = JULIA_X;
    memory[position + 5] = JULIA_Y;
    buttonSave.enabled = false;
    text1 = "\nSaved to #";
    text2 = bookmark;
end;

inline void handleTopRowButtons(in out updateBookmarks)
    for var index in 1 .. bookmarkButtons do
        var switch = buttonBookmark[index];
        if index == bookmark then
            switch.enabled = true;
        elsif index == bookmark_clr then
            switch.enabled = false;
            bookmark_clr = -1;
        elsif switch.@enabled then
            bookmark_clr = bookmark;
            bookmark = index;
            position = BOOKMARKS + BOOKMARK_SIZE * (bookmark - 1);
            updateBookmarks = true;
        end;
    end;

    for var index in 1 .. paletteButtons do
        var switch = buttonPalette[index];
        if index == PALETTE then
            switch.enabled = true;
        elsif index == palette_clr then
            switch.enabled = false;
            palette_clr = -1;
        elsif switch.@enabled then
            palette_clr = PALETTE;
            PALETTE = index;
            print("Palette #", PALETTE);
            printflush(message3);
            CHANGE = true;
        end;
    end;
end;

//   INITIALIZATION
///////////////////////////////////////////////////////////////////////

inline void initialize()
    print("Initializing...");
    printflush(message1);

    createPalette();
    initializeBookmarks();

    do
        for var n in 0 ... @links do
            var switch = getlink(n);
            if switch.@type == @switch and switch.@y == bookmark_y then
                var button_x = switch.@x;
                if button_x >= palette_x then
                    buttonPalette[button_x - palette_x] = switch;
                else
                    buttonBookmark[button_x - bookmark_x] = switch;
                end;
            end;
        end;
    while !buttonBookmark[bookmarkButtons] or !buttonPalette[paletteButtons];

    STOP = 1;
    X = -0.8;
    Y = 0;
    ZOOM = 50;
    JULIA = false;
    JULIA_X = 0;
    JULIA_Y = 0;
    PALETTE = 1;

    print("Palette #", PALETTE);
    printflush(message3);
end;

inline void initializeProcessors()
    links = @links;
    for var i in 0 ... links do
        var proc = getlink(i);
        proc.write(display, ".display");
        proc.write(memory, ".memory");
    end;
end;

inline void createPalette()
    // Palette creation
    var r = 128, g = 192, b = 64;

    for var i in 0 ... MAX_DEPTH do
        memory[i] = packcolor(r / 256, g / 256, b / 256, 255);
        r = (r + 147) % 256;
        g = (g +  87) % 256;
        b = (b +  59) % 256;
    end;

    memory[MAX_DEPTH] = %[black];
end;

inline void initializeBookmarks()
    var i = BOOKMARKS;
    bookmark(memory, out i, -0.8,           0,           50);
    bookmark(memory, out i, -0.14375,     1.0,         1600);
    bookmark(memory, out i, -1.675,       0.0,        25600);
    bookmark(memory, out i, -1.413547,   -0.03234831,  2500);
    bookmark(memory, out i,  0.37359375,  0.09015625, 12800);
    bookmark(memory, out i, -1.408547,   -0.03734831, 10000);
    bookmark(memory, out i,  0.371875,    0.078125,    3200);
    bookmark(memory, out i, -1.382347,   -0.02114831,  5000);
    bookmark(memory, out i,  0.355,       0.66,        3200);
    bookmark(memory, out i,  0.018125,   -0.818125,    6400);

    bookmarkJulia(memory, out i,  0.0,        0.0,           50,  -0.8,       0.0);
    bookmarkJulia(memory, out i, -0.14375,    1.03125,     3200,  -0.14375,   1.0);
    bookmarkJulia(memory, out i, -1.403547,   -0.02734831, 5000,  -1.408547, -0.03734831);

    while i < BOOKMARK_END do
        bookmark(memory, out i, X, Y, ZOOM);
    end;
end;

inline void bookmark(memory, in out position, x, y, zoom)
    memory[position++] = x;
    memory[position++] = y;
    memory[position++] = zoom;
    memory[position++] = false;
    position += 2;
end;

inline void bookmarkJulia(memory, in out position, x, y, zoom, julia_x, julia_y)
    memory[position++] = x;
    memory[position++] = y;
    memory[position++] = zoom;
    memory[position++] = true;
    memory[position++] = julia_x;
    memory[position++] = julia_y;
end;
