#set syntax = strict;
#set target = 8H;

#set processor-id = "Computing";
#set program-name = "Mandelbrot Mania!";
#set program-version = "v3.0";

require "mandelbrot-common.mnd";

volatile noinit var display, memory;
allocate heap in memory[VARIABLES ... BOOKMARKS];

external $LINE;         // Current batch
external $ITERATIONS;   // The total number of iterations
external $COMPLETED;    // Number of completed pixels
external $START;        // Start signal
external $STOP;         // Stop signal
external $X;            // Coordinates and palette
external $Y;
external $ZOOM;
external $JULIA;
external $JULIA_X;
external $JULIA_Y;
external $PALETTE;
external $ALL_PASS_COLORING;
external $SHOW_LEADER;

// Current coordinates
// Copied from external variables when work computation for faster access
var ZOOM, OFFSET_X, OFFSET_Y;
var JULIA, JULIA_X, JULIA_Y;

// Coloring configuration
var PALETTE, SMOOTH, ALL_PASS_COLORING;
const ONE_TO_LOG = 1 / log(2);
const QUARTER_TO_LOG = 0.25 / log(2);

var start = 0, stop;
var lastColor;

// Processor graphics buffer usage
var localBuffer;

begin
    do while display == null or memory == null;

MainLoop:
    while true do
        // Waiting for a start signal
        do wait(0); while start == $START;

        // New computation starts here
        start = $START;
        stop = $STOP;

        // Reset everything
        lastColor = -1;
        localBuffer = 0;
        drawflush(null);
        drawflush(display);

        // Load position information
        ZOOM     = $ZOOM;
        OFFSET_X = -HALF_SIZE / ZOOM + $X;
        OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
        JULIA    = $JULIA;
        JULIA_X  = $JULIA_X;
        JULIA_Y  = $JULIA_Y;
        PALETTE  = $PALETTE;
        SMOOTH   = PALETTE > 1;
        ALL_PASS_COLORING = $ALL_PASS_COLORING;
        var leaderLimit = $SHOW_LEADER ? 1 - ALL_PASS_COLORING : 99;

        while true do
            // Obtain a batch (or batches)
            var batch, multiple;
            atomic
                if stop != $STOP then
                    continue MainLoop;      // Break is signalled
                end;
                batch = $LINE;
                multiple = batch >= TOTAL_BATCHES / 2 ? 1 : 4;
                $LINE = batch + multiple;
            end;

            if batch >= TOTAL_BATCHES then
                break;
            end;

            // Compute all pixels in the batch
            for var i in 0 ... BATCH_SIZE * multiple do
                var x, y, dx, dy;
                adam5(batch * BATCH_SIZE + i, out x, out y, out dx, out dy);

                // Display a "leader" - white pixel being just computed
                if multiple > leaderLimit and localBuffer == 0 then
                    col(%[white]);
                    rect(x, y, dx, dx);
                    lastColor = %[white];
                    localBuffer = 2;
                    tryFlush();
                end;

                var iterations = compute(x, y);
                drawPixel(x, y, dx, dy, iterations);

                atomic
                    if stop != $STOP then
                        continue MainLoop;  // Break is signalled
                    end;
                    $COMPLETED++;
                    $ITERATIONS += iterations;
                 end;
            end;
        end;

        flush();
    end;
end;

// Applies a 5-pass interlacing scheme, similar to the 7-pass Adam7 employed in the PNG format.
// The computation is run for each pixel separately, index is the number of the computation.
// Returns the coordinates of the pixel and size of the block to draw (at the beginning, larger blocks
// are drawn to fill the entire display with an approximate image of the Mandelbrot set, at around 8%,
// a complete image, consisting of 1/16 of the total number of pixels, is drawn.
//
// The cost of the computation is about the same as the cost of a single iteration
void adam5(index, out x, out y, out dx, out dy)
    // We're dividing the index by 16 to be able to apply fast switching optimization
    // Without that, the range would be 0 ... 30976, which is too large for any optimization.
    case index \ 16
        when 0 ... PASS_SIZE16 then
            x = 4 * (index % SIZE4);
            y = 4 * (index \ SIZE4);
            dx = dy = ALL_PASS_COLORING ? 4 : 2;

        when PASS_SIZE16 ... 2 * PASS_SIZE16 then
            index -= PASS_SIZE;
            x = 4 * (index % SIZE4) + 2;
            y = 4 * (index \ SIZE4);
            dx = ALL_PASS_COLORING ? 2 : 1;
            dy = ALL_PASS_COLORING ? 4 : 2;

        when 2 * PASS_SIZE16 ... 4 * PASS_SIZE16 then
            index -= 2 * PASS_SIZE;
            x = 2 * (index % SIZE2);
            y = 4 * (index \ SIZE2) + 2;
            dx = dy = ALL_PASS_COLORING ? 2 : 1;

        when 4 * PASS_SIZE16 ... 8 * PASS_SIZE16 then
            index -= 4 * PASS_SIZE;
            x = 2 * (index % SIZE2) + 1;
            y = 2 * (index \ SIZE2);
            dx = 1; dy = ALL_PASS_COLORING ? 2 : 1;

        else
            index -= 8 * PASS_SIZE;
            x = (index % SIZE1);
            y = 2 * (index \ SIZE1) + 1;
            dx = dy = 1;
    end;
end;

// Computes the pixel value in iterations
// When color smoothing is active, returns a decimal value
inline def compute(x, y)
    var zx = x / ZOOM + OFFSET_X;
    var zy = y / ZOOM + OFFSET_Y;
    var cx, cy;

    if JULIA then
        cx = JULIA_X;
        cy = JULIA_Y;
    else
        cx = zx;
        cy = zy;

        // Cardioid test
        var p = len(cx - 0.25, cy);
        if cx <= p - 2 * p * p + 0.25 then
            return MAX_DEPTH;
        end;

        // Bulb test
        if len(cx + 1, cy) <= 0.25 then
            return MAX_DEPTH;
        end;
    end;

    // Mandelbrot iteration loop, gets unrolled by the compiler
    var dist, i;
    Compute: do
        for i in 0 ... MAX_DEPTH do
            var x1 = zx;
            var y1 = zy;
            zx = x1 * x1 - y1 * y1 + cx;
            zy = 2 * x1 * y1 + cy;
            dist = len(zx, zy);
            if dist >= 64 then
                break Compute;
            end;
        end;

        return i;
    while false;

    // Correction only if we're smoothing and not at max iteration
    if SMOOTH then
        var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
        i += correction;
    end;

    return i;
end;

// Converts the iteration to color, draws the pixel and handles flushing
inline void drawPixel(x, y, dx, dy, iterations)
    var color;
    if iterations == MAX_DEPTH then
        color = %[black];
    elsif SMOOTH then
        var r, g, b;
        case PALETTE
            when 2 then
                r = 255/255 - 7 * abs(32 - iterations) / 255;
                g = 240/255 - 6 * abs(iterations - 32) / 255;
                b = 120/255 + 4 * abs(32 - iterations) / 255;
                color = packcolor(r, g, b, 1);

            when 3 then
                r = sin(iterations / MAX_DEPTH * 360);
                g = cos(iterations / MAX_DEPTH * 360);
                b = 100/255 + 4 * abs(iterations - 32) / 255;
                color = packcolor(r, g, b, 1);

            when 4 then
                r = 4 * iterations / 255;
                g = 1.5 * iterations / 255;
                color = packcolor(r, g, 0, 1);

            else
                r = 1 - 4 * iterations / 255;
                color = packcolor(r, r, 0, 1);
        end;
    else
        color = memory[iterations];
    end;

    if localBuffer >= 254 then
        // The local buffer is full
        // This waits until local buffer empties
        flush();
    end;

    if localBuffer > 0 and color === lastColor then
        // When the local buffer is nonzero, we can skip setting the color.
        // We know the color was set when the buffer was zero.
        rect(x, y, dx, dy);
        localBuffer++;
    else
        col(color);
        rect(x, y, dx, dy);
        lastColor = color;
        localBuffer += 2;
    end;

    tryFlush();
end;

// Flushes the local buffer if there's enough capacity
inline void tryFlush()
    // By disabling the display, we can emulate the display not being redrawn due to being off-screen
    // Atomic makes it wait between retries, so there isn't busy waiting in flush()
    atomic
        if display.@enabled and localBuffer < DISPLAY_BUFFER - display.@bufferSize then
            drawflush(display);
            localBuffer = 0;
        end;
    end;
end;

// Ensure the local buffer is completely flushed.
// Called when the local buffer gets full and when the computation is finished
inline void flush()
    // Break waiting when the stop signal is set
    while localBuffer > 0 and stop == $STOP do
        tryFlush();
    end;
end;
