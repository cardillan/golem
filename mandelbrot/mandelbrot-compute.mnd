#set syntax = strict;
#set target = 8H;

require blocks;
require "mandelbrot-common.mnd";

const DISPLAY_BUFFER = 1024;

var display, memory;
allocate heap in memory[VARIABLES ... BOOKMARKS];

external $LINE;         // Current line
external $COMPLETED;    // Number of completed pixels
external $START;        // Start signal
external $STOP;         // Stop signal
external $X;            // Coordinates and palette
external $Y;
external $ZOOM;
external $JULIA;
external $JULIA_X;
external $JULIA_Y;
external $PALETTE;

// Current coordinates
var ZOOM, OFFSET_X, OFFSET_Y;
var JULIA, JULIA_X, JULIA_Y;

// Palette configuration
var PALETTE, SMOOTH;
const ONE_TO_LOG = 1 / log(2);
const QUARTER_TO_LOG = 0.25 / log(2);

var start = 0, stop;
var lastColor;

// Processor graphics buffer usage
noinit var localBuffer;

begin
    findLinkedBlocks("Mandelbrot Generator", null,
        @large-logic-display,   "Display",  out display,    true,
        @memory-bank,           "Memory",   out memory,     true
    );

MainLoop:
    while true do
        // Waiting for a start signal
        do wait(0); while start == $START;

        // New computation starts here
        start = $START;
        stop = $STOP;
        lastColor = -1;

        localBuffer = 0;
        drawflush(null);

        // Load positional information
        ZOOM     = $ZOOM;
        OFFSET_X = -HALF_SIZE / ZOOM + $X;
        OFFSET_Y = -HALF_SIZE / ZOOM + $Y;
        JULIA    = $JULIA;
        JULIA_X  = $JULIA_X;
        JULIA_Y  = $JULIA_Y;
        PALETTE  = $PALETTE;
        SMOOTH   = PALETTE > 1;

        while true do
            var line;
            atomic
                if stop != $STOP then
                    continue MainLoop;      // Break is signalled
                end;
                line = $LINE++;
            end;
            if line >= DISPLAY_SIZE_LARGE then
                break;
            end;

            var strip = case line
                when 0 ... 22 then 8 * line;
                when 22 ... 44 then 8 * line - 8 * 22 + 4;
                when 44 ... 88 then 4 * line - 4 * 44 + 2;
                else 2 * line - 2 * 88 + 1;
            end;

            var x = (SKIP * strip) % DISPLAY_SIZE_LARGE;

            for var y in 0 ... DISPLAY_SIZE_LARGE do
                var iterations = compute(x, y);
                drawPixel(x, y, iterations);
                atomic $COMPLETED++; end;
                if stop != $STOP then
                    continue MainLoop;  // Break is signalled
                end;
            end;

            emptyLocalBuffer();
        end;
    end;
end;

inline def compute(x, y)
    var zx = x / ZOOM + OFFSET_X;
    var zy = y / ZOOM + OFFSET_Y;
    var cx, cy;

    if JULIA then
        cx = JULIA_X;
        cy = JULIA_Y;
    else
        cx = zx;
        cy = zy;

        // Cardioid test
        var p = len(cx - 0.25, cy);
        if cx <= p - 2 * p * p + 0.25 then
            return MAX_DEPTH;
        end;

        // Bulb test
        if len(cx + 1, cy) <= 0.25 then
            return MAX_DEPTH;
        end;
    end;

    var dist, i;
    for i in 0 ... MAX_DEPTH do
        var x1 = zx;
        var y1 = zy;
        zx = x1 * x1 - y1 * y1 + cx;
        zy = 2 * x1 * y1 + cy;
        dist = len(zx, zy);
        if dist >= 64 then
            break;
        end;
    end;

    if i < SMOOTH * MAX_DEPTH then
        // Correction only if we're smoothing and not at max iteration
        var correction = 4 - log(log(dist) * QUARTER_TO_LOG) * ONE_TO_LOG;
        i += correction;
    end;

    return i;
end;

inline void drawPixel(x, y, iterations)
    var color;
    if SMOOTH then
        if iterations == MAX_DEPTH then
            color = %[black];
        else
            var r, g, b;
            case PALETTE
                when 2 then
                    r = 255/255 - 7 * abs(32 - iterations) / 255;
                    g = 240/255 - 6 * abs(iterations - 32) / 255;
                    b = 120/255 + 4 * abs(32 - iterations) / 255;
                    color = packcolor(r, g, b, 1);

                when 3 then
                    r = sin(iterations / MAX_DEPTH * 360);
                    g = cos(iterations / MAX_DEPTH * 360);
                    b = 100/255 + 4 * abs(iterations - 32) / 255;
                    color = packcolor(r, g, b, 1);

                when 4 then
                    r = 4 * iterations / 255;
                    g = 96 + 1.5 * iterations / 255;
                    color = packcolor(r, g, 0, 1);

                else
                    r = 1 - 4 * iterations / 255;
                    color = packcolor(r, r, 0, 1);
            end;
        end;
    else
        color = memory[iterations];
    end;

    if localBuffer >= 254 then
        // The local buffer is full
        // This waits until local buffer empties
        emptyLocalBuffer();
    end;

    if localBuffer > 0 and color === lastColor then
        // When the local buffer is nonzero, we can skip setting the color. We know the color was set when
        // the buffer was zero
        rect(x, y, 1, 1);
        localBuffer++;
    else
        col(color);
        rect(x, y, 1, 1);
        lastColor = color;
        localBuffer += 2;
    end;

    flushLocalBuffer();
end;

inline void flushLocalBuffer()
    // By disabling the display, we can emulate the display not being redrawn due to being off-screen
    // Atomic makes it wait between retries, so there isn't busy waiting
    atomic
        if display.@enabled then
            if localBuffer < DISPLAY_BUFFER - display.@bufferSize then
                drawflush(display);
                localBuffer = 0;
            end;
        end;
    end;
end;

inline void emptyLocalBuffer()
    while localBuffer > 0 do
        flushLocalBuffer();
    end;
end;
