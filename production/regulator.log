   359 instructions before optimizations.
    18 instructions eliminated by Temp Variables Elimination (7 iterations).
     1 instructions eliminated by Case Expression Optimization.
    47 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (6 iterations).
    20 instructions eliminated by Condition Optimization (3 passes, 9 iterations).
    27 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
     1 instructions eliminated by Expression Optimization (2 passes, 4 iterations).
     2 instructions eliminated by Boolean Optimization (7 iterations).
       2 final jumps of a short-circuited expression optimized.
     3 instructions eliminated by If Expression Optimization (4 iterations).
    11 instructions eliminated by Data Flow Optimization (3 passes, 11 iterations).
     1 instructions added by Loop Rotation (4 iterations).
       3 loop conditions were partially rotated.
   131 instructions added by Case Switching (6 iterations).
     1 case expressions converted to switched jumps by Case Switching.
     7 instructions eliminated by Jump Straightening (7 iterations).
     3 instructions updated by Jump Threading.
    25 instructions eliminated by Print Merging.
   328 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 770):
  * Partial loop rotation at line 36:5                           size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  o Convert case at line 97:13 (segments: 15)                    size    +0, benefit     2013.9, efficiency   Infinity
  o Convert case at line 97:13 (segments: 6)                     size    +1, benefit     2118.1, efficiency   2118.056
  o Convert case at line 97:13 (segments: 4)                     size   +20, benefit     2152.8, efficiency    107.639
  o Convert case at line 97:13 (segments: 6)                     size   +21, benefit     2256.9, efficiency    107.474
  o Convert case at line 97:13 (segments: 2)                     size   +38, benefit     2326.4, efficiency     61.221
  o Convert case at line 97:13 (segments: 5)                     size   +39, benefit     2361.1, efficiency     60.541
  o Convert case at line 97:13 (segments: 4, padded low)         size   +67, benefit     2395.8, efficiency     35.759
  o Convert case at line 97:13 (segments: 6, padded low)         size   +68, benefit     2500.0, efficiency     36.765
  o Convert case at line 97:13 (segments: 3)                     size   +80, benefit     2812.5, efficiency     35.156
  o Convert case at line 97:13 (segments: 1)                     size   +84, benefit     2847.2, efficiency     33.896
  o Convert case at line 97:13 (segments: 5, padded low)         size   +86, benefit     2881.9, efficiency     33.511
  o Convert case at line 97:13 (segments: 3, padded low)         size  +127, benefit     3333.3, efficiency     26.247
  o Convert case at line 97:13 (segments: 1, padded low)         size  +131, benefit     3472.2, efficiency     26.506

Pass 1: speed optimization selection (cost limit 769):
  o Convert case at line 97:13 (segments: 15)                    size    +0, benefit     2013.9, efficiency   Infinity
  o Convert case at line 97:13 (segments: 6)                     size    +1, benefit     2118.1, efficiency   2118.056
  o Convert case at line 97:13 (segments: 4)                     size   +20, benefit     2152.8, efficiency    107.639
  o Convert case at line 97:13 (segments: 6)                     size   +21, benefit     2256.9, efficiency    107.474
  o Convert case at line 97:13 (segments: 2)                     size   +38, benefit     2326.4, efficiency     61.221
  o Convert case at line 97:13 (segments: 5)                     size   +39, benefit     2361.1, efficiency     60.541
  o Convert case at line 97:13 (segments: 4, padded low)         size   +67, benefit     2395.8, efficiency     35.759
  o Convert case at line 97:13 (segments: 6, padded low)         size   +68, benefit     2500.0, efficiency     36.765
  o Convert case at line 97:13 (segments: 3)                     size   +80, benefit     2812.5, efficiency     35.156
  o Convert case at line 97:13 (segments: 1)                     size   +84, benefit     2847.2, efficiency     33.896
  o Convert case at line 97:13 (segments: 5, padded low)         size   +86, benefit     2881.9, efficiency     33.511
  o Convert case at line 97:13 (segments: 3, padded low)         size  +127, benefit     3333.3, efficiency     26.247
  * Convert case at line 97:13 (segments: 1, padded low)         size  +131, benefit     3472.2, efficiency     26.506 (+131 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    15 print :initialize:block
    16 print "\n"
    17 sensor *tmp3 :initialize:block @type
-    * set *tmp4 *tmp3
-    * jump *label9 equal *tmp4 @message
+   18 jump *label9 equal *tmp3 @message
    19 jump *label8 always
    20 label *label9
    21 set .message :initialize:block
    22 set *tmp2 .message
    23 jump *label7 always
    24 label *label8
-    * jump *label11 equal *tmp4 @switch
+   25 jump *label11 equal *tmp3 @switch
    26 jump *label10 always
    27 label *label11
    28 set .switch :initialize:block
    29 set *tmp2 .switch
    30 jump *label7 always
    31 label *label10
-    * jump *label13 equal *tmp4 @sorter
-    * jump *label13 equal *tmp4 @inverted-sorter
-    * jump *label13 equal *tmp4 @unloader
+   32 jump *label13 equal *tmp3 @sorter
+   33 jump *label13 equal *tmp3 @inverted-sorter
+   34 jump *label13 equal *tmp3 @unloader
    35 jump *label12 always
    36 label *label13
    37 set .sorter :initialize:block
    38 set *tmp2 .sorter
    39 jump *label7 always
    40 label *label12
-    * jump *label15 equal *tmp4 @vault
-    * jump *label15 equal *tmp4 @container
-    * jump *label15 equal *tmp4 @core-shard
-    * jump *label15 equal *tmp4 @core-foundation
-    * jump *label15 equal *tmp4 @core-nucleus
+   41 jump *label15 equal *tmp3 @vault
+   42 jump *label15 equal *tmp3 @container
+   43 jump *label15 equal *tmp3 @core-shard
+   44 jump *label15 equal *tmp3 @core-foundation
+   45 jump *label15 equal *tmp3 @core-nucleus
    46 jump *label14 always
    47 label *label15
    48 set .container :initialize:block
 
    53 set *tmp2 .first
    54 jump *label7 always
    55 label *label14
-    * jump *label17 equal *tmp4 @liquid-tank
-    * jump *label17 equal *tmp4 @liquid-container
-    * jump *label17 equal *tmp4 @liquid-router
+   56 jump *label17 equal *tmp3 @liquid-tank
+   57 jump *label17 equal *tmp3 @liquid-container
+   58 jump *label17 equal *tmp3 @liquid-router
    59 jump *label16 always
    60 label *label17
    61 set .container :initialize:block
 
    66 set *tmp2 .first
    67 jump *label7 always
    68 label *label16
-    * jump *label19 equal *tmp4 @battery
-    * jump *label19 equal *tmp4 @battery-large
+   69 jump *label19 equal *tmp3 @battery
+   70 jump *label19 equal *tmp3 @battery-large
    71 jump *label18 always
    72 label *label19
    73 set .container :initialize:block
 
    78 set *tmp2 .first
    79 jump *label7 always
    80 label *label18
-    * jump *label21 equal *tmp4 @power-node
-    * jump *label21 equal *tmp4 @power-node-large
-    * jump *label21 equal *tmp4 @surge-tower
+   81 jump *label21 equal *tmp3 @power-node
+   82 jump *label21 equal *tmp3 @power-node-large
+   83 jump *label21 equal *tmp3 @surge-tower
    84 jump *label20 always
    85 label *label21
    86 set .container :initialize:block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-45 instructions):
 
    19 jump *label8 always
    20 label *label9
    21 set .message :initialize:block
-    * set *tmp2 .message
    22 jump *label7 always
    23 label *label8
    24 jump *label11 equal *tmp3 @switch
    25 jump *label10 always
    26 label *label11
    27 set .switch :initialize:block
-    * set *tmp2 .switch
    28 jump *label7 always
    29 label *label10
    30 jump *label13 equal *tmp3 @sorter
 
    33 jump *label12 always
    34 label *label13
    35 set .sorter :initialize:block
-    * set *tmp2 .sorter
    36 jump *label7 always
    37 label *label12
    38 jump *label15 equal *tmp3 @vault
 
    47 set .maximum @itemCapacity
    48 op add *tmp5 :initialize:n 1
    49 set .first *tmp5
-    * set *tmp2 .first
    50 jump *label7 always
    51 label *label14
    52 jump *label17 equal *tmp3 @liquid-tank
 
    59 set .maximum @liquidCapacity
    60 op add *tmp6 :initialize:n 1
    61 set .first *tmp6
-    * set *tmp2 .first
    62 jump *label7 always
    63 label *label16
    64 jump *label19 equal *tmp3 @battery
 
    70 set .maximum @powerCapacity
    71 op add *tmp7 :initialize:n 1
    72 set .first *tmp7
-    * set *tmp2 .first
    73 jump *label7 always
    74 label *label18
    75 jump *label21 equal *tmp3 @power-node
 
    82 set .maximum @powerNetCapacity
    83 op add *tmp8 :initialize:n 1
    84 set .first *tmp8
-    * set *tmp2 .first
    85 jump *label7 always
    86 label *label20
-    * set *tmp2 null
    87 label *label7
    88 label *label5
    89 op sub :initialize:n :initialize:n 1
 
   109 print "No message."
   110 print "\n"
   111 set :initialize:repeat true
-    * set *tmp10 :initialize:repeat
   112 jump *label23 always
   113 label *label22
-    * set *tmp10 null
   114 label *label23
   115 op equal *tmp11 .switch null
   116 jump *label24 equal *tmp11 false
   117 print "No switch."
   118 print "\n"
   119 set :initialize:repeat true
-    * set *tmp12 :initialize:repeat
   120 jump *label25 always
   121 label *label24
-    * set *tmp12 null
   122 label *label25
   123 op equal *tmp13 .container null
   124 jump *label26 equal *tmp13 false
   125 print "No container."
   126 print "\n"
   127 set :initialize:repeat true
-    * set *tmp14 :initialize:repeat
   128 jump *label27 always
   129 label *label26
-    * set *tmp14 null
   130 label *label27
   131 printflush .message
   132 label *label2
 
   157 print :validate:text
   158 printflush .message
   159 stop
-    * set *tmp21 null
   160 jump *label35 always
   161 label *label34
-    * set *tmp21 null
   162 label *label35
   163 label *label33
   164 op greaterThanEq *tmp22 PCT_HIGH 0
 
   185 print :validate.1:text
   186 printflush .message
   187 stop
-    * set *tmp28 null
   188 jump *label43 always
   189 label *label42
-    * set *tmp28 null
   190 label *label43
   191 label *label41
   192 op lessThan *tmp29 PCT_LOW PCT_HIGH
 
   197 print :validate.2:text
   198 printflush .message
   199 stop
-    * set *tmp31 null
   200 jump *label46 always
   201 label *label45
-    * set *tmp31 null
   202 label *label46
   203 label *label44
   204 sensor *tmp32 .sorter @type
 
   208 op notEqual *tmp34 .state :setState:newState
   209 jump *label48 equal *tmp34 false
   210 set .state :setState:newState
-    * set *tmp36 .cycles
   211 op add .cycles .cycles 1
   212 op xor *tmp37 .inverted .state
   213 set .active *tmp37
 
   218 set *tmp38 "\nCurrently inactive:[salmon]"
   219 label *label51
   220 set .activeText *tmp38
-    * set *tmp35 .activeText
   221 jump *label49 always
   222 label *label48
-    * set *tmp35 null
   223 label *label49
   224 label *label47
   225 label *label0
 
   233 sensor *tmp43 .container @dead
   234 jump *label55 equal *tmp43 false
   235 end
-    * set *tmp44 null
   236 jump *label56 always
   237 label *label55
-    * set *tmp44 null
   238 label *label56
   239 sensor *tmp45 .message @dead
   240 jump *label57 equal *tmp45 false
   241 end
-    * set *tmp46 null
   242 jump *label58 always
   243 label *label57
-    * set *tmp46 null
   244 label *label58
   245 sensor *tmp47 .switch @dead
   246 jump *label59 equal *tmp47 false
   247 end
-    * set *tmp48 null
   248 jump *label60 always
   249 label *label59
-    * set *tmp48 null
   250 label *label60
   251 jump *label61 equal .sorter false
   252 label *label64
 
   255 jump *label63 always
   256 label *label63
   257 end
-    * set *tmp50 null
   258 jump *label62 always
   259 label *label61
-    * set *tmp50 null
   260 label *label62
   261 op notEqual *tmp51 .links @links
   262 jump *label65 equal *tmp51 false
   263 end
-    * set *tmp52 null
   264 jump *label66 always
   265 label *label65
-    * set *tmp52 null
   266 label *label66
   267 sensor *tmp53 .sorter @config
   268 set :item *tmp53
 
   275 print .container
   276 sensor *tmp58 .container .measure
   277 set :amount *tmp58
-    * set *tmp57 :amount
   278 jump *label68 always
   279 label *label67
   280 print "Measuring [gold]"
 
   284 print .container
   285 sensor *tmp59 .container :item
   286 set :amount *tmp59
-    * set *tmp57 :amount
   287 label *label68
   288 op mul *tmp60 100 :amount
   289 sensor *tmp61 .container .maximum
 
   295 op notEqual *tmp65 .state :setState.1:newState
   296 jump *label72 equal *tmp65 false
   297 set .state :setState.1:newState
-    * set *tmp67 .cycles
   298 op add .cycles .cycles 1
   299 op xor *tmp68 .inverted .state
   300 set .active *tmp68
 
   305 set *tmp69 "\nCurrently inactive:[salmon]"
   306 label *label75
   307 set .activeText *tmp69
-    * set *tmp66 .activeText
   308 jump *label73 always
   309 label *label72
-    * set *tmp66 null
   310 label *label73
   311 label *label71
-    * set *tmp64 null
   312 jump *label70 always
   313 label *label69
   314 op greaterThanEq *tmp70 :pct PCT_HIGH
 
   317 op notEqual *tmp72 .state :setState.2:newState
   318 jump *label79 equal *tmp72 false
   319 set .state :setState.2:newState
-    * set *tmp74 .cycles
   320 op add .cycles .cycles 1
   321 op xor *tmp75 .inverted .state
   322 set .active *tmp75
 
   327 set *tmp76 "\nCurrently inactive:[salmon]"
   328 label *label82
   329 set .activeText *tmp76
-    * set *tmp73 .activeText
   330 jump *label80 always
   331 label *label79
-    * set *tmp73 null
   332 label *label80
   333 label *label78
   334 set *tmp71 null
 
   336 label *label76
   337 set *tmp71 null
   338 label *label77
-    * set *tmp64 *tmp71
   339 label *label70
   340 print "\n"
   341 print "Level: [gold]"
 
   353 print PCT_LOW
   354 print "%"
   355 print "[]"
-    * set *tmp77 null
   356 jump *label84 always
   357 label *label83
   358 print "\n"
 
   365 print PCT_HIGH
   366 print "%"
   367 print "[]"
-    * set *tmp77 null
   368 label *label84
   369 print .activeText
   370 set *tmp78 .links

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
   331 label *label79
   332 label *label80
   333 label *label78
-    * set *tmp71 null
   334 jump *label77 always
   335 label *label76
-    * set *tmp71 null
   336 label *label77
   337 label *label70
   338 print "\n"

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-18 instructions):
 
     4 set :initialize:repeat false
     5 print "Configuring regulator..."
     6 print "\n"
-    * set *tmp0 @links
-    * set .links *tmp0
+    7 set .links @links
     8 op sub :initialize:n .links 1
     9 label *label4
    10 jump *label6 lessThan :initialize:n 0
-    * getlink *tmp1 :initialize:n
-    * set :initialize:block *tmp1
+   11 getlink :initialize:block :initialize:n
    12 print "Found: "
    13 print :initialize:block
    14 print "\n"
 
    43 set .container :initialize:block
    44 set .measure @totalItems
    45 set .maximum @itemCapacity
-    * op add *tmp5 :initialize:n 1
-    * set .first *tmp5
+   46 op add .first :initialize:n 1
    47 jump *label7 always
    48 label *label14
    49 jump *label17 equal *tmp3 @liquid-tank
 
    54 set .container :initialize:block
    55 set .measure @totalLiquids
    56 set .maximum @liquidCapacity
-    * op add *tmp6 :initialize:n 1
-    * set .first *tmp6
+   57 op add .first :initialize:n 1
    58 jump *label7 always
    59 label *label16
    60 jump *label19 equal *tmp3 @battery
 
    64 set .container :initialize:block
    65 set .measure @totalPower
    66 set .maximum @powerCapacity
-    * op add *tmp7 :initialize:n 1
-    * set .first *tmp7
+   67 op add .first :initialize:n 1
    68 jump *label7 always
    69 label *label18
    70 jump *label21 equal *tmp3 @power-node
 
    75 set .container :initialize:block
    76 set .measure @powerNetStored
    77 set .maximum @powerNetCapacity
-    * op add *tmp8 :initialize:n 1
-    * set .first *tmp8
+   78 op add .first :initialize:n 1
    79 jump *label7 always
    80 label *label20
    81 label *label7
 
   183 label *label42
   184 label *label43
   185 label *label41
-    * op lessThan *tmp29 PCT_LOW PCT_HIGH
-    * set :validate.2:condition *tmp29
+  186 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
   187 set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
   188 op equal *tmp30 :validate.2:condition false
   189 jump *label45 equal *tmp30 false
 
   195 label *label46
   196 label *label44
   197 sensor *tmp32 .sorter @type
-    * op equal *tmp33 *tmp32 @inverted-sorter
-    * set .inverted *tmp33
+  198 op equal .inverted *tmp32 @inverted-sorter
   199 set :setState:newState true
   200 op notEqual *tmp34 .state :setState:newState
   201 jump *label48 equal *tmp34 false
   202 set .state :setState:newState
   203 op add .cycles .cycles 1
-    * op xor *tmp37 .inverted .state
-    * set .active *tmp37
+  204 op xor .active .inverted .state
   205 jump *label50 equal .active false
   206 set *tmp38 "\nCurrently active:[green]"
   207 jump *label51 always
 
   214 label *label49
   215 label *label47
   216 label *label0
-    * set *tmp39 .switch
-    * control enabled *tmp39 0
+  217 control enabled .switch 0
   218 label *label52
   219 sensor *tmp41 .switch @enabled
   220 op equal *tmp42 *tmp41 0
 
   254 jump *label66 always
   255 label *label65
   256 label *label66
-    * sensor *tmp53 .sorter @config
-    * set :item *tmp53
+  257 sensor :item .sorter @config
   258 op equal *tmp54 :item null
   259 op notEqual *tmp55 .measure @totalItems
   260 op lor *tmp56 *tmp54 *tmp55
 
   262 set :item .measure
   263 print "Measuring [gold]total[] in "
   264 print .container
-    * sensor *tmp58 .container .measure
-    * set :amount *tmp58
+  265 sensor :amount .container .measure
   266 jump *label68 always
   267 label *label67
   268 print "Measuring [gold]"
 
   270 print "["
   271 print "] in "
   272 print .container
-    * sensor *tmp59 .container :item
-    * set :amount *tmp59
+  273 sensor :amount .container :item
   274 label *label68
   275 op mul *tmp60 100 :amount
   276 sensor *tmp61 .container .maximum
-    * op idiv *tmp62 *tmp60 *tmp61
-    * set :pct *tmp62
+  277 op idiv :pct *tmp60 *tmp61
   278 op lessThanEq *tmp63 :pct PCT_LOW
   279 jump *label69 equal *tmp63 false
   280 set :setState.1:newState true
 
   282 jump *label72 equal *tmp65 false
   283 set .state :setState.1:newState
   284 op add .cycles .cycles 1
-    * op xor *tmp68 .inverted .state
-    * set .active *tmp68
+  285 op xor .active .inverted .state
   286 jump *label74 equal .active false
   287 set *tmp69 "\nCurrently active:[green]"
   288 jump *label75 always
 
   303 jump *label79 equal *tmp72 false
   304 set .state :setState.2:newState
   305 op add .cycles .cycles 1
-    * op xor *tmp75 .inverted .state
-    * set .active *tmp75
+  306 op xor .active .inverted .state
   307 jump *label81 equal .active false
   308 set *tmp76 "\nCurrently active:[green]"
   309 jump *label82 always
 
   353 set :n .first
   354 label *label85
   355 jump *label87 greaterThanEq :n *tmp78
-    * getlink *tmp79 :n
-    * set :block *tmp79
-    * set *tmp80 :block
-    * control enabled *tmp80 .active
+  356 getlink :block :n
+  357 control enabled :block .active
   358 print "\n    "
   359 print :block
   360 label *label86

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    13 print :initialize:block
    14 print "\n"
    15 sensor *tmp3 :initialize:block @type
-    * jump *label9 equal *tmp3 @message
-    * jump *label8 always
+   16 jump *label8 notEqual *tmp3 @message
    17 label *label9
    18 set .message :initialize:block
    19 jump *label7 always
    20 label *label8
-    * jump *label11 equal *tmp3 @switch
-    * jump *label10 always
+   21 jump *label10 notEqual *tmp3 @switch
    22 label *label11
    23 set .switch :initialize:block
    24 jump *label7 always
    25 label *label10
    26 jump *label13 equal *tmp3 @sorter
    27 jump *label13 equal *tmp3 @inverted-sorter
-    * jump *label13 equal *tmp3 @unloader
-    * jump *label12 always
+   28 jump *label12 notEqual *tmp3 @unloader
    29 label *label13
    30 set .sorter :initialize:block
    31 jump *label7 always
 
    34 jump *label15 equal *tmp3 @container
    35 jump *label15 equal *tmp3 @core-shard
    36 jump *label15 equal *tmp3 @core-foundation
-    * jump *label15 equal *tmp3 @core-nucleus
-    * jump *label14 always
+   37 jump *label14 notEqual *tmp3 @core-nucleus
    38 label *label15
    39 set .container :initialize:block
    40 set .measure @totalItems
 
    44 label *label14
    45 jump *label17 equal *tmp3 @liquid-tank
    46 jump *label17 equal *tmp3 @liquid-container
-    * jump *label17 equal *tmp3 @liquid-router
-    * jump *label16 always
+   47 jump *label16 notEqual *tmp3 @liquid-router
    48 label *label17
    49 set .container :initialize:block
    50 set .measure @totalLiquids
 
    53 jump *label7 always
    54 label *label16
    55 jump *label19 equal *tmp3 @battery
-    * jump *label19 equal *tmp3 @battery-large
-    * jump *label18 always
+   56 jump *label18 notEqual *tmp3 @battery-large
    57 label *label19
    58 set .container :initialize:block
    59 set .measure @totalPower
 
    63 label *label18
    64 jump *label21 equal *tmp3 @power-node
    65 jump *label21 equal *tmp3 @power-node-large
-    * jump *label21 equal *tmp3 @surge-tower
-    * jump *label20 always
+   66 jump *label20 notEqual *tmp3 @surge-tower
    67 label *label21
    68 set .container :initialize:block
    69 set .measure @powerNetStored

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-18 instructions):
 
    91 print "First index: "
    92 print .first
    93 print "\n"
-    * op equal *tmp9 .message null
-    * jump *label22 equal *tmp9 false
+   94 jump *label22 notEqual .message null
    95 print "No message."
    96 print "\n"
    97 set :initialize:repeat true
    98 jump *label23 always
    99 label *label22
   100 label *label23
-    * op equal *tmp11 .switch null
-    * jump *label24 equal *tmp11 false
+  101 jump *label24 notEqual .switch null
   102 print "No switch."
   103 print "\n"
   104 set :initialize:repeat true
   105 jump *label25 always
   106 label *label24
   107 label *label25
-    * op equal *tmp13 .container null
-    * jump *label26 equal *tmp13 false
+  108 jump *label26 notEqual .container null
   109 print "No container."
   110 print "\n"
   111 set :initialize:repeat true
 
   117 jump *label1 notEqual :initialize:repeat false
   118 label *label3
   119 printflush null
-    * op greaterThanEq *tmp15 PCT_LOW 0
-    * jump *label28 equal *tmp15 false
+  120 jump *label28 lessThan PCT_LOW 0
   121 label *label32
-    * op lessThanEq *tmp16 PCT_LOW 100
-    * jump *label28 equal *tmp16 false
+  122 jump *label28 greaterThan PCT_LOW 100
   123 jump *label31 always
   124 label *label31
   125 op floor *tmp17 PCT_LOW
 
   134 label *label29
   135 set :validate:condition *tmp19
   136 set :validate:text "PCT_LOW must be an integer between 0 to 100."
-    * op equal *tmp20 :validate:condition false
-    * jump *label34 equal *tmp20 false
+  137 jump *label34 notEqual :validate:condition false
   138 print :validate:text
   139 printflush .message
   140 stop
 
   142 label *label34
   143 label *label35
   144 label *label33
-    * op greaterThanEq *tmp22 PCT_HIGH 0
-    * jump *label36 equal *tmp22 false
+  145 jump *label36 lessThan PCT_HIGH 0
   146 label *label40
-    * op lessThanEq *tmp23 PCT_HIGH 100
-    * jump *label36 equal *tmp23 false
+  147 jump *label36 greaterThan PCT_HIGH 100
   148 jump *label39 always
   149 label *label39
   150 op floor *tmp24 PCT_HIGH
 
   159 label *label37
   160 set :validate.1:condition *tmp26
   161 set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
-    * op equal *tmp27 :validate.1:condition false
-    * jump *label42 equal *tmp27 false
+  162 jump *label42 notEqual :validate.1:condition false
   163 print :validate.1:text
   164 printflush .message
   165 stop
 
   167 label *label42
   168 label *label43
   169 label *label41
-    * op lessThan :validate.2:condition PCT_LOW PCT_HIGH
   170 set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
-    * op equal *tmp30 :validate.2:condition false
-    * jump *label45 equal *tmp30 false
+  171 jump *label45 lessThan PCT_LOW PCT_HIGH
   172 print :validate.2:text
   173 printflush .message
   174 stop
 
   179 sensor *tmp32 .sorter @type
   180 op equal .inverted *tmp32 @inverted-sorter
   181 set :setState:newState true
-    * op notEqual *tmp34 .state :setState:newState
-    * jump *label48 equal *tmp34 false
+  182 jump *label48 equal .state :setState:newState
   183 set .state :setState:newState
   184 op add .cycles .cycles 1
   185 op xor .active .inverted .state
 
   198 control enabled .switch 0
   199 label *label52
   200 sensor *tmp41 .switch @enabled
-    * op equal *tmp42 *tmp41 0
-    * jump *label54 equal *tmp42 false
+  201 jump *label54 notEqual *tmp41 0
   202 set :start @time
   203 sensor *tmp43 .container @dead
   204 jump *label55 equal *tmp43 false
 
   228 jump *label62 always
   229 label *label61
   230 label *label62
-    * op notEqual *tmp51 .links @links
-    * jump *label65 equal *tmp51 false
+  231 jump *label65 equal .links @links
   232 end
   233 jump *label66 always
   234 label *label65
 
   254 op mul *tmp60 100 :amount
   255 sensor *tmp61 .container .maximum
   256 op idiv :pct *tmp60 *tmp61
-    * op lessThanEq *tmp63 :pct PCT_LOW
-    * jump *label69 equal *tmp63 false
+  257 jump *label69 greaterThan :pct PCT_LOW
   258 set :setState.1:newState true
-    * op notEqual *tmp65 .state :setState.1:newState
-    * jump *label72 equal *tmp65 false
+  259 jump *label72 equal .state :setState.1:newState
   260 set .state :setState.1:newState
   261 op add .cycles .cycles 1
   262 op xor .active .inverted .state
 
   273 label *label71
   274 jump *label70 always
   275 label *label69
-    * op greaterThanEq *tmp70 :pct PCT_HIGH
-    * jump *label76 equal *tmp70 false
+  276 jump *label76 lessThan :pct PCT_HIGH
   277 set :setState.2:newState false
-    * op notEqual *tmp72 .state :setState.2:newState
-    * jump *label79 equal *tmp72 false
+  278 jump *label79 equal .state :setState.2:newState
   279 set .state :setState.2:newState
   280 op add .cycles .cycles 1
   281 op xor .active .inverted .state

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-21 instructions):
 
    69 set .measure @powerNetStored
    70 set .maximum @powerNetCapacity
    71 op add .first :initialize:n 1
-    * jump *label7 always
    72 label *label20
    73 label *label7
    74 label *label5
 
    94 print "No message."
    95 print "\n"
    96 set :initialize:repeat true
-    * jump *label23 always
    97 label *label22
    98 label *label23
    99 jump *label24 notEqual .switch null
   100 print "No switch."
   101 print "\n"
   102 set :initialize:repeat true
-    * jump *label25 always
   103 label *label24
   104 label *label25
   105 jump *label26 notEqual .container null
   106 print "No container."
   107 print "\n"
   108 set :initialize:repeat true
-    * jump *label27 always
   109 label *label26
   110 label *label27
   111 printflush .message
 
   116 jump *label28 lessThan PCT_LOW 0
   117 label *label32
   118 jump *label28 greaterThan PCT_LOW 100
-    * jump *label31 always
   119 label *label31
   120 op floor *tmp17 PCT_LOW
   121 op strictEqual *tmp18 PCT_LOW *tmp17
   122 jump *label28 equal *tmp18 false
-    * jump *label30 always
   123 label *label30
   124 set *tmp19 true
   125 jump *label29 always
 
   132 print :validate:text
   133 printflush .message
   134 stop
-    * jump *label35 always
   135 label *label34
   136 label *label35
   137 label *label33
   138 jump *label36 lessThan PCT_HIGH 0
   139 label *label40
   140 jump *label36 greaterThan PCT_HIGH 100
-    * jump *label39 always
   141 label *label39
   142 op floor *tmp24 PCT_HIGH
   143 op strictEqual *tmp25 PCT_HIGH *tmp24
   144 jump *label36 equal *tmp25 false
-    * jump *label38 always
   145 label *label38
   146 set *tmp26 true
   147 jump *label37 always
 
   154 print :validate.1:text
   155 printflush .message
   156 stop
-    * jump *label43 always
   157 label *label42
   158 label *label43
   159 label *label41
 
   162 print :validate.2:text
   163 printflush .message
   164 stop
-    * jump *label46 always
   165 label *label45
   166 label *label46
   167 label *label44
 
   179 set *tmp38 "\nCurrently inactive:[salmon]"
   180 label *label51
   181 set .activeText *tmp38
-    * jump *label49 always
   182 label *label48
   183 label *label49
   184 label *label47
 
   191 sensor *tmp43 .container @dead
   192 jump *label55 equal *tmp43 false
   193 end
-    * jump *label56 always
   194 label *label55
   195 label *label56
   196 sensor *tmp45 .message @dead
   197 jump *label57 equal *tmp45 false
   198 end
-    * jump *label58 always
   199 label *label57
   200 label *label58
   201 sensor *tmp47 .switch @dead
   202 jump *label59 equal *tmp47 false
   203 end
-    * jump *label60 always
   204 label *label59
   205 label *label60
   206 jump *label61 equal .sorter false
   207 label *label64
   208 sensor *tmp49 .sorter @dead
   209 jump *label61 equal *tmp49 false
-    * jump *label63 always
   210 label *label63
   211 end
-    * jump *label62 always
   212 label *label61
   213 label *label62
   214 jump *label65 equal .links @links
   215 end
-    * jump *label66 always
   216 label *label65
   217 label *label66
   218 sensor :item .sorter @config
 
   249 set *tmp69 "\nCurrently inactive:[salmon]"
   250 label *label75
   251 set .activeText *tmp69
-    * jump *label73 always
   252 label *label72
   253 label *label73
   254 label *label71
 
   267 set *tmp76 "\nCurrently inactive:[salmon]"
   268 label *label82
   269 set .activeText *tmp76
-    * jump *label80 always
   270 label *label79
   271 label *label80
   272 label *label78
-    * jump *label77 always
   273 label *label76
   274 label *label77
   275 label *label70

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   218 sensor :item .sorter @config
   219 op equal *tmp54 :item null
   220 op notEqual *tmp55 .measure @totalItems
-    * op lor *tmp56 *tmp54 *tmp55
+  221 op or *tmp56 *tmp54 *tmp55
   222 jump *label67 equal *tmp56 false
   223 set :item .measure
   224 print "Measuring [gold]total[] in "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
   128 label *label29
   129 set :validate:condition *tmp19
   130 set :validate:text "PCT_LOW must be an integer between 0 to 100."
-    * jump *label34 notEqual :validate:condition false
-    * print :validate:text
+  131 jump *label34 notEqual *tmp19 false
+  132 print "PCT_LOW must be an integer between 0 to 100."
   133 printflush .message
   134 stop
   135 label *label34
 
   150 label *label37
   151 set :validate.1:condition *tmp26
   152 set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
-    * jump *label42 notEqual :validate.1:condition false
-    * print :validate.1:text
+  153 jump *label42 notEqual *tmp26 false
+  154 print "PCT_HIGH must be an integer between 0 to 100."
   155 printflush .message
   156 stop
   157 label *label42
 
   159 label *label41
   160 set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
   161 jump *label45 lessThan PCT_LOW PCT_HIGH
-    * print :validate.2:text
+  162 print "PCT_LOW must be less than PCT_HIGH."
   163 printflush .message
   164 stop
   165 label *label45
 
   168 sensor *tmp32 .sorter @type
   169 op equal .inverted *tmp32 @inverted-sorter
   170 set :setState:newState true
-    * jump *label48 equal .state :setState:newState
-    * set .state :setState:newState
+  171 jump *label48 equal false true
+  172 set .state true
   173 op add .cycles .cycles 1
-    * op xor .active .inverted .state
+  174 op xor .active .inverted :setState:newState
   175 jump *label50 equal .active false
   176 set *tmp38 "\nCurrently active:[green]"
   177 jump *label51 always
 
   220 op notEqual *tmp55 .measure @totalItems
   221 op or *tmp56 *tmp54 *tmp55
   222 jump *label67 equal *tmp56 false
-    * set :item .measure
   223 print "Measuring [gold]total[] in "
   224 print .container
   225 sensor :amount .container .measure
 
   237 op idiv :pct *tmp60 *tmp61
   238 jump *label69 greaterThan :pct PCT_LOW
   239 set :setState.1:newState true
-    * jump *label72 equal .state :setState.1:newState
-    * set .state :setState.1:newState
+  240 jump *label72 equal .state true
+  241 set .state true
   242 op add .cycles .cycles 1
-    * op xor .active .inverted .state
+  243 op xor .active .inverted :setState.1:newState
   244 jump *label74 equal .active false
   245 set *tmp69 "\nCurrently active:[green]"
   246 jump *label75 always
 
   255 label *label69
   256 jump *label76 lessThan :pct PCT_HIGH
   257 set :setState.2:newState false
-    * jump *label79 equal .state :setState.2:newState
-    * set .state :setState.2:newState
+  258 jump *label79 equal .state false
+  259 set .state false
   260 op add .cycles .cycles 1
-    * op xor .active .inverted .state
+  261 op xor .active .inverted :setState.2:newState
   262 jump *label81 equal .active false
   263 set *tmp76 "\nCurrently active:[green]"
   264 jump *label82 always
 
   305 set *tmp78 .links
   306 set :n .first
   307 label *label85
-    * jump *label87 greaterThanEq :n *tmp78
+  308 jump *label87 greaterThanEq :n .links
   309 getlink :block :n
   310 control enabled :block .active
   311 print "\n    "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
     0 set PCT_LOW 60
     1 set PCT_HIGH 80
-    * set .state false
     2 label *label1
     3 set :initialize:repeat false
     4 print "Configuring regulator..."
 
   125 label *label28
   126 set *tmp19 false
   127 label *label29
-    * set :validate:condition *tmp19
-    * set :validate:text "PCT_LOW must be an integer between 0 to 100."
   128 jump *label34 notEqual *tmp19 false
   129 print "PCT_LOW must be an integer between 0 to 100."
   130 printflush .message
 
   145 label *label36
   146 set *tmp26 false
   147 label *label37
-    * set :validate.1:condition *tmp26
-    * set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
   148 jump *label42 notEqual *tmp26 false
   149 print "PCT_HIGH must be an integer between 0 to 100."
   150 printflush .message
 
   152 label *label42
   153 label *label43
   154 label *label41
-    * set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
   155 jump *label45 lessThan PCT_LOW PCT_HIGH
   156 print "PCT_LOW must be less than PCT_HIGH."
   157 printflush .message
 
   165 jump *label48 equal false true
   166 set .state true
   167 op add .cycles .cycles 1
-    * op xor .active .inverted :setState:newState
+  168 op xor .active .inverted true
   169 jump *label50 equal .active false
   170 set *tmp38 "\nCurrently active:[green]"
   171 jump *label51 always
 
   234 jump *label72 equal .state true
   235 set .state true
   236 op add .cycles .cycles 1
-    * op xor .active .inverted :setState.1:newState
+  237 op xor .active .inverted true
   238 jump *label74 equal .active false
   239 set *tmp69 "\nCurrently active:[green]"
   240 jump *label75 always
 
   252 jump *label79 equal .state false
   253 set .state false
   254 op add .cycles .cycles 1
-    * op xor .active .inverted :setState.2:newState
+  255 op xor .active .inverted false
   256 jump *label81 equal .active false
   257 set *tmp76 "\nCurrently active:[green]"
   258 jump *label82 always
 
   296 print "[]"
   297 label *label84
   298 print .activeText
-    * set *tmp78 .links
   299 set :n .first
   300 label *label85
   301 jump *label87 greaterThanEq :n .links

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
   161 label *label44
   162 sensor *tmp32 .sorter @type
   163 op equal .inverted *tmp32 @inverted-sorter
-    * set :setState:newState true
   164 jump *label48 equal false true
   165 set .state true
   166 op add .cycles .cycles 1
 
   229 sensor *tmp61 .container .maximum
   230 op idiv :pct *tmp60 *tmp61
   231 jump *label69 greaterThan :pct PCT_LOW
-    * set :setState.1:newState true
   232 jump *label72 equal .state true
   233 set .state true
   234 op add .cycles .cycles 1
 
   246 jump *label70 always
   247 label *label69
   248 jump *label76 lessThan :pct PCT_HIGH
-    * set :setState.2:newState false
   249 jump *label79 equal .state false
   250 set .state false
   251 op add .cycles .cycles 1

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     7 op sub :initialize:n .links 1
     8 label *label4
     9 jump *label6 lessThan :initialize:n 0
+   10 label *label88
    11 getlink :initialize:block :initialize:n
    12 print "Found: "
    13 print :initialize:block
 
    73 label *label7
    74 label *label5
    75 op sub :initialize:n :initialize:n 1
-    * jump *label4 always
+   76 jump *label88 greaterThanEq :initialize:n 0
    77 label *label6
    78 print "Message: "
    79 print .message
 
   297 set :n .first
   298 label *label85
   299 jump *label87 greaterThanEq :n .links
+  300 label *label89
   301 getlink :block :n
   302 control enabled :block .active
   303 print "\n    "
   304 print :block
   305 label *label86
   306 op add :n :n 1
-    * jump *label85 always
+  307 jump *label89 lessThan :n .links
   308 label *label87
   309 print "[]"
   310 print "\n"

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-2 instructions):
 
   114 label *label3
   115 printflush null
   116 jump *label28 lessThan PCT_LOW 0
-    * label *label32
   117 jump *label28 greaterThan PCT_LOW 100
-    * label *label31
-    * op floor *tmp17 PCT_LOW
-    * op strictEqual *tmp18 PCT_LOW *tmp17
-    * jump *label28 equal *tmp18 false
-    * label *label30
-    * set *tmp19 true
+  118 op floor *tmp17 PCT_LOW
+  119 op strictEqual *tmp18 PCT_LOW *tmp17
+  120 op notEqual *tmp19 *tmp18 false
   121 jump *label29 always
   122 label *label28
   123 set *tmp19 false
 
   130 label *label35
   131 label *label33
   132 jump *label36 lessThan PCT_HIGH 0
-    * label *label40
   133 jump *label36 greaterThan PCT_HIGH 100
-    * label *label39
-    * op floor *tmp24 PCT_HIGH
-    * op strictEqual *tmp25 PCT_HIGH *tmp24
-    * jump *label36 equal *tmp25 false
-    * label *label38
-    * set *tmp26 true
+  134 op floor *tmp24 PCT_HIGH
+  135 op strictEqual *tmp25 PCT_HIGH *tmp24
+  136 op notEqual *tmp26 *tmp25 false
   137 jump *label37 always
   138 label *label36
   139 set *tmp26 false
 
   190 label *label59
   191 label *label60
   192 jump *label61 equal .sorter false
-    * label *label64
   193 sensor *tmp49 .sorter @dead
   194 jump *label61 equal *tmp49 false
-    * label *label63
   195 end
   196 label *label61
   197 label *label62

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
   113 jump *label1 notEqual :initialize:repeat false
   114 label *label3
   115 printflush null
-    * jump *label28 lessThan PCT_LOW 0
-    * jump *label28 greaterThan PCT_LOW 100
+  116 set *tmp19 false
+  117 jump *label29 lessThan PCT_LOW 0
+  118 jump *label29 greaterThan PCT_LOW 100
   119 op floor *tmp17 PCT_LOW
   120 op strictEqual *tmp18 PCT_LOW *tmp17
   121 op notEqual *tmp19 *tmp18 false
   122 jump *label29 always
-    * label *label28
-    * set *tmp19 false
   123 label *label29
   124 jump *label34 notEqual *tmp19 false
   125 print "PCT_LOW must be an integer between 0 to 100."
 
   128 label *label34
   129 label *label35
   130 label *label33
-    * jump *label36 lessThan PCT_HIGH 0
-    * jump *label36 greaterThan PCT_HIGH 100
+  131 set *tmp26 false
+  132 jump *label37 lessThan PCT_HIGH 0
+  133 jump *label37 greaterThan PCT_HIGH 100
   134 op floor *tmp24 PCT_HIGH
   135 op strictEqual *tmp25 PCT_HIGH *tmp24
   136 op notEqual *tmp26 *tmp25 false
   137 jump *label37 always
-    * label *label36
-    * set *tmp26 false
   138 label *label37
   139 jump *label42 notEqual *tmp26 false
   140 print "PCT_HIGH must be an integer between 0 to 100."
 
   156 set .state true
   157 op add .cycles .cycles 1
   158 op xor .active .inverted true
-    * jump *label50 equal .active false
-    * set *tmp38 "\nCurrently active:[green]"
+  159 set .activeText "\nCurrently inactive:[salmon]"
+  160 jump *label51 equal .active false
+  161 set .activeText "\nCurrently active:[green]"
   162 jump *label51 always
-    * label *label50
-    * set *tmp38 "\nCurrently inactive:[salmon]"
   163 label *label51
-    * set .activeText *tmp38
   164 label *label48
   165 label *label49
   166 label *label47
 
   220 set .state true
   221 op add .cycles .cycles 1
   222 op xor .active .inverted true
-    * jump *label74 equal .active false
-    * set *tmp69 "\nCurrently active:[green]"
+  223 set .activeText "\nCurrently inactive:[salmon]"
+  224 jump *label75 equal .active false
+  225 set .activeText "\nCurrently active:[green]"
   226 jump *label75 always
-    * label *label74
-    * set *tmp69 "\nCurrently inactive:[salmon]"
   227 label *label75
-    * set .activeText *tmp69
   228 label *label72
   229 label *label73
   230 label *label71
 
   235 set .state false
   236 op add .cycles .cycles 1
   237 op xor .active .inverted false
-    * jump *label81 equal .active false
-    * set *tmp76 "\nCurrently active:[green]"
+  238 set .activeText "\nCurrently inactive:[salmon]"
+  239 jump *label82 equal .active false
+  240 set .activeText "\nCurrently active:[green]"
   241 jump *label82 always
-    * label *label81
-    * set *tmp76 "\nCurrently inactive:[salmon]"
   242 label *label82
-    * set .activeText *tmp76
   243 label *label79
   244 label *label80
   245 label *label78

Modifications by Partial loop rotation at line 36:5 (+1 instructions):
 
   169 label *label52
   170 sensor *tmp41 .switch @enabled
   171 jump *label54 notEqual *tmp41 0
+  172 label *label90
   173 set :start @time
   174 sensor *tmp43 .container @dead
   175 jump *label55 equal *tmp43 false
 
   302 print "ms"
   303 printflush .message
   304 label *label53
-    * jump *label52 always
+  305 sensor *tmp41 .switch @enabled
+  306 jump *label90 equal *tmp41 0
   307 label *label54
   308 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   279 print .activeText
   280 set :n .first
   281 label *label85
-    * jump *label87 greaterThanEq :n .links
+  282 jump *label87 greaterThanEq .first .links
   283 label *label89
   284 getlink :block :n
   285 control enabled :block .active

Modifications by Convert case at line 97:13 (segments: 1, padded low) (+131 instructions):
 
    13 print :initialize:block
    14 print "\n"
    15 sensor *tmp3 :initialize:block @type
-    * jump *label8 notEqual *tmp3 @message
+   16 sensor *tmp84 *tmp3 @id
+   17 jump *label91 greaterThanEq *tmp84 147
+   18 multijump *label93 *tmp84 0 (m:*label92)
+   19 multilabel *label93 (m:*label92)
+   20 jump *label91 always
+   21 multilabel *label94 (m:*label92)
+   22 jump *label91 always
+   23 multilabel *label95 (m:*label92)
+   24 jump *label91 always
+   25 multilabel *label96 (m:*label92)
+   26 jump *label91 always
+   27 multilabel *label97 (m:*label92)
+   28 jump *label91 always
+   29 multilabel *label98 (m:*label92)
+   30 jump *label91 always
+   31 multilabel *label99 (m:*label92)
+   32 jump *label91 always
+   33 multilabel *label100 (m:*label92)
+   34 jump *label91 always
+   35 multilabel *label101 (m:*label92)
+   36 jump *label91 always
+   37 multilabel *label102 (m:*label92)
+   38 jump *label91 always
+   39 multilabel *label103 (m:*label92)
+   40 jump *label91 always
+   41 multilabel *label104 (m:*label92)
+   42 jump *label91 always
+   43 multilabel *label105 (m:*label92)
+   44 jump *label91 always
+   45 multilabel *label106 (m:*label92)
+   46 jump *label91 always
+   47 multilabel *label107 (m:*label92)
+   48 jump *label91 always
+   49 multilabel *label108 (m:*label92)
+   50 jump *label91 always
+   51 multilabel *label109 (m:*label92)
+   52 jump *label91 always
+   53 multilabel *label110 (m:*label92)
+   54 jump *label91 always
+   55 multilabel *label111 (m:*label92)
+   56 jump *label91 always
+   57 multilabel *label112 (m:*label92)
+   58 jump *label91 always
+   59 multilabel *label113 (m:*label92)
+   60 jump *label91 always
+   61 multilabel *label114 (m:*label92)
+   62 jump *label91 always
+   63 multilabel *label115 (m:*label92)
+   64 jump *label91 always
+   65 multilabel *label116 (m:*label92)
+   66 jump *label91 always
+   67 multilabel *label117 (m:*label92)
+   68 jump *label91 always
+   69 multilabel *label118 (m:*label92)
+   70 jump *label91 always
+   71 multilabel *label119 (m:*label92)
+   72 jump *label91 always
+   73 multilabel *label120 (m:*label92)
+   74 jump *label91 always
+   75 multilabel *label121 (m:*label92)
+   76 jump *label91 always
+   77 multilabel *label122 (m:*label92)
+   78 jump *label91 always
+   79 multilabel *label123 (m:*label92)
+   80 jump *label91 always
+   81 multilabel *label124 (m:*label92)
+   82 jump *label91 always
+   83 multilabel *label125 (m:*label92)
+   84 jump *label91 always
+   85 multilabel *label126 (m:*label92)
+   86 jump *label91 always
+   87 multilabel *label127 (m:*label92)
+   88 jump *label91 always
+   89 multilabel *label128 (m:*label92)
+   90 jump *label91 always
+   91 multilabel *label129 (m:*label92)
+   92 jump *label91 always
+   93 multilabel *label130 (m:*label92)
+   94 jump *label91 always
+   95 multilabel *label131 (m:*label92)
+   96 jump *label91 always
+   97 multilabel *label132 (m:*label92)
+   98 jump *label91 always
+   99 multilabel *label133 (m:*label92)
+  100 jump *label91 always
+  101 multilabel *label134 (m:*label92)
+  102 jump *label91 always
+  103 multilabel *label135 (m:*label92)
+  104 jump *label91 always
+  105 multilabel *label136 (m:*label92)
+  106 jump *label91 always
+  107 multilabel *label137 (m:*label92)
+  108 jump *label91 always
+  109 multilabel *label138 (m:*label92)
+  110 jump *label91 always
+  111 multilabel *label139 (m:*label92)
+  112 jump *label91 always
+  113 multilabel *label140 (m:*label92)
+  114 jump *label91 always
+  115 multilabel *label141 (m:*label92)
+  116 jump *label13 always
+  117 multilabel *label142 (m:*label92)
+  118 jump *label13 always
+  119 multilabel *label143 (m:*label92)
+  120 jump *label91 always
+  121 multilabel *label144 (m:*label92)
+  122 jump *label91 always
+  123 multilabel *label145 (m:*label92)
+  124 jump *label91 always
+  125 multilabel *label146 (m:*label92)
+  126 jump *label91 always
+  127 multilabel *label147 (m:*label92)
+  128 jump *label91 always
+  129 multilabel *label148 (m:*label92)
+  130 jump *label91 always
+  131 multilabel *label149 (m:*label92)
+  132 jump *label91 always
+  133 multilabel *label150 (m:*label92)
+  134 jump *label91 always
+  135 multilabel *label151 (m:*label92)
+  136 jump *label91 always
+  137 multilabel *label152 (m:*label92)
+  138 jump *label91 always
+  139 multilabel *label153 (m:*label92)
+  140 jump *label91 always
+  141 multilabel *label154 (m:*label92)
+  142 jump *label91 always
+  143 multilabel *label155 (m:*label92)
+  144 jump *label91 always
+  145 multilabel *label156 (m:*label92)
+  146 jump *label17 always
+  147 multilabel *label157 (m:*label92)
+  148 jump *label17 always
+  149 multilabel *label158 (m:*label92)
+  150 jump *label91 always
+  151 multilabel *label159 (m:*label92)
+  152 jump *label91 always
+  153 multilabel *label160 (m:*label92)
+  154 jump *label91 always
+  155 multilabel *label161 (m:*label92)
+  156 jump *label21 always
+  157 multilabel *label162 (m:*label92)
+  158 jump *label21 always
+  159 multilabel *label163 (m:*label92)
+  160 jump *label21 always
+  161 multilabel *label164 (m:*label92)
+  162 jump *label91 always
+  163 multilabel *label165 (m:*label92)
+  164 jump *label19 always
+  165 multilabel *label166 (m:*label92)
+  166 jump *label19 always
+  167 multilabel *label167 (m:*label92)
+  168 jump *label91 always
+  169 multilabel *label168 (m:*label92)
+  170 jump *label91 always
+  171 multilabel *label169 (m:*label92)
+  172 jump *label91 always
+  173 multilabel *label170 (m:*label92)
+  174 jump *label91 always
+  175 multilabel *label171 (m:*label92)
+  176 jump *label91 always
+  177 multilabel *label172 (m:*label92)
+  178 jump *label91 always
+  179 multilabel *label173 (m:*label92)
+  180 jump *label91 always
+  181 multilabel *label174 (m:*label92)
+  182 jump *label91 always
+  183 multilabel *label175 (m:*label92)
+  184 jump *label91 always
+  185 multilabel *label176 (m:*label92)
+  186 jump *label91 always
+  187 multilabel *label177 (m:*label92)
+  188 jump *label91 always
+  189 multilabel *label178 (m:*label92)
+  190 jump *label91 always
+  191 multilabel *label179 (m:*label92)
+  192 jump *label91 always
+  193 multilabel *label180 (m:*label92)
+  194 jump *label91 always
+  195 multilabel *label181 (m:*label92)
+  196 jump *label91 always
+  197 multilabel *label182 (m:*label92)
+  198 jump *label91 always
+  199 multilabel *label183 (m:*label92)
+  200 jump *label15 always
+  201 multilabel *label184 (m:*label92)
+  202 jump *label15 always
+  203 multilabel *label185 (m:*label92)
+  204 jump *label15 always
+  205 multilabel *label186 (m:*label92)
+  206 jump *label15 always
+  207 multilabel *label187 (m:*label92)
+  208 jump *label15 always
+  209 multilabel *label188 (m:*label92)
+  210 jump *label13 always
+  211 multilabel *label189 (m:*label92)
+  212 jump *label91 always
+  213 multilabel *label190 (m:*label92)
+  214 jump *label91 always
+  215 multilabel *label191 (m:*label92)
+  216 jump *label91 always
+  217 multilabel *label192 (m:*label92)
+  218 jump *label91 always
+  219 multilabel *label193 (m:*label92)
+  220 jump *label91 always
+  221 multilabel *label194 (m:*label92)
+  222 jump *label91 always
+  223 multilabel *label195 (m:*label92)
+  224 jump *label91 always
+  225 multilabel *label196 (m:*label92)
+  226 jump *label91 always
+  227 multilabel *label197 (m:*label92)
+  228 jump *label91 always
+  229 multilabel *label198 (m:*label92)
+  230 jump *label91 always
+  231 multilabel *label199 (m:*label92)
+  232 jump *label91 always
+  233 multilabel *label200 (m:*label92)
+  234 jump *label91 always
+  235 multilabel *label201 (m:*label92)
+  236 jump *label91 always
+  237 multilabel *label202 (m:*label92)
+  238 jump *label91 always
+  239 multilabel *label203 (m:*label92)
+  240 jump *label91 always
+  241 multilabel *label204 (m:*label92)
+  242 jump *label91 always
+  243 multilabel *label205 (m:*label92)
+  244 jump *label91 always
+  245 multilabel *label206 (m:*label92)
+  246 jump *label91 always
+  247 multilabel *label207 (m:*label92)
+  248 jump *label91 always
+  249 multilabel *label208 (m:*label92)
+  250 jump *label91 always
+  251 multilabel *label209 (m:*label92)
+  252 jump *label91 always
+  253 multilabel *label210 (m:*label92)
+  254 jump *label91 always
+  255 multilabel *label211 (m:*label92)
+  256 jump *label91 always
+  257 multilabel *label212 (m:*label92)
+  258 jump *label91 always
+  259 multilabel *label213 (m:*label92)
+  260 jump *label91 always
+  261 multilabel *label214 (m:*label92)
+  262 jump *label91 always
+  263 multilabel *label215 (m:*label92)
+  264 jump *label91 always
+  265 multilabel *label216 (m:*label92)
+  266 jump *label91 always
+  267 multilabel *label217 (m:*label92)
+  268 jump *label91 always
+  269 multilabel *label218 (m:*label92)
+  270 jump *label91 always
+  271 multilabel *label219 (m:*label92)
+  272 jump *label91 always
+  273 multilabel *label220 (m:*label92)
+  274 jump *label91 always
+  275 multilabel *label221 (m:*label92)
+  276 jump *label91 always
+  277 multilabel *label222 (m:*label92)
+  278 jump *label91 always
+  279 multilabel *label223 (m:*label92)
+  280 jump *label91 always
+  281 multilabel *label224 (m:*label92)
+  282 jump *label91 always
+  283 multilabel *label225 (m:*label92)
+  284 jump *label91 always
+  285 multilabel *label226 (m:*label92)
+  286 jump *label91 always
+  287 multilabel *label227 (m:*label92)
+  288 jump *label91 always
+  289 multilabel *label228 (m:*label92)
+  290 jump *label91 always
+  291 multilabel *label229 (m:*label92)
+  292 jump *label91 always
+  293 multilabel *label230 (m:*label92)
+  294 jump *label9 always
+  295 multilabel *label231 (m:*label92)
+  296 jump *label11 always
+  297 multilabel *label232 (m:*label92)
+  298 jump *label91 always
+  299 multilabel *label233 (m:*label92)
+  300 jump *label91 always
+  301 multilabel *label234 (m:*label92)
+  302 jump *label91 always
+  303 multilabel *label235 (m:*label92)
+  304 jump *label91 always
+  305 multilabel *label236 (m:*label92)
+  306 jump *label91 always
+  307 multilabel *label237 (m:*label92)
+  308 jump *label91 always
+  309 multilabel *label238 (m:*label92)
+  310 jump *label91 always
+  311 multilabel *label239 (m:*label92)
+  312 label *label17
+  313 set .container :initialize:block
+  314 set .measure @totalLiquids
+  315 set .maximum @liquidCapacity
+  316 op add .first :initialize:n 1
+  317 jump *label7 always
   318 label *label9
   319 set .message :initialize:block
   320 jump *label7 always
   321 label *label8
-    * jump *label10 notEqual *tmp3 @switch
   322 label *label11
   323 set .switch :initialize:block
   324 jump *label7 always
   325 label *label10
-    * jump *label13 equal *tmp3 @sorter
-    * jump *label13 equal *tmp3 @inverted-sorter
-    * jump *label12 notEqual *tmp3 @unloader
   326 label *label13
   327 set .sorter :initialize:block
   328 jump *label7 always
   329 label *label12
-    * jump *label15 equal *tmp3 @vault
-    * jump *label15 equal *tmp3 @container
-    * jump *label15 equal *tmp3 @core-shard
-    * jump *label15 equal *tmp3 @core-foundation
-    * jump *label14 notEqual *tmp3 @core-nucleus
   330 label *label15
   331 set .container :initialize:block
   332 set .measure @totalItems
 
   334 op add .first :initialize:n 1
   335 jump *label7 always
   336 label *label14
-    * jump *label17 equal *tmp3 @liquid-tank
-    * jump *label17 equal *tmp3 @liquid-container
-    * jump *label16 notEqual *tmp3 @liquid-router
-    * label *label17
-    * set .container :initialize:block
-    * set .measure @totalLiquids
-    * set .maximum @liquidCapacity
-    * op add .first :initialize:n 1
-    * jump *label7 always
   337 label *label16
-    * jump *label19 equal *tmp3 @battery
-    * jump *label18 notEqual *tmp3 @battery-large
   338 label *label19
   339 set .container :initialize:block
   340 set .measure @totalPower
 
   342 op add .first :initialize:n 1
   343 jump *label7 always
   344 label *label18
-    * jump *label21 equal *tmp3 @power-node
-    * jump *label21 equal *tmp3 @power-node-large
-    * jump *label20 notEqual *tmp3 @surge-tower
   345 label *label21
   346 set .container :initialize:block
   347 set .measure @powerNetStored
   348 set .maximum @powerNetCapacity
   349 op add .first :initialize:n 1
   350 label *label20
+  351 label *label91
   352 label *label7
   353 label *label5
   354 op sub :initialize:n :initialize:n 1

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   431 label *label44
   432 sensor *tmp32 .sorter @type
   433 op equal .inverted *tmp32 @inverted-sorter
-    * jump *label48 equal false true
   434 set .state true
   435 op add .cycles .cycles 1
   436 op xor .active .inverted true

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-2 instructions):
 
     6 set .links @links
     7 op sub :initialize:n .links 1
     8 label *label4
-    * jump *label6 lessThan :initialize:n 0
+    9 jump *label6 lessThan .links 1
    10 label *label88
    11 getlink :initialize:block :initialize:n
    12 print "Found: "
 
   396 jump *label29 lessThan PCT_LOW 0
   397 jump *label29 greaterThan PCT_LOW 100
   398 op floor *tmp17 PCT_LOW
-    * op strictEqual *tmp18 PCT_LOW *tmp17
-    * op notEqual *tmp19 *tmp18 false
+  399 op strictEqual *tmp19 PCT_LOW *tmp17
   400 jump *label29 always
   401 label *label29
   402 jump *label34 notEqual *tmp19 false
 
   410 jump *label37 lessThan PCT_HIGH 0
   411 jump *label37 greaterThan PCT_HIGH 100
   412 op floor *tmp24 PCT_HIGH
-    * op strictEqual *tmp25 PCT_HIGH *tmp24
-    * op notEqual *tmp26 *tmp25 false
+  413 op strictEqual *tmp26 PCT_HIGH *tmp24
   414 jump *label37 always
   415 label *label37
   416 jump *label42 notEqual *tmp26 false
 
   528 print :pct
   529 print "%"
   530 print "[]"
-    * jump *label83 equal .inverted false
+  531 jump *label83 notEqual *tmp32 @inverted-sorter
   532 print "\n"
   533 print "Activate above [green]"
   534 print PCT_HIGH

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-5 instructions):
 
   397 jump *label29 greaterThan PCT_LOW 100
   398 op floor *tmp17 PCT_LOW
   399 op strictEqual *tmp19 PCT_LOW *tmp17
-    * jump *label29 always
   400 label *label29
   401 jump *label34 notEqual *tmp19 false
   402 print "PCT_LOW must be an integer between 0 to 100."
 
   410 jump *label37 greaterThan PCT_HIGH 100
   411 op floor *tmp24 PCT_HIGH
   412 op strictEqual *tmp26 PCT_HIGH *tmp24
-    * jump *label37 always
   413 label *label37
   414 jump *label42 notEqual *tmp26 false
   415 print "PCT_HIGH must be an integer between 0 to 100."
 
   433 set .activeText "\nCurrently inactive:[salmon]"
   434 jump *label51 equal .active false
   435 set .activeText "\nCurrently active:[green]"
-    * jump *label51 always
   436 label *label51
   437 label *label48
   438 label *label49
 
   497 set .activeText "\nCurrently inactive:[salmon]"
   498 jump *label75 equal .active false
   499 set .activeText "\nCurrently active:[green]"
-    * jump *label75 always
   500 label *label75
   501 label *label72
   502 label *label73
 
   511 set .activeText "\nCurrently inactive:[salmon]"
   512 jump *label82 equal .active false
   513 set .activeText "\nCurrently active:[green]"
-    * jump *label82 always
   514 label *label82
   515 label *label79
   516 label *label80

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   507 jump *label79 equal .state false
   508 set .state false
   509 op add .cycles .cycles 1
-    * op xor .active .inverted false
+  510 set .active .inverted
   511 set .activeText "\nCurrently inactive:[salmon]"
   512 jump *label82 equal .active false
   513 set .activeText "\nCurrently active:[green]"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   509 op add .cycles .cycles 1
   510 set .active .inverted
   511 set .activeText "\nCurrently inactive:[salmon]"
-    * jump *label82 equal .active false
+  512 jump *label82 equal .inverted false
   513 set .activeText "\nCurrently active:[green]"
   514 label *label82
   515 label *label79

Modifications by Iterated phase, Condition Optimization, pass 3, iteration 1:
 
   509 op add .cycles .cycles 1
   510 set .active .inverted
   511 set .activeText "\nCurrently inactive:[salmon]"
-    * jump *label82 equal .inverted false
+  512 jump *label82 notEqual *tmp32 @inverted-sorter
   513 set .activeText "\nCurrently active:[green]"
   514 label *label82
   515 label *label79

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
+    0 label __start__
     1 set PCT_LOW 60
     2 set PCT_HIGH 80
     3 label *label1
 
   417 label *label51
   418 control enabled .switch 0
   419 sensor *tmp41 .switch @enabled
-    * jump *label54 notEqual *tmp41 0
+  420 jump __start__ notEqual *tmp41 0
   421 label *label90
   422 set :start @time
   423 sensor *tmp43 .container @dead
 
   461 sensor *tmp61 .container .maximum
   462 op idiv :pct *tmp60 *tmp61
   463 jump *label69 greaterThan :pct PCT_LOW
-    * jump *label72 equal .state true
+  464 jump *label70 equal .state true
   465 set .state true
   466 op add .cycles .cycles 1
   467 op xor .active .inverted true
   468 set .activeText "\nCurrently inactive:[salmon]"
-    * jump *label75 equal .active false
+  469 jump *label70 equal .active false
   470 set .activeText "\nCurrently active:[green]"
   471 label *label75
   472 label *label72

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-1 instructions):
 
   536 printflush .message
   537 sensor *tmp41 .switch @enabled
   538 jump *label90 equal *tmp41 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-25 instructions):
 
     2 set PCT_HIGH 80
     3 label *label1
     4 set :initialize:repeat false
-    * print "Configuring regulator..."
-    * print "\n"
+    5 print "Configuring regulator...\n"
     6 set .links @links
     7 op sub :initialize:n .links 1
     8 jump *label6 lessThan .links 1
 
   347 label *label6
   348 print "Message: "
   349 print .message
-    * print "\n"
-    * print "Switch: "
+  350 print "\nSwitch: "
   351 print .switch
-    * print "\n"
-    * print "Sorter: "
+  352 print "\nSorter: "
   353 print .sorter
-    * print "\n"
-    * print "Container: "
+  354 print "\nContainer: "
   355 print .container
-    * print "\n"
-    * print "First index: "
+  356 print "\nFirst index: "
   357 print .first
   358 print "\n"
   359 jump *label22 notEqual .message null
-    * print "No message."
-    * print "\n"
+  360 print "No message.\n"
   361 set :initialize:repeat true
   362 label *label22
   363 jump *label24 notEqual .switch null
-    * print "No switch."
-    * print "\n"
+  364 print "No switch.\n"
   365 set :initialize:repeat true
   366 label *label24
   367 jump *label26 notEqual .container null
-    * print "No container."
-    * print "\n"
+  368 print "No container.\n"
   369 set :initialize:repeat true
   370 label *label26
   371 printflush .message
 
   444 label *label67
   445 print "Measuring [gold]"
   446 print :item
-    * print "["
-    * print "] in "
+  447 print "[] in "
   448 print .container
   449 sensor :amount .container :item
   450 label *label68
 
   473 label *label79
   474 label *label76
   475 label *label70
-    * print "\n"
-    * print "Level: [gold]"
+  476 print "\nLevel: [gold]"
   477 print :pct
-    * print "%"
-    * print "[]"
+  478 print "%[]"
   479 jump *label83 notEqual *tmp32 @inverted-sorter
-    * print "\n"
-    * print "Activate above [green]"
+  480 print "\nActivate above [green]"
   481 print PCT_HIGH
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate below [salmon]"
+  482 print "%[]\nDeactivate below [salmon]"
   483 print PCT_LOW
-    * print "%"
-    * print "[]"
+  484 print "%[]"
   485 jump *label84 always
   486 label *label83
-    * print "\n"
-    * print "Activate below [green]"
+  487 print "\nActivate below [green]"
   488 print PCT_LOW
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate above [salmon]"
+  489 print "%[]\nDeactivate above [salmon]"
   490 print PCT_HIGH
-    * print "%"
-    * print "[]"
+  491 print "%[]"
   492 label *label84
   493 print .activeText
   494 set :n .first
 
   501 op add :n :n 1
   502 jump *label89 lessThan :n .links
   503 label *label87
-    * print "[]"
-    * print "\n"
-    * print "# of cycles: "
+  504 print "[]\n# of cycles: "
   505 print .cycles
   506 op sub *tmp82 @time :start
   507 op floor *tmp83 *tmp82
-    * print "\n"
-    * print "[lightgray]Loop: "
+  508 print "\n[lightgray]Loop: "
   509 print *tmp83
-    * print " "
-    * print "ms"
+  510 print " ms"
   511 printflush .message
   512 sensor *tmp41 .switch @enabled
   513 jump *label90 equal *tmp41 0

Final code before resolving virtual instructions:

        label __start__
    0:  set PCT_LOW 60                                               param PCT_LOW = 60;
    1:  set PCT_HIGH 80                                              param PCT_HIGH = 80;
        label *label1                                                do
    2:  set :initialize:repeat false                                 var repeat = false;
    3:  print "Configuring regulator...\n"                           println("Configuring regulator...");
    4:  set .links @links                                            links = @links;
    5:  op sub :initialize:n .links 1                                for var n in 0 ... links descending do
    6:  jump *label6 lessThan .links 1                               ...
        label *label88                                               ...
    7:  getlink :initialize:block :initialize:n                      var block = getlink(n);
    8:  print "Found: "                                              println("Found: ", block);
    9:  print :initialize:block                                      ...
   10:  print "\n"                                                   ...
   11:  sensor *tmp3 :initialize:block @type                         case block.@type
   12:  sensor *tmp84 *tmp3 @id                                      for var n in 0 ... links descending do
   13:  jump *label91 greaterThanEq *tmp84 147                       case block.@type
   14:  multijump *label93 *tmp84 0                                  ...
        multilabel *label93                                          ...
   15:  jump *label91 always 0 0                                     ...
        multilabel *label94                                          ...
   16:  jump *label91 always 0 0                                     ...
        multilabel *label95                                          ...
   17:  jump *label91 always 0 0                                     ...
        multilabel *label96                                          ...
   18:  jump *label91 always 0 0                                     ...
        multilabel *label97                                          ...
   19:  jump *label91 always 0 0                                     ...
        multilabel *label98                                          ...
   20:  jump *label91 always 0 0                                     ...
        multilabel *label99                                          ...
   21:  jump *label91 always 0 0                                     ...
        multilabel *label100                                         ...
   22:  jump *label91 always 0 0                                     ...
        multilabel *label101                                         ...
   23:  jump *label91 always 0 0                                     ...
        multilabel *label102                                         ...
   24:  jump *label91 always 0 0                                     ...
        multilabel *label103                                         ...
   25:  jump *label91 always 0 0                                     ...
        multilabel *label104                                         ...
   26:  jump *label91 always 0 0                                     ...
        multilabel *label105                                         ...
   27:  jump *label91 always 0 0                                     ...
        multilabel *label106                                         ...
   28:  jump *label91 always 0 0                                     ...
        multilabel *label107                                         ...
   29:  jump *label91 always 0 0                                     ...
        multilabel *label108                                         ...
   30:  jump *label91 always 0 0                                     ...
        multilabel *label109                                         ...
   31:  jump *label91 always 0 0                                     ...
        multilabel *label110                                         ...
   32:  jump *label91 always 0 0                                     ...
        multilabel *label111                                         ...
   33:  jump *label91 always 0 0                                     ...
        multilabel *label112                                         ...
   34:  jump *label91 always 0 0                                     ...
        multilabel *label113                                         ...
   35:  jump *label91 always 0 0                                     ...
        multilabel *label114                                         ...
   36:  jump *label91 always 0 0                                     ...
        multilabel *label115                                         ...
   37:  jump *label91 always 0 0                                     ...
        multilabel *label116                                         ...
   38:  jump *label91 always 0 0                                     ...
        multilabel *label117                                         ...
   39:  jump *label91 always 0 0                                     ...
        multilabel *label118                                         ...
   40:  jump *label91 always 0 0                                     ...
        multilabel *label119                                         ...
   41:  jump *label91 always 0 0                                     ...
        multilabel *label120                                         ...
   42:  jump *label91 always 0 0                                     ...
        multilabel *label121                                         ...
   43:  jump *label91 always 0 0                                     ...
        multilabel *label122                                         ...
   44:  jump *label91 always 0 0                                     ...
        multilabel *label123                                         ...
   45:  jump *label91 always 0 0                                     ...
        multilabel *label124                                         ...
   46:  jump *label91 always 0 0                                     ...
        multilabel *label125                                         ...
   47:  jump *label91 always 0 0                                     ...
        multilabel *label126                                         ...
   48:  jump *label91 always 0 0                                     ...
        multilabel *label127                                         ...
   49:  jump *label91 always 0 0                                     ...
        multilabel *label128                                         ...
   50:  jump *label91 always 0 0                                     ...
        multilabel *label129                                         ...
   51:  jump *label91 always 0 0                                     ...
        multilabel *label130                                         ...
   52:  jump *label91 always 0 0                                     ...
        multilabel *label131                                         ...
   53:  jump *label91 always 0 0                                     ...
        multilabel *label132                                         ...
   54:  jump *label91 always 0 0                                     ...
        multilabel *label133                                         ...
   55:  jump *label91 always 0 0                                     ...
        multilabel *label134                                         ...
   56:  jump *label91 always 0 0                                     ...
        multilabel *label135                                         ...
   57:  jump *label91 always 0 0                                     ...
        multilabel *label136                                         ...
   58:  jump *label91 always 0 0                                     ...
        multilabel *label137                                         ...
   59:  jump *label91 always 0 0                                     ...
        multilabel *label138                                         ...
   60:  jump *label91 always 0 0                                     ...
        multilabel *label139                                         ...
   61:  jump *label91 always 0 0                                     ...
        multilabel *label140                                         ...
   62:  jump *label91 always 0 0                                     ...
        multilabel *label141                                         ...
   63:  jump *label13 always 0 0                                     ...
        multilabel *label142                                         ...
   64:  jump *label13 always 0 0                                     ...
        multilabel *label143                                         ...
   65:  jump *label91 always 0 0                                     ...
        multilabel *label144                                         ...
   66:  jump *label91 always 0 0                                     ...
        multilabel *label145                                         ...
   67:  jump *label91 always 0 0                                     ...
        multilabel *label146                                         ...
   68:  jump *label91 always 0 0                                     ...
        multilabel *label147                                         ...
   69:  jump *label91 always 0 0                                     ...
        multilabel *label148                                         ...
   70:  jump *label91 always 0 0                                     ...
        multilabel *label149                                         ...
   71:  jump *label91 always 0 0                                     ...
        multilabel *label150                                         ...
   72:  jump *label91 always 0 0                                     ...
        multilabel *label151                                         ...
   73:  jump *label91 always 0 0                                     ...
        multilabel *label152                                         ...
   74:  jump *label91 always 0 0                                     ...
        multilabel *label153                                         ...
   75:  jump *label91 always 0 0                                     ...
        multilabel *label154                                         ...
   76:  jump *label91 always 0 0                                     ...
        multilabel *label155                                         ...
   77:  jump *label91 always 0 0                                     ...
        multilabel *label156                                         ...
   78:  jump *label17 always 0 0                                     ...
        multilabel *label157                                         ...
   79:  jump *label17 always 0 0                                     ...
        multilabel *label158                                         ...
   80:  jump *label91 always 0 0                                     ...
        multilabel *label159                                         ...
   81:  jump *label91 always 0 0                                     ...
        multilabel *label160                                         ...
   82:  jump *label91 always 0 0                                     ...
        multilabel *label161                                         ...
   83:  jump *label21 always 0 0                                     ...
        multilabel *label162                                         ...
   84:  jump *label21 always 0 0                                     ...
        multilabel *label163                                         ...
   85:  jump *label21 always 0 0                                     ...
        multilabel *label164                                         ...
   86:  jump *label91 always 0 0                                     ...
        multilabel *label165                                         ...
   87:  jump *label19 always 0 0                                     ...
        multilabel *label166                                         ...
   88:  jump *label19 always 0 0                                     ...
        multilabel *label167                                         ...
   89:  jump *label91 always 0 0                                     ...
        multilabel *label168                                         ...
   90:  jump *label91 always 0 0                                     ...
        multilabel *label169                                         ...
   91:  jump *label91 always 0 0                                     ...
        multilabel *label170                                         ...
   92:  jump *label91 always 0 0                                     ...
        multilabel *label171                                         ...
   93:  jump *label91 always 0 0                                     ...
        multilabel *label172                                         ...
   94:  jump *label91 always 0 0                                     ...
        multilabel *label173                                         ...
   95:  jump *label91 always 0 0                                     ...
        multilabel *label174                                         ...
   96:  jump *label91 always 0 0                                     ...
        multilabel *label175                                         ...
   97:  jump *label91 always 0 0                                     ...
        multilabel *label176                                         ...
   98:  jump *label91 always 0 0                                     ...
        multilabel *label177                                         ...
   99:  jump *label91 always 0 0                                     ...
        multilabel *label178                                         ...
  100:  jump *label91 always 0 0                                     ...
        multilabel *label179                                         ...
  101:  jump *label91 always 0 0                                     ...
        multilabel *label180                                         ...
  102:  jump *label91 always 0 0                                     ...
        multilabel *label181                                         ...
  103:  jump *label91 always 0 0                                     ...
        multilabel *label182                                         ...
  104:  jump *label91 always 0 0                                     ...
        multilabel *label183                                         ...
  105:  jump *label15 always 0 0                                     ...
        multilabel *label184                                         ...
  106:  jump *label15 always 0 0                                     ...
        multilabel *label185                                         ...
  107:  jump *label15 always 0 0                                     ...
        multilabel *label186                                         ...
  108:  jump *label15 always 0 0                                     ...
        multilabel *label187                                         ...
  109:  jump *label15 always 0 0                                     ...
        multilabel *label188                                         ...
  110:  jump *label13 always 0 0                                     ...
        multilabel *label189                                         ...
  111:  jump *label91 always 0 0                                     ...
        multilabel *label190                                         ...
  112:  jump *label91 always 0 0                                     ...
        multilabel *label191                                         ...
  113:  jump *label91 always 0 0                                     ...
        multilabel *label192                                         ...
  114:  jump *label91 always 0 0                                     ...
        multilabel *label193                                         ...
  115:  jump *label91 always 0 0                                     ...
        multilabel *label194                                         ...
  116:  jump *label91 always 0 0                                     ...
        multilabel *label195                                         ...
  117:  jump *label91 always 0 0                                     ...
        multilabel *label196                                         ...
  118:  jump *label91 always 0 0                                     ...
        multilabel *label197                                         ...
  119:  jump *label91 always 0 0                                     ...
        multilabel *label198                                         ...
  120:  jump *label91 always 0 0                                     ...
        multilabel *label199                                         ...
  121:  jump *label91 always 0 0                                     ...
        multilabel *label200                                         ...
  122:  jump *label91 always 0 0                                     ...
        multilabel *label201                                         ...
  123:  jump *label91 always 0 0                                     ...
        multilabel *label202                                         ...
  124:  jump *label91 always 0 0                                     ...
        multilabel *label203                                         ...
  125:  jump *label91 always 0 0                                     ...
        multilabel *label204                                         ...
  126:  jump *label91 always 0 0                                     ...
        multilabel *label205                                         ...
  127:  jump *label91 always 0 0                                     ...
        multilabel *label206                                         ...
  128:  jump *label91 always 0 0                                     ...
        multilabel *label207                                         ...
  129:  jump *label91 always 0 0                                     ...
        multilabel *label208                                         ...
  130:  jump *label91 always 0 0                                     ...
        multilabel *label209                                         ...
  131:  jump *label91 always 0 0                                     ...
        multilabel *label210                                         ...
  132:  jump *label91 always 0 0                                     ...
        multilabel *label211                                         ...
  133:  jump *label91 always 0 0                                     ...
        multilabel *label212                                         ...
  134:  jump *label91 always 0 0                                     ...
        multilabel *label213                                         ...
  135:  jump *label91 always 0 0                                     ...
        multilabel *label214                                         ...
  136:  jump *label91 always 0 0                                     ...
        multilabel *label215                                         ...
  137:  jump *label91 always 0 0                                     ...
        multilabel *label216                                         ...
  138:  jump *label91 always 0 0                                     ...
        multilabel *label217                                         ...
  139:  jump *label91 always 0 0                                     ...
        multilabel *label218                                         ...
  140:  jump *label91 always 0 0                                     ...
        multilabel *label219                                         ...
  141:  jump *label91 always 0 0                                     ...
        multilabel *label220                                         ...
  142:  jump *label91 always 0 0                                     ...
        multilabel *label221                                         ...
  143:  jump *label91 always 0 0                                     ...
        multilabel *label222                                         ...
  144:  jump *label91 always 0 0                                     ...
        multilabel *label223                                         ...
  145:  jump *label91 always 0 0                                     ...
        multilabel *label224                                         ...
  146:  jump *label91 always 0 0                                     ...
        multilabel *label225                                         ...
  147:  jump *label91 always 0 0                                     ...
        multilabel *label226                                         ...
  148:  jump *label91 always 0 0                                     ...
        multilabel *label227                                         ...
  149:  jump *label91 always 0 0                                     ...
        multilabel *label228                                         ...
  150:  jump *label91 always 0 0                                     ...
        multilabel *label229                                         ...
  151:  jump *label91 always 0 0                                     ...
        multilabel *label230                                         ...
  152:  jump *label9 always 0 0                                      ...
        multilabel *label231                                         ...
  153:  jump *label11 always 0 0                                     ...
        multilabel *label232                                         ...
  154:  jump *label91 always 0 0                                     ...
        multilabel *label233                                         ...
  155:  jump *label91 always 0 0                                     ...
        multilabel *label234                                         ...
  156:  jump *label91 always 0 0                                     ...
        multilabel *label235                                         ...
  157:  jump *label91 always 0 0                                     ...
        multilabel *label236                                         ...
  158:  jump *label91 always 0 0                                     ...
        multilabel *label237                                         ...
  159:  jump *label91 always 0 0                                     ...
        multilabel *label238                                         ...
  160:  jump *label91 always 0 0                                     ...
        multilabel *label239                                         ...
        label *label17                                               ...
  161:  set .container :initialize:block                             container = block;
  162:  set .measure @totalLiquids                                   measure = @totalLiquids;
  163:  set .maximum @liquidCapacity                                 maximum = @liquidCapacity;
  164:  op add .first :initialize:n 1                                first = n + 1;
  165:  jump *label7 always 0 0                                      case block.@type
        label *label9                                                ...
  166:  set .message :initialize:block                               message = block;
  167:  jump *label7 always 0 0                                      case block.@type
        label *label11                                               ...
  168:  set .switch :initialize:block                                switch = block;
  169:  jump *label7 always 0 0                                      case block.@type
        label *label13                                               ...
  170:  set .sorter :initialize:block                                sorter = block;
  171:  jump *label7 always 0 0                                      case block.@type
        label *label15                                               ...
  172:  set .container :initialize:block                             container = block;
  173:  set .measure @totalItems                                     measure = @totalItems;
  174:  set .maximum @itemCapacity                                   maximum = @itemCapacity;
  175:  op add .first :initialize:n 1                                first = n + 1;
  176:  jump *label7 always 0 0                                      case block.@type
        label *label19                                               ...
  177:  set .container :initialize:block                             container = block;
  178:  set .measure @totalPower                                     measure = @totalPower;
  179:  set .maximum @powerCapacity                                  maximum = @powerCapacity;
  180:  op add .first :initialize:n 1                                first = n + 1;
  181:  jump *label7 always 0 0                                      case block.@type
        label *label21                                               ...
  182:  set .container :initialize:block                             container = block;
  183:  set .measure @powerNetStored                                 measure = @powerNetStored;
  184:  set .maximum @powerNetCapacity                               maximum = @powerNetCapacity;
  185:  op add .first :initialize:n 1                                first = n + 1;
        label *label91                                               case block.@type
        label *label7                                                ...
  186:  op sub :initialize:n :initialize:n 1                         for var n in 0 ... links descending do
  187:  jump *label88 greaterThanEq :initialize:n 0                  ...
        label *label6                                                ...
  188:  print "Message: "                                            println("Message: ", message);
  189:  print .message                                               ...
  190:  print "\nSwitch: "                                           println("Switch: ", switch);
  191:  print .switch                                                ...
  192:  print "\nSorter: "                                           println("Sorter: ", sorter);
  193:  print .sorter                                                ...
  194:  print "\nContainer: "                                        println("Container: ", container);
  195:  print .container                                             ...
  196:  print "\nFirst index: "                                      println("First index: ", first);
  197:  print .first                                                 ...
  198:  print "\n"                                                   ...
  199:  jump *label22 notEqual .message null                         if message == null then println("No message."); repeat = true; end;
  200:  print "No message.\n"                                        ...
  201:  set :initialize:repeat true                                  ...
        label *label22                                               ...
  202:  jump *label24 notEqual .switch null                          if switch == null then println("No switch."); repeat = true; end;
  203:  print "No switch.\n"                                         ...
  204:  set :initialize:repeat true                                  ...
        label *label24                                               ...
  205:  jump *label26 notEqual .container null                       if container == null then println("No container."); repeat = true; end;
  206:  print "No container.\n"                                      ...
  207:  set :initialize:repeat true                                  ...
        label *label26                                               ...
  208:  printflush .message                                          printflush(message);
  209:  jump *label1 notEqual :initialize:repeat false               do
  210:  printflush null                                              printflush(null);
  211:  set *tmp19 false                                             validate(PCT_LOW >= 0 and PCT_LOW <= 100 and PCT_LOW === floor(PCT_LOW), "PCT_LOW must be an integer between 0 to 100.");
  212:  jump *label29 lessThan PCT_LOW 0                             ...
  213:  jump *label29 greaterThan PCT_LOW 100                        ...
  214:  op floor *tmp17 PCT_LOW 0                                    ...
  215:  op strictEqual *tmp19 PCT_LOW *tmp17                         ...
        label *label29                                               ...
  216:  jump *label34 notEqual *tmp19 false                          if !condition then
  217:  print "PCT_LOW must be an integer between 0 to 100."         print(text);
  218:  printflush .message                                          printflush(message);
  219:  stop                                                         stopProcessor();
        label *label34                                               if !condition then
  220:  set *tmp26 false                                             validate(PCT_HIGH >= 0 and PCT_HIGH <= 100 and PCT_HIGH === floor(PCT_HIGH), "PCT_HIGH must be an integer between 0 to 100.");
  221:  jump *label37 lessThan PCT_HIGH 0                            ...
  222:  jump *label37 greaterThan PCT_HIGH 100                       ...
  223:  op floor *tmp24 PCT_HIGH 0                                   ...
  224:  op strictEqual *tmp26 PCT_HIGH *tmp24                        ...
        label *label37                                               ...
  225:  jump *label42 notEqual *tmp26 false                          if !condition then
  226:  print "PCT_HIGH must be an integer between 0 to 100."        print(text);
  227:  printflush .message                                          printflush(message);
  228:  stop                                                         stopProcessor();
        label *label42                                               if !condition then
  229:  jump *label45 lessThan PCT_LOW PCT_HIGH                      ...
  230:  print "PCT_LOW must be less than PCT_HIGH."                  print(text);
  231:  printflush .message                                          printflush(message);
  232:  stop                                                         stopProcessor();
        label *label45                                               if !condition then
  233:  sensor *tmp32 .sorter @type                                  inverted = sorter.@type == @inverted-sorter;
  234:  op equal .inverted *tmp32 @inverted-sorter                   ...
  235:  set .state true                                              state = newState;
  236:  op add .cycles .cycles 1                                     if state != newState then
  237:  op xor .active .inverted true                                active = inverted ^ state;
  238:  set .activeText "\nCurrently inactive:[salmon]"              activeText = active ? "\nCurrently active:[green]" : "\nCurrently inactive:[salmon]";
  239:  jump *label51 equal .active false                            ...
  240:  set .activeText "\nCurrently active:[green]"                 ...
        label *label51                                               ...
  241:  control enabled .switch 0 0 0 0                              switch.enabled = 0;
  242:  sensor *tmp41 .switch @enabled                               while switch.@enabled == 0 do
  243:  jump __start__ notEqual *tmp41 0                             ...
        label *label90                                               ...
  244:  set :start @time                                             var start = @time;
  245:  sensor *tmp43 .container @dead                               if container.@dead          then end(); end;
  246:  jump *label55 equal *tmp43 false                             ...
  247:  end                                                          ...
        label *label55                                               ...
  248:  sensor *tmp45 .message @dead                                 if message.@dead            then end(); end;
  249:  jump *label57 equal *tmp45 false                             ...
  250:  end                                                          ...
        label *label57                                               ...
  251:  sensor *tmp47 .switch @dead                                  if switch.@dead             then end(); end;
  252:  jump *label59 equal *tmp47 false                             ...
  253:  end                                                          ...
        label *label59                                               ...
  254:  jump *label61 equal .sorter false                            if sorter and sorter.@dead  then end(); end;
  255:  sensor *tmp49 .sorter @dead                                  ...
  256:  jump *label61 equal *tmp49 false                             ...
  257:  end                                                          ...
        label *label61                                               ...
  258:  jump *label65 equal .links @links                            if links != @links          then end(); end;
  259:  end                                                          ...
        label *label65                                               ...
  260:  sensor :item .sorter @config                                 var item = sorter.@config;
  261:  op equal *tmp54 :item null                                   if item == null || measure != @totalItems then
  262:  op notEqual *tmp55 .measure @totalItems                      ...
  263:  op or *tmp56 *tmp54 *tmp55                                   ...
  264:  jump *label67 equal *tmp56 false                             ...
  265:  print "Measuring [gold]total[] in "                          print($"Measuring [gold]total[] in $container");
  266:  print .container                                             ...
  267:  sensor :amount .container .measure                           amount = container.sensor(measure);
  268:  jump *label68 always 0 0                                     if item == null || measure != @totalItems then
        label *label67                                               ...
  269:  print "Measuring [gold]"                                     print($"Measuring [gold]$item[] in $container");
  270:  print :item                                                  ...
  271:  print "[] in "                                               ...
  272:  print .container                                             ...
  273:  sensor :amount .container :item                              amount = container.sensor(item);
        label *label68                                               if item == null || measure != @totalItems then
  274:  op mul *tmp60 100 :amount                                    var pct = (100 * amount) \ container.sensor(maximum);
  275:  sensor *tmp61 .container .maximum                            ...
  276:  op idiv :pct *tmp60 *tmp61                                   ...
  277:  jump *label69 greaterThan :pct PCT_LOW                       if pct <= PCT_LOW then
  278:  jump *label70 equal .state true                              if state != newState then
  279:  set .state true                                              state = newState;
  280:  op add .cycles .cycles 1                                     if state != newState then
  281:  op xor .active .inverted true                                active = inverted ^ state;
  282:  set .activeText "\nCurrently inactive:[salmon]"              activeText = active ? "\nCurrently active:[green]" : "\nCurrently inactive:[salmon]";
  283:  jump *label70 equal .active false                            ...
  284:  set .activeText "\nCurrently active:[green]"                 ...
  285:  jump *label70 always 0 0                                     if pct <= PCT_LOW then
        label *label69                                               ...
  286:  jump *label76 lessThan :pct PCT_HIGH                         elsif pct >= PCT_HIGH then
  287:  jump *label79 equal .state false                             if state != newState then
  288:  set .state false                                             state = newState;
  289:  op add .cycles .cycles 1                                     if state != newState then
  290:  set .active .inverted                                        active = inverted ^ state;
  291:  set .activeText "\nCurrently inactive:[salmon]"              activeText = active ? "\nCurrently active:[green]" : "\nCurrently inactive:[salmon]";
  292:  jump *label82 notEqual *tmp32 @inverted-sorter               ...
  293:  set .activeText "\nCurrently active:[green]"                 ...
        label *label82                                               ...
        label *label79                                               if state != newState then
        label *label76                                               elsif pct >= PCT_HIGH then
        label *label70                                               if pct <= PCT_LOW then
  294:  print "\nLevel: [gold]"                                      print($"\nLevel: [gold]$pct%[]");
  295:  print :pct                                                   ...
  296:  print "%[]"                                                  ...
  297:  jump *label83 notEqual *tmp32 @inverted-sorter               if inverted then
  298:  print "\nActivate above [green]"                             print($"\nActivate above [green]$PCT_HIGH%[]");
  299:  print PCT_HIGH                                               ...
  300:  print "%[]\nDeactivate below [salmon]"                       print($"\nDeactivate below [salmon]$PCT_LOW%[]");
  301:  print PCT_LOW                                                ...
  302:  print "%[]"                                                  ...
  303:  jump *label84 always 0 0                                     if inverted then
        label *label83                                               ...
  304:  print "\nActivate below [green]"                             print($"\nActivate below [green]$PCT_LOW%[]");
  305:  print PCT_LOW                                                ...
  306:  print "%[]\nDeactivate above [salmon]"                       print($"\nDeactivate above [salmon]$PCT_HIGH%[]");
  307:  print PCT_HIGH                                               ...
  308:  print "%[]"                                                  ...
        label *label84                                               if inverted then
  309:  print .activeText                                            print(activeText);
  310:  set :n .first                                                for var n in first ... links do
  311:  jump *label87 greaterThanEq .first .links                    ...
        label *label89                                               ...
  312:  getlink :block :n                                            var block = getlink(n);
  313:  control enabled :block .active 0 0 0                         block.enabled = active;
  314:  print "\n    "                                               print("\n    ", block);
  315:  print :block                                                 ...
  316:  op add :n :n 1                                               for var n in first ... links do
  317:  jump *label89 lessThan :n .links                             ...
        label *label87                                               ...
  318:  print "[]\n# of cycles: "                                    print($"[]\n# of cycles: $cycles");
  319:  print .cycles                                                ...
  320:  op sub *tmp82 @time :start                                   print($"\n[lightgray]Loop: $ ms", floor(@time - start));
  321:  op floor *tmp83 *tmp82 0                                     ...
  322:  print "\n[lightgray]Loop: "                                  ...
  323:  print *tmp83                                                 ...
  324:  print " ms"                                                  ...
  325:  printflush .message                                          printflush(message);
  326:  sensor *tmp41 .switch @enabled                               while switch.@enabled == 0 do
  327:  jump *label90 equal *tmp41 0                                 ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   221     1x    221,0  inline void initialize()
    75     1x     75,0  <no function>
    20     3x      6,7  inline void setState(in newState)
    12     3x      4,0  inline void validate(in condition, in text)

Performance: parsed in 224 ms, compiled in 211 ms, optimized in 424 ms, run in 65 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Configuring regulator...
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Sorter: null
Container: null
First index: null
No switch.
No container.

[--- Previous segment repeated 226,71 times ---]

Execution step limit of 100000 exceeded.
