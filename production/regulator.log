   346 instructions before optimizations.
    20 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    47 instructions eliminated by Dead Code Elimination (4 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
    14 instructions eliminated by Jump Optimization (4 iterations).
    20 instructions eliminated by Single Step Elimination (3 passes, 7 iterations).
     3 instructions eliminated by If Expression Optimization (3 iterations).
     9 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
     7 instructions eliminated by Jump Straightening (4 iterations).
     3 instructions updated by JumpThreading.
    25 instructions eliminated by Print Merging.
   200 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 771):
  * Replicate loop condition at line 36:5                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    15 print :initialize.0:block
    16 print "\n"
    17 sensor *tmp3 :initialize.0:block @type
-    * set *tmp4 *tmp3
-    * jump *label9 equal *tmp4 @message
+   18 jump *label9 equal *tmp3 @message
    19 jump *label8 always
    20 label *label9
    21 set .message :initialize.0:block
    22 set *tmp2 .message
    23 jump *label7 always
    24 label *label8
-    * jump *label11 equal *tmp4 @switch
+   25 jump *label11 equal *tmp3 @switch
    26 jump *label10 always
    27 label *label11
    28 set .switch :initialize.0:block
    29 set *tmp2 .switch
    30 jump *label7 always
    31 label *label10
-    * jump *label13 equal *tmp4 @sorter
-    * jump *label13 equal *tmp4 @inverted-sorter
-    * jump *label13 equal *tmp4 @unloader
+   32 jump *label13 equal *tmp3 @sorter
+   33 jump *label13 equal *tmp3 @inverted-sorter
+   34 jump *label13 equal *tmp3 @unloader
    35 jump *label12 always
    36 label *label13
    37 set .sorter :initialize.0:block
    38 set *tmp2 .sorter
    39 jump *label7 always
    40 label *label12
-    * jump *label15 equal *tmp4 @vault
-    * jump *label15 equal *tmp4 @container
-    * jump *label15 equal *tmp4 @core-shard
-    * jump *label15 equal *tmp4 @core-foundation
-    * jump *label15 equal *tmp4 @core-nucleus
+   41 jump *label15 equal *tmp3 @vault
+   42 jump *label15 equal *tmp3 @container
+   43 jump *label15 equal *tmp3 @core-shard
+   44 jump *label15 equal *tmp3 @core-foundation
+   45 jump *label15 equal *tmp3 @core-nucleus
    46 jump *label14 always
    47 label *label15
    48 set .container :initialize.0:block
 
    53 set *tmp2 .first
    54 jump *label7 always
    55 label *label14
-    * jump *label17 equal *tmp4 @liquid-tank
-    * jump *label17 equal *tmp4 @liquid-container
-    * jump *label17 equal *tmp4 @liquid-router
+   56 jump *label17 equal *tmp3 @liquid-tank
+   57 jump *label17 equal *tmp3 @liquid-container
+   58 jump *label17 equal *tmp3 @liquid-router
    59 jump *label16 always
    60 label *label17
    61 set .container :initialize.0:block
 
    66 set *tmp2 .first
    67 jump *label7 always
    68 label *label16
-    * jump *label19 equal *tmp4 @battery
-    * jump *label19 equal *tmp4 @battery-large
+   69 jump *label19 equal *tmp3 @battery
+   70 jump *label19 equal *tmp3 @battery-large
    71 jump *label18 always
    72 label *label19
    73 set .container :initialize.0:block
 
    78 set *tmp2 .first
    79 jump *label7 always
    80 label *label18
-    * jump *label21 equal *tmp4 @power-node
-    * jump *label21 equal *tmp4 @power-node-large
-    * jump *label21 equal *tmp4 @surge-tower
+   81 jump *label21 equal *tmp3 @power-node
+   82 jump *label21 equal *tmp3 @power-node-large
+   83 jump *label21 equal *tmp3 @surge-tower
    84 jump *label20 always
    85 label *label21
    86 set .container :initialize.0:block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-45 instructions):
 
    19 jump *label8 always
    20 label *label9
    21 set .message :initialize.0:block
-    * set *tmp2 .message
    22 jump *label7 always
    23 label *label8
    24 jump *label11 equal *tmp3 @switch
    25 jump *label10 always
    26 label *label11
    27 set .switch :initialize.0:block
-    * set *tmp2 .switch
    28 jump *label7 always
    29 label *label10
    30 jump *label13 equal *tmp3 @sorter
 
    33 jump *label12 always
    34 label *label13
    35 set .sorter :initialize.0:block
-    * set *tmp2 .sorter
    36 jump *label7 always
    37 label *label12
    38 jump *label15 equal *tmp3 @vault
 
    47 set .maximum @itemCapacity
    48 op add *tmp5 :initialize.0:n 1
    49 set .first *tmp5
-    * set *tmp2 .first
    50 jump *label7 always
    51 label *label14
    52 jump *label17 equal *tmp3 @liquid-tank
 
    59 set .maximum @liquidCapacity
    60 op add *tmp6 :initialize.0:n 1
    61 set .first *tmp6
-    * set *tmp2 .first
    62 jump *label7 always
    63 label *label16
    64 jump *label19 equal *tmp3 @battery
 
    70 set .maximum @powerCapacity
    71 op add *tmp7 :initialize.0:n 1
    72 set .first *tmp7
-    * set *tmp2 .first
    73 jump *label7 always
    74 label *label18
    75 jump *label21 equal *tmp3 @power-node
 
    82 set .maximum @powerNetCapacity
    83 op add *tmp8 :initialize.0:n 1
    84 set .first *tmp8
-    * set *tmp2 .first
    85 jump *label7 always
    86 label *label20
-    * set *tmp2 null
    87 label *label7
    88 label *label5
    89 op sub :initialize.0:n :initialize.0:n 1
 
   109 print "No message."
   110 print "\n"
   111 set :initialize.0:repeat true
-    * set *tmp10 :initialize.0:repeat
   112 jump *label23 always
   113 label *label22
-    * set *tmp10 null
   114 label *label23
   115 op equal *tmp11 .switch null
   116 jump *label24 equal *tmp11 false
   117 print "No switch."
   118 print "\n"
   119 set :initialize.0:repeat true
-    * set *tmp12 :initialize.0:repeat
   120 jump *label25 always
   121 label *label24
-    * set *tmp12 null
   122 label *label25
   123 op equal *tmp13 .container null
   124 jump *label26 equal *tmp13 false
   125 print "No container."
   126 print "\n"
   127 set :initialize.0:repeat true
-    * set *tmp14 :initialize.0:repeat
   128 jump *label27 always
   129 label *label26
-    * set *tmp14 null
   130 label *label27
   131 printflush .message
   132 label *label2
 
   146 print :validate.0:text
   147 printflush .message
   148 stop
-    * set *tmp22 null
   149 jump *label30 always
   150 label *label29
-    * set *tmp22 null
   151 label *label30
   152 label *label28
   153 op greaterThanEq *tmp23 PCT_HIGH 0
 
   163 print :validate.1:text
   164 printflush .message
   165 stop
-    * set *tmp30 null
   166 jump *label33 always
   167 label *label32
-    * set *tmp30 null
   168 label *label33
   169 label *label31
   170 op lessThan *tmp31 PCT_LOW PCT_HIGH
 
   175 print :validate.2:text
   176 printflush .message
   177 stop
-    * set *tmp33 null
   178 jump *label36 always
   179 label *label35
-    * set *tmp33 null
   180 label *label36
   181 label *label34
   182 sensor *tmp34 .sorter @type
 
   186 op notEqual *tmp36 .state :setState.0:newState
   187 jump *label38 equal *tmp36 false
   188 set .state :setState.0:newState
-    * set *tmp38 .cycles
   189 op add .cycles .cycles 1
   190 op xor *tmp39 .inverted .state
   191 set .active *tmp39
 
   196 set *tmp40 "\nCurrently inactive:[salmon]"
   197 label *label41
   198 set .activeText *tmp40
-    * set *tmp37 .activeText
   199 jump *label39 always
   200 label *label38
-    * set *tmp37 null
   201 label *label39
   202 label *label37
   203 label *label0
 
   211 sensor *tmp45 .container @dead
   212 jump *label45 equal *tmp45 false
   213 end
-    * set *tmp46 null
   214 jump *label46 always
   215 label *label45
-    * set *tmp46 null
   216 label *label46
   217 sensor *tmp47 .message @dead
   218 jump *label47 equal *tmp47 false
   219 end
-    * set *tmp48 null
   220 jump *label48 always
   221 label *label47
-    * set *tmp48 null
   222 label *label48
   223 sensor *tmp49 .switch @dead
   224 jump *label49 equal *tmp49 false
   225 end
-    * set *tmp50 null
   226 jump *label50 always
   227 label *label49
-    * set *tmp50 null
   228 label *label50
   229 sensor *tmp51 .sorter @dead
   230 op land *tmp52 .sorter *tmp51
   231 jump *label51 equal *tmp52 false
   232 end
-    * set *tmp53 null
   233 jump *label52 always
   234 label *label51
-    * set *tmp53 null
   235 label *label52
   236 op notEqual *tmp54 .links @links
   237 jump *label53 equal *tmp54 false
   238 end
-    * set *tmp55 null
   239 jump *label54 always
   240 label *label53
-    * set *tmp55 null
   241 label *label54
   242 sensor *tmp56 .sorter @config
   243 set :item *tmp56
 
   251 print .container
   252 sensor *tmp62 .container .measure
   253 set :amount *tmp62
-    * set *tmp61 :amount
   254 jump *label56 always
   255 label *label55
   256 print "Measuring [gold]"
 
   260 print .container
   261 sensor *tmp63 .container :item
   262 set :amount *tmp63
-    * set *tmp61 :amount
   263 label *label56
   264 op mul *tmp64 100 :amount
   265 sensor *tmp65 .container .maximum
 
   271 op notEqual *tmp69 .state :setState.1:newState
   272 jump *label60 equal *tmp69 false
   273 set .state :setState.1:newState
-    * set *tmp71 .cycles
   274 op add .cycles .cycles 1
   275 op xor *tmp72 .inverted .state
   276 set .active *tmp72
 
   281 set *tmp73 "\nCurrently inactive:[salmon]"
   282 label *label63
   283 set .activeText *tmp73
-    * set *tmp70 .activeText
   284 jump *label61 always
   285 label *label60
-    * set *tmp70 null
   286 label *label61
   287 label *label59
-    * set *tmp68 null
   288 jump *label58 always
   289 label *label57
   290 op greaterThanEq *tmp74 :pct PCT_HIGH
 
   293 op notEqual *tmp76 .state :setState.2:newState
   294 jump *label67 equal *tmp76 false
   295 set .state :setState.2:newState
-    * set *tmp78 .cycles
   296 op add .cycles .cycles 1
   297 op xor *tmp79 .inverted .state
   298 set .active *tmp79
 
   303 set *tmp80 "\nCurrently inactive:[salmon]"
   304 label *label70
   305 set .activeText *tmp80
-    * set *tmp77 .activeText
   306 jump *label68 always
   307 label *label67
-    * set *tmp77 null
   308 label *label68
   309 label *label66
   310 set *tmp75 null
 
   312 label *label64
   313 set *tmp75 null
   314 label *label65
-    * set *tmp68 *tmp75
   315 label *label58
   316 print "\n"
   317 print "Level: [gold]"
 
   329 print PCT_LOW
   330 print "%"
   331 print "[]"
-    * set *tmp81 null
   332 jump *label72 always
   333 label *label71
   334 print "\n"
 
   341 print PCT_HIGH
   342 print "%"
   343 print "[]"
-    * set *tmp81 null
   344 label *label72
   345 print .activeText
   346 set *tmp82 .links

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
   307 label *label67
   308 label *label68
   309 label *label66
-    * set *tmp75 null
   310 jump *label65 always
   311 label *label64
-    * set *tmp75 null
   312 label *label65
   313 label *label58
   314 print "\n"

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-20 instructions):
 
     4 set :initialize.0:repeat false
     5 print "Configuring regulator..."
     6 print "\n"
-    * set *tmp0 @links
-    * set .links *tmp0
+    7 set .links @links
     8 op sub :initialize.0:n .links 1
     9 label *label4
    10 jump *label6 lessThan :initialize.0:n 0
-    * getlink *tmp1 :initialize.0:n
-    * set :initialize.0:block *tmp1
+   11 getlink :initialize.0:block :initialize.0:n
    12 print "Found: "
    13 print :initialize.0:block
    14 print "\n"
 
    43 set .container :initialize.0:block
    44 set .measure @totalItems
    45 set .maximum @itemCapacity
-    * op add *tmp5 :initialize.0:n 1
-    * set .first *tmp5
+   46 op add .first :initialize.0:n 1
    47 jump *label7 always
    48 label *label14
    49 jump *label17 equal *tmp3 @liquid-tank
 
    54 set .container :initialize.0:block
    55 set .measure @totalLiquids
    56 set .maximum @liquidCapacity
-    * op add *tmp6 :initialize.0:n 1
-    * set .first *tmp6
+   57 op add .first :initialize.0:n 1
    58 jump *label7 always
    59 label *label16
    60 jump *label19 equal *tmp3 @battery
 
    64 set .container :initialize.0:block
    65 set .measure @totalPower
    66 set .maximum @powerCapacity
-    * op add *tmp7 :initialize.0:n 1
-    * set .first *tmp7
+   67 op add .first :initialize.0:n 1
    68 jump *label7 always
    69 label *label18
    70 jump *label21 equal *tmp3 @power-node
 
    75 set .container :initialize.0:block
    76 set .measure @powerNetStored
    77 set .maximum @powerNetCapacity
-    * op add *tmp8 :initialize.0:n 1
-    * set .first *tmp8
+   78 op add .first :initialize.0:n 1
    79 jump *label7 always
    80 label *label20
    81 label *label7
 
   132 op land *tmp17 *tmp15 *tmp16
   133 op floor *tmp18 PCT_LOW
   134 op strictEqual *tmp19 PCT_LOW *tmp18
-    * op land *tmp20 *tmp17 *tmp19
-    * set :validate.0:condition *tmp20
+  135 op land :validate.0:condition *tmp17 *tmp19
   136 set :validate.0:text "PCT_LOW must be an integer between 0 to 100."
   137 op equal *tmp21 :validate.0:condition false
   138 jump *label29 equal *tmp21 false
 
   148 op land *tmp25 *tmp23 *tmp24
   149 op floor *tmp26 PCT_HIGH
   150 op strictEqual *tmp27 PCT_HIGH *tmp26
-    * op land *tmp28 *tmp25 *tmp27
-    * set :validate.1:condition *tmp28
+  151 op land :validate.1:condition *tmp25 *tmp27
   152 set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
   153 op equal *tmp29 :validate.1:condition false
   154 jump *label32 equal *tmp29 false
 
   159 label *label32
   160 label *label33
   161 label *label31
-    * op lessThan *tmp31 PCT_LOW PCT_HIGH
-    * set :validate.2:condition *tmp31
+  162 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
   163 set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
   164 op equal *tmp32 :validate.2:condition false
   165 jump *label35 equal *tmp32 false
 
   171 label *label36
   172 label *label34
   173 sensor *tmp34 .sorter @type
-    * op equal *tmp35 *tmp34 @inverted-sorter
-    * set .inverted *tmp35
+  174 op equal .inverted *tmp34 @inverted-sorter
   175 set :setState.0:newState true
   176 op notEqual *tmp36 .state :setState.0:newState
   177 jump *label38 equal *tmp36 false
   178 set .state :setState.0:newState
   179 op add .cycles .cycles 1
-    * op xor *tmp39 .inverted .state
-    * set .active *tmp39
+  180 op xor .active .inverted .state
   181 jump *label40 equal .active false
   182 set *tmp40 "\nCurrently active:[green]"
   183 jump *label41 always
 
   190 label *label39
   191 label *label37
   192 label *label0
-    * set *tmp41 .switch
-    * control enabled *tmp41 0
+  193 control enabled .switch 0
   194 label *label42
   195 sensor *tmp43 .switch @enabled
   196 op equal *tmp44 *tmp43 0
 
   227 jump *label54 always
   228 label *label53
   229 label *label54
-    * sensor *tmp56 .sorter @config
-    * set :item *tmp56
+  230 sensor :item .sorter @config
   231 op equal *tmp57 :item null
   232 op notEqual *tmp58 .measure @totalItems
   233 op or *tmp60 *tmp57 *tmp58
 
   236 set :item .measure
   237 print "Measuring [gold]total[] in "
   238 print .container
-    * sensor *tmp62 .container .measure
-    * set :amount *tmp62
+  239 sensor :amount .container .measure
   240 jump *label56 always
   241 label *label55
   242 print "Measuring [gold]"
 
   244 print "["
   245 print "] in "
   246 print .container
-    * sensor *tmp63 .container :item
-    * set :amount *tmp63
+  247 sensor :amount .container :item
   248 label *label56
   249 op mul *tmp64 100 :amount
   250 sensor *tmp65 .container .maximum
-    * op idiv *tmp66 *tmp64 *tmp65
-    * set :pct *tmp66
+  251 op idiv :pct *tmp64 *tmp65
   252 op lessThanEq *tmp67 :pct PCT_LOW
   253 jump *label57 equal *tmp67 false
   254 set :setState.1:newState true
 
   256 jump *label60 equal *tmp69 false
   257 set .state :setState.1:newState
   258 op add .cycles .cycles 1
-    * op xor *tmp72 .inverted .state
-    * set .active *tmp72
+  259 op xor .active .inverted .state
   260 jump *label62 equal .active false
   261 set *tmp73 "\nCurrently active:[green]"
   262 jump *label63 always
 
   277 jump *label67 equal *tmp76 false
   278 set .state :setState.2:newState
   279 op add .cycles .cycles 1
-    * op xor *tmp79 .inverted .state
-    * set .active *tmp79
+  280 op xor .active .inverted .state
   281 jump *label69 equal .active false
   282 set *tmp80 "\nCurrently active:[green]"
   283 jump *label70 always
 
   327 set :n .first
   328 label *label73
   329 jump *label75 greaterThanEq :n *tmp82
-    * getlink *tmp83 :n
-    * set :block *tmp83
-    * set *tmp84 :block
-    * control enabled *tmp84 .active
+  330 getlink :block :n
+  331 control enabled :block .active
   332 print "\n    "
   333 print :block
   334 label *label74

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    13 print :initialize.0:block
    14 print "\n"
    15 sensor *tmp3 :initialize.0:block @type
-    * jump *label9 equal *tmp3 @message
-    * jump *label8 always
+   16 jump *label8 notEqual *tmp3 @message
    17 label *label9
    18 set .message :initialize.0:block
    19 jump *label7 always
    20 label *label8
-    * jump *label11 equal *tmp3 @switch
-    * jump *label10 always
+   21 jump *label10 notEqual *tmp3 @switch
    22 label *label11
    23 set .switch :initialize.0:block
    24 jump *label7 always
    25 label *label10
    26 jump *label13 equal *tmp3 @sorter
    27 jump *label13 equal *tmp3 @inverted-sorter
-    * jump *label13 equal *tmp3 @unloader
-    * jump *label12 always
+   28 jump *label12 notEqual *tmp3 @unloader
    29 label *label13
    30 set .sorter :initialize.0:block
    31 jump *label7 always
 
    34 jump *label15 equal *tmp3 @container
    35 jump *label15 equal *tmp3 @core-shard
    36 jump *label15 equal *tmp3 @core-foundation
-    * jump *label15 equal *tmp3 @core-nucleus
-    * jump *label14 always
+   37 jump *label14 notEqual *tmp3 @core-nucleus
    38 label *label15
    39 set .container :initialize.0:block
    40 set .measure @totalItems
 
    44 label *label14
    45 jump *label17 equal *tmp3 @liquid-tank
    46 jump *label17 equal *tmp3 @liquid-container
-    * jump *label17 equal *tmp3 @liquid-router
-    * jump *label16 always
+   47 jump *label16 notEqual *tmp3 @liquid-router
    48 label *label17
    49 set .container :initialize.0:block
    50 set .measure @totalLiquids
 
    53 jump *label7 always
    54 label *label16
    55 jump *label19 equal *tmp3 @battery
-    * jump *label19 equal *tmp3 @battery-large
-    * jump *label18 always
+   56 jump *label18 notEqual *tmp3 @battery-large
    57 label *label19
    58 set .container :initialize.0:block
    59 set .measure @totalPower
 
    63 label *label18
    64 jump *label21 equal *tmp3 @power-node
    65 jump *label21 equal *tmp3 @power-node-large
-    * jump *label21 equal *tmp3 @surge-tower
-    * jump *label20 always
+   66 jump *label20 notEqual *tmp3 @surge-tower
    67 label *label21
    68 set .container :initialize.0:block
    69 set .measure @powerNetStored

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-14 instructions):
 
    91 print "First index: "
    92 print .first
    93 print "\n"
-    * op equal *tmp9 .message null
-    * jump *label22 equal *tmp9 false
+   94 jump *label22 notEqual .message null
    95 print "No message."
    96 print "\n"
    97 set :initialize.0:repeat true
    98 jump *label23 always
    99 label *label22
   100 label *label23
-    * op equal *tmp11 .switch null
-    * jump *label24 equal *tmp11 false
+  101 jump *label24 notEqual .switch null
   102 print "No switch."
   103 print "\n"
   104 set :initialize.0:repeat true
   105 jump *label25 always
   106 label *label24
   107 label *label25
-    * op equal *tmp13 .container null
-    * jump *label26 equal *tmp13 false
+  108 jump *label26 notEqual .container null
   109 print "No container."
   110 print "\n"
   111 set :initialize.0:repeat true
 
   124 op strictEqual *tmp19 PCT_LOW *tmp18
   125 op land :validate.0:condition *tmp17 *tmp19
   126 set :validate.0:text "PCT_LOW must be an integer between 0 to 100."
-    * op equal *tmp21 :validate.0:condition false
-    * jump *label29 equal *tmp21 false
+  127 jump *label29 notEqual :validate.0:condition false
   128 print :validate.0:text
   129 printflush .message
   130 stop
 
   139 op strictEqual *tmp27 PCT_HIGH *tmp26
   140 op land :validate.1:condition *tmp25 *tmp27
   141 set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
-    * op equal *tmp29 :validate.1:condition false
-    * jump *label32 equal *tmp29 false
+  142 jump *label32 notEqual :validate.1:condition false
   143 print :validate.1:text
   144 printflush .message
   145 stop
 
   149 label *label31
   150 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
   151 set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
-    * op equal *tmp32 :validate.2:condition false
-    * jump *label35 equal *tmp32 false
+  152 jump *label35 notEqual :validate.2:condition false
   153 print :validate.2:text
   154 printflush .message
   155 stop
 
   160 sensor *tmp34 .sorter @type
   161 op equal .inverted *tmp34 @inverted-sorter
   162 set :setState.0:newState true
-    * op notEqual *tmp36 .state :setState.0:newState
-    * jump *label38 equal *tmp36 false
+  163 jump *label38 equal .state :setState.0:newState
   164 set .state :setState.0:newState
   165 op add .cycles .cycles 1
   166 op xor .active .inverted .state
 
   179 control enabled .switch 0
   180 label *label42
   181 sensor *tmp43 .switch @enabled
-    * op equal *tmp44 *tmp43 0
-    * jump *label44 equal *tmp44 false
+  182 jump *label44 notEqual *tmp43 0
   183 set :start @time
   184 sensor *tmp45 .container @dead
   185 jump *label45 equal *tmp45 false
 
   206 jump *label52 always
   207 label *label51
   208 label *label52
-    * op notEqual *tmp54 .links @links
-    * jump *label53 equal *tmp54 false
+  209 jump *label53 equal .links @links
   210 end
   211 jump *label54 always
   212 label *label53
 
   215 op equal *tmp57 :item null
   216 op notEqual *tmp58 .measure @totalItems
   217 op or *tmp60 *tmp57 *tmp58
-    * op notEqual *tmp59 *tmp60 false
-    * jump *label55 equal *tmp59 false
+  218 jump *label55 equal *tmp60 false
   219 set :item .measure
   220 print "Measuring [gold]total[] in "
   221 print .container
 
   232 op mul *tmp64 100 :amount
   233 sensor *tmp65 .container .maximum
   234 op idiv :pct *tmp64 *tmp65
-    * op lessThanEq *tmp67 :pct PCT_LOW
-    * jump *label57 equal *tmp67 false
+  235 jump *label57 greaterThan :pct PCT_LOW
   236 set :setState.1:newState true
-    * op notEqual *tmp69 .state :setState.1:newState
-    * jump *label60 equal *tmp69 false
+  237 jump *label60 equal .state :setState.1:newState
   238 set .state :setState.1:newState
   239 op add .cycles .cycles 1
   240 op xor .active .inverted .state
 
   251 label *label59
   252 jump *label58 always
   253 label *label57
-    * op greaterThanEq *tmp74 :pct PCT_HIGH
-    * jump *label64 equal *tmp74 false
+  254 jump *label64 lessThan :pct PCT_HIGH
   255 set :setState.2:newState false
-    * op notEqual *tmp76 .state :setState.2:newState
-    * jump *label67 equal *tmp76 false
+  256 jump *label67 equal .state :setState.2:newState
   257 set .state :setState.2:newState
   258 op add .cycles .cycles 1
   259 op xor .active .inverted .state

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-16 instructions):
 
    69 set .measure @powerNetStored
    70 set .maximum @powerNetCapacity
    71 op add .first :initialize.0:n 1
-    * jump *label7 always
    72 label *label20
    73 label *label7
    74 label *label5
 
    94 print "No message."
    95 print "\n"
    96 set :initialize.0:repeat true
-    * jump *label23 always
    97 label *label22
    98 label *label23
    99 jump *label24 notEqual .switch null
   100 print "No switch."
   101 print "\n"
   102 set :initialize.0:repeat true
-    * jump *label25 always
   103 label *label24
   104 label *label25
   105 jump *label26 notEqual .container null
   106 print "No container."
   107 print "\n"
   108 set :initialize.0:repeat true
-    * jump *label27 always
   109 label *label26
   110 label *label27
   111 printflush .message
 
   124 print :validate.0:text
   125 printflush .message
   126 stop
-    * jump *label30 always
   127 label *label29
   128 label *label30
   129 label *label28
 
   138 print :validate.1:text
   139 printflush .message
   140 stop
-    * jump *label33 always
   141 label *label32
   142 label *label33
   143 label *label31
 
   147 print :validate.2:text
   148 printflush .message
   149 stop
-    * jump *label36 always
   150 label *label35
   151 label *label36
   152 label *label34
 
   164 set *tmp40 "\nCurrently inactive:[salmon]"
   165 label *label41
   166 set .activeText *tmp40
-    * jump *label39 always
   167 label *label38
   168 label *label39
   169 label *label37
 
   176 sensor *tmp45 .container @dead
   177 jump *label45 equal *tmp45 false
   178 end
-    * jump *label46 always
   179 label *label45
   180 label *label46
   181 sensor *tmp47 .message @dead
   182 jump *label47 equal *tmp47 false
   183 end
-    * jump *label48 always
   184 label *label47
   185 label *label48
   186 sensor *tmp49 .switch @dead
   187 jump *label49 equal *tmp49 false
   188 end
-    * jump *label50 always
   189 label *label49
   190 label *label50
   191 sensor *tmp51 .sorter @dead
   192 op land *tmp52 .sorter *tmp51
   193 jump *label51 equal *tmp52 false
   194 end
-    * jump *label52 always
   195 label *label51
   196 label *label52
   197 jump *label53 equal .links @links
   198 end
-    * jump *label54 always
   199 label *label53
   200 label *label54
   201 sensor :item .sorter @config
 
   232 set *tmp73 "\nCurrently inactive:[salmon]"
   233 label *label63
   234 set .activeText *tmp73
-    * jump *label61 always
   235 label *label60
   236 label *label61
   237 label *label59
 
   250 set *tmp80 "\nCurrently inactive:[salmon]"
   251 label *label70
   252 set .activeText *tmp80
-    * jump *label68 always
   253 label *label67
   254 label *label68
   255 label *label66
-    * jump *label65 always
   256 label *label64
   257 label *label65
   258 label *label58

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
   121 op land :validate.0:condition *tmp17 *tmp19
   122 set :validate.0:text "PCT_LOW must be an integer between 0 to 100."
   123 jump *label29 notEqual :validate.0:condition false
-    * print :validate.0:text
+  124 print "PCT_LOW must be an integer between 0 to 100."
   125 printflush .message
   126 stop
   127 label *label29
 
   135 op land :validate.1:condition *tmp25 *tmp27
   136 set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
   137 jump *label32 notEqual :validate.1:condition false
-    * print :validate.1:text
+  138 print "PCT_HIGH must be an integer between 0 to 100."
   139 printflush .message
   140 stop
   141 label *label32
 
   144 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
   145 set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
   146 jump *label35 notEqual :validate.2:condition false
-    * print :validate.2:text
+  147 print "PCT_LOW must be less than PCT_HIGH."
   148 printflush .message
   149 stop
   150 label *label35
 
   153 sensor *tmp34 .sorter @type
   154 op equal .inverted *tmp34 @inverted-sorter
   155 set :setState.0:newState true
-    * jump *label38 equal .state :setState.0:newState
-    * set .state :setState.0:newState
+  156 jump *label38 equal false true
+  157 set .state true
   158 op add .cycles .cycles 1
-    * op xor .active .inverted .state
+  159 op xor .active .inverted :setState.0:newState
   160 jump *label40 equal .active false
   161 set *tmp40 "\nCurrently active:[green]"
   162 jump *label41 always
 
   203 op notEqual *tmp58 .measure @totalItems
   204 op or *tmp60 *tmp57 *tmp58
   205 jump *label55 equal *tmp60 false
-    * set :item .measure
   206 print "Measuring [gold]total[] in "
   207 print .container
   208 sensor :amount .container .measure
 
   220 op idiv :pct *tmp64 *tmp65
   221 jump *label57 greaterThan :pct PCT_LOW
   222 set :setState.1:newState true
-    * jump *label60 equal .state :setState.1:newState
-    * set .state :setState.1:newState
+  223 jump *label60 equal .state true
+  224 set .state true
   225 op add .cycles .cycles 1
-    * op xor .active .inverted .state
+  226 op xor .active .inverted :setState.1:newState
   227 jump *label62 equal .active false
   228 set *tmp73 "\nCurrently active:[green]"
   229 jump *label63 always
 
   238 label *label57
   239 jump *label64 lessThan :pct PCT_HIGH
   240 set :setState.2:newState false
-    * jump *label67 equal .state :setState.2:newState
-    * set .state :setState.2:newState
+  241 jump *label67 equal .state false
+  242 set .state false
   243 op add .cycles .cycles 1
-    * op xor .active .inverted .state
+  244 op xor .active .inverted :setState.2:newState
   245 jump *label69 equal .active false
   246 set *tmp80 "\nCurrently active:[green]"
   247 jump *label70 always
 
   288 set *tmp82 .links
   289 set :n .first
   290 label *label73
-    * jump *label75 greaterThanEq :n *tmp82
+  291 jump *label75 greaterThanEq :n .links
   292 getlink :block :n
   293 control enabled :block .active
   294 print "\n    "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
     0 set PCT_LOW 60
     1 set PCT_HIGH 80
-    * set .state false
     2 label *label1
     3 set :initialize.0:repeat false
     4 print "Configuring regulator..."
 
   118 op floor *tmp18 PCT_LOW
   119 op strictEqual *tmp19 PCT_LOW *tmp18
   120 op land :validate.0:condition *tmp17 *tmp19
-    * set :validate.0:text "PCT_LOW must be an integer between 0 to 100."
   121 jump *label29 notEqual :validate.0:condition false
   122 print "PCT_LOW must be an integer between 0 to 100."
   123 printflush .message
 
   131 op floor *tmp26 PCT_HIGH
   132 op strictEqual *tmp27 PCT_HIGH *tmp26
   133 op land :validate.1:condition *tmp25 *tmp27
-    * set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
   134 jump *label32 notEqual :validate.1:condition false
   135 print "PCT_HIGH must be an integer between 0 to 100."
   136 printflush .message
 
   139 label *label33
   140 label *label31
   141 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
-    * set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
   142 jump *label35 notEqual :validate.2:condition false
   143 print "PCT_LOW must be less than PCT_HIGH."
   144 printflush .message
 
   152 jump *label38 equal false true
   153 set .state true
   154 op add .cycles .cycles 1
-    * op xor .active .inverted :setState.0:newState
+  155 op xor .active .inverted true
   156 jump *label40 equal .active false
   157 set *tmp40 "\nCurrently active:[green]"
   158 jump *label41 always
 
   219 jump *label60 equal .state true
   220 set .state true
   221 op add .cycles .cycles 1
-    * op xor .active .inverted :setState.1:newState
+  222 op xor .active .inverted true
   223 jump *label62 equal .active false
   224 set *tmp73 "\nCurrently active:[green]"
   225 jump *label63 always
 
   237 jump *label67 equal .state false
   238 set .state false
   239 op add .cycles .cycles 1
-    * op xor .active .inverted :setState.2:newState
+  240 op xor .active .inverted false
   241 jump *label69 equal .active false
   242 set *tmp80 "\nCurrently active:[green]"
   243 jump *label70 always
 
   281 print "[]"
   282 label *label72
   283 print .activeText
-    * set *tmp82 .links
   284 set :n .first
   285 label *label73
   286 jump *label75 greaterThanEq :n .links

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
   148 label *label34
   149 sensor *tmp34 .sorter @type
   150 op equal .inverted *tmp34 @inverted-sorter
-    * set :setState.0:newState true
   151 jump *label38 equal false true
   152 set .state true
   153 op add .cycles .cycles 1
 
   214 sensor *tmp65 .container .maximum
   215 op idiv :pct *tmp64 *tmp65
   216 jump *label57 greaterThan :pct PCT_LOW
-    * set :setState.1:newState true
   217 jump *label60 equal .state true
   218 set .state true
   219 op add .cycles .cycles 1
 
   231 jump *label58 always
   232 label *label57
   233 jump *label64 lessThan :pct PCT_HIGH
-    * set :setState.2:newState false
   234 jump *label67 equal .state false
   235 set .state false
   236 op add .cycles .cycles 1

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     7 op sub :initialize.0:n .links 1
     8 label *label4
     9 jump *label6 lessThan :initialize.0:n 0
+   10 label *label76
    11 getlink :initialize.0:block :initialize.0:n
    12 print "Found: "
    13 print :initialize.0:block
 
    73 label *label7
    74 label *label5
    75 op sub :initialize.0:n :initialize.0:n 1
-    * jump *label4 always
+   76 jump *label76 greaterThanEq :initialize.0:n 0
    77 label *label6
    78 print "Message: "
    79 print .message
 
   282 set :n .first
   283 label *label73
   284 jump *label75 greaterThanEq :n .links
+  285 label *label77
   286 getlink :block :n
   287 control enabled :block .active
   288 print "\n    "
   289 print :block
   290 label *label74
   291 op add :n :n 1
-    * jump *label73 always
+  292 jump *label77 lessThan :n .links
   293 label *label75
   294 print "[]"
   295 print "\n"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
   153 set .state true
   154 op add .cycles .cycles 1
   155 op xor .active .inverted true
-    * jump *label40 equal .active false
-    * set *tmp40 "\nCurrently active:[green]"
+  156 set .activeText "\nCurrently inactive:[salmon]"
+  157 jump *label41 equal .active false
+  158 set .activeText "\nCurrently active:[green]"
   159 jump *label41 always
-    * label *label40
-    * set *tmp40 "\nCurrently inactive:[salmon]"
   160 label *label41
-    * set .activeText *tmp40
   161 label *label38
   162 label *label39
   163 label *label37
 
   217 set .state true
   218 op add .cycles .cycles 1
   219 op xor .active .inverted true
-    * jump *label62 equal .active false
-    * set *tmp73 "\nCurrently active:[green]"
+  220 set .activeText "\nCurrently inactive:[salmon]"
+  221 jump *label63 equal .active false
+  222 set .activeText "\nCurrently active:[green]"
   223 jump *label63 always
-    * label *label62
-    * set *tmp73 "\nCurrently inactive:[salmon]"
   224 label *label63
-    * set .activeText *tmp73
   225 label *label60
   226 label *label61
   227 label *label59
 
   232 set .state false
   233 op add .cycles .cycles 1
   234 op xor .active .inverted false
-    * jump *label69 equal .active false
-    * set *tmp80 "\nCurrently active:[green]"
+  235 set .activeText "\nCurrently inactive:[salmon]"
+  236 jump *label70 equal .active false
+  237 set .activeText "\nCurrently active:[green]"
   238 jump *label70 always
-    * label *label69
-    * set *tmp80 "\nCurrently inactive:[salmon]"
   239 label *label70
-    * set .activeText *tmp80
   240 label *label67
   241 label *label68
   242 label *label66

Modifications by Replicate loop condition at line 36:5 (+1 instructions):
 
   166 label *label42
   167 sensor *tmp43 .switch @enabled
   168 jump *label44 notEqual *tmp43 0
+  169 label *label78
   170 set :start @time
   171 sensor *tmp45 .container @dead
   172 jump *label45 equal *tmp45 false
 
   299 print "ms"
   300 printflush .message
   301 label *label43
-    * jump *label42 always
+  302 sensor *tmp43 .switch @enabled
+  303 jump *label78 equal *tmp43 0
   304 label *label44
   305 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   276 print .activeText
   277 set :n .first
   278 label *label73
-    * jump *label75 greaterThanEq :n .links
+  279 jump *label75 greaterThanEq .first .links
   280 label *label77
   281 getlink :block :n
   282 control enabled :block .active

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   149 label *label34
   150 sensor *tmp34 .sorter @type
   151 op equal .inverted *tmp34 @inverted-sorter
-    * jump *label38 equal false true
   152 set .state true
   153 op add .cycles .cycles 1
   154 op xor .active .inverted true

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
   155 set .activeText "\nCurrently inactive:[salmon]"
   156 jump *label41 equal .active false
   157 set .activeText "\nCurrently active:[green]"
-    * jump *label41 always
   158 label *label41
   159 label *label38
   160 label *label39
 
   219 set .activeText "\nCurrently inactive:[salmon]"
   220 jump *label63 equal .active false
   221 set .activeText "\nCurrently active:[green]"
-    * jump *label63 always
   222 label *label63
   223 label *label60
   224 label *label61
 
   233 set .activeText "\nCurrently inactive:[salmon]"
   234 jump *label70 equal .active false
   235 set .activeText "\nCurrently active:[green]"
-    * jump *label70 always
   236 label *label70
   237 label *label67
   238 label *label68

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 set PCT_LOW 60
     2 set PCT_HIGH 80
     3 label *label1
 
   164 control enabled .switch 0
   165 label *label42
   166 sensor *tmp43 .switch @enabled
-    * jump *label44 notEqual *tmp43 0
+  167 jump __start__ notEqual *tmp43 0
   168 label *label78
   169 set :start @time
   170 sensor *tmp45 .container @dead
 
   213 sensor *tmp65 .container .maximum
   214 op idiv :pct *tmp64 *tmp65
   215 jump *label57 greaterThan :pct PCT_LOW
-    * jump *label60 equal .state true
+  216 jump *label58 equal .state true
   217 set .state true
   218 op add .cycles .cycles 1
   219 op xor .active .inverted true
   220 set .activeText "\nCurrently inactive:[salmon]"
-    * jump *label63 equal .active false
+  221 jump *label58 equal .active false
   222 set .activeText "\nCurrently active:[green]"
   223 label *label63
   224 label *label60

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   299 sensor *tmp43 .switch @enabled
   300 jump *label78 equal *tmp43 0
   301 label *label44
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-25 instructions):
 
     2 set PCT_HIGH 80
     3 label *label1
     4 set :initialize.0:repeat false
-    * print "Configuring regulator..."
-    * print "\n"
+    5 print "Configuring regulator...\n"
     6 set .links @links
     7 op sub :initialize.0:n .links 1
     8 label *label4
 
    77 label *label6
    78 print "Message: "
    79 print .message
-    * print "\n"
-    * print "Switch: "
+   80 print "\nSwitch: "
    81 print .switch
-    * print "\n"
-    * print "Sorter: "
+   82 print "\nSorter: "
    83 print .sorter
-    * print "\n"
-    * print "Container: "
+   84 print "\nContainer: "
    85 print .container
-    * print "\n"
-    * print "First index: "
+   86 print "\nFirst index: "
    87 print .first
    88 print "\n"
    89 jump *label22 notEqual .message null
-    * print "No message."
-    * print "\n"
+   90 print "No message.\n"
    91 set :initialize.0:repeat true
    92 label *label22
    93 label *label23
    94 jump *label24 notEqual .switch null
-    * print "No switch."
-    * print "\n"
+   95 print "No switch.\n"
    96 set :initialize.0:repeat true
    97 label *label24
    98 label *label25
    99 jump *label26 notEqual .container null
-    * print "No container."
-    * print "\n"
+  100 print "No container.\n"
   101 set :initialize.0:repeat true
   102 label *label26
   103 label *label27
 
   196 label *label55
   197 print "Measuring [gold]"
   198 print :item
-    * print "["
-    * print "] in "
+  199 print "[] in "
   200 print .container
   201 sensor :amount .container :item
   202 label *label56
 
   232 label *label64
   233 label *label65
   234 label *label58
-    * print "\n"
-    * print "Level: [gold]"
+  235 print "\nLevel: [gold]"
   236 print :pct
-    * print "%"
-    * print "[]"
+  237 print "%[]"
   238 jump *label71 equal .inverted false
-    * print "\n"
-    * print "Activate above [green]"
+  239 print "\nActivate above [green]"
   240 print PCT_HIGH
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate below [salmon]"
+  241 print "%[]\nDeactivate below [salmon]"
   242 print PCT_LOW
-    * print "%"
-    * print "[]"
+  243 print "%[]"
   244 jump *label72 always
   245 label *label71
-    * print "\n"
-    * print "Activate below [green]"
+  246 print "\nActivate below [green]"
   247 print PCT_LOW
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate above [salmon]"
+  248 print "%[]\nDeactivate above [salmon]"
   249 print PCT_HIGH
-    * print "%"
-    * print "[]"
+  250 print "%[]"
   251 label *label72
   252 print .activeText
   253 set :n .first
 
   262 op add :n :n 1
   263 jump *label77 lessThan :n .links
   264 label *label75
-    * print "[]"
-    * print "\n"
-    * print "# of cycles: "
+  265 print "[]\n# of cycles: "
   266 print .cycles
   267 op sub *tmp86 @time :start
   268 op floor *tmp87 *tmp86
-    * print "\n"
-    * print "[lightgray]Loop: "
+  269 print "\n[lightgray]Loop: "
   270 print *tmp87
-    * print " "
-    * print "ms"
+  271 print " ms"
   272 printflush .message
   273 label *label43
   274 sensor *tmp43 .switch @enabled

Final code before resolving virtual instructions:

        label __start__                                              param PCT_LOW = 60;
    0:  set PCT_LOW 60                                               ...
    1:  set PCT_HIGH 80                                              param PCT_HIGH = 80;
        label *label1                                                do
    2:  set :initialize.0:repeat false                               var repeat = false;
    3:  print "Configuring regulator...\n"                           println("Configuring regulator...");
    4:  set .links @links                                            links = @links;
    5:  op sub :initialize.0:n .links 1                              for var n in 0 ... links descending do
    6:  jump *label6 lessThan :initialize.0:n 0                      ...
        label *label76                                               ...
    7:  getlink :initialize.0:block :initialize.0:n                  var block = getlink(n);
    8:  print "Found: "                                              println("Found: ", block);
    9:  print :initialize.0:block                                    ...
   10:  print "\n"                                                   ...
   11:  sensor *tmp3 :initialize.0:block @type                       case block.@type
   12:  jump *label8 notEqual *tmp3 @message                         ...
   13:  set .message :initialize.0:block                             message = block;
   14:  jump *label7 always 0 0                                      case block.@type
        label *label8                                                ...
   15:  jump *label10 notEqual *tmp3 @switch                         ...
   16:  set .switch :initialize.0:block                              switch = block;
   17:  jump *label7 always 0 0                                      case block.@type
        label *label10                                               ...
   18:  jump *label13 equal *tmp3 @sorter                            ...
   19:  jump *label13 equal *tmp3 @inverted-sorter                   ...
   20:  jump *label12 notEqual *tmp3 @unloader                       ...
        label *label13                                               ...
   21:  set .sorter :initialize.0:block                              sorter = block;
   22:  jump *label7 always 0 0                                      case block.@type
        label *label12                                               ...
   23:  jump *label15 equal *tmp3 @vault                             ...
   24:  jump *label15 equal *tmp3 @container                         ...
   25:  jump *label15 equal *tmp3 @core-shard                        ...
   26:  jump *label15 equal *tmp3 @core-foundation                   ...
   27:  jump *label14 notEqual *tmp3 @core-nucleus                   ...
        label *label15                                               ...
   28:  set .container :initialize.0:block                           container = block;
   29:  set .measure @totalItems                                     measure = @totalItems;
   30:  set .maximum @itemCapacity                                   maximum = @itemCapacity;
   31:  op add .first :initialize.0:n 1                              first = n + 1;
   32:  jump *label7 always 0 0                                      case block.@type
        label *label14                                               ...
   33:  jump *label17 equal *tmp3 @liquid-tank                       ...
   34:  jump *label17 equal *tmp3 @liquid-container                  ...
   35:  jump *label16 notEqual *tmp3 @liquid-router                  ...
        label *label17                                               ...
   36:  set .container :initialize.0:block                           container = block;
   37:  set .measure @totalLiquids                                   measure = @totalLiquids;
   38:  set .maximum @liquidCapacity                                 maximum = @liquidCapacity;
   39:  op add .first :initialize.0:n 1                              first = n + 1;
   40:  jump *label7 always 0 0                                      case block.@type
        label *label16                                               ...
   41:  jump *label19 equal *tmp3 @battery                           ...
   42:  jump *label18 notEqual *tmp3 @battery-large                  ...
        label *label19                                               ...
   43:  set .container :initialize.0:block                           container = block;
   44:  set .measure @totalPower                                     measure = @totalPower;
   45:  set .maximum @powerCapacity                                  maximum = @powerCapacity;
   46:  op add .first :initialize.0:n 1                              first = n + 1;
   47:  jump *label7 always 0 0                                      case block.@type
        label *label18                                               ...
   48:  jump *label21 equal *tmp3 @power-node                        ...
   49:  jump *label21 equal *tmp3 @power-node-large                  ...
   50:  jump *label20 notEqual *tmp3 @surge-tower                    ...
        label *label21                                               ...
   51:  set .container :initialize.0:block                           container = block;
   52:  set .measure @powerNetStored                                 measure = @powerNetStored;
   53:  set .maximum @powerNetCapacity                               maximum = @powerNetCapacity;
   54:  op add .first :initialize.0:n 1                              first = n + 1;
        label *label20                                               case block.@type
        label *label7                                                ...
   55:  op sub :initialize.0:n :initialize.0:n 1                     for var n in 0 ... links descending do
   56:  jump *label76 greaterThanEq :initialize.0:n 0                ...
        label *label6                                                ...
   57:  print "Message: "                                            println("Message: ", message);
   58:  print .message                                               ...
   59:  print "\nSwitch: "                                           println("Switch: ", switch);
   60:  print .switch                                                ...
   61:  print "\nSorter: "                                           println("Sorter: ", sorter);
   62:  print .sorter                                                ...
   63:  print "\nContainer: "                                        println("Container: ", container);
   64:  print .container                                             ...
   65:  print "\nFirst index: "                                      println("First index: ", first);
   66:  print .first                                                 ...
   67:  print "\n"                                                   ...
   68:  jump *label22 notEqual .message null                         if message == null then println("No message."); repeat = true; end;
   69:  print "No message.\n"                                        ...
   70:  set :initialize.0:repeat true                                ...
        label *label22                                               ...
   71:  jump *label24 notEqual .switch null                          if switch == null then println("No switch."); repeat = true; end;
   72:  print "No switch.\n"                                         ...
   73:  set :initialize.0:repeat true                                ...
        label *label24                                               ...
   74:  jump *label26 notEqual .container null                       if container == null then println("No container."); repeat = true; end;
   75:  print "No container.\n"                                      ...
   76:  set :initialize.0:repeat true                                ...
        label *label26                                               ...
   77:  printflush .message                                          printflush(message);
   78:  jump *label1 notEqual :initialize.0:repeat false             do
   79:  printflush null                                              printflush(null);
   80:  op greaterThanEq *tmp15 PCT_LOW 0                            validate(PCT_LOW >= 0 and PCT_LOW <= 100 and PCT_LOW === floor(PCT_LOW), "PCT_LOW must be an integer between 0 to 100.");
   81:  op lessThanEq *tmp16 PCT_LOW 100                             ...
   82:  op land *tmp17 *tmp15 *tmp16                                 ...
   83:  op floor *tmp18 PCT_LOW 0                                    ...
   84:  op strictEqual *tmp19 PCT_LOW *tmp18                         ...
   85:  op land :validate.0:condition *tmp17 *tmp19                  ...
   86:  jump *label29 notEqual :validate.0:condition false           if !condition then
   87:  print "PCT_LOW must be an integer between 0 to 100."         print(text);
   88:  printflush .message                                          printflush(message);
   89:  stop                                                         stopProcessor();
        label *label29                                               if !condition then
   90:  op greaterThanEq *tmp23 PCT_HIGH 0                           validate(PCT_HIGH >= 0 and PCT_HIGH <= 100 and PCT_HIGH === floor(PCT_HIGH), "PCT_HIGH must be an integer between 0 to 100.");
   91:  op lessThanEq *tmp24 PCT_HIGH 100                            ...
   92:  op land *tmp25 *tmp23 *tmp24                                 ...
   93:  op floor *tmp26 PCT_HIGH 0                                   ...
   94:  op strictEqual *tmp27 PCT_HIGH *tmp26                        ...
   95:  op land :validate.1:condition *tmp25 *tmp27                  ...
   96:  jump *label32 notEqual :validate.1:condition false           if !condition then
   97:  print "PCT_HIGH must be an integer between 0 to 100."        print(text);
   98:  printflush .message                                          printflush(message);
   99:  stop                                                         stopProcessor();
        label *label32                                               if !condition then
  100:  op lessThan :validate.2:condition PCT_LOW PCT_HIGH           validate(PCT_LOW < PCT_HIGH, "PCT_LOW must be less than PCT_HIGH.");
  101:  jump *label35 notEqual :validate.2:condition false           if !condition then
  102:  print "PCT_LOW must be less than PCT_HIGH."                  print(text);
  103:  printflush .message                                          printflush(message);
  104:  stop                                                         stopProcessor();
        label *label35                                               if !condition then
  105:  sensor *tmp34 .sorter @type                                  inverted = sorter.@type == @inverted-sorter;
  106:  op equal .inverted *tmp34 @inverted-sorter                   ...
  107:  set .state true                                              state = newState;
  108:  op add .cycles .cycles 1                                     if state != newState then
  109:  op xor .active .inverted true                                active = inverted ^ state;
  110:  set .activeText "\nCurrently inactive:[salmon]"              activeText = active ? "\nCurrently active:[green]" : "\nCurrently inactive:[salmon]";
  111:  jump *label41 equal .active false                            ...
  112:  set .activeText "\nCurrently active:[green]"                 ...
        label *label41                                               ...
  113:  control enabled .switch 0 0 0 0                              switch.enabled = 0;
  114:  sensor *tmp43 .switch @enabled                               while switch.@enabled == 0 do
  115:  jump __start__ notEqual *tmp43 0                             ...
        label *label78                                               ...
  116:  set :start @time                                             var start = @time;
  117:  sensor *tmp45 .container @dead                               if container.@dead          then end(); end;
  118:  jump *label45 equal *tmp45 false                             ...
  119:  end                                                          ...
        label *label45                                               ...
  120:  sensor *tmp47 .message @dead                                 if message.@dead            then end(); end;
  121:  jump *label47 equal *tmp47 false                             ...
  122:  end                                                          ...
        label *label47                                               ...
  123:  sensor *tmp49 .switch @dead                                  if switch.@dead             then end(); end;
  124:  jump *label49 equal *tmp49 false                             ...
  125:  end                                                          ...
        label *label49                                               ...
  126:  sensor *tmp51 .sorter @dead                                  if sorter and sorter.@dead  then end(); end;
  127:  op land *tmp52 .sorter *tmp51                                ...
  128:  jump *label51 equal *tmp52 false                             ...
  129:  end                                                          ...
        label *label51                                               ...
  130:  jump *label53 equal .links @links                            if links != @links          then end(); end;
  131:  end                                                          ...
        label *label53                                               ...
  132:  sensor :item .sorter @config                                 var item = sorter.@config;
  133:  op equal *tmp57 :item null                                   if item == null || measure != @totalItems then
  134:  op notEqual *tmp58 .measure @totalItems                      ...
  135:  op or *tmp60 *tmp57 *tmp58                                   ...
  136:  jump *label55 equal *tmp60 false                             ...
  137:  print "Measuring [gold]total[] in "                          print($"Measuring [gold]total[] in $container");
  138:  print .container                                             ...
  139:  sensor :amount .container .measure                           amount = container.sensor(measure);
  140:  jump *label56 always 0 0                                     if item == null || measure != @totalItems then
        label *label55                                               ...
  141:  print "Measuring [gold]"                                     print($"Measuring [gold]$item[] in $container");
  142:  print :item                                                  ...
  143:  print "[] in "                                               ...
  144:  print .container                                             ...
  145:  sensor :amount .container :item                              amount = container.sensor(item);
        label *label56                                               if item == null || measure != @totalItems then
  146:  op mul *tmp64 100 :amount                                    var pct = (100 * amount) \ container.sensor(maximum);
  147:  sensor *tmp65 .container .maximum                            ...
  148:  op idiv :pct *tmp64 *tmp65                                   ...
  149:  jump *label57 greaterThan :pct PCT_LOW                       if pct <= PCT_LOW then
  150:  jump *label58 equal .state true                              if state != newState then
  151:  set .state true                                              state = newState;
  152:  op add .cycles .cycles 1                                     if state != newState then
  153:  op xor .active .inverted true                                active = inverted ^ state;
  154:  set .activeText "\nCurrently inactive:[salmon]"              activeText = active ? "\nCurrently active:[green]" : "\nCurrently inactive:[salmon]";
  155:  jump *label58 equal .active false                            ...
  156:  set .activeText "\nCurrently active:[green]"                 ...
  157:  jump *label58 always 0 0                                     if pct <= PCT_LOW then
        label *label57                                               ...
  158:  jump *label64 lessThan :pct PCT_HIGH                         elsif pct >= PCT_HIGH then
  159:  jump *label67 equal .state false                             if state != newState then
  160:  set .state false                                             state = newState;
  161:  op add .cycles .cycles 1                                     if state != newState then
  162:  op xor .active .inverted false                               active = inverted ^ state;
  163:  set .activeText "\nCurrently inactive:[salmon]"              activeText = active ? "\nCurrently active:[green]" : "\nCurrently inactive:[salmon]";
  164:  jump *label70 equal .active false                            ...
  165:  set .activeText "\nCurrently active:[green]"                 ...
        label *label70                                               ...
        label *label67                                               if state != newState then
        label *label64                                               elsif pct >= PCT_HIGH then
        label *label58                                               if pct <= PCT_LOW then
  166:  print "\nLevel: [gold]"                                      print($"\nLevel: [gold]$pct%[]");
  167:  print :pct                                                   ...
  168:  print "%[]"                                                  ...
  169:  jump *label71 equal .inverted false                          if inverted then
  170:  print "\nActivate above [green]"                             print($"\nActivate above [green]$PCT_HIGH%[]");
  171:  print PCT_HIGH                                               ...
  172:  print "%[]\nDeactivate below [salmon]"                       print($"\nDeactivate below [salmon]$PCT_LOW%[]");
  173:  print PCT_LOW                                                ...
  174:  print "%[]"                                                  ...
  175:  jump *label72 always 0 0                                     if inverted then
        label *label71                                               ...
  176:  print "\nActivate below [green]"                             print($"\nActivate below [green]$PCT_LOW%[]");
  177:  print PCT_LOW                                                ...
  178:  print "%[]\nDeactivate above [salmon]"                       print($"\nDeactivate above [salmon]$PCT_HIGH%[]");
  179:  print PCT_HIGH                                               ...
  180:  print "%[]"                                                  ...
        label *label72                                               if inverted then
  181:  print .activeText                                            print(activeText);
  182:  set :n .first                                                for var n in first ... links do
  183:  jump *label75 greaterThanEq .first .links                    ...
        label *label77                                               ...
  184:  getlink :block :n                                            var block = getlink(n);
  185:  control enabled :block .active 0 0 0                         block.enabled = active;
  186:  print "\n    "                                               print("\n    ", block);
  187:  print :block                                                 ...
  188:  op add :n :n 1                                               for var n in first ... links do
  189:  jump *label77 lessThan :n .links                             ...
        label *label75                                               ...
  190:  print "[]\n# of cycles: "                                    print($"[]\n# of cycles: $cycles");
  191:  print .cycles                                                ...
  192:  op sub *tmp86 @time :start                                   print($"\n[lightgray]Loop: $ ms", floor(@time - start));
  193:  op floor *tmp87 *tmp86 0                                     ...
  194:  print "\n[lightgray]Loop: "                                  ...
  195:  print *tmp87                                                 ...
  196:  print " ms"                                                  ...
  197:  printflush .message                                          printflush(message);
  198:  sensor *tmp43 .switch @enabled                               while switch.@enabled == 0 do
  199:  jump *label78 equal *tmp43 0                                 ...


Performance: parsed in 202 ms, compiled in 179 ms, optimized in 268 ms, run in 69 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (100,000 steps):
Configuring regulator...
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Sorter: null
Container: null
First index: null
No switch.
No container.

[--- Previous segment repeated 125,60 times ---]

Execution step limit of 100 000 exceeded.
