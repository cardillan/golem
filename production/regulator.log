   346 instructions before optimizations.
    20 instructions eliminated by Temp Variables Elimination (6 iterations).
     1 instructions eliminated by Case Expression Optimization.
    47 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    14 instructions eliminated by Jump Optimization (5 iterations).
    20 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     1 instructions modified by Expression Optimization (3 iterations).
     3 instructions eliminated by If Expression Optimization (3 iterations).
     9 instructions eliminated by Data Flow Optimization (3 passes, 10 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
   131 instructions added by Case Switching (5 iterations).
     1 case expressions converted to switched jumps Case Switching.
     7 instructions eliminated by Jump Straightening (5 iterations).
     3 instructions updated by Jump Threading.
    25 instructions eliminated by Print Merging.
   331 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 771):
  * Replicate loop condition at line 36:5                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  o Convert case at line 97:13 (segments: 15)                    size    +0, benefit     2013.9, efficiency   Infinity
  o Convert case at line 97:13 (segments: 6)                     size    +1, benefit     2118.1, efficiency   2118.056
  o Convert case at line 97:13 (segments: 4)                     size   +20, benefit     2152.8, efficiency    107.639
  o Convert case at line 97:13 (segments: 6)                     size   +21, benefit     2256.9, efficiency    107.474
  o Convert case at line 97:13 (segments: 2)                     size   +38, benefit     2326.4, efficiency     61.221
  o Convert case at line 97:13 (segments: 5)                     size   +39, benefit     2361.1, efficiency     60.541
  o Convert case at line 97:13 (segments: 4, padded low)         size   +67, benefit     2395.8, efficiency     35.759
  o Convert case at line 97:13 (segments: 6, padded low)         size   +68, benefit     2500.0, efficiency     36.765
  o Convert case at line 97:13 (segments: 3)                     size   +80, benefit     2812.5, efficiency     35.156
  o Convert case at line 97:13 (segments: 1)                     size   +84, benefit     2847.2, efficiency     33.896
  o Convert case at line 97:13 (segments: 5, padded low)         size   +86, benefit     2881.9, efficiency     33.511
  o Convert case at line 97:13 (segments: 3, padded low)         size  +127, benefit     3333.3, efficiency     26.247
  o Convert case at line 97:13 (segments: 1, padded low)         size  +131, benefit     3472.2, efficiency     26.506

Pass 1: speed optimization selection (cost limit 770):
  o Convert case at line 97:13 (segments: 15)                    size    +0, benefit     2013.9, efficiency   Infinity
  o Convert case at line 97:13 (segments: 6)                     size    +1, benefit     2118.1, efficiency   2118.056
  o Convert case at line 97:13 (segments: 4)                     size   +20, benefit     2152.8, efficiency    107.639
  o Convert case at line 97:13 (segments: 6)                     size   +21, benefit     2256.9, efficiency    107.474
  o Convert case at line 97:13 (segments: 2)                     size   +38, benefit     2326.4, efficiency     61.221
  o Convert case at line 97:13 (segments: 5)                     size   +39, benefit     2361.1, efficiency     60.541
  o Convert case at line 97:13 (segments: 4, padded low)         size   +67, benefit     2395.8, efficiency     35.759
  o Convert case at line 97:13 (segments: 6, padded low)         size   +68, benefit     2500.0, efficiency     36.765
  o Convert case at line 97:13 (segments: 3)                     size   +80, benefit     2812.5, efficiency     35.156
  o Convert case at line 97:13 (segments: 1)                     size   +84, benefit     2847.2, efficiency     33.896
  o Convert case at line 97:13 (segments: 5, padded low)         size   +86, benefit     2881.9, efficiency     33.511
  o Convert case at line 97:13 (segments: 3, padded low)         size  +127, benefit     3333.3, efficiency     26.247
  * Convert case at line 97:13 (segments: 1, padded low)         size  +131, benefit     3472.2, efficiency     26.506 (+131 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    15 print :initialize:block
    16 print "\n"
    17 sensor *tmp3 :initialize:block @type
-    * set *tmp4 *tmp3
-    * jump *label9 equal *tmp4 @message
+   18 jump *label9 equal *tmp3 @message
    19 jump *label8 always
    20 label *label9
    21 set .message :initialize:block
    22 set *tmp2 .message
    23 jump *label7 always
    24 label *label8
-    * jump *label11 equal *tmp4 @switch
+   25 jump *label11 equal *tmp3 @switch
    26 jump *label10 always
    27 label *label11
    28 set .switch :initialize:block
    29 set *tmp2 .switch
    30 jump *label7 always
    31 label *label10
-    * jump *label13 equal *tmp4 @sorter
-    * jump *label13 equal *tmp4 @inverted-sorter
-    * jump *label13 equal *tmp4 @unloader
+   32 jump *label13 equal *tmp3 @sorter
+   33 jump *label13 equal *tmp3 @inverted-sorter
+   34 jump *label13 equal *tmp3 @unloader
    35 jump *label12 always
    36 label *label13
    37 set .sorter :initialize:block
    38 set *tmp2 .sorter
    39 jump *label7 always
    40 label *label12
-    * jump *label15 equal *tmp4 @vault
-    * jump *label15 equal *tmp4 @container
-    * jump *label15 equal *tmp4 @core-shard
-    * jump *label15 equal *tmp4 @core-foundation
-    * jump *label15 equal *tmp4 @core-nucleus
+   41 jump *label15 equal *tmp3 @vault
+   42 jump *label15 equal *tmp3 @container
+   43 jump *label15 equal *tmp3 @core-shard
+   44 jump *label15 equal *tmp3 @core-foundation
+   45 jump *label15 equal *tmp3 @core-nucleus
    46 jump *label14 always
    47 label *label15
    48 set .container :initialize:block
 
    53 set *tmp2 .first
    54 jump *label7 always
    55 label *label14
-    * jump *label17 equal *tmp4 @liquid-tank
-    * jump *label17 equal *tmp4 @liquid-container
-    * jump *label17 equal *tmp4 @liquid-router
+   56 jump *label17 equal *tmp3 @liquid-tank
+   57 jump *label17 equal *tmp3 @liquid-container
+   58 jump *label17 equal *tmp3 @liquid-router
    59 jump *label16 always
    60 label *label17
    61 set .container :initialize:block
 
    66 set *tmp2 .first
    67 jump *label7 always
    68 label *label16
-    * jump *label19 equal *tmp4 @battery
-    * jump *label19 equal *tmp4 @battery-large
+   69 jump *label19 equal *tmp3 @battery
+   70 jump *label19 equal *tmp3 @battery-large
    71 jump *label18 always
    72 label *label19
    73 set .container :initialize:block
 
    78 set *tmp2 .first
    79 jump *label7 always
    80 label *label18
-    * jump *label21 equal *tmp4 @power-node
-    * jump *label21 equal *tmp4 @power-node-large
-    * jump *label21 equal *tmp4 @surge-tower
+   81 jump *label21 equal *tmp3 @power-node
+   82 jump *label21 equal *tmp3 @power-node-large
+   83 jump *label21 equal *tmp3 @surge-tower
    84 jump *label20 always
    85 label *label21
    86 set .container :initialize:block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-45 instructions):
 
    19 jump *label8 always
    20 label *label9
    21 set .message :initialize:block
-    * set *tmp2 .message
    22 jump *label7 always
    23 label *label8
    24 jump *label11 equal *tmp3 @switch
    25 jump *label10 always
    26 label *label11
    27 set .switch :initialize:block
-    * set *tmp2 .switch
    28 jump *label7 always
    29 label *label10
    30 jump *label13 equal *tmp3 @sorter
 
    33 jump *label12 always
    34 label *label13
    35 set .sorter :initialize:block
-    * set *tmp2 .sorter
    36 jump *label7 always
    37 label *label12
    38 jump *label15 equal *tmp3 @vault
 
    47 set .maximum @itemCapacity
    48 op add *tmp5 :initialize:n 1
    49 set .first *tmp5
-    * set *tmp2 .first
    50 jump *label7 always
    51 label *label14
    52 jump *label17 equal *tmp3 @liquid-tank
 
    59 set .maximum @liquidCapacity
    60 op add *tmp6 :initialize:n 1
    61 set .first *tmp6
-    * set *tmp2 .first
    62 jump *label7 always
    63 label *label16
    64 jump *label19 equal *tmp3 @battery
 
    70 set .maximum @powerCapacity
    71 op add *tmp7 :initialize:n 1
    72 set .first *tmp7
-    * set *tmp2 .first
    73 jump *label7 always
    74 label *label18
    75 jump *label21 equal *tmp3 @power-node
 
    82 set .maximum @powerNetCapacity
    83 op add *tmp8 :initialize:n 1
    84 set .first *tmp8
-    * set *tmp2 .first
    85 jump *label7 always
    86 label *label20
-    * set *tmp2 null
    87 label *label7
    88 label *label5
    89 op sub :initialize:n :initialize:n 1
 
   109 print "No message."
   110 print "\n"
   111 set :initialize:repeat true
-    * set *tmp10 :initialize:repeat
   112 jump *label23 always
   113 label *label22
-    * set *tmp10 null
   114 label *label23
   115 op equal *tmp11 .switch null
   116 jump *label24 equal *tmp11 false
   117 print "No switch."
   118 print "\n"
   119 set :initialize:repeat true
-    * set *tmp12 :initialize:repeat
   120 jump *label25 always
   121 label *label24
-    * set *tmp12 null
   122 label *label25
   123 op equal *tmp13 .container null
   124 jump *label26 equal *tmp13 false
   125 print "No container."
   126 print "\n"
   127 set :initialize:repeat true
-    * set *tmp14 :initialize:repeat
   128 jump *label27 always
   129 label *label26
-    * set *tmp14 null
   130 label *label27
   131 printflush .message
   132 label *label2
 
   146 print :validate:text
   147 printflush .message
   148 stop
-    * set *tmp22 null
   149 jump *label30 always
   150 label *label29
-    * set *tmp22 null
   151 label *label30
   152 label *label28
   153 op greaterThanEq *tmp23 PCT_HIGH 0
 
   163 print :validate.1:text
   164 printflush .message
   165 stop
-    * set *tmp30 null
   166 jump *label33 always
   167 label *label32
-    * set *tmp30 null
   168 label *label33
   169 label *label31
   170 op lessThan *tmp31 PCT_LOW PCT_HIGH
 
   175 print :validate.2:text
   176 printflush .message
   177 stop
-    * set *tmp33 null
   178 jump *label36 always
   179 label *label35
-    * set *tmp33 null
   180 label *label36
   181 label *label34
   182 sensor *tmp34 .sorter @type
 
   186 op notEqual *tmp36 .state :setState:newState
   187 jump *label38 equal *tmp36 false
   188 set .state :setState:newState
-    * set *tmp38 .cycles
   189 op add .cycles .cycles 1
   190 op xor *tmp39 .inverted .state
   191 set .active *tmp39
 
   196 set *tmp40 "\nCurrently inactive:[salmon]"
   197 label *label41
   198 set .activeText *tmp40
-    * set *tmp37 .activeText
   199 jump *label39 always
   200 label *label38
-    * set *tmp37 null
   201 label *label39
   202 label *label37
   203 label *label0
 
   211 sensor *tmp45 .container @dead
   212 jump *label45 equal *tmp45 false
   213 end
-    * set *tmp46 null
   214 jump *label46 always
   215 label *label45
-    * set *tmp46 null
   216 label *label46
   217 sensor *tmp47 .message @dead
   218 jump *label47 equal *tmp47 false
   219 end
-    * set *tmp48 null
   220 jump *label48 always
   221 label *label47
-    * set *tmp48 null
   222 label *label48
   223 sensor *tmp49 .switch @dead
   224 jump *label49 equal *tmp49 false
   225 end
-    * set *tmp50 null
   226 jump *label50 always
   227 label *label49
-    * set *tmp50 null
   228 label *label50
   229 sensor *tmp51 .sorter @dead
   230 op land *tmp52 .sorter *tmp51
   231 jump *label51 equal *tmp52 false
   232 end
-    * set *tmp53 null
   233 jump *label52 always
   234 label *label51
-    * set *tmp53 null
   235 label *label52
   236 op notEqual *tmp54 .links @links
   237 jump *label53 equal *tmp54 false
   238 end
-    * set *tmp55 null
   239 jump *label54 always
   240 label *label53
-    * set *tmp55 null
   241 label *label54
   242 sensor *tmp56 .sorter @config
   243 set :item *tmp56
 
   251 print .container
   252 sensor *tmp62 .container .measure
   253 set :amount *tmp62
-    * set *tmp61 :amount
   254 jump *label56 always
   255 label *label55
   256 print "Measuring [gold]"
 
   260 print .container
   261 sensor *tmp63 .container :item
   262 set :amount *tmp63
-    * set *tmp61 :amount
   263 label *label56
   264 op mul *tmp64 100 :amount
   265 sensor *tmp65 .container .maximum
 
   271 op notEqual *tmp69 .state :setState.1:newState
   272 jump *label60 equal *tmp69 false
   273 set .state :setState.1:newState
-    * set *tmp71 .cycles
   274 op add .cycles .cycles 1
   275 op xor *tmp72 .inverted .state
   276 set .active *tmp72
 
   281 set *tmp73 "\nCurrently inactive:[salmon]"
   282 label *label63
   283 set .activeText *tmp73
-    * set *tmp70 .activeText
   284 jump *label61 always
   285 label *label60
-    * set *tmp70 null
   286 label *label61
   287 label *label59
-    * set *tmp68 null
   288 jump *label58 always
   289 label *label57
   290 op greaterThanEq *tmp74 :pct PCT_HIGH
 
   293 op notEqual *tmp76 .state :setState.2:newState
   294 jump *label67 equal *tmp76 false
   295 set .state :setState.2:newState
-    * set *tmp78 .cycles
   296 op add .cycles .cycles 1
   297 op xor *tmp79 .inverted .state
   298 set .active *tmp79
 
   303 set *tmp80 "\nCurrently inactive:[salmon]"
   304 label *label70
   305 set .activeText *tmp80
-    * set *tmp77 .activeText
   306 jump *label68 always
   307 label *label67
-    * set *tmp77 null
   308 label *label68
   309 label *label66
   310 set *tmp75 null
 
   312 label *label64
   313 set *tmp75 null
   314 label *label65
-    * set *tmp68 *tmp75
   315 label *label58
   316 print "\n"
   317 print "Level: [gold]"
 
   329 print PCT_LOW
   330 print "%"
   331 print "[]"
-    * set *tmp81 null
   332 jump *label72 always
   333 label *label71
   334 print "\n"
 
   341 print PCT_HIGH
   342 print "%"
   343 print "[]"
-    * set *tmp81 null
   344 label *label72
   345 print .activeText
   346 set *tmp82 .links

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
   307 label *label67
   308 label *label68
   309 label *label66
-    * set *tmp75 null
   310 jump *label65 always
   311 label *label64
-    * set *tmp75 null
   312 label *label65
   313 label *label58
   314 print "\n"

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-20 instructions):
 
     4 set :initialize:repeat false
     5 print "Configuring regulator..."
     6 print "\n"
-    * set *tmp0 @links
-    * set .links *tmp0
+    7 set .links @links
     8 op sub :initialize:n .links 1
     9 label *label4
    10 jump *label6 lessThan :initialize:n 0
-    * getlink *tmp1 :initialize:n
-    * set :initialize:block *tmp1
+   11 getlink :initialize:block :initialize:n
    12 print "Found: "
    13 print :initialize:block
    14 print "\n"
 
    43 set .container :initialize:block
    44 set .measure @totalItems
    45 set .maximum @itemCapacity
-    * op add *tmp5 :initialize:n 1
-    * set .first *tmp5
+   46 op add .first :initialize:n 1
    47 jump *label7 always
    48 label *label14
    49 jump *label17 equal *tmp3 @liquid-tank
 
    54 set .container :initialize:block
    55 set .measure @totalLiquids
    56 set .maximum @liquidCapacity
-    * op add *tmp6 :initialize:n 1
-    * set .first *tmp6
+   57 op add .first :initialize:n 1
    58 jump *label7 always
    59 label *label16
    60 jump *label19 equal *tmp3 @battery
 
    64 set .container :initialize:block
    65 set .measure @totalPower
    66 set .maximum @powerCapacity
-    * op add *tmp7 :initialize:n 1
-    * set .first *tmp7
+   67 op add .first :initialize:n 1
    68 jump *label7 always
    69 label *label18
    70 jump *label21 equal *tmp3 @power-node
 
    75 set .container :initialize:block
    76 set .measure @powerNetStored
    77 set .maximum @powerNetCapacity
-    * op add *tmp8 :initialize:n 1
-    * set .first *tmp8
+   78 op add .first :initialize:n 1
    79 jump *label7 always
    80 label *label20
    81 label *label7
 
   132 op land *tmp17 *tmp15 *tmp16
   133 op floor *tmp18 PCT_LOW
   134 op strictEqual *tmp19 PCT_LOW *tmp18
-    * op land *tmp20 *tmp17 *tmp19
-    * set :validate:condition *tmp20
+  135 op land :validate:condition *tmp17 *tmp19
   136 set :validate:text "PCT_LOW must be an integer between 0 to 100."
   137 op equal *tmp21 :validate:condition false
   138 jump *label29 equal *tmp21 false
 
   148 op land *tmp25 *tmp23 *tmp24
   149 op floor *tmp26 PCT_HIGH
   150 op strictEqual *tmp27 PCT_HIGH *tmp26
-    * op land *tmp28 *tmp25 *tmp27
-    * set :validate.1:condition *tmp28
+  151 op land :validate.1:condition *tmp25 *tmp27
   152 set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
   153 op equal *tmp29 :validate.1:condition false
   154 jump *label32 equal *tmp29 false
 
   159 label *label32
   160 label *label33
   161 label *label31
-    * op lessThan *tmp31 PCT_LOW PCT_HIGH
-    * set :validate.2:condition *tmp31
+  162 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
   163 set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
   164 op equal *tmp32 :validate.2:condition false
   165 jump *label35 equal *tmp32 false
 
   171 label *label36
   172 label *label34
   173 sensor *tmp34 .sorter @type
-    * op equal *tmp35 *tmp34 @inverted-sorter
-    * set .inverted *tmp35
+  174 op equal .inverted *tmp34 @inverted-sorter
   175 set :setState:newState true
   176 op notEqual *tmp36 .state :setState:newState
   177 jump *label38 equal *tmp36 false
   178 set .state :setState:newState
   179 op add .cycles .cycles 1
-    * op xor *tmp39 .inverted .state
-    * set .active *tmp39
+  180 op xor .active .inverted .state
   181 jump *label40 equal .active false
   182 set *tmp40 "\nCurrently active:[green]"
   183 jump *label41 always
 
   190 label *label39
   191 label *label37
   192 label *label0
-    * set *tmp41 .switch
-    * control enabled *tmp41 0
+  193 control enabled .switch 0
   194 label *label42
   195 sensor *tmp43 .switch @enabled
   196 op equal *tmp44 *tmp43 0
 
   227 jump *label54 always
   228 label *label53
   229 label *label54
-    * sensor *tmp56 .sorter @config
-    * set :item *tmp56
+  230 sensor :item .sorter @config
   231 op equal *tmp57 :item null
   232 op notEqual *tmp58 .measure @totalItems
   233 op or *tmp60 *tmp57 *tmp58
 
   236 set :item .measure
   237 print "Measuring [gold]total[] in "
   238 print .container
-    * sensor *tmp62 .container .measure
-    * set :amount *tmp62
+  239 sensor :amount .container .measure
   240 jump *label56 always
   241 label *label55
   242 print "Measuring [gold]"
 
   244 print "["
   245 print "] in "
   246 print .container
-    * sensor *tmp63 .container :item
-    * set :amount *tmp63
+  247 sensor :amount .container :item
   248 label *label56
   249 op mul *tmp64 100 :amount
   250 sensor *tmp65 .container .maximum
-    * op idiv *tmp66 *tmp64 *tmp65
-    * set :pct *tmp66
+  251 op idiv :pct *tmp64 *tmp65
   252 op lessThanEq *tmp67 :pct PCT_LOW
   253 jump *label57 equal *tmp67 false
   254 set :setState.1:newState true
 
   256 jump *label60 equal *tmp69 false
   257 set .state :setState.1:newState
   258 op add .cycles .cycles 1
-    * op xor *tmp72 .inverted .state
-    * set .active *tmp72
+  259 op xor .active .inverted .state
   260 jump *label62 equal .active false
   261 set *tmp73 "\nCurrently active:[green]"
   262 jump *label63 always
 
   277 jump *label67 equal *tmp76 false
   278 set .state :setState.2:newState
   279 op add .cycles .cycles 1
-    * op xor *tmp79 .inverted .state
-    * set .active *tmp79
+  280 op xor .active .inverted .state
   281 jump *label69 equal .active false
   282 set *tmp80 "\nCurrently active:[green]"
   283 jump *label70 always
 
   327 set :n .first
   328 label *label73
   329 jump *label75 greaterThanEq :n *tmp82
-    * getlink *tmp83 :n
-    * set :block *tmp83
-    * set *tmp84 :block
-    * control enabled *tmp84 .active
+  330 getlink :block :n
+  331 control enabled :block .active
   332 print "\n    "
   333 print :block
   334 label *label74

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    13 print :initialize:block
    14 print "\n"
    15 sensor *tmp3 :initialize:block @type
-    * jump *label9 equal *tmp3 @message
-    * jump *label8 always
+   16 jump *label8 notEqual *tmp3 @message
    17 label *label9
    18 set .message :initialize:block
    19 jump *label7 always
    20 label *label8
-    * jump *label11 equal *tmp3 @switch
-    * jump *label10 always
+   21 jump *label10 notEqual *tmp3 @switch
    22 label *label11
    23 set .switch :initialize:block
    24 jump *label7 always
    25 label *label10
    26 jump *label13 equal *tmp3 @sorter
    27 jump *label13 equal *tmp3 @inverted-sorter
-    * jump *label13 equal *tmp3 @unloader
-    * jump *label12 always
+   28 jump *label12 notEqual *tmp3 @unloader
    29 label *label13
    30 set .sorter :initialize:block
    31 jump *label7 always
 
    34 jump *label15 equal *tmp3 @container
    35 jump *label15 equal *tmp3 @core-shard
    36 jump *label15 equal *tmp3 @core-foundation
-    * jump *label15 equal *tmp3 @core-nucleus
-    * jump *label14 always
+   37 jump *label14 notEqual *tmp3 @core-nucleus
    38 label *label15
    39 set .container :initialize:block
    40 set .measure @totalItems
 
    44 label *label14
    45 jump *label17 equal *tmp3 @liquid-tank
    46 jump *label17 equal *tmp3 @liquid-container
-    * jump *label17 equal *tmp3 @liquid-router
-    * jump *label16 always
+   47 jump *label16 notEqual *tmp3 @liquid-router
    48 label *label17
    49 set .container :initialize:block
    50 set .measure @totalLiquids
 
    53 jump *label7 always
    54 label *label16
    55 jump *label19 equal *tmp3 @battery
-    * jump *label19 equal *tmp3 @battery-large
-    * jump *label18 always
+   56 jump *label18 notEqual *tmp3 @battery-large
    57 label *label19
    58 set .container :initialize:block
    59 set .measure @totalPower
 
    63 label *label18
    64 jump *label21 equal *tmp3 @power-node
    65 jump *label21 equal *tmp3 @power-node-large
-    * jump *label21 equal *tmp3 @surge-tower
-    * jump *label20 always
+   66 jump *label20 notEqual *tmp3 @surge-tower
    67 label *label21
    68 set .container :initialize:block
    69 set .measure @powerNetStored

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-14 instructions):
 
    91 print "First index: "
    92 print .first
    93 print "\n"
-    * op equal *tmp9 .message null
-    * jump *label22 equal *tmp9 false
+   94 jump *label22 notEqual .message null
    95 print "No message."
    96 print "\n"
    97 set :initialize:repeat true
    98 jump *label23 always
    99 label *label22
   100 label *label23
-    * op equal *tmp11 .switch null
-    * jump *label24 equal *tmp11 false
+  101 jump *label24 notEqual .switch null
   102 print "No switch."
   103 print "\n"
   104 set :initialize:repeat true
   105 jump *label25 always
   106 label *label24
   107 label *label25
-    * op equal *tmp13 .container null
-    * jump *label26 equal *tmp13 false
+  108 jump *label26 notEqual .container null
   109 print "No container."
   110 print "\n"
   111 set :initialize:repeat true
 
   124 op strictEqual *tmp19 PCT_LOW *tmp18
   125 op land :validate:condition *tmp17 *tmp19
   126 set :validate:text "PCT_LOW must be an integer between 0 to 100."
-    * op equal *tmp21 :validate:condition false
-    * jump *label29 equal *tmp21 false
+  127 jump *label29 notEqual :validate:condition false
   128 print :validate:text
   129 printflush .message
   130 stop
 
   139 op strictEqual *tmp27 PCT_HIGH *tmp26
   140 op land :validate.1:condition *tmp25 *tmp27
   141 set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
-    * op equal *tmp29 :validate.1:condition false
-    * jump *label32 equal *tmp29 false
+  142 jump *label32 notEqual :validate.1:condition false
   143 print :validate.1:text
   144 printflush .message
   145 stop
 
   149 label *label31
   150 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
   151 set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
-    * op equal *tmp32 :validate.2:condition false
-    * jump *label35 equal *tmp32 false
+  152 jump *label35 notEqual :validate.2:condition false
   153 print :validate.2:text
   154 printflush .message
   155 stop
 
   160 sensor *tmp34 .sorter @type
   161 op equal .inverted *tmp34 @inverted-sorter
   162 set :setState:newState true
-    * op notEqual *tmp36 .state :setState:newState
-    * jump *label38 equal *tmp36 false
+  163 jump *label38 equal .state :setState:newState
   164 set .state :setState:newState
   165 op add .cycles .cycles 1
   166 op xor .active .inverted .state
 
   179 control enabled .switch 0
   180 label *label42
   181 sensor *tmp43 .switch @enabled
-    * op equal *tmp44 *tmp43 0
-    * jump *label44 equal *tmp44 false
+  182 jump *label44 notEqual *tmp43 0
   183 set :start @time
   184 sensor *tmp45 .container @dead
   185 jump *label45 equal *tmp45 false
 
   206 jump *label52 always
   207 label *label51
   208 label *label52
-    * op notEqual *tmp54 .links @links
-    * jump *label53 equal *tmp54 false
+  209 jump *label53 equal .links @links
   210 end
   211 jump *label54 always
   212 label *label53
 
   215 op equal *tmp57 :item null
   216 op notEqual *tmp58 .measure @totalItems
   217 op or *tmp60 *tmp57 *tmp58
-    * op notEqual *tmp59 *tmp60 false
-    * jump *label55 equal *tmp59 false
+  218 jump *label55 equal *tmp60 false
   219 set :item .measure
   220 print "Measuring [gold]total[] in "
   221 print .container
 
   232 op mul *tmp64 100 :amount
   233 sensor *tmp65 .container .maximum
   234 op idiv :pct *tmp64 *tmp65
-    * op lessThanEq *tmp67 :pct PCT_LOW
-    * jump *label57 equal *tmp67 false
+  235 jump *label57 greaterThan :pct PCT_LOW
   236 set :setState.1:newState true
-    * op notEqual *tmp69 .state :setState.1:newState
-    * jump *label60 equal *tmp69 false
+  237 jump *label60 equal .state :setState.1:newState
   238 set .state :setState.1:newState
   239 op add .cycles .cycles 1
   240 op xor .active .inverted .state
 
   251 label *label59
   252 jump *label58 always
   253 label *label57
-    * op greaterThanEq *tmp74 :pct PCT_HIGH
-    * jump *label64 equal *tmp74 false
+  254 jump *label64 lessThan :pct PCT_HIGH
   255 set :setState.2:newState false
-    * op notEqual *tmp76 .state :setState.2:newState
-    * jump *label67 equal *tmp76 false
+  256 jump *label67 equal .state :setState.2:newState
   257 set .state :setState.2:newState
   258 op add .cycles .cycles 1
   259 op xor .active .inverted .state

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-16 instructions):
 
    69 set .measure @powerNetStored
    70 set .maximum @powerNetCapacity
    71 op add .first :initialize:n 1
-    * jump *label7 always
    72 label *label20
    73 label *label7
    74 label *label5
 
    94 print "No message."
    95 print "\n"
    96 set :initialize:repeat true
-    * jump *label23 always
    97 label *label22
    98 label *label23
    99 jump *label24 notEqual .switch null
   100 print "No switch."
   101 print "\n"
   102 set :initialize:repeat true
-    * jump *label25 always
   103 label *label24
   104 label *label25
   105 jump *label26 notEqual .container null
   106 print "No container."
   107 print "\n"
   108 set :initialize:repeat true
-    * jump *label27 always
   109 label *label26
   110 label *label27
   111 printflush .message
 
   124 print :validate:text
   125 printflush .message
   126 stop
-    * jump *label30 always
   127 label *label29
   128 label *label30
   129 label *label28
 
   138 print :validate.1:text
   139 printflush .message
   140 stop
-    * jump *label33 always
   141 label *label32
   142 label *label33
   143 label *label31
 
   147 print :validate.2:text
   148 printflush .message
   149 stop
-    * jump *label36 always
   150 label *label35
   151 label *label36
   152 label *label34
 
   164 set *tmp40 "\nCurrently inactive:[salmon]"
   165 label *label41
   166 set .activeText *tmp40
-    * jump *label39 always
   167 label *label38
   168 label *label39
   169 label *label37
 
   176 sensor *tmp45 .container @dead
   177 jump *label45 equal *tmp45 false
   178 end
-    * jump *label46 always
   179 label *label45
   180 label *label46
   181 sensor *tmp47 .message @dead
   182 jump *label47 equal *tmp47 false
   183 end
-    * jump *label48 always
   184 label *label47
   185 label *label48
   186 sensor *tmp49 .switch @dead
   187 jump *label49 equal *tmp49 false
   188 end
-    * jump *label50 always
   189 label *label49
   190 label *label50
   191 sensor *tmp51 .sorter @dead
   192 op land *tmp52 .sorter *tmp51
   193 jump *label51 equal *tmp52 false
   194 end
-    * jump *label52 always
   195 label *label51
   196 label *label52
   197 jump *label53 equal .links @links
   198 end
-    * jump *label54 always
   199 label *label53
   200 label *label54
   201 sensor :item .sorter @config
 
   232 set *tmp73 "\nCurrently inactive:[salmon]"
   233 label *label63
   234 set .activeText *tmp73
-    * jump *label61 always
   235 label *label60
   236 label *label61
   237 label *label59
 
   250 set *tmp80 "\nCurrently inactive:[salmon]"
   251 label *label70
   252 set .activeText *tmp80
-    * jump *label68 always
   253 label *label67
   254 label *label68
   255 label *label66
-    * jump *label65 always
   256 label *label64
   257 label *label65
   258 label *label58

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
   121 op land :validate:condition *tmp17 *tmp19
   122 set :validate:text "PCT_LOW must be an integer between 0 to 100."
   123 jump *label29 notEqual :validate:condition false
-    * print :validate:text
+  124 print "PCT_LOW must be an integer between 0 to 100."
   125 printflush .message
   126 stop
   127 label *label29
 
   135 op land :validate.1:condition *tmp25 *tmp27
   136 set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
   137 jump *label32 notEqual :validate.1:condition false
-    * print :validate.1:text
+  138 print "PCT_HIGH must be an integer between 0 to 100."
   139 printflush .message
   140 stop
   141 label *label32
 
   144 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
   145 set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
   146 jump *label35 notEqual :validate.2:condition false
-    * print :validate.2:text
+  147 print "PCT_LOW must be less than PCT_HIGH."
   148 printflush .message
   149 stop
   150 label *label35
 
   153 sensor *tmp34 .sorter @type
   154 op equal .inverted *tmp34 @inverted-sorter
   155 set :setState:newState true
-    * jump *label38 equal .state :setState:newState
-    * set .state :setState:newState
+  156 jump *label38 equal false true
+  157 set .state true
   158 op add .cycles .cycles 1
-    * op xor .active .inverted .state
+  159 op xor .active .inverted :setState:newState
   160 jump *label40 equal .active false
   161 set *tmp40 "\nCurrently active:[green]"
   162 jump *label41 always
 
   203 op notEqual *tmp58 .measure @totalItems
   204 op or *tmp60 *tmp57 *tmp58
   205 jump *label55 equal *tmp60 false
-    * set :item .measure
   206 print "Measuring [gold]total[] in "
   207 print .container
   208 sensor :amount .container .measure
 
   220 op idiv :pct *tmp64 *tmp65
   221 jump *label57 greaterThan :pct PCT_LOW
   222 set :setState.1:newState true
-    * jump *label60 equal .state :setState.1:newState
-    * set .state :setState.1:newState
+  223 jump *label60 equal .state true
+  224 set .state true
   225 op add .cycles .cycles 1
-    * op xor .active .inverted .state
+  226 op xor .active .inverted :setState.1:newState
   227 jump *label62 equal .active false
   228 set *tmp73 "\nCurrently active:[green]"
   229 jump *label63 always
 
   238 label *label57
   239 jump *label64 lessThan :pct PCT_HIGH
   240 set :setState.2:newState false
-    * jump *label67 equal .state :setState.2:newState
-    * set .state :setState.2:newState
+  241 jump *label67 equal .state false
+  242 set .state false
   243 op add .cycles .cycles 1
-    * op xor .active .inverted .state
+  244 op xor .active .inverted :setState.2:newState
   245 jump *label69 equal .active false
   246 set *tmp80 "\nCurrently active:[green]"
   247 jump *label70 always
 
   288 set *tmp82 .links
   289 set :n .first
   290 label *label73
-    * jump *label75 greaterThanEq :n *tmp82
+  291 jump *label75 greaterThanEq :n .links
   292 getlink :block :n
   293 control enabled :block .active
   294 print "\n    "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
     0 set PCT_LOW 60
     1 set PCT_HIGH 80
-    * set .state false
     2 label *label1
     3 set :initialize:repeat false
     4 print "Configuring regulator..."
 
   118 op floor *tmp18 PCT_LOW
   119 op strictEqual *tmp19 PCT_LOW *tmp18
   120 op land :validate:condition *tmp17 *tmp19
-    * set :validate:text "PCT_LOW must be an integer between 0 to 100."
   121 jump *label29 notEqual :validate:condition false
   122 print "PCT_LOW must be an integer between 0 to 100."
   123 printflush .message
 
   131 op floor *tmp26 PCT_HIGH
   132 op strictEqual *tmp27 PCT_HIGH *tmp26
   133 op land :validate.1:condition *tmp25 *tmp27
-    * set :validate.1:text "PCT_HIGH must be an integer between 0 to 100."
   134 jump *label32 notEqual :validate.1:condition false
   135 print "PCT_HIGH must be an integer between 0 to 100."
   136 printflush .message
 
   139 label *label33
   140 label *label31
   141 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
-    * set :validate.2:text "PCT_LOW must be less than PCT_HIGH."
   142 jump *label35 notEqual :validate.2:condition false
   143 print "PCT_LOW must be less than PCT_HIGH."
   144 printflush .message
 
   152 jump *label38 equal false true
   153 set .state true
   154 op add .cycles .cycles 1
-    * op xor .active .inverted :setState:newState
+  155 op xor .active .inverted true
   156 jump *label40 equal .active false
   157 set *tmp40 "\nCurrently active:[green]"
   158 jump *label41 always
 
   219 jump *label60 equal .state true
   220 set .state true
   221 op add .cycles .cycles 1
-    * op xor .active .inverted :setState.1:newState
+  222 op xor .active .inverted true
   223 jump *label62 equal .active false
   224 set *tmp73 "\nCurrently active:[green]"
   225 jump *label63 always
 
   237 jump *label67 equal .state false
   238 set .state false
   239 op add .cycles .cycles 1
-    * op xor .active .inverted :setState.2:newState
+  240 op xor .active .inverted false
   241 jump *label69 equal .active false
   242 set *tmp80 "\nCurrently active:[green]"
   243 jump *label70 always
 
   281 print "[]"
   282 label *label72
   283 print .activeText
-    * set *tmp82 .links
   284 set :n .first
   285 label *label73
   286 jump *label75 greaterThanEq :n .links

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
   148 label *label34
   149 sensor *tmp34 .sorter @type
   150 op equal .inverted *tmp34 @inverted-sorter
-    * set :setState:newState true
   151 jump *label38 equal false true
   152 set .state true
   153 op add .cycles .cycles 1
 
   214 sensor *tmp65 .container .maximum
   215 op idiv :pct *tmp64 *tmp65
   216 jump *label57 greaterThan :pct PCT_LOW
-    * set :setState.1:newState true
   217 jump *label60 equal .state true
   218 set .state true
   219 op add .cycles .cycles 1
 
   231 jump *label58 always
   232 label *label57
   233 jump *label64 lessThan :pct PCT_HIGH
-    * set :setState.2:newState false
   234 jump *label67 equal .state false
   235 set .state false
   236 op add .cycles .cycles 1

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     7 op sub :initialize:n .links 1
     8 label *label4
     9 jump *label6 lessThan :initialize:n 0
+   10 label *label76
    11 getlink :initialize:block :initialize:n
    12 print "Found: "
    13 print :initialize:block
 
    73 label *label7
    74 label *label5
    75 op sub :initialize:n :initialize:n 1
-    * jump *label4 always
+   76 jump *label76 greaterThanEq :initialize:n 0
    77 label *label6
    78 print "Message: "
    79 print .message
 
   282 set :n .first
   283 label *label73
   284 jump *label75 greaterThanEq :n .links
+  285 label *label77
   286 getlink :block :n
   287 control enabled :block .active
   288 print "\n    "
   289 print :block
   290 label *label74
   291 op add :n :n 1
-    * jump *label73 always
+  292 jump *label77 lessThan :n .links
   293 label *label75
   294 print "[]"
   295 print "\n"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
   153 set .state true
   154 op add .cycles .cycles 1
   155 op xor .active .inverted true
-    * jump *label40 equal .active false
-    * set *tmp40 "\nCurrently active:[green]"
+  156 set .activeText "\nCurrently inactive:[salmon]"
+  157 jump *label41 equal .active false
+  158 set .activeText "\nCurrently active:[green]"
   159 jump *label41 always
-    * label *label40
-    * set *tmp40 "\nCurrently inactive:[salmon]"
   160 label *label41
-    * set .activeText *tmp40
   161 label *label38
   162 label *label39
   163 label *label37
 
   217 set .state true
   218 op add .cycles .cycles 1
   219 op xor .active .inverted true
-    * jump *label62 equal .active false
-    * set *tmp73 "\nCurrently active:[green]"
+  220 set .activeText "\nCurrently inactive:[salmon]"
+  221 jump *label63 equal .active false
+  222 set .activeText "\nCurrently active:[green]"
   223 jump *label63 always
-    * label *label62
-    * set *tmp73 "\nCurrently inactive:[salmon]"
   224 label *label63
-    * set .activeText *tmp73
   225 label *label60
   226 label *label61
   227 label *label59
 
   232 set .state false
   233 op add .cycles .cycles 1
   234 op xor .active .inverted false
-    * jump *label69 equal .active false
-    * set *tmp80 "\nCurrently active:[green]"
+  235 set .activeText "\nCurrently inactive:[salmon]"
+  236 jump *label70 equal .active false
+  237 set .activeText "\nCurrently active:[green]"
   238 jump *label70 always
-    * label *label69
-    * set *tmp80 "\nCurrently inactive:[salmon]"
   239 label *label70
-    * set .activeText *tmp80
   240 label *label67
   241 label *label68
   242 label *label66

Modifications by Replicate loop condition at line 36:5 (+1 instructions):
 
   166 label *label42
   167 sensor *tmp43 .switch @enabled
   168 jump *label44 notEqual *tmp43 0
+  169 label *label78
   170 set :start @time
   171 sensor *tmp45 .container @dead
   172 jump *label45 equal *tmp45 false
 
   299 print "ms"
   300 printflush .message
   301 label *label43
-    * jump *label42 always
+  302 sensor *tmp43 .switch @enabled
+  303 jump *label78 equal *tmp43 0
   304 label *label44
   305 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   276 print .activeText
   277 set :n .first
   278 label *label73
-    * jump *label75 greaterThanEq :n .links
+  279 jump *label75 greaterThanEq .first .links
   280 label *label77
   281 getlink :block :n
   282 control enabled :block .active

Modifications by Convert case at line 97:13 (segments: 1, padded low) (+131 instructions):
 
    13 print :initialize:block
    14 print "\n"
    15 sensor *tmp3 :initialize:block @type
-    * jump *label8 notEqual *tmp3 @message
+   16 sensor *tmp88 *tmp3 @id
+   17 jump *label79 greaterThanEq *tmp88 147
+   18 multijump *label81 *tmp88 0 (m:*label80)
+   19 multilabel *label81 (m:*label80)
+   20 jump *label79 always
+   21 multilabel *label82 (m:*label80)
+   22 jump *label79 always
+   23 multilabel *label83 (m:*label80)
+   24 jump *label79 always
+   25 multilabel *label84 (m:*label80)
+   26 jump *label79 always
+   27 multilabel *label85 (m:*label80)
+   28 jump *label79 always
+   29 multilabel *label86 (m:*label80)
+   30 jump *label79 always
+   31 multilabel *label87 (m:*label80)
+   32 jump *label79 always
+   33 multilabel *label88 (m:*label80)
+   34 jump *label79 always
+   35 multilabel *label89 (m:*label80)
+   36 jump *label79 always
+   37 multilabel *label90 (m:*label80)
+   38 jump *label79 always
+   39 multilabel *label91 (m:*label80)
+   40 jump *label79 always
+   41 multilabel *label92 (m:*label80)
+   42 jump *label79 always
+   43 multilabel *label93 (m:*label80)
+   44 jump *label79 always
+   45 multilabel *label94 (m:*label80)
+   46 jump *label79 always
+   47 multilabel *label95 (m:*label80)
+   48 jump *label79 always
+   49 multilabel *label96 (m:*label80)
+   50 jump *label79 always
+   51 multilabel *label97 (m:*label80)
+   52 jump *label79 always
+   53 multilabel *label98 (m:*label80)
+   54 jump *label79 always
+   55 multilabel *label99 (m:*label80)
+   56 jump *label79 always
+   57 multilabel *label100 (m:*label80)
+   58 jump *label79 always
+   59 multilabel *label101 (m:*label80)
+   60 jump *label79 always
+   61 multilabel *label102 (m:*label80)
+   62 jump *label79 always
+   63 multilabel *label103 (m:*label80)
+   64 jump *label79 always
+   65 multilabel *label104 (m:*label80)
+   66 jump *label79 always
+   67 multilabel *label105 (m:*label80)
+   68 jump *label79 always
+   69 multilabel *label106 (m:*label80)
+   70 jump *label79 always
+   71 multilabel *label107 (m:*label80)
+   72 jump *label79 always
+   73 multilabel *label108 (m:*label80)
+   74 jump *label79 always
+   75 multilabel *label109 (m:*label80)
+   76 jump *label79 always
+   77 multilabel *label110 (m:*label80)
+   78 jump *label79 always
+   79 multilabel *label111 (m:*label80)
+   80 jump *label79 always
+   81 multilabel *label112 (m:*label80)
+   82 jump *label79 always
+   83 multilabel *label113 (m:*label80)
+   84 jump *label79 always
+   85 multilabel *label114 (m:*label80)
+   86 jump *label79 always
+   87 multilabel *label115 (m:*label80)
+   88 jump *label79 always
+   89 multilabel *label116 (m:*label80)
+   90 jump *label79 always
+   91 multilabel *label117 (m:*label80)
+   92 jump *label79 always
+   93 multilabel *label118 (m:*label80)
+   94 jump *label79 always
+   95 multilabel *label119 (m:*label80)
+   96 jump *label79 always
+   97 multilabel *label120 (m:*label80)
+   98 jump *label79 always
+   99 multilabel *label121 (m:*label80)
+  100 jump *label79 always
+  101 multilabel *label122 (m:*label80)
+  102 jump *label79 always
+  103 multilabel *label123 (m:*label80)
+  104 jump *label79 always
+  105 multilabel *label124 (m:*label80)
+  106 jump *label79 always
+  107 multilabel *label125 (m:*label80)
+  108 jump *label79 always
+  109 multilabel *label126 (m:*label80)
+  110 jump *label79 always
+  111 multilabel *label127 (m:*label80)
+  112 jump *label79 always
+  113 multilabel *label128 (m:*label80)
+  114 jump *label79 always
+  115 multilabel *label129 (m:*label80)
+  116 jump *label13 always
+  117 multilabel *label130 (m:*label80)
+  118 jump *label13 always
+  119 multilabel *label131 (m:*label80)
+  120 jump *label79 always
+  121 multilabel *label132 (m:*label80)
+  122 jump *label79 always
+  123 multilabel *label133 (m:*label80)
+  124 jump *label79 always
+  125 multilabel *label134 (m:*label80)
+  126 jump *label79 always
+  127 multilabel *label135 (m:*label80)
+  128 jump *label79 always
+  129 multilabel *label136 (m:*label80)
+  130 jump *label79 always
+  131 multilabel *label137 (m:*label80)
+  132 jump *label79 always
+  133 multilabel *label138 (m:*label80)
+  134 jump *label79 always
+  135 multilabel *label139 (m:*label80)
+  136 jump *label79 always
+  137 multilabel *label140 (m:*label80)
+  138 jump *label79 always
+  139 multilabel *label141 (m:*label80)
+  140 jump *label79 always
+  141 multilabel *label142 (m:*label80)
+  142 jump *label79 always
+  143 multilabel *label143 (m:*label80)
+  144 jump *label79 always
+  145 multilabel *label144 (m:*label80)
+  146 jump *label17 always
+  147 multilabel *label145 (m:*label80)
+  148 jump *label17 always
+  149 multilabel *label146 (m:*label80)
+  150 jump *label79 always
+  151 multilabel *label147 (m:*label80)
+  152 jump *label79 always
+  153 multilabel *label148 (m:*label80)
+  154 jump *label79 always
+  155 multilabel *label149 (m:*label80)
+  156 jump *label21 always
+  157 multilabel *label150 (m:*label80)
+  158 jump *label21 always
+  159 multilabel *label151 (m:*label80)
+  160 jump *label21 always
+  161 multilabel *label152 (m:*label80)
+  162 jump *label79 always
+  163 multilabel *label153 (m:*label80)
+  164 jump *label19 always
+  165 multilabel *label154 (m:*label80)
+  166 jump *label19 always
+  167 multilabel *label155 (m:*label80)
+  168 jump *label79 always
+  169 multilabel *label156 (m:*label80)
+  170 jump *label79 always
+  171 multilabel *label157 (m:*label80)
+  172 jump *label79 always
+  173 multilabel *label158 (m:*label80)
+  174 jump *label79 always
+  175 multilabel *label159 (m:*label80)
+  176 jump *label79 always
+  177 multilabel *label160 (m:*label80)
+  178 jump *label79 always
+  179 multilabel *label161 (m:*label80)
+  180 jump *label79 always
+  181 multilabel *label162 (m:*label80)
+  182 jump *label79 always
+  183 multilabel *label163 (m:*label80)
+  184 jump *label79 always
+  185 multilabel *label164 (m:*label80)
+  186 jump *label79 always
+  187 multilabel *label165 (m:*label80)
+  188 jump *label79 always
+  189 multilabel *label166 (m:*label80)
+  190 jump *label79 always
+  191 multilabel *label167 (m:*label80)
+  192 jump *label79 always
+  193 multilabel *label168 (m:*label80)
+  194 jump *label79 always
+  195 multilabel *label169 (m:*label80)
+  196 jump *label79 always
+  197 multilabel *label170 (m:*label80)
+  198 jump *label79 always
+  199 multilabel *label171 (m:*label80)
+  200 jump *label15 always
+  201 multilabel *label172 (m:*label80)
+  202 jump *label15 always
+  203 multilabel *label173 (m:*label80)
+  204 jump *label15 always
+  205 multilabel *label174 (m:*label80)
+  206 jump *label15 always
+  207 multilabel *label175 (m:*label80)
+  208 jump *label15 always
+  209 multilabel *label176 (m:*label80)
+  210 jump *label13 always
+  211 multilabel *label177 (m:*label80)
+  212 jump *label79 always
+  213 multilabel *label178 (m:*label80)
+  214 jump *label79 always
+  215 multilabel *label179 (m:*label80)
+  216 jump *label79 always
+  217 multilabel *label180 (m:*label80)
+  218 jump *label79 always
+  219 multilabel *label181 (m:*label80)
+  220 jump *label79 always
+  221 multilabel *label182 (m:*label80)
+  222 jump *label79 always
+  223 multilabel *label183 (m:*label80)
+  224 jump *label79 always
+  225 multilabel *label184 (m:*label80)
+  226 jump *label79 always
+  227 multilabel *label185 (m:*label80)
+  228 jump *label79 always
+  229 multilabel *label186 (m:*label80)
+  230 jump *label79 always
+  231 multilabel *label187 (m:*label80)
+  232 jump *label79 always
+  233 multilabel *label188 (m:*label80)
+  234 jump *label79 always
+  235 multilabel *label189 (m:*label80)
+  236 jump *label79 always
+  237 multilabel *label190 (m:*label80)
+  238 jump *label79 always
+  239 multilabel *label191 (m:*label80)
+  240 jump *label79 always
+  241 multilabel *label192 (m:*label80)
+  242 jump *label79 always
+  243 multilabel *label193 (m:*label80)
+  244 jump *label79 always
+  245 multilabel *label194 (m:*label80)
+  246 jump *label79 always
+  247 multilabel *label195 (m:*label80)
+  248 jump *label79 always
+  249 multilabel *label196 (m:*label80)
+  250 jump *label79 always
+  251 multilabel *label197 (m:*label80)
+  252 jump *label79 always
+  253 multilabel *label198 (m:*label80)
+  254 jump *label79 always
+  255 multilabel *label199 (m:*label80)
+  256 jump *label79 always
+  257 multilabel *label200 (m:*label80)
+  258 jump *label79 always
+  259 multilabel *label201 (m:*label80)
+  260 jump *label79 always
+  261 multilabel *label202 (m:*label80)
+  262 jump *label79 always
+  263 multilabel *label203 (m:*label80)
+  264 jump *label79 always
+  265 multilabel *label204 (m:*label80)
+  266 jump *label79 always
+  267 multilabel *label205 (m:*label80)
+  268 jump *label79 always
+  269 multilabel *label206 (m:*label80)
+  270 jump *label79 always
+  271 multilabel *label207 (m:*label80)
+  272 jump *label79 always
+  273 multilabel *label208 (m:*label80)
+  274 jump *label79 always
+  275 multilabel *label209 (m:*label80)
+  276 jump *label79 always
+  277 multilabel *label210 (m:*label80)
+  278 jump *label79 always
+  279 multilabel *label211 (m:*label80)
+  280 jump *label79 always
+  281 multilabel *label212 (m:*label80)
+  282 jump *label79 always
+  283 multilabel *label213 (m:*label80)
+  284 jump *label79 always
+  285 multilabel *label214 (m:*label80)
+  286 jump *label79 always
+  287 multilabel *label215 (m:*label80)
+  288 jump *label79 always
+  289 multilabel *label216 (m:*label80)
+  290 jump *label79 always
+  291 multilabel *label217 (m:*label80)
+  292 jump *label79 always
+  293 multilabel *label218 (m:*label80)
+  294 jump *label9 always
+  295 multilabel *label219 (m:*label80)
+  296 jump *label11 always
+  297 multilabel *label220 (m:*label80)
+  298 jump *label79 always
+  299 multilabel *label221 (m:*label80)
+  300 jump *label79 always
+  301 multilabel *label222 (m:*label80)
+  302 jump *label79 always
+  303 multilabel *label223 (m:*label80)
+  304 jump *label79 always
+  305 multilabel *label224 (m:*label80)
+  306 jump *label79 always
+  307 multilabel *label225 (m:*label80)
+  308 jump *label79 always
+  309 multilabel *label226 (m:*label80)
+  310 jump *label79 always
+  311 multilabel *label227 (m:*label80)
+  312 label *label17
+  313 set .container :initialize:block
+  314 set .measure @totalLiquids
+  315 set .maximum @liquidCapacity
+  316 op add .first :initialize:n 1
+  317 jump *label7 always
   318 label *label9
   319 set .message :initialize:block
   320 jump *label7 always
   321 label *label8
-    * jump *label10 notEqual *tmp3 @switch
   322 label *label11
   323 set .switch :initialize:block
   324 jump *label7 always
   325 label *label10
-    * jump *label13 equal *tmp3 @sorter
-    * jump *label13 equal *tmp3 @inverted-sorter
-    * jump *label12 notEqual *tmp3 @unloader
   326 label *label13
   327 set .sorter :initialize:block
   328 jump *label7 always
   329 label *label12
-    * jump *label15 equal *tmp3 @vault
-    * jump *label15 equal *tmp3 @container
-    * jump *label15 equal *tmp3 @core-shard
-    * jump *label15 equal *tmp3 @core-foundation
-    * jump *label14 notEqual *tmp3 @core-nucleus
   330 label *label15
   331 set .container :initialize:block
   332 set .measure @totalItems
 
   334 op add .first :initialize:n 1
   335 jump *label7 always
   336 label *label14
-    * jump *label17 equal *tmp3 @liquid-tank
-    * jump *label17 equal *tmp3 @liquid-container
-    * jump *label16 notEqual *tmp3 @liquid-router
-    * label *label17
-    * set .container :initialize:block
-    * set .measure @totalLiquids
-    * set .maximum @liquidCapacity
-    * op add .first :initialize:n 1
-    * jump *label7 always
   337 label *label16
-    * jump *label19 equal *tmp3 @battery
-    * jump *label18 notEqual *tmp3 @battery-large
   338 label *label19
   339 set .container :initialize:block
   340 set .measure @totalPower
 
   342 op add .first :initialize:n 1
   343 jump *label7 always
   344 label *label18
-    * jump *label21 equal *tmp3 @power-node
-    * jump *label21 equal *tmp3 @power-node-large
-    * jump *label20 notEqual *tmp3 @surge-tower
   345 label *label21
   346 set .container :initialize:block
   347 set .measure @powerNetStored
   348 set .maximum @powerNetCapacity
   349 op add .first :initialize:n 1
   350 label *label20
+  351 label *label79
   352 label *label7
   353 label *label5
   354 op sub :initialize:n :initialize:n 1

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   428 label *label34
   429 sensor *tmp34 .sorter @type
   430 op equal .inverted *tmp34 @inverted-sorter
-    * jump *label38 equal false true
   431 set .state true
   432 op add .cycles .cycles 1
   433 op xor .active .inverted true

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
   434 set .activeText "\nCurrently inactive:[salmon]"
   435 jump *label41 equal .active false
   436 set .activeText "\nCurrently active:[green]"
-    * jump *label41 always
   437 label *label41
   438 label *label38
   439 label *label39
 
   498 set .activeText "\nCurrently inactive:[salmon]"
   499 jump *label63 equal .active false
   500 set .activeText "\nCurrently active:[green]"
-    * jump *label63 always
   501 label *label63
   502 label *label60
   503 label *label61
 
   512 set .activeText "\nCurrently inactive:[salmon]"
   513 jump *label70 equal .active false
   514 set .activeText "\nCurrently active:[green]"
-    * jump *label70 always
   515 label *label70
   516 label *label67
   517 label *label68

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   508 jump *label67 equal .state false
   509 set .state false
   510 op add .cycles .cycles 1
-    * op xor .active .inverted false
+  511 set .active .inverted
   512 set .activeText "\nCurrently inactive:[salmon]"
   513 jump *label70 equal .active false
   514 set .activeText "\nCurrently active:[green]"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   510 op add .cycles .cycles 1
   511 set .active .inverted
   512 set .activeText "\nCurrently inactive:[salmon]"
-    * jump *label70 equal .active false
+  513 jump *label70 equal .inverted false
   514 set .activeText "\nCurrently active:[green]"
   515 label *label70
   516 label *label67

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     5 print "\n"
     6 set .links @links
     7 op sub :initialize:n .links 1
-    * label *label4
     8 jump *label6 lessThan :initialize:n 0
     9 label *label76
    10 getlink :initialize:block :initialize:n
 
   317 label *label9
   318 set .message :initialize:block
   319 jump *label7 always
-    * label *label8
   320 label *label11
   321 set .switch :initialize:block
   322 jump *label7 always
-    * label *label10
   323 label *label13
   324 set .sorter :initialize:block
   325 jump *label7 always
-    * label *label12
   326 label *label15
   327 set .container :initialize:block
   328 set .measure @totalItems
   329 set .maximum @itemCapacity
   330 op add .first :initialize:n 1
   331 jump *label7 always
-    * label *label14
-    * label *label16
   332 label *label19
   333 set .container :initialize:block
   334 set .measure @totalPower
   335 set .maximum @powerCapacity
   336 op add .first :initialize:n 1
   337 jump *label7 always
-    * label *label18
   338 label *label21
   339 set .container :initialize:block
   340 set .measure @powerNetStored
   341 set .maximum @powerNetCapacity
   342 op add .first :initialize:n 1
-    * label *label20
   343 label *label79
   344 label *label7
-    * label *label5
   345 op sub :initialize:n :initialize:n 1
   346 jump *label76 greaterThanEq :initialize:n 0
   347 label *label6
 
   365 print "\n"
   366 set :initialize:repeat true
   367 label *label22
-    * label *label23
   368 jump *label24 notEqual .switch null
   369 print "No switch."
   370 print "\n"
   371 set :initialize:repeat true
   372 label *label24
-    * label *label25
   373 jump *label26 notEqual .container null
   374 print "No container."
   375 print "\n"
   376 set :initialize:repeat true
   377 label *label26
-    * label *label27
   378 printflush .message
-    * label *label2
   379 jump *label1 notEqual :initialize:repeat false
-    * label *label3
   380 printflush null
   381 op greaterThanEq *tmp15 PCT_LOW 0
   382 op lessThanEq *tmp16 PCT_LOW 100
 
   389 printflush .message
   390 stop
   391 label *label29
-    * label *label30
-    * label *label28
   392 op greaterThanEq *tmp23 PCT_HIGH 0
   393 op lessThanEq *tmp24 PCT_HIGH 100
   394 op land *tmp25 *tmp23 *tmp24
 
   400 printflush .message
   401 stop
   402 label *label32
-    * label *label33
-    * label *label31
   403 op lessThan :validate.2:condition PCT_LOW PCT_HIGH
   404 jump *label35 notEqual :validate.2:condition false
   405 print "PCT_LOW must be less than PCT_HIGH."
   406 printflush .message
   407 stop
   408 label *label35
-    * label *label36
-    * label *label34
   409 sensor *tmp34 .sorter @type
   410 op equal .inverted *tmp34 @inverted-sorter
   411 set .state true
 
   415 jump *label41 equal .active false
   416 set .activeText "\nCurrently active:[green]"
   417 label *label41
-    * label *label38
-    * label *label39
-    * label *label37
-    * label *label0
   418 control enabled .switch 0
-    * label *label42
   419 sensor *tmp43 .switch @enabled
   420 jump *label44 notEqual *tmp43 0
   421 label *label78
 
   424 jump *label45 equal *tmp45 false
   425 end
   426 label *label45
-    * label *label46
   427 sensor *tmp47 .message @dead
   428 jump *label47 equal *tmp47 false
   429 end
   430 label *label47
-    * label *label48
   431 sensor *tmp49 .switch @dead
   432 jump *label49 equal *tmp49 false
   433 end
   434 label *label49
-    * label *label50
   435 sensor *tmp51 .sorter @dead
   436 op land *tmp52 .sorter *tmp51
   437 jump *label51 equal *tmp52 false
   438 end
   439 label *label51
-    * label *label52
   440 jump *label53 equal .links @links
   441 end
   442 label *label53
-    * label *label54
   443 sensor :item .sorter @config
   444 op equal *tmp57 :item null
   445 op notEqual *tmp58 .measure @totalItems
 
   470 set .activeText "\nCurrently active:[green]"
   471 label *label63
   472 label *label60
-    * label *label61
-    * label *label59
   473 jump *label58 always
   474 label *label57
   475 jump *label64 lessThan :pct PCT_HIGH
 
   482 set .activeText "\nCurrently active:[green]"
   483 label *label70
   484 label *label67
-    * label *label68
-    * label *label66
   485 label *label64
-    * label *label65
   486 label *label58
   487 print "\n"
   488 print "Level: [gold]"
 
   515 label *label72
   516 print .activeText
   517 set :n .first
-    * label *label73
   518 jump *label75 greaterThanEq .first .links
   519 label *label77
   520 getlink :block :n
   521 control enabled :block .active
   522 print "\n    "
   523 print :block
-    * label *label74
   524 op add :n :n 1
   525 jump *label77 lessThan :n .links
   526 label *label75
 
   536 print " "
   537 print "ms"
   538 printflush .message
-    * label *label43
   539 sensor *tmp43 .switch @enabled
   540 jump *label78 equal *tmp43 0
   541 label *label44

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 set PCT_LOW 60
     2 set PCT_HIGH 80
     3 label *label1
 
   418 label *label41
   419 control enabled .switch 0
   420 sensor *tmp43 .switch @enabled
-    * jump *label44 notEqual *tmp43 0
+  421 jump __start__ notEqual *tmp43 0
   422 label *label78
   423 set :start @time
   424 sensor *tmp45 .container @dead
 
   462 sensor *tmp65 .container .maximum
   463 op idiv :pct *tmp64 *tmp65
   464 jump *label57 greaterThan :pct PCT_LOW
-    * jump *label60 equal .state true
+  465 jump *label58 equal .state true
   466 set .state true
   467 op add .cycles .cycles 1
   468 op xor .active .inverted true
   469 set .activeText "\nCurrently inactive:[salmon]"
-    * jump *label63 equal .active false
+  470 jump *label58 equal .active false
   471 set .activeText "\nCurrently active:[green]"
   472 label *label63
   473 label *label60

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1:
 
   469 set .activeText "\nCurrently inactive:[salmon]"
   470 jump *label58 equal .active false
   471 set .activeText "\nCurrently active:[green]"
-    * label *label63
-    * label *label60
   472 jump *label58 always
   473 label *label57
   474 jump *label64 lessThan :pct PCT_HIGH
 
   537 printflush .message
   538 sensor *tmp43 .switch @enabled
   539 jump *label78 equal *tmp43 0
-    * label *label44
   540 end

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   537 printflush .message
   538 sensor *tmp43 .switch @enabled
   539 jump *label78 equal *tmp43 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-25 instructions):
 
     2 set PCT_HIGH 80
     3 label *label1
     4 set :initialize:repeat false
-    * print "Configuring regulator..."
-    * print "\n"
+    5 print "Configuring regulator...\n"
     6 set .links @links
     7 op sub :initialize:n .links 1
     8 jump *label6 lessThan :initialize:n 0
 
   347 label *label6
   348 print "Message: "
   349 print .message
-    * print "\n"
-    * print "Switch: "
+  350 print "\nSwitch: "
   351 print .switch
-    * print "\n"
-    * print "Sorter: "
+  352 print "\nSorter: "
   353 print .sorter
-    * print "\n"
-    * print "Container: "
+  354 print "\nContainer: "
   355 print .container
-    * print "\n"
-    * print "First index: "
+  356 print "\nFirst index: "
   357 print .first
   358 print "\n"
   359 jump *label22 notEqual .message null
-    * print "No message."
-    * print "\n"
+  360 print "No message.\n"
   361 set :initialize:repeat true
   362 label *label22
   363 jump *label24 notEqual .switch null
-    * print "No switch."
-    * print "\n"
+  364 print "No switch.\n"
   365 set :initialize:repeat true
   366 label *label24
   367 jump *label26 notEqual .container null
-    * print "No container."
-    * print "\n"
+  368 print "No container.\n"
   369 set :initialize:repeat true
   370 label *label26
   371 printflush .message
 
   445 label *label55
   446 print "Measuring [gold]"
   447 print :item
-    * print "["
-    * print "] in "
+  448 print "[] in "
   449 print .container
   450 sensor :amount .container :item
   451 label *label56
 
   474 label *label67
   475 label *label64
   476 label *label58
-    * print "\n"
-    * print "Level: [gold]"
+  477 print "\nLevel: [gold]"
   478 print :pct
-    * print "%"
-    * print "[]"
+  479 print "%[]"
   480 jump *label71 equal .inverted false
-    * print "\n"
-    * print "Activate above [green]"
+  481 print "\nActivate above [green]"
   482 print PCT_HIGH
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate below [salmon]"
+  483 print "%[]\nDeactivate below [salmon]"
   484 print PCT_LOW
-    * print "%"
-    * print "[]"
+  485 print "%[]"
   486 jump *label72 always
   487 label *label71
-    * print "\n"
-    * print "Activate below [green]"
+  488 print "\nActivate below [green]"
   489 print PCT_LOW
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate above [salmon]"
+  490 print "%[]\nDeactivate above [salmon]"
   491 print PCT_HIGH
-    * print "%"
-    * print "[]"
+  492 print "%[]"
   493 label *label72
   494 print .activeText
   495 set :n .first
 
   502 op add :n :n 1
   503 jump *label77 lessThan :n .links
   504 label *label75
-    * print "[]"
-    * print "\n"
-    * print "# of cycles: "
+  505 print "[]\n# of cycles: "
   506 print .cycles
   507 op sub *tmp86 @time :start
   508 op floor *tmp87 *tmp86
-    * print "\n"
-    * print "[lightgray]Loop: "
+  509 print "\n[lightgray]Loop: "
   510 print *tmp87
-    * print " "
-    * print "ms"
+  511 print " ms"
   512 printflush .message
   513 sensor *tmp43 .switch @enabled
   514 jump *label78 equal *tmp43 0

Final code before resolving virtual instructions:

        label __start__                                              param PCT_LOW = 60;
    0:  set PCT_LOW 60                                               ...
    1:  set PCT_HIGH 80                                              param PCT_HIGH = 80;
        label *label1                                                do
    2:  set :initialize:repeat false                                 var repeat = false;
    3:  print "Configuring regulator...\n"                           println("Configuring regulator...");
    4:  set .links @links                                            links = @links;
    5:  op sub :initialize:n .links 1                                for var n in 0 ... links descending do
    6:  jump *label6 lessThan :initialize:n 0                        ...
        label *label76                                               ...
    7:  getlink :initialize:block :initialize:n                      var block = getlink(n);
    8:  print "Found: "                                              println("Found: ", block);
    9:  print :initialize:block                                      ...
   10:  print "\n"                                                   ...
   11:  sensor *tmp3 :initialize:block @type                         case block.@type
   12:  sensor *tmp88 *tmp3 @id                                      for var n in 0 ... links descending do
   13:  jump *label79 greaterThanEq *tmp88 147                       case block.@type
   14:  multijump *label81 *tmp88 0                                  ...
        multilabel *label81                                          ...
   15:  jump *label79 always 0 0                                     ...
        multilabel *label82                                          ...
   16:  jump *label79 always 0 0                                     ...
        multilabel *label83                                          ...
   17:  jump *label79 always 0 0                                     ...
        multilabel *label84                                          ...
   18:  jump *label79 always 0 0                                     ...
        multilabel *label85                                          ...
   19:  jump *label79 always 0 0                                     ...
        multilabel *label86                                          ...
   20:  jump *label79 always 0 0                                     ...
        multilabel *label87                                          ...
   21:  jump *label79 always 0 0                                     ...
        multilabel *label88                                          ...
   22:  jump *label79 always 0 0                                     ...
        multilabel *label89                                          ...
   23:  jump *label79 always 0 0                                     ...
        multilabel *label90                                          ...
   24:  jump *label79 always 0 0                                     ...
        multilabel *label91                                          ...
   25:  jump *label79 always 0 0                                     ...
        multilabel *label92                                          ...
   26:  jump *label79 always 0 0                                     ...
        multilabel *label93                                          ...
   27:  jump *label79 always 0 0                                     ...
        multilabel *label94                                          ...
   28:  jump *label79 always 0 0                                     ...
        multilabel *label95                                          ...
   29:  jump *label79 always 0 0                                     ...
        multilabel *label96                                          ...
   30:  jump *label79 always 0 0                                     ...
        multilabel *label97                                          ...
   31:  jump *label79 always 0 0                                     ...
        multilabel *label98                                          ...
   32:  jump *label79 always 0 0                                     ...
        multilabel *label99                                          ...
   33:  jump *label79 always 0 0                                     ...
        multilabel *label100                                         ...
   34:  jump *label79 always 0 0                                     ...
        multilabel *label101                                         ...
   35:  jump *label79 always 0 0                                     ...
        multilabel *label102                                         ...
   36:  jump *label79 always 0 0                                     ...
        multilabel *label103                                         ...
   37:  jump *label79 always 0 0                                     ...
        multilabel *label104                                         ...
   38:  jump *label79 always 0 0                                     ...
        multilabel *label105                                         ...
   39:  jump *label79 always 0 0                                     ...
        multilabel *label106                                         ...
   40:  jump *label79 always 0 0                                     ...
        multilabel *label107                                         ...
   41:  jump *label79 always 0 0                                     ...
        multilabel *label108                                         ...
   42:  jump *label79 always 0 0                                     ...
        multilabel *label109                                         ...
   43:  jump *label79 always 0 0                                     ...
        multilabel *label110                                         ...
   44:  jump *label79 always 0 0                                     ...
        multilabel *label111                                         ...
   45:  jump *label79 always 0 0                                     ...
        multilabel *label112                                         ...
   46:  jump *label79 always 0 0                                     ...
        multilabel *label113                                         ...
   47:  jump *label79 always 0 0                                     ...
        multilabel *label114                                         ...
   48:  jump *label79 always 0 0                                     ...
        multilabel *label115                                         ...
   49:  jump *label79 always 0 0                                     ...
        multilabel *label116                                         ...
   50:  jump *label79 always 0 0                                     ...
        multilabel *label117                                         ...
   51:  jump *label79 always 0 0                                     ...
        multilabel *label118                                         ...
   52:  jump *label79 always 0 0                                     ...
        multilabel *label119                                         ...
   53:  jump *label79 always 0 0                                     ...
        multilabel *label120                                         ...
   54:  jump *label79 always 0 0                                     ...
        multilabel *label121                                         ...
   55:  jump *label79 always 0 0                                     ...
        multilabel *label122                                         ...
   56:  jump *label79 always 0 0                                     ...
        multilabel *label123                                         ...
   57:  jump *label79 always 0 0                                     ...
        multilabel *label124                                         ...
   58:  jump *label79 always 0 0                                     ...
        multilabel *label125                                         ...
   59:  jump *label79 always 0 0                                     ...
        multilabel *label126                                         ...
   60:  jump *label79 always 0 0                                     ...
        multilabel *label127                                         ...
   61:  jump *label79 always 0 0                                     ...
        multilabel *label128                                         ...
   62:  jump *label79 always 0 0                                     ...
        multilabel *label129                                         ...
   63:  jump *label13 always 0 0                                     ...
        multilabel *label130                                         ...
   64:  jump *label13 always 0 0                                     ...
        multilabel *label131                                         ...
   65:  jump *label79 always 0 0                                     ...
        multilabel *label132                                         ...
   66:  jump *label79 always 0 0                                     ...
        multilabel *label133                                         ...
   67:  jump *label79 always 0 0                                     ...
        multilabel *label134                                         ...
   68:  jump *label79 always 0 0                                     ...
        multilabel *label135                                         ...
   69:  jump *label79 always 0 0                                     ...
        multilabel *label136                                         ...
   70:  jump *label79 always 0 0                                     ...
        multilabel *label137                                         ...
   71:  jump *label79 always 0 0                                     ...
        multilabel *label138                                         ...
   72:  jump *label79 always 0 0                                     ...
        multilabel *label139                                         ...
   73:  jump *label79 always 0 0                                     ...
        multilabel *label140                                         ...
   74:  jump *label79 always 0 0                                     ...
        multilabel *label141                                         ...
   75:  jump *label79 always 0 0                                     ...
        multilabel *label142                                         ...
   76:  jump *label79 always 0 0                                     ...
        multilabel *label143                                         ...
   77:  jump *label79 always 0 0                                     ...
        multilabel *label144                                         ...
   78:  jump *label17 always 0 0                                     ...
        multilabel *label145                                         ...
   79:  jump *label17 always 0 0                                     ...
        multilabel *label146                                         ...
   80:  jump *label79 always 0 0                                     ...
        multilabel *label147                                         ...
   81:  jump *label79 always 0 0                                     ...
        multilabel *label148                                         ...
   82:  jump *label79 always 0 0                                     ...
        multilabel *label149                                         ...
   83:  jump *label21 always 0 0                                     ...
        multilabel *label150                                         ...
   84:  jump *label21 always 0 0                                     ...
        multilabel *label151                                         ...
   85:  jump *label21 always 0 0                                     ...
        multilabel *label152                                         ...
   86:  jump *label79 always 0 0                                     ...
        multilabel *label153                                         ...
   87:  jump *label19 always 0 0                                     ...
        multilabel *label154                                         ...
   88:  jump *label19 always 0 0                                     ...
        multilabel *label155                                         ...
   89:  jump *label79 always 0 0                                     ...
        multilabel *label156                                         ...
   90:  jump *label79 always 0 0                                     ...
        multilabel *label157                                         ...
   91:  jump *label79 always 0 0                                     ...
        multilabel *label158                                         ...
   92:  jump *label79 always 0 0                                     ...
        multilabel *label159                                         ...
   93:  jump *label79 always 0 0                                     ...
        multilabel *label160                                         ...
   94:  jump *label79 always 0 0                                     ...
        multilabel *label161                                         ...
   95:  jump *label79 always 0 0                                     ...
        multilabel *label162                                         ...
   96:  jump *label79 always 0 0                                     ...
        multilabel *label163                                         ...
   97:  jump *label79 always 0 0                                     ...
        multilabel *label164                                         ...
   98:  jump *label79 always 0 0                                     ...
        multilabel *label165                                         ...
   99:  jump *label79 always 0 0                                     ...
        multilabel *label166                                         ...
  100:  jump *label79 always 0 0                                     ...
        multilabel *label167                                         ...
  101:  jump *label79 always 0 0                                     ...
        multilabel *label168                                         ...
  102:  jump *label79 always 0 0                                     ...
        multilabel *label169                                         ...
  103:  jump *label79 always 0 0                                     ...
        multilabel *label170                                         ...
  104:  jump *label79 always 0 0                                     ...
        multilabel *label171                                         ...
  105:  jump *label15 always 0 0                                     ...
        multilabel *label172                                         ...
  106:  jump *label15 always 0 0                                     ...
        multilabel *label173                                         ...
  107:  jump *label15 always 0 0                                     ...
        multilabel *label174                                         ...
  108:  jump *label15 always 0 0                                     ...
        multilabel *label175                                         ...
  109:  jump *label15 always 0 0                                     ...
        multilabel *label176                                         ...
  110:  jump *label13 always 0 0                                     ...
        multilabel *label177                                         ...
  111:  jump *label79 always 0 0                                     ...
        multilabel *label178                                         ...
  112:  jump *label79 always 0 0                                     ...
        multilabel *label179                                         ...
  113:  jump *label79 always 0 0                                     ...
        multilabel *label180                                         ...
  114:  jump *label79 always 0 0                                     ...
        multilabel *label181                                         ...
  115:  jump *label79 always 0 0                                     ...
        multilabel *label182                                         ...
  116:  jump *label79 always 0 0                                     ...
        multilabel *label183                                         ...
  117:  jump *label79 always 0 0                                     ...
        multilabel *label184                                         ...
  118:  jump *label79 always 0 0                                     ...
        multilabel *label185                                         ...
  119:  jump *label79 always 0 0                                     ...
        multilabel *label186                                         ...
  120:  jump *label79 always 0 0                                     ...
        multilabel *label187                                         ...
  121:  jump *label79 always 0 0                                     ...
        multilabel *label188                                         ...
  122:  jump *label79 always 0 0                                     ...
        multilabel *label189                                         ...
  123:  jump *label79 always 0 0                                     ...
        multilabel *label190                                         ...
  124:  jump *label79 always 0 0                                     ...
        multilabel *label191                                         ...
  125:  jump *label79 always 0 0                                     ...
        multilabel *label192                                         ...
  126:  jump *label79 always 0 0                                     ...
        multilabel *label193                                         ...
  127:  jump *label79 always 0 0                                     ...
        multilabel *label194                                         ...
  128:  jump *label79 always 0 0                                     ...
        multilabel *label195                                         ...
  129:  jump *label79 always 0 0                                     ...
        multilabel *label196                                         ...
  130:  jump *label79 always 0 0                                     ...
        multilabel *label197                                         ...
  131:  jump *label79 always 0 0                                     ...
        multilabel *label198                                         ...
  132:  jump *label79 always 0 0                                     ...
        multilabel *label199                                         ...
  133:  jump *label79 always 0 0                                     ...
        multilabel *label200                                         ...
  134:  jump *label79 always 0 0                                     ...
        multilabel *label201                                         ...
  135:  jump *label79 always 0 0                                     ...
        multilabel *label202                                         ...
  136:  jump *label79 always 0 0                                     ...
        multilabel *label203                                         ...
  137:  jump *label79 always 0 0                                     ...
        multilabel *label204                                         ...
  138:  jump *label79 always 0 0                                     ...
        multilabel *label205                                         ...
  139:  jump *label79 always 0 0                                     ...
        multilabel *label206                                         ...
  140:  jump *label79 always 0 0                                     ...
        multilabel *label207                                         ...
  141:  jump *label79 always 0 0                                     ...
        multilabel *label208                                         ...
  142:  jump *label79 always 0 0                                     ...
        multilabel *label209                                         ...
  143:  jump *label79 always 0 0                                     ...
        multilabel *label210                                         ...
  144:  jump *label79 always 0 0                                     ...
        multilabel *label211                                         ...
  145:  jump *label79 always 0 0                                     ...
        multilabel *label212                                         ...
  146:  jump *label79 always 0 0                                     ...
        multilabel *label213                                         ...
  147:  jump *label79 always 0 0                                     ...
        multilabel *label214                                         ...
  148:  jump *label79 always 0 0                                     ...
        multilabel *label215                                         ...
  149:  jump *label79 always 0 0                                     ...
        multilabel *label216                                         ...
  150:  jump *label79 always 0 0                                     ...
        multilabel *label217                                         ...
  151:  jump *label79 always 0 0                                     ...
        multilabel *label218                                         ...
  152:  jump *label9 always 0 0                                      ...
        multilabel *label219                                         ...
  153:  jump *label11 always 0 0                                     ...
        multilabel *label220                                         ...
  154:  jump *label79 always 0 0                                     ...
        multilabel *label221                                         ...
  155:  jump *label79 always 0 0                                     ...
        multilabel *label222                                         ...
  156:  jump *label79 always 0 0                                     ...
        multilabel *label223                                         ...
  157:  jump *label79 always 0 0                                     ...
        multilabel *label224                                         ...
  158:  jump *label79 always 0 0                                     ...
        multilabel *label225                                         ...
  159:  jump *label79 always 0 0                                     ...
        multilabel *label226                                         ...
  160:  jump *label79 always 0 0                                     ...
        multilabel *label227                                         ...
        label *label17                                               ...
  161:  set .container :initialize:block                             container = block;
  162:  set .measure @totalLiquids                                   measure = @totalLiquids;
  163:  set .maximum @liquidCapacity                                 maximum = @liquidCapacity;
  164:  op add .first :initialize:n 1                                first = n + 1;
  165:  jump *label7 always 0 0                                      case block.@type
        label *label9                                                ...
  166:  set .message :initialize:block                               message = block;
  167:  jump *label7 always 0 0                                      case block.@type
        label *label11                                               ...
  168:  set .switch :initialize:block                                switch = block;
  169:  jump *label7 always 0 0                                      case block.@type
        label *label13                                               ...
  170:  set .sorter :initialize:block                                sorter = block;
  171:  jump *label7 always 0 0                                      case block.@type
        label *label15                                               ...
  172:  set .container :initialize:block                             container = block;
  173:  set .measure @totalItems                                     measure = @totalItems;
  174:  set .maximum @itemCapacity                                   maximum = @itemCapacity;
  175:  op add .first :initialize:n 1                                first = n + 1;
  176:  jump *label7 always 0 0                                      case block.@type
        label *label19                                               ...
  177:  set .container :initialize:block                             container = block;
  178:  set .measure @totalPower                                     measure = @totalPower;
  179:  set .maximum @powerCapacity                                  maximum = @powerCapacity;
  180:  op add .first :initialize:n 1                                first = n + 1;
  181:  jump *label7 always 0 0                                      case block.@type
        label *label21                                               ...
  182:  set .container :initialize:block                             container = block;
  183:  set .measure @powerNetStored                                 measure = @powerNetStored;
  184:  set .maximum @powerNetCapacity                               maximum = @powerNetCapacity;
  185:  op add .first :initialize:n 1                                first = n + 1;
        label *label79                                               case block.@type
        label *label7                                                ...
  186:  op sub :initialize:n :initialize:n 1                         for var n in 0 ... links descending do
  187:  jump *label76 greaterThanEq :initialize:n 0                  ...
        label *label6                                                ...
  188:  print "Message: "                                            println("Message: ", message);
  189:  print .message                                               ...
  190:  print "\nSwitch: "                                           println("Switch: ", switch);
  191:  print .switch                                                ...
  192:  print "\nSorter: "                                           println("Sorter: ", sorter);
  193:  print .sorter                                                ...
  194:  print "\nContainer: "                                        println("Container: ", container);
  195:  print .container                                             ...
  196:  print "\nFirst index: "                                      println("First index: ", first);
  197:  print .first                                                 ...
  198:  print "\n"                                                   ...
  199:  jump *label22 notEqual .message null                         if message == null then println("No message."); repeat = true; end;
  200:  print "No message.\n"                                        ...
  201:  set :initialize:repeat true                                  ...
        label *label22                                               ...
  202:  jump *label24 notEqual .switch null                          if switch == null then println("No switch."); repeat = true; end;
  203:  print "No switch.\n"                                         ...
  204:  set :initialize:repeat true                                  ...
        label *label24                                               ...
  205:  jump *label26 notEqual .container null                       if container == null then println("No container."); repeat = true; end;
  206:  print "No container.\n"                                      ...
  207:  set :initialize:repeat true                                  ...
        label *label26                                               ...
  208:  printflush .message                                          printflush(message);
  209:  jump *label1 notEqual :initialize:repeat false               do
  210:  printflush null                                              printflush(null);
  211:  op greaterThanEq *tmp15 PCT_LOW 0                            validate(PCT_LOW >= 0 and PCT_LOW <= 100 and PCT_LOW === floor(PCT_LOW), "PCT_LOW must be an integer between 0 to 100.");
  212:  op lessThanEq *tmp16 PCT_LOW 100                             ...
  213:  op land *tmp17 *tmp15 *tmp16                                 ...
  214:  op floor *tmp18 PCT_LOW 0                                    ...
  215:  op strictEqual *tmp19 PCT_LOW *tmp18                         ...
  216:  op land :validate:condition *tmp17 *tmp19                    ...
  217:  jump *label29 notEqual :validate:condition false             if !condition then
  218:  print "PCT_LOW must be an integer between 0 to 100."         print(text);
  219:  printflush .message                                          printflush(message);
  220:  stop                                                         stopProcessor();
        label *label29                                               if !condition then
  221:  op greaterThanEq *tmp23 PCT_HIGH 0                           validate(PCT_HIGH >= 0 and PCT_HIGH <= 100 and PCT_HIGH === floor(PCT_HIGH), "PCT_HIGH must be an integer between 0 to 100.");
  222:  op lessThanEq *tmp24 PCT_HIGH 100                            ...
  223:  op land *tmp25 *tmp23 *tmp24                                 ...
  224:  op floor *tmp26 PCT_HIGH 0                                   ...
  225:  op strictEqual *tmp27 PCT_HIGH *tmp26                        ...
  226:  op land :validate.1:condition *tmp25 *tmp27                  ...
  227:  jump *label32 notEqual :validate.1:condition false           if !condition then
  228:  print "PCT_HIGH must be an integer between 0 to 100."        print(text);
  229:  printflush .message                                          printflush(message);
  230:  stop                                                         stopProcessor();
        label *label32                                               if !condition then
  231:  op lessThan :validate.2:condition PCT_LOW PCT_HIGH           validate(PCT_LOW < PCT_HIGH, "PCT_LOW must be less than PCT_HIGH.");
  232:  jump *label35 notEqual :validate.2:condition false           if !condition then
  233:  print "PCT_LOW must be less than PCT_HIGH."                  print(text);
  234:  printflush .message                                          printflush(message);
  235:  stop                                                         stopProcessor();
        label *label35                                               if !condition then
  236:  sensor *tmp34 .sorter @type                                  inverted = sorter.@type == @inverted-sorter;
  237:  op equal .inverted *tmp34 @inverted-sorter                   ...
  238:  set .state true                                              state = newState;
  239:  op add .cycles .cycles 1                                     if state != newState then
  240:  op xor .active .inverted true                                active = inverted ^ state;
  241:  set .activeText "\nCurrently inactive:[salmon]"              activeText = active ? "\nCurrently active:[green]" : "\nCurrently inactive:[salmon]";
  242:  jump *label41 equal .active false                            ...
  243:  set .activeText "\nCurrently active:[green]"                 ...
        label *label41                                               ...
  244:  control enabled .switch 0 0 0 0                              switch.enabled = 0;
  245:  sensor *tmp43 .switch @enabled                               while switch.@enabled == 0 do
  246:  jump __start__ notEqual *tmp43 0                             ...
        label *label78                                               ...
  247:  set :start @time                                             var start = @time;
  248:  sensor *tmp45 .container @dead                               if container.@dead          then end(); end;
  249:  jump *label45 equal *tmp45 false                             ...
  250:  end                                                          ...
        label *label45                                               ...
  251:  sensor *tmp47 .message @dead                                 if message.@dead            then end(); end;
  252:  jump *label47 equal *tmp47 false                             ...
  253:  end                                                          ...
        label *label47                                               ...
  254:  sensor *tmp49 .switch @dead                                  if switch.@dead             then end(); end;
  255:  jump *label49 equal *tmp49 false                             ...
  256:  end                                                          ...
        label *label49                                               ...
  257:  sensor *tmp51 .sorter @dead                                  if sorter and sorter.@dead  then end(); end;
  258:  op land *tmp52 .sorter *tmp51                                ...
  259:  jump *label51 equal *tmp52 false                             ...
  260:  end                                                          ...
        label *label51                                               ...
  261:  jump *label53 equal .links @links                            if links != @links          then end(); end;
  262:  end                                                          ...
        label *label53                                               ...
  263:  sensor :item .sorter @config                                 var item = sorter.@config;
  264:  op equal *tmp57 :item null                                   if item == null || measure != @totalItems then
  265:  op notEqual *tmp58 .measure @totalItems                      ...
  266:  op or *tmp60 *tmp57 *tmp58                                   ...
  267:  jump *label55 equal *tmp60 false                             ...
  268:  print "Measuring [gold]total[] in "                          print($"Measuring [gold]total[] in $container");
  269:  print .container                                             ...
  270:  sensor :amount .container .measure                           amount = container.sensor(measure);
  271:  jump *label56 always 0 0                                     if item == null || measure != @totalItems then
        label *label55                                               ...
  272:  print "Measuring [gold]"                                     print($"Measuring [gold]$item[] in $container");
  273:  print :item                                                  ...
  274:  print "[] in "                                               ...
  275:  print .container                                             ...
  276:  sensor :amount .container :item                              amount = container.sensor(item);
        label *label56                                               if item == null || measure != @totalItems then
  277:  op mul *tmp64 100 :amount                                    var pct = (100 * amount) \ container.sensor(maximum);
  278:  sensor *tmp65 .container .maximum                            ...
  279:  op idiv :pct *tmp64 *tmp65                                   ...
  280:  jump *label57 greaterThan :pct PCT_LOW                       if pct <= PCT_LOW then
  281:  jump *label58 equal .state true                              if state != newState then
  282:  set .state true                                              state = newState;
  283:  op add .cycles .cycles 1                                     if state != newState then
  284:  op xor .active .inverted true                                active = inverted ^ state;
  285:  set .activeText "\nCurrently inactive:[salmon]"              activeText = active ? "\nCurrently active:[green]" : "\nCurrently inactive:[salmon]";
  286:  jump *label58 equal .active false                            ...
  287:  set .activeText "\nCurrently active:[green]"                 ...
  288:  jump *label58 always 0 0                                     if pct <= PCT_LOW then
        label *label57                                               ...
  289:  jump *label64 lessThan :pct PCT_HIGH                         elsif pct >= PCT_HIGH then
  290:  jump *label67 equal .state false                             if state != newState then
  291:  set .state false                                             state = newState;
  292:  op add .cycles .cycles 1                                     if state != newState then
  293:  set .active .inverted                                        active = inverted ^ state;
  294:  set .activeText "\nCurrently inactive:[salmon]"              activeText = active ? "\nCurrently active:[green]" : "\nCurrently inactive:[salmon]";
  295:  jump *label70 equal .inverted false                          ...
  296:  set .activeText "\nCurrently active:[green]"                 ...
        label *label70                                               ...
        label *label67                                               if state != newState then
        label *label64                                               elsif pct >= PCT_HIGH then
        label *label58                                               if pct <= PCT_LOW then
  297:  print "\nLevel: [gold]"                                      print($"\nLevel: [gold]$pct%[]");
  298:  print :pct                                                   ...
  299:  print "%[]"                                                  ...
  300:  jump *label71 equal .inverted false                          if inverted then
  301:  print "\nActivate above [green]"                             print($"\nActivate above [green]$PCT_HIGH%[]");
  302:  print PCT_HIGH                                               ...
  303:  print "%[]\nDeactivate below [salmon]"                       print($"\nDeactivate below [salmon]$PCT_LOW%[]");
  304:  print PCT_LOW                                                ...
  305:  print "%[]"                                                  ...
  306:  jump *label72 always 0 0                                     if inverted then
        label *label71                                               ...
  307:  print "\nActivate below [green]"                             print($"\nActivate below [green]$PCT_LOW%[]");
  308:  print PCT_LOW                                                ...
  309:  print "%[]\nDeactivate above [salmon]"                       print($"\nDeactivate above [salmon]$PCT_HIGH%[]");
  310:  print PCT_HIGH                                               ...
  311:  print "%[]"                                                  ...
        label *label72                                               if inverted then
  312:  print .activeText                                            print(activeText);
  313:  set :n .first                                                for var n in first ... links do
  314:  jump *label75 greaterThanEq .first .links                    ...
        label *label77                                               ...
  315:  getlink :block :n                                            var block = getlink(n);
  316:  control enabled :block .active 0 0 0                         block.enabled = active;
  317:  print "\n    "                                               print("\n    ", block);
  318:  print :block                                                 ...
  319:  op add :n :n 1                                               for var n in first ... links do
  320:  jump *label77 lessThan :n .links                             ...
        label *label75                                               ...
  321:  print "[]\n# of cycles: "                                    print($"[]\n# of cycles: $cycles");
  322:  print .cycles                                                ...
  323:  op sub *tmp86 @time :start                                   print($"\n[lightgray]Loop: $ ms", floor(@time - start));
  324:  op floor *tmp87 *tmp86 0                                     ...
  325:  print "\n[lightgray]Loop: "                                  ...
  326:  print *tmp87                                                 ...
  327:  print " ms"                                                  ...
  328:  printflush .message                                          printflush(message);
  329:  sensor *tmp43 .switch @enabled                               while switch.@enabled == 0 do
  330:  jump *label78 equal *tmp43 0                                 ...


Code size and number of instantiations by function:
  Size  Times  AvgSize  Function
   224     1x    224,0  inline void initialize()
    75     1x     75,0  <no function>
    20     3x      6,7  inline void setState(in newState)
    12     3x      4,0  inline void validate(in condition, in text)

Performance: parsed in 223 ms, compiled in 216 ms, optimized in 393 ms, run in 57 ms.
Error connecting to Mlog Watcher: Connection refused: connect
  - make sure Mindustry with active Mlog Watcher mod is running
  - verify Mlog Watcher listens on port 9992

Program output (100,000 steps):
Configuring regulator...
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: message
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: display
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: bank
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Found: cell
Message: message
Switch: null
Sorter: null
Container: null
First index: null
No switch.
No container.

[--- Previous segment repeated 226,71 times ---]

Execution step limit of 100000 exceeded.
