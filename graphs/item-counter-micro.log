   230 instructions before optimizations.
     8 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    16 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (4 iterations).
     7 instructions eliminated by Jump Optimization (4 iterations).
     5 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
    97 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
    53 instructions eliminated by Data Flow Optimization (4 passes, 16 iterations).
     1 instructions eliminated by Loop Optimization (3 iterations).
     4 loops improved by Loop Optimization.
   110 instructions added by Loop Unrolling (7 iterations).
     3 loops unrolled by Loop Unrolling.
     2 instructions eliminated by Jump Straightening (4 iterations).
     4 instructions updated by JumpThreading.
     2 instructions eliminated by Unreachable Code Elimination.
    21 instructions eliminated by Print Merging.
    86 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 823):
    Replicate loop condition at line 67:5                        cost     1, benefit       25.0, efficiency       25.0
  * Unroll iteration loop at line 30:9                           cost     0, benefit      475.0, efficiency   Infinity (-8 instructions)
    Unroll loop at line 69:9                                     cost     6, benefit     5000.0, efficiency      833.3
    Unroll loop at line 82:9                                     cost     6, benefit     5000.0, efficiency      833.3

Pass 1: speed optimization selection (cost limit 831):
    Replicate loop condition at line 67:5                        cost     1, benefit       25.0, efficiency       25.0
  * Unroll loop at line 69:9                                     cost     6, benefit     5000.0, efficiency      833.3 (+54 instructions)
    Unroll loop at line 82:9                                     cost     6, benefit     5000.0, efficiency      833.3

Pass 1: speed optimization selection (cost limit 777):
    Replicate loop condition at line 67:5                        cost     1, benefit       25.0, efficiency       25.0
  * Unroll loop at line 82:9                                     cost     6, benefit     5000.0, efficiency      833.3 (+54 instructions)

Pass 1: speed optimization selection (cost limit 723):
  * Replicate loop condition at line 67:5                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    35 getlink *tmp3 :initialize.0:n
    36 set :initialize.0:block *tmp3
    37 sensor *tmp5 :initialize.0:block @type
-    * set *tmp6 *tmp5
-    * jump *label16 equal *tmp6 @memory-cell
-    * jump *label16 equal *tmp6 @memory-bank
+   38 jump *label16 equal *tmp5 @memory-cell
+   39 jump *label16 equal *tmp5 @memory-bank
    40 jump *label15 always
    41 label *label16
    42 set .memory :initialize.0:block
    43 set *tmp4 .memory
    44 jump *label14 always
    45 label *label15
-    * jump *label18 equal *tmp6 @plastanium-conveyor
+   46 jump *label18 equal *tmp5 @plastanium-conveyor
    47 jump *label17 always
    48 label *label18
    49 set .conv*3 .conv*2

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-11 instructions):
 
    40 jump *label15 always
    41 label *label16
    42 set .memory :initialize.0:block
-    * set *tmp4 .memory
    43 jump *label14 always
    44 label *label15
    45 jump *label18 equal *tmp5 @plastanium-conveyor
 
    51 set .conv*0 :initialize.0:block
    52 set *tmp7 .found
    53 op add .found .found 1
-    * set *tmp4 *tmp7
    54 jump *label14 always
    55 label *label17
-    * set *tmp4 null
    56 label *label14
    57 label *label12
    58 op sub :initialize.0:n :initialize.0:n 1
 
    69 print .found
    70 print ")"
    71 printflush message1
-    * set *tmp9 null
    72 jump *label20 always
    73 label *label19
    74 op greaterThan *tmp10 .found 4
 
    97 label *label24
    98 set *tmp11 *tmp13
    99 label *label22
-    * set *tmp9 *tmp11
   100 label *label20
   101 label *label2
   102 jump *label1 always
 
   124 jump *label31 equal *tmp26 false
   125 op add *tmp28 .total 10
   126 set .total *tmp28
-    * set *tmp27 *tmp28
   127 jump *label32 always
   128 label *label31
-    * set *tmp27 null
   129 label *label32
   130 label *label29
   131 op add :i :i 1
 
   163 jump *label36 equal *tmp40 false
   164 op add *tmp42 .total 10
   165 set .total *tmp42
-    * set *tmp41 *tmp42
   166 jump *label37 always
   167 label *label36
-    * set *tmp41 null
   168 label *label37
   169 label *label34
   170 op add :i.1 :i.1 1
 
   182 op notEqual *tmp46 .links @links
   183 jump *label38 equal *tmp46 false
   184 end
-    * set *tmp47 null
   185 jump *label39 always
   186 label *label38
-    * set *tmp47 null
   187 label *label39
   188 label *label26
   189 jump *label25 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-3 instructions):
 
    49 set .conv*2 .conv*1
    50 set .conv*1 .conv*0
    51 set .conv*0 :initialize.0:block
-    * set *tmp7 .found
    52 op add .found .found 1
    53 jump *label14 always
    54 label *label17
 
    81 print .found
    82 print ")"
    83 printflush message1
-    * set *tmp11 null
    84 jump *label22 always
    85 label *label21
    86 op equal *tmp12 .memory null
 
    93 jump *label3 always
    94 set *tmp13 null
    95 label *label24
-    * set *tmp11 *tmp13
    96 label *label22
    97 label *label20
    98 label *label2

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
    87 jump *label23 equal *tmp12 false
    88 print "$TITLE\n[salmon]No memory attached."
    89 printflush message1
-    * set *tmp13 null
    90 jump *label24 always
    91 label *label23
    92 jump *label3 always
-    * set *tmp13 null
    93 label *label24
    94 label *label22
    95 label *label20

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-8 instructions):
-    * read *tmp0 .memory 0
-    * set .total *tmp0
+    0 read .total .memory 0
     1 label *label1
     2 jump *label3 equal true false
     3 setaddr *tmp1 *label7
 
    26 label *label6
    27 set .memory null
    28 set .found 0
-    * set *tmp2 @links
-    * set .links *tmp2
+   29 set .links @links
    30 op sub :initialize.0:n .links 1
    31 label *label11
    32 jump *label13 lessThan :initialize.0:n 0
-    * getlink *tmp3 :initialize.0:n
-    * set :initialize.0:block *tmp3
+   33 getlink :initialize.0:block :initialize.0:n
    34 sensor *tmp5 :initialize.0:block @type
    35 jump *label16 equal *tmp5 @memory-cell
    36 jump *label16 equal *tmp5 @memory-bank
 
   104 label *label28
   105 jump *label30 greaterThanEq :i 4
   106 set *tmp17 :i
-    * set *tmp19 :i
-    * readarr *tmp20 .conv[] *tmp19
+  107 readarr *tmp20 .conv[] :i
   108 sensor *tmp21 *tmp20 @totalItems
   109 writearr *tmp21 .state1[] *tmp17
   110 set *tmp22 :i
 
   113 readarr *tmp25 .state2[] *tmp24
   114 op lessThan *tmp26 *tmp23 *tmp25
   115 jump *label31 equal *tmp26 false
-    * op add *tmp28 .total 10
-    * set .total *tmp28
+  116 op add .total .total 10
   117 jump *label32 always
   118 label *label31
   119 label *label32
 
   121 op add :i :i 1
   122 jump *label28 always
   123 label *label30
-    * set *tmp30 .total
-    * write *tmp30 .memory 0
+  124 write .total .memory 0
   125 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   126 print " "
   127 print "           "
 
   140 label *label33
   141 jump *label35 greaterThanEq :i.1 4
   142 set *tmp31 :i.1
-    * set *tmp33 :i.1
-    * readarr *tmp34 .conv[] *tmp33
+  143 readarr *tmp34 .conv[] :i.1
   144 sensor *tmp35 *tmp34 @totalItems
   145 writearr *tmp35 .state2[] *tmp31
   146 set *tmp36 :i.1
 
   149 readarr *tmp39 .state1[] *tmp38
   150 op lessThan *tmp40 *tmp37 *tmp39
   151 jump *label36 equal *tmp40 false
-    * op add *tmp42 .total 10
-    * set .total *tmp42
+  152 op add .total .total 10
   153 jump *label37 always
   154 label *label36
   155 label *label37

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
     0 read .total .memory 0
     1 label *label1
-    * jump *label3 equal true false
     2 setaddr *tmp1 *label7
     3 set :initialize.0:c .conv*0
     4 jump *label4 always

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-2 instructions):
 
    32 getlink :initialize.0:block :initialize.0:n
    33 sensor *tmp5 :initialize.0:block @type
    34 jump *label16 equal *tmp5 @memory-cell
-    * jump *label16 equal *tmp5 @memory-bank
-    * jump *label15 always
+   35 jump *label15 notEqual *tmp5 @memory-bank
    36 label *label16
    37 set .memory :initialize.0:block
    38 jump *label14 always
    39 label *label15
-    * jump *label18 equal *tmp5 @plastanium-conveyor
-    * jump *label17 always
+   40 jump *label17 notEqual *tmp5 @plastanium-conveyor
    41 label *label18
    42 set .conv*3 .conv*2
    43 set .conv*2 .conv*1

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-7 instructions):
 
    51 op sub :initialize.0:n :initialize.0:n 1
    52 jump *label11 always
    53 label *label13
-    * op equal *tmp8 .found 0
-    * jump *label19 equal *tmp8 false
+   54 jump *label19 notEqual .found 0
    55 print "[gold]Item Counter Micro[], version [gold]1.0[]"
    56 print "\"
    57 print "n[salmon]No plastanium conveyor attached (maximum: "
 
    63 printflush message1
    64 jump *label20 always
    65 label *label19
-    * op greaterThan *tmp10 .found 4
-    * jump *label21 equal *tmp10 false
+   66 jump *label21 lessThanEq .found 4
    67 print "[gold]Item Counter Micro[], version [gold]1.0[]"
    68 print "\"
    69 print "n[salmon]Too many plastanium conveyors attached (maximum: "
 
    75 printflush message1
    76 jump *label22 always
    77 label *label21
-    * op equal *tmp12 .memory null
-    * jump *label23 equal *tmp12 false
+   78 jump *label23 notEqual .memory null
    79 print "$TITLE\n[salmon]No memory attached."
    80 printflush message1
    81 jump *label24 always
 
    91 control enabled switch1 false
    92 label *label25
    93 sensor *tmp15 switch1 @enabled
-    * op equal *tmp16 *tmp15 false
-    * jump *label27 equal *tmp16 false
+   94 jump *label27 notEqual *tmp15 false
    95 set :start @time
    96 set :i 0
    97 label *label28
 
   104 set *tmp24 :i
   105 readarr *tmp23 .state1[] *tmp22
   106 readarr *tmp25 .state2[] *tmp24
-    * op lessThan *tmp26 *tmp23 *tmp25
-    * jump *label31 equal *tmp26 false
+  107 jump *label31 greaterThanEq *tmp23 *tmp25
   108 op add .total .total 10
   109 jump *label32 always
   110 label *label31
 
   139 set *tmp38 :i.1
   140 readarr *tmp37 .state2[] *tmp36
   141 readarr *tmp39 .state1[] *tmp38
-    * op lessThan *tmp40 *tmp37 *tmp39
-    * jump *label36 equal *tmp40 false
+  142 jump *label36 greaterThanEq *tmp37 *tmp39
   143 op add .total .total 10
   144 jump *label37 always
   145 label *label36
 
   157 print "ms"
   158 print "\n"
   159 printflush message1
-    * op notEqual *tmp46 .links @links
-    * jump *label38 equal *tmp46 false
+  160 jump *label38 equal .links @links
   161 end
   162 jump *label39 always
   163 label *label38

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    44 set .conv*1 .conv*0
    45 set .conv*0 :initialize.0:block
    46 op add .found .found 1
-    * jump *label14 always
    47 label *label17
    48 label *label14
    49 label *label12
 
   105 readarr *tmp25 .state2[] *tmp24
   106 jump *label31 greaterThanEq *tmp23 *tmp25
   107 op add .total .total 10
-    * jump *label32 always
   108 label *label31
   109 label *label32
   110 label *label29
 
   139 readarr *tmp39 .state1[] *tmp38
   140 jump *label36 greaterThanEq *tmp37 *tmp39
   141 op add .total .total 10
-    * jump *label37 always
   142 label *label36
   143 label *label37
   144 label *label34
 
   156 printflush message1
   157 jump *label38 equal .links @links
   158 end
-    * jump *label39 always
   159 label *label38
   160 label *label39
   161 label *label26

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   146 jump *label33 always
   147 label *label35
   148 op sub *tmp43 @time :start
-    * op div *tmp44 *tmp43 2
-    * op floor *tmp45 *tmp44
+  149 op idiv *tmp45 *tmp43 2
   150 print "[lightgray]Loop time: "
   151 print *tmp45
   152 print " "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
     0 read .total .memory 0
     1 label *label1
     2 setaddr *tmp1 *label7
-    * set :initialize.0:c .conv*0
     3 jump *label4 always
     4 multilabel *label7 marker0
-    * set .conv*0 :initialize.0:c
+    5 set .conv*0 null
     6 setaddr *tmp1 *label8
-    * set :initialize.0:c .conv*1
     7 jump *label4 always
     8 multilabel *label8 marker0
-    * set .conv*1 :initialize.0:c
+    9 set .conv*1 null
    10 setaddr *tmp1 *label9
-    * set :initialize.0:c .conv*2
    11 jump *label4 always
    12 multilabel *label9 marker0
-    * set .conv*2 :initialize.0:c
+   13 set .conv*2 null
    14 setaddr *tmp1 *label10
-    * set :initialize.0:c .conv*3
    15 label *label4
    16 set :initialize.0:c null
    17 label *label5
    18 multijump *tmp1 0 0 marker0
    19 multilabel *label10 marker0
-    * set .conv*3 :initialize.0:c
+   20 set .conv*3 null
    21 label *label6
    22 set .memory null
    23 set .found 0
 
    94 set *tmp17 :i
    95 readarr *tmp20 .conv[] :i
    96 sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] *tmp17
+   97 writearr *tmp21 .state1[] :i
    98 set *tmp22 :i
    99 set *tmp24 :i
-    * readarr *tmp23 .state1[] *tmp22
-    * readarr *tmp25 .state2[] *tmp24
+  100 readarr *tmp23 .state1[] :i
+  101 readarr *tmp25 .state2[] :i
   102 jump *label31 greaterThanEq *tmp23 *tmp25
   103 op add .total .total 10
   104 label *label31
 
   128 set *tmp31 :i.1
   129 readarr *tmp34 .conv[] :i.1
   130 sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] *tmp31
+  131 writearr *tmp35 .state2[] :i.1
   132 set *tmp36 :i.1
   133 set *tmp38 :i.1
-    * readarr *tmp37 .state2[] *tmp36
-    * readarr *tmp39 .state1[] *tmp38
+  134 readarr *tmp37 .state2[] :i.1
+  135 readarr *tmp39 .state1[] :i.1
   136 jump *label36 greaterThanEq *tmp37 *tmp39
   137 op add .total .total 10
   138 label *label36

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
    13 set .conv*2 null
    14 setaddr *tmp1 *label10
    15 label *label4
-    * set :initialize.0:c null
    16 label *label5
    17 multijump *tmp1 0 0 marker0
    18 multilabel *label10 marker0
 
    90 set :i 0
    91 label *label28
    92 jump *label30 greaterThanEq :i 4
-    * set *tmp17 :i
    93 readarr *tmp20 .conv[] :i
    94 sensor *tmp21 *tmp20 @totalItems
    95 writearr *tmp21 .state1[] :i
-    * set *tmp22 :i
-    * set *tmp24 :i
    96 readarr *tmp23 .state1[] :i
    97 readarr *tmp25 .state2[] :i
    98 jump *label31 greaterThanEq *tmp23 *tmp25
 
   121 set :i.1 0
   122 label *label33
   123 jump *label35 greaterThanEq :i.1 4
-    * set *tmp31 :i.1
   124 readarr *tmp34 .conv[] :i.1
   125 sensor *tmp35 *tmp34 @totalItems
   126 writearr *tmp35 .state2[] :i.1
-    * set *tmp36 :i.1
-    * set *tmp38 :i.1
   127 readarr *tmp37 .state2[] :i.1
   128 readarr *tmp39 .state1[] :i.1
   129 jump *label36 greaterThanEq *tmp37 *tmp39

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-2 instructions):
 
    24 op sub :initialize.0:n .links 1
    25 label *label11
    26 jump *label13 lessThan :initialize.0:n 0
+   27 label *label40
    28 getlink :initialize.0:block :initialize.0:n
    29 sensor *tmp5 :initialize.0:block @type
    30 jump *label16 equal *tmp5 @memory-cell
 
    44 label *label14
    45 label *label12
    46 op sub :initialize.0:n :initialize.0:n 1
-    * jump *label11 always
+   47 jump *label40 greaterThanEq :initialize.0:n 0
    48 label *label13
    49 jump *label19 notEqual .found 0
    50 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
    90 set :start @time
    91 set :i 0
    92 label *label28
-    * jump *label30 greaterThanEq :i 4
+   93 label *label41
    94 readarr *tmp20 .conv[] :i
    95 sensor *tmp21 *tmp20 @totalItems
    96 writearr *tmp21 .state1[] :i
 
   102 label *label32
   103 label *label29
   104 op add :i :i 1
-    * jump *label28 always
+  105 jump *label41 lessThan :i 4
   106 label *label30
   107 write .total .memory 0
   108 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
   121 print "\n"
   122 set :i.1 0
   123 label *label33
-    * jump *label35 greaterThanEq :i.1 4
+  124 label *label42
   125 readarr *tmp34 .conv[] :i.1
   126 sensor *tmp35 *tmp34 @totalItems
   127 writearr *tmp35 .state2[] :i.1
 
   133 label *label37
   134 label *label34
   135 op add :i.1 :i.1 1
-    * jump *label33 always
+  136 jump *label42 lessThan :i.1 4
   137 label *label35
   138 op sub *tmp43 @time :start
   139 op idiv *tmp45 *tmp43 2

Modifications by Unroll iteration loop at line 30:9 (-8 instructions):
     0 read .total .memory 0
     1 label *label1
-    * setaddr *tmp1 *label7
-    * jump *label4 always
-    * multilabel *label7 marker0
-    * set .conv*0 null
-    * setaddr *tmp1 *label8
-    * jump *label4 always
-    * multilabel *label8 marker0
-    * set .conv*1 null
-    * setaddr *tmp1 *label9
-    * jump *label4 always
-    * multilabel *label9 marker0
-    * set .conv*2 null
-    * setaddr *tmp1 *label10
-    * label *label4
-    * label *label5
-    * multijump *tmp1 0 0 marker0
-    * multilabel *label10 marker0
-    * set .conv*3 null
-    * label *label6
+    2 label *label43
+    3 label *label44
+    4 set .conv*0 null
+    5 label *label47
+    6 label *label48
+    7 set .conv*1 null
+    8 label *label51
+    9 label *label52
+   10 set .conv*2 null
+   11 label *label55
+   12 label *label56
+   13 set .conv*3 null
+   14 label *label6
    15 set .memory null
    16 set .found 0
    17 set .links @links

Modifications by Unroll loop at line 69:9 (+59 instructions):
 
    82 sensor *tmp15 switch1 @enabled
    83 jump *label27 notEqual *tmp15 false
    84 set :start @time
-    * set :i 0
-    * label *label28
-    * label *label41
-    * readarr *tmp20 .conv[] :i
-    * sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] :i
-    * readarr *tmp23 .state1[] :i
-    * readarr *tmp25 .state2[] :i
-    * jump *label31 greaterThanEq *tmp23 *tmp25
-    * op add .total .total 10
-    * label *label31
-    * label *label32
-    * label *label29
-    * op add :i :i 1
-    * jump *label41 lessThan :i 4
-    * label *label30
+   85 set :i 0
+   86 label *label60
+   87 label *label61
+   88 readarr *tmp20 .conv[] :i
+   89 sensor *tmp21 *tmp20 @totalItems
+   90 writearr *tmp21 .state1[] :i
+   91 readarr *tmp23 .state1[] :i
+   92 readarr *tmp25 .state2[] :i
+   93 jump *label62 greaterThanEq *tmp23 *tmp25
+   94 op add .total .total 10
+   95 label *label62
+   96 label *label63
+   97 label *label64
+   98 op add :i :i 1
+   99 label *label65
+  100 readarr *tmp20 .conv[] :i
+  101 sensor *tmp21 *tmp20 @totalItems
+  102 writearr *tmp21 .state1[] :i
+  103 readarr *tmp23 .state1[] :i
+  104 readarr *tmp25 .state2[] :i
+  105 jump *label66 greaterThanEq *tmp23 *tmp25
+  106 op add .total .total 10
+  107 label *label66
+  108 label *label67
+  109 label *label68
+  110 op add :i :i 1
+  111 label *label69
+  112 readarr *tmp20 .conv[] :i
+  113 sensor *tmp21 *tmp20 @totalItems
+  114 writearr *tmp21 .state1[] :i
+  115 readarr *tmp23 .state1[] :i
+  116 readarr *tmp25 .state2[] :i
+  117 jump *label70 greaterThanEq *tmp23 *tmp25
+  118 op add .total .total 10
+  119 label *label70
+  120 label *label71
+  121 label *label72
+  122 op add :i :i 1
+  123 label *label73
+  124 readarr *tmp20 .conv[] :i
+  125 sensor *tmp21 *tmp20 @totalItems
+  126 writearr *tmp21 .state1[] :i
+  127 readarr *tmp23 .state1[] :i
+  128 readarr *tmp25 .state2[] :i
+  129 jump *label74 greaterThanEq *tmp23 *tmp25
+  130 op add .total .total 10
+  131 label *label74
+  132 label *label75
+  133 label *label76
+  134 op add :i :i 1
+  135 label *label30
   136 write .total .memory 0
   137 print "[gold]Item Counter Micro[], version [gold]1.0[]"
   138 print " "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    85 set :i 0
    86 label *label60
    87 label *label61
-    * readarr *tmp20 .conv[] :i
+   88 readarr *tmp20 .conv[] 0
    89 sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] :i
-    * readarr *tmp23 .state1[] :i
-    * readarr *tmp25 .state2[] :i
+   90 writearr *tmp21 .state1[] 0
+   91 readarr *tmp23 .state1[] 0
+   92 readarr *tmp25 .state2[] 0
    93 jump *label62 greaterThanEq *tmp23 *tmp25
    94 op add .total .total 10
    95 label *label62
    96 label *label63
    97 label *label64
-    * op add :i :i 1
+   98 op add :i 0 1
    99 label *label65
-    * readarr *tmp20 .conv[] :i
+  100 readarr *tmp20 .conv[] 1
   101 sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] :i
-    * readarr *tmp23 .state1[] :i
-    * readarr *tmp25 .state2[] :i
+  102 writearr *tmp21 .state1[] 1
+  103 readarr *tmp23 .state1[] 1
+  104 readarr *tmp25 .state2[] 1
   105 jump *label66 greaterThanEq *tmp23 *tmp25
   106 op add .total .total 10
   107 label *label66
   108 label *label67
   109 label *label68
-    * op add :i :i 1
+  110 op add :i 1 1
   111 label *label69
-    * readarr *tmp20 .conv[] :i
+  112 readarr *tmp20 .conv[] 2
   113 sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] :i
-    * readarr *tmp23 .state1[] :i
-    * readarr *tmp25 .state2[] :i
+  114 writearr *tmp21 .state1[] 2
+  115 readarr *tmp23 .state1[] 2
+  116 readarr *tmp25 .state2[] 2
   117 jump *label70 greaterThanEq *tmp23 *tmp25
   118 op add .total .total 10
   119 label *label70
   120 label *label71
   121 label *label72
-    * op add :i :i 1
+  122 op add :i 2 1
   123 label *label73
-    * readarr *tmp20 .conv[] :i
+  124 readarr *tmp20 .conv[] 3
   125 sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] :i
-    * readarr *tmp23 .state1[] :i
-    * readarr *tmp25 .state2[] :i
+  126 writearr *tmp21 .state1[] 3
+  127 readarr *tmp23 .state1[] 3
+  128 readarr *tmp25 .state2[] 3
   129 jump *label74 greaterThanEq *tmp23 *tmp25
   130 op add .total .total 10
   131 label *label74
   132 label *label75
   133 label *label76
-    * op add :i :i 1
+  134 op add :i 3 1
   135 label *label30
   136 write .total .memory 0
   137 print "[gold]Item Counter Micro[], version [gold]1.0[]"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
    82 sensor *tmp15 switch1 @enabled
    83 jump *label27 notEqual *tmp15 false
    84 set :start @time
-    * set :i 0
    85 label *label60
    86 label *label61
    87 readarr *tmp20 .conv[] 0
 
    94 label *label62
    95 label *label63
    96 label *label64
-    * op add :i 0 1
    97 label *label65
    98 readarr *tmp20 .conv[] 1
    99 sensor *tmp21 *tmp20 @totalItems
 
   105 label *label66
   106 label *label67
   107 label *label68
-    * op add :i 1 1
   108 label *label69
   109 readarr *tmp20 .conv[] 2
   110 sensor *tmp21 *tmp20 @totalItems
 
   116 label *label70
   117 label *label71
   118 label *label72
-    * op add :i 2 1
   119 label *label73
   120 readarr *tmp20 .conv[] 3
   121 sensor *tmp21 *tmp20 @totalItems
 
   127 label *label74
   128 label *label75
   129 label *label76
-    * op add :i 3 1
   130 label *label30
   131 write .total .memory 0
   132 print "[gold]Item Counter Micro[], version [gold]1.0[]"

Modifications by Unroll loop at line 82:9 (+59 instructions):
 
   143 print "["
   144 print "]"
   145 print "\n"
-    * set :i.1 0
-    * label *label33
-    * label *label42
-    * readarr *tmp34 .conv[] :i.1
-    * sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] :i.1
-    * readarr *tmp37 .state2[] :i.1
-    * readarr *tmp39 .state1[] :i.1
-    * jump *label36 greaterThanEq *tmp37 *tmp39
-    * op add .total .total 10
-    * label *label36
-    * label *label37
-    * label *label34
-    * op add :i.1 :i.1 1
-    * jump *label42 lessThan :i.1 4
-    * label *label35
+  146 set :i.1 0
+  147 label *label77
+  148 label *label78
+  149 readarr *tmp34 .conv[] :i.1
+  150 sensor *tmp35 *tmp34 @totalItems
+  151 writearr *tmp35 .state2[] :i.1
+  152 readarr *tmp37 .state2[] :i.1
+  153 readarr *tmp39 .state1[] :i.1
+  154 jump *label79 greaterThanEq *tmp37 *tmp39
+  155 op add .total .total 10
+  156 label *label79
+  157 label *label80
+  158 label *label81
+  159 op add :i.1 :i.1 1
+  160 label *label82
+  161 readarr *tmp34 .conv[] :i.1
+  162 sensor *tmp35 *tmp34 @totalItems
+  163 writearr *tmp35 .state2[] :i.1
+  164 readarr *tmp37 .state2[] :i.1
+  165 readarr *tmp39 .state1[] :i.1
+  166 jump *label83 greaterThanEq *tmp37 *tmp39
+  167 op add .total .total 10
+  168 label *label83
+  169 label *label84
+  170 label *label85
+  171 op add :i.1 :i.1 1
+  172 label *label86
+  173 readarr *tmp34 .conv[] :i.1
+  174 sensor *tmp35 *tmp34 @totalItems
+  175 writearr *tmp35 .state2[] :i.1
+  176 readarr *tmp37 .state2[] :i.1
+  177 readarr *tmp39 .state1[] :i.1
+  178 jump *label87 greaterThanEq *tmp37 *tmp39
+  179 op add .total .total 10
+  180 label *label87
+  181 label *label88
+  182 label *label89
+  183 op add :i.1 :i.1 1
+  184 label *label90
+  185 readarr *tmp34 .conv[] :i.1
+  186 sensor *tmp35 *tmp34 @totalItems
+  187 writearr *tmp35 .state2[] :i.1
+  188 readarr *tmp37 .state2[] :i.1
+  189 readarr *tmp39 .state1[] :i.1
+  190 jump *label91 greaterThanEq *tmp37 *tmp39
+  191 op add .total .total 10
+  192 label *label91
+  193 label *label92
+  194 label *label93
+  195 op add :i.1 :i.1 1
+  196 label *label35
   197 op sub *tmp43 @time :start
   198 op idiv *tmp45 *tmp43 2
   199 print "[lightgray]Loop time: "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   146 set :i.1 0
   147 label *label77
   148 label *label78
-    * readarr *tmp34 .conv[] :i.1
+  149 readarr *tmp34 .conv[] 0
   150 sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] :i.1
-    * readarr *tmp37 .state2[] :i.1
-    * readarr *tmp39 .state1[] :i.1
+  151 writearr *tmp35 .state2[] 0
+  152 readarr *tmp37 .state2[] 0
+  153 readarr *tmp39 .state1[] 0
   154 jump *label79 greaterThanEq *tmp37 *tmp39
   155 op add .total .total 10
   156 label *label79
   157 label *label80
   158 label *label81
-    * op add :i.1 :i.1 1
+  159 op add :i.1 0 1
   160 label *label82
-    * readarr *tmp34 .conv[] :i.1
+  161 readarr *tmp34 .conv[] 1
   162 sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] :i.1
-    * readarr *tmp37 .state2[] :i.1
-    * readarr *tmp39 .state1[] :i.1
+  163 writearr *tmp35 .state2[] 1
+  164 readarr *tmp37 .state2[] 1
+  165 readarr *tmp39 .state1[] 1
   166 jump *label83 greaterThanEq *tmp37 *tmp39
   167 op add .total .total 10
   168 label *label83
   169 label *label84
   170 label *label85
-    * op add :i.1 :i.1 1
+  171 op add :i.1 1 1
   172 label *label86
-    * readarr *tmp34 .conv[] :i.1
+  173 readarr *tmp34 .conv[] 2
   174 sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] :i.1
-    * readarr *tmp37 .state2[] :i.1
-    * readarr *tmp39 .state1[] :i.1
+  175 writearr *tmp35 .state2[] 2
+  176 readarr *tmp37 .state2[] 2
+  177 readarr *tmp39 .state1[] 2
   178 jump *label87 greaterThanEq *tmp37 *tmp39
   179 op add .total .total 10
   180 label *label87
   181 label *label88
   182 label *label89
-    * op add :i.1 :i.1 1
+  183 op add :i.1 2 1
   184 label *label90
-    * readarr *tmp34 .conv[] :i.1
+  185 readarr *tmp34 .conv[] 3
   186 sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] :i.1
-    * readarr *tmp37 .state2[] :i.1
-    * readarr *tmp39 .state1[] :i.1
+  187 writearr *tmp35 .state2[] 3
+  188 readarr *tmp37 .state2[] 3
+  189 readarr *tmp39 .state1[] 3
   190 jump *label91 greaterThanEq *tmp37 *tmp39
   191 op add .total .total 10
   192 label *label91
   193 label *label92
   194 label *label93
-    * op add :i.1 :i.1 1
+  195 op add :i.1 3 1
   196 label *label35
   197 op sub *tmp43 @time :start
   198 op idiv *tmp45 *tmp43 2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
   143 print "["
   144 print "]"
   145 print "\n"
-    * set :i.1 0
   146 label *label77
   147 label *label78
   148 readarr *tmp34 .conv[] 0
 
   155 label *label79
   156 label *label80
   157 label *label81
-    * op add :i.1 0 1
   158 label *label82
   159 readarr *tmp34 .conv[] 1
   160 sensor *tmp35 *tmp34 @totalItems
 
   166 label *label83
   167 label *label84
   168 label *label85
-    * op add :i.1 1 1
   169 label *label86
   170 readarr *tmp34 .conv[] 2
   171 sensor *tmp35 *tmp34 @totalItems
 
   177 label *label87
   178 label *label88
   179 label *label89
-    * op add :i.1 2 1
   180 label *label90
   181 readarr *tmp34 .conv[] 3
   182 sensor *tmp35 *tmp34 @totalItems
 
   188 label *label91
   189 label *label92
   190 label *label93
-    * op add :i.1 3 1
   191 label *label35
   192 op sub *tmp43 @time :start
   193 op idiv *tmp45 *tmp43 2

Modifications by Replicate loop condition at line 67:5 (+1 instructions):
 
    81 label *label25
    82 sensor *tmp15 switch1 @enabled
    83 jump *label27 notEqual *tmp15 false
+   84 label *label94
    85 set :start @time
    86 label *label60
    87 label *label61
 
   203 label *label38
   204 label *label39
   205 label *label26
-    * jump *label25 always
+  206 sensor *tmp15 switch1 @enabled
+  207 jump *label94 equal *tmp15 false
   208 label *label27
   209 set .total 0
   210 write 0 .memory 0

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-136 instructions):
 
    85 set :start @time
    86 label *label60
    87 label *label61
-    * readarr *tmp20 .conv[] 0
+   88 set *tmp20 .conv*0
    89 sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] 0
-    * readarr *tmp23 .state1[] 0
-    * readarr *tmp25 .state2[] 0
+   90 set .state1*0 *tmp21
+   91 set *tmp23 .state1*0
+   92 set *tmp25 .state2*0
    93 jump *label62 greaterThanEq *tmp23 *tmp25
    94 op add .total .total 10
    95 label *label62
    96 label *label63
    97 label *label64
    98 label *label65
-    * readarr *tmp20 .conv[] 1
+   99 set *tmp20 .conv*1
   100 sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] 1
-    * readarr *tmp23 .state1[] 1
-    * readarr *tmp25 .state2[] 1
+  101 set .state1*1 *tmp21
+  102 set *tmp23 .state1*1
+  103 set *tmp25 .state2*1
   104 jump *label66 greaterThanEq *tmp23 *tmp25
   105 op add .total .total 10
   106 label *label66
   107 label *label67
   108 label *label68
   109 label *label69
-    * readarr *tmp20 .conv[] 2
+  110 set *tmp20 .conv*2
   111 sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] 2
-    * readarr *tmp23 .state1[] 2
-    * readarr *tmp25 .state2[] 2
+  112 set .state1*2 *tmp21
+  113 set *tmp23 .state1*2
+  114 set *tmp25 .state2*2
   115 jump *label70 greaterThanEq *tmp23 *tmp25
   116 op add .total .total 10
   117 label *label70
   118 label *label71
   119 label *label72
   120 label *label73
-    * readarr *tmp20 .conv[] 3
+  121 set *tmp20 .conv*3
   122 sensor *tmp21 *tmp20 @totalItems
-    * writearr *tmp21 .state1[] 3
-    * readarr *tmp23 .state1[] 3
-    * readarr *tmp25 .state2[] 3
+  123 set .state1*3 *tmp21
+  124 set *tmp23 .state1*3
+  125 set *tmp25 .state2*3
   126 jump *label74 greaterThanEq *tmp23 *tmp25
   127 op add .total .total 10
   128 label *label74
 
   146 print "\n"
   147 label *label77
   148 label *label78
-    * readarr *tmp34 .conv[] 0
+  149 set *tmp34 .conv*0
   150 sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] 0
-    * readarr *tmp37 .state2[] 0
-    * readarr *tmp39 .state1[] 0
+  151 set .state2*0 *tmp35
+  152 set *tmp37 .state2*0
+  153 set *tmp39 .state1*0
   154 jump *label79 greaterThanEq *tmp37 *tmp39
   155 op add .total .total 10
   156 label *label79
   157 label *label80
   158 label *label81
   159 label *label82
-    * readarr *tmp34 .conv[] 1
+  160 set *tmp34 .conv*1
   161 sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] 1
-    * readarr *tmp37 .state2[] 1
-    * readarr *tmp39 .state1[] 1
+  162 set .state2*1 *tmp35
+  163 set *tmp37 .state2*1
+  164 set *tmp39 .state1*1
   165 jump *label83 greaterThanEq *tmp37 *tmp39
   166 op add .total .total 10
   167 label *label83
   168 label *label84
   169 label *label85
   170 label *label86
-    * readarr *tmp34 .conv[] 2
+  171 set *tmp34 .conv*2
   172 sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] 2
-    * readarr *tmp37 .state2[] 2
-    * readarr *tmp39 .state1[] 2
+  173 set .state2*2 *tmp35
+  174 set *tmp37 .state2*2
+  175 set *tmp39 .state1*2
   176 jump *label87 greaterThanEq *tmp37 *tmp39
   177 op add .total .total 10
   178 label *label87
   179 label *label88
   180 label *label89
   181 label *label90
-    * readarr *tmp34 .conv[] 3
+  182 set *tmp34 .conv*3
   183 sensor *tmp35 *tmp34 @totalItems
-    * writearr *tmp35 .state2[] 3
-    * readarr *tmp37 .state2[] 3
-    * readarr *tmp39 .state1[] 3
+  184 set .state2*3 *tmp35
+  185 set *tmp37 .state2*3
+  186 set *tmp39 .state1*3
   187 jump *label91 greaterThanEq *tmp37 *tmp39
   188 op add .total .total 10
   189 label *label91

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-8 instructions):
 
    86 label *label60
    87 label *label61
    88 set *tmp20 .conv*0
-    * sensor *tmp21 *tmp20 @totalItems
-    * set .state1*0 *tmp21
+   89 sensor .state1*0 *tmp20 @totalItems
    90 set *tmp23 .state1*0
    91 set *tmp25 .state2*0
    92 jump *label62 greaterThanEq *tmp23 *tmp25
 
    96 label *label64
    97 label *label65
    98 set *tmp20 .conv*1
-    * sensor *tmp21 *tmp20 @totalItems
-    * set .state1*1 *tmp21
+   99 sensor .state1*1 *tmp20 @totalItems
   100 set *tmp23 .state1*1
   101 set *tmp25 .state2*1
   102 jump *label66 greaterThanEq *tmp23 *tmp25
 
   106 label *label68
   107 label *label69
   108 set *tmp20 .conv*2
-    * sensor *tmp21 *tmp20 @totalItems
-    * set .state1*2 *tmp21
+  109 sensor .state1*2 *tmp20 @totalItems
   110 set *tmp23 .state1*2
   111 set *tmp25 .state2*2
   112 jump *label70 greaterThanEq *tmp23 *tmp25
 
   116 label *label72
   117 label *label73
   118 set *tmp20 .conv*3
-    * sensor *tmp21 *tmp20 @totalItems
-    * set .state1*3 *tmp21
+  119 sensor .state1*3 *tmp20 @totalItems
   120 set *tmp23 .state1*3
   121 set *tmp25 .state2*3
   122 jump *label74 greaterThanEq *tmp23 *tmp25
 
   143 label *label77
   144 label *label78
   145 set *tmp34 .conv*0
-    * sensor *tmp35 *tmp34 @totalItems
-    * set .state2*0 *tmp35
+  146 sensor .state2*0 *tmp34 @totalItems
   147 set *tmp37 .state2*0
   148 set *tmp39 .state1*0
   149 jump *label79 greaterThanEq *tmp37 *tmp39
 
   153 label *label81
   154 label *label82
   155 set *tmp34 .conv*1
-    * sensor *tmp35 *tmp34 @totalItems
-    * set .state2*1 *tmp35
+  156 sensor .state2*1 *tmp34 @totalItems
   157 set *tmp37 .state2*1
   158 set *tmp39 .state1*1
   159 jump *label83 greaterThanEq *tmp37 *tmp39
 
   163 label *label85
   164 label *label86
   165 set *tmp34 .conv*2
-    * sensor *tmp35 *tmp34 @totalItems
-    * set .state2*2 *tmp35
+  166 sensor .state2*2 *tmp34 @totalItems
   167 set *tmp37 .state2*2
   168 set *tmp39 .state1*2
   169 jump *label87 greaterThanEq *tmp37 *tmp39
 
   173 label *label89
   174 label *label90
   175 set *tmp34 .conv*3
-    * sensor *tmp35 *tmp34 @totalItems
-    * set .state2*3 *tmp35
+  176 sensor .state2*3 *tmp34 @totalItems
   177 set *tmp37 .state2*3
   178 set *tmp39 .state1*3
   179 jump *label91 greaterThanEq *tmp37 *tmp39

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2:
 
    86 label *label60
    87 label *label61
    88 set *tmp20 .conv*0
-    * sensor .state1*0 *tmp20 @totalItems
+   89 sensor .state1*0 .conv*0 @totalItems
    90 set *tmp23 .state1*0
    91 set *tmp25 .state2*0
-    * jump *label62 greaterThanEq *tmp23 *tmp25
+   92 jump *label62 greaterThanEq .state1*0 .state2*0
    93 op add .total .total 10
    94 label *label62
    95 label *label63
    96 label *label64
    97 label *label65
    98 set *tmp20 .conv*1
-    * sensor .state1*1 *tmp20 @totalItems
+   99 sensor .state1*1 .conv*1 @totalItems
   100 set *tmp23 .state1*1
   101 set *tmp25 .state2*1
-    * jump *label66 greaterThanEq *tmp23 *tmp25
+  102 jump *label66 greaterThanEq .state1*1 .state2*1
   103 op add .total .total 10
   104 label *label66
   105 label *label67
   106 label *label68
   107 label *label69
   108 set *tmp20 .conv*2
-    * sensor .state1*2 *tmp20 @totalItems
+  109 sensor .state1*2 .conv*2 @totalItems
   110 set *tmp23 .state1*2
   111 set *tmp25 .state2*2
-    * jump *label70 greaterThanEq *tmp23 *tmp25
+  112 jump *label70 greaterThanEq .state1*2 .state2*2
   113 op add .total .total 10
   114 label *label70
   115 label *label71
   116 label *label72
   117 label *label73
   118 set *tmp20 .conv*3
-    * sensor .state1*3 *tmp20 @totalItems
+  119 sensor .state1*3 .conv*3 @totalItems
   120 set *tmp23 .state1*3
   121 set *tmp25 .state2*3
-    * jump *label74 greaterThanEq *tmp23 *tmp25
+  122 jump *label74 greaterThanEq .state1*3 .state2*3
   123 op add .total .total 10
   124 label *label74
   125 label *label75
 
   143 label *label77
   144 label *label78
   145 set *tmp34 .conv*0
-    * sensor .state2*0 *tmp34 @totalItems
+  146 sensor .state2*0 .conv*0 @totalItems
   147 set *tmp37 .state2*0
   148 set *tmp39 .state1*0
-    * jump *label79 greaterThanEq *tmp37 *tmp39
+  149 jump *label79 greaterThanEq .state2*0 .state1*0
   150 op add .total .total 10
   151 label *label79
   152 label *label80
   153 label *label81
   154 label *label82
   155 set *tmp34 .conv*1
-    * sensor .state2*1 *tmp34 @totalItems
+  156 sensor .state2*1 .conv*1 @totalItems
   157 set *tmp37 .state2*1
   158 set *tmp39 .state1*1
-    * jump *label83 greaterThanEq *tmp37 *tmp39
+  159 jump *label83 greaterThanEq .state2*1 .state1*1
   160 op add .total .total 10
   161 label *label83
   162 label *label84
   163 label *label85
   164 label *label86
   165 set *tmp34 .conv*2
-    * sensor .state2*2 *tmp34 @totalItems
+  166 sensor .state2*2 .conv*2 @totalItems
   167 set *tmp37 .state2*2
   168 set *tmp39 .state1*2
-    * jump *label87 greaterThanEq *tmp37 *tmp39
+  169 jump *label87 greaterThanEq .state2*2 .state1*2
   170 op add .total .total 10
   171 label *label87
   172 label *label88
   173 label *label89
   174 label *label90
   175 set *tmp34 .conv*3
-    * sensor .state2*3 *tmp34 @totalItems
+  176 sensor .state2*3 .conv*3 @totalItems
   177 set *tmp37 .state2*3
   178 set *tmp39 .state1*3
-    * jump *label91 greaterThanEq *tmp37 *tmp39
+  179 jump *label91 greaterThanEq .state2*3 .state1*3
   180 op add .total .total 10
   181 label *label91
   182 label *label92

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-24 instructions):
 
    85 set :start @time
    86 label *label60
    87 label *label61
-    * set *tmp20 .conv*0
    88 sensor .state1*0 .conv*0 @totalItems
-    * set *tmp23 .state1*0
-    * set *tmp25 .state2*0
    89 jump *label62 greaterThanEq .state1*0 .state2*0
    90 op add .total .total 10
    91 label *label62
    92 label *label63
    93 label *label64
    94 label *label65
-    * set *tmp20 .conv*1
    95 sensor .state1*1 .conv*1 @totalItems
-    * set *tmp23 .state1*1
-    * set *tmp25 .state2*1
    96 jump *label66 greaterThanEq .state1*1 .state2*1
    97 op add .total .total 10
    98 label *label66
    99 label *label67
   100 label *label68
   101 label *label69
-    * set *tmp20 .conv*2
   102 sensor .state1*2 .conv*2 @totalItems
-    * set *tmp23 .state1*2
-    * set *tmp25 .state2*2
   103 jump *label70 greaterThanEq .state1*2 .state2*2
   104 op add .total .total 10
   105 label *label70
   106 label *label71
   107 label *label72
   108 label *label73
-    * set *tmp20 .conv*3
   109 sensor .state1*3 .conv*3 @totalItems
-    * set *tmp23 .state1*3
-    * set *tmp25 .state2*3
   110 jump *label74 greaterThanEq .state1*3 .state2*3
   111 op add .total .total 10
   112 label *label74
 
   130 print "\n"
   131 label *label77
   132 label *label78
-    * set *tmp34 .conv*0
   133 sensor .state2*0 .conv*0 @totalItems
-    * set *tmp37 .state2*0
-    * set *tmp39 .state1*0
   134 jump *label79 greaterThanEq .state2*0 .state1*0
   135 op add .total .total 10
   136 label *label79
   137 label *label80
   138 label *label81
   139 label *label82
-    * set *tmp34 .conv*1
   140 sensor .state2*1 .conv*1 @totalItems
-    * set *tmp37 .state2*1
-    * set *tmp39 .state1*1
   141 jump *label83 greaterThanEq .state2*1 .state1*1
   142 op add .total .total 10
   143 label *label83
   144 label *label84
   145 label *label85
   146 label *label86
-    * set *tmp34 .conv*2
   147 sensor .state2*2 .conv*2 @totalItems
-    * set *tmp37 .state2*2
-    * set *tmp39 .state1*2
   148 jump *label87 greaterThanEq .state2*2 .state1*2
   149 op add .total .total 10
   150 label *label87
   151 label *label88
   152 label *label89
   153 label *label90
-    * set *tmp34 .conv*3
   154 sensor .state2*3 .conv*3 @totalItems
-    * set *tmp37 .state2*3
-    * set *tmp39 .state1*3
   155 jump *label91 greaterThanEq .state2*3 .state1*3
   156 op add .total .total 10
   157 label *label91

Modifications by Final phase, Jump Threading, iteration 1:
 
    50 print .found
    51 print ")"
    52 printflush message1
-    * jump *label20 always
+   53 jump *label1 always
    54 label *label19
    55 jump *label21 lessThanEq .found 4
    56 print "[gold]Item Counter Micro[], version [gold]1.0[]"
 
    62 print .found
    63 print ")"
    64 printflush message1
-    * jump *label22 always
+   65 jump *label1 always
    66 label *label21
-    * jump *label23 notEqual .memory null
+   67 jump *label3 notEqual .memory null
    68 print "$TITLE\n[salmon]No memory attached."
    69 printflush message1
-    * jump *label24 always
+   70 jump *label1 always
    71 label *label23
    72 jump *label3 always
    73 label *label24

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-2 instructions):
 
    68 print "$TITLE\n[salmon]No memory attached."
    69 printflush message1
    70 jump *label1 always
-    * label *label23
-    * jump *label3 always
-    * label *label24
-    * label *label22
-    * label *label20
-    * label *label2
-    * jump *label1 always
    71 label *label3
    72 label *label0
    73 control enabled switch1 false

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   169 label *label27
   170 set .total 0
   171 write 0 .memory 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-21 instructions):
 
    41 jump *label40 greaterThanEq :initialize.0:n 0
    42 label *label13
    43 jump *label19 notEqual .found 0
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print "\"
-    * print "n[salmon]No plastanium conveyor attached (maximum: "
-    * print 4
-    * print ","
-    * print " found: "
+   44 print "[gold]Item Counter Micro[], version [gold]1.0[]\n[salmon]No plastanium conveyor attached (maximum: 4, found: "
    45 print .found
    46 print ")"
    47 printflush message1
    48 jump *label1 always
    49 label *label19
    50 jump *label21 lessThanEq .found 4
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print "\"
-    * print "n[salmon]Too many plastanium conveyors attached (maximum: "
-    * print 4
-    * print ","
-    * print " found: "
+   51 print "[gold]Item Counter Micro[], version [gold]1.0[]\n[salmon]Too many plastanium conveyors attached (maximum: 4, found: "
    52 print .found
    53 print ")"
    54 printflush message1
 
    97 label *label76
    98 label *label30
    99 write .total .memory 0
-    * print "[gold]Item Counter Micro[], version [gold]1.0[]"
-    * print " "
-    * print "           "
-    * print "\n"
-    * print "Monitoring [green]"
+  100 print "[gold]Item Counter Micro[], version [gold]1.0[]            \nMonitoring [green]"
   101 print .found
-    * print "["
-    * print "] conveyors"
-    * print "\n"
-    * print "Total items: [gold]"
+  102 print "[] conveyors\nTotal items: [gold]"
   103 print .total
-    * print "["
-    * print "]"
-    * print "\n"
+  104 print "[]\n"
   105 label *label77
   106 label *label78
   107 sensor .state2*0 .conv*0 @totalItems
 
   136 op idiv *tmp45 *tmp43 2
   137 print "[lightgray]Loop time: "
   138 print *tmp45
-    * print " "
-    * print "ms"
-    * print "\n"
+  139 print " ms\n"
   140 printflush message1
   141 jump *label38 equal .links @links
   142 end

Final code before resolving virtual instructions:

    0:  read .total .memory 0                                        volatile total = memory[0];
        label *label1                                                while true do
    1:  set .conv*0 null                                             for var out c in conv do c = null; end;
    2:  set .conv*1 null                                             ...
    3:  set .conv*2 null                                             ...
    4:  set .conv*3 null                                             ...
    5:  set .memory null                                             memory = null;
    6:  set .found 0                                                 found = 0;
    7:  set .links @links                                            links = @links;
    8:  op sub :initialize.0:n .links 1                              for var n in 0 ... links descending do
    9:  jump *label13 lessThan :initialize.0:n 0                     ...
        label *label40                                               ...
   10:  getlink :initialize.0:block :initialize.0:n                  var block = getlink(n);
   11:  sensor *tmp5 :initialize.0:block @type                       case block.@type
   12:  jump *label16 equal *tmp5 @memory-cell                       ...
   13:  jump *label15 notEqual *tmp5 @memory-bank                    ...
        label *label16                                               ...
   14:  set .memory :initialize.0:block                              memory = block;
   15:  jump *label14 always 0 0                                     case block.@type
        label *label15                                               ...
   16:  jump *label17 notEqual *tmp5 @plastanium-conveyor            ...
   17:  set .conv*3 .conv*2                                          conv[1 ... MAX_LINKED] = conv[0 ... MAX_LINKED - 1];
   18:  set .conv*2 .conv*1                                          ...
   19:  set .conv*1 .conv*0                                          ...
   20:  set .conv*0 :initialize.0:block                              conv[0] = block;
   21:  op add .found .found 1                                       case block.@type
        label *label17                                               ...
        label *label14                                               ...
   22:  op sub :initialize.0:n :initialize.0:n 1                     for var n in 0 ... links descending do
   23:  jump *label40 greaterThanEq :initialize.0:n 0                ...
        label *label13                                               ...
   24:  jump *label19 notEqual .found 0                              if found == 0 then
   25:  print "[gold]Item Counter Micro[], version [gold]1.0[]\n[sal print($"$TITLE\n[salmon]No plastanium conveyor attached (maximum: $MAX_LINKED, found: $found)");
   26:  print .found                                                 ...
   27:  print ")"                                                    ...
   28:  printflush message1                                          printflush(message1);
   29:  jump *label1 always 0 0                                      if found == 0 then
        label *label19                                               ...
   30:  jump *label21 lessThanEq .found 4                            elsif found > MAX_LINKED then
   31:  print "[gold]Item Counter Micro[], version [gold]1.0[]\n[sal print($"$TITLE\n[salmon]Too many plastanium conveyors attached (maximum: $MAX_LINKED, found: $found)");
   32:  print .found                                                 ...
   33:  print ")"                                                    ...
   34:  printflush message1                                          printflush(message1);
   35:  jump *label1 always 0 0                                      elsif found > MAX_LINKED then
        label *label21                                               ...
   36:  jump *label3 notEqual .memory null                           elsif memory == null then
   37:  print "$TITLE\n[salmon]No memory attached."                  print("$TITLE\n[salmon]No memory attached.");
   38:  printflush message1                                          printflush(message1);
   39:  jump *label1 always 0 0                                      elsif memory == null then
        label *label3                                                while true do
   40:  control enabled switch1 false 0 0 0                          switch1.enabled = false;
   41:  sensor *tmp15 switch1 @enabled                               while !switch1.@enabled do
   42:  jump *label27 notEqual *tmp15 false                          ...
        label *label94                                               ...
   43:  set :start @time                                             var start = @time;
   44:  sensor .state1*0 .conv*0 @totalItems                         state1[i] = conv[i].@totalItems;
   45:  jump *label62 greaterThanEq .state1*0 .state2*0              if state1[i] < state2[i] then
   46:  op add .total .total 10                                      total += 10;
        label *label62                                               if state1[i] < state2[i] then
   47:  sensor .state1*1 .conv*1 @totalItems                         state1[i] = conv[i].@totalItems;
   48:  jump *label66 greaterThanEq .state1*1 .state2*1              if state1[i] < state2[i] then
   49:  op add .total .total 10                                      total += 10;
        label *label66                                               if state1[i] < state2[i] then
   50:  sensor .state1*2 .conv*2 @totalItems                         state1[i] = conv[i].@totalItems;
   51:  jump *label70 greaterThanEq .state1*2 .state2*2              if state1[i] < state2[i] then
   52:  op add .total .total 10                                      total += 10;
        label *label70                                               if state1[i] < state2[i] then
   53:  sensor .state1*3 .conv*3 @totalItems                         state1[i] = conv[i].@totalItems;
   54:  jump *label74 greaterThanEq .state1*3 .state2*3              if state1[i] < state2[i] then
   55:  op add .total .total 10                                      total += 10;
        label *label74                                               if state1[i] < state2[i] then
   56:  write .total .memory 0                                       memory[0] = total;
   57:  print "[gold]Item Counter Micro[], version [gold]1.0[]       println($"Monitoring [green]$found[] conveyors");
   58:  print .found                                                 ...
   59:  print "[] conveyors\nTotal items: [gold]"                    println($"Total items: [gold]$total[]");
   60:  print .total                                                 ...
   61:  print "[]\n"                                                 ...
   62:  sensor .state2*0 .conv*0 @totalItems                         state2[i] = conv[i].@totalItems;
   63:  jump *label79 greaterThanEq .state2*0 .state1*0              if state2[i] < state1[i] then
   64:  op add .total .total 10                                      total += 10;
        label *label79                                               if state2[i] < state1[i] then
   65:  sensor .state2*1 .conv*1 @totalItems                         state2[i] = conv[i].@totalItems;
   66:  jump *label83 greaterThanEq .state2*1 .state1*1              if state2[i] < state1[i] then
   67:  op add .total .total 10                                      total += 10;
        label *label83                                               if state2[i] < state1[i] then
   68:  sensor .state2*2 .conv*2 @totalItems                         state2[i] = conv[i].@totalItems;
   69:  jump *label87 greaterThanEq .state2*2 .state1*2              if state2[i] < state1[i] then
   70:  op add .total .total 10                                      total += 10;
        label *label87                                               if state2[i] < state1[i] then
   71:  sensor .state2*3 .conv*3 @totalItems                         state2[i] = conv[i].@totalItems;
   72:  jump *label91 greaterThanEq .state2*3 .state1*3              if state2[i] < state1[i] then
   73:  op add .total .total 10                                      total += 10;
        label *label91                                               if state2[i] < state1[i] then
   74:  op sub *tmp43 @time :start                                   println($"[lightgray]Loop time: $ ms", floor((@time - start) / 2));
   75:  op idiv *tmp45 *tmp43 2                                      ...
   76:  print "[lightgray]Loop time: "                               ...
   77:  print *tmp45                                                 ...
   78:  print " ms\n"                                                ...
   79:  printflush message1                                          printflush(message1);
   80:  jump *label38 equal .links @links                            if links != @links then
   81:  end                                                          end();
        label *label38                                               if links != @links then
   82:  sensor *tmp15 switch1 @enabled                               while !switch1.@enabled do
   83:  jump *label94 equal *tmp15 false                             ...
        label *label27                                               ...
   84:  set .total 0                                                 total = 0;
   85:  write 0 .memory 0                                            memory[0] = 0;


Performance: parsed in 177 ms, compiled in 220 ms, optimized in 235 ms, run in 6 ms.

Compiled mlog code was sent to Mlog Watcher.
  No response from Mlog Watcher - maybe an old version is installed?

Program output (1 steps):
The program didn't generate any output.
Execution exception at instruction 0: read .total .memory 0:
Variable '.memory' is not an object.
(Use the '#set err-not-an-object = false;' directive or the '--err-not-an-object false' command line option to ignore this exception.)
